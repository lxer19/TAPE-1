URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1993/GIT-CC-93-05.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.93.html
Root-URL: 
Email: (bodhi@cc.gatech.edu)  (schwan@cc.gatech.edu)  
Title: Experiments with Configurable Locks for Multiprocessors  
Author: Bodhisattwa Mukherjee Karsten Schwan 
Address: Atlanta, Georgia 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Date: 10 January 1993  
Pubnum: GIT-CC-93/05  
Abstract: Operating system kernels typically offer a fixed set of mechanisms and primitives. However, recent research shows that the attainment of high performance for a variety of parallel applications may require the availability of variants of existing primitives or additional low-level mechanisms. One approach to solve this problem is to offer a lightweight, reconfigurable and extensible operating system kernel. An application may configure it to suit its needs, including the selection of appropriate low-level policies, the construction of new primitives on top of the existing ones or the extension with additional primitives. In this paper, we investigate kernel configurability and extensibility for a specific class of operating system primitives: those used for task or thread synchronization. We present an implementation of multiprocessor locks that can be reconfigured statically and dynamically. In addition, we develop a representation for the lock abstraction and an associated reconfiguration mechanism that may be used for the development of other configurable and extensible operating system abstractions. 
Abstract-found: 1
Intro-found: 1
Reference: [ALL89] <author> Thomas E. Anderson, Edward D. Lazowska, and Henry M. Levy. </author> <title> The performance implications of thread management alternatives for shared-memory multiprocessors. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 38(12) </volume> <pages> 1631-1644, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Although the figure demonstrates a small performance advantage in favor of distributed locks, we hypothesize that 18 improvement will be more when the number of processors are large. Similar results have already been shown by others <ref> [ALL89] </ref>, hence they are not included in this paper. The final experiment compares two alternative lock implementations passive and active locks. Passive Vs. Active locks: If a lock object has a permanent thread bound to it, we refer to it as an active lock. <p> The family is customizable in which existing kernel abstractions and functions can be modified easily. As opposed to CHAOS objects, a reconfigurable lock contains its own mutable attributes and an internal configuration policy to guide any reconfiguration operation. There has been a lot of work on multiprocessor synchronization. In <ref> [ALL89] </ref>, Anderson et al. compare the performance of a number of software spin-waiting algorithms. They propose a few efficient spin-waiting algorithms such as Ethernet style backoff algorithm (introducing delay between successive spins analogous to Ethernet's backoff or Aloha), software queueing of spinning processors etc.
Reference: [Bla90a] <author> D. Black. </author> <title> Scheduling support for concurrency and parallelism in the mach operating systems. </title> <journal> IEEE Computer Magazine, </journal> <volume> 23(5) </volume> <pages> 35-43, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: The release module's selection (scheduling) policy may consist of a simple access to a thread-id noting the next thread to be executed (as in handoff scheduling <ref> [Bla90a] </ref>) or it may execute more complex scheduling strategies. The reconfigurable lock object also contains a monitor module which senses or probes user-defined parameters. This module implements a user-controlled lightweight thread monitoring system.
Reference: [Bla90b] <author> David. L. Black. </author> <title> Scheduling and Resource Management Techniques for Multiprocessors. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> July </month> <year> 1990. </year> <note> Techreport CMU-CS-90-152. </note>
Reference-contexts: An attempt to re-acquire the same lock is easily detected because a lock object knows the identity of its owner. Recursive locks are more expensive than the normal locks because each requesting 1 recursive locks are implemented in MACH <ref> [Bla90b] </ref> kernel to eliminate the lock-reentrancy problem. 19 thread performs an extra memory write at registration time. Simple conditional locks result when the timeout parameter is set accordingly.
Reference: [BLL88] <author> B. Bershad, E. Lazowska, and H. Levy. </author> <title> Presto: A system for object-oriented parallel programming. </title> <journal> Software: Practice and Experience, </journal> <volume> 18(8) </volume> <pages> 713-732, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Simple conditional locks result when the timeout parameter is set accordingly. A thread waiting for such a lock returns unsuccessfully if it cannot acquire the lock in a specified time. 5 Related Research Some of the notions introduced in PRESTO <ref> [BLLW88, BLL88] </ref>, CHOICES [CJR87] and CHAOS [GS89a, GS93, GS89b, SGZ90b, SGZ90a] are somewhat similar to this work. PRESTO supports two kinds of synchronization primitives: spinlocks and synchronization objects.
Reference: [BLLW88] <author> B. Bershad, E. Lazowska, H. Levy, and D. Wagner. </author> <title> An open environment for building parallel programming systems. </title> <booktitle> In Symposium on Parallel Programming: Experience with Applications, Languages and Systems, </booktitle> <pages> pages 1-9, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Simple conditional locks result when the timeout parameter is set accordingly. A thread waiting for such a lock returns unsuccessfully if it cannot acquire the lock in a specified time. 5 Related Research Some of the notions introduced in PRESTO <ref> [BLLW88, BLL88] </ref>, CHOICES [CJR87] and CHAOS [GS89a, GS93, GS89b, SGZ90b, SGZ90a] are somewhat similar to this work. PRESTO supports two kinds of synchronization primitives: spinlocks and synchronization objects.
Reference: [BS91a] <author> T. Bihari and K. Schwan. </author> <title> Dynamic adaptation of real-time software. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 143-174, </pages> <month> May </month> <year> 1991. </year>
Reference: [BS91b] <author> T. Bihari and K. Schwan. </author> <title> Dynamic adaptation of real-time software for reliable performance. </title> <journal> ACM Transactions on Computer Systems, </journal> <month> May </month> <year> 1991. </year>
Reference: [CCLP83] <author> G. Cox, M. Corwin, K. Lai, and F. Pollack. </author> <title> Interprocess communication and processor dispatching on the intel 432. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 1(1) </volume> <pages> 45-66, </pages> <month> February </month> <year> 1983. </year>
Reference: [CJR87] <author> R. Campbell, G. Johnston, and V. Russo. </author> <title> Choices (class hierarchical open interface for custom embedded systems). </title> <journal> Operating Systems Review, </journal> <volume> 21(3) </volume> <pages> 9-17, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Simple conditional locks result when the timeout parameter is set accordingly. A thread waiting for such a lock returns unsuccessfully if it cannot acquire the lock in a specified time. 5 Related Research Some of the notions introduced in PRESTO [BLLW88, BLL88], CHOICES <ref> [CJR87] </ref> and CHAOS [GS89a, GS93, GS89b, SGZ90b, SGZ90a] are somewhat similar to this work. PRESTO supports two kinds of synchronization primitives: spinlocks and synchronization objects.
Reference: [GS89a] <author> Ahmed Gheith and Karsten Schwan. Chaosart: </author> <title> A predictable real-time kernel. In Butterfly Users Group Meeting, BBN Advanced Computers INc., </title> <address> Rochester, NY, </address> <month> April </month> <year> 1989. </year> <note> Talk abstracts do not appear in proceedings. </note>
Reference-contexts: Simple conditional locks result when the timeout parameter is set accordingly. A thread waiting for such a lock returns unsuccessfully if it cannot acquire the lock in a specified time. 5 Related Research Some of the notions introduced in PRESTO [BLLW88, BLL88], CHOICES [CJR87] and CHAOS <ref> [GS89a, GS93, GS89b, SGZ90b, SGZ90a] </ref> are somewhat similar to this work. PRESTO supports two kinds of synchronization primitives: spinlocks and synchronization objects.
Reference: [GS89b] <author> Prabha Gopinath and Karsten Schwan. </author> <title> Chaos: Why one cannot have only an operating system for real-time applications. </title> <journal> SIGOPS Notices, </journal> <pages> pages 106-125, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Simple conditional locks result when the timeout parameter is set accordingly. A thread waiting for such a lock returns unsuccessfully if it cannot acquire the lock in a specified time. 5 Related Research Some of the notions introduced in PRESTO [BLLW88, BLL88], CHOICES [CJR87] and CHAOS <ref> [GS89a, GS93, GS89b, SGZ90b, SGZ90a] </ref> are somewhat similar to this work. PRESTO supports two kinds of synchronization primitives: spinlocks and synchronization objects.
Reference: [GS92] <author> Weiming Gu and Karsten Schwan. </author> <title> A monitoring and visualization system for parallel and distributed systems. </title> <type> Technical Report Draft, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: The resident policy which is responsible for the lock reconfiguration is called as the lock adaptation policy. Such adaptation policy depends on the locking pattern. Implementations of thread monitoring system <ref> [GS92] </ref> and adaptable locks [MS93] are described elsewhere. 4 Performance Evaluation 4.1 Formal Characterization Let V i be a state variable with value v i in domain D i (v i 2 D i ). Let SV be the set of variables that constitute the state of an object.
Reference: [GS93] <author> Ahmed Gheith and Karsten Schwan. </author> <title> Chaos-arc kernel support for multi-weight objects, invocations, and atomicity in real-time applications. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(1) </volume> <pages> 33-72, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Simple conditional locks result when the timeout parameter is set accordingly. A thread waiting for such a lock returns unsuccessfully if it cannot acquire the lock in a specified time. 5 Related Research Some of the notions introduced in PRESTO [BLLW88, BLL88], CHOICES [CJR87] and CHAOS <ref> [GS89a, GS93, GS89b, SGZ90b, SGZ90a] </ref> are somewhat similar to this work. PRESTO supports two kinds of synchronization primitives: spinlocks and synchronization objects.
Reference: [HA90] <author> Phil W. Hutto and Mustaque Ahamad. </author> <title> Slow memory: Weakening consistency to enhance concurrency in distrbuted shared memories. </title> <booktitle> In Proceedings of the International Conference on Distributed Computing Systems, </booktitle> <pages> pages 302-311, </pages> <year> 1990. </year>
Reference: [IFKR92] <author> H. Burkhardt III, S. Frank, B. Knobe, and J. Rothnie. </author> <title> Overview of the ksr1 computer system. </title> <type> Technical Report KSR-TR-9202001, </type> <institution> Kendall Square Research, </institution> <address> Boston, </address> <month> February </month> <year> 1992. </year>
Reference: [Jon79] <author> A.K. Jones. </author> <title> The object model: A conceptual tool for structuring software. </title> <booktitle> In Operating Systems AnAdvanced Course, </booktitle> <pages> pages 7-16. </pages> <publisher> Springer Verlag, New York, </publisher> <editor> Editors R. Bayer, R.M. Graham and G. Seegmueller, </editor> <year> 1979. </year>
Reference: [JS80] <author> Anita K. Jones and Peter Schwarz. </author> <title> Experience using multiprocessor systems: A status report. </title> <journal> Surveys of the Assoc. Comput. Mach., </journal> <volume> 12(2) </volume> <pages> 121-166, </pages> <month> June </month> <year> 1980. </year>
Reference: [LCC + 75] <author> R. Levin, E. Cohen, W. Corwin, F. Pollack, and W. Wulf. </author> <title> Policy/mechanism separation in hydra. </title> <booktitle> In Proceedings of the 5th Symposium on Operating System Principles, </booktitle> <address> Austin, Texas. </address> <publisher> Assoc. Comput. Mach., SigOps, </publisher> <month> Nov. </month> <year> 1975. </year>
Reference: [Mar91] <author> E. P. Markatos. </author> <title> Multiprocessor synchronization primitives with priorities. </title> <booktitle> In Eighth IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 1-7, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: FCFS and Priority lock: While FCFS lock scheduling is most common in multiprocessor lock implementations, non-preemptive-priority locks can be used in applications exhibiting specific locking patterns for improved application performance. Use of priority locks has been widely discussed in the real-time domain <ref> [Mar91] </ref>. Such locks can also be useful in client-server models of computation.
Reference: [MCS91] <author> J. Mellor-Crummey and M. Scott. </author> <title> Algorithms for scalable synchronization on shared-memory multiprocessors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9, </volume> <year> 1991. </year>
Reference-contexts: They propose a few efficient spin-waiting algorithms such as Ethernet style backoff algorithm (introducing delay between successive spins analogous to Ethernet's backoff or Aloha), software queueing of spinning processors etc. We have built similar backoff spin locks as different configurations of the reconfigurable lock. In <ref> [MCS91] </ref>, Mellor-Crummey et al. propose a new scalable algorithm (a list-based queuing lock, also known as MCS lock) which generates O (1) remote references per lock acquisition, independent of the number of processors attempting to acquire the lock.
Reference: [MS93] <author> Bodhisattwa Mukherjee and Karsten Schwan. </author> <title> Improving performance by use of adaptive objects: Experimentation with a configurable multiprocessor thread package. </title> <type> Technical Report GIT-CC-93/17, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: The resident policy which is responsible for the lock reconfiguration is called as the lock adaptation policy. Such adaptation policy depends on the locking pattern. Implementations of thread monitoring system [GS92] and adaptable locks <ref> [MS93] </ref> are described elsewhere. 4 Performance Evaluation 4.1 Formal Characterization Let V i be a state variable with value v i in domain D i (v i 2 D i ). Let SV be the set of variables that constitute the state of an object.
Reference: [Muk91] <author> Bodhisattwa Mukherjee. </author> <title> A portable and reconfigurable threads package. </title> <booktitle> In Proceedings of Sun User Group Technical Conference, </booktitle> <pages> pages 101-112, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The following measurements are taken on a 32-node BBN Butterfly GP1000 NUMA multiprocessor using a multiprocessor version of Cthreads as the basis <ref> [Muk91, SFG + 91] </ref>. Table 2 lists the latencies of the lock operations for different lock implementations available on the BBN multiprocessor (provided by the hardware, operating system and the Cthreads library).
Reference: [SB90] <author> Karsten Schwan and Win Bo. </author> <title> Topologies distributed objects on multicomputers. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(2) </volume> <pages> 111-157, </pages> <month> May </month> <year> 1990. </year>
Reference: [SBW91] <author> J. Saltz, H. Berryman, and J. Wu. </author> <title> Runtime compilation for multiprocessors. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 3(6), </volume> <year> 1991. </year>
Reference: [Sch80] <author> J.T. Schwarz. </author> <title> Ultracomputers. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(4) </volume> <pages> 484-543, </pages> <month> Oct. </month> <year> 1980. </year> <month> 22 </month>
Reference: [SFG + 91] <author> Karsten Schwan, Harold Forbes, Ahmed Gheith, Bodhisattwa Mukherjee, and Yiannis Samio--takis. </author> <title> A cthread library for multiprocessors. </title> <type> Technical Report GIT-ICS-91/02, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <year> 1991. </year>
Reference-contexts: The following measurements are taken on a 32-node BBN Butterfly GP1000 NUMA multiprocessor using a multiprocessor version of Cthreads as the basis <ref> [Muk91, SFG + 91] </ref>. Table 2 lists the latencies of the lock operations for different lock implementations available on the BBN multiprocessor (provided by the hardware, operating system and the Cthreads library).
Reference: [SGB87] <author> Karsten Schwan, Prabha Gopinath, </author> <title> and Win Bo. Chaos kernel support for objects in the real-time domain. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(8):904-916, </volume> <month> July </month> <year> 1987. </year>
Reference: [SGZ90a] <author> K. Schwan, A. Gheith, and H. Zhou. Chaos-arc: </author> <title> A kernel for predictable programs in dynamic real-time systems. </title> <booktitle> In Seventh IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <institution> Univ. of Virginia, </institution> <address> Charlottesville, </address> <pages> pages 11-19, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Simple conditional locks result when the timeout parameter is set accordingly. A thread waiting for such a lock returns unsuccessfully if it cannot acquire the lock in a specified time. 5 Related Research Some of the notions introduced in PRESTO [BLLW88, BLL88], CHOICES [CJR87] and CHAOS <ref> [GS89a, GS93, GS89b, SGZ90b, SGZ90a] </ref> are somewhat similar to this work. PRESTO supports two kinds of synchronization primitives: spinlocks and synchronization objects.
Reference: [SGZ90b] <author> Karsten Schwan, Ahmed Gheith, and Hongyi Zhou. </author> <title> From chaos-min to chaos-arc: A family of real-time multiprocessor kernels. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <address> Orlando, Florida, </address> <pages> pages 82-92. </pages> <publisher> IEEE, </publisher> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Simple conditional locks result when the timeout parameter is set accordingly. A thread waiting for such a lock returns unsuccessfully if it cannot acquire the lock in a specified time. 5 Related Research Some of the notions introduced in PRESTO [BLLW88, BLL88], CHOICES [CJR87] and CHAOS <ref> [GS89a, GS93, GS89b, SGZ90b, SGZ90a] </ref> are somewhat similar to this work. PRESTO supports two kinds of synchronization primitives: spinlocks and synchronization objects.
Reference: [SJG92] <author> P. Stenstrom, T. Joe, and A. Gupta. </author> <title> Comparative performance evaluation of cache-coherent numa and coma architectures. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 80-91, </pages> <month> May 19-21 </month> <year> 1992. </year>
Reference: [SRVO88] <author> Karsten Schwan, Rajiv Ramnath, Sridhar Vasudevan, and Dave Ogle. </author> <title> A language and system for parallel programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(4) </volume> <pages> 455-471, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: its scheduling policy) is permanently mutable because it may be changed at any time, but its scheduling policy is likely to be immutable whenever threads are waiting on the lock due to the inordinate potential expenses involved with the reorganization of internal lock data structures such as thread waiting queues <ref> [SRVO88] </ref>. Since object mutability is subject to change over time, the implementation of a reconfigurable lock object presented below possesses an internal policy controlling the object's reconfiguration. This policy makes use of object state describing its ownership by invokers.
Reference: [WLH81] <author> William A. Wulf, Roy Levin, and Samuel R. Harbison. Hydra/C.mmp: </author> <title> An Experimental Computer System. </title> <booktitle> McGraw-Hill Advanced Computer Science Series, </booktitle> <year> 1981. </year>
Reference: [ZSG92] <author> Hongyi Zhou, Karsten Schwan, and Ahmed Gheith. </author> <title> Dynamic synchronization of real-time threads for multiprocessor systems. </title> <booktitle> In Proceedings of the 3rd Symposium on Experiences with Distributed and Multiprocessor Systems, </booktitle> <month> March </month> <year> 1992. </year> <month> 23 </month>
Reference-contexts: At this time, attribute information like thread-id, priorities, ownership, etc. is processed by the lock's policy. The overhead of policy execution depends on the number of attributes processed and the complexity of the processing being performed (e.g., a somewhat complex lock scheduling algorithm is described in <ref> [ZSG92] </ref> for real-time locks). The registration overhead in the configurable lock implementation is the cost of one write operation on primary memory 2 .
References-found: 33

