URL: ftp://ftp.csd.uu.se/pub/papers/reports/0117.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: e-mail: Johan.Bevemyr@csd.uu.se  
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: Generational Parallel Copying Garbage Collector for Shared Memory Prolog  
Author: Johan Bevemyr 
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Computing Science Dept., Uppsala University  
Note: A  
Abstract: UPMAIL Technical Report No. 117 November 16, 1995 ISSN 1100-0686 Abstract We show how to combine a sequential copying garbage collector for Prolog with a scheme for parallel shared memory copying collection, and how to extend these schemes for generational garbage collection. We also present a new approach to dealing with troublesome primitives. The new garbage collector shows reasonable speedup for a number of benchmarks.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Ali, </author> <title> A Parallel Copying Garbage Collection Scheme for Shared-memory Multiprocessors, </title> <note> to appear in Special Issue on ICOT/NSF Workshop New Generation Computing, </note> <year> 1995. </year>
Reference-contexts: It has been shown how a generational copying garbage collector can be used for sequential Prolog [6]. It has also been shown how to parallelise copying garbage collection for shared memory multiprocessors <ref> [1] </ref>. We present a collection scheme that combines these techniques resulting in a parallel generational copying garbage collector for Prolog. <p> This results in a runtime cost for using generational garbage collection. In WAM based Prologs this overhead is already present in the form of trail tests and there is no extra runtime penalty for using generational collection. 3 Parallel Garbage Collection Khayri Ali <ref> [1] </ref> has proposed an elegant scheme for parallelising copying garbage collection on shared memory multiprocessors. His method assumes that memory is divided into segments where all segments are readable by all processing elements 5 processing elements allocate segments from the pool depending on their individual requirements. (PEs).
Reference: [2] <author> K. Appleby, M. Carlsson, S. Haridi, and D. Sahlin, </author> <title> Garbage Collection for Prolog Based on WAM, </title> <journal> Communications of the ACM, </journal> <volume> 31(6) </volume> <pages> 719-741, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: When two variables are unified, a pointer from one cell to the other cell is created. In general, pointer chains may arise which require dereferencing. 2 Sequential Copying Garbage Collection Traditionally, Prolog garbage collectors are based on a mark-slide algorithm <ref> [2] </ref>. The reason is that Prolog implementations tend to rely on that live data maintains their relative positions throughout the execution. This is important for the following reasons: 1. The location of a variable is used for deciding if trailing is required when binding the variable. 2. <p> Old choice points can be detected by marking them during garbage collection. A spare bit in the trail top pointer can be used for this purpose (this is what the mark-sweep collector in SICStus Prolog <ref> [2] </ref> does). Environments. Environments can be divided into three categories. 1. New environments, i.e., environments created after the last collection. 2. Old unprotected environments, i.e., environments created before the last col lection which are not protected by a surviving choice point. 3.
Reference: [3] <author> A.W. Appel, </author> <title> Simple generational garbage collection and fast allocation, </title> <editor> Software|Practice and Experience,19(2):171-183, </editor> <year> 1989. </year>
Reference-contexts: Implementing early reset is done by incorporating this step into the procedure that copies live data from the chain of choice points. 2.4 Generational Collection Generational garbage collection <ref> [11, 3] </ref> relies on the observation that newly created objects tend to be short-lived. Thus, garbage collection should concentrate on recently created data. The heap is split into two or more generations, and the most recent generation is collected most frequently.
Reference: [4] <author> Y. Bekkers, O. Ridoux and L. Ungaro, </author> <title> Dynamic Memory Management for Sequential Logic Programming Languages, </title> <booktitle> Proceedings of the International Workshop on Memory Management 92, </booktitle> <volume> LNCS 637 </volume> <pages> 82-102, </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: An improved method for dealing with the problem of comparison operators is presented below. 2.1 Instant Reclaiming A compacting collector preserves the heap segments (see Figure 1) and entire segments can be deallocated on backtracking. Bekkers, Ridoux and Ungaro <ref> [4] </ref> suggested that a reasonable approximation of the heap segments can be preserved across garbage collections. This is achieved by copying the data in a carefully chosen order, i.e., starting at the oldest choice point. This is not possible in a parallel setting without strict synchronisation, as explained below.
Reference: [5] <author> J. Bevemyr, </author> <title> A Recursion-Parallel Prolog Engine, </title> <type> PhL Thesis, </type> <institution> Computing Science Department, Uppsala University, </institution> <year> 1993. </year>
Reference-contexts: This problem occurs as soon as several heaps are used. One solution is to associate a choice point identifier with each variable. Different methods for this have been investigated by Bevemyr <ref> [5] </ref>. 4.2 Modifications to the Sequential Algorithm The sequential algorithm has to be modified in the following ways to run in parallel: 1. The algorithm for marking live data cannot use pointer reversal.
Reference: [6] <author> J. Bevemyr and T. Lindgren, </author> <title> A Simple and Efficient Copying Garbage Collector for Prolog, </title> <booktitle> Proceedings of Programming Language Implementation and Logic Programming, </booktitle> <volume> LNCS 844 </volume> <pages> 88-101, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Otherwise the garbage collector will become a sequential bottleneck. If the collection time is 15% of the sequential execution time, then that limits the speedup to 1=0:15 = 6:67. It has been shown how a generational copying garbage collector can be used for sequential Prolog <ref> [6] </ref>. It has also been shown how to parallelise copying garbage collection for shared memory multiprocessors [1]. We present a collection scheme that combines these techniques resulting in a parallel generational copying garbage collector for Prolog. <p> This is achieved by copying the data in a carefully chosen order, i.e., starting at the oldest choice point. This is not possible in a parallel setting without strict synchronisation, as explained below. Bevemyr and Lindgren <ref> [6] </ref> indicated that instant reclaiming of data that have survived a garbage collection can be sacrificed without loss of efficiency, at least for a range of benchmarks. Using their scheme, instant reclaiming of data is still possible for data allocated between collections. <p> All heap segments are merged into one during garbage collection (see Figure 2). 2.2 Trailing The variables' positions relative to the heap segments are used for deciding if a variable binding needs to be trailed or not. Bevemyr and Lindgren <ref> [6] </ref> solve this by trailing all bindings of variables that have survived a garbage collection, i.e., all variables residing in the collapsed segments. 2 garbage collection. Heap segments are preserved. 2.3 Bevemyr-Lindgren's Mark-Copy Algorithm The copying collector is a straightforward adaption of Cheney's algorithm [9] and works in three phases. <p> A slight complication appears in Prolog-implementations since they tend to allow external references into structures, e.g., to variables inside structures. These externally referenced cells can be reached and copied before the surrounding structure, resulting in duplicated memory for a single variable <ref> [6] </ref> (see Figure 3 and 4). This is undesirable since the result of doing garbage collection might then be that more space is required! Furthermore, the length of reference chains are no longer predictable. A solution to this problem is to mark all internal cells before copying. <p> The old generation. The traditional solution is to use a write barrier to detect cross generational pointers as they are created, and record them for use in the gc. The write barrier is implemented by adding detection code for each potential cross generational assignment. Bevemyr and Lindgren <ref> [6] </ref> observe that this code is already present in Prolog in the form of trail tests. All cross generational bindings can be automatically recorded by carefully setting the trail condition. This results in some extra trailing. 15 The trail.
Reference: [7] <author> J. Bevemyr, T. Lindgren & H. Millroth, </author> <title> Exploiting recursion-parallelism in Prolog, </title> <booktitle> Int. Conf. </booktitle> <editor> PARLE-93 (eds. A. Bode, M. Reeve & G. Wolf), </editor> <publisher> Springer LNCS 694 </publisher> <pages> 279-290, </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Each worker is a full WAM with all associated memory areas. All workers have shared access to each others heaps with the restriction that they can only create new objects on their own heap. Reform Prolog <ref> [7, 8] </ref> is an example of this kind of implementation. 4.1 Segmented Memory To use Ali's scheme the heaps have to be divided into segments. This is desirable for other reasons as well. <p> However, streamlining the implementation may change this. The load balancing algorithm does not work satisfactory for long lists of ground elements. The reason is that the main work lies in the depth first traversal, and that part is not parallelised. In Reform Prolog <ref> [7, 8] </ref> long list are used for storing arguments to the parallel processes. The cons-cells of these lists are stored in consecutive memory cells which make it possible to treat these lists as vectors. It should be possible to exploit this structure for more efficient parallelisation of the garbage collector.
Reference: [8] <author> J. Bevemyr, T. Lindgren & H. Millroth, </author> <title> Reform Prolog: The language and its implementation, </title> <booktitle> Proc. 10th Int. Conf. Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Each worker is a full WAM with all associated memory areas. All workers have shared access to each others heaps with the restriction that they can only create new objects on their own heap. Reform Prolog <ref> [7, 8] </ref> is an example of this kind of implementation. 4.1 Segmented Memory To use Ali's scheme the heaps have to be divided into segments. This is desirable for other reasons as well. <p> However, streamlining the implementation may change this. The load balancing algorithm does not work satisfactory for long lists of ground elements. The reason is that the main work lies in the depth first traversal, and that part is not parallelised. In Reform Prolog <ref> [7, 8] </ref> long list are used for storing arguments to the parallel processes. The cons-cells of these lists are stored in consecutive memory cells which make it possible to treat these lists as vectors. It should be possible to exploit this structure for more efficient parallelisation of the garbage collector.
Reference: [9] <author> C.J. </author> <title> Cheney, A nonrecursive list compacting algorithm, </title> <journal> Communications of the ACM, </journal> <volume> 13(11) </volume> <pages> 677-678, </pages> <month> November </month> <year> 1970. </year>
Reference-contexts: Bevemyr and Lindgren [6] solve this by trailing all bindings of variables that have survived a garbage collection, i.e., all variables residing in the collapsed segments. 2 garbage collection. Heap segments are preserved. 2.3 Bevemyr-Lindgren's Mark-Copy Algorithm The copying collector is a straightforward adaption of Cheney's algorithm <ref> [9] </ref> and works in three phases. The algorithm allows the standard optimisations of early reset. The global stack is divided into two areas. The old data reside in from-space and are evacuated into to-space.
Reference: [10] <author> J. Cohen, </author> <title> Garbage Collection of Linked Data Structure, </title> <journal> Computing Surveys, </journal> <volume> 13(3) </volume> <pages> 341-367, </pages> <month> September </month> <year> 1981. </year>
Reference: [11] <author> H. Lieberman, C. Hewitt, </author> <title> A real-time garbage collector based on the lifetimes of objects, </title> <journal> Communications of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: Implementing early reset is done by incorporating this step into the procedure that copies live data from the chain of choice points. 2.4 Generational Collection Generational garbage collection <ref> [11, 3] </ref> relies on the observation that newly created objects tend to be short-lived. Thus, garbage collection should concentrate on recently created data. The heap is split into two or more generations, and the most recent generation is collected most frequently.
Reference: [12] <author> H. Schorr and W.M. Waite, </author> <title> An Efficient Machine-Independent Procedure for Garbage Collection in Various List Structures, </title> <journal> Communications of the ACM, </journal> <volume> 10(8) </volume> <pages> 501-506, </pages> <month> August </month> <year> 1967. </year>
Reference-contexts: A solution to this problem is to mark all internal cells before copying. When a marked cell is encountered during copying all surrounding cells are copied. Marking the internal cells is done using the Deutsch-Schorr-Waite <ref> [12] </ref> pointer reversal algorithm. Algorithm: 1. Mark the live data. When a structure is encountered, mark the functor cell and all internal cells. When a simple object is found, mark that cell only. 2. Copy the data using Cheney's breadth-first algorithm.
Reference: [13] <author> H. Touati, T. Hama, </author> <title> A light-weight prolog garbage collector, </title> <booktitle> Proceedings of the International Conference on Fifth Generation Computing Systems, </booktitle> <year> 1988. </year>
Reference: [14] <author> D.H.D. Warren, </author> <title> An Abstract Prolog Instruction Set, </title> <type> SRI Tech. Note 309, </type> <institution> SRI International, Menlo Park, Calif., USA, </institution> <year> 1983. </year> <month> 19 </month>
Reference-contexts: It has also been shown how to parallelise copying garbage collection for shared memory multiprocessors [1]. We present a collection scheme that combines these techniques resulting in a parallel generational copying garbage collector for Prolog. Let us consider the architecture of a typical WAM <ref> [14] </ref>: most data are stored on a global stack (also called the heap), while choice points and environments are stored on a local stack (also referred to as the stack). A trail stack records bindings to be undone on backtracking.
References-found: 14

