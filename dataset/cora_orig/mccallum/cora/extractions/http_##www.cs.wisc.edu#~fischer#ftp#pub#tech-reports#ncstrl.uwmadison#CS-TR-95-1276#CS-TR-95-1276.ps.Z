URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1276/CS-TR-95-1276.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1276/
Root-URL: http://www.cs.wisc.edu
Title: Solving Shape-Analysis Problems in Languages with Destructive Updating  
Author: Mooly Sagiv ; and Thomas Reps Reinhard Wilhelm 
Affiliation: University of Wisconsin  Universitat des Saarlandes  
Abstract: This paper concerns the static analysis of programs that perform destructive updating on heap-allocated storage. We give an algorithm that conservatively solves this problem by using finite shape-graphs to approximate the possible "shapes" that heap-allocated structures in a program can take on. In contrast with previous work, our method is even accurate for certain programs that update cyclic data structures. For certain programs | including ones in which a significant amount of destructive updating takes place | our technique is able to determine such properties as (i) when the input to the program is a list, the output is (still) a list; (ii) when the input to the program is a tree, the output is (still) a tree; and (iii) when the input to the program is a possibly circular list, the output is a possibly circular list. For example, our method can determine that "list-ness" is preserved by (i) a program that performs list reversal via destructive updating of the input list, and (ii) a program that searches a list and splices a new element into the list. Furthermore, our method can determine that "circular list-ness" is preserved by the program that searches a list and splices in a new element. None of the existing methods that use graphs to model the program's store are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity). As far as we know, no other existing alias-analysis/shape-analysis method (whether based on graphs or other principles) has the ability to determine that "circular list-ness" is preserved by the list-insert program.
Abstract-found: 1
Intro-found: 1
Reference: [AW93] <author> U. Assmann and M. Weinhardt. </author> <title> Interprocedural heap analysis for parallelizing imperative programs. </title> <type> Unpublished Manuscript, </type> <year> 1993. </year>
Reference-contexts: Jones and Muchnick [JM82], Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed above, both from a theoretical perspective [CWZ90] and from an implementation perspective <ref> [AW93] </ref>.
Reference: [CBC93] <author> J.-D. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side-effects. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <year> 1993. </year> <month> 34 </month>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction of approximation of fixed points. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: Proof: Immediate from Proposition 4.11 and Theorem A.1, using Theorem (T2) of <ref> [CC77, pp. 252] </ref>. 2 The core of the proof of Theorem 4.13, which involves showing that each semantic equation of the abstract semantics is conservative with respect to the corresponding equation of the concrete semantics, is given in Appendix A as Theorem A.1. 4.4 What the Analysis Algorithm Achieves and Why
Reference: [CWZ90] <author> D.R. Chase, M. Wegman, and F. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <year> 1990. </year>
Reference-contexts: Furthermore, our method can determine that the list-insert program also preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, JM82, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> The variable set of a shape-graph node in the shape-graph for program-point v consists of variables that, for some execution sequence ending at v, must all point to the same run-time location. Previous methods have used allocation sites to represent run-time locations 5 <ref> [JM82, CWZ90, PCK93] </ref>. Allocation-site information alone is insufficient to handle programs that perform significant destructive updating, such as the destructive list-reversal program, as noted by Chase, Wegman, and Zadeck [CWZ90]. * Like other shape-analysis methods, our method clusters collections of run-time locations into summary nodes. <p> Previous methods have used allocation sites to represent run-time locations 5 [JM82, CWZ90, PCK93]. Allocation-site information alone is insufficient to handle programs that perform significant destructive updating, such as the destructive list-reversal program, as noted by Chase, Wegman, and Zadeck <ref> [CWZ90] </ref>. * Like other shape-analysis methods, our method clusters collections of run-time locations into summary nodes. In our approach, nodes that are not pointed to by variables are clustered into a single node. <p> Chase, Wegman, and Zadeck observed that their analysis method cannot handle programs such as the list-reversal program because it lacks a way to materialize ("unsumma-rize") summary nodes at certain key points of the analysis <ref> [CWZ90, pp. 309] </ref>. <p> Previous methods either never remove these edges ([Str92]) or have some heuristics to remove such edges under certain conditions <ref> [JM81, LH88, CWZ90, PCK93] </ref>. (This unusual characteristic of our method is enabled by the materialization technique mentioned above.) * We use sharing information to increase the accuracy of the primitive operations used by our method. <p> The limited form of sharing information used in <ref> [JM81, CWZ90] </ref> does not allow these methods to determine this fact. * The shape-node names also provide information that sometimes permits our method to determine that a shared-node becomes unshared (e.g., this occurs in the list-insert program when the input is either an acyclic or possibly cyclic list). <p> work of putting a program into a form that meets these assumptions is carried out by a preprocessor.) Note that the number of temporary variables that must be introduced to meet these restrictions is at most linear in the size of the original program. 2 6 As others have done <ref> [JM81, LH88, CWZ90] </ref>, procedures (including recursive procedures) can be handled by conservatively treating calls and returns as jumps. 7 Throughout the paper, our presentation is couched in terms of the Lisp primitives for manipulating heap-allocated storage. <p> For doubly-linked lists is shared (n ) = true, but is shared car (n ) = false and is shared cdr (n ) = false. (See Figure 10.) We have added this extension to our shape-analysis implementation. A similar extension was mentioned in <ref> [CWZ90] </ref> but not worked out. 5.3 More Summary Shape-Nodes The major source of inaccuracy in our method is the fact the summary shape-node n may cluster unrelated run-time locations. This is particularly inaccurate when is shared (n ) = true. <p> This is particularly inaccurate when is shared (n ) = true. There are several ways to improve the accuracy by using more summary shape-nodes including: * Using allocation-sites to identify shape-nodes <ref> [JM82, CWZ90] </ref>. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck <ref> [CWZ90] </ref>, and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> The use of a single shape-graph is possibly less accurate than a method based on sets of graphs, but it leads to more compact representations, and thus is more likely to lead to a practical shape-analysis algorithm. Jones and Muchnick [JM82], Chase, Wegman, and Zadeck <ref> [CWZ90] </ref>, and Stransky [Str92] present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed above, both from a theoretical perspective [CWZ90] and from an implementation perspective [AW93]. <p> Jones and Muchnick [JM82], Chase, Wegman, and Zadeck <ref> [CWZ90] </ref>, and Stransky [Str92] present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed above, both from a theoretical perspective [CWZ90] and from an implementation perspective [AW93]. <p> The Chase-Wegman-Zadeck algorithm lacks a node-materialization operation (although they did recognize that the lack of one was a stumbling block to the accuracy of their method <ref> [CWZ90, pp. 309] </ref>). Chase, Wegman, and Zadeck use reference-count values 0, 1, and 1, whereas we use a Boolean-valued is shared value.
Reference: [Deu92] <author> A. Deutsch. </author> <title> A storeless model for aliasing and its abstractions using finite representations of right-regular equivalence relations. </title> <booktitle> In IEEE International Conference on Computer Languages, </booktitle> <pages> pages 2-13, </pages> <year> 1992. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program.
Reference: [Deu94] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In SIG-PLAN Conference on Programming Languages Design and Implementation, </booktitle> <year> 1994. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program. <p> There are also several algorithms for finding may aliases that are not based on shape-graphs. The most sophisticated ones are those of Landi and Ryder [LR91] and Deutsch <ref> [Deu94] </ref>. Deutsch's algorithm is particularly interesting because, for certain programs that manipulate lists, it offers a way of representing the exact (infinite set of) may aliases in a compact way.
Reference: [Hen90] <author> L. Hendren. </author> <title> Parallelizing Programs with Recursive Date Structures. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> Jan </month> <year> 1990. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program. <p> This kind of conservative approximation is appropriate for use, for example, in parallelizing compilers [HNH92, HG92]. 5 As explained in Section 5.3, this can be incorporated into our method as an "orthogonal dimension" of shape-graph node names, if desired. 2 and trees, the non-graph-based method of Hendren <ref> [Hen90] </ref> is sometimes able to determine that a shared-node becomes unshared. However, this method does not handle data structures that contain cycles. An experimental implementation of the analysis method has been created; the examples presented in the paper have been prepared with the aid of this implementation. <p> A different approach was taken by Hendren, who designed an algorithm that handles only acyclic data structures <ref> [HN90, Hen90] </ref>. Because of the choice to work with programs that only manipulate acyclic structures, the algorithm does not have to have a way of representing cycles conservatively. For this alias-analysis problem, she has given an efficient algorithm that manipulates matrices that record access paths that are aliased.
Reference: [HG92] <author> L. Hendren and G.R. Gao. </author> <title> Designing programming languages for analyzability: A fresh look at pointer data structures. </title> <booktitle> In Proceedings of the International Conference on Computer Languages, </booktitle> <pages> pages 242-251, </pages> <year> 1992. </year>
Reference-contexts: This kind of conservative approximation is appropriate for use, for example, in parallelizing compilers <ref> [HNH92, HG92] </ref>. 5 As explained in Section 5.3, this can be incorporated into our method as an "orthogonal dimension" of shape-graph node names, if desired. 2 and trees, the non-graph-based method of Hendren [Hen90] is sometimes able to determine that a shared-node becomes unshared.
Reference: [HN90] <author> L. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive date structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program. <p> A different approach was taken by Hendren, who designed an algorithm that handles only acyclic data structures <ref> [HN90, Hen90] </ref>. Because of the choice to work with programs that only manipulate acyclic structures, the algorithm does not have to have a way of representing cycles conservatively. For this alias-analysis problem, she has given an efficient algorithm that manipulates matrices that record access paths that are aliased.
Reference: [HNH92] <author> L. Hendren, A. Nicolau, and J. Hummel. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and the transformation of imperative programs. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 249-260, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: This kind of conservative approximation is appropriate for use, for example, in parallelizing compilers <ref> [HNH92, HG92] </ref>. 5 As explained in Section 5.3, this can be incorporated into our method as an "orthogonal dimension" of shape-graph node names, if desired. 2 and trees, the non-graph-based method of Hendren [Hen90] is sometimes able to determine that a shared-node becomes unshared.
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In SIG-PLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <year> 1989. </year>
Reference-contexts: In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., <ref> [HPR89] </ref>). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph.
Reference: [JM81] <editor> N.D. Jones and S.S Muchnick. </editor> <title> Flow analysis and optimization of Lisp-like structures. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 4, </volume> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Furthermore, our method can determine that the list-insert program also preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, JM82, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> Previous methods either never remove these edges ([Str92]) or have some heuristics to remove such edges under certain conditions <ref> [JM81, LH88, CWZ90, PCK93] </ref>. (This unusual characteristic of our method is enabled by the materialization technique mentioned above.) * We use sharing information to increase the accuracy of the primitive operations used by our method. <p> The limited form of sharing information used in <ref> [JM81, CWZ90] </ref> does not allow these methods to determine this fact. * The shape-node names also provide information that sometimes permits our method to determine that a shared-node becomes unshared (e.g., this occurs in the list-insert program when the input is either an acyclic or possibly cyclic list). <p> work of putting a program into a form that meets these assumptions is carried out by a preprocessor.) Note that the number of temporary variables that must be introduced to meet these restrictions is at most linear in the size of the original program. 2 6 As others have done <ref> [JM81, LH88, CWZ90] </ref>, procedures (including recursive procedures) can be handled by conservatively treating calls and returns as jumps. 7 Throughout the paper, our presentation is couched in terms of the Lisp primitives for manipulating heap-allocated storage. <p> to use this widening operator to guarantee that a fixed point of Equation (4) of Section 4.3 can be found in polynomial time; it simply has to be applied whenever necessary to limit the cardinality of shape-node name sets to some chosen constant. (This is similar in spirit to k-limiting <ref> [JM81] </ref>, but it is likely to produce much better results because limiting the cardinality of name sets still preserves most of the structural information about the graph.) 5.2 More Sharing Information For some data structures, it is possible to provide more accurate shape-analysis information by extending the SSG domain to include <p> A similar shape-analysis problem, but for an imperative language supporting non-destructive manipulation of heap-allocated objects, was formulated independently by Jones and Muchnick, who treated the problem as one of solving (i.e., finding the least fixed-point of) a collection of equations using regular tree grammars <ref> [JM81] </ref>. In that same paper, Jones and Muchnick also began the study of shape analysis for languages with destructive updating. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in <ref> [JM81] </ref>), our work follows Jones and Muchnick [JM82], Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> obtained by our algorithm: 12 In this section, we use the term "shape-graph" in the generic sense, meaning any finite graph structure used to approximate the shapes of run-time data structures. 13 The idea of augmenting shape-graphs with sharing information also appears in the earlier work of Jones and Muchnick <ref> [JM81] </ref>. 23 "Strong Nullification" For an assignment of the form x:sel 0 := y, the Chase-Wegman-Zadeck method ordinarily performs a "weak update" (i.e., selector-edges emanating from what x points to are accumulated ). It performs a strong update only under certain specialized conditions.
Reference: [JM82] <editor> N.D. Jones and S.S Muchnick. </editor> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <year> 1982. </year>
Reference-contexts: Furthermore, our method can determine that the list-insert program also preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, JM82, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> The variable set of a shape-graph node in the shape-graph for program-point v consists of variables that, for some execution sequence ending at v, must all point to the same run-time location. Previous methods have used allocation sites to represent run-time locations 5 <ref> [JM82, CWZ90, PCK93] </ref>. Allocation-site information alone is insufficient to handle programs that perform significant destructive updating, such as the destructive list-reversal program, as noted by Chase, Wegman, and Zadeck [CWZ90]. * Like other shape-analysis methods, our method clusters collections of run-time locations into summary nodes. <p> This is particularly inaccurate when is shared (n ) = true. There are several ways to improve the accuracy by using more summary shape-nodes including: * Using allocation-sites to identify shape-nodes <ref> [JM82, CWZ90] </ref>. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick <ref> [JM82] </ref>, Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> The use of a single shape-graph is possibly less accurate than a method based on sets of graphs, but it leads to more compact representations, and thus is more likely to lead to a practical shape-analysis algorithm. Jones and Muchnick <ref> [JM82] </ref>, Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed above, both from a theoretical perspective [CWZ90] and from an implementation perspective [AW93].
Reference: [Lar89] <author> J.R. Larus. </author> <title> Restructuring Symbolic Programs for Concurrent Execution on Multiprocessors. </title> <type> PhD thesis, </type> <institution> University of California, </institution> <year> 1989. </year>
Reference-contexts: In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger <ref> [LH88, Lar89] </ref>, Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> Plevyak, Chien, and Karamcheti describe a shape-analysis algorithm that is similar to this extension [PCK93]. Unfortunately, the Plevyak-Chien-Karamcheti algorithm inherits most of the drawbacks of the original Chase-Wegman-Zadeck algorithm. Larus and Hilfinger <ref> [LH88, Lar89] </ref> devised a shape-analysis algorithm that is based on somewhat different principles from the aforementioned work. As with our algorithm, shape-nodes are labeled with some auxiliary information.
Reference: [LH88] <author> J.R. Larus and P.N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <year> 1988. </year>
Reference-contexts: Furthermore, our method can determine that the list-insert program also preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, JM82, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> Previous methods either never remove these edges ([Str92]) or have some heuristics to remove such edges under certain conditions <ref> [JM81, LH88, CWZ90, PCK93] </ref>. (This unusual characteristic of our method is enabled by the materialization technique mentioned above.) * We use sharing information to increase the accuracy of the primitive operations used by our method. <p> work of putting a program into a form that meets these assumptions is carried out by a preprocessor.) Note that the number of temporary variables that must be introduced to meet these restrictions is at most linear in the size of the original program. 2 6 As others have done <ref> [JM81, LH88, CWZ90] </ref>, procedures (including recursive procedures) can be handled by conservatively treating calls and returns as jumps. 7 Throughout the paper, our presentation is couched in terms of the Lisp primitives for manipulating heap-allocated storage. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger <ref> [LH88, Lar89] </ref>, Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> Plevyak, Chien, and Karamcheti describe a shape-analysis algorithm that is similar to this extension [PCK93]. Unfortunately, the Plevyak-Chien-Karamcheti algorithm inherits most of the drawbacks of the original Chase-Wegman-Zadeck algorithm. Larus and Hilfinger <ref> [LH88, Lar89] </ref> devised a shape-analysis algorithm that is based on somewhat different principles from the aforementioned work. As with our algorithm, shape-nodes are labeled with some auxiliary information.
Reference: [LR91] <author> W. Landi and B.G. Ryder. </author> <title> Pointer induced aliasing: A problem classification. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <year> 1991. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program. <p> There are also several algorithms for finding may aliases that are not based on shape-graphs. The most sophisticated ones are those of Landi and Ryder <ref> [LR91] </ref> and Deutsch [Deu94]. Deutsch's algorithm is particularly interesting because, for certain programs that manipulate lists, it offers a way of representing the exact (infinite set of) may aliases in a compact way.
Reference: [PCK93] <author> J. Plevyak, A.A. Chien, and V. Karamcheti. </author> <title> Analysis of dynamic structures for efficient parallel execution. </title> <editor> In U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing, volume 768 of Lecture Notes in Computer Science, </booktitle> <pages> pages 37-57, </pages> <address> Portland, OR, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: Furthermore, our method can determine that the list-insert program also preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, JM82, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> The variable set of a shape-graph node in the shape-graph for program-point v consists of variables that, for some execution sequence ending at v, must all point to the same run-time location. Previous methods have used allocation sites to represent run-time locations 5 <ref> [JM82, CWZ90, PCK93] </ref>. Allocation-site information alone is insufficient to handle programs that perform significant destructive updating, such as the destructive list-reversal program, as noted by Chase, Wegman, and Zadeck [CWZ90]. * Like other shape-analysis methods, our method clusters collections of run-time locations into summary nodes. <p> Previous methods either never remove these edges ([Str92]) or have some heuristics to remove such edges under certain conditions <ref> [JM81, LH88, CWZ90, PCK93] </ref>. (This unusual characteristic of our method is enabled by the materialization technique mentioned above.) * We use sharing information to increase the accuracy of the primitive operations used by our method. <p> The idea discussed in Section 5.2 of using multiple items of sharing information for each shape node (i.e., separating car references from cdr references) was originally proposed by Chase, Wegman, and Zadeck. Plevyak, Chien, and Karamcheti describe a shape-analysis algorithm that is similar to this extension <ref> [PCK93] </ref>. Unfortunately, the Plevyak-Chien-Karamcheti algorithm inherits most of the drawbacks of the original Chase-Wegman-Zadeck algorithm. Larus and Hilfinger [LH88, Lar89] devised a shape-analysis algorithm that is based on somewhat different principles from the aforementioned work. As with our algorithm, shape-nodes are labeled with some auxiliary information.
Reference: [Rey68] <author> J.C. Reynolds. </author> <title> Automatic computation of data set definitions. </title> <booktitle> In Information Processing 68: Proceedings of the IFIP Congress, </booktitle> <pages> pages 456-461, </pages> <address> New York, NY, 1968. </address> <publisher> North-Holland. </publisher>
Reference-contexts: The shape-analysis problem was originally investigated by Reynolds for a Lisp-like language with no destructive updating <ref> [Rey68] </ref>. Reynolds treated the problem as one of simplifying a collection 22 of set equations.
Reference: [Str92] <author> J. Stransky. </author> <title> A lattice for abstract interpretation of dynamic (Lisp-like) structures. </title> <journal> Information and Computation, </journal> <volume> 101(1) </volume> <pages> 70-102, </pages> <month> November </month> <year> 1992. </year> <month> 35 </month>
Reference-contexts: Furthermore, our method can determine that the list-insert program also preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, JM82, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck [CWZ90], and Stransky <ref> [Str92] </ref> who developed shape-analysis methods that associate each program point with a single shape-graph. <p> The use of a single shape-graph is possibly less accurate than a method based on sets of graphs, but it leads to more compact representations, and thus is more likely to lead to a practical shape-analysis algorithm. Jones and Muchnick [JM82], Chase, Wegman, and Zadeck [CWZ90], and Stransky <ref> [Str92] </ref> present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed above, both from a theoretical perspective [CWZ90] and from an implementation perspective [AW93].
References-found: 19

