URL: http://foxnet.cs.cmu.edu/people/fp/papers/CMU-CS-98-107.ps.gz
Refering-URL: 
Root-URL: 
Title: The Fox Project: Advanced Language Technology for Extensible Systems  
Author: Robert Harper, Peter Lee, and Frank Pfenning 
Note: Also published as Fox Memorandum CMU-CS-FOX-98-02 This research was sponsored by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. C533, issued by ESC/ENS under Contract No. F19628-95-C-0050. The views and conclusions contained in this document are those of the author and should not be interpreted as representing official policies, either expressed or implied, of the Advanced Research Projects Agency or the U.S. Government.  
Date: January 1998  
Address: Pittsburgh, PA 15213  Pittsburgh, PA 15213  
Affiliation: Carnegie Mellon University  School of Computer Science Carnegie Mellon University  
Pubnum: CMU-CS-98-107  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> D. Scott Alexander, Marianne Shaw, Scott M. Nettles, and Jonathan M. Smith. </author> <title> Active bridging. </title> <booktitle> In Proceedings of the ACM SIGCOMM'97 Conference, </booktitle> <address> Cannes, France, </address> <month> September </month> <year> 1997. </year>
Reference-contexts: In our previous work in the Fox Project, this kind of synergy has sparked a considerable amount of follow-on work, particularly in advanced network design, for example in the Cornell Ensemble system [27] and the UPenn Switchware 3 Project <ref> [1] </ref>. There have also been significant interactions with the Utah Flux [7] and Washington SPIN Projects [2]. <p> Ongoing research in Active Networks will draw on and inspire our research on the underpinnings of safe composition of code from untrusted components. PLAN. The Switchware Project at the University of Pennsylvania is developing an Active Network in conjunction with Bellcore <ref> [1] </ref>. A critical part of their work is the development of a programming language, called PLAN, for programming Active Networks [11].
Reference: [2] <author> B. Bershad, S. Savage, P. Pardyak, E. G. Sirer, D. Becker, M. Fiuczyn-ski, C. Chambers, and S. Eggers. </author> <title> Extensibility, safety, and performance 20 in the SPIN operating system. </title> <booktitle> In Symposium on Operating System Principles, </booktitle> <pages> pages 267-284, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: There have also been significant interactions with the Utah Flux [7] and Washington SPIN Projects <ref> [2] </ref>. Here, we illustrate this synergy by briefly reviewing the Project's FoxNet reconfigurable network protocol suite [3], and seeing how its development was instrumental in leading to the TIL type-directed compiler [24] and the Proof-Carrying Code [17] approach to safe mobile code.
Reference: [3] <author> Edoardo Biagioni, Nicholas Haines, Robert Harper, Peter Lee, and Brian G. Milnes. </author> <title> Standard ML signatures for a protocol stack. </title> <note> Fox Memorandum CMU-CS-93-170, </note> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> July </month> <year> 1993. </year> <note> (Also published as CMU-CS-FOX-93-01). </note>
Reference-contexts: There have also been significant interactions with the Utah Flux [7] and Washington SPIN Projects [2]. Here, we illustrate this synergy by briefly reviewing the Project's FoxNet reconfigurable network protocol suite <ref> [3] </ref>, and seeing how its development was instrumental in leading to the TIL type-directed compiler [24] and the Proof-Carrying Code [17] approach to safe mobile code. The FoxNet system is a collection of network protocol modules. <p> Specific features include polymorphic type inference, a flexible and expressive module and interface language, and support for functional and imperative programming. These features have been effectively deployed in the FoxNet implementation of TCP/IP <ref> [3] </ref> and in the Ensemble network protocol suite [27]. In the FoxNet a network protocol layer is a functor that is parameterized on the layer beneath it and that implements a generic protocol interface.
Reference: [4] <author> Iliano Cervesato and Frank Pfenning. </author> <title> A linear logical framework. </title> <editor> In E. Clarke, editor, </editor> <booktitle> Proceedings of the Eleventh Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 264-275, </pages> <address> New Brunswick, New Jersey, July 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Especially for complex safety policies which may be required in some Active Networks, more drastic extension to the framework itself might be required, such as provided by the linear logical framework (LLF) <ref> [4] </ref>. A linear framework has more succinct means for expressing mutable state and concurrency than traditional frameworks, and we plan to investigate efficient proof-checking techniques for LLF. 2. A second problem concerns the construction and maintenance of verification-condition generators, or VCGens.
Reference: [5] <author> David D. Clark. </author> <title> The structuring of systems using upcalls. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 171-180. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1985. </year>
Reference-contexts: This design supports the flexible composition of protocol layers and the rapid development of non-standard network protocols (also exemplified in Ensemble). The FoxNet implementation uses higher-order functions to implement "upcalls" <ref> [5] </ref> or "paths" [10] through a protocol stack, a key to achieving efficient protocol processing in a layered implementation.
Reference: [6] <author> Rowan Davies and Frank Pfenning. </author> <title> Practical refinement-type checking. </title> <type> Draft paper, </type> <month> July </month> <year> 1997. </year>
Reference-contexts: Thus we have been conducting research to refine the type system of ML to allow more program properties to be expressed and checked. We propose to continue this research with a focus on refinement types and dependent types. 1. Refinement Types. Using initial prototypes developed by the Fox project <ref> [8, 6] </ref> we propose to investigate how recursive data structure invariants can be checked effectively and how compilers can take ad vantage of this information to generate more efficient code. 2. Dependent Types.
Reference: [7] <author> Bryan Ford, Godmar Back, Greg Benson, Jay Lepreau, Albert Lin, and Olin Shivers. </author> <title> The Flux OSKit: A substrate for OS and language research. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Operating Systems Principles, </booktitle> <address> Saint-Malo, France, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: There have also been significant interactions with the Utah Flux <ref> [7] </ref> and Washington SPIN Projects [2]. Here, we illustrate this synergy by briefly reviewing the Project's FoxNet reconfigurable network protocol suite [3], and seeing how its development was instrumental in leading to the TIL type-directed compiler [24] and the Proof-Carrying Code [17] approach to safe mobile code. <p> Flux. We have an ongoing collaboration with Jay Lepreau at the University of Utah who is developing the Flux Operating System Toolkit <ref> [7] </ref> to provide the infrastructure for experimentation with advanced system structuring techniques. We are at present engaged in a cooperative effort to 19 extend the Kaffe implementation of the JVM and the Flux Toolkit to in-clude support for safe extension based on proof-carry code.
Reference: [8] <author> Tim Freeman. </author> <title> Refinement Types for ML. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> March </month> <year> 1994. </year> <note> Available as Technical Report CMU-CS-94-110. </note>
Reference-contexts: Thus we have been conducting research to refine the type system of ML to allow more program properties to be expressed and checked. We propose to continue this research with a focus on refinement types and dependent types. 1. Refinement Types. Using initial prototypes developed by the Fox project <ref> [8, 6] </ref> we propose to investigate how recursive data structure invariants can be checked effectively and how compilers can take ad vantage of this information to generate more efficient code. 2. Dependent Types.
Reference: [9] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <booktitle> In Second Symposium on Logic in Computer Science, </booktitle> <pages> pages 194-204, </pages> <address> Ithaca, New York, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: On the other hand a universal checker would be scrutinized carefully by each party, thereby increasing our confidence in its correctness.) In our previous work on PCC, we have shown that the Edinburgh Logical Framework (LF) <ref> [9] </ref> can be an effective language for encoding proofs. There are several advantages to the use of LF for proof encodings. First, LF is an extremely simple language but still highly expressive.
Reference: [10] <author> John H. Hartman, Larry L. Peterson, Andy Bavier, Peter A. Bigot, Patrick Bridges, Brady Montz, Rob Piltz, Todd A. Proebsting, and Oliver Spatscheck. Joust: </author> <title> A platform for communcation-oriented liquid software. </title> <type> Technical Report TR 97-16, </type> <institution> Department of Computer Science, The University of Arizona, </institution> <month> December </month> <year> 1997. </year>
Reference-contexts: This design supports the flexible composition of protocol layers and the rapid development of non-standard network protocols (also exemplified in Ensemble). The FoxNet implementation uses higher-order functions to implement "upcalls" [5] or "paths" <ref> [10] </ref> through a protocol stack, a key to achieving efficient protocol processing in a layered implementation. <p> We expect to interact closely with the UPenn group in the course of our research. Joust. John Hartman, Larry Peterson, et. al. <ref> [10] </ref> at the University of Ari-zona have coined the term liquid software for a general approach to achieving flexible and reliable code mobility in a network environment, with application to the construction of Active Networks and, more broadly, to the general problem of dynamic integration of mobile code.
Reference: [11] <author> Michael Hicks, Pankaj Kakkar, Jonathan T. Moore, Carl A. Gunter, and Scott Nettles. </author> <title> PLAN: A programming language for active networks. </title> <note> Submitted, </note> <month> November </month> <year> 1997. </year> <month> 21 </month>
Reference-contexts: PLAN. The Switchware Project at the University of Pennsylvania is developing an Active Network in conjunction with Bellcore [1]. A critical part of their work is the development of a programming language, called PLAN, for programming Active Networks <ref> [11] </ref>. Their work builds on ours in a number of respects, including the reliance on a typed, functional language based on ML as the basis for their design, and the use of a variant of our Proof-Carrying Code technology to provide assurances about the run-time behavior of active network software.
Reference: [12] <author> Xavier Leroy. </author> <title> The Objective Caml system: Documentation and user's guide. </title> <note> Available at http://pauillac.inria.fr/ocaml/htmlman/., 1996. </note>
Reference-contexts: The focus of this research thread are refinement types (for recursive data structures) and dependent types (for aggregate data structures), both of which are considered in the context of Standard ML. Standard ML [14] (and its close relative, Caml <ref> [12] </ref>) represent a high-water mark in the design of flexible, expressive type systems for programming languages. Specific features include polymorphic type inference, a flexible and expressive module and interface language, and support for functional and imperative programming.
Reference: [13] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: How might this be achieved? Current methods rely mainly on dynamic checking to ensure that the behavior of components is suitably constrained, for example, through the use of interpreted virtual machines <ref> [13, 26] </ref>. Components are written in an abstract machine code that is inherently safe to execute on an active node | the code is executed by a trusted interpreter that executes on behalf of the component. This amounts to an elaborate set of run-time checks to ensure safety. <p> However, they rely on dynamic checking techniques, rather than static analysis, to achieve these ends. In particular they employ a variant of the Java Virtual Machine <ref> [13] </ref> (extended with some Joust-specific constructs, and omitting some of the JVM functionality) to ensure safety of mobile code, and employ a "just in time" compiler to enhance performance.
Reference: [14] <author> Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: Type systems provide a general framework for specification and checking that has proved to be remarkably effective in a wide variety of settings, ranging from type systems for programming languages such as ML <ref> [14] </ref> to sophisticated formalisms for specifying and checking the execution behavior of programs, such as Proof-Carrying Code [17, 16]. Type systems have these desirable properties: 1. Scalability. <p> The goal is to allow more program properties to be ex-pressed naturally within a type system. The focus of this research thread are refinement types (for recursive data structures) and dependent types (for aggregate data structures), both of which are considered in the context of Standard ML. Standard ML <ref> [14] </ref> (and its close relative, Caml [12]) represent a high-water mark in the design of flexible, expressive type systems for programming languages. Specific features include polymorphic type inference, a flexible and expressive module and interface language, and support for functional and imperative programming.
Reference: [15] <author> George C. Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Proceedings of the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'97), </booktitle> <address> Paris, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: PCC is flexible. The proof checker does not require that a particular programming language be used. PCC can, in principle, be used for a wide range of languages, ranging from high-level languages such as ML <ref> [15] </ref>, to abstract machine codes, and even to machine languages. An important design criterion for an implementation of certified code is that the proof checker be simple, concise, and, preferably, universal. <p> Arranging for the compiled code to invoke a garbage collector at the appropriate times again should not pose any serious problems, though as we pointed out in our earlier work on PCC extensions of ML programs <ref> [15] </ref>, some care must be taken in the case that copying garbage collection is used.
Reference: [16] <author> George C. Necula and Peter Lee. </author> <title> Proof-carrying code. </title> <type> Technical Report CMU-CS-96-165, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> September </month> <year> 1996. </year>
Reference-contexts: Type systems provide a general framework for specification and checking that has proved to be remarkably effective in a wide variety of settings, ranging from type systems for programming languages such as ML [14] to sophisticated formalisms for specifying and checking the execution behavior of programs, such as Proof-Carrying Code <ref> [17, 16] </ref>. Type systems have these desirable properties: 1. Scalability. Types can be used to express a wide range of program properties, ranging from simple data representations (e.g., int's and float's) to sophisticated data structure invariants (e.g., coloring in variants on red-black trees or restrictions on array accesses). 2. <p> The code may be written in virtually any language that can be 9 given a precise operational semantics. In our previous work, we have de-veloped PCC for DEC Alpha assembly code and demonstrated its utility in safe operating system extensions <ref> [17, 16] </ref>.
Reference: [17] <author> George C. Necula and Peter Lee. </author> <title> Safe kernel extensions without run-time checking. </title> <booktitle> In Proceedings of the Second Symposium on Operating System Design and Implementation (OSDI'96), Seattle, </booktitle> <pages> pages 229-243, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Type systems provide a general framework for specification and checking that has proved to be remarkably effective in a wide variety of settings, ranging from type systems for programming languages such as ML [14] to sophisticated formalisms for specifying and checking the execution behavior of programs, such as Proof-Carrying Code <ref> [17, 16] </ref>. Type systems have these desirable properties: 1. Scalability. Types can be used to express a wide range of program properties, ranging from simple data representations (e.g., int's and float's) to sophisticated data structure invariants (e.g., coloring in variants on red-black trees or restrictions on array accesses). 2. <p> Here, we illustrate this synergy by briefly reviewing the Project's FoxNet reconfigurable network protocol suite [3], and seeing how its development was instrumental in leading to the TIL type-directed compiler [24] and the Proof-Carrying Code <ref> [17] </ref> approach to safe mobile code. The FoxNet system is a collection of network protocol modules. The modules are designed to be highly composable so that high-performance network systems can be quickly and reliably constructed and reconfigured. <p> The code may be written in virtually any language that can be 9 given a precise operational semantics. In our previous work, we have de-veloped PCC for DEC Alpha assembly code and demonstrated its utility in safe operating system extensions <ref> [17, 16] </ref>.
Reference: [18] <author> George C. Necula and Peter Lee. </author> <title> The design and implementation of a certifying compiler. </title> <booktitle> Submitted to the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <month> November </month> <year> 1997. </year>
Reference-contexts: Dependent Types. While dependent types in their full generality do not admit practical type-checking algorithms, some common special cases such as array bound checking have been shown to be feasible [31] which allows significantly more efficient proof-carrying code <ref> [18] </ref>. <p> Since our theorem prover generates checkable encodings of its proofs, it is then straightforward to generate PCC binaries for the target programs produced by the compiler. Our early experiments with the Touchstone prototype have been extremely encouraging, with excellent results shown for several realistic C programs <ref> [18] </ref>. We propose to continue the development of Touchstone, with the goal of eventually making it robust enough to distribute to other researchers. There are several aspects to this task. First, an appropriate "safe C-like language" has to be designed and formally specified.
Reference: [19] <author> George C. Necula and Peter Lee. </author> <title> Efficient representation and validation of proofs. </title> <booktitle> Submitted to the ACM Symposium on Logic in Computer Science, </booktitle> <month> December </month> <year> 1997. </year>
Reference-contexts: The proof-checking process used by the code consumer to determine code safety is completely automatic and can be implemented by a proof-checking program that is relatively simple and easy to trust. Thus, the safety-critical infrastructure that the code consumer must rely upon is reduced to a minimum <ref> [19] </ref>. 3. PCC is efficient.
Reference: [20] <author> George C. Necula and Peter Lee. </author> <title> Safe, untrusted agents using proof-carrying code. </title> <booktitle> Submitted to the Special Volume on Mobile Agents, Lecture Notes in Computer Science, </booktitle> <month> December </month> <year> 1997. </year>
Reference-contexts: The code consumer defines the safety policy, and this policy is not limited to a particular notion of "safety." We have already experimented both with simple safety properties, such as memory and type safety, and with properties that are normally difficult to verify, such as time limits on execution <ref> [20] </ref>. 2. PCC is low-risk and automatic. The proof-checking process used by the code consumer to determine code safety is completely automatic and can be implemented by a proof-checking program that is relatively simple and easy to trust.
Reference: [21] <author> Michael P. Plezbert and Ron K. Cytron. </author> <booktitle> Is "just in time" = "better late than never"? In The 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 120-131, </pages> <address> Paris, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: This amounts to an elaborate set of run-time checks to ensure safety. Of course this raises problems of efficiency, since the overhead of interpretation and dynamic enforcement is substantial. Efficiency can be regained, to some extent, by using "just in 1 time (JIT)" compilers <ref> [21] </ref> to translate virtual machine code to real hardware instructions. However, run-time checks to ensure safety are still required, and, what is worse, the complexity of the trusted code base increases substantially to include the JIT compiler itself, thereby reducing the reliability of the network as a whole.
Reference: [22] <author> Carsten Schurmann and Frank Pfenning. </author> <title> Automated theorem proving in a simple meta-logic for lf. </title> <note> Submitted, January 1998. 22 </note>
Reference-contexts: We plan to once again exploit the expressive power of logical frameworks to describe the operational semantics, logical verification conditions, and their relationship within the same language and apply automated proof tools <ref> [22] </ref> to verify critical properties of a VCGen. This will also require further research into the efficient implementation of the Twelf meta-theorem prover sketched in [22]. <p> expressive power of logical frameworks to describe the operational semantics, logical verification conditions, and their relationship within the same language and apply automated proof tools <ref> [22] </ref> to verify critical properties of a VCGen. This will also require further research into the efficient implementation of the Twelf meta-theorem prover sketched in [22].
Reference: [23] <author> Raymie Stata and Martn Abadi. </author> <title> A type system for Java bytecode subroutines. </title> <booktitle> In Proceedings of the 25th Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, CA, </address> <month> January </month> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: Certifying machine code has the great advantage of efficiency, but restricts code mobility since it applies to only one architecture. We therefore also propose to adapt the idea of PCC to virtual machine code. Proofs attached to virtual machine code can potentially simplify bytecode verification <ref> [23] </ref> and interpretation, enable multiple safety policies, and allow more efficient just-in-time compilation without sacrificing safety or relying on an unreasonably large trusted computing base. 3.3 Compiler Technology A critical element of our proposed research is the construction of demonstration compilers embodying ideas from our work on language technology and security <p> The abstract machine code could be as high level as ML or as low level as the Java Virtual 14 Machine, equipped with a suitable type system (for example, Abadi and Stata's type system for JVM <ref> [23] </ref>). 2. Proof-Carrying Code and Certifying Compilers.
Reference: [24] <author> David Tarditi, Greg Morrisett, Perry Cheng, Chris Stone, Robert Harper, and Peter Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 181-192, </pages> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: There have also been significant interactions with the Utah Flux [7] and Washington SPIN Projects [2]. Here, we illustrate this synergy by briefly reviewing the Project's FoxNet reconfigurable network protocol suite [3], and seeing how its development was instrumental in leading to the TIL type-directed compiler <ref> [24] </ref> and the Proof-Carrying Code [17] approach to safe mobile code. The FoxNet system is a collection of network protocol modules. The modules are designed to be highly composable so that high-performance network systems can be quickly and reliably constructed and reconfigured. <p> We propose to further develop and eventually integrate dependent types into the Fox project's TIL compiler <ref> [24] </ref>. 3.2 Safety Infrastructure Our work on safety infrastructure is concerned with both the theoretical foundations and the software necessary to exploit the concept of Proof-Carrying Code (PCC) in Active Networks and other extensible systems. <p> More specifically, we propose the following work on these two approaches to certifying compilers: 1. The basis for our experiments with Typed Intermediate Languages and Type-Directed Compilation is the TILT compiler for Standard ML. TILT is an evolution of the TIL compiler <ref> [24] </ref> to encompass the complete Standard ML language, including the module system.
Reference: [25] <author> David L. Tennenhouse and David J. Wetherall. </author> <title> Towards and active network architecture. </title> <journal> Computer Communication Review, </journal> <volume> 26(2), </volume> <month> April </month> <year> 1996. </year>
Reference-contexts: In short, the core enabling technology for achieving dynamic extensibility of software systems is verified encapsulation of system components. The goal of an Active Network is to exploit such dynamic extensibility of software systems to achieve unprecedented degrees of flexibility, robustness, and efficiency in modern high-speed networks <ref> [25] </ref>. The key idea is to use "active packets", or "capsules", that contain code to be incorporated into a network router or other active component of a network to modify its behavior in an application-specific manner. <p> This includes Active Network, but also systems being developed under the DARPA/ITO Quorum, Information Survivability, and EDCS programs. 4 Related Work Active Networks. The idea of an Active Network was proposed by Wether-all, Guttag, and Tennenhouse <ref> [30, 25, 29] </ref> as a means of improving the flexibility and performance of network protocols. The idea of Active Networks raises significant problems that are addressed in this proposal.
Reference: [26] <editor> USENIX Association. </editor> <title> The BSD Packet Filter: A New Architecture for User-Level Packet Capture, </title> <month> January </month> <year> 1993. </year>
Reference-contexts: How might this be achieved? Current methods rely mainly on dynamic checking to ensure that the behavior of components is suitably constrained, for example, through the use of interpreted virtual machines <ref> [13, 26] </ref>. Components are written in an abstract machine code that is inherently safe to execute on an active node | the code is executed by a trusted interpreter that executes on behalf of the component. This amounts to an elaborate set of run-time checks to ensure safety.
Reference: [27] <author> Robbert van Renesse, Ken Birman, Mark Hayden, Alexey Vaysburd, and David Karr. </author> <title> Building adaptive systems using ensemble. </title> <type> Technical Report TR97-1638, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: In our previous work in the Fox Project, this kind of synergy has sparked a considerable amount of follow-on work, particularly in advanced network design, for example in the Cornell Ensemble system <ref> [27] </ref> and the UPenn Switchware 3 Project [1]. There have also been significant interactions with the Utah Flux [7] and Washington SPIN Projects [2]. <p> Specific features include polymorphic type inference, a flexible and expressive module and interface language, and support for functional and imperative programming. These features have been effectively deployed in the FoxNet implementation of TCP/IP [3] and in the Ensemble network protocol suite <ref> [27] </ref>. In the FoxNet a network protocol layer is a functor that is parameterized on the layer beneath it and that implements a generic protocol interface. This design supports the flexible composition of protocol layers and the rapid development of non-standard network protocols (also exemplified in Ensemble). <p> Ensemble. Ken Birman and Robbert van Rennesse at Cornell have demonstrated convincingly that advanced programming languages with strong type systems, rich modularity mechanisms, and higher-order functions can be deployed to achieve an unprecedented degree of flexibility, reliability, and efficiency in the construction of networking software <ref> [27] </ref>. Moreover, efficiency is achieved, in part, by using theorem-proving techniques to carry out the verified transformation of well-structured programs into more efficient, but functionally equivalent, versions of these protocols.
Reference: [28] <author> R. Wahbe, S. Lucco, T. .E. Anderson, and S. L. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In 14th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 203-216, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: However, run-time checks to ensure safety are still required, and, what is worse, the complexity of the trusted code base increases substantially to include the JIT compiler itself, thereby reducing the reliability of the network as a whole. Another approach to run-time encapsulation is Software Fault Isolation (SFI) <ref> [28] </ref>. To avoid interpretation overhead, machine binaries are edited at load time to ensure that memory accesses are limited to a specific allowed range so that the component at worst self-destructs, rather than destroys the context in which it executes.
Reference: [29] <author> David J. Wetherall, John Guttag, and David L. Tennenhouse. </author> <title> ANTS: A toolkit for building and dynamically deploying network protocols. </title> <editor> In Aurel A. Lazar, editor, </editor> <booktitle> Proceedings of the First IEEE Conference on Open Architectures and Network Programming (OPENARCH'98), </booktitle> <address> San Francisco, CA, </address> <month> April </month> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: This includes Active Network, but also systems being developed under the DARPA/ITO Quorum, Information Survivability, and EDCS programs. 4 Related Work Active Networks. The idea of an Active Network was proposed by Wether-all, Guttag, and Tennenhouse <ref> [30, 25, 29] </ref> as a means of improving the flexibility and performance of network protocols. The idea of Active Networks raises significant problems that are addressed in this proposal.
Reference: [30] <author> David J. Wetherall and David L. Tennenhouse. </author> <title> The ACTIVE IP option. </title> <booktitle> In Proceedings of the 7th ACM SIGOPS European Workshop, </booktitle> <address> Connemara, Ireland, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: This includes Active Network, but also systems being developed under the DARPA/ITO Quorum, Information Survivability, and EDCS programs. 4 Related Work Active Networks. The idea of an Active Network was proposed by Wether-all, Guttag, and Tennenhouse <ref> [30, 25, 29] </ref> as a means of improving the flexibility and performance of network protocols. The idea of Active Networks raises significant problems that are addressed in this proposal.
Reference: [31] <author> Hongwei Xi and Frank Pfenning. </author> <title> Eliminating array bound checking through dependent types. </title> <note> Submitted, </note> <month> November </month> <year> 1997. </year> <month> 23 </month>
Reference-contexts: Dependent Types. While dependent types in their full generality do not admit practical type-checking algorithms, some common special cases such as array bound checking have been shown to be feasible <ref> [31] </ref> which allows significantly more efficient proof-carrying code [18].
References-found: 31

