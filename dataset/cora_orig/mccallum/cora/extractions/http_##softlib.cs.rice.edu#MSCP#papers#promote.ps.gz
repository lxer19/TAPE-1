URL: http://softlib.cs.rice.edu/MSCP/papers/promote.ps.gz
Refering-URL: http://www.cs.rice.edu/MSCP/publications.html
Root-URL: 
Title: Register Promotion in C Programs  
Author: Keith D. Cooper and John Lu 
Address: Houston, Texas 77005  
Affiliation: Department of Computer Science Rice University  
Abstract: The combination of pointers and pointer arithmetic in C makes the task of improving C programs somewhat more difficult than improving programs written in simpler languages like Fortran. While much work has been published that focuses on the analysis of pointers, little has appeared that uses the results of such analysis to improve the code compiled for C. This paper examines the problem of register promotion in C and presents experimental results showing that it can have dramatic effects on memory traffic. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Preston Briggs, Keith D. Cooper, and Linda Torc-zon. </author> <title> Improvements to graph coloring register allocation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 428-455, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: The promoted variables are scalars that the compiler did not enregister because it lacked the information to show that enregister-ing them was safe. Section 3.3 discusses one technique 2 The copies are subject to coalescing by the register allocator <ref> [1] </ref>. It is quite effective at eliminating copies like these. for extending the domain of promotion to include some array and more pointer-based values. <p> This particular improvement did not require the extra precision provided 4 It might be expected that the allocator would simply spill some subset of the twenty-eight promoted values and avoid the actual performance degradation. Our compiler uses a graph-coloring allocator <ref> [1] </ref>. These allocators are known to "over-spill" in tight situations.
Reference: [2] <author> David Callahan, Steve Carr, and Ken Kennedy. </author> <title> Improving register allocation for subscripted variables. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 53-65, </pages> <month> June </month> <year> 1990. </year> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: For example, Carr used dependence analysis to detect consistent patterns of cross-iteration reuse in Fortran and to promote the corresponding values into scalar temporaries that ended up in registers <ref> [2] </ref>. We are interested in expanding the set of array references promoted by the compiler. Our work to date has focussed on poor code that results from lack of information about the behavior of other procedures and pointer-based memory operations. <p> When the algorithm discovers such a value, it allocates a new virtual register and rewrites the code accordingly. This work is similar to Carr's work on scalar replacement in Fortran <ref> [2, 4, 3] </ref>. Carr developed a source-to-source translator that used dependence information to promote array elements that are reused across different iterations of the loop.
Reference: [3] <author> Steve Carr. </author> <title> Memory-Hierarchy Management. </title> <type> PhD thesis, </type> <institution> Rice University, Department of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: Register promotion increases the demand for registers|often called register pressure. As we improve the promoter, we increase its ability to generate an intermediate code program that requires spilling in the register allocator. Carr discovered this effect in his work on scalar replacement in Fortran <ref> [3] </ref>; beyond some point, the memory accesses removed by the transformation were balanced by the spills added during register allocation. He adopted a bin-packing discipline to "throttle" the promotion process. <p> When the algorithm discovers such a value, it allocates a new virtual register and rewrites the code accordingly. This work is similar to Carr's work on scalar replacement in Fortran <ref> [2, 4, 3] </ref>. Carr developed a source-to-source translator that used dependence information to promote array elements that are reused across different iterations of the loop.
Reference: [4] <author> Steve Carr and Ken Kennedy. </author> <title> Scalar replacement in the presence of conditional control flow. </title> <type> Technical Report TR92283, </type> <institution> Rice University, CRPC, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: When the algorithm discovers such a value, it allocates a new virtual register and rewrites the code accordingly. This work is similar to Carr's work on scalar replacement in Fortran <ref> [2, 4, 3] </ref>. Carr developed a source-to-source translator that used dependence information to promote array elements that are reused across different iterations of the loop.
Reference: [5] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <journal> SIG-PLAN Notices, </journal> <volume> 25(6) </volume> <pages> 296-310, </pages> <month> June </month> <year> 1990. </year> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The literature on pointer analysis has expanded greatly in recent years <ref> [18, 8, 22, 5, 14, 9, 12, 6, 13] </ref>. This paper presents a technique for using the results of pointer analysis to make the code generated by a C compiler run faster.
Reference: [6] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: The literature on pointer analysis has expanded greatly in recent years <ref> [18, 8, 22, 5, 14, 9, 12, 6, 13] </ref>. This paper presents a technique for using the results of pointer analysis to make the code generated by a C compiler run faster. <p> Many papers have described techniques for discerning information about the side effects of memory operations through pointer variables. Our work is based on "points-to" analysis; earlier work, like Landi and Ryder [13];, Choi, Burke, and Cytron <ref> [6] </ref>; and Deutsch [8] cast the problem in an "aliasing" framework. Algorithms for computing "points-to" information have been described by Emami, Ghiya, and Hen-dren [12]; by Wilson and Lam [22]; aand by Ruf [18].
Reference: [7] <author> Keith D. Cooper and Ken Kennedy. </author> <title> Interprocedu-ral side-effect analysis in linear time. </title> <journal> SIGPLAN Notices, </journal> <volume> 23(7) </volume> <pages> 57-66, </pages> <month> July </month> <year> 1988. </year> <booktitle> Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Each memory operation has an associated list of "tags"; these are textual names that identify the memory locations that can be used by the operation. Procedure calls have lists of modified tags and referenced tags to record their summary side effects <ref> [7] </ref>. Finally, the IL contains a hierarchy of memory instructions that denote increasingly more specific knowledge (see Table 1.) When it emits the IL, the front end encodes the best information it has into the tag field and the opcode. <p> MOD/REF analysis is then repeated, using the new tag sets for the pointer based-memory operations. 3 This algorithm seems quite simple. The equations for MOD and REF are drastically simplified by C's lack of call-by-reference parameters <ref> [7] </ref>. 5 Experimental Results To understand the impact of register promotion, we compiled 14 C programs using our laboratory compiler (see Figure 4). Four versions of each program were prepared, using the combinations of scalar promotion, no scalar promotion, MOD/REF analysis, and pointer analysis.
Reference: [8] <author> Alain Deutsch. </author> <title> Interprocedural May-Alias analysis for pointers: Beyond k-limiting. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6) </volume> <pages> 230-241, </pages> <month> June </month> <year> 1994. </year> <booktitle> Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The literature on pointer analysis has expanded greatly in recent years <ref> [18, 8, 22, 5, 14, 9, 12, 6, 13] </ref>. This paper presents a technique for using the results of pointer analysis to make the code generated by a C compiler run faster. <p> Many papers have described techniques for discerning information about the side effects of memory operations through pointer variables. Our work is based on "points-to" analysis; earlier work, like Landi and Ryder [13];, Choi, Burke, and Cytron [6]; and Deutsch <ref> [8] </ref> cast the problem in an "aliasing" framework. Algorithms for computing "points-to" information have been described by Emami, Ghiya, and Hen-dren [12]; by Wilson and Lam [22]; aand by Ruf [18]. Steensgaard showed a linear-time algorithm for performing a flow-insensitive points-to analysis by casting it as a type-inference problem [20].
Reference: [9] <author> Maryam Emami, Rakesh Ghiya, and Laurie Hen-dren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <journal> SIG-PLAN Notices, </journal> <volume> 29(6) </volume> <pages> 242-256, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The literature on pointer analysis has expanded greatly in recent years <ref> [18, 8, 22, 5, 14, 9, 12, 6, 13] </ref>. This paper presents a technique for using the results of pointer analysis to make the code generated by a C compiler run faster.
Reference: [10] <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Is it a tree, a DAG, </title> <booktitle> or a cyclic graph? a shape analysis for heap-directed pointers in c? Conference Record of the Fifteenth ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 1-15, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: gzip (enc) modref 910746 854886 55860 6.13 pointer 902023 836200 65823 7.30 gzip (dec) modref 136740 136387 353 0.26 pointer 136408 136055 353 0.26 looked at the problem of deriving better understanding of the "shape" of objects in the heap; two of the most recent are by Ghiya and Hendren <ref> [10] </ref> and Sagiv, Reps, and Wilhelm [19]. Each of these techniques has strengths and weaknesses. We chose to compute points-to rather than aliasing because we felt that it more closely corresponds to the problem that we were addressing in the compiler.
Reference: [11] <author> Gina Goff, Ken Kennedy, and Chau-Wen Tseng. </author> <title> Practical dependence testing. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(6) </volume> <pages> 15-29, </pages> <month> June </month> <year> 1991. </year> <booktitle> Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Some of the more complex examples require detailed dependence analysis or an equivalent technique to reason about conflicts with other references to the same array inside the loop <ref> [11, 16] </ref>. For example, Carr used dependence analysis to detect consistent patterns of cross-iteration reuse in Fortran and to promote the corresponding values into scalar temporaries that ended up in registers [2]. We are interested in expanding the set of array references promoted by the compiler.
Reference: [12] <author> Joseph Hummel, Laurie J. Hendren, and Alexander Nicolau. </author> <title> A general data dependence test for dynamic, pointer-based data structures. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6) </volume> <pages> 218-229, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The literature on pointer analysis has expanded greatly in recent years <ref> [18, 8, 22, 5, 14, 9, 12, 6, 13] </ref>. This paper presents a technique for using the results of pointer analysis to make the code generated by a C compiler run faster. <p> Our work is based on "points-to" analysis; earlier work, like Landi and Ryder [13];, Choi, Burke, and Cytron [6]; and Deutsch [8] cast the problem in an "aliasing" framework. Algorithms for computing "points-to" information have been described by Emami, Ghiya, and Hen-dren <ref> [12] </ref>; by Wilson and Lam [22]; aand by Ruf [18]. Steensgaard showed a linear-time algorithm for performing a flow-insensitive points-to analysis by casting it as a type-inference problem [20].
Reference: [13] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(7) </volume> <pages> 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The literature on pointer analysis has expanded greatly in recent years <ref> [18, 8, 22, 5, 14, 9, 12, 6, 13] </ref>. This paper presents a technique for using the results of pointer analysis to make the code generated by a C compiler run faster. <p> Many papers have described techniques for discerning information about the side effects of memory operations through pointer variables. Our work is based on "points-to" analysis; earlier work, like Landi and Ryder <ref> [13] </ref>;, Choi, Burke, and Cytron [6]; and Deutsch [8] cast the problem in an "aliasing" framework. Algorithms for computing "points-to" information have been described by Emami, Ghiya, and Hen-dren [12]; by Wilson and Lam [22]; aand by Ruf [18].
Reference: [14] <author> James R. Larus and Paul N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <journal> SIGPLAN Notices, </journal> <volume> 23(7) </volume> <pages> 21-34, </pages> <month> July </month> <year> 1988. </year> <booktitle> Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The literature on pointer analysis has expanded greatly in recent years <ref> [18, 8, 22, 5, 14, 9, 12, 6, 13] </ref>. This paper presents a technique for using the results of pointer analysis to make the code generated by a C compiler run faster.
Reference: [15] <author> Thomas Lengauer and Robert Endre Tarjan. </author> <title> A fast algorithm for finding dominators in a flow-graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 1(1) </volume> <pages> 121-141, </pages> <month> July </month> <year> 1979. </year>
Reference-contexts: B AMBIGUOUS b contains all tags referenced ambiguously in b, through procedure calls or pointer-based memory operations where the pointer contains multiple tags. 3. find loop structure|The compiler computes dominator information to identify loop nests using an algorithm due to Lengauer and Tarjan <ref> [15] </ref>. 4. analyze loop nests|For each loop l, the compiler solves the equations shown in Figure 1. <p> This requires O (CT ) time, worst case. The dominator algorithm used to find the loop structure can be implemented to require O (Eff (E; B)) time, where ff (E; B) is related to a functional inverse of Ackermann's function <ref> [15] </ref>. Computing L EXPLICIT and L AMBIGUOUS requires O (LBT ) time, while L PROMOTABLE and L LIFT require O (LT ) time.
Reference: [16] <author> Dror E. Maydan, John L. Hennessy, and Monica S. Lam. </author> <title> Efficient and exact data dependence analysis. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(6) </volume> <pages> 1-14, </pages> <month> June </month> <year> 1991. </year> <booktitle> Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Some of the more complex examples require detailed dependence analysis or an equivalent technique to reason about conflicts with other references to the same array inside the loop <ref> [11, 16] </ref>. For example, Carr used dependence analysis to detect consistent patterns of cross-iteration reuse in Fortran and to promote the corresponding values into scalar temporaries that ended up in registers [2]. We are interested in expanding the set of array references promoted by the compiler.
Reference: [17] <author> Etienne Morel and Claude Renvoise. </author> <title> Global optimization by suppression of partial redundancies. </title> <journal> Communications of the ACM, </journal> <volume> 22(2) </volume> <pages> 96-103, </pages> <month> Febru-ary </month> <year> 1979. </year>
Reference-contexts: It is quite effective at eliminating copies like these. for extending the domain of promotion to include some array and more pointer-based values. The algorithm only examines references inside loops; our implementation of partial redundancy elimination <ref> [17] </ref> uses memory tag information to achieve most of the effects of promotion in straight-line code. What does this algorithm cost? The cost of the inter-procedural analysis used to support register promotion varies with both the algorithm used and the desired precision of the information (See Sections 4 and 5).
Reference: [18] <author> Erik Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <journal> SIGPLAN Notices, </journal> <volume> 30(6) </volume> <pages> 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The literature on pointer analysis has expanded greatly in recent years <ref> [18, 8, 22, 5, 14, 9, 12, 6, 13] </ref>. This paper presents a technique for using the results of pointer analysis to make the code generated by a C compiler run faster. <p> Inside an SCC, all the functions have identical tag sets. Processing the SCCs in reverse topological order ensures that the tag set of any called function not in the current SCC has already been calculated. 3 Our approach to pointer analysis is similar to Ruf's work <ref> [18] </ref>. We analyze the entire program at once. Each function is converted into SSA form. For each SSA name, the analyzer determines the set of tags to which it may point. This is done by initializing SSA names with the pointer values they may initially have. <p> Algorithms for computing "points-to" information have been described by Emami, Ghiya, and Hen-dren [12]; by Wilson and Lam [22]; aand by Ruf <ref> [18] </ref>. Steensgaard showed a linear-time algorithm for performing a flow-insensitive points-to analysis by casting it as a type-inference problem [20].
Reference: [19] <author> Mooly Sagiv, Thomas Reps, and Reinhard Wil-helm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <booktitle> Conference Record of the Fifteenth ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 16-31, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: 6.13 pointer 902023 836200 65823 7.30 gzip (dec) modref 136740 136387 353 0.26 pointer 136408 136055 353 0.26 looked at the problem of deriving better understanding of the "shape" of objects in the heap; two of the most recent are by Ghiya and Hendren [10] and Sagiv, Reps, and Wilhelm <ref> [19] </ref>. Each of these techniques has strengths and weaknesses. We chose to compute points-to rather than aliasing because we felt that it more closely corresponds to the problem that we were addressing in the compiler. It also handles function pointers in a natural and useful way.
Reference: [20] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> Conference Record of the Fifteenth ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 31-41, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Algorithms for computing "points-to" information have been described by Emami, Ghiya, and Hen-dren [12]; by Wilson and Lam [22]; aand by Ruf [18]. Steensgaard showed a linear-time algorithm for performing a flow-insensitive points-to analysis by casting it as a type-inference problem <ref> [20] </ref>.
Reference: [21] <author> David W. Wall. </author> <title> Limits of instruction-level parallelism. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 176-189, </pages> <address> Santa Clara, California, </address> <year> 1991. </year>
Reference-contexts: Little prior work compares the results obtained by using a fixed set of transformations with different precisions of program analysis. One notable exception is David Wall's work on available instruction level parallelism (ILP) <ref> [21] </ref>. Wall estimated available ILP under a set of five different assumptions for the quality of analysis available in the compiler.
Reference: [22] <author> Robert P. Wilson and Monica S. Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 30(6) </volume> <pages> 1-12, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The literature on pointer analysis has expanded greatly in recent years <ref> [18, 8, 22, 5, 14, 9, 12, 6, 13] </ref>. This paper presents a technique for using the results of pointer analysis to make the code generated by a C compiler run faster. <p> Our work is based on "points-to" analysis; earlier work, like Landi and Ryder [13];, Choi, Burke, and Cytron [6]; and Deutsch [8] cast the problem in an "aliasing" framework. Algorithms for computing "points-to" information have been described by Emami, Ghiya, and Hen-dren [12]; by Wilson and Lam <ref> [22] </ref>; aand by Ruf [18]. Steensgaard showed a linear-time algorithm for performing a flow-insensitive points-to analysis by casting it as a type-inference problem [20].
References-found: 22

