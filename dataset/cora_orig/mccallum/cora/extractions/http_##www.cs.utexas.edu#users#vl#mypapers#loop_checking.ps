URL: http://www.cs.utexas.edu/users/vl/mypapers/loop_checking.ps
Refering-URL: http://www.cs.utexas.edu/users/vl/papers.html
Root-URL: 
Email: fvl,mccaing@cs.utexas.edu  teodor@cs.ucr.edu  staerk@gauss.stanford.edu  
Title: Loop Checking and the Well-Founded Semantics  
Author: Vladimir Lifschitz and Norman McCain Teodor C. Przymusinski Robert F. Stark 
Address: Austin, TX 78712, USA  Riverside, CA 92521, USA  Stanford, CA 94305, USA  
Affiliation: Department of Computer Sciences University of Texas at Austin  Department of Computer Science University of California at Riverside  Department of Mathematics Stanford University  
Abstract: Using a calculus of goals, we define the success and failure of a goal for propositional programs in the presence of loop checking. The calculus is sound with respect to the well-founded semantics; for finite programs, it is also complete. A Prolog-style proof search strategy for a modification of this calculus provides a query evaluation algorithm for finite propositional programs under the well-founded semantics. This algorithm is implemented as a meta-interpreter. 
Abstract-found: 1
Intro-found: 1
Reference: [ Bol and Degerstedt, 1993 ] <author> Roland Bol and Lars Degerstedt. </author> <title> The underlying search for magic templates and tabulation. </title> <booktitle> In Logic Programming: Proceedings of the Tenth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 793-811, </pages> <year> 1993. </year>
Reference-contexts: The idea of separating the search space from the search strategy underlies also the analysis of tabulation techniques in <ref> [ Bol and Degerstedt, 1993 ] </ref> . 2 The SLDNF Calculus A rule element is a (propositional) atom possibly preceded by the negation as failure symbol not . 4 A rule is a pair Head Body , where Head is an atom and Body is a finite set of rule elements.
Reference: [ Bol, 1991 ] <author> Roland Bol. </author> <title> Loop Checking in Logic Programming. </title> <type> PhD thesis, </type> <institution> University of Amsterdam, </institution> <year> 1991. </year>
Reference-contexts: It follows that loop checking is also sound for the answer set ("stable model") semantics [ Gelfond and Lifschitz, 1991 ] . The mathematical theory of loop checking in logic programming is the subject of a recent dissertation <ref> [ Bol, 1991 ] </ref> . In this note, we limit attention to a particularly simple case, propositional programs; the problems investigated by Bol have to do, for the most part, with nonground queries and thus do not even arise in the propositional case.
Reference: [ Chen and Warren, 1993 ] <author> Weidong Chen and David Warren. </author> <title> Query evaluation under the well founded semantics. </title> <booktitle> In The Twelfth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1993. </year>
Reference-contexts: This calculus, like L , is sound and complete for finite propositional programs. We plan to extend this work in several directions. First, it needs to be generalized to programs with variables. Second, we would like to describe tabulation <ref> [ Chen and Warren, 1993 ] </ref> in terms of a calculus of goals. Third, it is interesting to know how such calculi can be made complete relative to the answer set semantics.
Reference: [ Clark, 1978 ] <author> Keith Clark. </author> <title> Negation as failure. </title> <editor> In Herve Gallaire and Jack Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: The view of Prolog developed in that paper provides a clean separation between the inference rules and the search strategy, which makes the mathematics of Prolog considerably simpler. 3 For instance, the soundness of the calculus from [ Lifschitz, 1995 ] with respect to the completion semantics of <ref> [ Clark, 1978 ] </ref> can be verified by straightforward induction, and then the soundness of Prolog with respect to that semantics will immediately follow. The situation with the soundness of loop checking is similar, with an important difference. <p> The existing approaches to the semantics of logic programming can be loosely divided into two categories, depending on how they treat cycles in the program. Consider the simplest cycle: p p. Adding a rule like this can affect the meaning of a program under the completion semantics <ref> [ Clark, 1978 ] </ref> and some of its variants, whereas the well-founded semantics, the answer set semantics and other more recent semantical theories treat rules of this kind as irrelevant. Loop checking is a better match for the second group of theories than for the first.
Reference: [ Gelfond and Lifschitz, 1991 ] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Classical negation in logic programs and disjunctive databases. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 365-385, </pages> <year> 1991. </year>
Reference-contexts: It follows that loop checking is also sound for the answer set ("stable model") semantics <ref> [ Gelfond and Lifschitz, 1991 ] </ref> . The mathematical theory of loop checking in logic programming is the subject of a recent dissertation [ Bol, 1991 ] . <p> To simplify notation, we drop the braces in expressions of the forms j= f: : :g and =j f: : :g. 4 We do not use here the term "literal," in order to avoid conflict with the terminology of <ref> [ Gelfond and Lifschitz, 1991 ] </ref> and [ Kowalski and Sadri, 1991 ] , where literals are formed using classical (explicit) negation. (FP 1 ) (SN 1 ) (SP 1 ) (SP 1 ) (SP 1 ) (FN 1 ) (FN 1 ) (FP 1 ) Since the SLDNF calculus is
Reference: [ Kowalski and Sadri, 1991 ] <author> Robert Kowalski and Fariba Sadri. </author> <title> Logic programs with exceptions. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 387-400, </pages> <year> 1991. </year>
Reference-contexts: To simplify notation, we drop the braces in expressions of the forms j= f: : :g and =j f: : :g. 4 We do not use here the term "literal," in order to avoid conflict with the terminology of [ Gelfond and Lifschitz, 1991 ] and <ref> [ Kowalski and Sadri, 1991 ] </ref> , where literals are formed using classical (explicit) negation. (FP 1 ) (SN 1 ) (SP 1 ) (SP 1 ) (SP 1 ) (FN 1 ) (FN 1 ) (FP 1 ) Since the SLDNF calculus is sound relative to each of the three
Reference: [ Kunen, 1989 ] <author> Kenneth Kunen. </author> <title> Signed data dependencies in logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 7(3) </volume> <pages> 231-245, </pages> <year> 1989. </year>
Reference-contexts: Section 5 contains proof outlines. 3 The SLDNF calculus is a reformulation of the inductive characterization of the success and failure of goals under SLDNF given in <ref> [ Kunen, 1989 ] </ref> , and is similar to the calculus proposed earlier in [ Mints, 1986 ] .
Reference: [ Lifschitz, 1995 ] <author> Vladimir Lifschitz. </author> <title> SLDNF, constructive negation and grounding. </title> <booktitle> In Proc. of ICLP-95, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: For example, it applies to program (1), which is not stratified. Our definition of loop checking is in terms of a "calculus of goals," and in this sense we extend here the earlier work that relates Prolog to the "SLDNF calculus" <ref> [ Lifschitz, 1995 ] </ref> . The view of Prolog developed in that paper provides a clean separation between the inference rules and the search strategy, which makes the mathematics of Prolog considerably simpler. 3 For instance, the soundness of the calculus from [ Lifschitz, 1995 ] with respect to the completion <p> work that relates Prolog to the "SLDNF calculus" <ref> [ Lifschitz, 1995 ] </ref> . The view of Prolog developed in that paper provides a clean separation between the inference rules and the search strategy, which makes the mathematics of Prolog considerably simpler. 3 For instance, the soundness of the calculus from [ Lifschitz, 1995 ] with respect to the completion semantics of [ Clark, 1978 ] can be verified by straightforward induction, and then the soundness of Prolog with respect to that semantics will immediately follow. The situation with the soundness of loop checking is similar, with an important difference. <p> Accordingly, we establish the soundness of loop checking relative to the well-founded semantics and the answer set semantics | representatives of the second group. In Section 2 we review the SLDNF calculus as defined in <ref> [ Lifschitz, 1995 ] </ref> , and then introduce its modification that is more convenient for our present purposes. The calculus for loop checking and its properties are discussed in Section 3. The calculus turns out to be sound and complete for finite programs under the well-founded semantics. <p> A program is a set of rules (not necessarily finite). 2.1 First Formulation A goal is a finite set of rule elements. In the SLDNF calculus of the first kind corresponding to a program <ref> [ Lifschitz, 1995 ] </ref> , the derivable objects are expressions of the forms j= G ("G succeeds") and =j G ("G fails"), where G is a goal. <p> As observed in <ref> [ Lifschitz, 1995 ] </ref> , Prolog can be viewed as proof search in the SLDNF calculus of the first kind. 2.2 Second Formulation In the SLDNF calculus of the second kind corresponding to a program , the derivable objects are expressions of the forms j= E and =j E, where E
Reference: [ Mints, 1986 ] <author> Grigori Mints. </author> <title> A complete calculus for pure Prolog. </title> <journal> Proc: Academy of Sciences of Estonian SSR, </journal> <volume> 35(4) </volume> <pages> 367-380, </pages> <year> 1986. </year> <note> In Russian. </note>
Reference-contexts: Section 5 contains proof outlines. 3 The SLDNF calculus is a reformulation of the inductive characterization of the success and failure of goals under SLDNF given in [ Kunen, 1989 ] , and is similar to the calculus proposed earlier in <ref> [ Mints, 1986 ] </ref> .
Reference: [ Przymusinski, 1990 ] <author> Teodor Przymusinski. </author> <title> The well-founded semantics coincides with the three-valued stable semantics. </title> <journal> Fundamenta Informaticae, </journal> <pages> pages 445-464, </pages> <year> 1990. </year>
Reference-contexts: The simplest example is p not p: (3) In the calculus corresponding to this program, one can derive neither j= p nor =j p. Since the answer set semantics is stronger than the well-founded semantics <ref> [ Przymusinski, 1990 ] </ref> , Theorem 2 implies that L is sound for the answer set semantics also: Corollary 2.
Reference: [ Przymusinski, 1991 ] <author> Teodor Przymusinski. </author> <title> Stable semantics for disjunctive programs. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 401-424, </pages> <year> 1991. </year>
Reference-contexts: On the basis of this definition, we prove the soundness and com-pleteness of query evaluation with loop checking for finite propositional programs under the well-founded semantics [ Van Gelder et al., 1990 ] , <ref> [ Przymusinski, 1991 ] </ref> . It follows that loop checking is also sound for the answer set ("stable model") semantics [ Gelfond and Lifschitz, 1991 ] . The mathematical theory of loop checking in logic programming is the subject of a recent dissertation [ Bol, 1991 ] .
Reference: [ Przymusinski, 1994 ] <author> Teodor Przymusinski. </author> <title> Well-founded and stationary models of logic programs. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 12 </volume> <pages> 141-187, </pages> <year> 1994. </year>
Reference-contexts: The well-founded model of a program can be described as the least fixpoint of an operator associated with this program ( <ref> [ Przymusinski, 1994 ] </ref> , Theorem 13). If I and J satisfy (WF1) and (WF2) then I [ :J is a pre-fixpoint of .
Reference: [ Van Gelder et al., 1990 ] <author> Allen Van Gelder, Kenneth Ross, and John Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> Journal of ACM, </journal> <pages> pages 221-230, </pages> <year> 1990. </year>
Reference-contexts: On the basis of this definition, we prove the soundness and com-pleteness of query evaluation with loop checking for finite propositional programs under the well-founded semantics <ref> [ Van Gelder et al., 1990 ] </ref> , [ Przymusinski, 1991 ] . It follows that loop checking is also sound for the answer set ("stable model") semantics [ Gelfond and Lifschitz, 1991 ] .
References-found: 13

