URL: http://www.cs.princeton.edu/~jlk/viz/tviz.ps
Refering-URL: http://www.cs.princeton.edu/~jlk/resh.html
Root-URL: http://www.cs.princeton.edu
Title: Traversal-based Visualization of Data Structures  
Author: Jeffrey L. Korn Andrew W. Appel 
Keyword: CR Descriptors: I.3.3 [Computer Graphics]: Picture/Image Generation Viewing Algorithms; D.1.7 [Programming Techinques]: Visual Programming; D.2.5 [Software Engineering]: Testing and Debugging Debugging aids.  
Affiliation: Department of Computer Science, Princeton University  
Abstract: Algorithm animation systems and graphical debuggers perform the task of translating program state into visual representations. While algorithm animations typically rely on user augmented source code to produce visualizations, debuggers make use of symbolic information in the target program. As a result, visualizations produced by debuggers often lack important semantic content, making them inferior to algorithm animation systems. This paper presents a method to provide higher-level, more informative visualizations in a debugger using a technique called traversal-based visualization. The debugger traverses a data structure using a set of user-supplied patterns to identify parts of the data structure to be drawn a similar way. A declarative language is used to specify the patterns and the actions to take when the patterns are encountered. Alternatively, the user can construct traversal specifications through a graphical user interface to the declarative language. Furthermore, the debugger supports modification of data. Changes made to the on-screen representation are reflected in the underlying data. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. A. Baeza-Yates, L. Jara, G. Quezada. VCC: </author> <title> Automatic Animations of C Programs Proceedings of Compugraphics, </title> <month> December </month> <year> 1992, </year> <month> 389397. </month>
Reference: [2] <author> M. Brown. </author> <title> Exploring Algorithms using Balsa-II IEEE Computer, </title> <address> 21(5):1436, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: Some recent PC and UNIX debuggers such as DDD [19] and Deet [5] provide visual representations of data structures. The pictures rendered by these debuggers are essentially mirror images of how the data is laid out in memory. This is in contrast to algorithm animation systems such as Balsa <ref> [2] </ref> and Zeus [3], where an animator has a finer level of control by hand crafting the pictures through the augmentation of source code with fl This work is supported in part by AASERT grant DAA G55-97-0209, DARPA order number E381, and NSF grant ASC-9612756.
Reference: [3] <author> M. Brown. Zeus: </author> <title> A System for Algorithm Animation and Multi-View Editing IEEE Workshop on Visual Languages, </title> <address> Kobe, Japan, </address> <year> 1991, </year> <month> 49. </month>
Reference-contexts: The pictures rendered by these debuggers are essentially mirror images of how the data is laid out in memory. This is in contrast to algorithm animation systems such as Balsa [2] and Zeus <ref> [3] </ref>, where an animator has a finer level of control by hand crafting the pictures through the augmentation of source code with fl This work is supported in part by AASERT grant DAA G55-97-0209, DARPA order number E381, and NSF grant ASC-9612756.
Reference: [4] <author> R. A. Duisberg. </author> <title> Visual Programming of Program Visualizations: A Gestural Interface for Animating Algorithms. </title> <booktitle> IEEE Workshop on Visual Languages, </booktitle> <address> Washington, D.C., </address> <year> 1987, </year> <pages> 55 66. </pages>
Reference: [5] <author> D. R. Hanson, J. L. Korn. </author> <title> A Simple and Extensible Graphical Debugger Proceedings of the Winter USENIX Technical Conference, </title> <address> Anaheim, CA, </address> <month> January </month> <year> 1997, </year> <month> 173184. </month>
Reference-contexts: Such visualization is also useful to a debugger, as it can help reveal which parts of the code are not functioning correctly. Some recent PC and UNIX debuggers such as DDD [19] and Deet <ref> [5] </ref> provide visual representations of data structures. The pictures rendered by these debuggers are essentially mirror images of how the data is laid out in memory. <p> This paper does not go into the details of the fundamental operations that the debugger provides such as stepping and setting breakpoints (see <ref> [5] </ref>), but instead focuses only on the visual display of values. Which objects are displayed and when they are displayed are something that the debugger needs to handle, but the discussion here focuses on how they are displayed. <p> The current implementation is approximately 9,000 lines of Java code. Debugger Interaction Our system uses an abstract interface to access symbol table information through a debugging library (not discussed here, see <ref> [5] </ref>). An advantage to having an abstract interface to the debugger is that we can switch between alternate implementations of the API. For example, there are two implementations in Java.
Reference: [6] <author> C. McCreary. </author> <title> The VGJ Graph Drawing Tool http://www.eng.auburn.edu/department/cse/ research/graph_drawing/vgj.html. </title>
Reference: [7] <author> T. Moher. </author> <title> PROVIDE: A Process Visualization and Debugging Environment IEEE Transactions on Software Engineering, </title> <address> 14(6):849857, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: In order to produce such visualization, there must be a way for the user to specify what the underlying data means. The PROVIDE debugger <ref> [7] </ref> was one of the earliest debuggers to add a level of abstraction to the visual display of data. With PROVIDE, users could select from a limited set of simple mappings that could display elements in the form of pie charts, bar graphs, etc.
Reference: [8] <author> S. Mukherjea, J. T. Stasko. </author> <title> Toward Visual Debugging: Integrating Algorithm Animation Capabilities within a Source-Level Debugger ACM Transactions on Computer-Human Interaction, </title> <booktitle> 1(3) </booktitle> <pages> 215-244, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: With PROVIDE, users could select from a limited set of simple mappings that could display elements in the form of pie charts, bar graphs, etc. More recent systems have attempted a more flexible and generalizable approach. The Lens debugger <ref> [8] </ref> attempts to use the techniques found in algorithm animation systems and apply them at the debugger level. Algorithm animation systems use interesting events for visualization, which identify key steps in the algorithm where visualization code is inserted.
Reference: [9] <author> D. Lieber. </author> <note> The Jikes Debugger http://www.alphaworks. ibm.com/formula/jikesdebugger. </note>
Reference-contexts: Suppose we are at a breakpoint and we wish to graphically display a tree of type Expr. Figure 6 shows how a typical graphical debugger might draw a tree instance without user input <ref> [9] </ref>. In fact, some existing debuggers are incapable of drawing this much. Since left and right are declared as type Expr but instances are always of one of Expr's subtypes, some debuggers will draw the fields as an Expr which contains no fields.
Reference: [10] <author> B. Myers. </author> <title> A System for Displaying Data Structures Computer Graphics, </title> <address> 17(3):115125, </address> <month> July </month> <year> 1983. </year>
Reference: [11] <author> S. North, E. Koutsofios. </author> <title> Applications of Graph Visualization Proceedings of Graphics Interface, </title> <booktitle> 1994, </booktitle> <pages> 235245. </pages>
Reference: [12] <author> S. P. Reiss, S. Meyers, C. Duby. </author> <booktitle> Using GELO to Visualize Software Systems Proceedings of the ACM SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <year> 1989, </year> <month> 149157. </month>
Reference: [13] <author> G.-C. Roman, K. Cox, C. Wilcox, J. Plun. Pavane: </author> <title> A System for Declarative Visualization of Concurrent Computations Journal of Visual Languages and Computing, </title> <booktitle> 3(1), Jan-uary 1992, </booktitle> <pages> 161193. </pages>
Reference-contexts: Declarative visualization is a method that defines mappings from program state to graphical objects. It depends solely on data, eliminating the need to know about a program's control flow. Thus, declarative visualization does not need access to the source code of the algorithm being debugged. A system called Pavane <ref> [13] </ref> uses the technique of declarative visualization. However, Pavane is not a debugging system it is used to visualize concurrent computations. Its mappings resemble predicate logic and visualization of a mapping requires an access to every object in the heap.
Reference: [14] <author> G.-C. Roman, K. Cox. </author> <title> A Declarative Approach to Visualizing Concurrent Computations Computer, </title> <address> 22(10):2536, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Another problem with interesting events is that they cannot be used to debug an already running program that has created data structures prior to being debugged. An alternative approach to interesting events, introduced by Roman <ref> [14] </ref>, is called declarative visualization. Declarative visualization is a method that defines mappings from program state to graphical objects. It depends solely on data, eliminating the need to know about a program's control flow. Thus, declarative visualization does not need access to the source code of the algorithm being debugged.
Reference: [15] <author> T. Shimomura, S. Isoda. </author> <title> Linked-List Visualization for Debugging IEEE Software, </title> <address> 8(3):4451, </address> <month> May </month> <year> 1991. </year>
Reference: [16] <author> J. Stasko, J. Domingue, M. Brown, B. </author> <title> Price, </title> <editor> editors. </editor> <publisher> Software Visualization MIT Press, </publisher> <month> February, </month> <year> 1998. </year>
Reference: [17] <author> Sun Microsystems. </author> <title> Java Foundation Classes http://java. sun.com/products/jfc. </title>
Reference: [18] <author> D. C. Wang, A. W. Appel, J. L. Korn and C. S. Serra. </author> <booktitle> The Zephyr Abstract Syntax Description Language USENIX Conference on Domain-Specific Languages, </booktitle> <address> Santa Barbara, </address> <month> Octo-ber </month> <year> 1997. </year>
Reference-contexts: Thus, we use an alternate implementation of the debugging functions (the Reflection API) to access the underlying objects. 6 DISCUSSION Preliminary results from the system have been promising. We have used it to put together visualizations for a project called Zephyr <ref> [18] </ref>. Zephyr provides a language for describing tree-like intermediate forms in compilers (for example, abstract-syntax trees), and includes a tool that generates data structures matching the descriptions. Our visualizations draw the intermediate forms graphically.
Reference: [19] <author> A. Zeller and D. L utkehaus. </author> <title> DDD a free graphical front-end for UNIX debuggers SIGPLAN Notices, </title> <address> 31(1):2227, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Such visualization is also useful to a debugger, as it can help reveal which parts of the code are not functioning correctly. Some recent PC and UNIX debuggers such as DDD <ref> [19] </ref> and Deet [5] provide visual representations of data structures. The pictures rendered by these debuggers are essentially mirror images of how the data is laid out in memory.
References-found: 19

