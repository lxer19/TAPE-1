URL: http://www.csl.sri.com/shankar/marktoberdorf96.ps.gz
Refering-URL: http://www.csl.sri.com/shankar/
Root-URL: 
Title: Machine-Assisted Verification Using Theorem Proving and Model Checking  
Author: M. Broy. N. Shankar 
Keyword: Mechanical verification, Theorem proving, Model checking  
Address: Menlo Park, CA 94025 USA  
Affiliation: 1 Computer Science Laboratory, SRI International,  
Note: To Appear in Mathematical Programming Methodology, (ed.)  
Abstract: Theorem proving and model checking are complementary approaches to the verification of hardware designs and software algorithms. In theorem proving, the verification task is one of showing that the formal description of the program implies the formal statement of a putative program property, while model checking demonstrates that the program is a model that satisfies the putative property. Theorem proving is completely general but typically requires significant human guidance, whereas model checking though restricted to a limited range of properties of small (essentially) finite-state systems, is largely automatic. This paper is a tutorial on the combined use of theorem proving and model checking as mechanized in the PVS specification and verification environment. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Each process has a stuttering (skip) transition to allow internal steps that have no effect on the observable state. The stuttering step allows for a refinement map to be established between the abstract and concrete transition systems <ref> [1] </ref>. <p> The type state is then checked to be finite and the formula is translated into the boolean mu-calculus and processed by a BDD-based validity checker. 27 safety : |------- <ref> [1] </ref> (FORALL (s: state): I (s) IMPLIES AG (G, safe)(s)) Rule? (model-check) . . . By rewriting and mu-simplifying, Q.E.D. The fixed point in the above case is computed in just two iterations by the BDD package and the BMC validity checking only takes milliseconds.
Reference: [2] <author> R. Alur, C. Courcoubetis, N. Halbwachs, T. A. Henzinger, P.-H. Ho, X. Nicollin, A. Olivero, J. Sifakis, and S. Yovine. </author> <title> The algorithmic analysis of hybrid systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 138(1) </volume> <pages> 3-34, </pages> <month> 6 February </month> <year> 1995. </year>
Reference: [3] <author> Rajeev Alur, Costas Courcoubetis, and David Dill. </author> <title> Model-checking in dense real-time. </title> <journal> Information and Computation, </journal> <volume> 104(1) </volume> <pages> 2-34, </pages> <month> May </month> <year> 1993. </year>
Reference: [4] <author> S. Bensalem, Y. Lakhnech, and H. Saidi. </author> <title> Powerful techniques for the automatic generation of invariants. </title> <editor> In Rajeev Alur and Tom Henzinger, editors, </editor> <booktitle> Computer-Aided Verification96, Lecture Notes in Computer Science, </booktitle> <address> New Brunswick, NJ, </address> <month> July </month> <year> 1996. </year> <note> Springer Verlag. To appear. </note>
Reference: [5] <author> Nikolaj Bjtrner, Anca Browne, and Zohar Manna. </author> <title> Automatic generation of invariants and intermediate assertions. </title> <editor> In Ugo Montanari and Francesca Rossi, editors, </editor> <booktitle> Principles and Practice of Constraint Programming - CP '95, volume 976 of Lecture Notes in Computer Science, </booktitle> <address> Cas-sis, France, 1995. </address> <publisher> Springer Verlag. </publisher>
Reference: [6] <author> K. S. Brace, R. L. Rudell, and R. E. Bryant. </author> <title> Efficient implementation of a BDD package. </title> <booktitle> In Proc. of the 27th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 40-45, </pages> <year> 1990. </year>
Reference: [7] <author> R. E. Bryant. </author> <title> Graph-based algorithms for Boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference: [8] <author> Randal E. Bryant. </author> <title> Symbolic boolean manipulation with ordered binary-decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <month> September </month> <year> 1992. </year>
Reference: [9] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-170, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: We first examine the formalization of a fixed point calculus, the mu-calculus, in PVS before presenting the definitions of the CTL operators. 3.3.1 The Boolean Mu-Calculus The boolean mu-calculus (BMC) <ref> [9, 29] </ref> consists of boolean formulas and nary boolean predicates. 5 Boolean formulas are built from the truth values TRUE and FALSE and the atomic propositions, e.g., a, b, c, by means of negation :A, disjunction A _ B, boolean quantification 9x: A [x] or 8x: A [x], or by the
Reference: [10] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: To summarize the main points: * A shared state, interleaving model of concurrent programs such as those used by Manna and Pnueli's temporal logic [24], UNITY <ref> [10] </ref>, and TLA [21] can be formalized by means of predicates, relations, and sequences in a higher-order logic such as HOL [16, 17] or PVS [27]. * With sufficiently powerful mechanization based on term rewriting and decision procedures, it is possible to construct mechanically verified proofs of program properties that are
Reference: [11] <author> E. Clarke, O. Grumberg, and D. </author> <title> Long. Verification tools for finite-state concurrent systems. </title> <editor> In J. W. de Bakker, W.-P.de Roever, and G. Rozen-berg, editors, </editor> <title> A Decade of Concurrency: Reflections and Perspectives, </title> <booktitle> volume 803 of Lecture Notes in Computer Science, </booktitle> <pages> pages 124-175, </pages> <address> No-ordewijkerhout, The Netherlands, 1994. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: It is clearly more expedient to carry out such verifications by means of an exhaustive exploration of the reachable state space as is done with model checking <ref> [11, 12] </ref>. Model checking technology has developed to a point where it is possible to deal with quite large state spaces. It has also been extended to handle real-time constraints where the state space is actually uncountable [2,3].
Reference: [12] <author> E. M. Clarke and O. Grumberg. </author> <title> Research on automatic verication of finite state concurrent systems. </title> <booktitle> In Annual Review of Computer Science, </booktitle> <pages> pages 269-290. </pages> <publisher> Annual Reviews, Inc., </publisher> <year> 1987. </year>
Reference-contexts: It is clearly more expedient to carry out such verifications by means of an exhaustive exploration of the reachable state space as is done with model checking <ref> [11, 12] </ref>. Model checking technology has developed to a point where it is possible to deal with quite large state spaces. It has also been extended to handle real-time constraints where the state space is actually uncountable [2,3].
Reference: [13] <author> Costas Courcoubetis, </author> <title> editor. Computer-Aided Verification, </title> <booktitle> CAV '93, volume 697 of Lecture Notes in Computer Science, </booktitle> <address> Elounda, Greece, June/July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference: [14] <author> David Cyrluk. </author> <title> Inverting the abstraction mapping: A methodology for hardware verification. </title> <booktitle> In Srivas and Camilleri [33], </booktitle> <pages> pages 172-186. </pages>
Reference-contexts: The ideas and implementation underlying PVS are still undergoing development but the system has already been used in some substantial verification projects. These projects include the verification of hardware processors <ref> [14, 25] </ref>, floating-point hardware [26, 31], real-time, distributed, and fault-tolerant algorithms [18,22,23,32], and in the construction of background libraries for use in verification. This paper is a tutorial on the use of PVS for mechanized verification.
Reference: [15] <author> E. Allen Emerson and Chin-Laung Lei. </author> <title> Efficient model checking in fragments of the propositional mu-calculus (extended abstract). </title> <booktitle> In Proceedings, Symposium on Logic in Computer Science, </booktitle> <pages> pages 267-278, </pages> <address> Cam-bridge, Massachusetts, 16-18 June 1986. </address> <publisher> IEEE Computer Society. </publisher>
Reference: [16] <author> M. J. C. Gordon and T. F. Melham, </author> <title> editors. Introduction to HOL: </title>
Reference-contexts: To summarize the main points: * A shared state, interleaving model of concurrent programs such as those used by Manna and Pnueli's temporal logic [24], UNITY [10], and TLA [21] can be formalized by means of predicates, relations, and sequences in a higher-order logic such as HOL <ref> [16, 17] </ref> or PVS [27]. * With sufficiently powerful mechanization based on term rewriting and decision procedures, it is possible to construct mechanically verified proofs of program properties that are faithful to their informal coun terparts. * Failed invariance proofs can be used to diagnose the source of the fail ure. <p> The main conclusions to be drawn from this exercise are: * The key concepts and logics used in the formalization of simple transition systems can be captured in a higher-order logic such as that of HOL <ref> [16] </ref> or PVS [28]. * Model checking and automated theorem proving are complementary but compatible verification techniques. * Symbolic model checking using BDDs can be viewed as a decision pro cedure for a well-defined fragment of the PVS logic. * The same representation of transition systems can be used as a
References-found: 16

