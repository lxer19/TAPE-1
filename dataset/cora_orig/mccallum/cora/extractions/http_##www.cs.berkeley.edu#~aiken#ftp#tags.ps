URL: http://www.cs.berkeley.edu/~aiken/ftp/tags.ps
Refering-URL: http://www.cs.berkeley.edu/~aiken/pubs.html
Root-URL: 
Email: faiken,manuelg@cs.berkeley.edu  
Title: Dynamic Typing and Subtype Inference  
Author: Alexander Aiken Manuel Fahndrich 
Address: Berkeley, CA 94720-1776  
Affiliation: Computer Science Division University of California, Berkeley  
Abstract: Dynamic typing is a program analysis targeted at removing runtime tagging and untagging operations in dynamically typed languages. This paper shows that dynamic typing at least as powerful as Henglein's system [Hen92b] can be expressed using set constraints. 
Abstract-found: 1
Intro-found: 1
Reference: [Aik94] <author> A. Aiken. </author> <title> Set constraints: Results, applications, and future directions. </title> <booktitle> In Second Workshop on the Principles and Practice of Constraint Programming, </booktitle> <pages> pages 171-179, </pages> <address> Orcas Island, Washingtion, </address> <month> May </month> <year> 1994. </year> <note> Springer-Verlag LNCS no. 874. </note>
Reference-contexts: It is our thesis that many constraint-based analyses can be expressed using a particular constraint theory known as set constraints. Set constraints are a simple, general, and well-studied theory that is powerful enough to express many program analyses <ref> [HJ90, AW92, Hei92, Aik94] </ref>. In testing our thesis, it became apparent that dynamic typing is in some ways fundamentally different from other examples of constraint theories used in program analysis. The main technical challenge, and our central result, is establishing that set constraints can encode dynamic typing.
Reference: [AM91] <author> A. Aiken and B. Murphy. </author> <title> Static type inference in a dynamically typed language. </title> <booktitle> In Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 279-290, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Coercions from type Dynamic were introduced in a subsequent paper [Tha90]; as discussed in Section 3, this is not subtyping. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years <ref> [Gom90, AM91, CF91, Hen92b, WH92, WC94] </ref>. With the exception of the works of Henglein, Thatte, and Gomard, it is fair to characterize all of these systems as based on subtyping; none treat tag inference.
Reference: [AW92] <author> A. Aiken and E. Wimmers. </author> <title> Solving systems of set constraints. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 329-340, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: It is our thesis that many constraint-based analyses can be expressed using a particular constraint theory known as set constraints. Set constraints are a simple, general, and well-studied theory that is powerful enough to express many program analyses <ref> [HJ90, AW92, Hei92, Aik94] </ref>. In testing our thesis, it became apparent that dynamic typing is in some ways fundamentally different from other examples of constraint theories used in program analysis. The main technical challenge, and our central result, is establishing that set constraints can encode dynamic typing. <p> These constraint resolution rules are essentially those of [MR85, Hei92, AW93] specialized to our application. The soundness of these rules can be proven using standard techniques (e.g., see <ref> [AW92, AW93] </ref>). In Figure 6, stands for an arbitrary type expression and fl stands for an arbitrary variable. Rules 10 and 11 of Figure 6 appear non-constructive, but are actually easy to implement.
Reference: [AW93] <author> A. Aiken and E. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming 10 Languages and Computer Architecture, pages 31--41, </booktitle> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: For brevity, we skip the development of ideal models needed to formalize types as sets of values; the construction is well-known (e.g., see <ref> [MPS84, AW93] </ref>). We work with systems of set constraints of the following forms: X Y Q 6= tag [ notag A 6= 0 ) Q R Here X, Y stand for any expressions drawn from the grammar above. <p> To discover which completions are possible, it is necessary to solve the constraints. Figure 6 gives a set of rewrite rules that, when applied until closure (until no new constraints can be generated), reduce a system of constraints to solved form. These constraint resolution rules are essentially those of <ref> [MR85, Hei92, AW93] </ref> specialized to our application. The soundness of these rules can be proven using standard techniques (e.g., see [AW92, AW93]). In Figure 6, stands for an arbitrary type expression and fl stands for an arbitrary variable. <p> These constraint resolution rules are essentially those of [MR85, Hei92, AW93] specialized to our application. The soundness of these rules can be proven using standard techniques (e.g., see <ref> [AW92, AW93] </ref>). In Figure 6, stands for an arbitrary type expression and fl stands for an arbitrary variable. Rules 10 and 11 of Figure 6 appear non-constructive, but are actually easy to implement.
Reference: [AWL94] <author> A. Aiken, E. Wimmers, </author> <title> and T.K. Lakshman. Soft typing with conditional types. </title> <booktitle> In Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: The purpose and results of our study are two-fold. First, while dynamic typing is a very interesting system, it cannot remove as many type checks as other recently proposed algorithms based on subtyping <ref> [AWL94, WC94] </ref>. However, as noted above, dynamic typing has the singular ability to remove type tagging operations as well. Thus, the power of dynamic typing is incomparable to the subtyping approaches. <p> Rewriting the inference rules in this way is straightforward. The analysis of constraint resolution is unaffected by this change, so this system also has minimal completions. 6.3 Polymorphism The semantics of polymorphic types based on set constraints has been developed in <ref> [AWL94] </ref>. A polymorphic type has the form 8fl 1 ; : : : ; fl n :( where S). Intuitively, this type expresses bounded quantification, with the set of constraints S acting as bounds on the quantified variables. <p> More formally, the meaning is the intersection of all types s () where s is a solution of the constraints S for some choice of fl 1 ; : : : ; fl n . Polymorphism in the style of <ref> [AWL94] </ref> can be added to our system without modifying any other aspect. When tag variables are quantified, the meaning of coercions is parameterized in the type. <p> Thus, the same technique should integrate easily into other systems for analyzing dynamically typed programs. The system in <ref> [AWL94] </ref> is probably the most expressive and accurate such inference system known. We can report that it is in fact straightforward to adapt the techniques reported in this paper to the system of [AWL94], although we must unfortunately omit all details for lack of space. <p> The system in <ref> [AWL94] </ref> is probably the most expressive and accurate such inference system known. We can report that it is in fact straightforward to adapt the techniques reported in this paper to the system of [AWL94], although we must unfortunately omit all details for lack of space.
Reference: [CF91] <author> R. Cartwright and M. Fagan. </author> <title> Soft typing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 278-292, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Currently, the main application of dynamic typing is the optimization of programs written in dynamically typed languages (such as Lisp and Scheme) by removing runtime tests of type tags where they are provably unnecessary (so-called soft typing <ref> [CF91, WC94] </ref>). A remarkable, and to our knowledge unique, aspect of dynamic typing is that it not only permits the removal of dynamic type tag tests, but also allows the elimination of type tagging operations themselves. The purpose and results of our study are two-fold. <p> Coercions from type Dynamic were introduced in a subsequent paper [Tha90]; as discussed in Section 3, this is not subtyping. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years <ref> [Gom90, AM91, CF91, Hen92b, WH92, WC94] </ref>. With the exception of the works of Henglein, Thatte, and Gomard, it is fair to characterize all of these systems as based on subtyping; none treat tag inference.
Reference: [Gom90] <author> C. Gomard. </author> <title> Partial type inference for untyped functional programs (extended abstract). </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 282-287, </pages> <year> 1990. </year>
Reference-contexts: Besides previous work on program analysis using set constraints, Henglein's work on dynamic typing is the most closely related to our own. Henglein's work is based, in turn, on earlier works of Thatte and Gomard <ref> [Gom90] </ref> . Thatte originally worked with a system called partial types [Tha88], in which types could be coerced to a universal type, but not vice versa|a pure subtyping system. Coercions from type Dynamic were introduced in a subsequent paper [Tha90]; as discussed in Section 3, this is not subtyping. <p> Coercions from type Dynamic were introduced in a subsequent paper [Tha90]; as discussed in Section 3, this is not subtyping. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years <ref> [Gom90, AM91, CF91, Hen92b, WH92, WC94] </ref>. With the exception of the works of Henglein, Thatte, and Gomard, it is fair to characterize all of these systems as based on subtyping; none treat tag inference.
Reference: [Hei92] <author> N. Heintze. </author> <title> Set Based Program Analysis. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: It is our thesis that many constraint-based analyses can be expressed using a particular constraint theory known as set constraints. Set constraints are a simple, general, and well-studied theory that is powerful enough to express many program analyses <ref> [HJ90, AW92, Hei92, Aik94] </ref>. In testing our thesis, it became apparent that dynamic typing is in some ways fundamentally different from other examples of constraint theories used in program analysis. The main technical challenge, and our central result, is establishing that set constraints can encode dynamic typing. <p> To discover which completions are possible, it is necessary to solve the constraints. Figure 6 gives a set of rewrite rules that, when applied until closure (until no new constraints can be generated), reduce a system of constraints to solved form. These constraint resolution rules are essentially those of <ref> [MR85, Hei92, AW93] </ref> specialized to our application. The soundness of these rules can be proven using standard techniques (e.g., see [AW92, AW93]). In Figure 6, stands for an arbitrary type expression and fl stands for an arbitrary variable. <p> Once no constraints can be added, any remaining implication constraints can be deleted using Rule 11. A detailed justification is presented in <ref> [Hei92] </ref>. Constraint resolution is the most expensive phase. The rewrite rules work only with pairs of subexpressions of the original constraint system. Thus, the rules can produce at most O (n 2 ) constraints, where original system has size O (n).
Reference: [Hen92a] <author> F. Henglein. </author> <title> Dynamic typing. </title> <booktitle> In Proceedings of the Eurpean Symposium on Programming, </booktitle> <month> Febru-ary </month> <year> 1992. </year>
Reference-contexts: 1 Introduction This paper presents a study of Henglein's dynamic typing discipline <ref> [Hen92a, Hen92b] </ref>. Dynamic typing extends conventional static types with a single new type Dynamic. Special functions called coercions inject values into and project values from type Dynamic. <p> However, the set constraint formulation does not naturally suggest the very efficient resolution algorithms known for dynamic typing [Hen92b]; in this respect, dynamic typing appears to stand apart. The rest of this section presents an overview of the paper. Some basic definitions are needed. Following <ref> [Hen92a] </ref>, our results are presented using a small, paradigmatic language called dynamically typed lambda calculus. <p> We are free to choose among correct completions, though completions with fewer coercions are preferred for efficiency reasons. Thus, the goal of dynamic typing is to compute a correct completion with as few coercions as possible. Dynamic typing, as formulated in <ref> [Hen92a] </ref>, has computable minimal completions. A completion e 0 of e is minimal if every derivable completion of e includes all the coercions of e 0 . Two examples are given in Figure 1. The first example shows two completions of the term (x:x)(y:y). <p> type of the function that results, so it must have type FUNC? : Dynamic ; (Dynamic ! Dynamic), which forces the components of the function type to also be tagged and tested at runtime. (The use of ; instead of ! in the type is for consistency with notation in <ref> [Hen92b, Hen92a] </ref> and emphasizes the special role of coercions.) This fact is central to dynamic typing: if a value has type Dynamic, then all of its components must have type Dynamic. <p> We also consider a variation of dynamic typing where coercions may appear at points other than value creations and uses. (We do not consider induced coercions, another variation on dynamic typing in Henglein's original work <ref> [Hen92a] </ref>.) Finally, we report that the set constraint system can be incorporated into the most expressive system known for removing type tags, although in this case there are no longer minimal completions and constraint resolution becomes inherently exponential.
Reference: [Hen92b] <author> F. Henglein. </author> <title> Global tagging optimization by type inference. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 205-215, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: 1 Introduction This paper presents a study of Henglein's dynamic typing discipline <ref> [Hen92a, Hen92b] </ref>. Dynamic typing extends conventional static types with a single new type Dynamic. Special functions called coercions inject values into and project values from type Dynamic. <p> The main technical challenge, and our central result, is establishing that set constraints can encode dynamic typing. This characterization facilitates direct comparison of dynamic typing with other constraint-based analyses. However, the set constraint formulation does not naturally suggest the very efficient resolution algorithms known for dynamic typing <ref> [Hen92b] </ref>; in this respect, dynamic typing appears to stand apart. The rest of this section presents an overview of the paper. Some basic definitions are needed. Following [Hen92a], our results are presented using a small, paradigmatic language called dynamically typed lambda calculus. <p> type of the function that results, so it must have type FUNC? : Dynamic ; (Dynamic ! Dynamic), which forces the components of the function type to also be tagged and tested at runtime. (The use of ; instead of ! in the type is for consistency with notation in <ref> [Hen92b, Hen92a] </ref> and emphasizes the special role of coercions.) This fact is central to dynamic typing: if a value has type Dynamic, then all of its components must have type Dynamic. <p> Coercions from type Dynamic were introduced in a subsequent paper [Tha90]; as discussed in Section 3, this is not subtyping. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years <ref> [Gom90, AM91, CF91, Hen92b, WH92, WC94] </ref>. With the exception of the works of Henglein, Thatte, and Gomard, it is fair to characterize all of these systems as based on subtyping; none treat tag inference.
Reference: [HJ90] <author> N. Heintze and J. Jaffar. </author> <title> A decision procedure for a class of Herbrand set constraints. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 42-51, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: It is our thesis that many constraint-based analyses can be expressed using a particular constraint theory known as set constraints. Set constraints are a simple, general, and well-studied theory that is powerful enough to express many program analyses <ref> [HJ90, AW92, Hei92, Aik94] </ref>. In testing our thesis, it became apparent that dynamic typing is in some ways fundamentally different from other examples of constraint theories used in program analysis. The main technical challenge, and our central result, is establishing that set constraints can encode dynamic typing.
Reference: [MPS84] <author> D. MacQueen, G. Plotkin, and R. Sethi. </author> <title> An ideal model for recursive polymophic types. </title> <booktitle> In Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 165-174, </pages> <month> Jan-uary </month> <year> 1984. </year>
Reference-contexts: For brevity, we skip the development of ideal models needed to formalize types as sets of values; the construction is well-known (e.g., see <ref> [MPS84, AW93] </ref>). We work with systems of set constraints of the following forms: X Y Q 6= tag [ notag A 6= 0 ) Q R Here X, Y stand for any expressions drawn from the grammar above.
Reference: [MR85] <author> P. Mishra and U. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Proceedings of the Twelfth Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 7-21, </pages> <year> 1985. </year>
Reference-contexts: To discover which completions are possible, it is necessary to solve the constraints. Figure 6 gives a set of rewrite rules that, when applied until closure (until no new constraints can be generated), reduce a system of constraints to solved form. These constraint resolution rules are essentially those of <ref> [MR85, Hei92, AW93] </ref> specialized to our application. The soundness of these rules can be proven using standard techniques (e.g., see [AW92, AW93]). In Figure 6, stands for an arbitrary type expression and fl stands for an arbitrary variable.
Reference: [Tha88] <author> S. Thatte. </author> <title> Type inference with partial types. </title> <booktitle> In Automata, Languages and Programming: 15th International Colloquium, </booktitle> <pages> pages 615-629. </pages> <booktitle> Springer-Verlag Lecture Notes in Computer Science, </booktitle> <volume> vol. 317, </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: Besides previous work on program analysis using set constraints, Henglein's work on dynamic typing is the most closely related to our own. Henglein's work is based, in turn, on earlier works of Thatte and Gomard [Gom90] . Thatte originally worked with a system called partial types <ref> [Tha88] </ref>, in which types could be coerced to a universal type, but not vice versa|a pure subtyping system. Coercions from type Dynamic were introduced in a subsequent paper [Tha90]; as discussed in Section 3, this is not subtyping.
Reference: [Tha90] <author> S. Thatte. </author> <title> Quasi-static typing. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-381, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Thatte originally worked with a system called partial types [Tha88], in which types could be coerced to a universal type, but not vice versa|a pure subtyping system. Coercions from type Dynamic were introduced in a subsequent paper <ref> [Tha90] </ref>; as discussed in Section 3, this is not subtyping. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years [Gom90, AM91, CF91, Hen92b, WH92, WC94].
Reference: [WC94] <author> A. Wright and R. Cartwright. </author> <title> A practical soft typing system for scheme. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <month> June </month> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: Currently, the main application of dynamic typing is the optimization of programs written in dynamically typed languages (such as Lisp and Scheme) by removing runtime tests of type tags where they are provably unnecessary (so-called soft typing <ref> [CF91, WC94] </ref>). A remarkable, and to our knowledge unique, aspect of dynamic typing is that it not only permits the removal of dynamic type tag tests, but also allows the elimination of type tagging operations themselves. The purpose and results of our study are two-fold. <p> The purpose and results of our study are two-fold. First, while dynamic typing is a very interesting system, it cannot remove as many type checks as other recently proposed algorithms based on subtyping <ref> [AWL94, WC94] </ref>. However, as noted above, dynamic typing has the singular ability to remove type tagging operations as well. Thus, the power of dynamic typing is incomparable to the subtyping approaches. <p> Coercions from type Dynamic were introduced in a subsequent paper [Tha90]; as discussed in Section 3, this is not subtyping. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years <ref> [Gom90, AM91, CF91, Hen92b, WH92, WC94] </ref>. With the exception of the works of Henglein, Thatte, and Gomard, it is fair to characterize all of these systems as based on subtyping; none treat tag inference.
Reference: [WH92] <author> E. Wang and P. N. Hilfinger. </author> <title> Analysis of recursive types in Lisp-like languages. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 216-225, </pages> <month> June </month> <year> 1992. </year> <month> 11 </month>
Reference-contexts: Coercions from type Dynamic were introduced in a subsequent paper [Tha90]; as discussed in Section 3, this is not subtyping. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years <ref> [Gom90, AM91, CF91, Hen92b, WH92, WC94] </ref>. With the exception of the works of Henglein, Thatte, and Gomard, it is fair to characterize all of these systems as based on subtyping; none treat tag inference.
References-found: 17

