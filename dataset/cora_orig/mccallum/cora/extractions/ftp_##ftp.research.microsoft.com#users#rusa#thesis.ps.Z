URL: ftp://ftp.research.microsoft.com/users/rusa/thesis.ps.Z
Refering-URL: http://www.research.microsoft.com/~rusa/papers.html
Root-URL: http://www.research.microsoft.com
Email: rusa@diku.dk  
Title: Partial Evaluation of an Object-Oriented Imperative Language  
Author: Morten Marquard Bjarne Steensgaard 
Date: April 30, 1992  September 25, 1992)  
Note: Electronic mail: marquard@diku.dk or  (printed  
Address: Universitetsparken 1, DK-2100 Copenhagen Denmark  
Affiliation: Department of Computer Science University of Copenhagen  
Abstract-found: 0
Intro-found: 1
Reference: [Aho 86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <title> Compilers | Principles, Techniques and Tools. Student Series. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year> <note> (The Dragon Book). </note>
Reference-contexts: We do not want to collect this kind of garbage objects as we do not think the extra computation cost is worthwhile. If two local variables are alive <ref> [Aho 86] </ref> in nonoverlapping parts of a method body, then the two variables may be replaced by one. Having the partial evaluator perform this transformation may make the residual program harder to read, and a good optimizing compiler would perform the optimization anyway. <p> The analysis is an add-on to an abstract interpretation similar to the one described in Chapter 7 or later. We will only list the important additions to the 1 We have used defined rather than modified to follow the terminology used in e.g. <ref> [Aho 86] </ref>. Chapter 10 Reusing Computations 173 deduction rules. Combining the rules is left to the reader. In the rules presented in this section some semantic objects may seemingly pop up out of the blue but are really just "imported" from the abstract interpretation rules.
Reference: [Andersen 91a] <author> Birger Andersen. </author> <title> Ellie Language Definition Report. </title> <type> Technical Report 91/3, </type> <institution> DIKU, University of Copenhagen, Denmark, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: In pure languages, all data is represented by objects. That means that integers, floating point numbers, characters and filesystems all are represented as objects. Some object-oriented languages like Smalltalk [Goldberg 89] and Ellie <ref> [Andersen 91a] </ref> also 28 Partial Evaluation of an OO-Language, September 25, 1992 represent language constructions like if- and loop-constructions as objects. In the hybrid languages, there is a mixture of objects and other data entities as we know them from other programming languages like Pascal, C, Lisp, ML, etc.
Reference: [Andersen 91b] <author> L.O. Andersen. </author> <title> C Program Specialization. </title> <type> Master's thesis, </type> <institution> DIKU, University of Copenhagen, Denmark, </institution> <month> December </month> <year> 1991. </year> <title> DIKU Student Project 91-12-17, </title> <booktitle> 128 pages. </booktitle>
Reference-contexts: With the construction of the partial evaluator the first of the theses listed in Section 5.2 is proved. The second these cannot be said to be proved or disproved. Using objects it is possible to avoid a type analysis as required when performing partial evaluation of e.g. C <ref> [Andersen 91b] </ref>. The objects take the place of the types. On the other hand a number of other problems are introduced because objects are first class higher order values and because state is enclosed in objects.
Reference: [Andersen 92] <author> L.O. Andersen and C.K. Gomard. </author> <title> Speedup Analysis in Partial Evaluation (Preliminary Results). In Partial Evaluation and Semantics-Based Program Manipulation, </title> <address> San Francisco, California, </address> <month> June </month> <year> 1992. </year> <type> (Technical Report YALEU/DCS/RR-909, </type> <institution> Yale University), </institution> <address> pages 1-7. </address> <year> 1992. </year>
Reference-contexts: A speedup between 5 and 50 is normal. Recently research has commenced on techniques to predict the speedup before partial evaluation is performed <ref> [Andersen 92] </ref>. There is a question to consider when talking about partial evaluation.
Reference: [Appel 88] <author> Andrew W. Appel, Bruce F. Duba, and David B. MacQueen. </author> <title> Profiling in the Presence of Optimization and Garbage Collection. As a part of the New Jersey compiler documentation., </title> <month> November </month> <year> 1988. </year>
Reference-contexts: The flexible module system and the strong type system that ensures consistency across modules is what makes this style possible and desirable. We have used the execution time profiler delivered with the New Jersey ML compiler <ref> [Appel 88] </ref>. With this system, we found that we had to implement a new abstract data type and reimplement others from the library. These simple changes cut down execution times approximately 80%. Unfortunately there is no usable trace or debugging facilities with the New Jersey ML compiler.
Reference: [Appel 89] <author> Andrew W. Appel, James S. Mattson, and David R. Tarditi. </author> <title> A lexical analyzer generator for Standard ML. </title> <publisher> Princeton University, </publisher> <address> 1.3 edition, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: Module Lines Bytes Section Parser 2.442 65.525 12.2 Interpreter 7.603 257.898 12.3 Partial Evaluator 13.870 423.474 12.4 Self-interpreter 2.900 84.888 12.5 Test examples 1.939 47.273 12.6 Table 12.1: The code in the system 12.2 The extended parser We have used the ML-version of lex <ref> [Appel 89] </ref> and yacc [Tarditi 90] to implement a parser to convert a string into the sugared or unsugared abstract syntax. After parsing the basic blocks are split as described in Section 8.1.5. The result is a syntax tree.
Reference: [Berlin 90] <author> Andrew Berlin and Daniel Weise. </author> <title> Compiling Scientific Code using Partial Evaluation. </title> <type> Technical Report CSL-TR-90-422, </type> <institution> MIT and Stanford, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: Partial evaluation has also with success been applied to scientific computing. Here the online partial evaluator Fuse has been used. The reported problems handled successfully include the N-body problem (speedup around a factor of 40) and numerical integration using Runge-Kutta integration (speedup around a factor of 7) <ref> [Berlin 90] </ref>. An interesting observation was that the residual code was more suited for parallelization than the source program code. Yet another application area of partial evaluation is spreadsheets.
Reference: [Berry 91] <editor> Dave Berry. </editor> <address> The Edinburgh SML Library. </address> <month> October </month> <year> 1991. </year>
Reference-contexts: We have also tried using the PolyML compiler but the attempt failed due to lack of documentation. The Edinburgh Library states some conventions for writing modules and uses the make system within the library itself <ref> [Berry 91, Chapter 3 and 4] </ref>.
Reference: [Black 91] <author> Andrew Black. </author> <title> Types and Polymorphism in Emerald. </title> <institution> In [?]. Computer Science Department, Aarhus University, </institution> <year> 1991. </year>
Reference-contexts: If the first approach can be regarded as a valid approach to inheritance, then inheritance is nothing but an advanced form of syntactic sugar. There is general agreement that subtyping and subclassing is not the same thing <ref> [Black 91] </ref>, [Fischback 91], [Hutchinson 91], [Palsberg 91b]. Many people in the object-oriented community does however not like to think of inheritance as syntactic sugar. <p> The idea of subtyping is that wherever an instance of a type can be used so can instances of its subtypes. Researchers working with type systems in object-oriented languages now generally agree that the class hierarchy should be separated from the type hierarchy <ref> [Black 91] </ref>, 31 32 Partial Evaluation of an OO-Language, September 25, 1992 [Fischback 91], [Hutchinson 91], [Palsberg 91b]. In untyped languages and in languages where types are unrelated to inheritance, inheritance is only a textual sort-hand used to reuse code and save the programmer some work [Palsberg 91b].
Reference: [Blair 89] <author> Gordon S. Blair, John J. Gallagher, and Javad Malik. </author> <title> Genericity vs Inheritance vs Delegation vs Conformance vs . . . . Journal of Object-Oriented Programming 11-17, </title> <note> September/October 1989. 220 Chapter 14 Conclusion 221 </note>
Reference-contexts: Trellis/Owl [Schaffert 86], Eiffel [Meyer 90], Emerald [Raj 91] and Self [Ungar 87]. There is not general agreement on a definition of what requirements a language should fulfill to be regarded as object-oriented. There are several definitions, of which [Wegner 86], [Meyer 88], [Booch 91], and <ref> [Blair 89] </ref> are the most used. The oldest and 21 22 Partial Evaluation of an OO-Language, September 25, 1992 most widely known definition is [Wegner 86]. The one closest to our perception of object-orientedness is [Blair 89]. <p> There are several definitions, of which [Wegner 86], [Meyer 88], [Booch 91], and <ref> [Blair 89] </ref> are the most used. The oldest and 21 22 Partial Evaluation of an OO-Language, September 25, 1992 most widely known definition is [Wegner 86]. The one closest to our perception of object-orientedness is [Blair 89]. The definitions in [Meyer 88] and [Booch 91] are taught to many newcomers to the area of object-oriented programming. Not all languages that are object-oriented according to one definition will be object-oriented according to another definition. <p> A more formal definition of the conformance relation can be found in <ref> [Blair 89] </ref>. Inheritance Inheritance is a mechanism originating from Simula, that makes it possible to create new classes by extending or specializing existing classes. The new class is a subclass of the original one; the old a superclass of the new.
Reference: [Bobrow 86] <author> Daniel G. Bobrow, Linda G. DeMichiel, Richard P. Gabriel, Sonya Keene, Gregor Kiczales, and David A. Moon. </author> <title> Common Lisp Object System Specification. </title> <type> ANSI Report X3J13 Document 87-002, </type> <institution> ANSI, </institution> <year> 1986. </year>
Reference-contexts: In the hybrid languages, there is a mixture of objects and other data entities as we know them from other programming languages like Pascal, C, Lisp, ML, etc. Examples of hybrid object-oriented languages are C++ [Stroustrup 86], CLOS <ref> [Bobrow 86] </ref>, and Eiffel [Meyer 90]. There may be a lot of reasons for using hybrid languages. One reason that is valid for languages like e.g.
Reference: [Bondorf 88] <author> A. Bondorf, N.D. Jones, T. Mogensen, and P. Sestoft. </author> <title> Binding Time Analysis and the Taming of Self-Application. </title> <type> Draft, </type> <pages> 18 pages, </pages> <institution> DIKU, University of Copenhagen, Denmark, </institution> <month> August </month> <year> 1988. </year>
Reference-contexts: We will not describe the actual workings of a binding time analysis. The interested reader is referred to [Henglein 91], [Bondorf 90b] [Bondorf 90a], [Consel 90], <ref> [Bondorf 88] </ref>, [Nielson 88]. O*ine partial evaluators for higher order languages does usually also have a closure analysis in the prephase. The result of a closure analysis is some information about what closures may be applied at the application points in the program.
Reference: [Bondorf 90a] <author> A. Bondorf. </author> <title> Automatic Autoprojection of Higher Order Recursive Equations. </title> <editor> In Neil D. Jones (editor), </editor> <booktitle> ESOP '90. 3rd European Symposium on Programming, </booktitle> <address> Copenhagen, Denmark, </address> <month> May </month> <year> 1990. </year> <booktitle> (Lecture Notes in Computer Science, </booktitle> <volume> vol. 432), </volume> <pages> pages 70-87. </pages> <publisher> Springer-Verlag, </publisher> <month> May </month> <year> 1990. </year> <note> Revised version in </note> [?]. 
Reference-contexts: We will not describe the actual workings of a binding time analysis. The interested reader is referred to [Henglein 91], [Bondorf 90b] <ref> [Bondorf 90a] </ref>, [Consel 90], [Bondorf 88], [Nielson 88]. O*ine partial evaluators for higher order languages does usually also have a closure analysis in the prephase. The result of a closure analysis is some information about what closures may be applied at the application points in the program. <p> The source language is a subset of Scheme. Developed here at dikuby Anders Bondorf and Olivier Danvy. Uses abstract interpretation in the binding time analysis and closure analysis. Cannot handle partially static structures 3 . A fully automatic nontrivial partial evaluator <ref> [Bondorf 90a] </ref>. Fuse An online partial evaluator for a subset of Scheme. Most termination difficulties are overcome while generating sufficient specializations of functions. Fuse has been developed with the programmers in mind, and has successfully been used for a number of applications in the area of scientific programming.
Reference: [Bondorf 90b] <author> A. Bondorf. </author> <title> Self-Applicable Partial Evaluation. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, Denmark, </institution> <year> 1990. </year> <note> Revised version: DIKU Report 90/17. </note>
Reference-contexts: But what if the source program does not terminate for some input, where the specialized program does? Is this acceptable behavior? If the answer is no, then the partial evaluation is called strict. If the answer is yes, then the partial evaluation is called nonstrict <ref> [Bondorf 90b] </ref>. A nonstrict partial evaluator may be more aggressive in its attempt to perform computations at the time of specialization than a strict partial evaluator. Programs specialized with nonstrict partial evaluators may show better speedups than programs specialized with strict partial evaluators. <p> We will not describe the actual workings of a binding time analysis. The interested reader is referred to [Henglein 91], <ref> [Bondorf 90b] </ref> [Bondorf 90a], [Consel 90], [Bondorf 88], [Nielson 88]. O*ine partial evaluators for higher order languages does usually also have a closure analysis in the prephase. The result of a closure analysis is some information about what closures may be applied at the application points in the program. <p> newn if m.eq [0 ] then result n.plus [1 ] elseif n.eq [0 ] then newm m.minus [1 ] result self.Ackermann [newn, 1 ] else newn n.minus [1 ] newm m.minus [1 ] newn self.Ackermann [m, newn] result self.Ackermann [newm, newn] end if end Ackermann end something under dynamic control <ref> [Bondorf 90b] </ref>. That a loop is under dynamic control means that it is the value of a dynamic variable that controls when the loop should be exited. The partial evaluator should be able to handle this classical problem correctly. <p> Methods in the current object can be unfolded the same way as in applicative languages. Direct recursive methods cannot be unfolded. The recursion may be (partially) unrolled but this is another matter. Because the actual parameters are basic expressions there is no need for occurrence counting <ref> [Bondorf 90b] </ref> to determine if unfolding may lead to duplicating computations (it never does) so unfolding is somewhat simpler. The only extra problem is if an instance variable is used both as actual parameter to and modified in a procedural method. <p> For nonmanifest invocations, the function body is replaced by a single assignment statement assigning the global value to the result variable. This means that our specializer is going to be nonstrict <ref> [Bondorf 90b] </ref>. A function in the source program that may never terminate its computations but will return a specific global value if it terminates will be specialized to a method that always terminate. This means that the residual program has radically different termination properties than the original program.
Reference: [Bondorf 90c] <author> A. Bondorf and T.. Mogensen. Logimix: </author> <title> A Self-Applicable Partial Evaluator for Prolog. </title> <month> May </month> <year> 1990. </year> <pages> 2 pages. </pages> <institution> DIKU, University of Copen-hagen, Denmark. </institution>
Reference-contexts: Here we will only mention a few of them. Those we mention have either been fore-runners in the field of partial evaluation, are well known in the partial evaluation community, or have direct relevance to our work. There also exist partial evaluators for logic programming languages <ref> [Bondorf 90c, Sahlin 91] </ref>, but since they are irrelevant to us, we have omitted description of such partial evaluators here. Schism A partial evaluator for a higher order subset of Lisp. Originally required user annotations of the program. Is now fully automatic. Is still a subject of ongoing research.
Reference: [Booch 91] <author> Grady Booch. </author> <title> Object Oriented Design With Applications. </title> <publisher> Ben-jamin/Cummings Publishing Company, Inc., </publisher> <address> 390 Bridge Parkway, Redwood City, CA, </address> <year> 1991. </year>
Reference-contexts: Trellis/Owl [Schaffert 86], Eiffel [Meyer 90], Emerald [Raj 91] and Self [Ungar 87]. There is not general agreement on a definition of what requirements a language should fulfill to be regarded as object-oriented. There are several definitions, of which [Wegner 86], [Meyer 88], <ref> [Booch 91] </ref>, and [Blair 89] are the most used. The oldest and 21 22 Partial Evaluation of an OO-Language, September 25, 1992 most widely known definition is [Wegner 86]. The one closest to our perception of object-orientedness is [Blair 89]. The definitions in [Meyer 88] and [Booch 91] are taught to <p> [Wegner 86], [Meyer 88], <ref> [Booch 91] </ref>, and [Blair 89] are the most used. The oldest and 21 22 Partial Evaluation of an OO-Language, September 25, 1992 most widely known definition is [Wegner 86]. The one closest to our perception of object-orientedness is [Blair 89]. The definitions in [Meyer 88] and [Booch 91] are taught to many newcomers to the area of object-oriented programming. Not all languages that are object-oriented according to one definition will be object-oriented according to another definition. In Section 3.1 we will take a closer look at why object-oriented programming languages have become so widespread and successful.
Reference: [Chambers 91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <editor> In Andreas Paepcke (editor), </editor> <booktitle> OOPSLA '91, Conference Proceedings, Conference on Object-Oriented Programming, Systems, Languages, and Applications, ACM/SIGPLAN, </booktitle> <pages> pages 1-15. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: C++ and ObjectPascal are languages with add-on object-oriented features. Another reason might be efficiency. Pure object-oriented languages are typically not very efficient. The latest compiler for the language Self does to some extend show that this need not be the case <ref> [Chambers 91] </ref>. What is inheritance? Inheritance is by many people regarded as a very important element of object-orientedness. It is however not quite clear what inheritance is or rather how it should be implemented and what semantics it has. We will try to clarify the problems.
Reference: [Consel 88] <author> C. Consel. </author> <title> New Insights into Partial Evaluation: The Schism Experiment. </title> <editor> In H. Ganzinger (editor), </editor> <booktitle> ESOP '88, 2nd European Symposium on Programming, </booktitle> <address> Nancy, France, </address> <month> March </month> <year> 1988. </year> <booktitle> (Lecture Notes in Computer Science, </booktitle> <volume> vol. 300), </volume> <pages> pages 236-246. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Schism A partial evaluator for a higher order subset of Lisp. Originally required user annotations of the program. Is now fully automatic. Is still a subject of ongoing research. An overview is given in <ref> [Consel 88] </ref>. It does not perform a separate closure analysis before the binding time analysis, but instead it integrates the two in a polyvariant higher-order binding time analysis [Consel 90]. It handles partially static structures as mentioned in [Mogensen 88].
Reference: [Consel 90] <author> C. Consel. </author> <title> Binding Time Analysis for Higher Order Untyped Functional Languages. </title> <booktitle> In 1990 ACM Conference on Lisp and Functional Programming, Nice, France, ACM, </booktitle> <pages> pages 264-272. </pages> <year> 1990. </year>
Reference-contexts: We will not describe the actual workings of a binding time analysis. The interested reader is referred to [Henglein 91], [Bondorf 90b] [Bondorf 90a], <ref> [Consel 90] </ref>, [Bondorf 88], [Nielson 88]. O*ine partial evaluators for higher order languages does usually also have a closure analysis in the prephase. The result of a closure analysis is some information about what closures may be applied at the application points in the program. <p> Is now fully automatic. Is still a subject of ongoing research. An overview is given in [Consel 88]. It does not perform a separate closure analysis before the binding time analysis, but instead it integrates the two in a polyvariant higher-order binding time analysis <ref> [Consel 90] </ref>. It handles partially static structures as mentioned in [Mogensen 88]. Chapter 2 What is partial evaluation? 19 LambdaMix A partial evaluator for the untyped lambda calculus.
Reference: [DeMichiel 87] <author> Linda G. DeMichiel and Richard P. Gabriel. </author> <title> The Common Lisp Object System: An Overview. </title> <booktitle> In Proceedings of the 1987 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 151-170. </pages> <year> 1987. </year>
Reference: [Ershov 77] <author> A.P. Ershov. </author> <title> On the Partial Computation Principle. </title> <journal> Information Processing Letters 6(2) </journal> <pages> 38-41, </pages> <month> April </month> <year> 1977. </year> <title> 222 Partial Evaluation of an OO-Language, </title> <month> September 25, </month> <year> 1992 </year>
Reference-contexts: To illustrate what this mean, we can consider the functional program listed below (written in ML [Milner 90]) that implements the power function, computing the value of the first argument lifted to the power of the second argument. The example can be dated back to <ref> [Ershov 77] </ref>. 13 14 Partial Evaluation of an OO-Language, September 25, 1992 fun power (x,n) = if n = 0 then 1 else if even (n) then sqr (power (x, n div 2 )) else x * power (x, n1 ) Partial evaluation of this program with the information that the
Reference: [Fischback 91] <author> Rainer Fischback. </author> <title> Types and Class. </title> <institution> In [?]. Computer Science Department, Aarhus University, </institution> <year> 1991. </year>
Reference-contexts: If the first approach can be regarded as a valid approach to inheritance, then inheritance is nothing but an advanced form of syntactic sugar. There is general agreement that subtyping and subclassing is not the same thing [Black 91], <ref> [Fischback 91] </ref>, [Hutchinson 91], [Palsberg 91b]. Many people in the object-oriented community does however not like to think of inheritance as syntactic sugar. From our discussions with people disliking the thought we have learned that their dislike originate from use of languages where subtyping was the same thing as subclassing. <p> Researchers working with type systems in object-oriented languages now generally agree that the class hierarchy should be separated from the type hierarchy [Black 91], 31 32 Partial Evaluation of an OO-Language, September 25, 1992 <ref> [Fischback 91] </ref>, [Hutchinson 91], [Palsberg 91b]. In untyped languages and in languages where types are unrelated to inheritance, inheritance is only a textual sort-hand used to reuse code and save the programmer some work [Palsberg 91b].
Reference: [Futamura 71] <author> Y. Futamura. </author> <title> Partial Evaluation of Computation Process An Approach to a Compiler-Compiler. </title> <journal> Systems, Computers, </journal> <volume> Controls 2(5) </volume> <pages> 45-50, </pages> <year> 1971. </year>
Reference-contexts: It is possible to generate compilers from interpreters and even to generate compiler generators. The rules stating how to do this is called the Futamura Projections after the Japanese Computer Scientist Yoshihiko Futamura that first formulated them <ref> [Futamura 71] </ref>. The basic idea is that an interpreter is just a program that takes two arguments; the first argument being the program to interpret, and the second argument being the input (arguments) to this program.
Reference: [Gluck 91] <author> R. Gluck. </author> <title> Towards Multiple Self-Application. In Partial Evaluation and Semantics-Based Program Manipulation, New Haven, Connecticut. </title> <journal> (Sigplan Notices, </journal> <volume> vol. 26, no. 9, </volume> <month> September </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <pages> pages 309-320. </pages> <year> 1991. </year>
Reference-contexts: The three Futamura projections are just special cases of Turchin's metasystem transitions 1 . A recent paper describing the use of metasystem transitions is <ref> [Gluck 91] </ref>. 2.3 O*ine vs. Online Partial Evaluation A partial evaluator can be constructed after two basically different strategies. Partial evaluators constructed after these strategies are called either online or o*ine partial evaluators. 1 We have not been able to find a reference to the correct paper. <p> It is widely believed that it is not possible to make online partial evaluators self-applicable. This is partially disproved by <ref> [Gluck 91] </ref>. The paper describes an online partial evaluator that is self-applicable. The partial evaluator has the usual (for online partial evaluators) problem with termination and requires user annotations of programs to control unfolding. <p> These computations are those, which have to be performed by the residual program when the unknown input values become available. It is not phrased in the same way but it is nevertheless the same technique as described in <ref> [Gluck 91] </ref>.
Reference: [Goad 82] <author> C. Goad. </author> <title> Automatic Construction of Special Purpose Programs. </title> <editor> In D.W. Loveland (editor), </editor> <booktitle> 6th Conference on Automated Deduction, </booktitle> <address> New York, USA. </address> <booktitle> (Lecture Notes in Computer Science, </booktitle> <volume> vol. 138), </volume> <pages> pages 194-208. </pages> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: In the area of computer graphics, partial evaluation has successfully been used for raytracing [Mogensen 86], sorting of polygons <ref> [Goad 82] </ref> , and bitmap manipulating operations [OKeefe 91].
Reference: [Goldberg 89] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: the Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: In pure languages, all data is represented by objects. That means that integers, floating point numbers, characters and filesystems all are represented as objects. Some object-oriented languages like Smalltalk <ref> [Goldberg 89] </ref> and Ellie [Andersen 91a] also 28 Partial Evaluation of an OO-Language, September 25, 1992 represent language constructions like if- and loop-constructions as objects.
Reference: [Gomard 91a] <editor> C.K. Gomard and N.D. Jones. </editor> <title> Compiler Generation by Partial Evaluation: a Case Study. </title> <booktitle> Structured Programming 12 </booktitle> <pages> 123-144, </pages> <year> 1991. </year>
Reference-contexts: This makes some extra postphase optimizations possible. Relevant references are: [Weise 90], [Ruf 91] and [Weise 91b]. ImperativeMIX A self-applicable partial evaluator for a simple imperative language with basic blocks (and without procedures). The partial evaluator is described in <ref> [Gomard 91a] </ref>.
Reference: [Gomard 91b] <editor> C.K. Gomard and N.D. Jones. </editor> <title> A Partial Evaluator for the Untyped Lambda-Calculus. </title> <journal> Journal of Functional Programming 1(1) </journal> <pages> 21-69, </pages> <month> Jan-uary </month> <year> 1991. </year>
Reference-contexts: An interesting point about this partial evaluator is that the specialization is proven to be correct whenever the binding time annotations of the source program are correct. Described in <ref> [Gomard 91b] </ref>. The partial evaluator is strict. The specialization does fail to terminate for some programs. Similix Probably the most widespread partial evaluator at the moment. The source language is a subset of Scheme. Developed here at dikuby Anders Bondorf and Olivier Danvy.
Reference: [Henglein 91] <author> F. Henglein. </author> <title> Efficient Type Inference for Higher-Order Binding-Time Analysis. </title> <editor> In J. Hughes (editor), </editor> <booktitle> Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, Massachusetts, </address> <month> August </month> <year> 1991. </year> <booktitle> (Lecture Notes in Computer Science, </booktitle> <volume> vol. 523), </volume> <booktitle> ACM, </booktitle> <pages> pages 448-472. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: We will not describe the actual workings of a binding time analysis. The interested reader is referred to <ref> [Henglein 91] </ref>, [Bondorf 90b] [Bondorf 90a], [Consel 90], [Bondorf 88], [Nielson 88]. O*ine partial evaluators for higher order languages does usually also have a closure analysis in the prephase.
Reference: [Hutchinson 87] <author> Norman C. Hutchinson. </author> <title> Emerald: A Language to Support Distributed Programming. </title> <editor> In Mario R. Barbacci (editor), </editor> <booktitle> Proceedings from the Second Workshop on Large-Grained Parallelism, </booktitle> <pages> pages 45-47. </pages> <institution> Carnegie-Mellon University Software Engineering Institute, </institution> <address> Pittsburgh, PA, </address> <year> 1987. </year> <note> This appears in Special Report CMU/SEI-87-SR-5. </note>
Reference-contexts: This is similar to the abstract types used in Emerald <ref> [Hutchinson 87] </ref>. Abstract types is useful when describing the self-interpreter. It can simply be seen which methods the different objects must have, and it is simple to read the code.
Reference: [Hutchinson 91] <author> Norman C. Hutchinson. </author> <title> Types vs. Classe, and Why We Need Both. </title> <institution> In [?]. Computer Science Department, Aarhus University, </institution> <year> 1991. </year>
Reference-contexts: If the first approach can be regarded as a valid approach to inheritance, then inheritance is nothing but an advanced form of syntactic sugar. There is general agreement that subtyping and subclassing is not the same thing [Black 91], [Fischback 91], <ref> [Hutchinson 91] </ref>, [Palsberg 91b]. Many people in the object-oriented community does however not like to think of inheritance as syntactic sugar. From our discussions with people disliking the thought we have learned that their dislike originate from use of languages where subtyping was the same thing as subclassing. <p> Researchers working with type systems in object-oriented languages now generally agree that the class hierarchy should be separated from the type hierarchy [Black 91], 31 32 Partial Evaluation of an OO-Language, September 25, 1992 [Fischback 91], <ref> [Hutchinson 91] </ref>, [Palsberg 91b]. In untyped languages and in languages where types are unrelated to inheritance, inheritance is only a textual sort-hand used to reuse code and save the programmer some work [Palsberg 91b]. In the programming language Emerald, inheritance is actually handled in the desugaring phase of the compiler.
Reference: [Jacobsen 90] <author> H.F. Jacobsen. </author> <title> Speeding Up the Back-Propagation Algorithm by Partial Evaluation. </title> <month> October </month> <year> 1990. </year> <title> DIKU Student Project 90-10-13, </title> <type> 32 pages. </type> <institution> DIKU, University of Copenhagen. (In Danish). </institution>
Reference-contexts: Partial evaluation where the constant parameters was just the topology of the network and the learning rate and momentum resulted in residual programs that were 25-50% faster than the source program. The partial evaluator was an o*ine partial evaluator for a very small subset of C <ref> [Jacobsen 90] </ref>. Partial evaluation has also with success been applied to scientific computing. Here the online partial evaluator Fuse has been used.
Reference: [Jones 91] <author> Neil D. Jones. </author> <type> personal communication. </type> <year> 1991. </year> <title> (during supervision of the project). </title> <note> Chapter 14 Conclusion 223 </note>
Reference-contexts: The objects are created in the loop. This is a loop construction that is often ignored in abstract interpreters <ref> [Jones 91] </ref>. A fragment of a program containing such a loop is sketched in Figure 7.2. To avoid nontermination when performing abstract interpretation of programs of this kind, all the objects created in the loop should be represented by a single object value.
Reference: [Jones 92] <author> Neil D. Jones. </author> <title> Partial Evaluation and the Generation of Program Generators. </title> <note> 1992. To appear in a 1992 issue of Communications of the ACM. </note>
Reference-contexts: We will not require the partial evaluator be strict since this complicates the algorithm and requires extra work arguing that the partial evaluator actually is strict. 1 The example is taken from <ref> [Jones 92] </ref> Chapter 5 Ideas, Problems and Strategies 59 const imperative == object language function interpret [program, startx ] ! [result] var instruction var x var y var code var temp x startx y 0 instruction 0 loop code program.getline [instruction] instruction instruction.plus [1 ] exit when code.equal ["halt"] if code.equal <p> Using these brackets in this way follows the usage in e.g. <ref> [Jones 92] </ref>. In addition to the proofs of correctness of program state we have to prove that the abstract interpretation does not break on legal programs. This can be proven by proving that the interpretation does not break on any syntactic correct program.
Reference: [Kahn 87] <author> G. Kahn. </author> <title> Natural Semantics. </title> <editor> In F.J. Brandenburg, G. Vidal-Naquet, and M. Wirsing (editors), </editor> <booktitle> STACS 87. 4th Annual Symposium on Theoretical Aspects of Computer Science, Passau, Germany (Lecture Notes in Computer Science, </booktitle> <volume> vol. 247), </volume> <pages> pages 22-39. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: The semantics will be described using deduction rules as described by e.g. <ref> [Kahn 87] </ref>. We represent an object reference by an OID (Object ID). The OIDs can e.g. be the set of integers. We distinguish between builtin objects and objects made by evaluating object constructors in the program. None of the builtin objects have an internal state. <p> [a 1 , . . . , a n ]. 42 Partial Evaluation of an OO-Language, September 25, 1992 Judgment forms We use some judgment forms that are different from what can be seen elsewhere, e.g. the formal definition of ML [Milner 90,Milner 91] or the different semantics described in <ref> [Kahn 87] </ref>.
Reference: [Kleene 52] <author> S.C. Kleene. </author> <title> Introduction to Metamathematics. </title> <address> D. </address> <publisher> van Nostrand, </publisher> <address> Princeton, New Jersey, </address> <year> 1952. </year>
Reference-contexts: That it is possible to construct such a program is given by Kleene's s-m-n theorem <ref> [Kleene 52] </ref>. Normally the expectations to the residual program is that it will execute at least as fast as the source program. For many programs, the result of partial evaluation is a residual program that executes an order of magnitude faster than the source program.
Reference: [Meyer 88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Trellis/Owl [Schaffert 86], Eiffel [Meyer 90], Emerald [Raj 91] and Self [Ungar 87]. There is not general agreement on a definition of what requirements a language should fulfill to be regarded as object-oriented. There are several definitions, of which [Wegner 86], <ref> [Meyer 88] </ref>, [Booch 91], and [Blair 89] are the most used. The oldest and 21 22 Partial Evaluation of an OO-Language, September 25, 1992 most widely known definition is [Wegner 86]. The one closest to our perception of object-orientedness is [Blair 89]. The definitions in [Meyer 88] and [Booch 91] are <p> definitions, of which [Wegner 86], <ref> [Meyer 88] </ref>, [Booch 91], and [Blair 89] are the most used. The oldest and 21 22 Partial Evaluation of an OO-Language, September 25, 1992 most widely known definition is [Wegner 86]. The one closest to our perception of object-orientedness is [Blair 89]. The definitions in [Meyer 88] and [Booch 91] are taught to many newcomers to the area of object-oriented programming. Not all languages that are object-oriented according to one definition will be object-oriented according to another definition.
Reference: [Meyer 90] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: Many of the languages used are hybrid languages, i.e. existing conventional languages where object-oriented features has been added later, e.g. C++ [Stroustrup 86,Stroustrup 89], Flavors [Moon 86] and CLOS [DeMichiel 87,Bobrow 86]. However, some pure object-oriented languages have been designed from scratch, e.g. Trellis/Owl [Schaffert 86], Eiffel <ref> [Meyer 90] </ref>, Emerald [Raj 91] and Self [Ungar 87]. There is not general agreement on a definition of what requirements a language should fulfill to be regarded as object-oriented. There are several definitions, of which [Wegner 86], [Meyer 88], [Booch 91], and [Blair 89] are the most used. <p> In the hybrid languages, there is a mixture of objects and other data entities as we know them from other programming languages like Pascal, C, Lisp, ML, etc. Examples of hybrid object-oriented languages are C++ [Stroustrup 86], CLOS [Bobrow 86], and Eiffel <ref> [Meyer 90] </ref>. There may be a lot of reasons for using hybrid languages. One reason that is valid for languages like e.g.
Reference: [Meyer 91] <author> U. Meyer. </author> <title> Techniques for Partial Evaluation of Imperative Languages. In Partial Evaluation and Semantics-Based Program Manipulation, New Haven, Connecticut. </title> <journal> (Sigplan Notices, </journal> <volume> vol. 26, no. 9, </volume> <month> September </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <pages> pages 94-105. </pages> <year> 1991. </year>
Reference-contexts: Further more, the developed partial evaluator is improved in two more steps to improve the quality of the residual programs. During the work developing the partial evaluator we have developed a novel technique for generating explicators, which are needed in online partial evaluators of imperative languages <ref> [Meyer 91] </ref>. The fact, that all variables are enclosed in objects, makes the generation of explicators more difficult than in ordinary imperative languages. The developed technique overcomes these difficulties. <p> The fact, that all variables are enclosed in objects, makes the generation of explicators more difficult than in ordinary imperative languages. The developed technique overcomes these difficulties. The developed technique gives the residual program a more natural structure than it would have had, using the techniques described in e.g. <ref> [Meyer 91] </ref>. The work combines knowledge from two areas of computer science, which are rarely combined. Most scientists working with program transformations such as partial evaluation will not know much about object-oriented programming, and most scientists working with object-oriented programming will not know much about program transformation. <p> It has been suggested that o*ine partial evaluators should be used for imperative languages where variables may change from being bound to a unknown value to being bound to a known value (or the opposite way around) in a single basic block or structured statement <ref> [Meyer 91] </ref>. It is widely believed that it is not possible to make online partial evaluators self-applicable. This is partially disproved by [Gluck 91]. The paper describes an online partial evaluator that is self-applicable. <p> The generated assignment statements are called explicators. The technique is described in further detail in e.g. <ref> [Meyer 91] </ref> 2 . The technique can only be used if all variables that we need to generate explicators for are in the current scope. <p> We must consequently generate an assignment statement that ensures the variable has the correct value independent of what branch is taken at runtime. Following <ref> [Meyer 91] </ref> we use the 115 116 Partial Evaluation of an OO-Language, September 25, 1992 term explicators for assignment statements that must be generated because of undecidable branches. In Section 8.1 we will describe some of the problems related to the code generation. <p> We can identify the need for inserting the assignment statements when we generalize the program states created by taking the two branches. Assignment statements inserted before the points of program state generalization to ensure that variables are set in the residual program is called explicators <ref> [Meyer 91] </ref>. This technique is general enough for ordinary imperative programs where the program state is determined by the values assigned to global variables.
Reference: [Milner 90] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: To illustrate what this mean, we can consider the functional program listed below (written in ML <ref> [Milner 90] </ref>) that implements the power function, computing the value of the first argument lifted to the power of the second argument.
Reference: [Milner 91] <author> R. Milner and M. Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference: [Mogensen 86] <author> T. Mogensen. </author> <title> The Application of Partial Evaluation to Ray-Tracing. </title> <type> Master's thesis, </type> <institution> DIKU, University of Copenhagen, Denmark, </institution> <year> 1986. </year>
Reference-contexts: In the area of computer graphics, partial evaluation has successfully been used for raytracing <ref> [Mogensen 86] </ref>, sorting of polygons [Goad 82] , and bitmap manipulating operations [OKeefe 91].
Reference: [Mogensen 88] <author> T. Mogensen. </author> <title> Partially Static Structures in a Self-Applicable Partial Evaluator. </title> <editor> In D. Bjtrner, A.P. Ershov, and N.D. Jones (editors), </editor> <booktitle> Partial Evaluation and Mixed Computation, </booktitle> <pages> pages 325-347. </pages> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: An overview is given in [Consel 88]. It does not perform a separate closure analysis before the binding time analysis, but instead it integrates the two in a polyvariant higher-order binding time analysis [Consel 90]. It handles partially static structures as mentioned in <ref> [Mogensen 88] </ref>. Chapter 2 What is partial evaluation? 19 LambdaMix A partial evaluator for the untyped lambda calculus. Uses type inference for binding time analysis of variables and occurrence analysis of functions instead of a binding time analysis for variables by abstract interpretation and a closure analysis for functions.
Reference: [Moon 86] <author> David A. Moon. </author> <title> Object-Oriented Programming with Flavors. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 1-8. </pages> <publisher> Springer Verlag, </publisher> <month> Oc-tober </month> <year> 1986. </year>
Reference-contexts: In Smalltalk, everything from integers to language constructions are objects (also e.g. an if-construction). Object-oriented languages are in widespread use today. Many of the languages used are hybrid languages, i.e. existing conventional languages where object-oriented features has been added later, e.g. C++ [Stroustrup 86,Stroustrup 89], Flavors <ref> [Moon 86] </ref> and CLOS [DeMichiel 87,Bobrow 86]. However, some pure object-oriented languages have been designed from scratch, e.g. Trellis/Owl [Schaffert 86], Eiffel [Meyer 90], Emerald [Raj 91] and Self [Ungar 87].
Reference: [Nielson 88] <author> H.R. Nielson and F. Nielson. </author> <title> Automatic Binding Time Analysis for a Typed -Calculus. </title> <booktitle> Science of Computer Programming 10 </booktitle> <pages> 139-176, </pages> <year> 1988. </year>
Reference-contexts: We will not describe the actual workings of a binding time analysis. The interested reader is referred to [Henglein 91], [Bondorf 90b] [Bondorf 90a], [Consel 90], [Bondorf 88], <ref> [Nielson 88] </ref>. O*ine partial evaluators for higher order languages does usually also have a closure analysis in the prephase. The result of a closure analysis is some information about what closures may be applied at the application points in the program.
Reference: [Nygaard 70] <author> Kristen Nygaard. </author> <title> System description by SIMULA An introduction. </title> <type> Technical Report S-35, </type> <institution> Norsk Regnesentral / Norwegian Computing Center, </institution> <month> November </month> <year> 1970. </year> <title> 224 Partial Evaluation of an OO-Language, </title> <month> September 25, </month> <year> 1992 </year>
Reference-contexts: Some people claim that when using the same paradigm and concepts in the whole life-cycle of a system there will not be the traditional big steps from analysis to design to implementation etc. The object-oriented philosophy originate from the language Simula <ref> [Nygaard 70] </ref>, designed in the late 60's. However, the object-oriented paradigm did not become widespread until the late 70's when Smalltalk [Xerox 81] was developed. In Smalltalk, everything from integers to language constructions are objects (also e.g. an if-construction). Object-oriented languages are in widespread use today.
Reference: [OKeefe 91] <author> Patrick O'Keefe. </author> <title> Partial evaluation in ICAD's programs. </title> <month> November </month> <year> 1991. </year> <title> (personal communication during his visit to DIKU). </title>
Reference-contexts: In the area of computer graphics, partial evaluation has successfully been used for raytracing [Mogensen 86], sorting of polygons [Goad 82] , and bitmap manipulating operations <ref> [OKeefe 91] </ref>. <p> If one expect such behavior, then partial evaluation can be used to generate the often complicated algorithms from simpler ones. This feature has been exploited in the company ICAD to generate fast specialized bitmap manipulation algorithms from a very general algorithm <ref> [OKeefe 91] </ref>. Chapter 3 Ob ject-Oriented Programming Languages This purpose of this chapter is to give a short introduction to the object-oriented programming paradigm. This introduction contains a brief explanation of several buzz-words used in the object-oriented community.
Reference: [Palsberg 91a] <author> Jens Palsberg. </author> <title> Object-Oriented Type Inference. </title> <editor> In Andreas Paepcke (editor), </editor> <booktitle> OOPSLA '91, Conference Proceedings, Conference on Object-Oriented Programming, Systems, Languages, and Applications, ACM, </booktitle> <pages> pages 146-161. </pages> <year> 1991. </year>
Reference-contexts: Builtin Objects The most important object is the "nil" object. Formally, we do not need other builtin objects in the language. Everything else can be encoded as in the pure lambda calculus. An example of this can be found in <ref> [Palsberg 91a] </ref>. To make the language realistic and useful for programming we decided to make it possible to manipulate integers, strings, chars, and booleans as objects. In Appendix A we have listed the interface to the builtin objects.
Reference: [Palsberg 91b] <author> Jens Palsberg and Michael I. Scwartzbach. </author> <title> Subclassing and Subtyping. </title> <institution> In [?]. Computer Science Department, Aarhus University, </institution> <year> 1991. </year>
Reference-contexts: If the first approach can be regarded as a valid approach to inheritance, then inheritance is nothing but an advanced form of syntactic sugar. There is general agreement that subtyping and subclassing is not the same thing [Black 91], [Fischback 91], [Hutchinson 91], <ref> [Palsberg 91b] </ref>. Many people in the object-oriented community does however not like to think of inheritance as syntactic sugar. From our discussions with people disliking the thought we have learned that their dislike originate from use of languages where subtyping was the same thing as subclassing. <p> Researchers working with type systems in object-oriented languages now generally agree that the class hierarchy should be separated from the type hierarchy [Black 91], 31 32 Partial Evaluation of an OO-Language, September 25, 1992 [Fischback 91], [Hutchinson 91], <ref> [Palsberg 91b] </ref>. In untyped languages and in languages where types are unrelated to inheritance, inheritance is only a textual sort-hand used to reuse code and save the programmer some work [Palsberg 91b]. In the programming language Emerald, inheritance is actually handled in the desugaring phase of the compiler. <p> from the type hierarchy [Black 91], 31 32 Partial Evaluation of an OO-Language, September 25, 1992 [Fischback 91], [Hutchinson 91], <ref> [Palsberg 91b] </ref>. In untyped languages and in languages where types are unrelated to inheritance, inheritance is only a textual sort-hand used to reuse code and save the programmer some work [Palsberg 91b]. In the programming language Emerald, inheritance is actually handled in the desugaring phase of the compiler. The core language of Emerald has no notion of inheritance. We will not make inheritance an integrated part of the language.
Reference: [Raj 88] <author> Rajenda K. Raj, Ewan Tempero, Henry M. Levy, Norman C. Hutchin-son, and Andrew P. Black. </author> <title> The Emerald Approach to Programming. </title> <type> Technical Report 88-11-01, </type> <institution> Department of Computer Science, University of Washington, </institution> <address> Seattle, Washington, </address> <month> November </month> <year> 1988. </year> <note> Revised February 1989, later version published as [Raj 91]. </note>
Reference-contexts: An object is said to conform to an abstract type, iff the object always can be regarded as an object of the type, i.e. in some sense is greater than or equal to the type. The term conformance is formally defined in <ref> [Raj 88] </ref>. We assume the existence of some builtin abstracts types that the builtin objects conform to. 12.5.1 Parsing into a token stream Parsing a program is based on the simple syntax listed in Figure 12.4. The parsing is done in two phases, a lexical and a grammatical analysis.
Reference: [Raj 91] <author> Rajendra K. Raj, Ewan D. Tempero, Henry M. Levy, Andrew P. Black, Norman C. Hutchinson, and Eric Jul. </author> <title> Emerald: A General-Purpose Programming Language. </title> <journal> Software | Practice and Experience 21(1) </journal> <pages> 91-118, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: C++ [Stroustrup 86,Stroustrup 89], Flavors [Moon 86] and CLOS [DeMichiel 87,Bobrow 86]. However, some pure object-oriented languages have been designed from scratch, e.g. Trellis/Owl [Schaffert 86], Eiffel [Meyer 90], Emerald <ref> [Raj 91] </ref> and Self [Ungar 87]. There is not general agreement on a definition of what requirements a language should fulfill to be regarded as object-oriented. There are several definitions, of which [Wegner 86], [Meyer 88], [Booch 91], and [Blair 89] are the most used. <p> We call the language Simili. To make things easy, it was required that the language be small and simple, but still realistic for practical use. Our language is a "baby" Emerald <ref> [Raj 91] </ref>, i.e. Emerald without a strong type system and without the possibility of distributed and parallel programs. We have chosen Emerald as basis for our language because it is the only object oriented language we know of, that does not have classes and inheritance.
Reference: [Reddy 88] <author> Uday S. Reddy. </author> <title> Objects As Closures: Abstract Semantics of Object Oriented Languages. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, ACM, </booktitle> <pages> pages 289-297. </pages> <month> July 25-27 </month> <year> 1988. </year>
Reference-contexts: This has been known for a long time. We have been told that some of the early papers on Scheme by Abelson and Sussman show this. A recent paper describing how to implement objects using closures is <ref> [Reddy 88] </ref>. Here Chapter 3 Object-Oriented Programming Languages 29 we will just show by an example how this can be done. We will not use this in the rest of the report.
Reference: [Romanenko 90] <author> S.A. Romanenko. </author> <title> Arity Raiser and Its Use in Program Specialization. </title> <editor> In N. Jones (editor), </editor> <booktitle> ESOP '90. 3rd European Symposium on Programming, </booktitle> <address> Copenhagen, Denmark, </address> <month> May </month> <year> 1990. </year> <booktitle> (Lecture Notes in Computer Science, </booktitle> <volume> vol. 432), </volume> <pages> pages 341-360. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Often programs to be specialized have to be written and rewritten with the binding time annotation in mind. The postphase of o*ine partial evaluators usually performs last-minute optimizations, reductions, and unfolding. Some partial evaluators also perform arity raising in the post-phase <ref> [Romanenko 90] </ref>. Online partial evaluators have no prephase with a binding time analysis. They are one phase specializers 2 . Online partial evaluators have a single phase where the specialization is done and usually also a postphase that prints the generated program and performs some last-minute optimizations.
Reference: [Ruf 91] <author> Erik Ruf and Daniel Weise. </author> <title> Using types to avoid Redundant Specialization. </title> <booktitle> In Proceedings of the 1991 Symposium on Partial Evaluation and Semantics-Directed Program Manipulation, ACM SIGPLAN, </booktitle> <pages> pages 321-333. </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Fuse has backends that can generate both Scheme and C code. Fuse can handle partially static datastructures and uses graphs as an intermediate representation of programs. This makes some extra postphase optimizations possible. Relevant references are: [Weise 90], <ref> [Ruf 91] </ref> and [Weise 91b]. ImperativeMIX A self-applicable partial evaluator for a simple imperative language with basic blocks (and without procedures). The partial evaluator is described in [Gomard 91a]. <p> Assignment of values we know will be globally accessible in the residual program is only performed symbolically. So is invocations of functional methods if the value returned is globally accessible. Example 5.1 illustrates the technique. As phrased in <ref> [Ruf 91] </ref> we perform a symbolic execution of the program while generating a trace of the computations that could not completely be performed at the time of specialization. These computations are those, which have to be performed by the residual program when the unknown input values become available. <p> This might be worth doing for some languages (if not all). This can be done using different degrees of ingenuity. An example of a smart technique, which optimizes the reuse of functions using inferred type information is described in <ref> [Ruf 91] </ref>.
Reference: [Sahlin 91] <author> D. Sahlin. </author> <title> An Automatic Partial Evaluator for Full Prolog. </title> <type> PhD thesis, </type> <institution> Kungliga Tekniska Hogskolan, Stockholm, Sweden, </institution> <year> 1991. </year> <type> Report TRITA-TCS-9101, </type> <pages> 170 pages. </pages>
Reference-contexts: Here we will only mention a few of them. Those we mention have either been fore-runners in the field of partial evaluation, are well known in the partial evaluation community, or have direct relevance to our work. There also exist partial evaluators for logic programming languages <ref> [Bondorf 90c, Sahlin 91] </ref>, but since they are irrelevant to us, we have omitted description of such partial evaluators here. Schism A partial evaluator for a higher order subset of Lisp. Originally required user annotations of the program. Is now fully automatic. Is still a subject of ongoing research.
Reference: [Schaffert 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Car-rie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <editor> In Norman Mey-rowitz (editor), </editor> <booktitle> OOPSLA '86, Conference Proceedings, Conference on Object-Oriented Programming, Systems, Languages, and Applications, ACM/SIGPLAN, </booktitle> <pages> pages 9-16. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: Many of the languages used are hybrid languages, i.e. existing conventional languages where object-oriented features has been added later, e.g. C++ [Stroustrup 86,Stroustrup 89], Flavors [Moon 86] and CLOS [DeMichiel 87,Bobrow 86]. However, some pure object-oriented languages have been designed from scratch, e.g. Trellis/Owl <ref> [Schaffert 86] </ref>, Eiffel [Meyer 90], Emerald [Raj 91] and Self [Ungar 87]. There is not general agreement on a definition of what requirements a language should fulfill to be regarded as object-oriented.
Reference: [Stroustrup 86] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year> <note> Chapter 14 Conclusion 225 </note>
Reference-contexts: In the hybrid languages, there is a mixture of objects and other data entities as we know them from other programming languages like Pascal, C, Lisp, ML, etc. Examples of hybrid object-oriented languages are C++ <ref> [Stroustrup 86] </ref>, CLOS [Bobrow 86], and Eiffel [Meyer 90]. There may be a lot of reasons for using hybrid languages. One reason that is valid for languages like e.g.
Reference: [Stroustrup 89] <author> Bjarne Stroustrup. </author> <title> Multiple Inheritance for C++. </title> <booktitle> Computing Systems 367-395, </booktitle> <month> fall </month> <year> 1989. </year>
Reference: [Tarditi 90] <author> David R. Tarditi and Andrew W. Appel. ML-Yacc, </author> <note> version 2.0, Documentation for Release Version. </note> <month> April </month> <year> 1990. </year>
Reference-contexts: Module Lines Bytes Section Parser 2.442 65.525 12.2 Interpreter 7.603 257.898 12.3 Partial Evaluator 13.870 423.474 12.4 Self-interpreter 2.900 84.888 12.5 Test examples 1.939 47.273 12.6 Table 12.1: The code in the system 12.2 The extended parser We have used the ML-version of lex [Appel 89] and yacc <ref> [Tarditi 90] </ref> to implement a parser to convert a string into the sugared or unsugared abstract syntax. After parsing the basic blocks are split as described in Section 8.1.5. The result is a syntax tree.
Reference: [Ungar 87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA '87, Conference Proceedings, Conference on Object-Oriented Programming, Systems, Languages, and Applications, </booktitle> <pages> pages 227-241. </pages> <month> December </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12). </note>
Reference-contexts: C++ [Stroustrup 86,Stroustrup 89], Flavors [Moon 86] and CLOS [DeMichiel 87,Bobrow 86]. However, some pure object-oriented languages have been designed from scratch, e.g. Trellis/Owl [Schaffert 86], Eiffel [Meyer 90], Emerald [Raj 91] and Self <ref> [Ungar 87] </ref>. There is not general agreement on a definition of what requirements a language should fulfill to be regarded as object-oriented. There are several definitions, of which [Wegner 86], [Meyer 88], [Booch 91], and [Blair 89] are the most used.
Reference: [Wegner 86] <author> Peter Wegner. </author> <title> Dimensions of Object-Based Language Design. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, ACM, </booktitle> <pages> pages 168-182. </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: Trellis/Owl [Schaffert 86], Eiffel [Meyer 90], Emerald [Raj 91] and Self [Ungar 87]. There is not general agreement on a definition of what requirements a language should fulfill to be regarded as object-oriented. There are several definitions, of which <ref> [Wegner 86] </ref>, [Meyer 88], [Booch 91], and [Blair 89] are the most used. The oldest and 21 22 Partial Evaluation of an OO-Language, September 25, 1992 most widely known definition is [Wegner 86]. The one closest to our perception of object-orientedness is [Blair 89]. <p> There are several definitions, of which <ref> [Wegner 86] </ref>, [Meyer 88], [Booch 91], and [Blair 89] are the most used. The oldest and 21 22 Partial Evaluation of an OO-Language, September 25, 1992 most widely known definition is [Wegner 86]. The one closest to our perception of object-orientedness is [Blair 89]. The definitions in [Meyer 88] and [Booch 91] are taught to many newcomers to the area of object-oriented programming. Not all languages that are object-oriented according to one definition will be object-oriented according to another definition.
Reference: [Weise 90] <author> Danial Weise and Erik Ruf. </author> <title> Computing Types During Partial Evaluation. </title> <type> Technical Report, </type> <institution> Stanford University, </institution> <month> December </month> <year> 1990. </year> <note> Fuse-Memo 91-3-revised. </note>
Reference-contexts: Fuse has backends that can generate both Scheme and C code. Fuse can handle partially static datastructures and uses graphs as an intermediate representation of programs. This makes some extra postphase optimizations possible. Relevant references are: <ref> [Weise 90] </ref>, [Ruf 91] and [Weise 91b]. ImperativeMIX A self-applicable partial evaluator for a simple imperative language with basic blocks (and without procedures). The partial evaluator is described in [Gomard 91a].
Reference: [Weise 91a] <author> Daniel Weise. </author> <title> Termination properties of FUSE. november 1991. </title> <type> personal communication. </type>
Reference-contexts: Fuse as described in [Ruf 91,Weise 91b] does not handle this kind of loops even though the authors claim that Fuse has the same termination properties as we claim our algorithm has. Fuse does actually handle this kind of loop <ref> [Weise 91a] </ref>. The strategy used in Fuse is basicly that for each closure the call stack information at the time of creation of the closure is preserved. This call stack information is then used to detect speculative loops when the closure is applied. <p> This means that the residual program has radically different termination properties than the original program. This is the same behavior as found in Fuse <ref> [Weise 91a] </ref>. 8.2 Collecting the trace (code) The interpretation rules for expressions and statements should be modified to generate new expressions and statements that are as reduced as possible. The routines for interpreting basic blocks should be extended to generate new basic blocks.
Reference: [Weise 91b] <author> Daniel Weise, Roland Conybeare, Erik Ruf, and Scott Seligman. </author> <title> Automatic Online Partial Evaluation. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, ACM. </booktitle> <year> 1991. </year>
Reference-contexts: These difficulties have more or less been solved by the group of people working with the Fuse online partial evaluator <ref> [Weise 91b] </ref> (and independently also by the authors of this thesis). <p> Fuse has backends that can generate both Scheme and C code. Fuse can handle partially static datastructures and uses graphs as an intermediate representation of programs. This makes some extra postphase optimizations possible. Relevant references are: [Weise 90], [Ruf 91] and <ref> [Weise 91b] </ref>. ImperativeMIX A self-applicable partial evaluator for a simple imperative language with basic blocks (and without procedures). The partial evaluator is described in [Gomard 91a]. <p> The termination properties can be summarized as: the abstract interpretation fails to terminate when the program being interpreted itself fails to terminate for any input or when the program contains a nonterminating region regardless of input. 7.1 Generalizing in speculative loops leads to ter mination Using the terminology of <ref> [Weise 91b] </ref> we define a speculative loop to be a loop where the test of whether or not to exit the loop depends on the unknown input to the program. Speculative loops are the most common reasons for nontermination of the abstract interpretation described in the previous chapter. <p> if x.neq [1 ] then label2 else label5 label2: x x.minus [1 ] if dynamic.test [] then label3 else label4 label3: y 4 goto label4 label4: skip goto label1 label5: (b) with call information for all functions that the thread of control is passing through on the current execution path <ref> [Weise 91b] </ref>. Whenever a conditional branch expression is encountered where it is not possible at specialization time to determine what branch is taken, a conditional marker is pushed onto this stack. <p> This because the program might contain nested loops. Considering the impact on code generation, continuing the abstract interpretation (and thus later also the code generation) from the present point will lead to code duplication. Fuse continues the computations from the test. Using the terminology from <ref> [Weise 91b] </ref> the expansion can be regarded as a preample to the real loop. This preample can easily Chapter 7 Ensuring Termination 89 be removed but the specialized methods generated for use by the preample are not so easily removed.
Reference: [Xerox 81] <author> Xerox. </author> <title> The Smalltalk-80 System. </title> <type> BYTE 36-48, </type> <month> August </month> <year> 1981. </year>
Reference-contexts: The object-oriented philosophy originate from the language Simula [Nygaard 70], designed in the late 60's. However, the object-oriented paradigm did not become widespread until the late 70's when Smalltalk <ref> [Xerox 81] </ref> was developed. In Smalltalk, everything from integers to language constructions are objects (also e.g. an if-construction). Object-oriented languages are in widespread use today. Many of the languages used are hybrid languages, i.e. existing conventional languages where object-oriented features has been added later, e.g.
References-found: 65

