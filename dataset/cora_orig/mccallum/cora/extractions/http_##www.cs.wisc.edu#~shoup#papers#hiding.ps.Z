URL: http://www.cs.wisc.edu/~shoup/papers/hiding.ps.Z
Refering-URL: http://www.cs.wisc.edu/~shoup/papers/
Root-URL: 
Title: Instance-Hiding Proof Systems  
Author: D. Beaver J. Feigenbaum R. Ostrovsky V. Shoup 
Date: July 26, 1993  
Abstract: We define the notion of an instance-hiding proof system (ihps) for a function f; informally, an ihps is a protocol in which a polynomial-time verifier interacts with one or more all-powerful provers and is convinced of the value of f(x) but does not reveal the input x to the provers. We show here that a function f has a multiprover ihps if and only if it is computable in FNEXP. We formalize the notion of zero-knowledge for ihps's and show that any function that has a multiprover ihps in fact has one that is perfect zero-knowledge. Under the assumption that one-way permutations exist, we show that f has a one-prover, zero-knowledge ihps if and only if it is in FPSPACE and has a one-oracle instance-hiding scheme (ihs).
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, J. Feigenbaum, and J. Kilian. </author> <title> On Hiding Information from an Oracle, </title> <journal> J. Com-put. System Sci. </journal> <volume> 39 (1989), </volume> <pages> pp. 21-50. </pages>
Reference-contexts: Furthermore, it is shown in [3] that the class MIP of languages recognized by multiprover ips's is equal to the complexity class NEXP = NTIME (2 poly ). In an instance-hiding scheme (ihs) for a function f (cf. <ref> [1, 6, 7] </ref>), the input x is on a private tape, accessible only to the querier V . <p> In this model, V does not entrust any information about x to the provers, but it does have to trust the provers to answer questions correctly. Because their answers are trusted, the powerful players are referred to as "oracles" in <ref> [1, 6, 7] </ref>, rather than "provers." Beaver and Feigenbaum [6] have shown that all functions f have multioracle ihs's, thus settling a question of Rivest [24]. <p> The verifier's view of the interaction, denoted V iew (V; x), is hT (V; P 1 ; x); : : : ; T (V; P m ; x); Ri, where R is the distribution of V 's random coins. Definition 2.1 <ref> [1, 6] </ref>: The protocol (V; P 1 ; : : : ; P m ) is an m-oracle instance-hiding scheme (ihs) for the function f if it satisfies the following properties. (i) For all x, Prob ((V (x); P 1 ; : : : ; P m ) = f (x)) <p> A more general definition of instance-hiding is given in <ref> [1] </ref>; if we restrict attention to the case in which at most the length of the instance is leaked to the provers, then condition (ii) of Definition 2.1 and condition (iii) of Definition 2.2 are equivalent to the definition in [1]. <p> A more general definition of instance-hiding is given in <ref> [1] </ref>; if we restrict attention to the case in which at most the length of the instance is leaked to the provers, then condition (ii) of Definition 2.1 and condition (iii) of Definition 2.2 are equivalent to the definition in [1]. As usual, the probabilities 3=4 and 1=4 may be replaced by 1 1=poly and 1=poly without changing the set of functions that satisfy the definitions.
Reference: [2] <author> N. Alon and J. Spencer. </author> <title> The Probabilistic Method, </title> <publisher> John Wiley and Sons, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: The existence of a suitable polynomial n d has a standard proof using Chernoff bounds (see, e.g., <ref> [2, Appendix A] </ref>). For any transcript t, there is a set R (t) of random strings r that are consistent with t; these are r's for which there exists at least one x such that t is produced on input x and random string r.
Reference: [3] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Nondeterministic Exponential Time has Two-Prover Interactive Protocols, </title> <booktitle> Computational Complexity 1 (1991), </booktitle> <pages> pp. 3-40. </pages>
Reference-contexts: It is known [19, 25] that the class IP of languages recognized by 1-prover ips's is equal to the complexity class PSPACE. Furthermore, it is shown in <ref> [3] </ref> that the class MIP of languages recognized by multiprover ips's is equal to the complexity class NEXP = NTIME (2 poly ). <p> To prove (1), observe that statements (i) and (ii) of Proposition 3.1 guarantee that the constant term of w (X) in step A4 is indeed equal to f (x). Also, observe that statement (iii) of Proposition 3.1 implies that L g 2 NEXP; therefore, the result of <ref> [3] </ref> that NEXP = MIP shows that Protocol N can indeed be used in step A3.
Reference: [4] <author> L. Babai and S. Moran. </author> <title> Arthur-Merlin Games: A Randomized Proof System and a Hierarchy of Complexity Classes, </title> <journal> J. Comput. System Sci. </journal> <volume> 36 (1988), </volume> <pages> pp. 254-276. </pages>
Reference-contexts: University of Toronto, Computer Science Department, Toronto, Ontario M5S 1A4, CANADA, shoup@cs.toronto.edu. Work done at AT&T Bell Laboratories as a Postdoctoral Fellow in Theoretical Computer Science. 1 In an interactive proof system (ips) for a language L (cf. <ref> [4, 16, 9] </ref>), the input x is on a shared tape, accessible to the verifier and provers. If x is in L, the ips allows V to obtain convincing evidence of this fact. Because it obtains this evidence, V need not trust the provers to behave correctly.
Reference: [5] <author> D. Barrington. </author> <title> Bounded-Width Polynomial-Size Branching Programs Recognize Exactly Those Languages in N C 1 , J. </title> <journal> Comput. System Sci. </journal> <volume> 38 (1989), </volume> <pages> pp. 150-164. </pages>
Reference-contexts: By Barrington's theorem <ref> [5] </ref>, there is a branching program N that realizes g. On a given input, N determines a sequence 1 , : : :, l of permutations in S 5 , where each j is determined by the value of a single input bit.
Reference: [6] <author> D. Beaver and J. Feigenbaum. </author> <title> Hiding Instances in Multioracle Queries, </title> <booktitle> Proc. 7th Annual Symposium on Theoretical Aspects of Computer Science, Lecture Notes in Computer Science, </booktitle> <volume> vol. 415, </volume> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1990, </year> <pages> pp. 37-48. </pages>
Reference-contexts: Furthermore, it is shown in [3] that the class MIP of languages recognized by multiprover ips's is equal to the complexity class NEXP = NTIME (2 poly ). In an instance-hiding scheme (ihs) for a function f (cf. <ref> [1, 6, 7] </ref>), the input x is on a private tape, accessible only to the querier V . <p> In this model, V does not entrust any information about x to the provers, but it does have to trust the provers to answer questions correctly. Because their answers are trusted, the powerful players are referred to as "oracles" in <ref> [1, 6, 7] </ref>, rather than "provers." Beaver and Feigenbaum [6] have shown that all functions f have multioracle ihs's, thus settling a question of Rivest [24]. <p> In this model, V does not entrust any information about x to the provers, but it does have to trust the provers to answer questions correctly. Because their answers are trusted, the powerful players are referred to as "oracles" in [1, 6, 7], rather than "provers." Beaver and Feigenbaum <ref> [6] </ref> have shown that all functions f have multioracle ihs's, thus settling a question of Rivest [24]. In this paper, we introduce the notion of an instance-hiding proof system (ihps) for a function f and characterize the functions that have such systems. <p> The verifier's view of the interaction, denoted V iew (V; x), is hT (V; P 1 ; x); : : : ; T (V; P m ; x); Ri, where R is the distribution of V 's random coins. Definition 2.1 <ref> [1, 6] </ref>: The protocol (V; P 1 ; : : : ; P m ) is an m-oracle instance-hiding scheme (ihs) for the function f if it satisfies the following properties. (i) For all x, Prob ((V (x); P 1 ; : : : ; P m ) = f (x))
Reference: [7] <author> D. Beaver, J. Feigenbaum, J. Kilian, and P. Rogaway. </author> <title> Security with Low Communication Overhead, </title> <booktitle> Advances in Cryptology - Crypto '90, Lecture Notes in Computer Science, </booktitle> <volume> vol. 537, </volume> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1991, </year> <pages> pp. 62-76. </pages>
Reference-contexts: Furthermore, it is shown in [3] that the class MIP of languages recognized by multiprover ips's is equal to the complexity class NEXP = NTIME (2 poly ). In an instance-hiding scheme (ihs) for a function f (cf. <ref> [1, 6, 7] </ref>), the input x is on a private tape, accessible only to the querier V . <p> In this model, V does not entrust any information about x to the provers, but it does have to trust the provers to answer questions correctly. Because their answers are trusted, the powerful players are referred to as "oracles" in <ref> [1, 6, 7] </ref>, rather than "provers." Beaver and Feigenbaum [6] have shown that all functions f have multioracle ihs's, thus settling a question of Rivest [24]. <p> Note that it is not even known whether a constant number of provers suffice for the construction of instance-hiding schemes for boolean functions in FNEXP|the best known upper bound for the number of provers is n= log n and is given by the generic construction in <ref> [7] </ref>. Thus obtaining general ihps's with a constant number of provers may be impossible and, in any case, seems to require a new technique. Theorem 3 (in particular Lemma 5.2) was proven under the assumption that one-way permutations exist.
Reference: [8] <author> D. Beaver, J. Feigenbaum, and V. Shoup. </author> <title> Hiding Instances in Zero-Knowledge Proof Systems, </title> <institution> AT&T Bell Laboratories Technical Memorandum, </institution> <month> April 12, </month> <year> 1990. </year>
Reference-contexts: Sections 3 and 4 contains the proofs of Theorems 1 and 2, respectively. Section 5 contains the proof of Theorem 3. In Section 6, we state some open problems. Most of these results first appeared in our Technical Memoranda <ref> [8, 12] </ref>. 2 Preliminaries We now formally define ihs's, ihps's, and the notion of zero-knowledge that is appropriate in our setting, where the prover does not know the input.
Reference: [9] <author> M. Ben-Or, S. Goldwasser, J. Kilian, and A. Wigderson. </author> <title> Multiprover Interactive Proof Systems: How to Remove Intractability Assumptions, </title> <booktitle> Proc. 20th Annual Symposium on Theory of Computing, Association for Computing Machinery, </booktitle> <address> New York, </address> <year> 1988, </year> <pages> pp. 113-131. </pages>
Reference-contexts: University of Toronto, Computer Science Department, Toronto, Ontario M5S 1A4, CANADA, shoup@cs.toronto.edu. Work done at AT&T Bell Laboratories as a Postdoctoral Fellow in Theoretical Computer Science. 1 In an interactive proof system (ips) for a language L (cf. <ref> [4, 16, 9] </ref>), the input x is on a shared tape, accessible to the verifier and provers. If x is in L, the ips allows V to obtain convincing evidence of this fact. Because it obtains this evidence, V need not trust the provers to behave correctly. <p> For the purpose of constructing zero-knowledge protocols, it is convenient to assume, as in <ref> [9] </ref>, that the provers have access to a shared random tape that is not accessible to V . We prove the following. Theorem 2 Every function f 2 FNEXP has a perfect zero-knowledge instance-hiding proof system. <p> On inputs x 2 L, V accepts with probability 1. On inputs x =2 L, V rejects with probability at least 1=poly. Proof: By the "completeness theorem" of <ref> [9] </ref> and the "probabilistic oracle machine" characterization of [13], we may assume that there is a polynomial-time deterministic oracle machine such that 1. for all x 2 L, there exists an oracle E such that for all r, E (x; r) = 1; 2. for all x =2 L, for all <p> We present them here in some detail only to make our arguments about zero-knowledge and instance-hiding more transparent. 8 4.1.1 Bit Commitment Using the shared random tape, simple bit commitment can be implemented in a very simple way as in <ref> [9] </ref>. In the bit commitment scheme, there are two protocols: a bit commit protocol and a bit reveal protocol. Several provers can easily commit to the same random bit by simply taking that bit from the shared random tape. Only one of the provers actually executes the bit commit protocol. <p> protocol can be used in an ihps, note that the verifier does not send anything to the prover except during the prove protocol; as we have seen in Section 4.1.2, this reveals nothing about the input except its length. 4.2 A Zero-Knowledge MIP Protocol Zero-knowledge multiprover ips's were introduced in <ref> [9] </ref>. There it is shown that any language in MIP has a statistical zero-knowledge multiprover ips. Kilian [18] has shown that, in fact, any language in MIP has a perfect zero-knowledge multiprover ips.
Reference: [10] <author> M. Ben-Or, O. Goldreich, S. Goldwasser, J. H-astad, J. Kilian, S. Micali, and P. Rogaway. </author> <title> Everything Provable is Provable in Zero-Knowledge, </title> <booktitle> Advances in Cryptology - Crypto '88, Lecture Notes in Computer Science, </booktitle> <volume> vol. 403, </volume> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1990, </year> <pages> pp. 37-56. </pages>
Reference-contexts: Likewise, the protocols are easily employed in an ihps, because all the provers see are two random bits. 4.1.2 Multiple-use Notarized Envelopes In <ref> [10] </ref> it is shown how to construct a notarized envelope scheme from a protocol for simple bit commitment. There are two protocols: a notarized bit commit protocol and a prove protocol. The notarized bit commit protocol allows a prover to commit a bit. <p> We now present a notarized envelope scheme that is essentially the same as the one given in <ref> [10] </ref>. The restriction in [10] that a notarized envelope can be used in only one proof is just an artifact of the implementation that can easily be lifted. <p> We now present a notarized envelope scheme that is essentially the same as the one given in <ref> [10] </ref>. The restriction in [10] that a notarized envelope can be used in only one proof is just an artifact of the implementation that can easily be lifted. <p> Instead of representing a bit b as the sum c 1 c 2 , where c 1 and c 2 are committed using an ordinary bit commitment protocol (as done in <ref> [10] </ref>), we can represent b as the sum c 1 c m , which allows b to be used in m 1 proofs. <p> He then checks that j was selected according to the input bit and that t j = 1 j1 j j . The fact that these protocols satisfy the properties of a notarized envelope scheme is proven in <ref> [10] </ref>. When the protocols are used in a zero-knowledge proof system, a simulator can generate the corresponding part of the transcript provided it can generate with the correct distribution the values of all bits revealed during the protocols.
Reference: [11] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Program Result Checking Against Adaptive Programs and in Cryptographic Settings, </title> <journal> Distributed Computing and Cryptography, DIMACS Series on Discrete Mathematics and Theoretical Computer Science, </journal> <volume> vol. 2, </volume> <publisher> American Mathematical Society, </publisher> <address> Providence, </address> <year> 1991, </year> <pages> pp. 107-118. </pages>
Reference-contexts: We prove the following. Theorem 2 Every function f 2 FNEXP has a perfect zero-knowledge instance-hiding proof system. We remark that the notion of private/adaptive checker, which was introduced by Blum, Luby and Rubinfeld <ref> [11] </ref>, may be viewed as a restricted form of ihps in which the provers are only asked questions of the form "what is f (y)?" The ihps's exhibited in the proofs of Theorems 1 and 2 require a polynomial number of provers. We also address the power of one-prover ihps's.
Reference: [12] <author> J. Feigenbaum and R. Ostrovsky. </author> <title> A Note on One-Prover, Instance-Hiding, Zero-Knowledge Proof Systems, </title> <institution> AT&T Bell Laboratories Technical Memorandum, </institution> <month> June 12, </month> <year> 1991. </year>
Reference-contexts: Sections 3 and 4 contains the proofs of Theorems 1 and 2, respectively. Section 5 contains the proof of Theorem 3. In Section 6, we state some open problems. Most of these results first appeared in our Technical Memoranda <ref> [8, 12] </ref>. 2 Preliminaries We now formally define ihs's, ihps's, and the notion of zero-knowledge that is appropriate in our setting, where the prover does not know the input.
Reference: [13] <author> L. Fortnow, J. Rompel, and M. Sipser. </author> <title> On the Power of Multiprover Interactive Protocols, </title> <booktitle> Proc. 3rd Annual Structure in Complexity Theory Conference, </booktitle> <publisher> Institute of Electrical and Electronics Engineers Computer Society Press, Los Alamitos, </publisher> <year> 1988, </year> <pages> pp. 156-161. </pages>
Reference-contexts: On inputs x 2 L, V accepts with probability 1. On inputs x =2 L, V rejects with probability at least 1=poly. Proof: By the "completeness theorem" of [9] and the "probabilistic oracle machine" characterization of <ref> [13] </ref>, we may assume that there is a polynomial-time deterministic oracle machine such that 1. for all x 2 L, there exists an oracle E such that for all r, E (x; r) = 1; 2. for all x =2 L, for all oracles E, the probability that E (x; r) <p> The argument that the verifier accepts or rejects with the desired probability is found in <ref> [13] </ref>. 3 Proof of Theorem 1 3.1 Arithmetization of Boolean Functions Let f : f0; 1g fl ! f0; 1g be any Boolean function. For any n 1, we denote by K a fixed finite field such that n + 2 jKj = O (n).
Reference: [14] <author> Z. Galil, S. Haber, and M. Yung. </author> <title> Minimum-Knowledge Interactive Proofs for Decision Problems, </title> <journal> SIAM J. Comput. </journal> <volume> 18 (1989), </volume> <pages> pp. 711-739. </pages>
Reference-contexts: Because it obtains this evidence, V need not trust the provers to behave correctly. One may also consider ips's for functions f in which the verifier learns f (x) and obtains convincing evidence of the correctness of this value <ref> [14] </ref>. It is known [19, 25] that the class IP of languages recognized by 1-prover ips's is equal to the complexity class PSPACE.
Reference: [15] <author> S. Goldreich, S. Micali and A. Wigderson. </author> <title> How to Play ANY Mental Game, </title> <booktitle> Proc. 19th Annual Symposium on Theory of Computing, Association for Computing Machinery, </booktitle> <address> New York, </address> <year> 1987, </year> <pages> pp. 218-229. </pages>
Reference-contexts: COT with reversed roles of S and R is also possible. In [26], an implementation of COT based on factoring is given. In <ref> [15] </ref>, an implementation based on trapdoor permutations is presented. Finally, in [22], it is shown how to implement COT based on any one-way function. We separate the proof Theorem 3 into two lemmas. The assumption that one-way permutations exist is only needed for the second.
Reference: [16] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proof Systems, </title> <journal> SIAM J. Comput. </journal> <volume> 18 (1989), </volume> <pages> pp. 186-208. </pages>
Reference-contexts: University of Toronto, Computer Science Department, Toronto, Ontario M5S 1A4, CANADA, shoup@cs.toronto.edu. Work done at AT&T Bell Laboratories as a Postdoctoral Fellow in Theoretical Computer Science. 1 In an interactive proof system (ips) for a language L (cf. <ref> [4, 16, 9] </ref>), the input x is on a shared tape, accessible to the verifier and provers. If x is in L, the ips allows V to obtain convincing evidence of this fact. Because it obtains this evidence, V need not trust the provers to behave correctly.
Reference: [17] <author> J. Kilian. </author> <title> Founding Cryptography on Oblivious Transfer, </title> <booktitle> Proc. 20th Annual Symposium on Theory of Computing, Association for Computing Machinery, </booktitle> <address> New York, </address> <year> 1988, </year> <pages> pp. 20-31. </pages>
Reference-contexts: We give an implementation of the protocol using a variant of Kilian's oblivious N C 1 circuit evaluation protocol <ref> [17] </ref>. Without loss of generality, we may assume that F is a Boolean-valued function. Recall the branching program representation of F and the notation of Section 4.1.2. The function evaluation protocol runs as follows. The provers put shared random permutations 1 ; : : : ; m1 in notarized envelopes.
Reference: [18] <author> J. Kilian. </author> <title> Uses of Randomness in Algorithms and Protocols, </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: There it is shown that any language in MIP has a statistical zero-knowledge multiprover ips. Kilian <ref> [18] </ref> has shown that, in fact, any language in MIP has a perfect zero-knowledge multiprover ips. In this section, we present a different proof that every language in MIP has a perfect zero-knowledge multiprover ips.
Reference: [19] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan. </author> <title> Algebraic Methods for Interactive Proof Systems, </title> <journal> J. Assoc. Comput. Mach. </journal> <volume> 39 (1992), </volume> <pages> pp. 859-868. </pages>
Reference-contexts: Because it obtains this evidence, V need not trust the provers to behave correctly. One may also consider ips's for functions f in which the verifier learns f (x) and obtains convincing evidence of the correctness of this value [14]. It is known <ref> [19, 25] </ref> that the class IP of languages recognized by 1-prover ips's is equal to the complexity class PSPACE. Furthermore, it is shown in [3] that the class MIP of languages recognized by multiprover ips's is equal to the complexity class NEXP = NTIME (2 poly ). <p> with input x 1 and prefix p, such that V (x 1 ; r; p) = q i is the same as the number of r's, consistent with input x 2 and prefix p, such that V (x 2 ; r; p) = q i " is a PSPACE statement <ref> [19, 25] </ref>. V 0 (resp. P 0 ) computes the questions q i (resp. the answers a i ) exactly as V (resp. P 0 ) computes them. <p> Suppose that a function f satisfies Definition 2.2. We may conclude immediately that f satisfies Definition 2.1 and that f has a one-prover ips; it is shown in <ref> [19, 25] </ref> that the latter is equivalent to the conclusion that f 2 FPSPACE. Thus, combining Lemmas 5.1 and 5.2 yields a proof of Theorem 3. 18 6 Open Problems The protocols given in Sections 3 and 4 require a polynomial number of provers.
Reference: [20] <author> M. Naor. </author> <title> Bit Commitment Using Pseudo-Randomness, </title> <editor> J. </editor> <booktitle> Cryptology 4 (1991), </booktitle> <pages> pp. 151-158. </pages>
Reference-contexts: V 0 then commits s 1 to P 0 using the weak-committer/strong-receiver protocol in [21, 23], and P 0 commits s 2 to V 0 using the strong-committer/weak-receiver protocol in <ref> [20] </ref>. In the execution phase of the protocol, the sequence r = r 1 r 2 : : : r l , where r i = s 1i s 2i , plays the role of the verifier's random input in (P; V ). <p> They could clearly be replaced with other values that are "very small" and "reasonably large" respectively. 17 We now give more details. Let E (y) denote the output of the strong-commit--ter/weak-receiver bit-commitment protocol of <ref> [20] </ref>. Note that the definition of bit-commitment implies that the probabilistic polynomial-time verifier V 0 cannot distinguish between E (y) and E (), where is a random string of the same length as y. The polynomial-space prover P 0 can of course compute y from E (y). <p> To prove that (P 0 ; V 0 ) is zero-knowledge, we use the simulatability properties of the COT protocol of [21, 22] and the bit-commitment protocol of <ref> [20] </ref>. Let C i denote the transcript of the i th execution of COT that takes place in the overall execution (P 0 ; V 0 )(x). <p> E (a j )) is distinguishable from E (2j t ) (resp. E ((2j + 1) t )), contradicting the result of <ref> [20] </ref>, or the simulator's output is distinguishable from the actual COT transcript C j , contradicting the results of [21, 22]. Suppose that a function f satisfies Definition 2.2.
Reference: [21] <author> M. Naor, R. Ostrovsky, R. Venkatesan, and M. Yung. </author> <title> Perfect Zero-Knowledge Arguments for NP Can Be Based on General Complexity Assumptions, </title> <booktitle> Advances in Cryptology - Crypto '92, Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <address> Berlin, </address> <note> to appear. </note>
Reference-contexts: V 0 then commits s 1 to P 0 using the weak-committer/strong-receiver protocol in <ref> [21, 23] </ref>, and P 0 commits s 2 to V 0 using the strong-committer/weak-receiver protocol in [20]. <p> To prove that (P 0 ; V 0 ) is zero-knowledge, we use the simulatability properties of the COT protocol of <ref> [21, 22] </ref> and the bit-commitment protocol of [20]. Let C i denote the transcript of the i th execution of COT that takes place in the overall execution (P 0 ; V 0 )(x). <p> By "round j" of an execution of (P 0 ; V 0 )(x), we mean the part that produces (C j ; E (q j ); E (a j )). Our simulator M V fl (x) works as follows: For round j, it runs the simulator from <ref> [21, 22] </ref> of a COT protocol that has output (E (2j t ); E ((2j + 1) t )). After round m, M V fl (x) makes one query to an f -oracle and outputs f (x). <p> E (a j )) is distinguishable from E (2j t ) (resp. E ((2j + 1) t )), contradicting the result of [20], or the simulator's output is distinguishable from the actual COT transcript C j , contradicting the results of <ref> [21, 22] </ref>. Suppose that a function f satisfies Definition 2.2. We may conclude immediately that f satisfies Definition 2.1 and that f has a one-prover ips; it is shown in [19, 25] that the latter is equivalent to the conclusion that f 2 FPSPACE.
Reference: [22] <author> R. Ostrovsky, R. Venkatesan, and M. Yung. </author> <title> Fair Games Against an All-Powerful Adversary, SEQUENCES '91, </title> <address> Positano, </address> <month> June, </month> <year> 1991. </year> <note> Final version to appear in DIMACS Series on Discrete Mathematics and Theoretical Computer Science, </note> <year> 1993. </year>
Reference-contexts: COT with reversed roles of S and R is also possible. In [26], an implementation of COT based on factoring is given. In [15], an implementation based on trapdoor permutations is presented. Finally, in <ref> [22] </ref>, it is shown how to implement COT based on any one-way function. We separate the proof Theorem 3 into two lemmas. The assumption that one-way permutations exist is only needed for the second. Lemma 5.1 Suppose that f 2 FPSPACE and has a one-oracle instance-hiding scheme. <p> Intuitively, the execution phase is constructed by replacing each move of V by a COT protocol and replacing each answer of P with an encrypted answer. This can be accomplished if we have a COT protocol that can be simulated in a zero-knowledge fashion. Fortunately, Ostrovsky, Venkatesan, and Yung <ref> [22] </ref> provide such a protocol, assuming that one-way permutations exist. (If zero-knowledge simulators are not required, then a general one-way function suffices for COT [22].) 2 The values 2 n and 1=8 that we use in these definitions are chosen simply because they fit nicely with the error probability 1=4 used <p> This can be accomplished if we have a COT protocol that can be simulated in a zero-knowledge fashion. Fortunately, Ostrovsky, Venkatesan, and Yung <ref> [22] </ref> provide such a protocol, assuming that one-way permutations exist. (If zero-knowledge simulators are not required, then a general one-way function suffices for COT [22].) 2 The values 2 n and 1=8 that we use in these definitions are chosen simply because they fit nicely with the error probability 1=4 used in the definition of ihs. <p> To prove that (P 0 ; V 0 ) is zero-knowledge, we use the simulatability properties of the COT protocol of <ref> [21, 22] </ref> and the bit-commitment protocol of [20]. Let C i denote the transcript of the i th execution of COT that takes place in the overall execution (P 0 ; V 0 )(x). <p> By "round j" of an execution of (P 0 ; V 0 )(x), we mean the part that produces (C j ; E (q j ); E (a j )). Our simulator M V fl (x) works as follows: For round j, it runs the simulator from <ref> [21, 22] </ref> of a COT protocol that has output (E (2j t ); E ((2j + 1) t )). After round m, M V fl (x) makes one query to an f -oracle and outputs f (x). <p> E (a j )) is distinguishable from E (2j t ) (resp. E ((2j + 1) t )), contradicting the result of [20], or the simulator's output is distinguishable from the actual COT transcript C j , contradicting the results of <ref> [21, 22] </ref>. Suppose that a function f satisfies Definition 2.2. We may conclude immediately that f satisfies Definition 2.1 and that f has a one-prover ips; it is shown in [19, 25] that the latter is equivalent to the conclusion that f 2 FPSPACE.
Reference: [23] <author> R. Ostrovsky, R. Venkatesan, and M. Yung. </author> <title> Secure Commitment Against A Powerful Adversary, </title> <booktitle> Proc. 9th Annual Symposium on Theoretical Aspects of Computer Science, Lecture Notes in Computer Science, </booktitle> <volume> vol. 577, </volume> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1992, </year> <pages> pp. 439-448. </pages>
Reference-contexts: V 0 then commits s 1 to P 0 using the weak-committer/strong-receiver protocol in <ref> [21, 23] </ref>, and P 0 commits s 2 to V 0 using the strong-committer/weak-receiver protocol in [20].
Reference: [24] <author> R. Rivest. </author> <title> Workshop on Communication and Computing, </title> <publisher> MIT, </publisher> <address> Cambridge, </address> <month> October, </month> <year> 1986. </year> <month> 20 </month>
Reference-contexts: Because their answers are trusted, the powerful players are referred to as "oracles" in [1, 6, 7], rather than "provers." Beaver and Feigenbaum [6] have shown that all functions f have multioracle ihs's, thus settling a question of Rivest <ref> [24] </ref>. In this paper, we introduce the notion of an instance-hiding proof system (ihps) for a function f and characterize the functions that have such systems.
Reference: [25] <author> A. Shamir. </author> <title> IP = PSPACE, </title> <journal> J. Assoc. Comput. Mach. </journal> <volume> 39 (1992), </volume> <pages> pp. 869-877. </pages>
Reference-contexts: Because it obtains this evidence, V need not trust the provers to behave correctly. One may also consider ips's for functions f in which the verifier learns f (x) and obtains convincing evidence of the correctness of this value [14]. It is known <ref> [19, 25] </ref> that the class IP of languages recognized by 1-prover ips's is equal to the complexity class PSPACE. Furthermore, it is shown in [3] that the class MIP of languages recognized by multiprover ips's is equal to the complexity class NEXP = NTIME (2 poly ). <p> with input x 1 and prefix p, such that V (x 1 ; r; p) = q i is the same as the number of r's, consistent with input x 2 and prefix p, such that V (x 2 ; r; p) = q i " is a PSPACE statement <ref> [19, 25] </ref>. V 0 (resp. P 0 ) computes the questions q i (resp. the answers a i ) exactly as V (resp. P 0 ) computes them. <p> Suppose that a function f satisfies Definition 2.2. We may conclude immediately that f satisfies Definition 2.1 and that f has a one-prover ips; it is shown in <ref> [19, 25] </ref> that the latter is equivalent to the conclusion that f 2 FPSPACE. Thus, combining Lemmas 5.1 and 5.2 yields a proof of Theorem 3. 18 6 Open Problems The protocols given in Sections 3 and 4 require a polynomial number of provers.
Reference: [26] <author> A. C. Yao. </author> <title> How to Generate and Exchange Secrets, </title> <booktitle> Proc. 27th Annual Symposium on Foundations of Computer Science, </booktitle> <publisher> Institute of Electrical and Electronics Engineers Computer Society Press, Los Alamitos, </publisher> <year> 1986, </year> <pages> pp. 162-167. 21 </pages>
Reference-contexts: : : : ; z 0 Once the simulator has generated the value of F , it can simulate the conversation that occurs in step B5 in the manner described in Section 4.1.3. 5 Proof of Theorem 3 The proof of this theorem uses Combined Oblivious Transfer (COT), introduced in <ref> [26] </ref>. In this two-party protocol, player S (the sender) has a private input x, and player R (the receiver) has a private input y. They are also given a polynomial-size circuit C (; ). <p> At the end of the protocol, R learns C (x; y) (but does not learn anything about x that is not already revealed by C (x; y)), while S learns nothing. COT with reversed roles of S and R is also possible. In <ref> [26] </ref>, an implementation of COT based on factoring is given. In [15], an implementation based on trapdoor permutations is presented. Finally, in [22], it is shown how to implement COT based on any one-way function. We separate the proof Theorem 3 into two lemmas.
References-found: 26

