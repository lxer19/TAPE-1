URL: http://www-icparc.doc.ic.ac.uk/papers/applying_constraints_for_scheduling.ps
Refering-URL: http://www-icparc.doc.ic.ac.uk/papers.html
Root-URL: 
Title: Abstract  
Abstract: Different classes of scheduling problems are outlined, with emphasis on the constraints they involve. The application of constraint propagation to these problems is explained, and problem features which undermine its effectiveness are highlighted. We show which mechanisms restore the effectiveness of constraint logic programming for some such features, and how CLP can be extended to cope with the others. 
Abstract-found: 1
Intro-found: 1
Reference: [AB92] <author> A. Aggoun and N. Beldiceanu. </author> <title> Extending CHIP in order to solve complex scheduling problems. </title> <booktitle> In Proc. </booktitle> <address> JFPL, Lille, </address> <year> 1992. </year>
Reference-contexts: The use of global constraints for solving complex tasks has been explored within the CHIP context by devising and hard wiring specific constraints [Bel90]. A hard wired global constraint for scheduling has been built into CHIP <ref> [AB92] </ref>, and used for finding an optimal solution to the 10X10 job-shop 11 scheduling problem. A global constraint can be as complex as required. From a purely theoretical point of view the whole job-shop scheduling problem could be "wrapped up" as a global constraint.
Reference: [All83] <author> James F. Allen. </author> <title> Maintaining knowledge about temporal intervals. </title> <journal> Communications of the ACM, </journal> <volume> 26 </volume> <pages> 832-843, </pages> <year> 1983. </year>
Reference-contexts: The problem of disjunctive constraints, in this sense, is the first reason why scheduling is such a hard problem. Complete algorithms for reasoning about time intervals <ref> [All83] </ref> and time points [VK86] are known, but their cost is exponential. We have now reached the "pure" job shop scheduling problem. In this problem there are several jobs to be scheduled, each job comprising several tasks.
Reference: [All84] <author> James F. Allen. </author> <title> Towards a general theory of action and time. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 123-154, </pages> <year> 1984. </year>
Reference-contexts: Each individual task runs for a certain duration, which can be viewed as a temporal interval, so the temporal constraints between tasks can be represented as constraints on these intervals. Seven such interval constraints have been identified <ref> [All84] </ref>, of which we have encountered two, bef ore and meets, in the examples above.
Reference: [Bau89] <author> G. Baues. </author> <title> Einsatz der constraint-logic-programming-sprache CHIP bei der loesung eines job-shop-scheduling-problems. </title> <type> Master's thesis, </type> <institution> Technische Universitat Munchen, Munich, Germany, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Some of the tasks must be completed before others can start. Other temporal constraints on tasks can also arise. For example in an application of CHIP to wafer fabrication <ref> [Bau89] </ref> the next task had to start as soon as the previous one finished, since the wafers would be damaged by any waiting between two stages of the production.
Reference: [Bel90] <author> N. Beldiceanu. </author> <title> An example of introduction of global constraints in CHIP: Application to block theory problems. </title> <type> Technical Report TR-LP-49, </type> <institution> ECRC, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: The use of global constraints for solving complex tasks has been explored within the CHIP context by devising and hard wiring specific constraints <ref> [Bel90] </ref>. A hard wired global constraint for scheduling has been built into CHIP [AB92], and used for finding an optimal solution to the 10X10 job-shop 11 scheduling problem. A global constraint can be as complex as required.
Reference: [Bla92] <author> B.A. Blake. </author> <title> Assignment of independent tasks to minimize completion time. </title> <journal> Software Practice and Experience, </journal> <volume> 22(9), </volume> <year> 1992. </year>
Reference-contexts: An archetypal reactive scheduling problem is the scheduling of processes on a multi-processor computer system. On the assumption that the communication between processes is not a significant factor, a very naive approach can show a very good performance <ref> [Bla92] </ref>. It is suffices, in this case, for each new process to be queued on the processor which spawned it; whenever a processor becomes free it takes a process from the processor with the longest queue.
Reference: [CA92] <author> N. Christodoulou and V. Assimakopoulos. </author> <title> Constraint handling in vehicle-fleet scheduling: Modelization and formulation using CHIP. </title> <type> Technical Report doc-1.2, </type> <institution> CMSU, </institution> <year> 1992. </year> <note> CHIC report. </note>
Reference-contexts: Additionally there is a choice of different machines and also a due date for each task. This extended problem maps to an extended TSP called the "vehicle scheduling problem" (VSP) with multiple delivery vehicles and time windows for visiting locations <ref> [CA92] </ref>. Optimisation A typical feature of scheduling problems is the requirement for optimisation. This is a major challenge even for pure job-shop scheduling problems; for example proof of optimality has been obtained for a 10 job/10 machine problem only in 1988 [Pin88].
Reference: [CDNT92] <author> T.-L. Chew, J.-M. David, L. Nguyen, and Y. Tourbier. </author> <title> Le car sequencing problem revisite: </title> <institution> analyse d'une utilisation du recuit simule. </institution> <type> Technical report, </type> <institution> RENAULT, Service Systemes Experts, </institution> <year> 1992. </year>
Reference-contexts: For many hard search problems, such as the travelling salesman problem, assembly-line sequencing, and scheduling, approximation algorithms have been used very successfully <ref> [Muh92, CDNT92, MJPL92] </ref>. Such methods are often viewed as an alternative to constrained search. In fact constraints can be used with approximation algorithms in exactly the same way they are used with enumeration algorithms: the choice of approximation or enumeration is independent of the use of constraints.
Reference: [CF93] <author> A. Chamard and A. Fischler. </author> <title> Applying CHIP to a complex scheduling problem. </title> <type> Technical Report D3.1.2, </type> <institution> Dassault Aviation, </institution> <year> 1993. </year> <note> CHIC report. </note>
Reference-contexts: ask1) &lt; start (T ask2) contention (T ask1; T ask2) start (T ask2) + duration (T ask2) &lt; start (T ask1) 2 Our syntax for rules is not the CHIP compiler syntax 9 However for many problems such an approach introduces too many choice points and yields an unsatisfactory performance <ref> [CF93] </ref>. Disjunctive constraints can be used completely passively, by simply checking them for consistency. In this case the constraint is not used to prune the domains of any problem variables, it merely causes failure if, at any point in the search, all the disjuncts are inconsistent. <p> When only one consistent disjunct remains, it is imposed as an active constraint, and can be used for pruning the domains of the remaining variables. The simplest way to achieve this behaviour is to introduce an auxiliary variable with a binary domain <ref> [CF93] </ref>. In fact it has proved effective to include the auxiliary variable in the labelling routine. <p> In [DSVH90] various ways of using disjunctive constraints for a scheduling problem were investigated. The constraints were used for lookahead a powerful form of propagation for forward checking which corresponds approximately to the weak form of propagation proposed by <ref> [CF93] </ref> - and as choice points. For the particular scheduling application at hand, the use of disjunctive constraints as choice points proved to be most efficient! Generalised propagation [LW93] allows the disjunctive constraints to be expressed as ordinary Prolog rules (as in the first example above).
Reference: [DB87] <author> T. Dean and M. Boddy. </author> <title> An analysis of time-dependent planning. </title> <booktitle> In Proc. IJCAI, </booktitle> <year> 1987. </year>
Reference-contexts: A goal of current research is to design algorithms which behave reactively when given a small processing time, but behave predictively when more time is available <ref> [DB87] </ref>. Optimisation with "Soft" and Probabilistic Constraints Op-timisation is already difficult in case all the constraints have a logical semantics: true or false.
Reference: [dK86] <author> J. de Kleer. </author> <title> An assumption-based tms. </title> <journal> Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 127-162, </pages> <year> 1986. </year>
Reference-contexts: A problem which had been solved with CHIP [DSVH88] was solved even more efficiently by the new approach which used dynamically generated nogood assertions to prune branches of the search tree [MMST92]. The idea is based on the concept of nogood environments introduced by Assumption-Based Truth Maintenance Systems <ref> [dK86] </ref>. 12 As an example, suppose a customer requires 200 thin boards and 300 fat ones. The raw material comes in large sheets which can be cut in a fixed number of different ways.
Reference: [DSVH88] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving a cutting-stock problem in constraint programming. </title> <publisher> In M.I.T Press, </publisher> <editor> editor, </editor> <booktitle> Fifth International Conference on Logic ming (ICLP'88), </booktitle> <address> Seattle, USA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: A problem which had been solved with CHIP <ref> [DSVH88] </ref> was solved even more efficiently by the new approach which used dynamically generated nogood assertions to prune branches of the search tree [MMST92].
Reference: [DSVH90] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving large combinatorial problems in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 8, </volume> <year> 1990. </year>
Reference-contexts: Either one task must run first imposing one constraint on the final schedule or the other runs first in which case a different constraint must be imposed. Such disjunctive constraints have been dealt with in CHIP by simply choosing one disjunct during the search process <ref> [DSVH90] </ref>. <p> The amount of propagation invested in a disjunctive constraint has a significant effect on overall performance. In <ref> [DSVH90] </ref> various ways of using disjunctive constraints for a scheduling problem were investigated. The constraints were used for lookahead a powerful form of propagation for forward checking which corresponds approximately to the weak form of propagation proposed by [CF93] - and as choice points.
Reference: [DVHS + 88] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. </author> <title> The constraint logic programming language chip. </title> <booktitle> 22 In Proceedings of the International Conference on Fifth Genera--tion Computer Systems (FGCS'88), </booktitle> <pages> pages 693-702, </pages> <address> Tokyo, Japan, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: In this paragraph we focus on the search component of CLP. Firstly, the control of the search is program defined: both the order in which choices are made, and the order in which alternatives are chosen, are specified by the programmer. In CHIP <ref> [DVHS + 88] </ref> new constraints can even be added during the search process. The classic form of a CLP program, however, separates the posting of the constraints from the search procedure.
Reference: [FH93] <author> T. Fruhwirth and Ph. Hanschke. </author> <title> Terminological reasoning with constraint handling rules. </title> <booktitle> In First Workshop on the Principles and Practice of Constraint Programming, </booktitle> <address> Newport, RI, USA, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: Multiple choices arise naturally, for example, when there are multiple tasks in contention for one, or even several, machines. To avoid an increasing number of auxiliary variables, it is possible to obtain a similar constraint behaviour by using simplification rules (CHR's) <ref> [FH93] </ref>.
Reference: [Fru92] <author> T. Fruhwirth. </author> <title> Constraint simplification rules. </title> <type> Technical Report ECRC-92-18, </type> <institution> ECRC, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: Generalised propagation can produce new constraints of the specific class which can be treated by the constraint solver. Constraint simplification is a technique that improves the efficiency of constraint solving, however the same technique can be adapted to provide program-defined constraint propagation. Con 8 straint simplification rules <ref> [Fru92] </ref> allow the programmer to encode specific simplification and propagation steps, giving him precise control over the handling of constraints. In this paragraph we focus on the search component of CLP.
Reference: [FSB89] <author> M.S. Fox, N. Sadeh, and C. Baycan. </author> <title> Constrained heuristic search. </title> <booktitle> In Proc. IJCAI, </booktitle> <pages> pages 309-316, </pages> <year> 1989. </year>
Reference-contexts: The other parts of the schedule can then be fitted around the bottlenecks. This is often known as the "first fail" principle. To identify bottlenecks the concept of variable "tightness" was introduced in <ref> [FSB89] </ref>. A tight variable is one that eliminates lots of possible solutions.
Reference: [IS65] <author> E. Ignall and L. </author> <title> Schrage. Application of the branch and bound technique to some flow-shop scheduling problems. </title> <journal> Operations Research Quarterly, </journal> <volume> 13(3), </volume> <year> 1965. </year>
Reference-contexts: The only difference between jobs are the task durations. When there are three machines or less, the jobs can always be run in the same sequence on all three machines <ref> [IS65] </ref>. 1 However if there are four or more machines it is easy to construct examples where the "best" solution has jobs running in different sequences on different machines.
Reference: [JL87] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Principles of Programming Languages (POPL'87), </booktitle> <address> Munich, FRG, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: In this paragraph we summarise the different ways of handling constraints: solving, propagation and simplification. The CLP Scheme <ref> [JL87] </ref> is a generalisation of logic programming where constraints are handled by a solver for a specific class of constraints: each instance of the scheme deals with a different constraint class. Essentially the role of the solver is to detect inconsistency.
Reference: [Kuc92] <author> V. Kuchenhoff. </author> <title> Novel search and constraints an integration. </title> <type> Technical report, </type> <institution> ECRC, </institution> <year> 1992. </year> <note> CHIC deliverable. </note>
Reference-contexts: Experiments we have carried out show that constraints bring the same benefits of simplicity and efficiency when used with approximation algorithms that they do with enumeration algorithms <ref> [Kuc92] </ref>. Intuitively, approximation algorithms such as hill-climbing, simulated annealing and genetic algorithms, work when solutions which are similar have a broadly similar cost: the cost function is in a loose sense continuous. <p> The latter variables are subsequently labelled under the constraints in the usual CLP manner. The constrained TSP problem was too large too be solved by enumeration techniques, but very good solutions were found by the constrained genetic algorithm. These experiments are described in more detail in another deliverable <ref> [Kuc92] </ref>. Our experiments and our work on the theoretical foundations of constrained approximation are still in progress. Based on early results we are optimistic that the technique will be effective for a broad range of problems.
Reference: [Le 93] <author> T. Le Provost. </author> <title> Approximate generalised propagation. </title> <type> Technical report, </type> <institution> ECRC, </institution> <year> 1993. </year> <note> CHIC deliverable. </note>
Reference-contexts: When the constraint is invoked as a goal it is then possible to specify how it should be used for propagation, or for search. A way of experimenting with different amounts of propagation is offered by approximate generalised propagation <ref> [Le 93] </ref>. The advantage is that different amounts of propagation can be achieved by modifying a single parameter.
Reference: [Lep91] <author> C. Lepape. </author> <title> Constraint propagation in planning and scheduling. </title> <type> Technical report, </type> <institution> Robotics Lab., Stanford Univ., </institution> <month> Jan </month> <year> 1991. </year>
Reference-contexts: The amount of propagation which should be performed to obtain the best overall scheduling performance is not fixed for all scheduling problems nor even for the whole scheduling process for a single problem. Experiments described in <ref> [Lep91] </ref> show that the amount of propagation should be tailored to the current requirements of the scheduler.
Reference: [LS87] <author> C. Lepape and S. F. Smith. </author> <title> Management of temporal constraints for factory scheduling. </title> <booktitle> In IFIP Working Conf. on Temporal Aspects in Information Systems, </booktitle> <year> 1987. </year>
Reference-contexts: Two variables constrained by a common set of constraints should be labelled in such a way as to minimise this contention. 3.7 Preference Propagation In order to use the measures of tightness and contention outlined above, some technique of estimating them is required. The techniques described in <ref> [LS87] </ref> and [SF89] are based on constraint propagation. In this context, the purpose of propagation is not to eliminate impossible values from the domains of variables, but rather to identify degrees of freedom for variables and sources of contention. A simple motivating example of preference propagation is in [SRSF91].
Reference: [LW93] <author> T. Le Provost and M. G. Wallace. </author> <title> Generalised constraint propagation over the CLP scheme. </title> <journal> Journal of Logic Programming, </journal> <note> 1993. To appear. </note>
Reference-contexts: Constraint propagation can be less powerful but more efficient than constraint solving. Propagation does not always detect inconsistency amongst the current constraints, but when augmented by a (program defined) variable labelling procedure, completeness is restored in the sense that any inconsistency will be eventually detected. Generalised propagation <ref> [LW93] </ref> supports propagation without finite domains. Generalised propagation can produce new constraints of the specific class which can be treated by the constraint solver. Constraint simplification is a technique that improves the efficiency of constraint solving, however the same technique can be adapted to provide program-defined constraint propagation. <p> For the particular scheduling application at hand, the use of disjunctive constraints as choice points proved to be most efficient! Generalised propagation <ref> [LW93] </ref> allows the disjunctive constraints to be expressed as ordinary Prolog rules (as in the first example above). When the constraint is invoked as a goal it is then possible to specify how it should be used for propagation, or for search.
Reference: [MJPL92] <author> S. Minton, M. D. Johnston, A. B. Philips, and P. Laird. </author> <title> Minimizing conflicts: a heuristic repair method for constraint satisfaction and scheduling problems. </title> <journal> Artificial Intelligence, </journal> <volume> 58, </volume> <year> 1992. </year>
Reference-contexts: Approximation algorithms do not guarantee to find an optimal solution, but only to find a good solution with a high probability by exploring only a part of the solution space. The successful application of approximation to a scheduling problem is described in <ref> [MJPL92] </ref>. 2.2 Requirements Based on Probabilistic Infor mation and on Preferences A logical formulation of the scheduling problem is only possible on the assumption of complete precise information. A solution is a complete precise schedule satisfying the logical requirements. <p> The results of mid-term planning are fed into the short term planner as constraints. Another example is the scheduling of the Hubble Space Telescope <ref> [MJPL92] </ref>, which has been divided into two parts: a long term scheduling problem which assigns a year's work to a set of time segments of several days length, and a short term scheduling problem which produces a detailed sequence of commands for the telescope. <p> For many hard search problems, such as the travelling salesman problem, assembly-line sequencing, and scheduling, approximation algorithms have been used very successfully <ref> [Muh92, CDNT92, MJPL92] </ref>. Such methods are often viewed as an alternative to constrained search. In fact constraints can be used with approximation algorithms in exactly the same way they are used with enumeration algorithms: the choice of approximation or enumeration is independent of the use of constraints. <p> Therefore the elimination of infeasible solutions has to be achieved by a kind of trick. Violated constraints have an associated cost. For example in a hill-climbing algorithm for the n-queens problem <ref> [MJPL92] </ref> the cost of a solution is simply the number of pairs of queens which can take each other thenumber of violated constraints.
Reference: [MMCR92] <author> A. Montanari, E. Maim, E. Ciapessoni, and E. Ratto. </author> <title> Dealing with time granularity in the event calculus. </title> <booktitle> In Proc. FGCS, </booktitle> <address> Tokyo, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: In case two schedulers working at different granularities are integrated, there is a need to map events specified at one level of granularity to a higher or lower granularity. This problem is being tackled in the EQUATOR project <ref> [MMCR92] </ref>. 6 Scheduling and Rescheduling The data input to long term planning and scheduling systems is subject to change. Customers cancel or modify their orders, or change their due dates. Production processes and tools change, affecting task durations and setup times.
Reference: [MMST92] <author> F. Maruyama, Y. Minoda, Sawada S., and Y. Takizawa. </author> <title> Constraint satisfaction and optimisation using nogood justifications. </title> <booktitle> In Proc. 2nd Pacific Rim Conf. on AI, </booktitle> <year> 1992. </year>
Reference-contexts: A problem which had been solved with CHIP [DSVH88] was solved even more efficiently by the new approach which used dynamically generated nogood assertions to prune branches of the search tree <ref> [MMST92] </ref>. The idea is based on the concept of nogood environments introduced by Assumption-Based Truth Maintenance Systems [dK86]. 12 As an example, suppose a customer requires 200 thin boards and 300 fat ones.
Reference: [Muh92] <author> Heinz Muhlenbein. </author> <title> Parallel genetic algorithms and combinatorial optimization. </title> <journal> SIAM J. on Optimization, </journal> <year> 1992. </year> <month> 23 </month>
Reference-contexts: For many hard search problems, such as the travelling salesman problem, assembly-line sequencing, and scheduling, approximation algorithms have been used very successfully <ref> [Muh92, CDNT92, MJPL92] </ref>. Such methods are often viewed as an alternative to constrained search. In fact constraints can be used with approximation algorithms in exactly the same way they are used with enumeration algorithms: the choice of approximation or enumeration is independent of the use of constraints.
Reference: [Pin88] <author> E. Pinson. </author> <title> Le Probleme de Job Shop. </title> <type> PhD thesis, </type> <institution> Univ. Paris VI, </institution> <year> 1988. </year>
Reference-contexts: Optimisation A typical feature of scheduling problems is the requirement for optimisation. This is a major challenge even for pure job-shop scheduling problems; for example proof of optimality has been obtained for a 10 job/10 machine problem only in 1988 <ref> [Pin88] </ref>. The size of general TSP problems for which an optimum can be guaranteed to be found is around 30 locations.
Reference: [SF89] <author> N. Sadeh and M. S. Fox. </author> <title> Preference propagation in temporal/capacity constraint graphs. </title> <type> Technical Report CMU-RI-TR-89-2, </type> <institution> Robotics Institute, Carneggie Mellon Univ., </institution> <year> 1989. </year>
Reference-contexts: Two variables constrained by a common set of constraints should be labelled in such a way as to minimise this contention. 3.7 Preference Propagation In order to use the measures of tightness and contention outlined above, some technique of estimating them is required. The techniques described in [LS87] and <ref> [SF89] </ref> are based on constraint propagation. In this context, the purpose of propagation is not to eliminate impossible values from the domains of variables, but rather to identify degrees of freedom for variables and sources of contention. A simple motivating example of preference propagation is in [SRSF91].
Reference: [SRSF91] <author> K. P. Sycara, S.F. Roth, N. Sadeh, and M.S. Fox. </author> <title> Resourse allocation in distributed factory scheduling. </title> <journal> IEEE Expert, </journal> <year> 1991. </year>
Reference-contexts: In this context, the purpose of propagation is not to eliminate impossible values from the domains of variables, but rather to identify degrees of freedom for variables and sources of contention. A simple motivating example of preference propagation is in <ref> [SRSF91] </ref>. Consider a schedule involving four jobs, A; B; C and D which all have to run in a time period 0 15. Each job has a few tasks, each of which lasts 3 units of time, and which must be run in sequence. <p> It remains a subject of investigation, whether approximate generalised propagation can provide sufficient control to obtain the best amount of propagation for this application. Backtracking The other area of intense investigation in the scheduling world is how to control backtracking. One approach that has been proposed recently <ref> [SRSF91] </ref> is to distribute the search into separate processes. Each search process has access to global information, about tightness and contention and, later, resource consumption. However, it can only backtrack locally and the information it has contributed to the other processes is not removed.
Reference: [VHDT92] <author> P. Van Hentenryck, Y. Deville, and C.-M. Teng. </author> <title> A generic arc-consistency algorithm and its specialisations. </title> <journal> Artificial Intelligence, </journal> <volume> 57, </volume> <year> 1992. </year>
Reference-contexts: The scheduling problem characterised above is quite simple. All the constraints satisfy a monotonicity condition, which allows them to be solved by a polynomial propagation algorithm <ref> [VHDT92] </ref>. Resource Contention We now introduce the problem of resource contention, when we consider that tasks must be run on machines and there is a limited number of machines available. Suddenly the 3 problem become dramatically harder. <p> The cost of such powerful constraint handling for such problems is not prohibitive since the constraint problem is polynomial <ref> [VHDT92] </ref>. Contention for resources, as in the case that two tasks require the same machine, introduces a new difficulty. Either one task must run first imposing one constraint on the final schedule or the other runs first in which case a different constraint must be imposed.
Reference: [VK86] <author> Marc Vilain and Henry Kautz. </author> <title> Constraint propagation algorithms for temporal reasoning. </title> <booktitle> In Proc. AAAI-86, </booktitle> <pages> pages 377-382, </pages> <year> 1986. </year>
Reference-contexts: The problem of disjunctive constraints, in this sense, is the first reason why scheduling is such a hard problem. Complete algorithms for reasoning about time intervals [All83] and time points <ref> [VK86] </ref> are known, but their cost is exponential. We have now reached the "pure" job shop scheduling problem. In this problem there are several jobs to be scheduled, each job comprising several tasks.
Reference: [VSD92] <author> P. Van Hentenryck, H. Simonis, and M. Dincbas. </author> <title> Constraint satisfaction using constraint logic programming. </title> <journal> Artificial Intelligence, </journal> <volume> 58, </volume> <year> 1992. </year>
Reference-contexts: Essentially the role of the solver is to detect inconsistency. CHIP, and more generally cc (FD) <ref> [VSD92] </ref>, provides another way of handling constraints over finite domains: constraint propagation. Constraint propagation can be less powerful but more efficient than constraint solving.
References-found: 34

