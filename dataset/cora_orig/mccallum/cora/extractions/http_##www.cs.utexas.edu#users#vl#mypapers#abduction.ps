URL: http://www.cs.utexas.edu/users/vl/mypapers/abduction.ps
Refering-URL: http://www.cs.utexas.edu/users/vl/papers.html
Root-URL: 
Email: vl@cs.utexas.edu  hudson@cs.utexas.edu  
Phone: 2  
Title: From Disjunctive Programs to Abduction  
Author: Vladimir Lifschitz and Hudson Turner 
Address: Austin  Austin  
Affiliation: 1 Department of Computer Sciences and Department of Philosophy University of Texas at  Department of Computer Sciences University of Texas at  
Abstract: The purpose of this work is to clarify the relationship between three approaches to representing incomplete information in logic programming. Classical negation and epistemic disjunction are used in the first of these approaches, abductive logic programs with classical negation in the second, and a simpler form of abductive logic programming | without classical negation | in the third. In the literature, these ideas have been illustrated with examples related to properties of actions, and in this paper we consider an action domain also. We formalize this domain as a disjunctive program with classical negation, and then show how two abductive formalizations can be obtained from that program by a series of simple syntactic transformations. The three approaches under consideration turn out to be parts of a whole spectrum of different, but equivalent, ways of representing incomplete information.
Abstract-found: 1
Intro-found: 1
Reference: [AB90] <author> Krzysztof Apt and Marc Bezem. </author> <title> Acyclic programs. </title> <editor> In David Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 617-633, </pages> <year> 1990. </year>
Reference-contexts: The turkey is initially alive. The available actions are loading and shooting. We are interested in representing this action domain using the situation calculus and negation as failure. Early work of this kind is described in [EK89], [Eva89], <ref> [AB90] </ref> and [Gel91]. The subject is treated more systematically in several recent papers, including [GL93], [DDS93] and [Dun93]. We assume that the reader is familiar with the main ideas of this work. The following formulation of the two gun example is close to the one proposed in [Tur94].
Reference: [ABW88] <author> Krzysztof Apt, Howard Blair, and Adrian Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1988. </year>
Reference-contexts: definition of a "locally stratified" program [Prz88] when the set of atoms is defined as the set of ground atoms of a first-order language, and there is no classical negation. 4 This definition extends in a natural way the standard notion of "depends on" for nondisjunctive programs without classical negation <ref> [ABW88] </ref>.
Reference: [DDS93] <author> Mark Denecker and Danny De Schreye. </author> <title> Representing incomplete knowledge in abductive logic programming. </title> <editor> In Dale Miller, editor, </editor> <booktitle> Logic Programming: Proceedings of the 1993 Int'l Symposium, </booktitle> <pages> pages 147-163, </pages> <year> 1993. </year>
Reference-contexts: Classical negation and epistemic disjunction are used in the first of these approaches ([GL91], [Tur94]), abductive logic programs with classical negation in the second [Gel91], and a simpler form of abductive logic programming | without classical negation | in the third <ref> [DDS93] </ref>, [Dun93]. All these ideas have been illustrated with examples related to properties of actions, and in this paper we consider an action domain also. <p> Then, in Sections 4-9, we apply a series of six simple syntactic transformations to that program, so that a formulation in the spirit of [Gel91] is generated at one point along the way, and then a formulation in the spirit of <ref> [DDS93] </ref> is obtained. All programs formed in the process are equivalent to each other. Thus, the three approaches under consideration turn out to be parts of a whole spectrum of different, but equivalent, ways of representing incomplete information. <p> The available actions are loading and shooting. We are interested in representing this action domain using the situation calculus and negation as failure. Early work of this kind is described in [EK89], [Eva89], [AB90] and [Gel91]. The subject is treated more systematically in several recent papers, including [GL93], <ref> [DDS93] </ref> and [Dun93]. We assume that the reader is familiar with the main ideas of this work. The following formulation of the two gun example is close to the one proposed in [Tur94]. It uses variables for situations (s), actions (a), propositional fluents (f) and guns (x). <p> Using the CWA, instead of specialized rules with negative heads, for generating negative conclusions seems to be the main distinctive feature of the use of abduction by Denecker and De Schreye <ref> [DDS93] </ref> and Dung [Dun93], in comparison with Gelfond's approach [Gel91]. The result of this transformation is the following program 4 . 1. Initial conditions: (same as 1 - 3 ) not Holds (Alive; S0 ) not Holds (Loaded (Gun1 ); S0 ); not Holds (Loaded (Gun2 ); S0 ) 2. <p> Commonsense law of inertia: (same as 4 and 5 ) Holds (f; Result (a; s)) Holds (f; s); not Noninertial (f; a; s) Abducibles: The ground instances of Holds (f; S0 ). (same as 3 - 5 ) This representation follows the method advocated in <ref> [DDS93] </ref>. The last transformation, unlike the ones performed earlier, does change the meaning of the program, of course. But the way the belief sets change when we drop the CWA is easy to describe. In the following proposition, GA stands for the set of all ground atoms. Proposition 6.
Reference: [Dun93] <author> Phan Minh Dung. </author> <title> Representing actions in logic programming and its applications in database updates. </title> <booktitle> In Logic Programming: Proceedings of the Tenth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 222-238, </pages> <year> 1993. </year>
Reference-contexts: Classical negation and epistemic disjunction are used in the first of these approaches ([GL91], [Tur94]), abductive logic programs with classical negation in the second [Gel91], and a simpler form of abductive logic programming | without classical negation | in the third [DDS93], <ref> [Dun93] </ref>. All these ideas have been illustrated with examples related to properties of actions, and in this paper we consider an action domain also. <p> We are interested in representing this action domain using the situation calculus and negation as failure. Early work of this kind is described in [EK89], [Eva89], [AB90] and [Gel91]. The subject is treated more systematically in several recent papers, including [GL93], [DDS93] and <ref> [Dun93] </ref>. We assume that the reader is familiar with the main ideas of this work. The following formulation of the two gun example is close to the one proposed in [Tur94]. It uses variables for situations (s), actions (a), propositional fluents (f) and guns (x). <p> Using the CWA, instead of specialized rules with negative heads, for generating negative conclusions seems to be the main distinctive feature of the use of abduction by Denecker and De Schreye [DDS93] and Dung <ref> [Dun93] </ref>, in comparison with Gelfond's approach [Gel91]. The result of this transformation is the following program 4 . 1. Initial conditions: (same as 1 - 3 ) not Holds (Alive; S0 ) not Holds (Loaded (Gun1 ); S0 ); not Holds (Loaded (Gun2 ); S0 ) 2.
Reference: [EK89] <author> Kave Eshghi and Robert Kowalski. </author> <title> Abduction compared with negation as failure. </title> <editor> In Giorgio Levi and Maurizio Martelli, editors, </editor> <booktitle> Logic Programming: Proc. of the Sixth Int'l Conf., </booktitle> <pages> pages 234-255, </pages> <year> 1989. </year>
Reference-contexts: The turkey is initially alive. The available actions are loading and shooting. We are interested in representing this action domain using the situation calculus and negation as failure. Early work of this kind is described in <ref> [EK89] </ref>, [Eva89], [AB90] and [Gel91]. The subject is treated more systematically in several recent papers, including [GL93], [DDS93] and [Dun93]. We assume that the reader is familiar with the main ideas of this work. The following formulation of the two gun example is close to the one proposed in [Tur94].
Reference: [Eva89] <author> Chris Evans. </author> <title> Negation-as-failure as an approach to the Hanks and McDermott problem. </title> <booktitle> In Proc. of the Second Int'l Symp. on Artificial Intelligence, </booktitle> <year> 1989. </year> <month> 19 </month>
Reference-contexts: The turkey is initially alive. The available actions are loading and shooting. We are interested in representing this action domain using the situation calculus and negation as failure. Early work of this kind is described in [EK89], <ref> [Eva89] </ref>, [AB90] and [Gel91]. The subject is treated more systematically in several recent papers, including [GL93], [DDS93] and [Dun93]. We assume that the reader is familiar with the main ideas of this work. The following formulation of the two gun example is close to the one proposed in [Tur94].
Reference: [Gel91] <author> Michael Gelfond. </author> <title> Epistemic approach to formalization of commonsense rea-soning. </title> <type> Technical Report TR-91-2, </type> <institution> University of Texas at El Paso, Department of Computer Science, </institution> <year> 1991. </year>
Reference-contexts: 1 Introduction The purpose of this work is to clarify the relationship between three approaches to representing incomplete information in logic programming. Classical negation and epistemic disjunction are used in the first of these approaches ([GL91], [Tur94]), abductive logic programs with classical negation in the second <ref> [Gel91] </ref>, and a simpler form of abductive logic programming | without classical negation | in the third [DDS93], [Dun93]. All these ideas have been illustrated with examples related to properties of actions, and in this paper we consider an action domain also. <p> The second author is also supported by an IBM Graduate Fellowship. program with classical negation, along the lines of [Tur94] (Section 3). Then, in Sections 4-9, we apply a series of six simple syntactic transformations to that program, so that a formulation in the spirit of <ref> [Gel91] </ref> is generated at one point along the way, and then a formulation in the spirit of [DDS93] is obtained. All programs formed in the process are equivalent to each other. <p> not L to a program eliminates the answer sets that do not contain L. 1 We write X Y when X is a subset of Y , not necessarily proper. 2 The definition of abduction accepted here follows Inoue and Sakama ([IS93], [IS94]), whose work is based on [KM90] and <ref> [Gel91] </ref>. An abductive program is a pair h; i, where is a program and is a set of ground literals, called abducibles. <p> The turkey is initially alive. The available actions are loading and shooting. We are interested in representing this action domain using the situation calculus and negation as failure. Early work of this kind is described in [EK89], [Eva89], [AB90] and <ref> [Gel91] </ref>. The subject is treated more systematically in several recent papers, including [GL93], [DDS93] and [Dun93]. We assume that the reader is familiar with the main ideas of this work. The following formulation of the two gun example is close to the one proposed in [Tur94]. <p> Proposition 2 shows that this difference can be offset by constraint (4). The use of abduction in 2 is similar to the style of formalization proposed by Gelfond <ref> [Gel91] </ref>. <p> Using the CWA, instead of specialized rules with negative heads, for generating negative conclusions seems to be the main distinctive feature of the use of abduction by Denecker and De Schreye [DDS93] and Dung [Dun93], in comparison with Gelfond's approach <ref> [Gel91] </ref>. The result of this transformation is the following program 4 . 1. Initial conditions: (same as 1 - 3 ) not Holds (Alive; S0 ) not Holds (Loaded (Gun1 ); S0 ); not Holds (Loaded (Gun2 ); S0 ) 2.
Reference: [GL91] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Classical negation in logic programs and disjunctive databases. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 365-385, </pages> <year> 1991. </year>
Reference-contexts: Thus, this sequence of theorems itself further illustrates the close relationships between the different approaches to representing incomplete information. Readers uninterested in the details of the underlying theorems can safely skip the "Generalization" subsections. 2 Rules, Constraints and Abduction The answer set semantics <ref> [GL91] </ref> is defined for programs that consist of rules of the form L 1 j : : : j L k L k+1 ; : : : ; L m ; not L m+1 ; : : : ; not L n ; (1) where n m k 0, and each
Reference: [GL93] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Representing action and change by logic programs. </title> <journal> The Journal of Logic Programming, </journal> <volume> 17 </volume> <pages> 301-322, </pages> <year> 1993. </year>
Reference-contexts: The available actions are loading and shooting. We are interested in representing this action domain using the situation calculus and negation as failure. Early work of this kind is described in [EK89], [Eva89], [AB90] and [Gel91]. The subject is treated more systematically in several recent papers, including <ref> [GL93] </ref>, [DDS93] and [Dun93]. We assume that the reader is familiar with the main ideas of this work. The following formulation of the two gun example is close to the one proposed in [Tur94]. It uses variables for situations (s), actions (a), propositional fluents (f) and guns (x).
Reference: [HM87] <author> Steve Hanks and Drew McDermott. </author> <title> Nonmonotonic logic and temporal projection. </title> <journal> Artificial Intelligence, </journal> <volume> 33(3) </volume> <pages> 379-412, </pages> <year> 1987. </year>
Reference-contexts: The theorems stated in this paper show, however, that the observations made here are of a general nature, and they may be applicable to other knowledge representation problems. Our example domain is the enhancement of Yale Shooting <ref> [HM87] </ref> in which two guns are available and it is assumed that at least one of them is loaded. This is a case of temporal projection with incomplete information about the initial situation.
Reference: [IS93] <author> Katsumi Inoue and Chiaki Sakama. </author> <title> Transforming abductive logic programs to disjunctive programs. </title> <booktitle> In Logic Programming: Proceedings of the Tenth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 335-353, </pages> <year> 1993. </year>
Reference: [IS94] <author> Katsumi Inoue and Chiaki Sakama. </author> <title> On positive occurrences of negation as failure. </title> <booktitle> In Proc. of the Fourth Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 293-304, </pages> <year> 1994. </year>
Reference-contexts: For instance, adding the constraint not L to a program eliminates the answer sets that do not contain L. 1 We write X Y when X is a subset of Y , not necessarily proper. 2 The definition of abduction accepted here follows Inoue and Sakama ([IS93], <ref> [IS94] </ref>), whose work is based on [KM90] and [Gel91]. An abductive program is a pair h; i, where is a program and is a set of ground literals, called abducibles. <p> The belief sets for 2 are the same as the answer sets for 1 . It is interesting to relate the process used in constructing 2 to the view of abduction developed by Inoue and Sakama <ref> [IS94] </ref>. They show that declaring a literal L abducible has the same effect as adding the rule L j not L : Such rules are syntactically different than the rules introduced in Section 2, because they contain the negation as failure operator in the head.
Reference: [KM90] <author> Antonis Kakas and Paolo Mancarella. </author> <title> Generalized stable models: a semantics for abduction. </title> <booktitle> In Proc. of ECAI-90, </booktitle> <pages> pages 385-391, </pages> <year> 1990. </year>
Reference-contexts: the constraint not L to a program eliminates the answer sets that do not contain L. 1 We write X Y when X is a subset of Y , not necessarily proper. 2 The definition of abduction accepted here follows Inoue and Sakama ([IS93], [IS94]), whose work is based on <ref> [KM90] </ref> and [Gel91]. An abductive program is a pair h; i, where is a program and is a set of ground literals, called abducibles.
Reference: [LT94] <author> Vladimir Lifschitz and Hudson Turner. </author> <title> Splitting a logic program. </title> <booktitle> In Logic Programming: Proceedings of the Eleventh Int'l Conf. on Logic Programming, </booktitle> <pages> pages 23-37, </pages> <year> 1994. </year>
Reference-contexts: The first of them allows us to replace literals L 2 C that occur in the body of a rule with not L. Notice that in this lemma we needn't require that no literal in C depend upon its complement. 5 This definition comes from <ref> [LT94] </ref>. 14 Lemma 5. Let be a program, and L a literal such that the only rule in with L in its head is the rule L not L. <p> By part (i), X 0 is closed under X L . It follows that X 0 = X; so X is an answer set for . 2 The next lemma uses the following additional definitions, and theorem, from <ref> [LT94] </ref>. Let U be a splitting set for a program . The set of rules r 2 such that lit (r) U is denoted by b U (). Let X be a set of literals. <p> Moreover, each belief set X for 5 can be obtained from X " GA by adding the negations of all ground atoms that begin with Holds and do not belong to X " GA. Generalization The following theorem is an easy consequence of Proposition 2 from <ref> [LT94] </ref>. Theorem 6. Let be a program and a set of abducibles. Let C be a consistent set of literals such that no literal in C appears in or in .
Reference: [LW92] <author> Vladimir Lifschitz and Thomas Woo. </author> <title> Answer sets in general nonmonotonic reasoning (preliminary report). </title> <editor> In Bernhard Nebel, Charles Rich, and William Swartout, editors, </editor> <booktitle> Proc. of the Third Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 603-614, </pages> <year> 1992. </year>
Reference-contexts: However, the answer set semantics can be easily extended to rules like these <ref> [LW92] </ref>. In the case of 2 , this approach to characterizing the abducibles leads to the rule Holds (f; S0 ) j not Holds (f; S0 ) : This rule differs from the completeness rule (3) only in that it uses negation as failure not instead of classical negation :.
Reference: [Prz88] <author> Teodor Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1988. </year>
Reference-contexts: We omit the proof of Theorem 4, which relies on the fact that a stratified nondisjunctive program has at most one consistent answer set. 3 The definition given here is equivalent to the usual definition of a "locally stratified" program <ref> [Prz88] </ref> when the set of atoms is defined as the set of ground atoms of a first-order language, and there is no classical negation. 4 This definition extends in a natural way the standard notion of "depends on" for nondisjunctive programs without classical negation [ABW88].
Reference: [Tur94] <author> Hudson Turner. </author> <title> Signed logic programs. </title> <booktitle> In Logic Programming: Proceedings of the 1994 Int'l Symposium, </booktitle> <pages> pages 61-75, </pages> <year> 1994. </year> <title> This article was processed using the L a T E X macro package with LLNCS style 20 </title>
Reference-contexts: 1 Introduction The purpose of this work is to clarify the relationship between three approaches to representing incomplete information in logic programming. Classical negation and epistemic disjunction are used in the first of these approaches ([GL91], <ref> [Tur94] </ref>), abductive logic programs with classical negation in the second [Gel91], and a simpler form of abductive logic programming | without classical negation | in the third [DDS93], [Dun93]. <p> The second author is also supported by an IBM Graduate Fellowship. program with classical negation, along the lines of <ref> [Tur94] </ref> (Section 3). Then, in Sections 4-9, we apply a series of six simple syntactic transformations to that program, so that a formulation in the spirit of [Gel91] is generated at one point along the way, and then a formulation in the spirit of [DDS93] is obtained. <p> The subject is treated more systematically in several recent papers, including [GL93], [DDS93] and [Dun93]. We assume that the reader is familiar with the main ideas of this work. The following formulation of the two gun example is close to the one proposed in <ref> [Tur94] </ref>. It uses variables for situations (s), actions (a), propositional fluents (f) and guns (x). We will call this program 0 . 1. Initial conditions: Holds (Alive; S0 ) Holds (Loaded (Gun1 ); S0 ) j Holds (Loaded (Gun2 ); S0 ) 2. <p> Given a set X of literals, we'll say that a set Y of literals is complete in X if for every literal L 2 X at least one of the complementary literals L; L belongs to Y . Following is the definition from <ref> [Tur94] </ref> of a "signing" of a program. Let be a constraint-free program, and let Lit denote the set of ground literals in the language of . <p> So Theorem 1 guarantees that programs [ 0 and [ constraint ( 0 ) have the same consistent answer sets. Theorem 1 is proved using the following additional definitions, and theorem, from <ref> [Tur94] </ref>. 5 Given rules r and r 0 , we say that r is subsumed by r 0 , and we write r r 0 , if the following three conditions hold: - neg (r 0 ) neg (r), every literal in head (r 0 ) n head (r) appears complemented
References-found: 17

