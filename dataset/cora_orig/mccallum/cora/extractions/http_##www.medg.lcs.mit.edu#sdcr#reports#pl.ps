URL: http://www.medg.lcs.mit.edu/sdcr/reports/pl.ps
Refering-URL: http://www.medg.lcs.mit.edu/sdcr/reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Strategic Directions for Research on Programming Languages  
Author: Chris Hankin and Hanne Riis Nielson Jens Palsberg 
Address: College, London  
Affiliation: Imperial  University of Aarhus and  Purdue University  
Abstract: Programminglanguage research covers a wide range of principles spanning a spectrum from pure to applied and employing methods and techniques ranging from theory to systems. In this working group we have concentrated on five central aspects of this: semantics, type systems, program analysis, program transformation, and implementation; other aspects of programming language research are covered by other groups. This report summarizes the open problems and challenges uncovered by the group. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aho A. V., Sethi R. and Ullman J. D., </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Over the years different type systems have been developed and found their ways into commercially successful languages. |Program analysis: Program analysis is concerned with the problem of statically predicting properties of the dynamic executions of programs <ref> [1; 8; 14] </ref>. Traditionally, program analysis has been used extensively to enable various optimizations and transformations in compilers; among the newer applications is the validation of software to reduce the likelihood of malicious behaviour. <p> Techniques have been developed for different stages of the software development process: when developing programs from specifications, when specialising existing programs to specific con texts and, in particular, in optimizing compilers. |Implementation: This area concerns compilation <ref> [1] </ref> and run-time support. Current concerns in compiler technology include compilation for distributed systems, optimisations across module boundaries and correctness issues. Memory management, particularly on complex cache architectures, is a critical concern in run-time support. This area is increasingly concerned with the development of generic tools rather than tailored solutions. <p> Program analyses have been implemented in a number of optimizing compilers but the re-usability of these implementations seem to be rather limited. In particular, the automatic generation of program analysers is still lagging far behind the technology developed for front-ends (parsers) and back-ends (code generators) <ref> [1] </ref>. Although the theoretical foundations of a particular technique may seem well-understood there is still a long way to a generally useful analysis tool. PA-3: Choice of Program Analyses.
Reference: [2] <author> Bank J., </author> <title> Java security, </title> <note> available via http://www-swiss.ai.mit.edu/ jbank/javapaper/javapaper.html, </note> <year> 1995. </year>
Reference-contexts: The type system itself might be made changeable by the programmer, leading to customizable tools. T-4: New Applications. The safety and security issues inherent in distributed programming <ref> [2] </ref> may be partially solved using type systems. Known ideas on structural type matching, type systems for concurrency, and types for security should be extended and complemented. On a different front, there is a continuum between type systems and program analysis.
Reference: [3] <author> Burstall R. and Darlington J., </author> <title> A transformation system for developing recursive programs, </title> <journal> Journal of the ACM, </journal> <volume> 24(1), </volume> <pages> 44-67, </pages> <year> 1977. </year>
Reference-contexts: For example, most useful program transformations preserve the input/output semantics of the program but might radically change the program's complexity. The transformation of programs is an important technique in the development of reliable and efficient software <ref> [3; 13] </ref>. Techniques have been developed for different stages of the software development process: when developing programs from specifications, when specialising existing programs to specific con texts and, in particular, in optimizing compilers. |Implementation: This area concerns compilation [1] and run-time support.
Reference: [4] <author> Cardelli L. and Wegner P., </author> <title> On understanding types, data abstraction and polymorphism, </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4), </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: Over the years different techniques have been developed to handle the different programming paradigms and the different applications. |Type systems: A type is a collection of values which share a common structure, operations and other properties. A type system is a specification of how types are assigned to values <ref> [4] </ref>. Type safety the prevention of certain classes of programming errors is a desirable property of any programming language; many of the recently published standards for safety critical software insist upon the use of strongly typed programming languages. <p> There has been very little work so far on semantics-related issues that arise in these new areas. 3.2 Type Systems T-1: Types for Objects. Many type systems for object-oriented languages have been defined <ref> [4; 9] </ref>. Their relative merits should be investigated, aiming at building consensus on what features a type system should include, what the proper role of type inference is, and how these ideas can be integrated with module systems.
Reference: [5] <author> Carriero N. and Gelernter D., </author> <title> Coordination languages and their significance, </title> <journal> Communications of the ACM, </journal> <volume> 35(2), </volume> <pages> 97-107, </pages> <year> 1992. </year>
Reference-contexts: The following topics were abstracted from the position statements prepared by the participants of the working group. 3.1 Semantics S-1: Language Design. One example of an area in which there is current interest in language design is coordination languages <ref> [5; 6] </ref>. Coordination languages have been developed for programming systems in which multiple, heterogeneous agents cooperate on the execution of a particular task. The recent emergence of this class of languages has coincided with the emergence of the WWW; the latter provides a fertile area for applications.
Reference: [6] <editor> Ciancarini P. and Hankin C. (eds), </editor> <title> Coordination Languages and Models, </title> <publisher> LNCS 1061, Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The following topics were abstracted from the position statements prepared by the participants of the working group. 3.1 Semantics S-1: Language Design. One example of an area in which there is current interest in language design is coordination languages <ref> [5; 6] </ref>. Coordination languages have been developed for programming systems in which multiple, heterogeneous agents cooperate on the execution of a particular task. The recent emergence of this class of languages has coincided with the emergence of the WWW; the latter provides a fertile area for applications.
Reference: [7] <author> Cohen J., </author> <title> Garbage collection of linked data structures, </title> <journal> ACM Computing Surveys, </journal> <volume> 13(3), </volume> <pages> 341-367, </pages> <year> 1981. </year>
Reference: [8] <author> Cousot P. and Cousot R., </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints, </title> <booktitle> in proceedings of the 4th ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <publisher> ACM Press, </publisher> <pages> 238-252, </pages> <year> 1977. </year>
Reference-contexts: Over the years different type systems have been developed and found their ways into commercially successful languages. |Program analysis: Program analysis is concerned with the problem of statically predicting properties of the dynamic executions of programs <ref> [1; 8; 14] </ref>. Traditionally, program analysis has been used extensively to enable various optimizations and transformations in compilers; among the newer applications is the validation of software to reduce the likelihood of malicious behaviour.
Reference: [9] <author> Gunter C. and Mitchell J., </author> <title> Theoretical Aspects of Object-Oriented Programming, </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: There has been very little work so far on semantics-related issues that arise in these new areas. 3.2 Type Systems T-1: Types for Objects. Many type systems for object-oriented languages have been defined <ref> [4; 9] </ref>. Their relative merits should be investigated, aiming at building consensus on what features a type system should include, what the proper role of type inference is, and how these ideas can be integrated with module systems.
Reference: [10] <editor> Hankin C. and Nielson H. R. (eds), </editor> <booktitle> Symposium on Models of Programming Languages and Computation, ACM Computing Surveys, </booktitle> <volume> 28(2), </volume> <pages> 293-359, </pages> <year> 1996. </year>
Reference-contexts: A recent publication which contains more detailed discussion of some of the research themes identified below is <ref> [10] </ref>. 2. STRATEGIC DIRECTIONS This section presents five strategic directions identified by the working group. Our aim was to identify some general themes which will provide the impetus for new research over the next few years.
Reference: [11] <author> Hanus M., </author> <title> The integration of functions into logic programming: From theory to practice, </title> <journal> Journal of Logic Programming, </journal> <volume> 19 and 20, </volume> <pages> 583-628, </pages> <year> 1994. </year>
Reference-contexts: A problem that arises, particularly if the mixing is ad hoc, is that there can be unwelcome interactions between the component sublanguages. Examples of successful integrations include functional and logic languages <ref> [11] </ref> and functional languages with imperative features [17]. The emergence of concurrent and distributed applications raises new issues and opportunities for successful integrations. S-4: New Directions. The last few years have seen the development of a number of new areas of computing which pose interesting challenges for semantics.
Reference: [12] <author> Hoare C. A. R., </author> <title> Monitors: an operating system structuring concept, </title> <journal> Communications of the ACM, </journal> <volume> 17(10), </volume> <pages> 549-557. </pages> <note> Programming Languages 11 </note>
Reference-contexts: developed in the context of pure calculi such as the -calculus and com-binatory logic but extended by programming language researchers and now per vasive. |Exceptions: introduced in PL/1 but extensively studied and formalised in ML [15]; similar concepts have later appeared in C++. |Monitors: introduced by Hoare in the 1970s <ref> [12] </ref> and now forming the basis for the concurrency features of Java. In addition to language features, programming language research has also produced important techniques.
Reference: [13] <author> Jones N. D., Gomard C. K. and Sestoft P., </author> <title> Partial Evaluation and Automatic Program Generation, </title> <publisher> Prentice-Hall, </publisher> <year> 1993. </year>
Reference-contexts: For example, most useful program transformations preserve the input/output semantics of the program but might radically change the program's complexity. The transformation of programs is an important technique in the development of reliable and efficient software <ref> [3; 13] </ref>. Techniques have been developed for different stages of the software development process: when developing programs from specifications, when specialising existing programs to specific con texts and, in particular, in optimizing compilers. |Implementation: This area concerns compilation [1] and run-time support. <p> PT-2: Algorithm Development and Design. Program transformations have been used to integrate algorithm design and program development. This has already given rise to a better understanding of known algorithms and to the discovery of new algorithms <ref> [13] </ref>. A next step would be to use program transformation technology to gradually develop efficient implementations using the best known data structures. PT-3: Foundations. Program transformations allow us to replace certain programs with others.
Reference: [14] <author> Jones N. D. and Nielson F., </author> <title> Abstract interpretation: A semantic-based tool for program analysis, </title> <booktitle> in volume 4 of Handbook of Logic in Computer Science, </booktitle> <editor> Abramsky S., Gabbay D. and Maibaum T. (eds), </editor> <publisher> Clarendon Press, </publisher> <year> 1995. </year>
Reference-contexts: Over the years different type systems have been developed and found their ways into commercially successful languages. |Program analysis: Program analysis is concerned with the problem of statically predicting properties of the dynamic executions of programs <ref> [1; 8; 14] </ref>. Traditionally, program analysis has been used extensively to enable various optimizations and transformations in compilers; among the newer applications is the validation of software to reduce the likelihood of malicious behaviour.
Reference: [15] <author> Milner R., Tofte M. and Harper R., </author> <title> The definition of Standard ML, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: (while loops) were introduced in Recursion Theory but are pervasive in modern high-level languages. |Types: developed in the context of pure calculi such as the -calculus and com-binatory logic but extended by programming language researchers and now per vasive. |Exceptions: introduced in PL/1 but extensively studied and formalised in ML <ref> [15] </ref>; similar concepts have later appeared in C++. |Monitors: introduced by Hoare in the 1970s [12] and now forming the basis for the concurrency features of Java. In addition to language features, programming language research has also produced important techniques.
Reference: [16] <author> Nielson F. and Nielson H. R., </author> <title> Semantics with Applications, a Formal Introduction, </title> <publisher> Wiley, </publisher> <year> 1992. </year>
Reference-contexts: In addition to language features, programming language research has also produced important techniques. Let us mention the five areas that will receive special attention in this report: |Semantics: Formal semantics is concerned with the description of program meanings by operational, denotational or axiomatic specifications. <ref> [16; 17] </ref>. It improves our understanding of new as well as well-known programming constructs and it provides a yardstick for implementation and a foundation for analysis and verification techniques and program transformation. <p> S-2: Foundations. Work on programming language semantics have produced a number of different formalisms. Operational semantics provide an abstract implementation-oriented account of program meaning, denotational semantics give a more abstract mathematical account and axiomatic semantics focus on partial correctness issues (see <ref> [16; 17] </ref> for a thorough discussion). In Operational Semantics there is the choice between big-step Natural Semantics or small-step Structural Operational Semantics. In Denotational Semantics there is a choice about which mathematical universe is used for program meanings (for example, metric spaces or domains).
Reference: [17] <author> Tennent R. D., </author> <title> Semantics of Programming Languages, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1991. </year>
Reference-contexts: In addition to language features, programming language research has also produced important techniques. Let us mention the five areas that will receive special attention in this report: |Semantics: Formal semantics is concerned with the description of program meanings by operational, denotational or axiomatic specifications. <ref> [16; 17] </ref>. It improves our understanding of new as well as well-known programming constructs and it provides a yardstick for implementation and a foundation for analysis and verification techniques and program transformation. <p> S-2: Foundations. Work on programming language semantics have produced a number of different formalisms. Operational semantics provide an abstract implementation-oriented account of program meaning, denotational semantics give a more abstract mathematical account and axiomatic semantics focus on partial correctness issues (see <ref> [16; 17] </ref> for a thorough discussion). In Operational Semantics there is the choice between big-step Natural Semantics or small-step Structural Operational Semantics. In Denotational Semantics there is a choice about which mathematical universe is used for program meanings (for example, metric spaces or domains). <p> A problem that arises, particularly if the mixing is ad hoc, is that there can be unwelcome interactions between the component sublanguages. Examples of successful integrations include functional and logic languages [11] and functional languages with imperative features <ref> [17] </ref>. The emergence of concurrent and distributed applications raises new issues and opportunities for successful integrations. S-4: New Directions. The last few years have seen the development of a number of new areas of computing which pose interesting challenges for semantics.
References-found: 17

