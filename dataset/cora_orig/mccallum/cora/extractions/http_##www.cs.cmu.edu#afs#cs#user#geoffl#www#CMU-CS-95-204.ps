URL: http://www.cs.cmu.edu/afs/cs/user/geoffl/www/CMU-CS-95-204.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/geoffl/www/CMU-CS-95-204.html
Root-URL: 
Title: Efficient and Language-Independent Mobile Programs  
Author: Ali-Reza Adl-Tabatabai Geoff Langdale Steven Lucco Robert Wahbe 
Note: This work was supported by a software license grant from Colusa Software, Inc. Omniware is a registered trademark of Colusa Software.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: October 1995  
Pubnum: CMU-CS-95-204  
Abstract: This paper describes the design and implementation of Omniware: a safe, efficient and language-independent system for executing mobile program modules. Previous approaches to implementing mobile code rely on either language semantics or abstract machine interpretation to enforce safety. In the former case, the mobile code system sacrifices universality to gain safety by dictating a particular source language or type system. In the latter case, the mobile code system sacrifices performance to gain safety through abstract machine interpretation. Our approach uses software fault isolation, a technology developed to provide safe extension code for databases and operating systems, to achieve a unique combination of language-independence and excellent performance. Software fault isolation uses only the semantics of the underlying processor to determine whether a mobile code module can corrupt its execution environment. This separation of programming language implementation from program module safety enables our mobile code system to use a radically simplified virtual machine as its basis for portability. We used CISC instruction traces to augment the design of our RISC virtual machine, OmniVM. We measured the performance of the resulting system using a suite of four SPECMARK programs on the Pentium, PowerPC, Mips and Sparc processor architectures. Including the overhead for enforcing safety on all four processors, OmniVM executed the benchmark programs within 21% as fast as the optimized, unsafe code produced by the vendor-supplied compiler. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Kristy Andrews and Duane Sand. </author> <title> Migrating a CISC Computer Family onto RISC via Object Code Translation. </title> <booktitle> In Proceedings of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 213-222, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: OmniVM differs from Mahler in the far wider range of architectures it supports, and the requirement for safe execution. Similarly, the Taos operating system [29] defines as its compiler target the Taos Virtual Processor, which, like Mahler, is an attempt to support multi-platform optimization. Binary translation systems <ref> [1] </ref> address the problem of migrating existing native code from one platform to another but ignore safety. In the fat binary approach to software distribution, the compiler generates an object file containing multiple text sections one for each of the target architectures.
Reference: [2] <author> David F. Bacon, Susan L. Graham, and Oliver J. Sharp. </author> <title> Compiler Transformations for High-Performance Computing. </title> <journal> ACM Comput. Surv., </journal> <volume> 26(4) </volume> <pages> 345-420, </pages> <month> December </month> <year> 1994. </year> <month> 10 </month>
Reference-contexts: Hence, a compiler can perform a great deal of machine-independent optimization (such as register allocation, constant folding, constant propagation, and strength reduction <ref> [2] </ref>) prior to module load time. This is important in many mobile code contexts such as Web pages where load time, and hence optimization during loading, must be minimized. Section 4 demonstrates quantitatively that compilers can substantially optimize OmniVM modules prior to load time.
Reference: [3] <author> H. E. Bal, A. S. Tanenbaum, and M. F. Kaashoek. ORCA: </author> <title> a language for distributed programming. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(5) </volume> <pages> 17-24, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Similarly, distributed object-oriented database systems [4] use method invocation as a basis for data queries. In the absence of mobile code, these systems must manage heterogeneous binaries for each dynamically created data class. Because of these requirements, several languages for programming distributed systems, such as Orca <ref> [3] </ref> and Emerald [30], incorporate mobile code as a fundamental programming construct. The mobile code systems introduced to date have used one of two methods for enforcing safe execution: abstract machine interpretation or language semantics. Abstract machine interpreters [11] trade performance for safety.
Reference: [4] <author> J. Bennerjee, W. Kim, H. Kim, and H. Korth. </author> <title> Semantics and Implementation of Scheme Evolution in Object-Oriented Databases. </title> <booktitle> In Proc. ACM SIGMOD Conference, </booktitle> <pages> pages 311-322, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: Further, multi-platform operating systems, such as Microsoft Windows NT [26], when combined with network file systems, require either cumbersome management of processor-specific binaries or some form of mobile code. Similarly, distributed object-oriented database systems <ref> [4] </ref> use method invocation as a basis for data queries. In the absence of mobile code, these systems must manage heterogeneous binaries for each dynamically created data class.
Reference: [5] <author> Tim Berners-Lee, Roy T. Fielding, and Henrik Frystyk Nielsen. </author> <note> HTTP/1.0 Internet Draft 04, </note> <month> October </month> <year> 1995. </year> <title> Internet Draft (work in progress). </title>
Reference-contexts: Currently, the most visible computer application requiring mobile code is executable content for electronic documents. While documents containing executable content have been around for at least two decades [40, 12], the combination of electronic documents with widely adopted network protocols <ref> [5] </ref> on the Internet requires mobile executable document content. Because the program bits that come off a network wire are often untrusted, safety is an essential feature of any mobile code system.
Reference: [6] <author> David Bernstein and Michael Rodeh. </author> <title> Global Instruction Scheduling for Superscalar Machines. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 241-255, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The PowerPC has a few features that are unusually challenging for code generators, specifically, auto update addressing modes, branch-and-decrement instructions and multiple condition registers. Effective use of these features can result in substantial speed ups [20], especially when the compiler performs global instruction scheduling <ref> [6] </ref>. We are currently enhancing our translators to include more aggressive global instruction scheduling, and a more general framework for machine dependent peephole optimizations. We expect these improvements to bring PowerPC performance in line with the other two RISC processors.
Reference: [7] <author> Nathaniel S. Borenstein. </author> <title> EMail With A Mind of Its Own: The Safe-Tcl Language for Enabled Mail. </title> <booktitle> In IFIP Working Group 6.5 Conference, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: No performance evaluations have been released for Java, so it is difficult to evaluate the performance of the Java compiler or interpreter. Some mobile code systems rely entirely on interpretation of source code at the host. Many scripting languages are in this category, including safe variants of Perl, Tcl <ref> [7] </ref> and Python [35]. These language-specific mobile code systems are very useful for certain unstructured tasks such as parsing user input.
Reference: [8] <author> M. Burke and L. Torczon. </author> <title> Interprocedural optimization: eliminating unnecessary recompilation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(3) </volume> <pages> 367-399, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Typically, compilers target an entire architecture family, not a particular machine. Several studies suggest that we can significantly enhance performance using this information <ref> [23, 39, 8] </ref>. 4 Results To evaluate the performance of mobile code based on OmniVM, we have retargeted gcc (version 2.4.5) to generate OmniVM assembly code, and have developed an assembler and linker that generate OmniVM object files and executables.
Reference: [9] <author> L. Cardelli, J. Donahue, L. Glassman, M. Jordan, B. Kalsow, and G. Nelson. </author> <title> Modula-3 language definition. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(8), </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: This mechanism is effective and language-independent, but inherently slow. A mobile code system can use language semantics to enforce safety by guaranteeing that a program can't affect physical resources that it can't name <ref> [32, 9, 34] </ref>. Though rare in current practice, it is possible to achieve good performance using this approach if the compiler intermediate form for the language retains type information [21, 33]. However, this approach works through restriction.
Reference: [10] <author> F. Chow, S. Correll, M. Himelstein, E. Killian, and L. Weber. </author> <booktitle> How Many Addressing Modes Are Enough? In Proceedings of the 2nd International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 117-121, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: However, Section 4 also shows that by using a global pointer <ref> [10] </ref> on the Sparc, we can eliminate the bulk of this overhead. To optimize for use of a global pointer, the translator generates, for every access to static data, code that addresses the data by offset from a register 4 pointing into the static data area.
Reference: [11] <author> K. Chung and H Yuen. </author> <title> A Tiny Pascal Compiler. </title> <journal> Byte, </journal> <volume> 39(9) </volume> <pages> 58-64, </pages> <month> September </month> <year> 1978. </year>
Reference-contexts: The mobile code systems introduced to date have used one of two methods for enforcing safe execution: abstract machine interpretation or language semantics. Abstract machine interpreters <ref> [11] </ref> trade performance for safety. A mobile code system based around an abstract machine consists of a compiler for some number of source languages coupled with an interpreter for the abstract machine. <p> Omniware's overhead of only 10-20% makes it an order of magnitude faster than any other universal mobile code system, because other universal systems must rely on abstract machine interpretation to enforce safety <ref> [11, 27] </ref>. For many applications of mobile code, such as executable content for Internet documents, our current performance is more than sufficient.
Reference: [12] <institution> Compton's Interactive Encyclopedia, </institution> <year> 1995. </year>
Reference-contexts: Currently, the most visible computer application requiring mobile code is executable content for electronic documents. While documents containing executable content have been around for at least two decades <ref> [40, 12] </ref>, the combination of electronic documents with widely adopted network protocols [5] on the Internet requires mobile executable document content. Because the program bits that come off a network wire are often untrusted, safety is an essential feature of any mobile code system.
Reference: [13] <author> J Strong et al. </author> <title> The Problem of Programming Communication with Changing Machines. </title> <journal> Communications of the ACM, </journal> <volume> 1(8) </volume> <pages> 12-18, </pages> <month> August </month> <year> 1958. </year> <month> 11 </month>
Reference-contexts: In the fat binary approach to software distribution, the compiler generates an object file containing multiple text sections one for each of the target architectures. The ANDF [24] project is a recent attempt to standardize a universal intermediate language for software distribution <ref> [13] </ref>. ANDF's intermediate form is comprised of typed expression trees. This representation is at a higher level than the OmniVM, and more work is required to translate it to native code.
Reference: [14] <author> Michael Franz. </author> <title> Code-Generation On-the-Fly: A Key to Portable Software. </title> <type> PhD thesis, </type> <institution> Swiss Federal Institute of Technology Zurich, </institution> <year> 1994. </year> <note> Diss. ETH No. 10497. </note>
Reference-contexts: Thus, this representation is less suitable for applications where speed of translation is important, and will not benefit as much from front-end compiler optimizations as OmniVM does. The OMI project <ref> [14] </ref> uses a similar approach. Other mobile code systems that achieve portability and safety by compiling to a machine independent intermediate representation include Telescript [22] and Java [18]. Telescript enforces safety in its interpreter. Java depends on a type system for its safety.
Reference: [15] <author> C. W. Fraser and D. R. Hanson. </author> <title> A Retargetable Compiler for ANSI C. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(10) </volume> <pages> 29-43, </pages> <month> Oct </month> <year> 1991. </year>
Reference-contexts: This design choice has two advantages. First, it simplifies the implementation of compilers to OmniVM and translators from OmniVM. For example, we retargeted both gcc [16] and lcc <ref> [15] </ref> to OmniVM within two months. Second, the use of simple instructions gives the source language compiler more opportunity for optimization because more aspects (such as data layout) of the final code are defined by the compiler.
Reference: [16] <author> Gcc, </author> <year> 1994. </year> <title> Free Software Foundation. </title>
Reference-contexts: The use of SFI to enforce safety enables a key feature of the OmniVM design: the use of an enhanced RISC instruction set [28]. This design choice has two advantages. First, it simplifies the implementation of compilers to OmniVM and translators from OmniVM. For example, we retargeted both gcc <ref> [16] </ref> and lcc [15] to OmniVM within two months. Second, the use of simple instructions gives the source language compiler more opportunity for optimization because more aspects (such as data layout) of the final code are defined by the compiler.
Reference: [17] <author> James Gosling. </author> <title> Java Intermediate Bytecodes. </title> <booktitle> In ACM SIGPLAN Workshop on Intermediate Representations (IR '95), </booktitle> <pages> pages 111-118, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: A virtual machine implementing this type system can check whether this promise is kept and reject programs that perform type-violating operations on one or more values <ref> [17] </ref>. Hence, a mobile code system that uses language semantics to enforce safety sacrifices universality. This has two drawbacks. First, type-based mobile code systems can't implement type-unsafe languages such as C, 2 C++, Pascal, Common Lisp and Fortran. <p> Telescript enforces safety in its interpreter. Java depends on a type system for its safety. Java's intermediate representation is tailored for fast interpretation by a stack machine <ref> [17] </ref>, and, because it defers decisions such as data layout, requires considerably more work than OmniVM to translate into efficient machine code. No performance evaluations have been released for Java, so it is difficult to evaluate the performance of the Java compiler or interpreter.
Reference: [18] <author> James Gosling and Henry McGilton. </author> <title> The Java Language Environment: A White Paper, 1995. Sun Microsystems, </title> <publisher> Inc. </publisher>
Reference-contexts: The OMI project [14] uses a similar approach. Other mobile code systems that achieve portability and safety by compiling to a machine independent intermediate representation include Telescript [22] and Java <ref> [18] </ref>. Telescript enforces safety in its interpreter. Java depends on a type system for its safety. Java's intermediate representation is tailored for fast interpretation by a stack machine [17], and, because it defers decisions such as data layout, requires considerably more work than OmniVM to translate into efficient machine code.
Reference: [19] <author> Susan Graham, Steven Lucco, and Robert Wahbe. </author> <title> Adaptable Binary Programs. </title> <booktitle> In Proceedings of the 1995 Winter USENIX Conference, </booktitle> <pages> pages 315-325, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: To ease global analysis, control flow and relocation information is readily available from the object file <ref> [19] </ref>. The conservative size of the OmniVM register set leaves us with enough registers to easily implement code transformations such as SFI. OmniVM defines data types, sizes and layout, and provides instructions to assure portability across machines with different underlying representations of these types.
Reference: [20] <author> C. Brian Hall and Kevin O'Brien. </author> <title> Performance Characteristics of Architectural Features of the IBM RISC System/6000. </title> <booktitle> In Proceedings of the 4th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 303-309, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: The PowerPC has a few features that are unusually challenging for code generators, specifically, auto update addressing modes, branch-and-decrement instructions and multiple condition registers. Effective use of these features can result in substantial speed ups <ref> [20] </ref>, especially when the compiler performs global instruction scheduling [6]. We are currently enhancing our translators to include more aggressive global instruction scheduling, and a more general framework for machine dependent peephole optimizations. We expect these improvements to bring PowerPC performance in line with the other two RISC processors.
Reference: [21] <author> Robert Harper and Peter Lee. </author> <title> Advanced Languages for Systems Software: The Fox Project in 1994. </title> <type> Technical report, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> January </month> <year> 1994. </year> <note> techreport CMU-CS-FOX-94-01. </note>
Reference-contexts: Though rare in current practice, it is possible to achieve good performance using this approach if the compiler intermediate form for the language retains type information <ref> [21, 33] </ref>. However, this approach works through restriction. In the context of mobile code, a type is essentially a promise not to do something.
Reference: [22] <author> Scott Knaster. </author> <title> Magic Cap Concepts, </title> <month> May </month> <year> 1995. </year> <title> General Magic, </title> <publisher> Inc. </publisher>
Reference-contexts: The OMI project [14] uses a similar approach. Other mobile code systems that achieve portability and safety by compiling to a machine independent intermediate representation include Telescript <ref> [22] </ref> and Java [18]. Telescript enforces safety in its interpreter. Java depends on a type system for its safety.
Reference: [23] <author> Monica Lam, Edward Rothberg, and Michael Wolf. </author> <title> The Cache Performance and Optimizations of Blocked Algorithms. </title> <booktitle> In Proceedings of the 4th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 63-74, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Typically, compilers target an entire architecture family, not a particular machine. Several studies suggest that we can significantly enhance performance using this information <ref> [23, 39, 8] </ref>. 4 Results To evaluate the performance of mobile code based on OmniVM, we have retargeted gcc (version 2.4.5) to generate OmniVM assembly code, and have developed an assembler and linker that generate OmniVM object files and executables. <p> However, we plan to aggressively add optional optimization capabilities to our translators, including global optimizations, link-level (interprocedural) optimizations, and chip-specific transformations such as global instruction scheduling, instruction combination and the organization of code and data to fit cache capacity and layout <ref> [23] </ref>. By adding these additional capabilities, we hope to make the Omniware system suitable for tasks such as general software distribution. In addition, our data suggest several simple steps towards this goal. First, implementing a global pointer can significantly improve performance.
Reference: [24] <author> Stavros Macrakis. </author> <title> From UNCOL to ANDF: Progress in Standard Intermedia Languages, 1993. Open Software Foundation. </title>
Reference-contexts: Binary translation systems [1] address the problem of migrating existing native code from one platform to another but ignore safety. In the fat binary approach to software distribution, the compiler generates an object file containing multiple text sections one for each of the target architectures. The ANDF <ref> [24] </ref> project is a recent attempt to standardize a universal intermediate language for software distribution [13]. ANDF's intermediate form is comprised of typed expression trees. This representation is at a higher level than the OmniVM, and more work is required to translate it to native code.
Reference: [25] <author> B. Noble, M. Price, and M. Satyanarayanan. </author> <title> A Programming Interface for Application-Aware Adaptation in Mobile Computing. </title> <booktitle> In Proceedings of the Second USENIX Symposium on Mobile and Location-Independent Computing, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: Software decomposition, when combined with a second trend, the widespread adoption of distributed computing, dictates the need for mobile code. For example, distributed database systems [31] and file systems <ref> [25] </ref> require safe function shipping to achieve scalability. An e-mail client can ship a mail-filtering function to a server to reduce server bandwidth requirements. A file system server can ship a decompression function to a client to offload its processing.
Reference: [26] <institution> Windows NT Workstation 3.51 Product Overview, 1995. Microsoft Corporation. </institution>
Reference-contexts: An e-mail client can ship a mail-filtering function to a server to reduce server bandwidth requirements. A file system server can ship a decompression function to a client to offload its processing. Further, multi-platform operating systems, such as Microsoft Windows NT <ref> [26] </ref>, when combined with network file systems, require either cumbersome management of processor-specific binaries or some form of mobile code. Similarly, distributed object-oriented database systems [4] use method invocation as a basis for data queries.
Reference: [27] <author> J. Ousterhaut. </author> <title> TCL: An Embeddable Command Language. </title> <booktitle> In Proceedings of the 1990 Usenix Winter Conference, </booktitle> <pages> pages 22-26, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Omniware's overhead of only 10-20% makes it an order of magnitude faster than any other universal mobile code system, because other universal systems must rely on abstract machine interpretation to enforce safety <ref> [11, 27] </ref>. For many applications of mobile code, such as executable content for Internet documents, our current performance is more than sufficient.
Reference: [28] <author> David A. Patterson. </author> <title> Reduced Instruction Set Computers. </title> <journal> Communications of the ACM, </journal> <volume> 28(1) </volume> <pages> 8-21, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: This separation of programming language implementation from program module safety enables Omniware to use a radically simplified virtual machine as its basis for portability. The use of SFI to enforce safety enables a key feature of the OmniVM design: the use of an enhanced RISC instruction set <ref> [28] </ref>. This design choice has two advantages. First, it simplifies the implementation of compilers to OmniVM and translators from OmniVM. For example, we retargeted both gcc [16] and lcc [15] to OmniVM within two months.
Reference: [29] <author> Dick Pountain. </author> <title> Parallel Course. </title> <journal> Byte, </journal> <volume> 19(7) </volume> <pages> 53-60, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Designed for portable optimization rather than mobile code, Mahler [38] defines a virtual machine that abstracts the details of several different Titan processor implementations. OmniVM differs from Mahler in the far wider range of architectures it supports, and the requirement for safe execution. Similarly, the Taos operating system <ref> [29] </ref> defines as its compiler target the Taos Virtual Processor, which, like Mahler, is an attempt to support multi-platform optimization. Binary translation systems [1] address the problem of migrating existing native code from one platform to another but ignore safety.
Reference: [30] <author> Bjarne Steensgaard and Eric Jul. </author> <title> Object and Native Code Thread Mobility Among Heterogeneous Computers. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year> <note> (to appear). 12 </note>
Reference-contexts: Similarly, distributed object-oriented database systems [4] use method invocation as a basis for data queries. In the absence of mobile code, these systems must manage heterogeneous binaries for each dynamically created data class. Because of these requirements, several languages for programming distributed systems, such as Orca [3] and Emerald <ref> [30] </ref>, incorporate mobile code as a fundamental programming construct. The mobile code systems introduced to date have used one of two methods for enforcing safe execution: abstract machine interpretation or language semantics. Abstract machine interpreters [11] trade performance for safety.
Reference: [31] <author> M. Stonebraker and G. Kemnitz. </author> <title> The POSTGRES next-generation database management system. </title> <journal> Com--munications of the ACM, </journal> <volume> 34(10) </volume> <pages> 78-92, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Software decomposition, when combined with a second trend, the widespread adoption of distributed computing, dictates the need for mobile code. For example, distributed database systems <ref> [31] </ref> and file systems [25] require safe function shipping to achieve scalability. An e-mail client can ship a mail-filtering function to a server to reduce server bandwidth requirements. A file system server can ship a decompression function to a client to offload its processing.
Reference: [32] <author> Richard E. Sweet. </author> <title> The mesa programming environment. </title> <booktitle> In Proceedings SIGPLAN Symposium on Language Issues in Programming Environments, </booktitle> <pages> pages 216-229, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: This mechanism is effective and language-independent, but inherently slow. A mobile code system can use language semantics to enforce safety by guaranteeing that a program can't affect physical resources that it can't name <ref> [32, 9, 34] </ref>. Though rare in current practice, it is possible to achieve good performance using this approach if the compiler intermediate form for the language retains type information [21, 33]. However, this approach works through restriction.
Reference: [33] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <type> Technical report, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> October </month> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: Though rare in current practice, it is possible to achieve good performance using this approach if the compiler intermediate form for the language retains type information <ref> [21, 33] </ref>. However, this approach works through restriction. In the context of mobile code, a type is essentially a promise not to do something.
Reference: [34] <author> Jeffrey Ullman. </author> <title> Elements of ML programming. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: This mechanism is effective and language-independent, but inherently slow. A mobile code system can use language semantics to enforce safety by guaranteeing that a program can't affect physical resources that it can't name <ref> [32, 9, 34] </ref>. Though rare in current practice, it is possible to achieve good performance using this approach if the compiler intermediate form for the language retains type information [21, 33]. However, this approach works through restriction.
Reference: [35] <author> Guido van Rossum. </author> <title> Python Tutorial, </title> <month> October </month> <year> 1995. </year> <note> Online at: http://www.python.org/doc/tut/tut.html. </note>
Reference-contexts: Some mobile code systems rely entirely on interpretation of source code at the host. Many scripting languages are in this category, including safe variants of Perl, Tcl [7] and Python <ref> [35] </ref>. These language-specific mobile code systems are very useful for certain unstructured tasks such as parsing user input.
Reference: [36] <author> Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. </author> <title> Efficent Software-Based Fault Isolation. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Our mobile code system, Omniware, uses software fault isolation to enforce safety <ref> [36] </ref>. Table 1 summarizes the Omniware performance for four SPEC 92 programs; Section 4 provides detailed performance results. To support universal, efficient mobile code, we generalize the notion of a virtual machine to what we call a software-defined computer architecture. <p> Section 4 quantifies the overhead of using OmniVM to enforce write and execute protections on multi-page segments. Software fault isolation can also support efficient read protection and fine-grained access protection <ref> [36, 37] </ref>. Omniware does not yet incorporate these capabilities. SFI uses only the semantics of the underlying processor to determine whether a mobile code module can corrupt its execution environment. <p> Tables 3 and 4 also show the execution time overhead introduced by SFI. On all platforms there is a performance penalty of approximately 10%. Other reports have investigated the impact of applying compiler optimizations to software fault isolation <ref> [36] </ref>. <p> Finally, SFI forms the foundation of our approach, but incurs an execution time overhead of approximately 10%. Despite this overhead, our performance is still good. The overhead of SFI optimizations can be reduced using standard compiler techniques such as loop invariant code motion, as described in <ref> [36] </ref>. We have not implemented SFI optimizations and expect optimization will cut this overhead in half. 5 Conclusion This paper described a mobile code system and its implementations on the Pentium, PowerPC, Mips and Sparc processors.
Reference: [37] <author> Robert Wahbe, Steven Lucco, and Susan Graham. </author> <title> Practical Data Breakpoints: </title> <booktitle> Design and Implementation. In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Section 4 quantifies the overhead of using OmniVM to enforce write and execute protections on multi-page segments. Software fault isolation can also support efficient read protection and fine-grained access protection <ref> [36, 37] </ref>. Omniware does not yet incorporate these capabilities. SFI uses only the semantics of the underlying processor to determine whether a mobile code module can corrupt its execution environment.
Reference: [38] <author> David Wall. </author> <title> Experience with a Software-Defined Machine Architecture. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3), </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: Designed for portable optimization rather than mobile code, Mahler <ref> [38] </ref> defines a virtual machine that abstracts the details of several different Titan processor implementations. OmniVM differs from Mahler in the far wider range of architectures it supports, and the requirement for safe execution. <p> We also enhance performance by performing basic-block optimization during OmniVM translation. Section 4 details the specific optimizations we applied to our benchmark programs. Most of the gains reported in Section 4 came from our local instruction scheduler <ref> [38] </ref>. We are currently adding global optimizations to our translators, although for applications such as Internet executable content, these optimizations will probably cost more in load time than they are worth in mobile module performance. <p> Our translators include several optimizations. We have implemented local instruction scheduling in our Mips and PowerPC translators based on the algorithm described in <ref> [38] </ref>. In our Mips and Sparc translators, we fill branch delay slots using instructions preceding the branch.
Reference: [39] <author> David W. Wall. </author> <title> Global Register Allocation at Link Time. </title> <booktitle> In Proceedings of the 7th SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 264-275, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Typically, compilers target an entire architecture family, not a particular machine. Several studies suggest that we can significantly enhance performance using this information <ref> [23, 39, 8] </ref>. 4 Results To evaluate the performance of mobile code based on OmniVM, we have retargeted gcc (version 2.4.5) to generate OmniVM assembly code, and have developed an assembler and linker that generate OmniVM object files and executables.
Reference: [40] <author> G. Williams. </author> <title> Hypercard (personal toolkit). </title> <journal> Byte, </journal> <volume> 12(14) </volume> <pages> 109-117, </pages> <month> December </month> <year> 1987. </year> <month> 13 </month>
Reference-contexts: Currently, the most visible computer application requiring mobile code is executable content for electronic documents. While documents containing executable content have been around for at least two decades <ref> [40, 12] </ref>, the combination of electronic documents with widely adopted network protocols [5] on the Internet requires mobile executable document content. Because the program bits that come off a network wire are often untrusted, safety is an essential feature of any mobile code system.
References-found: 40

