URL: http://www2.cs.cornell.edu/CS71X-s97/papers/Shivers88.ps
Refering-URL: http://www2.cs.cornell.edu/CS71X-s97/cs719bib.htm
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: shivers@cs.cmu.edu  
Title: Control Flow Analysis in Scheme  
Author: Olin Shivers 
Affiliation: Carnegie Mellon University  
Abstract: Traditional flow analysis techniques, such as the ones typically employed by optimising Fortran compilers, do not work for Scheme-like languages. This paper presents a flow analysis technique control flow analysis which is applicable to Scheme-like languages. As a demonstration application, the information gathered by control flow analysis is used to perform a traditional flow analysis problem, induction variable elimination. Extensions and limitations are discussed. The techniques presented in this paper are backed up by working code. They are applicable not only to Scheme, but also to related languages, such as Common Lisp and ML. 
Abstract-found: 1
Intro-found: 1
Reference: [Dragon] <author> Aho, Ullman. </author> <title> Principles of Compiler Design. </title> <publisher> Addison-Wesley (1977). </publisher>
Reference-contexts: Fortran). Representative texts describing these techniques are <ref> [Dragon] </ref>, and in more detail, [Hecht].
Reference: [Hecht] <author> Hecht, Matthew S. </author> <title> Data Flow Analysis of Computer Programs. </title> <publisher> American Elsevier (New York, </publisher> <year> 1977). </year>
Reference-contexts: Fortran). Representative texts describing these techniques are [Dragon], and in more detail, <ref> [Hecht] </ref>.
Reference: [R3-Report] <editor> J. Rees & W. Clinger, Ed.. </editor> <title> The Revised 3 Report on the Algorithmic Language Scheme. </title> <journal> SIG-PLAN Notices 21(12) (Dec. </journal> <year> 1986), </year> <pages> pp. 37-79. </pages>
Reference-contexts: In Lisp, we must represent and deal with transfers of control caused by function calls. This is most important in the Scheme dialects <ref> [R3-Report] </ref>, where lambda expressions occur with extreme frequency. In the interests of simplicity, then, we adopt a representation where all transfers of control sequencing, looping, function call/return, conditional branching are represented with the same mechanism: the tail recursive function call.
Reference: [Declarative] <author> Steele, Guy L. </author> <title> Lambda: The Ultimate Declarative. </title> <type> AI Memo 379. </type> <institution> MIT AI Lab (Cambridge, </institution> <month> November </month> <year> 1976). </year>
Reference-contexts: In the interests of simplicity, then, we adopt a representation where all transfers of control sequencing, looping, function call/return, conditional branching are represented with the same mechanism: the tail recursive function call. This representation is called CPS, or Continuation Passing Style, and is treated at length in <ref> [Declarative] </ref>. CPS stands in contrast to the intermediate representation languages commonly chosen for traditional optimising compilers. These languages are conventionally some form of slightly cleaned-up assembly language: quads, three-address code, or triples. The disadvantage of such representations are their ad hoc, machine-specific, and low-level semantics. <p> On the other hand, in all execution paths, reference 2:x occurs in the same environment as reference 3:x. We cannot do general data flow analysis unless we can untangle the multiple environments that variables can be bound in. This is not surprising. As is pointed out in <ref> [Declarative] </ref>, lambda serves a dual semantic role of providing both control and environment structure. Control flow analysis has provided information about only one of these structures. We must also gather information about the relationships among the binding environments established during program execution.
Reference: [Rabbit] <author> Guy L. Steele. Rabbit: </author> <title> A Compiler for Scheme. </title> <institution> AI-TR-474. MIT AI Lab (Cambridge, </institution> <month> May </month> <year> 1978). </year>
Reference-contexts: These languages are conventionally some form of slightly cleaned-up assembly language: quads, three-address code, or triples. The disadvantage of such representations are their ad hoc, machine-specific, and low-level semantics. The alternative of CPS was first proposed by Steele in <ref> [Rabbit] </ref>, and further explored by Kranz, et al. in [ORBIT]. The advantages of CPS lie in its appeal to the formal semantics of the -calculus, and its representational simplicity. CPS conversion can be referred to as the hedgehog approach, after a quotation by Archilocus.
Reference: [ORBIT] <author> Kranz, David, et al. </author> <title> Orbit: An Optimizing Compiler for Scheme. </title> <booktitle> Proceedings of SIGPLAN '86 Symposium on Compiler Construction (June 1986), </booktitle> <pages> pp. 219-233. </pages>
Reference-contexts: These languages are conventionally some form of slightly cleaned-up assembly language: quads, three-address code, or triples. The disadvantage of such representations are their ad hoc, machine-specific, and low-level semantics. The alternative of CPS was first proposed by Steele in [Rabbit], and further explored by Kranz, et al. in <ref> [ORBIT] </ref>. The advantages of CPS lie in its appeal to the formal semantics of the -calculus, and its representational simplicity. CPS conversion can be referred to as the hedgehog approach, after a quotation by Archilocus. All control and environment structures are represented in CPS by lambda expressions and their application. <p> Hence side effects are handled by primitive functions, and special syn tax is not required. Lisp code violating any of these restrictions is easily mapped into equivalent Lisp code preserving them, so they carry no loss of generality. In point of fact, the front end of the ORBIT compiler <ref> [ORBIT] </ref> performs the transformation of standard Scheme code into the above representation as the first phase of compilation.
Reference: [LetS] <author> Waters, Richard C. </author> <title> LETS: an Expressional Loop Notation. </title> <type> AI Memo 680. </type> <institution> MIT AI Lab (Cam-bridge, </institution> <month> October </month> <year> 1982). </year>
Reference-contexts: The control flow of inner loops is usually explicitly written out, and tends not to use functions as first class citizens. To further editorialise, I believe that the updating of loop variables is a task best left to loop packages such as Waters' LetS <ref> [LetS] </ref> or the Yale Loop [YLoop], where the actual updating technique can be left to the macro writer to implement efficiently, and ignored by the application programmer. Even the standard Common Lisp and Scheme looping construct, do, permits a binding interpretation of its iteration variable update semantics.
Reference: [YLoop] <institution> Online documentation for the T3 implementation of the Yloop package is distributed by its current maintainer: Prof. Chris Riesbeck, Yale CS Dept. (riesbeck@yale.arpa). </institution>
Reference-contexts: The control flow of inner loops is usually explicitly written out, and tends not to use functions as first class citizens. To further editorialise, I believe that the updating of loop variables is a task best left to loop packages such as Waters' LetS [LetS] or the Yale Loop <ref> [YLoop] </ref>, where the actual updating technique can be left to the macro writer to implement efficiently, and ignored by the application programmer. Even the standard Common Lisp and Scheme looping construct, do, permits a binding interpretation of its iteration variable update semantics.
Reference: [Hudak1] <author> Hudak, Paul. </author> <title> A Semantic Model of Reference Counting and its Abstraction. </title> <booktitle> Proceedings of the 1986 ACM Conference on Lisp and Functional Programming (August 1986). </booktitle>
Reference-contexts: We can use finer grained approximations, expending more work to gain more information. To borrow a technique from <ref> [Hudak1] </ref>, we can track multiple closures over the same lambda. Since it's clear that in the real lambda semantics, a finite program can give rise to unbounded numbers of closures, we must identify some real closures together.
Reference: [Hudak2] <author> Hudak, Paul. </author> <note> Collecting Interpretations of Expressions (Preliminary Version). Research Report YALEU/DCS/RR-497. Yale University (August 1986). </note>
Reference-contexts: Flow Analysis in Scheme, will treat the environment problem, showing its solution, and the application of the lastref function to performing general flow analysis, including type inference as a demonstration example. 8.3 Mathematics The mathematics of Scheme control, environment, and data flow analysis is captured by abstract semantic interpretations [Cousot] <ref> [Hudak2] </ref>. This will be the topic of another paper. 9 Acknowledgements I would like to thank my advisor, Peter Lee, for carefully reviewing several drafts of this paper.
Reference: [Cousot] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> 4th ACM Symposium on Principles of Programming Languages (1977), </booktitle> <pages> pp. 238-252. </pages>
Reference-contexts: Environment Flow Analysis in Scheme, will treat the environment problem, showing its solution, and the application of the lastref function to performing general flow analysis, including type inference as a demonstration example. 8.3 Mathematics The mathematics of Scheme control, environment, and data flow analysis is captured by abstract semantic interpretations <ref> [Cousot] </ref> [Hudak2]. This will be the topic of another paper. 9 Acknowledgements I would like to thank my advisor, Peter Lee, for carefully reviewing several drafts of this paper.
References-found: 11

