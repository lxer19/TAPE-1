URL: http://dimacs.rutgers.edu/techps/1993/93-12.ps
Refering-URL: http://dimacs.rutgers.edu/TechnicalReports/1993.html
Root-URL: http://www.cs.rutgers.edu
Title: Tight Bound for Edge Guards in Rectilinear Monotone Polygons  
Author: by Iliana Bjorling-Sachs 
Address: New Brunswick, New Jersey 08903  
Affiliation: Department of Computer Science Rutgers University  
Note: A  DIMACS is a cooperative project of Rutgers University, Princeton University, AT&T Bell Laboratories and Bellcore. DIMACS is an NSF Science and Technology Center, funded under contract STC-88-09648; and also receives support from the New Jersey Commission on Science and Technology.  
Abstract: DIMACS Technical Report 93-12 March 1993 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aggarwal, A. </author> <title> "The Art Gallery Theorem: Its Variations, Applications and Algorithmic Aspects," </title> <type> Ph.D. thesis, </type> <institution> Johns Hopkins University, </institution> <year> 1984. </year>
Reference-contexts: The variable oldSQ keeps track of the number of side-triangles that may have been left unguarded during the previous guard assignment and newSQ does the same for the current guard assignment. For the category where exactly one cross-quadrilateral is present we have: category1: newSQ 0 if T ype <ref> [1] </ref> = A then if l CD [0] lies below r CD [0] then output r CD [0] r CD [1] else (the case is symmetric) output l CD [0] l CD [1] endif elseif T ype [1] = B then if l CD [0] lies below r CD [0] then <p> For the category where exactly one cross-quadrilateral is present we have: category1: newSQ 0 if T ype <ref> [1] </ref> = A then if l CD [0] lies below r CD [0] then output r CD [0] r CD [1] else (the case is symmetric) output l CD [0] l CD [1] endif elseif T ype [1] = B then if l CD [0] lies below r CD [0] then output pred (l CD [0] )l CD [0] else (the case is symmetric) output pred (r CD [0] )r CD <p> For the category where exactly one cross-quadrilateral is present we have: category1: newSQ 0 if T ype <ref> [1] </ref> = A then if l CD [0] lies below r CD [0] then output r CD [0] r CD [1] else (the case is symmetric) output l CD [0] l CD [1] endif elseif T ype [1] = B then if l CD [0] lies below r CD [0] then output pred (l CD [0] )l CD [0] else (the case is symmetric) output pred (r CD [0] )r CD [0] endif if T ype [1] = C then if l CD <p> exactly one cross-quadrilateral is present we have: category1: newSQ 0 if T ype <ref> [1] </ref> = A then if l CD [0] lies below r CD [0] then output r CD [0] r CD [1] else (the case is symmetric) output l CD [0] l CD [1] endif elseif T ype [1] = B then if l CD [0] lies below r CD [0] then output pred (l CD [0] )l CD [0] else (the case is symmetric) output pred (r CD [0] )r CD [0] endif if T ype [1] = C then if l CD [0] = l CD [1] <p> output l CD [0] l CD <ref> [1] </ref> endif elseif T ype [1] = B then if l CD [0] lies below r CD [0] then output pred (l CD [0] )l CD [0] else (the case is symmetric) output pred (r CD [0] )r CD [0] endif if T ype [1] = C then if l CD [0] = l CD [1] then (the quadrilaterals has a single vertex on the left side) if l CD [0] lies below r CD [0] and oldSQ 2 then output r CD [0] succ (r CD [0] ) newSQ Above (r CD [1] ) <p> <ref> [1] </ref> = B then if l CD [0] lies below r CD [0] then output pred (l CD [0] )l CD [0] else (the case is symmetric) output pred (r CD [0] )r CD [0] endif if T ype [1] = C then if l CD [0] = l CD [1] then (the quadrilaterals has a single vertex on the left side) if l CD [0] lies below r CD [0] and oldSQ 2 then output r CD [0] succ (r CD [0] ) newSQ Above (r CD [1] ) else output l CD [0] l CD [1] endif else (the <p> ype <ref> [1] </ref> = C then if l CD [0] = l CD [1] then (the quadrilaterals has a single vertex on the left side) if l CD [0] lies below r CD [0] and oldSQ 2 then output r CD [0] succ (r CD [0] ) newSQ Above (r CD [1] ) else output l CD [0] l CD [1] endif else (the quadrilateral has a single vertex on the right side) the case is symmetric endif if T ype [1] = D then - 35 - if l CD [0] lies below r CD [0] then if Above (r CD <p> = l CD <ref> [1] </ref> then (the quadrilaterals has a single vertex on the left side) if l CD [0] lies below r CD [0] and oldSQ 2 then output r CD [0] succ (r CD [0] ) newSQ Above (r CD [1] ) else output l CD [0] l CD [1] endif else (the quadrilateral has a single vertex on the right side) the case is symmetric endif if T ype [1] = D then - 35 - if l CD [0] lies below r CD [0] then if Above (r CD [1] ) 2 then output pred (l CD [0] <p> r CD [0] and oldSQ 2 then output r CD [0] succ (r CD [0] ) newSQ Above (r CD <ref> [1] </ref> ) else output l CD [0] l CD [1] endif else (the quadrilateral has a single vertex on the right side) the case is symmetric endif if T ype [1] = D then - 35 - if l CD [0] lies below r CD [0] then if Above (r CD [1] ) 2 then output pred (l CD [0] )l CD [0] newSQ Above (l CD [1] ) else output r CD [1] succ (r CD [1] ) endif else <p> ) else output l CD [0] l CD <ref> [1] </ref> endif else (the quadrilateral has a single vertex on the right side) the case is symmetric endif if T ype [1] = D then - 35 - if l CD [0] lies below r CD [0] then if Above (r CD [1] ) 2 then output pred (l CD [0] )l CD [0] newSQ Above (l CD [1] ) else output r CD [1] succ (r CD [1] ) endif else (the case is symmetric) endif oldSQ newSQ count oldSQ CD [0] CD [1] The routines for categories where exactly two and <p> vertex on the right side) the case is symmetric endif if T ype <ref> [1] </ref> = D then - 35 - if l CD [0] lies below r CD [0] then if Above (r CD [1] ) 2 then output pred (l CD [0] )l CD [0] newSQ Above (l CD [1] ) else output r CD [1] succ (r CD [1] ) endif else (the case is symmetric) endif oldSQ newSQ count oldSQ CD [0] CD [1] The routines for categories where exactly two and three cross-quadrilaterals are present are similar. <p> case is symmetric endif if T ype <ref> [1] </ref> = D then - 35 - if l CD [0] lies below r CD [0] then if Above (r CD [1] ) 2 then output pred (l CD [0] )l CD [0] newSQ Above (l CD [1] ) else output r CD [1] succ (r CD [1] ) endif else (the case is symmetric) endif oldSQ newSQ count oldSQ CD [0] CD [1] The routines for categories where exactly two and three cross-quadrilaterals are present are similar. <p> if T ype <ref> [1] </ref> = D then - 35 - if l CD [0] lies below r CD [0] then if Above (r CD [1] ) 2 then output pred (l CD [0] )l CD [0] newSQ Above (l CD [1] ) else output r CD [1] succ (r CD [1] ) endif else (the case is symmetric) endif oldSQ newSQ count oldSQ CD [0] CD [1] The routines for categories where exactly two and three cross-quadrilaterals are present are similar. <p> r CD [0] then if Above (r CD <ref> [1] </ref> ) 2 then output pred (l CD [0] )l CD [0] newSQ Above (l CD [1] ) else output r CD [1] succ (r CD [1] ) endif else (the case is symmetric) endif oldSQ newSQ count oldSQ CD [0] CD [1] The routines for categories where exactly two and three cross-quadrilaterals are present are similar. Each time a guard is assigned, the algorithm checks a constant number of cases before deciding which case is appropriate.
Reference: [2] <author> Bjorling-Sachs, I. and Souvaine, D. </author> <title> "A Tight Bound for Edge Guards in Monotone Polygons," </title> <type> DIMACS Technical Report 92-52, </type> <month> December </month> <year> 1992. </year>
Reference-contexts: If the polygon is monotone then d (n 2)=5e edge guards are known to be both necessary and sufficient <ref> [2] </ref>. Here we give a tight bound of d (n 2)=6e edge guards for rectilinear monotone polygons. That d (n 2)=6e edge guards are necessary is shown in section 2 by means of an example. <p> Table 1: The behavior of the lower bound. - 3 - at most this many edge guards to cover the entire polygon. This algorithm is analogous to the one presented in <ref> [2] </ref> for monotone but non-rectilinear polygons. As a basis for our algorithm, we use Sack's monotone quadrilateralization algorithm [6]. This algorithm starts at the topmost edge and then moves downward creating quadrilaterals by drawing internal diagonals between vertices.
Reference: [3] <author> Chvatal, V. </author> <title> "A Combinatorial Theorem in Plane Geometry," </title> <editor> J. </editor> <booktitle> Combinatorial Theory Series B 18 (1975), </booktitle> <pages> 39-41. </pages>
Reference-contexts: Similarly mobile guards may be restrained to move only along the edges of the polygon or they may be allowed to cut across open spaces. The first problem of this type was solved in 1975 by V. Chvatal <ref> [3] </ref>. He showed that bn=3c stationary guards are always sufficient and sometimes necessary in any simple polygon with n edges. This original art gallery problem and its many variations and extensions are the focus of a book by J. O'Rourke [5] published in 1987.
Reference: [4] <author> Garey, Johnson, Preparata and Tarjan, </author> <title> "Triangulating a Simple Polygon," Info. </title> <booktitle> Proc. Letters 7 (1978), </booktitle> <pages> 175-180. </pages>
Reference: [5] <author> O'Rourke, J. </author> <title> "Art gallery problems and algorithms," </title> <publisher> Oxford University Press (1987). </publisher>
Reference-contexts: Chvatal [3]. He showed that bn=3c stationary guards are always sufficient and sometimes necessary in any simple polygon with n edges. This original art gallery problem and its many variations and extensions are the focus of a book by J. O'Rourke <ref> [5] </ref> published in 1987. More recent results, obtained since this book was published, can be found in a survey paper by T. Shermer [7]. In this paper we consider a variation of the problem, suggested in 1981 by G. <p> The problem is to find a bound on the number of guards necessary to ensure that every point in the polygon is seen by at least one guard. An example of a polygon with n vertices that requires bn=4c edge guards is shown in <ref> [5] </ref>, but no tight bound on the number of required guards exists for a polygon with arbitrary shape. If the polygon is monotone then d (n 2)=5e edge guards are known to be both necessary and sufficient [2].
Reference: [6] <author> Sack, J.R. and Toussaint, G. </author> <title> "Guard Placement in Rectilinear polygons," </title> <booktitle> Computational Morphology (1988), </booktitle> <pages> 153-175. </pages>
Reference-contexts: Table 1: The behavior of the lower bound. - 3 - at most this many edge guards to cover the entire polygon. This algorithm is analogous to the one presented in [2] for monotone but non-rectilinear polygons. As a basis for our algorithm, we use Sack's monotone quadrilateralization algorithm <ref> [6] </ref>. This algorithm starts at the topmost edge and then moves downward creating quadrilaterals by drawing internal diagonals between vertices.
Reference: [7] <author> Shermer, T. </author> <title> "Recent Results in Art Galleries," </title> <booktitle> Proceedings of the IEEE vol. </booktitle> <volume> 80, no. 9, </volume> <year> (1992), </year> <pages> 1384-1399. </pages>
Reference-contexts: This original art gallery problem and its many variations and extensions are the focus of a book by J. O'Rourke [5] published in 1987. More recent results, obtained since this book was published, can be found in a survey paper by T. Shermer <ref> [7] </ref>. In this paper we consider a variation of the problem, suggested in 1981 by G. Toussaint, where each guard is allowed to move along one individual edge of the polygon. Guards of this type are called edge guards.
References-found: 7

