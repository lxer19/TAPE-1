URL: ftp://ftp.cs.virginia.edu/pub/techreports/IPC-88-03.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Scoping Persistent Name Spaces in ADAMS  
Author: J.L. Pfaltz, J.C. French, J.L. Whitlatch 
Address: Charlottesville, VA 22903  
Affiliation: Institute for Parallel Computation School of Engineering and Applied Science University of Virginia  
Date: June 28, 1988  
Pubnum: TR-88-03  
Abstract-found: 0
Intro-found: 1
Reference: [BaS77] <author> R. Bayer and M. Schkolnick, </author> <title> Concurrency of Operations on B-Trees., </title> <journal> Acta Inf. </journal> <volume> 9(1977), </volume> <pages> 1-21. </pages>
Reference-contexts: Carla Ellis [Ell80], expanding on work by Bayer and Schkolnick <ref> [BaS77] </ref>, defined three different locks, one for reading a node, two for writing. One of the "write" locks allowed only one process access at a time; the other two locks kept counts of processes using the lock on a given object at any one time.
Reference: [BuA86] <author> P. Buneman and M. Atkinson, </author> <title> Inheritance and Persistence in Database Programming Languages, </title> <booktitle> Proc. ACM SIGMOD Conf. </booktitle> <month> 15,2 (May </month> <year> 1986), </year> <pages> 4-15. </pages>
Reference-contexts: These are not unsurmountable issues; but clearly they can be messy. Third, as we develop computer languages that are capable of handling persistent objects, e.g. <ref> [BuA86] </ref>, we must be able to create and name persistent types, which are not traditional entities and need not be singular.
Reference: [CoM84] <author> G. Copeland and D. Maier, </author> <title> Making Smalltalk a Database System, </title> <booktitle> Proc. SIGMOD Conf., </booktitle> <address> Boston, </address> <month> June </month> <year> 1984, </year> <pages> 316-325. </pages>
Reference-contexts: The meaning of a name is that object, or element, or concept, which it denotes. Even though ADAMS may be regarded as an object-oriented database language <ref> [CoM84, MSe86] </ref>, we try to avoid using the term object. The things that an ADAMS name denotes are not true objects in the sense of [GoR83, 81]; that is, their manipulation is not restricted to only those methods (or processes) declared for the class. <p> In ADAMS, we use a "class" concept to denote a general class of objects. The use of "class" in this context has been popularized by "Smalltalk-80" <ref> [CoM84, GoR83, 81] </ref>. However, many readers may feel more comfortable if they substitute the synonym data type for class. Specific objects are named instantiations of the class. The basic class definition statement has the form 8 &lt;class_name&gt; is a &lt;class_designator&gt; [ &lt;definition&gt; ][ with scope &lt;scope_id&gt; ].
Reference: [Ell80] <author> C. S. Ellis, </author> <title> Concurrent Search and Insertion in 2-3 Trees, </title> <journal> Acta Inf. </journal> <volume> 14(1980), </volume> <pages> 63-86. </pages>
Reference-contexts: A number of researchers have designed lock mechanisms that in effect permit various degrees of access to items (nodes of a tree, pages of a file) and allow update only when the lock is exclusive (as defined by the system). Carla Ellis <ref> [Ell80] </ref>, expanding on work by Bayer and Schkolnick [BaS77], defined three different locks, one for reading a node, two for writing.
Reference: [GoR83] <author> A. Goldberg and D. Robson, </author> <title> Smalltalk-80: The Language and Its Implementation, </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year> <month> 36 </month>
Reference-contexts: Even though ADAMS may be regarded as an object-oriented database language [CoM84, MSe86], we try to avoid using the term object. The things that an ADAMS name denotes are not true objects in the sense of <ref> [GoR83, 81] </ref>; that is, their manipulation is not restricted to only those methods (or processes) declared for the class. We prefer to use a more neutral term, element. But, in the context of this paper, the reader may choose to treat element and object as synonyms. <p> In ADAMS, we use a "class" concept to denote a general class of objects. The use of "class" in this context has been popularized by "Smalltalk-80" <ref> [CoM84, GoR83, 81] </ref>. However, many readers may feel more comfortable if they substitute the synonym data type for class. Specific objects are named instantiations of the class. The basic class definition statement has the form 8 &lt;class_name&gt; is a &lt;class_designator&gt; [ &lt;definition&gt; ][ with scope &lt;scope_id&gt; ].
Reference: [HoU79] <author> J. E. Hopcroft and J. D. Ullman, </author> <title> Introduction to Automata Theory, Languages, and Computation, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference-contexts: Given its hierarchical organization, this reduces the scope of the name space that must be examined. Finally, ADAMS requires that all co-domains must be regular sets 35 defined by regular expressions. Thus, in theory (c.f. <ref> [HoU79] </ref>) the test for whether or not two co-domains are synonymous is decidable. (In practice, ADAMS does not test for synonymy between co-domains so only strongly synonymous attribute functions will be discovered.) Finally, we address the issue of synonymy enforcement protocols.
Reference: [KhC86] <author> S. N. Khoshafian and G. P. Copeland, </author> <title> Object Identity, </title> <booktitle> OOPSLA '86, Conf. Proc., </booktitle> <month> Sep. </month> <year> 1986, </year> <pages> 406-416. </pages>
Reference-contexts: But there is a danger in tying the the concept of a name too closely with that of the unique identification of a single entity or object. First, Khoshafian and Copeland point out in their excellent paper <ref> [KhC86] </ref>, there are many ways of identifying objects of interest besides naming them. One should avoid treating naming and identification as if they were synonyms. Second, the concepts of uniqueness and singularity are difficult to establish rigorously. They are very context dependent.
Reference: [MSe86] <author> D. Maier, J. Stein and et.al., </author> <title> Development of an Object-Oriented DBMS, </title> <booktitle> OOPSLA '86, Conf. Proc., </booktitle> <month> Sep. </month> <year> 1986, </year> <pages> 472-482. </pages>
Reference-contexts: The meaning of a name is that object, or element, or concept, which it denotes. Even though ADAMS may be regarded as an object-oriented database language <ref> [CoM84, MSe86] </ref>, we try to avoid using the term object. The things that an ADAMS name denotes are not true objects in the sense of [GoR83, 81]; that is, their manipulation is not restricted to only those methods (or processes) declared for the class.
Reference: [Pei49] <author> M. Pei, </author> <title> The Story of Language, </title> <address> J.B. Lippincott, Philadelphia, </address> <year> 1949. </year>
Reference-contexts: Name Space Hierarchy The meaning of words and names depends on their context. This is evident in natural language; meanings depend upon one's dialect, geographical location, economic position, educational level, and vocational speciality <ref> [Pei49] </ref>. In computer science, the importance of context has been most clearly formalized. Most readers will be familiar with a block structured language, such as Pascal or Algol, in which two identical words (variable identifiers), in separate procedures, can have completely different semantic meaning.
Reference: [Pfa77] <author> J. L. Pfaltz, </author> <title> Computer Data Structures, </title> <publisher> McGraw-Hill, </publisher> <month> Feb. </month> <year> 1977. </year>
Reference-contexts: An early, but generally effective, mechanism to ensure the safe removal of subordinate list structures has appeared in [Wei63] and <ref> [Pfa77] </ref>. It requires a record of the number of referencing super-lists. 29 5.1.
Reference: [PSF87] <author> J. L. Pfaltz, S. H. Son and J. C. </author> <title> French, Basic Database Concepts in the ADAMS Language Interface for Process Service, </title> <institution> IPC TR-87-001, Institute for Parallel Computation, Univ. of Virginia, </institution> <month> Nov. </month> <year> 1987. </year>
Reference-contexts: Third, as we develop computer languages that are capable of handling persistent objects, e.g. [BuA86], we must be able to create and name persistent types, which are not traditional entities and need not be singular. In ADAMS, the Advanced DAta Management System being developed at the University of Virginia <ref> [PSF87] </ref>, we resolve a number of these issues by regarding as "names" all noun-like words which denote in some manner things of interest in our particular universe of discourse which is the implementation of, and access in, databases.
Reference: [PSF88] <author> J. L. Pfaltz, S. H. Son and J. C. </author> <title> French, The ADAMS Interface Language, </title> <booktitle> Proc. 3th Conf. on Hypercube Concurrent Computers and Applications, </booktitle> <address> Pasadena, CA, </address> <month> Jan. </month> <year> 1988, </year> <pages> 1382-1389. </pages>
Reference-contexts: As noted earlier, the ADAMS Dictionary is persistent. Consequently, it structure can be described within the ADAMS syntax itself. Given below, in figure 6, is such a definition. Readers, unfamiliar with this syntax should refer to <ref> [PSF88] </ref>. Note that both this definition and the C definition given above are incomplete; a number of "low-level" types and co_domains are left undefined. The "union" of structures in C has always been an awkward construct, as has the "variant" record in Pascal syntax.
Reference: [Wei63] <author> J. Weizenbaum, </author> <title> Symmetric List Processor, </title> <journal> Comm. ACM 6,10 (Oct. </journal> <year> 1963), </year> <pages> 524-536. </pages>
Reference-contexts: An early, but generally effective, mechanism to ensure the safe removal of subordinate list structures has appeared in <ref> [Wei63] </ref> and [Pfa77]. It requires a record of the number of referencing super-lists. 29 5.1.
Reference: [WiH81] <author> P. H. Winston and B. K. P. Horn, </author> <title> LISP, </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1981. </year>
Reference-contexts: Garbage collection is a useful, automatic way to remove items that can no longer be referenced, and hence used. The method appears as an integral component of LISP interpreters, to deallocate storage for LISP functions or lists no longer active <ref> [WiH81] </ref>. It may also provide a means of deallocating heap storage no longer referenced by active processes. Garbage collection 28 depends on two factors; a means of marking the objects to be retained or deleted, and a means of inspecting the parts of the system that might use the objects.

References-found: 14

