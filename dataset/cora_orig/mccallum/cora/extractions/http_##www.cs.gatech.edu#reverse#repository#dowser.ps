URL: http://www.cs.gatech.edu/reverse/repository/dowser.ps
Refering-URL: http://www.cs.gatech.edu/reverse/repos.html
Root-URL: 
Title: Dowsing: A Tools Framework for Domain-Oriented Browsing of Software Artifacts  
Author: Richard Clayton, Spencer Rugaber, and Linda Wills 
Keyword: reverse engineering, domain analysis, program understanding, software tools  
Affiliation: Georgia Institute of Technology  
Abstract: Program understanding is an essential part of software maintenance and enhancement activities that relates a computer program to the goals and requirements it is designed to accomplish. Understanding techniques that rely only on source-code analysis are limited in their ability to derive this relationship. Application-domain analysis is another source of information that can aid program understanding by guiding the source-code analysis and providing structure to its results. We use the term dowsing to describe the process of exploring software and the related documentation from an application-domain point of view. We have designed a tools infrastructure to support dowsing and populated it with a variety of commercial and research tools. We have used the infrastructure and tools to explore software in two application domains: web browsers and software loader/verifiers for embedded systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Russell J. Abbott. </author> <title> Program Design by Informal English Descriptions. </title> <journal> Communications of the ACM, </journal> <volume> 12(11): </volume> <pages> 882-894, </pages> <month> November </month> <year> 1983. </year>
Reference-contexts: We then manually perform a noun-and-verb analysis on the textual description to extract possible object classes and associations. This step was suggested by the original approach to objectoriented analysis proposed by Abbot <ref> [1] </ref>. The second step in creating the application-domain model is to take the objects and associations found in the first step and organize them into a coherent model. We chose to organize around OMT because of its familiarity in the software engineering community.
Reference: [2] <author> Alfred V. Aho, Brian W. Kernighan, and Peter J. Weinberger. </author> <title> The AWK Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: However, usually it is easier to have the database write the analysis results as text into a file, and then let external programs massage the data file. This is what was done, for example, by the call-graph generator, which uses a simple awk <ref> [2] </ref> script to read the results of the call-graph analysis and write a description of the call graph in the language used by the dot graph-drawing program [20]. The results can be seen in Figure 4. 4.
Reference: [3] <author> Ted J. Biggerstaff, Bharat G. Mitbander, and Dallas Webster. </author> <title> Program Understanding and the Concept Assignment Problem. </title> <journal> Communications of the ACM, </journal> <volume> 37(5) </volume> <pages> 72-83, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: portrayed graphically to give an idea of the relative distribution of the concepts of interest; queries about relationships between concepts or actors in the domain; identification of the use of typical programming solutions used in the domain, such architectural styles, patterns, and cliches; data type analysis linked with concept assignment <ref> [3] </ref> to connect programmer-defined types with domain concepts. Domain Analysis A domain is a problem area. Typically, many application programs exist to solve the problems in a single domain. <p> In one sense, LaSSIE is interested in promoting reuse at the sub-architectural (e.g. module or subprogram) level, while our work is interested in promoting reuse at the architectural level. A high-level approach which influenced our work is that taken by DESIRE <ref> [3] </ref>. DESIRE was the first software understanding systems to make use of a rich domain model. This model contains machine-processable forms of design expectations for a particular domain, as well as informal semantic concepts.
Reference: [4] <author> Barry W. Boehm. </author> <title> Software Engineering Economics. </title> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: 1. Introduction Dowsing Software maintenance and enhancement activities are the largest part of total lifecycle costs <ref> [4] </ref>. Moreover, understanding source code and change requirements dominate maintenance and enhancement effort [14]. Consequently, methods and techniques for creating and browsing software artifacts that improve their understandability can significantly aid the overall software development process.
Reference: [5] <author> Grady Booch. </author> <title> ObjectOriented Analysis and Design with Applications, second edition. </title> <address> Benjamin/Cummings, </address> <year> 1994. </year>
Reference-contexts: Coupling Analysis The amount of communication between modules can be used as a measure of the strength of the association between them. A measure of the coupling [32] between two modules or objects is indicated by the strength of this association <ref> [5] </ref>. We interpret coupling as common, global-variable access; two subprograms accessing the same global are considered coupled. Determining the degree of coupling within a relational framework is somewhat complicated, particularly when the calculations involve more than simple counting and arithmetic.
Reference: [6] <author> Steven E. Brenner and Edwin Aoki. </author> <title> Introduction to CGI/PERL. M & T Books, </title> <year> 1996. </year>
Reference-contexts: Third, the constructed OMT Object Model is instantiated in a machine-manipulatable form using the Software Refinery tool set. In our Mosaic case study, we perform object analysis on textual descriptions of web browsers (such as Chapter 1 from <ref> [6] </ref>) by performing word-frequency analysis and object extraction. Frequency analysis is a first pass over the descriptions to determine important words. After eliminating noise words such as the, the remaining words are counted; high frequency words are assumed to be more important than low frequency words.
Reference: [7] <author> Eric J. Byrne and Gokul V. Subramamian. </author> <title> Deriving an Object Model from Legacy Fortran Code. </title> <booktitle> Proceedings of the International Conference on Software Maintenance, </booktitle> <address> Monterey, California, </address> <month> November 4-8, </month> <year> 1996, </year> <pages> 3-12. </pages>
Reference-contexts: From a domain-model perspective, the inter-object communication serves to suggest associations among objects. Type Analysis Analysis of source code data types may be used to develop an objectoriented representation of the code, even if the source language does not natively support objectoriented constructs <ref> [7] </ref>. Part-of associations (aggregation data structures) may be derived from analysis of the hierarchical structure of the types. For example, a datatypes subcomponent may refer to a collection. If a member subprogram associated with the datatype retrieves elements from the collection, that indicates a part-of association.
Reference: [8] <author> Y. F. Chen and C. V. Ramamoorthy. </author> <title> The C Information Abstractor. </title> <booktitle> Proceedings COMPASC 86, IEEE, </booktitle> <pages> 291-298, </pages> <year> 1986. </year>
Reference: [9] <author> Richard Clayton, Spencer Rugaber, Lyman Taylor, Linda Wills, </author> <title> A Case Study of Domain-based Program Understanding, </title> <booktitle> 5th International Workshop on Program Comprehension, </booktitle> <address> Dearborn, Michigan, </address> <month> May 28-30, </month> <year> 1997. </year>
Reference: [10] <author> E. Dahlhaus, D. S. Johnson, C. H. Papadimitriou, P. D. Seymour, and M. Yannakakis. </author> <title> The Complexity of Multiway Cuts (Extended Abstract). </title> <booktitle> 24th Annual ACM STOC, </booktitle> <address> May 1992, Victoria Canada, </address> <pages> pages 241-251. </pages>
Reference-contexts: Make use of the third-dimension and allow the analyst to navigate through the resulting visualizations to detect patterns; Apply some experimental algorithms that propose node-groupings that might suggest modules or architectural components to the analyst <ref> [10] </ref>; Make use of information from actual executions to color an otherwise confusing graph, indicating "hot spots," similar to an MRI scan of a human brain taken while the subject is performing some task.
Reference: [11] <author> Jean-Marc DeBaud, Bijith M. Moopen, and Spencer Rugaber. </author> <title> Domain Analysis and Reverse Engineering. </title> <booktitle> Proceedings of the 1994 International Conference on Software Maintenance. </booktitle> <address> Victoria, British Columbia, Canada, </address> <month> September 19-23, </month> <year> 1994, </year> <pages> 326-335. </pages>
Reference: [12] <author> Premkumar Devanbu, Ronald J. Brachman, Peter G. Selfridge, and Bruce W. Ballard. </author> <title> LaSSIE: A Knowledge-Based Software Information System, </title> <journal> Communications of the ACM, </journal> <volume> 34(5) </volume> <pages> 35-49, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Our work draws on and benefits from a set of approaches differing at the level of abstraction at which they address the problem. Our work is similar to approaches taken at the highest level of abstraction, such as LaSSIE <ref> [12] </ref>. LaSSIE is a knowledge-based information system designed to support maintenance and enhancements on a large software system. The LaSSIE knowledge base uses frames to represent information about the softwares domain, architecture, and code.
Reference: [13] <editor> Dialect User's Guide. </editor> <booktitle> Reasoning Systems, </booktitle> <address> Palo Alto, California, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: The domain model is represented using the Object Base, the Software Refinery subsystem responsible for holding the results of program analysis. In addition, we use its Dialect <ref> [13] </ref> tool to build parsers that translate between Refinery internal and external textual representations of the Object Model. Program Analysis Activities We have performed our program analyses using the Source Browser Facility (SBF) that is provided by SUN Microsystems with its C and C++ compilers [33].
Reference: [14] <author> R. K. Fjeldstad and W. T. Hamlen. </author> <title> Application Program Maintenance Study: Report to Our Respondents. Proceedings GUIDE 48, </title> <address> Philadelphia, Pennsylvania, </address> <month> April </month> <year> 1983, </year> <title> Tutorial on Software Maintenance, </title> <editor> G. Parikh and N. Zvegintozov, editors, </editor> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: 1. Introduction Dowsing Software maintenance and enhancement activities are the largest part of total lifecycle costs [4]. Moreover, understanding source code and change requirements dominate maintenance and enhancement effort <ref> [14] </ref>. Consequently, methods and techniques for creating and browsing software artifacts that improve their understandability can significantly aid the overall software development process.
Reference: [15] <author> David Garlan and Mary Shaw. </author> <title> Software Architecture: Perspectives on an Emerging Discipline. </title> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference-contexts: We believe an architectural abstraction of the program can bridge this gap. This raises several issues: What is the relation between the application-domain model and the architecture? How can architectural styles <ref> [15] </ref> be connected to program descriptions resulting from standard code analyses? What annotation mechanisms should be used to make these relationships explicit and allow them to evolve as the domain model is refined and program descriptions emerge? As the domain model, architectural description, and program description emerge and evolve, how are
Reference: [16] <author> Judith E. Grass and Yih-Farn Chen. </author> <title> The C++ Information Abstractor. </title> <booktitle> 1990 USENIX Conference, </booktitle> <year> 1990, </year> <pages> 265-277. </pages>
Reference: [17] <author> Ralph E. Griswald and Madge T. Griswald. </author> <title> The Icon Programming Language. </title> <publisher> Prentice Hall, </publisher> <year> 1983. </year>
Reference-contexts: This facility builds an initial procedural-level model of the code from which we access raw data necessary for our code analyses. After implementing a few analysis programs by hand using the Icon programming language <ref> [17] </ref>, we stored our raw data in a relational database and performed our analyses using SQL queries. SQL allowed us to quickly and easily formulate code analyses with a minimum of programming, but with a cost in naturalness in expression.
Reference: [18] <author> David R. Harris, Howard B. Reubenstein, and Alexander S. Yeh. </author> <title> Recognizers for Extracting Architectural Features from Source Code. </title> <booktitle> Second Working Conference on Reverse Engineering. </booktitle> <editor> Linda Wills, Philip Newcomb, and Elliot Chikofsky, </editor> <booktitle> editors, </booktitle> <pages> pp. 252-261, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> July </month> <year> 1995. </year>
Reference: [19] <author> W. Lewis Johnson and Ali Erdem. </author> <title> Interactive Explanation of Software Systems. </title> <journal> Automated Software Engineering, </journal> <volume> Volume 2, </volume> <year> 1996. </year>
Reference-contexts: Our work on dowsing and linkage tools has also been influenced by Johnson and Erdems research on interactive software explanation <ref> [19] </ref> as demonstrated in the IDOC tool. We share the goals of supporting interactive querying to explore results of code analyses and of using hypermedia to support browsing annotated software artifacts. Johnsons focus has been on supporting queries that are typically made in the context of performing specific maintenance tasks.
Reference: [20] <author> E. Koutsofios and S. C. </author> <title> North. Drawing Graphs with dot. </title> <journal> AT&T. </journal>
Reference-contexts: This is what was done, for example, by the call-graph generator, which uses a simple awk [2] script to read the results of the call-graph analysis and write a description of the call graph in the language used by the dot graph-drawing program <ref> [20] </ref>. The results can be seen in Figure 4. 4. Comparison with Other Work Recognizing and exploiting structure in domain, architecture, and code is the central problem in supporting program understanding.
Reference: [21] <author> MacDougall, M.H., </author> <title> Simulating Computer Systems: Techniques and Tools. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference: [22] <author> Mosaic. </author> <note> http://www.ncsa.uiuc.edu/SDG/Software/Mosaic. </note>
Reference-contexts: This section looks at several dowsing examples in the context of two case studies of our approach on significant applications. The first study examines the Mosaic web browser <ref> [22] </ref>. A web browser is a tool for exploring and reading documents on the Internet. Mosaic is a mature, publicly available browser whose 100,000 lines of source code are written in the C language, and for which some documentation is available.
Reference: [23] <author> MySQL. </author> <note> http://www.tcs.se. </note>
Reference-contexts: Repository Tools At the core of the Dowser is a repository for entering and managing the conceptual and logical models generated by the other tools. We have explored two such tools, the Refinery's objectoriented repository [28] and a public-domain, relational, record-management tool called MySQL <ref> [23] </ref>. The former has the natural advantages of being congruent to the domain model and integrated with one of the code analysis tools. The latter approach, similar to that taken by CIA and CIA++ [8,16], has the advantages of the relational algebra query language and a smaller conceptual footprint.
Reference: [24] <author> James M. Neighbors. </author> <title> Draco: A Method for Engineering Reusable Software Components. </title> <booktitle> Software Reusability / Concepts and Models, </booktitle> <volume> volume 1, </volume> <editor> Ted J. Biggerstaff and Alan J. Perlis, editors, </editor> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Once recognized, a domain can be characterized by its vocabulary, common assumptions, architectural approach, and literature. Domain analysis, according to Neighbors <ref> [24] </ref>, "is an attempt to identify the objects, operators, and relationships between what domain experts perceive to be important about the domain." As such, it bears a close resemblance to traditional systems analysis, but at the level of a collection of problems rather than a single one.
Reference: [25] <institution> OmniPage Professional Reference Manual. Caere Corporation, Los Gatos, California, </institution> <year> 1994. </year>
Reference-contexts: Consequently, such descriptions must be converted into a formal model of the domain. Although this cannot be done entirely automatically, we have developed or made use of tools for scanning in text and converting it to ASCII characters <ref> [25] </ref>, formatting the resulting text stream into structured HTML, and performing several types of lexical analyses. These lexical analyses include breaking text into words and filtering out uninteresting words, parsing it to determine parts of speech, detecting candidate objects, actions, and states, and computing word frequencies. <p> Army Tank and Automotive Command. The program is written in the Ada language and comprises 10,000 lines of code. The documentation is available only in hardcopy form, so we made use of scanning and character recognition tools for converting it to electronic form <ref> [25] </ref>. Domain Modeling Activities The core of our approach to program exploration is an application-domain model of the software. We have provided tools to help derive the domain model from software design artifacts and documents written about the application problem.
Reference: [26] <author> Rubn Prieto-Daz and Guillermo Arango. </author> <title> Domain Analysis and Software Systems Modeling. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> California, </address> <year> 1991. </year>
Reference-contexts: Domain Analysis A domain is a problem area. Typically, many application programs exist to solve the problems in a single domain. Arango and Prieto Diaz <ref> [26] </ref> give the following prerequisites for the presence of a domain: the existence of comprehensive relationships among objects in the domain, a community interested in solutions to the problems in the domain, a recognition that software solutions are appropriate to the problems in the domain, and a store of knowledge or
Reference: [27] <author> Alex Quilici and David N. Chin. </author> <title> DECODE: A Cooperative Environment for Reverse-Engineering Legacy Software. </title> <booktitle> Second Working Conference on Reverse Engineering, </booktitle> <editor> Linda Wills, Philip Newcomb, and Elliot Chikofsky, </editor> <booktitle> editors, </booktitle> <pages> pp. 156-165, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> July </month> <year> 1995. </year>
Reference-contexts: In the other direction, the domain knowledge made available in our work could serve to direct and sharpen pattern matching. Approaches still lower than those previously described are taken by such systems as DECODE <ref> [27] </ref>, which uses cooperative, bottom-up code analysis to create objectoriented descriptions (that is, data plus operations) of existing code. The code is analyzed using pattern-matching techniques scalable over large bodies of code.
Reference: [28] <institution> Refine User's Guide. Reasoning Systems Incorporated. Palo Alto, California, </institution> <year> 1990. </year>
Reference-contexts: For the first type, we have used two commercial tools, the Software Refinery tool suite (Refinery) <ref> [28] </ref> and the Source Browser Facility (SBF) [33] that is provided by SUN Microsystems with its Solaris C and C++ compilers. <p> Repository Tools At the core of the Dowser is a repository for entering and managing the conceptual and logical models generated by the other tools. We have explored two such tools, the Refinery's objectoriented repository <ref> [28] </ref> and a public-domain, relational, record-management tool called MySQL [23]. The former has the natural advantages of being congruent to the domain model and integrated with one of the code analysis tools. <p> For example, Figure 2 shows the OMT diagram we derived in the Mosaic case study. The third step in creating an application-domain model is to reify the OMT Object Model in a machine-processible form. We chose Refine, part of the Software Refinery <ref> [28] </ref>, as our modeling language. The Refinery is a large, Lisp-based program suite oriented towards program analysis and transformation. The Refinery is well suited to support dowsing because it can be used to represent both the application domain and the code under analysis.
Reference: [29] <author> Spencer Rugaber. </author> <title> Position Paper Domain Analysis and Reverse Engineering. </title> <booktitle> Software Engineering Techniques Workshop on Software Reengineering, </booktitle> <institution> Software Engineering Institute, Pittsburgh, Pennsylvania, </institution> <month> May 3-5, </month> <year> 1994. </year>
Reference: [30] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Domain access is provided in terms of an explicit domain model comprising two parts: a vocabulary and an OMT static model <ref> [30] </ref>. The vocabulary consists of key domain concepts from which keyword searches can be composed. It also serves as the starting point for the construction of the OMT model. The OMT model consists of domain actors and objects and the associations among them. <p> We create an application-domain model in three steps. First, various descriptions of the domain are analyzed to extract relevant information about the domain. Second, the extracted information is organized into a coherent application-domain model by applying the Object Modeling Technique (OMT) <ref> [30] </ref>. Third, the constructed OMT Object Model is instantiated in a machine-manipulatable form using the Software Refinery tool set. In our Mosaic case study, we perform object analysis on textual descriptions of web browsers (such as Chapter 1 from [6]) by performing word-frequency analysis and object extraction.
Reference: [31] <author> Eliot Soloway, Jeannine Pinto, Stan Letovsky, David Littman, and Robin Lampert. </author> <title> Designing Documentation to Compensate for Delocalized Plans. </title> <journal> Communications of the ACM, </journal> <volume> 31(11): </volume> <pages> 1259-1267, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: Unfortunately, such pointers typically suffer from several difficulties: being out-of-date with respect to the source code, indicating specific code without specifying the nature of the connection between the documentation and the code, and not supporting delocalized (non-contiguous) mappings between documents and code <ref> [31] </ref>. Our approach is to provide semi-automated support for deriving domain and code models from the actual software artifacts and for exploring the software that is organized around the domain model.
Reference: [32] <author> W. P. Stevens, G. J. Myers, and L. L. Constantine. </author> <title> Structured Design. </title> <journal> IBM Systems Journal, </journal> <volume> 13(2) </volume> <pages> 115-139, </pages> <year> 1974. </year>
Reference-contexts: Invocation (or call graph) analysis determines which subprograms invoke others in a program. If subprograms are grouped into modules, then the invocation between subprograms in different modules can be used to represent communication between the modules. Also, if a comparison between intra- and inter-module invocations is developed, module coherence <ref> [32] </ref> can be evaluated. If the modules denote architectural components, intercomponent communication is represented. From a domain-model perspective, the inter-object communication serves to suggest associations among objects. <p> Additionally, datatypes serving as collections have to be identified. Coupling Analysis The amount of communication between modules can be used as a measure of the strength of the association between them. A measure of the coupling <ref> [32] </ref> between two modules or objects is indicated by the strength of this association [5]. We interpret coupling as common, global-variable access; two subprograms accessing the same global are considered coupled.
Reference: [33] <institution> Browsing Source Code. Sun Microsystems. </institution> <year> 1994. </year>
Reference-contexts: For the first type, we have used two commercial tools, the Software Refinery tool suite (Refinery) [28] and the Source Browser Facility (SBF) <ref> [33] </ref> that is provided by SUN Microsystems with its Solaris C and C++ compilers. <p> Program Analysis Activities We have performed our program analyses using the Source Browser Facility (SBF) that is provided by SUN Microsystems with its C and C++ compilers <ref> [33] </ref>. This facility builds an initial procedural-level model of the code from which we access raw data necessary for our code analyses.
Reference: [34] <author> A. Yeh, D. Harris, and H. Reubenstein. </author> <title> Recovering Abstract Data Types and Object Instances from a Conventional Procedural Language. </title> <booktitle> Proceedings of the Second Working Conference on Reverse Engineering, </booktitle> <address> Toronto, Ontario, Canada, </address> <pages> pp. 227-236, </pages> <month> July </month> <year> 1995. </year>
Reference: [35] <author> Zeigler, </author> <title> B.P., Theory of Modeling and Simulation, </title> <publisher> John Wiley and Sons, </publisher> <address> New York, </address> <year> 1976. </year>
References-found: 35

