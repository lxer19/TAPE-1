URL: http://www.cs.princeton.edu/~appel/papers/142.ps
Refering-URL: http://www.cs.princeton.edu/~appel/papers/
Root-URL: http://www.cs.princeton.edu
Author: Andrew W. Appel 
Note: Supported in part by NSF Grant DCR-8603453 and by a Digital Equipment Corp. Faculty Incentive Grant  
Date: March 1988  
Address: CS-TR-142-88  
Affiliation: Princeton University  
Abstract: Many modern programming environments use tag bits at runtime to distinguish objects of different types. This is particularly common in systems with garbage collection, since the garbage collector must be able to distinguish pointers from non-pointers, and to learn the length of records pointed to. The use of tag bits leads to inefficiency. In addition to the obvious space overhead (tag bits and record descriptors occupy memory space), there is a time overhead: tag bits must be stripped off of data before arithmetic operations are performed, and re-attached to the data when it is stored into memory. This takes either extra instructions at runtime, or special tag-handling hardware, or both. This paper shows how the use of tag bits, record descriptor words, explicit type parameters, and the like can be avoided in languages (like ML) with static polymorphic typechecking. Though a form of tag will still be required for user-defined variant records, all other type information can be encoded once|in the program| rather than replicated many times in the data. This can lead to savings both in space and time. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel. </author> <title> Garbage collection can be faster than stack allocation. </title> <journal> Information Processing Letters, </journal> <volume> 25(4) </volume> <pages> 275-279, </pages> <year> 1987. </year>
Reference-contexts: Let g be the amortized cost of garbage collection: that is the total cost of garbage collection divided by the number of cells allocated. Then g is g = cost of copying cells freed = M which approaches zero 3 as M increases <ref> [1] </ref>.
Reference: [2] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time Concurrent Collection on Stock Multiprocessors. </title> <type> Technical Report CSL-TR-133-88, </type> <institution> Princeton University, </institution> <year> 1988. </year>
Reference-contexts: Thus, a depth-first copying collector can be implemented. 6 Breadth-first copying Most copying garbage collectors use breadth-first traversal, mostly because it is simpler to implement. Some specialized algorithms <ref> [2] </ref> require a "random-access" (but mostly breadth-first) traversal. Tagless collection is easier to do depth-first, but it is possible to do a breadth-first traversal.
Reference: [3] <author> Andrew W. Appel and David B. MacQueen. </author> <title> A Standard ML compiler. </title> <editor> In Gilles Kahn, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture (LNCS 274), </booktitle> <pages> pages 301-324, </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: We will make some arbitrary guesses about the cost of various operations, and calculate the resulting impact on time and space of an executing program. We will use the Standard ML of New Jersey compiler <ref> [3] </ref> for comparison. The code generated by this compiler uses a low-order tag bit on each (4-byte) word to distinguish pointers from integers, and uses a one-word descriptor on each record to communicate its type to the garbage collector.
Reference: [4] <author> Dianne E. Britton. </author> <title> Heap Storage Management for the Programming Language Pascal. </title> <type> Master's thesis, </type> <institution> University of Arizona, </institution> <year> 1975. </year>
Reference-contexts: Instead, a digested version of the user's type definitions, along with a static summary of the type of each variable and procedure parameter, can be provided to the garbage collector <ref> [4] </ref>. Because this information is derived from the program and is independent of the data that the program manipulates, it is of a fixed (small) size and requires no runtime overhead for its manipulation. When the garbage collector is invoked, it searches the stack for references into the heap. <p> tag field that in some (unchecked) implementations can be omitted from the run-time representation of the record; but for this garbage collection algorithm the compiler must insert and initialize the field even though the user can't access it. 3 Garbage collection cost vs. execution cost The previous section (and reference <ref> [4] </ref>) describe a runtime system for Pascal that has no tags except for variant records and represents integers in their natural (tagless) representation; call this system A.
Reference: [5] <author> Henry Lieberman and Carl Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Communications of the ACM, </journal> <volume> 23(6) </volume> <pages> 419-429, </pages> <year> 1983. </year>
Reference: [6] <author> Robin Milner. </author> <title> A proposal for Standard ML. </title> <booktitle> In ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 184-197, </pages> <year> 1984. </year> <month> 9 </month>
Reference-contexts: In contrast, the language LISP has just one set of list primitives which are applicable to lists of any type. This simplifies and clarifies programs, and permits a more abstract programming style. Languages like ML <ref> [6] </ref> have a static type system that allows functions (like cons) to be polymorphic [7]. That is, the language is type-checked at compile time, but the cons function can be used to build lists of any type of object.
Reference: [7] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: In contrast, the language LISP has just one set of list primitives which are applicable to lists of any type. This simplifies and clarifies programs, and permits a more abstract programming style. Languages like ML [6] have a static type system that allows functions (like cons) to be polymorphic <ref> [7] </ref>. That is, the language is type-checked at compile time, but the cons function can be used to build lists of any type of object. For example, the simplest polymorphic function is the identity function, (x:x), which has the type 8ff:(ff ! ff).
Reference: [8] <author> Paul Rovner, Roy Levin, and John Wick. </author> <title> On Extending Modula-2 For Building Large, Integrated Systems. </title> <type> Technical Report Research Report 3, </type> <institution> DEC Systems Research Center, </institution> <address> Palo Alto, CA, </address> <year> 1985. </year>
Reference-contexts: Ungar [10] has a good survey of tagging schemes. 2 Statically-typed languages Many programming languages have static (compile-time) type checking. In such languages, tags are not necessary for normal execution of the program. However, in some implementations of statically-typed languages with garbage collection <ref> [8] </ref> a descriptor is attached to the beginning of each record for use by the garbage collector.
Reference: [9] <author> David Ungar. </author> <title> Generation scavenging: a non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In SIGPLAN Notices (Proc. ACM SIG-SOFT/SIGPLAN Software Eng. Symp. on Practical Software Development Environments), </booktitle> <pages> pages 157-167, </pages> <year> 1984. </year>
Reference: [10] <author> David M. Ungar. </author> <title> The Design and Evaluation of a High Performance Smalltalk System. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year> <month> 10 </month>
Reference-contexts: Tag-bits can be handled by special hardware; but special hardware is more expensive and tends to be available in slower realizations than general-purpose machines with larger markets. Ungar <ref> [10] </ref> has a good survey of tagging schemes. 2 Statically-typed languages Many programming languages have static (compile-time) type checking. In such languages, tags are not necessary for normal execution of the program. <p> Thus, there was a 1.65% total overhead for tag handling on integers. On programs that are not so heavily symbolic as a compiler, we might expect a higher proportion of arithmetic instructions. Ungar <ref> [10] </ref> measured the dynamic frequency of tagged arithmetic instructions in Smalltalk and found them to be approximately 12% of all instructions. This included the comparison instructions and the "load class" instruction, however, and the SOAR machine Ungar was compiling for did not have a multiply instruction.
References-found: 10

