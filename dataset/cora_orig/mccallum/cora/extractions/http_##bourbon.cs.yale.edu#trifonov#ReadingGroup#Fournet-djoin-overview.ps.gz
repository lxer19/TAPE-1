URL: http://bourbon.cs.yale.edu/trifonov/ReadingGroup/Fournet-djoin-overview.ps.gz
Refering-URL: http://bourbon.cs.yale.edu/trifonov/ReadingGroup/
Root-URL: http://www.cs.yale.edu
Email: e-mail Cedric.Fournet@inria.fr  
Title: A Calculus of Mobile Agents  
Author: Cedric Fournet, Georges Gonthier, Jean-Jacques Levy, Luc Maranget, Didier Remy 
Address: 78153 Le Chesnay Cedex, FRANCE  
Affiliation: INRIA Rocquencourt  
Abstract: We introduce a calculus for mobile agents and give its chemical semantics, with a precise definition for migration, failure, and failure detection. Various examples written in our calculus illustrate how to express remote executions, dynamic loading of remote resources and protocols with mobile agents. We give the encoding of our distributed calculus into the join-calculus.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. Amadio and S. Prasad. </author> <title> Localities and failures. </title> <booktitle> In 14th Foundations of Software Technology and Theoretical Computer Science Conference. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> LNCS 880. </note>
Reference-contexts: Mobility in the -calculus refers to the communication of channel names on channels [11], whereas locality has been used as a tool to capture spatial dependencies among processes in non-interleaving semantics [4, 14]. The formal model developed for core FACILE <ref> [1] </ref> is more closely related to our work. In the l -calculus, the authors extend the syntax of the -calculus with locations. Channels are statically located; a location can fail, preventing further communication on its channels; location status can be tested in the language. <p> This condition automatically holds for simple processes considered as distributed processes, meaning that simple and distributed observation coincide. This is in sharp contrast with the -calculus with locality <ref> [1] </ref>, where the distributed congruence is strictly finer than the local one, even for local processes. 7 Future work In this paper, we laid the groundwork for a calculus of distributed processes with mobility and failure, and we investigated the use of process-calculus techniques for proving distributed protocols.
Reference: 2. <author> G. Berry and G. Boudol. </author> <title> The chemical abstract machine. </title> <journal> Theoretical Computer Science, </journal> <volume> 96 </volume> <pages> 217-248, </pages> <year> 1992. </year>
Reference-contexts: Chemical rules: We present our operational semantics in the chemical abstract machine style of Berry and Boudol <ref> [2] </ref>. The CHAM provides a precise and convenient way to specify reduction modulo equivalence. It also conveys some intuition about implementation schemes and implementation costs, especially in distinguishing between local and global operations.
Reference: 3. <author> K. A. Bharat and L. Cardelli. </author> <title> Migratory applications. </title> <type> Technical Report 138, </type> <institution> DEC-SRC, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: For instance, Obliq [5] encodes migration as a combination of remote cloning and aliasing, in a language with a global distributed scope. Examples of applications with large-grain mobility in Obliq can be found in <ref> [3] </ref>. However, little support is provided for failure recovery. In a functional setting, FACILE [7] provides process mobility from site to site, as the communication of higher-order values. As in this paper, the design choices are discussed in a chemical framework [10].
Reference: 4. <author> G. Boudol, I. Castellani, M. Hennessy, and A. Kiehn. </author> <title> A theory of processes with localities. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6 </volume> <pages> 165-200, </pages> <year> 1994. </year>
Reference-contexts: Mobility and locality already have other meanings in process calculi. Mobility in the -calculus refers to the communication of channel names on channels [11], whereas locality has been used as a tool to capture spatial dependencies among processes in non-interleaving semantics <ref> [4, 14] </ref>. The formal model developed for core FACILE [1] is more closely related to our work. In the l -calculus, the authors extend the syntax of the -calculus with locations.
Reference: 5. <author> L. Cardelli. </author> <title> A language with distributed scope. </title> <journal> Computing Systems, </journal> <volume> 8(1) </volume> <pages> 27-59, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: At the language level, numerous calling conventions such as call-by-move reflect these capabilities, and the use of migration for safety purposes is advocated. More recently, several languages have been proposed for large-scale dis-tributed programming, with some support for the mobile agent paradigm. For instance, Obliq <ref> [5] </ref> encodes migration as a combination of remote cloning and aliasing, in a language with a global distributed scope. Examples of applications with large-grain mobility in Obliq can be found in [3]. However, little support is provided for failure recovery.
Reference: 6. <author> C. Fournet and G. Gonthier. </author> <title> The reflexive chemical abstract machine and the join-calculus. </title> <booktitle> In 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Suppose, for instance, that we want to implement a concurrent calculus with CCS-like communication channels and with processes running on different physical sites. If we do not locate channels, we quickly face a global consensus problem for nearly every communication which uses the interconnection network. In a previous work <ref> [6] </ref>, we introduced the join-calculus, an asynchronous variant of Milner's -calculus with better locality and better static scoping rules. It avoids global consensus and thus may be implemented in a realistic distributed environment. Furthermore, it is shown to have the same expressive power as the -calculus. <p> Reduction rules ! consume some specific terms in the soup, replacing them by some other terms; they correspond to the basic computation steps. 3.2 The join-calculus and the reflexive chemical machine (RCHAM) Our starting point is the join-calculus as described in <ref> [6] </ref>. The join-calculus is as expressive as the asynchronous -calculus. Furthermore, our calculus is closer to a programming language than the -calculus. In particular, it can be seen as a concurrent extension of functional programming. <p> P in xh e V ; i 3.3 Observation We choose the observational equivalence framework as a formal basis for reasoning about processes <ref> [8, 6] </ref>. <p> We refer to <ref> [6] </ref> for discussion, examples and proof methods. The above definition of observational congruence is parametric in the reduction relation and in the context syntax. <p> In combination with the encoding of the join-calculus into the -calculus <ref> [6] </ref>, this provides an alternative definition of migration and failure in the usual setting of process calculi. This also suggests that our distributed extension does not unduly add semantic complexity. <p> In particular, this prevents contexts from accessing our internal representation or otherwise meddling with our protocol. We believe that this limitation can be enforced using "firewall" techniques as in <ref> [6] </ref>.
Reference: 7. <author> A. Giacalone, P. Mishra, and S. Prasad. </author> <title> FACILE: A symmetric integration of concurrent and functional programming. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 18(2) </volume> <pages> 121-160, </pages> <year> 1989. </year>
Reference-contexts: For instance, Obliq [5] encodes migration as a combination of remote cloning and aliasing, in a language with a global distributed scope. Examples of applications with large-grain mobility in Obliq can be found in [3]. However, little support is provided for failure recovery. In a functional setting, FACILE <ref> [7] </ref> provides process mobility from site to site, as the communication of higher-order values. As in this paper, the design choices are discussed in a chemical framework [10]. Mobility and locality already have other meanings in process calculi.
Reference: 8. <author> K. Honda and N. Yoshida. </author> <title> On reduction-based process semantics. </title> <journal> Theoretical Computer Science, </journal> <volume> 151 </volume> <pages> 437-486, </pages> <year> 1995. </year>
Reference-contexts: P in xh e V ; i 3.3 Observation We choose the observational equivalence framework as a formal basis for reasoning about processes <ref> [8, 6] </ref>.
Reference: 9. <author> E. </author> <month> Jul. </month> <title> Object Mobility in a Distributed Object-Oriented System. </title> <type> PhD thesis, </type> <institution> University of Washington, Computer Science Department, </institution> <month> Dec. </month> <year> 1988. </year>
Reference-contexts: Finally, we give directions for future work. 2 Related work Migration has been investigated mostly for object-oriented languages. Initially used in distributed systems to achieve a better load-balancing, migration evolves to a language feature in Emerald <ref> [9] </ref> : objects can be moved from one machine to another; they can also be attached to one another, an object carrying its attached objects as it moves.
Reference: 10. <author> L. Leth and B. Thomsen. </author> <title> Some facile chemistry. </title> <type> Technical Report ECRC-92-14, </type> <institution> European Computer-Industry Research Centre, Munich, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: However, little support is provided for failure recovery. In a functional setting, FACILE [7] provides process mobility from site to site, as the communication of higher-order values. As in this paper, the design choices are discussed in a chemical framework <ref> [10] </ref>. Mobility and locality already have other meanings in process calculi. Mobility in the -calculus refers to the communication of channel names on channels [11], whereas locality has been used as a tool to capture spatial dependencies among processes in non-interleaving semantics [4, 14].
Reference: 11. <author> R. Milner. </author> <title> The polyadic -calculus: a tutorial. In Logic and Algebra of Specification. </title> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: As in this paper, the design choices are discussed in a chemical framework [10]. Mobility and locality already have other meanings in process calculi. Mobility in the -calculus refers to the communication of channel names on channels <ref> [11] </ref>, whereas locality has been used as a tool to capture spatial dependencies among processes in non-interleaving semantics [4, 14]. The formal model developed for core FACILE [1] is more closely related to our work. In the l -calculus, the authors extend the syntax of the -calculus with locations. <p> We assume that names are used consistently in processes, respecting their arities. This could be made precise by using a recursive sort discipline as in the polyadic -calculus <ref> [11, 12] </ref>. We assume that all processes are well-sorted.
Reference: 12. <author> B. C. Pierce and D. Sangiorgi. </author> <title> Typing and subtyping for mobile processes. </title> <note> Mathematical Structures in Computer Science, 1995. To appear. A summary was presented at LICS '93. </note>
Reference-contexts: We assume that names are used consistently in processes, respecting their arities. This could be made precise by using a recursive sort discipline as in the polyadic -calculus <ref> [11, 12] </ref>. We assume that all processes are well-sorted.
Reference: 13. <author> B. C. Pierce and D. N. Turner. </author> <title> Concurrent objects in a process calculus. </title> <booktitle> In Theory and Practice of Parallel Programming, Sendai, </booktitle> <address> Japan, </address> <month> Apr. </month> <year> 1995. </year> <note> LNCS 907. </note>
Reference-contexts: a return channel together with every job. def printhx; i . : : : hi : : : in def hi . printh4; 0 i in printh3; i In practice, sequential control is so common that it deserves some syntactic sugar to make continuations implicit, as in the language PICT <ref> [13] </ref>. We write: def print (x) . : : : reply to print : : : in print (3); print (4) Synchronous names are written "x" and "print" instead of "x" and "print" to remind that they also carry an implicit continuation channel x .
Reference: 14. <author> D. Sangiorgi. </author> <title> Localities and non-interleaving semantics in calculi for mobile processes. </title> <type> Technical Report ECS-LFCS-94-282, </type> <institution> University of Edinburgh, </institution> <note> 94. to appear in TCS. </note>
Reference-contexts: Mobility and locality already have other meanings in process calculi. Mobility in the -calculus refers to the communication of channel names on channels [11], whereas locality has been used as a tool to capture spatial dependencies among processes in non-interleaving semantics <ref> [4, 14] </ref>. The formal model developed for core FACILE [1] is more closely related to our work. In the l -calculus, the authors extend the syntax of the -calculus with locations.
References-found: 14

