URL: ftp://ftp.cs.washington.edu/tr/1993/01/UW-CSE-93-01-02a.PS.Z
Refering-URL: http://www.cs.washington.edu/research/constraints/hclp/jlp-93.html
Root-URL: 
Email: internet: molly@cs.washington.edu borning@cs.washington.edu  
Title: Hierarchical Constraint Logic Programming Logic Programming (CLP) is a general scheme for extending logic programming
Author: Molly Wilson and Alan Borning 
Address: Seattle, Washington 98195  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington  
Note: Constraint  HCLP scheme, give example programs, and discuss related work. Authors' addresses:  
Abstract: Technical Report 93-01-02a Department of Computer Science and Engineering University of Washington May 1993 Abstract constraints. It is parameterized by D, the domain of the constraints. However, CLP(D) languages, as well as most other constraint systems, only allow the programmer to specify constraints that must hold. In many applications, such as interactive graphics, planning, document formatting, and decision support, one needs to express preferences as well as strict requirements. If we wish to make full use of the constraint paradigm, we need ways to represent these defaults and preferences declaratively, as constraints, rather than encoding them in the procedural parts of the language. We describe a scheme for extending CLP(D) to include both required and preferential constraints. An arbitrary number of strengths of preference are allowed. We present a theory of such constraint hierarchies, and an extension, Hierarchical Constraint Logic Programming, of the CLP scheme to include constraint hierarchies. We give an operational, model theoretic and fixed-point semantics for the HCLP scheme. Finally, we describe two interpreters we have written for instances of the This is a preprint of a paper that will appear in the Journal of Logic Programming, special issue on constraint logic programming. It is a slightly revised version of Technical Report 93-01-02, January 1993. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Krzysztof R. Apt, Howard R. Blair, and Adrian Walker. </author> <title> Towards a Theory of Declarative Knowledge. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming. </booktitle> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1988. </year>
Reference-contexts: E ([(X &lt; 10)]) is [0]. (There is only one constraint at the strong level.) E ([(X &lt; 10)]) is also [0]. e ((X = 4)) is 0. e ((X = 4)) is 1. E ([(X = 4)]) is [0]. E ([(X = 4)]) is <ref> [1] </ref>. <p> error sequence G (E ([(X &lt; 10)]); E ([(X = 4)])) evaluates to [[0]; [0]]. (Again, there is only one constraint at each level in the hierarchy, so the combining function has no effect.) The combined error sequence G (E ([(X &lt; 10)]); E ([(X = 4)])) evaluates to [[0]; <ref> [1] </ref>]. Since [[0]; [0]]&lt; g [[0]; [1]], is not in S. Moreover, there is no valuation in S 0 that is less than [[0]; [0]] in the lexicographic order defined by any &lt; g where &lt; g and &lt;&gt; g have the properties defined above. <p> 10)]); E ([(X = 4)])) evaluates to [[0]; [0]]. (Again, there is only one constraint at each level in the hierarchy, so the combining function has no effect.) The combined error sequence G (E ([(X &lt; 10)]); E ([(X = 4)])) evaluates to [[0]; <ref> [1] </ref>]. Since [[0]; [0]]&lt; g [[0]; [1]], is not in S. Moreover, there is no valuation in S 0 that is less than [[0]; [0]] in the lexicographic order defined by any &lt; g where &lt; g and &lt;&gt; g have the properties defined above. <p> There has been other work, specifically in the area of logic programming with negation, that deals with the notion of a canonical model for a particular logic program. There have been various methods used for defining what a canonical model should be (see <ref> [1, 27, 53] </ref>), but the intention is always that the canonical model represent exactly those queries that have "yes" answers in the program.
Reference: [2] <author> Paul Barth. </author> <title> An Object-Oriented Approach to Graphical Interfaces. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5(2) </volume> <pages> 142-172, </pages> <month> April </month> <year> 1986. </year> <month> 31 </month>
Reference-contexts: There has also been much applications-oriented work on using constraints, for domains such as geometric layout [3, 29, 49, 74, 78], user interface toolkits <ref> [2, 46, 47, 48, 75] </ref>, electrical circuit analysis [70, 73], and even jazz composition [40]. Regarding constraint hierarchies, our original description of constraint hierarchies is in reference [4].
Reference: [3] <author> Alan Borning. </author> <title> The Programming Language Aspects of ThingLab, A Constraint-Oriented Simu--lation Laboratory. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(4) </volume> <pages> 353-387, </pages> <month> October </month> <year> 1981. </year>
Reference-contexts: Such constraints are sometimes called soft constraints; the required ones are hard constraints. A set consisting of both hard and soft constraints is a constraint hierarchy. Our own work on constraint hierarchies has been application-oriented and driven primarily by pragmatic concerns. ThingLab <ref> [3] </ref>, for example, was a constraint-based laboratory that allowed a user to construct simulations of such things as electrical circuits, mechanical linkages, demonstrations of geometric theorems, and graphical calculators using interactive direct-manipulation techniques. <p> Weighted-sum-predicate-better, weighted-sum-metric-better, and so forth, are all defined analogously. 2.5 A Simple Example of the Differences Among the Comparators As a simple example to illustrate some of the differences among the comparators, consider a constraint-based spreadsheet, or a graphical calculator such as was described in <ref> [3] </ref>. Suppose there is a "sum" constraint relating real-valued variables A, B, and C. Previously, the values for these variables were A = 2, B = 3, and C = 5. The user has just edited C to be 7. <p> This is the same behavior as was exhibited by the original ThingLab <ref> [3] </ref>, but now produced as a consequence of declaratively represented hard and soft constraints. In a similar manner, we can (without any hard thinking required) translate all of the ThingLab examples into HCLP (R). For the more complex examples, the HCLP code becomes tediously long. <p> In addition, all variables have very weak equality constraints between their successive states, so that in the absence of stronger constraints, a variable will retain its value over time. There has also been much applications-oriented work on using constraints, for domains such as geometric layout <ref> [3, 29, 49, 74, 78] </ref>, user interface toolkits [2, 46, 47, 48, 75], electrical circuit analysis [70, 73], and even jazz composition [40]. Regarding constraint hierarchies, our original description of constraint hierarchies is in reference [4].
Reference: [4] <author> Alan Borning, Robert Duisberg, Bjorn Freeman-Benson, Axel Kramer, and Michael Woolf. </author> <title> Constraint Hierarchies. </title> <booktitle> In Proceedings of the 1987 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 48-60. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1987. </year>
Reference-contexts: Regarding constraint hierarchies, our original description of constraint hierarchies is in reference <ref> [4] </ref>. DeltaBlue, an efficient, incremental algorithm for finding a locally-predicate-better solution to a constraint hierarchy using local propagation is described in [20] and further analyzed in [43], [25], and [57]. Constraint hierarchies as described in reference [4] have subsequently been used in a number of systems, including ThingLab II [43, 44], <p> Regarding constraint hierarchies, our original description of constraint hierarchies is in reference <ref> [4] </ref>. DeltaBlue, an efficient, incremental algorithm for finding a locally-predicate-better solution to a constraint hierarchy using local propagation is described in [20] and further analyzed in [43], [25], and [57]. Constraint hierarchies as described in reference [4] have subsequently been used in a number of systems, including ThingLab II [43, 44], TRIP and TRIP II [37, 76], the Constraint Window System [16], and Multi-Garnet [56]. In addition to early conference publications [4, 7], constraint hierarchies are discussed in detail in [5]. <p> Constraint hierarchies as described in reference [4] have subsequently been used in a number of systems, including ThingLab II [43, 44], TRIP and TRIP II [37, 76], the Constraint Window System [16], and Multi-Garnet [56]. In addition to early conference publications <ref> [4, 7] </ref>, constraint hierarchies are discussed in detail in [5]. Most of the concepts in constraint hierarchies derive from concepts in subfields of operations research such as linear programming [45], multiobjective linear programming [45], goal programming [33], and generalized goal programming [32].
Reference: [5] <author> Alan Borning, Bjorn Freeman-Benson, and Molly Wilson. </author> <title> Constraint Hierarchies. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 5(3) </volume> <pages> 223-270, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: If an a priori lower bound B on the value of Var is known, then a call minimize (Var) could be replaced by a soft constraint medium Var = B. 2 However, if an a priori bound is not known, then this simulation would not work. Reference <ref> [5] </ref> describes how the constraint hierarchy theory can be extended to include objective functions. We could similarly extend an HCLP language to include objective functions explicitly, which would handle minimize directly (modulo the footnoted comment). <p> In addition to early conference publications [4, 7], constraint hierarchies are discussed in detail in <ref> [5] </ref>. Most of the concepts in constraint hierarchies derive from concepts in subfields of operations research such as linear programming [45], multiobjective linear programming [45], goal programming [33], and generalized goal programming [32]. <p> Similarly, the concepts of weighted-sum-better and worst-case-better solutions are both derived from analogous concepts in multiobjective linear programming problems and generalized goal programming. (See <ref> [5] </ref> for more discussion of the relation between constraint hierarchies and work in operations research. However, the essential feature of HCLP is that we embed constraints, both hard and soft, in a logic programming framework.) There is a substantial body of related research in the artificial intelligence community.
Reference: [6] <author> Alan Borning, Michael Maher, Amy Martindale, and Molly Wilson. </author> <title> Constraint Hierarchies and Logic Programming. </title> <type> Technical Report 88-11-10, </type> <institution> Computer Science Department, University of Washington, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: All answers to the current hierarchy are given before an attempt is made to resatisfy the goal. There is a unique computation tree associated with every answer, but the answers themselves are not always unique. (The pseudo-code for this algorithm can be found in <ref> [6] </ref>.) Here is a trivial example in HCLP (R; LPB) to illustrate the interpreter's behavior upon backtracking. banana (X) :- artichoke (X), weak X&gt;6. artichoke (X) :- strong X=1. artichoke (X) :- required X&gt;0, required X&lt;10, weak X&lt;4.
Reference: [7] <author> Alan Borning, Michael Maher, Amy Martindale, and Molly Wilson. </author> <title> Constraint Hierarchies and Logic Programming. </title> <booktitle> In Proceedings of the Sixth International Conference on Logic Programming, </booktitle> <pages> pages 149-164, </pages> <address> Lisbon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: The second is a more flexible but complex interpreter, written in Common Lisp, for HCLP (R; ?). In this version the comparator used can be selected by the programmer from a number of possibilities. Our original publication of the HCLP work is in reference <ref> [7] </ref>. <p> Constraint hierarchies as described in reference [4] have subsequently been used in a number of systems, including ThingLab II [43, 44], TRIP and TRIP II [37, 76], the Constraint Window System [16], and Multi-Garnet [56]. In addition to early conference publications <ref> [4, 7] </ref>, constraint hierarchies are discussed in detail in [5]. Most of the concepts in constraint hierarchies derive from concepts in subfields of operations research such as linear programming [45], multiobjective linear programming [45], goal programming [33], and generalized goal programming [32].
Reference: [8] <author> Gerhard Brewka. </author> <title> Preferred Subtheories: An Extended Logical Framework for Default Reasoning. </title> <booktitle> In Proceedings of the Eleventh International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 1043-1048, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Brewka <ref> [8] </ref> describes an approach to representing default information with multiple levels of preference. In this framework, there are many levels of theories, some of which are more preferred than others.
Reference: [9] <author> K. L. Clark. </author> <title> Negation as Failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Databases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: solution for a query Q and program P iff Qv is in the preferred model for P Proposition 4 v is a computed solution for a query Q and program P iff Qv 2 S best (T P " !) Let P fl denote the completion of the program P <ref> [9, 41] </ref>. The following proposition characterizes the "no" answers to queries in a completed HCLP program.
Reference: [10] <author> Jacques Cohen. </author> <title> Constraint Logic Programming Languages. </title> <journal> Communications of the ACM, </journal> <volume> 33(7) </volume> <pages> 52-68, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: The interpreter makes the appropriate calls to Garnet routines to perform the needed actions. (Garnet [47] is a user interface toolkit, written in Common Lisp and using X windows.) 10 Related Work As described in the introduction, HCLP builds on the CLP scheme <ref> [10, 34] </ref>.
Reference: [11] <author> Alain Colmerauer. </author> <title> An Introduction to Prolog III. </title> <journal> Communications of the ACM, </journal> <pages> pages 69-90, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: In place of unification (which can be viewed as testing the satisfiability of equations over the Herbrand universe), constraints are accumulated and tested for satisfiability over D, using techniques appropriate to the domain. Several such languages have now been implemented, including CLP (R) [35, 36], Prolog III <ref> [11] </ref>, CHIP [14, 77], CAL [61], CLP (*) [79], and Echidna [69]. The formal semantics of such languages differ primarily in the choice of underlying domain and constraints, as was shown formally in [34]. <p> Since HCLP is also a general scheme, it should be possible to implement HCLP languages for any of the domains, such as booleans, finite domains, or trees, supported by existing CLP languages (e.g., <ref> [11, 14, 35, 36, 61, 69, 77, 79] </ref>). 1 A number of CLP languages, for example CHIP [14, 77], include a minimize operator.
Reference: [12] <author> Alvaro del Val and Yoav Shoham. </author> <title> Deriving Properties of Belief Update from Theories of Action. </title> <booktitle> In Proceedings of the 10th Conference of the AAAI, </booktitle> <pages> pages 584-589, </pages> <year> 1992. </year>
Reference-contexts: These areas are all related in a broad sense in that they involve reasoning in the presence of change: either change through time, change in knowledge, or change in observation. (Reference <ref> [12] </ref> explores the relation between temporal reasoning and belief update and shows that the latter can be expressed in terms of the former.) In the case of default reasoning, new information may 29 involve eliminating false assumptions, just as adding new constraints to a constraint hierarchy may override weaker constraints.
Reference: [13] <author> Yannick Descotte and Jean-Claude Latombe. </author> <title> Making Compromises among Antagonist Constraints in a Planner. </title> <journal> Artificial Intelligence, </journal> <volume> 27(2) </volume> <pages> 183-217, </pages> <month> November </month> <year> 1985. </year>
Reference-contexts: Fox [17] discusses the problem of constraint-directed reasoning for job-shop scheduling, and allows the relaxation of constraints when conflicts occur, and context-sensitive selection and weighted interpretation of constraints. Descotte and Latombe <ref> [13] </ref> make compromises by selective backtracking among inconsistent constraints in a planner for manufacturing. Freuder [24] gives a general model for partial constraint satisfaction problems (PCSPs) for variables ranging over finite domains, extending the standard CSP model.
Reference: [14] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Bertheir. </author> <title> The Constraint Logic Programming Language CHIP. </title> <booktitle> In Proceedings Fifth Generation Computer Systems-88, </booktitle> <year> 1988. </year>
Reference-contexts: In place of unification (which can be viewed as testing the satisfiability of equations over the Herbrand universe), constraints are accumulated and tested for satisfiability over D, using techniques appropriate to the domain. Several such languages have now been implemented, including CLP (R) [35, 36], Prolog III [11], CHIP <ref> [14, 77] </ref>, CAL [61], CLP (*) [79], and Echidna [69]. The formal semantics of such languages differ primarily in the choice of underlying domain and constraints, as was shown formally in [34]. <p> Since HCLP is also a general scheme, it should be possible to implement HCLP languages for any of the domains, such as booleans, finite domains, or trees, supported by existing CLP languages (e.g., <ref> [11, 14, 35, 36, 61, 69, 77, 79] </ref>). 1 A number of CLP languages, for example CHIP [14, 77], include a minimize operator. <p> Since HCLP is also a general scheme, it should be possible to implement HCLP languages for any of the domains, such as booleans, finite domains, or trees, supported by existing CLP languages (e.g., [11, 14, 35, 36, 61, 69, 77, 79]). 1 A number of CLP languages, for example CHIP <ref> [14, 77] </ref>, include a minimize operator.
Reference: [15] <author> Raimund Ege, David Maier, and Alan Borning. </author> <title> The Filter Browser|Defining Interfaces Graphically. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming, </booktitle> <pages> pages 155-165, </pages> <address> Paris, </address> <month> June </month> <year> 1987. </year> <institution> Association Fran~caise pour la Cybernetique Economique et Technique. </institution>
Reference-contexts: However, since we have the full power of logic programming available, we can do considerably more. For example, filters are a powerful metaphor for the declarative construction of user interfaces. In the filter browser described in <ref> [15] </ref>, the screen view of some source object is constructed by passing the object through a series of filters to produce the final image. Each filter is represented as a collection of constraints (some of which may be required and some non-required) relating its input and output.
Reference: [16] <author> Danny Epstein and Wilf LaLonde. </author> <title> A Smalltalk Window System Based on Constraints. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 83-94, </pages> <address> San Diego, </address> <month> September </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: Constraint hierarchies as described in reference [4] have subsequently been used in a number of systems, including ThingLab II [43, 44], TRIP and TRIP II [37, 76], the Constraint Window System <ref> [16] </ref>, and Multi-Garnet [56]. In addition to early conference publications [4, 7], constraint hierarchies are discussed in detail in [5].
Reference: [17] <author> Mark S. Fox. </author> <title> Constraint-Directed Search: A Case Study of Job-Shop Scheduling. </title> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, California, </address> <year> 1987. </year>
Reference-contexts: However, the essential feature of HCLP is that we embed constraints, both hard and soft, in a logic programming framework.) There is a substantial body of related research in the artificial intelligence community. Fox <ref> [17] </ref> discusses the problem of constraint-directed reasoning for job-shop scheduling, and allows the relaxation of constraints when conflicts occur, and context-sensitive selection and weighted interpretation of constraints. Descotte and Latombe [13] make compromises by selective backtracking among inconsistent constraints in a planner for manufacturing.
Reference: [18] <author> Bjorn Freeman-Benson and Alan Borning. </author> <title> Integrating Constraints with an Object-Oriented Language. </title> <booktitle> In Proceedings of the 1992 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 268-286, </pages> <month> June </month> <year> 1992. </year> <month> 32 </month>
Reference-contexts: Steele's Ph.D. dissertation [71] is one of the first such efforts; an important characteristic of his system is the maintenance of dependency information to support dependency-directed backtracking and to aid in generating explanations. Leler [39] describes Bertrand, a constraint language based on augmented term rewriting. Kaleidoscope <ref> [18, 19, 23] </ref> combines constraints with object-oriented, imperative programming.
Reference: [19] <author> Bjorn Freeman-Benson and Alan Borning. </author> <booktitle> The Design and Implementation of Kaleidoscope'90, </booktitle>
Reference-contexts: Steele's Ph.D. dissertation [71] is one of the first such efforts; an important characteristic of his system is the maintenance of dependency information to support dependency-directed backtracking and to aid in generating explanations. Leler [39] describes Bertrand, a constraint language based on augmented term rewriting. Kaleidoscope <ref> [18, 19, 23] </ref> combines constraints with object-oriented, imperative programming.
References-found: 19

