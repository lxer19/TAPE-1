URL: http://www.cs.berkeley.edu/~dfb/papers/concert-iccl92.ps
Refering-URL: http://www.cs.berkeley.edu/~dfb/publist.html
Root-URL: 
Email: yemini@watson.ibm.com  
Phone: (914) 784-7627  
Title: High-Level Language Support for Programming Distributed Systems  
Author: J. S. Auerbach D. F. Bacon A. P. Goldberg G. S. Goldszmidt A. S. Gopal M. T. Kennedy A. R. Lowry J. R. Russell W. Silverman R. E. Strom D. M. Yellin S. A. Yemini 
Address: Box 704, Yorktown Heights, NY 10598  
Affiliation: IBM T. J. Watson Research Center  
Abstract: This paper presents a strategy to simplify the programming of heterogeneous distributed systems. Our approach is based on integrating a high-level distributed programming model, called the process model, directly into programming languages. Distributed applications written in such languages are portable across different environments, are shorter, and are simpler to develop than similar applications developed using conventional approaches. In this paper, we discuss the process model, and present overviews of Hermes and Concert/C, two languages that implement this model. Hermes is a secure, representation-independent language designed explicitly around the process model. Concert/C is the C language augmented with a small set of extensions to support the process model while allowing reuse of existing C code. Hermes has been prototyped; an implementation of Concert/C is in development. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. D. Birrell and B. J. Nelson, </author> <title> "Implementing remote procedure calls," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 2, </volume> <pages> pp. 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: of developing distributed applications: the use of the remote procedure call (RPC), and the use of new programming languages. 1.1.1 The Remote Procedure Call (RPC) Informally, an RPC facility enables a call in one address space to invoke a procedure within another ad dress space, possibly on a remote machine <ref> [1] </ref>. Most RPC packages are designed to hide some of the details of the underlying transport protocols and automatically handle much of the problem of converting data to and from transmittable form [2, 3, 4]. Unfortunately, even with today's RPC packages, developing distributed applications remains a task for an expert.
Reference: [2] <author> Sun Microsystems, </author> <title> SUN Network Programming, </title> <year> 1988. </year>
Reference-contexts: Most RPC packages are designed to hide some of the details of the underlying transport protocols and automatically handle much of the problem of converting data to and from transmittable form <ref> [2, 3, 4] </ref>. Unfortunately, even with today's RPC packages, developing distributed applications remains a task for an expert. This is because the programmer must master a large and complex programming interface, one that can be substantially different from the familiar one presented by the programming language.
Reference: [3] <author> M. Kong, T. H. Dineen, P. J. Leach, E. A. Martin, N. W. Mishkin, J. N. Pato, and G. L. Wyant, </author> <title> Network Computing System Reference Manual. </title> <address> En-glewood Cliffs, NJ: </address> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: Most RPC packages are designed to hide some of the details of the underlying transport protocols and automatically handle much of the problem of converting data to and from transmittable form <ref> [2, 3, 4] </ref>. Unfortunately, even with today's RPC packages, developing distributed applications remains a task for an expert. This is because the programmer must master a large and complex programming interface, one that can be substantially different from the familiar one presented by the programming language.
Reference: [4] <author> Open Software Foundation, </author> <title> OSF DCE Release 1.0 Developer's Kit Documentation Set, </title> <month> February </month> <year> 1991. </year>
Reference-contexts: Most RPC packages are designed to hide some of the details of the underlying transport protocols and automatically handle much of the problem of converting data to and from transmittable form <ref> [2, 3, 4] </ref>. Unfortunately, even with today's RPC packages, developing distributed applications remains a task for an expert. This is because the programmer must master a large and complex programming interface, one that can be substantially different from the familiar one presented by the programming language.
Reference: [5] <author> A. Black, N. Hutchinson, E. Jul, H. Levy, and L. Carter, </author> <title> "Distribution and abstract types in emerald," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 13, </volume> <pages> pp. 65-76, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Finally, conventional RPC services do not permit interoperability; that is, a server written assuming one particular RPC package cannot in general be invoked by a client written assuming another RPC package. 1.1.2 Distributed Programming Languages Programming languages that were designed to support distributed applications include object-oriented languages such as Emerald <ref> [5] </ref> and functional languages such as Concurrent ML [6] (see [7, 8] for discussions of such languages).
Reference: [6] <author> J. H. Reppy, </author> <title> "CML: A higher-order concurrent language," </title> <booktitle> in ACM SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 293-305, </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: that is, a server written assuming one particular RPC package cannot in general be invoked by a client written assuming another RPC package. 1.1.2 Distributed Programming Languages Programming languages that were designed to support distributed applications include object-oriented languages such as Emerald [5] and functional languages such as Concurrent ML <ref> [6] </ref> (see [7, 8] for discussions of such languages).
Reference: [7] <author> H. E. Bal, J. G. Steiner, and A. S. Tanenbaum, </author> <title> "Programming languages for distributed computing systems," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 21, </volume> <month> September </month> <year> 1991. </year>
Reference-contexts: a server written assuming one particular RPC package cannot in general be invoked by a client written assuming another RPC package. 1.1.2 Distributed Programming Languages Programming languages that were designed to support distributed applications include object-oriented languages such as Emerald [5] and functional languages such as Concurrent ML [6] (see <ref> [7, 8] </ref> for discussions of such languages).
Reference: [8] <author> G. A. Andrews, </author> <title> Concurrent Programming: </title> <booktitle> Principles and Practice. </booktitle> <publisher> Benjamin/Cummings Publishing Company, Inc., </publisher> <year> 1991. </year>
Reference-contexts: a server written assuming one particular RPC package cannot in general be invoked by a client written assuming another RPC package. 1.1.2 Distributed Programming Languages Programming languages that were designed to support distributed applications include object-oriented languages such as Emerald [5] and functional languages such as Concurrent ML [6] (see <ref> [7, 8] </ref> for discussions of such languages).
Reference: [9] <author> R. E. Strom and S. A. Yemini, </author> <title> "Optimistic recovery in distributed systems," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 3, </volume> <pages> pp. 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: also a spectrum of enforcement: (1) no enforcement | the system may "crash" if the rule is violated, (2) violations of a rule will be detected either at compile-time or run-time, (3) the implementation may guarantee proper behavior of the system even in the presence of machine failures (see in <ref> [9] </ref>). 2.2.2 Efficiency There are many implementation decisions affecting efficiency: e.g. data structure selection, assignment of processes to processors, sharing of many small processes within a single address space, etc. Additionally, implementations are free to perform arbitrarily aggressive transformations of programs, provided the semantics of the process model is preserved.
Reference: [10] <author> W. Korfhage and R. Yozzo, </author> <title> "Picking processes for migration," </title> <booktitle> in Proc. 4th ISMM/IASTED Intl. Conf. on Parallel and Distributed Computing Systems, </booktitle> <pages> pp. 193-195, </pages> <month> Oct </month> <year> 1991. </year>
Reference-contexts: Additionally, implementations are free to perform arbitrarily aggressive transformations of programs, provided the semantics of the process model is preserved. Examples include: migrating processes <ref> [10] </ref>, replicating processes [11], converting bi-directional calls to sends [12]. 3 Hermes Hermes [13] is a new experimental high-level language especially suited for distributed and multiappli-cation systems. It is a very high level language that fully incorporates the process model. In particular, 1.
Reference: [11] <author> A. P. Goldberg, </author> <title> Optimistic Algorithms for Distributed Transparent Process Replication. </title> <type> PhD thesis, </type> <institution> University of California at Los Angeles, </institution> <year> 1991. </year> <note> (UCLA Tech. Report CSD-910050). </note>
Reference-contexts: Additionally, implementations are free to perform arbitrarily aggressive transformations of programs, provided the semantics of the process model is preserved. Examples include: migrating processes [10], replicating processes <ref> [11] </ref>, converting bi-directional calls to sends [12]. 3 Hermes Hermes [13] is a new experimental high-level language especially suited for distributed and multiappli-cation systems. It is a very high level language that fully incorporates the process model. In particular, 1.
Reference: [12] <author> D. F. Bacon and R. E. Strom, </author> <title> "Optimistic parallelization of communicating sequential processes," </title> <booktitle> in Proceedings of the Third ACM SIG-PLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: Additionally, implementations are free to perform arbitrarily aggressive transformations of programs, provided the semantics of the process model is preserved. Examples include: migrating processes [10], replicating processes [11], converting bi-directional calls to sends <ref> [12] </ref>. 3 Hermes Hermes [13] is a new experimental high-level language especially suited for distributed and multiappli-cation systems. It is a very high level language that fully incorporates the process model. In particular, 1. The concepts of process, inport, outport, etc. are primitive concepts of Hermes. 2.
Reference: [13] <author> R. E. Strom, D. F. Bacon, A. Goldberg, A. Lowry, D. Yellin, and S. A. Yemini, </author> <title> Hermes: A Language for Distributed Computing. </title> <publisher> Prentice Hall, </publisher> <month> Jan-uary </month> <year> 1991. </year>
Reference-contexts: Additionally, implementations are free to perform arbitrarily aggressive transformations of programs, provided the semantics of the process model is preserved. Examples include: migrating processes [10], replicating processes [11], converting bi-directional calls to sends [12]. 3 Hermes Hermes <ref> [13] </ref> is a new experimental high-level language especially suited for distributed and multiappli-cation systems. It is a very high level language that fully incorporates the process model. In particular, 1. The concepts of process, inport, outport, etc. are primitive concepts of Hermes. 2. <p> It should port easily to most 32-bit systems. We distribute all source for the compiler and run-time. 2 We have published a tutorial and reference manual <ref> [13] </ref>. The Hermes run-time environment supports a single logical Hermes machine distributed over a network that can include any machine Hermes runs on. Her-mes compiles to a combination of C modules and a Hermes intermediate language. Hermes is a descendent of an earlier language, NIL.
Reference: [14] <author> R. E. Strom and S. A. Yemini, "Typestate: </author> <title> A programming language concept for enhancing software reliability," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-12, </volume> <pages> pp. 157-171, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: Programs are checked for conformity to the typestate rules using a dataflow algorithm <ref> [14] </ref>. All operations in a compiled Hermes process conform to the typestate rules|in particular, uninitialized data and memory belonging to another process cannot be accessed. As a result, any number of Hermes processes can safely share a single address space.
Reference: [15] <author> S. A. Yemini, G. Goldszmidt, A. Stoyenko, Y. Wei, and L. Beeck, </author> <title> "Concert: A high-level-language approach to heterogeneous distributed systems," </title> <booktitle> in The Ninth International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 162-171, </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: NIL was evaluated by using it to prototype two large SNA subsystems. This experience was encouraging both from the standpoint of software engineering and from the standpoint of performance. 5.2 Concert The existing Concert prototypes <ref> [15] </ref> demonstrate processes written in C running under AIX or OS/2 on PS/2 hardware calling each other and also VM/370 processes written in PL/I. Supported communications protocols include 3270 terminal emulation, APPC, NETBIOS, and TCP/IP. To bridge the heterogeneity of these environments, a communications package called TACT [16] is used.
Reference: [16] <author> J. Auerbach, "TACT: </author> <title> A protocol conversion toolkit," </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> vol. 8, </volume> <pages> pp. 143-159, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Supported communications protocols include 3270 terminal emulation, APPC, NETBIOS, and TCP/IP. To bridge the heterogeneity of these environments, a communications package called TACT <ref> [16] </ref> is used.
Reference: [17] <author> J. Auerbach, M. Kennedy, J. Russell, and S. Yem-ini, </author> <title> "Interprocess communication in concert/C," </title> <type> Tech. Rep. </type> <institution> RC17341, IBM T. J. Watson Research Center, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: We have temporarily deemphasized other potential Concert languages in favor of finalizing a complete and rigorous definition of the Concert/C language. A paper giving a complete description of this language is currently available <ref> [17] </ref>. 5.3 Conclusions The process model appears to be a simple yet expressive base for supporting distributed computing across diverse languages and system environments. Hermes and its predecessor NIL have shown that high level languages can significantly simplify programming complex systems and yet still have highly efficient implementations.
References-found: 17

