URL: http://www-inst.eecs.berkeley.edu/~cs264/f95/papers/cc96_remote_attribution.ps
Refering-URL: http://www-inst.eecs.berkeley.edu/~cs264/f95/readings/index.html
Root-URL: 
Title: Remote Attribution  
Author: John Tang Boyland 
Keyword: attribute grammars, semantic analysis  
Address: Berkeley, CA 94720-1776, USA  
Affiliation: University of California, Berkeley, Computer Science Division, Department of Electrical Engineering and Computer Science,  
Abstract: This paper introduces a method of handling direct remote attribute dependencies in attribute grammars. Once a connection between two nodes has been established, attribute values may flow in either direction. Contrary to classical attribute grammars, attribute uses and definitions may be distributed throughout the tree. Distributed definitions of a collection attribute are combined declaratively to yield a single definition. Remote attribution greatly increases the expressiveness of attribute grammars, allowing attribute grammars to express computations often assumed to be possible only using side-effects or imperative constructs. However, remote attribution remains firmly grounded in the original spirit of attribute grammars because it does not require user-visible side-effects. Moreover, a safe evaluation order can be determined automatically; it is not necessary for an attribute grammar writer to manually schedule dependencies to ensure that no attribute is used before it has been evaluated. These properties are shown through a reduction to classical attribute grammars. Attribute grammars using remote attribution can be implemented more efficiently than those restricted to classical attribute dependencies. Remote attribution thus provides a higher-level, more intuitive and yet still declarative notation that enables more efficient implementation. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> ALBLAS, H. </author> <title> Attribute evaluation methods. In Attribute Grammars, </title> <booktitle> Applications and Systems. International Summer School SAGA Proceedings, </booktitle> <address> Prague, Czechoslovakia, </address> <month> 4-13 June </month> <year> 1991 (1991), </year> <editor> H. Alblas and B. Melichar, Eds., </editor> <volume> vol. </volume> <booktitle> 545 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 48-113. </pages>
Reference-contexts: In the definition of classical attribute grammars, attribute values are specified as pure functions of attribute values of neighboring nodes. A variety of implementation techniques have been developed <ref> [1] </ref> and a number of usable attribute grammar implementation tools exist [4, 12, 14]. Aside from a few cases (for instance an Ada type checker [18] and a VHDL compiler [7]), however, attribute grammars have not been particularly successful either in formal language specification or in practical compiler generation.
Reference: 2. <author> BOYLAND, J. </author> <title> Conditional attribute grammars. </title> <note> Submitted to ACM TOPLAS, </note> <year> 1995. </year>
Reference-contexts: Nontermination (sometimes signified by a bottom value) is unacceptable, because an undeclared identifier in the program should not cause the compiler to crash. Instead, a default node reference is needed. In the absence of conditional attribution <ref> [2] </ref>, the default must permit attributes to be read and written. In Fig. 2, NOT_FOUND is used as a default. Remote Definitions are Unordered. The examples in Figs. 1 and 2 are not completely comparable.
Reference: 3. <author> BOYLAND, J., AND GRAHAM, S. L. </author> <title> Composing tree attributions. </title> <booktitle> In Conference Record of the Twenty-first Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1994), </year> <pages> pp. 375-388. </pages>
Reference-contexts: In a higher-order attribute grammar, rules may construct new subtrees and graft them into the tree being attributed. At no point, however, may attributed nodes be transmitted through the attribute system. Composable attribute grammars [6] and their extension, composable tree attributions <ref> [3] </ref> have a feature roughly equivalent to remote attribute use. In these systems it is possible to construct new nodes and pass them through the attribute system, possibly fetching attribute values.
Reference: 4. <author> FARROW, R. </author> <title> The Linguist translator-writing system. </title> <type> Tech. rep., </type> <institution> Declarative Systems Inc., </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: In the definition of classical attribute grammars, attribute values are specified as pure functions of attribute values of neighboring nodes. A variety of implementation techniques have been developed [1] and a number of usable attribute grammar implementation tools exist <ref> [4, 12, 14] </ref>. Aside from a few cases (for instance an Ada type checker [18] and a VHDL compiler [7]), however, attribute grammars have not been particularly successful either in formal language specification or in practical compiler generation.
Reference: 5. <author> FARROW, R. </author> <title> Fibered evaluation in Linguist. </title> <type> unpublished, </type> <year> 1990. </year>
Reference-contexts: This remote use appears because the analysis in the first stage was unable to determine where the node in n2 came from. 3 The term fiber is borrowed from Farrow who defines a feature with dependencies similar to remote attribute use <ref> [5] </ref>. 9 B ! local n1, n2, v, NEW: n1$sn, n2$a, n1$cC n1 = B.in NEW: B.in$cC = n1$cC NEW: n2$a = n1$sn.a remote use NEW: v = n2$a The fiber attribute B.in$cC has the opposite direction of the source attribute B.in; while the latter is inherited, the former is synthesized <p> Modifying the analysis to handle approximations is straightforward. The resulting analysis is coarser and the reduction may yield a circular attribute grammar. Farrow investigated approximation for remote attribute use only and proved that no finite approximation will work for all noncircular attribute grammars <ref> [5] </ref>. A simple approximation that collapses attribute access cycles yields a non-circular classical attribute grammar when applied to the attribute grammar in Fig. 2 (in fact the result is OAG). <p> The published references of these two systems require descriptional composition for implementation. The analysis given in Sect. 3 was based on analysis given by Farrow for handling just such situations <ref> [5] </ref>. Something similar to collection attributes may be defined, but direct remote attribute definition is not permitted in these systems. 14 Acknowledgements This paper is an outgrowth of a discussion between William Maddox and myself.
Reference: 6. <author> FARROW, R., MARLOWE, T. J., AND YELLIN, D. M. </author> <title> Composable attribute grammars: Support for modularity in translator design and implementation. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1992), </year> <pages> pp. 223-234. </pages>
Reference-contexts: In a higher-order attribute grammar, rules may construct new subtrees and graft them into the tree being attributed. At no point, however, may attributed nodes be transmitted through the attribute system. Composable attribute grammars <ref> [6] </ref> and their extension, composable tree attributions [3] have a feature roughly equivalent to remote attribute use. In these systems it is possible to construct new nodes and pass them through the attribute system, possibly fetching attribute values.
Reference: 7. <author> FARROW, R., AND STANCULESCU, A. G. </author> <title> A VHDL compiler based on attribute grammar methodology. </title> <booktitle> In Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation (June 1989), </booktitle> <pages> pp. 120-130. </pages>
Reference-contexts: A variety of implementation techniques have been developed [1] and a number of usable attribute grammar implementation tools exist [4, 12, 14]. Aside from a few cases (for instance an Ada type checker [18] and a VHDL compiler <ref> [7] </ref>), however, attribute grammars have not been particularly successful either in formal language specification or in practical compiler generation. In fact, many people have the impression that attribute grammars are clumsy, often requiring longer and more complicated specifications than an imperative language would require to express the same task.
Reference: 8. <author> GRAY, R. W., HEURING, V. P., LEVI, S. P., SLOANE, A. M., AND WAITE, W. M. Eli: </author> <title> A complete flexible compiler construction system. </title> <journal> Communications of the ACM 35, </journal> <month> 2 (Feb. </month> <year> 1992), </year> <pages> 121-131. </pages>
Reference-contexts: A simple attribute grammar using remote attribution, the results of fiber analysis and the reduction to a classical attribute grammar 13 4 Related Work LIGA [14], part of the Eli compiler construction system <ref> [8] </ref>, has a notation that can reduce the number of copy rules. The INCLUDING construct allows a rule to refer to the closest ancestor node that has a certain attribute defined; the corresponding CONSTITUENTS construct allows a rule to refer to attributes of descendants.
Reference: 9. <author> HEDIN, G. </author> <title> An overview of door attribute grammars. </title> <booktitle> In Proceedings of Compiler Construction, 5th International Conference, </booktitle> <month> CC'94 (Apr. </month> <year> 1994), </year> <editor> P. A. Fritzson, Ed., </editor> <volume> vol. </volume> <booktitle> 786 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 31-51. </pages>
Reference-contexts: It appears that these annotations are not powerful enough to describe the results of fiber analysis using approximations such as the one defined by Farrow. Neither do non-local attribute grammars give the power of remote attribute definition. Gorel Hedin defines an extension called door attribute grammars <ref> [9] </ref>. Like Johnson and Fischer, she is interested in making incremental re-evaluation of attribute grammars more efficient. In the extension, remote attribute use is restricted to special tree annotations called door objects.
Reference: 10. <author> JOHNSON, G. F., AND FISCHER, C. N. </author> <title> A meta-language and system for nonlocal incremental attribute evaluation in language-based editors. </title> <booktitle> In Conference Record of the Twelfth ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1985), </year> <pages> pp. 141-151. </pages>
Reference-contexts: However, the dependencies are different. The list of declarations no longer depends on each declaration's shape. A general incremental evaluation strategy that could track remote dependencies would not have to look up every identifier again just because the type of one declaration changed <ref> [10] </ref>. Having the declaration node available at the use site makes it easier to transmit further information. In this case, determining whether a declaration is used is extremely easy to specify. Each declaration has a synthesized collection attribute used. <p> For example, an identifier may be looked up in a symbol table before all the declarations have been inserted. Johnson and Fischer define a construct called a non-local attribute grammar including a feature analogous to remote attribute use <ref> [10] </ref>. They also describe an algorithm for producing a classical (local) attribute grammar from a non-local one using user-written annotations. It appears that these annotations are not powerful enough to describe the results of fiber analysis using approximations such as the one defined by Farrow.
Reference: 11. <author> JOURDAN, M., BELLEC, C. L., AND PARIGOT, D. </author> <title> The OLGA attribute grammar description language: Design, implementation and evaluation. In Attribute Grammars and their Applications. </title> <booktitle> International Conference WAGA Proceedings, </booktitle> <address> Paris, France, 19-21 Sept. </address> <year> 1990 (1990), </year> <editor> P. Deransart and M. Jourdan, Eds., </editor> <volume> vol. </volume> <booktitle> 461 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 222-237. </pages>
Reference-contexts: Such tasks can be accomplished using global collection attributes that are simply collection attributes of the root. A sugared notation makes these attributes easier to use. Global attributes can replace some of the imperative constructs used in attribute grammar implementations (for instance, generating error messages in Olga <ref> [11] </ref>). Using collection attributes greatly reduces the amount of busy-work in attribute grammars. The attribute grammar in Fig. 2 accomplishes the same task as that in Fig. 1 at a higher level.
Reference: 12. <author> JOURDAN, M., AND PARIGOT, D. </author> <title> Internals and externals of the FNC-2 attribute grammar system. In Attribute Grammars, </title> <booktitle> Applications and Systems. International Summer School SAGA Proceedings, </booktitle> <address> Prague, Czechoslovakia, </address> <month> 4-13 June </month> <year> 1991 (1991), </year> <editor> H. Alblas and B. Melichar, Eds., </editor> <volume> vol. </volume> <booktitle> 545 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 485-504. </pages>
Reference-contexts: In the definition of classical attribute grammars, attribute values are specified as pure functions of attribute values of neighboring nodes. A variety of implementation techniques have been developed [1] and a number of usable attribute grammar implementation tools exist <ref> [4, 12, 14] </ref>. Aside from a few cases (for instance an Ada type checker [18] and a VHDL compiler [7]), however, attribute grammars have not been particularly successful either in formal language specification or in practical compiler generation.
Reference: 13. <author> KASTENS, U. </author> <title> Ordered attributed grammars. </title> <journal> Acta Informatica 13, </journal> <month> 3 (Mar. </month> <year> 1980), </year> <pages> 229-256. 15 </pages>
Reference-contexts: A hand-written classical attribute grammar performing a task most naturally expressed using collection attributes will have a much less efficient implementation. 4 The remote-aware implementation of remote attribution must be able to handle non-normal-form attribute definitions. Kasten's OAG algorithm <ref> [13] </ref> would work correctly on the attribute grammar after normalization because it schedules each attribute as soon as possible, but not all schedulers have this property. 11 Notation: A (X) (C (X)) : (collection) attributes of X. U (X j ) (D (X j )) : used (defined) attr. occs.
Reference: 14. <author> KASTENS, U. </author> <title> Attribute grammars in a compiler construction environment. In Attribute Grammars, </title> <booktitle> Applications and Systems. International Summer School SAGA Proceedings, </booktitle> <address> Prague, Czechoslovakia, </address> <month> 4-13 June </month> <year> 1991 (1991), </year> <editor> H. Alblas and B. Melichar, Eds., </editor> <volume> vol. </volume> <booktitle> 545 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 380-400. </pages>
Reference-contexts: In the definition of classical attribute grammars, attribute values are specified as pure functions of attribute values of neighboring nodes. A variety of implementation techniques have been developed [1] and a number of usable attribute grammar implementation tools exist <ref> [4, 12, 14] </ref>. Aside from a few cases (for instance an Ada type checker [18] and a VHDL compiler [7]), however, attribute grammars have not been particularly successful either in formal language specification or in practical compiler generation. <p> However, using an attribute of a node computed dynamically, or worse, defining an attribute remotely, makes it harder for static analysis to determine a safe evaluation order. In current systems 8 that allow something close to remote attribute use (say LIGA <ref> [14, 15] </ref>), the programmer must add control attributes to force the evaluation order to be safe. This section shows that a safe order can be guaranteed automatically through a reduction to classical attribute grammars. <p> A simple attribute grammar using remote attribution, the results of fiber analysis and the reduction to a classical attribute grammar 13 4 Related Work LIGA <ref> [14] </ref>, part of the Eli compiler construction system [8], has a notation that can reduce the number of copy rules.
Reference: 15. <author> KASTENS, U., AND WAITE, W. M. </author> <title> Modularity and reusability in attribute grammars. </title> <journal> Acta Informatica 31 (1994), </journal> <pages> 601-627. </pages>
Reference-contexts: However, using an attribute of a node computed dynamically, or worse, defining an attribute remotely, makes it harder for static analysis to determine a safe evaluation order. In current systems 8 that allow something close to remote attribute use (say LIGA <ref> [14, 15] </ref>), the programmer must add control attributes to force the evaluation order to be safe. This section shows that a safe order can be guaranteed automatically through a reduction to classical attribute grammars. <p> LIGA also supports control attributes allowing an attribute grammar to make use of, say, an imperative interface to a symbol table. Control attributes represent preconditions and postconditions for scheduling imperative actions, such as inserting an element in a symbol table <ref> [15] </ref>. However, these control attributes must be written into the attribute grammar by the compiler writer, and omitting a control attribute may lead to an incorrect schedule. For example, an identifier may be looked up in a symbol table before all the declarations have been inserted.
Reference: 16. <author> KNUTH, D. E. </author> <title> Semantics of context free languages. </title> <journal> Math Systems Theory 2, </journal> <month> 2 (June </month> <year> 1968), </year> <pages> 127-145. </pages> <note> Errata Math Systems Theory 5, </note> <month> 1 </month> <year> (1971), </year> <pages> 95-96. </pages>
Reference-contexts: 1 Introduction Attribute grammars <ref> [16] </ref> were developed to specify the semantics of programming languages as an alternative to writing a compiler in an imperative language. An imperative program is not an ideal specification, because it expresses how a computation is to proceed, rather than what the desired result is to be.
Reference: 17. <author> SWIESTRA, D., AND VOGT, H. </author> <title> Higher order attribute grammars. In Attribute Grammars, </title> <booktitle> Applications and Systems. International Summer School SAGA Proceedings, </booktitle> <address> Prague, Czechoslo-vakia, </address> <month> 4-13 June </month> <year> 1991, </year> <editor> H. Alblas and B. Melichar, Eds., </editor> <volume> vol. </volume> <booktitle> 545 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991, </year> <pages> pp. 256-296. </pages>
Reference-contexts: This feature comes close to remote attribute definition in power. Again, manual decisions are needed to ensure correct implementation. Another extension of attribute grammars that involves passing nodes through the attribute system is higher-order attribute grammars <ref> [17, 19] </ref>. In a higher-order attribute grammar, rules may construct new subtrees and graft them into the tree being attributed. At no point, however, may attributed nodes be transmitted through the attribute system.
Reference: 18. <author> UHL, J., DROSSOPOULOU, S., PERSCH, G., GOOS, G., DAUSMANN, M., WINTERSTEIN, G., AND KIRCHG ASSNER, W. </author> <title> An Attribute Grammar for the Semantic Analysis of Ada, </title> <booktitle> vol. 139 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1982. </year>
Reference-contexts: A variety of implementation techniques have been developed [1] and a number of usable attribute grammar implementation tools exist [4, 12, 14]. Aside from a few cases (for instance an Ada type checker <ref> [18] </ref> and a VHDL compiler [7]), however, attribute grammars have not been particularly successful either in formal language specification or in practical compiler generation.
Reference: 19. <author> VOGT, H. H., SWIESTRA, S. D., AND KUIPER, M. F. </author> <title> Higher order attribute grammars. </title> <booktitle> In Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation (June 1989), </booktitle> <pages> pp. </pages> <month> 131-145. </month> <title> This article was processed using the L A T E X macro package with LLNCS style 16 </title>
Reference-contexts: This feature comes close to remote attribute definition in power. Again, manual decisions are needed to ensure correct implementation. Another extension of attribute grammars that involves passing nodes through the attribute system is higher-order attribute grammars <ref> [17, 19] </ref>. In a higher-order attribute grammar, rules may construct new subtrees and graft them into the tree being attributed. At no point, however, may attributed nodes be transmitted through the attribute system.
References-found: 19

