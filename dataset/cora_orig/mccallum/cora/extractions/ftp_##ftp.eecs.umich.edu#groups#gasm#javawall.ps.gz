URL: ftp://ftp.eecs.umich.edu/groups/gasm/javawall.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/proglang.html
Root-URL: http://www.eecs.umich.edu
Email: wallace@eecs.umich.edu  
Title: The Semantics of the Java Programming Language: Preliminary Version  
Author: Charles Wallace 
Address: Ann Arbor, Michigan 48109-2122 USA  
Affiliation: Electrical Engineering and Computer Science University of Michigan  
Abstract: A mathematical model of the Java programming language is constructed. We provide both compile-time and runtime semantics of the language, through a series of refinements that gradually add levels of detail to the model. 
Abstract-found: 1
Intro-found: 1
Reference: [App] <institution> AppletMagic home page. http://www.appletmagic.com. Intermetrics, Inc. </institution>
Reference: [ASM] <institution> ASM home page. http://www.eecs.umich.edu/groups/gasm/. University of Michigan. </institution>
Reference-contexts: 1 Introduction We provide operational semantics for the Java programming language using the Abstract State Machine (ASM) methodology of <ref> [Gur95, ASM] </ref>. We use Montages ([KP97b]) to specify not only the runtime behavior of a Java program but also the actions performed at compile time.
Reference: [BGS97] <author> A. Blass, Y. Gurevich, and S. Shelah. </author> <title> Choiceless polynomial time. </title> <type> Technical Report CSE-TR-338-97, </type> <institution> University of Michigan, </institution> <year> 1997. </year>
Reference-contexts: To execute R at S, execute all R i simultaneously. 2 This type of term first appeared in <ref> [BGS97] </ref>. 3 * If R is a conditional rule, of the form if g 0 then R 0 . . . elseif g n then R n endif, where g 1 : : : g n (the guards) are terms and R 0 : : : R n are rules, then
Reference: [Bor95] <editor> E. Borger, editor. </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference: [BR94] <author> E. Borger and D. Rosenzweig. </author> <title> A mathematical definition of full Prolog. </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1994. </year>
Reference: [BS97] <author> E. Borger and Wolfram Schulte. </author> <title> Proving the correctness for compiling Java programs to Java VM code. </title> <booktitle> In Proceedings of IFIP Working Group 2.2 Meeting, </booktitle> <year> 1997. </year>
Reference-contexts: Section 7 explains the initialization of classes and class instances. Section 8 explains the finalization of class instances. Section 9 concerns the execution of threads. Finally, Section 10 deals with locks and wait sets. Another effort to provide semantics for Java is the work of <ref> [BS97] </ref>. However, only an abstract of this paper is provided publicly. To the best of our knowledge, our paper is the first publicly available document providing both compile-time and runtime semantics for Java. In this preliminary version, there are some aspects of the language which we do not cover.
Reference: [Gem] <institution> GemMex home page. </institution> <note> http://www.first.gmd.de/~ma/gem/index.html. Matthias Anlauff, GMD FIRST. </note>
Reference: [GH93] <author> Y. Gurevich and J. Huggins. </author> <title> The semantics of the C programming language. </title> <editor> In E. Borger, H. Kleine Buning, G. Jager, S. Martini, and M.M. Richter, editors, </editor> <booktitle> Computer Science Logic, volume 702 of Lecture Notes in Computer Science, </booktitle> <pages> pages 274-309. </pages> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: As a result, there are many subtle issues concerning compilation of Java programs. A mathematical model of the language, such as the one presented here, can present these issues in a clear and unambiguous way. Early work in the area (e.g. <ref> [GH93, Wal95] </ref>) considered only runtime semantics. All compile-time information was represented informally and was assumed to exist in the initial state of the model. More recently, the Montage approach has provided a convenient way to represent how this information is derived at compile time.
Reference: [GJS96] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: COMPILE-TIME RULES Control/Data flow graph (optional) Compile-time ASM rule (optional) COMPILE-TIME CONDITION condition ASM guard (optional) . . . RUNTIME RULES Task Label: Runtime ASM rule (optional) . . . 3 We use a grammar equivalent to the LALR (1) grammar of <ref> [GJS96] </ref>, but with certain modifications to ease understanding. 5 Nodes and tasks The initial state of L contains the compact derivation tree of a program P .
Reference: [Gur95] <author> Y. Gurevich. </author> <title> Evolving Algebras 1993: Lipari guide. </title> <booktitle> In Borger [Bor95], </booktitle> <pages> pages 9-36. </pages>
Reference-contexts: 1 Introduction We provide operational semantics for the Java programming language using the Abstract State Machine (ASM) methodology of <ref> [Gur95, ASM] </ref>. We use Montages ([KP97b]) to specify not only the runtime behavior of a Java program but also the actions performed at compile time. <p> Matthias Anlauff developed the GemMex tool ([Gem]), which was used to produce the diagrams in this paper. Jim Huggins gave insightful comments on a draft of the paper. 2 Preliminaries In this section, we provide brief introductions to ASMs and Montages. We use <ref> [Gur95, Gur97] </ref> as our references for ASMs. We use the definition of Montages in [KP97b], with a few extensions. 2.1 Abstract state machines 2.1.1 States and updates A vocabulary is a finite collection of function names, each with a fixed arity.
Reference: [Gur97] <author> Y. Gurevich. </author> <title> May 1997 draft of the ASM guide. </title> <institution> University of Michigan, </institution> <year> 1997. </year>
Reference-contexts: Matthias Anlauff developed the GemMex tool ([Gem]), which was used to produce the diagrams in this paper. Jim Huggins gave insightful comments on a draft of the paper. 2 Preliminaries In this section, we provide brief introductions to ASMs and Montages. We use <ref> [Gur95, Gur97] </ref> as our references for ASMs. We use the definition of Montages in [KP97b], with a few extensions. 2.1 Abstract state machines 2.1.1 States and updates A vocabulary is a finite collection of function names, each with a fixed arity.
Reference: [Jav] <institution> Java glossary. http://java.sun.com/docs/glossary.html. Sun Microsystems. </institution>
Reference: [KP97a] <author> P.W. Kutter and A. Pierantonio. </author> <title> The formal specification of Oberon. </title> <journal> Journal of Universal Computer Science, </journal> <volume> 3(5) </volume> <pages> 443-503, </pages> <year> 1997. </year>
Reference: [KP97b] <author> P.W. Kutter and A. Pierantonio. </author> <title> Montages specifications of realistic programming languages. </title> <journal> Journal of Universal Computer Science, </journal> <volume> 3(5) </volume> <pages> 416-442, </pages> <year> 1997. </year>
Reference-contexts: Jim Huggins gave insightful comments on a draft of the paper. 2 Preliminaries In this section, we provide brief introductions to ASMs and Montages. We use [Gur95, Gur97] as our references for ASMs. We use the definition of Montages in <ref> [KP97b] </ref>, with a few extensions. 2.1 Abstract state machines 2.1.1 States and updates A vocabulary is a finite collection of function names, each with a fixed arity. Relations are treated as Boolean-valued functions; we call them relation functions.
Reference: [Wal95] <author> C. Wallace. </author> <title> The semantics of the C++ programming language. </title> <booktitle> In Borger [Bor95], </booktitle> <pages> pages 131-164. 92 </pages>
Reference-contexts: As a result, there are many subtle issues concerning compilation of Java programs. A mathematical model of the language, such as the one presented here, can present these issues in a clear and unambiguous way. Early work in the area (e.g. <ref> [GH93, Wal95] </ref>) considered only runtime semantics. All compile-time information was represented informally and was assumed to exist in the initial state of the model. More recently, the Montage approach has provided a convenient way to represent how this information is derived at compile time.
References-found: 15

