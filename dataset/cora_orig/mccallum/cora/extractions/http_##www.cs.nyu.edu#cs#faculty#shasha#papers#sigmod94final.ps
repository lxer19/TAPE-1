URL: http://www.cs.nyu.edu/cs/faculty/shasha/papers/sigmod94final.ps
Refering-URL: http://www.cs.nyu.edu/cs/faculty/shasha/papers/papers.html
Root-URL: http://www.cs.nyu.edu
Email: (jason@vienna.njit.edu).  (chin@cis.njit.edu).  (marr@cshl.org).  (bshapiro@ncifcrf.gov).  (shasha@cs.nyu.edu).  (kzhang@csd.uwo.ca).  
Title: Combinatorial Pattern Discovery for Scientific Data: proteins, organisms, weather patterns, etc.) that possess some important
Author: Dennis Shasha k Kaizhong Zhang flfl k 
Address: Technology, Newark, NJ 07102  Technology, Newark, NJ 07102  100 Bungtown Road, Cold Spring Harbor, NY 11724  MD 21701  New York University, 251 Mercer Street, New York, NY 10012  Ontario, London, Ontario, Canada N6A 5B7  
Affiliation: Computer and Information Science, New Jersey Institute of  Computer and Information Science, New Jersey Institute of  Laboratory,  Image Processing Section, Laboratory of Mathematical Biology, Division of Cancer Biology and Diagnosis, National Cancer Institute, National Institutes of Health, Frederick,  Courant Institute of Mathematical Sciences,  flfl Department of Computer Science, The University of Western  
Note: Suppose you are given a set of natural entities (e.g.,  Cold Spring Harbor  
Abstract: Some Preliminary Results fl Abstract This paper presents an example of combinatorial pattern discovery: the discovery of patterns in protein databases. The structural representation we consider are strings and the distance metric is string edit distance permitting vari fl This work was supported, in part, by the National Science Foundation under Grants IRI-8901699, CCR-9103953, IRI-9224601 and IRI-9224602, by the Office of Naval Research under Grants N00014-90-J-1110, N00014-91-J-1472 and N00014-92-J-1719, by the Natural Sciences and Engineering Research Council of Canada under Grant OGP0046373, by NJIT under Grant SBR-421280 and by a grant from the AT&T Foundation. T. G. Marr was supported by the Department of Energy under Grant DE-FG02-91ER61190 and by the National Institutes of Health under Grant 1RO1-HG0020301A1. able length don't cares. Our techniques incorporate string matching algorithms and novel heuristics for discovery and optimization, most of which generalize to other combinatorial structures. Experimental results of applying the techniques to both generated data and functionally related protein families obtained from the Cold Spring Harbor Laboratory show the effectiveness of the proposed techniques. When we apply the discovered patterns to perform protein classification, they give information that is complementary to the best protein classifier available today. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal, S. Ghosh, T. Imielinski, B. Iyer, and A. Swami. </author> <title> An interval classifier for database mining applications. </title> <booktitle> In Proceedings of the 18th International Conference on Very Large Data Bases, </booktitle> <pages> pages 560-573, </pages> <address> Vancouver, Canada, </address> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: Example Finding Sequence Similarities Consider the three sequences in Figure 1. Fig. 1. Three sequences. Suppose only exactly coinciding segments of lengths greater than 3 are considered as `similar.' Then S 1 and S 3 have one similarity (or common pattern): flS 1 <ref> [1; 4] </ref>fl = flYDPMfl () flS 3 [1; 4]fl = flYDPMfl where V [x; y] is a segment of a sequence V from the xth to the yth letter inclusively. <p> Fig. 1. Three sequences. Suppose only exactly coinciding segments of lengths greater than 3 are considered as `similar.' Then S 1 and S 3 have one similarity (or common pattern): flS 1 <ref> [1; 4] </ref>fl = flYDPMfl () flS 3 [1; 4]fl = flYDPMfl where V [x; y] is a segment of a sequence V from the xth to the yth letter inclusively. <p> If similarities within distance one are sought, i.e., one mutation (mismatch, insertion or deletion) is allowed in the similarities, then S 1 , S 2 and S 3 share three similar patterns: flS 1 <ref> [1; 4] </ref>fl = flYDPM fl () flS 2 [8; 11]fl = flTYDP fl () flS 2 [9; 12]fl = flYDPA fl () flS 3 [1; 4]fl = flYDPM fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S <p> one mutation (mismatch, insertion or deletion) is allowed in the similarities, then S 1 , S 2 and S 3 share three similar patterns: flS 1 <ref> [1; 4] </ref>fl = flYDPM fl () flS 2 [8; 11]fl = flTYDP fl () flS 2 [9; 12]fl = flYDPA fl () flS 3 [1; 4]fl = flYDPM fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S 1 [12; 15]fl = flYDPM fl RLVG fl <p> () flS 2 [9; 12]fl = flYDPA fl () flS 3 <ref> [1; 4] </ref>fl = flYDPM fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S 1 [12; 15]fl = flYDPM fl RLVG fl () flS 1 [1; 5] fl S 1 [13; 15]fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; <p> fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S 1 [12; 15]fl = flYDPM fl RLVG fl () flS 1 <ref> [1; 5] </ref> fl S 1 [13; 15]fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG fl End of Example To discover such (approximately) common patterns <p> than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 <ref> [1; 4] </ref> fl S 1 [12; 15]fl = flYDPM fl RLVG fl () flS 1 [1; 5] fl S 1 [13; 15]fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG fl End of Example To discover such (approximately) common patterns in a database of sequences, our overall strategy is first to find candidate segments among <p> four similar patterns: flS 1 [1; 4] fl S 1 [12; 15]fl = flYDPM fl RLVG fl () flS 1 <ref> [1; 5] </ref> fl S 1 [13; 15]fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG fl End of Example To discover such (approximately) common patterns in a database of sequences, our overall strategy is first to find candidate segments among a small sample, and then to combine the segments into candidate patterns and check which <p> We repeated the experiments by varying the compositions of samples and parameter values Length, Dist, Occur. The results obtained are mostly consistent with those given above. 5 Data Classification One application of database mining involves the ability to do classification in database systems <ref> [1] </ref>. In the Quest data mining project, for instance, Agrawal et al. [1] enhanced the database capability with classification queries and proposed algorithms to generate classification rules for a database of records using information in a training set. 7 By combining our pattern discovery techniques and a previously published fingerprint technique, <p> The results obtained are mostly consistent with those given above. 5 Data Classification One application of database mining involves the ability to do classification in database systems <ref> [1] </ref>. In the Quest data mining project, for instance, Agrawal et al. [1] enhanced the database capability with classification queries and proposed algorithms to generate classification rules for a database of records using information in a training set. 7 By combining our pattern discovery techniques and a previously published fingerprint technique, we have developed a classifier (referred to as the motif-hashing (or MH)
Reference: [2] <author> R. Agrawal, T. Imielinski, and A. Swami. </author> <title> Mining association rules between sets of items in large databases. </title> <booktitle> In Proceedings of the 1993 ACM SIG-MOD International Conference on Management of Data, </booktitle> <pages> pages 207-216, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: With the significant growth of database sizes in several applications, discovering potentially useful patterns in those databases has become the subject of significant research [6, 10, 31, 33]. Much of the work in database mining (e.g., <ref> [2, 9, 14] </ref>) has concentrated on record-oriented applications. The goal there is to find correlations among attribute-value pairs that give rise to useful properties.
Reference: [3] <author> D. J. Bacon and W. J. Anderson. </author> <title> Multiple sequence alignment. </title> <journal> Journal of Molecular Biology, </journal> <volume> 191 </volume> <pages> 153-161, </pages> <year> 1986. </year>
Reference-contexts: There are also techniques based on local similarity search. The techniques work effectively when similarities meet some constraints, such as they occur in a predetermined number of sequences in the database [26], they differ by mismatches, but not by insertions/deletions <ref> [3] </ref>, or they are situated at almost the same distance from the start of the sequences [34]. In contrast to the above techniques, our approach can find similarities composed of nonconsecutive segments separated by variable length don't cares without prior knowledge of their structures, positions, or occurrence frequency.
Reference: [4] <author> A. Bairoch. PROSITE: </author> <title> A dictionary of sites and patterns in proteins. </title> <journal> Nucleic Acids Research, </journal> <volume> 20 </volume> <pages> 2013-2018, </pages> <year> 1992. </year>
Reference-contexts: Example Finding Sequence Similarities Consider the three sequences in Figure 1. Fig. 1. Three sequences. Suppose only exactly coinciding segments of lengths greater than 3 are considered as `similar.' Then S 1 and S 3 have one similarity (or common pattern): flS 1 <ref> [1; 4] </ref>fl = flYDPMfl () flS 3 [1; 4]fl = flYDPMfl where V [x; y] is a segment of a sequence V from the xth to the yth letter inclusively. <p> Fig. 1. Three sequences. Suppose only exactly coinciding segments of lengths greater than 3 are considered as `similar.' Then S 1 and S 3 have one similarity (or common pattern): flS 1 <ref> [1; 4] </ref>fl = flYDPMfl () flS 3 [1; 4]fl = flYDPMfl where V [x; y] is a segment of a sequence V from the xth to the yth letter inclusively. <p> If similarities within distance one are sought, i.e., one mutation (mismatch, insertion or deletion) is allowed in the similarities, then S 1 , S 2 and S 3 share three similar patterns: flS 1 <ref> [1; 4] </ref>fl = flYDPM fl () flS 2 [8; 11]fl = flTYDP fl () flS 2 [9; 12]fl = flYDPA fl () flS 3 [1; 4]fl = flYDPM fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S <p> one mutation (mismatch, insertion or deletion) is allowed in the similarities, then S 1 , S 2 and S 3 share three similar patterns: flS 1 <ref> [1; 4] </ref>fl = flYDPM fl () flS 2 [8; 11]fl = flTYDP fl () flS 2 [9; 12]fl = flYDPA fl () flS 3 [1; 4]fl = flYDPM fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S 1 [12; 15]fl = flYDPM fl RLVG fl <p> () flS 2 [9; 12]fl = flYDPA fl () flS 3 <ref> [1; 4] </ref>fl = flYDPM fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S 1 [12; 15]fl = flYDPM fl RLVG fl () flS 1 [1; 5] fl S 1 [13; 15]fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; <p> than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 <ref> [1; 4] </ref> fl S 1 [12; 15]fl = flYDPM fl RLVG fl () flS 1 [1; 5] fl S 1 [13; 15]fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG fl End of Example To discover such (approximately) common patterns in a database of sequences, our overall strategy is first to find candidate segments among <p> We applied the classifier to all 698 groups of related proteins in the SWISS-PROT protein sequence databank version 27 [5]. These groups are categorized based on the documentation given in the PROSITE catalog version 11.0 <ref> [4] </ref>. The groups comprise more than 15,000 proteins. At present, the best tool to classify these proteins is the blocks server developed in [15] (referred to as HH).
Reference: [5] <author> A. Bairoch and B. Boeckmann. </author> <title> The SWISS-PROT protein sequence data bank. </title> <journal> Nucleic Acids Research, </journal> <volume> 20 </volume> <pages> 2019-2022, </pages> <year> 1992. </year>
Reference-contexts: fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S 1 [12; 15]fl = flYDPM fl RLVG fl () flS 1 <ref> [1; 5] </ref> fl S 1 [13; 15]fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG fl End of Example To discover such (approximately) common patterns <p> four similar patterns: flS 1 [1; 4] fl S 1 [12; 15]fl = flYDPM fl RLVG fl () flS 1 <ref> [1; 5] </ref> fl S 1 [13; 15]fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG fl End of Example To discover such (approximately) common patterns in a database of sequences, our overall strategy is first to find candidate segments among a small sample, and then to combine the segments into candidate patterns and check which <p> We applied the classifier to all 698 groups of related proteins in the SWISS-PROT protein sequence databank version 27 <ref> [5] </ref>. These groups are categorized based on the documentation given in the PROSITE catalog version 11.0 [4]. The groups comprise more than 15,000 proteins. At present, the best tool to classify these proteins is the blocks server developed in [15] (referred to as HH).
Reference: [6] <author> W. Buntine and M. D. </author> <title> Alto, editors. Collected Notes on the Workshop for Pattern Discovery in Large Databases. </title> <type> Technical Report FIA-91-07, </type> <institution> NASA Ames Research Center, Moffett Field, California, </institution> <month> April </month> <year> 1991. </year> <month> 9 </month>
Reference-contexts: With the significant growth of database sizes in several applications, discovering potentially useful patterns in those databases has become the subject of significant research <ref> [6, 10, 31, 33] </ref>. Much of the work in database mining (e.g., [2, 9, 14]) has concentrated on record-oriented applications. The goal there is to find correlations among attribute-value pairs that give rise to useful properties.
Reference: [7] <author> A. Califano and I. Rigoutsos. </author> <title> FLASH: A fast look-up algorithm for string homology. </title> <booktitle> In Proceedings of the 1st International Conference on Intelligent Systems for Molecular Biology, </booktitle> <address> Bethesda, MD, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: If a motif occurs in m groups, its weight is assigned as log 2 d (698=m)e. * Hash the training sequences using the gapped fin gerprint technique <ref> [7] </ref>. When classifying a test sequence T , we first compare T with all the motifs. After comparison, each group obtains a raw score, which equals the sum of the weights of the group's motifs occurring in T .
Reference: [8] <author> W. G. Cochran. </author> <title> Sampling Techniques. </title> <publisher> Wiley, </publisher> <year> 1977. </year>
Reference-contexts: If similarities within distance one are sought, i.e., one mutation (mismatch, insertion or deletion) is allowed in the similarities, then S 1 , S 2 and S 3 share three similar patterns: flS 1 [1; 4]fl = flYDPM fl () flS 2 <ref> [8; 11] </ref>fl = flTYDP fl () flS 2 [9; 12]fl = flYDPA fl () flS 3 [1; 4]fl = flYDPM fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four <p> Consider a candidate pattern P . Let D (a, respectively) denote the number of sequences in D (A, respectively) that contain P within the allowed distance. Let N be the database size and n the sample size; F = D=N and f = a=n. Fact 4. <ref> [8] </ref> With probability = 99%, F is in the in terval ( ^ F L , ^ F U ) where ^ F L = f (t N n r n 1 ); r N 1 f (1 f ) + 2n The symbol t is the value of the normal <p> When the probability = 99%, t = 2:58 <ref> [8] </ref>. The values of N; n are given; f; a can be obtained by checking with the sample (cf. subphase A of phase 2).
Reference: [9] <author> V. Dhar and A. Tuzhilin. </author> <title> Abstract-driven pattern discovery in databases. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(6) </volume> <pages> 926-938, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: With the significant growth of database sizes in several applications, discovering potentially useful patterns in those databases has become the subject of significant research [6, 10, 31, 33]. Much of the work in database mining (e.g., <ref> [2, 9, 14] </ref>) has concentrated on record-oriented applications. The goal there is to find correlations among attribute-value pairs that give rise to useful properties. <p> If similarities within distance one are sought, i.e., one mutation (mismatch, insertion or deletion) is allowed in the similarities, then S 1 , S 2 and S 3 share three similar patterns: flS 1 [1; 4]fl = flYDPM fl () flS 2 [8; 11]fl = flTYDP fl () flS 2 <ref> [9; 12] </ref>fl = flYDPA fl () flS 3 [1; 4]fl = flYDPM fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S
Reference: [10] <author> W. J. Frawley, G. Piatetsky-Shapiro, and C. J. Matheus. </author> <title> Knowledge discovery in databases: An overview. </title> <editor> In G. Piatetsky-Shapiro and W. J. Fraw-ley, editors, </editor> <booktitle> Knowledge Discovery in Databases, </booktitle> <pages> pages 1-27. </pages> <publisher> AAAI/MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: With the significant growth of database sizes in several applications, discovering potentially useful patterns in those databases has become the subject of significant research <ref> [6, 10, 31, 33] </ref>. Much of the work in database mining (e.g., [2, 9, 14]) has concentrated on record-oriented applications. The goal there is to find correlations among attribute-value pairs that give rise to useful properties.
Reference: [11] <author> K. A. Frenkel. </author> <title> The human genome project and informatics. </title> <journal> Communications of the ACM, </journal> <volume> 34(11) </volume> <pages> 41-51, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: If 1 two sequences are almost the same or share very similar subsequences, it may be that the common part may perform similar functions via related biochemical mechanisms <ref> [11, 18, 19, 21] </ref>. These similarities may involve as few as two or three amino acids in some cases. Whereas computerized tools exist for comparing entire sequences, discovering similar subsequences is still usually done by visual inspection. <p> If similarities within distance one are sought, i.e., one mutation (mismatch, insertion or deletion) is allowed in the similarities, then S 1 , S 2 and S 3 share three similar patterns: flS 1 [1; 4]fl = flYDPM fl () flS 2 <ref> [8; 11] </ref>fl = flTYDP fl () flS 2 [9; 12]fl = flYDPA fl () flS 3 [1; 4]fl = flYDPM fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four
Reference: [12] <author> G. H. Gonnet and R. Baeza-Yates. </author> <title> Handbook of Algorithms and Data Structures. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, 2 edition, </address> <year> 1991. </year>
Reference-contexts: If similarities within distance one are sought, i.e., one mutation (mismatch, insertion or deletion) is allowed in the similarities, then S 1 , S 2 and S 3 share three similar patterns: flS 1 [1; 4]fl = flYDPM fl () flS 2 [8; 11]fl = flTYDP fl () flS 2 <ref> [9; 12] </ref>fl = flYDPA fl () flS 3 [1; 4]fl = flYDPM fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S <p> = flYDPA fl () flS 3 [1; 4]fl = flYDPM fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S 1 <ref> [12; 15] </ref>fl = flYDPM fl RLVG fl () flS 1 [1; 5] fl S 1 [13; 15]fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG <p> allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S 1 <ref> [12; 15] </ref>fl = flYDPM fl RLVG fl () flS 1 [1; 5] fl S 1 [13; 15]fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG fl End of Example To discover such (approximately) common patterns in a database of sequences, our overall strategy is first to find candidate segments among a small sample, and then <p> When databases are sizable, using a large sample may entail the construction of a "disk-based" suffix tree. To improve efficiency, one could use the coding scheme suggested in Patricia tries' implementation <ref> [12, 24] </ref> and pack as much as possible of the tree's upper part into memory. Doing so saves I/O since the tree's upper part is accessed more frequently than the lower part of the tree.
Reference: [13] <author> P. J. Haas and A. N. Swami. </author> <title> Sequential sampling procedures for query size estimation. </title> <booktitle> In Proceedings of the 1992 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 341-350, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S 1 [12; 15]fl = flYDPM fl RLVG fl () flS 1 [1; 5] fl S 1 <ref> [13; 15] </ref>fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG fl End of Example To discover such (approximately) common patterns in a database of sequences, <p> [1; 4] fl S 1 [12; 15]fl = flYDPM fl RLVG fl () flS 1 [1; 5] fl S 1 <ref> [13; 15] </ref>fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG fl End of Example To discover such (approximately) common patterns in a database of sequences, our overall strategy is first to find candidate segments among a small sample, and then to combine the segments into candidate patterns and check which patterns satisfy the specified requirements. <p> The main question from an optimization point of view is which candidates to compare. Our strategy is as follows. We use simple random sampling without replacement <ref> [13, 16, 22, 25] </ref> to select sample sequences from the database. Consider a candidate pattern P . Let D (a, respectively) denote the number of sequences in D (A, respectively) that contain P within the allowed distance.
Reference: [14] <author> J. Han, Y. Cai, and N. Cercone. </author> <title> Knowledge discovery in databases: An attribute-oriented approach. </title> <booktitle> In Proceedings of the 18th International Conference on Very Large Data Bases, </booktitle> <pages> pages 547-559, </pages> <address> Vancou-ver, Canada, </address> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: With the significant growth of database sizes in several applications, discovering potentially useful patterns in those databases has become the subject of significant research [6, 10, 31, 33]. Much of the work in database mining (e.g., <ref> [2, 9, 14] </ref>) has concentrated on record-oriented applications. The goal there is to find correlations among attribute-value pairs that give rise to useful properties.
Reference: [15] <author> S. Henikoff and J. G. Henikoff. </author> <title> Automated assembly of protein blocks for database searching. </title> <journal> Nucleic Acids Research, </journal> 19(23) 6565-6572, 1991. 
Reference-contexts: = flYDPA fl () flS 3 [1; 4]fl = flYDPM fl If similarities having the form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S 1 <ref> [12; 15] </ref>fl = flYDPM fl RLVG fl () flS 1 [1; 5] fl S 1 [13; 15]fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG <p> form flX fl Y fl are sought with lengths greater than 7 and one mutation allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S 1 [12; 15]fl = flYDPM fl RLVG fl () flS 1 [1; 5] fl S 1 <ref> [13; 15] </ref>fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG fl End of Example To discover such (approximately) common patterns in a database of sequences, <p> allowed, then S 1 and S 3 share the following four similar patterns: flS 1 [1; 4] fl S 1 <ref> [12; 15] </ref>fl = flYDPM fl RLVG fl () flS 1 [1; 5] fl S 1 [13; 15]fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG fl End of Example To discover such (approximately) common patterns in a database of sequences, our overall strategy is first to find candidate segments among a small sample, and then <p> [1; 4] fl S 1 [12; 15]fl = flYDPM fl RLVG fl () flS 1 [1; 5] fl S 1 <ref> [13; 15] </ref>fl = flYDPMI fl LVG fl () flS 3 [1; 4] fl S 3 [12; 15]fl = flYDPM fl TLVG fl () flS 3 [1; 5] fl S 3 [13; 15]fl = flYDPMN fl LVG fl End of Example To discover such (approximately) common patterns in a database of sequences, our overall strategy is first to find candidate segments among a small sample, and then to combine the segments into candidate patterns and check which patterns satisfy the specified requirements. <p> These groups are categorized based on the documentation given in the PROSITE catalog version 11.0 [4]. The groups comprise more than 15,000 proteins. At present, the best tool to classify these proteins is the blocks server developed in <ref> [15] </ref> (referred to as HH). HH generates a set of blocks for each group, where a block comprises ungapped aligned regions extracted from the sequences in the group.
Reference: [16] <author> W. C. Hou and G. Ozsoyoglu. </author> <title> Statistical estimators for aggregate relational algebra queries. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 16(4) </volume> <pages> 600-654, </pages> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: The main question from an optimization point of view is which candidates to compare. Our strategy is as follows. We use simple random sampling without replacement <ref> [13, 16, 22, 25] </ref> to select sample sequences from the database. Consider a candidate pattern P . Let D (a, respectively) denote the number of sequences in D (A, respectively) that contain P within the allowed distance.
Reference: [17] <author> L. C. K. Hui. </author> <title> Color set size problem with applications to string matching. </title> <editor> In A. Apostolico, M. Crochemore, Z. Galil, and U. Manber, editors, </editor> <title> Combinatorial Pattern Matching, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 644, </volume> <pages> pages 230-243. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Phase 1 consists of two subphases. In subphase A, we construct an index structure for the sequences in the sample. In subphase B, we traverse the structure to locate the candidate segments. 2.2.1 Subphase A of Phase 1 We construct a generalized suffix tree <ref> [17] </ref> (GST) for the sample of sequences. A suffix tree is a trie-like data structure that compactly represents a string by collapsing a series of nodes having one child to a single node whose parent edge has a string. Suffix trees are used extensively in string matching [20, 23]. <p> Fact 2. If count (v) = b, then occurrence no 0 A (string (v)) = b. The reason is that if count (v) = b, string (v) is a prefix of the suffixes from b sequences in A. Fact 3. <ref> [17, 23] </ref> The time and space needed to construct the GST is O (n) where n is the total length of all sequences in the sample. 2.2.2 Subphase B of Phase 1 In this phase, we traverse the GST constructed in subphase A to find all segments (i.e., all prefixes of
Reference: [18] <editor> L. Hunter, editor. </editor> <booktitle> Artificial Intelligence and Molecular Biology. </booktitle> <publisher> AAAI Press/The MIT Press, </publisher> <address> Menlo Park, CA, </address> <year> 1993. </year>
Reference-contexts: If 1 two sequences are almost the same or share very similar subsequences, it may be that the common part may perform similar functions via related biochemical mechanisms <ref> [11, 18, 19, 21] </ref>. These similarities may involve as few as two or three amino acids in some cases. Whereas computerized tools exist for comparing entire sequences, discovering similar subsequences is still usually done by visual inspection.
Reference: [19] <author> N. Kamel, M. Delobel, T. G. Marr, R. Robbins, J. Thierry-Mieg, and A. Tsugita. </author> <title> Data and knowledge bases for genome mapping: </title> <booktitle> What lies ahead? Panel Presentation in the 17th International Conference on Very Large Data Bases, </booktitle> <address> Barcelona, Spain, </address> <month> Sep. </month> <year> 1991. </year>
Reference-contexts: If 1 two sequences are almost the same or share very similar subsequences, it may be that the common part may perform similar functions via related biochemical mechanisms <ref> [11, 18, 19, 21] </ref>. These similarities may involve as few as two or three amino acids in some cases. Whereas computerized tools exist for comparing entire sequences, discovering similar subsequences is still usually done by visual inspection.
Reference: [20] <author> G. M. Landau and U. Vishkin. </author> <title> Fast parallel and serial approximate string matching. </title> <journal> Journal of Algorithms, </journal> <volume> 10(2) </volume> <pages> 157-169, </pages> <year> 1989. </year>
Reference-contexts: A suffix tree is a trie-like data structure that compactly represents a string by collapsing a series of nodes having one child to a single node whose parent edge has a string. Suffix trees are used extensively in string matching <ref> [20, 23] </ref>. A GST is an extension of the suffix tree, designed for representing a set of strings. Each suffix of a string is represented by a leaf in the GST. Each leaf is associated with an index i.
Reference: [21] <author> R. J. Lipton, T. G. Marr, and J. D. Welsh. </author> <title> Computational approaches to discovering semantics in molecular biology. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 77(7) </volume> <pages> 1056-1060, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: If 1 two sequences are almost the same or share very similar subsequences, it may be that the common part may perform similar functions via related biochemical mechanisms <ref> [11, 18, 19, 21] </ref>. These similarities may involve as few as two or three amino acids in some cases. Whereas computerized tools exist for comparing entire sequences, discovering similar subsequences is still usually done by visual inspection.
Reference: [22] <author> R. J. Lipton, J. F. Naughton, and D. A. Schneider. </author> <title> Practical selectivity estimation through adaptive sampling. </title> <booktitle> In Proceedings of the 1990 ACM SIG-MOD International Conference on Management of Data, </booktitle> <pages> pages 1-12, </pages> <address> Atlantic City, NJ, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: The main question from an optimization point of view is which candidates to compare. Our strategy is as follows. We use simple random sampling without replacement <ref> [13, 16, 22, 25] </ref> to select sample sequences from the database. Consider a candidate pattern P . Let D (a, respectively) denote the number of sequences in D (A, respectively) that contain P within the allowed distance.
Reference: [23] <author> E. M. McCreight. </author> <title> A space-economical suffix tree construction algorithm. </title> <journal> JACM, </journal> <volume> 23 </volume> <pages> 262-272, </pages> <year> 1976. </year>
Reference-contexts: A suffix tree is a trie-like data structure that compactly represents a string by collapsing a series of nodes having one child to a single node whose parent edge has a string. Suffix trees are used extensively in string matching <ref> [20, 23] </ref>. A GST is an extension of the suffix tree, designed for representing a set of strings. Each suffix of a string is represented by a leaf in the GST. Each leaf is associated with an index i. <p> Fact 2. If count (v) = b, then occurrence no 0 A (string (v)) = b. The reason is that if count (v) = b, string (v) is a prefix of the suffixes from b sequences in A. Fact 3. <ref> [17, 23] </ref> The time and space needed to construct the GST is O (n) where n is the total length of all sequences in the sample. 2.2.2 Subphase B of Phase 1 In this phase, we traverse the GST constructed in subphase A to find all segments (i.e., all prefixes of
Reference: [24] <author> D. R. Morrison. </author> <title> PATRICIA practical algorithm to retrieve information coded in alphanumeric. </title> <journal> JACM, </journal> <volume> 15(4) </volume> <pages> 514-534, </pages> <year> 1968. </year>
Reference-contexts: When databases are sizable, using a large sample may entail the construction of a "disk-based" suffix tree. To improve efficiency, one could use the coding scheme suggested in Patricia tries' implementation <ref> [12, 24] </ref> and pack as much as possible of the tree's upper part into memory. Doing so saves I/O since the tree's upper part is accessed more frequently than the lower part of the tree.
Reference: [25] <author> F. Olken and D. Rotem. </author> <title> Random sampling from B + trees. </title> <booktitle> In Proceedings of the 15th International Conference on Very Large Data Bases, </booktitle> <pages> pages 269-278, </pages> <address> Amsterdam, The Netherlands, </address> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: The main question from an optimization point of view is which candidates to compare. Our strategy is as follows. We use simple random sampling without replacement <ref> [13, 16, 22, 25] </ref> to select sample sequences from the database. Consider a candidate pattern P . Let D (a, respectively) denote the number of sequences in D (A, respectively) that contain P within the allowed distance.
Reference: [26] <author> M. A. Roytberg. </author> <title> A search for common patterns in many sequences. </title> <booktitle> Computer Applications in the Biosciences, </booktitle> <volume> 8(1) </volume> <pages> 57-64, </pages> <year> 1992. </year>
Reference-contexts: However, when the sequences have only short regions of local similarities, this approach makes no sense. There are also techniques based on local similarity search. The techniques work effectively when similarities meet some constraints, such as they occur in a predetermined number of sequences in the database <ref> [26] </ref>, they differ by mismatches, but not by insertions/deletions [3], or they are situated at almost the same distance from the start of the sequences [34].
Reference: [27] <author> D. Sankoff and J. B. Kruskal, </author> <title> editors. Time Warps, String Edits, and Macromolecules: The Theory and Practice of Sequence Comparison. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: Theory holds that the edit distance is a useful measure of evolutionary distance <ref> [27] </ref>. For the purpose of this work, we assume that all the edit operations have unit cost, though the techniques we propose do not depend on that cost assumption or essentially on the edit distance metric. Example Finding Sequence Similarities Consider the three sequences in Figure 1. Fig. 1.
Reference: [28] <author> B. A. Shapiro and K. Zhang. </author> <title> Comparing multiple RNA secondary structures using tree comparisons. </title> <booktitle> Computer Applications in the Biosciences, </booktitle> <volume> 6(4) </volume> <pages> 309-318, </pages> <year> 1990. </year>
Reference-contexts: We have concentrated so far on sequences, but would like to apply our previous work on trees and graphs <ref> [28, 29, 40, 41] </ref> to scientific problems as well [32]. This will require new data structures. We have little experience with scientific visualization, but believe that it could be a helpful part of our tool.
Reference: [29] <author> D. Shasha, J. T. L. Wang, K. Zhang, and F. Y. Shih. </author> <title> Exact and approximate algorithms for unordered tree matching. </title> <journal> IEEE Transactions on Systems, Man and Cybernetics, </journal> <volume> 24(3), </volume> <month> March </month> <year> 1994. </year>
Reference-contexts: We have concentrated so far on sequences, but would like to apply our previous work on trees and graphs <ref> [28, 29, 40, 41] </ref> to scientific problems as well [32]. This will require new data structures. We have little experience with scientific visualization, but believe that it could be a helpful part of our tool.
Reference: [30] <author> D. Shasha and T. L. Wang. </author> <title> New techniques for best-match retrieval. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 8(2) </volume> <pages> 140-158, </pages> <month> Apr. </month> <year> 1990. </year> <month> 10 </month>
Reference-contexts: However, if a pattern is active only in some of the sub-databases, one would need to compare it with all sequences to determine its overall activity. The work reported here is part of a project for developing a comprehensive toolbox for pattern discovery and pattern retrieval <ref> [30, 36, 37] </ref> in scientific databases. The goal is to allow a natural scientist to present structural data and a pattern metric and to ask the toolbox to find the common structural motifs in the data according to the metric.
Reference: [31] <author> A. Silberschatz, M. Stonebraker, and J. D. Ullman. </author> <title> Database systems: Achievements and opportunities. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 94-109, </pages> <year> 1991. </year>
Reference-contexts: With the significant growth of database sizes in several applications, discovering potentially useful patterns in those databases has become the subject of significant research <ref> [6, 10, 31, 33] </ref>. Much of the work in database mining (e.g., [2, 9, 14]) has concentrated on record-oriented applications. The goal there is to find correlations among attribute-value pairs that give rise to useful properties.
Reference: [32] <author> B. Subramanian, S. B. Zdonik, T. W. Leung, and S. L. Vandenberg. </author> <title> Ordered types in the AQUA data model. </title> <editor> In C. Beeri, A. Ohori, and D. Shasha, editors, </editor> <booktitle> Database Programming Languages (DBPL-4), Proceedings of the Fourth International Workshop on Database Programming Languages Object Models and Languages, </booktitle> <pages> pages 115-135. </pages> <publisher> Springer-Verlag, Workshops in Computing Series, </publisher> <year> 1994. </year>
Reference-contexts: We have concentrated so far on sequences, but would like to apply our previous work on trees and graphs [28, 29, 40, 41] to scientific problems as well <ref> [32] </ref>. This will require new data structures. We have little experience with scientific visualization, but believe that it could be a helpful part of our tool. In that area or in any other related to our goal, we welcome cooperation, suggestions, and friendly competition.
Reference: [33] <author> S. Tsur. </author> <title> Data dredging. </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 13(4) </volume> <pages> 58-63, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: With the significant growth of database sizes in several applications, discovering potentially useful patterns in those databases has become the subject of significant research <ref> [6, 10, 31, 33] </ref>. Much of the work in database mining (e.g., [2, 9, 14]) has concentrated on record-oriented applications. The goal there is to find correlations among attribute-value pairs that give rise to useful properties.
Reference: [34] <author> M. Vingron and P. Argos. </author> <title> A fast and sensitive multiple sequence alignment algorithm. </title> <booktitle> Computer Applications in the Biosciences, </booktitle> <volume> 5 </volume> <pages> 115-122, </pages> <year> 1989. </year>
Reference-contexts: The techniques work effectively when similarities meet some constraints, such as they occur in a predetermined number of sequences in the database [26], they differ by mismatches, but not by insertions/deletions [3], or they are situated at almost the same distance from the start of the sequences <ref> [34] </ref>. In contrast to the above techniques, our approach can find similarities composed of nonconsecutive segments separated by variable length don't cares without prior knowledge of their structures, positions, or occurrence frequency. The rest of the paper is organized as follows.
Reference: [35] <author> R. A. Wagner and M. J. Fischer. </author> <title> The string-to-string correction problem. </title> <journal> JACM, </journal> <volume> 21(1) </volume> <pages> 168-173, </pages> <month> Jan. </month> <year> 1974. </year>
Reference-contexts: The dissimilarity measure used in comparing two sequences is the edit distance, i.e., the minimum weighted number of insertions, deletions and substitutions used to transform one sequence to the other <ref> [35] </ref> after an optimal substitution for the VLDCs. Theory holds that the edit distance is a useful measure of evolutionary distance [27].
Reference: [36] <author> J. T. L. Wang, K. Zhang, K. Jeong, and D. Shasha. </author> <title> A system for approximate tree matching. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 6(2), </volume> <month> April </month> <year> 1994. </year>
Reference-contexts: However, if a pattern is active only in some of the sub-databases, one would need to compare it with all sequences to determine its overall activity. The work reported here is part of a project for developing a comprehensive toolbox for pattern discovery and pattern retrieval <ref> [30, 36, 37] </ref> in scientific databases. The goal is to allow a natural scientist to present structural data and a pattern metric and to ask the toolbox to find the common structural motifs in the data according to the metric.
Reference: [37] <author> T. L. Wang and D. Shasha. </author> <title> Query processing for distance metrics. </title> <booktitle> In Proceedings of the 16th International Conference on Very Large Data Bases, </booktitle> <pages> pages 602-613, </pages> <address> Brisbane, Australia, </address> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: However, if a pattern is active only in some of the sub-databases, one would need to compare it with all sequences to determine its overall activity. The work reported here is part of a project for developing a comprehensive toolbox for pattern discovery and pattern retrieval <ref> [30, 36, 37] </ref> in scientific databases. The goal is to allow a natural scientist to present structural data and a pattern metric and to ask the toolbox to find the common structural motifs in the data according to the metric.
Reference: [38] <author> M. S. Waterman, </author> <title> editor. Mathematical Methods for DNA Sequence Analysis. </title> <publisher> CRC Press, </publisher> <address> Boca Raton, FL, </address> <year> 1989. </year>
Reference-contexts: Many techniques have been published in the literature to solve similar problems. 1 A commonly used one is based on multiple sequence alignment (see <ref> [38] </ref> for review). The technique is useful when entire sequences in the database are similar. However, when the sequences have only short regions of local similarities, this approach makes no sense. There are also techniques based on local similarity search.
Reference: [39] <author> S. Wu and U. Manber. </author> <title> Fast text searching allowing errors. </title> <journal> Communications of the ACM, </journal> <volume> 35(10) </volume> <pages> 83-91, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: identify all patterns having at most a certain length with at least a certain activity. 3 Given a regular expression pattern P and sequence S, one can find if P is within distance Dist of S in O (Dist fi jSj) time when O (jP j) = O (log jSj) <ref> [39] </ref>. Phase 1 consists of two subphases. In subphase A, we construct an index structure for the sequences in the sample.
Reference: [40] <author> K. Zhang and D. Shasha. </author> <title> Simple fast algorithms for the editing distance between trees and related problems. </title> <journal> SIAM J. Computing, </journal> <volume> 18(6) </volume> <pages> 1245-1262, </pages> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: We have concentrated so far on sequences, but would like to apply our previous work on trees and graphs <ref> [28, 29, 40, 41] </ref> to scientific problems as well [32]. This will require new data structures. We have little experience with scientific visualization, but believe that it could be a helpful part of our tool.
Reference: [41] <author> K. Zhang, D. Shasha, and J. T. L. Wang. </author> <title> Approximate tree matching in the presence of variable length don't cares. </title> <journal> Journal of Algorithms, </journal> <volume> 16(1) </volume> <pages> 33-66, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: This conforms to the 5 The definition of VLDCs may vary for different types of objects. For trees, for example, a VLDC may substitute for a path of nodes in a tree <ref> [41] </ref>. 5 intuition that P is the less constraining of the two pat-terns. Call the set of objects within distance 0 of P , Obj (P ). The above definition of subpattern implies that Obj (P ) Obj (P ). Definition 3. <p> We have concentrated so far on sequences, but would like to apply our previous work on trees and graphs <ref> [28, 29, 40, 41] </ref> to scientific problems as well [32]. This will require new data structures. We have little experience with scientific visualization, but believe that it could be a helpful part of our tool.
Reference: [42] <author> G. K. Zipf. </author> <title> Human Behavior and the Principle of Least Effort. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1949. </year> <month> 11 </month>
Reference-contexts: When there are ties for occurrence numbers with respect to distance 0, we break the ties by considering occurrence numbers with respect to distance 1. 9 To reduce the effect made by `chance motifs', we associate each motif with a weight based on Zipf's Law <ref> [42] </ref>. If a motif occurs in m groups, its weight is assigned as log 2 d (698=m)e. * Hash the training sequences using the gapped fin gerprint technique [7]. When classifying a test sequence T , we first compare T with all the motifs.
References-found: 42

