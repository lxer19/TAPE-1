URL: http://www.cs.jhu.edu/~cowen/timer.ps
Refering-URL: http://www.cs.jhu.edu/~cowen/
Root-URL: http://www.cs.jhu.edu
Title: A Formal Framework for Evaluating Heuristic Programs 1  
Author: by Lenore Cowen Joan Feigenbaum Sampath Kannan 
Address: Baltimore, MD 21218.  Room 2C-473, 600 Mountain Avenue, Murray Hill, NJ 07974.  Philadelphia, PA 19104.  
Affiliation: Dept. of Math. Sciences, Johns Hopkins University,  AT&T Bell Laboratories  Dept. of Computer and Information Science, University of Pennsylvania,  
Date: 1995  cember 1, 1994.  Spring, 1994.  
Note: July  2 DIMACS postdoctoral visitor, 1994. Visit supported by an NSF Postdoctoral Fellowship.  3 DIMACS permanent member.  DIMACS is a cooperative project of Rutgers University, Princeton University, AT&T Bell Laboratories and Bellcore. DIMACS is an NSF Science and Technology Center, funded under contract STC-91-19999; and also receives support from the New Jersey Commission on Science and Technology.  
Pubnum: 4 DIMACS visitor  
Abstract: DIMACS Technical Report 95-27 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Adleman and M. Huang, </author> <title> Recognizing primes in random polynomial time, </title> <booktitle> Proc. 19th Symposium on Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1987, </year> <pages> pp. 462-469. </pages>
Reference-contexts: Suppose that H proceeds by running the sophisticated algorithm of Adleman and Huang <ref> [1] </ref> for n c steps 1 and then, if no proof of primality is found, switching to a simple-minded trial-division algorithm that takes exponential time but always decides correctly whether a number is prime or composite. Let d (n) = n c . <p> We tried to find out what the exponent c is and instead discovered, in correspondence with the authors of <ref> [1] </ref>, that it has never been calculated precisely.
Reference: [2] <author> L. Babai, L. Fortnow, and C. Lund, </author> <title> Nondeterministic Exponential Time has Two-Prover Interactive Protocols, Computational Complexity, </title> <booktitle> 1 (1991), </booktitle> <pages> pp. 3-40. </pages>
Reference-contexts: It is exactly when a timer says STOP that it has detected a "bug" of this form. Program checking was introduced with a practical motivation, but it has had a profound impact on complexity theory <ref> [14, 19, 2] </ref>. We hope that the study of timers, also motivated by practical concerns, will lead to interesting theoretical results. The next section contains our family of definitions. Section 3 gives examples of timers drawn from diverse problem areas in computer science.
Reference: [3] <author> M. Blum, </author> <title> Program Result Checking: A New Approach to Making Programs More Reliable, </title> <booktitle> Proc. 20th International Colloquium on Automata, Languages, and Programming, Lecture Notes in Computer Science, </booktitle> <volume> vol. 700, </volume> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1993, </year> <pages> pp. 2-14. </pages> <note> First appeared in preliminary form in International Computer Science Institute Technical Report 88-009, </note> <institution> Berkeley CA, </institution> <year> 1988. </year>
Reference-contexts: At the same time, it never calls a "good" instance bad. A family of definitions that capture this notion formally is presented in Section 2. The concept of timers is related to the concept of program checking introduced by Blum <ref> [3] </ref>. A checker is a companion program that checks the correctness of the output produced by an (unproven but bounded-time) program on a particular instance. <p> This is done in order to help focus on the problem at hand. In general, however, programs do not always halt, and the definition of - 2 - `bug' must be extended to cover programming errors that slow a program down or cause it to diverge altogether <ref> [3, pp. 2-3] </ref>. It is exactly when a timer says STOP that it has detected a "bug" of this form. Program checking was introduced with a practical motivation, but it has had a profound impact on complexity theory [14, 19, 2]. <p> If H always (resp. never) finishes in time d (n), then a timer E that always outputs GO (resp. STOP) is a third type of trivial timer. As discussed in Section 1, timers are in some way analogous to program checkers as defined in <ref> [3] </ref>. With Definition 2.1 in hand, we can point out two respects in which timers and checkers are fundamentally different. A checker is an oracle machine that calls the program H whose output is being checked, whereas a nontrivial timer cannot call H as a - 3 - subroutine.
Reference: [4] <author> L. Goldberg, </author> <title> Efficient Algorithms for Listing Combinatorial Structures, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge UK, </address> <year> 1993. </year>
Reference-contexts: Similarly, a listing program could take as input a graph G and output the list of all spanning trees of G. For an excellent introduction to the theory of listing, see Goldberg <ref> [4] </ref>. We restrict attention to listing programs that run in polynomial total time, i.e., in time polynomial in n (the length of the input) and C (the length of the output). <p> This stricter property is not needed for our statements about timers to be meaningful. These and other measures of efficiency are discussed in <ref> [4] </ref>. <p> Because E outputs STOP on almost all such graphs, E is a g-strong probabilistic timer. A listing program for perfect matchings that runs in time Cg (n), for some polynomial g, can be obtained using the "recursive listing" technique described in <ref> [4, x2.1.1] </ref>.
Reference: [5] <author> S. Goldwasser and S. Micali, </author> <title> Probabilistic Encryption, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 28 (1984), </volume> <pages> pp. 270-299. </pages>
Reference-contexts: Which formal definition one should satisfy depends on the circumstances. Analogously there are different definitions of "one-way function," some useful in complexity theory [6, 13] and some in cryptography <ref> [8, 5, 7, 15, 18] </ref>. Another useful analogy can be drawn with the study of "reactive systems," such as process controllers, communication protocols, and operating systems; formal treatments of such systems always identify "safety" and "liveness" properties.
Reference: [6] <author> J. Grollman and A. Selman, </author> <title> Complexity Measures for Public-Key Cryptosystems, </title> <journal> SIAM Journal on Computing, </journal> <volume> 17 (1988), </volume> <pages> pp. 309-335. </pages>
Reference-contexts: Which formal definition one should satisfy depends on the circumstances. Analogously there are different definitions of "one-way function," some useful in complexity theory <ref> [6, 13] </ref> and some in cryptography [8, 5, 7, 15, 18]. Another useful analogy can be drawn with the study of "reactive systems," such as process controllers, communication protocols, and operating systems; formal treatments of such systems always identify "safety" and "liveness" properties.
Reference: [7] <author> J. Hastad, </author> <title> Pseudo-Random Generators under Uniform Assumptions, </title> <booktitle> Proc. 22nd Symposium on the Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1990, </year> <pages> pp. 395-404. </pages>
Reference-contexts: Which formal definition one should satisfy depends on the circumstances. Analogously there are different definitions of "one-way function," some useful in complexity theory [6, 13] and some in cryptography <ref> [8, 5, 7, 15, 18] </ref>. Another useful analogy can be drawn with the study of "reactive systems," such as process controllers, communication protocols, and operating systems; formal treatments of such systems always identify "safety" and "liveness" properties.
Reference: [8] <author> R. Impagliazzo, L. Levin, and M. Luby, </author> <title> Pseudo-Random Generation from One-Way Functions, </title> <booktitle> Proc. 21st Symposium on the Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1989, </year> <pages> pp. 12-24. </pages>
Reference-contexts: Which formal definition one should satisfy depends on the circumstances. Analogously there are different definitions of "one-way function," some useful in complexity theory [6, 13] and some in cryptography <ref> [8, 5, 7, 15, 18] </ref>. Another useful analogy can be drawn with the study of "reactive systems," such as process controllers, communication protocols, and operating systems; formal treatments of such systems always identify "safety" and "liveness" properties.
Reference: [9] <author> M. Jerrum and A. Sinclair, </author> <title> Approximating the Permanent, </title> <journal> SIAM Journal on Computing, </journal> <volume> 18 (1989), </volume> <pages> pp. 1149-1178. </pages>
Reference-contexts: The timer E that we give for programs that list perfect matchings uses the same basic idea as the one for spanning trees, but it differs in some details. Jerrum and Sinclair <ref> [9] </ref> give a probabilistic method for approximating the number of perfect matchings in a 2n vertex graph that runs in time O (q 3 n 5 log 2 n), where q is a known upper bound on M n1 =M n , the ratio of near-perfect matchings to perfect matchings. <p> Even if a good upper bound on q is not known a priori, <ref> [9] </ref> shows how, given a candidate upper bound c 1 , the algorithm can be modified to halt within a small constant factor of the time bounds reported above, with q replaced by c 1 ; with high probability, the modified algorithm either produces a good estimate for the number of <p> In order to show this, we need that there exist a family of graphs with more than a polynomial number of matchings, for which the ratio M n1 =M n is not too large. This is satisfied by the simple observation in <ref> [9] </ref> that all bipartite graphs on n vertices with minimal degree n=4 are q-amenable, for q (n) = n 2 . It is - 9 - easy to construct such graphs with a superpolynomial number of perfect matchings.
Reference: [10] <author> D. Johnson, C. Papadimitriou, and M. Yannakakis, </author> <title> On Generating All Maximal Independent Sets, </title> <journal> Information Processing Letters, </journal> <volume> 27 (1988), </volume> <pages> pp. 119-123. </pages>
Reference-contexts: on all inputs and hence, for any polynomially bounded deadline function d, has a trivial complete timer that always says STOP.) The two listing problems that we examine in detail happen to have algorithms with the polynomial delay property, a more stringent property first defined by Johnson, Papadimitriou, and Yannakakis <ref> [10] </ref>. In a polynomial-delay algorithm, the time it takes to generate the first output configuration and the time between any two consecutive output configurations are both bounded by a polynomial in the size of the input. This stricter property is not needed for our statements about timers to be meaningful.
Reference: [11] <editor> G. Kirchoff, Uber die Auflosung der Gleichungen, auf welche man bei der Untersuchung der linearen Verteilung galvanische Strome gefuhrt wird, </editor> <title> Ann. </title> <journal> Phys. Chem., </journal> <volume> 72 (1847), </volume> <pages> pp. 497-508. </pages>
Reference-contexts: The number of spanning trees of a graph G can be computed exactly in deterministic polynomial time <ref> [11] </ref>, but the number of perfect matchings is a #P -complete function [20]. <p> Let A be the algorithm of <ref> [11] </ref> that computes l in time M (n), where M (n) is the time to compute the determinant of an n fi n matrix.
Reference: [12] <author> D. Knuth, </author> <title> Sorting and Searching, </title> <booktitle> The Art of Computer Programming, </booktitle> <volume> vol. 3, </volume> <publisher> Addison-Wesley, </publisher> <address> Reading, </address> <year> 1973. </year> <month> - 13 </month> - 
Reference-contexts: Our examples are chosen to satisfy a variety of the definitions given in the previous section. 3.1 Bubble Sort Let H be a standard implementation of Bubble Sort, such as the one given in Knuth <ref> [12] </ref>. <p> Let M (i) P b (i)1 and M max 1in M (i): Then it is clear from the description of H given in <ref> [12] </ref> that M is a lower bound on the running time of H on input (x 1 ; x 2 ; : : : ; x n ). We use this fact to define a linear-time, deterministic, O (1)-complete timer E for (H; d). Let c 2 be a constant.
Reference: [13] <author> K. Ko, T. Long, and D. Du, </author> <title> On One-Way Functions and Polynomial-time Isomor-phisms, </title> <booktitle> Theoretical Computer Science, 47 (1986), </booktitle> <pages> pp. 263-276. </pages>
Reference-contexts: Which formal definition one should satisfy depends on the circumstances. Analogously there are different definitions of "one-way function," some useful in complexity theory <ref> [6, 13] </ref> and some in cryptography [8, 5, 7, 15, 18]. Another useful analogy can be drawn with the study of "reactive systems," such as process controllers, communication protocols, and operating systems; formal treatments of such systems always identify "safety" and "liveness" properties.
Reference: [14] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan, </author> <title> Algebraic Methods for Interactive Proof Systems, </title> <journal> Journal of the ACM, </journal> <volume> 39 (1992), </volume> <pages> pp. 859-868. </pages>
Reference-contexts: It is exactly when a timer says STOP that it has detected a "bug" of this form. Program checking was introduced with a practical motivation, but it has had a profound impact on complexity theory <ref> [14, 19, 2] </ref>. We hope that the study of timers, also motivated by practical concerns, will lead to interesting theoretical results. The next section contains our family of definitions. Section 3 gives examples of timers drawn from diverse problem areas in computer science.
Reference: [15] <author> M. Naor and M. Yung, </author> <title> Universal One-Way Hash Functions and their Cryptographic Applications, </title> <booktitle> Proc. 21st Symposium on the Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1989, </year> <pages> pp. 33-43. </pages>
Reference-contexts: Which formal definition one should satisfy depends on the circumstances. Analogously there are different definitions of "one-way function," some useful in complexity theory [6, 13] and some in cryptography <ref> [8, 5, 7, 15, 18] </ref>. Another useful analogy can be drawn with the study of "reactive systems," such as process controllers, communication protocols, and operating systems; formal treatments of such systems always identify "safety" and "liveness" properties.
Reference: [16] <author> J.R. Munkres, </author> <title> Topology: A First Course, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, </address> <year> 1975. </year>
Reference-contexts: The timer will come from a lower bound on the rate of convergence. Let F : R ! R be a continuously differentiable contraction function, with 1 &gt; c 0 jF 0 (x)j c &gt; 0, for all x 2 R. (See <ref> [16] </ref> for definitions.) Further assume that F (0) is not 0. Define H to be the following algorithm that takes F; *, and an initial point x (0) as input and computes an *-approximation to the (unique) fixed point of F . <p> That this process will converge to the fixed point of F and that this point is unique, is a well-known fixed-point theorem <ref> [16] </ref>. Now consider the following procedure E. We will show, for a certain class of functions F , that E is in fact a timer. Let d be the given deadline.
Reference: [17] <author> R. Read and R. Tarjan, </author> <title> Bounds on Backtrack Algorithms for Listing Cycles, Paths, and Spanning Trees, Networks, </title> <booktitle> 5 (1975), </booktitle> <pages> pp. 237-252. </pages>
Reference-contexts: Both the type of timer that the method yields and the meaning of "significantly" depend on the particular listing problem. Let H be any polynomial total time listing program 2 for spanning trees (e.g., the one of Read and Tarjan <ref> [17] </ref>); this means that the running time of H is poly (n; l), where n is the size of the input graph G, and l is the number of spanning trees.
Reference: [18] <author> J. Rompel, </author> <title> One-Way Functions are Necessary and Sufficient for Secure Signatures, </title> <booktitle> Proc. 22nd Symposium on the Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1990, </year> <pages> pp. 387-394. </pages>
Reference-contexts: Which formal definition one should satisfy depends on the circumstances. Analogously there are different definitions of "one-way function," some useful in complexity theory [6, 13] and some in cryptography <ref> [8, 5, 7, 15, 18] </ref>. Another useful analogy can be drawn with the study of "reactive systems," such as process controllers, communication protocols, and operating systems; formal treatments of such systems always identify "safety" and "liveness" properties.
Reference: [19] <author> A. Shamir, </author> <title> IP = PSPACE, </title> <journal> Journal of the ACM, </journal> <volume> 39 (1992), </volume> <pages> pp. 869-877. </pages>
Reference-contexts: It is exactly when a timer says STOP that it has detected a "bug" of this form. Program checking was introduced with a practical motivation, but it has had a profound impact on complexity theory <ref> [14, 19, 2] </ref>. We hope that the study of timers, also motivated by practical concerns, will lead to interesting theoretical results. The next section contains our family of definitions. Section 3 gives examples of timers drawn from diverse problem areas in computer science.
Reference: [20] <author> L. Valiant, </author> <title> The Complexity of Computing the Permanent, </title> <booktitle> Theoretical Computer Science, 8 (1979), </booktitle> <pages> pp. 189-201. </pages>
Reference-contexts: The number of spanning trees of a graph G can be computed exactly in deterministic polynomial time [11], but the number of perfect matchings is a #P -complete function <ref> [20] </ref>. A general method of building timers for listing programs is to compute (either exactly or approximately) the length l of the list S (p) and then to output STOP if and only if the estimate is significantly greater than d (jpj).
References-found: 20

