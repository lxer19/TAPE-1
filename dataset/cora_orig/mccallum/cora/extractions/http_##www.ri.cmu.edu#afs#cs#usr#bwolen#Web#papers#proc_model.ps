URL: http://www.ri.cmu.edu/afs/cs/usr/bwolen/Web/papers/proc_model.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/usr/bwolen/www/publications.html
Root-URL: 
Title: Procedure Call Models for Distributed Parameters in Data Parallel Programs  
Author: Bwolen Yang David R. O'Hallaron 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: When a computer program invokes a procedure, both the caller and the callee must agree on how to pass the parameters into and out of the procedure. In this paper, this agreement is referred to as the procedure call model. In data parallel languages like High Performance Fortran (HPF), the procedure call model for distributed parameters can have an impact on procedure call overhead. This paper introduces a taxonomy of procedure call models, and examines how different models can reduce the procedure call overhead by avoiding unnecessary redistribution and by providing compile-time distribution information. A key result is that the procedure call model bounds the availability of compile-time information on the distribution of parameters, and this information can have an impact on the quality of the redistribution code. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Blelloch, G. E., Chatterjee, S., Hard-wick, J. C., Sipelstein, J., and Zagha, M. </author> <title> Implementation of a portable nested data-parallel language. </title> <journal> Journal of Parallel and Distributed Computing 21, </journal> <month> 1 (Apr. </month> <year> 1994), </year> <pages> 4-14. </pages>
Reference-contexts: For example, some compiler systems (e.g., Sun C compilers) determine the ordering of parameters on the stack, while other systems (e.g., Borland C compilers) allow the user to specify the ordering. There is an additional complication when a data parallel program <ref> [1, 2, 4, 6, 7, 8, 10, 11] </ref> invokes a procedure: the procedure's parameters might be distributed across the nodes of the system. In general, different parameters can have different distributions, and the distribution of the same actual parameter might change from invocation to invocation.
Reference: [2] <author> Bodin, F., Beckman, P., Gannon, D., Yang, S., Kesavan, S., Malony, A., and Mohr, B. </author> <title> Implementing a parallel C++ runtime system for scalable parallel systems. </title> <booktitle> In Supercomputing '93 (Portland, </booktitle> <address> OR, </address> <month> November </month> <year> 1993), </year> <pages> pp. </pages> <month> xxx-xxx. </month>
Reference-contexts: For example, some compiler systems (e.g., Sun C compilers) determine the ordering of parameters on the stack, while other systems (e.g., Borland C compilers) allow the user to specify the ordering. There is an additional complication when a data parallel program <ref> [1, 2, 4, 6, 7, 8, 10, 11] </ref> invokes a procedure: the procedure's parameters might be distributed across the nodes of the system. In general, different parameters can have different distributions, and the distribution of the same actual parameter might change from invocation to invocation.
Reference: [3] <author> Borkar, S., Cohn, R., Cox, G., Glea-son, S., Gross, T., Kung, H. T., Lam, M., Moore, B., Peterson, C., Pieper, J., Rankin, L., Tseng, P. S., Sutton, J., Ur-banski, J., and Webb, J. </author> <title> iWarp: An integrated solution to high-speed parallel computing. </title> <booktitle> In Supercomputing '88 (Nov. </booktitle> <year> 1988), </year> <pages> pp. 330-339. </pages>
Reference-contexts: The measurements are performed on High Performance Fortran (HPF) [6] programs compiled by a parallelizing Fortran compiler [10] and running on a 64-node parallel system <ref> [3] </ref>. The results of this study make two points clear. First, for both procedure entry and return, each of the models has advantages and disadvantages; no one model is best in all cases. <p> This section examines how availability of distribution information can influence the cost of redistributing a 256K integer array on a 64-node iWarp system <ref> [3] </ref>. The redistribution code is generated by the Fx parallelizing Fortran compiler based on the algorithm in [10]. 3.1 iWarp and Fx The iWarp system is a distributed-memory multi-computer, consisting of 4 to 1024 nodes connected as a 2D torus. iWarp is characterized by direct access to programmable connections.
Reference: [4] <author> Chapman, B., Mehrotra, P., and Zima, H. </author> <title> Programming in Vienna Fortran. </title> <booktitle> Scientific Programming 1, </booktitle> <month> 1 (Aug. </month> <year> 1992), </year> <pages> 31-50. </pages>
Reference-contexts: For example, some compiler systems (e.g., Sun C compilers) determine the ordering of parameters on the stack, while other systems (e.g., Borland C compilers) allow the user to specify the ordering. There is an additional complication when a data parallel program <ref> [1, 2, 4, 6, 7, 8, 10, 11] </ref> invokes a procedure: the procedure's parameters might be distributed across the nodes of the system. In general, different parameters can have different distributions, and the distribution of the same actual parameter might change from invocation to invocation. <p> The agreement is couched in terms of some conformation rules. There are many possible kinds of conformation rules. For example, on procedure entry, the rule could require that a parameter's distribution must conform to one particular distribution, or to a small set of distributions <ref> [4] </ref>. Conformation rules can be specified explicitly by the programmer (typically by exporting the rule in a procedure interface block) or determined automatically by the compiler. <p> A common conformation rule used by compilers is that a parameter's original distribution (just before the procedure entry) must be restored when the procedure returns <ref> [4] </ref>. This rule simplifies compiler analysis on the caller side. The main advantage of the conform-on-return model is derived from availability of the compile-time distribution information and is identical to that of conform-on-entry model except the role of caller and callee are reversed. <p> Like HPF, the programmer can specify a single distribution for the conformation rule, and there is no support for either of the return models. Unlike HPF, Fx does not provide a procedure interface block, which makes it more difficult to write efficient separately-compiled library routines. Vienna Fortran <ref> [4] </ref> allows the programmer to specify either the conform-on-entry or inherit-on-entry models, but does not support either of the return models. It also allows the programmer to specify a number of interesting and potentially very useful conformation rules.
Reference: [5] <author> Gupta, S., Kaushik, S., Huang, C., and Sadayappan, P. </author> <title> On compiling array expressions for efficient execution on distributed-memory machines. </title> <type> Tech. Rep. </type> <institution> OSU-CISRC-4/94-TR19, Computer and Information Science Research Center, Ohio State University, </institution> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: For general block-cyclic distribu-tions (i.e., neither block nor cyclic distribution), the Fx compiler uses a virtual cyclic approach [9] to generate redistribution code, as opposed to a virtual block approach <ref> [5] </ref>. The virtual cyclic approach iterates over the array sections as a union of cyclic distributions, while the virtual block approach iterates as a union of block distributions. The best approach depends on the block size.
Reference: [6] <author> High Performance Fortran Forum. </author> <title> High Performance Fortran language specification, version 1.0. </title> <type> Tech. Rep. CRPC-TR92225, </type> <institution> Center for Research on Parallel Computation, Rice University, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: For example, some compiler systems (e.g., Sun C compilers) determine the ordering of parameters on the stack, while other systems (e.g., Borland C compilers) allow the user to specify the ordering. There is an additional complication when a data parallel program <ref> [1, 2, 4, 6, 7, 8, 10, 11] </ref> invokes a procedure: the procedure's parameters might be distributed across the nodes of the system. In general, different parameters can have different distributions, and the distribution of the same actual parameter might change from invocation to invocation. <p> Next, we measure the effects of factors that influence these redistribution costs, including choice of distribution and the amount of compile-time information about parameter distributions. The measurements are performed on High Performance Fortran (HPF) <ref> [6] </ref> programs compiled by a parallelizing Fortran compiler [10] and running on a 64-node parallel system [3]. The results of this study make two points clear. First, for both procedure entry and return, each of the models has advantages and disadvantages; no one model is best in all cases. <p> The former could end up to be an expensive mistake, while the latter might not be feasible if the number of choices becomes too large. 4 Procedure call models in existing data parallel systems The current specification of HPF <ref> [6] </ref> allows the programmer to choose the procedure call model on procedure entry, but not on procedure return. Both conform-on-entry and inherit-on-entry are supported.
Reference: [7] <author> Hiranandani, S., Kennedy, K., and Tseng, C. W. </author> <title> Compiling Fortran D for MIMD distributed-memory machines. </title> <type> CACM 35, </type> <month> 8 (Aug </month> <year> 1992), </year> <pages> 66-80. </pages>
Reference-contexts: For example, some compiler systems (e.g., Sun C compilers) determine the ordering of parameters on the stack, while other systems (e.g., Borland C compilers) allow the user to specify the ordering. There is an additional complication when a data parallel program <ref> [1, 2, 4, 6, 7, 8, 10, 11] </ref> invokes a procedure: the procedure's parameters might be distributed across the nodes of the system. In general, different parameters can have different distributions, and the distribution of the same actual parameter might change from invocation to invocation.
Reference: [8] <author> ISO. </author> <title> Fortran 90, </title> <month> May </month> <year> 1991. </year> <note> ISO/IEC 1539: 1991 (E) and ANSI X3.198-1192. </note>
Reference-contexts: For example, some compiler systems (e.g., Sun C compilers) determine the ordering of parameters on the stack, while other systems (e.g., Borland C compilers) allow the user to specify the ordering. There is an additional complication when a data parallel program <ref> [1, 2, 4, 6, 7, 8, 10, 11] </ref> invokes a procedure: the procedure's parameters might be distributed across the nodes of the system. In general, different parameters can have different distributions, and the distribution of the same actual parameter might change from invocation to invocation.
Reference: [9] <author> Stichnoth, J. </author> <title> Efficient compilation of array statements for private memory multicomputers. </title> <type> Tech. Rep. </type> <institution> CMU-CS-93-109, School of Computer Science, Carnegie Mellon University, </institution> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: The block distribution and the cyclic distribution are simply special cases of the block-cyclic distribution, where b = dn=pe for the block distribution, and b = 1 for the cyclic distribution. For general block-cyclic distribu-tions (i.e., neither block nor cyclic distribution), the Fx compiler uses a virtual cyclic approach <ref> [9] </ref> to generate redistribution code, as opposed to a virtual block approach [5]. The virtual cyclic approach iterates over the array sections as a union of cyclic distributions, while the virtual block approach iterates as a union of block distributions. The best approach depends on the block size.
Reference: [10] <author> Stichnoth, J., O'Hallaron, D., and Gross, T. </author> <title> Generating communication for array statements: Design, implementation, and evaluation. </title> <journal> Journal of Parallel and Distributed Computing 21, </journal> <month> 1 (Apr. </month> <year> 1994), </year> <pages> 150-159. </pages>
Reference-contexts: For example, some compiler systems (e.g., Sun C compilers) determine the ordering of parameters on the stack, while other systems (e.g., Borland C compilers) allow the user to specify the ordering. There is an additional complication when a data parallel program <ref> [1, 2, 4, 6, 7, 8, 10, 11] </ref> invokes a procedure: the procedure's parameters might be distributed across the nodes of the system. In general, different parameters can have different distributions, and the distribution of the same actual parameter might change from invocation to invocation. <p> Next, we measure the effects of factors that influence these redistribution costs, including choice of distribution and the amount of compile-time information about parameter distributions. The measurements are performed on High Performance Fortran (HPF) [6] programs compiled by a parallelizing Fortran compiler <ref> [10] </ref> and running on a 64-node parallel system [3]. The results of this study make two points clear. First, for both procedure entry and return, each of the models has advantages and disadvantages; no one model is best in all cases. <p> This section examines how availability of distribution information can influence the cost of redistributing a 256K integer array on a 64-node iWarp system [3]. The redistribution code is generated by the Fx parallelizing Fortran compiler based on the algorithm in <ref> [10] </ref>. 3.1 iWarp and Fx The iWarp system is a distributed-memory multi-computer, consisting of 4 to 1024 nodes connected as a 2D torus. iWarp is characterized by direct access to programmable connections. Connections between arbitrary nodes can be established at run-time and left up for an arbitrary amount of time. <p> Furthermore, when the procedure is written in a foreign source language like assembly (a common practice for separately compiled vendor supplied library routines), then interprocedural analysis can be very difficult if not impossible. The current implementation of the Fx compiler <ref> [10] </ref> provides directives that allow the programmer to choose either the conform model or the inherit model on entry. Like HPF, the programmer can specify a single distribution for the conformation rule, and there is no support for either of the return models.
Reference: [11] <author> Thinking Machines Corporation. </author> <title> CM Fortran Programming Guide. </title> <address> Cambridge, Mas-sachusetts, </address> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: For example, some compiler systems (e.g., Sun C compilers) determine the ordering of parameters on the stack, while other systems (e.g., Borland C compilers) allow the user to specify the ordering. There is an additional complication when a data parallel program <ref> [1, 2, 4, 6, 7, 8, 10, 11] </ref> invokes a procedure: the procedure's parameters might be distributed across the nodes of the system. In general, different parameters can have different distributions, and the distribution of the same actual parameter might change from invocation to invocation.
References-found: 11

