URL: http://www.cs.utah.edu/~machiraj/res/thesis/thesis.ps
Refering-URL: http://www.cs.utah.edu/~machiraj/res/thesis/main.html
Root-URL: 
Title: A FRAMEWORK FOR MIGRATING OBJECTS IN DISTRIBUTED GRAPHICS APPLICATIONS  
Author: by Vijay Machiraju 
Degree: A thesis submitted to the faculty of The University of Utah in partial fulfillment of the requirements for the degree of Master of Science  
Date: June 1997  
Affiliation: Department of Computer Science The University of Utah  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A.S. Tanenbaum, </author> <title> Distributed Operating Systems. Upper Saddle River, </title> <address> New Jersey 07458: </address> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference: [2] <author> M. Linton and C. Price, </author> <title> "Building Distributed User Interfaces with Fresco," </title> <booktitle> in Proc. Seventh X Technical Conference, </booktitle> <address> (Boston, </address> <publisher> Masachusetts), </publisher> <pages> pp. 77-87, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: CosLifeCycle::FactoryFinder_ptr there, const CosLifeCycle::Criteria& the_criteria); // Externalization and Internalization operations... void internalize_from_stream ( CosStream::Stream_ptr sourceStreamIO, CosLifeCycle::FactoryFinder_ptr there); void externalize_to_stream ( CosStream::Stream_ptr targetStreamIO); -; 92 typedef matrix_obj mat_1d_obj; typedef matrix_obj mat_2d_obj; class srf_obj : public attr_obj - // private data members trimming_loop_obj *trim_; mat_3d_obj *s_mesh_; tear_info_obj *t_info_; shell_obj *shell_; mat_1d_obj *s_kv_ <ref> [2] </ref>; int s_order_ [2]; ec_type s_type_ [2]; public: // member functions... -; of the hierarchy is made to inherit from fgObject, and the externalization and internalization operations are defined for each object type. <p> CosLifeCycle::Criteria& the_criteria); // Externalization and Internalization operations... void internalize_from_stream ( CosStream::Stream_ptr sourceStreamIO, CosLifeCycle::FactoryFinder_ptr there); void externalize_to_stream ( CosStream::Stream_ptr targetStreamIO); -; 92 typedef matrix_obj mat_1d_obj; typedef matrix_obj mat_2d_obj; class srf_obj : public attr_obj - // private data members trimming_loop_obj *trim_; mat_3d_obj *s_mesh_; tear_info_obj *t_info_; shell_obj *shell_; mat_1d_obj *s_kv_ <ref> [2] </ref>; int s_order_ [2]; ec_type s_type_ [2]; public: // member functions... -; of the hierarchy is made to inherit from fgObject, and the externalization and internalization operations are defined for each object type. <p> Externalization and Internalization operations... void internalize_from_stream ( CosStream::Stream_ptr sourceStreamIO, CosLifeCycle::FactoryFinder_ptr there); void externalize_to_stream ( CosStream::Stream_ptr targetStreamIO); -; 92 typedef matrix_obj mat_1d_obj; typedef matrix_obj mat_2d_obj; class srf_obj : public attr_obj - // private data members trimming_loop_obj *trim_; mat_3d_obj *s_mesh_; tear_info_obj *t_info_; shell_obj *shell_; mat_1d_obj *s_kv_ <ref> [2] </ref>; int s_order_ [2]; ec_type s_type_ [2]; public: // member functions... -; of the hierarchy is made to inherit from fgObject, and the externalization and internalization operations are defined for each object type.
Reference: [3] <author> R.M. Soley and C.M. Stone, </author> <title> The Object Management Architecture Guide. </title> <publisher> John Wiley & Sons, Inc., </publisher> <editor> third ed., </editor> <month> July </month> <year> 1995. </year>
Reference: [4] <author> Object Management Group, </author> <title> "The Common Object Request Broker: Architecture and Specification (CORBA)," </title> <month> July </month> <year> 1995. </year>
Reference: [5] <author> E. Jul, H. Levy, N. Hutchinson, and A. Black, </author> <title> "Fine-grained Mobility in the Emerald system," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 6, </volume> <pages> pp. 109-133, </pages> <month> Feb. </month> <year> 1988. </year>
Reference: [6] <author> R.J. Fowler, </author> <title> Decentralized Object Finding Using Forwarding Addresses. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <address> Seattle, </address> <month> Dec. </month> <year> 1985. </year>
Reference: [7] <author> P.Y. Chevalier, D. Hagimont, J. Mossiere, and X.R. DePine, </author> <title> "Object Migration in the Guide System," </title> <type> Tech. Rep. 101, Broadcast, </type> <year> 1995. </year>
Reference: [8] <author> S.J. Caughey, G.D. Parrington, and S.K. Shrivastava, </author> <title> "SHADOWS A Flexible Support for Objects in Distributed Systems," </title> <booktitle> in IWOOOS'93, </booktitle> <month> Dec. </month> <year> 1993. </year>
Reference: [9] <author> R.S. Chin and S.T. Chanson, </author> <title> "Distributed Object-based Programming Systems," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 23, </volume> <pages> pp. 91-124, </pages> <month> Mar. </month> <year> 1991. </year>
Reference: [10] <author> A.S. Tanenbaum and R. van Renesse, </author> <title> "Distributed Operating Systems," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 17, </volume> <pages> pp. 419-470, </pages> <month> Dec. </month> <year> 1985. </year>
Reference-contexts: Smart pointers, as defined earlier, need no further modifications to incorporate these cases. Figure 5.14 shows how smart pointers can be nested to solve this problem. class test; class different_pointers - test *p1; test **p2; test ***p3; test *p4 <ref> [10] </ref>; test **p5 [10][20]; -; // the above class is equivalent to the following class // using smart pointers class different_pointers - smartPointer&lt; test &gt; p1; smartPointer&lt; smartPointer&lt; test &gt;> p2; smartPointer&lt; smartPointer&lt; smartPointer &lt; test &gt;>> p3; smartPointer&lt; test &gt; p4 [10]; smartPointer&lt; smartPointer&lt; test &gt;> p5 [10][20]; -; CHAPTER <p> test *p1; test **p2; test ***p3; test *p4 <ref> [10] </ref>; test **p5 [10][20]; -; // the above class is equivalent to the following class // using smart pointers class different_pointers - smartPointer&lt; test &gt; p1; smartPointer&lt; smartPointer&lt; test &gt;> p2; smartPointer&lt; smartPointer&lt; smartPointer &lt; test &gt;>> p3; smartPointer&lt; test &gt; p4 [10]; smartPointer&lt; smartPointer&lt; test &gt;> p5 [10][20]; -; CHAPTER 6 CONCURRENCY CONTROL One of the ways for migrating an object, as described in Chapter 2, is replication. The replicated object and the target object share the same logical identity.
Reference: [11] <author> M. Rozier and J.L. Martins, </author> <title> Distributed Operating Systems, Theory and Practice, ch. </title> <booktitle> The CHORUS Distributed Operating System; Some Design Issues, </booktitle> <pages> pp. 262-287. </pages> <address> Berlin, Heidelberg: </address> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference: [12] <author> P. Dasgupta, R. LeBlanc, and W. Appelbe, </author> <title> "The Clouds Distributed Operating System Functional Description, Implementation Details, and Related Work," </title> <booktitle> in IEEE 8th International Conference on Distributed Computing Systems, </booktitle> <address> (San Jose), </address> <year> 1989. </year>
Reference: [13] <author> Object Management Group, </author> <title> "Common Object Services Specification, Volume 104 I," </title> <type> tech. rep., </type> <institution> Object Management Group, </institution> <year> 1994. </year>
Reference: [14] <institution> International Business Machines Corporation and SunSoft, Inc, "Object Ex-ternalization Service," </institution> <type> tech. rep., </type> <institution> Object Management Group, </institution> <year> 1994. </year>
Reference: [15] <author> B. Stroustrup, </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1991. </year>
Reference: [16] <author> H. Korth and A. Silberschatz, </author> <title> Database System Concepts. </title> <publisher> McGraw-Hill, </publisher> <year> 1986. </year>
Reference-contexts: Assuming that the data manipulated by the application resides in a database, users maintain consistency in the data by performing transactions on the database. Transactions play three distinct and important roles in maintaining the consistency of data <ref> [16] </ref>: (a) they are logical units that group together operations comprising a complete task, (b) they are atomicity units whose 76 execution preserves the consistency of the database, and (3) they are recovery units that ensure that either all the steps enclosed within them are executed or none are. <p> A schedule of transactions might not be serializable, but still satisfy application-specific consistency requirements. Some of the standard concurrency control techniques include the locking protocols (two-phase locking being the most popular), timestamp ordering, and optimistic concurrency control schemes <ref> [16] </ref>. We assume that the reader is familiar with the concepts in some of these concurrency control strategies. To clearly understand the drawbacks of these schemes when applied to graphics applications, and for the rest of the discussion in this chapter, we consider an example.
Reference: [17] <author> N.S. Barghouti and G.E. Kaiser, </author> <title> "Concurrency Control in Advanced Database Applications," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 23, </volume> <pages> pp. 269-317, </pages> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Thus all the concurrency in the design process is lost. Besides, the standard concurrency control strategies are not appropriate for design scenarios in CAD applications for several other reasons <ref> [17] </ref>: Long Transactions: Operations on objects in design environments are often long-lived. Blocking all the resources until a transaction commits would result in substantial reduction in concurrency and collaboration.
Reference: [18] <author> R.H. Katz, </author> <title> "Toward a Unified Framework for Version Modeling in Engineering Databases," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 22, </volume> <pages> pp. 375-408, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: The concurrency control scheme should support long transactions, user control, and synergistic cooperation. We start with a simple version management system to maintain consistency in the local repositories. Then we discuss the drawbacks of this scheme and propose extensions to support the required features. Version management <ref> [18] </ref> is the term used to describe the set of organizational concepts and operational mechanisms for arranging engineering design data into hierarchical aggregates that change over time.
Reference: [19] <author> N. Rahn, "BORG: </author> <title> A System for Assimilating Legacy Systems into Distributed Objects," </title> <type> Master's thesis, </type> <institution> University of Utah, </institution> <year> 1996. </year>
Reference-contexts: For example, the model constructor could save the model to a .a1 file, which can then be used by the renderer to render the model. Nicholas Rahn has provided object-oriented wrappers to these independent applications, so that each of them can make member function invocations on the other objects <ref> [19] </ref>. In this setting, the large-grain objects in Alpha 1 such as the model constructor, model viewer, and renderer will be running as CORBA servers, and any object is free to invoke methods on these objects.
References-found: 19

