URL: http://www.cs.sunysb.edu/~astiwari/mod-survey.ps
Refering-URL: http://www.cs.sunysb.edu/~astiwari/
Root-URL: http://www.cs.sunysb.edu
Email: antonis@turing.cs.ucy.ac.cy  frak,ftg@doc.ic.ac.uk  
Title: The Role of Abduction in Logic Programming  
Author: A.C. Kakas R.A. Kowalski, F. Toni 
Address: 75 Kallipoleos Street, Nicosia P.O. Box 537, Cyprus.  London SW7 2BZ, UK.  
Affiliation: Department of Computer Science, University of Cyprus,  Department of Computing, Imperial College of Science, Technology and Medicine, 180 Queen's Gate,  
Abstract: This paper is a survey and critical overview of recent work on the extension of Logic Programming to perform Abductive Reasoning (Abductive Logic Programming). It updates the earlier paper "Abductive Logic Programming" [88]. We outline the general framework of Abduction and its applications to Knowledge Assimilation and Default Reasoning; we describe the argumentation-theoretic approach to the use of abduction as an interpretation for Negation as Failure, introduced in the earlier version [88] of this paper; and we present recent work on the generalisation of the argumentation-theoretic approach to provide a framework for default reasoning in general. We also analyse the links between Abduction and Constraint Logic Programming, as well as between Abduction and the extension of Logic Programming obtained by adding a form of explicit negation. Finally we discuss the relation between Abduction and Truth Maintenance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Akama, S., </author> <title> Answer set semantics and constructive logic with strong negation. </title> <note> Technical Report (1992) </note>
Reference-contexts: For this reason we use the term "explicit negation" instead. A similar notion has been investigated by Pearce and Wagner [130], who develop an extension of definite programs by means of Nelson's strong negation. They also suggest the possibility of combining strong negation with NAF. Akama <ref> [1] </ref> argues that the semantics of this combination of strong negation with NAF is equivalent to the answer set semantics for extended logic programs developed by Gelfond and Lifschitz.
Reference: [2] <author> Alferes, J.J., Damasio, C.V., Pereira, L.M., </author> <title> Top-down query evaluation for well-founded semantics with explicit negation. </title> <booktitle> Proc. European Conference on Artificial Intelligence, </booktitle> <publisher> ECAI '94,John Wiley, </publisher> <month> Amster-dam </month> <year> (1994) </year>
Reference-contexts: Pereira and Alferes [135] and Alferes, Dung and Pereira [3] have defined new semantics for ELP that incorporates the coherence principle. These semantics are adaptations of Przymuszynski's extended stable model semantics [153] and Dung's preferred extension semantics [39], respectively, to ELP. Alferes, Damasio and Pereira <ref> [2] </ref> provide a sound and complete proof procedure for the semantics in [135].
Reference: [3] <author> Alferes, J.J., Dung, P.M., Pereira, L.M., </author> <title> Scenario semantics of extended logic programs. </title> <booktitle> Proc. 2nd International Workshop on Logic Programming and Nonmonotonic Reasoning MIT press (Pereira and Nerode eds.), </booktitle> <address> Lisbon (1993) 334-348 </address>
Reference-contexts: They consider the satisfaction of this principle to be a desirable property of any semantics for ELP, as illustrated by the following example, taken from <ref> [3] </ref>. Example 6.5 Given the extended logic program :drivers strike take bus ~ drivers strike one should derive the conclusion take bus. 76 The coherence principle automatically holds for the answer set semantics. Pereira and Alferes [135] and Alferes, Dung and Pereira [3] have defined new semantics for ELP that incorporates <p> as illustrated by the following example, taken from <ref> [3] </ref>. Example 6.5 Given the extended logic program :drivers strike take bus ~ drivers strike one should derive the conclusion take bus. 76 The coherence principle automatically holds for the answer set semantics. Pereira and Alferes [135] and Alferes, Dung and Pereira [3] have defined new semantics for ELP that incorporates the coherence principle. These semantics are adaptations of Przymuszynski's extended stable model semantics [153] and Dung's preferred extension semantics [39], respectively, to ELP. Alferes, Damasio and Pereira [2] provide a sound and complete proof procedure for the semantics in [135].
Reference: [4] <author> Alferes, J.J., Pereira, L.M., </author> <title> An argumentation-theoretic semantics based on non-refutable falsity. </title> <booktitle> Proc. International Conference on Logic Programming, MIT Press, Workshop on Non-monotonic Extensions of Logic Programming (Dix, </booktitle> <editor> Pereira, Przymusinski eds.) </editor> <address> Santa Margherita Ligure, Italy (1994) </address>
Reference-contexts: Alferes and Pereira <ref> [4] </ref> apply the argumentation-theoretic interpretation introduced in [88] to expand the well-founded model of normal and extended logic programs (see section 5). In the case of normal logic programming, their semantics gives the same result as the acceptability semantics in example 4.7. <p> Their proposal, which requires that P 0 [ be consistent with the integrity constraints 8X:[p (X) ^ p 0 (X)] for each predicate p, instead of using a separate notion of attack via explicit negation, has certain undesirable consequences, as shown in <ref> [4] </ref>. For example, the program p ~ p; ~ q admits both f~ qg and f~ pg as admissible extensions, while the only intuitively correct extension is f~ qg. Alferes and Pereira [4] use argumentation-theoretic notions to extend the well-founded semantics for ELP in [135]. <p> instead of using a separate notion of attack via explicit negation, has certain undesirable consequences, as shown in <ref> [4] </ref>. For example, the program p ~ p; ~ q admits both f~ qg and f~ pg as admissible extensions, while the only intuitively correct extension is f~ qg. Alferes and Pereira [4] use argumentation-theoretic notions to extend the well-founded semantics for ELP in [135].
Reference: [5] <author> Alferes, J.J., Pereira, L.M., </author> <title> Contradiction in logic programs: when avoidance equal removal, Parts I and II. </title> <booktitle> Proc. 4th Int. Workshop on Extensions of Logic Programming (R. </booktitle> <editor> Dyckhoff ed.), </editor> <booktitle> (1993) 7-26, Lecture Notes in AI 798, </booktitle> <publisher> Springer-Verlag </publisher>
Reference-contexts: In fact Pereira, Aparicio and Alferes have also used this method to study counterfactual reasoning [139]. Alferes and Pereira <ref> [5] </ref> have shown that this method of restoring consistency can also be viewed in terms of inconsistency avoidance. This method [137] is not able to restore consistency in all cases, as illustrated by the following example.
Reference: [6] <author> Allemand, D., Tanner, M., Bylander, T., Josephson, J., </author> <title> The computational complexity of abduction. </title> <booktitle> Artificial Intelligence 49 (1991) 25-60 </booktitle>
Reference-contexts: However, the abductive task is tractable for certain more restricted classes of logic programs (see for example [52]). There are other formalisations of abduction. We mention them for completeness, but in the sequel we will concentrate on the logic-based view previously described. * Allemand, Tanner, Bylander and Josephson <ref> [6] </ref> and Reggia [155] present a mathematical characterisation, where abduction is defined over sets of observations and hypotheses, in terms of coverings and parsimony. * Levesque [117] gives an account of abduction at the "knowledge level".
Reference: [7] <author> Apt, K.R., Bezem, M., </author> <title> Acyclic programs. </title> <booktitle> Proc. 7th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Jerusalem (1990) 579-597 </address>
Reference-contexts: The abductive task for the logic-based approach has been proved to be highly intractable: it is NP-hard even if T is a set of acyclic <ref> [7] </ref> propositional definite clauses [174, 48], and is even harder if T is a set of any propositional clauses [48]. These complexity results hold even if explanations are not required to be minimal. <p> In addition, for each integrity constraint, a probability value is assigned to each abducible, so that the sum of all the 13 values of all the abducibles in each integrity constraint is 1. If the abductive framework satisfies certain assumptions, e.g. T is acyclic <ref> [7] </ref>, the bodies of all the clauses defining each non-abducible atom are mutually exclusive and these clauses are "covering", and abducibles in A are "probabilistically independent", then such a probabilistic Horn abduction theory can be mapped onto a (discrete) Bayesian network and vice versa. 2 Knowledge Assimilation Abduction takes place in <p> In con trast, all natural representations of the problem in Theorist give incorrect results. As Eshghi and Kowalski [53], Evans [55] and Apt and Bezem <ref> [7] </ref> observe, the Yale shooting problem has the form of a logic program, and interpreting negation in the problem as negation as failure yields only the correct result. This is the case for both the semantics and the proof theory of LP.
Reference: [8] <author> Aravindan, C., Dung, </author> <title> P.M., Belief dynamics, abduction and databases. </title> <booktitle> Proc. 4th European Workshop on Logics in AI, (1994), To appear in Lecture Notes in AI, </booktitle> <publisher> Springer Verlag 94 </publisher>
Reference-contexts: This notion has been used to study the evolution of databases by means of updates [86]. It should be noted that the use of abduction to perform belief revision in the view update case also allows results which are not unique, as illustrated in example 2.3. Aravindan and Dung <ref> [8] </ref> have given an abductive characterisation of rational belief revision and have applied this result to formulate belief revision postulates for the view update problem. 18 A logic-based theory of the assimilation of new information has also been developed in the Relevance Theory of Sperber and Wilson [178] with special attention
Reference: [9] <author> Baral, C., Gelfond, M., </author> <title> Logic programming and knowledge representa-tion. </title> <note> To appear in Journal of Logic Programming (1994) </note>
Reference-contexts: The knowledge representation problem in ALP is complicated by the need to decide whether information should be represented as part of the program, as an integrity constraint, or as an observation to be explained, as illustrated by the following example taken from <ref> [9] </ref>.
Reference: [10] <author> Barbuti, R., Mancarella, P., Pedreschi, D., Turini, F., </author> <title> A transformational approach to negation in logic programming. </title> <note> Journal of Logic Programming 8 (1990) 201-228 </note>
Reference: [11] <author> Bondarenko, A., Toni, F., Kowalski, R. A., </author> <title> An assumption-based framework for non-monotonic reasoning. </title> <booktitle> Proc. 2nd International Workshop on Logic Programming and Nonmonotonic Reasoning MIT press (Pereira and Nerode eds.), </booktitle> <address> Lisbon (1993) 171-189 </address>
Reference-contexts: This can be done, without this last clause, explicitly in the ELP framework with priorities of [99] (section 6.4) or in the rules and exceptions approach [112] (section 6.3). An argumentation-theoretic interpretation for ELP has also been proposed by Bondarenko, Toni and Kowalski <ref> [11] </ref>. Their proposal, which requires that P 0 [ be consistent with the integrity constraints 8X:[p (X) ^ p 0 (X)] for each predicate p, instead of using a separate notion of attack via explicit negation, has certain undesirable consequences, as shown in [4]. <p> Dung shows that many problems from such different areas as AI, game theory and economics can be formulated and studied within this argumentation-theoretic framework. Bondarenko, Toni and Kowalski <ref> [11] </ref> modified Dung's notion of an abstract argumentation-theoretic framework by defining an argument to be a monotonic derivation from a set of abductive assumptions. This new framework, like that of [87], can be understood as a natural abstraction and extension of the Theorist framework in two respects. <p> Kakas, Mancarella and Dung define a notion of attack between conflicting sets of sentences, but these can be any subtheories of a given theory, rather than being subtheories drawn from a pre-assigned set of assumption sentences as in <ref> [11, 12] </ref>. Also as in the special case of LP (see section 4.3) this notion of attack together with the acceptability semantics ensures that defences are genuine counterattacks, i.e. that they do not at the same time attack the theory that we are trying to construct.
Reference: [12] <author> Bondarenko, A., Dung, P.M., Kowalski, R. A., Toni, F., </author> <title> An abstract, argumentation-theoretic framework for default reasoning. </title> <note> In draft (1995) </note>
Reference-contexts: We follow the approach of Bondarenko, Dung, Kowalski and Toni <ref> [12] </ref> (see also [87]). Let T be a set of sentences in any monotonic logic, ` the provability operator for that logic and A a set of candidate abducible sentences. For any ff 2 A, let ff be some sentence that represents the "contrary" of ff. <p> Kakas, Mancarella and Dung define a notion of attack between conflicting sets of sentences, but these can be any subtheories of a given theory, rather than being subtheories drawn from a pre-assigned set of assumption sentences as in <ref> [11, 12] </ref>. Also as in the special case of LP (see section 4.3) this notion of attack together with the acceptability semantics ensures that defences are genuine counterattacks, i.e. that they do not at the same time attack the theory that we are trying to construct.
Reference: [13] <author> Brewka, G., </author> <title> Preferred subtheories: an extended logical framework for default reasoning. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1043-1048 </address>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [13, 22, 61, 77, 143, 148, 180] </ref>. Cox and Pietrzykowski [29] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not 6 be explainable in terms of other explanations.
Reference: [14] <author> Brewka, G., </author> <title> An abductive framework for generalised logic programs. </title> <booktitle> Proc. 2nd International Workshop on Logic Programming and Non-monotonic Reasoning MIT press (Pereira and Nerode eds.), </booktitle> <address> Lisbon (1993) 349-364 </address>
Reference-contexts: An abductive semantics of NAF without disjunctive integrity constraints has been proposed by Dung [39] (see section 4.3 below). The abductive proof procedure is sound with respect to this improved semantics. 34 An alternative abductive semantics of NAF without disjunctive integrity con-straints has been proposed by Brewka <ref> [14] </ref>, following ideas presented in [104]. He suggests that the set which includes both accepted and refuted NAF hypotheses be maximised. <p> This semantics generalises the semantics for LP given in <ref> [14] </ref>. 8 Abduction and Truth Maintenance In this section we will consider the relationship between truth maintenance (TM) and abduction. TM systems have historically been presented from a procedural point of view.
Reference: [15] <author> Brewka, G., Konolige, K., </author> <title> An abductive framework for general logic programs and other non-monotonic systems. </title> <booktitle> Proc. 13th International Joint Conference on Artificial Intelligence, </booktitle> <address> Chambery, France (1993) 9-15 </address>
Reference-contexts: More generally, this approach provides a framework for default reasoning with priorities on sentences of a theory, viewed as default rules. It also provides a framework for restoring consistency in a theory T by using the acceptable subsets of T (see sections 6.2 and 6.3). 84 Brewka and Konolige <ref> [15] </ref> also propose an abductive framework which unifies and provides new semantics for LP, autoepistemic logic and default logic, but does not use argumentation-theoretic notions.
Reference: [16] <author> A. Brogi, E. Lamma, P. Mello, P. Mancarella, </author> <title> Normal logic programs as open positive programs. </title> <booktitle> Proc. ICSLP '92 (1992) </booktitle>
Reference-contexts: Stationary expansions [154] are equivalent to complete extensions, as shown in <ref> [16] </ref>. Moreover, Dung shows that the well-founded model [187] is the smallest complete extension that can be constructed bottom-up from the empty set of negative hypotheses, by adding incrementally all admissible hypotheses. Thus the well-founded semantics is minimalist and sceptical, whereas the preferred extension semantics is maximalist and credulous.
Reference: [17] <author> Bry, F., </author> <title> Intensional updates: abduction via deduction. </title> <booktitle> Proc. 7th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Jerusalem (1990) 561-575 </address>
Reference-contexts: The assimilation of a new datum can be performed by adding to the theory new hypotheses that are explanations for the datum. Knowledge assimilation can also be viewed as the general context within which abduction takes place. Database view updates <ref> [17, 91, 28] </ref> are an important special case of knowledge assimilation. Update requests are interpreted as observations to be explained. The explanations of the observations are transactions that satisfy the update request. Another important application which can be understood in terms of a "noncausal" use of abduction is default reasoning.
Reference: [18] <author> Burchert, H.-J., </author> <title> A resolution principle for constrained logics. </title> <booktitle> Artificial Intelligence 66 (1994) 235-271 95 </booktitle>
Reference-contexts: This framework has been developed further by Fung [60] and has been applied to job-shop scheduling by Toni [184]. A related proposal, to include user-defined constraint handling rules within a CLP framework, has been made by Fruhwirth [75]. Burchert <ref> [18] </ref> and Burchert and Nutt [19], on the other hand, define a framework for general clausal resolution and show how abduction without integrity constraints can be treated as a special case of constrained resolution.
Reference: [19] <author> Burchert, H.-J., Nutt, W., </author> <title> On abduction and answer generation through constraint resolution. </title> <type> Technical Report DFKI, </type> <address> Kaiserslautern (1991) </address>
Reference-contexts: This framework has been developed further by Fung [60] and has been applied to job-shop scheduling by Toni [184]. A related proposal, to include user-defined constraint handling rules within a CLP framework, has been made by Fruhwirth [75]. Burchert [18] and Burchert and Nutt <ref> [19] </ref>, on the other hand, define a framework for general clausal resolution and show how abduction without integrity constraints can be treated as a special case of constrained resolution. Another approach, which integrates both frameworks while preserving their identity, has been developed by Kakas and Michael [101].
Reference: [20] <author> Casamayor, J., Decker, H., </author> <title> Some proof procedures for computational first-order theories, with an abductive flavour to them. </title> <booktitle> Proc. 1st Compulog-Net Workshop on Logic Programming in Artificial Intelligence, </booktitle> <institution> Imperial College, </institution> <address> London (1992) </address>
Reference-contexts: Their extension modifies the integrity checking method of [165] and deals more generally with arbitrary integrity constraints expressed in the form of denials. Casamayor and Decker <ref> [20] </ref> also develop an abductive proof procedure for NAF. Their proposal combines features of the Eshghi-Kowalski procedure with ancestor resolution.
Reference: [21] <author> Chan, D., </author> <title> Constructive negation based on the completed database. </title> <booktitle> Proc. 5th International Conference and Symposium on Logic Programming, </booktitle> <address> Washington, Seattle (1988) 111-125 </address>
Reference: [22] <author> Charniak, E., McDermott, D., </author> <title> Introduction to artificial intelligence. </title> <publisher> (Addison-Wesley, </publisher> <address> Menlo Park, Ca,1985) </address>
Reference-contexts: Abduction is widely used in common-sense reasoning, for instance in diagnosis, to reason from effect to cause <ref> [22, 142] </ref>. <p> They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [13, 22, 61, 77, 143, 148, 180] </ref>. Cox and Pietrzykowski [29] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not 6 be explainable in terms of other explanations. <p> Abduction can be used to perform high level vision [29]. The hypotheses are the objects to be recognised, and the observations are partial descriptions of objects. Abduction can be used in natural language understanding to interpret ambiguous sentences <ref> [22, 62, 78, 179] </ref>. The abductive explanations correspond to the various possible interpretations of such sentences. 12 In planning problems, plans can be viewed as explanations of the given goal state to be reached [50, 176].
Reference: [23] <author> Chen, W., Warren, </author> <title> D.S., Abductive logic programming. </title> <type> Technical Report Dept. </type> <institution> of Comp. Science, State Univ. of New York at Stony Brook (1989) </institution>
Reference-contexts: A logic program where each literal L i in the body of every clause is atomic is said to be definite. Abduction can be computed in LP by extending SLD and SLDNF <ref> [23, 53, 54, 91, 94, 34, 181] </ref>. Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. <p> This assumption has the advantage that all explanations are thereby guaranteed to be basic. Semantics and proof procedures for ALP have been proposed by Eshghi and Kowalski [53], Kakas and Mancarella [90] and Chen and Warren <ref> [23] </ref>. Chen and Warren extend the perfect model semantics of Przymusinski [152] to include abducibles and integrity constraints over abducibles.
Reference: [24] <author> Clark,K.L., </author> <title> Negation as failure. Logic and Data Bases, </title> <editor> Gallaire and Minker eds., </editor> <publisher> Plenum, </publisher> <address> New York(1978) 293-322 </address>
Reference-contexts: Resolution-based techniques for computing abduction have also been developed by Demolombe and Fari~nas del Cerro [31] and Gaifman and Shapiro [64]. Abduction can also be applied to logic programming (LP). A (general) logic program is a set of Horn clauses extended by negation as failure <ref> [24] </ref>, i.e. clauses of the form: A L 1 ; : : : ; L n where each L i is either an atom A i or its negation ~ A i 1 , A is an atom and each variable occurring in the clause is implicitly universally quantified. <p> iff KB [ is consistent: Alternatively the theoremhood view requires that: KB satisfies iff KB j= : These definitions have been proposed in the case where the theory is a logic program P by Kowalski and Sadri [165] and Lloyd and Topor [118] respectively, where KB is the Clark completion <ref> [24] </ref> of P . Another view of integrity constraints [85, 90, 107, 160, 161] regards these as epistemic or metalevel statements about the content of the database. In this case the integrity constraints are understood as statements at a different level from those in the knowledge base. <p> Default reasoning can also be performed with the use of negation as failure 25 (NAF) <ref> [24] </ref> in general logic programs. NAF provides a natural and power-ful mechanism for performing non-monotonic and default reasoning. As we have already mentioned, it provides a simple solution to the Yale shooting problem. <p> An alternative approach is presented by Console, Dupre and Torasso [26]. Here clauses of programs are interpreted as if-halves of if-and-only-if definitions that are obtained from the completion of the program <ref> [24] </ref> restricted to non-abducible predicates. Abductive hypotheses are generated deductively by replacing atoms by their definitions, starting from the observation to be explained. <p> In the more general case of non-propositional abductive logic programs, the Clark equality theory CET <ref> [24] </ref>, is used; the notion that F is more specific than F 0 requires that F ! F 0 be a logical consequence of CET and that F 0 ! F not be a consequence of CET. The explanation formula is unique up to equivalence with respect to CET.
Reference: [25] <author> Console, L., Theseider Dupre, D., Torasso, P. </author> <title> A Theory for diagnosis for incomplete causal models. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1311-1317 </address>
Reference-contexts: In general, abduction is appropriate for reasoning with incomplete information. The generation of abducibles to solve a top-level goal can be viewed as the addition of new information to make incomplete information more complete. Abduction can be used to generate causal explanations for fault diagnosis (see for example <ref> [25, 151] </ref>). In medical diagnosis, for example, the candidate hypotheses are the possible causes (diseases), and the observations are the symptoms to be explained [146, 155]. Abduction can also be used for model-based diagnosis [51, 159].
Reference: [26] <author> Console, L., Theseider Dupre, D., Torasso, P. </author> <title> On the relationship between abduction and deduction. </title> <note> Journal of Logic and Computation 2(5) (1991) 661-690 </note>
Reference-contexts: An alternative approach is presented by Console, Dupre and Torasso <ref> [26] </ref>. Here clauses of programs are interpreted as if-halves of if-and-only-if definitions that are obtained from the completion of the program [24] restricted to non-abducible predicates. Abductive hypotheses are generated deductively by replacing atoms by their definitions, starting from the observation to be explained. <p> Abduction is performed by means of deduction in the style of <ref> [26] </ref> (see section 5.6). This framework has been developed further by Fung [60] and has been applied to job-shop scheduling by Toni [184]. A related proposal, to include user-defined constraint handling rules within a CLP framework, has been made by Fruhwirth [75].
Reference: [27] <author> Console, L., Saitta, L., </author> <title> Abduction, induction and inverse resolution. </title> <booktitle> Proc. 1st Compulog-Net Workshop on Logic Programming in Artificial Intelligence, </booktitle> <institution> Imperial College, </institution> <address> London (1992) </address>
Reference-contexts: In particular, additional restrictions on are needed to distinguish abductive explanations from inductive generalisations <ref> [27] </ref>. Moreover, we also need to restrict so that it conveys some reason why the observations hold, e.g. we do not want to explain one effect in terms of another effect, but only in terms of some cause.
Reference: [28] <author> Console, L., Sapino, M.L., Theseider Dupre, D., </author> <title> The role of abduction in database view updating. </title> <note> To appear in Journal of Intelligent Information Systems (1994) 96 </note>
Reference-contexts: The assimilation of a new datum can be performed by adding to the theory new hypotheses that are explanations for the datum. Knowledge assimilation can also be viewed as the general context within which abduction takes place. Database view updates <ref> [17, 91, 28] </ref> are an important special case of knowledge assimilation. Update requests are interpreted as observations to be explained. The explanations of the observations are transactions that satisfy the update request. Another important application which can be understood in terms of a "noncausal" use of abduction is default reasoning.
Reference: [29] <author> Cox, P. T., Pietrzykowski, T., </author> <title> Causes for events: their computation and applications. </title> <booktitle> Proc. 8th International Conference on Automated Deduction, CADE '86 (1992) 608-621 </booktitle>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations [13, 22, 61, 77, 143, 148, 180]. Cox and Pietrzykowski <ref> [29] </ref> identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not 6 be explainable in terms of other explanations. For instance, in example 1.1 the explanation fgrass-is-wetg for the observation shoes-are-wet is not basic, whereas the alternative explanations frained-last-nightg fsprinkler-was-ong are. <p> Various authors have suggested the use of top-down, goal-oriented computation, based on the use of deduction to drive the generation of abductive hypotheses. Cox and Pietrzykowski <ref> [29] </ref> construct hypotheses from the "dead ends" of linear resolution proofs. Finger and Genesereth [57] generate "deductive solutions to design problems" using the "residue" left behind in resolution proofs. <p> Abduction can be used to perform high level vision <ref> [29] </ref>. The hypotheses are the objects to be recognised, and the observations are partial descriptions of objects. Abduction can be used in natural language understanding to interpret ambiguous sentences [22, 62, 78, 179].
Reference: [30] <author> Decker, H., </author> <title> Integrity enforcement on deductive databases. </title> <booktitle> Proc. EDS '86, </booktitle> <address> Charleston, SC (1986) 271-285 </address>
Reference-contexts: For each such semantics, we have a specification of the integrity checking problem. Although the different views of integrity satisfaction are conceptually very different, the integrity checking procedures based upon these views are not very different in practice (e.g. <ref> [30, 165, 118] </ref>).
Reference: [31] <author> Demolombe, R., Fari~nas del Cerro, L., </author> <title> An inference rule for hypotheses generation. </title> <booktitle> Proc. 12th International Joint Conference on Artificial Intelligence, </booktitle> <address> Sidney (1991) 152-157 </address>
Reference-contexts: The ATMS can be regarded as a form of hyper-resolution, augmented with subsumption, for propositional logic programs [162]. Lamma and Mello [115] have developed an extension of the ATMS for the non-propositional case. Resolution-based techniques for computing abduction have also been developed by Demolombe and Fari~nas del Cerro <ref> [31] </ref> and Gaifman and Shapiro [64]. Abduction can also be applied to logic programming (LP).
Reference: [32] <author> Denecker, M., De Schreye, D., </author> <title> Temporal reasoning with abductive event calculus. </title> <booktitle> Proc. 1st Compulog-Net Workshop on Logic Programming in Artificial Intelligence, </booktitle> <institution> Imperial College, </institution> <address> London (1992) </address>
Reference: [33] <author> Denecker, M., De Schreye, D., </author> <title> On the duality of abduction and model generation. </title> <booktitle> Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1992) 650-657 </address>
Reference-contexts: The explanation formula is unique up to equivalence with respect to CET. The proof procedure is extended to take into account the equality theory CET. Denecker and De Schreye <ref> [33] </ref> compare the search space obtained by reasoning backward using the if-half of the if-and-only-if form of a definite program with that obtained by reasoning forward using the only-if-half.
Reference: [34] <author> Denecker, M., De Schreye, D., SLDNFA: </author> <title> an abductive procedure for normal abductive programs. </title> <booktitle> Proc. International Conference and Symposium on Logic Programming, </booktitle> <year> (1992) </year> <month> 686-700 </month>
Reference-contexts: A logic program where each literal L i in the body of every clause is atomic is said to be definite. Abduction can be computed in LP by extending SLD and SLDNF <ref> [23, 53, 54, 91, 94, 34, 181] </ref>. Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. <p> The problem of constructive abduction has also been studied within the completion semantics. Denecker and De Schreye <ref> [34] </ref> define a proof procedure for constructive abduction, SLDNFA, which they show is sound and complete. Teusink [181] extends Drabent's [38] procedure, SLDNA, for constructive 66 negation to perform constructive abduction and uses three-valued semantics to show soundness and completeness. In both proposals, [34] and [181], integrity constraints are dealt with <p> Denecker and De Schreye <ref> [34] </ref> define a proof procedure for constructive abduction, SLDNFA, which they show is sound and complete. Teusink [181] extends Drabent's [38] procedure, SLDNA, for constructive 66 negation to perform constructive abduction and uses three-valued semantics to show soundness and completeness. In both proposals, [34] and [181], integrity constraints are dealt with by means of a transformation, rather than explicitly. 6 Extended Logic Programming Extended Logic Programming (ELP) extends general LP by allowing, in addition to NAF, a second, explicit form of negation.
Reference: [35] <author> Denecker, M., De Schreye, D., </author> <title> Representing incomplete knowledge in abductive logic programming. </title> <booktitle> Proc. </booktitle> <address> ILSP'93, Vancouver (1993) </address>
Reference-contexts: Therefore, instances of persists should be abduced unless some integrity constraint is violated. Indeed, in standard formulations of the persistence axiom the positive atom persists (T 1 ; P; T 2 ) is replaced by a negative literal ~ clipped (T 1 ; P; T 2 ) <ref> [176, 35] </ref>. In contrast, the abduction of happens is used for non-default hypothetical reasoning. The distinction between default reasoning and non-default abduction is also made in Konolige's proposal [103], which combines abduction for non-default hypothetical reasoning with default logic [158] for default reasoning. <p> In the last case, the observation is assimilated by adding the explanation fbird (tweety)g to the program, and therefore has beak (tweety) is derived in the resulting generalised stable model. Thus, the last two alternatives have similar effects. Denecker and DeSchreye <ref> [35] </ref> argue that the second alternative is especially appropriate for knowledge representation in the temporal reasoning domain. 5.2 An abductive proof procedure for ALP In [91, 92, 93], a proof procedure is given to compute abductive explanations in ALP.
Reference: [36] <author> Doyle, J., </author> <title> A truth maintenance system. </title> <booktitle> Artificial Intelligence 12 (1979) 231-272 </booktitle>
Reference-contexts: some of the non abdicible predicates can also be undefined. 5.4 Computation of abduction through TMS Satoh and Iwayama [170] present a method for computing generalised stable models for logic programs with integrity constraints represented as denials. 55 The method is a bottom-up computation based upon the TMS procedure of <ref> [36] </ref>. Although the computation is not goal-directed, goals (or queries) can be represented as denials and be treated as integrity constraints. <p> The semantics of a TM system can accordingly be understood in terms of the semantics of the corresponding propositional logic program with abducibles and integrity constraints. The two most popular systems are the justification-based TM system (JTMS) of Doyle <ref> [36] </ref> and the assumption-based TM system (ATMS) of deKleer [102]. 8.1 Justification-based truth maintenance A justification in a JTMS can be written in the form p p 1 ; : : : ; p n ; ~ p n+1 ; : : : ; ~ p m ; expressing that p
Reference: [37] <author> Doyle, J., </author> <title> Rational belief revision. </title> <booktitle> Proc. 2nd International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> Cambridge, Mass. </address> <year> (1991) </year> <month> 163-174 </month>
Reference-contexts: Both of these updates satisfy the integrity constraints. However, only the first update satisfies the integrity constraints if we are given the further update insert mother (sue; bob): The general problem of belief revision has been studied formally in <ref> [65, 128, 129, 37] </ref>. <p> These axioms ensure that there is always a unique way of performing belief revision. However Doyle <ref> [37] </ref> argues that, for applications in AI, this uniqueness property is too strong. He proposes instead the notion of "economic rationality", in which the revised sets of beliefs are optimal, but not necessarily unique, with respect to a set of preference criteria on the possible beliefs states. <p> We have seen that the process of belief revision also needs to be considered within a KA context. In particular, it could be useful to investigate relationships between the belief revision frameworks of <ref> [37, 65, 128, 129] </ref> and various integrity constraint checking and restoration procedures. The extension of LP to include integrity constraints is useful both for abduc-tive LP and for deductive databases.
Reference: [38] <author> Drabent, W., </author> <title> What is failure? An approach to constructive negation. </title> <note> To appear in Acta Informatica (1994) </note>
Reference-contexts: The problem of constructive abduction has also been studied within the completion semantics. Denecker and De Schreye [34] define a proof procedure for constructive abduction, SLDNFA, which they show is sound and complete. Teusink [181] extends Drabent's <ref> [38] </ref> procedure, SLDNA, for constructive 66 negation to perform constructive abduction and uses three-valued semantics to show soundness and completeness.
Reference: [39] <author> Dung, </author> <title> P.M., Negation as hypothesis: an abductive foundation for logic programming Proc. </title> <booktitle> 8th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Paris (1991) 3-17 97 </address>
Reference-contexts: We will describe this procedure in some detail as it also serves as the basis for computing abductive explanations more generally within logic programming with other abducibles and integrity constraints (see section 5). In this section we will refer to the version of the abductive proof procedure presented in <ref> [39] </ref>. 9 9 As noticed by Dung [39], the procedure presented in [54] contains a mistake, which is 29 The abductive proof procedure interleaves two types of computation. <p> In this section we will refer to the version of the abductive proof procedure presented in <ref> [39] </ref>. 9 9 As noticed by Dung [39], the procedure presented in [54] contains a mistake, which is 29 The abductive proof procedure interleaves two types of computation. <p> So, as Eshghi and Kowalski [54] show by means of this example, the abduc-tive proof procedure is not always sound with respect to the above abductive semantics of NAF. In fact, following the result in <ref> [39] </ref>, it can be proved that the proof procedure is sound for the class of order-consistent logic programs defined by Sato [168]. Intuitively, this is the class of programs which do not contain clauses giving rise to odd-step loops via NAF. <p> They relax this requirement and consider partial or three-valued stable models instead. In the context of the abductive semantics of NAF this is an argument against the disjunctive integrity constraints. An abductive semantics of NAF without disjunctive integrity constraints has been proposed by Dung <ref> [39] </ref> (see section 4.3 below). The abductive proof procedure is sound with respect to this improved semantics. 34 An alternative abductive semantics of NAF without disjunctive integrity con-straints has been proposed by Brewka [14], following ideas presented in [104]. <p> An alternative three-valued semantics for NAF has been proposed by Gior-dano, Martelli and Sapino [72]. According to their semantics, given the program p p p and p fl are both undefined. In contrast, p fl holds in the semantics of <ref> [39] </ref>, as well as in the stable model [68] and well-founded semantics [187]. Giordano, Martelli and Sapino [72] modify the abductive proof procedure so that the modification is sound and complete with respect to their semantics. <p> Finally, we note that, to show that ~ p holds for programs such as p p, it is possible to define a non-effective extension of the proof procedure, that allows infinite failure in the consistency phases. 35 4.3 An argumentation-theoretic interpretation Dung <ref> [39] </ref> replaces the disjunctive integrity constraints by a weaker requirement similar to the requirement that that the set of negative hypotheses be a maximally consistent set. Unfortunately, simply replacing the disjunctive integrity constraints by maximality does not work, as shown in the following example. <p> In <ref> [39] </ref> a consistent set of hypotheses (not necessarily maximal) satisfying the property of containing its own defence against all attacks is said to be admissible (to P fl ). <p> Kakas and Mancarella [95] show that it is equivalent to Sacca and Zaniolo's partial stable model semantics [164]. Like the partial stable model semantics, it includes the stable model semantics as a special case. Dung <ref> [39] </ref> also defines the notion of complete extension. <p> Note that here the condition "P fl [ is consistent with I fl " of the definition of preferred extensions and admissible sets of hypotheses is subsumed by the new condition. This is a consequence of another difference between [96, 97] and <ref> [39] </ref>, namely that for each attack E against the counter-attack is required to be against E rather than against E. In other words, the defence of must be a genuine attack that does not at the same time also attack . <p> Pereira and Alferes [135] and Alferes, Dung and Pereira [3] have defined new semantics for ELP that incorporates the coherence principle. These semantics are adaptations of Przymuszynski's extended stable model semantics [153] and Dung's preferred extension semantics <ref> [39] </ref>, respectively, to ELP. Alferes, Damasio and Pereira [2] provide a sound and complete proof procedure for the semantics in [135]. <p> We have seen, in particular, that a proof procedure which is incorrect under one semantics (e.g. [54]) can be correct under another improved semantics (e.g. <ref> [39] </ref>). We have also introduced an argumentation-theoretic interpretation for the semantics of abduction applied to NAF, and we have seen that this interpretation can help to understand the relationships between different semantics.
Reference: [40] <author> Dung, </author> <title> P.M., An abductive foundation for non-monotonic truth main-tenance. </title> <booktitle> Proc. 1st World Conference on Fundamentals of Artificial Intelligence, Paris, </booktitle> <editor> de Glas ed. </editor> <year> (1991) </year>
Reference-contexts: The JTMS can also be understood in terms of abduction using the abduc-tive approach to the semantics of NAF, as shown in <ref> [40, 71, 92] </ref>. This has the advantage that the nogoods of the JTMS can be interpreted as integrity constraints of the abductive framework.
Reference: [41] <author> Dung, </author> <title> P.M., Acyclic disjunctive logic programs with abductive procedure as proof procedure. </title> <booktitle> Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1992) 555-561 </address>
Reference-contexts: Whereas the transformation of [167] deals with inclusive disjunction, Dung <ref> [41] </ref> presents a simpler transformation that deals with exclusive disjunction, but works only for the case of acyclic programs.
Reference: [42] <author> Dung, </author> <title> P.M., An abductive procedure for disjunctive logic programming. </title> <type> Technical Report Dept. </type> <institution> of Computing, Asian Institute of Technology (1992) </institution>
Reference-contexts: For example, the clause p _ q can be replaced by the two clauses p ~ q With this transformation, for acyclic programs, the Eshghi-Kowalski procedure presented in section 4.2 is sound. For the more general case, Dung <ref> [42] </ref> represents disjunction explicitly and extends the Eshghi-Kowalski procedure by using resolution-based techniques similar to those employed in [57]. 62 5.6 Abduction through deduction from the comple- tion In the approaches presented so far, hypotheses are generated by backward reasoning with the clauses of logic programs used as inference rules.
Reference: [43] <author> Dung, </author> <title> P.M., </title> <type> Personal Communication (1992) </type>
Reference-contexts: Thus, the stable theories are those which are maximally acceptable to ;, where acceptability is defined by this approximation to the recursive definition. A related argumentation-theoretic interpretation for the semantics of NAF in LP has also been developed by Geffner [67]. This interpretation is equivalent to the well-founded semantics <ref> [43] </ref>.
Reference: [44] <author> Dung, </author> <title> P.M., On the acceptability of arguments and its fundamental role in nonmonotonic reasoning and logic programming. </title> <booktitle> To appear in Artificial Intelligence (1994) (Extended Abstract in Proc. International Joint Conference on Artificial Intelligence, </booktitle> <year> (1993), </year> <pages> 852-859) </pages>
Reference-contexts: In particular, he showed how default logic can be understood in such terms and proposed 81 a default reasoning framework based on the argumentation-theoretic accept-ability semantics (see section 4.3) as an alternative to default logic. Dung <ref> [44] </ref> proposed an abstraction of the argumentation-theoretic interpretation of NAF introduced in [88], where arguments and the notion of one argument attacking another are treated as primitive concepts which can be superimposed upon any monotonic logic and can even be introduced into non-linguistic contexts.
Reference: [45] <author> Dung, </author> <title> P.M., An argumentation semantics for logic programming with explicit negation. </title> <booktitle> Proc. 10th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Budapest (1993) </address>
Reference-contexts: A set of hypotheses is KM-admissible if * for every attack E against , attacks (E ) via NAF alone. In section 6.5 we will see that the notion of KM-admissible set of hypotheses is similar to the notion of admissibility proposed by Dung <ref> [45] </ref> for extended logic programming, in that only attacks via NAF are allowed to counterattack. 16 Recall that the abductive proof procedure for ALP employs the restriction that each integrity constraint contains at least one literal with an abducible predicate. 54 The argumentation-theoretic interpretation of ALP suggests several ways in which <p> This reduction automatically provides us with an argumentation-theoretic interpretation of ELP, where attacks via these integrity constraints become attacks via explicit negation. Such notions of attack via explicit negation have been defined by Dung <ref> [45] </ref> and Kakas, Mancarella and Dung [99]. <p> However, the resulting semantics might give unwanted results, as illustrated by the following example given in <ref> [45] </ref>. <p> Therefore, fab bird fl (tweety)g counterattacks all attacks against it, and is admissible. As a consequence, f ly (tweety) holds in the extension given by fab bird fl (tweety)g. However, intuitively f ly (tweety) should hold in no extension. To cope with this problem, Dung <ref> [45] </ref> suggests the following semantics, while keeping the definition of attack unchanged. A set of hypotheses is D-admissible if * does not attack itself, either via explicit negation or via NAF, and * for every attack E against , either via explicit negation or via NAF, attacks E via NAF.
Reference: [46] <author> Dung, P.M., Ruamviboonsuk, P., </author> <title> Well-founded reasoning with classical negation. </title> <booktitle> Proc. 1st International Workshop on Logic Programming and Nonmonotonic Reasoning (Nerode, </booktitle> <editor> Marek and Subrahmanian eds.), </editor> <address> Washington DC (1991) 120-135 </address>
Reference-contexts: In the example above we can restore consistency by rejecting the NAF assumption ~ bird (tom) even though bird (tom) does not hold. We then get the consistent set fbat (tom); f ly (tom)g. This problem has been studied in <ref> [46] </ref> and [137]. Both of these studies are primarily concerned with the related problem of inconsistency of the well-founded semantics when applied to extended logic programs [153]. To deal with the problem of inconsistency in extended logic programs, Dung and Ruamviboonsuk [46] apply the preferred extension semantics to a new abductive <p> This problem has been studied in <ref> [46] </ref> and [137]. Both of these studies are primarily concerned with the related problem of inconsistency of the well-founded semantics when applied to extended logic programs [153]. To deal with the problem of inconsistency in extended logic programs, Dung and Ruamviboonsuk [46] apply the preferred extension semantics to a new abductive framework derived from an extended logic program. An extended logic program P is first transformed into an ordinary general logic program P 0 by renaming explicitly negated literals : p (t) by positive literals p 0 (t). <p> For the program in example 6.2, the method in [134] restores consistency by letting p undefined, while the method in [140] restores consistency by assigning p to truth. This second method is more suitable for diagnosis applications. Both methods, <ref> [46] </ref> and [137, 134, 140], can deal only with inconsistencies that can be attributed to NAF hypotheses, as shown by the following example. <p> Alferes, Damasio and Pereira [2] provide a sound and complete proof procedure for the semantics in [135]. The proof procedure is implemented in Prolog by means of an appropriate transformation from ELP to general LP. 6.5 An argumentation-theoretic approach to ELP The Dung and Ruamviboonsuk semantics for ELP <ref> [46] </ref> in effect reduces ELP to ALP by renaming the explicit negation :p of a predicate p to a new predicate p 0 and employing integrity constraints 8X:[p (X) ^ p 0 (X)] for all predicates p in the program.
Reference: [47] <author> Dung, P.M., Kakas, A.C., Mancarella, P., </author> <title> Negation as failure revisited. </title> <note> Technical Report (1992) </note>
Reference-contexts: Thus the well-founded semantics is minimalist and sceptical, whereas the preferred extension semantics is maximalist and credulous. The relationship between these two semantics is further investigated in <ref> [47] </ref>, where 37 the well-founded model and preferred extensions are shown to correspond to the least fixed point and greatest fixed point, respectively, of the same operator. Kakas and Mancarella [96, 97] propose an improvement of the preferred extension semantics. Their proposal can be illustrated by the following example.
Reference: [48] <author> Eiter, T., Gottlob, G., </author> <title> The complexity of logic-based abduction. </title> <booktitle> Proc. 10th Symposium on Theoretical Aspects of Computing (STACS-93), Springer Verlag lecture Notes on Computer Science 665, </booktitle> <editor> eds. Enjalbert, P., Finkel, A., Wagner, </editor> <address> K.W. </address> <note> (1993) 70-79 (Extended paper to appear in Journal of the ACM) </note>
Reference-contexts: The abductive task for the logic-based approach has been proved to be highly intractable: it is NP-hard even if T is a set of acyclic [7] propositional definite clauses <ref> [174, 48] </ref>, and is even harder if T is a set of any propositional clauses [48]. These complexity results hold even if explanations are not required to be minimal. However, the abductive task is tractable for certain more restricted classes of logic programs (see for example [52]). <p> The abductive task for the logic-based approach has been proved to be highly intractable: it is NP-hard even if T is a set of acyclic [7] propositional definite clauses [174, 48], and is even harder if T is a set of any propositional clauses <ref> [48] </ref>. These complexity results hold even if explanations are not required to be minimal. However, the abductive task is tractable for certain more restricted classes of logic programs (see for example [52]). There are other formalisations of abduction.
Reference: [49] <author> Elkan, C., </author> <title> A rational reconstruction of non-monotonic truth maintenance systems. </title> <booktitle> Artificial Intelligence 43 (1990) 219-234 98 </booktitle>
Reference-contexts: Several authors have observed that the JTMS can be given a semantics corresponding to the semantics of logic programs, by interpreting justifications as propositional logic program clauses, and interpreting ~ p i as NAF of p i . The papers <ref> [49, 71, 92, 141] </ref>, in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. <p> The papers [49, 71, 92, 141], in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. Several authors <ref> [49, 59, 92, 156] </ref>, exploiting the interpretation of stable models as autoepistemic expansions [68], have shown a correspondence between well-founded labellings and stable expansions of the set of justifications viewed as autoepistemic theories.
Reference: [50] <author> Eshghi, K., </author> <title> Abductive planning with event calculus. </title> <booktitle> Proc. 5th Interna--tional Conference and Symposium on Logic Programming, </booktitle> <address> Washington, Seattle (1988) 562-579 </address>
Reference-contexts: Abduction can be used in natural language understanding to interpret ambiguous sentences [22, 62, 78, 179]. The abductive explanations correspond to the various possible interpretations of such sentences. 12 In planning problems, plans can be viewed as explanations of the given goal state to be reached <ref> [50, 176] </ref>. These applications of abduction can all be understood as generating hypotheses which are causes for observations which are effects. An application that does not necessarily have a direct causal interpretation is knowledge assimilation [94, 105, 114, 125], described in greater detail below. <p> information that a property holds at a particular time point can be assimilated by adding an explanation in terms of the happening of some event that initiates this property at an earlier point of time together with an appropriate assumption that the property persists from one time to the other <ref> [50, 89, 176, 186] </ref>. This has the additional effect that the new KB will imply that the property holds until it is terminated in the future by the happening of some event [176]. <p> Constraints can also be simplified, replacing, for example, 2 &lt; t ^ 3 &lt; t 3 &lt; t: Such simplification is less common in abductive frameworks. A number of proposals have been made recently to unify the treatment of abducibles and constraints. Several of these, <ref> [50, 176, 120, 100] </ref> in particular, have investigated the implementation of specialised constraint satisfaction and simplification algorithms of CLP (specifically for inequality) by means of general-purpose integrity checking methods applied to domain-specific integrity constraints as in the case of ALP. 65 Kowalski [109] proposes a general framework which attempts to unify <p> A procedure for performing constructive abduction within a framework that treats equality as an abducible predicate and the Clark equality theory as a set of integrity constraint was first proposed by Eshghi <ref> [50] </ref>. Building upon this proposal, Kakas and Mancarella [98] extend the abductive proof procedure for LP in [54] (see section 4.2) to combine constructive negation with constructive abduction in a uniform way, by reducing the former to the latter using the abductive interpretation of NAF.
Reference: [51] <author> Eshghi, K., </author> <title> Diagnoses as stable models. </title> <booktitle> Proc. 1st International Workshop on Principles of Diagnosis, </booktitle> <address> Menlo Park, Ca (1990) </address>
Reference-contexts: Abduction can be used to generate causal explanations for fault diagnosis (see for example [25, 151]). In medical diagnosis, for example, the candidate hypotheses are the possible causes (diseases), and the observations are the symptoms to be explained [146, 155]. Abduction can also be used for model-based diagnosis <ref> [51, 159] </ref>. In this case the theory describes the "normal" behaviour of the system, and the task is to find a set of hypotheses of the form "some component A is not normal" that explains why the behaviour of the system is not normal.
Reference: [52] <author> Eshghi, K., </author> <title> A tractable set of abduction problems. </title> <booktitle> Proc. 13th International Joint Conference on Artificial Intelligence, </booktitle> <address> Chambery, France (1993) 3-8 </address>
Reference-contexts: These complexity results hold even if explanations are not required to be minimal. However, the abductive task is tractable for certain more restricted classes of logic programs (see for example <ref> [52] </ref>). There are other formalisations of abduction.
Reference: [53] <author> Eshghi, K., Kowalski, R.A., </author> <title> Abduction through deduction. </title> <institution> Technical Report Department of Computing, Imperial College, </institution> <address> London (1988) </address>
Reference-contexts: A logic program where each literal L i in the body of every clause is atomic is said to be definite. Abduction can be computed in LP by extending SLD and SLDNF <ref> [23, 53, 54, 91, 94, 34, 181] </ref>. Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. <p> Default reasoning concerns the use of general rules to derive information in the absence of contradictions. In the application of abduction to default reasoning, conclusions are viewed as observations to be explained by means of assumptions which hold by default unless a contradiction can be shown <ref> [53, 145] </ref>. As Poole [145] argues, the use of abduction avoids the need to develop a non-classical, non-monotonic logic for default reasoning. In section 3 we will further discuss the use of abduction for default reasoning in greater detail. <p> In con trast, all natural representations of the problem in Theorist give incorrect results. As Eshghi and Kowalski <ref> [53] </ref>, Evans [55] and Apt and Bezem [7] observe, the Yale shooting problem has the form of a logic program, and interpreting negation in the problem as negation as failure yields only the correct result. This is the case for both the semantics and the proof theory of LP. Moreover, [53] <p> <ref> [53] </ref>, Evans [55] and Apt and Bezem [7] observe, the Yale shooting problem has the form of a logic program, and interpreting negation in the problem as negation as failure yields only the correct result. This is the case for both the semantics and the proof theory of LP. Moreover, [53] and [89] show how to retain the correct result when negation as failure is interpreted as a form of abduction. <p> This example can be regarded as an instance of that transformation. 26 4.1 Logic programs as abductive frameworks The similarity between abduction and NAF can be used to give an abductive interpretation of NAF. This interpretation was presented in <ref> [53] </ref> and [54], where negative literals are interpreted as abductive hypotheses that can be assumed to hold provided that, together with the program, they satisfy a canonical set of integrity constraints. <p> This assumption has the advantage that all explanations are thereby guaranteed to be basic. Semantics and proof procedures for ALP have been proposed by Eshghi and Kowalski <ref> [53] </ref>, Kakas and Mancarella [90] and Chen and Warren [23]. Chen and Warren extend the perfect model semantics of Przymusinski [152] to include abducibles and integrity constraints over abducibles.
Reference: [54] <author> Eshghi, K., Kowalski, R.A., </author> <title> Abduction compared with negation by failure. </title> <booktitle> Proc. 6th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Lisbon (1989) 234-255 </address>
Reference-contexts: A logic program where each literal L i in the body of every clause is atomic is said to be definite. Abduction can be computed in LP by extending SLD and SLDNF <ref> [23, 53, 54, 91, 94, 34, 181] </ref>. Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. <p> In [165] this assumption is exploited by reasoning forward from the updates. This idea is exploited for the purpose of checking the satisfaction of abductive hypotheses in <ref> [54, 93, 94] </ref>. Although this procedure was originally formulated for the consistency view of constraint satisfaction, it has proved equally appropriate for the semantics of integrity constraints in abductive logic programming. 1.3 Applications In this section we briefly describe some of the applications of abduction in AI. <p> This example can be regarded as an instance of that transformation. 26 4.1 Logic programs as abductive frameworks The similarity between abduction and NAF can be used to give an abductive interpretation of NAF. This interpretation was presented in [53] and <ref> [54] </ref>, where negative literals are interpreted as abductive hypotheses that can be assumed to hold provided that, together with the program, they satisfy a canonical set of integrity constraints. <p> we define the meaning of the integrity constraints I fl as follows: An extension P fl [ (which is a Horn theory) of P fl satisfies I fl if and only if for every variable-free atom p, P fl [ 6j= p ^ p fl ; and Eshghi and Kowalski <ref> [54] </ref> show that there is a one to one correspondence between stable models [68] of P and abductive extensions of P fl . We recall the definition of stable model: Let P be a general logic program, and assume that all the clauses in P are variable-free 8 . <p> The Theorist framework of [145, 150] provides such an implementation of abduction by means of a resolution based proof procedure. In their study of NAF through abduction Eshghi and Kowalski <ref> [54] </ref> have defined an abductive proof procedure for NAF in logic programming. We will describe this procedure in some detail as it also serves as the basis for computing abductive explanations more generally within logic programming with other abducibles and integrity constraints (see section 5). <p> In this section we will refer to the version of the abductive proof procedure presented in [39]. 9 9 As noticed by Dung [39], the procedure presented in <ref> [54] </ref> contains a mistake, which is 29 The abductive proof procedure interleaves two types of computation. <p> In general, whenever a hypothesis is tested for integrity, we can add the hypothesis to either at the beginning or at the end of the consistency phase. When this addition is done at the beginning (as originally defined in <ref> [54] </ref>) this extra information can be used in any subordinate abductive phase. In this example, the hypothesis p fl is used in the subordinate abductive proof of q to justify the failure of q fl and consequently to render p fl acceptable. <p> The abductive proof procedure succeeds with the explanation fq fl g, but the only set of hypotheses which satisfies the integrity constraints is fp fl g. So, as Eshghi and Kowalski <ref> [54] </ref> show by means of this example, the abduc-tive proof procedure is not always sound with respect to the above abductive semantics of NAF. <p> Giordano, Martelli and Sapino [72] modify the abductive proof procedure so that the modification is sound and complete with respect to their semantics. Satoh and Iwayama [171], on the other hand, show how to extend the abduc-tive proof procedure of <ref> [54] </ref> to deal correctly with the stable model semantics. Their extension modifies the integrity checking method of [165] and deals more generally with arbitrary integrity constraints expressed in the form of denials. Casamayor and Decker [20] also develop an abductive proof procedure for NAF. <p> In the original abductive proof procedure of <ref> [54] </ref>, hypotheses in defences are always added to . However, in the proof procedure for the acceptability semantics defences D can not always be added to , because even though D might be acceptable to , [ D might not be acceptable to ;. <p> The definitions of admissible, stable and acceptable sets of hypotheses all require that every attack against be counterattacked. Although every su-perset of an attack is also an attack, the abductive proof procedure in <ref> [54] </ref> only considers those "minimal" attacks generated by SLD, 12 without examining superset attacks. This is possible because all supersets of an attack can be counterattacked in exactly the same way as the attack itself, which is generated by SLD. For this reason, the proof procedure of [54] is sound for <p> proof procedure in <ref> [54] </ref> only considers those "minimal" attacks generated by SLD, 12 without examining superset attacks. This is possible because all supersets of an attack can be counterattacked in exactly the same way as the attack itself, which is generated by SLD. For this reason, the proof procedure of [54] is sound for the admissibility semantics. Unfortunately, supersets of attacks need to be considered to guarantee soundness of the proof procedure for the acceptability semantics. In [182], however, Toni and Kakas prove that only certain supersets of "minimally generated" attacks need to be considered. <p> This extends the abductive proof procedure for NAF <ref> [54] </ref> described in section 4.2, retaining the basic structure which interleaves an abductive phase that generates and collects abductive hypotheses with a consistency phase that incrementally checks these hypotheses for integrity. We will illustrate these extended proof procedure by means of examples. Example 5.5 Consider again example 4.2. <p> A procedure for performing constructive abduction within a framework that treats equality as an abducible predicate and the Clark equality theory as a set of integrity constraint was first proposed by Eshghi [50]. Building upon this proposal, Kakas and Mancarella [98] extend the abductive proof procedure for LP in <ref> [54] </ref> (see section 4.2) to combine constructive negation with constructive abduction in a uniform way, by reducing the former to the latter using the abductive interpretation of NAF. The problem of constructive abduction has also been studied within the completion semantics. <p> We have seen the importance of clarifying the semantics of abduction and of defining a semantics that helps to unify the different forms of abduction, NAF, and default reasoning within a common framework. We have seen, in particular, that a proof procedure which is incorrect under one semantics (e.g. <ref> [54] </ref>) can be correct under another improved semantics (e.g. [39]). We have also introduced an argumentation-theoretic interpretation for the semantics of abduction applied to NAF, and we have seen that this interpretation can help to understand the relationships between different semantics.
Reference: [55] <author> Evans, </author> <title> C.A., Negation as failure as an approach to the Hanks and McDermott problem. </title> <booktitle> Proc. 2nd International Symposium on Artificial intelligence, Monterrey, </booktitle> <address> Mexico (1989) </address>
Reference-contexts: In con trast, all natural representations of the problem in Theorist give incorrect results. As Eshghi and Kowalski [53], Evans <ref> [55] </ref> and Apt and Bezem [7] observe, the Yale shooting problem has the form of a logic program, and interpreting negation in the problem as negation as failure yields only the correct result. This is the case for both the semantics and the proof theory of LP.
Reference: [56] <author> Evans, </author> <title> C.A., Kakas, A.C., </title> <booktitle> Hypothetico-deductive reasoning. Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1992) 546-554 </address>
Reference-contexts: For example Sattar and Goebel [173] use "crucial literals" to discriminate between two mutually incompatible explanations. When the crucial literals are tested, one of the explanations is rejected. More generally Evans and Kakas <ref> [56] </ref> use the notion of corroboration to select explanations. An explanation fails to be corroborated if some of its logical consequences are not observed.
Reference: [57] <author> Finger, J.J., Genesereth, </author> <title> M.R., RESIDUE: a deductive approach to design synthesis. </title> <type> Technical Report no. </type> <institution> CS-85-1035, Stanford University (1985) </institution>
Reference-contexts: Various authors have suggested the use of top-down, goal-oriented computation, based on the use of deduction to drive the generation of abductive hypotheses. Cox and Pietrzykowski [29] construct hypotheses from the "dead ends" of linear resolution proofs. Finger and Genesereth <ref> [57] </ref> generate "deductive solutions to design problems" using the "residue" left behind in resolution proofs. Poole, Goebel and Aleliunas [150] also use linear resolution to generate hypotheses. 7 In contrast, the ATMS [102] computes abductive explanations bottom-up. <p> For the more general case, Dung [42] represents disjunction explicitly and extends the Eshghi-Kowalski procedure by using resolution-based techniques similar to those employed in <ref> [57] </ref>. 62 5.6 Abduction through deduction from the comple- tion In the approaches presented so far, hypotheses are generated by backward reasoning with the clauses of logic programs used as inference rules. An alternative approach is presented by Console, Dupre and Torasso [26].
Reference: [58] <author> Fujita, M., Hasegawa, R., </author> <title> A model generation theorem prover in KL1 using a ramified-stack algorithm. </title> <booktitle> Proc. 8th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Paris (1991) 535-548 </address>
Reference-contexts: where a is abducible, into DLP clauses (p ^ a) _ a 0 q where a 0 is a new atom that stands for the complement of a, as expressed by the integrity constraint : (a ^ a 0 ): (3) A model generation theorem-prover (such as SATCHMO or MGTP <ref> [58] </ref>) can then be applied to compute all the minimal models that satisfy the integrity constraints (3). This transformation is related to a similar transformation [82] for eliminating NAF. Elsewhere [167], Sakama and Inoue demonstrate a one-to-one correspondence between generalised stable models for ALP and possible models [166] for DLP.
Reference: [59] <author> Fujiwara, Y., Honiden, S., </author> <title> Relating the TMS to Autoepistemic Logic. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1199-1205 </address>
Reference-contexts: The papers [49, 71, 92, 141], in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. Several authors <ref> [49, 59, 92, 156] </ref>, exploiting the interpretation of stable models as autoepistemic expansions [68], have shown a correspondence between well-founded labellings and stable expansions of the set of justifications viewed as autoepistemic theories.
Reference: [60] <author> Fung, T. H., </author> <title> Theorem proving approach with constraint handling and its applications on databases. </title> <type> MSc Thesis, </type> <institution> Imperial College, </institution> <address> London (1993) </address>
Reference-contexts: Abduction is performed by means of deduction in the style of [26] (see section 5.6). This framework has been developed further by Fung <ref> [60] </ref> and has been applied to job-shop scheduling by Toni [184]. A related proposal, to include user-defined constraint handling rules within a CLP framework, has been made by Fruhwirth [75].
Reference: [61] <author> Gabbay, </author> <title> D.M., Abduction in labelled deductive systems. A conceptual abstract. </title> <booktitle> Proc. of the European Conference on Symbolic and Quantitative Approaches for uncertainty '91, Springer Verlag lecture Notes on Computer Science 548, </booktitle> <editor> eds. R. Kruse and P. </editor> <address> Siegel (1991) 3-12 </address>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [13, 22, 61, 77, 143, 148, 180] </ref>. Cox and Pietrzykowski [29] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not 6 be explainable in terms of other explanations.
Reference: [62] <author> Gabbay, </author> <title> D.M., Kempson, R.M., Labelled abduction and relevance reasoning. Workshop on Non-Standard Queries and Non-Standard Answers, </title> <address> Toulose, France (1991) </address>
Reference-contexts: Abduction can be used to perform high level vision [29]. The hypotheses are the objects to be recognised, and the observations are partial descriptions of objects. Abduction can be used in natural language understanding to interpret ambiguous sentences <ref> [22, 62, 78, 179] </ref>. The abductive explanations correspond to the various possible interpretations of such sentences. 12 In planning problems, plans can be viewed as explanations of the given goal state to be reached [50, 176].
Reference: [63] <editor> Gabbay, D.M., Kempson, R.M., Pitts, J., </editor> <title> Labelled abduction and relevance reasoning. Non-standard queries and answers, </title> <editor> R.Demolombe and T. Imielinski, eds., </editor> <publisher> Oxford University press (1994) 155-185 </publisher>
Reference-contexts: Gabbay, Kempson and Pitts <ref> [63] </ref> have investigated how abductive reasoning and relevance theory can be integrated to choose between different abductive interpretations of a natural language discourse. KA and belief revision are also related to truth maintenance systems.
Reference: [64] <author> Gaifman, H., Shapiro, E., </author> <title> Proof theory and semantics of logic programming. </title> <booktitle> Proc. LICS'89, </booktitle> <publisher> IEEE Computer Society Press (1989) 50-62 </publisher>
Reference-contexts: Lamma and Mello [115] have developed an extension of the ATMS for the non-propositional case. Resolution-based techniques for computing abduction have also been developed by Demolombe and Fari~nas del Cerro [31] and Gaifman and Shapiro <ref> [64] </ref>. Abduction can also be applied to logic programming (LP).
Reference: [65] <author> Gardenfors, P., </author> <title> Knowledge in flux: modeling the dynamics of epistemic states. </title> <publisher> (MIT Press, </publisher> <address> Cambridge, Ma,1988) </address>
Reference-contexts: Both of these updates satisfy the integrity constraints. However, only the first update satisfies the integrity constraints if we are given the further update insert mother (sue; bob): The general problem of belief revision has been studied formally in <ref> [65, 128, 129, 37] </ref>. <p> We have seen that the process of belief revision also needs to be considered within a KA context. In particular, it could be useful to investigate relationships between the belief revision frameworks of <ref> [37, 65, 128, 129] </ref> and various integrity constraint checking and restoration procedures. The extension of LP to include integrity constraints is useful both for abduc-tive LP and for deductive databases.
Reference: [66] <author> Geffner, H., </author> <title> Casual theories for non-monotonic reasoning. </title> <booktitle> Proc. AAAI '90 (1990) </booktitle>
Reference-contexts: Example 6.3 It is not possible to restore consistency by removing NAF hypotheses given the program: p 71 However, Inoue [81, 80] suggests a general method for restoring consistency, which is applicable to this case. This method (see also section 6.3) is based on <ref> [66] </ref> and [145] and consists in isolating inconsistencies by finding maximally consistent subprograms. In this approach a knowledge system is represented by a pair (P; H), where: 1. P and H are both extended logic programs, 2. P represents a set of facts, 3. H represents a set of assumptions. <p> However, this approach can be extended, as we shall see in section 6.6. More direct approaches to the problem of treating positive and negative predicates symmetrically in default reasoning are presented in [81, 80], following the methods of <ref> [66] </ref> and [145] (see section 6.2 for a discussion), and in [87, 99], based on an argumentation-theoretic framework (see sections 6.4 and 7). 74 6.4 (Extended) Logic Programming without Nega- tion as Failure Kakas, Mancarella and Dung [99] show that the Kowalski-Sadri transformation presented in section 6.3 can be applied in
Reference: [67] <author> Geffner, H., </author> <title> Beyond negation as failure. </title> <booktitle> Proc. 2nd International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> Cambridge, Mass. </address> <year> (1991) </year> <month> 218-229 </month>
Reference-contexts: Thus, the stable theories are those which are maximally acceptable to ;, where acceptability is defined by this approximation to the recursive definition. A related argumentation-theoretic interpretation for the semantics of NAF in LP has also been developed by Geffner <ref> [67] </ref>. This interpretation is equivalent to the well-founded semantics [43].
Reference: [68] <author> Gelfond, M., Lifschitz, V., </author> <title> The Stable model semantics for logic programs. </title> <booktitle> Proc. 5th International Conference and Symposium on Logic Programming, </booktitle> <address> Washington, Seattle (1988) 1070-1080 </address>
Reference-contexts: extension P fl [ (which is a Horn theory) of P fl satisfies I fl if and only if for every variable-free atom p, P fl [ 6j= p ^ p fl ; and Eshghi and Kowalski [54] show that there is a one to one correspondence between stable models <ref> [68] </ref> of P and abductive extensions of P fl . We recall the definition of stable model: Let P be a general logic program, and assume that all the clauses in P are variable-free 8 . <p> An alternative three-valued semantics for NAF has been proposed by Gior-dano, Martelli and Sapino [72]. According to their semantics, given the program p p p and p fl are both undefined. In contrast, p fl holds in the semantics of [39], as well as in the stable model <ref> [68] </ref> and well-founded semantics [187]. Giordano, Martelli and Sapino [72] modify the abductive proof procedure so that the modification is sound and complete with respect to their semantics. <p> The papers [49, 71, 92, 141], in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. Several authors [49, 59, 92, 156], exploiting the interpretation of stable models as autoepistemic expansions <ref> [68] </ref>, have shown a correspondence between well-founded labellings and stable expansions of the set of justifications viewed as autoepistemic theories. The JTMS can also be understood in terms of abduction using the abduc-tive approach to the semantics of NAF, as shown in [40, 71, 92].
Reference: [69] <author> Gelfond, M., Lifschitz, V., </author> <title> Logic programs with classical negation. </title> <booktitle> Proc. 7th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Jerusalem (1990) 579-597 </address>
Reference-contexts: For open predicates it is possible to extend logic programs to allow explicit negation in the conclusions of clauses. In this section we will discuss the extension proposed by Gelfond and Lifschitz <ref> [69] </ref>. This extension is based on the stable model semantics, and can be understood, therefore, in terms of 67 abduction, as we have already seen. <p> This negation denoted by ":" is called "classical negation" in <ref> [69] </ref>. However, as we will see below, because the contrapositives of extended clauses do not hold, the term "classical negation" can be regarded as inappropriate. For this reason we use the term "explicit negation" instead. <p> The corresponding answer sets of P contain explicit negative literals : p (t) wherever the stable models contain p 0 (t). In <ref> [69] </ref> the answer sets are defined directly on the extended program by modifying the definition of the stable model semantics.
Reference: [70] <author> Goebel, R., Furukawa, K., Poole, D., </author> <title> Using definite clauses and integrity constraints as the basis for a theory formation approach to diagnostic reasoning. </title> <booktitle> Proc. 3rd International Conference on Logic Programming, </booktitle> <publisher> MIT Press, London (1986) Springer Verlag Lecture Notes in Computer Science 225, </publisher> <pages> 211-222 100 </pages>
Reference-contexts: An alternative way of viewing abduction, which emphasises the defeasibil-ity of abducibles, is retractability <ref> [70] </ref>. Instead of regarding abducibles as atoms to be consistently added to a theory, they can be considered as assertions in the theory to be retracted in the presence of contradictions until consistency (or integrity) is restored (c.f. section 6.2).
Reference: [71] <author> Giordano, L., Martelli, A., </author> <title> Generalized stable model semantics, truth maintenance and conflict resolution. </title> <booktitle> Proc. 7th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Jerusalem (1990) 427-411 </address>
Reference-contexts: Several authors have observed that the JTMS can be given a semantics corresponding to the semantics of logic programs, by interpreting justifications as propositional logic program clauses, and interpreting ~ p i as NAF of p i . The papers <ref> [49, 71, 92, 141] </ref>, in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. <p> The JTMS can also be understood in terms of abduction using the abduc-tive approach to the semantics of NAF, as shown in <ref> [40, 71, 92] </ref>. This has the advantage that the nogoods of the JTMS can be interpreted as integrity constraints of the abductive framework.
Reference: [72] <author> Giordano, L., Martelli, A., Sapino, M. L., </author> <title> A semantics for Eshghi and Kowalski's abductive procedure. </title> <booktitle> Proc. 10th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Budapest (1993) 586-600 </address>
Reference-contexts: Moreover, this semantics has other undesirable consequences. For example, the program p ~ p; ~ q admits both f~ qg and f~ pg as "models", while the only intuitively correct "model" is f~ qg. An alternative three-valued semantics for NAF has been proposed by Gior-dano, Martelli and Sapino <ref> [72] </ref>. According to their semantics, given the program p p p and p fl are both undefined. In contrast, p fl holds in the semantics of [39], as well as in the stable model [68] and well-founded semantics [187]. Giordano, Martelli and Sapino [72] modify the abductive proof procedure so that <p> been proposed by Gior-dano, Martelli and Sapino <ref> [72] </ref>. According to their semantics, given the program p p p and p fl are both undefined. In contrast, p fl holds in the semantics of [39], as well as in the stable model [68] and well-founded semantics [187]. Giordano, Martelli and Sapino [72] modify the abductive proof procedure so that the modification is sound and complete with respect to their semantics. Satoh and Iwayama [171], on the other hand, show how to extend the abduc-tive proof procedure of [54] to deal correctly with the stable model semantics.
Reference: [73] <author> Hanks, S., McDermott, D., </author> <title> Default reasoning, non-monotonic logics, and the frame problem. </title> <booktitle> Proc. 8th AAAI '86, </booktitle> <address> Philadelphia (1986) 328-333 </address>
Reference-contexts: But, more importantly, there are still other examples where the Theorist approach arguably gives the wrong result. The most important of these is the now notorious Yale shooting problem of <ref> [73, 74] </ref>.
Reference: [74] <author> Hanks, S., McDermott, D., </author> <title> Non-monotonic logics and temporal projection. </title> <booktitle> Artificial Intelligence 33 (1987) </booktitle>
Reference-contexts: But, more importantly, there are still other examples where the Theorist approach arguably gives the wrong result. The most important of these is the now notorious Yale shooting problem of <ref> [73, 74] </ref>.
Reference: [75] <author> Fruhwirth, T., </author> <title> Constraint simplification rules. </title> <note> Technical Report ECRC-92-18 (1992) </note>
Reference-contexts: This framework has been developed further by Fung [60] and has been applied to job-shop scheduling by Toni [184]. A related proposal, to include user-defined constraint handling rules within a CLP framework, has been made by Fruhwirth <ref> [75] </ref>. Burchert [18] and Burchert and Nutt [19], on the other hand, define a framework for general clausal resolution and show how abduction without integrity constraints can be treated as a special case of constrained resolution.
Reference: [76] <author> Hasegawa, R., Fujita, M., </author> <title> Parallel theorem provers and their applications. </title> <booktitle> Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1992) 132-154 </address>
Reference-contexts: M 1 = ; and M 2 = fa; pg are the generalised stable models of hP; A; Ii. The program can be transformed into a disjunctive logic program P D p a 19 A description of this work can also be found in <ref> [76] </ref>. 61 P D has possible models M 0 1 = f*g, M 0 3 = f*; a; pg, such that M 0 2 f*g = M 0 Conversely, [167] shows how to transform DLP programs into ALP.
Reference: [77] <author> Hobbs, J.R., Stickel, M., Appelt, D., Martin, P., </author> <title> Interpretation as abduction. </title> <type> Technical Report 499, </type> <institution> Artificial Intelligence Center, Computing and Engineering Sciences Division, </institution> <address> Menlo Park, Ca (1990) </address>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [13, 22, 61, 77, 143, 148, 180] </ref>. Cox and Pietrzykowski [29] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not 6 be explainable in terms of other explanations.
Reference: [78] <author> Hobbs, J.R., </author> <title> An integrated abductive framework for discourse interpretation. </title> <booktitle> Proc. AAAI Symposium on Automated Abduction, </booktitle> <address> Stanford (1990) 10-12 </address>
Reference-contexts: Abduction can be used to perform high level vision [29]. The hypotheses are the objects to be recognised, and the observations are partial descriptions of objects. Abduction can be used in natural language understanding to interpret ambiguous sentences <ref> [22, 62, 78, 179] </ref>. The abductive explanations correspond to the various possible interpretations of such sentences. 12 In planning problems, plans can be viewed as explanations of the given goal state to be reached [50, 176].
Reference: [79] <author> Inoue, K., </author> <title> An abductive procedure for the CMS/ATMS. </title> <booktitle> Proc. Eu-ropean Conference on Artificial Intelligence, ECAI '90 International Workshop on Truth Maintenance, Stockholm, Springer Verlag Lecture notes in Computer Science (1990) </booktitle>
Reference-contexts: This abductive interpretation of ATMS has been developed further by Inoue <ref> [79] </ref>, who gives an abductive proof procedure for the ATMS.
Reference: [80] <author> Inoue, K., </author> <title> Extended logic programs with default assumptions. </title> <booktitle> Proc. 8th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Paris (1991) 490-504 </address>
Reference-contexts: Both methods, [46] and [137, 134, 140], can deal only with inconsistencies that can be attributed to NAF hypotheses, as shown by the following example. Example 6.3 It is not possible to restore consistency by removing NAF hypotheses given the program: p 71 However, Inoue <ref> [81, 80] </ref> suggests a general method for restoring consistency, which is applicable to this case. This method (see also section 6.3) is based on [66] and [145] and consists in isolating inconsistencies by finding maximally consistent subprograms. <p> This is not entirely adequate for a proper treatment of exceptions to exceptions. However, this approach can be extended, as we shall see in section 6.6. More direct approaches to the problem of treating positive and negative predicates symmetrically in default reasoning are presented in <ref> [81, 80] </ref>, following the methods of [66] and [145] (see section 6.2 for a discussion), and in [87, 99], based on an argumentation-theoretic framework (see sections 6.4 and 7). 74 6.4 (Extended) Logic Programming without Nega- tion as Failure Kakas, Mancarella and Dung [99] show that the Kowalski-Sadri transformation presented in <p> However it is worth noting that any other semantics of extended logic programs could also be used. For example Inoue <ref> [81, 80] </ref> uses an extension of the answer set semantics (see section 6.2), but for a slightly different transformation. 80 6.7 ELP with abduction Inoue [80] (see also section 6.3) and Pereira, Aparicio and Alferes [136] investigate extended logic programs with abducibles but without integrity constraints. <p> However it is worth noting that any other semantics of extended logic programs could also be used. For example Inoue [81, 80] uses an extension of the answer set semantics (see section 6.2), but for a slightly different transformation. 80 6.7 ELP with abduction Inoue <ref> [80] </ref> (see also section 6.3) and Pereira, Aparicio and Alferes [136] investigate extended logic programs with abducibles but without integrity constraints. They transform such programs into extended logic programs without abduction by adding a new pair of clauses p (X) ~ : p (X) for each abducible predicate p. <p> Notice that the transformation is identical to that of Satoh and Iwayama [170] presented in section 5.5, except for the use of explicit negation instead of new predicates. Inoue <ref> [80] </ref> and Pereira, Aparicio and Alferes [136] assign different semantics to the resulting program. Whereas Inoue applies the answer set semantics, Pereira, Aparicio and Alferes apply the extended stable model semantics of [153]. Pereira, Aparicio and Alferes [138] have also developed proof procedures for this semantics.
Reference: [81] <author> Inoue, K., </author> <title> Hypothetical reasoning in logic programs. </title> <note> Journal of Logic Programming 18 (1994) 191-227 </note>
Reference-contexts: Both methods, [46] and [137, 134, 140], can deal only with inconsistencies that can be attributed to NAF hypotheses, as shown by the following example. Example 6.3 It is not possible to restore consistency by removing NAF hypotheses given the program: p 71 However, Inoue <ref> [81, 80] </ref> suggests a general method for restoring consistency, which is applicable to this case. This method (see also section 6.3) is based on [66] and [145] and consists in isolating inconsistencies by finding maximally consistent subprograms. <p> This is not entirely adequate for a proper treatment of exceptions to exceptions. However, this approach can be extended, as we shall see in section 6.6. More direct approaches to the problem of treating positive and negative predicates symmetrically in default reasoning are presented in <ref> [81, 80] </ref>, following the methods of [66] and [145] (see section 6.2 for a discussion), and in [87, 99], based on an argumentation-theoretic framework (see sections 6.4 and 7). 74 6.4 (Extended) Logic Programming without Nega- tion as Failure Kakas, Mancarella and Dung [99] show that the Kowalski-Sadri transformation presented in <p> However it is worth noting that any other semantics of extended logic programs could also be used. For example Inoue <ref> [81, 80] </ref> uses an extension of the answer set semantics (see section 6.2), but for a slightly different transformation. 80 6.7 ELP with abduction Inoue [80] (see also section 6.3) and Pereira, Aparicio and Alferes [136] investigate extended logic programs with abducibles but without integrity constraints.
Reference: [82] <author> Inoue, K., Koshimura, M., Hasegawa, R., </author> <title> Embedding negation as failure into a model generation theorem prover. </title> <booktitle> Proc. 11th International Conference on Automated Deduction, CADE '92, </booktitle> <address> Saratoga Springs, NY (1992) </address>
Reference-contexts: This transformation is related to a similar transformation <ref> [82] </ref> for eliminating NAF. Elsewhere [167], Sakama and Inoue demonstrate a one-to-one correspondence between generalised stable models for ALP and possible models [166] for DLP. Consider, for example, the abductive logic program hP; A; Ii where P is p a A = fag and I is empty.
Reference: [83] <author> Inoue, K., Ohta, Y., Hasegawa, R., Nakashima, M., </author> <title> Hypothetical reasoning systems on the MGTP. </title> <type> Technical Report ICOT, </type> <note> Tokyo (in Japanese) (1992) </note>
Reference-contexts: In addition to the transformations from ALP to general LP, discussed above, transformations between ALP and disjunctive logic programming (DLP) have also been investigated. Inoue et al. <ref> [83] </ref> 19 , in particular, translate ALP clauses of the form p q; a where a is abducible, into DLP clauses (p ^ a) _ a 0 q where a 0 is a new atom that stands for the complement of a, as expressed by the integrity constraint : (a ^
Reference: [84] <author> Junker, U., </author> <title> A correct non-monotonic ATMS. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1049-1054 </address>
Reference-contexts: Other non-monotonic extensions of ATMS have been developed in <ref> [84, 163] </ref>. It should be noted that one difference between ATMS and ALP is the requirement in ATMS that only minimal sets of assumptions be recorded. This minimality of assumptions is essential for the computational efficiency of the ATMS.
Reference: [85] <author> Kakas, A. C., </author> <title> Deductive databases as theories of belief. Technical Report Logic Programming Group, </title> <institution> Imperial College, </institution> <address> London (1991) </address>
Reference-contexts: Another view of integrity constraints <ref> [85, 90, 107, 160, 161] </ref> regards these as epistemic or metalevel statements about the content of the database. In this case the integrity constraints are understood as statements at a different level from those in the knowledge base.
Reference: [86] <author> Kakas, </author> <title> A.C., On the evolution of databases. Technical Report Logic Programming Group, </title> <institution> Imperial College, </institution> <address> London (1991) </address>
Reference-contexts: He proposes instead the notion of "economic rationality", in which the revised sets of beliefs are optimal, but not necessarily unique, with respect to a set of preference criteria on the possible beliefs states. This notion has been used to study the evolution of databases by means of updates <ref> [86] </ref>. It should be noted that the use of abduction to perform belief revision in the view update case also allows results which are not unique, as illustrated in example 2.3.
Reference: [87] <author> Kakas, </author> <title> A.C., Default reasoning via negation as failure. </title> <booktitle> Proc. ECAI-92 workshop on "Foundations of Knowledge Representation and Reasoning", Lecture Notes in AI 810, </booktitle> <publisher> Springer Verlag, </publisher> <editor> eds. </editor> <booktitle> Lakemeyer and Nebel (1992) </booktitle>
Reference-contexts: A similar approach to restoring consistency follows also from the work in <ref> [87, 99] </ref> (see section 7), where argumentation-based semantics can be used to select acceptable (and hence consistent) subsets of an inconsistent extended logic program. 6.3 Rules and exceptions in LP Another way of restoring consistency of answer sets is presented in [112], where sentences with explicitly negated conclusions are given priority <p> However, this approach can be extended, as we shall see in section 6.6. More direct approaches to the problem of treating positive and negative predicates symmetrically in default reasoning are presented in [81, 80], following the methods of [66] and [145] (see section 6.2 for a discussion), and in <ref> [87, 99] </ref>, based on an argumentation-theoretic framework (see sections 6.4 and 7). 74 6.4 (Extended) Logic Programming without Nega- tion as Failure Kakas, Mancarella and Dung [99] show that the Kowalski-Sadri transformation presented in section 6.3 can be applied in the reverse direction, to replace clauses with NAF by clauses with <p> Any semantics can be used for the transformed program (including even a transformational one, e.g. replacing explicitly negated atoms : p (t) by a new atom p 0 (t)). 7 An Abstract Argumentation-based Frame work for Default Reasoning Following the argumentation-theoretic interpretation of NAF introduced in [88], Kakas <ref> [87] </ref> generalised the interpretation and showed how other logics for default reasoning can be based upon a similar semantics. <p> Bondarenko, Toni and Kowalski [11] modified Dung's notion of an abstract argumentation-theoretic framework by defining an argument to be a monotonic derivation from a set of abductive assumptions. This new framework, like that of <ref> [87] </ref>, can be understood as a natural abstraction and extension of the Theorist framework in two respects. First, the underlying logic can be any monotonic logic and not just classical first-order logic. <p> We follow the approach of Bondarenko, Dung, Kowalski and Toni [12] (see also <ref> [87] </ref>). Let T be a set of sentences in any monotonic logic, ` the provability operator for that logic and A a set of candidate abducible sentences. For any ff 2 A, let ff be some sentence that represents the "contrary" of ff.
Reference: [88] <author> Kakas, A. C., Kowalski, R. A., Toni, F., </author> <title> Abductive logic programming. </title> <note> Journal of Logic and Computation 2(6) (1993) 719-770 </note>
Reference-contexts: 1 Introduction This paper extends and updates our earlier survey and analysis of work on the extension of logic programming to perform abductive reasoning <ref> [88] </ref>. The purpose of the paper is to provide a critical overview of some of the main research results, in order to develop a common framework for evaluating these results, to identify the main unresolved problems, and to indicate directions for future work. <p> Alferes and Pereira [4] apply the argumentation-theoretic interpretation introduced in <ref> [88] </ref> to expand the well-founded model of normal and extended logic programs (see section 5). In the case of normal logic programming, their semantics gives the same result as the acceptability semantics in example 4.7. Simari and Loui [177] define an argumentation-theoretic framework for default reasoning in general. <p> This new framework for ELP is proposed in [99] as an example of a general theory of the acceptability semantics (see section 4.3) developed within the argumentation-theoretic framework introduced in <ref> [88] </ref> (see section 7). Its semantics is based upon an appropriate notion of attack between subtheories consisting of partially ordered extended clauses in a theory T . <p> Any semantics can be used for the transformed program (including even a transformational one, e.g. replacing explicitly negated atoms : p (t) by a new atom p 0 (t)). 7 An Abstract Argumentation-based Frame work for Default Reasoning Following the argumentation-theoretic interpretation of NAF introduced in <ref> [88] </ref>, Kakas [87] generalised the interpretation and showed how other logics for default reasoning can be based upon a similar semantics. <p> In particular, he showed how default logic can be understood in such terms and proposed 81 a default reasoning framework based on the argumentation-theoretic accept-ability semantics (see section 4.3) as an alternative to default logic. Dung [44] proposed an abstraction of the argumentation-theoretic interpretation of NAF introduced in <ref> [88] </ref>, where arguments and the notion of one argument attacking another are treated as primitive concepts which can be superimposed upon any monotonic logic and can even be introduced into non-linguistic contexts.
Reference: [89] <author> Kakas, A. C., Mancarella, P., </author> <title> Anomalous models and abduction. </title> <booktitle> Proc. 2nd International Symposium on Artificial intelligence, Monterrey, </booktitle> <address> Mexico (1989) </address>
Reference-contexts: information that a property holds at a particular time point can be assimilated by adding an explanation in terms of the happening of some event that initiates this property at an earlier point of time together with an appropriate assumption that the property persists from one time to the other <ref> [50, 89, 176, 186] </ref>. This has the additional effect that the new KB will imply that the property holds until it is terminated in the future by the happening of some event [176]. <p> ; P; T 2 ) ^ happens (E; T ) ^ terminates (E; P ) ^ T 1 &lt; T &lt; T 2 ]: Assimilating new information by adding explanations that satisfy the integrity constraints has the further effect of resolving conflicts between the current KB and the new information <ref> [89, 176] </ref>. <p> This is the case for both the semantics and the proof theory of LP. Moreover, [53] and <ref> [89] </ref> show how to retain the correct result when negation as failure is interpreted as a form of abduction. On the other hand, the Theorist framework does overcome the problem that some default theories do not have extensions and hence cannot be given any meaning within Reiter's default logic.
Reference: [90] <author> Kakas, A. C., Mancarella, P., </author> <title> Generalized Stable Models: a Semantics for Abduction. </title> <booktitle> Proc. 9th European Conference on Artificial Intelligence, ECAI '90, </booktitle> <month> Stockolm </month> <year> (1990) </year> <month> 385-391 </month>
Reference-contexts: Another view of integrity constraints <ref> [85, 90, 107, 160, 161] </ref> regards these as epistemic or metalevel statements about the content of the database. In this case the integrity constraints are understood as statements at a different level from those in the knowledge base. <p> This assumption has the advantage that all explanations are thereby guaranteed to be basic. Semantics and proof procedures for ALP have been proposed by Eshghi and Kowalski [53], Kakas and Mancarella <ref> [90] </ref> and Chen and Warren [23]. Chen and Warren extend the perfect model semantics of Przymusinski [152] to include abducibles and integrity constraints over abducibles. Here we shall concentrate on the proposal of Kakas and Mancarella, which extends the stable model semantics. 5.1 Generalised stable model semantics Kakas and Mancarella [90] <p> <ref> [90] </ref> and Chen and Warren [23]. Chen and Warren extend the perfect model semantics of Przymusinski [152] to include abducibles and integrity constraints over abducibles. Here we shall concentrate on the proposal of Kakas and Mancarella, which extends the stable model semantics. 5.1 Generalised stable model semantics Kakas and Mancarella [90] develop a semantics for ALP by generalising the stable model semantics for LP. Let hP; A; Ii be an abductive framework, where P is a general logic program, and let be a subset of A.
Reference: [91] <author> Kakas, A. C., Mancarella, P., </author> <title> Database updates through abduction. </title> <booktitle> Proc. 16th International Conference on Very Large Databases, </booktitle> <address> VLDB'90, Brisbane, Australia (1990) 102 </address>
Reference-contexts: A logic program where each literal L i in the body of every clause is atomic is said to be definite. Abduction can be computed in LP by extending SLD and SLDNF <ref> [23, 53, 54, 91, 94, 34, 181] </ref>. Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. <p> The assimilation of a new datum can be performed by adding to the theory new hypotheses that are explanations for the datum. Knowledge assimilation can also be viewed as the general context within which abduction takes place. Database view updates <ref> [17, 91, 28] </ref> are an important special case of knowledge assimilation. Update requests are interpreted as observations to be explained. The explanations of the observations are transactions that satisfy the update request. Another important application which can be understood in terms of a "noncausal" use of abduction is default reasoning. <p> The task of translating the update request on the view predicates to an equivalent update on the extensional part (as in case (4) of KA) is achieved by finding an abductive explanation for the update in terms of variable-free instances of extensional predicates <ref> [91] </ref>. Any violation of integrity is dealt with by changing the extensional part of the database. <p> Another important difference is the distinction that the abductive proof procedure for NAF makes between the abductive and consistency phases. This allows a natural extension of the procedure to a more general framework where we have other hypotheses and integrity constraints in addition to those for NAF <ref> [91, 92, 93] </ref> (see section 5.2). To see how the abductive proof procedure extends SLDNF, consider the following program. <p> Thus, the last two alternatives have similar effects. Denecker and DeSchreye [35] argue that the second alternative is especially appropriate for knowledge representation in the temporal reasoning domain. 5.2 An abductive proof procedure for ALP In <ref> [91, 92, 93] </ref>, a proof procedure is given to compute abductive explanations in ALP. <p> Even if the absence of abducibles is not identified with the presence of their complement, the abductive proof procedure <ref> [91, 92, 93] </ref> described above suffers from the same soundness problem shown in section 4 for the abductive proof procedure for NAF.
Reference: [92] <author> Kakas, A. C., Mancarella, P., </author> <title> On the relation of truth maintenance and abduction. </title> <booktitle> Proc. of the 1st Pacific Rim International Conference on Artificial Intelligence, </booktitle> <address> PRICAI'90, Nagoya, Japan (1990) </address>
Reference-contexts: Another important difference is the distinction that the abductive proof procedure for NAF makes between the abductive and consistency phases. This allows a natural extension of the procedure to a more general framework where we have other hypotheses and integrity constraints in addition to those for NAF <ref> [91, 92, 93] </ref> (see section 5.2). To see how the abductive proof procedure extends SLDNF, consider the following program. <p> Thus, the last two alternatives have similar effects. Denecker and DeSchreye [35] argue that the second alternative is especially appropriate for knowledge representation in the temporal reasoning domain. 5.2 An abductive proof procedure for ALP In <ref> [91, 92, 93] </ref>, a proof procedure is given to compute abductive explanations in ALP. <p> Integrity checking can also be optimised when there are domain specific integrity constraints, provided the constraints can be formulated as denials 15 containing at least one literal whose predicate is abducible. In this case the abductive proof procedure needs only a minor extension <ref> [92, 93] </ref>: when a new hypothesis is added to , the proof procedure resolves the hypothesis against any integrity constraint containing that hypothesis, and then reasons backward from the resolvent. To illustrate this extension consider the following example. <p> Even if the absence of abducibles is not identified with the presence of their complement, the abductive proof procedure <ref> [91, 92, 93] </ref> described above suffers from the same soundness problem shown in section 4 for the abductive proof procedure for NAF. <p> Several authors have observed that the JTMS can be given a semantics corresponding to the semantics of logic programs, by interpreting justifications as propositional logic program clauses, and interpreting ~ p i as NAF of p i . The papers <ref> [49, 71, 92, 141] </ref>, in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. <p> The papers [49, 71, 92, 141], in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. Several authors <ref> [49, 59, 92, 156] </ref>, exploiting the interpretation of stable models as autoepistemic expansions [68], have shown a correspondence between well-founded labellings and stable expansions of the set of justifications viewed as autoepistemic theories. <p> The JTMS can also be understood in terms of abduction using the abduc-tive approach to the semantics of NAF, as shown in <ref> [40, 71, 92] </ref>. This has the advantage that the nogoods of the JTMS can be interpreted as integrity constraints of the abductive framework. <p> Ignoring the propositional nature of a TM system, ALP can be regarded as a hybrid of JTMS and ATMS, combining the non-monotonic negative assumptions of JTMS and the positive assumptions of ATMS, and allowing both positive and negative conditions in both justifications and nogoods <ref> [92] </ref>. Other non-monotonic extensions of ATMS have been developed in [84, 163]. It should be noted that one difference between ATMS and ALP is the requirement in ATMS that only minimal sets of assumptions be recorded. This minimality of assumptions is essential for the computational efficiency of the ATMS.
Reference: [93] <author> Kakas, A. C., Mancarella, P., </author> <title> Abductive LP. </title> <booktitle> Proc. NACLP '90, Workshop on Non-Monotonic Reasoning and Logic Programming, </booktitle> <address> Austin, Texas (1990) </address>
Reference-contexts: In [165] this assumption is exploited by reasoning forward from the updates. This idea is exploited for the purpose of checking the satisfaction of abductive hypotheses in <ref> [54, 93, 94] </ref>. Although this procedure was originally formulated for the consistency view of constraint satisfaction, it has proved equally appropriate for the semantics of integrity constraints in abductive logic programming. 1.3 Applications In this section we briefly describe some of the applications of abduction in AI. <p> Another important difference is the distinction that the abductive proof procedure for NAF makes between the abductive and consistency phases. This allows a natural extension of the procedure to a more general framework where we have other hypotheses and integrity constraints in addition to those for NAF <ref> [91, 92, 93] </ref> (see section 5.2). To see how the abductive proof procedure extends SLDNF, consider the following program. <p> Thus, the last two alternatives have similar effects. Denecker and DeSchreye [35] argue that the second alternative is especially appropriate for knowledge representation in the temporal reasoning domain. 5.2 An abductive proof procedure for ALP In <ref> [91, 92, 93] </ref>, a proof procedure is given to compute abductive explanations in ALP. <p> Integrity checking can also be optimised when there are domain specific integrity constraints, provided the constraints can be formulated as denials 15 containing at least one literal whose predicate is abducible. In this case the abductive proof procedure needs only a minor extension <ref> [92, 93] </ref>: when a new hypothesis is added to , the proof procedure resolves the hypothesis against any integrity constraint containing that hypothesis, and then reasons backward from the resolvent. To illustrate this extension consider the following example. <p> Even if the absence of abducibles is not identified with the presence of their complement, the abductive proof procedure <ref> [91, 92, 93] </ref> described above suffers from the same soundness problem shown in section 4 for the abductive proof procedure for NAF.
Reference: [94] <author> Kakas, A. C., Mancarella, P., </author> <title> Knowledge assimilation and abduction. </title> <booktitle> Proc. European Conference on Artificial Intelligence, ECAI '90 International Workshop on Truth Maintenance, Stockholm, Springer Verlag Lecture notes in Computer Science (1990) </booktitle>
Reference-contexts: A logic program where each literal L i in the body of every clause is atomic is said to be definite. Abduction can be computed in LP by extending SLD and SLDNF <ref> [23, 53, 54, 91, 94, 34, 181] </ref>. Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. <p> In [165] this assumption is exploited by reasoning forward from the updates. This idea is exploited for the purpose of checking the satisfaction of abductive hypotheses in <ref> [54, 93, 94] </ref>. Although this procedure was originally formulated for the consistency view of constraint satisfaction, it has proved equally appropriate for the semantics of integrity constraints in abductive logic programming. 1.3 Applications In this section we briefly describe some of the applications of abduction in AI. <p> These applications of abduction can all be understood as generating hypotheses which are causes for observations which are effects. An application that does not necessarily have a direct causal interpretation is knowledge assimilation <ref> [94, 105, 114, 125] </ref>, described in greater detail below. The assimilation of a new datum can be performed by adding to the theory new hypotheses that are explanations for the datum. Knowledge assimilation can also be viewed as the general context within which abduction takes place. <p> The new information is independent from the current KB. The new KB is obtained by adding the new information to the current KB. In case (4) the KB can, alternatively, be augmented by an explanation for the new datum <ref> [94, 105, 114] </ref>. In [114] the authors have developed a system for knowledge assimilation (KA) based on this use of abduction. They have identified the basic issues associated with such a system and proposed solutions for some of these. <p> In this way the abductive proof procedure generalises SLDNF. Furthermore, the abductive explanation produced by the procedure can be recorded and used in any subsequent revision of the beliefs held by the program, in a similar fashion to truth maintenance systems <ref> [94] </ref>. In fact, this abductive treatment of NAF allows us to identify a close connection between logic programming and truth maintenance systems in general (see section 8). Another important difference is the distinction that the abductive proof procedure for NAF makes between the abductive and consistency phases.
Reference: [95] <author> Kakas, A. C., Mancarella, P., </author> <title> Preferred extensions are partial stable models. </title> <journal> Journal of Logic Programming, </journal> <month> 14(3,4):341-348 </month> <year> (1993) </year>
Reference-contexts: In example 4.5 the definition of preferred extension excludes the maximally consistent extension f p fl g, because there is no defence against the attack q fl . The preferred extension semantics provides a unifying framework for various approaches to the semantics of negation in LP. Kakas and Mancarella <ref> [95] </ref> show that it is equivalent to Sacca and Zaniolo's partial stable model semantics [164]. Like the partial stable model semantics, it includes the stable model semantics as a special case. Dung [39] also defines the notion of complete extension.
Reference: [96] <author> Kakas, A. C., Mancarella, P., </author> <title> Negation as stable hypotheses. </title> <booktitle> Proc. 1st International Workshop on Logic Programming and Nonmonotonic Reasoning (Nerode, </booktitle> <editor> Marek and Subrahmanian eds.), </editor> <address> Washington DC (1991) </address>
Reference-contexts: The relationship between these two semantics is further investigated in [47], where 37 the well-founded model and preferred extensions are shown to correspond to the least fixed point and greatest fixed point, respectively, of the same operator. Kakas and Mancarella <ref> [96, 97] </ref> propose an improvement of the preferred extension semantics. Their proposal can be illustrated by the following example. <p> The empty set is the only preferred extension. However, intuitively should be admissible because the only attack E against attacks itself, and therefore should not be regarded as an admissible attack against . To deal with this kind of example, Kakas and Mancarella <ref> [96, 97] </ref> modify Dung's semantics, increasing the number of ways in which an attack E can be defeated. Whereas Dung only allows to defeat an attack E, they also allow E to defeat itself. <p> Note that here the condition "P fl [ is consistent with I fl " of the definition of preferred extensions and admissible sets of hypotheses is subsumed by the new condition. This is a consequence of another difference between <ref> [96, 97] </ref> and [39], namely that for each attack E against the counter-attack is required to be against E rather than against E. In other words, the defence of must be a genuine attack that does not at the same time also attack . <p> This interpretation is equivalent to the well-founded semantics [43]. Based upon Geffner's notion of argumentation, Torres [185] has proposed an argumentation-theoretic semantics for NAF that is equivalent to Kakas and Mancarella's stable theory semantics <ref> [96, 97] </ref>, but is formulated in terms of the following notion of attack: E attacks (relative to P fl ) if P fl [ E [ ` p for some p fl 2 .
Reference: [97] <author> Kakas, A. C., Mancarella, P., </author> <title> Stable theories for logic programs. </title> <booktitle> Proc. </booktitle> <address> ISLP '91, San Diego (1991) </address>
Reference-contexts: The relationship between these two semantics is further investigated in [47], where 37 the well-founded model and preferred extensions are shown to correspond to the least fixed point and greatest fixed point, respectively, of the same operator. Kakas and Mancarella <ref> [96, 97] </ref> propose an improvement of the preferred extension semantics. Their proposal can be illustrated by the following example. <p> The empty set is the only preferred extension. However, intuitively should be admissible because the only attack E against attacks itself, and therefore should not be regarded as an admissible attack against . To deal with this kind of example, Kakas and Mancarella <ref> [96, 97] </ref> modify Dung's semantics, increasing the number of ways in which an attack E can be defeated. Whereas Dung only allows to defeat an attack E, they also allow E to defeat itself. <p> Note that here the condition "P fl [ is consistent with I fl " of the definition of preferred extensions and admissible sets of hypotheses is subsumed by the new condition. This is a consequence of another difference between <ref> [96, 97] </ref> and [39], namely that for each attack E against the counter-attack is required to be against E rather than against E. In other words, the defence of must be a genuine attack that does not at the same time also attack . <p> In other words, the defence of must be a genuine attack that does not at the same time also attack . Therefore, if is inconsistent, it contains as 38 a subset an attack E, which can not be counterattacked because E is empty. In <ref> [97] </ref>, Kakas and Mancarella show how these notions can also be used to extend the sceptical well-founded model semantics. In example 4.6 above this extension of the well-founded model will contain the negation of p. <p> Like the original definition of admissible sets of hypotheses and preferred extension, the definition of weakly stable sets of hypotheses and stable theories was not originally formulated in terms of attack, but is equivalent to the one presented here. Kakas and Mancarella <ref> [97] </ref> argue that the notion of defeating an attack needs to be liberalised further. They illustrate their argument with the following example. <p> This interpretation is equivalent to the well-founded semantics [43]. Based upon Geffner's notion of argumentation, Torres [185] has proposed an argumentation-theoretic semantics for NAF that is equivalent to Kakas and Mancarella's stable theory semantics <ref> [96, 97] </ref>, but is formulated in terms of the following notion of attack: E attacks (relative to P fl ) if P fl [ E [ ` p for some p fl 2 .
Reference: [98] <author> Kakas, A. C., Mancarella, P., </author> <title> Constructive abduction in logic programming. </title> <type> Technical Report Dipartimento di Informatica, </type> <institution> Universita di Pisa (1993) </institution>
Reference-contexts: A procedure for performing constructive abduction within a framework that treats equality as an abducible predicate and the Clark equality theory as a set of integrity constraint was first proposed by Eshghi [50]. Building upon this proposal, Kakas and Mancarella <ref> [98] </ref> extend the abductive proof procedure for LP in [54] (see section 4.2) to combine constructive negation with constructive abduction in a uniform way, by reducing the former to the latter using the abductive interpretation of NAF. The problem of constructive abduction has also been studied within the completion semantics.
Reference: [99] <author> Kakas, A. C., Mancarella, P., Dung, </author> <title> P.M., The acceptability semantics for logic programs. </title> <booktitle> Proc. 11th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Santa Margherita Ligure, Italy (1994) 504-519 </address>
Reference-contexts: A similar approach to restoring consistency follows also from the work in <ref> [87, 99] </ref> (see section 7), where argumentation-based semantics can be used to select acceptable (and hence consistent) subsets of an inconsistent extended logic program. 6.3 Rules and exceptions in LP Another way of restoring consistency of answer sets is presented in [112], where sentences with explicitly negated conclusions are given priority <p> However, this approach can be extended, as we shall see in section 6.6. More direct approaches to the problem of treating positive and negative predicates symmetrically in default reasoning are presented in [81, 80], following the methods of [66] and [145] (see section 6.2 for a discussion), and in <ref> [87, 99] </ref>, based on an argumentation-theoretic framework (see sections 6.4 and 7). 74 6.4 (Extended) Logic Programming without Nega- tion as Failure Kakas, Mancarella and Dung [99] show that the Kowalski-Sadri transformation presented in section 6.3 can be applied in the reverse direction, to replace clauses with NAF by clauses with <p> symmetrically in default reasoning are presented in [81, 80], following the methods of [66] and [145] (see section 6.2 for a discussion), and in [87, 99], based on an argumentation-theoretic framework (see sections 6.4 and 7). 74 6.4 (Extended) Logic Programming without Nega- tion as Failure Kakas, Mancarella and Dung <ref> [99] </ref> show that the Kowalski-Sadri transformation presented in section 6.3 can be applied in the reverse direction, to replace clauses with NAF by clauses with explicit negation together with a priority ordering between extended clauses. <p> In <ref> [99] </ref>, the resulting prioritised clauses are formulated in an ELP framework (with explicit negation) without NAF but with an ordering relation on the clauses of the given program. This new framework for ELP is proposed in [99] as an example of a general theory of the acceptability semantics (see section 4.3) <p> In <ref> [99] </ref>, the resulting prioritised clauses are formulated in an ELP framework (with explicit negation) without NAF but with an ordering relation on the clauses of the given program. This new framework for ELP is proposed in [99] as an example of a general theory of the acceptability semantics (see section 4.3) developed within the argumentation-theoretic framework introduced in [88] (see section 7). Its semantics is based upon an appropriate notion of attack between subtheories consisting of partially ordered extended clauses in a theory T . <p> This reduction automatically provides us with an argumentation-theoretic interpretation of ELP, where attacks via these integrity constraints become attacks via explicit negation. Such notions of attack via explicit negation have been defined by Dung [45] and Kakas, Mancarella and Dung <ref> [99] </ref>. <p> The last clause ab bird (X) penguin (X); ~ ab penguin (X) 78 can be understood as attempting to assign a higher priority to the second clause of the program over the first. This can be done, without this last clause, explicitly in the ELP framework with priorities of <ref> [99] </ref> (section 6.4) or in the rules and exceptions approach [112] (section 6.3). An argumentation-theoretic interpretation for ELP has also been proposed by Bondarenko, Toni and Kowalski [11]. <p> For example, the program p ~ p; ~ q admits both f~ qg and f~ pg as admissible extensions, while the only intuitively correct extension is f~ qg. Alferes and Pereira [4] use argumentation-theoretic notions to extend the well-founded semantics for ELP in [135]. Kakas, Mancarella and Dung <ref> [99] </ref> also define a well-founded semantics for ELP based upon argumentation-theoretic notions. 6.6 A methodology for default reasoning with explicit negation Compared with other authors, who primarily focus on extending or modifying the semantics of LP to deal with default reasoning, Pereira, Aparicio and Alferes [136] develop a methodology for performing <p> Based upon this abductive interpretation of default logic, Satoh [169] proposes a sound and complete proof procedure for default logic, by extending the proof procedure for ALP of [172]. At a similar level of abstraction, Kakas, Mancarella and Dung <ref> [99] </ref> also propose a general argumentation-theoretic framework based primarily on the acceptability semantics. As with LP, other semantics such as preferred extension and stable theory semantics can be obtained as approximations of the acceptability semantics. <p> As with LP, other semantics such as preferred extension and stable theory semantics can be obtained as approximations of the acceptability semantics. A sceptical form of semantics, analogous to the well-founded semantics for LP, is also given in <ref> [99] </ref>, based on a strong form of acceptability. Kakas, Mancarella and Dung define a notion of attack between conflicting sets of sentences, but these can be any subtheories of a given theory, rather than being subtheories drawn from a pre-assigned set of assumption sentences as in [11, 12].
Reference: [100] <author> Kakas, A. C., Michael, A., </author> <title> Scheduling through abduction. </title> <booktitle> Proc. ICLP'93 Post Conference workshop on Abductive Reasoning (1993) </booktitle>
Reference-contexts: Constraints can also be simplified, replacing, for example, 2 &lt; t ^ 3 &lt; t 3 &lt; t: Such simplification is less common in abductive frameworks. A number of proposals have been made recently to unify the treatment of abducibles and constraints. Several of these, <ref> [50, 176, 120, 100] </ref> in particular, have investigated the implementation of specialised constraint satisfaction and simplification algorithms of CLP (specifically for inequality) by means of general-purpose integrity checking methods applied to domain-specific integrity constraints as in the case of ALP. 65 Kowalski [109] proposes a general framework which attempts to unify
Reference: [101] <author> Kakas, A. C., Michael, A., </author> <title> Integrating abductive and constraint logic programming. </title> <note> To appear in Proc. International Logic Programming Conference, (1995) 103 [102] deKleer, J., An assumption-based TMS. Artificial Intelligence 32 (1986) </note>
Reference-contexts: Another approach, which integrates both frameworks while preserving their identity, has been developed by Kakas and Michael <ref> [101] </ref>. In this approach, the central notions of the two frameworks are combined, so that abduction and constraint handling cooperate to solve a common goal.
Reference: [103] <author> Konolige, K., </author> <title> A general theory of abduction. </title> <booktitle> Spring Symposium on Automated Abduction, </booktitle> <address> Standford University (1990) 62-66 </address>
Reference-contexts: In contrast, the abduction of happens is used for non-default hypothetical reasoning. The distinction between default reasoning and non-default abduction is also made in Konolige's proposal <ref> [103] </ref>, which combines abduction for non-default hypothetical reasoning with default logic [158] for default reasoning. This proposal is similar, therefore, to the way in which generalised stable models combine abduction with NAF.
Reference: [104] <author> Konolige, K., </author> <title> Using defualt and causal reasoning in diagnosis. </title> <booktitle> Proc. 3rd International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> Cambridge (1992) </address>
Reference-contexts: The abductive proof procedure is sound with respect to this improved semantics. 34 An alternative abductive semantics of NAF without disjunctive integrity con-straints has been proposed by Brewka [14], following ideas presented in <ref> [104] </ref>. He suggests that the set which includes both accepted and refuted NAF hypotheses be maximised. For each such set of hypotheses, the logic program admits a "model" which is the union of the sets of accepted hypotheses together with the "complement" of the refuted hypotheses.
Reference: [105] <author> Kowalski, R.A., </author> <title> Logic for problem solving. </title> ( <publisher> Elsevier, </publisher> <address> New York,1979) </address>
Reference-contexts: These applications of abduction can all be understood as generating hypotheses which are causes for observations which are effects. An application that does not necessarily have a direct causal interpretation is knowledge assimilation <ref> [94, 105, 114, 125] </ref>, described in greater detail below. The assimilation of a new datum can be performed by adding to the theory new hypotheses that are explanations for the datum. Knowledge assimilation can also be viewed as the general context within which abduction takes place. <p> There are four possible deductive relationships between the current knowledge base (KB), the new information, and the new KB which arises as a result <ref> [105, 110] </ref>. 1. The new information is already deducible from the current KB. The new KB, as a result, is identical with the current one. 2. The current KB = KB 1 [ KB 2 can be decomposed into two parts. <p> The new information is independent from the current KB. The new KB is obtained by adding the new information to the current KB. In case (4) the KB can, alternatively, be augmented by an explanation for the new datum <ref> [94, 105, 114] </ref>. In [114] the authors have developed a system for knowledge assimilation (KA) based on this use of abduction. They have identified the basic issues associated with such a system and proposed solutions for some of these. <p> It is interesting to note that case (3) can be used to check the integrity of abductive hypotheses generated in case (4). Any violation of integrity detected in case (3) can be remedied in several ways <ref> [105] </ref>. The new input can be retracted as in conventional databases. Alternatively the new input can be upheld and some other assumptions can be withdrawn. This is the case with view updates.
Reference: [106] <author> Kowalski, R.A., </author> <title> Belief revision without constraints. </title> <booktitle> Computational Intelligence 3(3), </booktitle> <year> (1987) </year>
Reference: [107] <author> Kowalski, R.A., </author> <title> Problems and promises of computational logic. </title> <booktitle> Proc. Symposium on Computational Logic, </booktitle> <editor> Lloyd ed., </editor> <booktitle> Springer Verlag Lecture Notes in Computer Science (1990) </booktitle>
Reference-contexts: Another view of integrity constraints <ref> [85, 90, 107, 160, 161] </ref> regards these as epistemic or metalevel statements about the content of the database. In this case the integrity constraints are understood as statements at a different level from those in the knowledge base.
Reference: [108] <author> Kowalski, R.A., </author> <title> Database updates in the event calculus. </title> <note> Journal of Logic Programming 12 (1992) 121-146 </note>
Reference-contexts: In other cases the addition of 14 an explanation as a way of assimilating new data is forced by the particular way in which the knowledge is represented in the theory. This is the case, for instance, for the formulation of temporal reasoning in the Event Calculus <ref> [113, 108] </ref>, as illustrated by the following example.
Reference: [109] <author> Kowalski, R. A., </author> <title> A dual form of logic programming. </title> <booktitle> Lecture Notes, Workshop in Honour of Jack Minker, </booktitle> <institution> University of Maryland, </institution> <month> Novem-ber </month> <year> 1992 </year>
Reference-contexts: Several of these, [50, 176, 120, 100] in particular, have investigated the implementation of specialised constraint satisfaction and simplification algorithms of CLP (specifically for inequality) by means of general-purpose integrity checking methods applied to domain-specific integrity constraints as in the case of ALP. 65 Kowalski <ref> [109] </ref> proposes a general framework which attempts to unify ALP and CLP using if-and-only-if definitions for ordinary LP predicates and using integrity constraints for abducible and constraint predicates. Abduction is performed by means of deduction in the style of [26] (see section 5.6).
Reference: [110] <author> Kowalski, R.A., </author> <title> Logic without model theory. To appear in What is a Logical System? (D. </title> <editor> Gabbay, ed.) </editor> <publisher> Oxford University Press (1994) </publisher>
Reference-contexts: The restriction to Herbrand interpretations means that interpretations are purely syntactic objects, which have no bearing on 9 the correspondence between language and "reality". A purely syntactic view of semantics, based upon the notion of knowledge assimilation described in section 2 below, is developed in <ref> [110] </ref>. One important alternative way to specify the semantics of a language, which will be used in the sequel, is through the translation of sentences expressed in one language into sentences of another language, whose semantics is already well understood. <p> There are four possible deductive relationships between the current knowledge base (KB), the new information, and the new KB which arises as a result <ref> [105, 110] </ref>. 1. The new information is already deducible from the current KB. The new KB, as a result, is identical with the current one. 2. The current KB = KB 1 [ KB 2 can be decomposed into two parts.
Reference: [111] <author> Kowalski, R.A., Sadri, F., </author> <title> Knowledge representation without integrity constraints. </title> <institution> Technical Report Department of Computing, Imperial College, </institution> <address> London (1988) </address>
Reference-contexts: Hence by adding the hypothesis r to the explanation we can ensure that q fl is acceptable. An important feature of the abductive proof procedures is that they avoid performing a full general-purpose integrity check (such as the forward reasoning procedure of <ref> [111] </ref>). In the case of a negative hypothesis, q fl for example, 48 2 = fq fl ; rg r fl q p a general-purpose forward reasoning integrity check would have to use rules in the program such as p q fl to derive p. <p> Instead of regarding abducibles as atoms to be consistently added to a theory, they can be considered as assertions in the theory to be retracted in the presence of contradictions until consistency (or integrity) is restored (c.f. section 6.2). One approach to this understanding of abduction is presented in <ref> [111] </ref>. Here, Kowalski and Sadri present a transformation from a general logic program P with integrity constraints I, together with some indication of how to restore consistency, to a new general logic program P 0 without integrity constraints. <p> The transformation of <ref> [111] </ref> replaces a program P with integrity constraints I by a program P 0 without integrity constraints which is always consistent with I; and if P is inconsistent with I, then P 0 represents one possible way to restore consistency (relative to the choice of the retractable atom). <p> This problem was addressed in a subsequent paper [112] in which integrity constraints are re-expressed as extended clauses and the retractable atoms become explicitly negated conclusions. This use of extended clauses in place of integrity constraints with retractibles is discussed later in section 6.3. The transformation of <ref> [111] </ref>, applied to ALP, treats all abducibles as default abducibles. In particular, abducibles which do not occur as retractibles in integrity constraints are simply asserted in the transformed program P 0 . Therefore, this transformation can only be used to eliminate default abducibles together with their integrity constraints. <p> Kowalski and Sadri [112] also present a transformation, which preserves the new semantics, and is arguably a more elegant form of the transformation presented in <ref> [111] </ref> (see section 5.5). <p> In the case of the flying-birds example described above the new transformation gives the clause f ly (X) bird (X); ~ : f ly (X): 73 This can be further transformed by "macroprocessing" the call to : f ly (X), giving the result of the original transformation in <ref> [111] </ref> f ly (X) bird (X); ~ walk (X): In general, the new transformation introduces a new condition ~ : p (t) into every clause with a positive conclusion p (t). The condition is vacuous if there are no exceptions with : p in the conclusion.
Reference: [112] <author> Kowalski, R.A., Sadri, F., </author> <title> Logic programs with exceptions. </title> <booktitle> Proc. 7th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Jerusalem (1990) 598-613 </address>
Reference-contexts: Moreover the proof of equivalence was based on a tedious comparison of search spaces for the two programs. This problem was addressed in a subsequent paper <ref> [112] </ref> in which integrity constraints are re-expressed as extended clauses and the retractable atoms become explicitly negated conclusions. This use of extended clauses in place of integrity constraints with retractibles is discussed later in section 6.3. The transformation of [111], applied to ALP, treats all abducibles as default abducibles. <p> to restoring consistency follows also from the work in [87, 99] (see section 7), where argumentation-based semantics can be used to select acceptable (and hence consistent) subsets of an inconsistent extended logic program. 6.3 Rules and exceptions in LP Another way of restoring consistency of answer sets is presented in <ref> [112] </ref>, where sentences with explicitly negated conclusions are given priority over sentences with positive conclusions. In this approach, extended clauses with negative conclusions are similar to integrity constraints with retractibles. <p> In this example, the extended clause : f ly (X) walk (X) can be interpreted as an exception to the "general" rule f ly (X) bird (X): To capture the intention that exceptions should override general rules, Kowal-ski and Sadri <ref> [112] </ref> modify the answer set semantics, so that instances of clauses with positive conclusions are retracted if they are contradicted by explicit negative information. Kowalski and Sadri [112] also present a transformation, which preserves the new semantics, and is arguably a more elegant form of the transformation presented in [111] (see <p> exception to the "general" rule f ly (X) bird (X): To capture the intention that exceptions should override general rules, Kowal-ski and Sadri <ref> [112] </ref> modify the answer set semantics, so that instances of clauses with positive conclusions are retracted if they are contradicted by explicit negative information. Kowalski and Sadri [112] also present a transformation, which preserves the new semantics, and is arguably a more elegant form of the transformation presented in [111] (see section 5.5). <p> This can be done, without this last clause, explicitly in the ELP framework with priorities of [99] (section 6.4) or in the rules and exceptions approach <ref> [112] </ref> (section 6.3). An argumentation-theoretic interpretation for ELP has also been proposed by Bondarenko, Toni and Kowalski [11].
Reference: [113] <author> Kowalski, R.A., Sergot, M., </author> <title> A logic-based calculus of events. </title> <booktitle> New Generation Computing 4 (1986) 67-95 104 </booktitle>
Reference-contexts: In other cases the addition of 14 an explanation as a way of assimilating new data is forced by the particular way in which the knowledge is represented in the theory. This is the case, for instance, for the formulation of temporal reasoning in the Event Calculus <ref> [113, 108] </ref>, as illustrated by the following example.
Reference: [114] <author> Kunifuji, S., Tsurumaki, K., Furukawa, K., </author> <title> Consideration of a hypothesis-based reasoning system. </title> <journal> Journal of Japanese Society for Artificial Intelligence 1(2) (1986) 228-237 </journal>
Reference-contexts: These applications of abduction can all be understood as generating hypotheses which are causes for observations which are effects. An application that does not necessarily have a direct causal interpretation is knowledge assimilation <ref> [94, 105, 114, 125] </ref>, described in greater detail below. The assimilation of a new datum can be performed by adding to the theory new hypotheses that are explanations for the datum. Knowledge assimilation can also be viewed as the general context within which abduction takes place. <p> The new information is independent from the current KB. The new KB is obtained by adding the new information to the current KB. In case (4) the KB can, alternatively, be augmented by an explanation for the new datum <ref> [94, 105, 114] </ref>. In [114] the authors have developed a system for knowledge assimilation (KA) based on this use of abduction. They have identified the basic issues associated with such a system and proposed solutions for some of these. <p> The new information is independent from the current KB. The new KB is obtained by adding the new information to the current KB. In case (4) the KB can, alternatively, be augmented by an explanation for the new datum [94, 105, 114]. In <ref> [114] </ref> the authors have developed a system for knowledge assimilation (KA) based on this use of abduction. They have identified the basic issues associated with such a system and proposed solutions for some of these.
Reference: [115] <author> Lamma, E., Mello, P., </author> <title> An assumption-based truth maintenance system dealing with non ground justifications. </title> <booktitle> Proc. 1st Compulog-Net Workshop on Logic Programming in Artificial Intelligence, </booktitle> <institution> Imperial College, </institution> <address> London (1992) </address>
Reference-contexts: Poole, Goebel and Aleliunas [150] also use linear resolution to generate hypotheses. 7 In contrast, the ATMS [102] computes abductive explanations bottom-up. The ATMS can be regarded as a form of hyper-resolution, augmented with subsumption, for propositional logic programs [162]. Lamma and Mello <ref> [115] </ref> have developed an extension of the ATMS for the non-propositional case. Resolution-based techniques for computing abduction have also been developed by Demolombe and Fari~nas del Cerro [31] and Gaifman and Shapiro [64]. Abduction can also be applied to logic programming (LP). <p> The extension of the ATMS to the non-propositional case requires a new notion of minimality of sets of assumptions. Minimality as subset inclusion is not sufficient, but needs to be replaced by a notion of minimal consequence from sets of not necessarily variable-free assumptions <ref> [115] </ref>. Ignoring the propositional nature of a TM system, ALP can be regarded as a hybrid of JTMS and ATMS, combining the non-monotonic negative assumptions of JTMS and the positive assumptions of ATMS, and allowing both positive and negative conditions in both justifications and nogoods [92].
Reference: [116] <author> Lever, J. M., </author> <title> Combining induction with resolution in logic programming. </title> <type> PhD Thesis, </type> <institution> Department of Computing, Imperial College, </institution> <month> Lon-don </month> <year> (1991) </year>
Reference-contexts: Integrity constraints are useful to avoid unintended updates to a database or knowledge base. They can also be used to represent desired properties of a program <ref> [116] </ref>. The concept of integrity constraints first arose in the field of databases and to a lesser extent in the field of AI knowledge representation. The basic idea is that only certain knowledge base states are considered acceptable, and an integrity constraint is meant to enforce these legal states.
Reference: [117] <author> Levesque, H.J., </author> <title> A knowledge-level account of abduction. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1061-1067 </address>
Reference-contexts: We mention them for completeness, but in the sequel we will concentrate on the logic-based view previously described. * Allemand, Tanner, Bylander and Josephson [6] and Reggia [155] present a mathematical characterisation, where abduction is defined over sets of observations and hypotheses, in terms of coverings and parsimony. * Levesque <ref> [117] </ref> gives an account of abduction at the "knowledge level". He characterises abduction in terms of a (modal) logic of beliefs, and shows how the logic-based approach to abduction can be understood in terms of a particular kind of belief.
Reference: [118] <author> Lloyd, J.W., Topor, R.W., </author> <title> A basis for deductive database system. </title> <note> Journal of Logic Programming 2 (1985) 93-109 </note>
Reference-contexts: The consistency view requires that: KB satisfies iff KB [ is consistent: Alternatively the theoremhood view requires that: KB satisfies iff KB j= : These definitions have been proposed in the case where the theory is a logic program P by Kowalski and Sadri [165] and Lloyd and Topor <ref> [118] </ref> respectively, where KB is the Clark completion [24] of P . Another view of integrity constraints [85, 90, 107, 160, 161] regards these as epistemic or metalevel statements about the content of the database. <p> For each such semantics, we have a specification of the integrity checking problem. Although the different views of integrity satisfaction are conceptually very different, the integrity checking procedures based upon these views are not very different in practice (e.g. <ref> [30, 165, 118] </ref>).
Reference: [119] <author> McDermott, D., </author> <title> Nonmonotonic logic II: nonmonotonic modal theories. </title> <note> JACM 29(1) (1982) </note>
Reference-contexts: give an idea of this framework, we show here how a simplified version of the framework can be used to define an abstract notion of stable semantics which includes as special cases stable models for logic programs and extensions for default logic [158], autoepistemic logic [126] and non-monotonic logic II <ref> [119] </ref>. We follow the approach of Bondarenko, Dung, Kowalski and Toni [12] (see also [87]). Let T be a set of sentences in any monotonic logic, ` the provability operator for that logic and A a set of candidate abducible sentences.
Reference: [120] <author> Maim, E., </author> <title> Abduction and constraint logic programming. </title> <booktitle> Proc. Euro-pean Conference on Artificial Intelligence, ECAI '92 Vienna, </booktitle> <address> Austria (1992) </address>
Reference-contexts: Constraints can also be simplified, replacing, for example, 2 &lt; t ^ 3 &lt; t 3 &lt; t: Such simplification is less common in abductive frameworks. A number of proposals have been made recently to unify the treatment of abducibles and constraints. Several of these, <ref> [50, 176, 120, 100] </ref> in particular, have investigated the implementation of specialised constraint satisfaction and simplification algorithms of CLP (specifically for inequality) by means of general-purpose integrity checking methods applied to domain-specific integrity constraints as in the case of ALP. 65 Kowalski [109] proposes a general framework which attempts to unify
Reference: [121] <author> Makinson, D., </author> <title> General theory of cumulative inference. </title> <booktitle> Proc. 2nd International Workshop on Monmonotonic reasoning, Springer Verlag Lecture Notes in Computer Science 346 (1989) </booktitle>
Reference-contexts: He presents a number of examples where the two formulations differ and argues that Reiter's default logic gives counterintuitive results. In fact, many of these examples can be dealt with correctly in certain extensions of default logic, such as Cumulative Default Logic <ref> [121] </ref>, and it is possible to dispute some of the other examples. But, more importantly, there are still other examples where the Theorist approach arguably gives the wrong result. The most important of these is the now notorious Yale shooting problem of [73, 74].
Reference: [122] <author> Manthey, R., Bry, F., </author> <title> SATCHMO: a theorem prover implemented in Prolog. </title> <booktitle> Proc. 9th International Conference on Automated Deduction, CADE '88, </booktitle> <address> Argonne, Illinois (1988) 415-434 </address>
Reference-contexts: They show an equivalence between the search space for SLD-resolution extended with abduction and the search space for model generation with SATCHMO <ref> [122] </ref> augmented with term rewriting to simulate unification. 64 5.7 Abduction and Constraint Logic Programming ALP has many similarities with constraint logic programming (CLP). Recognition of these similarities has motivated a number of recent proposals to unify the two frameworks. Both frameworks distinguish two kinds of predicates.
Reference: [123] <author> Marek, W., Truszczynski, M., </author> <title> Stable semantics for logic programs and default theories. </title> <booktitle> Proc. </booktitle> <month> NACLP '89 </month> <year> (1989) </year> <month> 243-256 </month>
Reference: [124] <author> Minker, J., </author> <title> On indefinite databases and the closed world assumption. </title> <booktitle> Proc. 6th International Conference on Automated Deduction, CADE 105 '82, </booktitle> <address> New York, </address> <note> Springer Verlag Lecture Notes in Computer Science 138 (1982) 292-308 </note>
Reference-contexts: This can be done by means of a transformation similar to the one used to separate extensional and intensional predicates in deductive databases <ref> [124] </ref>.
Reference: [125] <author> Miyaki, T., Kunifuji, S., Kitakami, H., Furukawa, K., Takeuchi, A., Yokota, H., </author> <title> A knowledge assimilation method for logic databases. </title> <booktitle> International Symposium on Logic Programming, </booktitle> <address> Atlantic City, NJ (1984) 118-125 </address>
Reference-contexts: These applications of abduction can all be understood as generating hypotheses which are causes for observations which are effects. An application that does not necessarily have a direct causal interpretation is knowledge assimilation <ref> [94, 105, 114, 125] </ref>, described in greater detail below. The assimilation of a new datum can be performed by adding to the theory new hypotheses that are explanations for the datum. Knowledge assimilation can also be viewed as the general context within which abduction takes place.
Reference: [126] <author> Moore, R., </author> <title> Semantical considerations on non-monotonic logic. </title> <booktitle> Artificial Intelligence 25 (1985) </booktitle>
Reference-contexts: To give an idea of this framework, we show here how a simplified version of the framework can be used to define an abstract notion of stable semantics which includes as special cases stable models for logic programs and extensions for default logic [158], autoepistemic logic <ref> [126] </ref> and non-monotonic logic II [119]. We follow the approach of Bondarenko, Dung, Kowalski and Toni [12] (see also [87]). Let T be a set of sentences in any monotonic logic, ` the provability operator for that logic and A a set of candidate abducible sentences.
Reference: [127] <author> Morris, P. H., </author> <title> The anomalous extension problem in default reasoning. </title> <booktitle> Artificial Intelligence 35 (1988) 383-399 </booktitle>
Reference-contexts: The most important of these is the now notorious Yale shooting problem of [73, 74]. This can be reduced to the propositional logic program alive-af ter-load-wait-shoot alive-af ter-load-wait, ~ abnormal-alive-shoot loaded-af ter-load-wait loaded-af ter-load, ~ abnormal-loaded-wait abnormal-alive-shoot loaded-af ter-load-wait alive-af ter-load-wait loaded-af ter-load: As argued in <ref> [127] </ref>, these clauses can be simplified further: First, the facts alive-af ter-load-wait and loaded-af ter-load can be eliminated by resolving them against the corresponding conditions of the first two clauses, giving alive-af ter-load-wait-shoot ~ abnormal-alive-shoot loaded-af ter-load-wait ~ abnormal-loaded-wait abnormal-alive-shoot loaded-af ter-load-wait Then the atom loaded-af ter-load-wait can be resolved away <p> The second extension is intuitively incorrect under the intended interpretation. Hanks and Mc Dermott showed that many other approaches to default reasoning give similarly incorrect results. However, Morris <ref> [127] </ref> showed that the default theory which has no facts but contains the two non-normal defaults : M : q : M : r yields only one extension, containing q, which is the correct result. In con trast, all natural representations of the problem in Theorist give incorrect results. <p> In the JTMS changing an assumption is done by changing an OUT label to IN. 86 Suppose, for example, that we are given the justifications p ~ q corresponding to the propositional form of the Yale shooting problem. As Morris <ref> [127] </ref> observes, these correctly determine that q is labelled IN and that r and p are labelled OUT. If the JTMS is subsequently informed that p is true, then dependency-directed backtracking will install a justification for r, changing its label from OUT to IN.
Reference: [128] <author> Nebel, B., </author> <title> A knowledge level analysis of belief revision. </title> <booktitle> Proc. 1st International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> Toronto (1989) 301-311 </address>
Reference-contexts: Both of these updates satisfy the integrity constraints. However, only the first update satisfies the integrity constraints if we are given the further update insert mother (sue; bob): The general problem of belief revision has been studied formally in <ref> [65, 128, 129, 37] </ref>. <p> We have seen that the process of belief revision also needs to be considered within a KA context. In particular, it could be useful to investigate relationships between the belief revision frameworks of <ref> [37, 65, 128, 129] </ref> and various integrity constraint checking and restoration procedures. The extension of LP to include integrity constraints is useful both for abduc-tive LP and for deductive databases.
Reference: [129] <author> Nebel, B., </author> <title> Belief revision and default reasoning: syntax-based approaches. </title> <booktitle> Proc. 2nd International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> Cambridge, Mass. </address> <year> (1991) </year> <month> 417-428 </month>
Reference-contexts: Both of these updates satisfy the integrity constraints. However, only the first update satisfies the integrity constraints if we are given the further update insert mother (sue; bob): The general problem of belief revision has been studied formally in <ref> [65, 128, 129, 37] </ref>. <p> We have seen that the process of belief revision also needs to be considered within a KA context. In particular, it could be useful to investigate relationships between the belief revision frameworks of <ref> [37, 65, 128, 129] </ref> and various integrity constraint checking and restoration procedures. The extension of LP to include integrity constraints is useful both for abduc-tive LP and for deductive databases.
Reference: [130] <author> Pearce, D., Wagner, G., </author> <title> Logic programming with strong negation. </title> <booktitle> Proc. Workshop on Extensions of Logic Programming, Springer Ver-lag Lecture Notes in Computer Science (1991) </booktitle>
Reference-contexts: However, as we will see below, because the contrapositives of extended clauses do not hold, the term "classical negation" can be regarded as inappropriate. For this reason we use the term "explicit negation" instead. A similar notion has been investigated by Pearce and Wagner <ref> [130] </ref>, who develop an extension of definite programs by means of Nelson's strong negation. They also suggest the possibility of combining strong negation with NAF.
Reference: [131] <author> Pearl, J., </author> <title> Embracing causality in formal reasoning. </title> <booktitle> Proc. AAAI '87, </booktitle> <address> Washington, Seattle (1987) 360-373 </address>
Reference-contexts: Abduction is widely used in common-sense reasoning, for instance in diagnosis, to reason from effect to cause [22, 142]. We consider here an example drawn from <ref> [131] </ref>. 4 Example 1.1 Consider the following theory T grass-is-wet rained-last-night grass-is-wet sprinkler-was-on shoes-are-wet grass-is-wet: If we observe that our shoes are wet, and we want to know why this is so, frained-last-nightg is a possible explanation, i.e. a set of hypotheses that together with the explicit knowledge in T implies
Reference: [132] <author> Pearl, J., </author> <title> Probabilistic reasoning in intelligent systems: Networks of plausible inference. </title> <publisher> (Morgan Kaufmann, </publisher> <address> San Mateo, California,1988) </address>
Reference-contexts: In section 3 we will further discuss the use of abduction for default reasoning in greater detail. Because negation as failure in LP is a form of default reasoning, its interpretation by means of abduction will be discussed in section 4. Some authors (e.g. Pearl <ref> [132] </ref>) advocate the use of probability theory as an alternative approach to common sense reasoning in general, and to many of the applications listed above in particular. However, Poole [149] shows how abduction can be used to simulate (discrete) Bayesian networks in probability theory.
Reference: [133] <author> Peirce, C.S., </author> <title> Collected papers of Charles Sanders Peirce. </title> <booktitle> Vol.2, </booktitle> <pages> 1931-1958, </pages> <editor> Hartshorn et al. eds., </editor> <publisher> Harvard University Press </publisher>
Reference-contexts: We also discuss recent work on the argumentation-theoretic interpretation of abduction, which was introduced in the earlier version of this paper. The philosopher Pierce first introduced the notion of abduction. In <ref> [133] </ref> he identified three distinguished forms of reasoning. Deduction, an analytic process based on the application of general rules to particular cases, with the inference of a result. Induction, synthetic reasoning which infers the rule from the case and the result.
Reference: [134] <author> Pereira, L.M., Alferes, J.J., Aparicio, J.N., </author> <title> Contradiction removal semantics with explicit negation Proc. </title> <booktitle> Applied Logic Conference, </booktitle> <month> Ams-terdam </month> <year> (1992) </year> <month> 106 </month>
Reference-contexts: This method [137] is not able to restore consistency in all cases, as illustrated by the following example. Example 6.2 given the extended logic program p q r ~ p the method of [137] is unable to restore consistency by withdrawing the hypothesis p fl . In <ref> [134] </ref> and [140], Pereira and Alferes present two different modifications of the method of [137] to deal with this problem. For the program in example 6.2, the method in [134] restores consistency by letting p undefined, while the method in [140] restores consistency by assigning p to truth. <p> In <ref> [134] </ref> and [140], Pereira and Alferes present two different modifications of the method of [137] to deal with this problem. For the program in example 6.2, the method in [134] restores consistency by letting p undefined, while the method in [140] restores consistency by assigning p to truth. This second method is more suitable for diagnosis applications. <p> For the program in example 6.2, the method in [134] restores consistency by letting p undefined, while the method in [140] restores consistency by assigning p to truth. This second method is more suitable for diagnosis applications. Both methods, [46] and <ref> [137, 134, 140] </ref>, can deal only with inconsistencies that can be attributed to NAF hypotheses, as shown by the following example.
Reference: [135] <author> Pereira, L.M., Alferes, J.J., </author> <title> Well-founded semantics for logic programs with explicit negation. </title> <booktitle> Proc. 92 European Conference on Artificial Intelligence, ECAI 'Vienna,Austria 1992 (1)02-106 </booktitle>
Reference-contexts: In the extended logic program which results from the transformation described above, if :p holds then ~ p holds in the corresponding general logic program, for any atom p. We can argue, therefore, that the transformed extended logic program satisfies the coherence principle, proposed by Pereira and Alferes <ref> [135] </ref>, namely that whenever :p holds then ~ p must also hold. They consider the satisfaction of this principle to be a desirable property of any semantics for ELP, as illustrated by the following example, taken from [3]. <p> Example 6.5 Given the extended logic program :drivers strike take bus ~ drivers strike one should derive the conclusion take bus. 76 The coherence principle automatically holds for the answer set semantics. Pereira and Alferes <ref> [135] </ref> and Alferes, Dung and Pereira [3] have defined new semantics for ELP that incorporates the coherence principle. These semantics are adaptations of Przymuszynski's extended stable model semantics [153] and Dung's preferred extension semantics [39], respectively, to ELP. <p> These semantics are adaptations of Przymuszynski's extended stable model semantics [153] and Dung's preferred extension semantics [39], respectively, to ELP. Alferes, Damasio and Pereira [2] provide a sound and complete proof procedure for the semantics in <ref> [135] </ref>. <p> For example, the program p ~ p; ~ q admits both f~ qg and f~ pg as admissible extensions, while the only intuitively correct extension is f~ qg. Alferes and Pereira [4] use argumentation-theoretic notions to extend the well-founded semantics for ELP in <ref> [135] </ref>.
Reference: [136] <author> Pereira, L.M., Aparicio, J.N., Alferes, J.J., </author> <title> Non-monotonic reasoning with well-founded semantics. </title> <booktitle> Proc. 8th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Paris (1991) </address>
Reference-contexts: Example 5.8 Consider the propositional abductive framework hP; A; Ii where P is p a A = fag, and I = ;. The well-founded model of hP; A; Ii is ;. In <ref> [136] </ref>, Pereira, Aparicio and Alferes define an alternative, generalised well-founded semantics for ALP where first programs are extended by a set of abducibles as in the case of generalised stable models, and then the well-founded semantics (rather than stable model semantics) is applied to the extended programs. <p> Kakas, Mancarella and Dung [99] also define a well-founded semantics for ELP based upon argumentation-theoretic notions. 6.6 A methodology for default reasoning with explicit negation Compared with other authors, who primarily focus on extending or modifying the semantics of LP to deal with default reasoning, Pereira, Aparicio and Alferes <ref> [136] </ref> develop a methodology for performing default reasoning with extended logic programs. Defaults of the form "normally if q then p" are represented by an extended clause p q; ~ : nameqp; ~ : p (4) where the condition nameqp can be understood as a name given to the default. <p> the more general default (5), we add the additional clause : birds f ly (X) penguin (X); ~ : penguins don 0 t f ly (X): Then to express that superpenguins fly, we can add the rule: :penguins don 0 t f ly (X) superpenguin (X): Pereira, Aparicio and Alferes <ref> [136] </ref> use the well-founded semantics extended with explicit negation to give a semantics for this methodology for default reasoning. However it is worth noting that any other semantics of extended logic programs could also be used. <p> For example Inoue [81, 80] uses an extension of the answer set semantics (see section 6.2), but for a slightly different transformation. 80 6.7 ELP with abduction Inoue [80] (see also section 6.3) and Pereira, Aparicio and Alferes <ref> [136] </ref> investigate extended logic programs with abducibles but without integrity constraints. They transform such programs into extended logic programs without abduction by adding a new pair of clauses p (X) ~ : p (X) for each abducible predicate p. <p> Notice that the transformation is identical to that of Satoh and Iwayama [170] presented in section 5.5, except for the use of explicit negation instead of new predicates. Inoue [80] and Pereira, Aparicio and Alferes <ref> [136] </ref> assign different semantics to the resulting program. Whereas Inoue applies the answer set semantics, Pereira, Aparicio and Alferes apply the extended stable model semantics of [153]. Pereira, Aparicio and Alferes [138] have also developed proof procedures for this semantics. As mentioned above, Pereira, Aparicio and Alferes [136] understand the transformed <p> Aparicio and Alferes <ref> [136] </ref> assign different semantics to the resulting program. Whereas Inoue applies the answer set semantics, Pereira, Aparicio and Alferes apply the extended stable model semantics of [153]. Pereira, Aparicio and Alferes [138] have also developed proof procedures for this semantics. As mentioned above, Pereira, Aparicio and Alferes [136] understand the transformed programs in terms of (three-valued) extended stable models. This has the advantage that it gives a semantics to every logic program and it does not force abducibles to be either believed or disbelieved.
Reference: [137] <author> Pereira, L.M., Aparicio, J.N., Alferes, J.J., </author> <title> Contradiction removal within well-founded semantics. </title> <booktitle> Proc. 1st International Workshop on Logic Programming and Nonmonotonic Reasoning (Nerode, </booktitle> <editor> Marek and Subrahmanian eds.), </editor> <address> Washington DC (1991) </address>
Reference-contexts: In the example above we can restore consistency by rejecting the NAF assumption ~ bird (tom) even though bird (tom) does not hold. We then get the consistent set fbat (tom); f ly (tom)g. This problem has been studied in [46] and <ref> [137] </ref>. Both of these studies are primarily concerned with the related problem of inconsistency of the well-founded semantics when applied to extended logic programs [153]. <p> The new integrity constraints in I fl have the effect of removing a NAF hypothesis when it leads to a contradiction. Clearly, any other semantics for logic programs with integrity constraints could also be applied to this framework. Pereira, Aparicio and Alferes <ref> [137] </ref> employ a similar approach within the context of Przymuszynski's extended stable models [153]. It consists in identifying explicitly all the possible sets of NAF hypotheses which lead to an inconsistency and then restoring consistency by removing at least one hypothesis from each such set. <p> In fact Pereira, Aparicio and Alferes have also used this method to study counterfactual reasoning [139]. Alferes and Pereira [5] have shown that this method of restoring consistency can also be viewed in terms of inconsistency avoidance. This method <ref> [137] </ref> is not able to restore consistency in all cases, as illustrated by the following example. Example 6.2 given the extended logic program p q r ~ p the method of [137] is unable to restore consistency by withdrawing the hypothesis p fl . <p> This method <ref> [137] </ref> is not able to restore consistency in all cases, as illustrated by the following example. Example 6.2 given the extended logic program p q r ~ p the method of [137] is unable to restore consistency by withdrawing the hypothesis p fl . In [134] and [140], Pereira and Alferes present two different modifications of the method of [137] to deal with this problem. <p> Example 6.2 given the extended logic program p q r ~ p the method of <ref> [137] </ref> is unable to restore consistency by withdrawing the hypothesis p fl . In [134] and [140], Pereira and Alferes present two different modifications of the method of [137] to deal with this problem. For the program in example 6.2, the method in [134] restores consistency by letting p undefined, while the method in [140] restores consistency by assigning p to truth. This second method is more suitable for diagnosis applications. <p> For the program in example 6.2, the method in [134] restores consistency by letting p undefined, while the method in [140] restores consistency by assigning p to truth. This second method is more suitable for diagnosis applications. Both methods, [46] and <ref> [137, 134, 140] </ref>, can deal only with inconsistencies that can be attributed to NAF hypotheses, as shown by the following example.
Reference: [138] <author> Pereira, L.M., Aparicio, J.N., Alferes, J.J., </author> <title> Derivation procedures for extended stable models. </title> <booktitle> Proc. 12th International Joint Conference on Artificial Intelligence, </booktitle> <address> Sidney (1991) 863-868 </address>
Reference-contexts: Inoue [80] and Pereira, Aparicio and Alferes [136] assign different semantics to the resulting program. Whereas Inoue applies the answer set semantics, Pereira, Aparicio and Alferes apply the extended stable model semantics of [153]. Pereira, Aparicio and Alferes <ref> [138] </ref> have also developed proof procedures for this semantics. As mentioned above, Pereira, Aparicio and Alferes [136] understand the transformed programs in terms of (three-valued) extended stable models.
Reference: [139] <author> Pereira, L.M., Aparicio, J.N., Alferes, J.J., </author> <title> Counterfactual reasoning based on revising assumptions. </title> <booktitle> Proc. </booktitle> <address> ISLP '91, San Diego (1991) </address>
Reference-contexts: In fact Pereira, Aparicio and Alferes have also used this method to study counterfactual reasoning <ref> [139] </ref>. Alferes and Pereira [5] have shown that this method of restoring consistency can also be viewed in terms of inconsistency avoidance. This method [137] is not able to restore consistency in all cases, as illustrated by the following example.
Reference: [140] <author> Pereira, L.M., Damasio, C.V., Alferes, J.J., </author> <title> Diagnosis and debugging as contradiction removal. </title> <booktitle> Proc. 2nd International Workshop on Logic Programming and Nonmonotonic Reasoning MIT press (Pereira and Nerode eds.), </booktitle> <address> Lisbon (1993) 316-330 </address>
Reference-contexts: This method [137] is not able to restore consistency in all cases, as illustrated by the following example. Example 6.2 given the extended logic program p q r ~ p the method of [137] is unable to restore consistency by withdrawing the hypothesis p fl . In [134] and <ref> [140] </ref>, Pereira and Alferes present two different modifications of the method of [137] to deal with this problem. For the program in example 6.2, the method in [134] restores consistency by letting p undefined, while the method in [140] restores consistency by assigning p to truth. <p> In [134] and <ref> [140] </ref>, Pereira and Alferes present two different modifications of the method of [137] to deal with this problem. For the program in example 6.2, the method in [134] restores consistency by letting p undefined, while the method in [140] restores consistency by assigning p to truth. This second method is more suitable for diagnosis applications. Both methods, [46] and [137, 134, 140], can deal only with inconsistencies that can be attributed to NAF hypotheses, as shown by the following example. <p> For the program in example 6.2, the method in [134] restores consistency by letting p undefined, while the method in [140] restores consistency by assigning p to truth. This second method is more suitable for diagnosis applications. Both methods, [46] and <ref> [137, 134, 140] </ref>, can deal only with inconsistencies that can be attributed to NAF hypotheses, as shown by the following example.
Reference: [141] <author> Pimentel, S. G., Cuadrado, J. L., </author> <title> A truth maintenance system based on stable models. </title> <booktitle> Proc. </booktitle> <month> NACLP '89 </month> <year> (1989) </year>
Reference-contexts: Several authors have observed that the JTMS can be given a semantics corresponding to the semantics of logic programs, by interpreting justifications as propositional logic program clauses, and interpreting ~ p i as NAF of p i . The papers <ref> [49, 71, 92, 141] </ref>, in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program.
Reference: [142] <author> Pople, H. E. Jr., </author> <booktitle> On the mechanization of abductive logic. Proc. 3rd International Joint Conference on Artificial Intelligence, </booktitle> <year> (1973) </year> <month> 147-152 </month>
Reference-contexts: Abduction is widely used in common-sense reasoning, for instance in diagnosis, to reason from effect to cause <ref> [22, 142] </ref>.
Reference: [143] <author> Poole, D., </author> <title> On the comparison of theories: preferring the most specific explanation. </title> <booktitle> Proc. 9th International Joint Conference on Artificial Intelligence, </booktitle> <address> Los Angeles, Ca (1985) 144-147 </address>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [13, 22, 61, 77, 143, 148, 180] </ref>. Cox and Pietrzykowski [29] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not 6 be explainable in terms of other explanations. <p> In the case of normal logic programming, their semantics gives the same result as the acceptability semantics in example 4.7. Simari and Loui [177] define an argumentation-theoretic framework for default reasoning in general. They combine a notion of acceptability with Poole's notion of "most specific" explanation <ref> [143] </ref>, to deal with hierarchies 40 of defaults.
Reference: [144] <author> Poole, D., </author> <title> Variables in hypotheses. </title> <booktitle> Proc. 10th International Joint Conference on Artificial Intelligence, </booktitle> <address> Milan (1987) 905-908 107 </address>
Reference: [145] <author> Poole, D., </author> <title> A logical framework for default reasoning. </title> <note> Artificial Intelli--gence 36 (1988) 27-47 </note>
Reference-contexts: been proposed to restrict the number of candidate explanations: * Once we restrict the hypotheses to belong to a specified set of sentences, we can further restrict, without loss of generality, the hypotheses to atoms (that "name" these sentences) which are predicates explicitly indicated as abducible, as shown by Poole <ref> [145] </ref>. * In section 1.2 we will discuss the use of integrity constraints to reduce the number of possible explanations. * Additional information can help to discriminate between different explanations, by rendering some of them more appropriate or plausible than others. <p> Default reasoning concerns the use of general rules to derive information in the absence of contradictions. In the application of abduction to default reasoning, conclusions are viewed as observations to be explained by means of assumptions which hold by default unless a contradiction can be shown <ref> [53, 145] </ref>. As Poole [145] argues, the use of abduction avoids the need to develop a non-classical, non-monotonic logic for default reasoning. In section 3 we will further discuss the use of abduction for default reasoning in greater detail. <p> In the application of abduction to default reasoning, conclusions are viewed as observations to be explained by means of assumptions which hold by default unless a contradiction can be shown [53, 145]. As Poole <ref> [145] </ref> argues, the use of abduction avoids the need to develop a non-classical, non-monotonic logic for default reasoning. In section 3 we will further discuss the use of abduction for default reasoning in greater detail. <p> As already mentioned in section 1, Poole, Goebel and Aleliunas [150] and Poole <ref> [145] </ref> propose an alternative formalisation of default reasoning in terms of abduction. <p> The new theory F [ should be consistent. This process of theory formation is a form of abduction, where variable-free instances of defaults in D are the candidate abducibles. Poole <ref> [145] </ref> shows that the semantics of the theory formation framework hF ; Di is equivalent to that of an abductive framework hF 0 ; A; ;i (see section 1.2) where the default formulae are all atomic. <p> Any such method will be very useful in practice in view of the many diverse applications of abductive reasoning, including default reasoning. The Theorist framework of <ref> [145, 150] </ref> provides such an implementation of abduction by means of a resolution based proof procedure. In their study of NAF through abduction Eshghi and Kowalski [54] have defined an abductive proof procedure for NAF in logic programming. <p> Example 6.3 It is not possible to restore consistency by removing NAF hypotheses given the program: p 71 However, Inoue [81, 80] suggests a general method for restoring consistency, which is applicable to this case. This method (see also section 6.3) is based on [66] and <ref> [145] </ref> and consists in isolating inconsistencies by finding maximally consistent subprograms. In this approach a knowledge system is represented by a pair (P; H), where: 1. P and H are both extended logic programs, 2. P represents a set of facts, 3. H represents a set of assumptions. <p> In this approach a knowledge system is represented by a pair (P; H), where: 1. P and H are both extended logic programs, 2. P represents a set of facts, 3. H represents a set of assumptions. The semantics is given using abduction as in <ref> [145] </ref> (see section 3) by means of theory extensions P [ of P , with H maximal with respect to set inclusion, such that P [ has a consistent answer set. <p> However, this approach can be extended, as we shall see in section 6.6. More direct approaches to the problem of treating positive and negative predicates symmetrically in default reasoning are presented in [81, 80], following the methods of [66] and <ref> [145] </ref> (see section 6.2 for a discussion), and in [87, 99], based on an argumentation-theoretic framework (see sections 6.4 and 7). 74 6.4 (Extended) Logic Programming without Nega- tion as Failure Kakas, Mancarella and Dung [99] show that the Kowalski-Sadri transformation presented in section 6.3 can be applied in the reverse
Reference: [146] <author> Poole, D., </author> <title> Representing knowledge for logic-based diagnosis. </title> <booktitle> Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1988) 1282-1290 </address>
Reference-contexts: Abduction can be used to generate causal explanations for fault diagnosis (see for example [25, 151]). In medical diagnosis, for example, the candidate hypotheses are the possible causes (diseases), and the observations are the symptoms to be explained <ref> [146, 155] </ref>. Abduction can also be used for model-based diagnosis [51, 159].
Reference: [147] <author> Poole, D., </author> <title> Explanation and prediction: an architecture for default and abductive reasoning. </title> <note> Computational Intelligence Journal 5 (1989) 97-110 </note>
Reference-contexts: The distinction between default reasoning and non-default abduction is also made in Konolige's proposal [103], which combines abduction for non-default hypothetical reasoning with default logic [158] for default reasoning. This proposal is similar, therefore, to the way in which generalised stable models combine abduction with NAF. Poole <ref> [147] </ref>, on the other hand, proposes an abductive framework where abducibles can be specified either as default, like persists, or non-default, like happens. In [183], Toni and Kowalski show how both default and non-default abducibles can be reduced to NAF. This reduction is discussed in section 5.5 below.
Reference: [148] <author> Poole, D., </author> <title> Logic programming, abduction and probability. </title> <booktitle> Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1992) 530-538 </address>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [13, 22, 61, 77, 143, 148, 180] </ref>. Cox and Pietrzykowski [29] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not 6 be explainable in terms of other explanations.
Reference: [149] <author> Poole, D., </author> <title> Probabilistic Horn abduction and Bayesian networks. </title> <booktitle> Artificial Intelligence 64 (1993) 81-129 </booktitle>
Reference-contexts: Some authors (e.g. Pearl [132]) advocate the use of probability theory as an alternative approach to common sense reasoning in general, and to many of the applications listed above in particular. However, Poole <ref> [149] </ref> shows how abduction can be used to simulate (discrete) Bayesian networks in probability theory.
Reference: [150] <author> Poole, D., Goebel, R.G., Aleliunas, </author> <title> Theorist: a logical reasoning system for default and diagnosis. The Knowledge Fronteer: Essays in the Representation of Knowledge, </title> <editor> Cercone and McCalla eds, </editor> <booktitle> Springer Ver-lag Lecture Notes in Computer Science (1987) 331-352 </booktitle>
Reference-contexts: Cox and Pietrzykowski [29] construct hypotheses from the "dead ends" of linear resolution proofs. Finger and Genesereth [57] generate "deductive solutions to design problems" using the "residue" left behind in resolution proofs. Poole, Goebel and Aleliunas <ref> [150] </ref> also use linear resolution to generate hypotheses. 7 In contrast, the ATMS [102] computes abductive explanations bottom-up. The ATMS can be regarded as a form of hyper-resolution, augmented with subsumption, for propositional logic programs [162]. <p> As already mentioned in section 1, Poole, Goebel and Aleliunas <ref> [150] </ref> and Poole [145] propose an alternative formalisation of default reasoning in terms of abduction. <p> Any such method will be very useful in practice in view of the many diverse applications of abductive reasoning, including default reasoning. The Theorist framework of <ref> [145, 150] </ref> provides such an implementation of abduction by means of a resolution based proof procedure. In their study of NAF through abduction Eshghi and Kowalski [54] have defined an abductive proof procedure for NAF in logic programming.
Reference: [151] <author> Preist, C., Eshghi, K., </author> <title> Consistency-based and abductive diagnoses as generalised stable models. </title> <booktitle> Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1992) 514-521 </address>
Reference-contexts: In general, abduction is appropriate for reasoning with incomplete information. The generation of abducibles to solve a top-level goal can be viewed as the addition of new information to make incomplete information more complete. Abduction can be used to generate causal explanations for fault diagnosis (see for example <ref> [25, 151] </ref>). In medical diagnosis, for example, the candidate hypotheses are the possible causes (diseases), and the observations are the symptoms to be explained [146, 155]. Abduction can also be used for model-based diagnosis [51, 159].
Reference: [152] <author> Przymusinski, </author> <title> T.C., On the declarative and procedural semantics of logic programs. </title> <note> Journal of Automated Reasoning 5 (1989) 167-205 </note>
Reference-contexts: This assumption has the advantage that all explanations are thereby guaranteed to be basic. Semantics and proof procedures for ALP have been proposed by Eshghi and Kowalski [53], Kakas and Mancarella [90] and Chen and Warren [23]. Chen and Warren extend the perfect model semantics of Przymusinski <ref> [152] </ref> to include abducibles and integrity constraints over abducibles. Here we shall concentrate on the proposal of Kakas and Mancarella, which extends the stable model semantics. 5.1 Generalised stable model semantics Kakas and Mancarella [90] develop a semantics for ALP by generalising the stable model semantics for LP.
Reference: [153] <author> Przymusinski, </author> <title> T.C., Extended stable semantics for normal and disjunctive programs. </title> <booktitle> Proc. 7th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Jerusalem (1990) 459-477 </address>
Reference-contexts: For the overall class of general logic programs, moreover, it is possible to argue that it is the semantics and not the proof procedure that is at fault. Indeed, Sacca and Zaniolo [164], Przymusinski <ref> [153] </ref> and others have argued that the totality requirement of stable models is too strong. They relax this requirement and consider partial or three-valued stable models instead. In the context of the abductive semantics of NAF this is an argument against the disjunctive integrity constraints. <p> Notice that, although Gelfond and Lifschitz define the answer set semantics directly without transforming the program and then applying the stable model semantics, the transformation can also be used with any other semantics for the resulting transformed program. Thus Przymusinski <ref> [153] </ref> for example applies the well-founded semantics to extended logic programs. Similarly any other semantics can also be applied. As we have seen before, this is one of the main advantages of transformational semantics in general. <p> We then get the consistent set fbat (tom); f ly (tom)g. This problem has been studied in [46] and [137]. Both of these studies are primarily concerned with the related problem of inconsistency of the well-founded semantics when applied to extended logic programs <ref> [153] </ref>. To deal with the problem of inconsistency in extended logic programs, Dung and Ruamviboonsuk [46] apply the preferred extension semantics to a new abductive framework derived from an extended logic program. <p> Clearly, any other semantics for logic programs with integrity constraints could also be applied to this framework. Pereira, Aparicio and Alferes [137] employ a similar approach within the context of Przymuszynski's extended stable models <ref> [153] </ref>. It consists in identifying explicitly all the possible sets of NAF hypotheses which lead to an inconsistency and then restoring consistency by removing at least one hypothesis from each such set. <p> Pereira and Alferes [135] and Alferes, Dung and Pereira [3] have defined new semantics for ELP that incorporates the coherence principle. These semantics are adaptations of Przymuszynski's extended stable model semantics <ref> [153] </ref> and Dung's preferred extension semantics [39], respectively, to ELP. Alferes, Damasio and Pereira [2] provide a sound and complete proof procedure for the semantics in [135]. <p> Inoue [80] and Pereira, Aparicio and Alferes [136] assign different semantics to the resulting program. Whereas Inoue applies the answer set semantics, Pereira, Aparicio and Alferes apply the extended stable model semantics of <ref> [153] </ref>. Pereira, Aparicio and Alferes [138] have also developed proof procedures for this semantics. As mentioned above, Pereira, Aparicio and Alferes [136] understand the transformed programs in terms of (three-valued) extended stable models.
Reference: [154] <author> T. Przymusinski, </author> <title> Semantics of disjunctive logic programs and deductive databases. </title> <booktitle> Proc. DOOD '91 (1991) </booktitle>
Reference-contexts: An extension P fl [ is complete if * P fl [ is consistent with I fl and * = fp fl j for each attack E against fp fl g; attacks Eg (i.e. is admissible and it contains all hypotheses it can defend against all attacks). Stationary expansions <ref> [154] </ref> are equivalent to complete extensions, as shown in [16]. Moreover, Dung shows that the well-founded model [187] is the smallest complete extension that can be constructed bottom-up from the empty set of negative hypotheses, by adding incrementally all admissible hypotheses.
Reference: [155] <author> Reggia, J., </author> <title> Diagnostic experts systems based on a set-covering model. </title> <note> International Journal of Man-Machine Studies 19(5) (1983) 437-460 108 </note>
Reference-contexts: There are other formalisations of abduction. We mention them for completeness, but in the sequel we will concentrate on the logic-based view previously described. * Allemand, Tanner, Bylander and Josephson [6] and Reggia <ref> [155] </ref> present a mathematical characterisation, where abduction is defined over sets of observations and hypotheses, in terms of coverings and parsimony. * Levesque [117] gives an account of abduction at the "knowledge level". <p> Abduction can be used to generate causal explanations for fault diagnosis (see for example [25, 151]). In medical diagnosis, for example, the candidate hypotheses are the possible causes (diseases), and the observations are the symptoms to be explained <ref> [146, 155] </ref>. Abduction can also be used for model-based diagnosis [51, 159].
Reference: [156] <author> Reinfrank, M., Dessler, O., </author> <title> On the relation between truth maintenance and non-monotonic logics. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1206-1212 </address>
Reference-contexts: The papers [49, 71, 92, 141], in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. Several authors <ref> [49, 59, 92, 156] </ref>, exploiting the interpretation of stable models as autoepistemic expansions [68], have shown a correspondence between well-founded labellings and stable expansions of the set of justifications viewed as autoepistemic theories.
Reference: [157] <author> Reiter, R., </author> <title> On closed world data bases. Logic and Databases, </title> <editor> Gallaire and Minker eds., </editor> <publisher> Plenum, </publisher> <address> New York(1978) 55-76 </address>
Reference-contexts: This is appropriate when the closed world assumption <ref> [157] </ref>, that the program gives a complete definition of the positive instances of a predicate, can safely be applied. It is not appropriate when the definition of a predicate is incomplete and therefore "open", as in the case of abducible predicates.
Reference: [158] <author> Reiter, R., </author> <title> A Logic for default reasoning. </title> <booktitle> Artificial Intelligence 13 (1980) 81-132 </booktitle>
Reference-contexts: One of the most important formalisations of default reasoning is the Default Logic of Reiter <ref> [158] </ref>. Reiter separates beliefs into two kinds, ordinary sentences used to express "facts" and default rules of inference used to express general rules. <p> In contrast, the abduction of happens is used for non-default hypothetical reasoning. The distinction between default reasoning and non-default abduction is also made in Konolige's proposal [103], which combines abduction for non-default hypothetical reasoning with default logic <ref> [158] </ref> for default reasoning. This proposal is similar, therefore, to the way in which generalised stable models combine abduction with NAF. Poole [147], on the other hand, proposes an abductive framework where abducibles can be specified either as default, like persists, or non-default, like happens. <p> To give an idea of this framework, we show here how a simplified version of the framework can be used to define an abstract notion of stable semantics which includes as special cases stable models for logic programs and extensions for default logic <ref> [158] </ref>, autoepistemic logic [126] and non-monotonic logic II [119]. We follow the approach of Bondarenko, Dung, Kowalski and Toni [12] (see also [87]). Let T be a set of sentences in any monotonic logic, ` the provability operator for that logic and A a set of candidate abducible sentences.
Reference: [159] <author> Reiter, R., </author> <title> A theory of diagnosis from first principle. </title> <booktitle> Artificial Intelligence 32 (1987) </booktitle>
Reference-contexts: Abduction can be used to generate causal explanations for fault diagnosis (see for example [25, 151]). In medical diagnosis, for example, the candidate hypotheses are the possible causes (diseases), and the observations are the symptoms to be explained [146, 155]. Abduction can also be used for model-based diagnosis <ref> [51, 159] </ref>. In this case the theory describes the "normal" behaviour of the system, and the task is to find a set of hypotheses of the form "some component A is not normal" that explains why the behaviour of the system is not normal.
Reference: [160] <author> Reiter, R., </author> <title> On integrity constraints. </title> <booktitle> Proc. 2nd Conference on Theoretical Aspects of Reasoning about Knowledge, </booktitle> <editor> Moshe Y. Vardi ed., </editor> <address> Pacific Grove, California (1988) </address>
Reference-contexts: Another view of integrity constraints <ref> [85, 90, 107, 160, 161] </ref> regards these as epistemic or metalevel statements about the content of the database. In this case the integrity constraints are understood as statements at a different level from those in the knowledge base.
Reference: [161] <author> Reiter, R., </author> <title> On asking what a database knows. </title> <booktitle> Proc. Symposium on Computational Logic, </booktitle> <editor> Lloyd ed., </editor> <booktitle> Springer Verlag Lecture Notes in Computer Science (1990) </booktitle>
Reference-contexts: Another view of integrity constraints <ref> [85, 90, 107, 160, 161] </ref> regards these as epistemic or metalevel statements about the content of the database. In this case the integrity constraints are understood as statements at a different level from those in the knowledge base.
Reference: [162] <author> Reiter, R., deKleer, J., </author> <title> Foundations of assumption-based truth maintenance systems: preliminary report. </title> <booktitle> Proc. AAAI '87, </booktitle> <address> Washington, Seattle (1987) 183-188 </address>
Reference-contexts: Poole, Goebel and Aleliunas [150] also use linear resolution to generate hypotheses. 7 In contrast, the ATMS [102] computes abductive explanations bottom-up. The ATMS can be regarded as a form of hyper-resolution, augmented with subsumption, for propositional logic programs <ref> [162] </ref>. Lamma and Mello [115] have developed an extension of the ATMS for the non-propositional case. Resolution-based techniques for computing abduction have also been developed by Demolombe and Fari~nas del Cerro [31] and Gaifman and Shapiro [64]. Abduction can also be applied to logic programming (LP). <p> The dependence r a; b; c; d is not recorded because it is subsumed by the dependence r a; b; c: Reiter and deKleer <ref> [162] </ref> show that, given a set of justifications, nogoods, and candidate assumptions, the ATMS can be understood as computing minimal and consistent abductive explanations in the propositional case (where assumptions are interpreted as abductive hypotheses).
Reference: [163] <author> Rodi, W.L., Pimentel, S.G., </author> <title> A non-monotonic ATMS using stable bases. </title> <booktitle> Proc. 2nd International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> Cambridge, Mass. </address> <year> (1991) </year>
Reference-contexts: Other non-monotonic extensions of ATMS have been developed in <ref> [84, 163] </ref>. It should be noted that one difference between ATMS and ALP is the requirement in ATMS that only minimal sets of assumptions be recorded. This minimality of assumptions is essential for the computational efficiency of the ATMS.
Reference: [164] <author> Sacca, D., Zaniolo, C., </author> <title> Stable models and non determinism for logic programs with negation Proc. </title> <booktitle> ACM SIGMOD-SIGACT Symposium on Principles of Database Systems (1990) 205-217 </booktitle>
Reference-contexts: For the overall class of general logic programs, moreover, it is possible to argue that it is the semantics and not the proof procedure that is at fault. Indeed, Sacca and Zaniolo <ref> [164] </ref>, Przymusinski [153] and others have argued that the totality requirement of stable models is too strong. They relax this requirement and consider partial or three-valued stable models instead. In the context of the abductive semantics of NAF this is an argument against the disjunctive integrity constraints. <p> The preferred extension semantics provides a unifying framework for various approaches to the semantics of negation in LP. Kakas and Mancarella [95] show that it is equivalent to Sacca and Zaniolo's partial stable model semantics <ref> [164] </ref>. Like the partial stable model semantics, it includes the stable model semantics as a special case. Dung [39] also defines the notion of complete extension.
Reference: [165] <author> Sadri, F., Kowalski, R.A., </author> <title> An application of general purpose theorem-proving to database integrity. Foundations of Deductive Databases and Logic Programming, </title> <editor> Minker ed., </editor> <publisher> Morgan Kaufmann Publishers, </publisher> <address> Palo Alto (1987) 313-362 </address>
Reference-contexts: The consistency view requires that: KB satisfies iff KB [ is consistent: Alternatively the theoremhood view requires that: KB satisfies iff KB j= : These definitions have been proposed in the case where the theory is a logic program P by Kowalski and Sadri <ref> [165] </ref> and Lloyd and Topor [118] respectively, where KB is the Clark completion [24] of P . Another view of integrity constraints [85, 90, 107, 160, 161] regards these as epistemic or metalevel statements about the content of the database. <p> For each such semantics, we have a specification of the integrity checking problem. Although the different views of integrity satisfaction are conceptually very different, the integrity checking procedures based upon these views are not very different in practice (e.g. <ref> [30, 165, 118] </ref>). <p> A common idea of all these procedures is to render integrity checking more efficient by exploiting the assumption that the database before the update satisfies the integrity constraints, and therefore if integrity constraints are violated after the update, this violation should depend upon the update itself. In <ref> [165] </ref> this assumption is exploited by reasoning forward from the updates. This idea is exploited for the purpose of checking the satisfaction of abductive hypotheses in [54, 93, 94]. <p> Satoh and Iwayama [171], on the other hand, show how to extend the abduc-tive proof procedure of [54] to deal correctly with the stable model semantics. Their extension modifies the integrity checking method of <ref> [165] </ref> and deals more generally with arbitrary integrity constraints expressed in the form of denials. Casamayor and Decker [20] also develop an abductive proof procedure for NAF. Their proposal combines features of the Eshghi-Kowalski procedure with ancestor resolution.
Reference: [166] <author> Sakama, C., Inoue, K., </author> <title> Negation in disjunctive logic programs. </title> <booktitle> Proc. 10th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <month> Bu-dapest </month> <year> (1993) </year> <month> 703-719 109 </month>
Reference-contexts: This transformation is related to a similar transformation [82] for eliminating NAF. Elsewhere [167], Sakama and Inoue demonstrate a one-to-one correspondence between generalised stable models for ALP and possible models <ref> [166] </ref> for DLP. Consider, for example, the abductive logic program hP; A; Ii where P is p a A = fag and I is empty. M 1 = ; and M 2 = fa; pg are the generalised stable models of hP; A; Ii.
Reference: [167] <author> Sakama, C., Inoue, K., </author> <title> On the equivalence between disjunctive and abductive logic programs. </title> <booktitle> Proc. 11th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Santa Margherita Ligure, Italy (1994) 489-503 </address>
Reference-contexts: This transformation is related to a similar transformation [82] for eliminating NAF. Elsewhere <ref> [167] </ref>, Sakama and Inoue demonstrate a one-to-one correspondence between generalised stable models for ALP and possible models [166] for DLP. Consider, for example, the abductive logic program hP; A; Ii where P is p a A = fag and I is empty. <p> transformed into a disjunctive logic program P D p a 19 A description of this work can also be found in [76]. 61 P D has possible models M 0 1 = f*g, M 0 3 = f*; a; pg, such that M 0 2 f*g = M 0 Conversely, <ref> [167] </ref> shows how to transform DLP programs into ALP. For ex ample, consider the disjunctive logic program P D a _ b c whose possible models are M 1 = fc; ag, M 2 = fc; bg and M 3 = fc; a; bg. <p> Whereas the transformation of <ref> [167] </ref> deals with inclusive disjunction, Dung [41] presents a simpler transformation that deals with exclusive disjunction, but works only for the case of acyclic programs.
Reference: [168] <author> Sato, T., </author> <title> Completed logic programs and their consistency. </title> <note> Journal of Logic Programming 9 (1990) 33-44 </note>
Reference-contexts: In fact, following the result in [39], it can be proved that the proof procedure is sound for the class of order-consistent logic programs defined by Sato <ref> [168] </ref>. Intuitively, this is the class of programs which do not contain clauses giving rise to odd-step loops via NAF. For the overall class of general logic programs, moreover, it is possible to argue that it is the semantics and not the proof procedure that is at fault.
Reference: [169] <author> Satoh, K., </author> <title> A top-down proof procedure for default logic by using abduction. </title> <booktitle> Proc. European Conference on Artificial Intelligence, ECAI '94, </booktitle> <address> Amsterdam (1994) </address>
Reference-contexts: This notion of stability includes as special cases stable models in LP and extensions in default logic, autoepistemic logic and non-monotonic logic II. Based upon this abductive interpretation of default logic, Satoh <ref> [169] </ref> proposes a sound and complete proof procedure for default logic, by extending the proof procedure for ALP of [172]. At a similar level of abstraction, Kakas, Mancarella and Dung [99] also propose a general argumentation-theoretic framework based primarily on the acceptability semantics.
Reference: [170] <author> Satoh, K., Iwayama, N., </author> <title> Computing abduction using the TMS. </title> <booktitle> Proc. 8th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Paris (1991) 505-518 </address>
Reference-contexts: The proof procedure can be also modified to provide a sound computational mechanism for the generalised stable model semantics. This approach has been followed by Satoh and Iwayama <ref> [170] </ref>, as we illustrate in section 5.4. 5.3 An argumentation-theoretic interpretation of the abductive proof procedure for ALP Similarly to the LP case, the abductive proof procedure for ALP can be reinterpreted in argumentation-theoretic terms. <p> Thus the negation of an abducible is not interpreted as NAF. Moreover, since abducible predicates can be undefined some of the non abdicible predicates can also be undefined. 5.4 Computation of abduction through TMS Satoh and Iwayama <ref> [170] </ref> present a method for computing generalised stable models for logic programs with integrity constraints represented as denials. 55 The method is a bottom-up computation based upon the TMS procedure of [36]. <p> Example 5.9 Consider the program P p q q ~ r and the set of integrity constraints I = f: pg. P has two stable models M 1 = fp; qg and M 2 = frg, but only M 2 satisfies I. The proof procedure of <ref> [170] </ref> deterministically computes only the intended model M 2 , without first computing and then rejecting M 1 . In section 8 we will see more generally that truth maintenance systems can be regarded as a form of ALP. 5.5 Simulation of abduction Satoh and Iwayama [170] also show that an <p> The proof procedure of <ref> [170] </ref> deterministically computes only the intended model M 2 , without first computing and then rejecting M 1 . In section 8 we will see more generally that truth maintenance systems can be regarded as a form of ALP. 5.5 Simulation of abduction Satoh and Iwayama [170] also show that an abductive logic program can be transformed into a logic program without abducibles but where the integrity constraints remain. <p> Therefore, this transformation can only be used to eliminate default abducibles together with their integrity constraints. A more complete transformation [183] can be obtained by combining the use of retractibles to eliminate integrity constraints with the transformation of <ref> [170] </ref> for reducing non-default abducibles to NAF. <p> Note that the last two clauses in P 0 are those used by Satoh and Iwayama <ref> [170] </ref> to simulate non-default abduction by means of NAF. Toni and Kowalski [183] prove that the transformation is correct and complete in the sense that there is a one-to-one correspondence between attacks in the framework hP; A; Ii and in the framework corresponding to the transformed program P 0 . <p> They transform such programs into extended logic programs without abduction by adding a new pair of clauses p (X) ~ : p (X) for each abducible predicate p. Notice that the transformation is identical to that of Satoh and Iwayama <ref> [170] </ref> presented in section 5.5, except for the use of explicit negation instead of new predicates. Inoue [80] and Pereira, Aparicio and Alferes [136] assign different semantics to the resulting program. Whereas Inoue applies the answer set semantics, Pereira, Aparicio and Alferes apply the extended stable model semantics of [153]. <p> This has the advantage that the nogoods of the JTMS can be interpreted as integrity constraints of the abductive framework. The correspondence between abduction and the JTMS is reinforced by <ref> [170] </ref>, which gives a proof procedure to compute generalised stable models using the JTMS (see section 5.4). 8.2 Assumption-based truth maintenance Justifications in ATMS have the more restricted Horn clause form p p 1 ; : : : ; p n : However, whereas the JTMS maintains only one implicit context
Reference: [171] <author> Satoh, K., Iwayama, N., </author> <title> A correct top-down proof procedure for general logic programs with integrity constraints. </title> <booktitle> Proc. 3rd International Workshop on Extensions of Logic Programming (1992) 19-34 </booktitle>
Reference-contexts: In contrast, p fl holds in the semantics of [39], as well as in the stable model [68] and well-founded semantics [187]. Giordano, Martelli and Sapino [72] modify the abductive proof procedure so that the modification is sound and complete with respect to their semantics. Satoh and Iwayama <ref> [171] </ref>, on the other hand, show how to extend the abduc-tive proof procedure of [54] to deal correctly with the stable model semantics. Their extension modifies the integrity checking method of [165] and deals more generally with arbitrary integrity constraints expressed in the form of denials.
Reference: [172] <author> Satoh, K., Iwayama, N., </author> <title> A query evaluation method for abductive logic programming. </title> <booktitle> Proc. International Conference and Symposium on Logic Programming, </booktitle> <year> (1992) </year> <month> 671-685 </month>
Reference-contexts: Based upon this abductive interpretation of default logic, Satoh [169] proposes a sound and complete proof procedure for default logic, by extending the proof procedure for ALP of <ref> [172] </ref>. At a similar level of abstraction, Kakas, Mancarella and Dung [99] also propose a general argumentation-theoretic framework based primarily on the acceptability semantics. As with LP, other semantics such as preferred extension and stable theory semantics can be obtained as approximations of the acceptability semantics.
Reference: [173] <author> Sattar, A., Goebel, R., </author> <title> Using crucial literals to select better theories. </title> <type> Technical Report Dept. </type> <institution> of Computer Science, University of Alberta, </institution> <address> Canada (1989) </address>
Reference-contexts: For example Sattar and Goebel <ref> [173] </ref> use "crucial literals" to discriminate between two mutually incompatible explanations. When the crucial literals are tested, one of the explanations is rejected. More generally Evans and Kakas [56] use the notion of corroboration to select explanations.
Reference: [174] <author> Selman, B., Levesque, H.J., </author> <title> Abductive and default reasoning: a computational core. </title> <booktitle> Proc. AAAI 90 1990 ( )343-348 </booktitle>
Reference-contexts: The abductive task for the logic-based approach has been proved to be highly intractable: it is NP-hard even if T is a set of acyclic [7] propositional definite clauses <ref> [174, 48] </ref>, and is even harder if T is a set of any propositional clauses [48]. These complexity results hold even if explanations are not required to be minimal. However, the abductive task is tractable for certain more restricted classes of logic programs (see for example [52]).
Reference: [175] <author> Sergot,M., </author> <title> A query-the-user facility for logic programming. Integrated Interactive Computer Systems, </title> <editor> Degano and Sandwell eds., </editor> <publisher> North Hol-land Press (1983) 27-41 </publisher>
Reference-contexts: When the crucial literals are tested, one of the explanations is rejected. More generally Evans and Kakas [56] use the notion of corroboration to select explanations. An explanation fails to be corroborated if some of its logical consequences are not observed. A related technique is presented by Sergot in <ref> [175] </ref>, where information is obtained from the user during the process of query evaluation. * Moreover various (domain specific) criteria of preference can be specified. They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations [13, 22, 61, 77, 143, 148, 180]. <p> Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. This is similar to viewing abducibles as "askable" conditions which are treated as qualifications to answers to queries <ref> [175] </ref>. In the same way that it is useful to distinguish a subset of all predicates as "askable", it is useful to distinguish certain predicates as abducible. In fact, it is generally convenient to choose, as abducible predicates, ones which are not conclusions of any clause.
Reference: [176] <author> Shanahan, M., </author> <title> Prediction is deduction but explanation is abduction. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1055-1060 110 </address>
Reference-contexts: Abduction can be used in natural language understanding to interpret ambiguous sentences [22, 62, 78, 179]. The abductive explanations correspond to the various possible interpretations of such sentences. 12 In planning problems, plans can be viewed as explanations of the given goal state to be reached <ref> [50, 176] </ref>. These applications of abduction can all be understood as generating hypotheses which are causes for observations which are effects. An application that does not necessarily have a direct causal interpretation is knowledge assimilation [94, 105, 114, 125], described in greater detail below. <p> information that a property holds at a particular time point can be assimilated by adding an explanation in terms of the happening of some event that initiates this property at an earlier point of time together with an appropriate assumption that the property persists from one time to the other <ref> [50, 89, 176, 186] </ref>. This has the additional effect that the new KB will imply that the property holds until it is terminated in the future by the happening of some event [176]. <p> This has the additional effect that the new KB will imply that the property holds until it is terminated in the future by the happening of some event <ref> [176] </ref>. <p> ; P; T 2 ) ^ happens (E; T ) ^ terminates (E; P ) ^ T 1 &lt; T &lt; T 2 ]: Assimilating new information by adding explanations that satisfy the integrity constraints has the further effect of resolving conflicts between the current KB and the new information <ref> [89, 176] </ref>. <p> Therefore, instances of persists should be abduced unless some integrity constraint is violated. Indeed, in standard formulations of the persistence axiom the positive atom persists (T 1 ; P; T 2 ) is replaced by a negative literal ~ clipped (T 1 ; P; T 2 ) <ref> [176, 35] </ref>. In contrast, the abduction of happens is used for non-default hypothetical reasoning. The distinction between default reasoning and non-default abduction is also made in Konolige's proposal [103], which combines abduction for non-default hypothetical reasoning with default logic [158] for default reasoning. <p> Constraints can also be simplified, replacing, for example, 2 &lt; t ^ 3 &lt; t 3 &lt; t: Such simplification is less common in abductive frameworks. A number of proposals have been made recently to unify the treatment of abducibles and constraints. Several of these, <ref> [50, 176, 120, 100] </ref> in particular, have investigated the implementation of specialised constraint satisfaction and simplification algorithms of CLP (specifically for inequality) by means of general-purpose integrity checking methods applied to domain-specific integrity constraints as in the case of ALP. 65 Kowalski [109] proposes a general framework which attempts to unify
Reference: [177] <author> Simari, G.R., Loui, </author> <title> R.P, A mathematical treatment of defeasible rea-soning and its implementation. </title> <booktitle> Artificial Intelligence 53 (1992) 125-157 </booktitle>
Reference-contexts: Alferes and Pereira [4] apply the argumentation-theoretic interpretation introduced in [88] to expand the well-founded model of normal and extended logic programs (see section 5). In the case of normal logic programming, their semantics gives the same result as the acceptability semantics in example 4.7. Simari and Loui <ref> [177] </ref> define an argumentation-theoretic framework for default reasoning in general. They combine a notion of acceptability with Poole's notion of "most specific" explanation [143], to deal with hierarchies 40 of defaults.
Reference: [178] <author> Sperber, D., Wilson, D., </author> <title> Relevance: communication and cognition. </title> <publisher> (Basil Blanckwell Ltd, Oxford, UK,1986) </publisher>
Reference-contexts: Aravindan and Dung [8] have given an abductive characterisation of rational belief revision and have applied this result to formulate belief revision postulates for the view update problem. 18 A logic-based theory of the assimilation of new information has also been developed in the Relevance Theory of Sperber and Wilson <ref> [178] </ref> with special attention to natural language understanding. Gabbay, Kempson and Pitts [63] have investigated how abductive reasoning and relevance theory can be integrated to choose between different abductive interpretations of a natural language discourse. KA and belief revision are also related to truth maintenance systems.
Reference: [179] <author> Stickel, </author> <title> M.E., A prolog-like inference system for computing minimum-cost abductive explanations in natural-language interpretation. </title> <booktitle> Proc. International Computer Science Conference (Artificial Intelligence: Theory and Applications), </booktitle> <editor> Honk Kong, Lassez and Chin eds. </editor> <year> (1988) </year> <month> 343-350 </month>
Reference-contexts: Abduction can be used to perform high level vision [29]. The hypotheses are the objects to be recognised, and the observations are partial descriptions of objects. Abduction can be used in natural language understanding to interpret ambiguous sentences <ref> [22, 62, 78, 179] </ref>. The abductive explanations correspond to the various possible interpretations of such sentences. 12 In planning problems, plans can be viewed as explanations of the given goal state to be reached [50, 176].
Reference: [180] <author> Stickel, </author> <title> M.E., Rationale and methods for abductive reasoning in natural language interpretation. </title> <booktitle> Proc. International Scientific Symposium on Natural Language and Logic, Hamburg, Germany, Springer Verlag Lecture Notes in Artificial Intelligence (1989) 233-252 </booktitle>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [13, 22, 61, 77, 143, 148, 180] </ref>. Cox and Pietrzykowski [29] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not 6 be explainable in terms of other explanations.
Reference: [181] <author> Teusink, F., </author> <title> Using SLDFA-resolution with abductive logic programs. </title> <booktitle> ILPS '93 post-conference workshop "Logic Programming with Incomplete Information" (1993) </booktitle>
Reference-contexts: A logic program where each literal L i in the body of every clause is atomic is said to be definite. Abduction can be computed in LP by extending SLD and SLDNF <ref> [23, 53, 54, 91, 94, 34, 181] </ref>. Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. <p> The problem of constructive abduction has also been studied within the completion semantics. Denecker and De Schreye [34] define a proof procedure for constructive abduction, SLDNFA, which they show is sound and complete. Teusink <ref> [181] </ref> extends Drabent's [38] procedure, SLDNA, for constructive 66 negation to perform constructive abduction and uses three-valued semantics to show soundness and completeness. In both proposals, [34] and [181], integrity constraints are dealt with by means of a transformation, rather than explicitly. 6 Extended Logic Programming Extended Logic Programming (ELP) extends <p> Denecker and De Schreye [34] define a proof procedure for constructive abduction, SLDNFA, which they show is sound and complete. Teusink <ref> [181] </ref> extends Drabent's [38] procedure, SLDNA, for constructive 66 negation to perform constructive abduction and uses three-valued semantics to show soundness and completeness. In both proposals, [34] and [181], integrity constraints are dealt with by means of a transformation, rather than explicitly. 6 Extended Logic Programming Extended Logic Programming (ELP) extends general LP by allowing, in addition to NAF, a second, explicit form of negation.
Reference: [182] <author> Toni, F., Kakas, A. C., </author> <title> Computing the acceptability semantics. </title> <booktitle> To appear in Proc. International Workshop on Logic Programming and Nonmonotonic Reasoning (1995) </booktitle>
Reference-contexts: The argumentation-theoretic interpretation suggests how to extend the proof procedure to capture more fully the stable theory semantics and more generally the semantics given by the recursive definition for acceptability. The extension, presented in <ref> [182] </ref>, involves temporarily remembering a (selected) 41 2 =fp fl g q fl q procedure attack E and using E itself together with the subset of generated so far, to counterattack E, in the subordinate abductive phase. <p> For this reason, the proof procedure of [54] is sound for the admissibility semantics. Unfortunately, supersets of attacks need to be considered to guarantee soundness of the proof procedure for the acceptability semantics. In <ref> [182] </ref>, however, Toni and Kakas prove that only certain supersets of "minimally generated" attacks need to be considered. The additional features required for the proof procedure to capture more fully the acceptability semantics render the proof procedure considerably more complex and less efficient than proof procedures for simpler semantics.
Reference: [183] <author> Toni, F., Kowalski, R. A., </author> <title> Reduction of abductive logic programs to normal logic programs. </title> <booktitle> To appear in Proc. International Logic Programming Conference, </booktitle> <year> (1995) </year>
Reference-contexts: This proposal is similar, therefore, to the way in which generalised stable models combine abduction with NAF. Poole [147], on the other hand, proposes an abductive framework where abducibles can be specified either as default, like persists, or non-default, like happens. In <ref> [183] </ref>, Toni and Kowalski show how both default and non-default abducibles can be reduced to NAF. This reduction is discussed in section 5.5 below. <p> In particular, abducibles which do not occur as retractibles in integrity constraints are simply asserted in the transformed program P 0 . Therefore, this transformation can only be used to eliminate default abducibles together with their integrity constraints. A more complete transformation <ref> [183] </ref> can be obtained by combining the use of retractibles to eliminate integrity constraints with the transformation of [170] for reducing non-default abducibles to NAF. <p> Note that the last two clauses in P 0 are those used by Satoh and Iwayama [170] to simulate non-default abduction by means of NAF. Toni and Kowalski <ref> [183] </ref> prove that the transformation is correct and complete in the sense that there is a one-to-one correspondence between attacks in the framework hP; A; Ii and in the framework corresponding to the transformed program P 0 .
Reference: [184] <author> Toni, F., </author> <title> A theorem-proving approach to job-shop scheduling. </title> <type> Technical Report Imperial College, </type> <address> London (1994) </address>
Reference-contexts: Abduction is performed by means of deduction in the style of [26] (see section 5.6). This framework has been developed further by Fung [60] and has been applied to job-shop scheduling by Toni <ref> [184] </ref>. A related proposal, to include user-defined constraint handling rules within a CLP framework, has been made by Fruhwirth [75].
Reference: [185] <author> Torres, A., </author> <title> Negation as failure to support. </title> <booktitle> Proc. 2nd International Workshop on Logic Programming and Nonmonotonic Reasoning MIT press (Pereira and Nerode eds.), </booktitle> <address> Lisbon (1993) 223-243 </address>
Reference-contexts: A related argumentation-theoretic interpretation for the semantics of NAF in LP has also been developed by Geffner [67]. This interpretation is equivalent to the well-founded semantics [43]. Based upon Geffner's notion of argumentation, Torres <ref> [185] </ref> has proposed an argumentation-theoretic semantics for NAF that is equivalent to Kakas and Mancarella's stable theory semantics [96, 97], but is formulated in terms of the following notion of attack: E attacks (relative to P fl ) if P fl [ E [ ` p for some p fl 2 <p> Firstly, the notion of attack itself can be modified, e.g. following Torres' equivalent formulation of the stable theory semantics <ref> [185] </ref> (see section 4.3). Secondly, the notion of admissibility can be changed to allow counterattacks via integrity constraints, as well as via NAF.
Reference: [186] <author> Van Belleghem, K., Denecker, M., De Schreye, D., </author> <title> Representing con-tinuos change in the abductive event calculus. </title> <booktitle> Proc. 11th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Santa Margherita Lig-ure, Italy (1994) 225-239 111 </address>
Reference-contexts: information that a property holds at a particular time point can be assimilated by adding an explanation in terms of the happening of some event that initiates this property at an earlier point of time together with an appropriate assumption that the property persists from one time to the other <ref> [50, 89, 176, 186] </ref>. This has the additional effect that the new KB will imply that the property holds until it is terminated in the future by the happening of some event [176].
Reference: [187] <author> Van Gelder, A., Ross, K.A., Schlipf, J.S., </author> <title> Unfounded sets and the well--founded semantics for general logic programs. </title> <booktitle> Proc. ACM SIGMOD-SIGACT, Symposium on Principles of Database Systems (1988) </booktitle>
Reference-contexts: The same abductive proof procedure, but where each new hypothesis is added to only at the successful completion of its consistency phase, provides a sound proof procedure for the well-founded semantics <ref> [187] </ref>. <p> According to their semantics, given the program p p p and p fl are both undefined. In contrast, p fl holds in the semantics of [39], as well as in the stable model [68] and well-founded semantics <ref> [187] </ref>. Giordano, Martelli and Sapino [72] modify the abductive proof procedure so that the modification is sound and complete with respect to their semantics. Satoh and Iwayama [171], on the other hand, show how to extend the abduc-tive proof procedure of [54] to deal correctly with the stable model semantics. <p> Stationary expansions [154] are equivalent to complete extensions, as shown in [16]. Moreover, Dung shows that the well-founded model <ref> [187] </ref> is the smallest complete extension that can be constructed bottom-up from the empty set of negative hypotheses, by adding incrementally all admissible hypotheses. Thus the well-founded semantics is minimalist and sceptical, whereas the preferred extension semantics is maximalist and credulous.
Reference: [188] <author> Van Gelder, K.A., Schlipf, J.S., </author> <title> Commonsense axiomatizations for logic programs. </title> <note> Journal of Logic Programming 17 (1993) 161-195 </note>
Reference-contexts: Of special importance is the problem of relating circumscription and the if-and-only-if completion semantics to the argumentation-theoretic approach. An important step in this direction may be the "common sense" axiomatisation of NAF <ref> [188] </ref> by Van Gelder and Schlipf, which augments the if-and-only-if completion with axioms of induction. The inclusion of induction axioms relates this approach to circumscription, whereas the rewriting of negative literals by new positive literals relates it to the abductive interpretation of NAF.
Reference: [189] <author> Wallace, M., </author> <title> Negation by constraints: a sound and efficient implementation of negation in deductive databases. </title> <booktitle> Proc. 4th Symposium on Logic Programming, </booktitle> <address> San Francisco (1987) 112 </address>
References-found: 188

