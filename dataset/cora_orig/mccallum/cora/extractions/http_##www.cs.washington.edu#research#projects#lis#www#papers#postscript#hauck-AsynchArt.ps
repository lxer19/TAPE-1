URL: http://www.cs.washington.edu/research/projects/lis/www/papers/postscript/hauck-AsynchArt.ps
Refering-URL: http://www.cs.washington.edu/research/projects/lis/www/papers/
Root-URL: 
Title: Asynchronous Design Methodologies: An Overview  
Author: Scott Hauck 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Date: 1, January, 1995.  
Note: Proceedings of the IEEE, Vol. 83, No.  
Abstract: Asynchronous design has been an active area of research since at least the mid 1950's, but has yet to achieve widespread use. We examine the benefits and problems inherent in asynchronous computations, and in some of the more notable design methodologies. These include Huffman asynchronous circuits, burst-mode circuits, micropipelines, template-based and trace theory-based delay-insensitive circuits, signal transition graphs, change diagrams, and compilation-based quasi delay-insensitive circuits. 
Abstract-found: 1
Intro-found: 1
Reference: <editor> The references listed here include only those papers actually referenced in this text. </editor> <title> For a more complete bibliography of the field, the interested reader is directed to the public bibliography being maintained at Eindhoven University of Technology. </title> <note> Email inquiries should be sent to async-bib@win.tue.nl. </note>
Reference: [1] <author> T. J. Chaney, C. E. Molnar, </author> <title> Anomalous Behavior of Synchronizers and Arbiters, </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-22, </volume> <pages> pp. 421-422, </pages> <month> Apr. </month> <year> 1973. </year>
Reference-contexts: Many asynchronous circuits sense computation completion, and will run as quickly as the current physical properties allow. Robust mutual exclusion and external input handling - Elements that guarantee correct mutual exclusion of independent signals and synchronization of external signals to a clock are subject to metastability <ref> [1] </ref>. A metastable state is an unstable equilibrium state, such as a pair of cross-coupled CMOS inverters at 2.5V, which a system can remain in for an unbounded amount of time [2]. Synchronous circuits require all elements to exhibit bounded response time.
Reference: [2] <author> C. Mead, L. Conway, </author> <title> Introduction to VLSI Systems. </title> <address> Reading Mass: </address> <publisher> Addison-Wesley Publishing Co., </publisher> <year> 1980. </year>
Reference-contexts: A metastable state is an unstable equilibrium state, such as a pair of cross-coupled CMOS inverters at 2.5V, which a system can remain in for an unbounded amount of time <ref> [2] </ref>. Synchronous circuits require all elements to exhibit bounded response time. Thus, there is some chance that mutual exclusion circuits will fail in a synchronous system. Most asynchronous systems can wait an arbitrarily long time for such an element to complete, allowing robust mutual exclusion.
Reference: [3] <author> D. L. Dill, </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-independent Circuits. </title> <address> Cambridge, Mass: </address> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: We likewise do not cover many of the related areas, such as verification and testing, which are very important to asynchronous design, yet too complex to be handled adequately here. Interested readers are directed elsewhere for details on asynchronous verification <ref> [3] </ref> and testing [4]. Asynchronous design methodologies can most easily be categorized by the timing models they assume, and this paper is organized along these lines. Section 2 covers systems using bounded-delay models, including fundamental-mode Huffman circuits, extensions of these circuits to non-fundamental mode, and burst-mode circuits.
Reference: [4] <author> H. Hulgaard, S. M. Burns, G. Borriello, </author> <title> Testing Asynchronous Circuits: A Survey, </title> <institution> University of Washington, Dept. </institution> <note> of CSE Internal Report, 1991. Also available as TR # 94-03-06. 35 </note>
Reference-contexts: We likewise do not cover many of the related areas, such as verification and testing, which are very important to asynchronous design, yet too complex to be handled adequately here. Interested readers are directed elsewhere for details on asynchronous verification [3] and testing <ref> [4] </ref>. Asynchronous design methodologies can most easily be categorized by the timing models they assume, and this paper is organized along these lines. Section 2 covers systems using bounded-delay models, including fundamental-mode Huffman circuits, extensions of these circuits to non-fundamental mode, and burst-mode circuits. Section 3 focuses on micropipelines.
Reference: [5] <author> S. H. Unger, </author> <title> Asynchronous Sequential Switching Circuits. </title> <address> New York NY: </address> <publisher> Wiley-Interscience, </publisher> <year> 1969. </year>
Reference-contexts: A. Huffman, who developed many of the early concepts of these circuits. 2.1 Fundamental Mode Huffman Circuits In this model, circuits are designed in much the same way as synchronous circuits. The circuit to be synthesized is usually expressed as a flow-table <ref> [5] </ref>, a form similar to a truth-table. As shown in Figure 1, a flow-table has a row for each internal state, and a column for each combination of inputs.
Reference: [6] <author> R. E. Miller, </author> <title> Switching Theory Volume II: Sequential Circuits and Machines. </title> <address> New York NY: </address> <publisher> John Wiley & Sons, </publisher> <year> 1965. </year>
Reference: [7] <author> L. A. Hollaar, </author> <title> Direct Implementation of Asynchronous Control Units, </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-31, No. 12, </volume> <pages> pp. 1133-1141, </pages> <month> Dec. </month> <year> 1982. </year>
Reference-contexts: Therefore, this observation cannot completely eliminate the fundamental mode assumption. Another method, described by Hollaar <ref> [7] </ref>, uses detailed knowledge of the implementation strategy to allow new transitions to arrive earlier than the fundamental-mode assumption allows.
Reference: [8] <author> S. M. Nowick, D. L. Dill, </author> <title> Automatic Synthesis of Locally-Clocked Asynchronous State Machines, </title> <booktitle> in Proceedings of ICCAD, </booktitle> <pages> pp. 318-321, </pages> <year> 1991. </year>
Reference-contexts: As described by Nowick and Dill <ref> [8, 9] </ref> burst-mode circuits can be implemented by the circuit shown in Figure 5 (left). A clock is generated locally in each state machine, but is independent of local clocks in any other module.
Reference: [9] <author> S. M. Nowick, D. L. Dill, </author> <title> Synthesis of Asynchronous State Machines Using a Local Clock, </title> <booktitle> in Proceedings of ICCD, </booktitle> <pages> pp. 192-197, </pages> <year> 1991. </year>
Reference-contexts: As described by Nowick and Dill <ref> [8, 9] </ref> burst-mode circuits can be implemented by the circuit shown in Figure 5 (left). A clock is generated locally in each state machine, but is independent of local clocks in any other module. <p> However, special hardware can be added to the local clock logic to make sure all AND products involving the previous state are disabled before the next state bits arrive <ref> [9] </ref>. This eliminates hazards due to multiple state bit transitions, at the expense of more complicated internal timing constraints. In this way, synchronous state encoding schemes can be used, possibly with a significant decrease in the required number of state bits.
Reference: [10] <author> K. Yun, D. Dill, </author> <title> Automatic Synthesis of 3D Asynchronous State Machines, </title> <booktitle> in Proceedings of ICCAD, </booktitle> <pages> pp. 576-580, </pages> <year> 1992. </year>
Reference-contexts: This eliminates hazards due to multiple state bit transitions, at the expense of more complicated internal timing constraints. In this way, synchronous state encoding schemes can be used, possibly with a significant decrease in the required number of state bits. As described by Yun, Nowick, and Dill <ref> [10, 11] </ref>, burst-mode circuits can also be implemented by using techniques similar to those of Huffman circuits. Since burst-mode circuits allow multiple input changes, one would expect to have the same hazard problems that motivated the single-input-change restriction in the Huffman circuits.
Reference: [11] <author> K. Yun, D. Dill, S. M. Nowick, </author> <title> Synthesis of 3D Asynchronous State Machines, </title> <booktitle> in Proceedings of ICCD, </booktitle> <pages> pp. 346-350, </pages> <year> 1992. </year>
Reference-contexts: This eliminates hazards due to multiple state bit transitions, at the expense of more complicated internal timing constraints. In this way, synchronous state encoding schemes can be used, possibly with a significant decrease in the required number of state bits. As described by Yun, Nowick, and Dill <ref> [10, 11] </ref>, burst-mode circuits can also be implemented by using techniques similar to those of Huffman circuits. Since burst-mode circuits allow multiple input changes, one would expect to have the same hazard problems that motivated the single-input-change restriction in the Huffman circuits. <p> Thus, the technique of adding redundant cubes to a sum-of-products form used in Huffman circuits to remove hazards is sufficient to implement burst-mode circuits. As proven by Yun, Dill and Nowick <ref> [11] </ref>, these must include a cube covering the initial and final states of an input burst where the output variable remains true. Thus, this cube will remain true during the entire input burst, and the output will be hazard-free.
Reference: [12] <author> A. Davis, B. Coates, K. Stevens, </author> <title> The Post Office Experience: Designing a Large Asynchronous Chip, </title> <booktitle> in Proceedings of the 26th Annual Hawaii International Conference on Systems Sciences, </booktitle> <volume> Vol. I, </volume> <pages> pp. 409-418, </pages> <year> 1993. </year>
Reference-contexts: A different design methodology, referred to as burst-mode, attempts to move even closer to synchronous design styles than the Huffman method. The burst-mode design style was developed by Nowick, Yun, and Dill [8-11] based on earlier work at HP laboratories by Davis, Stevens, and Coates <ref> [12] </ref>. As shown in Figure 5 (center), circuits are specified via a standard state-machine, where each arc is labeled by a nonempty set of inputs (an input burst), and a set of outputs (an output burst).
Reference: [13] <author> S. M. Nowick, D. L. Dill, </author> <title> Exact Two-Level Minimization of Hazard-Free Logic with Multiple-Input Changes, </title> <booktitle> in Proceedings of ICCAD, </booktitle> <pages> pp. 626-630, </pages> <year> 1992. </year>
Reference-contexts: In all transitions, the outputs are generated directly in response to the inputs, and the local clock offers no hazard protection. Thus, the redundant cubes necessary in Huffman circuits are also needed for the output logic, and special care must be taken to avoid dynamic hazards <ref> [13] </ref>. The local clock generation logic may also contain similar hazards. Although this signal is not directly seen by the environment, a hazard on the clock lines could cause the state to change partially or completely when no change was intended.
Reference: [14] <author> M. Abramovici, M. A. Breuer, A. D. Friedman, </author> <title> Digital Systems Testing and Testable Design. </title> <address> New York NY: </address> <publisher> Computer Science Press, </publisher> <year> 1990. </year>
Reference: [15] <author> G. L. Smith, </author> <title> Model For Delay Faults Based Upon Paths, </title> <booktitle> in Proceedings of International Test Conference, </booktitle> <pages> pp. 342-349, </pages> <year> 1985. </year>
Reference-contexts: Bounded-delay asynchronous circuits greatly complicate fault detection. First, the technique of adding redundant terms to functions to eliminate hazards is in direct conflict with the fault testing technique of avoiding redundant terms to make faults visible ([14] pp. 100-103). Also, these circuits must be tested for delay faults <ref> [15] </ref>. A delay fault is a fault on an element or path that alters its delay. In a synchronous circuit, such a fault would require the chip to be clocked at a slower rate.
Reference: [16] <author> I. E. Sutherland, </author> <title> Micropipelines, </title> <journal> Communications of the ACM, </journal> <volume> vol. 32, no. 6, </volume> <pages> pp. 720-738, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Each of these models will be discussed later in this paper. However, each of these models tend to have less pervasive timing assumptions, possibly making them easier to test. 3. Micropipelines Micropipelines were introduced in Ivan Sutherlands Turing Award lecture <ref> [16] </ref> primarily as an asynchronous alternative to synchronous elastic pipelines (pipelines where the amount of data contained in them can vary). However, they also serve as a powerful method for implementing general computations.
Reference: [17] <author> S. Karthik, I. de Souza, J. T. Rahmeh, J. A. Abraham, </author> <title> Interlock Schemes for Micropipelines: Application to a Self-Timed Rebound Sorter, </title> <booktitle> in Proceedings of ICCD, </booktitle> <pages> pp. 393-396, </pages> <year> 1991. </year>
Reference-contexts: Although the control structure for a micropipeline can be enhanced by using additional elements, this is a fairly complex and error-prone activity. While several micropipelined solutions to specific circuit structures have been developed <ref> [17, 18, 19] </ref>, including a complete asynchronous microprocessor [20], a general, higher-level method for designing micropipeline control circuits is essential. 4. Delay-Insensitive Circuits Delay-insensitive circuits use a delay model completely opposite to the bounded-delay model: they assume that delays in both elements and wires are unbounded.
Reference: [18] <author> A. Liebchen, G. Gopalakrishnan, </author> <title> Dynamic Reordering of High Latency Transactions Using a Modified Micropipeline, </title> <booktitle> in Proceedings of ICCD, </booktitle> <pages> pp. 336-340, </pages> <year> 1992. </year>
Reference-contexts: Although the control structure for a micropipeline can be enhanced by using additional elements, this is a fairly complex and error-prone activity. While several micropipelined solutions to specific circuit structures have been developed <ref> [17, 18, 19] </ref>, including a complete asynchronous microprocessor [20], a general, higher-level method for designing micropipeline control circuits is essential. 4. Delay-Insensitive Circuits Delay-insensitive circuits use a delay model completely opposite to the bounded-delay model: they assume that delays in both elements and wires are unbounded.
Reference: [19] <author> J. Spars, C. D. Nielsen, L. S. Nielsen, J. Staunstrup, </author> <title> Design of Self-timed Multipliers: A Comparison, </title> <institution> Technical University of Denmark, Department of Computer Science Tech. </institution> <type> Rep., </type> <year> 1992. </year>
Reference-contexts: Although the control structure for a micropipeline can be enhanced by using additional elements, this is a fairly complex and error-prone activity. While several micropipelined solutions to specific circuit structures have been developed <ref> [17, 18, 19] </ref>, including a complete asynchronous microprocessor [20], a general, higher-level method for designing micropipeline control circuits is essential. 4. Delay-Insensitive Circuits Delay-insensitive circuits use a delay model completely opposite to the bounded-delay model: they assume that delays in both elements and wires are unbounded.
Reference: [20] <author> D. Pountain, </author> <title> Computing Without Clocks, </title> <journal> BYTE, </journal> <volume> Vol. 18, No. 1, </volume> <pages> pp. 145-150, </pages> <month> January, </month> <year> 1993. </year>
Reference-contexts: Although the control structure for a micropipeline can be enhanced by using additional elements, this is a fairly complex and error-prone activity. While several micropipelined solutions to specific circuit structures have been developed [17, 18, 19], including a complete asynchronous microprocessor <ref> [20] </ref>, a general, higher-level method for designing micropipeline control circuits is essential. 4. Delay-Insensitive Circuits Delay-insensitive circuits use a delay model completely opposite to the bounded-delay model: they assume that delays in both elements and wires are unbounded.
Reference: [21] <author> A. J. Martin, </author> <title> The Limitations to Delay-Insensitivity in Asynchronous Circuits, </title> <booktitle> in Proceedings of the 1990 MIT Conference on Advanced Research in VLSI, </booktitle> <pages> pp. 263-278, </pages> <year> 1990. </year>
Reference-contexts: It should be obvious that this allows only a very limited class of circuits to be built, making such a methodology unsuitable for general circuit design. Martin has developed a more formal argument of the limitations of delay-insensitive circuits with only single-output gates <ref> [21] </ref>. 4.2 Module Synthesis Via INets In order to make delay-insensitive circuit design practical for general computations, we must create a set of basic modules that both obey delay-insensitive properties and give enough functionality to implement a wide class of circuits. These modules will include multi-output elements.
Reference: [22] <author> C. E. Molnar, T. P. Fang, F. U. Rosenberger, </author> <title> Synthesis of Delay-Insensitive Modules, </title> <booktitle> in Proceedings of the 1985 Chapel Hill Conference on Advanced Research in VLSI, </booktitle> <pages> pp. 67-86, </pages> <year> 1985. </year>
Reference-contexts: In the following discussion, this delay model will in fact be that of bounded-delay, as discussed previously. 14 A methodology for delay-insensitive module design has been proposed by Molnar, Fang and Rosenberger <ref> [22] </ref>. This methodology is founded upon use of an INet, a model based on Petri Nets [23]. Note that a second methodology based on Petri-Nets, namely STGs, is discussed in Section 5.1. <p> For example, an INet could easily have two consecutive transitions on a single wire, which is an output hazard, and thus is not delay-insensitive. What is necessary is a general constraint on allowable INet structures. Luckily, the socalled Foam Rubber Wrapper constraint <ref> [22] </ref> does exactly that. It states that for any delay-insensitive circuit we must be able to attach arbitrary delays on the input and output lines, and the new interface created must have the exact same behavior as the original module, with no hazards. <p> Purely combinational functions can have faster implementations since there are no feedback paths to delay, though the inertial delays on the outputs remain. The second implementation strategy <ref> [22, 27] </ref> is similar to the locally-clocked burst-mode circuits discussed earlier. However, instead of generating a clock only when inputs arrive, a locally-clocked module (Q-module ) is constantly clocking its latches. <p> Methods for checking correctness of hand-designed circuits against INet specifications <ref> [22] </ref> are beyond the scope of this paper. 4.3 Module-based Compilation Systems Once we have a set of delay-insensitive modules, such as those generated via INet descriptions, building delay-insensitive circuits becomes easy.
Reference: [23] <author> T. Murata, </author> <title> Petri Nets: Properties, Analysis and Applications, </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> vol. 77, no. 4, </volume> <pages> pp. 541-580, </pages> <year> 1989. </year> <month> 36 </month>
Reference-contexts: In the following discussion, this delay model will in fact be that of bounded-delay, as discussed previously. 14 A methodology for delay-insensitive module design has been proposed by Molnar, Fang and Rosenberger [22]. This methodology is founded upon use of an INet, a model based on Petri Nets <ref> [23] </ref>. Note that a second methodology based on Petri-Nets, namely STGs, is discussed in Section 5.1. Two simple INets are shown in dark horizontal lines), with tokens (the small filled circles) marking some of the places. <p> Like INets, STGs specify asynchronous circuits with Petri-Nets <ref> [23] </ref> whose transitions are labeled with signal names. The assumption is that when a labeled transition fires, the corresponding signal in the 23 circuit has a transition.
Reference: [24] <author> R. F. Sproull, I. E. Sutherland, </author> <title> Asynchronous Systems Volume I: Introduction, </title> <type> Sutherland, </type> <institution> Sproull & Associates, Inc. </institution> <type> Tech. Rep. SSA #4706, </type> <year> 1986. </year>
Reference: [25] <author> J. T. Udding, </author> <title> A Formal Model for Defining and Classifying Delay-insensitive Circuits and Systems, </title> <journal> Distributed Computing, </journal> <volume> vol 1, no. 4, </volume> <pages> pp. 197-204, </pages> <year> 1986. </year>
Reference-contexts: If introducing these delays allows behaviors not present in the original circuit, the circuit is not delay-insensitive. Note that the same requirement can be expressed as local constraints on ISGs <ref> [25] </ref>. x 1 y 1 z 1 y 1 ' Combinational logic D D x 1 y 1 z 1 y 1 ' Combinational logic Q-clock Control Q Q Q 16 The final step in this module synthesis process is to derive a circuit implementation of the generated Karnaugh maps.
Reference: [26] <author> T. P. Fang, C. E. Molnar, </author> <title> Synthesis of Reliable Speed-Independent Circuit Modules: II. Circuit and Delay Conditions to Ensure Operation Free of Problems from Races and Hazards, </title> <institution> Computer Systems Laboratory, Washington University Tech. </institution> <note> Memorandum 298, </note> <year> 1983. </year>
Reference-contexts: This is done via circuit structures similar to those presented in the bounded-delay section of this paper, as shown in Figure 12. For the clock-free form, instead of following the restrictions of the fundamental-mode presented earlier, some hazards are allowed to occur and are filtered out at the outputs <ref> [26] </ref>. While the redundant AND terms and delays on feedback paths found in Huffman circuits are retained, dynamic hazards are a problem since the fundamental-mode assumption is not being enforced. Dynamic hazards are multiple transitions when an output is meant to change exactly once.
Reference: [27] <author> F. U. Rosenberger, C. E. Molnar, T. J. Chaney, T.-P. Fang, Q-Modules: </author> <title> Internally Clocked Delay-Insensitive Modules, </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. 37, no. 9, </volume> <pages> pp. 1005-1018, </pages> <year> 1988. </year>
Reference-contexts: Purely combinational functions can have faster implementations since there are no feedback paths to delay, though the inertial delays on the outputs remain. The second implementation strategy <ref> [22, 27] </ref> is similar to the locally-clocked burst-mode circuits discussed earlier. However, instead of generating a clock only when inputs arrive, a locally-clocked module (Q-module ) is constantly clocking its latches.
Reference: [28] <author> E. Brunvand, R. F. Sproull, </author> <title> Translating Concurrent Programs into Delay-Insensitive Circuits, </title> <booktitle> in Proceedings of ICCAD, </booktitle> <pages> pp. 262-265, </pages> <year> 1989. </year>
Reference-contexts: Although we have seen that module-based systems can ease manual design, their main power is seen when they are coupled with a high-level language and automatic translation software. As described by Brunvand and Sproull <ref> [28] </ref>, what is necessary is to choose a language applicable to describing asynchronous circuits (in this case it is a subset of Occam, a language based on Communicating Sequential Processes), and then provide delay-insensitive modules for each of the language constructs. <p> Thus, the initial effort of creating module sets may be greatly magnified by the number of technologies being used, or may restrict the choice of technologies. One final problem is that while strict delay-insensitive designs will encapsulate timing issues within modules, some methodologies <ref> [28] </ref> use bundled data protocols. Bundled data involves timing constraints between modules, complicating circuit implementation. 4.4 Trace-Based Circuits A method for delay-insensitive circuit design has been proposed by Ebergen [29, 30] which uses a unified model for both module specification and circuit design.
Reference: [29] <author> J. C. Ebergen, </author> <title> Translating Programs into Delay-Insensitive Circuits, </title> <institution> Centre for Mathematics and Computer Science, Amsterdam CWI Tract 56, </institution> <year> 1989. </year>
Reference-contexts: One final problem is that while strict delay-insensitive designs will encapsulate timing issues within modules, some methodologies [28] use bundled data protocols. Bundled data involves timing constraints between modules, complicating circuit implementation. 4.4 Trace-Based Circuits A method for delay-insensitive circuit design has been proposed by Ebergen <ref> [29, 30] </ref> which uses a unified model for both module specification and circuit design. It is based on trace theory, a model similar to regular expressions. A trace is an alphabet and a set of strings which describe the desired circuit functionality. <p> Eventually the circuit at right is derived. Specifics of the grammar and the translation system are beyond the scope of this paper, and are described elsewhere <ref> [29] </ref>.
Reference: [30] <author> J. C. Ebergen, </author> <title> A Formal Approach to Designing Delay-Insensitive Circuits, </title> <journal> Distributed Computing, </journal> <volume> vol. 5, no. 3, </volume> <pages> pp. 107-119, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: One final problem is that while strict delay-insensitive designs will encapsulate timing issues within modules, some methodologies [28] use bundled data protocols. Bundled data involves timing constraints between modules, complicating circuit implementation. 4.4 Trace-Based Circuits A method for delay-insensitive circuit design has been proposed by Ebergen <ref> [29, 30] </ref> which uses a unified model for both module specification and circuit design. It is based on trace theory, a model similar to regular expressions. A trace is an alphabet and a set of strings which describe the desired circuit functionality.
Reference: [31] <author> A. J. Martin, </author> <title> Programming in VLSI: From Communicating Processes to Delay-Insensitive Circuits, </title> <booktitle> in UT Year of Programming Institute on Concurrent Programming, </booktitle> <editor> C. A. R. Hoare, Ed. </editor> <address> MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1989, </year> <pages> pp. 1-64. </pages>
Reference-contexts: E. Muller for his pioneering work on this model, make the assumption that while gate delays are unbounded, all wire delays are negligible (less than the minimum gate delay). Quasi-delay-insensitive circuits adopt the delay-insensitive assumptions that both gate and wire delays are unbounded, but augment this with isochronic forks <ref> [31] </ref>. As mentioned earlier, isochronic forks are forking wires where the difference in delays between destinations is negligible. The reason that both of these models will be discussed together in this section is that for all practical purposes they are identical. <p> Synchronization, then &lt;sym q &gt; := &lt;sym p &gt;. Probe &lt;porti&gt; Returns TRUE if other process is waiting on &lt;port j &gt;, FALSE otherwise. Table 3. Communicating Processes language constructs. 5.3 Communicating Processes Compilation The final model we will discuss is Martins communicating processes compilation technique <ref> [31] </ref>. This methodology translates programs written in a language similar to Communicating Sequential Processes into asynchronous circuits. Similar to most of the previous techniques, the source language describes circuits by specifying the required sequences of communications in the circuit. The important language constructs are listed in Table 3. <p> To convert them into sets of transitions, they are expanded into four-phase handshaking protocols. Reshuffling of transitions and insertion of state variables is then performed to distinguish ambiguous states. Finally, production rules are generated, which lead to a physical circuit realization. Although the exact algorithms for these steps <ref> [31] </ref> are beyond the scope of this discussion, it is important to realize that many of these steps require subtle choices that may have significant impact on circuit area and delay.
Reference: [32] <author> T. A. Chu, C. K. C. Leung, T. S. Wanuga, </author> <title> A Design Methodology for Concurrent VLSI Systems, </title> <booktitle> in Proceedings of ICCD, </booktitle> <pages> pp. 407-410, </pages> <year> 1985. </year>
Reference-contexts: Finally, the isochronic constraint may require delay fault testing similar to bounded-delay circuits. 5.1 Signal Transition Graphs One of the most well-known design methodologies currently under study is signal transition graphs (STGs), introduced by Chu, Leung and Wanuga <ref> [32, 33] </ref> (signal graphs, a model nearly identical to STGs, were introduced independently [34]). Like INets, STGs specify asynchronous circuits with Petri-Nets [23] whose transitions are labeled with signal names. The assumption is that when a labeled transition fires, the corresponding signal in the 23 circuit has a transition.
Reference: [33] <author> T. A. Chu, </author> <title> Synthesis of Self-timed VLSI Circuits from Graph-Theoretic Specifications, M.I.T. </title> <type> Tech. Rep. </type> <institution> MIT/LCS/TR-393, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: Finally, the isochronic constraint may require delay fault testing similar to bounded-delay circuits. 5.1 Signal Transition Graphs One of the most well-known design methodologies currently under study is signal transition graphs (STGs), introduced by Chu, Leung and Wanuga <ref> [32, 33] </ref> (signal graphs, a model nearly identical to STGs, were introduced independently [34]). Like INets, STGs specify asynchronous circuits with Petri-Nets [23] whose transitions are labeled with signal names. The assumption is that when a labeled transition fires, the corresponding signal in the 23 circuit has a transition. <p> STG (e) is not single-cycle, since both x+ and x- appear twice. y+ x r+ s y+ x+ y s r+ x+ y- s s+ x+ x s y r s+ yr s+ and s (right) <ref> [33] </ref>. As implied earlier, the substantial restrictions put on the allowable Petri-Net constructs, both from the requirements in the previous section as well as the classes STG/MG, STG/IC, and STG/NC, are only justified if they enable better algorithms. <p> While STGs can use the same techniques to implement circuits (i.e. generating the underlying state graph from the Petri-Net specification, then implementing the implied Karnaugh map), techniques have been developed to implement STGs without the exponential blowup. One of the most intuitive approaches is contraction <ref> [33] </ref>. <p> Unfortunately, this logic can be very complex, and the assumption of completely hazard-free computation in a single gate can be difficult to meet in practice. Chu <ref> [33] </ref> also includes an algorithm for converting an STG/NC into an STG/IC, which both requires and preserves all of the requirements listed previously, except that single-cycle transitions are no longer guaranteed. <p> Beerel and Meng [40] generate speed-independent circuits from state graphs using simple gates such as ANDs, ORs, and C-Elements. This overcomes Chus complex gate assumption <ref> [33] </ref>, in which a gate is assumed to be able to compute an arbitrarily complex function without internal hazards. Although the gates generated by Beerel and Meng [40] may have high-fanin gates, subsequent work [41] has begun to overcome this limitation as well. Instead of speed-independence, Lavagno, Keutzer and.
Reference: [34] <author> L. Y. Rosenblum, A. V. Yakovlev, </author> <title> Signal Graphs: From Self-timed to Timed Ones, </title> <booktitle> in International Workshop on Timed Petri Nets, </booktitle> <address> Torino, Italy, </address> <pages> pp. 199-206, </pages> <year> 1985. </year>
Reference-contexts: the isochronic constraint may require delay fault testing similar to bounded-delay circuits. 5.1 Signal Transition Graphs One of the most well-known design methodologies currently under study is signal transition graphs (STGs), introduced by Chu, Leung and Wanuga [32, 33] (signal graphs, a model nearly identical to STGs, were introduced independently <ref> [34] </ref>). Like INets, STGs specify asynchronous circuits with Petri-Nets [23] whose transitions are labeled with signal names. The assumption is that when a labeled transition fires, the corresponding signal in the 23 circuit has a transition.
Reference: [35] <author> T. H. Y. Meng, R. W. Brodersen, D. G. Messerschmitt, </author> <title> Automatic Synthesis of Asynchronous Circuits from High-Level Specifications, </title> <journal> IEEE Transactions on CAD, </journal> <volume> vol. 8, no. 11, </volume> <pages> pp. 1185-1205, </pages> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: Both of these issues are discussed by Meng, Brodersen, and Messerschmitt <ref> [35] </ref>. As shown in Figure 21, datapath logic blocks built out of differential cascode voltage switch 26 logic (DCVSL) are connected together by interconnect circuits, which ensure that proper four-phase handshaking conventions are maintained between stages. <p> As long as these stages are connected together in a way that respects the 4-phase handshaking, they can correctly implement speed-independent computations. The job of controlling the 4-phase handshaking is performed by interconnect circuits synthesized from STGs. Although this method <ref> [35] </ref> assumes that these handshake circuits will be implemented by state graph expansion of the complete STG, other strategies, including Chus contraction algorithm, could also be used. <p> Meng, Brodersen and Messerschmitt <ref> [35] </ref> also include an automatic algorithm for transforming a live, safe STG/MG to ensure persistency which claims to produce the maximum concurrency.
Reference: [36] <author> A. V. Yakovlev, </author> <title> On Limitations and Extensions of STG Model for Designing Asynchronous Control Circuits, </title> <booktitle> in Proceedings of ICCD, </booktitle> <pages> pp. 396-400, </pages> <year> 1992. </year>
Reference: [37] <author> P. Vanbekbergen, F. Catthoor, G. Goossens, H. De Man, </author> <title> Time & Area Performant Synthesis of Asynchronous Control Circuits, </title> <booktitle> in Proceedings of TAU90, </booktitle> <year> 1990. </year>
Reference-contexts: Several other researchers have developed efficient algorithms for STG transformation and synthesis. As described above, Chus algorithm requires that the STG to be synthesized not only be persistent, but also obey several other restrictions, including unique state encoding. Vanbekbergen, Catthoor, Goossens and De Man <ref> [37] </ref> present algorithms to transform a live, single-cycle STG/MG to ensure both persistency and unique state encoding.
Reference: [38] <author> K. J. Lin, C. S. Lin, </author> <title> A Realization Algorithm of Asynchronous Circuits from STG, </title> <booktitle> in Proceedings of EDAC, </booktitle> <pages> pp. 322-326, </pages> <year> 1992. </year>
Reference-contexts: Vanbekbergen, Catthoor, Goossens and De Man [37] present algorithms to transform a live, single-cycle STG/MG to ensure both persistency and unique state encoding. Lin and Lin <ref> [38] </ref> describe how a live, safe, single-cycle STG/MG can be made persistent and unique state coded, and then how to generate an implementation via an efficient algorithm that requires no state graph expansion at all.
Reference: [39] <author> K. J. Lin, C. S. Lin, </author> <booktitle> On the Verification of State-Coding in STGs, in Proceedings of ICCAD, </booktitle> <pages> pp. 118-122, </pages> <year> 1992. </year>
Reference-contexts: They then extend this theory to test realizable state coding (also known as complete state coding) in live, safe STG/ICs <ref> [39] </ref>.
Reference: [40] <author> P. A. Beerel, T. H. Y. Meng, </author> <title> Automatic Gate-Level Synthesis of Speed-Independent Circuits, </title> <booktitle> in Proceedings of ICCAD, </booktitle> <pages> pp. 581-586, </pages> <year> 1992. </year>
Reference-contexts: What is needed is either some form of hierarchy, or a higher-level specification method with STGs for the simple components. Note that if we are willing to pay the possibly exponential cost of state graph expansion there are a number of interesting algorithms for STG synthesis. Beerel and Meng <ref> [40] </ref> generate speed-independent circuits from state graphs using simple gates such as ANDs, ORs, and C-Elements. This overcomes Chus complex gate assumption [33], in which a gate is assumed to be able to compute an arbitrarily complex function without internal hazards. Although the gates generated by Beerel and Meng [40] may <p> Meng <ref> [40] </ref> generate speed-independent circuits from state graphs using simple gates such as ANDs, ORs, and C-Elements. This overcomes Chus complex gate assumption [33], in which a gate is assumed to be able to compute an arbitrarily complex function without internal hazards. Although the gates generated by Beerel and Meng [40] may have high-fanin gates, subsequent work [41] has begun to overcome this limitation as well. Instead of speed-independence, Lavagno, Keutzer and.
Reference: [41] <author> P. A. Beerel, T. H. Y. Meng, </author> <title> Logic Transformations and Observability Dont Cares in Speed-Independent Circuits, </title> <booktitle> in Proceedings of TAU, </booktitle> <year> 1993. </year> <month> 37 </month>
Reference-contexts: This overcomes Chus complex gate assumption [33], in which a gate is assumed to be able to compute an arbitrarily complex function without internal hazards. Although the gates generated by Beerel and Meng [40] may have high-fanin gates, subsequent work <ref> [41] </ref> has begun to overcome this limitation as well. Instead of speed-independence, Lavagno, Keutzer and. Sangiovanni-Vincentelli [42] present an approach to implementing live, safe STG/ICs with unique state assignments in a bounded-delay model (Note that the STGs do not have to be persistent and can have non-single-cycle transitions).
Reference: [42] <author> L. Lavagno, K. Keutzer, A. Sangiovanni-Vincentelli, </author> <title> Algorithms for Synthesis of Hazard-free Asynchronous Circuits, </title> <booktitle> in Proceedings of DAC, </booktitle> <pages> pp. 302-308, </pages> <year> 1991. </year>
Reference-contexts: Although the gates generated by Beerel and Meng [40] may have high-fanin gates, subsequent work [41] has begun to overcome this limitation as well. Instead of speed-independence, Lavagno, Keutzer and. Sangiovanni-Vincentelli <ref> [42] </ref> present an approach to implementing live, safe STG/ICs with unique state assignments in a bounded-delay model (Note that the STGs do not have to be persistent and can have non-single-cycle transitions).
Reference: [43] <author> L. Lavagno, A. Sangiovanni-Vincentelli, </author> <title> Linear Programming for Optimum Hazard Elimination in Asynchronous Circuits, </title> <booktitle> in Proceedings of ICCD, </booktitle> <pages> pp. 275-278, </pages> <year> 1992. </year>
Reference-contexts: Delays are inserted into the system to avoid some hazards, and while the necessary inserted delays can depend on the computation delays of multiple 28 signals, a linear-programming algorithm for optimally inserting delays exists <ref> [43] </ref>. While this approach shares the problem of delay-fault testing with the bounded-delay circuits presented earlier, algorithms have been developed for handling this issue [44]. Finally, both Lavagno, Moon, Brayton and.
Reference: [44] <author> K. Keutzer, L. Lavagno, A. Sangiovanni-Vincentelli, </author> <title> Synthesis for Testability Techniques for Asynchronous Circuits, </title> <booktitle> in Proceedings of ICCAD, </booktitle> <pages> pp. 326-329, </pages> <year> 1991. </year>
Reference-contexts: While this approach shares the problem of delay-fault testing with the bounded-delay circuits presented earlier, algorithms have been developed for handling this issue <ref> [44] </ref>. Finally, both Lavagno, Moon, Brayton and.
Reference: [45] <author> L. Lavagno, C. W. Moon, R. K. Brayton, A. Sangiovanni-Vincentelli, </author> <title> Solving the State Assignment Problem for Signal Transition Graphs, </title> <booktitle> in Proceedings of DAC, </booktitle> <pages> pp. 568-572, </pages> <year> 1992. </year>
Reference-contexts: While this approach shares the problem of delay-fault testing with the bounded-delay circuits presented earlier, algorithms have been developed for handling this issue [44]. Finally, both Lavagno, Moon, Brayton and. Sangiovanni-Vincentelli <ref> [45] </ref> and Vanbekbergen, Lin, Goossens and De Man [46] handle state-variable insertion, with the former operating on live, safe STG/ICs, while the latter allows any state graph that is at least finite, connected, and has a consistent state assignment. 5.2 Change Diagrams Change diagrams (CDs) [47] are a model similar to
Reference: [46] <author> P. Vanbekbergen, B. Lin, G. Goossens, H. De Man, </author> <title> A Generalized State Assignment Theory for Transformations on Signal Transition Graphs, </title> <booktitle> in Proceedings of ICCAD, </booktitle> <pages> pp. 112-117, </pages> <year> 1992. </year>
Reference-contexts: While this approach shares the problem of delay-fault testing with the bounded-delay circuits presented earlier, algorithms have been developed for handling this issue [44]. Finally, both Lavagno, Moon, Brayton and. Sangiovanni-Vincentelli [45] and Vanbekbergen, Lin, Goossens and De Man <ref> [46] </ref> handle state-variable insertion, with the former operating on live, safe STG/ICs, while the latter allows any state graph that is at least finite, connected, and has a consistent state assignment. 5.2 Change Diagrams Change diagrams (CDs) [47] are a model similar to STGs, but which avoids some of the restrictions
Reference: [47] <author> M. A. Kishinevsky, A. Y. Kondratyev, A. R. Taubin, V. I. Varshavsky, </author> <title> On Self-Timed Behavior Verification, </title> <booktitle> in Proceedings of TAU92, </booktitle> <month> March </month> <year> 1992. </year>
Reference-contexts: Sangiovanni-Vincentelli [45] and Vanbekbergen, Lin, Goossens and De Man [46] handle state-variable insertion, with the former operating on live, safe STG/ICs, while the latter allows any state graph that is at least finite, connected, and has a consistent state assignment. 5.2 Change Diagrams Change diagrams (CDs) <ref> [47] </ref> are a model similar to STGs, but which avoids some of the restrictions found in STGs. Like STGs, a CD has nodes labeled by transitions, and arcs between transitions that define the allowed sequences of transition firings.
Reference: [48] <author> M. A. Kishinevsky, </author> <title> Private Communications, </title> <month> March </month> <year> 1993. </year>
Reference-contexts: It can be shown that only the first n periods of the CD need be unrolled, where n is the number of nodes in the original graph. Efficient methods for implementing CD specifications have been developed which avoid state graph expansion, but have not yet been published <ref> [48] </ref>. b r+ d+ c+ a+ 01001000 1110 10110111 0001 abcd r a a+ r+ b+ a+ b a (right). The change diagram at right is assumed to be 2-bounded.
Reference: [49] <author> K. van Berkel, </author> <title> Handshake circuits: an intermediary between communicating processes and VLSI, </title> <institution> Technische Universiteit Eindhoven, </institution> <year> 1992. </year>
Reference-contexts: Although the language constructs are somewhat more primitive than most typical software languages, they provide a higher-level abstraction than many of the other systems, including trace theory. Just as importantly, they provide enough flexibility to handle most types of circuits. Note that van Berkel <ref> [49] </ref> describes another approach with many similarities to Martins work. As illustrated in Figure 25, the first step in deriving a circuit from a program specification is to reduce complex control structures into combinations of simple processes.
Reference: [50] <author> A. J. Martin, S. M. Burns, T. K. Lee, D. Borkovic, P. J. Hazewindus, </author> <title> The Design of an Asynchronous Microprocessor, </title> <editor> in C. L. Seitz, Ed., </editor> <booktitle> Advanced Research in VLSI: Proceedings of the Decennial Caltech Conference, </booktitle> <pages> pp. 351-373, </pages> <year> 1989. </year>
Reference: [51] <author> G. M. Jacobs, R. W. Brodersen, </author> <title> A Fully Asynchronous Digital Signal Processor Using Self-Timed Circuits, </title> <journal> IEEE Journal of SolidState Circuits, </journal> <volume> Vol. 25, No. 6, </volume> <pages> pp. 1526-1537, </pages> <month> Dec. </month> <year> 1990. </year>
Reference: [52] <author> T. Williams, </author> <title> A Zero-Overhead Self-Timed 160-ns 54-b CMOS Divider, </title> <journal> Journal of SolidState Circuits, </journal> <volume> Vol. 26, No. 11, </volume> <pages> pp. 1651-1661, </pages> <month> Nov. </month> <year> 1991. </year>
Reference: [53] <author> J. Kessels, K. van Berkel, R. Burgess, M. Roncken, F. Schalij, </author> <title> An Error Decoder for the Compact Disc Player as an Example of VLSI Programming, </title> <booktitle> Proceedings of the European Conference on Design Automation, </booktitle> <pages> pp. 69-74, </pages> <year> 1992. </year>
Reference: [54] <author> M. R. Greenstreet, STARI: </author> <title> A Technique for High-Bandwidth Communication, </title> <type> Ph.D. Thesis, </type> <institution> Princeton University, </institution> <year> 1993. </year>
Reference: [55] <author> C. L. Seitz, W.-K. Su, </author> <title> A Family of Routing and Communication Chips Based on the Mosaic, </title> <editor> in G. Borriello, C. Ebeling, Ed., </editor> <booktitle> Research on Integrated Systems: Proceedings of the 1993 Symposium, </booktitle> <pages> pp. 320-337, </pages> <year> 1993. </year>
References-found: 56

