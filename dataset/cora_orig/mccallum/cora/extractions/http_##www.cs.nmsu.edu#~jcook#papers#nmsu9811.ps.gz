URL: http://www.cs.nmsu.edu/~jcook/papers/nmsu9811.ps.gz
Refering-URL: http://www.cs.nmsu.edu/~jcook/papers/
Root-URL: http://www.cs.nmsu.edu
Email: fjcook,jdageg@cs.nmsu.edu  
Title: Highly Reliable Upgrading of Components  
Author: Jonathan E. Cook Jeffrey A. Dage Jonathan E. Cook and Jeffrey A. Dage 
Note: c 1998  
Address: Las Cruces, NM 88003 USA  
Affiliation: Department of Computer Science New Mexico State University  
Abstract: New Mexico State University Department of Computer Science Technical Report NMSU-CSTR-9811 September 1998 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Andrews. </author> <title> Using Executable Assertions for Testing and Fault Tolerance. </title> <booktitle> In Proceedings of the 9th International Symposium on Fault-Tolerant Computing (FTCS-9), </booktitle> <pages> pages 102-105, </pages> <address> New York, 1979. </address> <publisher> IEEE. </publisher>
Reference-contexts: [2], and extending semantic analysis on variants of components to the pre-deployment phase [13]. 2.2 Self-Checking Systems Self-checking systems employ a type of run-time specification checking, where formal assertions about the state of the software or the values of inputs and outputs are checked during the execution of the program <ref> [1, 14, 44] </ref>. This type of dynamic formal verification is different than static verification in that it only checks states actually reached during execution. It enables partial models to be checked, however, and offers a relatively inexpensive method for ensuring that certain properties are met.
Reference: [2] <author> G. Aschemann and R. Kehr. </author> <title> Towards a Requirements-based Information Model for Configuration Management. </title> <booktitle> In Proceedings of the Fourth International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 181-188. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1998. </year>
Reference-contexts: Some reliability work has begun, such as the Simplex architecture for upgrading real-time controllers [38], analyzing the impacts of reconfiguration at an architectural level [29], checking whether a given or new configuration meets requirements constraints <ref> [2] </ref>, and extending semantic analysis on variants of components to the pre-deployment phase [13]. 2.2 Self-Checking Systems Self-checking systems employ a type of run-time specification checking, where formal assertions about the state of the software or the values of inputs and outputs are checked during the execution of the program [1,
Reference: [3] <author> M. Auguston, S. Banerjee, M. Mamnani, G. Nabi, J. Reinfelds, U. Sarkans, and I. Strnad. </author> <title> A Debugger and Assertion Checker for the Awk Programming Language. </title> <booktitle> In Proc. International Conference on Software Engineering: Education and Practice, </booktitle> <address> Dunedin, New Zealand, </address> <year> 1996. </year>
Reference-contexts: It enables partial models to be checked, however, and offers a relatively inexpensive method for ensuring that certain properties are met. Many methods have taken an approach at the level of a programming language <ref> [3, 8, 25, 28, 37] </ref>, while others have taken a more system-level view [10, 36]. 2.3 Multi-Versioned Systems Independently developing multiple versions of a component, and using them together, has been investigated as a way to make a system more reliable [4].
Reference: [4] <author> A. Avizienis. </author> <title> The N-version Approach to Fault-Tolerant Software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(12) </volume> <pages> 1491-1501, </pages> <year> 1985. </year> <month> 14 </month>
Reference-contexts: an approach at the level of a programming language [3, 8, 25, 28, 37], while others have taken a more system-level view [10, 36]. 2.3 Multi-Versioned Systems Independently developing multiple versions of a component, and using them together, has been investigated as a way to make a system more reliable <ref> [4] </ref>.
Reference: [5] <author> C. Bidan, V. Issarny, T. Saridakis, and A. Zarras. </author> <title> A Dynamic Reconfiguration Service for CORBA. </title> <booktitle> In Proceedings of the Fourth International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 35-42. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1998. </year>
Reference-contexts: The leading candidate for application is CORBA, the distributed component standard, but other promising frameworks include dynamic link libraries and JavaBeans. Existing research frameworks exploring issues in distributed configurable systems may also provide good beginning foundations (e.g., <ref> [5, 26, 33, 34, 35, 39, 40] </ref>) There are many needed directions for future work, besides the transfer to current component frameworks. These include: 13 * Extending the current work to handle voting mechanisms and state computations.
Reference: [6] <author> S. Brilliant, J. Knight, and N. Leveson. </author> <title> Analysis of Faults in an N-Version Software Experiment. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(2) </volume> <pages> 238-247, </pages> <year> 1990. </year>
Reference-contexts: Empirical evidence indicates, however, that the assumptions about independence may not be valid <ref> [6, 20, 21] </ref>; notions of failure diversity have been devised to better understand the conditions under which multi-versioned systems work well [12, 24, 32]. 2.4 Redundant/Replicated Systems Redundant or replicated systems run more than one copy of the exact same component, usually to protect against hardware/network faults or to provide better
Reference: [7] <author> R. Conradi and B. Westfechtel. </author> <title> Version Models for Software Configuration Management. </title> <journal> ACM Computing Surveys, </journal> <note> (to appear), </note> <year> 1998. </year>
Reference-contexts: These issues include maintaining consistent states among replicas [23], and managing reconfigurable groups of replicas [19]. 2.5 Configuration Management The field of configuration management (CM) provides a standard framework and terminology for relating component versions <ref> [7] </ref>. The term version is applied to any unique instance of a component. Certain versions that prove stable and foundational can be designated as baseline versions. A new revision of a component is created by taking an existing version and modifying it in some way|a linear relationship.
Reference: [8] <author> J. Cook. </author> <title> Assertions for the Tcl Language. </title> <booktitle> In Proc. 5th Annual Tcl/Tk Workshop '97, </booktitle> <pages> pages 73-80. </pages> <publisher> Usenix, </publisher> <month> July </month> <year> 1997. </year>
Reference-contexts: It enables partial models to be checked, however, and offers a relatively inexpensive method for ensuring that certain properties are met. Many methods have taken an approach at the level of a programming language <ref> [3, 8, 25, 28, 37] </ref>, while others have taken a more system-level view [10, 36]. 2.3 Multi-Versioned Systems Independently developing multiple versions of a component, and using them together, has been investigated as a way to make a system more reliable [4]. <p> For evaluating constraints, our prototype takes advantage of previous work one author had done on Tcl assertions <ref> [8] </ref>. The expression constructs from this work, especially existential and universal quantifiers over lists and arrays, are used to provide first-order logical constraint expressions.
Reference: [9] <author> F. Cristian. </author> <title> Understanding Fault-Tolerant Distributed Systems. </title> <journal> Communications of the ACM, </journal> <volume> 34(2), </volume> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: been devised to better understand the conditions under which multi-versioned systems work well [12, 24, 32]. 2.4 Redundant/Replicated Systems Redundant or replicated systems run more than one copy of the exact same component, usually to protect against hardware/network faults or to provide better service in terms of speed or availability <ref> [9] </ref>. While these frameworks have not addressed software fault tolerance, many of the issues addressed in this research come to bear in our investigations.
Reference: [10] <author> M. Diaz, G. Juanole, and J. Courtiat. </author> <title> Observer|A Concept for Formal On-Line Validation of Distributed Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> 20(12) 900-913, 1994. 
Reference-contexts: It enables partial models to be checked, however, and offers a relatively inexpensive method for ensuring that certain properties are met. Many methods have taken an approach at the level of a programming language [3, 8, 25, 28, 37], while others have taken a more system-level view <ref> [10, 36] </ref>. 2.3 Multi-Versioned Systems Independently developing multiple versions of a component, and using them together, has been investigated as a way to make a system more reliable [4].
Reference: [11] <institution> Digital Equipment Corporation, Hewlett-Packard Company, HyperDesk Corporation, NCR Corporation, </institution> <note> Object Design, </note> <author> Inc., and SunSoft, Inc. </author> <title> The Common Object Request Broker: Architecture and Specification, Version 1.2. Object Management Group, </title> <type> Framingham, </type> <institution> Massachusetts, </institution> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Currently, system construction has moved away from monolithic systems towards more component-based architectures. Shared and dynamic-link libraries, Java class files, and distributed component frameworks <ref> [11, 17] </ref>, all provide a separation between components that make up a system. In these settings, individual components can be replaced relatively independent of one another. Individual component replacement offers a step in the direction of more reliable upgrades.
Reference: [12] <author> D. Eckhardt and L. Lee. </author> <title> A Theoretical Basis for the Analysis of Redundant Software Subject to Coincident Errors. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(12):1511|1517, </volume> <year> 1985. </year>
Reference-contexts: Empirical evidence indicates, however, that the assumptions about independence may not be valid [6, 20, 21]; notions of failure diversity have been devised to better understand the conditions under which multi-versioned systems work well <ref> [12, 24, 32] </ref>. 2.4 Redundant/Replicated Systems Redundant or replicated systems run more than one copy of the exact same component, usually to protect against hardware/network faults or to provide better service in terms of speed or availability [9].
Reference: [13] <author> P. Feiler and J. Li. </author> <title> Consistency in Dynamic Reconfiguration. </title> <booktitle> In Proceedings of the Fourth International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 189-196. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1998. </year>
Reference-contexts: Some reliability work has begun, such as the Simplex architecture for upgrading real-time controllers [38], analyzing the impacts of reconfiguration at an architectural level [29], checking whether a given or new configuration meets requirements constraints [2], and extending semantic analysis on variants of components to the pre-deployment phase <ref> [13] </ref>. 2.2 Self-Checking Systems Self-checking systems employ a type of run-time specification checking, where formal assertions about the state of the software or the values of inputs and outputs are checked during the execution of the program [1, 14, 44].
Reference: [14] <author> P. Fritzson, M. Auguston, and N. Shahmehri. </author> <title> Using Assertions in Declarative and Operational Models for Automated Debugging. </title> <journal> Journal of Systems and Software, </journal> <volume> 25(3) </volume> <pages> 223-232, </pages> <year> 1994. </year>
Reference-contexts: [2], and extending semantic analysis on variants of components to the pre-deployment phase [13]. 2.2 Self-Checking Systems Self-checking systems employ a type of run-time specification checking, where formal assertions about the state of the software or the values of inputs and outputs are checked during the execution of the program <ref> [1, 14, 44] </ref>. This type of dynamic formal verification is different than static verification in that it only checks states actually reached during execution. It enables partial models to be checked, however, and offers a relatively inexpensive method for ensuring that certain properties are met.
Reference: [15] <author> D. Gluch and C.B. Weinstock, eds. </author> <title> Workshop on the State of the Practice in Dependably Upgrading Critical Systems. </title> <type> Technical Report CMU/SEI-97-SR-014, </type> <institution> Software Engineering Institute, </institution> <month> Aug. </month> <year> 1997. </year>
Reference-contexts: However, emphasis is on reconfiguring a system for a new task or in simply on-the-fly component replacement, and the general assumption is that the component will be reliable in its new task [27, 43]. A recently held workshop on dependably upgrading critical systems <ref> [15] </ref> noted many of the fundamental reliability concerns that still need to be addressed in this field, since the frameworks have thus far been focussed on support mechanisms and not on ensuring system reliability.
Reference: [16] <author> K. Goudarzi and J. Kramer. </author> <title> Maintaining Node Consistency in the Face of Dynamic Change. </title> <booktitle> In Proceedings of the Third International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 62-69. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: Each of these areas is summarized briefly below. 2.1 Distributed Configurable Systems The research in the area of distributed configurable systems has been focussed on dynamically changing the relationships and connections between components, and in replacing components while the system is running <ref> [16, 18, 22, 30, 33, 42] </ref>. Transaction models are generally used to control when replacement takes place, and mechanisms have been developed to transfer state to the new component [23].
Reference: [17] <author> G. Hamilton, ed. </author> <title> JavaBeans API Specification, 1.01. </title> <type> Technical report, </type> <institution> Sun Microsystems, Inc. </institution>
Reference-contexts: Currently, system construction has moved away from monolithic systems towards more component-based architectures. Shared and dynamic-link libraries, Java class files, and distributed component frameworks <ref> [11, 17] </ref>, all provide a separation between components that make up a system. In these settings, individual components can be replaced relatively independent of one another. Individual component replacement offers a step in the direction of more reliable upgrades.
Reference: [18] <author> S. Hauptmann and J. Wasel. </author> <title> On-Line Maintainence with On-the-Fly Software Replacement. </title> <booktitle> In Proceedings of the Third International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 70-80. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: Each of these areas is summarized briefly below. 2.1 Distributed Configurable Systems The research in the area of distributed configurable systems has been focussed on dynamically changing the relationships and connections between components, and in replacing components while the system is running <ref> [16, 18, 22, 30, 33, 42] </ref>. Transaction models are generally used to control when replacement takes place, and mechanisms have been developed to transfer state to the new component [23].
Reference: [19] <author> C. Karamanolis and J. Magee. </author> <title> A Replication Protocol to Support Dynamically Configurable Groups of Servers. </title> <booktitle> In Proceedings of the Third International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 161-168. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: While these frameworks have not addressed software fault tolerance, many of the issues addressed in this research come to bear in our investigations. These issues include maintaining consistent states among replicas [23], and managing reconfigurable groups of replicas <ref> [19] </ref>. 2.5 Configuration Management The field of configuration management (CM) provides a standard framework and terminology for relating component versions [7]. The term version is applied to any unique instance of a component. Certain versions that prove stable and foundational can be designated as baseline versions.
Reference: [20] <author> J. Knight and N. Leveson. </author> <title> An Empirical Study of Failure Probabilities in Multi-version Software. </title> <booktitle> In Proceedings of the 16th International Symposium on Fault-Tolerant Computing (FTCS-16), </booktitle> <pages> pages 165-170, </pages> <address> New York, </address> <month> July </month> <year> 1986. </year> <journal> IEEE. </journal> <volume> 15 </volume>
Reference-contexts: Empirical evidence indicates, however, that the assumptions about independence may not be valid <ref> [6, 20, 21] </ref>; notions of failure diversity have been devised to better understand the conditions under which multi-versioned systems work well [12, 24, 32]. 2.4 Redundant/Replicated Systems Redundant or replicated systems run more than one copy of the exact same component, usually to protect against hardware/network faults or to provide better
Reference: [21] <author> J. Knight and N. Leveson. </author> <title> An Experimental Evaluation of the Assumption of Independence in Multi--version Programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(1) </volume> <pages> 96-109, </pages> <year> 1986. </year>
Reference-contexts: Empirical evidence indicates, however, that the assumptions about independence may not be valid <ref> [6, 20, 21] </ref>; notions of failure diversity have been devised to better understand the conditions under which multi-versioned systems work well [12, 24, 32]. 2.4 Redundant/Replicated Systems Redundant or replicated systems run more than one copy of the exact same component, usually to protect against hardware/network faults or to provide better
Reference: [22] <author> J. Kramer and J. Magee. </author> <title> The Evolving Philosophers Problem: Dynamic Change Management. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(11) </volume> <pages> 1293-1306, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Each of these areas is summarized briefly below. 2.1 Distributed Configurable Systems The research in the area of distributed configurable systems has been focussed on dynamically changing the relationships and connections between components, and in replacing components while the system is running <ref> [16, 18, 22, 30, 33, 42] </ref>. Transaction models are generally used to control when replacement takes place, and mechanisms have been developed to transfer state to the new component [23].
Reference: [23] <author> M. Little and S. Shrivastava. </author> <title> Using Application Specific Knowledge for Configuring Object Replicas. </title> <booktitle> In Proceedings of the Third International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 169-176. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: Transaction models are generally used to control when replacement takes place, and mechanisms have been developed to transfer state to the new component <ref> [23] </ref>. However, emphasis is on reconfiguring a system for a new task or in simply on-the-fly component replacement, and the general assumption is that the component will be reliable in its new task [27, 43]. <p> While these frameworks have not addressed software fault tolerance, many of the issues addressed in this research come to bear in our investigations. These issues include maintaining consistent states among replicas <ref> [23] </ref>, and managing reconfigurable groups of replicas [19]. 2.5 Configuration Management The field of configuration management (CM) provides a standard framework and terminology for relating component versions [7]. The term version is applied to any unique instance of a component.
Reference: [24] <author> B. Littlewoood and D. Miller. </author> <title> Conceptual Modelling of Coincident Failures in Multiversion Software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(12) </volume> <pages> 1596-1614, </pages> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: Empirical evidence indicates, however, that the assumptions about independence may not be valid [6, 20, 21]; notions of failure diversity have been devised to better understand the conditions under which multi-versioned systems work well <ref> [12, 24, 32] </ref>. 2.4 Redundant/Replicated Systems Redundant or replicated systems run more than one copy of the exact same component, usually to protect against hardware/network faults or to provide better service in terms of speed or availability [9].
Reference: [25] <author> D. Luckham. </author> <title> Programming with Specifications: An introduction to Anna, a language for specifying Ada programs. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: It enables partial models to be checked, however, and offers a relatively inexpensive method for ensuring that certain properties are met. Many methods have taken an approach at the level of a programming language <ref> [3, 8, 25, 28, 37] </ref>, while others have taken a more system-level view [10, 36]. 2.3 Multi-Versioned Systems Independently developing multiple versions of a component, and using them together, has been investigated as a way to make a system more reliable [4].
Reference: [26] <author> J. Magee, N. Dulay, S. Eisenbach, and J. Kramer. </author> <title> A Constructive Development Environment for Parallel and Distributed Systems. </title> <booktitle> In Proceedings of the Second International Workshop on Configurable Distributed Systems. </booktitle> <publisher> IEEE Press, </publisher> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: The leading candidate for application is CORBA, the distributed component standard, but other promising frameworks include dynamic link libraries and JavaBeans. Existing research frameworks exploring issues in distributed configurable systems may also provide good beginning foundations (e.g., <ref> [5, 26, 33, 34, 35, 39, 40] </ref>) There are many needed directions for future work, besides the transfer to current component frameworks. These include: 13 * Extending the current work to handle voting mechanisms and state computations.
Reference: [27] <author> G. Matos and E. White. </author> <title> Application of Dynamic Reconfiguration in the Design of Fault Tolerant Production Systems. </title> <booktitle> In Proceedings of the Fourth International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 2-9. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1998. </year>
Reference-contexts: However, emphasis is on reconfiguring a system for a new task or in simply on-the-fly component replacement, and the general assumption is that the component will be reliable in its new task <ref> [27, 43] </ref>. A recently held workshop on dependably upgrading critical systems [15] noted many of the fundamental reliability concerns that still need to be addressed in this field, since the frameworks have thus far been focussed on support mechanisms and not on ensuring system reliability.
Reference: [28] <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: It enables partial models to be checked, however, and offers a relatively inexpensive method for ensuring that certain properties are met. Many methods have taken an approach at the level of a programming language <ref> [3, 8, 25, 28, 37] </ref>, while others have taken a more system-level view [10, 36]. 2.3 Multi-Versioned Systems Independently developing multiple versions of a component, and using them together, has been investigated as a way to make a system more reliable [4].
Reference: [29] <author> P. Oreizy and R. Taylor. </author> <title> On the Role of Software Architectures in Runtime System Reconfiguration. </title> <booktitle> In Proceedings of the Fourth International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 61-70. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1998. </year>
Reference-contexts: Some reliability work has begun, such as the Simplex architecture for upgrading real-time controllers [38], analyzing the impacts of reconfiguration at an architectural level <ref> [29] </ref>, checking whether a given or new configuration meets requirements constraints [2], and extending semantic analysis on variants of components to the pre-deployment phase [13]. 2.2 Self-Checking Systems Self-checking systems employ a type of run-time specification checking, where formal assertions about the state of the software or the values of inputs
Reference: [30] <author> I. Oueicheck and X. R. de Pina. </author> <title> Dynamic Configuration Management in the Guide Object-Oriented Distributed System. </title> <booktitle> In Proceedings of the Third International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 28-35. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: Each of these areas is summarized briefly below. 2.1 Distributed Configurable Systems The research in the area of distributed configurable systems has been focussed on dynamically changing the relationships and connections between components, and in replacing components while the system is running <ref> [16, 18, 22, 30, 33, 42] </ref>. Transaction models are generally used to control when replacement takes place, and mechanisms have been developed to transfer state to the new component [23].
Reference: [31] <author> J. Ousterhout. </author> <title> Tcl and the Tk Toolkit. Professional Computing Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1994. </year>
Reference-contexts: improve performance, and might take the form of configuration parameters for the framework. 4 EXAMPLE In this section we describe our prototype implementation of the reliable component upgrading framework, and present an example use of the framework. 4.1 Prototype Implementation We have prototyped this framework in the Tcl programming langauage <ref> [31] </ref>. Tcl offers meta-level language features such as a functional-like "eval" command and the ability to replace built-in 9 commands with customized ones, thus providing easy hooks into the language execution. In Tcl, the main component is a procedure, and it is at this level that we implemented our prototype.
Reference: [32] <author> D. Partridge and W. Krzanowski. </author> <title> Distinct Failure Diversity in Multiversion Software. </title> <type> Technical Report unkown, </type> <institution> University of Exeter, UK, </institution> <month> Aug. </month> <year> 1997. </year>
Reference-contexts: Empirical evidence indicates, however, that the assumptions about independence may not be valid [6, 20, 21]; notions of failure diversity have been devised to better understand the conditions under which multi-versioned systems work well <ref> [12, 24, 32] </ref>. 2.4 Redundant/Replicated Systems Redundant or replicated systems run more than one copy of the exact same component, usually to protect against hardware/network faults or to provide better service in terms of speed or availability [9].
Reference: [33] <author> J. Purtilo. </author> <title> The POLYLITH Software Bus. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 151-174, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Each of these areas is summarized briefly below. 2.1 Distributed Configurable Systems The research in the area of distributed configurable systems has been focussed on dynamically changing the relationships and connections between components, and in replacing components while the system is running <ref> [16, 18, 22, 30, 33, 42] </ref>. Transaction models are generally used to control when replacement takes place, and mechanisms have been developed to transfer state to the new component [23]. <p> The leading candidate for application is CORBA, the distributed component standard, but other promising frameworks include dynamic link libraries and JavaBeans. Existing research frameworks exploring issues in distributed configurable systems may also provide good beginning foundations (e.g., <ref> [5, 26, 33, 34, 35, 39, 40] </ref>) There are many needed directions for future work, besides the transfer to current component frameworks. These include: 13 * Extending the current work to handle voting mechanisms and state computations.
Reference: [34] <author> J. Purtilo and P. Jalote. </author> <title> An Environment for Developing Fault Tolerant Software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 153-159, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: The leading candidate for application is CORBA, the distributed component standard, but other promising frameworks include dynamic link libraries and JavaBeans. Existing research frameworks exploring issues in distributed configurable systems may also provide good beginning foundations (e.g., <ref> [5, 26, 33, 34, 35, 39, 40] </ref>) There are many needed directions for future work, besides the transfer to current component frameworks. These include: 13 * Extending the current work to handle voting mechanisms and state computations.
Reference: [35] <author> N. Rodriguez, R. Ierusalimschy, and R. Cerqueira. </author> <title> Dynamic Configuration with CORBA Components. </title> <booktitle> In Proceedings of the Fourth International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 27-34. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1998. </year>
Reference-contexts: The leading candidate for application is CORBA, the distributed component standard, but other promising frameworks include dynamic link libraries and JavaBeans. Existing research frameworks exploring issues in distributed configurable systems may also provide good beginning foundations (e.g., <ref> [5, 26, 33, 34, 35, 39, 40] </ref>) There are many needed directions for future work, besides the transfer to current component frameworks. These include: 13 * Extending the current work to handle voting mechanisms and state computations.
Reference: [36] <author> D. Rosenblum. </author> <title> Automated Monitoring of Component Integrity in Distributed Object Systems. </title> <booktitle> In Advanced Topics Workshop of the 3rd USENIX Conference on Object-Oriented Technologies and Systems. USENIX Association, </booktitle> <month> June </month> <year> 1997. </year> <month> 16 </month>
Reference-contexts: It enables partial models to be checked, however, and offers a relatively inexpensive method for ensuring that certain properties are met. Many methods have taken an approach at the level of a programming language [3, 8, 25, 28, 37], while others have taken a more system-level view <ref> [10, 36] </ref>. 2.3 Multi-Versioned Systems Independently developing multiple versions of a component, and using them together, has been investigated as a way to make a system more reliable [4].
Reference: [37] <author> D. S. Rosenblum. </author> <title> A Practical Approach to Programming with Assertions. </title> <journal> IEEE Transactions on Software Engineering, </journal> <year> 1995. </year>
Reference-contexts: It enables partial models to be checked, however, and offers a relatively inexpensive method for ensuring that certain properties are met. Many methods have taken an approach at the level of a programming language <ref> [3, 8, 25, 28, 37] </ref>, while others have taken a more system-level view [10, 36]. 2.3 Multi-Versioned Systems Independently developing multiple versions of a component, and using them together, has been investigated as a way to make a system more reliable [4].
Reference: [38] <author> L. Sha, R. Rajkumar, and M. Gagliardi. </author> <title> Evolving Dependable Real Time Systems. </title> <booktitle> In Component-Based Software Engineering: Selected Papers from the Software Engineering Institute, </booktitle> <pages> pages 125-132. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year> <note> Reprinted from Proc. Aerospace Applications Conf., </note> <year> 1996. </year>
Reference-contexts: Some reliability work has begun, such as the Simplex architecture for upgrading real-time controllers <ref> [38] </ref>, analyzing the impacts of reconfiguration at an architectural level [29], checking whether a given or new configuration meets requirements constraints [2], and extending semantic analysis on variants of components to the pre-deployment phase [13]. 2.2 Self-Checking Systems Self-checking systems employ a type of run-time specification checking, where formal assertions about
Reference: [39] <author> S. Shrivastava. </author> <title> Lessons Learned from Building and Using the Arjuna Distributed Programming System, </title> <booktitle> volume 938 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: The leading candidate for application is CORBA, the distributed component standard, but other promising frameworks include dynamic link libraries and JavaBeans. Existing research frameworks exploring issues in distributed configurable systems may also provide good beginning foundations (e.g., <ref> [5, 26, 33, 34, 35, 39, 40] </ref>) There are many needed directions for future work, besides the transfer to current component frameworks. These include: 13 * Extending the current work to handle voting mechanisms and state computations.
Reference: [40] <author> S. Shrivastava and S. Wheater. </author> <title> Architectural Support for Dynamic Reconfiguration of Large Scale Distributed Applications. </title> <booktitle> In Proceedings of the Fourth International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 10-17. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1998. </year>
Reference-contexts: The leading candidate for application is CORBA, the distributed component standard, but other promising frameworks include dynamic link libraries and JavaBeans. Existing research frameworks exploring issues in distributed configurable systems may also provide good beginning foundations (e.g., <ref> [5, 26, 33, 34, 35, 39, 40] </ref>) There are many needed directions for future work, besides the transfer to current component frameworks. These include: 13 * Extending the current work to handle voting mechanisms and state computations.
Reference: [41] <author> A. van der Hoek, D. Heimbigner, and A. Wolf. </author> <title> Software Architecture, Configuration Management, and Configurable Distributed Systems: A Menage a Trois. </title> <type> Technical Report CU-CS-849-98, </type> <institution> University of Colorado, </institution> <month> Jan. </month> <year> 1998. </year>
Reference-contexts: These relationships play an important role in component upgrading. Some new research directions in configuration management involve extending the use of versions to the architectural level, especially in the realm of distributed, configurable, component-based systems <ref> [41] </ref>. 3 METHODS This section presents the methods that make up our active framework that supports the reliable upgrading of a component. 3.1 Overview The key insight in our approach is that the successive versions of a component constitute a multi-versioned system, albeit without the independence assumption of "true" multi-versioned systems.
Reference: [42] <author> I. Warren and I. Sommerville. </author> <title> A Model for Dynamic Configuration which Preserves Application Integrity. </title> <booktitle> In Proceedings of the Third International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 81-88. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: Each of these areas is summarized briefly below. 2.1 Distributed Configurable Systems The research in the area of distributed configurable systems has been focussed on dynamically changing the relationships and connections between components, and in replacing components while the system is running <ref> [16, 18, 22, 30, 33, 42] </ref>. Transaction models are generally used to control when replacement takes place, and mechanisms have been developed to transfer state to the new component [23].
Reference: [43] <author> D. Welch. </author> <title> Building Self-Reconfiguring Distributed Systems using Compensating Reconfiguration. </title> <booktitle> In Proceedings of the Fourth International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 18-25. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1998. </year>
Reference-contexts: However, emphasis is on reconfiguring a system for a new task or in simply on-the-fly component replacement, and the general assumption is that the component will be reliable in its new task <ref> [27, 43] </ref>. A recently held workshop on dependably upgrading critical systems [15] noted many of the fundamental reliability concerns that still need to be addressed in this field, since the frameworks have thus far been focussed on support mechanisms and not on ensuring system reliability.
Reference: [44] <author> S. Yau and R. Cheung. </author> <title> Design of Self-Checking Software. </title> <booktitle> In Proc. 1975 International Conference on Reliable Software, </booktitle> <pages> pages 450-457, </pages> <address> New York, </address> <year> 1975. </year> <journal> ACM. </journal> <volume> 17 </volume>
Reference-contexts: [2], and extending semantic analysis on variants of components to the pre-deployment phase [13]. 2.2 Self-Checking Systems Self-checking systems employ a type of run-time specification checking, where formal assertions about the state of the software or the values of inputs and outputs are checked during the execution of the program <ref> [1, 14, 44] </ref>. This type of dynamic formal verification is different than static verification in that it only checks states actually reached during execution. It enables partial models to be checked, however, and offers a relatively inexpensive method for ensuring that certain properties are met.
References-found: 44

