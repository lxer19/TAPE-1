URL: ftp://st.cs.uiuc.edu/pub/patterns/papers/problem-frames.ps
Refering-URL: http://st-www.cs.uiuc.edu/users/patterns/New.html
Root-URL: http://www.cs.uiuc.edu
Title: Problems, Methods and Specialisation  
Author: Michael Jackson 
Date: 2001)  
Note: (A Contribution to the Special Issue of SE Journal on Software Engineering in the Year  
Abstract: Software Engineering is not a discipline: it is an aspiration, as yet unachieved. Many approaches have been proposed, including reusable components, formal methods, structured methods, and architectural studies. These approaches chiefly emphasise the engineering product: the solution rather than the problem it solves. An approach to understanding and classifying software development problems in terms of problem frames is suggested. In addition to such general approaches, specialisation is essential: the established branches of engineering are all specialisations. Some specialisations have arisen in software development, notably in compiler construction and software for personal computers. More are needed.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Christopher Alexander, </author> <title> Sora Ishikawa and Murray Silverstein; A Pattern Language; Oxford University Press, </title> <address> New York, </address> <year> 1977. </year>
Reference-contexts: They are concerned to classify and study common architectural styles such as pipes-and-filters and blackboard-connected-processes. Their approach has something in common with the work on programming cliches [17], and with the `Pattern Language' approach [8] that draws on the work of the software methodologist's favourite architect, Christopher Alexander <ref> [1] </ref>. All of this work approaches the design task from the side of the software-hardware machine. It focuses on the characteristics and structure of the solution, and so offers a prospect of evolving the kinds of standard design that are found in the established branches of engineering.
Reference: [2] <author> Frederick P Brooks Jr; No Silver Bullet|Essence and Accidents of Software Engineering; Information Processing 86: </author> <booktitle> Proceedings of the IFIP 10th World Computer Congress, </booktitle> <pages> pages 1069-1076; North-Holland, </pages> <year> 1986. </year>
Reference-contexts: Software engineering has not become like the other established branches, and it will not become so in the near future. One reason is simply that it's difficult. Fred Brooks, in his much-quoted paper <ref> [2] </ref>, said: "The essence of a software entity is a construct of interlocking concepts: data sets, relationships among data items, algorithms, and invocations of functions. This essence is abstract, in that the conceptual construct is the same under many different representations.
Reference: [3] <institution> Pierre-Arnoul de Marneffe; Holon Programming: A survey; Universite de Liege, Service Informatique, </institution> <year> 1973. </year> <booktitle> Quoted in: Donald E Knuth; 18 Structured Programming with go to Statements; ACM Computing Sur--veys Volume 6 Number 4, </booktitle> <pages> pages 261-301, </pages> <month> December </month> <year> 1974. </year>
Reference-contexts: There is then a potential difficulty in implementation, to give one domain within the machine an implementation that conforms to both sets of characteristics. This kind of composition exploits what traditional engineers call The Shanley Principle, whose relevance to software development was pointed out by de Marneffe <ref> [3] </ref>: " ... If you make a cross-section of, for instance, the German V-2 [rocket], you find external skin, structural rods, tank wall, etc.
Reference: [4] <editor> E W Dijkstra; Cooperating Sequential Processes; in Programming Languages, </editor> <publisher> F Genuys ed; Academic Press, </publisher> <year> 1968. </year>
Reference-contexts: Its developers were also apparently unaware of the pitfalls associated with concurrent access to shared variables, a problem whose solution, by T Dekker, had been reported in the year of the NATO conference <ref> [4] </ref>. Another reason for the failure of our aspiration to become engineers is that many theorists and practitioners, even among the most professional, are nave.
Reference: [5] <author> David Garlan and Mary Shaw. </author> <title> An Introduction to Software Architecture; in Advances in Software Engineering and Knowledge Engineering Volume 1, </title> <publisher> V Ambriola and G Tortora eds; World Scientific Publishing Co, </publisher> <address> New Jersey, </address> <year> 1993. </year>
Reference-contexts: But this very generality gives a design space that is too wide for comfort. 5 3 Problems and Solutions Garlan and Shaw, in their architectural approach <ref> [5] </ref>, move towards a narrowing of the design space facing the developer. They are concerned to classify and study common architectural styles such as pipes-and-filters and blackboard-connected-processes.
Reference: [6] <author> Michael Jackson; System Development; Prentice-Hall International, </author> <year> 1983. </year>
Reference-contexts: The products of this expertise provide the foundation on which a system's requirements and specifications may be built. Some attention [16] has been paid to application domains considered generically: to the banking domain, or to missile applications, or to strategic-management-support-systems. And some development methods (for example, JSD <ref> [6] </ref>) have advocated explicit analysis and description of the particular `real world' for each particular system. Identifying and understanding the `real world' must be a first step towards understanding the problem to be solved. It is the context in which the problem exists. <p> Here we can only identify a few software problem frames and describe them roughly. We may call them the JSD frame, the Workpiece frame, and the Environment-Effect frame. 6.1 The JSD Problem Frame The JSD method <ref> [6] </ref> uses a problem frame appropriate to the development of information systems. The principal parts of the JSD problem frame are these: 11 Real World This is the particular world about which the system is to produce information. It is a domain in the problem context.
Reference: [7] <editor> Michael Jackson and Pamela Zave; Domain Descriptions; RE'93 Proceedings, </editor> <publisher> pages 56-64; IEEE Computer Society Press, </publisher> <year> 1992. </year>
Reference-contexts: The software developer's expertise in a domain <ref> [7] </ref> is, above all, an active understanding of how to describe it. The products of this expertise provide the foundation on which a system's requirements and specifications may be built.
Reference: [8] <editor> Ralph E Johnson; Documenting Frameworks using Patterns; OOP-SLA'92 Proceedings, </editor> <booktitle> ACM SIGPLAN Notices Volume 27 Number 10, </booktitle> <pages> pages 63-76, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: They are concerned to classify and study common architectural styles such as pipes-and-filters and blackboard-connected-processes. Their approach has something in common with the work on programming cliches [17], and with the `Pattern Language' approach <ref> [8] </ref> that draws on the work of the software methodologist's favourite architect, Christopher Alexander [1]. All of this work approaches the design task from the side of the software-hardware machine.
Reference: [9] <editor> Ralph E Johnson; Why a Conference on Pattern Languages? ACM SE Notes, </editor> <volume> Volume 19 Number 1, </volume> <pages> pages 50-52, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: But it tends to ignore the complementary|and perhaps more important|side of the development task: the characterisation of the problem to which the software-hardware machine provides a solution. Johnson, a leading proponent of patterns, says in <ref> [9] </ref>: "Alexander focuses as much on the problem to be solved and the various forces on the problem as he does on the solution to the problem.
Reference: [10] <institution> Cliff B Jones; Systematic Software Development Using VDM; 2nd edition; Prentice-Hall International, </institution> <year> 1990. </year>
Reference-contexts: Or, perversely, it is too general. How many programmers, even while you read this sentence, are programming linear search? And some of them, no doubt, are programming it wrongly. Proponents of formal methods, such as Z [20] and VDM <ref> [10] </ref>, offer a different diagnosis and therapy: they point to the often neglected mathematical aspect of software development. Undeniably, computer programs can be regarded as formal things, and can therefore be subjected to mathematical treatment. Formalists want to emulate the practitioners of the established branches of engineering.
Reference: [11] <editor> Nancy G Leveson and Clark S Turner; An Investigation of the Therac-25 Accidents; IEEE Computer, </editor> <volume> Volume 26 Number 7, </volume> <pages> pages 18-41, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Software development is still largely an amateur activity in a very important sense. In a paper analysing the Therac-25 accidents <ref> [11] </ref>, an official of the US Food and Drug Administration (FDA) is quoted as saying: "A significant amount of software for life-critical systems comes from small firms, especially in the medical device industry; firms that fit the profile of those resistant to or uninformed of the prin ciples of either system
Reference: [12] <author> Bertrand Meyer; Object-Oriented Software Construction; Prentice-Hall International, </author> <year> 1988. </year>
Reference-contexts: Rigorous description and calculation must come second. It may then be crucially important for some aspects of the task, but it is not always at the heart of the problem. `Structured' [21] and `Object-Oriented' <ref> [12] </ref> methods are concerned with the problem of designing software structures. In most cases their prescriptions, too, are excessively general. Every piece of software can be described| at least, to some extent|by a dataflow diagram. Every program can be built|more or less appropriately|in an object-oriented language.
Reference: [13] <author> Peter Naur and Brian Randell, </author> <booktitle> eds; Software Engineering: Report on a conference sponsored by the NATO Science Committee, Garmisch, Germany, 7th to 11th October 1968; NATO Brussels, </booktitle> <year> 1969. </year>
Reference-contexts: 1 The Aspiration The term Software Engineering is usually thought to date from 1968. The report of the first Software Engineering conference <ref> [13] </ref> explains the background: "In late 1967 the [NATO Science Committee] Study Group recommended the holding of a working conference on Software Engineering. <p> One strong medicine is the development and use of catalogues of ready-made components, following the example of electronic engineers and some others. In an invited address at the NATO conference <ref> [13] </ref>, Doug McIlroy said: 3 "Components, dignified as a hardware field, is unknown as a legit-imate branch of software. When we undertake to write a compiler, we begin by saying `What table mechanism shall we build?' Not `What mechanism shall we use?', but `What mechanism shall we build?'.
Reference: [14] <institution> D L Parnas and J Madey; Functional Documentation for Computer Systems Engineering (Version 2); CRL Report 237, McMaster University, </institution> <address> Hamilton Ontario, Canada, </address> <year> 1991. </year> <month> 19 </month>
Reference-contexts: It has something in common with an approach described by Parnas and Madey <ref> [14] </ref>. It is suitable for an embedded system that controls an external domain. The principal parts are: Environment The domain to be controlled.
Reference: [15] <institution> G A Polya; How To Solve It; Princeton University Press, </institution> <address> 2nd Edition, </address> <year> 1957. </year>
Reference-contexts: The ancient Greek mathematicians paid a lot of attention to the study of problems, treating it separately from the related study of solutions and solution methods. An admirable little book by Polya <ref> [15] </ref> gives an account of their ideas.
Reference: [16] <institution> Ruben Prieto-Daz and Guillermo Arango; Domain Analysis and Software Systems Modeling; IEEE Computer Society Press, </institution> <year> 1991. </year>
Reference-contexts: The software developer's expertise in a domain [7] is, above all, an active understanding of how to describe it. The products of this expertise provide the foundation on which a system's requirements and specifications may be built. Some attention <ref> [16] </ref> has been paid to application domains considered generically: to the banking domain, or to missile applications, or to strategic-management-support-systems. And some development methods (for example, JSD [6]) have advocated explicit analysis and description of the particular `real world' for each particular system.
Reference: [17] <editor> Charles Rich and Richard C Waters; Formalizing Reusable Software Components in the Programmer's Apprentice; In Software Reusability Volume II; Ted J Biggerstaff and Alan J Perlis eds; pages 313-343; Addison-Wesley, </editor> <year> 1989. </year>
Reference-contexts: They are concerned to classify and study common architectural styles such as pipes-and-filters and blackboard-connected-processes. Their approach has something in common with the work on programming cliches <ref> [17] </ref>, and with the `Pattern Language' approach [8] that draws on the work of the software methodologist's favourite architect, Christopher Alexander [1]. All of this work approaches the design task from the side of the software-hardware machine.
Reference: [18] <author> W P Stevens, G J Myers, </author> <title> and L L Constantine; Structured Design; IBM Systems Journal Volume 13 Number 2, </title> <booktitle> pages 115-139, 1974; reprinted in Peter Freeman and Anthony I Wasserman; Tutorial on Software Design Techniques; IEEE Computer Society Press, 4th edition, </booktitle> <year> 1983. </year>
Reference-contexts: Identifying and understanding the `real world' must be a first step towards understanding the problem to be solved. It is the context in which the problem exists. Consider, for example, this classic problem (adapted from <ref> [18] </ref>): "A patient-monitoring program is required for a hospital. Each patient is monitored by an analog device that measures factors such as pulse, temperature, blood pressure, and skin resistance. 8 "The program reads these factors on a periodic basis (specified for each patient).
Reference: [19] <author> Wladyslaw M Turski; And No Philosopher's Stone, </author> <booktitle> Either; Information Processing 86: Proceedings of the IFIP 10th World Computer Congress, </booktitle> <pages> pages 1077-1080; North-Holland, </pages> <year> 1986. </year>
Reference-contexts: But the materials and techniques of software development, in those areas where we lack standard designs, have a very wide applicability. The problem can not be taken for granted: it must be quite explicitly identified and analysed. 4 Problem Contexts Responding to Fred Brooks, Wlad Turski <ref> [19] </ref> pointed out that software development is concerned with more than a formal computing system: "But, as we have observed before, software has another aspect: that of describing properties of an application domain. In this sense software does not always relate two formal systems [software and hardware].
Reference: [20] <author> J B Wordsworth; Software Development with Z; Addison-Wesley, </author> <year> 1992. </year>
Reference-contexts: Or, perversely, it is too general. How many programmers, even while you read this sentence, are programming linear search? And some of them, no doubt, are programming it wrongly. Proponents of formal methods, such as Z <ref> [20] </ref> and VDM [10], offer a different diagnosis and therapy: they point to the often neglected mathematical aspect of software development. Undeniably, computer programs can be regarded as formal things, and can therefore be subjected to mathematical treatment. Formalists want to emulate the practitioners of the established branches of engineering.
Reference: [21] <institution> Edward Yourdon; Modern Structured Analysis; Prentice-Hall International, </institution> <year> 1989. </year> <note> 26/07/94 M A Jackson 101 Hamilton Terrace London NW8 9QX mj@doc.ic.ac.uk jacksonma@attmail.att.com +44 0171 286 1814 (voice) +44 0171 266 2645 (fax) file: sejrnl02.tex 20 </note>
Reference-contexts: Only when that has been done, at least in outline, is the subject matter for calculation available. Rigorous description and calculation must come second. It may then be crucially important for some aspects of the task, but it is not always at the heart of the problem. `Structured' <ref> [21] </ref> and `Object-Oriented' [12] methods are concerned with the problem of designing software structures. In most cases their prescriptions, too, are excessively general. Every piece of software can be described| at least, to some extent|by a dataflow diagram. Every program can be built|more or less appropriately|in an object-oriented language.
References-found: 21

