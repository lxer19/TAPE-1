URL: http://www.cs.ucsd.edu/users/mihir/papers/cascade.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/mihir/papers/cascade.html
Root-URL: http://www.cs.ucsd.edu
Email: Email: mihir@cs.ucsd.edu.  Email: canetti@  Email: hugo@  
Title: Pseudorandom Functions Revisited: The Cascade Construction and its Concrete Security function families are a powerful
Author: Mihir Bellare Ran Canetti Hugo Krawczyk 
Address: San Diego, 9500 Gilman Drive, La Jolla, CA 92093.  PO Box 704, Yorktown Heights, New York 10598.  PO Box 704, Yorktown Heights, New York 10598.  
Affiliation: Department of Computer Science Engineering, Mail Code 0114, University of California at  IBM T.J. Watson Research Center,  at MIT. IBM T.J. Watson Research Center,  
Note: Pseudorandom  has been established.  watson.ibm.com. Work done while author was  watson.ibm.com.  
Date: August 7, 1996  
Abstract: An abridged version of this paper appears in Proceedings of the 37th Symposium on Foundations Abstract In this work we investigate new ways of designing pseudorandom function families. The goal is to find constructions that are both efficient and secure, and thus eventually to bring the benefits of pseudorandom functions to practice. The basic building blocks in our design are certain limited versions of pseudorandom function families, called finite-length input pseudorandom function families, for which very efficient realizations exist in practical cryptography. Thus rather than starting from one-way functions, we propose constructions of "full-fledged" pseudorandom function families from these limited ones. In particular we propose the cascade construction, and provide a concrete security analysis which relates the strength of the cascade to that of the underlying finite pseudorandom function family in a precise and quantitative way. of Computer Science, IEEE, 1996.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. Aiello and R. Venkatesan, </author> <title> "Foiling birthday attacks in length doubling transformations," </title> <booktitle> Advances in Cryptology - Eurocrypt 96 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 1070, </volume> <editor> U. Maurer ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The above two ingredients, explicit security parameters and carefully quantified security reductions, form the basis for what we call concrete security analysis. In the case of pseudorandom functions this study was initiated in [5, 4]. Security preserving reductions are the subject of other works as well, e.g. <ref> [10, 12, 1] </ref>.
Reference: [2] <author> ANSI X3.106, </author> <title> "American National Standard for Information Systems | Data Encryption Algorithm | Modes of Operation," </title> <institution> American National Standards Institute, </institution> <year> 1983. </year>
Reference-contexts: Let us now explain the background and motivation for this assumption and approach. The basis for FI-PRFs. There is a body of cryptographic primitives, extensively used in practice, which are more efficient than number theoretic primitives yet seem to possess appreciable cryptographic strengths. Examples of such primitives include DES <ref> [2] </ref>, and the compression functions of SHA [18] and of MD5 [16]. In particular, it might be reasonable to assume that such primitives, or simple enhancements or extensions of them, behave like pseudorandom functions in the first place.
Reference: [3] <author> M. Bellare, R. Canetti and H. Krawczyk, </author> <title> "Keying hash functions for message authentication", </title> <booktitle> Advances in Cryptology - Crypto 96 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 1109, </volume> <editor> N. Koblitz ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: In a companion work, we build message authentication functions from collision-resistant hash functions <ref> [3] </ref>. That work uses a different assumption than the one here. It assumes the underlying compression function to be a secure message authentication function, and the iterations (a la Merkle) be collision resistant. <p> It assumes the underlying compression function to be a secure message authentication function, and the iterations (a la Merkle) be collision resistant. Using our work, one can show that if the compression function is a good pseudorandom function then both of the above assumptions in <ref> [3] </ref> are fulfilled. Finally, we remark that the construction, and our proof methodology, are reminiscent of the [9] construction and proof. They construct VI-PRFs from length doubling pseudorandom bit generators, whereas we use FI-PRFs.
Reference: [4] <author> M. Bellare, R. Gu erin and P. Rogaway, </author> <title> "XOR MACs: New methods for message authentication using finite pseudorandom functions," </title> <booktitle> Advances in Cryptology - Crypto 95 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 963, </volume> <editor> D. Coppersmith ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Such a suggestion was first made in the context of DES [13, 5] and has also been suggested for the compression function of MD5 <ref> [4] </ref>, the last two both in the context of constructing message authentication codes. <p> The above two ingredients, explicit security parameters and carefully quantified security reductions, form the basis for what we call concrete security analysis. In the case of pseudorandom functions this study was initiated in <ref> [5, 4] </ref>. Security preserving reductions are the subject of other works as well, e.g. [10, 12, 1]. <p> That work differs from ours in the practical cryptographic primitive considered (it builds on block ciphers as opposed to compression functions as in our case). FI-PRFs are used to construct message authentication codes in <ref> [4] </ref>. Underlying their constructions is a construction of a randomized family of VI-PRFs. But they don't provide a (deterministic) VI-PRF family.
Reference: [5] <author> M. Bellare, J. Kilian and P. Rogaway, </author> <title> "The security of cipher block chaining." </title> <booktitle> Advances in Cryptology - Crypto 94 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 839, </volume> <editor> Y. Desmedt ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The idea is to move to different building blocks. 1.1 From FI-PRFs to VI-PRFs We assume the existence of fixed-length input pseudorandom function (FI-PRF) families. This is a primitive first introduced by Bellare, Kilian and Rogaway <ref> [5] </ref> in order to model the popular Data Encryption Algorithm. A FI-PRF family is a family of functions which already have the pseudorandom function property. But they have the following serious drawback: unlike VI-PRF 3 functions, the members of this family only take fixed-length inputs. <p> In particular, it might be reasonable to assume that such primitives, or simple enhancements or extensions of them, behave like pseudorandom functions in the first place. Such a suggestion was first made in the context of DES <ref> [13, 5] </ref> and has also been suggested for the compression function of MD5 [4], the last two both in the context of constructing message authentication codes. <p> It is easy to see that if h is collision-resistant then so is H. 1 The notion of security is appropriately quantified to discuss finite objects <ref> [5] </ref>. We discuss this later. 4 Known CRHs (e.g., Rivest's MDi series, SHA) follow this paradigm. These CRH are in wide use. Their strength lies in their efficiency and versatility: in particular, they can be run, in software, faster than most other cryptographic transforms. The basic cascade construction. <p> The above two ingredients, explicit security parameters and carefully quantified security reductions, form the basis for what we call concrete security analysis. In the case of pseudorandom functions this study was initiated in <ref> [5, 4] </ref>. Security preserving reductions are the subject of other works as well, e.g. [10, 12, 1]. <p> In the case of pseudorandom functions this study was initiated in [5, 4]. Security preserving reductions are the subject of other works as well, e.g. [10, 12, 1]. Following <ref> [5] </ref>, we say that a function family G is (t; q; l; *)-secure if a program that runs in time t (more precisely, the running time plus size of the description of the program, in some fixed RAM model of computation, must be bounded by t), given an oracle for a <p> Let us now turn to constructions based on FI-PRFs. The first construction of VI-PRFs from FI-PRFs is in <ref> [5] </ref>. They analyze another popular construction (namely, Cipher Block Chaining, or CBC) and show that it yields a VI-PRF if the underlying functions are FI-PRFs. That work differs from ours in the practical cryptographic primitive considered (it builds on block ciphers as opposed to compression functions as in our case). <p> Comparing efficiency, given the generator, the [9] construction takes m applications of it to process an m-bit message, while given the FI-PRF, we take m=b applications of it. 2 Definitions We define FI-PRF families and their concrete security, slightly extending the definitions of <ref> [5] </ref>. 7 Notation. Denote by jxj the length of string x. Let [m] = f1; : : : ; mg for any integer m 0. <p> Thus collisions happen with probability ( lq 2 2 k ). Inequality (1) follows. We remark that this idea can be extended in a straightforward way to breaking message authentication codes (see <ref> [5] </ref> for definitions) based on the cascade construction of pseudorandom functions. We demonstrate the technique on messages of two blocks: first choose an arbitrary block b 2 B.
Reference: [6] <author> M. Bellare and P. Rogaway, </author> <title> "Entity authentication and key distribution," </title> <booktitle> Advances in Cryptology - Crypto 93 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 773, </volume> <editor> D. Stinson ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 13 </month>
Reference-contexts: But they don't provide a (deterministic) VI-PRF family. If F is a FI-PRF family and H is a collision-resistant function then the family G defined by G a (x) = F a (H (x)) is a VI-PRF family. (This simple observation was made in <ref> [6] </ref>.) A variant is to let H be a collection of almost universal 2 hash functions [7, 19], meaning that for any fixed but distinct x; x 0 , the probability that h (x) = h (x 0 ) is small, when h is drawn randomly from H.
Reference: [7] <author> L. Carter and M. Wegman, </author> <title> "Universal Hash Functions". </title> <editor> J. </editor> <booktitle> of Computer and System Science 18, </booktitle> <year> 1979, </year> <pages> pp. 143-154. </pages>
Reference-contexts: is a FI-PRF family and H is a collision-resistant function then the family G defined by G a (x) = F a (H (x)) is a VI-PRF family. (This simple observation was made in [6].) A variant is to let H be a collection of almost universal 2 hash functions <ref> [7, 19] </ref>, meaning that for any fixed but distinct x; x 0 , the probability that h (x) = h (x 0 ) is small, when h is drawn randomly from H.
Reference: [8] <author> I. Damg -ard, </author> <title> "A design principle for hash functions," </title> <booktitle> Advances in Cryptology - Crypto 89 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 435, </volume> <editor> G. Brassard ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: The construction of CRHs, due to Merkle [14] and Damg-ard <ref> [8] </ref>, is as follows. First design a "compression function" h that takes two inputs of fixed length one of k bits and the other of b bits | and outputs a k-bit string.
Reference: [9] <author> O. Goldreich, S. Goldwasser and S. Micali, </author> <title> "How to construct random functions," </title> <journal> Journal of the ACM, </journal> <volume> Vol. 33, No. 4, </volume> <pages> 210-217, </pages> <year> (1986). </year>
Reference-contexts: 1 Introduction The notion of a pseudorandom function family was proposed by Goldreich, Goldwasser and Micali <ref> [9] </ref>. In such a family, each function is specified by a short, random key, and can be easily computed given the key. <p> These are the kinds of pseudorandom functions we want. So how can one construct (variable-length input) pseudorandom function families? A traditional approach constructs pseudorandom function families from pseudorandom generators <ref> [9] </ref>. Pseudorandom generators are in turn constructed from any one-way function [11]. (Recently a different construction of pseudorandom function families from trapdoor functions was proposed [15].) In these works pseudorandom function families are regarded as a compound primitive, whereas one-way functions (or trapdoor functions) are the building blocks. <p> In the typical cases where * 0 (1) is much smaller than * 0 (q), F rcsc does significantly better than F acsc . 6 1.5 Related work In comparison to constructions based on one-way or trapdoor functions <ref> [11, 9, 15] </ref>, ours are more efficient in practice. Let us now turn to constructions based on FI-PRFs. The first construction of VI-PRFs from FI-PRFs is in [5]. <p> Using our work, one can show that if the compression function is a good pseudorandom function then both of the above assumptions in [3] are fulfilled. Finally, we remark that the construction, and our proof methodology, are reminiscent of the <ref> [9] </ref> construction and proof. They construct VI-PRFs from length doubling pseudorandom bit generators, whereas we use FI-PRFs. However the basic cascade construction (which, as we have said, is a keyed version of Merkle's construction) may be viewed as a generalization of the binary tree construction of [9]. <p> are reminiscent of the <ref> [9] </ref> construction and proof. They construct VI-PRFs from length doubling pseudorandom bit generators, whereas we use FI-PRFs. However the basic cascade construction (which, as we have said, is a keyed version of Merkle's construction) may be viewed as a generalization of the binary tree construction of [9]. In our case the tree has arity 2 b . (Recall b is the input block-size. The tree is as follows. The root stores the original key a. <p> Such a family can be seen as a length doubling pseudorandom bit generator defined by G (y) = F y (0) : F y (1).) Our proof is influenced by that of <ref> [9] </ref>, but new features emerge because we are dealing with pseudorandom functions, not generators, making the reducibility question a different one. Comparing efficiency, given the generator, the [9] construction takes m applications of it to process an m-bit message, while given the FI-PRF, we take m=b applications of it. 2 Definitions <p> doubling pseudorandom bit generator defined by G (y) = F y (0) : F y (1).) Our proof is influenced by that of <ref> [9] </ref>, but new features emerge because we are dealing with pseudorandom functions, not generators, making the reducibility question a different one. Comparing efficiency, given the generator, the [9] construction takes m applications of it to process an m-bit message, while given the FI-PRF, we take m=b applications of it. 2 Definitions We define FI-PRF families and their concrete security, slightly extending the definitions of [5]. 7 Notation. Denote by jxj the length of string x. <p> Pseudorandomness of function families. Intuitively, a finite function family F is pseudorandom if the input-output behavior of a random member of the family is indistinguishable from the behavior of a random function of the same domain and range. This is formalized via the notion of statistical tests, or distinguishes <ref> [9] </ref>. A distinguisher is an oracle algorithm; it is given a random member either of a family F 1 or of a family F 2 , and tries to decide which is the case.
Reference: [10] <author> O. Goldreich, R. Impagliazzo, L. Levin, R. Venkatesan, and R. Zuckerman, D., </author> <title> "Security Preserving Amplification of Hardness." </title> <booktitle> Proceedings of the 31st Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1990. </year>
Reference-contexts: The above two ingredients, explicit security parameters and carefully quantified security reductions, form the basis for what we call concrete security analysis. In the case of pseudorandom functions this study was initiated in [5, 4]. Security preserving reductions are the subject of other works as well, e.g. <ref> [10, 12, 1] </ref>.
Reference: [11] <author> J. H -astad, R. Impagliazzo, L. Levin and M. Luby, </author> <title> "Construction of a pseudo-random generator from any one-way function," </title> <type> Manuscript. </type> <note> Earlier versions in STOC 89 and STOC 90. </note>
Reference-contexts: These are the kinds of pseudorandom functions we want. So how can one construct (variable-length input) pseudorandom function families? A traditional approach constructs pseudorandom function families from pseudorandom generators [9]. Pseudorandom generators are in turn constructed from any one-way function <ref> [11] </ref>. (Recently a different construction of pseudorandom function families from trapdoor functions was proposed [15].) In these works pseudorandom function families are regarded as a compound primitive, whereas one-way functions (or trapdoor functions) are the building blocks. <p> In the typical cases where * 0 (1) is much smaller than * 0 (q), F rcsc does significantly better than F acsc . 6 1.5 Related work In comparison to constructions based on one-way or trapdoor functions <ref> [11, 9, 15] </ref>, ours are more efficient in practice. Let us now turn to constructions based on FI-PRFs. The first construction of VI-PRFs from FI-PRFs is in [5].
Reference: [12] <author> A. Herzberg and M. Luby, </author> <title> "Public Randomness in Cryptography." </title> <booktitle> Advances in Cryptology - Crypto 92 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 740, </volume> <editor> E. Brickell ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The above two ingredients, explicit security parameters and carefully quantified security reductions, form the basis for what we call concrete security analysis. In the case of pseudorandom functions this study was initiated in [5, 4]. Security preserving reductions are the subject of other works as well, e.g. <ref> [10, 12, 1] </ref>.
Reference: [13] <author> M. Luby and C. Rackoff, </author> <title> "How to construct pseudorandom permutations from pseudorandom functions," </title> <journal> SIAM J. Computation, </journal> <volume> Vol. 17, No. 2, </volume> <month> April </month> <year> 1988. </year>
Reference-contexts: In particular, it might be reasonable to assume that such primitives, or simple enhancements or extensions of them, behave like pseudorandom functions in the first place. Such a suggestion was first made in the context of DES <ref> [13, 5] </ref> and has also been suggested for the compression function of MD5 [4], the last two both in the context of constructing message authentication codes.
Reference: [14] <author> R. Merkle, </author> <title> "One way hash functions and DES," </title> <booktitle> Advances in Cryptology - Crypto 89 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 435, </volume> <editor> G. Brassard ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <title> (Based on unpublished paper from 1979 and his Ph. </title> <type> D thesis, </type> <institution> Stanford, </institution> <year> 1979). </year>
Reference-contexts: The construction of CRHs, due to Merkle <ref> [14] </ref> and Damg-ard [8], is as follows. First design a "compression function" h that takes two inputs of fixed length one of k bits and the other of b bits | and outputs a k-bit string.
Reference: [15] <author> M. Naor and O. Reingold, </author> <title> "Synthesizers and their application to the parallel construction of pseudo-random functions," </title> <booktitle> Proceedings of the 36th Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1995. </year>
Reference-contexts: So how can one construct (variable-length input) pseudorandom function families? A traditional approach constructs pseudorandom function families from pseudorandom generators [9]. Pseudorandom generators are in turn constructed from any one-way function [11]. (Recently a different construction of pseudorandom function families from trapdoor functions was proposed <ref> [15] </ref>.) In these works pseudorandom function families are regarded as a compound primitive, whereas one-way functions (or trapdoor functions) are the building blocks. In all cases, the suggested candidates for the building blocks come from number-theoretic problems or combinatorial problems. <p> In the typical cases where * 0 (1) is much smaller than * 0 (q), F rcsc does significantly better than F acsc . 6 1.5 Related work In comparison to constructions based on one-way or trapdoor functions <ref> [11, 9, 15] </ref>, ours are more efficient in practice. Let us now turn to constructions based on FI-PRFs. The first construction of VI-PRFs from FI-PRFs is in [5].
Reference: [PV] <author> B. Preneel and P. van Oorschot, </author> <title> "MD-x MAC and building fast MACs from hash functions," </title> <booktitle> Advances in Cryptology - Crypto 95 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 963, </volume> <editor> D. Coppersmith ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: If indeed MAC (a i ) =MAC (a j ) then also MAC (a j c) = m. (We note that this attack applies to a variety of well known MAC schemes, including DES-CBC-MAC. A similar attack was independently reported by <ref> [PV] </ref>.) Acknowledgments We thank Moni Naor for helpful comments.
Reference: [16] <author> R. Rivest, </author> <title> "The MD5 message-digest algorithm," IETF Network Working Group, </title> <type> RFC 1321, </type> <month> April </month> <year> 1992. </year>
Reference-contexts: The basis for FI-PRFs. There is a body of cryptographic primitives, extensively used in practice, which are more efficient than number theoretic primitives yet seem to possess appreciable cryptographic strengths. Examples of such primitives include DES [2], and the compression functions of SHA [18] and of MD5 <ref> [16] </ref>. In particular, it might be reasonable to assume that such primitives, or simple enhancements or extensions of them, behave like pseudorandom functions in the first place.
Reference: [17] <author> P. Rogaway and D. Coppersmith, </author> <title> "A software optimized encryption algorithm," </title> <booktitle> Workshop on software encryption, </booktitle> <address> Cambridge, </address> <year> 1993. </year>
Reference: [18] <author> FIPS 180, </author> <title> "Secure Hash Standard", Federal Information Processing Standard (FIPS), </title> <type> Publication 180, </type> <institution> National Institute of Standards and Technology, US Department of Commerce, </institution> <address> Washington D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The basis for FI-PRFs. There is a body of cryptographic primitives, extensively used in practice, which are more efficient than number theoretic primitives yet seem to possess appreciable cryptographic strengths. Examples of such primitives include DES [2], and the compression functions of SHA <ref> [18] </ref> and of MD5 [16]. In particular, it might be reasonable to assume that such primitives, or simple enhancements or extensions of them, behave like pseudorandom functions in the first place.
Reference: [19] <author> M. Wegman and L. Carter, </author> <title> "New Hash Functions and Their Use in Authentication and Set Equality", </title> <journal> JCSS Vol. </journal> <volume> 22, </volume> <year> 1981, </year> <pages> pp. 265-279. 14 </pages>
Reference-contexts: is a FI-PRF family and H is a collision-resistant function then the family G defined by G a (x) = F a (H (x)) is a VI-PRF family. (This simple observation was made in [6].) A variant is to let H be a collection of almost universal 2 hash functions <ref> [7, 19] </ref>, meaning that for any fixed but distinct x; x 0 , the probability that h (x) = h (x 0 ) is small, when h is drawn randomly from H.
References-found: 20

