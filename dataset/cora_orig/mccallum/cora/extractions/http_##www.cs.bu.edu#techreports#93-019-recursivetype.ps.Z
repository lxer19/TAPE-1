URL: http://www.cs.bu.edu/techreports/93-019-recursivetype.ps.Z
Refering-URL: http://cs-www.bu.edu/techreports/Home.html
Root-URL: 
Email: (jahama@cs.bu.edu)  (kfoury@cs.bu.edu)  
Title: Type Reconstruction in the Presence of Polymorphic Recursion and Recursive Types  
Author: Said Jahama A.J. Kfoury 
Affiliation: Boston University  Boston University  
Abstract: December 20, 1993 Technical Report: bu-cs #93-019 Abstract We establish the equivalence of type reconstruction with polymorphic recursion and recursive types is equivalent to regular semi-unification which proves the undecidability of the corresponding type reconstruction problem. We also establish the equivalence of type reconstruction with polymorphic recursion and positive recursive types to a special case of regular semi-unification which we call positive regular semi-unification. The decidability of positive regular semi unification is an open problem.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, 93. </pages>
Reference-contexts: The importance of recursive types and positive recursive types in programming language theory has been recognized for many years; a sample of recent results, restricted to aspects of type-checking and type-reconstruction, can be found in <ref> [1, 3, 17] </ref>. The report is organized as follows. We first give a precise definition of recursive and positive recursive types (Section 2) and introduce the systems ML+fix+) and ML+fix+pos- (Section 3). We call the two system S and S + for short.
Reference: [2] <author> Courcelle B. </author> <title> Fundemental properties of infinite trees. </title> <journal> Theoretical Com--puter Science, </journal> <volume> 25 </volume> <pages> 48-80, </pages> <year> 1983. </year>
Reference-contexts: We refer the reader to [3] for an exact definition of ( ) fl . It is also true that every type in T reg has a notation (not unique) in T . We refer the reader to <ref> [2] </ref> for the proof of this fact, the reference also contains a detailed discussion of infinite and regular types. This means that, whenever appropriate, we can use properties of T reg to prove results for T and vice versa.
Reference: [3] <author> F. Cardone and M. Coppo. </author> <title> Type inference with recursive types: Syntax and semantics. </title> <journal> Information and Computation, </journal> <volume> 92 </volume> <pages> 48-80, </pages> <year> 1991. </year>
Reference-contexts: The importance of recursive types and positive recursive types in programming language theory has been recognized for many years; a sample of recent results, restricted to aspects of type-checking and type-reconstruction, can be found in <ref> [1, 3, 17] </ref>. The report is organized as follows. We first give a precise definition of recursive and positive recursive types (Section 2) and introduce the systems ML+fix+) and ML+fix+pos- (Section 3). We call the two system S and S + for short. <p> Every recursive type represents an underlying regular type obtained by unfolding infinitely many times. More formally there is a map ( ) fl : T ! T reg . We refer the reader to <ref> [3] </ref> for an exact definition of ( ) fl . It is also true that every type in T reg has a notation (not unique) in T . <p> There are two standard notions of equivalence of recursive types, referred to as strong () and weak (~) equivalence. t iff fl = t fl , i.e. they represent the same regular type. For ~ we use the definition given in <ref> [3] </ref>: Definition 3 Let ~ T fi T be the smallest equivalence relation satisfying 1. ff: ~ [ff := ff:]. 3. ~ 0 ) ff: ~ ff: 0 : Observe that ~ t implies t . <p> However, the converse is false, for example: ff:ff ! ff ff:((ff ! ff) ! ff) while it is not the case that ff:ff ! ff ~ ff:((ff ! ff) ! ff). Observe also that the relations and ~ are both decidable <ref> [3] </ref>. 3 Systems S and S + In this thesis we consider a simple language consisting of -terms augmented with a polymorphic fix constructor and a set of constants. Unless otherwise noted, we refer to object constants by a; b; c; and object variables by x; y; z; . <p> Every regular (resp. positive regular) substitution S can be extended in a natural way to a function S : T ! T (resp., S : T ;+ ! T ;+ ) <ref> [3] </ref>. An instance of semi-unification is a finite set of inequalities: = f 1 t 1 ; : : : ; n t n g where t i ; u i 2 T fin .
Reference: [4] <author> J. Dorre and W. </author> <title> Rounds. On subsumption and semiunification in feature algebras. </title> <booktitle> In Proceedings of IEEE 5th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 300 - 310, </pages> <year> 1990. </year>
Reference-contexts: The let-in constructor is the only source of polymorphism in 1 This is not to diminish the importance of semi-unification for other parts of theoretical computer science. See for example <ref> [4, 9, 20] </ref> as well as the Introduction in [13]for a survey of other application areas. <p> The proof of this result is in <ref> [4] </ref>. This result is further restricted to semi-unification on binary trees in [7] which leads to the following: Theorem 12 Type Reconstruction in system S is undecidable. Proof: The proof is directly obtained by the undecidability of regular semi-unification [4] and the equivalence of regular semi-unification to regular semi-unification on binary <p> The proof of this result is in <ref> [4] </ref>. This result is further restricted to semi-unification on binary trees in [7] which leads to the following: Theorem 12 Type Reconstruction in system S is undecidable. Proof: The proof is directly obtained by the undecidability of regular semi-unification [4] and the equivalence of regular semi-unification to regular semi-unification on binary trees [7]. We have to leave open the decidability of Type Reconstruction in system S + and the decidability of PRSUP.
Reference: [5] <author> P. Giannini and S. Ronchi Della Rocca. </author> <title> Characterization of typings in polymorphic type discipline. </title> <booktitle> In Proceedings of IEEE 3rd Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 61 - 71, </pages> <year> 1988. </year>
Reference-contexts: In this subsection, we give a syntax-oriented version of S and S + . This simplifies the proofs in this report. This sort of simplification is a standard step in many papers dealing with polymorphic recursion; see <ref> [5, 6, 14, 18] </ref>. Let ; t 2 T and ~ff = ff 1 ff n for some n 0.
Reference: [6] <author> F. Henglein. </author> <title> Type inference with polymorphic recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 254-290, 93. </pages>
Reference-contexts: This equivalence generalizes the well-known relationship between standard (first-order) unification and typability in the simply-typed -calculus. For a sample of results in this area, the reader is referred to <ref> [6, 15, 12, 14] </ref>. 1 In this report, we extend the theory of semi-unification to deal with polymorphic recursion and recursive types simultaneously. Polymorphic recursion is introduced by a fixpoint constructor, fix, at the object level; recursive types are introduced by a fixpoint constructor, , at the type level. <p> Mycroft extended the ML type system with this feature, proved the principal-type property of the resulting system, but left open the corresponding type-reconstruction problem [19]. Subsequently, ML+fix was studied extensively by Henglein <ref> [6] </ref>, Leiss [15], and Kfoury, Tiuryn and Urzyczyn [14], who finally proved the type-reconstruction problem to be undecidable [13]. <p> In this subsection, we give a syntax-oriented version of S and S + . This simplifies the proofs in this report. This sort of simplification is a standard step in many papers dealing with polymorphic recursion; see <ref> [5, 6, 14, 18] </ref>. Let ; t 2 T and ~ff = ff 1 ff n for some n 0. <p> All derived types in T ;+ . 10 The main result of this subsection is Lemma 5. It is similar to Lemma 5 in [14] and Lemma 5 in <ref> [6] </ref>. The proof of this lemma is adopted from the Proof of Lemma 5 in [6]. <p> All derived types in T ;+ . 10 The main result of this subsection is Lemma 5. It is similar to Lemma 5 in [14] and Lemma 5 in <ref> [6] </ref>. The proof of this lemma is adopted from the Proof of Lemma 5 in [6].
Reference: [7] <author> S. Jahama and A.J. Kfoury. </author> <title> A general theory of semi-uniffication. </title> <type> Technical Report 93-018, </type> <institution> Boston University, Department of Computer Science, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: The proof of this result is in [4]. This result is further restricted to semi-unification on binary trees in <ref> [7] </ref> which leads to the following: Theorem 12 Type Reconstruction in system S is undecidable. Proof: The proof is directly obtained by the undecidability of regular semi-unification [4] and the equivalence of regular semi-unification to regular semi-unification on binary trees [7]. <p> result is further restricted to semi-unification on binary trees in <ref> [7] </ref> which leads to the following: Theorem 12 Type Reconstruction in system S is undecidable. Proof: The proof is directly obtained by the undecidability of regular semi-unification [4] and the equivalence of regular semi-unification to regular semi-unification on binary trees [7]. We have to leave open the decidability of Type Reconstruction in system S + and the decidability of PRSUP.
Reference: [8] <author> P. Kanellakis and J.C. Mitchell. </author> <title> Polymorphic unification and ml typing. </title> <booktitle> In Proceedings of 16th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 105 - 115, </pages> <year> 1989. </year>
Reference-contexts: Nevertheless, the greatest successes of semi-unification theory are undoubtedly in the area of polymorphic type systems. 2 standard ML, and its addition to the simply-typed -calculus turns the type--reconstruction from PTIME-complete to DEXPTIME-complete <ref> [8, 16, 14] </ref>. However, as shown in [14]), if polymorphic recursion is also added (via the fix constructor), which turns type-reconstruction into an undecidable problem, then we can omit let-in.
Reference: [9] <author> D. Kapur, D. Musser, P. Narendran, and J. Stillman. </author> <title> Semi-unification. </title> <editor> In Nori and Kumar, editors, </editor> <booktitle> Proceedings of 8th Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <volume> LNCS 338, </volume> <pages> pages 435 - 454. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The let-in constructor is the only source of polymorphism in 1 This is not to diminish the importance of semi-unification for other parts of theoretical computer science. See for example <ref> [4, 9, 20] </ref> as well as the Introduction in [13]for a survey of other application areas.
Reference: [10] <author> A.J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> The hierarchy of finitely typed functional programs. </title> <booktitle> In Proceedings of IEEE 2nd Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 225 - 235, </pages> <year> 1987. </year>
Reference: [11] <author> A.J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> On the computational power of universally polymorphic recursion. </title> <booktitle> In Proceedings of IEEE 3rd Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 72 - 81, </pages> <year> 1988. </year>
Reference: [12] <author> A.J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> An analysis of ml typability. </title> <editor> In Arnold, editor, </editor> <booktitle> 15th Colloquium on Trees in Algebra and Programming, CAAP 90, </booktitle> <volume> LNCS 431, </volume> <pages> pages 206 - 220. </pages> <publisher> Springer Verlag, </publisher> <year> 1990. </year> <month> 24 </month>
Reference-contexts: This equivalence generalizes the well-known relationship between standard (first-order) unification and typability in the simply-typed -calculus. For a sample of results in this area, the reader is referred to <ref> [6, 15, 12, 14] </ref>. 1 In this report, we extend the theory of semi-unification to deal with polymorphic recursion and recursive types simultaneously. Polymorphic recursion is introduced by a fixpoint constructor, fix, at the object level; recursive types are introduced by a fixpoint constructor, , at the type level.
Reference: [13] <author> A.J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> The undecidability of the semi-unification problem. </title> <booktitle> In Proceedings of the 22nd Annual ACM Symposium on Theory of Computing, Baltimore, </booktitle> <pages> pages 468 - 476, </pages> <year> 1990. </year>
Reference-contexts: Subsequently, ML+fix was studied extensively by Henglein [6], Leiss [15], and Kfoury, Tiuryn and Urzyczyn [14], who finally proved the type-reconstruction problem to be undecidable <ref> [13] </ref>. The importance of recursive types and positive recursive types in programming language theory has been recognized for many years; a sample of recent results, restricted to aspects of type-checking and type-reconstruction, can be found in [1, 3, 17]. The report is organized as follows.
Reference: [14] <author> A.J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> Type-reconstruction in the presence of polymorphic recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 290-311, 93. </pages>
Reference-contexts: This equivalence generalizes the well-known relationship between standard (first-order) unification and typability in the simply-typed -calculus. For a sample of results in this area, the reader is referred to <ref> [6, 15, 12, 14] </ref>. 1 In this report, we extend the theory of semi-unification to deal with polymorphic recursion and recursive types simultaneously. Polymorphic recursion is introduced by a fixpoint constructor, fix, at the object level; recursive types are introduced by a fixpoint constructor, , at the type level. <p> Mycroft extended the ML type system with this feature, proved the principal-type property of the resulting system, but left open the corresponding type-reconstruction problem [19]. Subsequently, ML+fix was studied extensively by Henglein [6], Leiss [15], and Kfoury, Tiuryn and Urzyczyn <ref> [14] </ref>, who finally proved the type-reconstruction problem to be undecidable [13]. The importance of recursive types and positive recursive types in programming language theory has been recognized for many years; a sample of recent results, restricted to aspects of type-checking and type-reconstruction, can be found in [1, 3, 17]. <p> Nevertheless, the greatest successes of semi-unification theory are undoubtedly in the area of polymorphic type systems. 2 standard ML, and its addition to the simply-typed -calculus turns the type--reconstruction from PTIME-complete to DEXPTIME-complete <ref> [8, 16, 14] </ref>. However, as shown in [14]), if polymorphic recursion is also added (via the fix constructor), which turns type-reconstruction into an undecidable problem, then we can omit let-in. <p> Nevertheless, the greatest successes of semi-unification theory are undoubtedly in the area of polymorphic type systems. 2 standard ML, and its addition to the simply-typed -calculus turns the type--reconstruction from PTIME-complete to DEXPTIME-complete [8, 16, 14]. However, as shown in <ref> [14] </ref>), if polymorphic recursion is also added (via the fix constructor), which turns type-reconstruction into an undecidable problem, then we can omit let-in. We then define two forms of the semi-unification problem (Section 4), denoted RSUP (for regular SUP) and PRSUP (for positive-regular SUP). <p> In this subsection, we give a syntax-oriented version of S and S + . This simplifies the proofs in this report. This sort of simplification is a standard step in many papers dealing with polymorphic recursion; see <ref> [5, 6, 14, 18] </ref>. Let ; t 2 T and ~ff = ff 1 ff n for some n 0. <p> All derived types in T ;+ . 10 The main result of this subsection is Lemma 5. It is similar to Lemma 5 in <ref> [14] </ref> and Lemma 5 in [6]. The proof of this lemma is adopted from the Proof of Lemma 5 in [6]. <p> M is typable in S iff M has a regular solution. 2. M is typable in S 0 iff M has a positive regular solution. 13 The construction given here is very similar to the construction given in Section 4.2 <ref> [14] </ref>. The proofs here differ slightly (but still the same style) because the syntax-oriented version given here does not have the GEN rule. Also, constants are added here. We view our construction as an extension of the construction given in [14] and we use most of the definitions related to it. <p> is very similar to the construction given in Section 4.2 <ref> [14] </ref>. The proofs here differ slightly (but still the same style) because the syntax-oriented version given here does not have the GEN rule. Also, constants are added here. We view our construction as an extension of the construction given in [14] and we use most of the definitions related to it. <p> Instead of n and t n , we also write M and t M . The only difference between M here and in <ref> [14] </ref> is that we add constants here and we do not allow polymorphic abstraction. <p> For all fi i occurring in M , the bound variables of S (fi i ) are precisely the set: S The following lemma is an extension of Lemma 12 in <ref> [14] </ref>. Lemma 8 Let M be a term. Then: 1. <p> For any S + : V ! T 8 ;+ , S + is a positive regular solution of M (in the sense of semi-unification) iff S + is a positive regular solution of M in the sense definition 7). Proof: This reproduces the proof of Lemma 13 in <ref> [14] </ref> with the necessary terminological changes. Consider the inequality (T; U ) introduced in part 1 of the definition of M . <p> M y j g iff S is a regular (resp. positive regular) solution of f (T ij ; U ij )g in the sense of semi-unification. 6 From RSUP to S and from PRSUP to S + In this section, we use the same construction given in Section 4.3 of <ref> [14] </ref> and we reproduce most of the text of Section 4.3 with the necessary modifications. We begin with a technical trick which is used to force an object variable to be assigned a particular finite type (or a substitution instance of it). <p> The following lemma, which is an extension of Lemma 14 in <ref> [14] </ref>, explains the crucial property of the term hz : t i. Lemma 10 Let t 2 T fin be an arbitrary finite type such that F V (t ) fff 1 ; : : : ; ff ` g: 1. <p> M is typable in S iff has a regular solution. 2. M is typable in S + iff has a positive regular solution. Proof: Here we just show the proof of Part 1 of the lemma. The proof is just a reproduction of the proof of Lemma 13 in <ref> [14] </ref> with the necessary modifications. For the left to right implication, suppose that M is typable.
Reference: [15] <author> H. Leiss. </author> <title> Semi-unification and type inference for polymorphic recursion. </title> <institution> Research Report INF 2-ASE-5-89, Siemens, Munchen, </institution> <year> 1989. </year>
Reference-contexts: This equivalence generalizes the well-known relationship between standard (first-order) unification and typability in the simply-typed -calculus. For a sample of results in this area, the reader is referred to <ref> [6, 15, 12, 14] </ref>. 1 In this report, we extend the theory of semi-unification to deal with polymorphic recursion and recursive types simultaneously. Polymorphic recursion is introduced by a fixpoint constructor, fix, at the object level; recursive types are introduced by a fixpoint constructor, , at the type level. <p> Mycroft extended the ML type system with this feature, proved the principal-type property of the resulting system, but left open the corresponding type-reconstruction problem [19]. Subsequently, ML+fix was studied extensively by Henglein [6], Leiss <ref> [15] </ref>, and Kfoury, Tiuryn and Urzyczyn [14], who finally proved the type-reconstruction problem to be undecidable [13].
Reference: [16] <author> H.G. Mairson. </author> <title> Deciding ml typability is complete for deterministic exponential time. </title> <booktitle> In Proceedings of 17th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 382 - 401, </pages> <year> 1990. </year>
Reference-contexts: Nevertheless, the greatest successes of semi-unification theory are undoubtedly in the area of polymorphic type systems. 2 standard ML, and its addition to the simply-typed -calculus turns the type--reconstruction from PTIME-complete to DEXPTIME-complete <ref> [8, 16, 14] </ref>. However, as shown in [14]), if polymorphic recursion is also added (via the fix constructor), which turns type-reconstruction into an undecidable problem, then we can omit let-in.
Reference: [17] <author> N.P. Mendler. </author> <title> Inductive types and type constraints in the second-order lambda calculus. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 159-172, </pages> <year> 1991. </year>
Reference-contexts: The importance of recursive types and positive recursive types in programming language theory has been recognized for many years; a sample of recent results, restricted to aspects of type-checking and type-reconstruction, can be found in <ref> [1, 3, 17] </ref>. The report is organized as follows. We first give a precise definition of recursive and positive recursive types (Section 2) and introduce the systems ML+fix+) and ML+fix+pos- (Section 3). We call the two system S and S + for short.
Reference: [18] <author> J.C. Mitchell. </author> <title> Polymorphic type inference and containment. </title> <journal> Information and Computation, </journal> <volume> 76(2/3):211 - 249, </volume> <year> 1988. </year>
Reference-contexts: In this subsection, we give a syntax-oriented version of S and S + . This simplifies the proofs in this report. This sort of simplification is a standard step in many papers dealing with polymorphic recursion; see <ref> [5, 6, 14, 18] </ref>. Let ; t 2 T and ~ff = ff 1 ff n for some n 0.
Reference: [19] <author> A. Mycroft. </author> <title> Polymorphic type schemes and recursive definitions, </title> <note> lncs 167. </note> <editor> In Paul and Robinet, editors, </editor> <booktitle> International Symposium on Programming, </booktitle> <pages> pages 217 - 228. </pages> <publisher> Springer Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Polymorphic recursion allows the definition of a function F to contain recursive calls to F at different types, all instances of the same generic type. Mycroft extended the ML type system with this feature, proved the principal-type property of the resulting system, but left open the corresponding type-reconstruction problem <ref> [19] </ref>. Subsequently, ML+fix was studied extensively by Henglein [6], Leiss [15], and Kfoury, Tiuryn and Urzyczyn [14], who finally proved the type-reconstruction problem to be undecidable [13].
Reference: [20] <author> P. Pudlak. </author> <title> On a unification problem related to kreisel's conjecture. </title> <journal> Com-mentationes Mathematicae Universitatis Carolinae, Prague, Czechoslo-vakia, </journal> <volume> 29(3):551 - 556, </volume> <year> 1988. </year> <month> 25 </month>
Reference-contexts: The let-in constructor is the only source of polymorphism in 1 This is not to diminish the importance of semi-unification for other parts of theoretical computer science. See for example <ref> [4, 9, 20] </ref> as well as the Introduction in [13]for a survey of other application areas.
References-found: 20

