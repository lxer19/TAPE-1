URL: http://www.cs.berkeley.edu/~aiken/ftp/ppcp94.ps
Refering-URL: http://www.cs.berkeley.edu/~aiken/pubs.html
Root-URL: 
Email: aiken@cs.berkeley.edu  
Title: Future Directions  
Author: Alexander Aiken 
Address: Berkeley, CA 94720-1776  
Affiliation: Computer Science Division University of California, Berkeley  
Abstract: Set Constraints: Results, Applications and Abstract. Set constraints are a natural formalism for many problems that arise in program analysis. This paper provides a brief introduction to set constraints: what set constraints are, why they are interesting, the current state of the art, open problems, applications and implementa tions.
Abstract-found: 1
Intro-found: 1
Reference: [AKVW93] <author> A. Aiken, D. Kozen, M. Vardi, and E. Wimmers. </author> <title> The complexity of set constraints. </title> <booktitle> In Computer Science Logic '93, </booktitle> <address> Swansea, Wales, </address> <month> September </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: A system of set constraints is satisfiable if it has at least one solution. The following result was proven first in [AW92]. Simpler proofs have been discovered since <ref> [BGW93, AKVW93] </ref>. Theorem 1. It is decidable whether a system of set constraints is satisfiable. Furthermore, all solutions can be finitely presented. It is important to note that the definition of set constraints used here does damage to history. <p> Four proofs of decidability of the satisfiability problem for the basic language are known <ref> [AW92, GTT92, BGW93, AKVW93] </ref>. Remarkably, each proof is based on completely different techniques. <p> Set constraint resolution algorithms can be computationally expensive in general. For the basic problem, deciding satisfiability is NEXPTIME-complete [BGW93] and even if the language is restricted to the set operations over constants satisfiability remains NP-complete <ref> [AKVW93] </ref>.
Reference: [AKW93] <author> A. Aiken, D. Kozen, and E. Wimmers. </author> <title> Decidability of systems of set constraints with negative constraints. </title> <type> Research Report RJ 9421, </type> <institution> IBM, </institution> <year> 1993. </year>
Reference-contexts: of a system of positive constraints: : i _ X i 6 Y i Since conjunctions of positive constraints correspond to an existential property (i.e., is any assignment a solution of the constraints) disjunctions of negative constraints can express universal properties (i.e., is every assignment a solution of the constraints) <ref> [AKW93, GTT93] </ref>. Four proofs of decidability of the satisfiability problem for the basic language are known [AW92, GTT92, BGW93, AKVW93]. Remarkably, each proof is based on completely different techniques. <p> Three independent proofs of the decidability of set constraints with negative constraints have been discovered <ref> [AKW93, GTT93, CP94a] </ref>; currently there is only one reported proof of the decidability of set constraints with projections [CP94b]. These are decision procedures only, however, and do not characterize the solution sets.
Reference: [AL94] <author> A. Aiken and T.K. Lakshman. </author> <title> Directional type checking of logic programs. </title> <booktitle> In Proceedings of the 1st International Static Analysis Symposium, </booktitle> <month> Septem-ber </month> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: Recently, there has been a great deal of interest in program analysis algorithms based on solving systems of set constraints, including analyses for functional languages [AWL94, Hei94, AW93, AM91, JM79, MR85, Rey69], logic programming languages <ref> [AL94, HJ92, HJ90b, Mis84] </ref>, and imperative languages [HJ91]. In these algorithms, sets of terms describe the possible values computed by a program. Set constraints are generated from the program text; solving the constraints yields some useful information about the program (e.g., for type-checking or optimization).
Reference: [AM91] <author> A. Aiken and B. Murphy. </author> <title> Static type inference in a dynamically typed language. </title> <booktitle> In Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 279-290, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Recently, there has been a great deal of interest in program analysis algorithms based on solving systems of set constraints, including analyses for functional languages <ref> [AWL94, Hei94, AW93, AM91, JM79, MR85, Rey69] </ref>, logic programming languages [AL94, HJ92, HJ90b, Mis84], and imperative languages [HJ91]. In these algorithms, sets of terms describe the possible values computed by a program.
Reference: [AW92] <author> A. Aiken and E. Wimmers. </author> <title> Solving systems of set constraints. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 329-340, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: A solution of a system of set constraints is an assignment such that V i (X i ) (Y i ) is true. A system of set constraints is satisfiable if it has at least one solution. The following result was proven first in <ref> [AW92] </ref>. Simpler proofs have been discovered since [BGW93, AKVW93]. Theorem 1. It is decidable whether a system of set constraints is satisfiable. Furthermore, all solutions can be finitely presented. It is important to note that the definition of set constraints used here does damage to history. <p> Four proofs of decidability of the satisfiability problem for the basic language are known <ref> [AW92, GTT92, BGW93, AKVW93] </ref>. Remarkably, each proof is based on completely different techniques.
Reference: [AW93] <author> A. Aiken and E. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Recently, there has been a great deal of interest in program analysis algorithms based on solving systems of set constraints, including analyses for functional languages <ref> [AWL94, Hei94, AW93, AM91, JM79, MR85, Rey69] </ref>, logic programming languages [AL94, HJ92, HJ90b, Mis84], and imperative languages [HJ91]. In these algorithms, sets of terms describe the possible values computed by a program. <p> In an appropriate domain, the meaning of X ! Y is X ! Y = ff jx 2 X ) f (x) 2 Y g Function spaces are used primarily in the analysis of functional programming languages <ref> [AW93, AWL94] </ref>. Finally, negative constraints are strict containments X 6 Y . <p> Status of set constraint problems. Set constraints extended with function spaces have been used to develop very expressive subtype inference systems for functional languages. Currently, constraint solving algorithms for a fairly general class of set constraints with function types are known <ref> [AW93, AWL94] </ref>. Damm has proven the surprising result that satisfiability of set constraints with function spaces is decidable [Dam94]. Set constraint resolution algorithms can be computationally expensive in general. <p> Thatte introduced partial types [Tha88], the type inference problem for which, while substantially different from earlier systems, is also reducible a set constraint resolution problem. The most recent work in this area is due to Wimmers and the author <ref> [AW93, AWL94] </ref>, who provide a type inference system that generalizes the results in [MR85, Tha88]. An implementation of this last system is publicly available (see Section 6). A natural application area for set constraints is the analysis of logic programs.
Reference: [AWL94] <author> A. Aiken, E. Wimmers, </author> <title> and T.K. Lakshman. Soft typing with conditional types. </title> <booktitle> In Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Recently, there has been a great deal of interest in program analysis algorithms based on solving systems of set constraints, including analyses for functional languages <ref> [AWL94, Hei94, AW93, AM91, JM79, MR85, Rey69] </ref>, logic programming languages [AL94, HJ92, HJ90b, Mis84], and imperative languages [HJ91]. In these algorithms, sets of terms describe the possible values computed by a program. <p> In an appropriate domain, the meaning of X ! Y is X ! Y = ff jx 2 X ) f (x) 2 Y g Function spaces are used primarily in the analysis of functional programming languages <ref> [AW93, AWL94] </ref>. Finally, negative constraints are strict containments X 6 Y . <p> Status of set constraint problems. Set constraints extended with function spaces have been used to develop very expressive subtype inference systems for functional languages. Currently, constraint solving algorithms for a fairly general class of set constraints with function types are known <ref> [AW93, AWL94] </ref>. Damm has proven the surprising result that satisfiability of set constraints with function spaces is decidable [Dam94]. Set constraint resolution algorithms can be computationally expensive in general. <p> Thatte introduced partial types [Tha88], the type inference problem for which, while substantially different from earlier systems, is also reducible a set constraint resolution problem. The most recent work in this area is due to Wimmers and the author <ref> [AW93, AWL94] </ref>, who provide a type inference system that generalizes the results in [MR85, Tha88]. An implementation of this last system is publicly available (see Section 6). A natural application area for set constraints is the analysis of logic programs. <p> The latter implementation is available by anonymous ftp and comes with a type inference system for a functional language based on solving systems of set constraints <ref> [AWL94] </ref>. To get this system, retrieve pub/personal/aiken/Illyria.tar.Z from the machine s2k-ftp.cs.berkeley.edu.
Reference: [BGW93] <author> L. Bachmair, H. Ganzinger, and U. Waldmann. </author> <title> Set constraints are the monadic class. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 75-83, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: A system of set constraints is satisfiable if it has at least one solution. The following result was proven first in [AW92]. Simpler proofs have been discovered since <ref> [BGW93, AKVW93] </ref>. Theorem 1. It is decidable whether a system of set constraints is satisfiable. Furthermore, all solutions can be finitely presented. It is important to note that the definition of set constraints used here does damage to history. <p> Four proofs of decidability of the satisfiability problem for the basic language are known <ref> [AW92, GTT92, BGW93, AKVW93] </ref>. Remarkably, each proof is based on completely different techniques. <p> Four proofs of decidability of the satisfiability problem for the basic language are known [AW92, GTT92, BGW93, AKVW93]. Remarkably, each proof is based on completely different techniques. A particularly elegant proof is due to Bach-mair, Ganzinger, and Waldmann <ref> [BGW93] </ref>; their result shows set constraints are equivalent to the monadic class, the class of first order formulas with arbitrary quantification but only unary predicates and no function symbols. <p> Constraint resolution algorithms for restricted forms of the general problem are known [HJ90a, Hei92]; the current state of the art permits the full basic language and restricts only projections <ref> [BGW93] </ref>. Work on set constraints extended with negative constraints has been motivated in part because it is an intermediate step toward handling projections. To see this, consider the expression c 1 (c (X; Y )). <p> Damm has proven the surprising result that satisfiability of set constraints with function spaces is decidable [Dam94]. Set constraint resolution algorithms can be computationally expensive in general. For the basic problem, deciding satisfiability is NEXPTIME-complete <ref> [BGW93] </ref> and even if the language is restricted to the set operations over constants satisfiability remains NP-complete [AKVW93]. <p> The basic language of set constraints is now known to be equivalent to the monadic class of logical formulas <ref> [BGW93] </ref>; the first decision procedure for the monadic class was given by Lowenheim in 1915 [L 15]. Within the realm of computer science, Reynolds was the first to develop a resolution algorithm for a class of set constraints [Rey69]. Reynolds was interested in the analysis and optimization of Lisp programs.
Reference: [CP94a] <author> W. Charatonik and L. Pacholski. </author> <title> Negative set constraints wtih equality: An easy proof of decidability. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <month> July </month> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: Three independent proofs of the decidability of set constraints with negative constraints have been discovered <ref> [AKW93, GTT93, CP94a] </ref>; currently there is only one reported proof of the decidability of set constraints with projections [CP94b]. These are decision procedures only, however, and do not characterize the solution sets.
Reference: [CP94b] <author> W. Charatonik and L. Pacholski. </author> <title> Set constraints with projections are in NEXPTIME. </title> <booktitle> In Foundations of Computer Science, </booktitle> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: The situation with the various extensions is less clear. Table 1 summarizes the current state of knowledge. The decidability of the satisfiability of set constraints with projections was open for several years [HJ90a] and has only very recently been resolved <ref> [CP94b] </ref>. Constraint resolution algorithms for restricted forms of the general problem are known [HJ90a, Hei92]; the current state of the art permits the full basic language and restricts only projections [BGW93]. <p> Three independent proofs of the decidability of set constraints with negative constraints have been discovered [AKW93, GTT93, CP94a]; currently there is only one reported proof of the decidability of set constraints with projections <ref> [CP94b] </ref>. These are decision procedures only, however, and do not characterize the solution sets. Problem Satisfiability Constraint Resolution basic yes yes basic with projections yes with restrictions basic with function spaces yes with restrictions basic with negative constraints yes ? Table 1. Status of set constraint problems.
Reference: [Dam94] <author> F. M. Damm. </author> <title> Subtyping with union types, intersection types and recursive types. </title> <booktitle> In Proceedings of the International Symposium on Theoretical Aspects of Computer Software. </booktitle> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: Currently, constraint solving algorithms for a fairly general class of set constraints with function types are known [AW93, AWL94]. Damm has proven the surprising result that satisfiability of set constraints with function spaces is decidable <ref> [Dam94] </ref>. Set constraint resolution algorithms can be computationally expensive in general. For the basic problem, deciding satisfiability is NEXPTIME-complete [BGW93] and even if the language is restricted to the set operations over constants satisfiability remains NP-complete [AKVW93].
Reference: [GTT92] <author> R. Gilleron, S. Tison, and M. Tommasi. </author> <title> Solving systems of set constraints using tree automata. </title> <booktitle> In Proceedings of the 10th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 505-514, </pages> <year> 1992. </year>
Reference-contexts: Four proofs of decidability of the satisfiability problem for the basic language are known <ref> [AW92, GTT92, BGW93, AKVW93] </ref>. Remarkably, each proof is based on completely different techniques.
Reference: [GTT93] <author> R. Gilleron, S. Tison, and M. Tommasi. </author> <title> Solving Systems of Set Constraints with Negated Subset Relationships. </title> <booktitle> In Foundations of Computer Science, </booktitle> <pages> pages 372-380, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: of a system of positive constraints: : i _ X i 6 Y i Since conjunctions of positive constraints correspond to an existential property (i.e., is any assignment a solution of the constraints) disjunctions of negative constraints can express universal properties (i.e., is every assignment a solution of the constraints) <ref> [AKW93, GTT93] </ref>. Four proofs of decidability of the satisfiability problem for the basic language are known [AW92, GTT92, BGW93, AKVW93]. Remarkably, each proof is based on completely different techniques. <p> Three independent proofs of the decidability of set constraints with negative constraints have been discovered <ref> [AKW93, GTT93, CP94a] </ref>; currently there is only one reported proof of the decidability of set constraints with projections [CP94b]. These are decision procedures only, however, and do not characterize the solution sets.
Reference: [Hei92] <author> N. Heintze. </author> <title> Set Based Program Analysis. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: Table 1 summarizes the current state of knowledge. The decidability of the satisfiability of set constraints with projections was open for several years [HJ90a] and has only very recently been resolved [CP94b]. Constraint resolution algorithms for restricted forms of the general problem are known <ref> [HJ90a, Hei92] </ref>; the current state of the art permits the full basic language and restricts only projections [BGW93]. Work on set constraints extended with negative constraints has been motivated in part because it is an intermediate step toward handling projections. <p> By restricting the set operations (instead of the arity of constructors) it is possible to achieve polynomial time algorithms for interesting classes of constraints <ref> [JM79, MR85, Hei92] </ref>. 4 Algorithms At the current time, the literature on set constraint algorithms is very diverse in many dimensions, with a wide variety of notation and algorithmic techniques in use. <p> :; 1) [ : : : [ c (1; : : : ; 1; :X n ) [ d6=c For set constraint problems with restricted set operations and where the constraints have least solutions, it is possible to design polynomial time algorithms to compute the least solution; for examples, see <ref> [JM79, MR85, Hei92, Hei94] </ref>. <p> A natural application area for set constraints is the analysis of logic programs. The idea was first explored by Mishra [Mis84]; more recently, this line of work has been well developed in a series of papers by Jaffar and Heintze [HJ90b, HJ90a, HJ92], as well as in Heintze's thesis <ref> [Hei92] </ref>. Many of the techniques developed in [Hei92] have been fruitfully applied to compile time analysis in other areas, especially the compile-time analysis of ML programs [Hei94]. 6 Conclusions and Directions Interest in set constraints originally arose from the needs of researchers working in program analysis. <p> The idea was first explored by Mishra [Mis84]; more recently, this line of work has been well developed in a series of papers by Jaffar and Heintze [HJ90b, HJ90a, HJ92], as well as in Heintze's thesis <ref> [Hei92] </ref>. Many of the techniques developed in [Hei92] have been fruitfully applied to compile time analysis in other areas, especially the compile-time analysis of ML programs [Hei94]. 6 Conclusions and Directions Interest in set constraints originally arose from the needs of researchers working in program analysis. <p> Besides a number of prototype or special purpose systems, there are currently two substantial, complete set constraint resolution implementations, one by Nevin Heintze at CMU <ref> [Hei92] </ref> and one by the author and colleagues at IBM. The latter implementation is available by anonymous ftp and comes with a type inference system for a functional language based on solving systems of set constraints [AWL94]. To get this system, retrieve pub/personal/aiken/Illyria.tar.Z from the machine s2k-ftp.cs.berkeley.edu.
Reference: [Hei94] <author> N. Heintze. </author> <title> Set-based analysis of ML programs (extended abstract). </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <month> June </month> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: Recently, there has been a great deal of interest in program analysis algorithms based on solving systems of set constraints, including analyses for functional languages <ref> [AWL94, Hei94, AW93, AM91, JM79, MR85, Rey69] </ref>, logic programming languages [AL94, HJ92, HJ90b, Mis84], and imperative languages [HJ91]. In these algorithms, sets of terms describe the possible values computed by a program. <p> :; 1) [ : : : [ c (1; : : : ; 1; :X n ) [ d6=c For set constraint problems with restricted set operations and where the constraints have least solutions, it is possible to design polynomial time algorithms to compute the least solution; for examples, see <ref> [JM79, MR85, Hei92, Hei94] </ref>. <p> Many of the techniques developed in [Hei92] have been fruitfully applied to compile time analysis in other areas, especially the compile-time analysis of ML programs <ref> [Hei94] </ref>. 6 Conclusions and Directions Interest in set constraints originally arose from the needs of researchers working in program analysis. Currently, there is a lively, continuing interplay between the theoretical and practical efforts in the area. Future work is most likely to proceed along three lines.
Reference: [HJ90a] <author> N. Heintze and J. Jaffar. </author> <title> A decision procedure for a class of Herbrand set constraints. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 42-51, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Theorem 1. It is decidable whether a system of set constraints is satisfiable. Furthermore, all solutions can be finitely presented. It is important to note that the definition of set constraints used here does damage to history. The original formulation of set constraints, due to Heintze and Jaffar <ref> [HJ90a] </ref>, also includes projection operations in the constraint language. However, it is convenient pedagogically to present results as extensions of the definition above. This organization also reflects the manner in which recent research has progressed. <p> The situation with the various extensions is less clear. Table 1 summarizes the current state of knowledge. The decidability of the satisfiability of set constraints with projections was open for several years <ref> [HJ90a] </ref> and has only very recently been resolved [CP94b]. Constraint resolution algorithms for restricted forms of the general problem are known [HJ90a, Hei92]; the current state of the art permits the full basic language and restricts only projections [BGW93]. <p> Table 1 summarizes the current state of knowledge. The decidability of the satisfiability of set constraints with projections was open for several years [HJ90a] and has only very recently been resolved [CP94b]. Constraint resolution algorithms for restricted forms of the general problem are known <ref> [HJ90a, Hei92] </ref>; the current state of the art permits the full basic language and restricts only projections [BGW93]. Work on set constraints extended with negative constraints has been motivated in part because it is an intermediate step toward handling projections. <p> A natural application area for set constraints is the analysis of logic programs. The idea was first explored by Mishra [Mis84]; more recently, this line of work has been well developed in a series of papers by Jaffar and Heintze <ref> [HJ90b, HJ90a, HJ92] </ref>, as well as in Heintze's thesis [Hei92].
Reference: [HJ90b] <author> N. Heintze and J. Jaffar. </author> <title> A finite presentation theorem for approximating logic programs. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 197-209, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Recently, there has been a great deal of interest in program analysis algorithms based on solving systems of set constraints, including analyses for functional languages [AWL94, Hei94, AW93, AM91, JM79, MR85, Rey69], logic programming languages <ref> [AL94, HJ92, HJ90b, Mis84] </ref>, and imperative languages [HJ91]. In these algorithms, sets of terms describe the possible values computed by a program. Set constraints are generated from the program text; solving the constraints yields some useful information about the program (e.g., for type-checking or optimization). <p> ; c n can be defined such that (c i (E)) = ft i j9t 1 ; : : : ; t n : c (t 1 ; : : :; t n ) 2 (E)g To date, projections are used primarily in set constraint analyses for logic programming languages <ref> [HJ90b] </ref>. A separate extension is adding sets of functions X ! Y to the set expressions. This is a major change, because it not only enriches the language, but also requires a new domain. <p> A natural application area for set constraints is the analysis of logic programs. The idea was first explored by Mishra [Mis84]; more recently, this line of work has been well developed in a series of papers by Jaffar and Heintze <ref> [HJ90b, HJ90a, HJ92] </ref>, as well as in Heintze's thesis [Hei92].
Reference: [HJ91] <author> N. Heintze and J. Jaffar. </author> <title> Set-based program analysis. </title> <type> Draft manuscript, </type> <year> 1991. </year>
Reference-contexts: Recently, there has been a great deal of interest in program analysis algorithms based on solving systems of set constraints, including analyses for functional languages [AWL94, Hei94, AW93, AM91, JM79, MR85, Rey69], logic programming languages [AL94, HJ92, HJ90b, Mis84], and imperative languages <ref> [HJ91] </ref>. In these algorithms, sets of terms describe the possible values computed by a program. Set constraints are generated from the program text; solving the constraints yields some useful information about the program (e.g., for type-checking or optimization). Set constraints have proven to be a very successful formalism.
Reference: [HJ92] <author> N. Heintze and J. Jaffar. </author> <title> An engine for logic program analysis. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 318-328, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Recently, there has been a great deal of interest in program analysis algorithms based on solving systems of set constraints, including analyses for functional languages [AWL94, Hei94, AW93, AM91, JM79, MR85, Rey69], logic programming languages <ref> [AL94, HJ92, HJ90b, Mis84] </ref>, and imperative languages [HJ91]. In these algorithms, sets of terms describe the possible values computed by a program. Set constraints are generated from the program text; solving the constraints yields some useful information about the program (e.g., for type-checking or optimization). <p> A natural application area for set constraints is the analysis of logic programs. The idea was first explored by Mishra [Mis84]; more recently, this line of work has been well developed in a series of papers by Jaffar and Heintze <ref> [HJ90b, HJ90a, HJ92] </ref>, as well as in Heintze's thesis [Hei92].
Reference: [JM79] <author> N. D. Jones and S. S. Muchnick. </author> <title> Flow analysis and optimization of LISP-like structures. </title> <booktitle> In Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 244-256, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: Recently, there has been a great deal of interest in program analysis algorithms based on solving systems of set constraints, including analyses for functional languages <ref> [AWL94, Hei94, AW93, AM91, JM79, MR85, Rey69] </ref>, logic programming languages [AL94, HJ92, HJ90b, Mis84], and imperative languages [HJ91]. In these algorithms, sets of terms describe the possible values computed by a program. <p> By restricting the set operations (instead of the arity of constructors) it is possible to achieve polynomial time algorithms for interesting classes of constraints <ref> [JM79, MR85, Hei92] </ref>. 4 Algorithms At the current time, the literature on set constraint algorithms is very diverse in many dimensions, with a wide variety of notation and algorithmic techniques in use. <p> :; 1) [ : : : [ c (1; : : : ; 1; :X n ) [ d6=c For set constraint problems with restricted set operations and where the constraints have least solutions, it is possible to design polynomial time algorithms to compute the least solution; for examples, see <ref> [JM79, MR85, Hei92, Hei94] </ref>. <p> Using this information, a Lisp program could be optimized by, for example, eliminating run-time type checks where it was provably safe to do so. Independently of Reynolds, Jones and Muchnick developed a different analysis system for Lisp programs based on solving systems of set equations <ref> [JM79] </ref>. This analysis was used not only to eliminate dynamic type checks but also to reduce reference count operations in automatic memory management systems based on reference counting.
Reference: [Lo15] <author> L. Lowenheim. </author> <title> Uber moglichkeiten im relativkalkul. </title> <journal> Math. Annalen, </journal> <volume> 76 </volume> <pages> 228-251, </pages> <year> 1915. </year>
Reference: [Mis84] <author> P. Mishra. </author> <title> Towards a theory of types in PROLOG. </title> <booktitle> In Proceedings of the First IEEE Symposium in Logic Programming, </booktitle> <pages> pages 289-298, </pages> <year> 1984. </year>
Reference-contexts: Recently, there has been a great deal of interest in program analysis algorithms based on solving systems of set constraints, including analyses for functional languages [AWL94, Hei94, AW93, AM91, JM79, MR85, Rey69], logic programming languages <ref> [AL94, HJ92, HJ90b, Mis84] </ref>, and imperative languages [HJ91]. In these algorithms, sets of terms describe the possible values computed by a program. Set constraints are generated from the program text; solving the constraints yields some useful information about the program (e.g., for type-checking or optimization). <p> An implementation of this last system is publicly available (see Section 6). A natural application area for set constraints is the analysis of logic programs. The idea was first explored by Mishra <ref> [Mis84] </ref>; more recently, this line of work has been well developed in a series of papers by Jaffar and Heintze [HJ90b, HJ90a, HJ92], as well as in Heintze's thesis [Hei92].
Reference: [MR85] <author> P. Mishra and U. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Proceedings of the Twelfth Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 7-21, </pages> <year> 1985. </year>
Reference-contexts: Recently, there has been a great deal of interest in program analysis algorithms based on solving systems of set constraints, including analyses for functional languages <ref> [AWL94, Hei94, AW93, AM91, JM79, MR85, Rey69] </ref>, logic programming languages [AL94, HJ92, HJ90b, Mis84], and imperative languages [HJ91]. In these algorithms, sets of terms describe the possible values computed by a program. <p> By restricting the set operations (instead of the arity of constructors) it is possible to achieve polynomial time algorithms for interesting classes of constraints <ref> [JM79, MR85, Hei92] </ref>. 4 Algorithms At the current time, the literature on set constraint algorithms is very diverse in many dimensions, with a wide variety of notation and algorithmic techniques in use. <p> :; 1) [ : : : [ c (1; : : : ; 1; :X n ) [ d6=c For set constraint problems with restricted set operations and where the constraints have least solutions, it is possible to design polynomial time algorithms to compute the least solution; for examples, see <ref> [JM79, MR85, Hei92, Hei94] </ref>. <p> Mishra and Reddy described a type system based on a set constraint resolution algorithm that could handle considerably more complex constraints than previous algorithms <ref> [MR85] </ref>. Thatte introduced partial types [Tha88], the type inference problem for which, while substantially different from earlier systems, is also reducible a set constraint resolution problem. <p> The most recent work in this area is due to Wimmers and the author [AW93, AWL94], who provide a type inference system that generalizes the results in <ref> [MR85, Tha88] </ref>. An implementation of this last system is publicly available (see Section 6). A natural application area for set constraints is the analysis of logic programs.
Reference: [Rey69] <author> J. C. Reynolds. </author> <title> Automatic Computation of Data Set Definitions, </title> <booktitle> pages 456-461. Information Processing 68. </booktitle> <publisher> North-Holland, </publisher> <year> 1969. </year>
Reference-contexts: Recently, there has been a great deal of interest in program analysis algorithms based on solving systems of set constraints, including analyses for functional languages <ref> [AWL94, Hei94, AW93, AM91, JM79, MR85, Rey69] </ref>, logic programming languages [AL94, HJ92, HJ90b, Mis84], and imperative languages [HJ91]. In these algorithms, sets of terms describe the possible values computed by a program. <p> Within the realm of computer science, Reynolds was the first to develop a resolution algorithm for a class of set constraints <ref> [Rey69] </ref>. Reynolds was interested in the analysis and optimization of Lisp programs. In this application, set constraints were used to compute a conservative description of the data structures in use at a program point.
Reference: [Sei90] <author> H. Seidl. </author> <title> Deciding equivalence of finite tree automata. </title> <journal> SIAM Journal of Computing, </journal> <volume> 19(3) </volume> <pages> 424-437, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: This non-deterministic choice increases the complexity of set constraint problems above the complexity of the corresponding tree automata problems. For example, deciding whether the language of one tree automata is a subset of another is complete for EXPTIME <ref> [Sei90] </ref>; solving a general system of set constraint inclusions is complete for NEXPTIME.
Reference: [Tha88] <author> S. Thatte. </author> <title> Type inference with partial types. </title> <booktitle> In Automata, Languages and Programming: 15th International Colloquium, </booktitle> <pages> pages 615-629. </pages> <booktitle> Springer-Verlag Lecture Notes in Computer Science, </booktitle> <volume> vol. 317, </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: Mishra and Reddy described a type system based on a set constraint resolution algorithm that could handle considerably more complex constraints than previous algorithms [MR85]. Thatte introduced partial types <ref> [Tha88] </ref>, the type inference problem for which, while substantially different from earlier systems, is also reducible a set constraint resolution problem. The most recent work in this area is due to Wimmers and the author [AW93, AWL94], who provide a type inference system that generalizes the results in [MR85, Tha88]. <p> The most recent work in this area is due to Wimmers and the author [AW93, AWL94], who provide a type inference system that generalizes the results in <ref> [MR85, Tha88] </ref>. An implementation of this last system is publicly available (see Section 6). A natural application area for set constraints is the analysis of logic programs.
Reference: [WH92] <author> E. Wang and P. N. Hilfinger. </author> <title> Analysis of recursive types in Lisp-like languages. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 216-225, </pages> <month> June </month> <year> 1992. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: This analysis was used not only to eliminate dynamic type checks but also to reduce reference count operations in automatic memory management systems based on reference counting. Recently Wang and Hilfinger have proposed another analysis method for Lisp based on set equations <ref> [WH92] </ref>. 1 As written, the law for negation appears to require that the set of all constructors d such that d 6= c can be enumerated and thus the set of constructors must be finite.
References-found: 27

