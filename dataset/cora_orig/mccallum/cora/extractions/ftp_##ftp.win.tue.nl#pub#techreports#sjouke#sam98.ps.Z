URL: ftp://ftp.win.tue.nl/pub/techreports/sjouke/sam98.ps.Z
Refering-URL: http://www.win.tue.nl/cs/fm/Sjouke.Mauw/
Root-URL: http://www.win.tue.nl
Email: feijs@win.tue.nl, sjouke@win.tue.nl  
Phone: 2  
Title: MSC and data  
Author: L.M.G. Feijs ; S. Mauw 
Keyword: MSC, data, algebraic specifications, ASN.1, semantics  
Address: Prof. Holstlaan 4, 5656 AA, Eindhoven, The Netherlands.  P.O. Box 513, NL-5600 MB Eindhoven, The Netherlands.  
Affiliation: 1 Philips Research Laboratories Eindhoven.  Department of Mathematics and Computing Science, Eindhoven University of Technology,  
Abstract: The extension of the MSC language with more advanced data concepts is one of the current topics of discussion in the MSC standardization community. We discuss some problems and possibilities. By means of two case studies we study the practical consequences of our proposed approach. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.C.M. Baeten and S. Mauw. </author> <title> Delayed choice: an operator for joining Message Sequence Charts. </title> <editor> In D. Hogrefe and S. Leue, editors, </editor> <booktitle> Formal Description Techniques, VII, </booktitle> <pages> pages 340-354. </pages> <publisher> Chapman & Hall, </publisher> <year> 1995. </year>
Reference-contexts: In Figure 2 we show the intended meaning of the MSC from Figure 1, denoting the choice with the symbol which is known as the delayed choice (see <ref> [1] </ref>). Formalization Next, we formalize the construction from the previous section. As explained before, our aim is to study what the interface is between the behavioural MSC language and the data language. We try to abstract as much as possible from the actual data language being used.
Reference: [2] <author> P. Baker and C. Jervis. </author> <title> Formal description of data. </title> <booktitle> SG10 meeting Lutterworth TDL16, </booktitle> <address> ITU-TS, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: We will illustrate this approach with two case studies. The first case study concerns the extension of MSC with a data language based on algebraic specifications. The second case study takes ASN.1 as a starting point and is based on the proposal from Baker and Jervis <ref> [2] </ref>. Acknowledgments We thank Andre Engels and Michel Reniers for proof reading previous versions of this document. <p> We learn from the work of Baker and Jervis <ref> [2] </ref> that it may be desirable to work with constraints which apply to the messages. In this way it is possible to completely fix a message, but it is also possible to give constraints to one or more fields, leaving the value of the other fields unspecified. <p> However, we should then read the MSCs in Figure 2 as the graphical representations of their semantical meaning in A D . 3.3 MSC and a constrained syntax language Example In this section we study the extension of MSC with a constrained syntax language as proposed by Baker and Jervis <ref> [2] </ref>. The proposal is aimed at allowing a more flexible syntax for the specification of message parameters. Its main virtues are the following. * Not all parameters of a message have to be provided. <p> In Figure 3 we show an example of an MSC specification combined with a simple ASN.1 specification. Please note that this example deviates slightly from the syntax proposed in <ref> [2] </ref>. Namely, we have added a message name m, rather than considering the type Frame as the name of the message. <p> For most components we refer to <ref> [2] </ref>. Since we allow all possible substitutions for all terms, we set the function is comp to true. <p> S P : MSC P ! A P the semantical function as defined in Z.120 Annex B : A P fi A P ! A P the delayed choice operator from Z.120 Annex B Concerning data: wf decl : String ! Bool see the BNF grammar and typing rules from <ref> [2] </ref> wf term : D fi String ! Bool see the BNF grammar and typing rules from [2] closed : D fi T ! Bool terms of which all components are fully determined SUBST all functions that yield fully determined terms which satisfy the constraints apply : SUBST fi T ! <p> : A P fi A P ! A P the delayed choice operator from Z.120 Annex B Concerning data: wf decl : String ! Bool see the BNF grammar and typing rules from <ref> [2] </ref> wf term : D fi String ! Bool see the BNF grammar and typing rules from [2] closed : D fi T ! Bool terms of which all components are fully determined SUBST all functions that yield fully determined terms which satisfy the constraints apply : SUBST fi T ! R application of the substitution function D the semantical model from [2] S data : D fi <p> grammar and typing rules from <ref> [2] </ref> closed : D fi T ! Bool terms of which all components are fully determined SUBST all functions that yield fully determined terms which satisfy the constraints apply : SUBST fi T ! R application of the substitution function D the semantical model from [2] S data : D fi T closed ! D the interpretation of a term in the model from [2] is comp : SUBST fi SUBST ! Bool the function that always yields true Table 3: Instantiation of the interface for a constrained syntax notation 4 CONCLUSIONS This paper can be <p> fully determined SUBST all functions that yield fully determined terms which satisfy the constraints apply : SUBST fi T ! R application of the substitution function D the semantical model from <ref> [2] </ref> S data : D fi T closed ! D the interpretation of a term in the model from [2] is comp : SUBST fi SUBST ! Bool the function that always yields true Table 3: Instantiation of the interface for a constrained syntax notation 4 CONCLUSIONS This paper can be seen as a feasibility study on the incorporation of data in MSC.
Reference: [3] <author> ITU-TS. </author> <title> ITU-TS Recommendation Z.100: Specification and Description Language (SDL). </title> <address> ITU-TS, Geneva, </address> <year> 1988. </year>
Reference-contexts: But also when using MSC for the visualization of traces, actual data values may be observed. Since MSC is closely related to SDL <ref> [3] </ref>, some things can be learned from the way in which SDL deals with data. The first formal data language integrated with SDL was based on algebraic specifications. These are known for having a very simple syntax and a clear semantical foundation.
Reference: [4] <author> ITU-TS. </author> <title> ITU-TS Recommendation Z.120: Message Sequence Chart (MSC). </title> <address> ITU-TS, Geneva, </address> <year> 1997. </year>
Reference-contexts: 1 INTRODUCTION Quite high on the list of possible extensions for MSC <ref> [4] </ref> is data. Currently, the language has hardly any data concept. At best, data can be expressed as a parameter of a message which is simply considered as a syntactical extension of the message name. Operations can be defined informally by means of actions.
Reference: [5] <author> S. Mauw and G.J. Veltink. </author> <title> A process specification formalism. </title> <note> Fundamenta Informaticae, XIII:85-139, </note> <year> 1990. </year>
Reference-contexts: First, we discuss the instantiation of the interface for an extension of MSC with a simple algebraic specification language (e.g. from <ref> [5] </ref>). The instantiation is sketched in Table 2. It shows that for most entries references to literature or standard solutions are provided. <p> S P : MSC P ! A P the semantical function as defined in Z.120 Annex B : A P fi A P ! A P the delayed choice operator from Z.120 Annex B Concerning data: wf decl : String ! Bool see the BNF grammar and typing rules from <ref> [5] </ref> wf term : D fi String ! Bool see the BNF grammar and typing rules from [5] closed : D fi T ! Bool all terms constructed from function symbols only SUBST all functions from variables to (closed) terms apply : SUBST fi T ! R application of the (extended) <p> : A P fi A P ! A P the delayed choice operator from Z.120 Annex B Concerning data: wf decl : String ! Bool see the BNF grammar and typing rules from <ref> [5] </ref> wf term : D fi String ! Bool see the BNF grammar and typing rules from [5] closed : D fi T ! Bool all terms constructed from function symbols only SUBST all functions from variables to (closed) terms apply : SUBST fi T ! R application of the (extended) substitution function D the term model S data : D fi T closed ! D the equivalence
Reference: [6] <author> D. Steedman. </author> <title> Abstract syntax notation one (ASN.1): the tutorial and reference. </title> <institution> Technology Appraisals Ltd., </institution> <year> 1990. </year>
Reference-contexts: These are known for having a very simple syntax and a clear semantical foundation. In practice, however, the functional style of an algebraic specification showed to be too difficult for people used to an imperative language. Therefore, an alternative data language, ASN.1 <ref> [6] </ref>, was adopted. This enforced the development of a second recommendation, which exists next to the first one. Currently, the development of SDL2000 involves a redesign of the SDL data language. This situation has several drawbacks. Both recommendations have a large overlap, and thus there is a maintenance problem. <p> The idea is that certain messages or certain fields are deliberately left unspecified, for example because they are not relevant (yet) or because a value has to be provided later. Constrained syntax languages have a long tradition in industrial applications, notably the languages ASN.1 <ref> [6] </ref> and TTCN [7]. 3.2 MSC and an algebraic specification language Example We start this section with a simple example that shows the combination of MSC with a data language based on algebraic specifications (see Figure 1).
Reference: [7] <author> ISO/IEC Information technology. </author> <title> OSI conformance testing methodology and framework, part 3: The Tree and Tabular Notation (TTCN). ISO document ISO9646. </title> <address> ISO/IEC, </address> <year> 1990. </year>
Reference-contexts: The idea is that certain messages or certain fields are deliberately left unspecified, for example because they are not relevant (yet) or because a value has to be provided later. Constrained syntax languages have a long tradition in industrial applications, notably the languages ASN.1 [6] and TTCN <ref> [7] </ref>. 3.2 MSC and an algebraic specification language Example We start this section with a simple example that shows the combination of MSC with a data language based on algebraic specifications (see Figure 1). This MSC consists of two parts, namely, the data declaration and the behaviour specification.
References-found: 7

