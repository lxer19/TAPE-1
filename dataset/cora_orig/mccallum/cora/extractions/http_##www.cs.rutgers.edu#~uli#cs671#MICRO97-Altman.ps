URL: http://www.cs.rutgers.edu/~uli/cs671/MICRO97-Altman.ps
Refering-URL: http://www.cs.rutgers.edu/~uli/cs671/index.html
Root-URL: http://www.cs.rutgers.edu
Email: govind@cs.mun.ca erik@macs.ee.mcgill.ca gao@cs.mcgill.ca  
Title: Minimizing Register Requirements under Resource-Constrained Rate-Optimal Software Pipelining  
Author: R. Govindarajan Erik R. Altman Guang R. Gao 
Address: St. John's, A1C 5S7, CANADA Montreal, H3A 2A7, CANADA Montreal, H3A 2A7, CANADA  
Affiliation: Dept. of Computer Science Dept. of Electrical Engineering School of Computer Science Memorial Univ. of Newfoundland McGill University McGill University  
Abstract: In this paper we address the following software pipelin-ing problem: given a loop and a machine architecture with a fixed number of processor resources (e.g. function units), how can one construct a software-pipelined schedule which runs on the given architecture at the maximum possible iteration rate (a la rate-optimal) while minimizing the number of registers? The main contributions of this paper are: * First, we demonstrate that such problem can be described by a simple mathematical formulation with precise optimization objectives under periodic linear scheduling framework. The mathematical formulation provides a clear picture which permits one to visualize the overall solution space (for rate-optimal schedules) under different sets of con straints. * Secondly, we show that a precise mathematical formulation and its solution does make a significant performance difference! We evaluated the performance of our method against three other leading contemporary heuristic methods: Huff 's Slack Scheduling [9], Wang, Eisenbeis, Jourdan and Su's FRLC [23], and Gasperoni and Schwiegelshohn's modified list scheduling [6]. Experimental results show that the method described in this paper performed significantly better than these methods. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken and A. Nicolau. </author> <title> A realistic resource-constrained software pipelining algorithm. </title> <editor> In A. Nico-lau, D. Gelernter, T. Gross, and D. Padua, editors, </editor> <booktitle> Advances in Languages and Compilers for Parallel Processing, Res. Monographs in Parallel and Distrib. Computing, chapter 14, </booktitle> <pages> pages 274-290. </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Software pipelining <ref> [1, 4, 9, 11, 12, 13, 17, 18, 22] </ref> has been proposed as an efficient method for loop schedul fl This work was supported by research grants from NSERC (Canada) and MICRONET -Network Centers of Excellence (Canada). <p> An instruction i is initiated at the r-th time step in the repetitive pattern, if o i = r. Now, since each o i 2 [0; T 1], we can write O as O Transpose = <ref> [0; 1; ; T 1] </ref> fi A: (4) where A = 6 6 a 0;0 a 0;1 a 0;(N1) . . . . . . 3 7 5 is a 0-1 matrix. In particular, a r;i = 1 if o i = r; otherwise, a r;i = 0.
Reference: [2] <author> J. R. Allen, K. Kennedy, C. Porterfield, and J. Warren. </author> <title> Conversion of control dependence to data dependence. </title> <booktitle> In Conf. Rec. of the Tenth Ann. ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 177-189, </pages> <address> Austin, TX, </address> <month> Jan. </month> <pages> 24-26, </pages> <year> 1983. </year>
Reference-contexts: Huff found that a large majority of loops contain no conditionals [9], and hence we have concentrated in this paper on straightline code. For loops involving conditionals, we assume a hardware model that supports predicated execution as in [20]. If-conversion <ref> [2] </ref> can be performed to support this model. As well, in [18] it was shown that predicated execution simplifies code generation after modulo scheduling. 3.1 OPT-T Formulation Let the number of nodes in the DDG be N and let T be the iteration period.
Reference: [3] <author> E. R. Altman, R. Govindarajan, and G. R. Gao. </author> <title> Software pipelining to minimize registers and resources. </title> <type> ACAPS Technical Memo 79, </type> <institution> School of Computer Science, McGill University, Montreal, Que., </institution> <year> 1994. </year> <note> under preparation. </note>
Reference-contexts: Notice that in this case, TRB is a subset of TB. We have developed a tool which generates statistical information on the sizes of various regions in the solution space for a a given loop L and a resource constraint R <ref> [3] </ref>. Using this tool, we know that, for our example, there are 32 schedules in the set T as will be illustrated in Fig. 4 in Section 5.3. Among these 32 schedules, 10 are in the region TR, for R = 3 and T min = 2.
Reference: [4] <author> J. C. Dehnert and R. A. Towle. </author> <title> Compiling for Cydra 5. </title> <journal> Journal of Supercomputing, </journal> <volume> 7 </volume> <pages> 181-227, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Software pipelining <ref> [1, 4, 9, 11, 12, 13, 17, 18, 22] </ref> has been proposed as an efficient method for loop schedul fl This work was supported by research grants from NSERC (Canada) and MICRONET -Network Centers of Excellence (Canada). <p> 58 13 45 11 40 2 38 FRLC 32 26 20 6 21 30 15 15 Gasperoni 35 23 4 19 29 22 2 20 Table 5: Comparison of ILP performance to 3 Heuristic Methods on Machines with 2-8 Function Units. 6 Related Work Software pipelining has been extensively studied <ref> [4, 6, 11, 17, 22, 18, 9, 22, 23] </ref>, and a variety of techniques have been suggested for finding a good schedule with bounded function units. The readers are referred to [16] for a comprehensive survey. <p> Other heuristic-based scheduling methods have been proposed by Wang et al [23], and Gasperoni and Schwiegelshohn [6]. We have compared how the ILP schedules perform against these three scheduling methods in Section 5.2. The FPS compiler [17], the Cydra 5 compiler, Cydrix T M Fortran <ref> [4] </ref>, and the HP-PA compiler [15] are production compilers based on heuristic methods implementing resource-constrained software pipelining. Rau et al. [18] have addressed the problem of register allocation for modulo scheduled loops. In their method register allocation is performed on already scheduled loops.
Reference: [5] <author> K. Ebcioglu and T. Nakatani. </author> <title> A new compilation technique for parallelizing loops with unpredictable branches on a VLIW architecture. </title> <editor> In D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing, Res. Monographs in Parallel and Distrib. Computing, chapter 12, </booktitle> <pages> pages 213-229. </pages> <year> 1990. </year>
Reference-contexts: Different code generation schema for modulo scheduled loops have been discussed in [19]. In [14], a Petri net based approach to Software pipelin-ing loops in the presence of resource constraints has been presented. Ebcioglu et al. have proposed the technique of enhanced software pipelining with resource constraints <ref> [5] </ref>. Related work in scheduling graphs in the presence of conditionals have been reported in [24].
Reference: [6] <author> F. Gasperoni and U. Schwiegelshohn. </author> <title> Efficient algorithms for cyclic scheduling. Res. </title> <type> Rep. RC 17068, </type> <institution> IBM T. J. Watson Res. Center, </institution> <address> Yorktown Heights, NY, </address> <year> 1991. </year>
Reference-contexts: Question 2, the "So what?" question, has been addressed by comparing our method with 3 other approaches, Huff's Slack Scheduling [9], Wang, Eisen-beis, Jourdan and Su's FRLC variant of DESP-Decomposed Software Pipelining [23], and Gasper-oni and Schwiegelshohn's modified list scheduling approach <ref> [6] </ref>. We have implemented the above three heuristic methods in our experimental scheduling testbed. We have measured the performance of various scheduling methods on a set of 27 kernel loops taken from various benchmark programs. <p> Using our 27 benchmark loops, we measured how well our approach compares with 3 leading heuristic methods on machines with from 2-8 function units. The 3 heuristics are Huff's Slack Scheduling [9], Wang, Eisenbeis, Jourdan and Su's FRLC [23], and Gasperoni and Schwiegelshohn's modified list scheduling <ref> [6] </ref>. Our implementation of these heuristic methods are based on the details given in the respective references. <p> 58 13 45 11 40 2 38 FRLC 32 26 20 6 21 30 15 15 Gasperoni 35 23 4 19 29 22 2 20 Table 5: Comparison of ILP performance to 3 Heuristic Methods on Machines with 2-8 Function Units. 6 Related Work Software pipelining has been extensively studied <ref> [4, 6, 11, 17, 22, 18, 9, 22, 23] </ref>, and a variety of techniques have been suggested for finding a good schedule with bounded function units. The readers are referred to [16] for a comprehensive survey. <p> He reported extremely good results in addressing the OPT problem. Other heuristic-based scheduling methods have been proposed by Wang et al [23], and Gasperoni and Schwiegelshohn <ref> [6] </ref>. We have compared how the ILP schedules perform against these three scheduling methods in Section 5.2. The FPS compiler [17], the Cydra 5 compiler, Cydrix T M Fortran [4], and the HP-PA compiler [15] are production compilers based on heuristic methods implementing resource-constrained software pipelining.
Reference: [7] <author> M. B. Girkar, M. R. Haghighat, C. L. Lee, B. P. Le-ung, and D. A. Schouten. </author> <title> Parafrase-2 user's manual. </title> <type> TR RC-17068(#75743), </type> <institution> Center for Supercomputing Research and Development, University of Illinois at Urbana-Champagne, IL, </institution> <year> 1991. </year>
Reference-contexts: To evaluate our approach, we first obtain the DDG of the floating point operations in each loop from a modified Paraphrase compiler <ref> [7] </ref>. We have assumed a unit latency for add, subtract, and store instructions, a latency of 2 for multiply and load, and a latency of 17 for divide. Using the DDG and the latencies of individual instructions, our program SPILP, generates the ILP formulations.
Reference: [8] <author> R. Govindarajan, E. R. Altman, and G. R. Gao. </author> <title> Minimizing register requirement in resource-constrained software pipelining. </title> <type> ACAPS Technical Memo 80, </type> <institution> School of Computer Science, McGill University, Montreal, Que., </institution> <year> 1994. </year>
Reference-contexts: In particular, the iteration period of these schedules were 4 to 8 times slower than the ILP schedules. 3 Due to space limitation comparative results are provided only for one heterogeneous architecture. The readers are referred to <ref> [8] </ref> for other results.
Reference: [9] <author> R. A. Huff. </author> <title> Lifetime-sensitive modulo scheduling. </title> <booktitle> In Proc. of the SIGPLAN '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 258-267, </pages> <address> Al-buquerque, NM, </address> <month> Jun. </month> <pages> 23-25, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Software pipelining <ref> [1, 4, 9, 11, 12, 13, 17, 18, 22] </ref> has been proposed as an efficient method for loop schedul fl This work was supported by research grants from NSERC (Canada) and MICRONET -Network Centers of Excellence (Canada). <p> Further improvement in execution time is possible by developing a special purpose solver tailored to our formulation. Question 2, the "So what?" question, has been addressed by comparing our method with 3 other approaches, Huff's Slack Scheduling <ref> [9] </ref>, Wang, Eisen-beis, Jourdan and Su's FRLC variant of DESP-Decomposed Software Pipelining [23], and Gasper-oni and Schwiegelshohn's modified list scheduling approach [6]. We have implemented the above three heuristic methods in our experimental scheduling testbed. <p> Thus, T dep for the given dependency graph is 1. Resource constraints (of the architecture) impose a lower bound on the initiation interval. This bound, denoted by T res , is given by <ref> [17, 9, 11] </ref>: T res = number of nodes number of function units Since we have 3 function units, for the graph of Figure 1, T res = d 6 3 e = 2. <p> In this paper, we have assumed all function units are identical and are fully pipelined (i.e. without any structural hazards). In Section 3.2, the problem formulation is extended to heterogeneous function units. Huff found that a large majority of loops contain no conditionals <ref> [9] </ref>, and hence we have concentrated in this paper on straightline code. For loops involving conditionals, we assume a hardware model that supports predicated execution as in [20]. If-conversion [2] can be performed to support this model. <p> To solve the OPT problem, we need to iteratively solve the OPT-T formulation for increasing values of T starting from T lb . This is because it has been observed that in most cases, T min is at or near T lb <ref> [11, 9] </ref>. Further, in solving the ILP formulation of the OPT-T problem, we can guide our search by giving a lower bound on the number of buffers required. <p> Our results indicate otherwise. Using our 27 benchmark loops, we measured how well our approach compares with 3 leading heuristic methods on machines with from 2-8 function units. The 3 heuristics are Huff's Slack Scheduling <ref> [9] </ref>, Wang, Eisenbeis, Jourdan and Su's FRLC [23], and Gasperoni and Schwiegelshohn's modified list scheduling [6]. Our implementation of these heuristic methods are based on the details given in the respective references. <p> 58 13 45 11 40 2 38 FRLC 32 26 20 6 21 30 15 15 Gasperoni 35 23 4 19 29 22 2 20 Table 5: Comparison of ILP performance to 3 Heuristic Methods on Machines with 2-8 Function Units. 6 Related Work Software pipelining has been extensively studied <ref> [4, 6, 11, 17, 22, 18, 9, 22, 23] </ref>, and a variety of techniques have been suggested for finding a good schedule with bounded function units. The readers are referred to [16] for a comprehensive survey. <p> Lam [11] proposed a resource-constrained software pipelining method using list scheduling and hierarchical reduction of cyclic components. Our A matrix is similar to her modulo resource reservation table, a concept originally due to Rau and Glaeser [17]. Huff's Slack Scheduling <ref> [9] </ref> is also an iterative solution to the OPT problem.
Reference: [10] <author> C.-T. Hwang, J.-H. Lee, and Y.-C. Hsu. </author> <title> A formal approach to the scheduling problem in high-level synthesis. </title> <journal> IEEE Trans. on Computer-Aided Design, </journal> <volume> 10(4) </volume> <pages> 464-475, </pages> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: Ebcioglu et al. have proposed the technique of enhanced software pipelining with resource constraints [5]. Related work in scheduling graphs in the presence of conditionals have been reported in [24]. In <ref> [10] </ref>, Hwang et al. proposed an ILP formulation for scheduling acyclic graphs. 7 Conclusions In this paper we have proposed a method to construct software pipelined schedules that use minimum buffers and run at the fastest iteration rate for the given resource constraints.
Reference: [11] <author> M. Lam. </author> <title> Software pipelining: An effective scheduling technique for VLIW machines. </title> <booktitle> In Proc. of the SIGPLAN '88 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 318-328, </pages> <address> Atlanta, GA, </address> <month> Jun. </month> <pages> 22-24, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Software pipelining <ref> [1, 4, 9, 11, 12, 13, 17, 18, 22] </ref> has been proposed as an efficient method for loop schedul fl This work was supported by research grants from NSERC (Canada) and MICRONET -Network Centers of Excellence (Canada). <p> Thus, T dep for the given dependency graph is 1. Resource constraints (of the architecture) impose a lower bound on the initiation interval. This bound, denoted by T res , is given by <ref> [17, 9, 11] </ref>: T res = number of nodes number of function units Since we have 3 function units, for the graph of Figure 1, T res = d 6 3 e = 2. <p> These conceptual FIFO buffers can either be di-rectly implemented using dedicated architecture features such as circular buffers or rotating registers [20], or be mapped to physical registers (with appropriate register moves) on conventional architectures as described in <ref> [11, 13] </ref>. In [13], it was demonstrated that the minimum buffer requirement provides a very tight upper bound on the total register requirement, and once the buffer assignment is done, a classical graph coloring method can be subsequently performed which generally leads to the minimum register requirement. <p> This can be specified in the integer programming formulation as T 1 X a r;i = 1 ; a r;i 0 is an integer ; 8i 2 [0; N 1] (5) The A matrix is similar to the modulo reservation ta-ble <ref> [11] </ref>, a concept originally due to [17]. An instruction i is initiated at the r-th time step in the repetitive pattern if o i = r or a r;i = 1. <p> To solve the OPT problem, we need to iteratively solve the OPT-T formulation for increasing values of T starting from T lb . This is because it has been observed that in most cases, T min is at or near T lb <ref> [11, 9] </ref>. Further, in solving the ILP formulation of the OPT-T problem, we can guide our search by giving a lower bound on the number of buffers required. <p> 58 13 45 11 40 2 38 FRLC 32 26 20 6 21 30 15 15 Gasperoni 35 23 4 19 29 22 2 20 Table 5: Comparison of ILP performance to 3 Heuristic Methods on Machines with 2-8 Function Units. 6 Related Work Software pipelining has been extensively studied <ref> [4, 6, 11, 17, 22, 18, 9, 22, 23] </ref>, and a variety of techniques have been suggested for finding a good schedule with bounded function units. The readers are referred to [16] for a comprehensive survey. <p> The readers are referred to [16] for a comprehensive survey. Lam <ref> [11] </ref> proposed a resource-constrained software pipelining method using list scheduling and hierarchical reduction of cyclic components. Our A matrix is similar to her modulo resource reservation table, a concept originally due to Rau and Glaeser [17]. Huff's Slack Scheduling [9] is also an iterative solution to the OPT problem.
Reference: [12] <author> S. Moon and K. Ebcioglu. </author> <title> An efficient resource-constrained global scheduling technique for superscalar and VLIW processors. </title> <booktitle> In Proc. of the 25th Ann. Intl. Symp. on Microarchitecture, </booktitle> <pages> pages 55-71, </pages> <address> Portland, OR, </address> <month> Dec. </month> <pages> 1-4, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Software pipelining <ref> [1, 4, 9, 11, 12, 13, 17, 18, 22] </ref> has been proposed as an efficient method for loop schedul fl This work was supported by research grants from NSERC (Canada) and MICRONET -Network Centers of Excellence (Canada).
Reference: [13] <author> Q. Ning and G. R. Gao. </author> <title> A novel framework of register allocation for software pipelining. </title> <booktitle> In Conf. Rec. of the Twentieth Ann. ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 29-42, </pages> <address> Charleston, SC, </address> <month> Jan. </month> <pages> 10-13, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Software pipelining <ref> [1, 4, 9, 11, 12, 13, 17, 18, 22] </ref> has been proposed as an efficient method for loop schedul fl This work was supported by research grants from NSERC (Canada) and MICRONET -Network Centers of Excellence (Canada). <p> We are able to express the resource constraints as linear constraints | combining such resource constraints with the work by Ning and Gao, where a tight upper bound for register requirement is specified using linear constraints <ref> [13] </ref>, a unified formulation for the OPT-T problem is obtained. We have implemented the solution method to construct schedules for target architecture with either homogeneous or heterogeneous function units. <p> In solving the OPT-T problem, tight bounds for the integer variables are obtained, using what are called the As Soon As Possible (ASAP) and the As Late As Possible (ALAP) schedules. Further, a lower bound on the number of buffers is obtained from Ning/Gao's linear program formulation <ref> [13] </ref>. These bounds drastically reduce the search space of the integer program which facilitates obtaining the optimal solution in a reasonable computation time. <p> These conceptual FIFO buffers can either be di-rectly implemented using dedicated architecture features such as circular buffers or rotating registers [20], or be mapped to physical registers (with appropriate register moves) on conventional architectures as described in <ref> [11, 13] </ref>. In [13], it was demonstrated that the minimum buffer requirement provides a very tight upper bound on the total register requirement, and once the buffer assignment is done, a classical graph coloring method can be subsequently performed which generally leads to the minimum register requirement. <p> These conceptual FIFO buffers can either be di-rectly implemented using dedicated architecture features such as circular buffers or rotating registers [20], or be mapped to physical registers (with appropriate register moves) on conventional architectures as described in [11, 13]. In <ref> [13] </ref>, it was demonstrated that the minimum buffer requirement provides a very tight upper bound on the total register requirement, and once the buffer assignment is done, a classical graph coloring method can be subsequently performed which generally leads to the minimum register requirement. <p> K T + A Transpose fi 2 6 4 1 T 1 7 7 = T (7) Finally, in order to derive the objective function of the formulation, we need to specify the register requirement of the periodic schedule in a linear form. In <ref> [13] </ref>, the buffer requirement b i for an instruction i in the linear schedule form was derived as: T b i + t i t j T m ij ; for each edge (i; j) (8) The objective of the OPT-T formulation is to minimize the total number of buffers used <p> Further, in solving the ILP formulation of the OPT-T problem, we can guide our search by giving a lower bound on the number of buffers required. This can be accomplished by solving the minimum register optimal schedule formulation, for the initiation period T , proposed by Ning and Gao <ref> [13] </ref>, which is a linear program formulation. 5 Results and Discussion In this section we present some initial results of our experimental study. We also compare our results with other leading heuristic methods. 5.1 Experimental Results We have implemented the OPT formulation on a UNIX workbench.
Reference: [14] <author> M. Rajagopalan and V. H. Allan. </author> <title> Efficient scheduling of fine grain parallelism in loops. </title> <booktitle> In Proc. of the 26th Ann. Intl. Symp. on Microarchitecture, </booktitle> <pages> pages 2-11, </pages> <address> Austin, TX, </address> <month> Dec. </month> <pages> 1-3, </pages> <year> 1993. </year>
Reference-contexts: Rau et al. [18] have addressed the problem of register allocation for modulo scheduled loops. In their method register allocation is performed on already scheduled loops. Different code generation schema for modulo scheduled loops have been discussed in [19]. In <ref> [14] </ref>, a Petri net based approach to Software pipelin-ing loops in the presence of resource constraints has been presented. Ebcioglu et al. have proposed the technique of enhanced software pipelining with resource constraints [5]. Related work in scheduling graphs in the presence of conditionals have been reported in [24].
Reference: [15] <author> S. Ramakrishnan. </author> <title> Software pipelining in PA-RISC compilers. </title> <journal> Hewlett-Packard J., </journal> <pages> pages 39-45, </pages> <month> Jun. </month> <year> 1992. </year>
Reference-contexts: We have compared how the ILP schedules perform against these three scheduling methods in Section 5.2. The FPS compiler [17], the Cydra 5 compiler, Cydrix T M Fortran [4], and the HP-PA compiler <ref> [15] </ref> are production compilers based on heuristic methods implementing resource-constrained software pipelining. Rau et al. [18] have addressed the problem of register allocation for modulo scheduled loops. In their method register allocation is performed on already scheduled loops.
Reference: [16] <author> B. R. Rau and J. A. Fisher. </author> <title> Instruction-level parallel processing: History, overview and perspective. </title> <journal> J. of Supercomputing, </journal> <volume> 7 </volume> <pages> 9-50, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The readers are referred to <ref> [16] </ref> for a comprehensive survey. Lam [11] proposed a resource-constrained software pipelining method using list scheduling and hierarchical reduction of cyclic components. Our A matrix is similar to her modulo resource reservation table, a concept originally due to Rau and Glaeser [17].
Reference: [17] <author> B. R. Rau and C. D. Glaeser. </author> <title> Some scheduling techniques and an easily schedulable horizontal architecture for high performance scientific computing. </title> <booktitle> In Proc. of the 14th Ann. Microprogramming Work., </booktitle> <pages> pages 183-198, </pages> <address> Chatham, MA, </address> <month> Oct. </month> <pages> 12-15, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction Software pipelining <ref> [1, 4, 9, 11, 12, 13, 17, 18, 22] </ref> has been proposed as an efficient method for loop schedul fl This work was supported by research grants from NSERC (Canada) and MICRONET -Network Centers of Excellence (Canada). <p> Thus, T dep for the given dependency graph is 1. Resource constraints (of the architecture) impose a lower bound on the initiation interval. This bound, denoted by T res , is given by <ref> [17, 9, 11] </ref>: T res = number of nodes number of function units Since we have 3 function units, for the graph of Figure 1, T res = d 6 3 e = 2. <p> This can be specified in the integer programming formulation as T 1 X a r;i = 1 ; a r;i 0 is an integer ; 8i 2 [0; N 1] (5) The A matrix is similar to the modulo reservation ta-ble [11], a concept originally due to <ref> [17] </ref>. An instruction i is initiated at the r-th time step in the repetitive pattern if o i = r or a r;i = 1. <p> 58 13 45 11 40 2 38 FRLC 32 26 20 6 21 30 15 15 Gasperoni 35 23 4 19 29 22 2 20 Table 5: Comparison of ILP performance to 3 Heuristic Methods on Machines with 2-8 Function Units. 6 Related Work Software pipelining has been extensively studied <ref> [4, 6, 11, 17, 22, 18, 9, 22, 23] </ref>, and a variety of techniques have been suggested for finding a good schedule with bounded function units. The readers are referred to [16] for a comprehensive survey. <p> The readers are referred to [16] for a comprehensive survey. Lam [11] proposed a resource-constrained software pipelining method using list scheduling and hierarchical reduction of cyclic components. Our A matrix is similar to her modulo resource reservation table, a concept originally due to Rau and Glaeser <ref> [17] </ref>. Huff's Slack Scheduling [9] is also an iterative solution to the OPT problem. <p> He reported extremely good results in addressing the OPT problem. Other heuristic-based scheduling methods have been proposed by Wang et al [23], and Gasperoni and Schwiegelshohn [6]. We have compared how the ILP schedules perform against these three scheduling methods in Section 5.2. The FPS compiler <ref> [17] </ref>, the Cydra 5 compiler, Cydrix T M Fortran [4], and the HP-PA compiler [15] are production compilers based on heuristic methods implementing resource-constrained software pipelining. Rau et al. [18] have addressed the problem of register allocation for modulo scheduled loops.
Reference: [18] <author> B. R. Rau, M. Lee, P. P. Tirumalai, and M. S. Schlansker. </author> <title> Register allocation for software pipelined loops. </title> <booktitle> In Proc. of the SIGPLAN '92 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 283-299, </pages> <address> San Francisco, CA, </address> <month> Jun. </month> <pages> 17-19, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Software pipelining <ref> [1, 4, 9, 11, 12, 13, 17, 18, 22] </ref> has been proposed as an efficient method for loop schedul fl This work was supported by research grants from NSERC (Canada) and MICRONET -Network Centers of Excellence (Canada). <p> remarks are presented in Section 7. 2 Exploiting the Space of Software-Pipelined Schedules 2.1 An Example We introduce the notion of rate-optimal schedules under resource constraints, and illustrate how to search among them the ones which optimize the register usage with the help of a simple example loop taken from <ref> [18] </ref>. The loop L (in the C language) is: for (i = 0; i &lt; n; i++) f a [i] = s * s * a [i]; The dependence graph for the loop L is depicted in Consider an architecture with 3 pipelined homogeneous function units. <p> For loops involving conditionals, we assume a hardware model that supports predicated execution as in [20]. If-conversion [2] can be performed to support this model. As well, in <ref> [18] </ref> it was shown that predicated execution simplifies code generation after modulo scheduling. 3.1 OPT-T Formulation Let the number of nodes in the DDG be N and let T be the iteration period. <p> 58 13 45 11 40 2 38 FRLC 32 26 20 6 21 30 15 15 Gasperoni 35 23 4 19 29 22 2 20 Table 5: Comparison of ILP performance to 3 Heuristic Methods on Machines with 2-8 Function Units. 6 Related Work Software pipelining has been extensively studied <ref> [4, 6, 11, 17, 22, 18, 9, 22, 23] </ref>, and a variety of techniques have been suggested for finding a good schedule with bounded function units. The readers are referred to [16] for a comprehensive survey. <p> We have compared how the ILP schedules perform against these three scheduling methods in Section 5.2. The FPS compiler [17], the Cydra 5 compiler, Cydrix T M Fortran [4], and the HP-PA compiler [15] are production compilers based on heuristic methods implementing resource-constrained software pipelining. Rau et al. <ref> [18] </ref> have addressed the problem of register allocation for modulo scheduled loops. In their method register allocation is performed on already scheduled loops. Different code generation schema for modulo scheduled loops have been discussed in [19].
Reference: [19] <author> B. R. Rau, M. S. Schlansker, and P. P. Tirumalai. </author> <title> Code generation schema for modulo scheduled loops. </title> <booktitle> In Proc. of the 25th Ann. Intl. Symp. on Microarchi-tecture, </booktitle> <pages> pages 158-169, </pages> <address> Portland, OR, </address> <month> Dec. </month> <pages> 1-4, </pages> <year> 1992. </year>
Reference-contexts: Rau et al. [18] have addressed the problem of register allocation for modulo scheduled loops. In their method register allocation is performed on already scheduled loops. Different code generation schema for modulo scheduled loops have been discussed in <ref> [19] </ref>. In [14], a Petri net based approach to Software pipelin-ing loops in the presence of resource constraints has been presented. Ebcioglu et al. have proposed the technique of enhanced software pipelining with resource constraints [5].
Reference: [20] <author> B. R. Rau, D. W. L. Yen, W. Yen, and R. A. Towle. </author> <title> The Cydra 5 departmental supercomputer. </title> <journal> Computer, </journal> <volume> 22(1) </volume> <pages> 12-35, </pages> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: We do not discuss this possibility in this paper though the proposed techniques can be easily extended to those cases as well. These conceptual FIFO buffers can either be di-rectly implemented using dedicated architecture features such as circular buffers or rotating registers <ref> [20] </ref>, or be mapped to physical registers (with appropriate register moves) on conventional architectures as described in [11, 13]. <p> Huff found that a large majority of loops contain no conditionals [9], and hence we have concentrated in this paper on straightline code. For loops involving conditionals, we assume a hardware model that supports predicated execution as in <ref> [20] </ref>. If-conversion [2] can be performed to support this model. As well, in [18] it was shown that predicated execution simplifies code generation after modulo scheduling. 3.1 OPT-T Formulation Let the number of nodes in the DDG be N and let T be the iteration period.
Reference: [21] <author> R. Reiter. </author> <title> Scheduling parallel computations. </title> <journal> J. of the ACM, </journal> <volume> 15(4) </volume> <pages> 590-599, </pages> <month> Oct. </month> <year> 1968. </year>
Reference-contexts: T dep , is given by: T dep = max 8cycles C d (C) where d (C) is the sum of the delays (or latencies) of the instructions (or nodes) in cycle C of the dependence graph, and m (C) is the sum of the dependence distances around cycle C <ref> [21] </ref>. Those cycles C crit with minimum value of d (C crit ) m (C crit ) are termed critical cycles of the graph. In our example graph, (refer to Fig. 1), the self loops on instructions s 0 and s 2 are both critical cycles. <p> In this paper we focus on the periodic schedule form T i + t s discussed in Section 2. For the periodic schedule to be feasible <ref> [21] </ref>: t j t i d i T m ij ; 8 (i; j) 2 E (1) These constraints are referred as dependency constraints. For any schedule to be feasible they must satisfy the dependency constraints.
Reference: [22] <author> R. F. Touzeau. </author> <title> A Fortran compiler for the FPS-164 scientific computer. </title> <booktitle> In Proc. of the SIGPLAN '84 Symp. on Compiler Construction, </booktitle> <pages> pages 48-57, </pages> <address> Montreal, Que., </address> <month> Jun. </month> <pages> 17-22, </pages> <year> 1984. </year>
Reference-contexts: 1 Introduction Software pipelining <ref> [1, 4, 9, 11, 12, 13, 17, 18, 22] </ref> has been proposed as an efficient method for loop schedul fl This work was supported by research grants from NSERC (Canada) and MICRONET -Network Centers of Excellence (Canada). <p> 58 13 45 11 40 2 38 FRLC 32 26 20 6 21 30 15 15 Gasperoni 35 23 4 19 29 22 2 20 Table 5: Comparison of ILP performance to 3 Heuristic Methods on Machines with 2-8 Function Units. 6 Related Work Software pipelining has been extensively studied <ref> [4, 6, 11, 17, 22, 18, 9, 22, 23] </ref>, and a variety of techniques have been suggested for finding a good schedule with bounded function units. The readers are referred to [16] for a comprehensive survey.
Reference: [23] <author> J. Wang, C. Eisenbeis, M. Jourdan, and B. Su. </author> <title> DEcomposed Software Pipelining: A new approach to exploit instruction-level parallelism for loop programs. Res. </title> <type> Rep. </type> <institution> RR-1838, INRIA-Rocquencourt, France, </institution> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Further improvement in execution time is possible by developing a special purpose solver tailored to our formulation. Question 2, the "So what?" question, has been addressed by comparing our method with 3 other approaches, Huff's Slack Scheduling [9], Wang, Eisen-beis, Jourdan and Su's FRLC variant of DESP-Decomposed Software Pipelining <ref> [23] </ref>, and Gasper-oni and Schwiegelshohn's modified list scheduling approach [6]. We have implemented the above three heuristic methods in our experimental scheduling testbed. We have measured the performance of various scheduling methods on a set of 27 kernel loops taken from various benchmark programs. <p> In more than 14% of the cases, our ILP approach yielded schedules requiring fewer buffers than Huff's Slack Scheduling. ILP schedules are faster than the Slack Schedules in more than 10% of the cases. Compared to either the FRLC method <ref> [23] </ref> or the Gasperoni's modified list scheduling, our ILP schedules are faster in more than 50% of the cases. <p> Our results indicate otherwise. Using our 27 benchmark loops, we measured how well our approach compares with 3 leading heuristic methods on machines with from 2-8 function units. The 3 heuristics are Huff's Slack Scheduling [9], Wang, Eisenbeis, Jourdan and Su's FRLC <ref> [23] </ref>, and Gasperoni and Schwiegelshohn's modified list scheduling [6]. Our implementation of these heuristic methods are based on the details given in the respective references. <p> 58 13 45 11 40 2 38 FRLC 32 26 20 6 21 30 15 15 Gasperoni 35 23 4 19 29 22 2 20 Table 5: Comparison of ILP performance to 3 Heuristic Methods on Machines with 2-8 Function Units. 6 Related Work Software pipelining has been extensively studied <ref> [4, 6, 11, 17, 22, 18, 9, 22, 23] </ref>, and a variety of techniques have been suggested for finding a good schedule with bounded function units. The readers are referred to [16] for a comprehensive survey. <p> He reported extremely good results in addressing the OPT problem. Other heuristic-based scheduling methods have been proposed by Wang et al <ref> [23] </ref>, and Gasperoni and Schwiegelshohn [6]. We have compared how the ILP schedules perform against these three scheduling methods in Section 5.2.
Reference: [24] <author> N. J. Warter, S. A. Mahlke, W.. Hwu, and B. Ra-makrishna Rau. </author> <title> Reverse If-Conversion. </title> <booktitle> In Proc. of the SIGPLAN '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 290-299, </pages> <address> Albu-querque, NM, </address> <month> Jun. </month> <pages> 23-25, </pages> <year> 1993. </year>
Reference-contexts: In [14], a Petri net based approach to Software pipelin-ing loops in the presence of resource constraints has been presented. Ebcioglu et al. have proposed the technique of enhanced software pipelining with resource constraints [5]. Related work in scheduling graphs in the presence of conditionals have been reported in <ref> [24] </ref>. In [10], Hwang et al. proposed an ILP formulation for scheduling acyclic graphs. 7 Conclusions In this paper we have proposed a method to construct software pipelined schedules that use minimum buffers and run at the fastest iteration rate for the given resource constraints.
References-found: 24

