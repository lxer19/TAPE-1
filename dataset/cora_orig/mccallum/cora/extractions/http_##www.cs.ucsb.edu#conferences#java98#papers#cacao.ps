URL: http://www.cs.ucsb.edu/conferences/java98/papers/cacao.ps
Refering-URL: http://www.cs.ucsb.edu/conferences/java98/program.html
Root-URL: http://www.cs.ucsb.edu
Title: Monitors and Exceptions: How to implement Java efficiently  
Author: Andreas Krall and Mark Probst 
Web: http://www.complang.tuwien.ac.at/andi/ http://www.unix.cslab.tuwien.ac.at/~schani/  
Address: Argentinierstrae 8 A-1040 Wien  
Affiliation: Institut fur Computersprachen Technische Universitat Wien  
Abstract: Efficient implementation of monitors and exceptions is crucial for the performance of Java. One implementation of threads showed a factor of 30 difference in run time on some benchmark programs. This article describes an efficient implementation of monitors for Java as used in the CACAO just-in-time compiler. With this implementation the thread overhead is less than 40% for typical application programs and can be completely eliminated for some applications. This article also gives the implementation details of the new exception handling scheme in CACAO. The new approach reduces the size of the generated native code by a half and allows null pointers to be checked by hardware. By using these techniques, the CACAO system has become the fastest JavaVM implementation for the Alpha processor. 
Abstract-found: 1
Intro-found: 1
Reference: [AG96] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Java's <ref> [AG96] </ref> main success as a programming language results from its role as an Internet programming language through the machine independent distribution of programs with the Java virtual machine [LY96].
Reference: [BRE92] <author> Brian N. Bershad, David D. Redell, and John R. Ellis. </author> <title> Fast mutual exclusion for uniprocessors. </title> <booktitle> In Annual Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 223-233. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1992. </year>
Reference-contexts: This library is a user-level implementation which need no support from the operating system. A very popular library of user-level primitives for implementing threads is QuickThreads by David Keppel, described in [Kep93]. Bershad et al. present a fast mechanism for mutual exclusion on uniprocessor systems <ref> [BRE92] </ref>. They have a software solution for the implementation of an atomic test-and-set operation which is faster than the corresponding hardware instruction.
Reference: [CFLM92] <author> Don Cameron, Paul Faust, Dmitry Lenkov, and Michey Mehta. </author> <title> A portable implementation of C++ exception handling. </title> <booktitle> In C++ Technical Conference, </booktitle> <pages> pages 225-243. </pages> <publisher> USENIX, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: The first method has been used in portable implementations of exception handling for C++ <ref> [CFLM92] </ref> or Ada [GMB94] using setjmp and longjmp. A linked exception handling data structure is created when entering a try block and the structure is discarded when leaving the protected block. Java requires precise exceptions.
Reference: [GMB94] <author> E. W. Giering, Frank Mueller, and T. P. Baker. </author> <title> Features of the Gnu Ada runtime library. </title> <booktitle> In TRI-Ada '94, </booktitle> <pages> pages 93-103. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: The first method has been used in portable implementations of exception handling for C++ [CFLM92] or Ada <ref> [GMB94] </ref> using setjmp and longjmp. A linked exception handling data structure is created when entering a try block and the structure is discarded when leaving the protected block. Java requires precise exceptions.
Reference: [HGH96] <author> Cheng-Hsueh A. Hsieh, John C. Gyllen-haal, and Wen-mei W. Hwu. </author> <title> Java bytecode to native code translation: The Caffeine prototype and preliminary results. </title> <booktitle> In 29th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO'29), </booktitle> <year> 1996. </year>
Reference-contexts: Register allocation afterwards uses local variables instead of stack locations. The SUN JDK represents an object by a cell with two pointers: the first points to the instance data of the object, the second to the class descriptor <ref> [HGH96] </ref>. CA 1 CAO's representation eliminates one unnecessary indi-rection [KG97]. The object itself contains the pointer to the class descriptor and the instance data.
Reference: [Jav97] <institution> Java threads whitepaper. </institution> <address> http://java. sun.com/, </address> <year> 1997. </year>
Reference-contexts: Sun's first implementation of the JavaVM on Solaris was based on user-level threads. The current implementation uses a combination of kernel and user-level threads. Some of the advantages of this approach are outlined in <ref> [Jav97] </ref>. The freely available JavaVM implementation kaffe by Tim Wilkinson uses user-level threads [Wil97]. Until version 0.9, each object contained the complete mu-tex data structure. This enabled a fast monitor implementation but used a lot more memory than necessary.
Reference: [Jig97] <author> Jigsaw. </author> <note> http://www.w3.org/Jigsaw/, 1997. </note>
Reference-contexts: Execution of this program takes only a few seconds using Cacao with threads disabled. Biss is a more or less typical working session with the Java development environment of the Biss-AWT [Meh97]. It is slightly multithreaded. Jigsaw invokes the HTTP server Jigsaw <ref> [Jig97] </ref> of the World Wide Web Consortium and lets it serve identical parallel requests from seven hosts, amounting to about one megabyte split across 200 files 3 Application Objects allocated Objects with mutex Monitor operations Parallel Mutexes javac 111504 13695 840292 5 Biss 84939 13357 1058901 12 Jigsaw 215411 23804 855691
Reference: [Kep93] <author> David Keppel. </author> <title> Tools and techniques for building fast portable threads packages. </title> <type> Technical Report UWCSE 93-05-06, </type> <institution> University of Washington, </institution> <year> 1993. </year> <month> 9 </month>
Reference-contexts: In [Mue93], Mueller describes a library implementation of POSIX threads on a standard UNIX system. This library is a user-level implementation which need no support from the operating system. A very popular library of user-level primitives for implementing threads is QuickThreads by David Keppel, described in <ref> [Kep93] </ref>. Bershad et al. present a fast mechanism for mutual exclusion on uniprocessor systems [BRE92]. They have a software solution for the implementation of an atomic test-and-set operation which is faster than the corresponding hardware instruction.
Reference: [KG97] <author> Andreas Krall and Reinhard Grafl. </author> <title> CA--CAO a 64 bit JavaVM just-in-time compiler. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 9(11) </volume> <pages> 1017-1030, </pages> <year> 1997. </year>
Reference-contexts: Faster implementations are possible using just-in-time compilers which translate Java byte code on demand into native code. We developed such a JIT-based JavaVM system called CACAO, which is described in <ref> [KG97] </ref>. CACAO is freely available via the world wide web. Conventional compilers are designed for producing highly optimized code without paying much attention to their compile time performance. The design goals of Java just-in-time compilers are different: they must produce fast code in the smallest possible compilation time. <p> Register allocation afterwards uses local variables instead of stack locations. The SUN JDK represents an object by a cell with two pointers: the first points to the instance data of the object, the second to the class descriptor [HGH96]. CA 1 CAO's representation eliminates one unnecessary indi-rection <ref> [KG97] </ref>. The object itself contains the pointer to the class descriptor and the instance data. <p> A JavaVM interpreter can easily interpret this structure and dispatch to the corresponding handler code. If the byte code is translated to native code, the equivalent technique is more complicated. To simplify restoration of the registers, the old CACAO implementation used a different scheme <ref> [KG97] </ref>. A method has two return values: the real return value and an exception value stored in a register. After each method call, the exception register is checked and, if it is non-zero, the exception handling code is executed.
Reference: [KS90] <author> Andrew Koenig and Bjarne Stroustrup. </author> <title> Exception handling for C++. </title> <journal> Journal of Object Oriented Programming, </journal> <volume> 3(2) </volume> <pages> 16-33, </pages> <month> July/August </month> <year> 1990. </year>
Reference-contexts: The data structure can be used to store such information. The disadvantage of this method is that creating and discarding of the data structure takes some time even if an exception is never raised. The second method has been suggested for an efficient exception handling implementation of C++ <ref> [KS90] </ref> and is used in Java implementations. For every method, the JavaVM maintains an exception table. This exception table contains the program counter of the start and the end of the try block, the program counter of the exception handler and the type of the exception.
Reference: [LY96] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Java's [AG96] main success as a programming language results from its role as an Internet programming language through the machine independent distribution of programs with the Java virtual machine <ref> [LY96] </ref>. Additional reasons for its success are: * easy to use object-oriented language * security and safety (bound checks and exception handling) * support for multithreading * integrated garbage collection Some of these features of Java can decrease the performance of Java applications drastically if implemented in the wrong way.
Reference: [Meh97] <author> Peter Mehlitz. </author> <title> Biss AWT. </title> <address> http://www. biss-net.com/biss-awt.html, </address> <year> 1997. </year>
Reference-contexts: Execution of this program takes only a few seconds using Cacao with threads disabled. Biss is a more or less typical working session with the Java development environment of the Biss-AWT <ref> [Meh97] </ref>. It is slightly multithreaded.
Reference: [Mue93] <author> Frank Mueller. </author> <title> A library implementation of POSIX threads under UNIX. </title> <booktitle> In Winter USENIX, </booktitle> <pages> pages 29-41, </pages> <address> San Diego, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: This enabled a fast monitor implementation but used a lot more memory than necessary. Apart from thread implementations used in JavaVM's there are many other thread standards and implementations, the most notable being the IEEE POSIX extension [POS96]. In <ref> [Mue93] </ref>, Mueller describes a library implementation of POSIX threads on a standard UNIX system. This library is a user-level implementation which need no support from the operating system. A very popular library of user-level primitives for implementing threads is QuickThreads by David Keppel, described in [Kep93].
Reference: [POS96] <institution> Standard for threads interface to POSIX. IEEE, P1003.1c, </institution> <year> 1996. </year>
Reference-contexts: Until version 0.9, each object contained the complete mu-tex data structure. This enabled a fast monitor implementation but used a lot more memory than necessary. Apart from thread implementations used in JavaVM's there are many other thread standards and implementations, the most notable being the IEEE POSIX extension <ref> [POS96] </ref>. In [Mue93], Mueller describes a library implementation of POSIX threads on a standard UNIX system. This library is a user-level implementation which need no support from the operating system. A very popular library of user-level primitives for implementing threads is QuickThreads by David Keppel, described in [Kep93].
Reference: [PTB + 97] <author> Todd A. Proebsting, Gregg Townsend, Patrick Bridges, John H. Hartman, Tim Newsham, and Scott A. Watterson. Toba: </author> <title> Java for applications. </title> <type> Technical report, </type> <institution> University of Arizona, </institution> <address> Tucson, AZ, </address> <year> 1997. </year>
Reference-contexts: To answer this question, we have used a modified version of kaffe to gather statistics about monitor usage. The results are summarized in table 2. Javac is an invocation of Sun's javac on the Toba source files <ref> [PTB + 97] </ref> and is thus single-threaded. Execution of this program takes only a few seconds using Cacao with threads disabled. Biss is a more or less typical working session with the Java development environment of the Biss-AWT [Meh97]. It is slightly multithreaded.
Reference: [Sta95] <author> William Stallings. </author> <title> Operating Systems. </title> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference-contexts: Monitors are usually implemented using mutex (mutual exclusion). A mutex is a data structure which contains the necessary information to guarantee that only one unit of execution can perform a critical section at the same time <ref> [Sta95] </ref>. As we show in section 2.4 a fast implementation of the synchronization mechanism is crucial for the efficiency of Java.
Reference: [Wil97] <author> Tim Wilkinson. KAFFE: </author> <title> A free virtual machine to run Java code. </title> <note> http: //www.kaffe.org, 1997. 10 </note>
Reference-contexts: Sun's first implementation of the JavaVM on Solaris was based on user-level threads. The current implementation uses a combination of kernel and user-level threads. Some of the advantages of this approach are outlined in [Jav97]. The freely available JavaVM implementation kaffe by Tim Wilkinson uses user-level threads <ref> [Wil97] </ref>. Until version 0.9, each object contained the complete mu-tex data structure. This enabled a fast monitor implementation but used a lot more memory than necessary. Apart from thread implementations used in JavaVM's there are many other thread standards and implementations, the most notable being the IEEE POSIX extension [POS96]. <p> Cacao's current implementation of threads is based mainly on the threading code of kaffe version 0.7, which has been released under a BSD-style license and can thus be used freely <ref> [Wil97] </ref>. As mentioned above, kaffe's threads are completely user-level, which means, for example, that they cannot take advantage of a multiprocessor system. There are several reasons why we chose this approach: * Thread support differs from operating system to operating system.
References-found: 17

