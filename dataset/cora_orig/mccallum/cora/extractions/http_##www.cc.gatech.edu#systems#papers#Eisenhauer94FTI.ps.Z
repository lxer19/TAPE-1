URL: http://www.cc.gatech.edu/systems/papers/Eisenhauer94FTI.ps.Z
Refering-URL: http://www.cs.gatech.edu/systems/projects/FALCON/
Root-URL: 
Title: Falcon Toward Interactive Parallel Programs: The On-line Steering of a Molecular Dynamics Application From Proceedings
Author: Greg Eisenhauer Weiming Gu Karsten Schwan Niru Mallavarupu 
Address: Atlanta, GA 30332  
Affiliation: College of Computing Georgia Institute of Technology  
Date: August 1994  
Pubnum: (HPDC-3)  
Abstract: This paper focuses on the opportunities and costs of on-line steering as applied to a substantial parallel application. We demonstrate potential performance improvements through the use of the Falcon system, an experimental system for the on-line monitoring and steering of parallel programs. The visual presentation of program output along with animated displays of program performance information via Falcon's monitoring system enables the on-line capture, analysis, and display of program information required for program steering. Falcon also provides the mechanisms for the manipulations of program state that accomplish this online steering. 
Abstract-found: 1
Intro-found: 1
Reference: [Bru91] <author> Bernd Bruegge. </author> <title> A portable platform for dis tributed event environments. </title> <booktitle> In ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <address> Santa Cruz, </address> <pages> pages 184-193, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Regardless of the speed and nature of interaction, program steering is based on the on-line capture of information defining current program and configuration state <ref> [Bru91, MW91, OSS93] </ref>, and it assumes that human users or algorithms inspect such information and manipulate it to make steering decisions.
Reference: [BS91] <author> T. Bihari and K. Schwan. </author> <title> Dynamic adaptation of real-time software. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 143-174, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The program steering addressed by our work encompasses rapid, on-line program changes that require built-in, custom monitoring and on-line algorithms determining and enacting such changes (e.g., in research addressing configurable operating systems [MS93]). It also includes gradual changes to long-running real-time programs <ref> [BS91] </ref> and scientific applications able to interact at human speeds via user interfaces, such as the application presented in this paper.
Reference: [ES94] <author> Greg Eisenhauer and Karsten Schwan. </author> <title> Md a flexible framework for high-speed parallel molecular dynamics. In High Performance Computing, </title> <booktitle> Proceedings of the 1994 SCS Simulation Multiconference, </booktitle> <pages> pages 70-75. </pages> <institution> Society for Computer Simulation, Society for Computer Simulation, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: Cthreads also gives users the flexibility to design and use thread primitives customized to their applications. The Falcon monitoring and steering system is strongly, but not inseparably, tied to Cthreads. 3.1 General performance Normative comparisons of the KSR-1 MD code and basic speedup results are presented in <ref> [ES94] </ref>. They demonstrate performance similar to what is attained with comparable Fortran codes running on a Cray Y-MP and the KSR-1 itself. Speedup results show continuing improvements even for large numbers of processors (up to 60 on our KSR-1 machine). <p> As an example of how sensitive program behavior can be to variations of these parameters, consider the performance differences between two slightly different styles of establishing the boundaries between spatial domains. To achieve the better performance numbers in <ref> [ES94] </ref>, we did not rely strictly on geometry to establish the domain boundaries. Instead we allowed the boundaries to shift slightly in either direction in order to balance the number of molecules assigned to each domain. We call this balancing the decomposition.
Reference: [GS89] <author> Prabha Gopinath and Karsten Schwan. </author> <title> Chaos: Why one cannot have only an operating system for real-time applications. </title> <journal> SIGOPS Notices, </journal> <pages> pages 106-125, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Examples of this include the rapid automatic configuration of small program fragments for maintaining real-time response in uniprocessor systems [MP89], the on-line adaptation of functional program components for realizing reliability/performance tradeoffs in parallel and real-time applications <ref> [GS89] </ref>, and load balancing or program configuration for enhanced reliability in distributed systems [MW91]. Performance gains can also be realized from the manipulation of specific program attributes during execution.
Reference: [KS91] <author> Carol Kilpatrick and Karsten Schwan. </author> <title> Chaos mon - application-specific monitoring and display of performance information for parallel and distributed systems. </title> <booktitle> In ACM Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 57-67. </pages> <booktitle> ACM SIGPLAN Notices, </booktitle> <volume> Vol. 26, No. 12, </volume> <month> May </month> <year> 1991. </year>
Reference-contexts: The library offers the ability to adhere to specific timing constraints regarding the on-line execution of monitoring and visualization code with respect to the execution of an application's core computations. In addition, Falcon offers a sensor language <ref> [KS91] </ref> with which program-dependent monitoring attributes may be stated and implemented. A higher-level view language and configuration language and library support are being developed for support of large-scale program monitoring and display. <p> As a result, users can easily construct just the monitoring views they desire <ref> [KS91] </ref>, in addition to or instead of the default views provided with the system. This capability is especially important for end users who wish to debug and steer their parallel applications using views concerning their output data, then adjusting attributes like `time step size', etc.
Reference: [KSO90] <author> Carol Kilpatrick, Karsten Schwan, and David Ogle. </author> <title> Using languages for describing capture, analysis, and display of performance in formation for parallel and distributed applications. </title> <booktitle> In International Conference on Computer Languages `90, </booktitle> <address> New Orleans, </address> <pages> pages 180-189. </pages> <publisher> IEEE, </publisher> <month> March </month> <year> 1990. </year>
Reference-contexts: Falcon supports program steering by permitting the on-line alteration of configuration attributes. Future work will permit the association of monitoring attributes with steering algorithms that automatically change configuration attributes when triggered by monitoring events. We previously developed language primitives for stating high-level monitoring specifications <ref> [KSO90] </ref>. The current implementation of Falcon focuses on developing runtime library support in order to investigate effective parallelizations of monitoring activities as well as using alternative methods for monitoring.
Reference: [LMC88] <author> T. Leblanc and J. Mellor-Crummey. </author> <title> De bugging parallel programs with instant replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C(36), </volume> <month> April </month> <year> 1988. </year>
Reference-contexts: A higher-level view language and configuration language and library support are being developed for support of large-scale program monitoring and display. An easy-to-use system for inclusion of custom sensors with user code will also be part of the Falcon tool. A major advantage of Falcon over other monitoring systems <ref> [LMC88, MCH + 90] </ref> and tools like Paragraph is its ability to accept user-specifications that state what and how monitoring should be performed for a specific user program.
Reference: [MCH + 90] <author> Barton P. Miller, Morgan Clark, Jeff Hol lingsworth, Steven Kirstead, Sek-See Lim, and Timothy Torzewski. Ips-2: </author> <title> The second generation of a parallel program measurement system. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(2) </volume> <pages> 206-217, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: A higher-level view language and configuration language and library support are being developed for support of large-scale program monitoring and display. An easy-to-use system for inclusion of custom sensors with user code will also be part of the Falcon tool. A major advantage of Falcon over other monitoring systems <ref> [LMC88, MCH + 90] </ref> and tools like Paragraph is its ability to accept user-specifications that state what and how monitoring should be performed for a specific user program.
Reference: [MP89] <author> Henry Massalin and Calton Pu. </author> <title> Threads and input/output in the synthesis kernel. </title> <booktitle> In Proceedings of the 12th Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201. </pages> <publisher> SIGOPS, Assoc. Comput. Mach., </publisher> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: System- or program-specific on-line algorithms select and enact program or system changes to provide one type of performance advantage. Examples of this include the rapid automatic configuration of small program fragments for maintaining real-time response in uniprocessor systems <ref> [MP89] </ref>, the on-line adaptation of functional program components for realizing reliability/performance tradeoffs in parallel and real-time applications [GS89], and load balancing or program configuration for enhanced reliability in distributed systems [MW91]. Performance gains can also be realized from the manipulation of specific program attributes during execution.
Reference: [MS93] <author> Bodhisattwa Mukherjee and Karsten Schwan. </author> <title> Improving performance by use of adaptive objects: Experimentation with a configurable multiprocessor thread package. </title> <booktitle> In Proc. of Second International Symposium on High Performance Distributed Computing (HPDC-2), </booktitle> <pages> pages 59-66, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: The program steering addressed by our work encompasses rapid, on-line program changes that require built-in, custom monitoring and on-line algorithms determining and enacting such changes (e.g., in research addressing configurable operating systems <ref> [MS93] </ref>). It also includes gradual changes to long-running real-time programs [BS91] and scientific applications able to interact at human speeds via user interfaces, such as the application presented in this paper. <p> Examples of environment changes include the balancing of system loads in order to guarantee acceptable rates of progress to different program components, or the configuration of operating system or even communication protocol components to tailor their functionality to different phases of a program's execution <ref> [MS93] </ref>. A final form that program steering may take is to have users direct their computations towards "inter-esting" or "meaningful" subdomains. Many current large scale computations create immense quantities of data, but only a fraction of that data may be relevant to the phenomenon being studied.
Reference: [MW91] <author> Keith Marzullo and Mark Wood. </author> <title> Making real time systems reactive. </title> <journal> ACM Operating Systems Review, </journal> <volume> 25(1), </volume> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: Regardless of the speed and nature of interaction, program steering is based on the on-line capture of information defining current program and configuration state <ref> [Bru91, MW91, OSS93] </ref>, and it assumes that human users or algorithms inspect such information and manipulate it to make steering decisions. <p> Examples of this include the rapid automatic configuration of small program fragments for maintaining real-time response in uniprocessor systems [MP89], the on-line adaptation of functional program components for realizing reliability/performance tradeoffs in parallel and real-time applications [GS89], and load balancing or program configuration for enhanced reliability in distributed systems <ref> [MW91] </ref>. Performance gains can also be realized from the manipulation of specific program attributes during execution.
Reference: [OSS93] <author> D.M. Ogle, K. Schwan, and R. Snodgrass. </author> <title> Application-dependent dynamic monitoring of distributed and parallel systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4(7) </volume> <pages> 762-778, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Regardless of the speed and nature of interaction, program steering is based on the on-line capture of information defining current program and configuration state <ref> [Bru91, MW91, OSS93] </ref>, and it assumes that human users or algorithms inspect such information and manipulate it to make steering decisions.
Reference: [Sta91] <author> John T. Stasko. </author> <title> Using direct manipulation to build algorithm animations by demonstration. </title> <booktitle> In Proceedings of the ACM SIGCHI '91 Conference on Human Factors in Computing Systems, </booktitle> <address> New Orleans, </address> <pages> pages 307-314, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Toward this end, we use standard graphical tools, such as X windows and Motif for Falcon's graphical displays, and we use existing tools such as Polka <ref> [Sta91] </ref> for program animation. 4.2 Performance understanding Falcon offers a default "thread lifetime" view of a thread program that is invaluable for understanding and evaluating the performance of the MD code.
Reference: [XORL92] <author> T. K. Xia, Jian Ouyang, M. W. Ribarsky, and Uzi Landman. </author> <title> Interfacial alkane films. </title> <journal> Physical Review Letters, </journal> <volume> 69(13) </volume> <pages> 1967-1970, </pages> <month> 28 September </month> <year> 1992. </year> <month> 8 </month>
Reference-contexts: this paper we examine a molecular dynamics application in which domain decompositions can be changed interactively in order to adjust processor loads and improve performance under changing experimental conditions. 2.2 The parallel MD code MD is an interactive molecular dynamics simulation used to explore the statistical mechanics of complex liquids <ref> [XORL92] </ref>. The specific physical system modeled is a time-stepped simulation of the behavior of hydrocarbon chains on a fixed substrate. The dominant computational requirement is the calculation of long-range forces between particles, but other required computations with different characteristics also affect the application's structure and behavior. <p> The resulting overheads are moderate for fairly coarse decompositions (e.g., 100-1000 particles per process) but unacceptable for finer grain decompositions (e.g., 10 particles per process). Our simulated system is used by physicists at Georgia Tech <ref> [XORL92] </ref> to investigate evolutionary trends of the structure and dynamics of n-hexadecane (C 16 -H 34 ) films on a crystalline substrate modeling Au (001).
References-found: 14

