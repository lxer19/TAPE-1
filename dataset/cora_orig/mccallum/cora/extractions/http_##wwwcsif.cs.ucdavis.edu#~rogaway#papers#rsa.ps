URL: http://wwwcsif.cs.ucdavis.edu/~rogaway/papers/rsa.ps
Refering-URL: http://seclab.cs.ucdavis.edu/papers.html
Root-URL: http://www.cs.ucdavis.edu
Email: e-mail: mihir@watson.ibm.com  e-mail: rogaway@cs.ucdavis.edu  
Title: A New Suggestion for How to Encrypt with RSA  
Author: Mihir Bellare Phillip Rogaway 
Address: PO Box 704, Yorktown Heights, NY 10598, USA.  CA 95616, USA.  
Affiliation: Laboratory, IBM T.J. Watson Research Center,  Department of Computer Science, University of California at Davis, Davis,  
Date: October 18, 1994  
Note: Earlier version appears as "Optimal Asymmetric Encryption" in Advances in Cryptology Eurocrypt '94. Lecture Notes in Computer Science, Springer-Verlag (1994).  Advanced Networking  
Abstract: Given an arbitrary k-bit to k-bit trapdoor permutation f and a hash function, we exhibit an encryption scheme for which (i) any string x of length slightly less than k bits can be encrypted as f(r x ), where r x is a simple probabilistic encoding of x depending on the hash function; and (ii) the scheme can be proven semantically secure assuming the hash function is "ideal." Moreover, a slightly enhanced scheme is shown to have the property that the adversary can create ciphertexts only of strings for which she "knows" the corresponding plaintexts|such a scheme is not only semantically secure but also non-malleable and secure against chosen-ciphertext attack. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Bellare, J. Kilian and P. Rogaway, </author> <title> "On the security of cipher-block chaining," </title> <booktitle> Proceedings of Crypto 94. </booktitle>
Reference-contexts: Goldwasser and Micali [11] first suggested encrypting a message by probabilistically encrypting each of its bits: if B f denotes a hard core predicate [5, 26, 10] for the trapdoor permutation f , then 3 Exact security is not new: previous works which address it explicitly include <ref> [10, 14, 23, 16, 8, 1] </ref>. <p> We call twice this quantity the advantage which A has in predicting b. Multiplying by two makes the advantage fall in the range <ref> [0; 1] </ref> (0 for a worthless prediction and 1 for an always correct one), instead of [0; 0:5]. Definition 3.1 Let G be a generator for an encryption scheme having plaintext-length function n ().
Reference: [2] <author> M. Bellare and P. Rogaway, </author> <title> "Random oracles are practical: a paradigm for designing efficient protocols," </title> <booktitle> Proceedings of the First Annual Conference on Computer and Communications Security, ACM, </booktitle> <year> 1993. </year>
Reference-contexts: In practice, G and H are best derived from some standard cryptographic hash function. (For example, they can be derived from the compression function of the Secure Hash Algorithm [18] following the methods described in <ref> [2] </ref>). 1.2 The plaintext-aware scheme A variety of goals for encryption have come to be known which are actually stronger than the notion of [11]. These include non-malleability [7] and chosen ciphertext security. <p> In this regard we are following the paradigm of <ref> [2] </ref> who argue that even though results which assume an ideal hash function do not provide provable security with respect to the standard model of computation, assuming an ideal hash function and doing proofs with respect to it provides much greater assurance benefit than purely ad. hoc. protocol design. <p> Indeed whether or not [22, 15] "work" depends on aspects of f beyond its being one-way, insofar as it is easy to show that if there exists a trapdoor permutation then there exists one for which encryption as above is completely insecure. 4 In <ref> [2] </ref> we suggested the scheme E G and proved it semantically secure in the same ideal-hash model used here. In comparison with the schemes given here, the drawback is that the encryption size is n + k rather than k. Now we turn to stronger goals. <p> Non-malleability is provably achieved by [7], but the scheme is extremely inefficient. An efficient scheme proven in <ref> [2] </ref> to achieve both non-malleability and chosen-ciphertext security under the ideal-hash model is E BR (x) = f (r) k G (r) x k H (rx) : Again the drawback is a bit complexity of n + k + k 1 . 4 But f is mandated to be RSA in <p> The use of "key variants" 1 , 2 and 3 is motivated similarly. Our choice to only use half the bits of SHA has to do with a general "deficiency" in the use of SHA-like hash functions to instantiate random oracles; see <ref> [2] </ref> for a discussion. Acknowledgments We thank Don Johnson for an early discussion on this problem, where he described the method of [15]. We thank Silvio Micali for encouraging us to find and present the exact security of our constructions.
Reference: [3] <author> L. Blum, M. Blum and M. Shub, </author> <title> "A Simple Unpredictable Pseudo-Random Number Generator," </title> <journal> SIAM Journal on Computing 15(2), </journal> <pages> 364-383, </pages> <month> May </month> <year> 1986. </year> <month> 13 </month>
Reference-contexts: In practice, again, G and H are derived from some standard cryptographic hash function. 1.3 Efficiency The function f can be set to any candidate trapdoor permutation such as RSA [21] or modular squaring <ref> [19, 3] </ref>. In such a case the time for computing G and H is negligible compared to the time for computing f; f 1 . Thus complexity is discussed only in terms of f; f 1 computations.
Reference: [4] <author> M. Blum and S. Goldwasser, </author> <title> "An efficient probabilistic public-key encryption scheme which hides all partial information," </title> <booktitle> Advances in Cryptology - Crypto 84 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 196, </volume> <publisher> Springer-Verlag, </publisher> <editor> B. Blakley, ed., </editor> <year> 1985. </year>
Reference-contexts: This yields an encryption of length O (nk) which requires n evaluations of f to encrypt and n evaluation of f 1 to decrypt, which is not practical. The more efficient construction of Blum and Goldwasser <ref> [4] </ref> is based on the particular choice of f as the modular squaring function [19]. They achieve encryption size n + k. They require O (nk 2 = log k) steps to encrypt and O (k 3 ) steps to decrypt. The encryption is longer than ours by n bits.
Reference: [5] <author> M. Blum and S. Micali, </author> <title> "How to generate cryptographically strong sequences of pseudorandom bits," </title> <journal> SIAM Journal on Computing 13(4), </journal> <pages> 850-864, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: Indeed it was exactly such considerations that helped inspire ideas like semantic security [11] and hardcore bits <ref> [5, 26] </ref>. 3 H : f0; 1g n ! f0; 1g k 0 . To encrypt x 2 f0; 1g n choose a random k 0 -bit r and set E G;H (x) = f (x G (r) k r H (x G (r))): Here "k" denotes concatenation. <p> We begin by discussing work on attaining semantic security, and then move on to stronger goals. Goldwasser and Micali [11] first suggested encrypting a message by probabilistically encrypting each of its bits: if B f denotes a hard core predicate <ref> [5, 26, 10] </ref> for the trapdoor permutation f , then 3 Exact security is not new: previous works which address it explicitly include [10, 14, 23, 16, 8, 1].
Reference: [6] <author> I. Damg -ard, </author> <title> "Towards practical public key cryptosystems secure against chosen ciphertext attacks," </title> <booktitle> Advances in Cryptology - Crypto 91 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 576, </volume> <publisher> Springer-Verlag, </publisher> <editor> J. Feigenbaum, ed., </editor> <year> 1991. </year>
Reference-contexts: Now we turn to stronger goals. Chosen-ciphertext security was provably achieved by [17], but the scheme is extremely inefficient. More practical encryption schemes which aimed at achieving chosen ciphertext security were proposed by Damg-ard <ref> [6] </ref> and Zheng and Seberry [27]. The latter scheme is E ZS (x) = f (r) k (G (r) (x k H (x)) ; matching our plaintext-aware scheme in computation but having bit complexity n + k + k 1 .
Reference: [7] <author> D. Dolev, C. Dwork and M. Naor, </author> <title> "Non-malleable cryptography," </title> <booktitle> Proceedings of the Twenty Third Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1991. </year>
Reference-contexts: Our first scheme achieves semantic security [11], while our second scheme achieves a notion of plaintext-aware encryption, which we introduce here. This new notion is very strong, and in particular implies "ambitious" goals like chosen-ciphertext security and non-malleability <ref> [7] </ref> in the ideal-hash model which we assume. The methods of this paper are simple and completely practical. They provide a good starting point for an asymmetric encryption/key distribution standard. Next we describe our schemes and their properties. <p> These include non-malleability <ref> [7] </ref> and chosen ciphertext security. We introduce a new notion of an encryption scheme being plaintext-aware|roughly said, it should be impossible for a party to produce a valid ciphertext without "knowing" the corresponding plaintext (see Section 3 for a precise definition). <p> The latter scheme is E ZS (x) = f (r) k (G (r) (x k H (x)) ; matching our plaintext-aware scheme in computation but having bit complexity n + k + k 1 . Non-malleability is provably achieved by <ref> [7] </ref>, but the scheme is extremely inefficient.
Reference: [8] <author> S. Even, O. Goldreich and S. Micali, </author> <title> "On-line/Off line digital signatures," </title> <type> Manuscript. </type> <note> Preliminary version in Advances in Cryptology - Crypto 89 Proceedings, Lecture Notes in Computer Science Vol. 435, Springer-Verlag, </note> <editor> G. Brassard, ed., </editor> <year> 1989. </year>
Reference-contexts: Goldwasser and Micali [11] first suggested encrypting a message by probabilistically encrypting each of its bits: if B f denotes a hard core predicate [5, 26, 10] for the trapdoor permutation f , then 3 Exact security is not new: previous works which address it explicitly include <ref> [10, 14, 23, 16, 8, 1] </ref>.
Reference: [9] <author> U. Feige, A. Fiat and A. Shamir, </author> <title> "Zero knowledge proofs of identity," </title> <journal> Journal of Cryptology, </journal> <volume> Vol. 1, </volume> <pages> pp. 77-94, </pages> <year> 1987. </year>
Reference-contexts: In formalizing this we have relied on definitional ideas which begin with <ref> [12, 9, 25] </ref>. Our notion requires that some (universal) algorithm K (the "knowledge extractor") can usually decrypt whatever ciphertext an adversary B may output, just by watching the G; H-queries which B makes.
Reference: [10] <author> O. Goldreich and L. Levin, </author> <title> "A hard predicate for all one-way functions," </title> <booktitle> Proceedings of the Twenty First Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1989. </year>
Reference-contexts: We begin by discussing work on attaining semantic security, and then move on to stronger goals. Goldwasser and Micali [11] first suggested encrypting a message by probabilistically encrypting each of its bits: if B f denotes a hard core predicate <ref> [5, 26, 10] </ref> for the trapdoor permutation f , then 3 Exact security is not new: previous works which address it explicitly include [10, 14, 23, 16, 8, 1]. <p> Goldwasser and Micali [11] first suggested encrypting a message by probabilistically encrypting each of its bits: if B f denotes a hard core predicate [5, 26, 10] for the trapdoor permutation f , then 3 Exact security is not new: previous works which address it explicitly include <ref> [10, 14, 23, 16, 8, 1] </ref>.
Reference: [11] <author> S. Goldwasser and S. Micali, </author> <title> "Probabilistic Encryption," </title> <journal> Journal of Computer and System Sciences 28, </journal> <pages> 270-299, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Assuming an ideal hash function and an arbitrary trapdoor permutation, we describe and prove secure two simple-embedding schemes that are bit-optimal (i.e., the length of the string x that can be encrypted by f (r x ) is almost k). Our first scheme achieves semantic security <ref> [11] </ref>, while our second scheme achieves a notion of plaintext-aware encryption, which we introduce here. This new notion is very strong, and in particular implies "ambitious" goals like chosen-ciphertext security and non-malleability [7] in the ideal-hash model which we assume. The methods of this paper are simple and completely practical. <p> The scheme makes use of a "generator" G: f0; 1g k 0 ! f0; 1g n and a "hash function" 1 By a provably-secure scheme we mean here one shown, under some standard complexity-theoretic assumption, to achieve a notion of security at least as strong as semantic security <ref> [11] </ref>. 2 It is well-known that a naive embedding like r x = x is no good: besides the usual deficiencies of any deterministic encryption, f being a trapdoor permutation does not mean that f (x) conceals all the interesting properties of x. <p> Indeed it was exactly such considerations that helped inspire ideas like semantic security <ref> [11] </ref> and hardcore bits [5, 26]. 3 H : f0; 1g n ! f0; 1g k 0 . <p> The formal statement of our result is in Theorem 4.1. It says that if f is a trapdoor permutation and G; H are ideal then the basic scheme achieves the notion of semantic security <ref> [11] </ref> appropriately adjusted to take account of the presence of G; H . <p> some standard cryptographic hash function. (For example, they can be derived from the compression function of the Secure Hash Algorithm [18] following the methods described in [2]). 1.2 The plaintext-aware scheme A variety of goals for encryption have come to be known which are actually stronger than the notion of <ref> [11] </ref>. These include non-malleability [7] and chosen ciphertext security. We introduce a new notion of an encryption scheme being plaintext-aware|roughly said, it should be impossible for a party to produce a valid ciphertext without "knowing" the corresponding plaintext (see Section 3 for a precise definition). <p> In the following, f mapping k-bits to k-bits is the trapdoor permutation. As above, the following assumes the length n of the message to be encrypted is at most k. We begin by discussing work on attaining semantic security, and then move on to stronger goals. Goldwasser and Micali <ref> [11] </ref> first suggested encrypting a message by probabilistically encrypting each of its bits: if B f denotes a hard core predicate [5, 26, 10] for the trapdoor permutation f , then 3 Exact security is not new: previous works which address it explicitly include [10, 14, 23, 16, 8, 1]. <p> Things can be patched in standard ways. 7 3 Semantically Secure Encryption We extend the definition of semantic security <ref> [11] </ref> to the random oracle model in a way which enables us to discuss exact security. 3.1 Encryption schemes An asymmetric (i.e. public key) encryption scheme is specified by a probabilistic generator, G, and an associated plaintext-length function, n (). <p> It captures the notion of semantic security <ref> [11] </ref> appropriately lifted to take into account the presence of G; H. We consider an adversary who runs in two stages. In the find-stage it is given an encryption algorithm E and outputs a pair x 0 ; x 1 of messages.
Reference: [12] <author> S. Goldwasser, S. Micali and C. Rackoff, </author> <title> "The knowledge complexity of interactive proof systems," </title> <journal> SIAM J. of Comp., </journal> <volume> Vol. 18, No. 1, </volume> <pages> 186-208, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: In formalizing this we have relied on definitional ideas which begin with <ref> [12, 9, 25] </ref>. Our notion requires that some (universal) algorithm K (the "knowledge extractor") can usually decrypt whatever ciphertext an adversary B may output, just by watching the G; H-queries which B makes.
Reference: [13] <author> S. Goldwasser, S. Micali and R. Rivest, </author> <title> "A digital signature scheme secure against adaptive chosen-message attacks," </title> <journal> SIAM Journal of Computing, </journal> <volume> 17(2) </volume> <pages> 281-308, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: = f (r) k G (r) x k H (rx) : Again the drawback is a bit complexity of n + k + k 1 . 4 But f is mandated to be RSA in both of [22, 15]. 6 2 Preliminaries 2.1 Probabilistic algorithms We shall use notation of <ref> [13] </ref>. If A is a probabilistic algorithm then A (x; y; ) refers to to the probability space which to the string assigns the probability that A on inputs x; y; outputs .
Reference: [14] <author> R. Impagliazzo, L. Levin and M. Luby, </author> <title> "Pseudo-random generation from one-way functions," </title> <booktitle> Proceedings of the Twenty First Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1989. </year>
Reference-contexts: Goldwasser and Micali [11] first suggested encrypting a message by probabilistically encrypting each of its bits: if B f denotes a hard core predicate [5, 26, 10] for the trapdoor permutation f , then 3 Exact security is not new: previous works which address it explicitly include <ref> [10, 14, 23, 16, 8, 1] </ref>.
Reference: [15] <author> D. Johnson, A. Lee, W. Martin, S. Matyas and J. Wilkins, </author> <title> "Hybrid key distribution scheme giving key record recovery," </title> <journal> IBM Technical Disclosure Bulletin, </journal> <volume> 37(2A), </volume> <pages> 5-16, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Since heuristic schemes achieving these conditions exist <ref> [22, 15] </ref>, if provable security is provided at the cost of violating any of these conditions (e.g., two applications of f to encrypt, message length n + k rather than k) practioners will prefer the heuristic constructions. <p> One example is the RSA Public Key Cryptography Standard #1 [22], where r x in the embedding x 7! r x is essentially x in the low-order bit positions and a string of random non-zero bytes in the remaining bit positions. Another scheme is described in <ref> [15] </ref>; a simplified version of it is E G Of concern with both of these schemes is that there is no compelling reason to believe that x is as hard to compute from f (r x ) as r x is hard to compute from f (r x )|let alone that <p> Indeed whether or not <ref> [22, 15] </ref> "work" depends on aspects of f beyond its being one-way, insofar as it is easy to show that if there exists a trapdoor permutation then there exists one for which encryption as above is completely insecure. 4 In [2] we suggested the scheme E G and proved it semantically <p> both non-malleability and chosen-ciphertext security under the ideal-hash model is E BR (x) = f (r) k G (r) x k H (rx) : Again the drawback is a bit complexity of n + k + k 1 . 4 But f is mandated to be RSA in both of <ref> [22, 15] </ref>. 6 2 Preliminaries 2.1 Probabilistic algorithms We shall use notation of [13]. If A is a probabilistic algorithm then A (x; y; ) refers to to the probability space which to the string assigns the probability that A on inputs x; y; outputs . <p> Acknowledgments We thank Don Johnson for an early discussion on this problem, where he described the method of <ref> [15] </ref>. We thank Silvio Micali for encouraging us to find and present the exact security of our constructions. Thanks also to (anonymous) Eurocrypt reviewers for their comments and corrections. This work was carried out while the second author worked for IBM in Austin, Texas (System Design (Jamil Bissar), PSP LAN Systems).
Reference: [16] <author> T. Leighton and S. Micali, </author> <title> "Provably fast and secure digital signature algorithms based on secure hash functions," </title> <type> Manuscript, </type> <month> March </month> <year> 1993. </year>
Reference-contexts: Goldwasser and Micali [11] first suggested encrypting a message by probabilistically encrypting each of its bits: if B f denotes a hard core predicate [5, 26, 10] for the trapdoor permutation f , then 3 Exact security is not new: previous works which address it explicitly include <ref> [10, 14, 23, 16, 8, 1] </ref>.
Reference: [17] <author> M. Naor and M. Yung, </author> <title> "Public-key cryptosystems provably secure against chosen ci-phertext attacks," </title> <booktitle> Proceedings of the Twenty Second Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1990. </year>
Reference-contexts: In comparison with the schemes given here, the drawback is that the encryption size is n + k rather than k. Now we turn to stronger goals. Chosen-ciphertext security was provably achieved by <ref> [17] </ref>, but the scheme is extremely inefficient. More practical encryption schemes which aimed at achieving chosen ciphertext security were proposed by Damg-ard [6] and Zheng and Seberry [27].
Reference: [18] <institution> National Institute of Standards, </institution> <note> FIPS Publication 180, "Secure Hash Standard," 1993. 14 </note>
Reference-contexts: In practice, G and H are best derived from some standard cryptographic hash function. (For example, they can be derived from the compression function of the Secure Hash Algorithm <ref> [18] </ref> following the methods described in [2]). 1.2 The plaintext-aware scheme A variety of goals for encryption have come to be known which are actually stronger than the notion of [11]. These include non-malleability [7] and chosen ciphertext security. <p> A concrete instantiation of our plaintext-aware scheme (using RSA for f and getting G; H from the Secure Hash Algorithm <ref> [18] </ref>) is given in Section 7. 4 1.4 The ideal hash function paradigm As we indicated above, when proving security we take G; H to be random, and when we want a concrete scheme, G; H are instantiated by primitives derived from a cryptographic hash function. <p> We use RSA as the trapdoor permutation and construct the functions G; H out of the (revised) NIST Secure Hash Algorithm <ref> [18] </ref>. (Other hash algorithms such as MD5 [20] would do as well). Let f be the RSA function [21], so f (x) = x e mod N is specified by (e; N ) where N is the k-bit product of two large primes and (e; '(N )) = 1.
Reference: [19] <author> M. Rabin, </author> <title> "Digitalized signatures and public-key functions as intractable as factorization," </title> <institution> MIT Laboratory for Computer Science TR-212, </institution> <month> January </month> <year> 1979. </year>
Reference-contexts: In practice, again, G and H are derived from some standard cryptographic hash function. 1.3 Efficiency The function f can be set to any candidate trapdoor permutation such as RSA [21] or modular squaring <ref> [19, 3] </ref>. In such a case the time for computing G and H is negligible compared to the time for computing f; f 1 . Thus complexity is discussed only in terms of f; f 1 computations. <p> The more efficient construction of Blum and Goldwasser [4] is based on the particular choice of f as the modular squaring function <ref> [19] </ref>. They achieve encryption size n + k. They require O (nk 2 = log k) steps to encrypt and O (k 3 ) steps to decrypt. The encryption is longer than ours by n bits.
Reference: [20] <author> R. Rivest, </author> <title> "The MD5 message-digest algorithm," IETF Network Working Group, </title> <type> RFC 1321, </type> <month> April </month> <year> 1992. </year>
Reference-contexts: We use RSA as the trapdoor permutation and construct the functions G; H out of the (revised) NIST Secure Hash Algorithm [18]. (Other hash algorithms such as MD5 <ref> [20] </ref> would do as well). Let f be the RSA function [21], so f (x) = x e mod N is specified by (e; N ) where N is the k-bit product of two large primes and (e; '(N )) = 1.
Reference: [21] <author> R. Rivest, A. Shamir and L. Adleman, </author> <title> "A method for obtaining digital signatures and public key cryptosystems," </title> <note> CACM 21 (1978). </note>
Reference-contexts: In practice, again, G and H are derived from some standard cryptographic hash function. 1.3 Efficiency The function f can be set to any candidate trapdoor permutation such as RSA <ref> [21] </ref> or modular squaring [19, 3]. In such a case the time for computing G and H is negligible compared to the time for computing f; f 1 . Thus complexity is discussed only in terms of f; f 1 computations. <p> RSA <ref> [21] </ref> is a good candidate function as a secure trapdoor permutation. 5 5 Candidates like RSA [21] don't quite fit our definition, in that the domain of RSA is some Z fl N , a proper subset of of f0; 1g k . <p> RSA <ref> [21] </ref> is a good candidate function as a secure trapdoor permutation. 5 5 Candidates like RSA [21] don't quite fit our definition, in that the domain of RSA is some Z fl N , a proper subset of of f0; 1g k . <p> We use RSA as the trapdoor permutation and construct the functions G; H out of the (revised) NIST Secure Hash Algorithm [18]. (Other hash algorithms such as MD5 [20] would do as well). Let f be the RSA function <ref> [21] </ref>, so f (x) = x e mod N is specified by (e; N ) where N is the k-bit product of two large primes and (e; '(N )) = 1. We demand k 512 bits (larger values are recommended).
Reference: [22] <author> RSA Data Security, Inc., </author> <title> "PKCS #1: RSA Encryption Standard," </title> <month> June </month> <year> 1991. </year>
Reference-contexts: Since heuristic schemes achieving these conditions exist <ref> [22, 15] </ref>, if provable security is provided at the cost of violating any of these conditions (e.g., two applications of f to encrypt, message length n + k rather than k) practioners will prefer the heuristic constructions. <p> But it is not known to have a trapdoor and hence is not usable for the problem we are considering. What we have called simple-embedding schemes are prevalent in computing practice. One example is the RSA Public Key Cryptography Standard #1 <ref> [22] </ref>, where r x in the embedding x 7! r x is essentially x in the low-order bit positions and a string of random non-zero bytes in the remaining bit positions. <p> Indeed whether or not <ref> [22, 15] </ref> "work" depends on aspects of f beyond its being one-way, insofar as it is easy to show that if there exists a trapdoor permutation then there exists one for which encryption as above is completely insecure. 4 In [2] we suggested the scheme E G and proved it semantically <p> both non-malleability and chosen-ciphertext security under the ideal-hash model is E BR (x) = f (r) k G (r) x k H (rx) : Again the drawback is a bit complexity of n + k + k 1 . 4 But f is mandated to be RSA in both of <ref> [22, 15] </ref>. 6 2 Preliminaries 2.1 Probabilistic algorithms We shall use notation of [13]. If A is a probabilistic algorithm then A (x; y; ) refers to to the probability space which to the string assigns the probability that A on inputs x; y; outputs .
Reference: [23] <author> C. Schnorr, </author> <title> "Efficient identification and signatures for smart cards," </title> <booktitle> Advances in Cryptology - Crypto 89 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 435, </volume> <publisher> Springer-Verlag, </publisher> <editor> G. Brassard, ed., </editor> <year> 1989. </year>
Reference-contexts: Goldwasser and Micali [11] first suggested encrypting a message by probabilistically encrypting each of its bits: if B f denotes a hard core predicate [5, 26, 10] for the trapdoor permutation f , then 3 Exact security is not new: previous works which address it explicitly include <ref> [10, 14, 23, 16, 8, 1] </ref>.
Reference: [24] <author> A. Schrift and A. Shamir, </author> <title> "The discrete log is very discreet," </title> <booktitle> Proceedings of the Twenty Second Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1990. </year>
Reference-contexts: Their decryption time is a constant factor more than ours. Of course the above two schemes have the advantage of being based only on standard assumptions, not the use of an ideal hash function. The discrete log function simultaneously hides a constant fraction of the bits of its pre-image <ref> [24] </ref>. But it is not known to have a trapdoor and hence is not usable for the problem we are considering. What we have called simple-embedding schemes are prevalent in computing practice.
Reference: [25] <author> M. Tompa and H. Woll, </author> <title> "Random self-reducibility and zero-knowledge interactive proofs of possession of information," </title> <type> UCSD TR CS92-244, </type> <year> 1992. </year>
Reference-contexts: In formalizing this we have relied on definitional ideas which begin with <ref> [12, 9, 25] </ref>. Our notion requires that some (universal) algorithm K (the "knowledge extractor") can usually decrypt whatever ciphertext an adversary B may output, just by watching the G; H-queries which B makes.
Reference: [26] <author> A. Yao, </author> <title> "Theory and applications of trapdoor functions," </title> <booktitle> Proceedings of the Twenty Third Annual Symposium on the Foundations of Computer Science, IEEE, </booktitle> <year> 1982. </year>
Reference-contexts: Indeed it was exactly such considerations that helped inspire ideas like semantic security [11] and hardcore bits <ref> [5, 26] </ref>. 3 H : f0; 1g n ! f0; 1g k 0 . To encrypt x 2 f0; 1g n choose a random k 0 -bit r and set E G;H (x) = f (x G (r) k r H (x G (r))): Here "k" denotes concatenation. <p> We begin by discussing work on attaining semantic security, and then move on to stronger goals. Goldwasser and Micali [11] first suggested encrypting a message by probabilistically encrypting each of its bits: if B f denotes a hard core predicate <ref> [5, 26, 10] </ref> for the trapdoor permutation f , then 3 Exact security is not new: previous works which address it explicitly include [10, 14, 23, 16, 8, 1].
Reference: [27] <author> Y. Zheng and J. Seberry, </author> <title> "Practical approaches to attaining security against adaptively chosen ciphertext attacks," </title> <booktitle> Advances in Cryptology - Crypto 92 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 740, </volume> <publisher> Springer-Verlag, </publisher> <editor> E. Brickell, ed., </editor> <year> 1992. </year>
Reference-contexts: Now we turn to stronger goals. Chosen-ciphertext security was provably achieved by [17], but the scheme is extremely inefficient. More practical encryption schemes which aimed at achieving chosen ciphertext security were proposed by Damg-ard [6] and Zheng and Seberry <ref> [27] </ref>. The latter scheme is E ZS (x) = f (r) k (G (r) (x k H (x)) ; matching our plaintext-aware scheme in computation but having bit complexity n + k + k 1 . Non-malleability is provably achieved by [7], but the scheme is extremely inefficient.
References-found: 27

