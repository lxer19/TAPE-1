URL: http://www.cs.purdue.edu/homes/palsberg/paper/ecoop92.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: alf@daimi.aau.dk palsberg@daimi.aau.dk mis@daimi.aau.dk  
Title: Making Type Inference Practical  
Author: Nicholas Oxhtj Jens Palsberg Michael I. Schwartzbach 
Keyword: Type inference, implementation, collection classes, tools, Smalltalk.  
Address: Ny Munkegade, DK-8000 -Arhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Note: In Proc. ECOOP'92, Springer-Verlag (LNCS 615), pages 329-349.  
Abstract: We present the implementation of a type inference algorithm for untyped object-oriented programs with inheritance, assignments, and late binding. The algorithm significantly improves our previous one, presented at OOPSLA'91, since it can handle collection classes, such as List, in a useful way. Also, the complexity has been dramatically improved, from exponential time to low polynomial time. The implementation uses the techniques of incremental graph construction and constraint template instantiation to avoid representing intermediate results, doing superfluous work, and recomputing type information. Experiments indicate that the implementation type checks as much as 100 lines pr. second. This results in a mature product, on which a number of tools can be based, for example a safety tool, an image compression tool, a code optimization tool, and an annotation tool. This may make type inference for object-oriented languages practical. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alan H. Borning and Daniel H. H. Ingalls. </author> <title> A type declaration and inference system for Smalltalk. </title> <booktitle> In Ninth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 133-141, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction The basic purpose of doing type inference for untyped object-oriented programs is to guarantee that all messages are understood <ref> [1] </ref>. At OOPSLA'91 we presented a type inference algorithm for an untyped object-oriented language with inheritance, assignments, and late binding [17]. The algorithm can type check many common programs, including those with polymorphic and recursive methods. It can not, however, infer types in programs that use collection classes.
Reference: [2] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In Gilles Kahn, David MacQueen, and Gordon Plotkin, editors, </editor> <booktitle> Semantics of Data Types, </booktitle> <pages> pages 51-68. </pages> <publisher> Springer-Verlag (LNCS 173), </publisher> <year> 1984. </year>
Reference-contexts: Note that our notion of type, which we also investigated in [18, 17, 19], differs from those used in other theoretical studies of types in object-oriented programming <ref> [3, 7, 2] </ref> and related record-calculi [21, 26]. In the following section we show an algorithm to infer such type information. The algorithm works even for programs with collection classes. 3 The Algorithm We now review the type inference algorithm presented in [17].
Reference: [3] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Note that our notion of type, which we also investigated in [18, 17, 19], differs from those used in other theoretical studies of types in object-oriented programming <ref> [3, 7, 2] </ref> and related record-calculi [21, 26]. In the following section we show an algorithm to infer such type information. The algorithm works even for programs with collection classes. 3 The Algorithm We now review the type inference algorithm presented in [17].
Reference: [4] <author> William Cook and Jens Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <journal> Information and Computation, </journal> <volume> 114(2) </volume> <pages> 329-350, </pages> <year> 1994. </year> <note> Also in Proc. </note> <editor> OOPSLA'89, </editor> <booktitle> ACM SIGPLAN 24 Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 433-443, </pages> <address> New Orleans, Louisiana, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: The time for computing a solution is quadratic in the size of the global constraints. 9 In [17] we sketched a proof of the soundness of the solution with respect to a dynamic semantics <ref> [4, 5, 20, 14, 12] </ref>. The global constraints for the example program are solvable; hence, the example program is typable.
Reference: [5] <author> William R. Cook. </author> <title> A Denotational Semantics of Inheritance. </title> <type> PhD thesis, </type> <institution> Brown University, </institution> <year> 1989. </year>
Reference-contexts: The time for computing a solution is quadratic in the size of the global constraints. 9 In [17] we sketched a proof of the soundness of the solution with respect to a dynamic semantics <ref> [4, 5, 20, 14, 12] </ref>. The global constraints for the example program are solvable; hence, the example program is typable.
Reference: [6] <author> Ole-Johan Dahl, Bjtrn Myhrhaug, and Kristen Nygaard. </author> <title> Simula 67 common base language. </title> <type> Technical report, </type> <institution> Norwegian Computing Center, Oslo, Norway, </institution> <year> 1968. </year>
Reference-contexts: Instead the inferred type of a receiver can be examined to determine if the message send is safe. If not, then a dynamic check can be inserted before the method lookup (similarly to the qua checks of Simula <ref> [6] </ref> and Beta [15]). This selective approach may greatly reduce the number of required checks, compared to Simula and Beta implementations.
Reference: [7] <author> Scott Danforth and Chris Tomlinson. </author> <title> Type theories and object-oriented programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 20(1) </volume> <pages> 29-72, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Note that our notion of type, which we also investigated in [18, 17, 19], differs from those used in other theoretical studies of types in object-oriented programming <ref> [3, 7, 2] </ref> and related record-calculi [21, 26]. In the following section we show an algorithm to infer such type information. The algorithm works even for programs with collection classes. 3 The Algorithm We now review the type inference algorithm presented in [17].
Reference: [8] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80|The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: In section 4 we demonstrate how the implementation works, and in section 5 we summarize the tools that we either have built or envision, on the basis of our implementation. 2 The Language We now outline an example language on which to apply our algorithm. The language resembles Smalltalk <ref> [8] </ref>, see figure 1, and is taken from our previous paper [17]. (Program) P :: = C 1 . . . C n E (Class) C :: = class ClassId [inherits ClassId] var Id 1 . . . Id k M 1 . . .
Reference: [9] <author> Justin O. Graver and Ralph E. Johnson. </author> <title> A type system for Smalltalk. </title> <booktitle> In Seventeenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 136-150, </pages> <year> 1990. </year>
Reference-contexts: Suzuki [24] was the first to address the problem of type inference for such a language; his algorithm was not capable of checking most common programs, however. Later, Graver and Johnson <ref> [10, 9] </ref> provided an algorithm for a simplified problem, where the types of instance variables must be specified by programmer so that only the types of arguments are to be inferred. Recently, Hense [11] addressed the problem of inferring types that are useful in connection with separate compilation.
Reference: [10] <author> Justin Owen Graver. </author> <title> Type-Checking and Type-Inference for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> August </month> <year> 1989. </year> <month> UIUCD-R-89-1539. </month>
Reference-contexts: Suzuki [24] was the first to address the problem of type inference for such a language; his algorithm was not capable of checking most common programs, however. Later, Graver and Johnson <ref> [10, 9] </ref> provided an algorithm for a simplified problem, where the types of instance variables must be specified by programmer so that only the types of arguments are to be inferred. Recently, Hense [11] addressed the problem of inferring types that are useful in connection with separate compilation.
Reference: [11] <author> Andreas V. Hense. </author> <title> Polymorphic type inference for a simple object oriented programming language with state. </title> <type> Technical Report No. </type> <institution> A 20/90, Fachbericht 14, Universitat des Saarlandes, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: Later, Graver and Johnson [10, 9] provided an algorithm for a simplified problem, where the types of instance variables must be specified by programmer so that only the types of arguments are to be inferred. Recently, Hense <ref> [11] </ref> addressed the problem of inferring types that are useful in connection with separate compilation. This means that his algorithm is not allowed to reconsider the program text when new classes are added to the program. <p> Thus, we really only perform type inference on the subset of the example language that does not use inheritance. This approach is common to all previous algorithms, except the one presented in <ref> [11] </ref>. The well-known insight is that inheritance is a technique for reusing untyped code, and thus an inherited method can be used in completely unexpected contexts in a subclass. Much better typings can be obtained by considering such a method twice|once for the superclass and once for the subclass. <p> This results in the duplication of type variables; in general, more type variables will improve the chances for typability, and the inferred types will be more precise. The algorithm in <ref> [11] </ref> pays a price for not expanding inheritance; it can type fewer programs. The actual expansion is a simple syntactic transformation on program texts. It is illustrated in figure 3. Note that methods are duplicated and renamed, and that care must be taken in connection with self and super.
Reference: [12] <author> Andreas V. Hense. </author> <title> Wrapper semantics of an object-oriented programming language with state. </title> <editor> In T. Ito and A. R. Meyer, editors, </editor> <booktitle> Proc. Theoretical Aspects of Computer Software, </booktitle> <pages> pages 548-568. </pages> <publisher> Springer-Verlag (LNCS 526), </publisher> <year> 1991. </year>
Reference-contexts: The time for computing a solution is quadratic in the size of the global constraints. 9 In [17] we sketched a proof of the soundness of the solution with respect to a dynamic semantics <ref> [4, 5, 20, 14, 12] </ref>. The global constraints for the example program are solvable; hence, the example program is typable.
Reference: [13] <author> Urs Holzle, Craig Chambers, and David Ungar. </author> <title> Optimizing dynamically-typed object-oriented languages with polymorphic inline caches. </title> <booktitle> In Proc. ECOOP'91, Fifth European Conference on Object-Oriented Programming, </booktitle> <pages> pages 21-38, </pages> <year> 1991. </year>
Reference-contexts: This simplifies the code for dynamic method lookups. More significantly, the inferred type of a receiver corresponds closely to the information contained in a polymorphic in-line cache (PIC) employed by Holzle, Chambers, and Ungar <ref> [13] </ref> to greatly improve efficiency. This information approximates the set of all possible non-nil values to which the receiver expression may evaluate in any execution of the program. Our inferred 17 types yield sets that are slightly too large. Using PICs one obtain sets that are slightly too small.
Reference: [14] <author> Samuel Kamin. </author> <title> Inheritance in Smalltalk-80: A denotational definition. </title> <booktitle> In Fifteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 80-87, </pages> <year> 1988. </year>
Reference-contexts: The time for computing a solution is quadratic in the size of the global constraints. 9 In [17] we sketched a proof of the soundness of the solution with respect to a dynamic semantics <ref> [4, 5, 20, 14, 12] </ref>. The global constraints for the example program are solvable; hence, the example program is typable.
Reference: [15] <author> Bent B. Kristensen, Ole Lehrmann Madsen, Birger Mtller-Pedersen, and Kristen Nygaard. </author> <title> The BETA programming language. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 7-48. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Instead the inferred type of a receiver can be examined to determine if the message send is safe. If not, then a dynamic check can be inserted before the method lookup (similarly to the qua checks of Simula [6] and Beta <ref> [15] </ref>). This selective approach may greatly reduce the number of required checks, compared to Simula and Beta implementations.
Reference: [16] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: These can safely be removed, since we are sure that they will never be invoked. Note that this technique of image compression is useful also for typed object-oriented languages such as C++ [23] and Eiffel <ref> [16] </ref>. 5.3 Code Optimization Tool When a safety guarantee is issued, then the run-time checks for message-not-understood can be left out. This simplifies the code for dynamic method lookups.
Reference: [17] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proc. OOPSLA'91, ACM SIGPLAN Sixth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 146-161, </pages> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The basic purpose of doing type inference for untyped object-oriented programs is to guarantee that all messages are understood [1]. At OOPSLA'91 we presented a type inference algorithm for an untyped object-oriented language with inheritance, assignments, and late binding <ref> [17] </ref>. The algorithm can type check many common programs, including those with polymorphic and recursive methods. It can not, however, infer types in programs that use collection classes. A collection class is used to contain different instances in different parts of the program. <p> The language resembles Smalltalk [8], see figure 1, and is taken from our previous paper <ref> [17] </ref>. (Program) P :: = C 1 . . . C n E (Class) C :: = class ClassId [inherits ClassId] var Id 1 . . . Id k M 1 . . . <p> The expression "self class new" yields an instance of the class of self. The expression "E instanceOf ClassId" yields a run-time check for class membership. If the check fails, then the expression evaluates to nil. In the paper <ref> [17] </ref> we demonstrated how to program the classes True, False, Natural, and List is this basic language. Suzuki [24] was the first to address the problem of type inference for such a language; his algorithm was not capable of checking most common programs, however. <p> Recently, Hense [11] addressed the problem of inferring types that are useful in connection with separate compilation. This means that his algorithm is not allowed to reconsider the program text when new classes are added to the program. The comparison in <ref> [17] </ref> demonstrates that this demand leads to the rejection of more programs than does our algorithm. It remains to be seen if the two approaches can be combined. <p> We want the set to be as small as possible; smaller sets are more precise, lead to the acceptance of more program, and yield more efficient code generation. Note that our notion of type, which we also investigated in <ref> [18, 17, 19] </ref>, differs from those used in other theoretical studies of types in object-oriented programming [3, 7, 2] and related record-calculi [21, 26]. In the following section we show an algorithm to infer such type information. <p> In the following section we show an algorithm to infer such type information. The algorithm works even for programs with collection classes. 3 The Algorithm We now review the type inference algorithm presented in <ref> [17] </ref>. This section can serve both as a brief summary for those who want to appreciate the refinements presented in the following section, and as a gentle introduction for those who want to read the original paper. <p> The details of this result are presented in <ref> [17] </ref>. Note how this technique can manage to untangle the recursive dependencies mentioned above. In the limit a condition will either hold or not, and every type variable will attain some value. If no solution exists, then a special error value will be the result of the computation. <p> If no solution exists, then a special error value will be the result of the computation. The time for computing a solution is quadratic in the size of the global constraints. 9 In <ref> [17] </ref> we sketched a proof of the soundness of the solution with respect to a dynamic semantics [4, 5, 20, 14, 12]. The global constraints for the example program are solvable; hence, the example program is typable. <p> new]] = fAg [[(A new) m: (B new)]] = [[e n]] = [[temp]] = [[temp p]] 1 = fg The remaining type variables have no constraints imposed on them; consequently they attain the value fg in the minimal solution. 3.7 Collection Classes So far, we have described the algorithm in <ref> [17] </ref> It can find typings for many different kinds of programs: polymorphic methods, recursive methods, and late binding pose no problem. It does, however, have a fatal flaw that renders it next to useless in a practical context: each instance variable has only a single associated type variable. <p> In figure 17 none of the classes are treated as collection classes. This corresponds to running the previous algorithm from the OOPSLA'91 paper <ref> [17] </ref>. Note that one of the programs cannot be type checked with this algorithm. In figure 18 all classes are treated as collection classes. This gives slower running times, but better typings; for example, the program "Container class" can now be type checked.
Reference: [18] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> What is type-safe code reuse? In Proc. </title> <booktitle> ECOOP'91, Fifth European Conference on Object-Oriented Programming, </booktitle> <pages> pages 325-341. </pages> <publisher> Springer-Verlag (LNCS 512), </publisher> <address> Geneva, Switzerland, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: We want the set to be as small as possible; smaller sets are more precise, lead to the acceptance of more program, and yield more efficient code generation. Note that our notion of type, which we also investigated in <ref> [18, 17, 19] </ref>, differs from those used in other theoretical studies of types in object-oriented programming [3, 7, 2] and related record-calculi [21, 26]. In the following section we show an algorithm to infer such type information.
Reference: [19] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Static typing for object-oriented programming. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 23(1) </volume> <pages> 19-53, </pages> <year> 1994. </year>
Reference-contexts: We want the set to be as small as possible; smaller sets are more precise, lead to the acceptance of more program, and yield more efficient code generation. Note that our notion of type, which we also investigated in <ref> [18, 17, 19] </ref>, differs from those used in other theoretical studies of types in object-oriented programming [3, 7, 2] and related record-calculi [21, 26]. In the following section we show an algorithm to infer such type information.
Reference: [20] <author> Uday S. Reddy. </author> <title> Objects as closures: Abstract semantics of object-oriented languages. </title> <booktitle> In Proc. ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 289-297, </pages> <year> 1988. </year>
Reference-contexts: The time for computing a solution is quadratic in the size of the global constraints. 9 In [17] we sketched a proof of the soundness of the solution with respect to a dynamic semantics <ref> [4, 5, 20, 14, 12] </ref>. The global constraints for the example program are solvable; hence, the example program is typable.
Reference: [21] <author> Didier Remy. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> In Sixteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 77-88, </pages> <year> 1989. </year>
Reference-contexts: Note that our notion of type, which we also investigated in [18, 17, 19], differs from those used in other theoretical studies of types in object-oriented programming [3, 7, 2] and related record-calculi <ref> [21, 26] </ref>. In the following section we show an algorithm to infer such type information. The algorithm works even for programs with collection classes. 3 The Algorithm We now review the type inference algorithm presented in [17].
Reference: [22] <author> Michael I. Schwartzbach. </author> <title> Type inference with inequalities. </title> <booktitle> In Proc. TAPSOFT'91, </booktitle> <pages> pages 441-455. </pages> <publisher> Springer-Verlag (LNCS 493), </publisher> <year> 1991. </year>
Reference-contexts: The general idea is to define a type variable [[E]] for every expression E occurring in the program <ref> [25, 22] </ref>. We then generate a collection of constraints on these variables. Finally, we attempt to solve these constraints. If they are solvable, then their minimal solution corresponds to the inferred typing; if not, then the program is not typable.
Reference: [23] <author> Bjarne Stroustrup. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: When this has been done for all message sends, then some unmarked methods will remain. These can safely be removed, since we are sure that they will never be invoked. Note that this technique of image compression is useful also for typed object-oriented languages such as C++ <ref> [23] </ref> and Eiffel [16]. 5.3 Code Optimization Tool When a safety guarantee is issued, then the run-time checks for message-not-understood can be left out. This simplifies the code for dynamic method lookups.
Reference: [24] <author> Norihisa Suzuki. </author> <title> Inferring types in Smalltalk. </title> <booktitle> In Eighth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 187-199, </pages> <year> 1981. </year> <month> 25 </month>
Reference-contexts: The expression "E instanceOf ClassId" yields a run-time check for class membership. If the check fails, then the expression evaluates to nil. In the paper [17] we demonstrated how to program the classes True, False, Natural, and List is this basic language. Suzuki <ref> [24] </ref> was the first to address the problem of type inference for such a language; his algorithm was not capable of checking most common programs, however.
Reference: [25] <author> Mitchell Wand. </author> <title> A simple algorithm and proof for type inference. </title> <journal> Fundamentae Informaticae, </journal> <volume> X:115--122, </volume> <year> 1987. </year>
Reference-contexts: The general idea is to define a type variable [[E]] for every expression E occurring in the program <ref> [25, 22] </ref>. We then generate a collection of constraints on these variables. Finally, we attempt to solve these constraints. If they are solvable, then their minimal solution corresponds to the inferred typing; if not, then the program is not typable.
Reference: [26] <author> Mitchell Wand. </author> <title> Type inference for record concatenation and multiple inheritance. </title> <booktitle> In LICS'89, Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 92-97, </pages> <year> 1989. </year> <month> 26 </month>
Reference-contexts: Note that our notion of type, which we also investigated in [18, 17, 19], differs from those used in other theoretical studies of types in object-oriented programming [3, 7, 2] and related record-calculi <ref> [21, 26] </ref>. In the following section we show an algorithm to infer such type information. The algorithm works even for programs with collection classes. 3 The Algorithm We now review the type inference algorithm presented in [17].
References-found: 26

