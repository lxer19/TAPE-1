URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/elf-papers/caap96.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/elf-papers/INDEX.html
Root-URL: http://www.cs.cmu.edu
Email: fp@cs.cmu.edu  
Title: The Practice of Logical Frameworks  
Author: Frank Pfenning 
Date: April 1996  
Address: CAAP'96, Linkoping, Sweden,  Pittsburgh, PA 15213-3891  
Affiliation: of  Department of Computer Science Carnegie Mellon University  
Note: To appear in the proceedings  
Abstract-found: 0
Intro-found: 1
Reference: [AHMP92] <author> Arnon Avron, Furio A. Honsell, Ian A. Mason, and Robert Pollack. </author> <title> Using typed lambda calculus to implement formal systems on a machine. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 9(3) </volume> <pages> 309-354, </pages> <year> 1992. </year> <note> A preliminary version appeared as University of Edinburgh Report ECS-LFCS-87-31. </note>
Reference-contexts: Applications of LF have been numerous, first with pencil and paper <ref> [HHP93, AHMP92] </ref>, then in the context of the Elf language which implements LF (see Section 5). A significant challenge in the area of meta-representation are modal and other non-local side conditions in the formulation of deductive systems, as they occur, for example, in the presentation of linear logic.
Reference: [ALS94] <author> Jurgen Avenhaus and Carlos Lora-Saenz. </author> <title> Higher order conditional rewriting and narrowing. </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Proceedings of the First International Conference on Constraints in Computational Logics, </booktitle> <pages> pages 269-284, </pages> <address> Munich, Germany, </address> <month> September </month> <year> 1994. </year> <note> Springer-Verlag LNCS 845. </note>
Reference-contexts: Building equations into the representation of syntax has been recognized as a significant challenge and investigated in the context of logical frameworks by [Nip91] with a rapidly increasing literature regarding its operational properties <ref> [ALS94, Kah95, LP95, Pre95] </ref>. Finally, substitutions are often used in informal developments.
Reference: [And93] <author> Penny Anderson. </author> <title> Program Derivation by Proof Transformation. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> October </month> <year> 1993. </year> <note> Available as Technical Report CMU-CS-93-206. </note>
Reference-contexts: They can still be executed due to the computational interpretation of meta-language Elf via logic programming search. This technique has been applied in a number of case studies such as program derivation <ref> [And93, And94a, And94b] </ref>, type preservation [MP91], compiler verification [HP92a], CPS conversion [DP95], partial evaluation [Hat95], theorem proving [Pfe92b], the Church-Rosser theorem [Pfe92c], and cut elimination [Pfe95].
Reference: [And94a] <author> Penny Anderson. </author> <title> Program extraction in a logical framework setting. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Proceedings of the 5th International Conference on Logic Programming and Automated Reasoning, </booktitle> <pages> pages 144-158, </pages> <address> Kiev, Ukraine, July 1994. </address> <publisher> Springer-Verlag LNAI 822. </publisher>
Reference-contexts: They can still be executed due to the computational interpretation of meta-language Elf via logic programming search. This technique has been applied in a number of case studies such as program derivation <ref> [And93, And94a, And94b] </ref>, type preservation [MP91], compiler verification [HP92a], CPS conversion [DP95], partial evaluation [Hat95], theorem proving [Pfe92b], the Church-Rosser theorem [Pfe92c], and cut elimination [Pfe95].
Reference: [And94b] <author> Penny Anderson. </author> <title> Representing proof transformations for program optimization. </title> <booktitle> In Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 575-589, </pages> <address> Nancy, France, June 1994. </address> <publisher> Springer-Verlag LNAI 814. </publisher>
Reference-contexts: They can still be executed due to the computational interpretation of meta-language Elf via logic programming search. This technique has been applied in a number of case studies such as program derivation <ref> [And93, And94a, And94b] </ref>, type preservation [MP91], compiler verification [HP92a], CPS conversion [DP95], partial evaluation [Hat95], theorem proving [Pfe92b], the Church-Rosser theorem [Pfe92c], and cut elimination [Pfe95].
Reference: [BC93] <author> David A. Basin and Robert L. Constable. </author> <title> Metalogical frameworks. </title> <editor> In G. Huet and G. Plotkin, editors, </editor> <booktitle> Logical Environments, </booktitle> <pages> pages 1-29. </pages> <publisher> Cam-bridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: The interested reader is referred to [MOM93, KKV93, Hab94]. Another approach derives from the notion of labelled deductive system due to Gabbay [Gab94]. Here the meta-logic is a classical logic with equality [Gab93]. Two further notes on terminology. Some researchers distinguish logical frameworks from meta-logical frameworks <ref> [BC93] </ref>, the latter being intended as a meta-language for reasoning about deductive systems rather than within them. Clearly, the latter is more general, since meta-logical frameworks must first provide means for specifying deductive systems before one can reason about them. <p> This cannot be considered as an inductive type, because of the negative occurrence of exp in the type of lam. An attempt to formulate a valid induction principle for the type exp fails. Several options have been explored to escape this dilemma. The first, for example used in <ref> [BC93, Fef88, MN94, Pol95] </ref> is to reject the notion of higher-order abstract syntax and use inductive representations directly. This is engenders a complication of the encoding and consequently of the meta-theory, which now has to deal with many lemmas regarding variable naming.
Reference: [BHN + 94] <author> Manfred Broy, Ursula Hinkel, Tobias Nipkow, Christian Prehofer, and Bir-git Schieder. </author> <title> Interpreter verification for a functional language. In P.S. </title> <editor> Thiagarajan, editor, </editor> <booktitle> Proceedings of the 14th Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 77-88. </pages> <publisher> Springer-Verlag LNCS 880, </publisher> <year> 1994. </year>
Reference-contexts: Many experiments have been carried out following this methodology, including type inference [Pfe88], equational reasoning [Nip89], theorem proving [Fel89], functional programming [HM90, Han93], specification languages [MM93], VLSI design [Ros92], set theory [Pau93, Noe93], interpreter verification <ref> [BHN + 94] </ref> and the Church-Rosser theorem [Nip95, Ras95]. However, in many applications we need to go a step further and design a representation of derivations themselves as objects in the meta-language. A natural first choice for this representation is also the simply-typed -calculus.
Reference: [C + 86] <author> Robert L. Constable et al. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1986. </year>
Reference-contexts: On the one hand, this led to a number of systems for constructive mathematics and the extraction of functional programs from constructive proofs (for example, Nuprl <ref> [C + 86, CH90] </ref>, LEGO [Pol94], and Coq [DFH + 93]). On the other hand, it strongly influenced the design of LF [HHP93], also called the Edinburgh Logical Framework (ELF). <p> Tactics and Tacticals provide a popular mechanism to structure and program search. Tactics and tacticals arose out of the LCF theorem proving effort [GMW79, Pau83] and are used in such diverse systems as NuPrl <ref> [C + 86] </ref>, Coq [DFH + 93], Isabelle [NP92], and Prolog [NM88, Fel93]. In all but the last 6 one, they are programmed in ML which was originally developed to support theorem proving for LCF. Logic programming offers a different approach to meta-programming.
Reference: [Cer96] <author> Iliano Cervesato. </author> <title> A Linear Logical Framework. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Torino, </institution> <year> 1996. </year> <month> Forthcoming. </month>
Reference-contexts: This hiatus has recently come to a close with implementations of frameworks based on inductive definitions such as FS0 [Fef88, MSB93] and ALF [Mag95], partial inductive definitions [Hal91, Eri93, Eri94] and substructural logics <ref> [SH91, Gir93, Mil94, Cer96] </ref>. There is a different approach to logical frameworks based on equational rather than deductive reasoning. While one can be interpreted in the other without much difficulty, the meta-languages based on equational reasoning take a rather different form and we will not discuss them here. <p> A higher-order classical linear meta-logic to address some of these problems has been proposed by Miller [Mil94], a conservative extension of LF by Cervesato <ref> [Cer96] </ref>. Implemen 5 tation projects for these languages have just begun. Besides linear and related logics, these frameworks also enable a whole new class of languages to be represented concisely, namely those involving state and concurrency [Chi95]. Also relevant is the work on labelled deductive systems [Gab93, Gab94].
Reference: [CH90] <author> Robert Constable and Douglas Howe. </author> <title> NuPrl as a general logic. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic and Computation. </booktitle> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: On the one hand, this led to a number of systems for constructive mathematics and the extraction of functional programs from constructive proofs (for example, Nuprl <ref> [C + 86, CH90] </ref>, LEGO [Pol94], and Coq [DFH + 93]). On the other hand, it strongly influenced the design of LF [HHP93], also called the Edinburgh Logical Framework (ELF).
Reference: [Chi95] <author> Jawahar Lal Chirimar. </author> <title> Proof Theoretic Approach to Specification Languages. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: Implemen 5 tation projects for these languages have just begun. Besides linear and related logics, these frameworks also enable a whole new class of languages to be represented concisely, namely those involving state and concurrency <ref> [Chi95] </ref>. Also relevant is the work on labelled deductive systems [Gab93, Gab94]. Another challenge is the development of appropriate structuring principles to achieve modular presentation of deductive systems. This has been studied in the abstract [HST94] and in the context of the Elf language [HP92b], but only prototype implementations exist.
Reference: [CNSvS94] <author> Thierry Coquand, Bengt Nordstrom, Jan M. Smith, and Bjorn von Sydow. </author> <title> Type theory and programming. </title> <journal> Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> 52 </volume> <pages> 203-228, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Since all primitive recursive functionals are total (which we prove once and for all), the required y is thus guaranteed to exist. An extension of this idea beyond primitive recursion to general pattern matching (without the notion of higher-order abstract syntax) has been explored in the ALF system <ref> [Mag95, MN94, Coq92, CNSvS94] </ref>. The empirical evidence suggests that this shortens developments considerably [Coq92] and also allows the formulations of functions in a manner which is closer to functional programming practice. Adding such functions to the simply-typed -calculus or LF still leads to inadequate encodings.
Reference: [Con94] <author> Robert L. Constable. </author> <title> Using reflection to explain and enhance type theory. In Proof and Computation, </title> <booktitle> NATO ASI Series. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The granularity and efficiency of reasoning in such explicit encodings is generally too low to allow complex developments|we must look for ways to incorporate equational theories directly into the underlying meta-logic or type theory without sacrificing decidability and other desirable properties. Some promising work in this direction includes reflection <ref> [Con94] </ref> and dependently typed rewriting [Vir95]. 4 Search and Meta-Programming The representation of a deductive system in a logical framework may be used for a variety of purposes. The obvious application is to construct derivations within a deductive system, with the support of the framework implementation.
Reference: [Coq92] <author> Catarina Coquand. </author> <title> A proof of normalization for simply typed lambda calculus written in ALF. </title> <booktitle> In Proceedings of the Workshop on Types for Proofs and Programs, </booktitle> <pages> pages 85-92, </pages> <address> B-astad, Sweden, </address> <year> 1992. </year>
Reference-contexts: Since all primitive recursive functionals are total (which we prove once and for all), the required y is thus guaranteed to exist. An extension of this idea beyond primitive recursion to general pattern matching (without the notion of higher-order abstract syntax) has been explored in the ALF system <ref> [Mag95, MN94, Coq92, CNSvS94] </ref>. The empirical evidence suggests that this shortens developments considerably [Coq92] and also allows the formulations of functions in a manner which is closer to functional programming practice. Adding such functions to the simply-typed -calculus or LF still leads to inadequate encodings. <p> An extension of this idea beyond primitive recursion to general pattern matching (without the notion of higher-order abstract syntax) has been explored in the ALF system [Mag95, MN94, Coq92, CNSvS94]. The empirical evidence suggests that this shortens developments considerably <ref> [Coq92] </ref> and also allows the formulations of functions in a manner which is closer to functional programming practice. Adding such functions to the simply-typed -calculus or LF still leads to inadequate encodings.
Reference: [dB72] <author> N. G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: In informal practice we pervasively use the so-called variable convention, that is, we identify expressions that differ only in the names assigned to their bound variables. This can be achieved in the meta-language by using de Bruijn indices <ref> [dB72] </ref> where a variable occurrence is replaced by a pointer to the corresponding binder. Another approach, which remains closer to informal practice, reduces all binding operators to a single one, namely -abstraction in the meta-language. <p> This is engenders a complication of the encoding and consequently of the meta-theory, which now has to deal with many lemmas regarding variable naming. Using de Bruijn indices <ref> [dB72] </ref> alleviates this problem somewhat. In fact, this representation was designed in order to be able to give a completely rigorous proof of the Church-Rosser theorem for the untyped -calculus. It has subsequently been used in formalizations of this proof in NQTHM [Sha88], Coq [Hue94] and Isabelle [Nip95, Ras95].
Reference: [DFH + 93] <author> Gilles Dowek, Amy Felty, Hugo Herbelin, Gerard Huet, Chet Murthy, Catherine Parent, Christine Paulin-Mohring, and Benjamin Werner. </author> <title> The 10 Coq proof assistant user's guide. Rapport Techniques 154, </title> <publisher> INRIA, </publisher> <address> Roc--quencourt, France, </address> <year> 1993. </year> <note> Version 5.8. </note>
Reference-contexts: On the one hand, this led to a number of systems for constructive mathematics and the extraction of functional programs from constructive proofs (for example, Nuprl [C + 86, CH90], LEGO [Pol94], and Coq <ref> [DFH + 93] </ref>). On the other hand, it strongly influenced the design of LF [HHP93], also called the Edinburgh Logical Framework (ELF). <p> Tactics and Tacticals provide a popular mechanism to structure and program search. Tactics and tacticals arose out of the LCF theorem proving effort [GMW79, Pau83] and are used in such diverse systems as NuPrl [C + 86], Coq <ref> [DFH + 93] </ref>, Isabelle [NP92], and Prolog [NM88, Fel93]. In all but the last 6 one, they are programmed in ML which was originally developed to support theorem proving for LCF. Logic programming offers a different approach to meta-programming.
Reference: [DFH95] <author> Joelle Despeyroux, Amy Felty, and Andre Hirschowitz. </author> <title> Higher-order abstract syntax in Coq. </title> <editor> In M. Dezani-Ciancaglini and G. Plotkin, editors, </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <pages> pages 124-138, </pages> <address> Edinburgh, Scotland, April 1995. </address> <publisher> Springer-Verlag LNCS 902. </publisher>
Reference-contexts: Presently, the external argument guaranteeing the meta-theorem has been carried out mechanically only for some of these above-mentioned experiments. An important challenge for logical frameworks is to reconcile induction principles with higher-order abstract syntax. Two approaches, using existing inductive calculi, are presented in <ref> [DH94, DFH95] </ref>. Another approach, pursued by the author in joint work with Joelle Despeyroux and Carsten Schurmann, employs modal restrictions to separate closed from arbitrary expressions, thereby recovering adequacy of encodings in conjunction with a system of primitive recursive functionals for higher-order data representations.
Reference: [DH94] <author> Joelle Despeyroux and Andre Hirschowitz. </author> <title> Higher-order abstract syntax with induction in Coq. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Proceedings of the 5th International Conference on Logic Programming and Automated Reasoning, </booktitle> <pages> pages 159-173, </pages> <address> Kiev, Ukraine, July 1994. </address> <publisher> Springer-Verlag LNAI 822. </publisher>
Reference-contexts: Presently, the external argument guaranteeing the meta-theorem has been carried out mechanically only for some of these above-mentioned experiments. An important challenge for logical frameworks is to reconcile induction principles with higher-order abstract syntax. Two approaches, using existing inductive calculi, are presented in <ref> [DH94, DFH95] </ref>. Another approach, pursued by the author in joint work with Joelle Despeyroux and Carsten Schurmann, employs modal restrictions to separate closed from arbitrary expressions, thereby recovering adequacy of encodings in conjunction with a system of primitive recursive functionals for higher-order data representations.
Reference: [DP95] <author> Olivier Danvy and Frank Pfenning. </author> <title> The occurrence of continuation parameters in CPS terms. </title> <type> Technical Report CMU-CS-95-121, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: They can still be executed due to the computational interpretation of meta-language Elf via logic programming search. This technique has been applied in a number of case studies such as program derivation [And93, And94a, And94b], type preservation [MP91], compiler verification [HP92a], CPS conversion <ref> [DP95] </ref>, partial evaluation [Hat95], theorem proving [Pfe92b], the Church-Rosser theorem [Pfe92c], and cut elimination [Pfe95]. With this technique we can implement and execute meta-theoretic proofs, but LF type checking alone cannot guarantee that a higher-level type family actually represents a meta-theoretic proof.
Reference: [Dug94] <author> Dominic Duggan. </author> <title> Logical closures. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Proceedings of the 5th International Conference on Logic Programming and Automated Reasoning, </booktitle> <pages> pages 114-129, </pages> <address> Kiev, Ukraine, July 1994. </address> <publisher> Springer-Verlag LNAI 822. </publisher>
Reference-contexts: Finally, substitutions are often used in informal developments. Some work on incorporating them directly into frameworks has been done <ref> [Dug94, Mag95] </ref>, but further theoretical and practical issues regarding explicit substitutions remain to be explored. 3 Representing Derivations The next step is to represent the judgments and the defining axioms and inference rules of the deductive system under consideration.
Reference: [Ell89] <author> Conal Elliott. </author> <title> Higher-order unification with dependent types. </title> <editor> In N. Dershowitz, editor, </editor> <booktitle> Rewriting Techniques and Applications, </booktitle> <pages> pages 121-136, </pages> <address> Chapel Hill, North Carolina, April 1989. </address> <publisher> Springer-Verlag LNCS 355. </publisher>
Reference-contexts: Huet's algorithm has been used extensively in Prolog and Isabelle and generally seems to have good computational properties. It also generalizes smoothly from the simply-typed to the dependently typed case, as discovered independently by Elliott <ref> [Ell89, Ell90] </ref> and Pym [Pym90, Pym92]. The practical success of Huet's algorithm seems to be in part due to the fact that difficult, higher-order unification problems rarely arise in practice.
Reference: [Ell90] <author> Conal M. Elliott. </author> <title> Extensions and Applications of Higher-Order Unification. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> May </month> <year> 1990. </year> <note> Available as Technical Report CMU-CS-90-134. </note>
Reference-contexts: Huet's algorithm has been used extensively in Prolog and Isabelle and generally seems to have good computational properties. It also generalizes smoothly from the simply-typed to the dependently typed case, as discovered independently by Elliott <ref> [Ell89, Ell90] </ref> and Pym [Pym90, Pym92]. The practical success of Huet's algorithm seems to be in part due to the fact that difficult, higher-order unification problems rarely arise in practice.
Reference: [Eri93] <author> Lars-Henrik Eriksson. </author> <title> Finitary Partial Inductive Definitions and General Logic. </title> <type> PhD thesis, </type> <institution> Department of Computer and System Sciences, Royal Institute of Technology, Stockholm, </institution> <year> 1993. </year>
Reference-contexts: This hiatus has recently come to a close with implementations of frameworks based on inductive definitions such as FS0 [Fef88, MSB93] and ALF [Mag95], partial inductive definitions <ref> [Hal91, Eri93, Eri94] </ref> and substructural logics [SH91, Gir93, Mil94, Cer96]. There is a different approach to logical frameworks based on equational rather than deductive reasoning. <p> Instead of completely rejecting higher-order abstract syntax, we can also relax the notion of inductive definition to obtain partial inductive definitions [Hal91]. These have been used as the basis for a logical framework <ref> [Eri93] </ref>, implemented in the Pi derivation editor [Eri94], but its potential for formalizing meta-theory remains largely unexplored. 8 A third option is to externalize the induction.
Reference: [Eri94] <author> Lars-Henrik Eriksson. </author> <title> Pi: An interactive derivation editor for the calculus of partial inductive definitions. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 821-825, </pages> <address> Nancy, France, June 1994. </address> <publisher> Springer Verlag LNAI 814. </publisher>
Reference-contexts: This hiatus has recently come to a close with implementations of frameworks based on inductive definitions such as FS0 [Fef88, MSB93] and ALF [Mag95], partial inductive definitions <ref> [Hal91, Eri93, Eri94] </ref> and substructural logics [SH91, Gir93, Mil94, Cer96]. There is a different approach to logical frameworks based on equational rather than deductive reasoning. <p> Instead of completely rejecting higher-order abstract syntax, we can also relax the notion of inductive definition to obtain partial inductive definitions [Hal91]. These have been used as the basis for a logical framework [Eri93], implemented in the Pi derivation editor <ref> [Eri94] </ref>, but its potential for formalizing meta-theory remains largely unexplored. 8 A third option is to externalize the induction.
Reference: [Fef88] <author> Solomon Feferman. </author> <title> Finitary inductive systems. </title> <editor> In R. Ferro, editor, </editor> <booktitle> Proceedings of Logic Colloquium '88, </booktitle> <pages> pages 191-220, </pages> <address> Padova, Italy, </address> <month> August </month> <year> 1988. </year> <pages> North-Holland. </pages>
Reference-contexts: This hiatus has recently come to a close with implementations of frameworks based on inductive definitions such as FS0 <ref> [Fef88, MSB93] </ref> and ALF [Mag95], partial inductive definitions [Hal91, Eri93, Eri94] and substructural logics [SH91, Gir93, Mil94, Cer96]. There is a different approach to logical frameworks based on equational rather than deductive reasoning. <p> This cannot be considered as an inductive type, because of the negative occurrence of exp in the type of lam. An attempt to formulate a valid induction principle for the type exp fails. Several options have been explored to escape this dilemma. The first, for example used in <ref> [BC93, Fef88, MN94, Pol95] </ref> is to reject the notion of higher-order abstract syntax and use inductive representations directly. This is engenders a complication of the encoding and consequently of the meta-theory, which now has to deal with many lemmas regarding variable naming.
Reference: [Fel89] <author> Amy Felty. </author> <title> Specifying and Implementing Theorem Provers in a Higher-Order Logic Programming Language. </title> <type> PhD thesis, </type> <institution> University of Pennsylva-nia, </institution> <month> August </month> <year> 1989. </year> <note> Available as Technical Report MS-CIS-89-53. </note>
Reference-contexts: With a general implementation of the meta-logic, we can now reason within the object language and interpret the results via the adequacy theorem. Many experiments have been carried out following this methodology, including type inference [Pfe88], equational reasoning [Nip89], theorem proving <ref> [Fel89] </ref>, functional programming [HM90, Han93], specification languages [MM93], VLSI design [Ros92], set theory [Pau93, Noe93], interpreter verification [BHN + 94] and the Church-Rosser theorem [Nip95, Ras95]. However, in many applications we need to go a step further and design a representation of derivations themselves as objects in the meta-language. <p> We introduce a new type for derivations, where each inference rules becomes a constructor of objects of the new type. Functional constructors can be used to model parametric and hypothetical judgments. This technique has been investigated by Felty <ref> [Fel89] </ref> for representing derivations in first-order logic. One drawback of this representation is that the validity of derivations must be axiomatized explicitly. This is because the system of simple types is not accurate enough to capture the expressions which are part of a judgment.
Reference: [Fel91] <author> Amy Felty. </author> <title> A logic programming approach to implementing higher-order term rewriting. </title> <editor> In Lars-Henrik Eriksson, Lars Hallnas, and Peter Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 135-161, </pages> <address> Stockholm, Sweden, Janu-ary 1991. </address> <publisher> Springer-Verlag LNAI 596. </publisher>
Reference-contexts: The ALF framework employs explicit substitutions in a similar structuring role [Mag95]. It is straightforward to encode systems of equational reasoning in any of the logical frameworks we have discussed <ref> [Nip89, Fel91] </ref>. The granularity and efficiency of reasoning in such explicit encodings is generally too low to allow complex developments|we must look for ways to incorporate equational theories directly into the underlying meta-logic or type theory without sacrificing decidability and other desirable properties.
Reference: [Fel93] <author> Amy Felty. </author> <title> Implementing tactics and tacticals in a higher-order logic programming language. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 11(1) </volume> <pages> 43-81, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Tactics and Tacticals provide a popular mechanism to structure and program search. Tactics and tacticals arose out of the LCF theorem proving effort [GMW79, Pau83] and are used in such diverse systems as NuPrl [C + 86], Coq [DFH + 93], Isabelle [NP92], and Prolog <ref> [NM88, Fel93] </ref>. In all but the last 6 one, they are programmed in ML which was originally developed to support theorem proving for LCF. Logic programming offers a different approach to meta-programming. <p> Unification is a central and indispensable operation in traditional first-order theorem provers and logic programming languages. It plays a critical role in the implementations of tactics and tacticals in Isabelle and Prolog <ref> [Fel93, FH94] </ref>. Unification allows the search algorithm to postpone existential choices until more information becomes available as to which instances may be useful. Since most logical frameworks go beyond first-order terms, traditional first-order unification is insufficient.
Reference: [FH94] <author> Amy Felty and Douglas Howe. </author> <title> Tactic theorem proving with refinement-tree proofs and metavariables. </title> <editor> In Alan Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 605-619, </pages> <address> Nancy, France, June 1994. </address> <publisher> Springer-Verlag LNAI 596. </publisher> <pages> 11 </pages>
Reference-contexts: Unification is a central and indispensable operation in traditional first-order theorem provers and logic programming languages. It plays a critical role in the implementations of tactics and tacticals in Isabelle and Prolog <ref> [Fel93, FH94] </ref>. Unification allows the search algorithm to postpone existential choices until more information becomes available as to which instances may be useful. Since most logical frameworks go beyond first-order terms, traditional first-order unification is insufficient.
Reference: [FM88] <author> Amy Felty and Dale Miller. </author> <title> Specifying theorem provers in a higher-order logic programming language. </title> <editor> In Ewing Lusk and Ross Overbeek, editors, </editor> <booktitle> Proceedings of the Ninth International Conference on Automated Deduction, </booktitle> <pages> pages 61-80, </pages> <address> Argonne, Illinois, </address> <month> May </month> <year> 1988. </year> <note> Springer-Verlag LNCS 310. </note>
Reference-contexts: Variations of this approach to encoding derivability have been devised by Paulson [Pau86] and Felty and Miller <ref> [FM88] </ref>. Quantifiers in hereditary Harrop formulas are typed and range over simply-typed -terms, thus permitting the technique of higher-order abstract syntax. With a general implementation of the meta-logic, we can now reason within the object language and interpret the results via the adequacy theorem.
Reference: [Gab93] <author> Dov M. Gabbay. </author> <title> Classical vs non-classical logics: The universality of classical logic. </title> <type> Technical Report MPI-I-93-230, </type> <institution> Max-Planck-Institut fur Infor-matik, Saarbrucken, Germany, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: The interested reader is referred to [MOM93, KKV93, Hab94]. Another approach derives from the notion of labelled deductive system due to Gabbay [Gab94]. Here the meta-logic is a classical logic with equality <ref> [Gab93] </ref>. Two further notes on terminology. Some researchers distinguish logical frameworks from meta-logical frameworks [BC93], the latter being intended as a meta-language for reasoning about deductive systems rather than within them. <p> Implemen 5 tation projects for these languages have just begun. Besides linear and related logics, these frameworks also enable a whole new class of languages to be represented concisely, namely those involving state and concurrency [Chi95]. Also relevant is the work on labelled deductive systems <ref> [Gab93, Gab94] </ref>. Another challenge is the development of appropriate structuring principles to achieve modular presentation of deductive systems. This has been studied in the abstract [HST94] and in the context of the Elf language [HP92b], but only prototype implementations exist.
Reference: [Gab94] <author> Dov M Gabbay. </author> <title> Labelled deductive systems, volume 1 | foundations. </title> <type> Technical Report 465, </type> <institution> Max-Planck-Institut fur Informatik, Saarbrucken, Germany, </institution> <year> 1994. </year>
Reference-contexts: The interested reader is referred to [MOM93, KKV93, Hab94]. Another approach derives from the notion of labelled deductive system due to Gabbay <ref> [Gab94] </ref>. Here the meta-logic is a classical logic with equality [Gab93]. Two further notes on terminology. Some researchers distinguish logical frameworks from meta-logical frameworks [BC93], the latter being intended as a meta-language for reasoning about deductive systems rather than within them. <p> Implemen 5 tation projects for these languages have just begun. Besides linear and related logics, these frameworks also enable a whole new class of languages to be represented concisely, namely those involving state and concurrency [Chi95]. Also relevant is the work on labelled deductive systems <ref> [Gab93, Gab94] </ref>. Another challenge is the development of appropriate structuring principles to achieve modular presentation of deductive systems. This has been studied in the abstract [HST94] and in the context of the Elf language [HP92b], but only prototype implementations exist.
Reference: [Gar92] <author> Philippa Gardner. </author> <title> Representing Logics in Type Theory. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <month> July </month> <year> 1992. </year> <note> Available as Technical Report CST-93-92. </note>
Reference-contexts: The pure type system preserves decidability of type-checking, which is very easily lost for language extensions. is the basis of the LF logical framework [HHP93] which also systematizes the representation techniques for various judgment forms and the proofs of adequacy of these representations <ref> [Gar92] </ref>. Applications of LF have been numerous, first with pencil and paper [HHP93, AHMP92], then in the context of the Elf language which implements LF (see Section 5).
Reference: [Geh95] <author> Wolfgang Gehrke. </author> <title> Problems in rewriting applied to categorical concepts by the example of a computational comonad. </title> <editor> In Jieh Hsiang, editor, </editor> <booktitle> Proceedings of the Sixth International Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 210-224, </pages> <address> Kaiserslautern, Germany, April 1995. </address> <publisher> Springer-Verlag LNCS 914. </publisher>
Reference-contexts: Termination orderings and higher-order, dependently typed rewriting provide tools which should significantly extend the scope of the methods sketched here. Some work along these lines can be found in <ref> [Geh95, Kah95, LP95, vdPS95] </ref>. High-level representations of deductive systems allow proofs of their properties to be implemented quickly and efficiently. Yet the current degree of automation is not satisfactory.
Reference: [Gir93] <author> Jean-Yves Girard. </author> <title> On the unity of logic. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 59 </volume> <pages> 201-217, </pages> <year> 1993. </year>
Reference-contexts: This hiatus has recently come to a close with implementations of frameworks based on inductive definitions such as FS0 [Fef88, MSB93] and ALF [Mag95], partial inductive definitions [Hal91, Eri93, Eri94] and substructural logics <ref> [SH91, Gir93, Mil94, Cer96] </ref>. There is a different approach to logical frameworks based on equational rather than deductive reasoning. While one can be interpreted in the other without much difficulty, the meta-languages based on equational reasoning take a rather different form and we will not discuss them here.
Reference: [GMW79] <author> Michael J. Gordon, Robin Milner, and Christopher P. Wadsworth. </author> <title> Edin-burgh LCF. </title> <publisher> Springer-Verlag LNCS 78, </publisher> <year> 1979. </year>
Reference-contexts: Instead, we must look for methods that support interactive deduction while permitting heuristic searches to be programmed and automatic methods to be used when they exist. Tactics and Tacticals provide a popular mechanism to structure and program search. Tactics and tacticals arose out of the LCF theorem proving effort <ref> [GMW79, Pau83] </ref> and are used in such diverse systems as NuPrl [C + 86], Coq [DFH + 93], Isabelle [NP92], and Prolog [NM88, Fel93]. In all but the last 6 one, they are programmed in ML which was originally developed to support theorem proving for LCF.
Reference: [Hab94] <author> Marianne Haberstrau. ECOLOG: </author> <title> An environment for constraint logics. </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Proceedings of the First International Conference on Constraints in Computational Logics, </booktitle> <pages> pages 237-252, </pages> <address> Munich, Germany, </address> <month> September </month> <year> 1994. </year> <note> Springer-Verlag LNCS 845. </note>
Reference-contexts: While one can be interpreted in the other without much difficulty, the meta-languages based on equational reasoning take a rather different form and we will not discuss them here. The interested reader is referred to <ref> [MOM93, KKV93, Hab94] </ref>. Another approach derives from the notion of labelled deductive system due to Gabbay [Gab94]. Here the meta-logic is a classical logic with equality [Gab93]. Two further notes on terminology.
Reference: [Hal91] <author> Lars Hallnas. </author> <title> Partial inductive definitions. </title> <journal> Theoretical Computer Science, </journal> <volume> 87(1) </volume> <pages> 115-142, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: This hiatus has recently come to a close with implementations of frameworks based on inductive definitions such as FS0 [Fef88, MSB93] and ALF [Mag95], partial inductive definitions <ref> [Hal91, Eri93, Eri94] </ref> and substructural logics [SH91, Gir93, Mil94, Cer96]. There is a different approach to logical frameworks based on equational rather than deductive reasoning. <p> It has subsequently been used in formalizations of this proof in NQTHM [Sha88], Coq [Hue94] and Isabelle [Nip95, Ras95]. Instead of completely rejecting higher-order abstract syntax, we can also relax the notion of inductive definition to obtain partial inductive definitions <ref> [Hal91] </ref>. These have been used as the basis for a logical framework [Eri93], implemented in the Pi derivation editor [Eri94], but its potential for formalizing meta-theory remains largely unexplored. 8 A third option is to externalize the induction.
Reference: [Han93] <author> John Hannan. </author> <title> Extended natural semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(2) </volume> <pages> 123-152, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: With a general implementation of the meta-logic, we can now reason within the object language and interpret the results via the adequacy theorem. Many experiments have been carried out following this methodology, including type inference [Pfe88], equational reasoning [Nip89], theorem proving [Fel89], functional programming <ref> [HM90, Han93] </ref>, specification languages [MM93], VLSI design [Ros92], set theory [Pau93, Noe93], interpreter verification [BHN + 94] and the Church-Rosser theorem [Nip95, Ras95]. However, in many applications we need to go a step further and design a representation of derivations themselves as objects in the meta-language.
Reference: [Hat95] <author> John Hatcliff. </author> <title> Mechanically verifying the correctness of an o*ine partial evaluator. </title> <booktitle> In Proceedings of the Seventh International Symposium on Programming Languages, Implementations, Logics and Programs, </booktitle> <pages> pages 279-298, </pages> <address> Utrecht, The Netherlands, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag LNCS 982. </note>
Reference-contexts: They can still be executed due to the computational interpretation of meta-language Elf via logic programming search. This technique has been applied in a number of case studies such as program derivation [And93, And94a, And94b], type preservation [MP91], compiler verification [HP92a], CPS conversion [DP95], partial evaluation <ref> [Hat95] </ref>, theorem proving [Pfe92b], the Church-Rosser theorem [Pfe92c], and cut elimination [Pfe95]. With this technique we can implement and execute meta-theoretic proofs, but LF type checking alone cannot guarantee that a higher-level type family actually represents a meta-theoretic proof.
Reference: [HHP93] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year> <note> A preliminary version appeared in the Proceedings of the Symposium on Logic in Computer Science, pages 194-204, </note> <month> June </month> <year> 1987. </year>
Reference-contexts: On the one hand, this led to a number of systems for constructive mathematics and the extraction of functional programs from constructive proofs (for example, Nuprl [C + 86, CH90], LEGO [Pol94], and Coq [DFH + 93]). On the other hand, it strongly influenced the design of LF <ref> [HHP93] </ref>, also called the Edinburgh Logical Framework (ELF). Concurrent with the development of LF, frameworks based on higher-order logic and resolution were designed in the form of generic theorem provers [Pau86, Pau89, NP92] and logic programming languages [NM88, MNPS91]. <p> This entails that object language variables are represented by variables in the meta-language, and variables bound in the object language are bound with corresponding scope in the meta-language. This is the fundamental idea of higher-order abstract syntax <ref> [HHP93, PE88] </ref> which goes back to Martin-Lof's system of arities [NPS90]. Higher-order abstract syntax identifies expressions that differ only in the names assigned to their bound variables through ff-conversion in the meta-language. <p> Dependent types create the need for a rule of type conversion which drastically alters the character of the type theory. The pure type system preserves decidability of type-checking, which is very easily lost for language extensions. is the basis of the LF logical framework <ref> [HHP93] </ref> which also systematizes the representation techniques for various judgment forms and the proofs of adequacy of these representations [Gar92]. Applications of LF have been numerous, first with pencil and paper [HHP93, AHMP92], then in the context of the Elf language which implements LF (see Section 5). <p> Applications of LF have been numerous, first with pencil and paper <ref> [HHP93, AHMP92] </ref>, then in the context of the Elf language which implements LF (see Section 5). A significant challenge in the area of meta-representation are modal and other non-local side conditions in the formulation of deductive systems, as they occur, for example, in the presentation of linear logic.
Reference: [HM90] <author> John Hannan and Dale Miller. </author> <title> From operational semantics to abstract machines: Preliminary results. </title> <editor> In M. Wand, editor, </editor> <booktitle> Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 323-332, </pages> <address> Nice, France, </address> <year> 1990. </year>
Reference-contexts: With a general implementation of the meta-logic, we can now reason within the object language and interpret the results via the adequacy theorem. Many experiments have been carried out following this methodology, including type inference [Pfe88], equational reasoning [Nip89], theorem proving [Fel89], functional programming <ref> [HM90, Han93] </ref>, specification languages [MM93], VLSI design [Ros92], set theory [Pau93, Noe93], interpreter verification [BHN + 94] and the Church-Rosser theorem [Nip95, Ras95]. However, in many applications we need to go a step further and design a representation of derivations themselves as objects in the meta-language.
Reference: [HP92a] <author> John Hannan and Frank Pfenning. </author> <title> Compiler verification in LF. </title> <editor> In Andre Scedrov, editor, </editor> <booktitle> Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 407-418, </pages> <address> Santa Cruz, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: They can still be executed due to the computational interpretation of meta-language Elf via logic programming search. This technique has been applied in a number of case studies such as program derivation [And93, And94a, And94b], type preservation [MP91], compiler verification <ref> [HP92a] </ref>, CPS conversion [DP95], partial evaluation [Hat95], theorem proving [Pfe92b], the Church-Rosser theorem [Pfe92c], and cut elimination [Pfe95]. With this technique we can implement and execute meta-theoretic proofs, but LF type checking alone cannot guarantee that a higher-level type family actually represents a meta-theoretic proof.
Reference: [HP92b] <author> Robert Harper and Frank Pfenning. </author> <title> A module system for a programming language based on the LF logical framework. </title> <journal> Journal of Logic and Computation. </journal> <note> To appear. A preliminary version is available as Technical Report CMU-CS-92-191. </note>
Reference-contexts: Also relevant is the work on labelled deductive systems [Gab93, Gab94]. Another challenge is the development of appropriate structuring principles to achieve modular presentation of deductive systems. This has been studied in the abstract [HST94] and in the context of the Elf language <ref> [HP92b] </ref>, but only prototype implementations exist. The ALF framework employs explicit substitutions in a similar structuring role [Mag95]. It is straightforward to encode systems of equational reasoning in any of the logical frameworks we have discussed [Nip89, Fel91].
Reference: [HST94] <author> Robert Harper, Donald Sannella, and Andrzej Tarlecki. </author> <title> Structured presentations and logic representations. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 12 67 </volume> <pages> 113-160, </pages> <year> 1994. </year>
Reference-contexts: Also relevant is the work on labelled deductive systems [Gab93, Gab94]. Another challenge is the development of appropriate structuring principles to achieve modular presentation of deductive systems. This has been studied in the abstract <ref> [HST94] </ref> and in the context of the Elf language [HP92b], but only prototype implementations exist. The ALF framework employs explicit substitutions in a similar structuring role [Mag95]. It is straightforward to encode systems of equational reasoning in any of the logical frameworks we have discussed [Nip89, Fel91].
Reference: [Hue75] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: Unification allows the search algorithm to postpone existential choices until more information becomes available as to which instances may be useful. Since most logical frameworks go beyond first-order terms, traditional first-order unification is insufficient. Despite its undecidability, Huet <ref> [Hue75] </ref> devised a practical algorithm for higher-order pre-unification, a form of unification where solvable equations of a certain form are postponed as constraints. Huet's algorithm has been used extensively in Prolog and Isabelle and generally seems to have good computational properties.
Reference: [Hue94] <author> Gerard Huet. </author> <title> Residual theory in -calculus: A formal development. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(3) </volume> <pages> 371-394, </pages> <month> July </month> <year> 1994. </year> <note> Preliminary version available as INRIA Technical Report 2009, </note> <month> August </month> <year> 1993. </year>
Reference-contexts: Using de Bruijn indices [dB72] alleviates this problem somewhat. In fact, this representation was designed in order to be able to give a completely rigorous proof of the Church-Rosser theorem for the untyped -calculus. It has subsequently been used in formalizations of this proof in NQTHM [Sha88], Coq <ref> [Hue94] </ref> and Isabelle [Nip95, Ras95]. Instead of completely rejecting higher-order abstract syntax, we can also relax the notion of inductive definition to obtain partial inductive definitions [Hal91].
Reference: [Jut77] <editor> L.S. van Benthem Jutting. </editor> <title> Checking Landau's "Grundlagen" in the AU-TOMATH System. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1977. </year>
Reference-contexts: Therefore, the logic underlying a particular mathematical development was an integral part of its formalization. Many of the ideas underlying the Automath languages have found their way into modern systems. The main experiment conducted within Automath was the formalization of Landau's Foundations of Analysis <ref> [Jut77] </ref>. In the early 80's the importance of constructive type theories for computer science was being recognized through the pioneering work of Martin-Lof [ML80, ML85a, ML85b].
Reference: [Kah95] <author> Stefan Kahrs. </author> <title> Towards a domain theory for termination proofs. </title> <editor> In Jieh Hsiang, editor, </editor> <booktitle> Proceedings of the Sixth International Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 241-255, </pages> <address> Kaiserslautern, Germany, April 1995. </address> <publisher> Springer-Verlag LNCS 914. </publisher>
Reference-contexts: Building equations into the representation of syntax has been recognized as a significant challenge and investigated in the context of logical frameworks by [Nip91] with a rapidly increasing literature regarding its operational properties <ref> [ALS94, Kah95, LP95, Pre95] </ref>. Finally, substitutions are often used in informal developments. <p> Termination orderings and higher-order, dependently typed rewriting provide tools which should significantly extend the scope of the methods sketched here. Some work along these lines can be found in <ref> [Geh95, Kah95, LP95, vdPS95] </ref>. High-level representations of deductive systems allow proofs of their properties to be implemented quickly and efficiently. Yet the current degree of automation is not satisfactory.
Reference: [KKV93] <author> Claude Kircher, Helene Kirchner, and Marian Vittek. </author> <title> Implementing computational systems with constraints. </title> <editor> In P. van Hentenryck and V. Saraswat, editors, </editor> <booktitle> Proceedings of the First Workshop on Principles and Practice of Constraints Programming, </booktitle> <address> Newport, Rhode Island, April 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: While one can be interpreted in the other without much difficulty, the meta-languages based on equational reasoning take a rather different form and we will not discuss them here. The interested reader is referred to <ref> [MOM93, KKV93, Hab94] </ref>. Another approach derives from the notion of labelled deductive system due to Gabbay [Gab94]. Here the meta-logic is a classical logic with equality [Gab93]. Two further notes on terminology.
Reference: [KP93] <author> Michael Kohlhase and Frank Pfenning. </author> <title> Unification in a -calculus with intersection types. </title> <editor> In Dale Miller, editor, </editor> <booktitle> Proceedings of the International Logic Programming Symposium, </booktitle> <pages> pages 488-505, </pages> <address> Vancouver, Canada, Octo-ber 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: In a first-order meta-language this problem can be addressed by using an order-sorted type system, but in higher-order languages these interact, sometimes in undesirable ways, with other features. Preliminary theoretical work to extend order-sorted techniques to logical frameworks is reported in <ref> [Pfe93, KP93] </ref>, but to our knowledge none has been implemented on a realistic scale. The variable convention is just one example where syntax is considered modulo a certain equivalence.
Reference: [LP95] <author> Olav Lysne and Javier Piris. </author> <title> A termination ordering for higher order rewrite systems. </title> <editor> In Jieh Hsiang, editor, </editor> <booktitle> Proceedings of the Sixth International Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 26-40, </pages> <address> Kaiser-slautern, Germany, April 1995. </address> <publisher> Springer-Verlag LNCS 914. </publisher>
Reference-contexts: Building equations into the representation of syntax has been recognized as a significant challenge and investigated in the context of logical frameworks by [Nip91] with a rapidly increasing literature regarding its operational properties <ref> [ALS94, Kah95, LP95, Pre95] </ref>. Finally, substitutions are often used in informal developments. <p> Termination orderings and higher-order, dependently typed rewriting provide tools which should significantly extend the scope of the methods sketched here. Some work along these lines can be found in <ref> [Geh95, Kah95, LP95, vdPS95] </ref>. High-level representations of deductive systems allow proofs of their properties to be implemented quickly and efficiently. Yet the current degree of automation is not satisfactory.
Reference: [Mag95] <author> Lena Magnusson. </author> <title> The Implementation of ALF|A Proof Editor Based on Martin-Lof's Monomorphic Type Theory with Explicit Substitution. </title> <type> PhD thesis, </type> <institution> Chalmers University of Technology and Goteborg University, </institution> <month> Janu-ary </month> <year> 1995. </year>
Reference-contexts: This hiatus has recently come to a close with implementations of frameworks based on inductive definitions such as FS0 [Fef88, MSB93] and ALF <ref> [Mag95] </ref>, partial inductive definitions [Hal91, Eri93, Eri94] and substructural logics [SH91, Gir93, Mil94, Cer96]. There is a different approach to logical frameworks based on equational rather than deductive reasoning. <p> Finally, substitutions are often used in informal developments. Some work on incorporating them directly into frameworks has been done <ref> [Dug94, Mag95] </ref>, but further theoretical and practical issues regarding explicit substitutions remain to be explored. 3 Representing Derivations The next step is to represent the judgments and the defining axioms and inference rules of the deductive system under consideration. <p> Another challenge is the development of appropriate structuring principles to achieve modular presentation of deductive systems. This has been studied in the abstract [HST94] and in the context of the Elf language [HP92b], but only prototype implementations exist. The ALF framework employs explicit substitutions in a similar structuring role <ref> [Mag95] </ref>. It is straightforward to encode systems of equational reasoning in any of the logical frameworks we have discussed [Nip89, Fel91]. <p> Since all primitive recursive functionals are total (which we prove once and for all), the required y is thus guaranteed to exist. An extension of this idea beyond primitive recursion to general pattern matching (without the notion of higher-order abstract syntax) has been explored in the ALF system <ref> [Mag95, MN94, Coq92, CNSvS94] </ref>. The empirical evidence suggests that this shortens developments considerably [Coq92] and also allows the formulations of functions in a manner which is closer to functional programming practice. Adding such functions to the simply-typed -calculus or LF still leads to inadequate encodings.
Reference: [Mil91] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <journal> Journal of Logic and Computation, </journal> <volume> 1(4) </volume> <pages> 497-536, </pages> <year> 1991. </year>
Reference-contexts: The practical success of Huet's algorithm seems to be in part due to the fact that difficult, higher-order unification problems rarely arise in practice. An analysis of this observation led Miller <ref> [Mil91] </ref> to discover higher-order patterns, a sublanguage of the simply-typed -calculus with restricted variable occurrences. For this fragment, most general unifiers exist. In fact, the theoretical complexity of this problem is linear [Qia93], just as for first-order unification.
Reference: [Mil94] <editor> Dale Miller. A multiple-conclusion meta-logic. In S. Abramsky, editor, </editor> <booktitle> Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 272-281, </pages> <address> Paris, France, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: This hiatus has recently come to a close with implementations of frameworks based on inductive definitions such as FS0 [Fef88, MSB93] and ALF [Mag95], partial inductive definitions [Hal91, Eri93, Eri94] and substructural logics <ref> [SH91, Gir93, Mil94, Cer96] </ref>. There is a different approach to logical frameworks based on equational rather than deductive reasoning. While one can be interpreted in the other without much difficulty, the meta-languages based on equational reasoning take a rather different form and we will not discuss them here. <p> A significant challenge in the area of meta-representation are modal and other non-local side conditions in the formulation of deductive systems, as they occur, for example, in the presentation of linear logic. A higher-order classical linear meta-logic to address some of these problems has been proposed by Miller <ref> [Mil94] </ref>, a conservative extension of LF by Cervesato [Cer96]. Implemen 5 tation projects for these languages have just begun. Besides linear and related logics, these frameworks also enable a whole new class of languages to be represented concisely, namely those involving state and concurrency [Chi95].
Reference: [ML80] <author> Per Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In Logic, Methodology and Philosophy of Science VI, </booktitle> <pages> pages 153-175. </pages> <publisher> North-Holland, </publisher> <year> 1980. </year>
Reference-contexts: The main experiment conducted within Automath was the formalization of Landau's Foundations of Analysis [Jut77]. In the early 80's the importance of constructive type theories for computer science was being recognized through the pioneering work of Martin-Lof <ref> [ML80, ML85a, ML85b] </ref>. On the one hand, this led to a number of systems for constructive mathematics and the extraction of functional programs from constructive proofs (for example, Nuprl [C + 86, CH90], LEGO [Pol94], and Coq [DFH + 93]).
Reference: [ML85a] <author> Per Martin-Lof. </author> <title> On the meanings of the logical constants and the justifications of the logical laws. </title> <type> Technical Report 2, </type> <institution> Scuola di Specializzazione in Logica Matematica, Dipartimento di Matematica, Universita di Siena, </institution> <year> 1985. </year>
Reference-contexts: The main experiment conducted within Automath was the formalization of Landau's Foundations of Analysis [Jut77]. In the early 80's the importance of constructive type theories for computer science was being recognized through the pioneering work of Martin-Lof <ref> [ML80, ML85a, ML85b] </ref>. On the one hand, this led to a number of systems for constructive mathematics and the extraction of functional programs from constructive proofs (for example, Nuprl [C + 86, CH90], LEGO [Pol94], and Coq [DFH + 93]).
Reference: [ML85b] <author> Per Martin-Lof. </author> <title> Truth of a propositions, evidence of a judgement, validity of a proof. Notes to a talk given at the workshop Theory of Meaning, </title> <institution> Centro Fiorentino di Storia e Filosofia della Scienza, </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: The main experiment conducted within Automath was the formalization of Landau's Foundations of Analysis [Jut77]. In the early 80's the importance of constructive type theories for computer science was being recognized through the pioneering work of Martin-Lof <ref> [ML80, ML85a, ML85b] </ref>. On the one hand, this led to a number of systems for constructive mathematics and the extraction of functional programs from constructive proofs (for example, Nuprl [C + 86, CH90], LEGO [Pol94], and Coq [DFH + 93]).
Reference: [MM93] <author> D. Mery and A. Mokkedem. </author> <title> Crocos: an integrated environment for interactive verification of SDL specifications. </title> <editor> In G. v. Bochmann and D. K. Probst, editors, </editor> <booktitle> Computer Aided Verification: Fourth International Workshop, CAV '92. </booktitle> <publisher> Springer-Verlag LNCS 663, </publisher> <year> 1993. </year>
Reference-contexts: With a general implementation of the meta-logic, we can now reason within the object language and interpret the results via the adequacy theorem. Many experiments have been carried out following this methodology, including type inference [Pfe88], equational reasoning [Nip89], theorem proving [Fel89], functional programming [HM90, Han93], specification languages <ref> [MM93] </ref>, VLSI design [Ros92], set theory [Pau93, Noe93], interpreter verification [BHN + 94] and the Church-Rosser theorem [Nip95, Ras95]. However, in many applications we need to go a step further and design a representation of derivations themselves as objects in the meta-language.
Reference: [MN94] <author> Lena Magnusson and Bengt Nordstrom. </author> <title> The ALF proof editor and its proof engine. </title> <editor> In Henk Barendregt and Tobias Nipkow, editors, </editor> <booktitle> Types for Proofs 13 and Programs, </booktitle> <pages> pages 213-237. </pages> <publisher> Springer-Verlag LNCS 806, </publisher> <year> 1994. </year>
Reference-contexts: This cannot be considered as an inductive type, because of the negative occurrence of exp in the type of lam. An attempt to formulate a valid induction principle for the type exp fails. Several options have been explored to escape this dilemma. The first, for example used in <ref> [BC93, Fef88, MN94, Pol95] </ref> is to reject the notion of higher-order abstract syntax and use inductive representations directly. This is engenders a complication of the encoding and consequently of the meta-theory, which now has to deal with many lemmas regarding variable naming. <p> Since all primitive recursive functionals are total (which we prove once and for all), the required y is thus guaranteed to exist. An extension of this idea beyond primitive recursion to general pattern matching (without the notion of higher-order abstract syntax) has been explored in the ALF system <ref> [Mag95, MN94, Coq92, CNSvS94] </ref>. The empirical evidence suggests that this shortens developments considerably [Coq92] and also allows the formulations of functions in a manner which is closer to functional programming practice. Adding such functions to the simply-typed -calculus or LF still leads to inadequate encodings.
Reference: [MNPS91] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: On the other hand, it strongly influenced the design of LF [HHP93], also called the Edinburgh Logical Framework (ELF). Concurrent with the development of LF, frameworks based on higher-order logic and resolution were designed in the form of generic theorem provers [Pau86, Pau89, NP92] and logic programming languages <ref> [NM88, MNPS91] </ref>. The type-theoretic and logic programming approaches were later combined in the Elf language [Pfe89, Pfe91a, Pfe92a, Pfe94].
Reference: [MOM93] <author> Narciso Mart-Oliet and Jose Meseguer. </author> <title> Rewriting logic as a logical and semantical framework. </title> <type> Technical Report SRI-CSL-93-05, </type> <institution> SRI International, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: While one can be interpreted in the other without much difficulty, the meta-languages based on equational reasoning take a rather different form and we will not discuss them here. The interested reader is referred to <ref> [MOM93, KKV93, Hab94] </ref>. Another approach derives from the notion of labelled deductive system due to Gabbay [Gab94]. Here the meta-logic is a classical logic with equality [Gab93]. Two further notes on terminology.
Reference: [MP91] <author> Spiro Michaylov and Frank Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <editor> In L.-H. Eriksson, L. Hallnas, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 299-344, </pages> <address> Stockholm, Sweden, </address> <month> January </month> <year> 1991. </year> <note> Springer-Verlag LNAI 596. </note>
Reference-contexts: They can still be executed due to the computational interpretation of meta-language Elf via logic programming search. This technique has been applied in a number of case studies such as program derivation [And93, And94a, And94b], type preservation <ref> [MP91] </ref>, compiler verification [HP92a], CPS conversion [DP95], partial evaluation [Hat95], theorem proving [Pfe92b], the Church-Rosser theorem [Pfe92c], and cut elimination [Pfe95]. With this technique we can implement and execute meta-theoretic proofs, but LF type checking alone cannot guarantee that a higher-level type family actually represents a meta-theoretic proof.
Reference: [MP92] <author> Spiro Michaylov and Frank Pfenning. </author> <title> An empirical study of the runtime behavior of higher-order logic programs. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings of the Workshop on the Prolog Programming Language, </booktitle> <pages> pages 257-271, </pages> <address> Philadelphia, Pennsylvania, </address> <month> July </month> <year> 1992. </year> <institution> University of Pennsylvania. </institution> <note> Available as Technical Report MS-CIS-92-86. </note>
Reference-contexts: Miller proposed it as the basis for a lower-level language L similar to Prolog, but one where unification does not branch, since only higher-order patterns are permitted as terms. An empirical study of this restriction <ref> [MP92, MP93] </ref> showed that most dynamically arising unification problems lie within this fragment, but that a syntactic restriction rules out some useful programming idioms, since the operation of substitution of terms for bound variables has to be reprogrammed for each syntactic category.
Reference: [MP93] <author> Spiro Michaylov and Frank Pfenning. </author> <title> Higher-order logic programming as constraint logic programming. </title> <booktitle> In Position Papers for the First Workshop on Principles and Practice of Constraint Programming, </booktitle> <pages> pages 221-229, </pages> <address> Newport, Rhode Island, </address> <month> April </month> <year> 1993. </year> <institution> Brown University. </institution>
Reference-contexts: Miller proposed it as the basis for a lower-level language L similar to Prolog, but one where unification does not branch, since only higher-order patterns are permitted as terms. An empirical study of this restriction <ref> [MP92, MP93] </ref> showed that most dynamically arising unification problems lie within this fragment, but that a syntactic restriction rules out some useful programming idioms, since the operation of substitution of terms for bound variables has to be reprogrammed for each syntactic category. <p> For example, compare the undecidability of higher-order unification with the efficiency of first-order unification. One way to recapture efficiency would be to compile or specialize the general search procedure to specific encoded logics. Only very preliminary work on this has been done <ref> [NJ89, MP93] </ref>. 5 Representing Meta-Theory Since logical frameworks are designed to express the language and inference rules of deductive systems at a very high level of abstraction, one rightly suspects that they should be amenable to an investigation of the meta-theory of deductive systems.
Reference: [MSB93] <author> Sean Matthews, Alan Smaill, and David Basin. </author> <title> Experience with F S 0 as a framework theory. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Environments, </booktitle> <pages> pages 61-82. </pages> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: This hiatus has recently come to a close with implementations of frameworks based on inductive definitions such as FS0 <ref> [Fef88, MSB93] </ref> and ALF [Mag95], partial inductive definitions [Hal91, Eri93, Eri94] and substructural logics [SH91, Gir93, Mil94, Cer96]. There is a different approach to logical frameworks based on equational rather than deductive reasoning.
Reference: [NGdV94] <editor> R.P. Nederpelt, J.H. Geuvers, and R.C. de Vrijer, editors. </editor> <booktitle> Selected Papers on Automath, volume 133 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <year> 1994. </year>
Reference-contexts: Our task will be to exhibit some of the central principles underlying logical frameworks and discuss them in terms of their practical consequences. This will help us to motivate what we consider the major challenges faced by the field at present. Historically, the first logical framework was Automath <ref> [NGdV94] </ref> and its various languages, developed during the late 60's and early 70's. The goal of the Automath project was to provide a tool for the formalization of mathemat-ics without foundational prejudice. Therefore, the logic underlying a particular mathematical development was an integral part of its formalization.
Reference: [Nip89] <author> Tobias Nipkow. </author> <title> Equational reasoning in Isabelle. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 12 </volume> <pages> 123-149, </pages> <year> 1989. </year>
Reference-contexts: With a general implementation of the meta-logic, we can now reason within the object language and interpret the results via the adequacy theorem. Many experiments have been carried out following this methodology, including type inference [Pfe88], equational reasoning <ref> [Nip89] </ref>, theorem proving [Fel89], functional programming [HM90, Han93], specification languages [MM93], VLSI design [Ros92], set theory [Pau93, Noe93], interpreter verification [BHN + 94] and the Church-Rosser theorem [Nip95, Ras95]. <p> The ALF framework employs explicit substitutions in a similar structuring role [Mag95]. It is straightforward to encode systems of equational reasoning in any of the logical frameworks we have discussed <ref> [Nip89, Fel91] </ref>. The granularity and efficiency of reasoning in such explicit encodings is generally too low to allow complex developments|we must look for ways to incorporate equational theories directly into the underlying meta-logic or type theory without sacrificing decidability and other desirable properties.
Reference: [Nip91] <author> Tobias Nipkow. </author> <title> Higher-order critical pairs. </title> <editor> In G. Kahn, editor, </editor> <booktitle> Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 342-349, </pages> <address> Am-sterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: In classical logic, for example, it is sometimes convenient to think of :(A ^ B) as the same formula as :A _ :B. Building equations into the representation of syntax has been recognized as a significant challenge and investigated in the context of logical frameworks by <ref> [Nip91] </ref> with a rapidly increasing literature regarding its operational properties [ALS94, Kah95, LP95, Pre95]. Finally, substitutions are often used in informal developments.
Reference: [Nip95] <author> Tobias Nipkow. </author> <title> More Church-Rosser proofs (in Isabelle/HOL). </title> <type> Unpublished manuscript, </type> <month> July </month> <year> 1995. </year>
Reference-contexts: Many experiments have been carried out following this methodology, including type inference [Pfe88], equational reasoning [Nip89], theorem proving [Fel89], functional programming [HM90, Han93], specification languages [MM93], VLSI design [Ros92], set theory [Pau93, Noe93], interpreter verification [BHN + 94] and the Church-Rosser theorem <ref> [Nip95, Ras95] </ref>. However, in many applications we need to go a step further and design a representation of derivations themselves as objects in the meta-language. A natural first choice for this representation is also the simply-typed -calculus. <p> In fact, this representation was designed in order to be able to give a completely rigorous proof of the Church-Rosser theorem for the untyped -calculus. It has subsequently been used in formalizations of this proof in NQTHM [Sha88], Coq [Hue94] and Isabelle <ref> [Nip95, Ras95] </ref>. Instead of completely rejecting higher-order abstract syntax, we can also relax the notion of inductive definition to obtain partial inductive definitions [Hal91].
Reference: [NJ89] <author> Gopalan Nadathur and Bharat Jayaraman. </author> <title> Towards a WAM model for Prolog. </title> <editor> In Ewing Lusk and Ross Overbeek, editors, </editor> <booktitle> Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pages 1180-1198, </pages> <address> Cleveland, Ohio, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: For example, compare the undecidability of higher-order unification with the efficiency of first-order unification. One way to recapture efficiency would be to compile or specialize the general search procedure to specific encoded logics. Only very preliminary work on this has been done <ref> [NJ89, MP93] </ref>. 5 Representing Meta-Theory Since logical frameworks are designed to express the language and inference rules of deductive systems at a very high level of abstraction, one rightly suspects that they should be amenable to an investigation of the meta-theory of deductive systems.
Reference: [NM88] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Fifth International Logic Programming Conference, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Washington, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: On the other hand, it strongly influenced the design of LF [HHP93], also called the Edinburgh Logical Framework (ELF). Concurrent with the development of LF, frameworks based on higher-order logic and resolution were designed in the form of generic theorem provers [Pau86, Pau89, NP92] and logic programming languages <ref> [NM88, MNPS91] </ref>. The type-theoretic and logic programming approaches were later combined in the Elf language [Pfe89, Pfe91a, Pfe92a, Pfe94]. <p> Tactics and Tacticals provide a popular mechanism to structure and program search. Tactics and tacticals arose out of the LCF theorem proving effort [GMW79, Pau83] and are used in such diverse systems as NuPrl [C + 86], Coq [DFH + 93], Isabelle [NP92], and Prolog <ref> [NM88, Fel93] </ref>. In all but the last 6 one, they are programmed in ML which was originally developed to support theorem proving for LCF. Logic programming offers a different approach to meta-programming.
Reference: [Noe93] <author> Philippe Noel. </author> <title> Experimenting with Isabelle in ZF set theory. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 10(1) </volume> <pages> 15-58, </pages> <year> 1993. </year>
Reference-contexts: Many experiments have been carried out following this methodology, including type inference [Pfe88], equational reasoning [Nip89], theorem proving [Fel89], functional programming [HM90, Han93], specification languages [MM93], VLSI design [Ros92], set theory <ref> [Pau93, Noe93] </ref>, interpreter verification [BHN + 94] and the Church-Rosser theorem [Nip95, Ras95]. However, in many applications we need to go a step further and design a representation of derivations themselves as objects in the meta-language. A natural first choice for this representation is also the simply-typed -calculus.
Reference: [NP92] <editor> Tobias Nipkow and Lawrence C. Paulson. Isabelle-91. In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 673-676, </pages> <address> Saratoga Springs, NY, </address> <year> 1992. </year> <note> Springer-Verlag LNAI 607. System abstract. </note>
Reference-contexts: On the other hand, it strongly influenced the design of LF [HHP93], also called the Edinburgh Logical Framework (ELF). Concurrent with the development of LF, frameworks based on higher-order logic and resolution were designed in the form of generic theorem provers <ref> [Pau86, Pau89, NP92] </ref> and logic programming languages [NM88, MNPS91]. The type-theoretic and logic programming approaches were later combined in the Elf language [Pfe89, Pfe91a, Pfe92a, Pfe94]. <p> Tactics and Tacticals provide a popular mechanism to structure and program search. Tactics and tacticals arose out of the LCF theorem proving effort [GMW79, Pau83] and are used in such diverse systems as NuPrl [C + 86], Coq [DFH + 93], Isabelle <ref> [NP92] </ref>, and Prolog [NM88, Fel93]. In all but the last 6 one, they are programmed in ML which was originally developed to support theorem proving for LCF. Logic programming offers a different approach to meta-programming.
Reference: [NPS90] <author> B. Nordstrom, K. Petersson, and J.M. Smith. </author> <title> Programming in Martin-Lof's Type Theory: An Introduction. </title> <publisher> Oxford University Press, </publisher> <year> 1990. </year> <month> 14 </month>
Reference-contexts: This entails that object language variables are represented by variables in the meta-language, and variables bound in the object language are bound with corresponding scope in the meta-language. This is the fundamental idea of higher-order abstract syntax [HHP93, PE88] which goes back to Martin-Lof's system of arities <ref> [NPS90] </ref>. Higher-order abstract syntax identifies expressions that differ only in the names assigned to their bound variables through ff-conversion in the meta-language.
Reference: [Pau83] <author> Lawrence Paulson. </author> <title> Tactics and tacticals in Cambridge LCF. </title> <type> Technical Report 39, </type> <institution> University of Cambridge, Computer Laboratory, </institution> <month> July </month> <year> 1983. </year>
Reference-contexts: Instead, we must look for methods that support interactive deduction while permitting heuristic searches to be programmed and automatic methods to be used when they exist. Tactics and Tacticals provide a popular mechanism to structure and program search. Tactics and tacticals arose out of the LCF theorem proving effort <ref> [GMW79, Pau83] </ref> and are used in such diverse systems as NuPrl [C + 86], Coq [DFH + 93], Isabelle [NP92], and Prolog [NM88, Fel93]. In all but the last 6 one, they are programmed in ML which was originally developed to support theorem proving for LCF.
Reference: [Pau86] <author> Lawrence C. Paulson. </author> <title> Natural deduction as higher-order resolution. </title> <journal> Journal of Logic Programming, </journal> <volume> 3 </volume> <pages> 237-258, </pages> <year> 1986. </year>
Reference-contexts: On the other hand, it strongly influenced the design of LF [HHP93], also called the Edinburgh Logical Framework (ELF). Concurrent with the development of LF, frameworks based on higher-order logic and resolution were designed in the form of generic theorem provers <ref> [Pau86, Pau89, NP92] </ref> and logic programming languages [NM88, MNPS91]. The type-theoretic and logic programming approaches were later combined in the Elf language [Pfe89, Pfe91a, Pfe92a, Pfe94]. <p> Variations of this approach to encoding derivability have been devised by Paulson <ref> [Pau86] </ref> and Felty and Miller [FM88]. Quantifiers in hereditary Harrop formulas are typed and range over simply-typed -terms, thus permitting the technique of higher-order abstract syntax. With a general implementation of the meta-logic, we can now reason within the object language and interpret the results via the adequacy theorem.
Reference: [Pau89] <author> Lawrence C. Paulson. </author> <title> The foundation of a generic theorem prover. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(3) </volume> <pages> 363-397, </pages> <year> 1989. </year>
Reference-contexts: On the other hand, it strongly influenced the design of LF [HHP93], also called the Edinburgh Logical Framework (ELF). Concurrent with the development of LF, frameworks based on higher-order logic and resolution were designed in the form of generic theorem provers <ref> [Pau86, Pau89, NP92] </ref> and logic programming languages [NM88, MNPS91]. The type-theoretic and logic programming approaches were later combined in the Elf language [Pfe89, Pfe91a, Pfe92a, Pfe94].
Reference: [Pau93] <author> Lawrence C. Paulson. </author> <title> Set theory for verification: I. From foundations to functions. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 11(3) </volume> <pages> 353-389, </pages> <year> 1993. </year>
Reference-contexts: Many experiments have been carried out following this methodology, including type inference [Pfe88], equational reasoning [Nip89], theorem proving [Fel89], functional programming [HM90, Han93], specification languages [MM93], VLSI design [Ros92], set theory <ref> [Pau93, Noe93] </ref>, interpreter verification [BHN + 94] and the Church-Rosser theorem [Nip95, Ras95]. However, in many applications we need to go a step further and design a representation of derivations themselves as objects in the meta-language. A natural first choice for this representation is also the simply-typed -calculus.
Reference: [PE88] <author> Frank Pfenning and Conal Elliott. </author> <title> Higher-order abstract syntax. </title> <booktitle> In Proceedings of the ACM SIGPLAN '88 Symposium on Language Design and Implementation, </booktitle> <pages> pages 199-208, </pages> <address> Atlanta, Georgia, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: This entails that object language variables are represented by variables in the meta-language, and variables bound in the object language are bound with corresponding scope in the meta-language. This is the fundamental idea of higher-order abstract syntax <ref> [HHP93, PE88] </ref> which goes back to Martin-Lof's system of arities [NPS90]. Higher-order abstract syntax identifies expressions that differ only in the names assigned to their bound variables through ff-conversion in the meta-language.
Reference: [Pfe88] <author> Frank Pfenning. </author> <title> Partial polymorphic type inference and higher-order unification. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 153-163, </pages> <address> Snowbird, Utah, July 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: With a general implementation of the meta-logic, we can now reason within the object language and interpret the results via the adequacy theorem. Many experiments have been carried out following this methodology, including type inference <ref> [Pfe88] </ref>, equational reasoning [Nip89], theorem proving [Fel89], functional programming [HM90, Han93], specification languages [MM93], VLSI design [Ros92], set theory [Pau93, Noe93], interpreter verification [BHN + 94] and the Church-Rosser theorem [Nip95, Ras95].
Reference: [Pfe89] <author> Frank Pfenning. </author> <title> Elf: A language for logic definition and verified meta-programming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 313-322, </pages> <address> Pacific Grove, California, June 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Concurrent with the development of LF, frameworks based on higher-order logic and resolution were designed in the form of generic theorem provers [Pau86, Pau89, NP92] and logic programming languages [NM88, MNPS91]. The type-theoretic and logic programming approaches were later combined in the Elf language <ref> [Pfe89, Pfe91a, Pfe92a, Pfe94] </ref>. At this point around 1988, there seems to have been in a pause in the development of new frameworks, while the potential and limitations of existing systems were explored in numerous experiments.
Reference: [Pfe91a] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Concurrent with the development of LF, frameworks based on higher-order logic and resolution were designed in the form of generic theorem provers [Pau86, Pau89, NP92] and logic programming languages [NM88, MNPS91]. The type-theoretic and logic programming approaches were later combined in the Elf language <ref> [Pfe89, Pfe91a, Pfe92a, Pfe94] </ref>. At this point around 1988, there seems to have been in a pause in the development of new frameworks, while the potential and limitations of existing systems were explored in numerous experiments. <p> For this reason, the logic programming language Elf uses neither Huet's algorithm nor a static pattern restriction, but a general higher-order constraint simplification algorithm <ref> [Pfe91a, Pfe91b] </ref>. This algorithm directly solves problems within Miller's decidable fragment, while other equations are postponed as constraints. On the positive side, this can drastically reduce backtracking compared to higher-order unification and imposes no restrictions on variable oc 7 currences.
Reference: [Pfe91b] <author> Frank Pfenning. </author> <title> Unification and anti-unification in the Calculus of Constructions. </title> <booktitle> In Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 74-85, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: For this reason, the logic programming language Elf uses neither Huet's algorithm nor a static pattern restriction, but a general higher-order constraint simplification algorithm <ref> [Pfe91a, Pfe91b] </ref>. This algorithm directly solves problems within Miller's decidable fragment, while other equations are postponed as constraints. On the positive side, this can drastically reduce backtracking compared to higher-order unification and imposes no restrictions on variable oc 7 currences.
Reference: [Pfe92a] <author> Frank Pfenning. </author> <title> Computation and deduction. </title> <note> Unpublished lecture notes, revised May 1994, </note> <month> May </month> <year> 1992. </year>
Reference-contexts: Concurrent with the development of LF, frameworks based on higher-order logic and resolution were designed in the form of generic theorem provers [Pau86, Pau89, NP92] and logic programming languages [NM88, MNPS91]. The type-theoretic and logic programming approaches were later combined in the Elf language <ref> [Pfe89, Pfe91a, Pfe92a, Pfe94] </ref>. At this point around 1988, there seems to have been in a pause in the development of new frameworks, while the potential and limitations of existing systems were explored in numerous experiments.
Reference: [Pfe92b] <author> Frank Pfenning. </author> <title> Dependent types in logic programming. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Types in Logic Programming, chapter 10, </booktitle> <pages> pages 285-311. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: They can still be executed due to the computational interpretation of meta-language Elf via logic programming search. This technique has been applied in a number of case studies such as program derivation [And93, And94a, And94b], type preservation [MP91], compiler verification [HP92a], CPS conversion [DP95], partial evaluation [Hat95], theorem proving <ref> [Pfe92b] </ref>, the Church-Rosser theorem [Pfe92c], and cut elimination [Pfe95]. With this technique we can implement and execute meta-theoretic proofs, but LF type checking alone cannot guarantee that a higher-level type family actually represents a meta-theoretic proof.
Reference: [Pfe92c] <author> Frank Pfenning. </author> <title> A proof of the Church-Rosser theorem and its representation in a logical framework. </title> <journal> Journal of Automated Reasoning. </journal> <note> To appear. A preliminary version is available as Carnegie Mellon Technical Report CMU-CS-92-186, </note> <month> September </month> <year> 1992. </year>
Reference-contexts: This technique has been applied in a number of case studies such as program derivation [And93, And94a, And94b], type preservation [MP91], compiler verification [HP92a], CPS conversion [DP95], partial evaluation [Hat95], theorem proving [Pfe92b], the Church-Rosser theorem <ref> [Pfe92c] </ref>, and cut elimination [Pfe95]. With this technique we can implement and execute meta-theoretic proofs, but LF type checking alone cannot guarantee that a higher-level type family actually represents a meta-theoretic proof.
Reference: [Pfe93] <author> Frank Pfenning. </author> <title> Refinement types for logical frameworks. </title> <editor> In Herman Geu-vers, editor, </editor> <booktitle> Informal Proceedings of the Workshop on Types for Proofs and Programs, </booktitle> <pages> pages 285-299, </pages> <address> Nijmegen, The Netherlands, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: In a first-order meta-language this problem can be addressed by using an order-sorted type system, but in higher-order languages these interact, sometimes in undesirable ways, with other features. Preliminary theoretical work to extend order-sorted techniques to logical frameworks is reported in <ref> [Pfe93, KP93] </ref>, but to our knowledge none has been implemented on a realistic scale. The variable convention is just one example where syntax is considered modulo a certain equivalence.
Reference: [Pfe94] <author> Frank Pfenning. </author> <title> Elf: A meta-language for deductive systems. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 811-815, </pages> <address> Nancy, France, </address> <month> June </month> <year> 1994. </year> <note> Springer-Verlag LNAI 814. System abstract. </note>
Reference-contexts: Concurrent with the development of LF, frameworks based on higher-order logic and resolution were designed in the form of generic theorem provers [Pau86, Pau89, NP92] and logic programming languages [NM88, MNPS91]. The type-theoretic and logic programming approaches were later combined in the Elf language <ref> [Pfe89, Pfe91a, Pfe92a, Pfe94] </ref>. At this point around 1988, there seems to have been in a pause in the development of new frameworks, while the potential and limitations of existing systems were explored in numerous experiments.
Reference: [Pfe95] <author> Frank Pfenning. </author> <title> Structural cut elimination. </title> <editor> In D. Kozen, editor, </editor> <booktitle> Proceedings of the Tenth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 156-166, </pages> <address> San Diego, California, June 1995. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: This technique has been applied in a number of case studies such as program derivation [And93, And94a, And94b], type preservation [MP91], compiler verification [HP92a], CPS conversion [DP95], partial evaluation [Hat95], theorem proving [Pfe92b], the Church-Rosser theorem [Pfe92c], and cut elimination <ref> [Pfe95] </ref>. With this technique we can implement and execute meta-theoretic proofs, but LF type checking alone cannot guarantee that a higher-level type family actually represents a meta-theoretic proof.
Reference: [Pol94] <author> Robert Pollack. </author> <title> The Theory of LEGO: A Proof Checker for the Extended Calculus of Constructions. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1994. </year>
Reference-contexts: On the one hand, this led to a number of systems for constructive mathematics and the extraction of functional programs from constructive proofs (for example, Nuprl [C + 86, CH90], LEGO <ref> [Pol94] </ref>, and Coq [DFH + 93]). On the other hand, it strongly influenced the design of LF [HHP93], also called the Edinburgh Logical Framework (ELF).
Reference: [Pol95] <author> Robert Pollack. </author> <title> A verified typechecker. </title> <editor> In M. Dezani-Ciancaglini and G. Plotkin, editors, </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <pages> pages 365-380, </pages> <address> Edinburgh, Scotland, </address> <month> April </month> <year> 1995. </year> <note> Springer-Verlag LNCS 902. 15 </note>
Reference-contexts: This cannot be considered as an inductive type, because of the negative occurrence of exp in the type of lam. An attempt to formulate a valid induction principle for the type exp fails. Several options have been explored to escape this dilemma. The first, for example used in <ref> [BC93, Fef88, MN94, Pol95] </ref> is to reject the notion of higher-order abstract syntax and use inductive representations directly. This is engenders a complication of the encoding and consequently of the meta-theory, which now has to deal with many lemmas regarding variable naming.
Reference: [PR92] <author> Frank Pfenning and Ekkehard Rohwedder. </author> <title> Implementing the meta-theory of deductive systems. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 537-551, </pages> <address> Saratoga Springs, New York, June 1992. </address> <publisher> Springer-Verlag LNAI 607. </publisher>
Reference-contexts: With this technique we can implement and execute meta-theoretic proofs, but LF type checking alone cannot guarantee that a higher-level type family actually represents a meta-theoretic proof. The design of an appropriate external validity condition for these relations and its implementation is the subject of current research described in <ref> [PR92, RP96, Roh96] </ref>. Presently, the external argument guaranteeing the meta-theorem has been carried out mechanically only for some of these above-mentioned experiments. An important challenge for logical frameworks is to reconcile induction principles with higher-order abstract syntax. Two approaches, using existing inductive calculi, are presented in [DH94, DFH95].
Reference: [Pre95] <author> Christian Prehofer. </author> <title> Solving Higher-Order Equations: From Logic to Programming. </title> <type> PhD thesis, </type> <institution> Technische Universitat Munchen, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Building equations into the representation of syntax has been recognized as a significant challenge and investigated in the context of logical frameworks by [Nip91] with a rapidly increasing literature regarding its operational properties <ref> [ALS94, Kah95, LP95, Pre95] </ref>. Finally, substitutions are often used in informal developments.
Reference: [PW90] <author> David Pym and Lincoln Wallen. </author> <title> Investigations into proof-search in a system of first-order dependent function types. In M.E. </title> <editor> Stickel, editor, </editor> <booktitle> Proceedings of the 10th International Conference on Automated Deduction, </booktitle> <pages> pages 236-250, </pages> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1990. </year> <note> Springer-Verlag LNCS 449. </note>
Reference-contexts: Methods for general proof search for LF have been investigated <ref> [PW90] </ref>, but a general and practically efficient theorem proving procedure for a logical framework remains an important area for further research. Generality, as found in a logical framework, often comes at the price of efficiency. For example, compare the undecidability of higher-order unification with the efficiency of first-order unification.
Reference: [Pym90] <author> David Pym. </author> <title> Proofs, Search and Computation in General Logic. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1990. </year> <note> Available as CST-69-90, also published as ECS-LFCS-90-125. </note>
Reference-contexts: Huet's algorithm has been used extensively in Prolog and Isabelle and generally seems to have good computational properties. It also generalizes smoothly from the simply-typed to the dependently typed case, as discovered independently by Elliott [Ell89, Ell90] and Pym <ref> [Pym90, Pym92] </ref>. The practical success of Huet's algorithm seems to be in part due to the fact that difficult, higher-order unification problems rarely arise in practice. An analysis of this observation led Miller [Mil91] to discover higher-order patterns, a sublanguage of the simply-typed -calculus with restricted variable occurrences.
Reference: [Pym92] <author> David Pym. </author> <title> A unification algorithm for the -calculus. </title> <journal> International Journal of Foundations of Computer Science, </journal> <volume> 3(3) </volume> <pages> 333-378, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Huet's algorithm has been used extensively in Prolog and Isabelle and generally seems to have good computational properties. It also generalizes smoothly from the simply-typed to the dependently typed case, as discovered independently by Elliott [Ell89, Ell90] and Pym <ref> [Pym90, Pym92] </ref>. The practical success of Huet's algorithm seems to be in part due to the fact that difficult, higher-order unification problems rarely arise in practice. An analysis of this observation led Miller [Mil91] to discover higher-order patterns, a sublanguage of the simply-typed -calculus with restricted variable occurrences.
Reference: [Qia93] <author> Zhenyu Qian. </author> <title> Linear unification of higher-order patterns. </title> <editor> In M.-C. Gaudel and J.-P. Jouannaud, editors, </editor> <booktitle> Proceedings of the Colloquium on Trees in Algebra and Programming, </booktitle> <pages> pages 391-405, </pages> <address> Orsay, France, April 1993. </address> <publisher> Springer-Verlag LNCS 668. </publisher>
Reference-contexts: An analysis of this observation led Miller [Mil91] to discover higher-order patterns, a sublanguage of the simply-typed -calculus with restricted variable occurrences. For this fragment, most general unifiers exist. In fact, the theoretical complexity of this problem is linear <ref> [Qia93] </ref>, just as for first-order unification. Miller proposed it as the basis for a lower-level language L similar to Prolog, but one where unification does not branch, since only higher-order patterns are permitted as terms.
Reference: [Ras95] <author> Ole Rasmussen. </author> <title> The Church-Rosser theorem in Isabelle: A proof porting experiment. </title> <type> Technical Report 364, </type> <institution> University of Cambridge, Computer Laboratory, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Many experiments have been carried out following this methodology, including type inference [Pfe88], equational reasoning [Nip89], theorem proving [Fel89], functional programming [HM90, Han93], specification languages [MM93], VLSI design [Ros92], set theory [Pau93, Noe93], interpreter verification [BHN + 94] and the Church-Rosser theorem <ref> [Nip95, Ras95] </ref>. However, in many applications we need to go a step further and design a representation of derivations themselves as objects in the meta-language. A natural first choice for this representation is also the simply-typed -calculus. <p> In fact, this representation was designed in order to be able to give a completely rigorous proof of the Church-Rosser theorem for the untyped -calculus. It has subsequently been used in formalizations of this proof in NQTHM [Sha88], Coq [Hue94] and Isabelle <ref> [Nip95, Ras95] </ref>. Instead of completely rejecting higher-order abstract syntax, we can also relax the notion of inductive definition to obtain partial inductive definitions [Hal91].
Reference: [Roh96] <author> Ekkehard Rohwedder. </author> <title> Verifying the Meta-Theory of Deductive Systems. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1996. </year> <month> Forthcoming. </month>
Reference-contexts: With this technique we can implement and execute meta-theoretic proofs, but LF type checking alone cannot guarantee that a higher-level type family actually represents a meta-theoretic proof. The design of an appropriate external validity condition for these relations and its implementation is the subject of current research described in <ref> [PR92, RP96, Roh96] </ref>. Presently, the external argument guaranteeing the meta-theorem has been carried out mechanically only for some of these above-mentioned experiments. An important challenge for logical frameworks is to reconcile induction principles with higher-order abstract syntax. Two approaches, using existing inductive calculi, are presented in [DH94, DFH95].
Reference: [Ros92] <author> Lars Rossen. </author> <title> A Relational Approach to Sequential VLSI Design. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Technical University of Denmark, </institution> <year> 1992. </year>
Reference-contexts: Many experiments have been carried out following this methodology, including type inference [Pfe88], equational reasoning [Nip89], theorem proving [Fel89], functional programming [HM90, Han93], specification languages [MM93], VLSI design <ref> [Ros92] </ref>, set theory [Pau93, Noe93], interpreter verification [BHN + 94] and the Church-Rosser theorem [Nip95, Ras95]. However, in many applications we need to go a step further and design a representation of derivations themselves as objects in the meta-language.
Reference: [RP96] <author> Ekkehard Rohwedder and Frank Pfenning. </author> <title> Mode and termination checking for higher-order logic programs. </title> <editor> In Hanne Riis Nielson, editor, </editor> <booktitle> Proceedings of the European Symposium on Programming, </booktitle> <address> Linkoping, Sweden, </address> <month> April </month> <year> 1996. </year> <note> Springer-Verlag LNCS. To appear. </note>
Reference-contexts: With this technique we can implement and execute meta-theoretic proofs, but LF type checking alone cannot guarantee that a higher-level type family actually represents a meta-theoretic proof. The design of an appropriate external validity condition for these relations and its implementation is the subject of current research described in <ref> [PR92, RP96, Roh96] </ref>. Presently, the external argument guaranteeing the meta-theorem has been carried out mechanically only for some of these above-mentioned experiments. An important challenge for logical frameworks is to reconcile induction principles with higher-order abstract syntax. Two approaches, using existing inductive calculi, are presented in [DH94, DFH95].
Reference: [SH91] <author> Peter Schroeder-Heister. </author> <title> Structural frameworks, substructural logics, and the role of elimination inferences. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 385-403. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: This hiatus has recently come to a close with implementations of frameworks based on inductive definitions such as FS0 [Fef88, MSB93] and ALF [Mag95], partial inductive definitions [Hal91, Eri93, Eri94] and substructural logics <ref> [SH91, Gir93, Mil94, Cer96] </ref>. There is a different approach to logical frameworks based on equational rather than deductive reasoning. While one can be interpreted in the other without much difficulty, the meta-languages based on equational reasoning take a rather different form and we will not discuss them here.
Reference: [Sha88] <author> N. Shankar. </author> <title> A mechanical proof of the Church-Rosser theorem. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 35(3) </volume> <pages> 475-522, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Using de Bruijn indices [dB72] alleviates this problem somewhat. In fact, this representation was designed in order to be able to give a completely rigorous proof of the Church-Rosser theorem for the untyped -calculus. It has subsequently been used in formalizations of this proof in NQTHM <ref> [Sha88] </ref>, Coq [Hue94] and Isabelle [Nip95, Ras95]. Instead of completely rejecting higher-order abstract syntax, we can also relax the notion of inductive definition to obtain partial inductive definitions [Hal91].
Reference: [vdPS95] <author> J. van de Pol and H. Schwichtenberg. </author> <title> Strict functionals for termination proofs. </title> <editor> In M. Dezani-Ciancaglini and G. Plotkin, editors, </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <pages> pages 350-364, </pages> <address> Edinburgh, Scotland, April 1995. </address> <publisher> Springer-Verlag LNCS 902. </publisher>
Reference-contexts: Termination orderings and higher-order, dependently typed rewriting provide tools which should significantly extend the scope of the methods sketched here. Some work along these lines can be found in <ref> [Geh95, Kah95, LP95, vdPS95] </ref>. High-level representations of deductive systems allow proofs of their properties to be implemented quickly and efficiently. Yet the current degree of automation is not satisfactory.
Reference: [Vir95] <author> Roberto Virga. </author> <title> Higher-order superposition for dependent types. </title> <type> Technical Report CMU-CS-95-150, </type> <institution> Carnegie Mellon University, </institution> <year> 1995. </year> <month> 16 </month>
Reference-contexts: Some promising work in this direction includes reflection [Con94] and dependently typed rewriting <ref> [Vir95] </ref>. 4 Search and Meta-Programming The representation of a deductive system in a logical framework may be used for a variety of purposes. The obvious application is to construct derivations within a deductive system, with the support of the framework implementation.
References-found: 106

