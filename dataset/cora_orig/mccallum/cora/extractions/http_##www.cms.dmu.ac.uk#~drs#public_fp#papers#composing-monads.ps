URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/composing-monads.ps
Refering-URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/
Root-URL: 
Email: jones-mark@cs.yale.edu  ldup@ra.alcbel.be  
Title: Composing monads  
Author: Mark P. Jones Luc Duponcheel 
Date: December 1993  
Address: New Haven, CT, U.S.A.  Belgium  
Affiliation: Yale University  Alcatel Bell Telephone Antwerp,  
Pubnum: Research Report YALEU/DCS/RR-1004,  
Abstract: Monads are becoming an increasingly important tool for functional programming. Different monads can be used to model a wide range of programming language features. However, real programs typically require a combination of different features, so it is important to have techniques for combining several features in a single monad. In practice, it is usually possible to construct a monad that supports some specific combination of features. However, the techniques used are typically ad-hoc and it is very difficult to find general techniques for combining arbitrary monads. This report gives three general constructions for the composition of monads, each of which depends on the existence of an auxiliary function linking the monad structures of the components. In each case, we establish a set of laws that the auxiliary function must satisfy to ensure that the composition is itself a monad. Using the notation of constructor classes, we describe some specific applications of these constructions. These results are used in the development of a simple expression evaluator that combines exceptions, output and an environment of variable bindings using a composition of three corresponding monads.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Duponcheel. </author> <title> A short note on monad and monad morphism composition. </title> <institution> Alcatel Bell Telephone, Antwerp, B-2018, Belgium. </institution> <type> Manuscript, </type> <month> September </month> <year> 1993. </year>
Reference-contexts: To this end, in a number of places, we have intentionally chosen to give definitions or results without reference to the corresponding categorical concepts. Readers with an interest in a more technical, category theoretic presentation of the ideas described in this report are referred to <ref> [1] </ref>. We will assume some familiarity with the motivation for monads and their use in structuring functional programs; Wadler [14, 15] provides an excellent introduction to these topics. <p> of properties of prod , including: prod : map (join : map prod ) = join : map prod : prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], <ref> [1, 2] </ref>, [3, 4], [3, 2]] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all we know <p> prod : prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], <ref> [1, 2] </ref>, [3, 4], [3, 2]] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all we know is that it is not possible using the constructions described in this report. 6.5 Some additional monad compositions
Reference: [2] <author> C. Hall, K. Hammond, W. Partain, S.L. Peyton Jones and P. Wadler. </author> <title> The Glasgow Haskell compiler: a retrospective. </title> <booktitle> In Proceedings of the 1992 Glasgow Workshop on Functional Programming, </booktitle> <address> Ayr, Scotland, July 1992. </address> <publisher> Springer Verlag Workshops in computing series. </publisher>
Reference-contexts: Monads are already widely used in both small and large programs (for example, the Glasgow Haskell compiler, the largest Haskell program known to us at the time of writing, makes substantial use of monads <ref> [2] </ref>). New approaches to old problems have been proposed, relying heavily on the use of monads. For example, the I/O monad proposed in [11] is already widely used and may soon be included as part of the definition of Haskell. Monads are even influencing the design of programming languages. <p> of properties of prod , including: prod : map (join : map prod ) = join : map prod : prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], <ref> [1, 2] </ref>, [3, 4], [3, 2]] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all we know <p> , including: prod : map (join : map prod ) = join : map prod : prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [1, 2], [3, 4], <ref> [3, 2] </ref>] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all we know is that it is <p> prod : prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], <ref> [1, 2] </ref>, [3, 4], [3, 2]] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all we know is that it is not possible using the constructions described in this report. 6.5 Some additional monad compositions <p> prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [1, 2], [3, 4], <ref> [3, 2] </ref>] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all we know is that it is not possible using the constructions described in this report. 6.5 Some additional monad compositions The following
Reference: [3] <editor> P. Hudak, S.L. Peyton Jones and P. Wadler (eds.). </editor> <title> Report on the programming language Haskell, version 1.2. </title> <journal> ACM SIGPLAN notices, </journal> <volume> 27, 5, </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Programming examples will be written using the syntax of Gofer, a small, experimental, purely functional language based closely on the definition of Haskell <ref> [3] </ref>. This enables us to use constructor classes [5] to show how our results can be expressed in a concrete programming language. For completeness, we have included detailed proofs for many of our results. <p> In this section, we present a general framework for working with different forms of monad composition. Later, we will describe a number of concrete examples of monad composition, and use some of these in a simple application. 5.1 Representing functors The Haskell programming language <ref> [3] </ref> makes use of a system of type classes to provide a flexible treatment of ad-hoc polymorphism. A type class is a set of types, often referred to as the instances of the class, together with a family of operations that are defined for each instance. <p> of prod , including: prod : map (join : map prod ) = join : map prod : prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [1, 2], <ref> [3, 4] </ref>, [3, 2]] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all we know is that <p> , including: prod : map (join : map prod ) = join : map prod : prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [1, 2], [3, 4], <ref> [3, 2] </ref>] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all we know is that it is <p> : map prod : prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [1, 2], <ref> [3, 4] </ref>, [3, 2]] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all we know is that it is not possible using the constructions described in this report. 6.5 Some additional <p> prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [1, 2], [3, 4], <ref> [3, 2] </ref>] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all we know is that it is not possible using the constructions described in this report. 6.5 Some additional monad compositions The following
Reference: [4] <author> G. Hutton. </author> <title> Higher-order functions for parsing. </title> <journal> Journal of Functional Programming, </journal> <volume> volume 2, part 3, </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: a number of properties of prod , including: prod : map (join : map prod ) = join : map prod : prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] <ref> [[1, 4] </ref>, [1, 2], [3, 4], [3, 2]] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all <p> of prod , including: prod : map (join : map prod ) = join : map prod : prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [1, 2], <ref> [3, 4] </ref>, [3, 2]] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all we know is that <p> = join : map prod : prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] <ref> [[1, 4] </ref>, [1, 2], [3, 4], [3, 2]] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all we know is that it is not possible using the constructions described in this report. 6.5 <p> : map prod : prod : However, using the following, somewhat contrived counter example, we find that this law does not always hold: ? (prod . map (join . map prod)) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [1, 2], <ref> [3, 4] </ref>, [3, 2]] ? (join . map prod . prod) [[[[[1],[3]]]],[[[[4]]],[[[2]]]]] [[1, 4], [3, 4], [1, 2], [3, 2]] Of course, none of what we have said here proves that it is impossible to construct monads by composition of arbitrary monads with the list monad; all we know is that it is not possible using the constructions described in this report. 6.5 Some additional <p> m s) where join (STM xss) = STM (ns ! [ (s 00 ; x ) j (STM xs; s 0 ) xss s; (s 00 ; x ) xs s 0 ]) For example, a monad of this form is often used in the construction of a combinator parser <ref> [4, 14, 15] </ref>. In this kind of application, we use the stream of tokens to be parsed as the state.
Reference: [5] <author> M.P. Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymorphism. </title> <booktitle> In Proceedings of the 6th ACM conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Copenhagen, Denmark, </address> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: For example, the I/O monad proposed in [11] is already widely used and may soon be included as part of the definition of Haskell. Monads are even influencing the design of programming languages. For example, monads provide an important motivating example for the system of constructor classes presented in <ref> [5] </ref>. With the exception of [8], questions about how monads can be combined have, so far, received surprisingly little attention. This is an important topic because many real programs require a combination of features, for example, state, I/O and exceptions. <p> Programming examples will be written using the syntax of Gofer, a small, experimental, purely functional language based closely on the definition of Haskell [3]. This enables us to use constructor classes <ref> [5] </ref> to show how our results can be expressed in a concrete programming language. For completeness, we have included detailed proofs for many of our results. In keeping with our aim to avoid unnecessary technical details, most of the proofs are constructed from first principles using simple equational reasoning. <p> The bind operator is particularly useful in practical work with monads and as a means of translating the notation of monad comprehensions <ref> [14, 15, 5] </ref>. Furthermore, only three laws are needed to specify the properties of a monad in this case. Nevertheless, we have chosen to work with the map, unit, join formulation of monads outlined above. <p> For convenience, we will use the notation of constructor classes <ref> [5] </ref> implemented as part of the Gofer system, although the same ideas can also be applied to a much wider range of languages. In this section, we present a general framework for working with different forms of monad composition. <p> For example, one common application of monads is to model state-based computations using state transformers; i.e. functions taking an initial state and returning a pair containing a final state and a return value of some type. This is described, for example in <ref> [5] </ref>, using a type constructor: data State s a = ST (s ! (s; a)) 39 The type s used here gives the type of values used for the state while a represents the type of return values. <p> Perhaps there is another general construction for combining two monads that could be applied to (s !) and Writer s to obtain a state monad? As a more interesting example, we can combine a simple state monad with an arbitrary using the following definitions, adapted from <ref> [5] </ref>: data StateM m s a = STM (s ! m (s; a)) instance Monad m ) Functor (StateM m s) where map f (STM xs) = STM (ns ! [ (s 0 ; f x ) j (s 0 ; x ) xs s ]) instance Monad m ) Premonad
Reference: [6] <author> M. Jones and P. Hudak. </author> <title> Implicit and Explicit Parallel Programming in Haskell. </title> <institution> Yale University, Department of Computer Science, Research Report YALEU/DCS/RR-982, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: However, it is not possible to remove the restrictions altogether. In particular, our constructions cannot be used to compose the List monad with itself. The importance of commutative monads has also been recognized in other situations. For example, in <ref> [6] </ref>, monads satisfying the commutativity axiom are used to capture explicit parallel execution of programs written in a monadic style. 6.4.1 Composing a monad with itself In Section 2 we commented that, just by looking at the types involved, it was clear that a definition join = join M : join
Reference: [7] <author> R.B. Kieburtz, B. Agapiev and J. Hook. </author> <title> Three Monads for Continuations. </title> <booktitle> In Pro ceedings of the ACM SIGPLAN Workshop on Continuations, </booktitle> <institution> Department of Computer Science, Stanford University, </institution> <note> Report No. STAN-CS-92-1462, </note> <month> June </month> <year> 1992. </year>
Reference-contexts: Examples of this include the strictness monad in [14], state transformers in [10] and `composable contexts' in <ref> [7] </ref>. In a similar way, we expect the composition of arbitrary monads with List may still be useful in practical programming applications, even though the associativity law does not always hold.
Reference: [8] <author> D.J. King and P. Wadler. </author> <title> Combining monads. </title> <booktitle> In Proceedings of the Fifth Annual Glasgow Workshop on Functional Programming, </booktitle> <address> Ayr, Scotland, </address> <publisher> Springer Verlag Workshops in Computer Science, </publisher> <year> 1992. </year>
Reference-contexts: Monads are even influencing the design of programming languages. For example, monads provide an important motivating example for the system of constructor classes presented in [5]. With the exception of <ref> [8] </ref>, questions about how monads can be combined have, so far, received surprisingly little attention. This is an important topic because many real programs require a combination of features, for example, state, I/O and exceptions. <p> In keeping with our aim to avoid unnecessary technical details, most of the proofs are constructed from first principles using simple equational reasoning. Working in this manner has lead to some surprising insights. For example, one of our results in Section 3 corresponds closely to a result stated in <ref> [8] </ref>, but a careful study of the laws that are actually used in the proof has allowed us to weaken the hypotheses and state the result in a slightly more general form. <p> In contrast, King and Wadler <ref> [8] </ref> give a slightly different construction which seems more general, avoiding any restrictions on the choice of monads that can be composed with List. <p> Unfortunately, this promise of a more general construction turns out to be something of a mirage; although developed in a rather different manner, their approach turns out to be equivalent to our prod construction and does, in fact, require some form of commutativity. The construction given in <ref> [8] </ref>, is based on the definitions: () :: Monad m ) m [a] ! m [a] ! m [a] a b = [ x ++ y j x a; y b ] prod :: Monad m ) [m [a]] ! m [a] prod = foldr () (unit [ ]) This prod
Reference: [9] <author> E. Moggi. </author> <title> Computational lambda-calculus and monads. </title> <booktitle> IEEE Symposium on Logic in Computer Science, Asilomar, </booktitle> <address> California, </address> <year> 1989. </year>
Reference-contexts: containing executable versions of the programs described in this report is currently available by anonymous ftp from nebula.cs.yale.edu in the file pub/yale-fp/reports/RR-1004.gs. 1 Much of the initial interest in monads has been motivated by the work of Wadler [14, 15] who, in turn, drew inspiration from the work of Moggi <ref> [9] </ref> and Spivey [12]. Monads are already widely used in both small and large programs (for example, the Glasgow Haskell compiler, the largest Haskell program known to us at the time of writing, makes substantial use of monads [2]).
Reference: [10] <author> M. Odersky, D. Rabin and P. Hudak. </author> <title> Call by name, assignment, and the lambda calculus. </title> <booktitle> In 20th Annual Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, South Carolina, </address> <year> 1993. </year>
Reference-contexts: In practice, there are several examples where the basic framework suggested by the types of the monad operators is useful in practical programming examples, even though the corresponding monad laws are not all satisfied. Examples of this include the strictness monad in [14], state transformers in <ref> [10] </ref> and `composable contexts' in [7]. In a similar way, we expect the composition of arbitrary monads with List may still be useful in practical programming applications, even though the associativity law does not always hold.
Reference: [11] <author> S.L. Peyton Jones and P. Wadler. </author> <title> Imperative functional programming. </title> <booktitle> In 20th An nual Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, South Car-olina, </address> <year> 1993. </year> <month> 43 </month>
Reference-contexts: New approaches to old problems have been proposed, relying heavily on the use of monads. For example, the I/O monad proposed in <ref> [11] </ref> is already widely used and may soon be included as part of the definition of Haskell. Monads are even influencing the design of programming languages. For example, monads provide an important motivating example for the system of constructor classes presented in [5].
Reference: [12] <author> M. Spivey. </author> <title> A functional theory of exceptions. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14(1), </volume> <year> 1990. </year>
Reference-contexts: of the programs described in this report is currently available by anonymous ftp from nebula.cs.yale.edu in the file pub/yale-fp/reports/RR-1004.gs. 1 Much of the initial interest in monads has been motivated by the work of Wadler [14, 15] who, in turn, drew inspiration from the work of Moggi [9] and Spivey <ref> [12] </ref>. Monads are already widely used in both small and large programs (for example, the Glasgow Haskell compiler, the largest Haskell program known to us at the time of writing, makes substantial use of monads [2]). <p> We will also present some further examples using the same techniques to obtain compositions with other standard monads. 24 6.1 The Maybe datatype The Maybe datatype, used in <ref> [12] </ref> to model a form of exception handling, is defined by: data Maybe a = Just a j Nothing There is a natural functor and monad structure corresponding to this datatype, given by the following declarations (proofs that these functions satisfy the appropriate laws are left as an exercise for the
Reference: [13] <author> G.L. Steele Jr. </author> <title> Building interpreters by composing monads. </title> <booktitle> To appear in proceed ings of 21st annual ACM SIGPLAN-SIGACT symposium on Principles of Programming Languages, </booktitle> <address> Portland, Oregon, </address> <month> January </month> <year> 1994 </year>
Reference-contexts: For example, the constructors PComp m Maybe, DComp (r !) m, and StateM m s are all examples of this with a hole represented by the parameter m. A similar idea motivates the recent work of Steele <ref> [13] </ref> except that the holes are built into so-called pseudomonad operators rather than individual constructors. The pseudomonad operators are difficult to express properly in the Haskell type system and appear to require some form of existential or recursive typing. <p> p a ! (a ! m (p b)) ! m (p b) pjoin :: Monad m ) p (m (p a)) ! m (p a) pjoin m = m `pbind ` id m `pbind ` f = pjoin (map f m) The pbind function is included for those familiar with <ref> [13] </ref> and provides a pseudomonad version of the monadic bind operator mentioned in Section 2. The pjoin function is not used by Steele, but is included because of its close relationship to the join-based formulation of monads used in this report.
Reference: [14] <author> P. Wadler. </author> <title> Comprehending Monads. </title> <note> Mathematical Structures in Computer Science, 2, 4 (December 1992). An earlier version appears in Conference on LISP and Functional Programming, </note> <institution> Nice, France, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: as specific instances of a more general concept. fl A Gofer script containing executable versions of the programs described in this report is currently available by anonymous ftp from nebula.cs.yale.edu in the file pub/yale-fp/reports/RR-1004.gs. 1 Much of the initial interest in monads has been motivated by the work of Wadler <ref> [14, 15] </ref> who, in turn, drew inspiration from the work of Moggi [9] and Spivey [12]. <p> Readers with an interest in a more technical, category theoretic presentation of the ideas described in this report are referred to [1]. We will assume some familiarity with the motivation for monads and their use in structuring functional programs; Wadler <ref> [14, 15] </ref> provides an excellent introduction to these topics. Programming examples will be written using the syntax of Gofer, a small, experimental, purely functional language based closely on the definition of Haskell [3]. <p> A simple application, building on this framework, is included in Section 7. Finally, Section 8 illustrates that there are other ways of combining certain monads, setting a direction for future work. 2 Monads for functional programming Wadler <ref> [14] </ref> defines a monad as a unary type constructor M together with three functions map, unit and join whose types are given by: map :: (a ! b) ! (M a ! M b) unit :: a ! M a join :: M (M a) ! M a In addition, these <p> The bind operator is particularly useful in practical work with monads and as a means of translating the notation of monad comprehensions <ref> [14, 15, 5] </ref>. Furthermore, only three laws are needed to specify the properties of a monad in this case. Nevertheless, we have chosen to work with the map, unit, join formulation of monads outlined above. <p> Several functional programming languages, including Haskell and Gofer, provide a special syntax for list comprehensions which allow some list-based computations to be expressed very clearly and concisely. Lists form a monad (see Section 6.4 for details) and, noticing this, Wadler <ref> [14] </ref> showed how the comprehension notation could be generalized to an arbitrary monad. A comprehension is written using the notation [ exp j gs ] where exp is an expression and gs is a list of generators i.e. expressions of the form x e. <p> Using the monad laws, we can show that the way in which these rules are used to find a translation of a monad comprehension does not have any effect on the meaning of the result. See <ref> [14] </ref> for further details. <p> m s) where join (STM xss) = STM (ns ! [ (s 00 ; x ) j (STM xs; s 0 ) xss s; (s 00 ; x ) xs s 0 ]) For example, a monad of this form is often used in the construction of a combinator parser <ref> [4, 14, 15] </ref>. In this kind of application, we use the stream of tokens to be parsed as the state. <p> In practice, there are several examples where the basic framework suggested by the types of the monad operators is useful in practical programming examples, even though the corresponding monad laws are not all satisfied. Examples of this include the strictness monad in <ref> [14] </ref>, state transformers in [10] and `composable contexts' in [7]. In a similar way, we expect the composition of arbitrary monads with List may still be useful in practical programming applications, even though the associativity law does not always hold.
Reference: [15] <author> P. Wadler. </author> <title> The essence of functional programming. </title> <booktitle> In 19th Annual Symposium on Principles of Programming Languages, </booktitle> <address> Santa Fe, New Mexico, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: as specific instances of a more general concept. fl A Gofer script containing executable versions of the programs described in this report is currently available by anonymous ftp from nebula.cs.yale.edu in the file pub/yale-fp/reports/RR-1004.gs. 1 Much of the initial interest in monads has been motivated by the work of Wadler <ref> [14, 15] </ref> who, in turn, drew inspiration from the work of Moggi [9] and Spivey [12]. <p> Readers with an interest in a more technical, category theoretic presentation of the ideas described in this report are referred to [1]. We will assume some familiarity with the motivation for monads and their use in structuring functional programs; Wadler <ref> [14, 15] </ref> provides an excellent introduction to these topics. Programming examples will be written using the syntax of Gofer, a small, experimental, purely functional language based closely on the definition of Haskell [3]. <p> For example, Wadler <ref> [15] </ref> describes how a monad can be characterized using just the unit function together with an operator bind :: M a ! (a ! M b) ! M b Both the map and join operators that we have described can be defined using bind and unit. <p> The bind operator is particularly useful in practical work with monads and as a means of translating the notation of monad comprehensions <ref> [14, 15, 5] </ref>. Furthermore, only three laws are needed to specify the properties of a monad in this case. Nevertheless, we have chosen to work with the map, unit, join formulation of monads outlined above. <p> m s) where join (STM xss) = STM (ns ! [ (s 00 ; x ) j (STM xs; s 0 ) xss s; (s 00 ; x ) xs s 0 ]) For example, a monad of this form is often used in the construction of a combinator parser <ref> [4, 14, 15] </ref>. In this kind of application, we use the stream of tokens to be parsed as the state.
References-found: 15

