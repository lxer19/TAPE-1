URL: http://choices.cs.uiuc.edu/2k/papers/CompConfig-TR.ps.gz
Refering-URL: http://choices.cs.uiuc.edu/2k/
Root-URL: http://www.cs.uiuc.edu
Email: -f-kon,roy-@cs.uiuc.edu http://choices.cs.uiuc.edu  
Title: On the Role of Inter-Component Dependence in Supporting Automatic Reconfiguration  
Author: Fabio Kon Roy H. Campbell 
Note: This research is supported by a grant from the National Science Foundation, NSF 98-70736. Fabio Kon is supported in part by a grant from CAPES, the Brazilian Research Agency, proc.#1405/95-2.  
Date: December, 1998  
Address: 1304 West Springfield Avenue, Urbana, IL 61801-2987 USA  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Pubnum: Report No. UIUCDCS-R-98-2080, UILU-ENG-98-1738  
Abstract: An updated description of the work presented in this report is going to appear in the 5th USENIX Conference on Object-Oriented Technologies and Systems (COOTS'99). 
Abstract-found: 1
Intro-found: 1
Reference: [Bar98] <author> Saulo Barros. </author> <title> The Regional Atmospheric Modeling System (RAMS) Project. </title> <note> http: //www.ime.usp.br/~rams/, 1998. </note>
Reference-contexts: In addition, the Java implementation is being used by researchers at the University of S~ao Paulo to prototype a domain decomposition manager. This manager has two demonstration applications: a Distributed Information System for Mobile Agents [SGE98] and the parallelization of an Atmospheric Modeling System <ref> [Bar98] </ref>. Work on implementations of the framework in Java RMI and CORBA is underway. We will use them in the 2K distributed operating system. As discussed in 3.2, the ComponentConfigurator will be used in 2K to support runtime architectural awareness as the basis for implementing fault-tolerant reconfigurable systems.
Reference: [BG98] <author> Elisa Bertino and Giovanna Guerrini. </author> <title> Extending the ODMG Object Model with Composite Objects. </title> <booktitle> In Proceedings of the OOPSLA'98, </booktitle> <month> October </month> <year> 1998. </year>
Reference-contexts: This extra information helps the system to provide fault-tolerance and automatic configuration and offers Components the possibility of being aware of their dependencies. Bertino and Guerrini <ref> [BG98] </ref> extended the ODMG object database standard data model to include the concept of Composite objects. An extension of the ODMG object definition language (ODL) is used to specify the semantics of the dependencies between composite objects and their components.
Reference: [BSP + 95] <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. E. Fiuczynski, D. Becker, C. Chabers, and S. Eggers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In Proceedings of the 15th Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Previous research in microkernels and customizable operating systems such as Mach [Lop91], SPIN <ref> [BSP + 95] </ref>, L4 [Her97], Exokernel [KEG + 97], and Choices [LTC96] developed low-level techniques for dynamic loading new modules to the operating system both in kernel and user space. Nevertheless, a high-level model for operating system reconfiguration is still inexistent.
Reference: [Chi95] <author> Shigeru Chiba. </author> <title> A Metaobject Protocol for C++. </title> <booktitle> In Proceedings of the OOPSLA'95, </booktitle> <pages> pages 285-299, </pages> <month> October </month> <year> 1995. </year> <month> 14 </month>
Reference-contexts: In order to avoid a proliferation of programming errors related to dependence reification, it would be necessary to develop special languages, compilers, and runtime systems to guarantee the safety of component execution. A cleaner solution is to use existing reflective languages and environments [Coi96]. Iguana [GC96] and OpenC++ <ref> [Chi95] </ref>, for example, are extensions to C++ that reify several features of this language, allowing dynamic modification of their implementations. In these languages, it would be possible to instrument method invocation to take care of dependence maintenance. <p> adapting the system and its components to changing parameters such as network bandwidth, CPU load, resource availability, user access patterns, etc. 4 Related Work The idea of having a ComponentConfigurator object associated with Components is similar to the concept of meta-objects utilized by reflective systems such as CLOS [KdRB91], OpenC++ <ref> [Chi95] </ref>, Iguana [GC96], and Apertos [ILY95]. In these systems, meta-objects can be used to customize all aspects of object behavior. On the other hand, the intent of the ComponentConfigurator is 12 not to modify the Component behavior but to maintain extra information about inter-component dependence.
Reference: [CNM98] <author> Roy H. Campbell, Klara Nahrstedt, and M. Dennis Mickunas. </author> <title> 2K: A Component-Based Network-Centric Operating System. Project home page: </title> <address> http://choices.cs.uiuc. edu/2K, </address> <year> 1998. </year>
Reference-contexts: We will select an existing solution or develop a new customized language to represent and process requirement information. The language must allow processing specifications at execution time with little overhead. We will then deploy it in 2K , a new distributed operating system <ref> [KSC + 98, CNM98] </ref> currently under development. <p> It is used to represent and manipulate the internal structure of dynamicTAO. We, then, discuss how this framework will be used to support architectural awareness in the 2K distributed operating system. 3.1 dynamicTAO One of the major constituent elements of the 2K distributed operating system <ref> [KSC + 98, CNM98] </ref> is a reflective middleware layer based on CORBA. After carefully studying existing Object Request Brokers, we came to the conclusion that the TAO ORB [SC98] would be the best starting point for developing our infrastructure.
Reference: [Coi96] <author> Pierre Cointe. </author> <title> Reflective languages and metalevel architectures. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(4es):151, </volume> <month> December </month> <year> 1996. </year>
Reference-contexts: In order to avoid a proliferation of programming errors related to dependence reification, it would be necessary to develop special languages, compilers, and runtime systems to guarantee the safety of component execution. A cleaner solution is to use existing reflective languages and environments <ref> [Coi96] </ref>. Iguana [GC96] and OpenC++ [Chi95], for example, are extensions to C++ that reify several features of this language, allowing dynamic modification of their implementations. In these languages, it would be possible to instrument method invocation to take care of dependence maintenance.
Reference: [Den97] <author> Adam Denning. </author> <title> ActiveX Controls Inside Out. </title> <publisher> Microsoft Press, </publisher> <address> Redmond, </address> <note> second edition, </note> <year> 1997. </year>
Reference-contexts: Rather than being an alternative to object-orientation, component technology extends the initial concepts of objects. It stresses the desire for independent pieces of software that can be reused and combined in different ways to implement complex software systems. Recently developed component architectures <ref> [Ham97, Den97, OMG97] </ref> support the construction of sophisticated systems by assembling together a collection of off-the-shelf software components with the help of visual tools or programmatic interfaces. However, there is still very little support for managing the interactions between components.
Reference: [FK98] <author> Svend Frolund and Jari Koistinen. </author> <title> Quality of Service Specification in Distributed Object Systems Design. </title> <booktitle> In Proceedings of the 4th USENIX Conference on Object-Oriented Technology and Systems (COOTS), </booktitle> <address> Santa Fe, New Mexico, </address> <month> April </month> <year> 1998. </year>
Reference-contexts: QoS-aware systems can use these data to enable proper admission control, resource negotiation, and resource reservation. The last item is the one which determines which auxiliary components must be loaded and in which kind of software environment they will execute. Our group is studying QoS specification languages <ref> [FK98, LBS + 98] </ref>. We will select an existing solution or develop a new customized language to represent and process requirement information. The language must allow processing specifications at execution time with little overhead.
Reference: [GC89] <author> Cary G. Gray and David R. Cheriton. Leases: </author> <title> An Efficient Fault-Tolerant Mechanism for Distributed File Cache Consistency. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 202-210, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: This can be addressed by assigning an expiration time to the validity of the reified dependencies between components. This mechanism is known as leases <ref> [GC89] </ref> and is also used in other contexts like the SODA distributed file system [KM95] and JINI [Wal98]. After a lease is expired, a component may assume that the dependency no longer exists and complete its destruction process.
Reference: [GC96] <author> Brendan Gowing and Vinny Cahill. </author> <title> Meta-object protocols for C++: The iguana approach. </title> <booktitle> In Proceedings of Reflection '96, </booktitle> <pages> pages 137-152, </pages> <address> San Francisco, USA, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: In order to avoid a proliferation of programming errors related to dependence reification, it would be necessary to develop special languages, compilers, and runtime systems to guarantee the safety of component execution. A cleaner solution is to use existing reflective languages and environments [Coi96]. Iguana <ref> [GC96] </ref> and OpenC++ [Chi95], for example, are extensions to C++ that reify several features of this language, allowing dynamic modification of their implementations. In these languages, it would be possible to instrument method invocation to take care of dependence maintenance. <p> system and its components to changing parameters such as network bandwidth, CPU load, resource availability, user access patterns, etc. 4 Related Work The idea of having a ComponentConfigurator object associated with Components is similar to the concept of meta-objects utilized by reflective systems such as CLOS [KdRB91], OpenC++ [Chi95], Iguana <ref> [GC96] </ref>, and Apertos [ILY95]. In these systems, meta-objects can be used to customize all aspects of object behavior. On the other hand, the intent of the ComponentConfigurator is 12 not to modify the Component behavior but to maintain extra information about inter-component dependence.
Reference: [GHJV95] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns, Elements of Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: After carefully studying existing Object Request Brokers, we came to the conclusion that the TAO ORB [SC98] would be the best starting point for developing our infrastructure. TAO is a portable, flexible, extensible, and configurable ORB based on design patterns. It uses the Strategy design pattern <ref> [GHJV95] </ref> to separate different aspects of the ORB internal engine. A configuration file is used to specify the strategies the ORB uses to implement aspects like concurrency, request demultiplexing, scheduling, and connection management. At ORB startup time, the configuration file is parsed and the selected strategies are loaded. <p> Another problem occurs when one replaces the Thread-Pool strategy by a new one. There may be several incoming requests enqueued in the strategy waiting for a thread to execute them. The solution is to use the Memento pattern <ref> [GHJV95] </ref> to encapsulate the old strategy state in an object that is passed to the new strategy. An object is used to encapsulate the queue of waiting requests. The system simply passes this object to the new strategy which then takes care of the enqueued requests.
Reference: [Ham97] <author> Graham Hamilton. </author> <title> JavaBeans specification. Sun Microsystems, </title> <note> 1997. Available at http://java.sun.com/beans/docs. </note>
Reference-contexts: Rather than being an alternative to object-orientation, component technology extends the initial concepts of objects. It stresses the desire for independent pieces of software that can be reused and combined in different ways to implement complex software systems. Recently developed component architectures <ref> [Ham97, Den97, OMG97] </ref> support the construction of sophisticated systems by assembling together a collection of off-the-shelf software components with the help of visual tools or programmatic interfaces. However, there is still very little support for managing the interactions between components.
Reference: [Her97] <author> Hermann Hartig and Michael Hohmuth and Jochen Liedtke and Sebastian Schonberg and Jean Wolter. </author> <title> The Performance of -Kernel-Based Systems. </title> <booktitle> In Proceedings of the Sixteenth Symposium on Operating Systems Principles, </booktitle> <address> Saint Malo, France, </address> <month> October </month> <year> 1997. </year> <note> ACM. </note>
Reference-contexts: Previous research in microkernels and customizable operating systems such as Mach [Lop91], SPIN [BSP + 95], L4 <ref> [Her97] </ref>, Exokernel [KEG + 97], and Choices [LTC96] developed low-level techniques for dynamic loading new modules to the operating system both in kernel and user space. Nevertheless, a high-level model for operating system reconfiguration is still inexistent.
Reference: [HLS97] <author> Tim Harrison, David Levine, and Douglas C. Schmidt. </author> <title> The Design and Performance of a Real-time CORBA Object Event Service. </title> <booktitle> In Proceedings of OOPSLA '97, </booktitle> <address> Atlanta, Georgia, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: At ORB startup time, the configuration file is parsed and the selected strategies are loaded. TAO is primarily targeted for static hard real-time applications such as Avionics systems <ref> [HLS97] </ref>. Thus, it assumes that, once the ORB is initially configured, its strategies will remain in place until it completes its execution. There is very little support for on-the-fly reconfiguration. The 2K project seeks to build a flexible infrastructure to support adaptive applications running on dynamic environments.
Reference: [ILY95] <author> Jun-ichiro Itoh, Rodger Lea, and Yasuhiko Yokote. </author> <title> Using Meta-objects to Support Optimization in the Apertos Operating System. </title> <booktitle> In USENIX Conference on Object-Oriented Technologies (COOTS), </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: components to changing parameters such as network bandwidth, CPU load, resource availability, user access patterns, etc. 4 Related Work The idea of having a ComponentConfigurator object associated with Components is similar to the concept of meta-objects utilized by reflective systems such as CLOS [KdRB91], OpenC++ [Chi95], Iguana [GC96], and Apertos <ref> [ILY95] </ref>. In these systems, meta-objects can be used to customize all aspects of object behavior. On the other hand, the intent of the ComponentConfigurator is 12 not to modify the Component behavior but to maintain extra information about inter-component dependence.
Reference: [KC99] <author> Fabio Kon and Roy H. Campbell. </author> <title> Supporting Automatic Configuration of Component-Based Distributed Systems. </title> <booktitle> In Proceeedings of the 5th USENIX Conference on Object-Oriented Technologies and Systems, COOTS'99 (to appear), </booktitle> <month> May </month> <year> 1999. </year>
Reference-contexts: The C++ framework was successfully deployed in dynamicTAO which was made aware of its own internal structure. Future work in the 2K operating system will demonstrate how the model behaves in a complex distributed component-based system. <ref> [KC99] </ref> presents an updated description of the work described in this paper. Acknowledgments We gratefully acknowledge the help provided by Manuel Roman on the implementation of dynam-icTAO. We thank Dilma Menezes, Francisco Ballesteros, and the members of the 2K team for their feedback on the ideas presented in this paper.
Reference: [KdRB91] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: used for adapting the system and its components to changing parameters such as network bandwidth, CPU load, resource availability, user access patterns, etc. 4 Related Work The idea of having a ComponentConfigurator object associated with Components is similar to the concept of meta-objects utilized by reflective systems such as CLOS <ref> [KdRB91] </ref>, OpenC++ [Chi95], Iguana [GC96], and Apertos [ILY95]. In these systems, meta-objects can be used to customize all aspects of object behavior. On the other hand, the intent of the ComponentConfigurator is 12 not to modify the Component behavior but to maintain extra information about inter-component dependence.
Reference: [KEG + 97] <author> M. Frans Kaashoek, Dawson R. Engler, Gregory R. Ganger, Hector Brice~no, Russell Hunt, David Mazieres, Tom Pinckney, Robert Grimm, John Janotti, and Kenneth Mackenzie. </author> <title> Application Performance and Flexibility on Exokernel Systems. </title> <booktitle> In Proceedings of the Sixteenth Symposium on Operating Systems Principles, </booktitle> <address> Saint Malo, France, </address> <month> October </month> <year> 1997. </year> <journal> ACM. </journal> <volume> 15 </volume>
Reference-contexts: Previous research in microkernels and customizable operating systems such as Mach [Lop91], SPIN [BSP + 95], L4 [Her97], Exokernel <ref> [KEG + 97] </ref>, and Choices [LTC96] developed low-level techniques for dynamic loading new modules to the operating system both in kernel and user space. Nevertheless, a high-level model for operating system reconfiguration is still inexistent.
Reference: [KM95] <author> Fabio Kon and Arnaldo Mandel. </author> <title> SODA: A Lease-Based Consistent Distributed File Sys--tem. </title> <booktitle> In Proceedings of the 13th Brazilian Symposium on Computer Networks, </booktitle> <address> Belo Hori-zonte, </address> <year> 1995. </year> <note> Available at ftp://ftp.ime.usp.br:/pub/reports/comp/rt-mac-9503. ps.gz. </note>
Reference-contexts: This can be addressed by assigning an expiration time to the validity of the reified dependencies between components. This mechanism is known as leases [GC89] and is also used in other contexts like the SODA distributed file system <ref> [KM95] </ref> and JINI [Wal98]. After a lease is expired, a component may assume that the dependency no longer exists and complete its destruction process. In this case, a component that relies on a particular dependency must always verify if the lease for this dependency is still valid.
Reference: [KSC + 98] <author> Fabio Kon, Ashish Singhai, Roy H. Campbell, Dulcineia Carvalho, Robert Moore, and Francisco J. Ballesteros. </author> <title> 2K: A Reflective, Component-Based Operating System for Rapidly Changing Environments. </title> <booktitle> In Proceedings of the ECOOP'98 Workshop on Reflective Object-Oriented Programming and Systems, </booktitle> <address> Brussels, Belgium, </address> <month> July </month> <year> 1998. </year>
Reference-contexts: We will select an existing solution or develop a new customized language to represent and process requirement information. The language must allow processing specifications at execution time with little overhead. We will then deploy it in 2K , a new distributed operating system <ref> [KSC + 98, CNM98] </ref> currently under development. <p> It is used to represent and manipulate the internal structure of dynamicTAO. We, then, discuss how this framework will be used to support architectural awareness in the 2K distributed operating system. 3.1 dynamicTAO One of the major constituent elements of the 2K distributed operating system <ref> [KSC + 98, CNM98] </ref> is a reflective middleware layer based on CORBA. After carefully studying existing Object Request Brokers, we came to the conclusion that the TAO ORB [SC98] would be the best starting point for developing our infrastructure.
Reference: [LBS + 98] <author> J. P. Loyall, D. E. Bakken, R. E. Schantz, J. A. Zinky, D. A. Karr, R. Vanegas, and K. R. Anderson. </author> <title> QoS Aspect Languages and Their Runtime Integration. </title> <booktitle> In Proceedings of the Fourth Workshop on Languages, Compilers, and Run-time Systems for Scalable Computers (LCR98), </booktitle> <address> Pittsburgh, Pennsylvania, </address> <month> May </month> <year> 1998. </year> <note> To appear in Lecture Notes in Computer Science, Springer-Verlag. </note>
Reference-contexts: QoS-aware systems can use these data to enable proper admission control, resource negotiation, and resource reservation. The last item is the one which determines which auxiliary components must be loaded and in which kind of software environment they will execute. Our group is studying QoS specification languages <ref> [FK98, LBS + 98] </ref>. We will select an existing solution or develop a new customized language to represent and process requirement information. The language must allow processing specifications at execution time with little overhead.
Reference: [Lop91] <author> Keith Lopere. </author> <title> Mach 3 kernel principles. Open Software Foundation, </title> <year> 1991. </year>
Reference-contexts: Previous research in microkernels and customizable operating systems such as Mach <ref> [Lop91] </ref>, SPIN [BSP + 95], L4 [Her97], Exokernel [KEG + 97], and Choices [LTC96] developed low-level techniques for dynamic loading new modules to the operating system both in kernel and user space. Nevertheless, a high-level model for operating system reconfiguration is still inexistent.
Reference: [LTC96] <author> W. S. Liao, S. Tan, and R. H. Campbell. </author> <title> Fine-grained, Dynamic User Customization of Operating Systems. </title> <booktitle> In Proceedings Fifth International Workshop on Object-Orientation in Operating Systems, </booktitle> <pages> pages 62-66, </pages> <address> Seattle, Washington USA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Previous research in microkernels and customizable operating systems such as Mach [Lop91], SPIN [BSP + 95], L4 [Her97], Exokernel [KEG + 97], and Choices <ref> [LTC96] </ref> developed low-level techniques for dynamic loading new modules to the operating system both in kernel and user space. Nevertheless, a high-level model for operating system reconfiguration is still inexistent. These previous works have not addressed a number of problems related to fault-tolerance and dynamic reconfiguration.
Reference: [OMG97] <author> OMG. </author> <title> CORBA Component Model RFP. </title> <note> Available at http://www.omg.org/docs/ orbos/9705-22.pdf, </note> <year> 1997. </year>
Reference-contexts: Rather than being an alternative to object-orientation, component technology extends the initial concepts of objects. It stresses the desire for independent pieces of software that can be reused and combined in different ways to implement complex software systems. Recently developed component architectures <ref> [Ham97, Den97, OMG97] </ref> support the construction of sophisticated systems by assembling together a collection of off-the-shelf software components with the help of visual tools or programmatic interfaces. However, there is still very little support for managing the interactions between components.
Reference: [ORT98] <author> Peyman Oreizy, David S. Rosenblum, and Richard N. Taylor. </author> <title> On the role of connectors in modeling and implementing software architectures. </title> <type> Technical Report UCI-ICS-98-04, </type> <institution> Department of Information and Computer Science, University of California, Irvine, </institution> <month> February </month> <year> 1998. </year>
Reference-contexts: modules are affected? * How must those other modules react? * When (re)configuring the system, which components must be loaded to meet the service demand and the required quality of service? * If a system component fails, how can the system detect it and recover gracefully? Oreizy, Taylor, and Rosenblum <ref> [ORT98, OT98] </ref> have identified the need for an explicit representation of the system architecture in order to support consistent, dynamic reconfiguration. In their model, components interact with each other through Connectors that are used both for communication and for representing the dependencies among groups of components.
Reference: [OT98] <author> Peyman Oreizy and Richard N. Taylor. </author> <title> On the Role of Software Architectures in Runtime System Reconfiguration. </title> <booktitle> In Proceedings of the 4th International Conference on Configurable Distributed Systems, Annapolis, </booktitle> <address> Maryland, USA, </address> <month> May </month> <year> 1998. </year>
Reference-contexts: modules are affected? * How must those other modules react? * When (re)configuring the system, which components must be loaded to meet the service demand and the required quality of service? * If a system component fails, how can the system detect it and recover gracefully? Oreizy, Taylor, and Rosenblum <ref> [ORT98, OT98] </ref> have identified the need for an explicit representation of the system architecture in order to support consistent, dynamic reconfiguration. In their model, components interact with each other through Connectors that are used both for communication and for representing the dependencies among groups of components.
Reference: [RKC98] <author> Manuel Roman, Fabio Kon, and Roy H. Campbell. </author> <title> Design and Implementation of Runtime Reflection in Communication Middleware: the dynamicTAO Case. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> December </month> <year> 1998. </year>
Reference-contexts: The 2K project seeks to build a flexible infrastructure to support adaptive applications running on dynamic environments. On-the-fly adaptation is extremely important for a wide range of applications including the ones dealing with multimedia, mobile computers, and dynamically changing environments. The design of 2K depends on dynamicTAO <ref> [RKC98] </ref>, an extension of TAO that enables on-the-fly reconfiguration of its strategies. dynamicTAO exports an interface for loading and unloading modules into the ORB runtime, and for inspecting the ORB configuration state.
Reference: [SC98] <author> Douglas C. Schmidt and Chris Cleeland. </author> <title> Applying Patterns to Develop Extensible ORB Middleware. </title> <journal> IEEE Communications Magazine, </journal> <note> 1998. (to appear), available at http://www.cs.wustl.edu/~schmidt/ACE-papers.html. </note>
Reference-contexts: After carefully studying existing Object Request Brokers, we came to the conclusion that the TAO ORB <ref> [SC98] </ref> would be the best starting point for developing our infrastructure. TAO is a portable, flexible, extensible, and configurable ORB based on design patterns. It uses the Strategy design pattern [GHJV95] to separate different aspects of the ORB internal engine.
Reference: [Sch94] <author> Douglas C. Schmidt. </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching. </title> <booktitle> In Proceedings of the 1st Pattern Languages of Programs Conference, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: These subclasses may also store references to client requests that depend on them. With this information, it is possible to decide when a strategy can be safely unloaded. Consider, for example, the three concurrency strategies supported by dynamicTAO: Single-Threaded Reactive <ref> [Sch94] </ref>, Thread-Per-Connection, and Thread-Pool. If the user switches from the Reactive or Thread-Per-Connection strategies to any other concurrency strategy, nothing special needs to be done. dynamicTAO may simply load the new strategy, update the proper TAO-Configurator hook, unload the old strategy, and continue.
Reference: [SGE98] <editor> Dilma Menezes da Silva, Marco Dimas Gubitoso, and Markus Endler. Sistemas de Informac~ao Distribuidos para Agentes Moveis. </editor> <booktitle> In Proceedings of the XXV Integrated Seminars in Software and Hardware (SEMISH'98), </booktitle> <pages> pages 125-140, </pages> <address> Belo Horizonte, Brazil, </address> <month> August </month> <year> 1998. </year> <note> SBC. Available at http://www.ime.usp.br/~dilma/papers/ semish98.ps. 16 </note>
Reference-contexts: In addition, the Java implementation is being used by researchers at the University of S~ao Paulo to prototype a domain decomposition manager. This manager has two demonstration applications: a Distributed Information System for Mobile Agents <ref> [SGE98] </ref> and the parallelization of an Atmospheric Modeling System [Bar98]. Work on implementations of the framework in Java RMI and CORBA is underway. We will use them in the 2K distributed operating system.
Reference: [SGH + 89] <author> Marc Shapiro, Yvon Gourhant, Sabine Habert, Laurence Mosseri, Michel Ruffin, and Cline Valot. </author> <title> SOS: An object-oriented operating system | assessment and perspectives. </title> <journal> Computing Systems, </journal> <volume> 2(4) </volume> <pages> 287-338, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Our framework differs from theirs in the sense that it is not limited to database systems and that we are able to represent arbitrary dependency relationships between components. The idea of using prerequisites to represent the dependencies among operating system objects was introduced in the SOS operating system <ref> [SGH + 89] </ref> developed at INRIA, France. In the SOS model, objects contain a list of prerequisites that must be satisfied before they are activated. Even though the idea was promising, it was not fully explored in that project.
Reference: [SGM89] <author> Marc Shapiro, Philippe Gautron, and Laurence Mosseri. </author> <title> Persistence and Migration for C++ Objects. </title> <editor> In Stephen Cook, editor, ECOOP'89, </editor> <booktitle> Proc. of the Third European Conf. on Object-Oriented Programming, British Computer Society Workshop Series, </booktitle> <pages> pages 191-204, </pages> <address> Nottingham (GB), </address> <month> July </month> <year> 1989. </year> <institution> The British Computer Society, Cambridge University Society. </institution>
Reference-contexts: Even though the idea was promising, it was not fully explored in that project. Prerequisites were only used to express that an object depends on the code implementing it and not much experimentation was carried out <ref> [SGM89, Sha98] </ref>. SOS does not include a model for dynamic management of inter-component dependence. Modern operating systems, like Solaris for example, use an explicit representation of the dependencies among shared libraries to implement dynamic linking [Sun97]. A shared library contains a list of other libraries upon which it depends.
Reference: [Sha98] <author> Marc Shapiro. </author> <type> Personal communication, </type> <month> July </month> <year> 1998. </year>
Reference-contexts: Even though the idea was promising, it was not fully explored in that project. Prerequisites were only used to express that an object depends on the code implementing it and not much experimentation was carried out <ref> [SGM89, Sha98] </ref>. SOS does not include a model for dynamic management of inter-component dependence. Modern operating systems, like Solaris for example, use an explicit representation of the dependencies among shared libraries to implement dynamic linking [Sun97]. A shared library contains a list of other libraries upon which it depends.
Reference: [Sun97] <author> Sun Microsystems. </author> <title> Linker and Libraries, </title> <note> 1997. On-line document available at http: //docs.sun.com. </note>
Reference-contexts: SOS does not include a model for dynamic management of inter-component dependence. Modern operating systems, like Solaris for example, use an explicit representation of the dependencies among shared libraries to implement dynamic linking <ref> [Sun97] </ref>. A shared library contains a list of other libraries upon which it depends. The system tries to locate all the required libraries before executing any application code.
Reference: [Wal98] <author> Jim Waldo. </author> <title> Jini Architecture Overview. </title> <note> Available at http://java.sun.com/ products/jini/whitepapers, 1998. 17 </note>
Reference-contexts: This can be addressed by assigning an expiration time to the validity of the reified dependencies between components. This mechanism is known as leases [GC89] and is also used in other contexts like the SODA distributed file system [KM95] and JINI <ref> [Wal98] </ref>. After a lease is expired, a component may assume that the dependency no longer exists and complete its destruction process. In this case, a component that relies on a particular dependency must always verify if the lease for this dependency is still valid.
References-found: 35

