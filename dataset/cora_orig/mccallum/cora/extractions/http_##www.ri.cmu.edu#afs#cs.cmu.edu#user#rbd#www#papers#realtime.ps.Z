URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/rbd/www/papers/realtime.ps.Z
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/rbd/www/bib-interactiveperformance.html
Root-URL: 
Title: Real Time Control For Interactive Computer Music and Animation  
Author: Roger B. Dannenberg 
Address: Pittsburgh, PA 15213  
Affiliation: Computer Science Department Carnegie Mellon University  
Abstract: Real-time systems are commonly regarded as the most complex form of computer program due to parallelism, the use of special purpose input/output devices, and the fact that time-dependent errors are hard to reproduce. Several practical techniques can be used to limit the complexity of implementing real-time interactive music and animation programs. The techniques are: (1) a program structure in which input events are translated into procedure calls, (2) the use of non-preemptive programs where possible, (3) event-based programming which allows interleaved program execution, automatic storage management, and a single run-time stack, (4) multiple processes communicating by messages where task preemption is necessary, and (5) interface construction tools to facilitate experimentation and program refinement. These techniques are supported by software developed by the author for real-time interactive music programs and more recently for animation. Although none of these techniques are new, they have never been used in this combination, nor have they been investigated in this context. Implementation details and examples that illustrate the advantage of these techniques are presented. Emphasis is placed on software organization. No specific techniques for sound and image generation are presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrews, G. R. </author> <title> Concepts and Notations for Concurrent Programming. </title> <journal> ACM Computing Surveys 15(1) </journal> <pages> 3-43, </pages> <month> March, </month> <year> 1983. </year>
Reference-contexts: Suppose A assigns a value to V [i] but is preempted before it increments i. Process B might then overwrite V [i]. This is one example of a classic operating systems problem. The standard solutions to this problem <ref> [1] </ref> all involve making updates to shared data structures mutually exclusive. In this case, process B would be denied access to array V until process A finished its operations. This requires extra processing to take place before and after updating the data structure.
Reference: [2] <author> Boynton, L., P. Lavoie, Y. Orlarey, C. Rueda and David Wessel. MIDI-LISP: </author> <title> A Lisp Based Music Programming Environment for the Macintosh. </title> <editor> In P. Berg (editor), </editor> <booktitle> Proceedings of the International Computer Music Conference 1986, </booktitle> <pages> pages 183-186. </pages> <booktitle> International Computer Music Association, </booktitle> <year> 1986. </year>
Reference-contexts: It appears that this software has enabled at least several composers and a number of students to create programs which would not have been possible otherwise [5, 7, 10]. Some Lisp-based Midi software, which provides an alternative manifestation of many of these same design principles, has been similarly successful <ref> [2, 3] </ref>. Of these recommendations, the use of multiple processes and interface design tools are the ones with which I have the least experience. These were implemented as tools for a recent work involving interactive music and graphics generation.
Reference: [3] <author> L. Boynton, J. Duthen, Y. Potard, and X. Rodet. </author> <title> Adding a Graphical Interface to FORMES. </title> <editor> In P. Berg (editor), </editor> <booktitle> Proceedings of the International Computer Music Conference 1986, </booktitle> <pages> pages 105-108. </pages> <booktitle> International Computer Music Association, </booktitle> <year> 1986. </year>
Reference-contexts: It appears that this software has enabled at least several composers and a number of students to create programs which would not have been possible otherwise [5, 7, 10]. Some Lisp-based Midi software, which provides an alternative manifestation of many of these same design principles, has been similarly successful <ref> [2, 3] </ref>. Of these recommendations, the use of multiple processes and interface design tools are the ones with which I have the least experience. These were implemented as tools for a recent work involving interactive music and graphics generation.
Reference: [4] <author> Buxton, William. </author> <title> Lexical and pragmatic considerations of input structures. </title> <booktitle> Computer Graphics 17(1) </booktitle> <pages> 31-36, </pages> <year> 1983. </year>
Reference-contexts: This same technique is often used for building display-oriented user interfaces where an application must handle interleaved events generated by the mouse, menu system, and console keyboard <ref> [4] </ref>. This organization helps in writing software that is always ready to handle any input event as opposed to always being in some mode expecting a particular type of input. 2 3. Preemption Preemption occurs when one process is stopped at an arbitrary instruction in order to run another process.
Reference: [5] <author> Chabot, Xavier, Roger Dannenberg, </author> <title> and Georges Bloch. </title>
Reference-contexts: The CMU Midi Toolkit, which embodies most of these recommendations has been in use for several years. It appears that this software has enabled at least several composers and a number of students to create programs which would not have been possible otherwise <ref> [5, 7, 10] </ref>. Some Lisp-based Midi software, which provides an alternative manifestation of many of these same design principles, has been similarly successful [2, 3]. Of these recommendations, the use of multiple processes and interface design tools are the ones with which I have the least experience.
References-found: 5

