URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/able/ftp/implicit-invoc-fme97.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/project/able/www/paper_abstracts/implicit-invoc-fme97.html
Root-URL: 
Email: fdingeljgarlanjsjhag@cs.cmu.edu  notkin@cs.washington.edu  
Phone: 2  
Title: Towards a formal treatment of implicit invocation  
Author: J. Dingel D. Garlan S. Jha and D. Notkin 
Address: Pittsburgh, PA 15213, USA  Seattle, WA 98195, USA  
Affiliation: 1 Carnegie Mellon University,  University of Washington,  
Abstract: Implicit invocation [SN92,GN91] has become an important architectural style for large-scale system design and evolution. This paper addresses the lack of specification and verification formalisms for such systems. A formal computational model for implicit invocation is presented. We develop a verification framework for implicit invocation that is based on Jones' rely/guarantee reasoning for concurrent systems [Jon83,Jon90,Stt91]. The application of the framework is illustrated with several examples. The merits and limitations of the rely/guarantee paradigm in the context of implicit invocation systems are also discussed.
Abstract-found: 1
Intro-found: 1
Reference: [AAG95] <author> G. Abowd, R. Allen, and D. Garlan. </author> <title> Formalizing style to understand de-scriptions of software architecture. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> October </month> <year> 1995. </year>
Reference-contexts: Two of this paper's authors produced an early characterization of II systems in Z [GN91]. More recently, researchers in software architecture have looked at some of the formal properties of II architectural styles <ref> [AAG95] </ref>. This research was primarily focused 4 on taxonomic issues, and does not provide an explicit computational model that permits compositional reasoning about the behaviour of such systems. Other researchers have looked at formal issues of event-multicast and process groups as a mechanism for achieving fault tolerance through replication [BJ89].
Reference: [BCTW96] <author> D.J. Barrett, L.A. Clarke, P.L. Tarr, and A.E. Wise. </author> <title> A framework for eventbased software integration. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(4) </volume> <pages> 378-421, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: An early survey of applications of the technique appeared in [GKN88] in which the authors illustrated how and why the ideas of II systems are pervasive in software systems. More recently <ref> [BCTW96] </ref> produced a taxonomic survey of II mechanisms, together with a generic object model for comparison of them.
Reference: [BJ89] <author> K. Birman and Th. Joseph. </author> <title> Exploiting replication in distributed systems. </title> <editor> In Mullender and Sape, editors, </editor> <booktitle> Distributed Systems, </booktitle> <pages> pages 319 - 365. </pages> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: This research was primarily focused 4 on taxonomic issues, and does not provide an explicit computational model that permits compositional reasoning about the behaviour of such systems. Other researchers have looked at formal issues of event-multicast and process groups as a mechanism for achieving fault tolerance through replication <ref> [BJ89] </ref>. This work differs from that on implicit invocation in that multiple recipients of an event typically perform the same computations. This leads to very different requirements for underlying theory, since the main issue is how to add and remove replicated servers correctly to a running system.
Reference: [BN84] <author> A. Birrel and B. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 356-372, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: 1 Introduction A critical issue for large-scale systems design and evolution is the choice of an architectural style that permits the integration of separately-developed components into larger systems. Familiar styles include those based on remote procedure call <ref> [BN84] </ref>, shared variables, asynchronous message passing, etc. One key factor determining the effectiveness of an architectural style is the ability to reason effectively about properties of a system from properties of its components.
Reference: [CM88] <author> K.M. Chandy and J. Misra. </author> <title> Parallel program design: a foundation. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference: [Dij76] <author> E.W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1976. </year>
Reference: [Ger89] <author> C. Gerety. </author> <title> HP Softbench: A new generation of software development tools. </title> <type> Technical Report SESD-89-25, </type> <institution> Hewlett-Packard Software Engineering Systems Division, Fort Collins, Colorado, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: Mechanisms to support II are found in commercial toolkits (e.g., Softbench <ref> [Ger89] </ref>, ToolTalk, DecFuse), communication standards (e.g., Corba), integration frameworks (e.g., OLE), and programming environments (e.g., Smalltalk). However, there is currently no established basis for reasoning about II systems.
Reference: [GKN88] <author> D. Garlan, G.E. Kaiser, and D. Notkin. </author> <title> On the criteria to be used in composing tools into systems. </title> <type> Technical Report 88-08-09, </type> <institution> Department of Computer Science, University of Washington, </institution> <address> Seattle, WA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Within the general area of II research several researchers have attempted to provide precise characterizations of implicit invocation systems. An early survey of applications of the technique appeared in <ref> [GKN88] </ref> in which the authors illustrated how and why the ideas of II systems are pervasive in software systems. More recently [BCTW96] produced a taxonomic survey of II mechanisms, together with a generic object model for comparison of them.
Reference: [GN91] <author> D. Garlan and D. Notkin. </author> <title> Formalizing design spaces: Implicit invocation mechanisms. </title> <booktitle> In VDM'91: Formal Software Development Methods, </booktitle> <pages> pages 31-44, </pages> <address> Noordwijkerhout, The Netherlands, </address> <month> October </month> <year> 1991. </year> <note> Springer-Verlag, LNCS 551. </note>
Reference-contexts: Closer to our line of research, several researchers have attempted to provide a formal characterization of certain aspects of II systems. Two of this paper's authors produced an early characterization of II systems in Z <ref> [GN91] </ref>. More recently, researchers in software architecture have looked at some of the formal properties of II architectural styles [AAG95]. This research was primarily focused 4 on taxonomic issues, and does not provide an explicit computational model that permits compositional reasoning about the behaviour of such systems.
Reference: [Hoa69] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10), </volume> <month> October </month> <year> 1969. </year>
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference: [ISO87] <author> ISO. </author> <title> Information processing systems open systems interconnection - LOTOS a formal description technique based on the temporal ordering of observational behaviour. </title> <type> Technical Report ISO/TC 97/SC 21, </type> <institution> International Standards Organization, </institution> <year> 1987. </year>
Reference: [Jon83] <author> C.B. Jones. </author> <title> Tentative steps toward a development method for interfering programs. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 5(4):569619, </volume> <month> October </month> <year> 1983. </year>
Reference: [Jon90] <author> C.B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Prentice Hall International, </publisher> <year> 1990. </year> <note> Second Edition. </note>
Reference: [Mil80] <author> R. Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume Lecture Notes in Computer Science, </booktitle> <volume> volume 92. </volume> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference: [OG76] <author> S. Owicki and D. Gries. </author> <title> Verifying properties of parallel programs: an ax-iomatic approach. </title> <journal> Communications of the ACM, </journal> <volume> 19(5) </volume> <pages> 279-284, </pages> <month> May </month> <year> 1976. </year>
Reference: [Rei90] <author> S.P. Reiss. </author> <title> Connecting tools using message passing in the FIELD program development environment. </title> <journal> IEEE Software, </journal> <month> July </month> <year> 1990. </year>
Reference-contexts: For example, user code might register a procedure that is invoked when a particular signal is raised by the kernel. This allows the user code added control without compromising the kernel. A somewhat more complicated example arises in broadcast message-based programming environments (such as those derived from Reiss' Field <ref> [Rei90] </ref> system). A collection of tools, such as a compiler, a debugger, an editor, a program visualization tool, etc., execute together. Rather than calling one another directly, at appropriate times they each announce potentially interesting activities. <p> Note that the above reasoning could easily be extended to handle the example system augmented with the methods initialize and reset under the appropriate binding. 16 4.2 Example: a filesystem We now consider an example inspired by the common application of implicit invocation to software development environments, such as Field <ref> [Rei90] </ref>. Previously, a state was a mapping from variables to values. We now consider a slightly different scenario, in which the state is given by the contents and the attributes of a file system F. Suppose F is a set of source files.
Reference: [SN92] <author> K. Sullivan and D. Notkin. </author> <title> Reconciling environment integration and com-ponent independence. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(3), </volume> <month> July </month> <year> 1992. </year>
Reference: [Stt91] <author> K. Sttlen. </author> <title> A method for the development of totally correct shared-state parallel programs. </title> <booktitle> In CONCUR '91, </booktitle> <pages> pages 510-525. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year> <month> 20 </month>
References-found: 19

