URL: http://www.cs.toronto.edu/~ruppert/consensus.ps
Refering-URL: http://www.cs.toronto.edu/~ruppert/index.html
Root-URL: 
Email: ruppert@cs.utoronto.ca  
Title: Determining Consensus Numbers  
Author: Eric Ruppert 
Date: November 14, 1996  
Abstract: Conditions on a shared object type T are given that are both necessary and sufficient for n-process consensus to be solvable using objects of type T and registers. The conditions apply to two large classes of deterministic shared objects: read-modify-write objects [10] and readable objects which have operations that allow processes to read the state of the object. These two classes include most objects that are used as the primitives of practical distributed systems. When the sequential specification of T is finite, the conditions may be checked in a finite amount of time to decide the question "Is the consensus number of T at least n?" The conditions are also used to provide a clear proof of the robustness of the consensus hierarchy for read-modify-write and readable objects.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Yehuda Afek, Hagit Attiya, Danny Dolev, Eli Gafni, Michael Merritt, and Nir Shavit. </author> <title> Atomic snapshots of shared memory. </title> <booktitle> In Proc. 9th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 1-13, </pages> <year> 1990. </year>
Reference-contexts: It has been shown that the scan operation does not increase the power of the array of registers to solve consensus, since the snapshot object can be implemented from ordinary registers <ref> [1, 2] </ref>. Here, the n-universality conditions for readable objects are used to show that the addition of an atomic scan operation does not increase the power of any readable object type to solve consensus. <p> Processes may update one element of the array or read the contents of the entire array. The latter operation is called a scan. Afek et al. <ref> [1] </ref> and Anderson [2] independently showed that an atomic snapshot object can be implemented by read/write registers.
Reference: [2] <author> James H. Anderson. </author> <title> Composite registers. </title> <booktitle> In Proc. 9th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 15-29, </pages> <year> 1990. </year>
Reference-contexts: It has been shown that the scan operation does not increase the power of the array of registers to solve consensus, since the snapshot object can be implemented from ordinary registers <ref> [1, 2] </ref>. Here, the n-universality conditions for readable objects are used to show that the addition of an atomic scan operation does not increase the power of any readable object type to solve consensus. <p> Processes may update one element of the array or read the contents of the entire array. The latter operation is called a scan. Afek et al. [1] and Anderson <ref> [2] </ref> independently showed that an atomic snapshot object can be implemented by read/write registers.
Reference: [3] <author> Elizabeth Borowsky, Eli Gafni, and Yehuda Afek. </author> <title> Consensus power makes (some) sense! In Proc. </title> <booktitle> 13th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 363-372, </pages> <year> 1994. </year>
Reference-contexts: Two teams of researchers, Borowski, Gafni and Afek <ref> [3] </ref> and Peterson, Bazzi and Neiger [13] have claimed that the consensus 2 hierarchy is robust for all deterministic objects. These papers are complex, and full versions have not yet appeared. <p> Lo and Hadzilacos [11] improved this, showing that the hierarchy h r m restricted to oblivious objects is not robust even if non-determinism is bounded. Borowsky, Gafni and Afek <ref> [3] </ref> and Peterson, Bazzi and Neiger [13] have claimed that the consensus hierarchy is robust for deterministic objects. These papers are quite complex.
Reference: [4] <author> Tushar Chandra, Vassos Hadzilacos, Prasad Jayanti, and Sam Toueg. </author> <title> The h r m hierarchy is not robust. </title> <year> 1994. </year>
Reference-contexts: Jayanti showed that h r m is the (unique) tight wait-free hierarchy [9]. Chandra et al. <ref> [4, 5] </ref> showed that the consensus hierarchy is not robust, if non-determinsistic, non-oblivious objects are allowed. Schenk [14] showed that the consensus hierarchy is not robust, even if restricted to oblivious objects, if objects with unbounded non-determinism are allowed.
Reference: [5] <author> Tushar Chandra, Vassos Hadzilacos, Prasad Jayanti, and Sam Toueg. </author> <title> Wait-freedom vs. t-resiliency and the robustness of wait-free hierarchies. </title> <booktitle> In Proc. 13th ACM Symposium on Prin ciples of Distributed Computing, </booktitle> <pages> pages 334-343, </pages> <year> 1994. </year>
Reference-contexts: Jayanti showed that h r m is the (unique) tight wait-free hierarchy [9]. Chandra et al. <ref> [4, 5] </ref> showed that the consensus hierarchy is not robust, if non-determinsistic, non-oblivious objects are allowed. Schenk [14] showed that the consensus hierarchy is not robust, even if restricted to oblivious objects, if objects with unbounded non-determinism are allowed. <p> The proofs in this paper make use of two important properties of readable and RMW objects: Such objects are deterministic, and their state information can be freely accessed by all processes. Objects that have been used to show that the hierarchy is not robust <ref> [5, 11, 14] </ref> have neither of these 19 properties. They are non-deterministic and severely restrict the ways that processes may access their state information.
Reference: [6] <author> Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2), </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: The output values must all be the same, and every output must be the input value of some process. These two conditions are called consistency and validity, respectively. The proofs that the n-universality conditions are necessary for the solvability of n-consensus are bivalency arguments (see <ref> [6, 7] </ref>) that use the following terminology. The configuration of a protocol at any point in its execution consists of the state of every shared object, together with the internal state of every process.
Reference: [7] <author> Maurice Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1) </volume> <pages> 124-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Thus, a question about computability may be formulated as a question about implementations: Can one object type be implemented using a given set of primitive object types? Herlihy <ref> [7] </ref> showed that the consensus problem, in which each process begins with an input and all non-faulty processes must agree on one of the input values, plays a central role in the study of the power of object types. <p> For simplicity, it is assumed that all objects are oblivious. Processes are completely asynchronous and the wait-free model <ref> [7] </ref> of fault tolerance is used. <p> The output values must all be the same, and every output must be the input value of some process. These two conditions are called consistency and validity, respectively. The proofs that the n-universality conditions are necessary for the solvability of n-consensus are bivalency arguments (see <ref> [6, 7] </ref>) that use the following terminology. The configuration of a protocol at any point in its execution consists of the state of every shared object, together with the internal state of every process. <p> The sets V and F may have arbitrary cardinality; they need not be finite or even countable. Herlihy <ref> [7] </ref> gave the following characterization of the sets of RMW operations that can be used to solve 2-process consensus. <p> There is a critical configuration S 0 of the protocol. If such a configuration did not exist, one could produce an execution of infinite length by always scheduling a process whose next step produces a multivalent configuration, and this would violate the termination condition. A standard bivalency argument (see <ref> [7] </ref>) may be used to show that the next operation performed by any process when the system is in the configuration S 0 must be an operation on the same object, say X, and that X cannot be a register. <p> Proof: This follows from Theorems 5 and 11 and the fact that n-process consensus objects can be used to obtain a wait-free implementation of any data object in a system of n processes <ref> [7] </ref>. fl Corollary 13 If the set of possible values for RMW variables is finite, the following question is decidable: "Given a positive integer n and a set F of functions, can n-consensus be solved using only registers and RMW variables if the RMW operations can apply functions from the set <p> Proof: This follows from Theorems 17 and 20 and the fact that n-process consensus objects can be used to obtain a wait-free implementation of any data object in a system of n processes <ref> [7] </ref>. fl An atomic snapshot object is a distributed version of an array data structure. Processes may update one element of the array or read the contents of the entire array. The latter operation is called a scan. <p> Thus (ack; ?) 2 R A;j " R B;j , violating the conditions of Definition 15. Thus, T n is not (n + 1)-universal. fl 5 Robustness for RMW and Readable Ob jects Jayanti [9] formalized Herlihy's notion of a hierarchy <ref> [7] </ref> of shared object types and defined a number of desirable properties for hierarchies, including robustness. <p> Suppose the claim is false to derive a contradiction. Then, since h r m (T ) n, there is a protocol using objects whose types are from the set S that solves consensus among n processes. A bivalency argument <ref> [7] </ref> shows that this protocol has a critical configuration, S 0 , and that the next operation taken by any process when the system is in this configuration must be an operation on the same object, X. Let T X be the type of object X.
Reference: [8] <author> Maurice P. Herlihy and Jeannette M. Wing. </author> <title> Axioms for concurrent objects. </title> <booktitle> In Proc. 14th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 13-26, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: When an object is accessed by more than one process concurrently, its behaviour can be specified by insisting that operations appear to occur instantaneously at some time between their invocations and their responses. Such an object is called linearizable <ref> [8] </ref>. This paper deals only with deterministic, linearizable objects. It is assumed that the designer of a protocol may choose the initial states of the shared objects.
Reference: [9] <author> Prasad Jayanti. </author> <title> On the robustness of Herlihy's hierarchy. </title> <booktitle> In Proc. 12th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 145-157, </pages> <year> 1993. </year> <month> 20 </month>
Reference-contexts: Thus, the question of whether such an object type can be used, together with registers, to solve n-consensus is decidable. The n-universality conditions are also used to provide a clear proof that the consensus hierarchy <ref> [9] </ref> is robust for RMW and readable objects. <p> Thus (ack; ?) 2 R A;j " R B;j , violating the conditions of Definition 15. Thus, T n is not (n + 1)-universal. fl 5 Robustness for RMW and Readable Ob jects Jayanti <ref> [9] </ref> formalized Herlihy's notion of a hierarchy [7] of shared object types and defined a number of desirable properties for hierarchies, including robustness. <p> Jayanti showed that h r m is the (unique) tight wait-free hierarchy <ref> [9] </ref>. Chandra et al. [4, 5] showed that the consensus hierarchy is not robust, if non-determinsistic, non-oblivious objects are allowed. Schenk [14] showed that the consensus hierarchy is not robust, even if restricted to oblivious objects, if objects with unbounded non-determinism are allowed.
Reference: [10] <author> Clyde P. Kruskal, Larry Rudolph, and Marc Snir. </author> <title> Efficient synchronization on multiprocessors with shared memory. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(4) </volume> <pages> 579-601, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: In this paper, the power of deterministic objects to solve consensus is studied. Two important classes of objects are considered: read-modify-write (RMW) objects and readable objects. Most of the primitive objects that have been considered for practical distributed systems fall into one of these two categories. A RMW operation <ref> [10] </ref> updates the value of a variable by applying a function to the variable's current value, and then returns the old value. If all permitted operations on an object are RMW operations, the object is called a RMW object. Compare&Swap, Test&Set and Fetch&Add variables are examples of RMW objects.
Reference: [11] <author> Wai-Kau Lo and Vassos Hadzilacos. </author> <title> All of us are smarter than any of us: more on the robustness of the consensus hierarchy (Part I). </title> <type> Technical Report CSRI-348, </type> <institution> CSRI, University of Toronto, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: Chandra et al. [4, 5] showed that the consensus hierarchy is not robust, if non-determinsistic, non-oblivious objects are allowed. Schenk [14] showed that the consensus hierarchy is not robust, even if restricted to oblivious objects, if objects with unbounded non-determinism are allowed. Lo and Hadzilacos <ref> [11] </ref> improved this, showing that the hierarchy h r m restricted to oblivious objects is not robust even if non-determinism is bounded. Borowsky, Gafni and Afek [3] and Peterson, Bazzi and Neiger [13] have claimed that the consensus hierarchy is robust for deterministic objects. These papers are quite complex. <p> The proofs in this paper make use of two important properties of readable and RMW objects: Such objects are deterministic, and their state information can be freely accessed by all processes. Objects that have been used to show that the hierarchy is not robust <ref> [5, 11, 14] </ref> have neither of these 19 properties. They are non-deterministic and severely restrict the ways that processes may access their state information.
Reference: [12] <author> Nancy A. Lynch. </author> <title> Distributed Algorithms, chapter 8. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: Formally, an object can be specified as an I/O automaton (see <ref> [12] </ref>). Each operation causes a state transition and returns a response. If the state transition and response are uniquely determined by the current state of the object and the operation applied, then the object is called deterministic.
Reference: [13] <author> Gary L. Peterson, Rida A. Bazzi, and Gil Neiger. </author> <title> A gap theorem for consensus types. </title> <booktitle> In Proc. 13th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 344-353, </pages> <year> 1994. </year>
Reference-contexts: Two teams of researchers, Borowski, Gafni and Afek [3] and Peterson, Bazzi and Neiger <ref> [13] </ref> have claimed that the consensus 2 hierarchy is robust for all deterministic objects. These papers are complex, and full versions have not yet appeared. <p> Peterson, Bazzi and Neiger <ref> [13] </ref> refer to objects that solve team-restricted n-consensus as splitters. Lemma 6 If a set O of objects can be used to solve team-restricted (n + 1)-consensus, then O can be used to solve team-restricted n-consensus, for any n 2. <p> Lo and Hadzilacos [11] improved this, showing that the hierarchy h r m restricted to oblivious objects is not robust even if non-determinism is bounded. Borowsky, Gafni and Afek [3] and Peterson, Bazzi and Neiger <ref> [13] </ref> have claimed that the consensus hierarchy is robust for deterministic objects. These papers are quite complex.
Reference: [14] <author> Eric Schenk. </author> <title> The consensus hierarchy is not robust. </title> <booktitle> 1996. </booktitle> <pages> 21 </pages>
Reference-contexts: Jayanti showed that h r m is the (unique) tight wait-free hierarchy [9]. Chandra et al. [4, 5] showed that the consensus hierarchy is not robust, if non-determinsistic, non-oblivious objects are allowed. Schenk <ref> [14] </ref> showed that the consensus hierarchy is not robust, even if restricted to oblivious objects, if objects with unbounded non-determinism are allowed. Lo and Hadzilacos [11] improved this, showing that the hierarchy h r m restricted to oblivious objects is not robust even if non-determinism is bounded. <p> The proofs in this paper make use of two important properties of readable and RMW objects: Such objects are deterministic, and their state information can be freely accessed by all processes. Objects that have been used to show that the hierarchy is not robust <ref> [5, 11, 14] </ref> have neither of these 19 properties. They are non-deterministic and severely restrict the ways that processes may access their state information.
References-found: 14

