URL: ftp://ftp.cs.clemson.edu/techreports/94-108.ps.Z
Refering-URL: http://www.cs.clemson.edu/html/research/techrpt.shtml
Root-URL: http://www.cs.clemson.edu
Email: anandk@cs.clemson.edu  
Title: Program Slicing: An Application of Object-oriented Program Dependency Graphs  
Author: Anand Krishnaswamy 
Address: Clemson, SC 29634-1906  
Affiliation: Dept. of Computer Science Clemson University  
Abstract: A considerable amount of work has been done in the area of representing programs with single and multiple procedure bodies. A complete study of the latter requires both intra and interprocedural analysis. In the analysis of an object-oriented program, it is all the more important due to the existence of numerous classes and methods within the classes. Object-oriented design is based on the philosophy of data encapsulation and controlled access to the encapsulated data. There are different representations available for object-oriented design. These representations do not give a complete picture of the programs thus restricting code analysis and preventing many testing techniques from using them. This paper discusses the issues involved in representing object-oriented programs. A representation based on the Program Dependency Graphs is designed. Different concepts of the paradigm are represented, including polymorphism, dynamic binding and the class inheritance hierarchy. Message exchanges between objects are also discussed and a more compact manner of representing parameter flow is presented. A second issue addressed in this paper is that of slicing in object-oriented programs. Determining an object-oriented slice is more complex than determining either an intraprocedural or interprocedural slice. It has been shown that Program Dependency Graphs are well suited for slicing procedural programs. A high level pseudocode algorithm is given, that demonstrates the applicability of the Object-oriented Program Dependency Graph for slicing object-oriented programs. Other applications based on this representation are also introduced. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> The common object request broker: </editor> <title> Architecture and specification. </title> <type> Technical report, </type> <institution> Object Management Group and X/Open, </institution> <year> 1992. </year>
Reference-contexts: languages * Able to support a range of program analysis activities * Freedom to be updated, when the paradigm grows * Freedom to be tailored to a particular language There are different representations available for object-oriented design, like the Object Modeling Technique (OMT) [23] and the Interface Definition Language (IDL) <ref> [1] </ref>. These representations being design based, fail to give a complete picture of the programs they represent. Implementation details are not presented, and this prevents the complete analysis of the code. <p> The following sections discuss the two issues in more detail. 3.1 Representing Object-oriented Programs There are a few representations for object-oriented programs that come close to being general, like Rumbaugh's Object Modeling Technique (OMT) [23] and Object Management Group's Interface Definition Language (IDL) <ref> [1] </ref>. Another representation for object-oriented programs is the extension to the formal specification language Z, namely Object Z [6]. All these representations have their own limitations, that of being at the design level, and hence do not provide a complete picture of the software system.
Reference: [2] <author> Hiralal Agrawal and Joseph R. Horgan. </author> <title> Dynamic program slicing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 246-256, </pages> <year> 1990. </year>
Reference-contexts: An advantage of such a method is that procedure bodies not called, are not represented. This is the typical manner in which dynamic processing tools work. Agrawal et al <ref> [2] </ref> define the Dynamic Dependence Graphs using this technique of building PDGs. A disadvantage is that the representation has to be constructed from scratch for the called procedure during each execution and an independent per-procedure representation cannot be saved.
Reference: [3] <author> Ryder B.G. </author> <title> Constructing the call graph of a program. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(3) </volume> <pages> 216-225, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: Some interprocedural versions of a PDG are the System Dependency Graphs (SDG) first introduced by Horwitz et al [25] and extended by Livadas et al [19], the Unified Interprocedural Graph (UIG) by Harrold et al [8], the Call Graph by Ryder <ref> [3] </ref>, Lakhotia [18] and others, and the Program Summary Graph by Callahan [4]. Although an interprocedural representation can depict an object-oriented program as a set of interlinked procedures, connected through call and return edges, there is a gap when it comes to representing the procedures as methods of a class. <p> A Call Graph is an interprocedural program representation where vertices represent individual procedures and edges represent call sites. Each edge is labeled with the actual parameters associated with that call site. A program's Call Graph can be constructed efficiently <ref> [3] </ref> and used for many applications such as program maintenance and interprocedural data flow analysis. However, the Call Graph is a flow-insensitive structure since it does not incorporate control flow information.
Reference: [4] <author> Callahan D. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> In Proceedings of SIGPLAN'88 Conf. Programming Language Design and Implementation, </booktitle> <pages> pages 47-56, </pages> <year> 1988. </year>
Reference-contexts: of a PDG are the System Dependency Graphs (SDG) first introduced by Horwitz et al [25] and extended by Livadas et al [19], the Unified Interprocedural Graph (UIG) by Harrold et al [8], the Call Graph by Ryder [3], Lakhotia [18] and others, and the Program Summary Graph by Callahan <ref> [4] </ref>. Although an interprocedural representation can depict an object-oriented program as a set of interlinked procedures, connected through call and return edges, there is a gap when it comes to representing the procedures as methods of a class. <p> The OPDG is designed to handle interprocedural analysis and at the same time, represent the concepts of the object-oriented paradigm in a clear subtle way. The Unified Interprocedural Graph (UIG) [8] extracts the important information incorporated into: the Call Graph, the SDG, the Program Summary Graph <ref> [4] </ref>, and the Interprocedural Flow Graph (IFG) [10]. Algorithms developed for the previous representations are adapted to develop the UIG. The UIG provides savings in both storage and access times over the storage and access times required for the individual representations.
Reference: [5] <author> Hiralal Agrawal; Richard A. DeMillo and Eugene H. Spafford. </author> <title> Dynamic slicing in the presence of unconstrained pointers. </title> <booktitle> In Proceedings of the Fourth Symposium on Testing, Analysis and Verification (TAV4). ACM/IEEE-CS, </booktitle> <pages> pages 60-73, </pages> <year> 1991. </year>
Reference-contexts: This is similar to obtaining a dynamic slice in a procedural program, once the test pattern is known. Given a test pattern, a history is generated containing the set of vertices and edges traversed during the execution of the program <ref> [5] </ref>. Based on the history, the slice is generated for a particular statement-variable combination. Similarly, at run-time, all the polymorphic references are resolved, and hence the slice that is created will be unique and without any ambiguities. <p> In an object-oriented sense, determining a slice at run-time is more meaningful than determining a static slice. This is due to the possibility of Polymorphic Slices existing at compile time because of unresolved polymorphic references (see section 5.1.1). It has been shown in <ref> [5] </ref> and other work in the area of dynamic slice determination for procedural programs, that static slices tend to be large and imprecise due to different reasons. Some reasons given are those of pointers and composite variables (arrays, records, etc.).
Reference: [6] <author> David Duke and Roger Duke. </author> <title> Towards a semantics for object-z. In VDM '90: VDM and Z, </title> <year> 1990. </year>
Reference-contexts: Another representation for object-oriented programs is the extension to the formal specification language Z, namely Object Z <ref> [6] </ref>. All these representations have their own limitations, that of being at the design level, and hence do not provide a complete picture of the software system. The OMT model represents classes and relations between the classes.
Reference: [7] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C ++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference: [8] <author> Mary Jean Harrold and Brian Malloy. </author> <title> A unified interprocedural program representation for a maintenance environment. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(6) </volume> <pages> 584-593, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Different techniques are seen in the literature that discuss issues about parameter handling. Some of the techniques are based on work done by Horwitz et al in [25], Harrold et al in <ref> [8] </ref> and Livadas and Scroll in [19]. Each paper discusses the pros and cons of the different approaches. <p> Some interprocedural versions of a PDG are the System Dependency Graphs (SDG) first introduced by Horwitz et al [25] and extended by Livadas et al [19], the Unified Interprocedural Graph (UIG) by Harrold et al <ref> [8] </ref>, the Call Graph by Ryder [3], Lakhotia [18] and others, and the Program Summary Graph by Callahan [4]. <p> The SDG does not provide mechanisms to incorporate the important object-oriented concepts including inheritance, polymorphism and dynamic binding. The OPDG is designed to handle interprocedural analysis and at the same time, represent the concepts of the object-oriented paradigm in a clear subtle way. The Unified Interprocedural Graph (UIG) <ref> [8] </ref> extracts the important information incorporated into: the Call Graph, the SDG, the Program Summary Graph [4], and the Interprocedural Flow Graph (IFG) [10]. Algorithms developed for the previous representations are adapted to develop the UIG.
Reference: [9] <author> Mary Jean Harrold and John D. McGregor. </author> <title> Hierarchical incremental testing. </title> <type> Technical Report TR91-111, </type> <institution> Department of Computer Science, Clemson University, </institution> <year> 1991. </year>
Reference-contexts: The CHS is not a complete static representation of the program since it does not represent any implementation details of the methods. However, this level of information is enough for certain algorithms such as the Hierarchical Incremental Testing (HIT) <ref> [9] </ref> procedure, to provide useful information. The CHS at this stage represents the program after basic class design. The second layer is the Control Dependence Subgraph (CDS). The implementation for each method is included in this representation. Since this is a static representation, some information cannot be completely resolved.
Reference: [10] <author> Mary Jean Harrold and Mary Lou Soffa. </author> <title> Computation of interprocedural definition and use dependencies. </title> <booktitle> In Proceedings of IEEE Computer Society 1990 Int. Conf. on Comput. Languages, </booktitle> <address> New Orleans, LA, </address> <pages> pages 297-306, </pages> <year> 1990. </year>
Reference-contexts: The Unified Interprocedural Graph (UIG) [8] extracts the important information incorporated into: the Call Graph, the SDG, the Program Summary Graph [4], and the Interprocedural Flow Graph (IFG) <ref> [10] </ref>. Algorithms developed for the previous representations are adapted to develop the UIG. The UIG provides savings in both storage and access times over the storage and access times required for the individual representations.
Reference: [11] <author> Rajiv Gupta; Mary Jean Harrold and Mary Lou Soffa. </author> <title> An approach to regression testing using slicing. </title> <booktitle> In Proceedings of the Conference on Software Maintenance '92, </booktitle> <pages> pages 299-308, </pages> <year> 1992. </year>
Reference-contexts: The major problem encountered in determining slices across procedure bodies is the handling of parameters and flow of control and data across procedures. Pioneer work in interprocedural slicing has been done by Weiser [26], Horwitz et al [25], Gupta et al <ref> [11] </ref> and Livadas et al [19] among others. Slicing an object-oriented program requires more information than slicing a procedural program, even with multiple procedure bodies. A PDG provides sufficient information for a slicing tool to retrieve the slice for a statement-variable combination [14][19].
Reference: [12] <author> Horwitz S; Prins J and Reps T. </author> <title> Integrating non-interfering versions of programs. </title> <booktitle> In Proceedings of the 15th ACM Symposium of Programming Languages, </booktitle> <year> 1988. </year>
Reference-contexts: A brief discussion about few other applications is given below. * Integrating non-interfering versions of programs Horwitz et al present an algorithm for integrating several related, but different variants of a base program <ref> [12] </ref>. Slicing is used to determine the elements from the base program and its variants that are to be incorporated in the integrated program. This algorithm can be adapted with some changes to be applicable for object-oriented programs.
Reference: [13] <author> Ferrante J; Ottenstein K and Warren J.D. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-331, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Since the data members are encapsulated within the boundaries of the class scope, very few parameters are used along with the message calls leading to a more clear and compact message exchange mechanism. 2.2 Program Dependency Graphs A Program Dependency Graph (PDG) <ref> [13] </ref> is a graphical representation of a program that encodes both control and data dependencies into a single structure. For given statements X and Y in a program, the two statements can be related to each other either through control or data flow. <p> There are different versions of the PDG, each with an extension of the formal definition given by Ferrante et al <ref> [13] </ref>. As an object-oriented system consists of a number of messages between its constituent objects, the representation should be capable of depicting interprocedural dependencies, along with the other concepts of the paradigm namely, polymorphism, dynamic binding, classes and objects, and inheritance. <p> Furthermore, the Call Graph does not express important object-oriented concepts such as inheritance, polymorphism and dynamic binding. The OPDG incorporates these important concepts into the PDG using the edges and vertices described in Figure 2 and discussed in section 4.2. The Program Dependence Graph (PDG) <ref> [13] </ref> has proven to be a valuable tool for program analysis since it encodes both control and data dependence information into a single representation. The PDG has been used for program optimization, parallelization, testing, static and dynamic slicing, debugging and browsing.
Reference: [14] <author> Ottenstein K.J and Ottenstein L.M. </author> <title> The program dependence graph in a software development environment. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 19(5) </volume> <pages> 177-184, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: The basic requirements for the process of obtaining the slice are the data and control flow information. A Program Dependency Graph (PDG) provides the control flow, control dependence and data flow information. It was shown by Ottenstein and Ottenstein <ref> [14] </ref> that PDGs are well-suited for program slicing. <p> Determining a slice in a program is a very important related problem in the area of PDGs. Weiser introduced the concept of static program slicing in [26]. Ottenstein and Ottenstein discussed the algorithm to determine an intraprocedural slice based on the program dependence graphs <ref> [14] </ref>. Horwitz et al extended the concept introduced in [14] to determine interprocedural slices, using an enhanced version of the PDGs, namely the System Dependence Graph [25]. The problem was compared to a vertex reachability problem by both [14] and [25], since once a PDG has been built for a given <p> Weiser introduced the concept of static program slicing in [26]. Ottenstein and Ottenstein discussed the algorithm to determine an intraprocedural slice based on the program dependence graphs <ref> [14] </ref>. Horwitz et al extended the concept introduced in [14] to determine interprocedural slices, using an enhanced version of the PDGs, namely the System Dependence Graph [25]. The problem was compared to a vertex reachability problem by both [14] and [25], since once a PDG has been built for a given program, the problem is indeed determining which vertices are <p> algorithm to determine an intraprocedural slice based on the program dependence graphs <ref> [14] </ref>. Horwitz et al extended the concept introduced in [14] to determine interprocedural slices, using an enhanced version of the PDGs, namely the System Dependence Graph [25]. The problem was compared to a vertex reachability problem by both [14] and [25], since once a PDG has been built for a given program, the problem is indeed determining which vertices are reachable from the concerned statement vertex. In an object-oriented sense, determining a slice at run-time is more meaningful than determining a static slice.
Reference: [15] <author> David H. Abbott; Timothy D. Korson and John D. McGregor. </author> <title> A proposed design complexity metric for object-oriented development. </title> <type> Technical Report 94-105, </type> <institution> Clemson University, </institution> <year> 1994. </year> <month> 26 </month>
Reference-contexts: A debugger can be designed to extract the slice information and once this is obtained, the trace of the data flow can be made. * Psychological Complexity Metric Computation at the Design and Implementation levels This metric <ref> [15] </ref> computes the number of permitted interactions (PI value) that are possible with the available class interface. This is done by computing the interface size of the data items in the class.
Reference: [16] <author> Tim Korson and John McGregor. </author> <title> Object-oriented software design: A tutorial. </title> <journal> Communica--tions of the ACM, </journal> <volume> 33(9):40 | 60, </volume> <year> 1990. </year>
Reference-contexts: A class is a conceptual definition of a collection of data items, and operations on that data. Objects are instances of a class, and are those units that are syntactically addressable in a program <ref> [16] </ref>. The object-oriented paradigm's design principle is to build the system in an incremental fashion. A hierarchy of classes is developed, and specialized classes are constructed as we move down the hierarchy. Similarly, classes with more generalized features are seen as we move up the hierarchy. <p> Polymorphism in an object-oriented sense means that over time, object references can be to more than one class. As such, a polymorphic reference has both a static and a dynamic type associated with it <ref> [16] </ref>. The static type is the type with which the object is associated at declaration time and the dynamic type is the one that exists at run-time and is susceptible to change. Classes are composed of data members and methods which form the attributes of the class. <p> Consider the following declaration statements in C++: C *c1; // C is a class in a hierarchy C c2; // c1 and c2 are instance variables 16 Both c1 and c2 have a static type of class C. However, c1 can have a different dynamic type <ref> [16] </ref>, if there are subclasses inheriting from C, since c1 can be made to point to an instance of C or any of its subclasses. Whenever a message is sent to an object whose static type is the class C, the Call edge terminates at the Class header for C. <p> header, since the procedure is not bound to any class. 17 the actual and formal Parameter vertices are obviated, making the representation more straight forward and easier to understand. 4.3.3 Representing Polymorphism A polymorphic reference in an object-oriented language can, over time, refer to instances of more than one class <ref> [16] </ref>. Thus a polymorphic reference has both a static and a dynamic type associated with it. Polymorphism is associated with dynamic binding since the binding of a polymorphic message to the code to be executed in response to the call is accomplished dynamically.
Reference: [17] <author> Brian Malloy; John D. McGregor; Anand Krishnaswamy and Murali Medikonda. </author> <title> An extensible program representation for object-oriented software. </title> <note> Working Paper, </note> <year> 1994. </year>
Reference-contexts: Control Dependencies in a program are encoded in the CDS. The CFG describes the flow of control in the program and is similar to a flowchart in the normal sense. A DDS is a graph that incorporates all the data dependencies among the statements in a program. segment <ref> [17] </ref>. A CDS contains several types of vertices. Statement vertices, such as S1 and S3, represent statements in the program. Region vertices, such as R1 and R2, summarize control dependencies for statements in the region. <p> The scope of the problem handled in this research spans over two issues. The first is the design of a suitable compact representation for object-oriented programs <ref> [17] </ref>. An addendum to the problem discussed is that of retrieving a slice for an object-oriented program, given the compact representation. <p> This research work concentrates on bringing the important conceptual features of an object-oriented program in the form of a clear visible representation form <ref> [17] </ref>.
Reference: [18] <author> Arun Lakhotia. </author> <title> Constructing call multigraphs using dependence graphs. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 273-84, </pages> <year> 1993. </year>
Reference-contexts: Some interprocedural versions of a PDG are the System Dependency Graphs (SDG) first introduced by Horwitz et al [25] and extended by Livadas et al [19], the Unified Interprocedural Graph (UIG) by Harrold et al [8], the Call Graph by Ryder [3], Lakhotia <ref> [18] </ref> and others, and the Program Summary Graph by Callahan [4]. Although an interprocedural representation can depict an object-oriented program as a set of interlinked procedures, connected through call and return edges, there is a gap when it comes to representing the procedures as methods of a class.
Reference: [19] <author> Panos E. Livadas and Stephen Croll. </author> <title> Program slicing. </title> <type> Technical Report SERC-TR-61-F, </type> <institution> University of Florida, Gainesville, </institution> <year> 1992. </year>
Reference-contexts: Different techniques are seen in the literature that discuss issues about parameter handling. Some of the techniques are based on work done by Horwitz et al in [25], Harrold et al in [8] and Livadas and Scroll in <ref> [19] </ref>. Each paper discusses the pros and cons of the different approaches. <p> The versions of a PDG that come close to our requirements for representing object-oriented programs are the interprocedural dependency graphs. Some interprocedural versions of a PDG are the System Dependency Graphs (SDG) first introduced by Horwitz et al [25] and extended by Livadas et al <ref> [19] </ref>, the Unified Interprocedural Graph (UIG) by Harrold et al [8], the Call Graph by Ryder [3], Lakhotia [18] and others, and the Program Summary Graph by Callahan [4]. <p> The major problem encountered in determining slices across procedure bodies is the handling of parameters and flow of control and data across procedures. Pioneer work in interprocedural slicing has been done by Weiser [26], Horwitz et al [25], Gupta et al [11] and Livadas et al <ref> [19] </ref> among others. Slicing an object-oriented program requires more information than slicing a procedural program, even with multiple procedure bodies. A PDG provides sufficient information for a slicing tool to retrieve the slice for a statement-variable combination [14][19]. <p> When multiple call sites are present, this calling context helps distinguish between the call sites. Horwitz et al solve this by using linkage grammars [25]. Livadas et al showed a method of calculating dependencies that eliminates the need to follow the linkage grammar concept <ref> [19] </ref>. We present a method to handle the calling context problem that is simple and can be built in along with the implementation. In order to maintain the calling context for a message, we need information for every Call edge going to a Class header about the destination method. <p> The main concern in performing interprocedural analysis, is that of handling parameters and preserving the calling context. Parameters are handled with additional edges and vertices in the SDG and in the UIG. Horwitz et al present an algorithm in [25] using linkage grammars. Livadas and Scroll <ref> [19] </ref> present an alternate method to calculate the calling context, based on the call order in the program. The OPDG builds on the work presented in [19] and incorporates information into the Class header to save the calling context of the calls. <p> Horwitz et al present an algorithm in [25] using linkage grammars. Livadas and Scroll <ref> [19] </ref> present an alternate method to calculate the calling context, based on the call order in the program. The OPDG builds on the work presented in [19] and incorporates information into the Class header to save the calling context of the calls. Parameters are handled by redefining the Call edge to engulf the control and data flow between the call site and the called method or procedure.
Reference: [20] <author> Panos E. Livadas and Prabal K. Roy. </author> <title> Program dependence analysis. </title> <booktitle> In IEEE Conference on Software Maintenance 1992, </booktitle> <pages> pages 356-365, </pages> <year> 1992. </year>
Reference-contexts: Formally, a SDG is a directed, labeled multigraph that consists of a program dependence graph 7 and a collection of procedure dependence graphs. The program dependence graph models the main program and the latter model the procedure bodies in the software system <ref> [20] </ref>. The SDG also handles interprocedural flow of data and control, and the representation for the transfer of parameters. Different techniques are seen in the literature that discuss issues about parameter handling.
Reference: [21] <author> Mary Jean Harrold; Brian Malloy and Gregg Rothermel. </author> <title> Efficient construction of program dependence graphs. </title> <booktitle> ACM International Symposium on Software Testing and Analysis, </booktitle> <volume> 18(3) </volume> <pages> 160-70, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: A PDG is formally defined to have a Control Dependence Subgraph (CDS), a Control Flow Graph (CFG) and a Data Dependence Subgraph (DDS) <ref> [21] </ref>. Control Dependencies in a program are encoded in the CDS. The CFG describes the flow of control in the program and is similar to a flowchart in the normal sense. A DDS is a graph that incorporates all the data dependencies among the statements in a program. segment [17]. <p> Furthermore, vertices S3, S4, R4, R5 and S11 are all in the same region R3 and thus, have the same control dependencies. Control flow information, for a structured program, is incorporated into the PDG, implicitly by ordering the vertices and explicitly by adding backedges for loops <ref> [21] </ref>. In Figure 1, vertices S3, S4, C5 and P5 are ordered as they appear in the source code, which also indicates the flow of control for these vertices. <p> Information regarding the data members of the class are also available in the Class header. - Method/Procedure A Method or a Procedure header is the entry vertex for the corresponding method or 12 procedure. Its representation is similar to the entry vertex of a procedure as given in <ref> [21] </ref> or [25]. The Method header adds additional meaning to the representation by encapsulating information such as the class to which it belongs, data attributes of the class and parameter translation from actual to formal and vice-versa. <p> A brief description for each type of edge is given below. * Control Edges Flow Edges These are uni-directional edges that depict the explicit flow of control in the program. Implicit flow is denoted using the left-to-right notation of <ref> [21] </ref>. In figure 4, for the example code segment given, implicit flow of control is represented between the statements S20, S21 and S22 using the left-to-right notation. <p> The PDG has been used for program optimization, parallelization, testing, static and dynamic slicing, debugging and browsing. The PDG has been extended to incorporate control flow information <ref> [21] </ref>, expanding the viable applications of the PDG. However, even with this extension, the PDG does not permit interprocedural analysis. Furthermore, the PDG does not possess the expressiveness to represent such important object-oriented concepts as inheritance, polymorphism and dynamic binding.
Reference: [22] <author> John D. McGregor and David A. Sykes. </author> <title> Object-Oriented Software Development: Engineering Software for Reuse. </title> <publisher> Van Nostrand Reinhold, </publisher> <year> 1992. </year>
Reference-contexts: Inheritance is a relation between classes that allows definition and implementation of a class to be built on another. Inheritance proposes reuse of software units, like pre-designed classes and hence is a major structuring principle in the design of object-oriented systems <ref> [22] </ref>. Another concept that stands prominently in an object-oriented design is polymorphism and dynamic binding of messages to methods. Polymorphism in an object-oriented sense means that over time, object references can be to more than one class.
Reference: [23] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: Able to act as a bridge across languages * Able to support a range of program analysis activities * Freedom to be updated, when the paradigm grows * Freedom to be tailored to a particular language There are different representations available for object-oriented design, like the Object Modeling Technique (OMT) <ref> [23] </ref> and the Interface Definition Language (IDL) [1]. These representations being design based, fail to give a complete picture of the programs they represent. Implementation details are not presented, and this prevents the complete analysis of the code. <p> The following sections discuss the two issues in more detail. 3.1 Representing Object-oriented Programs There are a few representations for object-oriented programs that come close to being general, like Rumbaugh's Object Modeling Technique (OMT) <ref> [23] </ref> and Object Management Group's Interface Definition Language (IDL) [1]. Another representation for object-oriented programs is the extension to the formal specification language Z, namely Object Z [6].
Reference: [24] <author> Bjarne Stroustrup. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <note> second edition, </note> <year> 1991. </year>
Reference: [25] <author> Horwitz S; Reps T and Binkley D. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> Jan </month> <year> 1990. </year>
Reference-contexts: A PDG is defined usually for a single procedure program. In order to make it more realistic, we have to consider a representation that matches the real world programs, that are made up of multiple procedures. A System Dependence Graph <ref> [25] </ref>, is a decorated parse tree of the program. Formally, a SDG is a directed, labeled multigraph that consists of a program dependence graph 7 and a collection of procedure dependence graphs. <p> The SDG also handles interprocedural flow of data and control, and the representation for the transfer of parameters. Different techniques are seen in the literature that discuss issues about parameter handling. Some of the techniques are based on work done by Horwitz et al in <ref> [25] </ref>, Harrold et al in [8] and Livadas and Scroll in [19]. Each paper discusses the pros and cons of the different approaches. <p> The versions of a PDG that come close to our requirements for representing object-oriented programs are the interprocedural dependency graphs. Some interprocedural versions of a PDG are the System Dependency Graphs (SDG) first introduced by Horwitz et al <ref> [25] </ref> and extended by Livadas et al [19], the Unified Interprocedural Graph (UIG) by Harrold et al [8], the Call Graph by Ryder [3], Lakhotia [18] and others, and the Program Summary Graph by Callahan [4]. <p> Horwitz et al give a general definition of a slice <ref> [25] </ref>. A slice is defined with respect to a program point p and a variable x that is defined or used at p. We consider this definition of a slice in the remainder of this work. <p> The major problem encountered in determining slices across procedure bodies is the handling of parameters and flow of control and data across procedures. Pioneer work in interprocedural slicing has been done by Weiser [26], Horwitz et al <ref> [25] </ref>, Gupta et al [11] and Livadas et al [19] among others. Slicing an object-oriented program requires more information than slicing a procedural program, even with multiple procedure bodies. A PDG provides sufficient information for a slicing tool to retrieve the slice for a statement-variable combination [14][19]. <p> Its representation is similar to the entry vertex of a procedure as given in [21] or <ref> [25] </ref>. The Method header adds additional meaning to the representation by encapsulating information such as the class to which it belongs, data attributes of the class and parameter translation from actual to formal and vice-versa. The Method header also forms one of the end points of the Class Membership edge. <p> There are different applications of slicing, few of them being isolation of individual computation threads within a program, understanding complicated code, debugging, automatic parallelization and code reusability. Horwitz et al give a general definition of a slice <ref> [25] </ref>. A slice is defined with respect to a program point p and a variable x that is defined or used at p. <p> When multiple call sites are present, this calling context helps distinguish between the call sites. Horwitz et al solve this by using linkage grammars <ref> [25] </ref>. Livadas et al showed a method of calculating dependencies that eliminates the need to follow the linkage grammar concept [19]. We present a method to handle the calling context problem that is simple and can be built in along with the implementation. <p> However, even with this extension, the PDG does not permit interprocedural analysis. Furthermore, the PDG does not possess the expressiveness to represent such important object-oriented concepts as inheritance, polymorphism and dynamic binding. The System Dependence Graph (SDG) <ref> [25] </ref> combines PDGs for individual procedures with additional information to permit the computation of an interprocedural slice of the program. To construct the system dependence graph, vertices are added to a procedure's dependence graph to model parameter passing, in a manner similar to the construction of the OPDG. <p> The main concern in performing interprocedural analysis, is that of handling parameters and preserving the calling context. Parameters are handled with additional edges and vertices in the SDG and in the UIG. Horwitz et al present an algorithm in <ref> [25] </ref> using linkage grammars. Livadas and Scroll [19] present an alternate method to calculate the calling context, based on the call order in the program. The OPDG builds on the work presented in [19] and incorporates information into the Class header to save the calling context of the calls. <p> Ottenstein and Ottenstein discussed the algorithm to determine an intraprocedural slice based on the program dependence graphs [14]. Horwitz et al extended the concept introduced in [14] to determine interprocedural slices, using an enhanced version of the PDGs, namely the System Dependence Graph <ref> [25] </ref>. The problem was compared to a vertex reachability problem by both [14] and [25], since once a PDG has been built for a given program, the problem is indeed determining which vertices are reachable from the concerned statement vertex. <p> Horwitz et al extended the concept introduced in [14] to determine interprocedural slices, using an enhanced version of the PDGs, namely the System Dependence Graph <ref> [25] </ref>. The problem was compared to a vertex reachability problem by both [14] and [25], since once a PDG has been built for a given program, the problem is indeed determining which vertices are reachable from the concerned statement vertex. In an object-oriented sense, determining a slice at run-time is more meaningful than determining a static slice.
Reference: [26] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(4) </volume> <pages> 352-357, </pages> <month> July </month> <year> 1984. </year> <month> 27 </month>
Reference-contexts: and is termed, the Object-oriented Program Dependency Graph or the OPDG. 3.2 Calculating an Object-oriented Slice The slice of a program with respect to a program point p and variable x consists of all statements and predicates of the program that might affect the value of x at point p <ref> [26] </ref>. Horwitz et al give a general definition of a slice [25]. A slice is defined with respect to a program point p and a variable x that is defined or used at p. We consider this definition of a slice in the remainder of this work. <p> The major problem encountered in determining slices across procedure bodies is the handling of parameters and flow of control and data across procedures. Pioneer work in interprocedural slicing has been done by Weiser <ref> [26] </ref>, Horwitz et al [25], Gupta et al [11] and Livadas et al [19] among others. Slicing an object-oriented program requires more information than slicing a procedural program, even with multiple procedure bodies. <p> are developed in a progression down the hierarchy, more choices are linked together. 5 Program Slicing The slice of a program with respect to a program point p and variable x consists of all statements and predicates of the program that might affect the value of x at point p <ref> [26] </ref>. There are different applications of slicing, few of them being isolation of individual computation threads within a program, understanding complicated code, debugging, automatic parallelization and code reusability. Horwitz et al give a general definition of a slice [25]. <p> The resulting representation of an object-oriented program is more compact and easier to understand. Determining a slice in a program is a very important related problem in the area of PDGs. Weiser introduced the concept of static program slicing in <ref> [26] </ref>. Ottenstein and Ottenstein discussed the algorithm to determine an intraprocedural slice based on the program dependence graphs [14]. Horwitz et al extended the concept introduced in [14] to determine interprocedural slices, using an enhanced version of the PDGs, namely the System Dependence Graph [25].
References-found: 26

