URL: ftp://ftp.cs.concordia.ca/pub/laks/papers/dood93.ps.gz
Refering-URL: http://karna.cs.umd.edu:3264/people/godfrey/cites.html
Root-URL: 
Email: e-mail: flaks, sadri, subbug@cs.concordia.ca  
Title: On the Logical Foundations of Schema Integration and Evolution in Heterogeneous Database Systems  
Author: Laks V.S. Lakshmanan Fereidoon Sadri Iyer N. Subramanian 
Address: Montreal, Quebec  
Affiliation: Department of Computer Science, Concordia University,  
Date: Dec. 1993.  
Note: Appears in: DOOD'93, Phoenix, AZ,  
Abstract: Developing a declarative approach to schema integration in the context of heterogeneous database systems is a major goal of this research. We take a first step toward this goal in this paper, by developing a simple logic called SchemaLog which is syntactically higher-order but has a first-order semantics. SchemaLog can provide for a logical integration of multiple relational databases in a federation of database systems. We develop a fixpoint theory as well as a sound and complete proof theory for the definite clause fragment of SchemaLog and show their equivalence to the model-theoretic semantics. We argue that a uniform framework for schema integration as well as schema evolution is both desirable and possible. We illustrate the simplicity and power of SchemaLog with a variety of applications involving database programming (with schema browsing), schema integration, schema evolution, and cooperative query answering. 
Abstract-found: 1
Intro-found: 1
Reference: [ABW88] <author> Apt, K.R., Blair, H.A., and Walker, A. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming. </booktitle> <address> Morgan-Koffmann, </address> <year> 1988. </year>
Reference-contexts: The proof of this theorem follows arguments very similar to those for classical logic programming (see [vK76]). 2 Allowing negation in SchemaLog programs is fairly straightforward. For example, stratified negation (see Apt et. al. <ref> [ABW88] </ref>) can be easily supported and the fixpoint semantics can be correspondingly extended. 4.2 Proof Theory of SchemaLog In this section, we present a resolution based proof theory for SchemaLog. We consider the issues of Herbrand theorem, unification, and resolution.
Reference: [ACM90] <editor> ACM. </editor> <booktitle> ACM Computing Surveys, </booktitle> <volume> volume 22, </volume> <month> Sept </month> <year> 1990. </year> <note> Special issue on HDBS. </note>
Reference-contexts: HDBS are also referred to as Multi Database Systems (MDBS) and Federated Database Systems (FDBS) by different authors. The reader is referred to <ref> [ACM90] </ref> (in particular, see Sheth and Larson [SL90], [LLR90]) and Hsiao [Hsi92] for recent surveys in the field. One aspect of heterogeneity stems from the difference in the structure of (similar) data and query languages across the individual database systems.
Reference: [AG87] <author> Abiteboul, S. and Grumbach, S. Col: </author> <title> A logic-based language for complex objects. </title> <booktitle> In Proc. of Workshop on Database Programming Languages, </booktitle> <pages> pages 253-276, </pages> <year> 1987. </year>
Reference-contexts: We compare SchemaLog with existing higher-order logics such as HiLog (Chen et. al. [CKW90]), F-logic (Kifer et. al. [KLW90]), HOL (Manchanda [Man89]), and COL (Abiteboul and Grumbach <ref> [AG87] </ref>), and also comment on the "design decisions" we made in the development of SchemaLog (Section 6). Finally, we give our conclusions and discuss future research (Section 7). For lack of space, we suppress all the proofs. <p> This paper also illustrates a template mechanism to define the database schema. But it is not obvious how to extend this language to a framework which would support queries over higher-order objects across multiple databases. Abiteboul and Grumbach <ref> [AG87] </ref> introduces a logic called COL for defining and manipulating complex objects. COL achieves the functionality for manipulating complex objects by introducing what are called (base and derived) "data functions". The syntax as well as the semantics of COL is higher-order.
Reference: [ASD + 91] <author> Ahmed, R., Smedt, P., Du, W., Kent, W., Ketabchi, A., and Litwin, W. </author> <title> The pegasus heterogeneous multidatabase system. </title> <booktitle> IEEE Computer, </booktitle> <month> Dec </month> <year> 1991. </year>
Reference-contexts: A "canonical" example of the CDM based approach is the Pegasus project of Ahmed et.al. <ref> [ASD + 91] </ref>. Pegasus defines a common object model for unifying the data models of the underlying systems.
Reference: [BG92] <author> Barsalou, T. and Gangopadhyay, D. </author> <title> An open framework for interoperation of multimodel multidatabase systems. </title> <booktitle> In IEEE Data Engg., </booktitle> <year> 1992. </year>
Reference-contexts: Krishnamurthy, Litwin, and Kent [KLK91] extends this language and demonstrates its relational schema integration capabilities. However, they do not provide a formal model-theoretic semantics for their language. An interesting approach that falls in between the above two classifications is the M (DM) model of Barsalou and Gangopadhyay <ref> [BG92] </ref>. M (DM) deals with a set of metatypes each formalizing the data model construct in second-order logic. Although the combination of logic, object orientation and metaprogramming gives much power to M (DM), its second-order nature raises questions about the possibility of practical implementations based on this approach.
Reference: [BLN86] <author> Batini, C., Lenzerini M., and Navathe S.B. </author> <title> A comparative analysis of methodologies for database schema integration. </title> <journal> ACM Comput. Surveys, </journal> <pages> pages 323-364, </pages> <month> Dec </month> <year> 1986. </year>
Reference-contexts: Schema integration is a crucial requirement for a HDBS. Most of the approaches attempted so far for the schema integration problem have been ad hoc. The survey paper of Batini et. al <ref> [BLN86] </ref> discusses and compares 12 methodologies for schema integration. We can broadly classify the schema integration approaches into two. 1) Approaches based on defining a common data model: Most of the existing approaches attempted for schema integration belong to this category.
Reference: [CD88] <author> Cuppens, F. and Demolombe, R. </author> <title> Cooperative answering: a methodology to provide intelligent access to databases. </title> <booktitle> In Second Intl. conf. on Expert Database Systems, </booktitle> <year> 1988. </year>
Reference-contexts: We also consider the aspect of CQA, concerned with answering queries in data/knowledge base systems by extending the scope of the query so that more information can be gathered in the answers, as discussed in Cuppens and Demolombe <ref> [CD88] </ref>. Responses can be generated by looking for answers that are related to the original answers, but are not necessarily literal answers of the original query. Consider the application of schema evolution discussed in the previous section.
Reference: [CKW89] <author> Chen, W., Kifer, M., and Warren, </author> <title> D.S. Hilog as a platform for database language. </title> <booktitle> In 2nd Intl. Workshop on Database Programming Languages, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: HiLog also blurs the distinction between the atoms and terms. Thus, the language has a powerful syntactic expressivity and finds natural applications in numerous contexts [see [CKW90] for details]. HiLog has a sound and complete proof theory. <ref> [CKW89] </ref> discusses the applicability of HiLog as a database programming language. The higher-order syntactic features of the language find interesting applications for schema browsing, set operations, and as an implementation vehicle for object-oriented languages.
Reference: [CKW90] <author> Chen, W., Kifer, M., and Warren, </author> <title> D.S. A foundation for higher-order logic programming. </title> <type> Technical report, </type> <institution> SUNY at Stony Brook, </institution> <year> 1990. </year> <note> (Preliminary versions appear in Proc. 2nd Intl. Workshop on DBPL, 1989 and Proc. NACLP 1989.). </note>
Reference-contexts: Our syntax was inspired in part by that of [KN88]. However while they provide no formal semantics, we develop model-theoretic, fixpoint and proof-theoretic semantics for SchemaLog. Besides, technically the framework developed by us is different from theirs. SchemaLog, like HiLog (Chen et. al. <ref> [CKW90] </ref>), is syntactically higher-order but semantically first-order. In this paper, we confine ourselves to the schema integration problem for relational databases. Our eventual objective is to extend SchemaLog into a logic capable of providing for the integration of different data models (notably the object oriented model). <p> We also make a case for adopting a uniform framework for schema integration and evolution and illustrate via examples how SchemaLog could fulfill this need. We compare SchemaLog with existing higher-order logics such as HiLog (Chen et. al. <ref> [CKW90] </ref>), F-logic (Kifer et. al. [KLW90]), HOL (Manchanda [Man89]), and COL (Abiteboul and Grumbach [AG87]), and also comment on the "design decisions" we made in the development of SchemaLog (Section 6). Finally, we give our conclusions and discuss future research (Section 7). <p> Yet its higher-order syntax gives it sufficient power to express complex queries in a natural way thus bringing programming closer to intuition. For instance let us take a look at the following example query adopted from <ref> [CKW90] </ref>. (Q3) Find the names of all the binary relations in which the token `john' appears. <p> The (inevitably) numerous aliases of `john' could be captured as an edb relation representing the correspondence mappings between names across the component databases of the federation. 6 Discussion The notion of "higher-orderness" associated with a logic is ill-defined. Chen et. al. <ref> [CKW90] </ref> points this out and provides a clear classification of logics based on the order of their syntax and semantics. It is generally believed that higher-order syntax would be quite useful in the context of object-oriented databases, database programming, and schema integration. <p> It is generally believed that higher-order syntax would be quite useful in the context of object-oriented databases, database programming, and schema integration. In this section, we compare SchemaLog with existing higher-order logics. We also comment on the "design decisions" made in the development of SchemaLog. HiLog (Chen et. al. <ref> [CKW90] </ref>) is a powerful logic based on higher-order syntax but with a first-order semantics. Parameters are arityless in this language and the distinction between predicate, function and constant symbols is eliminated. HiLog terms could be constructed from any logical symbol followed by any finite number of arguments. <p> HiLog terms could be constructed from any logical symbol followed by any finite number of arguments. HiLog also blurs the distinction between the atoms and terms. Thus, the language has a powerful syntactic expressivity and finds natural applications in numerous contexts [see <ref> [CKW90] </ref> for details]. HiLog has a sound and complete proof theory. [CKW89] discusses the applicability of HiLog as a database programming language. The higher-order syntactic features of the language find interesting applications for schema browsing, set operations, and as an implementation vehicle for object-oriented languages. <p> SchemaLog treats the data in a database, the schema of the individual databases in a federation, as well as the databases themselves as first class citizens. This makes SchemaLog (syntactically) higher-order. We have developed a simple first-order semantics for SchemaLog, based on the idea (e.g., see <ref> [CKW90] </ref>) of making the intensions of higher-order objects explicit in the semantic structure and making the higher-order variables range over these intensions rather than the extensions they stand for. We have also developed a fixpoint theoretic and proof-theoretic semantics of SchemaLog (for definite clause programs).
Reference: [CL73] <author> Chang, C.L. and Lee, R.C.T. </author> <title> Symbolic Logic and Mechanical Theorem Proving. </title> <address> New York, </address> <publisher> Academic Press, </publisher> <year> 1973. </year>
Reference-contexts: Herbrand's theorem can now be proved from the above result using a technique similar to that used for predicate calculus <ref> [CL73] </ref>. 2 6 Actually, the proof theory is sound and complete for all clausal theories. Unification: Unification in SchemaLog has to be treated differently from the way it is done conventionally.
Reference: [GGM92] <author> Gaasterland, T., Godfrey, P., and Minker, J. </author> <title> An overview of cooperative answering. </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 1 </volume> <pages> 123-157., </pages> <year> 1992. </year>
Reference-contexts: An overview of the work done in this area can be found in Gaasterland et. al. <ref> [GGM92] </ref>. We also consider the aspect of CQA, concerned with answering queries in data/knowledge base systems by extending the scope of the query so that more information can be gathered in the answers, as discussed in Cuppens and Demolombe [CD88].
Reference: [Hsi92] <author> Hsiao, D.K. </author> <title> Federated databases and systems: Part-one a tutorial on their data sharing. </title> <journal> VLDB Journal, </journal> <volume> 1 </volume> <pages> 127-179, </pages> <year> 1992. </year>
Reference-contexts: HDBS are also referred to as Multi Database Systems (MDBS) and Federated Database Systems (FDBS) by different authors. The reader is referred to [ACM90] (in particular, see Sheth and Larson [SL90], [LLR90]) and Hsiao <ref> [Hsi92] </ref> for recent surveys in the field. One aspect of heterogeneity stems from the difference in the structure of (similar) data and query languages across the individual database systems.
Reference: [Kim90] <author> Kim, Won. </author> <title> Introduction to Object Oriented Databases. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Schema evolution is a somewhat abused term in the database field. There is no clear definition associated with this term and it has been interpreted to mean different things by different researchers. While Kim <ref> [Kim90] </ref> treats versioning of 10 This example is an adaptation of a similar example in [KN88]. schema for object management as schema evolution, Nguyen and Rieu [NR89] considers the various schema change operations and the associated consequences as being its main issues.
Reference: [KLK91] <author> Krishnamurthy, R., Litwin, W., and Kent, W. </author> <title> Language features for interoperability of databases with schematic discrepancies. </title> <booktitle> In ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 40-49, </pages> <year> 1991. </year>
Reference-contexts: This language has most if not all of the power of Prolog and unlike Prolog, is declarative. It is based on bottom-up semantics and the approach replaces higher-order unification with the term matching operation. Krishnamurthy, Litwin, and Kent <ref> [KLK91] </ref> extends this language and demonstrates its relational schema integration capabilities. However, they do not provide a formal model-theoretic semantics for their language. An interesting approach that falls in between the above two classifications is the M (DM) model of Barsalou and Gangopadhyay [BG92]. <p> Q1: Which are the departments that have an average salary of above $25K in all the three universities for any given category? Q2: List similar departments in univ B and univ C that have the same average salary for similar categories of staff. Following <ref> [KLK91] </ref>, we can visualize the "universe of discourse" 4 as a tuple of databases where each database is a tuple of relations and each relation is a set of tuples of objects (which are simply values).
Reference: [KLW90] <author> Kifer, M., Lausen, G., and Wu, J. </author> <title> Logical foundations of frame-based languages. </title> <type> Technical Report 90/14, </type> <institution> SUNY at Stony Brook, </institution> <month> August </month> <year> 1990. </year> <note> (revised and extended 1992 and 1993; to appear in JACM.). </note>
Reference-contexts: We also make a case for adopting a uniform framework for schema integration and evolution and illustrate via examples how SchemaLog could fulfill this need. We compare SchemaLog with existing higher-order logics such as HiLog (Chen et. al. [CKW90]), F-logic (Kifer et. al. <ref> [KLW90] </ref>), HOL (Manchanda [Man89]), and COL (Abiteboul and Grumbach [AG87]), and also comment on the "design decisions" we made in the development of SchemaLog (Section 6). Finally, we give our conclusions and discuss future research (Section 7). For lack of space, we suppress all the proofs. <p> Hence HiLog (without further extensions) seems to be unsuitable for schema integration purposes. Kifer et. al. <ref> [KLW90] </ref> provides a logical foundation for object-oriented databases using a logic called F-logic. Like Hilog, F-logic is a logic with a higher-order syntax but a first-order semantics 12 . The logic is powerful enough to capture the object-oriented notions of complex objects, classes, types, methods, and inheritance.
Reference: [KN88] <author> Krishnamurthy, R. and Naqvi, S. </author> <title> Towards a real horn clause language. </title> <booktitle> In Proc. 14th VLDB Conf., </booktitle> <pages> pages 252-263, </pages> <year> 1988. </year>
Reference-contexts: Thus a CDM, as defined in the previous case is not required: the higher-order language in some sense plays the role of the CDM here. The major advantage associated with this approach is the declarativity it derives from its logical foundations. Krishnamurthy and Naqvi <ref> [KN88] </ref> proposes a horn-clause like language that can "range over" both data and meta-data by allowing higher-order variables. This language has most if not all of the power of Prolog and unlike Prolog, is declarative. <p> In this paper, we develop the logical foundations of schema integration of HDBS based on a higher-order logic called SchemaLog. Our syntax was inspired in part by that of <ref> [KN88] </ref>. However while they provide no formal semantics, we develop model-theoretic, fixpoint and proof-theoretic semantics for SchemaLog. Besides, technically the framework developed by us is different from theirs. SchemaLog, like HiLog (Chen et. al. [CKW90]), is syntactically higher-order but semantically first-order. <p> Schema evolution is a somewhat abused term in the database field. There is no clear definition associated with this term and it has been interpreted to mean different things by different researchers. While Kim [Kim90] treats versioning of 10 This example is an adaptation of a similar example in <ref> [KN88] </ref>. schema for object management as schema evolution, Nguyen and Rieu [NR89] considers the various schema change operations and the associated consequences as being its main issues.
Reference: [Llo87] <author> Lloyd, J. W. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: An SLD-refutation of P [ fGg is a finite SLD-derivation of P [ fGg which has the empty clause 2 as the last goal in the derivation. The notions of correct and computed answers are defined in a manner identical to that for standard logic programming (e.g., see Lloyd <ref> [Llo87] </ref>). We can prove, Theorem 4.3 Soundness of SLD-Resolution: Let P be a definite program and G a definite goal. Then every computed answer for P [ fGg is a correct answer for P [ fGg.
Reference: [LLR90] <author> Litwin, Witold, Leo, Mark, and Roussopoulos, Nick. </author> <title> Interoperability of multiple autonomous databases. </title> <journal> ACM computing surveys, </journal> <volume> 22(3) </volume> <pages> 267-293, </pages> <month> Sept </month> <year> 1990. </year>
Reference-contexts: HDBS are also referred to as Multi Database Systems (MDBS) and Federated Database Systems (FDBS) by different authors. The reader is referred to [ACM90] (in particular, see Sheth and Larson [SL90], <ref> [LLR90] </ref>) and Hsiao [Hsi92] for recent surveys in the field. One aspect of heterogeneity stems from the difference in the structure of (similar) data and query languages across the individual database systems.
Reference: [LR82] <author> Landers, T. and Rosenberg, R. </author> <title> An overview of multibase. </title> <booktitle> Distributed Databases, </booktitle> <pages> pages 153-184, </pages> <year> 1982. </year>
Reference-contexts: A "canonical" example of the CDM based approach is the Pegasus project of Ahmed et.al. [ASD + 91]. Pegasus defines a common object model for unifying the data models of the underlying systems. Landers and Rosenberg <ref> [LR82] </ref> uses the functional model of DAPLEX as the CDM in their Multibase project, while Mermaid (Templeton etal [Tem87]) uses a relational CDM, and allows only for relational schema integration (with extensions to include text). Thus federation users may formulate queries using SQL.
Reference: [LSS93] <author> Lakshmanan, L.V.S., Sadri, F., and Subramanian, I. N. </author> <title> On the logical foundations of schema integration and evolution in heterogeneous database systems. </title> <type> Technical report, </type> <institution> Concordia University, Montreal, </institution> <month> July </month> <year> 1993. </year> <note> Submitted for publication, October 1993. (A preliminary version appeared in International Conference on Deductive and Object Oriented Databases, December 1993.). </note>
Reference-contexts: Finally, we give our conclusions and discuss future research (Section 7). For lack of space, we suppress all the proofs. The complete details of the results in this paper can be found in <ref> [LSS93] </ref>. 2 SchemaLog by Example In this section, we will introduce the syntax and intuitive meaning of our proposed language informally via an example. We will follow it with a formal account of the syntax and semantics in the next section. <p> Theorem 4.2 (Herbrand's Theorem) A set of wffs in clausal form is unsatisfi-able iff there is a finite conjunction of ground instances of its clauses which is unsatisfiable. Proof sketch: It can be shown <ref> [LSS93] </ref> that there is a transformation from Schema-Log to first order logic such that a SchemaLog formula is true in a structure M under vaf iff the corresponding first order formula f is true in the corresponding first order structure M f under the vaf -. <p> A unifier of a literal L i with literal L j is a most general unifier (mgu) iff for each unifier for L i with L j , there exists a substitution such that = . We refer the reader to <ref> [LSS93] </ref> for complete details of the unification algorithm, which is essentially obtained by simple modifications to the corresponding algorithm for predicate logic. The modifications account for the differences in the syntax. <p> Then every computed answer for P [ fGg is a correct answer for P [ fGg. Proof sketch: This theorem can be proved by a simple induction on the length of the refutation. The details can be found in <ref> [LSS93] </ref>. 2 Theorem 4.4 Completeness of SLD-resolution: Let P be a definite program and G be a goal. For every correct answer for P [ fGg, there exists a computed answer for P [ fGg and a substitution fl such that = fl. <p> Proof sketch: The proof makes use of the mgu lemma and the lifting lemma. These lemmas can be proved in a way similar to that for predicate calculus. The details can be found in <ref> [LSS93] </ref>. 2 Molecular programming vs Atomic programming We mentioned in Section 3.1 that molecular formulas can be introduced in the syntax of SchemaLog as an abbreviation for a conjunction of atomic formulas. Molecular formulas can indeed provide a mechanism for direct, convenient programming. <p> The details are discussed at length in <ref> [LSS93] </ref>. 8 This will necessitate two rules one for each argument of the predicate grandpa. set of predicate symbols and then interpreting them "classically". <p> Even though SchemaLog is quite simple, our study (and our experience) indicates that it has a rich expressive power making it applicable to a variety of problems including database programming (with schema browsing), schema integration and evolution, and cooperative query answering. In <ref> [LSS93] </ref>, we give a reduction of SchemaLog to first-order logic. Several issues remain open. Our proof theory is complete only for clausal theories. Skolemiza-tion is an issue just as it is in HiLog and we are presently working on resolving it 13 .
Reference: [Man89] <author> Manchanda, S. </author> <title> Higher-order logic as a data model. </title> <booktitle> In Proc. of the North American Conf. on Logic Programming, </booktitle> <pages> pages 330-341, </pages> <year> 1989. </year>
Reference-contexts: We also make a case for adopting a uniform framework for schema integration and evolution and illustrate via examples how SchemaLog could fulfill this need. We compare SchemaLog with existing higher-order logics such as HiLog (Chen et. al. [CKW90]), F-logic (Kifer et. al. [KLW90]), HOL (Manchanda <ref> [Man89] </ref>), and COL (Abiteboul and Grumbach [AG87]), and also comment on the "design decisions" we made in the development of SchemaLog (Section 6). Finally, we give our conclusions and discuss future research (Section 7). For lack of space, we suppress all the proofs. <p> However it does not have a means of referring to individual schemas (as first class citizens) which is vital in schema integration applications. A higher-order language for computing with labeled sets is introduced in Man-chanda <ref> [Man89] </ref>. The language supports structured data, object-identity, and sets. This also belongs to the above class of languages in that its semantics is first-order. This paper also illustrates a template mechanism to define the database schema.
Reference: [NR89] <author> Nguyen, G.T. and Rieu, D. </author> <title> Schema evolution in object-oriented database systems. </title> <journal> Data and Knowledge Engg., North-Holland, </journal> <volume> 4 </volume> <pages> 43-67, </pages> <year> 1989. </year>
Reference-contexts: There is no clear definition associated with this term and it has been interpreted to mean different things by different researchers. While Kim [Kim90] treats versioning of 10 This example is an adaptation of a similar example in [KN88]. schema for object management as schema evolution, Nguyen and Rieu <ref> [NR89] </ref> considers the various schema change operations and the associated consequences as being its main issues. Osborn [Osb89] gives some interesting perspectives on the consequences of the polymorphic constructs in object-oriented databases and how this aids in avoiding `code' evolution.
Reference: [Osb89] <author> Osborn, Sylvia. </author> <title> The role of polymorphism in schema evolution in an object-oriented database. </title> <journal> In IEEE Trans. on Knowledge and Data Engg., </journal> <pages> pages 310-317, </pages> <month> Sept </month> <year> 1989. </year>
Reference-contexts: While Kim [Kim90] treats versioning of 10 This example is an adaptation of a similar example in [KN88]. schema for object management as schema evolution, Nguyen and Rieu [NR89] considers the various schema change operations and the associated consequences as being its main issues. Osborn <ref> [Osb89] </ref> gives some interesting perspectives on the consequences of the polymorphic constructs in object-oriented databases and how this aids in avoiding `code' evolution.
Reference: [She88] <author> Shepherdson, </author> <title> J.C. Negation in logic programming. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming. </booktitle> <address> Morgan-Koffmann, </address> <year> 1988. </year>
Reference-contexts: We have also developed a fixpoint theoretic and proof-theoretic semantics of SchemaLog (for definite clause programs). In fact, the framework can be easily extended to incorporate the various forms of negation extensively studied in the literature of deductive databases and logic programming (see <ref> [She88] </ref> for a survey), notably stratified negation, with minor modifications.
Reference: [SL90] <author> Sheth, Amit P. and Larson, James A. </author> <title> Federated database system for managing distributed, heterogeneous and autonomous databases. </title> <journal> ACM computing surveys, </journal> <volume> 22(3) </volume> <pages> 183-236, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: HDBS are also referred to as Multi Database Systems (MDBS) and Federated Database Systems (FDBS) by different authors. The reader is referred to [ACM90] (in particular, see Sheth and Larson <ref> [SL90] </ref>, [LLR90]) and Hsiao [Hsi92] for recent surveys in the field. One aspect of heterogeneity stems from the difference in the structure of (similar) data and query languages across the individual database systems.
Reference: [Tem87] <author> Templeton, M., et al. Mermaid: </author> <title> A front-end to distributed heterogeneous databases. </title> <booktitle> In Proc. IEEE 75, </booktitle> <volume> 5, </volume> <pages> pages 695-708, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Pegasus defines a common object model for unifying the data models of the underlying systems. Landers and Rosenberg [LR82] uses the functional model of DAPLEX as the CDM in their Multibase project, while Mermaid (Templeton etal <ref> [Tem87] </ref>) uses a relational CDM, and allows only for relational schema integration (with extensions to include text). Thus federation users may formulate queries using SQL. The major problem associated with the approaches in this category is the amount of human participation required for obtaining the CDM mappings.
Reference: [Ull87] <author> Ullman, J.D. </author> <title> Database theory: Past and future. </title> <booktitle> In Proc. of the ACM Symp. PODS, </booktitle> <year> 1987. </year>
Reference-contexts: Osborn [Osb89] gives some interesting perspectives on the consequences of the polymorphic constructs in object-oriented databases and how this aids in avoiding `code' evolution. Our Perspective: Ullman <ref> [Ull87] </ref> argues for the need for allowing the user to be ignorant about the structure of the database and pose queries to the database with only the knowledge about the attributes (in all relations) of the database.
Reference: [Ull91] <author> Ullman, J.D. </author> <title> A comparison between deductive and object oriented database systems. </title> <booktitle> In Proc. Deductive and Object Oriented Databases Conf., </booktitle> <pages> pages 263-277, </pages> <year> 1991. </year> <editor> [vK76] van Emden, M.H. and Kowalski, R.A. </editor> <title> The semantics of predicate logic as a programming language. </title> <journal> JACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <month> October </month> <year> 1976. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: On the technical side, programming predicates can be easily incorporated in SchemaLog by introducing a separate 7 The reason for the special manner in which the id-component of the head is constructed has to do with declarative programming of ad hoc recursive queries, as motivated by Ullman <ref> [Ull91] </ref>. The details are discussed at length in [LSS93]. 8 This will necessitate two rules one for each argument of the predicate grandpa. set of predicate symbols and then interpreting them "classically".
References-found: 28

