URL: http://www.cs.ucsd.edu/~wgg/Abstracts/wkorman.thesis.ps.gz
Refering-URL: http://www.cs.ucsd.edu/~wgg/papers.html
Root-URL: http://www.cs.ucsd.edu
Title: Elbereth: Tool Support for Refactoring Java Programs  
Author: Walter Fred Korman 
Degree: A thesis submitted in partial satisfaction of the requirements for the degree Master of Science in Computer Science by  Committee in charge: Professor William G. Griswold, Chairperson Professor Jeanne Ferrante Professor Joseph Goguen  
Date: 1998  
Affiliation: UNIVERSITY OF CALIFORNIA, SAN DIEGO  
Abstract-found: 0
Intro-found: 1
Reference: [Berners-Lee et al., 1994] <author> Berners-Lee, T., Masinter, L., and McCahill, M. </author> <year> (1994). </year> <title> Uniform Resource Locators (URL). </title> <type> RFC 1738. </type>
Reference-contexts: This use of inheritance can allow code re-use while maintaining an intuitive, hierarchical structuring of classes representing similarities in functionality. This refactoring was performed on Elbereth to allow inclusion of network-accessible source files specified via Uniform Resource Locators (URLs) <ref> [Berners-Lee et al., 1994] </ref>. The SourceFile class was enhanced by creating a new URLSourceFile class that subclassed the SourceFile class, overriding methods to allow reading source file data over the network instead of directly from a local hard drive (Figure II.15).
Reference: [Bischofberger, 1992] <author> Bischofberger, W. R. </author> <year> (1992). </year> <title> Sniff|A Pragmatic Approach to a C++ Programming Environment. </title> <booktitle> In USENIX C++ Technical Conference Proceedings, </booktitle> <pages> pages 67-81, </pages> <address> Portland, OR. </address>
Reference-contexts: The disadvantage with such tools is that the programmer loses control over the class design and the software may end up with a counterintuitive class structure [Opdyke, 1992] [Casais, 1994]. Other visualization tools such as Rigi and Sniff can be used for planning refactorings [Muller et al., 1992] <ref> [Bischofberger, 1992] </ref>. However, they cannot serve as the user interface for a refactoring tool. For example, the Rigi environment constructs a view based on entities such as functions, files, classes, or modules. This view is then augmented by the programmer.
Reference: [Bowdidge, 1995] <author> Bowdidge, R. W. </author> <year> (1995). </year> <title> Supporting the Restructuring of Data Abstractions through Manipulation of a Program Visualization. </title> <type> PhD thesis, </type> <institution> University of California, San Diego, Department of Computer Science & Engineering. </institution> <note> Technical Report CS95-457. </note>
Reference-contexts: Finally, in planning a complex redesign, it is desirable to have support for recording the designer's many discoveries, thoughts, and refactoring plans. I.B The Star Diagram For programs written in a procedural programming language, this problem has been addressed by a restructuring tool designed around the star diagram visualization <ref> [Bowdidge, 1995] </ref> [Bowdidge and Griswold, 1994]. A star diagram provides a compact, hierarchical, tree-structured visual representation of the source code relating to a particular data structure, eliding code unrelated to the data structure's use and maintenance. Similar code fragments are merged into "node stacks" to reveal potentially redundant computations. <p> Elbereth can serve as the user interface for an interactive restructuring tool like Opdyke's automated refactoring tool [Opdyke, 1992]. Bowdidge's restructuring tool uses the star diagram visualization in an analogous manner to perform automatic restructurings of Scheme programs [Bowdidge and Griswold, 1994] <ref> [Bowdidge, 1995] </ref>. A text-oriented user interface for a star diagram-based interactive restructuring tool allows a programmer to fill in a transformation form with keyboard entry and selections from program text.
Reference: [Bowdidge and Griswold, 1994] <author> Bowdidge, R. W. and Griswold, W. G. </author> <year> (1994). </year> <title> Automated support for encapsulating abstract data types. </title> <booktitle> In ACM SIGSOFT '94 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 97-110. </pages>
Reference-contexts: I.B The Star Diagram For programs written in a procedural programming language, this problem has been addressed by a restructuring tool designed around the star diagram visualization [Bowdidge, 1995] <ref> [Bowdidge and Griswold, 1994] </ref>. A star diagram provides a compact, hierarchical, tree-structured visual representation of the source code relating to a particular data structure, eliding code unrelated to the data structure's use and maintenance. Similar code fragments are merged into "node stacks" to reveal potentially redundant computations. <p> Elbereth can serve as the user interface for an interactive restructuring tool like Opdyke's automated refactoring tool [Opdyke, 1992]. Bowdidge's restructuring tool uses the star diagram visualization in an analogous manner to perform automatic restructurings of Scheme programs <ref> [Bowdidge and Griswold, 1994] </ref> [Bowdidge, 1995]. A text-oriented user interface for a star diagram-based interactive restructuring tool allows a programmer to fill in a transformation form with keyboard entry and selections from program text.
Reference: [Brandt, 1998] <author> Brandt, S. R. </author> <year> (1998). </year> <title> Regular Expressions in Java. </title> <address> http://www.win.net/~stevesoft/pat/. </address>
Reference-contexts: There are a total of 94 classes in the system. Additionally, Elbereth makes use of two third-party libraries; the Acme package for image manipulation [Poskanzer, 1998] and the pat.regex regular expression matching package <ref> [Brandt, 1998] </ref>. Development was done on a Sun UltraSparc 2 with 200 megabytes of RAM. Sun's Java Development Kit 1.0.2 through 1.1.5 was used for compilation and execution.
Reference: [Casais, 1994] <author> Casais, E. </author> <year> (1994). </year> <title> Automatic reorganization of object-oriented hierarchies: A case study. </title> <booktitle> Object Oriented Systems, </booktitle> <volume> 1(2) </volume> <pages> 95-115. </pages>
Reference-contexts: Batch restructuring tools free the programmer from all manual tasks by enforcing specific design requirements upon the software, restructuring as needed without programmer intervention. Examples of such tools include Lieberherr's Demeter System [Lieberherr et al., 1994] and Casais' tool for performing reorganization of class hierarchies <ref> [Casais, 1994] </ref>. The disadvantage with such tools is that the programmer loses control over the class design and the software may end up with a counterintuitive class structure [Opdyke, 1992] [Casais, 1994]. <p> of such tools include Lieberherr's Demeter System [Lieberherr et al., 1994] and Casais' tool for performing reorganization of class hierarchies <ref> [Casais, 1994] </ref>. The disadvantage with such tools is that the programmer loses control over the class design and the software may end up with a counterintuitive class structure [Opdyke, 1992] [Casais, 1994]. Other visualization tools such as Rigi and Sniff can be used for planning refactorings [Muller et al., 1992] [Bischofberger, 1992]. However, they cannot serve as the user interface for a refactoring tool.
Reference: [Gamma et al., 1993] <author> Gamma, E., Helm, R., Johnson, R., and Vlissides, J. </author> <year> (1993). </year> <title> Design patterns: Abstraction and reuse of object-oriented design. </title> <booktitle> Proceedings of ECOOP. </booktitle>
Reference-contexts: The intrinsic difficulty of good object-oriented design in complex systems is emphasized by the growing popularity of design patterns, which can impart experience and design knowledge to software designers <ref> [Gamma et al., 1993] </ref>. Opdyke proposes that refactoring existing class hierarchies can improve their maintainability and reusability [Opdyke, 1992] [Opdyke and Johnson, 1990]. A refactoring activity changes the organization of an object-oriented program without changing its behavior. <p> The code elsewhere in the system to handle file loading was then modified to take advantage of the new subclass by instantiating a URLSourceFile object for filenames specified as URLs, or a SourceFile object otherwise. The Factory design pattern <ref> [Gamma et al., 1993] </ref> was used to create the appropriate kind of SourceFile object. The programmer begins the refactoring by clicking the Class Browser button in the Project window to open the class browser window (Figure II.16).
Reference: [Gosling et al., 1996] <author> Gosling, J., Joy, B., and Steele, G. </author> <year> (1996). </year> <title> The Java Language Specification. </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: To empirically evaluate these claims we have implemented Elbereth [Korman and Griswold, 1998], a tool for exploring, planning, and carrying out refactorings of Java programs <ref> [Gosling et al., 1996] </ref>. Elbereth is based on a restructuring planning tool for C [Griswold et al., 1996] [Griswold, 1997] with enhancements that not only exploit the hierarchical type information provided by classes and inheritance, but also streamline common refac-toring scenarios.
Reference: [Griswold, 1997] <author> Griswold, W. G. </author> <year> (1997). </year> <title> Tool support for planning the restructuring of data abstractions in large systems. </title> <type> Technical report, </type> <institution> University of California, San Diego, Department of Computer Science & Engineering. </institution> <note> Technical Report CS95-457. </note>
Reference-contexts: To empirically evaluate these claims we have implemented Elbereth [Korman and Griswold, 1998], a tool for exploring, planning, and carrying out refactorings of Java programs [Gosling et al., 1996]. Elbereth is based on a restructuring planning tool for C [Griswold et al., 1996] <ref> [Griswold, 1997] </ref> with enhancements that not only exploit the hierarchical type information provided by classes and inheritance, but also streamline common refac-toring scenarios. <p> The star diagram visualization has previously been shown to ease the task of restructuring software written in procedural programming languages such as C and MUMPS <ref> [Griswold, 1997] </ref>. This thesis has shown that the use of Elbereth and the star diagram visualization can aid in refactoring moderately-sized Java programs.
Reference: [Griswold et al., 1996] <author> Griswold, W. G., Chen, M. I., Bowdidge, R. W., and Mor-genthaler, J. D. </author> <year> (1996). </year> <title> Tool support for planning the restructuring of data abstractions in large systems. </title> <booktitle> In ACM SIGSOFT '96 Symposium on the Foundations of Software Engineering. </booktitle> <volume> 45 46 </volume>
Reference-contexts: To empirically evaluate these claims we have implemented Elbereth [Korman and Griswold, 1998], a tool for exploring, planning, and carrying out refactorings of Java programs [Gosling et al., 1996]. Elbereth is based on a restructuring planning tool for C <ref> [Griswold et al., 1996] </ref> [Griswold, 1997] with enhancements that not only exploit the hierarchical type information provided by classes and inheritance, but also streamline common refac-toring scenarios.
Reference: [Korman and Griswold, 1998] <author> Korman, W. and Griswold, W. G. </author> <year> (1998). </year> <note> Elbereth Home Page. http://www-cse.ucsd.edu/users/wkorman/elbereth/. </note>
Reference-contexts: Stacked fragments are frequently candidates for a refactoring such as abstraction into new methods. We hypothesize that these techniques can be extended to take advantage of object-oriented constructs, thereby providing more effective assistance in the maintenance of object-oriented programs. To empirically evaluate these claims we have implemented Elbereth <ref> [Korman and Griswold, 1998] </ref>, a tool for exploring, planning, and carrying out refactorings of Java programs [Gosling et al., 1996]. <p> The actual implementation of Elbereth, publicly available for use by other programmers, is a useful product of this research. The executable Java bytecodes for the tool are posted on the Elbereth home page on 43 the World-Wide Web, along with basic documentation and links to more information <ref> [Korman and Griswold, 1998] </ref>. The Elbereth home page has been visited by over a thousand people since its initial release in December of 1997. We have received comments and incorporated many fixes and additions to the tool based on actual end-user feedback.
Reference: [Lieberherr et al., 1994] <author> Lieberherr, K., Hursch, W., and Xiao, C. </author> <year> (1994). </year> <title> Object-extending class transformations. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6(4) </volume> <pages> 391-416. </pages>
Reference-contexts: Batch restructuring tools free the programmer from all manual tasks by enforcing specific design requirements upon the software, restructuring as needed without programmer intervention. Examples of such tools include Lieberherr's Demeter System <ref> [Lieberherr et al., 1994] </ref> and Casais' tool for performing reorganization of class hierarchies [Casais, 1994]. The disadvantage with such tools is that the programmer loses control over the class design and the software may end up with a counterintuitive class structure [Opdyke, 1992] [Casais, 1994].
Reference: [Muller et al., 1992] <author> Muller, H. A., Tilley, S. R., Orgun, M. A., and Corrie, B. D. </author> <year> (1992). </year> <title> A reverse engineering environment based on spatial and visual software interconnection models. </title> <booktitle> In SIGSOFT '92: Fifth Symposium on Software Development Environments, </booktitle> <pages> pages 88-98. </pages>
Reference-contexts: The disadvantage with such tools is that the programmer loses control over the class design and the software may end up with a counterintuitive class structure [Opdyke, 1992] [Casais, 1994]. Other visualization tools such as Rigi and Sniff can be used for planning refactorings <ref> [Muller et al., 1992] </ref> [Bischofberger, 1992]. However, they cannot serve as the user interface for a refactoring tool. For example, the Rigi environment constructs a view based on entities such as functions, files, classes, or modules. This view is then augmented by the programmer.
Reference: [Opdyke, 1992] <author> Opdyke, W. F. </author> <year> (1992). </year> <title> Refactoring Object-Oriented Frameworks. </title> <type> Ph.D. dissertation, </type> <institution> University of Illinois at Urbana-Champaign. </institution>
Reference-contexts: The intrinsic difficulty of good object-oriented design in complex systems is emphasized by the growing popularity of design patterns, which can impart experience and design knowledge to software designers [Gamma et al., 1993]. Opdyke proposes that refactoring existing class hierarchies can improve their maintainability and reusability <ref> [Opdyke, 1992] </ref> [Opdyke and Johnson, 1990]. A refactoring activity changes the organization of an object-oriented program without changing its behavior. It includes changes such as encapsulating public ref 1 2 erences to member data in a new method or creating abstract superclasses from shared behavior in similar classes. <p> Although Elbereth is not currently integrated with a tool that performs refactorings for the programmer, it could be used as a graphical front-end for an automatic restructuring tool <ref> [Opdyke, 1992] </ref>. Elbereth's implementation consists of approximately 22,000 lines of source code in 82 files. 12,000 of these lines and 11 of the files are code produced by the JavaCC parser generator [SunTest, 1998]. <p> The disadvantage is that the programmer must engage in a great deal of interaction, although the tool may provide composite transformations that can speed the task. Elbereth can serve as the user interface for an interactive restructuring tool like Opdyke's automated refactoring tool <ref> [Opdyke, 1992] </ref>. Bowdidge's restructuring tool uses the star diagram visualization in an analogous manner to perform automatic restructurings of Scheme programs [Bowdidge and Griswold, 1994] [Bowdidge, 1995]. <p> Examples of such tools include Lieberherr's Demeter System [Lieberherr et al., 1994] and Casais' tool for performing reorganization of class hierarchies [Casais, 1994]. The disadvantage with such tools is that the programmer loses control over the class design and the software may end up with a counterintuitive class structure <ref> [Opdyke, 1992] </ref> [Casais, 1994]. Other visualization tools such as Rigi and Sniff can be used for planning refactorings [Muller et al., 1992] [Bischofberger, 1992]. However, they cannot serve as the user interface for a refactoring tool.
Reference: [Opdyke and Johnson, 1990] <author> Opdyke, W. F. and Johnson, R. E. </author> <year> (1990). </year> <title> Refac-toring: An aid in designing application frameworks and evolving object-oriented systems. </title> <booktitle> Symposium on Object-Oriented Programming Emphasizing Practical Applications, </booktitle> <pages> 40(2). </pages>
Reference-contexts: The intrinsic difficulty of good object-oriented design in complex systems is emphasized by the growing popularity of design patterns, which can impart experience and design knowledge to software designers [Gamma et al., 1993]. Opdyke proposes that refactoring existing class hierarchies can improve their maintainability and reusability [Opdyke, 1992] <ref> [Opdyke and Johnson, 1990] </ref>. A refactoring activity changes the organization of an object-oriented program without changing its behavior. It includes changes such as encapsulating public ref 1 2 erences to member data in a new method or creating abstract superclasses from shared behavior in similar classes.
Reference: [Poskanzer, 1998] <author> Poskanzer, J. </author> <year> (1998). </year> <title> ACME Java Software. </title> <address> http://www.acme.com/java/. </address>
Reference-contexts: As mentioned in Chapter II, Elbereth's final implementation consists of approximately 22,000 lines of source code in 82 source files. There are a total of 94 classes in the system. Additionally, Elbereth makes use of two third-party libraries; the Acme package for image manipulation <ref> [Poskanzer, 1998] </ref> and the pat.regex regular expression matching package [Brandt, 1998]. Development was done on a Sun UltraSparc 2 with 200 megabytes of RAM. Sun's Java Development Kit 1.0.2 through 1.1.5 was used for compilation and execution.
Reference: [SunTest, 1998] <institution> SunTest (1998). JavaCC Home Page. </institution> <note> http://www.suntest.com/JavaCC/. </note>
Reference-contexts: Elbereth's implementation consists of approximately 22,000 lines of source code in 82 files. 12,000 of these lines and 11 of the files are code produced by the JavaCC parser generator <ref> [SunTest, 1998] </ref>. Since analysis of the generated files is largely irrelevant from the perspective of software design, we omitted them from our refactoring projects. The resulting source code then consists of 10,000 lines of source and 71 source files. <p> Development was done on a Sun UltraSparc 2 with 200 megabytes of RAM. Sun's Java Development Kit 1.0.2 through 1.1.5 was used for compilation and execution. The JavaCC parser-generator <ref> [SunTest, 1998] </ref> was used to generate the parser and AST Elbereth uses to store and represent Java source code internally.
References-found: 17

