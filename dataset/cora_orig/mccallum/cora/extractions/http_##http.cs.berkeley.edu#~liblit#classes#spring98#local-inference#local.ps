URL: http://http.cs.berkeley.edu/~liblit/classes/spring98/local-inference/local.ps
Refering-URL: http://http.cs.berkeley.edu/~liblit/classes/spring98/local-inference/
Root-URL: 
Title: Local Qualification Inference for Titanium  
Author: Ben Liblit 
Date: May 17, 1998  
Abstract: Titanium is a parallel programming language that presents a single global address space for all concurrent computations. In order to improve performance on distributed-memory architectures, programmers may explicitly qualify selected references as local to a single process. This paper proposes a static inference system for automatically applying "local" qualifications wherever possible, within the constraints of the Titanium type system. A prototype implementation of the analysis has been completed with the help of the BANE analysis toolkit. We describe and evaluate the analysis itself, as well as the implementation strategy by which the analysis has been deployed.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java TM Language Specification. The Java TM Series. </title> <publisher> Addison-Wesley, </publisher> <address> Menlo Park, California, </address> <year> 1996. </year>
Reference-contexts: The reader who is already an experienced Titanium programmer may wish to skip ahead to subsection 2.5, where we highlight problems that remain unsolved by the current Titanium memory model. 2.1 Titanium Basics Titanium uses the syntax and semantics of Java 1 <ref> [1] </ref>, and adds a number of features to support the needs of the scientific computing community. In this paper, we mention only those features pertinent to the analysis at hand; see [5] for a more complete description of the language as a whole.
Reference: [2] <author> Arvind Krishnamurthy. </author> <title> Analyses and optimizations for shared address space programs. </title> <type> Ph.D. qualifying examination talk, </type> <month> November </month> <year> 1995. </year> <month> 9 </month>
Reference-contexts: In table 1, we present times collected on a Thinking Machines CM-5 and partial times collected on a Cray T3D. These findings were originally presented in <ref> [2] </ref> and [4], respectively. The benchmark reveals that the performance cost of using wide references for local data can be profound. Even when the code for reading and writing through wide references is inlined, the CM-5 shows nearly a 75% slowdown compared with simple pointers.
Reference: [3] <author> Carleton Miyamoto and Ben Liblit. Themis: </author> <title> Enforcing titanium consistency on the now. </title> <note> CS262 semester project report. Available from &lt;http://www.cs.berkeley.edu/ ~liblit/classes/fall97/cs262/themis/&gt;, </note> <month> December </month> <year> 1997. </year>
Reference: [4] <author> Kathy Yelick, David Culler, and Jim Demmel. </author> <title> Programming support for clusters of multiprocessors (clumps). </title> <institution> Talk presented at Lawrence Livermore National Laboratories, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: In table 1, we present times collected on a Thinking Machines CM-5 and partial times collected on a Cray T3D. These findings were originally presented in [2] and <ref> [4] </ref>, respectively. The benchmark reveals that the performance cost of using wide references for local data can be profound. Even when the code for reading and writing through wide references is inlined, the CM-5 shows nearly a 75% slowdown compared with simple pointers.
Reference: [5] <author> Kathy Yelick, Geoff Pike, Carleton Miyamoto, Ben Liblit, Arvind Krishnamurthy, Paul Hilfinger, Susan Graham, David Gay, Phil Colella, and Alex Aiken. Titanium: </author> <title> a high-performance java dialect. </title> <booktitle> In ACM Workshop on Java for High-Performance Network Computing, </booktitle> <address> Stanford, California, </address> <month> February </month> <year> 1998. </year> <institution> Association for Computing Machinery. </institution> <month> 10 </month>
Reference-contexts: In this paper, we mention only those features pertinent to the analysis at hand; see <ref> [5] </ref> for a more complete description of the language as a whole. Two notable Java features are absent from Titanium. First, Titanium has no bytecodes or virtual machine. Titanium programs are compiled to native code and executed directly on the host system.
References-found: 5

