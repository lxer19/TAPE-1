URL: http://www.cs.brown.edu/courses/cs227/papers/b2/disjunct.ps
Refering-URL: http://www.cs.brown.edu/courses/cs227/readinglist.html
Root-URL: http://www.cs.brown.edu/
Email: hlastnamei@db.fmi.uni-passau.de moer@ira.uka.de  
Title: Optimizing Disjunctive Queries with Expensive Predicates  
Author: A. Kemper G. Moerkotte K. Peithner M. Steinbrunn 
Address: 94030 Passau, Germany 76128 Karlsruhe, Germany  
Affiliation: Universitat Passau Universitat Karlsruhe Fakultat fur Mathematik und Informatik Fakultat fur Informatik  
Abstract: In this work, we propose and assess a technique called bypass processing for optimizing the evaluation of disjunctive queries with expensive predicates. The technique is particularly useful for optimizing selection predicates that contain terms whose evaluation costs vary tremendously; e.g., the evaluation of a nested subquery or the invocation of a user-defined function in an object-oriented or extended relational model may be orders of magnitude more expensive than an attribute access (and comparison). The idea of bypass processing consists of avoiding the evaluation of such expensive terms whenever the outcome of the entire selection predicate can already be induced by testing other, less expensive terms. In order to validate the viability of bypass evaluation, we extend a previously developed optimizer architecture and incorporate three alternative optimization algorithms for generating bypass processing plans. 
Abstract-found: 1
Intro-found: 1
Reference: [Bat86] <author> D. S. Batory. </author> <title> Extensible cost models and query optimization in GENESIS. </title> <journal> IEEE Database Engineering, </journal> <volume> 9(4), </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: One particularly important aspect is the optimization and efficient processing of declarative queries. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context [OS90, KM90, CD92]. Many researchers have worked on optimizer architectures that facilitate flexibility: <ref> [GD87, Bat86, BMG93, GM93] </ref> are proposals for optimizer generators; [BG92, HFLP89] described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases. fl This work was supported by the German Research Council under contracts DFG Ke 401/6-1 and SFB 346. [HS93] pointed out
Reference: [BG92] <author> L. Becker and R. H. Guting. </author> <title> Rule-based optimization and query processing in an extensible geometric database system. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 17(2) </volume> <pages> 247-303, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Many researchers have worked on optimizer architectures that facilitate flexibility: [GD87, Bat86, BMG93, GM93] are proposals for optimizer generators; <ref> [BG92, HFLP89] </ref> described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases. fl This work was supported by the German Research Council under contracts DFG Ke 401/6-1 and SFB 346. [HS93] pointed out that the ordering of the selection predicate evaluation is
Reference: [BMG93] <author> J. A. Blakeley, W. J. McKenna, and G. Graefe. </author> <title> Experiences building the Open OODB Query Optimizer. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 287-295, </pages> <address> Washington, DC, USA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: One particularly important aspect is the optimization and efficient processing of declarative queries. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context [OS90, KM90, CD92]. Many researchers have worked on optimizer architectures that facilitate flexibility: <ref> [GD87, Bat86, BMG93, GM93] </ref> are proposals for optimizer generators; [BG92, HFLP89] described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases. fl This work was supported by the German Research Council under contracts DFG Ke 401/6-1 and SFB 346. [HS93] pointed out <p> The complete set of operators in our algebra also contains a join, an unnest, a projection, and a set difference operator. The function invocations and the attribute accesses are generalized to expansions |an operator similar to the materialize operator as proposed in <ref> [BMG93] </ref>. The simplification step decomposes the query into its building blocks, and enriches them with statistical data, called basic values. For the purpose of the paper, we are mainly interested in selectivities and evaluation costs for function invocations.
Reference: [CD92] <author> S. Cluet and C. Delobel. </author> <title> A general framework for the optimization of object-oriented queries. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 383-392, </pages> <address> San Diego, USA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction During the past few years we have witnessed tremendous efforts in optimizing "next-generation" database systems|see, e.g., [FMV93]. One particularly important aspect is the optimization and efficient processing of declarative queries. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context <ref> [OS90, KM90, CD92] </ref>. <p> QEPs are composed from basic building blocks [Loh88] which are, step by step, augmented to complete evaluation plans. This building block approach|also used for global query optimization [Sel86]|incorporates the factorization of common subexpressions (cf. <ref> [CD92] </ref>) and the early pruning of non-promising alternatives. Local optimization algorithms (in our terminology called knowledge sources) are associated with the regions and carry out the augmentation of the (still incomplete) QEPs until, at the top-most region, complete QEPs are generated.
Reference: [FMV93] <author> J.-C. Freytag, D. Maier, and G. Vossen, </author> <title> editors. Query Processing for Advanced Applications. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, USA, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction During the past few years we have witnessed tremendous efforts in optimizing "next-generation" database systems|see, e.g., <ref> [FMV93] </ref>. One particularly important aspect is the optimization and efficient processing of declarative queries. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context [OS90, KM90, CD92].
Reference: [Fre87] <author> J.-C. Freytag. </author> <title> A rule-based view of query optimization. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 173-180, </pages> <address> San Francisco, USA, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction During the past few years we have witnessed tremendous efforts in optimizing "next-generation" database systems|see, e.g., [FMV93]. One particularly important aspect is the optimization and efficient processing of declarative queries. <ref> [Fre87, GD87, Loh88] </ref> made rule-based query optimization popular, which was later adopted in the object-oriented context [OS90, KM90, CD92].
Reference: [GD87] <author> G. Graefe and D. J. DeWitt. </author> <title> The EXODUS optimizer generator. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 160-172, </pages> <address> San Francisco, USA, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction During the past few years we have witnessed tremendous efforts in optimizing "next-generation" database systems|see, e.g., [FMV93]. One particularly important aspect is the optimization and efficient processing of declarative queries. <ref> [Fre87, GD87, Loh88] </ref> made rule-based query optimization popular, which was later adopted in the object-oriented context [OS90, KM90, CD92]. <p> One particularly important aspect is the optimization and efficient processing of declarative queries. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context [OS90, KM90, CD92]. Many researchers have worked on optimizer architectures that facilitate flexibility: <ref> [GD87, Bat86, BMG93, GM93] </ref> are proposals for optimizer generators; [BG92, HFLP89] described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases. fl This work was supported by the German Research Council under contracts DFG Ke 401/6-1 and SFB 346. [HS93] pointed out <p> Each knowledge source is allowed to restrict its search space and to use its own search strategy as it is also suggested by [LV91]. The (global) optimization process is controlled by A* search [Pea84], which advances the alternative which has the least expected cost. In contrast to the approaches <ref> [GD87, GM93] </ref>, where an expected cost factor is assigned to the transformation rules, the Flight total transit time () (1; fl) H H legs (0; fl) Connection departure arrival (1; 1) H H from (0; fl) H H to Airportlocation name timezone building block approach allows us to derive the expected
Reference: [GM93] <author> G. Graefe and W. J. McKenna. </author> <title> The Volcano optimizer generator: Extensibility and efficient search. </title> <booktitle> In Proc. IEEE Conf. on Data Engineering, </booktitle> <pages> pages 209-218, </pages> <address> Wien, Austria, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: One particularly important aspect is the optimization and efficient processing of declarative queries. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context [OS90, KM90, CD92]. Many researchers have worked on optimizer architectures that facilitate flexibility: <ref> [GD87, Bat86, BMG93, GM93] </ref> are proposals for optimizer generators; [BG92, HFLP89] described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases. fl This work was supported by the German Research Council under contracts DFG Ke 401/6-1 and SFB 346. [HS93] pointed out <p> Each knowledge source is allowed to restrict its search space and to use its own search strategy as it is also suggested by [LV91]. The (global) optimization process is controlled by A* search [Pea84], which advances the alternative which has the least expected cost. In contrast to the approaches <ref> [GD87, GM93] </ref>, where an expected cost factor is assigned to the transformation rules, the Flight total transit time () (1; fl) H H legs (0; fl) Connection departure arrival (1; 1) H H from (0; fl) H H to Airportlocation name timezone building block approach allows us to derive the expected
Reference: [Han77] <author> M. Z. Hanani. </author> <title> An optimal evaluation of boolean expressions in an online query system. </title> <journal> Communications of the ACM, </journal> <volume> 20 </volume> <pages> 344-347, </pages> <month> May </month> <year> 1977. </year>
Reference-contexts: If P time 's evaluation results are not saved, the sorting of Boolean factors and conditions within Boolean factors as in plan 3b is the optimum (cf. <ref> [Han77] </ref>). <p> The advantage compared to the DNF-based plan is not only the lower evaluation cost average, but also the avoidance of a duplicate-eliminating union operation. Furthermore, the optimal ordering of Boolean factors and conditions within a Boolean factor can be determined efficiently <ref> [Han77] </ref>. Objects that are not elements of the result set can be eliminated early, namely as soon as one Boolean factor evaluates to "false." However, for elements of the result set, it may be necessary to evaluate certain conditions repeatedly.
Reference: [HFLP89] <author> L. M. Haas, J. C. Freytag, G. M. Lohman, and H. Pirahesh. </author> <title> Extensible query processing in starburst. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 377-388, </pages> <address> Portland, Or, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Many researchers have worked on optimizer architectures that facilitate flexibility: [GD87, Bat86, BMG93, GM93] are proposals for optimizer generators; <ref> [BG92, HFLP89] </ref> described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases. fl This work was supported by the German Research Council under contracts DFG Ke 401/6-1 and SFB 346. [HS93] pointed out that the ordering of the selection predicate evaluation is
Reference: [HS93] <author> J. M. Hellerstein and M. Stonebraker. </author> <title> Predicate migration: Optimizing queries with expensive predicates. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 267-276, </pages> <address> Washington, DC, USA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: facilitate flexibility: [GD87, Bat86, BMG93, GM93] are proposals for optimizer generators; [BG92, HFLP89] described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases. fl This work was supported by the German Research Council under contracts DFG Ke 401/6-1 and SFB 346. <ref> [HS93] </ref> pointed out that the ordering of the selection predicate evaluation is particularly important in the presence of expensive conditions. These may occur in relational systems in the form of nested subqueries or in extended relational and object-oriented systems in the form of user-defined functions. [HS93]'s work is based on ordering <p> However, if a cache for P time 's evaluation results is available as proposed in <ref> [HS93] </ref>, plan 3c is the optimum, and the cost can|at best|be reduced to an average per object of c (P length ) + c (P time ) + s (P length ) (1 s (P time )) c (P tz ) = 45:16 if zero lookup and maintenance cost for cached <p> The proposed technique|called bypass processing|is particularly advantageous when the evaluation costs of the conditions dominate the query processing costs. As pointed out in <ref> [HS93] </ref>, such expensive conditions may occur in object-oriented as well as in (extended and pure) relational systems. The bypass technique tries to derive the outcome of the selection predicate without evaluating such expensive conditions whenever possible.
Reference: [JK84] <author> M. Jarke and J. Koch. </author> <title> Query optimization in database systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 16(2) </volume> <pages> 111-152, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: Another proposed technique (e.g., <ref> [OS90, JK84] </ref>) of evaluating disjunctive selection predicates consists of transforming the predicate into disjunctive normal form (DNF). Then, the or 's are usually transformed into a multiway union, and each resulting stream is optimized as usual. This approach facilitates parallel processing. <p> For the example query, these figures are given in Table 1. Let us now contrast the bypass technique with evaluation plans based on transforming the selection predicate into the disjunctive normal form (DNF) or the conjunctive normal form (CNF) <ref> [JK84] </ref>.
Reference: [KM90] <author> A. Kemper and G. Moerkotte. </author> <title> Advanced query processing in object bases using access support relations. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 290-301, </pages> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: 1 Introduction During the past few years we have witnessed tremendous efforts in optimizing "next-generation" database systems|see, e.g., [FMV93]. One particularly important aspect is the optimization and efficient processing of declarative queries. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context <ref> [OS90, KM90, CD92] </ref>.
Reference: [KM93] <author> A. Kemper and G. Moerkotte. </author> <title> Query optimization in object bases: Exploiting the relational techniques. </title> <booktitle> In [FMV93]. </booktitle>
Reference: [KM94] <author> A. Kemper and G. Moerkotte. </author> <title> Object-Oriented Database Management: </title> <booktitle> Applications in Engineering and Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, USA, </address> <year> 1994. </year>
Reference-contexts: These can be characterized as eastward journeys spanning more than three time zones and consisting of more than three connections or with a total transit time (sum of all the times the passenger spends waiting in transit) of more than four hours. In the query language GOMql <ref> [KM94] </ref>, this query can be expressed as in Figure 2, where the total transit time is computed by the function total transit time () associated with the type Flight. 2 range f: Flight retrieve f where f:legs:last ():to:timezone f:legs:first ():from:timezone 3 and f:legs:length () 3 or f:total transit time () 4
Reference: [KMP93] <author> A. Kemper, G. Moerkotte, and K. Peithner. </author> <title> A blackboard architecture for query optimization in object bases. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 543-554, </pages> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Many researchers have worked on optimizer architectures that facilitate flexibility: [GD87, Bat86, BMG93, GM93] are proposals for optimizer generators; [BG92, HFLP89] described extensible optimizers in the extended relational context; <ref> [MDZ93, KMP93] </ref> proposed architectural frameworks for query optimization in object bases. fl This work was supported by the German Research Council under contracts DFG Ke 401/6-1 and SFB 346. [HS93] pointed out that the ordering of the selection predicate evaluation is particularly important in the presence of expensive conditions. <p> In order to verify the viability of the approach, we developed an optimizer for generating query evaluation plans for bypass processing. This optimizer is an instantiation of our previously developed architectural framework for object-oriented query optimization <ref> [KMP93] </ref>. This architecture is centered around a blackboard structure divided into regions|an idea also proposed by [MDZ93]|which contain incomplete query evaluation plans (QEPs). QEPs are composed from basic building blocks [Loh88] which are, step by step, augmented to complete evaluation plans. <p> During the rest of the paper, we will consider several strategies to find optimized bypass plans and compare their performance in terms of the costs of their generated evaluation plans and their (optimization) running times. 3 Optimization Framework In <ref> [KMP93] </ref>, a (generic) architectural framework for query optimization was introduced. This framework is based on a blackboard architecture which achieves desirable characteristics of a query optimizer as extensibility, adaptability, and evolutionary improvement. Especially, the integration of new optimization techniques 4 can be carried out with acceptable effort. <p> To simplify this discussion, only one alternative anchor set, namely f% f=#0 (oid (Flight ))g, is considered|the "real" optimizer has to consider alternative anchor sets to exploit index structures <ref> [KMP93] </ref>. This anchor set creates a new temporary relation with one column, called f , scans the extension of Flight, and associates the object identifiers (OIDs) with the attribute f . In total, the decomposition of the example query contains ten expansions and three selections. <p> Region 0 Region 1 Region 2 Region 3 A* Random BDC intro intro + - p regions knowledge sources 3.3 Blackboard Architecture The composition process is reflected by a blackboard architecture which is an instantiation of our generic blackboard framework <ref> [KMP93] </ref>. As sketched in Figure 4, the blackboard for this presentation consists of four regions between which the query evaluation plans are composed step by step. Each region symbolizes one state of the optimization process where the alternatives|called items|are temporarily maintained.
Reference: [KMS92] <author> A. Kemper, G. Moerkotte, and M. Steinbrunn. </author> <title> Optimizing Boolean expressions in object bases. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 79-90, </pages> <address> Vancouver, B.C., Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: For purpose of comparison, we devised four alternative knowledge sources|three of which generate QEPs for bypass processing and one for DNF-based processing. In one of these knowledge sources we apply a formerly developed heuristic based on the Boolean Difference Calculus <ref> [KMS92] </ref>, which ranks conditions on the basis of their evaluation cost and their significance for obtaining the predicates' outcome. In Section 2 the idea of bypass evaluation is illuminated on an illustrative example. In comparison to conventional selection processing, the advantages of bypass processing are shown. <p> The algorithm for constructing the evaluation plan reads as follows (cf. <ref> [KMS92] </ref>): 1. Compute the weights w x i for all conditions x i in the predicate f . 2. <p> A*: This algorithm basically covers the entire solution space and directs its search by A*. 2. BDC: A heuristic that was originally developed for finding near-optimal decision trees for Boolean predicates <ref> [KMS92] </ref>. 3. Random: A random construction of bypass eval uation plans. * DNF: An algorithm starting with the disjunctive normal form of the selection predicate and producing a DNF-based query evaluation plan. On a set of automatically-generated queries based upon a "real" schema we quantified the performance gains.
Reference: [Loh88] <author> G. M. Lohman. </author> <title> Grammar-like functional rules for representing query optimization alternatives. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 18-27, </pages> <address> Chicago, USA, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction During the past few years we have witnessed tremendous efforts in optimizing "next-generation" database systems|see, e.g., [FMV93]. One particularly important aspect is the optimization and efficient processing of declarative queries. <ref> [Fre87, GD87, Loh88] </ref> made rule-based query optimization popular, which was later adopted in the object-oriented context [OS90, KM90, CD92]. <p> This optimizer is an instantiation of our previously developed architectural framework for object-oriented query optimization [KMP93]. This architecture is centered around a blackboard structure divided into regions|an idea also proposed by [MDZ93]|which contain incomplete query evaluation plans (QEPs). QEPs are composed from basic building blocks <ref> [Loh88] </ref> which are, step by step, augmented to complete evaluation plans. This building block approach|also used for global query optimization [Sel86]|incorporates the factorization of common subexpressions (cf. [CD92]) and the early pruning of non-promising alternatives. <p> Especially, the integration of new optimization techniques 4 can be carried out with acceptable effort. This allows us to test several algorithms for optimizing selection predicates for the bypass processing technique. The blackboard query optimizer is based on a building block approach <ref> [Loh88] </ref>. The entire query is decomposed into building blocks, and alternative query evaluation plans are obtained by composing these blocks. The former|usually called simplification|normalizes and reduces the query to a set of atomic building blocks.
Reference: [LV91] <author> R. S. G. Lanzelotte and P. Valduriez. </author> <title> Extending the search strategy in a query optimizer. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 363-373, </pages> <address> Barcelona, Spain, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: Each knowledge source is allowed to restrict its search space and to use its own search strategy as it is also suggested by <ref> [LV91] </ref>. The (global) optimization process is controlled by A* search [Pea84], which advances the alternative which has the least expected cost.
Reference: [MDZ93] <author> G. Mitchell, U. Dayal, and S. B. Zdonik. </author> <title> Control of an extensible query optimizer: A planning-based approach. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 517-528, </pages> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Many researchers have worked on optimizer architectures that facilitate flexibility: [GD87, Bat86, BMG93, GM93] are proposals for optimizer generators; [BG92, HFLP89] described extensible optimizers in the extended relational context; <ref> [MDZ93, KMP93] </ref> proposed architectural frameworks for query optimization in object bases. fl This work was supported by the German Research Council under contracts DFG Ke 401/6-1 and SFB 346. [HS93] pointed out that the ordering of the selection predicate evaluation is particularly important in the presence of expensive conditions.
Reference: [MS79] <author> C. Monma and J. Sidney. </author> <title> Sequencing with series-parallel precedence constraints. </title> <journal> Math. Oper. Res., </journal> <volume> 4 </volume> <pages> 215-224, </pages> <year> 1979. </year>
Reference-contexts: This approach yields the optimal evaluation sequence for (purely) conjunctive selection predicates <ref> [MS79] </ref>. An obvious extension towards predicates containing disjunctions is to convert the entire selection predicate into conjunctive normal form (CNF) and apply the sorting on the resulting Boolean factors [SAC + 79]. Furthermore, the disjuncts within one Boolean factor could be ordered according to selectivity and evaluation cost.
Reference: [OS90] <author> M. T. Ozsu and D. D. Straube. </author> <title> Queries and query processing in object-oriented database systems. </title> <journal> ACM Trans. Office Inf. Syst., </journal> <volume> 8(4) </volume> <pages> 387-430, </pages> <address> Oc-tober 90. </address>
Reference-contexts: 1 Introduction During the past few years we have witnessed tremendous efforts in optimizing "next-generation" database systems|see, e.g., [FMV93]. One particularly important aspect is the optimization and efficient processing of declarative queries. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context <ref> [OS90, KM90, CD92] </ref>. <p> Another proposed technique (e.g., <ref> [OS90, JK84] </ref>) of evaluating disjunctive selection predicates consists of transforming the predicate into disjunctive normal form (DNF). Then, the or 's are usually transformed into a multiway union, and each resulting stream is optimized as usual. This approach facilitates parallel processing.
Reference: [Pea84] <author> J. Pearl. </author> <title> Heuristics. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1984. </year>
Reference-contexts: Each knowledge source is allowed to restrict its search space and to use its own search strategy as it is also suggested by [LV91]. The (global) optimization process is controlled by A* search <ref> [Pea84] </ref>, which advances the alternative which has the least expected cost.
Reference: [SAC + 79] <author> P. G. Selinger, M. M. Astrahan, D. D. Chamber-lin, R. A. Lorie, and T. G. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 23-34, </pages> <address> Boston, USA, </address> <month> June </month> <year> 1979. </year>
Reference-contexts: This approach yields the optimal evaluation sequence for (purely) conjunctive selection predicates [MS79]. An obvious extension towards predicates containing disjunctions is to convert the entire selection predicate into conjunctive normal form (CNF) and apply the sorting on the resulting Boolean factors <ref> [SAC + 79] </ref>. Furthermore, the disjuncts within one Boolean factor could be ordered according to selectivity and evaluation cost. <p> The second approach, based on the conjunctive normal form, avoids the costly elimination of duplicates. Two possible CNF-based plans for the example predicate are depicted in Figure 3b and 3c. An object moves on to the next stage (i.e., the next "Boolean factor," cf. <ref> [SAC + 79] </ref>) as soon as it is certain that it qualifies. For instance, if an object does not pass P length , P time is evaluated.
Reference: [Sel86] <author> T. K. Sellis. </author> <title> Global query optimization. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 191-205, </pages> <address> Washington, USA, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: The optimization process is controlled by the global search strategy A* [Pea84]|also used for global query optimization <ref> [Sel86] </ref>. For that, history and future costs derived from the state of the composition are assigned to each item. The current expressions determine the history, and the remaining operations|called future work |the future costs.
Reference: [SMK93] <author> M. Steinbrunn, G. Moerkotte, and A. Kemper. </author> <title> Optimizing join orders. </title> <type> Technical report MIP-9307, </type> <institution> Universitat Passau, 94030 Passau, Ger-many, </institution> <year> 1993. </year> <month> 12 </month>
Reference-contexts: This instantiation of the generic blackboard framework can easily be extended by further optimization heuristics, as e.g., the determination of a good join 6 order (cf. <ref> [SMK93] </ref>), if some more regions with the ap-propriate knowledge sources are integrated into the iteration. The optimization process is controlled by the global search strategy A* [Pea84]|also used for global query optimization [Sel86]. <p> However, the BDC strategy is a specialized knowledge source that cannot be applied, for instance, to queries containing join operations| this requires an appropriate generalization, such as described in <ref> [SMK93] </ref>. 6 Conclusion In this paper we addressed the problem of optimizing the evaluation of disjunctive queries. The proposed technique|called bypass processing|is particularly advantageous when the evaluation costs of the conditions dominate the query processing costs. <p> We are currently working on augmenting the BDC heuristic in order to cover arbitrary relational algebra operators, such as the join <ref> [SMK93] </ref>. Acknowledgements We thank Barbara Hartmann for implementing the query generator and for carrying out the benchmarks. We gratefully acknowledge Guy Lohman's constructive help in revising the paper. 11
References-found: 26

