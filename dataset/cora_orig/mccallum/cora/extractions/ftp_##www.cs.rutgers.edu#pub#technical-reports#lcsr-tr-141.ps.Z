URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-141.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Title: Static Infinite Wait Anomaly Detection in Polynomial Time  
Author: Stephen P. Masticola Barbara G. Ryder 
Keyword: synchronization anomalies, Ada, deadlocks, static analysis, parallel programming  
Affiliation: Department of Computer Science Rutgers University  
Abstract: Infinite wait anomalies associated with a barrier rendezvous model (e.g., Ada) can be divided into two classes: stalls and deadlocks. Although precise static deadlock detection is NP-hard, we present two polynomial time algorithms which operate on a statically derivable program representation, the sync graph, to certify a useful class of programs free of deadlocks. We identify three conditions local to any deadlocked tasks, and a fourth global condition on all tasks, which must occur in the sync graph of any program which can deadlock. Again, exact checking of the local conditions is NP-hard; the algorithms check them using conservative approximations. Certifying stall freedom is intractable for programs with conditional branching, including loops. We give program transforms which may help alleviate this difficulty. 
Abstract-found: 1
Intro-found: 1
Reference: [Apt83] <author> Apt, K. R. </author> <title> "A static analysis of CSP programs." </title> <booktitle> Lecture Notes in Computer Science #164 Logics of Programs (Proceedings, </booktitle> <publisher> 1983) Springer-Verlag, </publisher> <pages> pp. 1-17. </pages>
Reference-contexts: McDowell [McDo89] builds a reduced concurrency history graph structure by aggregating related concurrency history states into "clans"; the resulting graph may still exceed polynomial size in the worst case. Work specifically concerning static deadlock detection in parallel programs dates to [Saxe77] for semaphore-based communication and <ref> [Apt83] </ref> for CSP. More recently, Murata et.al. [MSS89] proposed a method for Ada deadlock detection based 7 For clarity in the example, the expression argument of the signal statement is a variable with the same name as the variable parameter of the accept statement.
Reference: [ADWR86] <author> Avrunin, G.S., Dillon, L. K., Wileden, J. C., and Riddle, W. E. </author> <title> "Constrained expressions: adding analysis capabilities to design methods for concurrent software systems." </title> <journal> IEEE Trans. on Software Eng., </journal> <month> February </month> <year> 1986, </year> <pages> 278-291. </pages>
Reference-contexts: Of particular relevance to this research is the work of Callahan and Subhlok [CS88], who present an O (jstatementsj 3 ) lattice algorithm for conservative approximation of race anomalies under a slightly different model of rendezvous than the one used here. Avrunin et. al. <ref> [ADWR86] </ref> propose a representation of possible rendezvous sequences based upon "constrained ex pressions", formalized as regular grammars with additional nonregular constraints. Programs are proven deadlock-free by proving that they do not generate rendezvous sequences which lead to deadlock. Dillon [Dill90] presents another interesting technique based on semiautomatic proofs of correctness.
Reference: [CS88] <author> Callahan, D. and Subhlok, J. </author> <title> "Static analysis of low-level synchronization." </title> <booktitle> SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <year> 1988, </year> <pages> 100-111. </pages>
Reference-contexts: pair of nodes in D are such that one must always finish executing before the other starts 3 . (If the nodes in D were sequenceable, then they could not simultaneously be in the execution wave.) (b) All nodes in D are co-executable in the sense of Callahan and Subhlok <ref> [CS88] </ref>; that is, all the nodes in D may be executed in the same run of the program. 4. When the nodes of D are executing simultaneously, this must not imply that a node which can rendezvous with a member of D is also executing with them. <p> It is possible to derive a subset of the node orderings directly from the sync graph; we might use a data flow framework based on the following two rules, similar to the SCP reserved (k) lattice of Callahan and Subhlok <ref> [CS88] </ref>. 1. If r dominates s in the control flow graph of their task, then r must precede s. 2. If there is a node r such that for all sync edges fr; sg, s precedes some node t, then r must precede t. <p> Thus, the problem of expression unification is eliminated. 6 Related work. Much of the research on static analysis of rendezvousing tasks has focused on detection of race conditions [EP88]. Of particular relevance to this research is the work of Callahan and Subhlok <ref> [CS88] </ref>, who present an O (jstatementsj 3 ) lattice algorithm for conservative approximation of race anomalies under a slightly different model of rendezvous than the one used here.
Reference: [Dill90] <author> Dillon, L. K. </author> <title> "Verifying general safety properties of Ada tasking programs." </title> <journal> IEEE Trans. on Software Eng., </journal> <month> January </month> <year> 1990, </year> <pages> 51-63. </pages>
Reference-contexts: Avrunin et. al. [ADWR86] propose a representation of possible rendezvous sequences based upon "constrained ex pressions", formalized as regular grammars with additional nonregular constraints. Programs are proven deadlock-free by proving that they do not generate rendezvous sequences which lead to deadlock. Dillon <ref> [Dill90] </ref> presents another interesting technique based on semiautomatic proofs of correctness. Her model represents programs as forests of "symbolic execution trees"; freedom from deadlock is proven by proving a set of assertions that deadlocked execution waves are infeasible. Neither paper claims tractability or full automation of the proof algorithm.
Reference: [EP88] <author> Emrath, P. A. and Padua, D. A. </author> <title> "Automatic detection of nondeterminacy in parallel programs." </title> <booktitle> SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <year> 1988, </year> <pages> 89-99. </pages>
Reference-contexts: Encapsulated expressions could be communicated between tasks, but their values could never be changed. Thus, the problem of expression unification is eliminated. 6 Related work. Much of the research on static analysis of rendezvousing tasks has focused on detection of race conditions <ref> [EP88] </ref>. Of particular relevance to this research is the work of Callahan and Subhlok [CS88], who present an O (jstatementsj 3 ) lattice algorithm for conservative approximation of race anomalies under a slightly different model of rendezvous than the one used here.
Reference: [CD73] <author> Coffman, E. O. and Denning, P. J. </author> <title> Operating systems theory. Static Infinite Wait Anomaly Detection in Polynomial Time 18 Prentice-Hall, </title> <year> 1973. </year>
Reference-contexts: A program consisting solely of straight-line code can deadlock only if it has a feasible execution wave such that some subset of nodes in the wave are coupled in a cycle. This result is not in itself novel <ref> [CD73] </ref>; our approach is to refine an approximation to feasible execution waves and use that as a basis for cycle detection. We require that the refined algorithm execute in low-order polynomial time.
Reference: [Hech77] <author> Hecht, M. S. </author> <title> "Flow analysis of computer programs." </title> <publisher> Elsevier North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: Initial results on stall detection and avoidance also are presented. As is common in static analysis, we assume that all control flow paths in a program are executable and that the control flow graph of a procedure is reducible, i.e., each loop has only one entry point <ref> [Hech77] </ref>. Both deadlock detection algorithms are safe in that if an anomaly is possible, they will report this possibility; however, sometimes they will report anomalous situations when none can actually occur.
Reference: [Knut71] <author> Knuth, D. E. </author> <title> "An empirical study of FORTRAN programs." </title> <journal> Software Practice and Experience 1, </journal> <year> 1971, </year> <pages> 105-133. </pages>
Reference-contexts: Loops are not frequently nested to great depth in actual programs, so the size of T (P ) should not grow explosively with the size of P except in pathological cases <ref> [Knut71] </ref>. 4 Refined algorithm. Unfortunately, if we attempt to detect deadlocks using constraint 1 alone, we will incorrectly diagnose too many deadlocks in programs which do not actually deadlock.
Reference: [LC89] <author> Long, D. L. and Clarke, L. A. </author> <title> "Task interaction graphs for concurrency analysis." </title> <booktitle> Eleventh International Conf. on Software Engineering, </booktitle> <year> 1989, </year> <pages> 44-52. </pages>
Reference-contexts: Thus, the number of concurrency states is greater than the product of the numbers of rendezvous nodes in each task. Later work by Young and Taylor [YT88] apply information gathered during symbolic execution to rule out infeasible concurrency states. Long and Clarke <ref> [LC89] </ref> propose a similar task interaction concurrency graph representation, and cite empirical evidence of a linear reduction in the number of states with respect to the concurrency state graph.
Reference: [McDo89] <author> McDowell, C. E. </author> <title> "A practical algorithm for static analysis of parallel programs." </title> <journal> Journal of Parallel and Distributed Computing 6, </journal> <year> 1989, </year> <pages> 515-536. </pages>
Reference-contexts: Long and Clarke [LC89] propose a similar task interaction concurrency graph representation, and cite empirical evidence of a linear reduction in the number of states with respect to the concurrency state graph. McDowell <ref> [McDo89] </ref> builds a reduced concurrency history graph structure by aggregating related concurrency history states into "clans"; the resulting graph may still exceed polynomial size in the worst case. Work specifically concerning static deadlock detection in parallel programs dates to [Saxe77] for semaphore-based communication and [Apt83] for CSP.
Reference: [MR90] <author> Masticola, S. P. and Ryder, B. G. </author> <title> "Static infinite wait anomaly detection in polynomial time." </title> <institution> LCSR-TR-141, Laboratory for Computer Science Research, Rutgers University, </institution> <year> 1990. </year>
Reference-contexts: Finding whether there are deadlocks satisfying constraints 1 and 2, or 1 and 3a, is NP-hard; proofs presented in <ref> [MR90] </ref> are based on 3-satisfiability. Our second deadlock detection algorithm is a refinement of the first, and eliminates some spurious deadlocks using an approximation of constrains 2 and 3a, but at an increase in cost. We have outlined modifications which further increase precision at the cost of additional execution time.
Reference: [MSS89] <author> Murata, T., Shenker, B., and Shatz, S. M. </author> <title> "Detection of Ada static deadlocks using Petri net invariants." </title> <journal> IEEE Trans. on Software Eng., </journal> <month> March </month> <year> 1989, </year> <pages> 314-326. </pages>
Reference-contexts: Work specifically concerning static deadlock detection in parallel programs dates to [Saxe77] for semaphore-based communication and [Apt83] for CSP. More recently, Murata et.al. <ref> [MSS89] </ref> proposed a method for Ada deadlock detection based 7 For clarity in the example, the expression argument of the signal statement is a variable with the same name as the variable parameter of the accept statement. This need not generally be the case. <p> This need not generally be the case. Static Infinite Wait Anomaly Detection in Polynomial Time 17 on a Petri-net representation of possible rendezvous. Although the authors of <ref> [MSS89] </ref> do not provide complexity analysis, the execution time of their "inconsistency" deadlock detection algorithm is clearly proportional to the size of the powerset of rendezvous statements in the program. 7 Conclusions. We have shown here that all infinite-wait anomalies can be divided into deadlocks and stalls.
Reference: [Saxe77] <author> Saxena, A. </author> <title> "Static detection of deadlocks." </title> <institution> CU-CS-122-77, Dept. of Computer Science, University of Colorado at Boulder, </institution> <year> 1977. </year>
Reference-contexts: McDowell [McDo89] builds a reduced concurrency history graph structure by aggregating related concurrency history states into "clans"; the resulting graph may still exceed polynomial size in the worst case. Work specifically concerning static deadlock detection in parallel programs dates to <ref> [Saxe77] </ref> for semaphore-based communication and [Apt83] for CSP. More recently, Murata et.al. [MSS89] proposed a method for Ada deadlock detection based 7 For clarity in the example, the expression argument of the signal statement is a variable with the same name as the variable parameter of the accept statement.
Reference: [Tayl83a] <author> Taylor, R. N. </author> <title> "A general-purpose algorithm for analyzing concurrent programs." </title> <journal> Communications of the ACM, </journal> <month> May </month> <year> 1983, </year> <pages> 362-376. </pages>
Reference-contexts: Her model represents programs as forests of "symbolic execution trees"; freedom from deadlock is proven by proving a set of assertions that deadlocked execution waves are infeasible. Neither paper claims tractability or full automation of the proof algorithm. Taylor <ref> [Tayl83a] </ref> represents the possible concurrency states of a program as a graph. A concurrency state represents the rendezvous status of all tasks within a program. Thus, the number of concurrency states is greater than the product of the numbers of rendezvous nodes in each task.
Reference: [Tayl83b] <author> Taylor, R. N. </author> <title> "Complexity of analyzing the synchronization structure of concurrent programs." </title> <journal> Acta Informatica, </journal> <volume> 19, </volume> <year> 1983, </year> <pages> 57-84. </pages>
Reference-contexts: This is also impossible, since s can rendezvous only with v, and s must follow r. Therefore, we know that v must execute after r. 4.1 Deadlock detection complexity. Taylor <ref> [Tayl83b] </ref> showed that exact static detection of possible deadlocks in straight-line Ada programs without select statements is NP-complete. Here, our intention is to develop a conservative polynomial-time algorithm which can prove that Static Infinite Wait Anomaly Detection in Polynomial Time 12 some useful subset of programs is free of deadlock.
Reference: [YT88] <author> Young, M. and Taylor, R. N. </author> <title> "Combining static concurrency analysis with symbolic execution." </title> <journal> IEEE Trans. on Software Eng., </journal> <month> October </month> <year> 1988, </year> <pages> 1499-1511. </pages>
Reference-contexts: A concurrency state represents the rendezvous status of all tasks within a program. Thus, the number of concurrency states is greater than the product of the numbers of rendezvous nodes in each task. Later work by Young and Taylor <ref> [YT88] </ref> apply information gathered during symbolic execution to rule out infeasible concurrency states. Long and Clarke [LC89] propose a similar task interaction concurrency graph representation, and cite empirical evidence of a linear reduction in the number of states with respect to the concurrency state graph.
References-found: 16

