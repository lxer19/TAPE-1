URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-38.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-38.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Scott Meyers and Steven P. Reiss, </author> <title> "An Empirical Study of Multiple-View Software Develpment," </title> <booktitle> Proceedings of the Fifth ACM SIGSOFT Symposium on Software Develpment Environments 17 (December 1992), </booktitle> <pages> 41-46. </pages>
Reference-contexts: If multiple links are defined in software units of a program, multiple views are available for programmers. Empirical study shows that multiple-view software development may promote productivity significantly <ref> [1] </ref>. Among the possible links that can be defined, child link, as described in the previous section, plays a special role in our framework. It defines the structure used by system building and version control, and corresponds to the module-submodule relation in software decomposition.
Reference: [2] <author> Ian Sommerville, </author> <title> Software Engineering, </title> <publisher> 3rd ed., Addison Wesley, </publisher> <address> Wokingham, England, </address> <year> 1989. </year>
Reference-contexts: It defines the structure used by system building and version control, and corresponds to the module-submodule relation in software decomposition. As there is no definite way to decompose a software system <ref> [2] </ref>, there is no definite way to define the child links. We only impose the restriction that the child links should not form cycles, and the structure formed by the child links should reflect the process of building a software system.
Reference: [3] <author> Henry Lieberman, </author> <title> "Using Prototypical Objects to Implement Shared Behavior in Object Oriented Languages," </title> <booktitle> ACM OOPSLA'86 (Sep. </booktitle> <year> 1986). </year>
Reference-contexts: As shown in the example of Figure 7, a programmer usually needs to "reuse" the modules developed by other members of a programming team. To capture the behavior of these shadow objects, the delegation model <ref> [3] </ref> [4] [5] is a natural candidate. The delegation mechanism is proposed as an alternative to the mechanism of classes and inheritance. An instance may share data and behavior with the prototype it delegates to while having its own local modifications. Delegation gives us great flexibility.
Reference: [4] <author> David Ungar and Randall B.Smith, </author> <title> "Self: The Power of Simplicity," </title> <booktitle> ACM OOPSLA'87 (Oct. </booktitle> <year> 1987). </year>
Reference-contexts: As shown in the example of Figure 7, a programmer usually needs to "reuse" the modules developed by other members of a programming team. To capture the behavior of these shadow objects, the delegation model [3] <ref> [4] </ref> [5] is a natural candidate. The delegation mechanism is proposed as an alternative to the mechanism of classes and inheritance. An instance may share data and behavior with the prototype it delegates to while having its own local modifications. Delegation gives us great flexibility.
Reference: [5] <author> Lynn Andrea Stein, Henry Lieberman, and David Ungar, </author> <title> "A Shared View of Sharing: </title> <booktitle> The Treaty of Orlando," In Concepts, Applications and Databases, </booktitle> <address> Reading, Massachusetts (1989). </address>
Reference-contexts: As shown in the example of Figure 7, a programmer usually needs to "reuse" the modules developed by other members of a programming team. To capture the behavior of these shadow objects, the delegation model [3] [4] <ref> [5] </ref> is a natural candidate. The delegation mechanism is proposed as an alternative to the mechanism of classes and inheritance. An instance may share data and behavior with the prototype it delegates to while having its own local modifications. Delegation gives us great flexibility.
Reference: [6] <author> Gerard Boudier, Ferdinando Gallo, Regis Minot, and Ian Thomas, </author> <title> "An Overview of PCTE and PCTE+," </title> <booktitle> Proceedings of the ACM Software Development Environments, ACM SIGSOFT Software Engineering Notes 13 (Nov. </booktitle> <year> 1988), </year> <pages> 248-257. </pages>
Reference: [7] <author> James C. Ferrans, David W. Hurst, Michael A. Sen-nett, Burton M. Covnot, Wenguang Ji, Peter Ka-jka, and Wei Ouyang, "HyperWeb: </author> <title> A Framework for Hypermedia-Based Environments," </title> <booktitle> ACM SIG-SOFT '92: Fifth Symposium on Software Develp-ment Environments (SDES), </booktitle> <address> New York, NY (De-cember 1992). </address>
Reference-contexts: By encapsulating submodules into autonomous software units, their implementation is hidden from the development consideration at a higher level. The lack of associations between related software artifacts in traditional environments has long been rec 9 ognized. A popular approach to solving this problem is to use a hypertext system <ref> [7] </ref> [8]. A hypertext system has the flexibility to establish links between any two arbitrary software artifacts. However, too many unrestricted links in a software development environment is just like too many goto statements in a program, they bring the navigation problems and cognitive overhead.
Reference: [8] <author> P. Brown, </author> <title> "Integrated Hypertext and Program Understanding Tools.," </title> <journal> IBM System Journal 30 (1991), </journal> <pages> 363-392. </pages>
Reference-contexts: The lack of associations between related software artifacts in traditional environments has long been rec 9 ognized. A popular approach to solving this problem is to use a hypertext system [7] <ref> [8] </ref>. A hypertext system has the flexibility to establish links between any two arbitrary software artifacts. However, too many unrestricted links in a software development environment is just like too many goto statements in a program, they bring the navigation problems and cognitive overhead.
Reference: [9] <author> Alan W. Brown, </author> <title> "Integrated Project Support Environments: The Aspect Project," </title> <booktitle> The APIC Series, </booktitle> <address> London, England (1991). </address>
Reference-contexts: The internal complexity of submodules is hidden behind the abstract operations of software units. Some advanced programming environments use a large centralized database to keep information and data of software systems being developed <ref> [9] </ref> [10] [11]. These environments usually support more and better functionalities than traditional ones. But as the target software system becomes larger, the database also becomes larger. This simply leads to more overhead.
Reference: [10] <author> Yih-Farn Chen, Michael Y. Nishimoto, and C. V. Ramaoorthy, </author> <title> "The C Information Abstraction System," </title> <booktitle> IEEE Transaction on Software Engineering 16 (March 1990), </booktitle> <pages> 325-334. </pages>
Reference-contexts: The internal complexity of submodules is hidden behind the abstract operations of software units. Some advanced programming environments use a large centralized database to keep information and data of software systems being developed [9] <ref> [10] </ref> [11]. These environments usually support more and better functionalities than traditional ones. But as the target software system becomes larger, the database also becomes larger. This simply leads to more overhead.
Reference: [11] <author> Premkumar Devanbu, Ronald J. Brachman, Peter G. Selfridge, and Bruce W. Ballard, </author> <title> "LaSSIE: A Knowledge-Based Software Information System," </title> <booktitle> Communication of the ACM 34 (May 1991), </booktitle> <pages> 34-49. </pages>
Reference-contexts: The internal complexity of submodules is hidden behind the abstract operations of software units. Some advanced programming environments use a large centralized database to keep information and data of software systems being developed [9] [10] <ref> [11] </ref>. These environments usually support more and better functionalities than traditional ones. But as the target software system becomes larger, the database also becomes larger. This simply leads to more overhead.
Reference: [12] <author> Steven P. Reiss, </author> <title> "Connecting Tools Using Message Passing in the Field Environment," </title> <booktitle> IEEE Software 7 (July 1990), </booktitle> <pages> 57-66. </pages>
Reference-contexts: A programmer can graphically build the skeleton of a module by creating a DAG of software units. Flesh of this skeleton can be filled in later by invoking operations associated with each software unit. 4.5 Other Related Work Field <ref> [12] </ref> and SoftBench [13] allow a programmer to browse an existing software system in terms of logical units. Users can also visualize the interaction between abstractions at run time. But in these systems, software is organized in the traditional way instead of around these logical units.
Reference: [13] <author> M.R. Cagan, </author> <title> "The HP SoftBench Environment: An Architecture for a New Generation of Software Tools.," </title> <journal> Hewlett-Packerd Journal (June, </journal> <year> 1990). </year>
Reference-contexts: A programmer can graphically build the skeleton of a module by creating a DAG of software units. Flesh of this skeleton can be filled in later by invoking operations associated with each software unit. 4.5 Other Related Work Field [12] and SoftBench <ref> [13] </ref> allow a programmer to browse an existing software system in terms of logical units. Users can also visualize the interaction between abstractions at run time. But in these systems, software is organized in the traditional way instead of around these logical units.
Reference: [14] <author> Randy H. Katz, </author> <title> "Toward a Unified Framework for Version Modeling in Engineering Databases," </title> <booktitle> ACM Computing Surveys 22 (December 1990), </booktitle> <pages> 375-408. </pages>
Reference-contexts: The mapping between logical units and programs is achieved through special mechanisms. Versioning of composite objects is not common in existing programming environments, but has been well discussed in the design of computer-aided design databases. Katz gave a good overview of these researches in <ref> [14] </ref>. In these systems, components of a composite object are associated by individual links instead of links from a single object. This leads to a more complex version control framework. There are also languages and systems aimed to supply a generic environment for the development of distributed object-oriented systems.
Reference: [15] <author> Andrew Black, Norman Hutchinson, Eric Jul, Henry Levy, and Larry Carter, </author> <title> "Distribution and Abstract Types in Emerald," </title> <journal> IEEE Transactions on Software Engineering SE-13 (Jan. </journal> <year> 1987). </year>
Reference-contexts: In these systems, components of a composite object are associated by individual links instead of links from a single object. This leads to a more complex version control framework. There are also languages and systems aimed to supply a generic environment for the development of distributed object-oriented systems. Emerald <ref> [15] </ref> is a strongly typed object-oriented language that supports location-independent invocation and object migration. DOWL [16] supplies similar features but claims to ex cel by some rather subtle advantages. Amber [17] augments a subset of C++ with primitives to manage concurrency and distribution.
Reference: [16] <editor> Bruno Achauer, </editor> <booktitle> "The DOWL Distributed Object-Oriented Language," Communication of the ACM 36 (September 1993), </booktitle> <pages> 48-55. </pages>
Reference-contexts: This leads to a more complex version control framework. There are also languages and systems aimed to supply a generic environment for the development of distributed object-oriented systems. Emerald [15] is a strongly typed object-oriented language that supports location-independent invocation and object migration. DOWL <ref> [16] </ref> supplies similar features but claims to ex cel by some rather subtle advantages. Amber [17] augments a subset of C++ with primitives to manage concurrency and distribution. PCTE and PCTE+ supply a public tool interface to support the construction of software engineering environments.
Reference: [17] <author> J. Chase, F. Amador, E. Lazowska, H. Levy, and R. Littlefield, </author> <title> "The Amber system: Parallel programming on a network of multiprocessors.," </title> <booktitle> Proceedings of the Twelfth ACM Symposium on Operating System Principles, </booktitle> <address> New York (1989). </address> <month> 12 </month>
Reference-contexts: Emerald [15] is a strongly typed object-oriented language that supports location-independent invocation and object migration. DOWL [16] supplies similar features but claims to ex cel by some rather subtle advantages. Amber <ref> [17] </ref> augments a subset of C++ with primitives to manage concurrency and distribution. PCTE and PCTE+ supply a public tool interface to support the construction of software engineering environments.
References-found: 17

