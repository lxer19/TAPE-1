URL: http://www.cs.purdue.edu/homes/linh/ps/dissert0.ps
Refering-URL: http://www.cs.purdue.edu/homes/linh/CV.htm
Root-URL: http://www.cs.purdue.edu
Title: Chemical Reaction Model Based Parallel Programming: Synthesis, Semantics, and Implementation  
Author: Hong Lin Supervisor: Guoliang Chen 
Date: January 1997  
Address: Hefei, Anhui, P.R.China  
Affiliation: Department of Computer Science University of Science and Technology of China  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J.-P. Ban^atre, D. Le Metayer, </author> <title> The Gamma model and its discipline of programming, </title> <booktitle> Science of Computer Programming, </booktitle> <volume> Vol. 15, </volume> <year> 1990, </year> <pages> pp. 55-77. </pages>
Reference-contexts: Introduction 1.1 The chemical reaction model 1.1.1 Gamma Gamma <ref> [1, 2, 3] </ref> is a kernel language in which programs are described in terms of multiset transformations. It is a high-level programming language in which parallelism is left implicit and especially suitable for data parallel paradigm. Existing work has demonstrated its significance for the construction of massively parallel programs. <p> Therefore correctness and efficiency issues are separated in program constructions [18, 19]. In Gamma language, the classical method proposed by J.-P. Ban^atre and D. Le Metayer <ref> [1, 20] </ref> is to decompose the specification into an invariant and a termination condition. The program is synthesized by deduction to meet the termination condition while keeping the invariant satisfied. <p> Functional programming [58], which aims at developping data parallelism, has elegant mathematical properties and is suitable for program derivation [59, 60]. Gamma can be considered a functional style high-level programming language and suitable to describe data parallelism [61]. The succinctness of the computation model makes parallel program derivation feasible <ref> [1] </ref>. This thesis proposes a method for derivation of Gamma programs by verifying the program specification in first-order logic, as an other dimension from the classical method consisting in decomposing the specification into an invariant and a termination condition [1, 20]. <p> This thesis proposes a method for derivation of Gamma programs by verifying the program specification in first-order logic, as an other dimension from the classical method consisting in decomposing the specification into an invariant and a termination condition <ref> [1, 20] </ref>. In Section 2.2, we introduce logical specifications and transformations in specification level. In Section 2.3, we describe the method of constructing verification programs from specifications. <p> For exam ple, is replaced with x := y k y := x * Quantified assignment is transformed in a similar way. For example, &lt; ki : 0i &lt; n :: a [i] := a [i + 1] &gt; is changed to a [0] := a <ref> [1] </ref> k : : : ka [n 1] := a [n] * Quantified statement list is replaced with a set of asynchronous statements. For example, &lt; []i : 0i &lt; n :: a [i] := a [i + 1] &gt; is changed to a [0] := a [1][]: : :[]a [n <p> [0] := a <ref> [1] </ref> k : : : ka [n 1] := a [n] * Quantified statement list is replaced with a set of asynchronous statements. For example, &lt; []i : 0i &lt; n :: a [i] := a [i + 1] &gt; is changed to a [0] := a [1][]: : :[]a [n 1] := a [n] 78 CHAPTER 7. <p> Each x [i] will contain a tuple. Currently tuple set is contained in front part of array x (i.e., be loaded from x <ref> [1] </ref> to some x [j] (1jn). A counter 7.5. IMPLEMENTING GAMMA BY UNITY 89 count : integer is been declared to record the size of current tuple set. <p> number in Seconds) of Gamma program sort nnp 1 2 4 8 16 32 2048 59 69 29 37 47 60 8192 1172 836 318 254 100 103 7.6.1 A Gamma program For the problem refered to, the following Gamma program can be designed in a procedure of formal derivation <ref> [1] </ref>. sort a = [P; M ] where P = x; y ! (x:i; y:v); (y:i; x:v) ( x:i &lt; y:i^x:v &gt; y:v Suppose index = fij1ing and value = fvj9i2f1; : : :; ng:v = a [i]g, then M indexfivalue and 8x; y2M:x:i6=y:i and S x:i = f1; : : <p> Firstly, we rewrite the Unity program in a plattened form, i.e. program sort assign a <ref> [1] </ref> := min (a [1]; a [2])ka [2] := max (a [1]; a [2]) [] [] end fsortg Then by applying the denotational function to the Unity program, we get the following Gamma translation. sort a = [P; f ( 0 a [i] 0 ; a [i])ji = 1; : : <p> Firstly, we rewrite the Unity program in a plattened form, i.e. program sort assign a <ref> [1] </ref> := min (a [1]; a [2])ka [2] := max (a [1]; a [2]) [] [] end fsortg Then by applying the denotational function to the Unity program, we get the following Gamma translation. sort a = [P; f ( 0 a [i] 0 ; a [i])ji = 1; : : :; ng] where P <p> Firstly, we rewrite the Unity program in a plattened form, i.e. program sort assign a <ref> [1] </ref> := min (a [1]; a [2])ka [2] := max (a [1]; a [2]) [] [] end fsortg Then by applying the denotational function to the Unity program, we get the following Gamma translation. sort a = [P; f ( 0 a [i] 0 ; a [i])ji = 1; : : :; ng] where P = i=1 P 1 = ( 0 <p> [2]) [] [] end fsortg Then by applying the denotational function to the Unity program, we get the following Gamma translation. sort a = [P; f ( 0 a [i] 0 ; a [i])ji = 1; : : :; ng] where P = i=1 P 1 = ( 0 a <ref> [1] </ref> 0 ; x); ( 0 a [2] 0 ; y) ! ( 0 a [1] 0 ; min (x; y)); ( 0 a [2] 0 ; max (x; y)) P n1 = ( 0 a [n 1] 0 ; x); ( 0 a [n] 0 ; y) ! With 0 <p> we get the following Gamma translation. sort a = [P; f ( 0 a [i] 0 ; a [i])ji = 1; : : :; ng] where P = i=1 P 1 = ( 0 a <ref> [1] </ref> 0 ; x); ( 0 a [2] 0 ; y) ! ( 0 a [1] 0 ; min (x; y)); ( 0 a [2] 0 ; max (x; y)) P n1 = ( 0 a [n 1] 0 ; x); ( 0 a [n] 0 ; y) ! With 0 a [i] 0 substituted with i (i = 1; : : :; n), we can <p> RELATIONSHIP BETWEEN GAMMA AND UNITY Chapter 8 Conclusion and future work This thesis aims at a systematic study on Gamma and its higher-order extension. Research has been done on program synthesis, semantics and implementation. Gamma is proposed for systematic derivation of correct programs <ref> [1] </ref>. The existing method for the derivation follows a common practice which consists in splitting the property into two parts: the invariant which holds during the whole computation, and the variant which is required to hold only at the end of the computation.
Reference: [2] <author> J.-P. Ban^atre, D. Le Metayer, </author> <title> Programming by multiset transformation, </title> <journal> CACM, </journal> <volume> Vol. 36, No. 1, </volume> <month> Jan. </month> <year> 1993, </year> <pages> pp. 98-111. </pages>
Reference-contexts: Introduction 1.1 The chemical reaction model 1.1.1 Gamma Gamma <ref> [1, 2, 3] </ref> is a kernel language in which programs are described in terms of multiset transformations. It is a high-level programming language in which parallelism is left implicit and especially suitable for data parallel paradigm. Existing work has demonstrated its significance for the construction of massively parallel programs. <p> Firstly, we rewrite the Unity program in a plattened form, i.e. program sort assign a [1] := min (a [1]; a <ref> [2] </ref>)ka [2] := max (a [1]; a [2]) [] [] end fsortg Then by applying the denotational function to the Unity program, we get the following Gamma translation. sort a = [P; f ( 0 a [i] 0 ; a [i])ji = 1; : : :; ng] where P = i=1 P <p> Firstly, we rewrite the Unity program in a plattened form, i.e. program sort assign a [1] := min (a [1]; a <ref> [2] </ref>)ka [2] := max (a [1]; a [2]) [] [] end fsortg Then by applying the denotational function to the Unity program, we get the following Gamma translation. sort a = [P; f ( 0 a [i] 0 ; a [i])ji = 1; : : :; ng] where P = i=1 P 1 = ( 0 a [1] <p> applying the denotational function to the Unity program, we get the following Gamma translation. sort a = [P; f ( 0 a [i] 0 ; a [i])ji = 1; : : :; ng] where P = i=1 P 1 = ( 0 a [1] 0 ; x); ( 0 a <ref> [2] </ref> 0 ; y) ! ( 0 a [1] 0 ; min (x; y)); ( 0 a [2] 0 ; max (x; y)) P n1 = ( 0 a [n 1] 0 ; x); ( 0 a [n] 0 ; y) ! With 0 a [i] 0 substituted with i (i <p> [P; f ( 0 a [i] 0 ; a [i])ji = 1; : : :; ng] where P = i=1 P 1 = ( 0 a [1] 0 ; x); ( 0 a <ref> [2] </ref> 0 ; y) ! ( 0 a [1] 0 ; min (x; y)); ( 0 a [2] 0 ; max (x; y)) P n1 = ( 0 a [n 1] 0 ; x); ( 0 a [n] 0 ; y) ! With 0 a [i] 0 substituted with i (i = 1; : : :; n), we can rewrite this program to a more compact form. <p> Linda's model is based on generative communications, which are done via the tuple space. Both data and program objects are represented as tuples. Linda is a very simple communication model that can easily be incorporated into existing programming language. As such, Linda is not a computational model <ref> [2] </ref>. It may be suitable to consider program languages to whom Linda primitives are implanted as potential implementation machines of Gamma. Relationship between Unity and Linda can be viewed from this point. Linear Objects (or LO) was originally proposed as an integration of logic programming and object-oriented programming [80].
Reference: [3] <author> J.-P. Ban^atre, and D. Le Metayer, </author> <title> Gamma and the chemical reaction model: ten years after, </title> <editor> in: J.M. Andresli, and C. Hankin (eds.), </editor> <title> Coordination Programming: Mechanisms, Models and Semantics, </title> <publisher> Imperial College Press, </publisher> <year> 1996, </year> <note> to appear. </note>
Reference-contexts: Introduction 1.1 The chemical reaction model 1.1.1 Gamma Gamma <ref> [1, 2, 3] </ref> is a kernel language in which programs are described in terms of multiset transformations. It is a high-level programming language in which parallelism is left implicit and especially suitable for data parallel paradigm. Existing work has demonstrated its significance for the construction of massively parallel programs. <p> Computations which may be carried out in parallel are determined in a special design phase which aims at mapping the Unity program onto a particular target machine <ref> [3] </ref>. The observations suggest that the abstractness of Gamma machine is stronger than that of Unity. 1.5. THE ORGANISATION OF THIS THESIS 7 This thesis uses a similar technique to specify the semantics of Unity programs: semantics of the program is specified by a set of temporal logic formulas. <p> However, efficiency of implementing them on message-passing (MP) environments can also be satisfiable when appropriate techniques are used <ref> [3, 18] </ref>. We implement Gamma and Unity on a MP-machine, Dawning-1000. For a given problem, we can write a Gamma program and a Unity one separately. The experiments show that running a Gamma program is usually more time-consuming than running its Unity counterpart. <p> Because of Gamma's "synchronous termination" semantics <ref> [3] </ref>, g 0 1 = is not allowed. 2 This definition is more constrained than that in [10] in the definitions of &lt; g; X &gt;" and &lt; g; X &gt; ! Y . In a word, we only care confluent transitions. 29 30 CHAPTER 3. <p> However, efficiency of implementing them on message-passing (MP) environments can also be satisfiable when appropriate techniques are used <ref> [3, 18] </ref>. We implement Gamma and Unity on a MP-machine, Dawning-1000. For a given problem, we can write a Gamma program and a Unity one seperately. The experiments show that running a Gamma program is usually more time-consuming than running its Unity counterpart. <p> Techniques for "detection of neighborhood relationships" <ref> [3] </ref> can be used in the derivation. Another merit of transformational approach is seperating problem description and program refinement. The first level, Gamma, should emphasize the abstractness and succinctness.
Reference: [4] <author> N. Carriero, and D. Gelernter, </author> <title> Linda in context, </title> <journal> CACM, </journal> <volume> Vol. </volume> <pages> 32-4, pp. 444-458, </pages> <month> Apr. </month> <year> 1989. </year>
Reference-contexts: Existing work has demonstrated its significance for the construction of massively parallel programs. In Gamma programming paradigm, programmers can concentrate on the logic of problems to transfer the tuple space (this terminology is borrowed from Linda, which shares some idea with Gamma <ref> [4, 5] </ref>), and are free from considering execution environment. It has issued follow-up elaborations on chemical reaction model, such as Chemical abstract machine (Cham) [6], higher-order Gamma [7], Structured Gamma [8], and Multran [5]. Multiset is a set except that its elements may have multiple occurrences. <p> In practical programming, the program is assigned an initial multiset. In this chapter, however, we assume the program can begin its execution from any multiset in a proper type. We call elements of the multiset tuples (This terminology is borrowed from Linda <ref> [4] </ref>). Tuples are typed and the type is call tuple space. Any multiset whose tuples are in the tuple space is called a state. Any Gamma program can be viewed as a specification of some desired properties. <p> For implementing Gamma, we propose a method of transforming Gamma programs to Unity programs and test the effect of this transformation on a sorting problem. The results support the expectation that using Unity as an implementation level of Gamma benefit the improvement of the efficiency of the programs. Linda <ref> [4, 79] </ref> is a related approach to Gamma. Linda's model is based on generative communications, which are done via the tuple space. Both data and program objects are represented as tuples. Linda is a very simple communication model that can easily be incorporated into existing programming language. <p> The significance of the approach is that the programmer can define his own types and programs can be checked according to the type definitions. The application of this idea to the definition and the analysis of software architectures [87, 88] (or, in other terminologies, configuration programming [89], coordination programming <ref> [4, 90] </ref>) is an important aspect of current research [91, 8, 5]. Significance of this application is based on the fact that common and formally based language is lack for describing software architectures and the chemical reaction model can be used as a candidate [92, 8].
Reference: [5] <author> W. Ma, V.K. Murthy, and E.V. Krishnamurthy, </author> <title> Multran|a coordination programming language using multiset and transactions, </title> <editor> in: S.K. Aityan et al. (eds.), </editor> <booktitle> Proc. the 1st Int'l Conf. on Neural, Parallel, and Scientific Computations (ICNPSC), </booktitle> <year> 1995, </year> <pages> pp. 301-304. </pages>
Reference-contexts: Existing work has demonstrated its significance for the construction of massively parallel programs. In Gamma programming paradigm, programmers can concentrate on the logic of problems to transfer the tuple space (this terminology is borrowed from Linda, which shares some idea with Gamma <ref> [4, 5] </ref>), and are free from considering execution environment. It has issued follow-up elaborations on chemical reaction model, such as Chemical abstract machine (Cham) [6], higher-order Gamma [7], Structured Gamma [8], and Multran [5]. Multiset is a set except that its elements may have multiple occurrences. <p> It has issued follow-up elaborations on chemical reaction model, such as Chemical abstract machine (Cham) [6], higher-order Gamma [7], Structured Gamma [8], and Multran <ref> [5] </ref>. Multiset is a set except that its elements may have multiple occurrences. The computation sequence of a Gamma program is the transformation from the original multiset to the final one. We refer to the elements in the multiset as tuples. <p> Unity Logic is a formal system for specifying and reasoning about such properties <ref> [5] </ref>. <p> The reverse proposition is not generally tenable, because Unity Logic is established to state some of the most commonly used properties of programs, it can not describe all the features about the execution of programs. The expressivity of the logic is weaker than that of temporal logic <ref> [5] </ref>. 7.4 Program transformation from Unity to Gamma Firstly we will define the notion of semantic equivalence between Unity programs and Gamma programs. <p> The application of this idea to the definition and the analysis of software architectures [87, 88] (or, in other terminologies, configuration programming [89], coordination programming [4, 90]) is an important aspect of current research <ref> [91, 8, 5] </ref>. Significance of this application is based on the fact that common and formally based language is lack for describing software architectures and the chemical reaction model can be used as a candidate [92, 8].
Reference: [6] <author> G. Berry, and G. Boudol, </author> <title> The Chemical Abstract Machine, </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 96, </volume> <pages> pp. 217-248, </pages> <year> 1992. </year>
Reference-contexts: It has issued follow-up elaborations on chemical reaction model, such as Chemical abstract machine (Cham) <ref> [6] </ref>, higher-order Gamma [7], Structured Gamma [8], and Multran [5]. Multiset is a set except that its elements may have multiple occurrences. The computation sequence of a Gamma program is the transformation from the original multiset to the final one. We refer to the elements in the multiset as tuples. <p> = x : M; pivot : P ivot ! x : R ; pivot : P ivot xpivot P 2 = x : M; pivot : P ivot ! x : R &gt; ; pivot : P ivot x &gt; pivot 1.1.2 The chemical abstract machine Cham (chemical abstract machine) <ref> [6] </ref> is based on Gamma but more mechanisms are introduced to enhance the expressivity. Cham is an elaboration on Gamma to model asynchronous computations. The most important additions to Gamma are the notions of membrane and airlock mechanism to describe CCS [11].
Reference: [7] <author> D. Le Metayer, </author> <title> Higher-order multiset processing, </title> <booktitle> DIMACS Series in Discrete Mathematics and Theoretical Computer Science, Vol.18, </booktitle> <pages> 179-200, </pages> <year> 1994. </year>
Reference-contexts: It has issued follow-up elaborations on chemical reaction model, such as Chemical abstract machine (Cham) [6], higher-order Gamma <ref> [7] </ref>, Structured Gamma [8], and Multran [5]. Multiset is a set except that its elements may have multiple occurrences. The computation sequence of a Gamma program is the transformation from the original multiset to the final one. We refer to the elements in the multiset as tuples. <p> Of course, in some cases the programs may not terminate, that is to say when the reaction will take place for ever. In this thesis, we adopt a syntax of Gamma unified to that for higher-order Gamma <ref> [7] </ref>. In this syntax, a program is expressed as a conf iguration, which is made of a program and a record of named multisets. The record component of the configuration can be seen as the environment of the program. Each component of the environment is a typed multiset. <p> Cham is an elaboration on Gamma to model asynchronous computations. The most important additions to Gamma are the notions of membrane and airlock mechanism to describe CCS [11]. These extensions are difficult for Gamma to describe. 1.1.3 Higher-order Gamma Higher-order Gamma <ref> [7] </ref> is an extension of Gamma formalism unifying the program and data syntactic categories, that is say unifying multiset and (R; A) pair into a single notion of conf iguration. A configuration is made of a program and a record of named multisets. <p> Parallelism is emphasized in program construction. Efficiency issues can be dealt with in a totally separated phase and framework of the program need not be changed in reforming the program. 1.3 Semantics 1.3.1 Temporal semantics Studies in semantics of Gamma are currently in themes of operational semantics <ref> [9, 10, 7] </ref> and temporal semantics [29, 30]. Temporal logics are very useful to reason about temporal properties such as safety and liveness, and thus are widely used in program specification and verification [31, 32]. <p> The techniques presented here will, however, show their effect in improving the efficiency of the programs. 1.4.1 Flattening higher-order Gamma Higher-order Gamma (written HoGamma in this thesis) unifies the program and data syntactic categories. As a consequence, active programs can be inserted into multisets. <ref> [7] </ref> shows that more sophisticated control strategies can be expressed within the language. In particular, it is proved that Cham can be defined in HoGamma. This thesis studies the relationships between Gamma and its extensions. <p> if g 1 always diverge (i.e., rewrite forever, written &lt; g 1 ; X &gt;") then so does g 2 , and if g 1 eventually terminate producing some multiset Y (written &lt; g 1 ; X &gt; ! Y ) then so does g 2 2 . 1 In <ref> [9, 10, 7] </ref>, rule 4 is defined as &lt; g 1 ; X &gt; ! &lt; g 0 &lt; g 1 + g 2 ; X &gt; ! &lt; g 0 It is not appropriate for cases in which g 1 cannot be a sequential composition and thus g 0 1 <p> This approach will lead to a new style categorical semantics (Chapter 5). We do not adopt this approach in this chapter because we try to establish a general semantic framework and avoid involving operational concepts. Higher-order Gamma <ref> [7] </ref> is an elaborations on basic Gamma. Its semantics is the topic of the following chapter. 52 CHAPTER 4. <p> We will prove Par can be expressed within Imc with each Sim being expressed within a thread, thus complete our proofs. To examine the structure of Sim, we show the (concrete) syntax of Exp <ref> [7] </ref> below: Exp = Conf j Conf:V ar i j x i j Arithexp j Boolexp j M ultexp j card (M ultexp) j : : : Conf = P assive j Active P assive = [; Env] Active = [P rog; Env] Env = (V ar 1 = M ultexp <p> FLATTENING HIGHER-ORDER GAMMA We note that a HoGamma program is an active configuration whose environment may include other active configurations. So it is a recursive construction. Reaction can take place (nondeter-ministically) at each level according to the structural operational semantics of HoGamma <ref> [7] </ref>. For any HoGamma program H, the set of its active configurations is written as C (H) (Note that structures of configurations are statically determined). L is the set of labels. Bimorphism S H : C (H) ! L signs each active configuration in C (H) to a label.
Reference: [8] <author> P. Fradet, and D. Le Metayer, </author> <title> Structured Gamma, </title> <note> Inria Research Report, Publication interne n ffi 989, </note> <year> 1996. </year>
Reference-contexts: It has issued follow-up elaborations on chemical reaction model, such as Chemical abstract machine (Cham) [6], higher-order Gamma [7], Structured Gamma <ref> [8] </ref>, and Multran [5]. Multiset is a set except that its elements may have multiple occurrences. The computation sequence of a Gamma program is the transformation from the original multiset to the final one. We refer to the elements in the multiset as tuples. <p> As a special conditional term rewriting system [76, 77], how Gamma is related to the existing work, especially on issues such as Church-Rosser property, termination, and composition theory, is also an aspect of future work. Structured Gamma <ref> [8, 86] </ref> is the result of an attempt to solve the problem that the fact of Gamma's lack of structuring may lead to to programs which are unnecessary complex when the programmer needs to encode specific data structures and is detrimental both for reasoning about programs and for implementing them, without <p> The application of this idea to the definition and the analysis of software architectures [87, 88] (or, in other terminologies, configuration programming [89], coordination programming [4, 90]) is an important aspect of current research <ref> [91, 8, 5] </ref>. Significance of this application is based on the fact that common and formally based language is lack for describing software architectures and the chemical reaction model can be used as a candidate [92, 8]. <p> Significance of this application is based on the fact that common and formally based language is lack for describing software architectures and the chemical reaction model can be used as a candidate <ref> [92, 8] </ref>. Acknowledgement First of all, I would like to express gratitude to my supervisor, Professor Guoliang Chen, for his persistent guidance. His dilligence in work gives me much influence. It is he who encouraged me when I was disheartened.
Reference: [9] <author> C. Hankin, D. Le Metayer, and D. Sands, </author> <title> A culculus of Gamma programs. </title> <booktitle> Proc. 5th Workshop on Languages and Compilers for Parallel Computing, </booktitle> <publisher> Yale, Springer Verlag, LNCS 757, </publisher> <year> 1993. </year>
Reference-contexts: Programs can be composed using the sequential operator ffi and the parallel operator +. Conf:V ar returns the value of the field V ar in 3 4 CHAPTER 1. INTRODUCTION the configuration Conf (when Conf has reached a stable state). Operational semantics of Gamma <ref> [9, 10] </ref> restricts that the environment returned by a parallel composition P 1 + P 2 must be stable for both P 1 and P 2 . <p> Parallelism is emphasized in program construction. Efficiency issues can be dealt with in a totally separated phase and framework of the program need not be changed in reforming the program. 1.3 Semantics 1.3.1 Temporal semantics Studies in semantics of Gamma are currently in themes of operational semantics <ref> [9, 10, 7] </ref> and temporal semantics [29, 30]. Temporal logics are very useful to reason about temporal properties such as safety and liveness, and thus are widely used in program specification and verification [31, 32]. <p> Operational semantics of Gamma is in the style of Plotkin's Structural Operational Semantics <ref> [9, 10] </ref>. Conf igurations consist of a program and a multiset; transitions are of the form &lt; g; X &gt; ! &lt; g; X 0 &gt; &lt; g; X &gt; ! X 0 Multisets are terminal configurations. The semantics are composed of five rules in Table 3.1 1 . [9, 10] <p> Semantics <ref> [9, 10] </ref>. Conf igurations consist of a program and a multiset; transitions are of the form &lt; g; X &gt; ! &lt; g; X 0 &gt; &lt; g; X &gt; ! X 0 Multisets are terminal configurations. The semantics are composed of five rules in Table 3.1 1 . [9, 10] defined a notion of operational equivalence: g 1 g 2 if f g 1 vg 2 ^ g 2 vg 1 Intuitively, g 1 vg 2 whenever, for each possible input X, if g 1 always diverge (i.e., rewrite forever, written &lt; g 1 ; X &gt;") then so <p> if g 1 always diverge (i.e., rewrite forever, written &lt; g 1 ; X &gt;") then so does g 2 , and if g 1 eventually terminate producing some multiset Y (written &lt; g 1 ; X &gt; ! Y ) then so does g 2 2 . 1 In <ref> [9, 10, 7] </ref>, rule 4 is defined as &lt; g 1 ; X &gt; ! &lt; g 0 &lt; g 1 + g 2 ; X &gt; ! &lt; g 0 It is not appropriate for cases in which g 1 cannot be a sequential composition and thus g 0 1 <p> written &lt; g; M &gt;# must ) if any ! fl rewrite terminates, i.e. there is a state N for any ! fl rewrite such that &lt; g; M &gt;! fl N . g terminates (or the relation ! is strongly normalising with respect to g, written g # must <ref> [9, 10] </ref>) if g terminates on any state M , i.e. 8M: &lt; g; M &gt;# must . <p> Proof. 2 This definition is different from that in <ref> [9, 10] </ref>. There, &lt; g; M &gt;" means there can be a infinite ! fl rewrite in which no state is final. 4.2. SEMANTICS OF SIMPLE GAMMA PROGRAMS 43 1. Obvious. 2. <p> This is the corollary of 2 and Proposition 4.4-2. 2 4.2. SEMANTICS OF SIMPLE GAMMA PROGRAMS 45 4.2.3 Confluence A program g is conf luent on state M (or Church Rosser on state M , written Con (g; M ) <ref> [9] </ref>) if for any M 1 ; M 2 2T g 9 &lt; g 3 ; M 3 &gt; :(&lt; g 1 ; M 1 &gt;! fl &lt; g 3 ; M 3 &gt; ^ &lt; g 2 ; M 2 &gt;! fl &lt; g 3 ; M 3 &gt;) And <p> Con (g; M ) , 8C; C 0 2 (D g ) 0 :(CR (fM g)^C 0 R (fM g) ! R (C) R (C 0 6= ). T 46 CHAPTER 4. CATEGORICAL SEMANTICS OF GAMMA 4.2.4 Operational equivalence In <ref> [9] </ref>, an ordering v on programs is defined. g 1 vg 2 , 8M: ((: &lt; g 1 ; M &gt;# must ) &lt; g 2 ; M &gt; # must )^ 8N:(&lt; g 1 ; M &gt; ! fl N ) &lt; g 2 ; M &gt; ! fl N <p> D g 1 ffi (D g 2 + D g 3 ) v (D g 1 ffi D g 2 ) + (D g 1 ffi D g 3 ). 2 4.4 Related and future work The computation model of Gamma is closely related to conditional term rewriting <ref> [9, 46, 47] </ref>. In [46, 47], Gamma is considered as a speciality of concurrent rewriting logic. Therefore, categorical semantics for rewriting logic can be specialized to Gamma. <p> 4 ] 2 D, these are equivalent to the assertion that there are morphisms f : A ! B and g : A ! C implies there are morphisms h : B ! D and k : C ! D. 2 5.3.3 Operational equivalence An ordering v on Gamma programs <ref> [9, 10] </ref> is defined as P 1 v P 2 , 8M:(([P 1 ; M ] ") [P 2 ; M ] ")^ where M; N are inert multisets and [P; M ] " indicates that the configuration [P; M ] may diverge, i.e., and the equivalence relation ~ on program <p> Each quadriple (a; b; c; d) will be translated into a fl-command <ref> [9] </ref> by the following method: Case 1: c 62 fL; Rg. (a; i) : SP; (i; b) : P L!(d; i) : SP; (i; c) : P L Case 2: c = L. (a; i) : SP; (i; b) : P L!(d; i 1) : SP; (i; b) : P L
Reference: [10] <author> C. Hankin, D. Le Metayer, and D. Sands, </author> <title> A parallel programming style and its algebra of programs, </title> <booktitle> in: Proc. of PARLE'93, </booktitle> <volume> LNCS 694, </volume> <pages> pp: 367-378, </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Programs can be composed using the sequential operator ffi and the parallel operator +. Conf:V ar returns the value of the field V ar in 3 4 CHAPTER 1. INTRODUCTION the configuration Conf (when Conf has reached a stable state). Operational semantics of Gamma <ref> [9, 10] </ref> restricts that the environment returned by a parallel composition P 1 + P 2 must be stable for both P 1 and P 2 . <p> Parallelism is emphasized in program construction. Efficiency issues can be dealt with in a totally separated phase and framework of the program need not be changed in reforming the program. 1.3 Semantics 1.3.1 Temporal semantics Studies in semantics of Gamma are currently in themes of operational semantics <ref> [9, 10, 7] </ref> and temporal semantics [29, 30]. Temporal logics are very useful to reason about temporal properties such as safety and liveness, and thus are widely used in program specification and verification [31, 32]. <p> Operational semantics of Gamma is in the style of Plotkin's Structural Operational Semantics <ref> [9, 10] </ref>. Conf igurations consist of a program and a multiset; transitions are of the form &lt; g; X &gt; ! &lt; g; X 0 &gt; &lt; g; X &gt; ! X 0 Multisets are terminal configurations. The semantics are composed of five rules in Table 3.1 1 . [9, 10] <p> Semantics <ref> [9, 10] </ref>. Conf igurations consist of a program and a multiset; transitions are of the form &lt; g; X &gt; ! &lt; g; X 0 &gt; &lt; g; X &gt; ! X 0 Multisets are terminal configurations. The semantics are composed of five rules in Table 3.1 1 . [9, 10] defined a notion of operational equivalence: g 1 g 2 if f g 1 vg 2 ^ g 2 vg 1 Intuitively, g 1 vg 2 whenever, for each possible input X, if g 1 always diverge (i.e., rewrite forever, written &lt; g 1 ; X &gt;") then so <p> if g 1 always diverge (i.e., rewrite forever, written &lt; g 1 ; X &gt;") then so does g 2 , and if g 1 eventually terminate producing some multiset Y (written &lt; g 1 ; X &gt; ! Y ) then so does g 2 2 . 1 In <ref> [9, 10, 7] </ref>, rule 4 is defined as &lt; g 1 ; X &gt; ! &lt; g 0 &lt; g 1 + g 2 ; X &gt; ! &lt; g 0 It is not appropriate for cases in which g 1 cannot be a sequential composition and thus g 0 1 <p> Because of Gamma's "synchronous termination" semantics [3], g 0 1 = is not allowed. 2 This definition is more constrained than that in <ref> [10] </ref> in the definitions of &lt; g; X &gt;" and &lt; g; X &gt; ! Y . In a word, we only care confluent transitions. 29 30 CHAPTER 3. <p> written &lt; g; M &gt;# must ) if any ! fl rewrite terminates, i.e. there is a state N for any ! fl rewrite such that &lt; g; M &gt;! fl N . g terminates (or the relation ! is strongly normalising with respect to g, written g # must <ref> [9, 10] </ref>) if g terminates on any state M , i.e. 8M: &lt; g; M &gt;# must . <p> Proof. 2 This definition is different from that in <ref> [9, 10] </ref>. There, &lt; g; M &gt;" means there can be a infinite ! fl rewrite in which no state is final. 4.2. SEMANTICS OF SIMPLE GAMMA PROGRAMS 43 1. Obvious. 2. <p> 4 ] 2 D, these are equivalent to the assertion that there are morphisms f : A ! B and g : A ! C implies there are morphisms h : B ! D and k : C ! D. 2 5.3.3 Operational equivalence An ordering v on Gamma programs <ref> [9, 10] </ref> is defined as P 1 v P 2 , 8M:(([P 1 ; M ] ") [P 2 ; M ] ")^ where M; N are inert multisets and [P; M ] " indicates that the configuration [P; M ] may diverge, i.e., and the equivalence relation ~ on program <p> The most important thing is to prove that for any Gamma program P 1 ; P 2 , There exists a Gamma Program P , which is operational equivalent <ref> [10] </ref> to P 1 ffiP 2 . <p> Following is the document of function M Unity in denotational style <ref> [10, 19] </ref>: M Unity : U nity ! Gamma M Unity [u] 4 = Gamma (M Statement list [u]) M Statement list : Statement list ! L list M Statement list [sl] 4 = over sl apply M Statement combine 00 + + 00 empty &lt;&gt; end M Statement : Statement <p> They are not changed during the execution of assign section. Then the (R; A) pair above can be translated in the following way: 1. k = l (For example, (R; A) pair is an optimiser or transmuter <ref> [10] </ref>.) &lt; kj : 1jk :: x [ind [i][j]] := y 0 k i := i + 1 if R^i &lt; C k n ~ inc [count] if R where R = R (x [ind [i][1]]; : : :; x [ind [i][k]]). 2. k &lt; l (For example, (R; A) pair <p> There is (are) expander (s) in g but any expander derminates. We can make n = jT g j. We can prove termination of the expander by establishing a well founded multiset ordering and showing the expander reduces the sets with respect to this ordering <ref> [10] </ref>. 3. There is (are) expander (s) in g and at least one of the expanders does not terminates. In this cases, jT g j = 1. <p> But we still risk halt of the translation (if the size of current tuple set reaches n and only expander can be fired). Fortunately, most of Gamma programs belong to case 1 and 2 <ref> [10] </ref>. 7.6 A case study Both Gamma and Unity can be implemented directly on any given architecture. The implementation is more natural on machines with shared memory than on ones with distributed memory, because Gamma is suitable for describing data parallelism [40] and Unity is in shared variable paradigm.
Reference: [11] <author> R. Milner, </author> <title> Communications and Concurrency, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1989. </year>
Reference-contexts: Cham is an elaboration on Gamma to model asynchronous computations. The most important additions to Gamma are the notions of membrane and airlock mechanism to describe CCS <ref> [11] </ref>. These extensions are difficult for Gamma to describe. 1.1.3 Higher-order Gamma Higher-order Gamma [7] is an extension of Gamma formalism unifying the program and data syntactic categories, that is say unifying multiset and (R; A) pair into a single notion of conf iguration.
Reference: [12] <editor> M.R. Lowry, R.D. McCartney, </editor> <booktitle> Automating software design, 1991, </booktitle> <publisher> AAAI Press. </publisher>
Reference-contexts: R M 6=M 0 Q 3 = [M ] : E 2 ; M 0 : R ! [P 1 ; M ] : E 1 ; M : R M 6=M 0 1.2 Program synthesis for Gamma There are many approaches to program construction being proposed and deeply studied <ref> [12, 13] </ref>. These approaches are aiming at formalisms developping correct programs. For each of these approaches, there are, however, two problems which seem difficult to overcome: * It needs high skills to master the approach; * There are domains in which the approach does not applicable.
Reference: [13] <author> J. Xu et.al., </author> <title> Automating software design, </title> <publisher> Tsinghua University Press and Guangxi Sci & Tech Press, </publisher> <year> 1994. </year>
Reference-contexts: R M 6=M 0 Q 3 = [M ] : E 2 ; M 0 : R ! [P 1 ; M ] : E 1 ; M : R M 6=M 0 1.2 Program synthesis for Gamma There are many approaches to program construction being proposed and deeply studied <ref> [12, 13] </ref>. These approaches are aiming at formalisms developping correct programs. For each of these approaches, there are, however, two problems which seem difficult to overcome: * It needs high skills to master the approach; * There are domains in which the approach does not applicable.
Reference: [14] <author> Z. Manna, R. Waldinger, </author> <title> Fundamentals of deductive program synthesis , IEEE Trans. </title> <booktitle> on Software Engineering, </booktitle> <address> Vol.18, No.8, Aug.1992, pp674-704. </address>
Reference-contexts: These approaches are aiming at formalisms developping correct programs. For each of these approaches, there are, however, two problems which seem difficult to overcome: * It needs high skills to master the approach; * There are domains in which the approach does not applicable. For examples, deductive synthesis <ref> [14] </ref> can not be used to solve equations; knowledge based methods [15] are restricted by the number of heuristic rules; transformational approaches [16] depend on the quality and number of transformation rules, etc. 1.3. SEMANTICS 5 It seems excessive to demand the latter problem being completely solved. <p> INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory [41, 42], algebraic specification [43], program transformation [16], deductive synthesis <ref> [14, 44] </ref>, term rewriting system [45, 46, 47], and other methods in automatic software engineering [48, 49, 50, 51, 52], automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53, 54], and details of parallel architectures have to be considered <p> This is also the goal of this thesis. There are also several kinds of operations: function, predicate operation, and procedure. Only functions are discussed here. The latter two can be transformed into functions. In general, we shall be dealing with specifications of the form <ref> [14] </ref> f (a) ( f ind z such that Q [a; z] where Q [a; z] is a sentence of the background theory. Function f should be synthesized in a procedure of theorem proving. <p> Although most cases can satisfy these requirements, and in some cases these requirements can be weakened, these requirements, any way, will restrict the application range of this method. Another problem is that skills are needed in inferences for improving efficiency. Compared to the deductive-tableau method <ref> [14] </ref>, where a proof in syntax of the first-order logic is required to be constructed in an intelligent strategy [44], the method presented in this 2.5. CONCLUSION 27 thesis constructs a program from the process of semantically proving the specification.
Reference: [15] <author> A.W. Biermann, B.W. Ballard, </author> <title> Towards natural language programming, </title> <journal> American Journal of Computational Linguistics, Vol.6, No.2, Apr.1980. </journal> <volume> 101 102 BIBLIOGRAPHY </volume>
Reference-contexts: For examples, deductive synthesis [14] can not be used to solve equations; knowledge based methods <ref> [15] </ref> are restricted by the number of heuristic rules; transformational approaches [16] depend on the quality and number of transformation rules, etc. 1.3. SEMANTICS 5 It seems excessive to demand the latter problem being completely solved.
Reference: [16] <author> F.L. Bauer et.al. </author> <title> The Munich Project CIP, Vol.1: The wide spectrum language CIP-L, </title> <publisher> LNCS 183, </publisher> <year> 1985. </year>
Reference-contexts: For examples, deductive synthesis [14] can not be used to solve equations; knowledge based methods [15] are restricted by the number of heuristic rules; transformational approaches <ref> [16] </ref> depend on the quality and number of transformation rules, etc. 1.3. SEMANTICS 5 It seems excessive to demand the latter problem being completely solved. But the necessity to solve the former one cannot be overemphasized if we want to reach a practical automating software design system. <p> INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory [41, 42], algebraic specification [43], program transformation <ref> [16] </ref>, deductive synthesis [14, 44], term rewriting system [45, 46, 47], and other methods in automatic software engineering [48, 49, 50, 51, 52], automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53, 54], and details of parallel architectures have
Reference: [17] <author> E.Y. Shapiro, </author> <title> Inductive inference of theories from facts, </title> <type> Report 192, </type> <institution> Dept. of Computer Science, Yale University (Feb. </institution> <year> 1981) </year>
Reference-contexts: Let us highlight two barriers in reaching this goal: * There is no a straightforward way to bridge descriptive specifications and operational ones. For example, first-order formulas, unless in some elaberately arranged recursive forms (e.g., as those studied in learning systems <ref> [17] </ref>), is hard to be mapped to programs directly; * The target programs are even harder to construct when efficiency is considered. Therefore correctness and efficiency issues are separated in program constructions [18, 19]. In Gamma language, the classical method proposed by J.-P. Ban^atre and D.
Reference: [18] <author> K.M. Chandy, & J. Misra, </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Therefore correctness and efficiency issues are separated in program constructions <ref> [18, 19] </ref>. In Gamma language, the classical method proposed by J.-P. Ban^atre and D. Le Metayer [1, 20] is to decompose the specification into an invariant and a termination condition. The program is synthesized by deduction to meet the termination condition while keeping the invariant satisfied. <p> As a matter of fact, HoGamma (and thus Cham) can be expressed within Gamma, as shown in this thesis. The result can be regarded as an implementation method of HoGamma (and Cham). 1.4.2 Program transformation from Gamma to Unity On expressivity of Gamma and Unity Unity model <ref> [18, 19] </ref> is similar to Gamma and share the same properties of Gamma. But contrast to Gamma, Unity is more alike a conventional programming language. <p> However, efficiency of implementing them on message-passing (MP) environments can also be satisfiable when appropriate techniques are used <ref> [3, 18] </ref>. We implement Gamma and Unity on a MP-machine, Dawning-1000. For a given problem, we can write a Gamma program and a Unity one separately. The experiments show that running a Gamma program is usually more time-consuming than running its Unity counterpart. <p> However, efficiency of implementing them on message-passing (MP) environments can also be satisfiable when appropriate techniques are used <ref> [3, 18] </ref>. We implement Gamma and Unity on a MP-machine, Dawning-1000. For a given problem, we can write a Gamma program and a Unity one seperately. The experiments show that running a Gamma program is usually more time-consuming than running its Unity counterpart. <p> To ensure that all possible tuple combinations are tested, the technique used in the Connection Machine [40] is refered to. Table 7.3 shows the experimental results of implementing Gamma program sort on Dawning-1000. 7.6.2 A Unity program The follow is a Unity program of sorting constructed in Unity Logic <ref> [18] </ref>. program sort assign &lt; []i : 1i &lt; n :: a [i]; a [i + 1] := min (a [i]; a [i + 1]); max (a [i]; a [i + 1]) end fsortg The implementation of Unity involves distributing variables among processors and executing the program on each data segment.
Reference: [19] <author> J. Misra, </author> <title> A foundation of parallel programming, </title> <editor> M. Broy (Ed.), </editor> <booktitle> Constructive Methods in Computing Science, NATO ASI Series, Vol.F55, </booktitle> <pages> 397-443, </pages> <year> 1989. </year>
Reference-contexts: Therefore correctness and efficiency issues are separated in program constructions <ref> [18, 19] </ref>. In Gamma language, the classical method proposed by J.-P. Ban^atre and D. Le Metayer [1, 20] is to decompose the specification into an invariant and a termination condition. The program is synthesized by deduction to meet the termination condition while keeping the invariant satisfied. <p> As a matter of fact, HoGamma (and thus Cham) can be expressed within Gamma, as shown in this thesis. The result can be regarded as an implementation method of HoGamma (and Cham). 1.4.2 Program transformation from Gamma to Unity On expressivity of Gamma and Unity Unity model <ref> [18, 19] </ref> is similar to Gamma and share the same properties of Gamma. But contrast to Gamma, Unity is more alike a conventional programming language. <p> Following is the document of function M Unity in denotational style <ref> [10, 19] </ref>: M Unity : U nity ! Gamma M Unity [u] 4 = Gamma (M Statement list [u]) M Statement list : Statement list ! L list M Statement list [sl] 4 = over sl apply M Statement combine 00 + + 00 empty &lt;&gt; end M Statement : Statement
Reference: [20] <author> L. Mussat, </author> <title> Parallel programming with bags, </title> <booktitle> Proc. Workshop on Research Directions in High-Level Parallel Programming Languages, Mont-Saint Michel, 1991, </booktitle> <publisher> Springer-Verlag, LNCS 574, </publisher> <pages> 219-230. </pages>
Reference-contexts: Therefore correctness and efficiency issues are separated in program constructions [18, 19]. In Gamma language, the classical method proposed by J.-P. Ban^atre and D. Le Metayer <ref> [1, 20] </ref> is to decompose the specification into an invariant and a termination condition. The program is synthesized by deduction to meet the termination condition while keeping the invariant satisfied. <p> This thesis proposes a method for derivation of Gamma programs by verifying the program specification in first-order logic, as an other dimension from the classical method consisting in decomposing the specification into an invariant and a termination condition <ref> [1, 20] </ref>. In Section 2.2, we introduce logical specifications and transformations in specification level. In Section 2.3, we describe the method of constructing verification programs from specifications.
Reference: [21] <author> B. Quan, W. Chen, and C. Jin, </author> <title> Automatic programming with proving algorithm, </title> <institution> Technical report of Jilin University, </institution> <year> 1995. </year>
Reference-contexts: The program is designed under the guidance of the invariant and the variant rather than derived out directly from the specification. And much skill is need in figuring out the invariant and variant. In <ref> [21, 22] </ref>, a method for constructing programs from first-order specifications is proposed. The method constructs a semantic verification program for a specification. Few syntactic derivation is needed in constructing the program. A method for improving efficiency is presented in [23].
Reference: [22] <author> H. Lin, Y. Chen, and M. Wang, </author> <title> Synthesizing Gamma program from first-order specification, </title> <booktitle> Proc. the Second Chinese World Congress on Intelligent Control and Intelligent Automation (CWC ICIA'97), Xian, </booktitle> <address> China, </address> <month> June 23-27, </month> <year> 1997, </year> <note> to appear. </note>
Reference-contexts: The program is designed under the guidance of the invariant and the variant rather than derived out directly from the specification. And much skill is need in figuring out the invariant and variant. In <ref> [21, 22] </ref>, a method for constructing programs from first-order specifications is proposed. The method constructs a semantic verification program for a specification. Few syntactic derivation is needed in constructing the program. A method for improving efficiency is presented in [23].
Reference: [23] <author> J. Cai and R. Paige, </author> <title> Program derivation by fixed point computation, </title> <journal> SCP, </journal> <volume> 11:3, </volume> <pages> pp. 197-261, </pages> <year> 1989. </year>
Reference-contexts: In [21, 22], a method for constructing programs from first-order specifications is proposed. The method constructs a semantic verification program for a specification. Few syntactic derivation is needed in constructing the program. A method for improving efficiency is presented in <ref> [23] </ref>. Related works include RAPTS system based on the SETL language and derivation techniques based on "generate-and-test" algorithms [24, 25, 26, 27, 28]. In these techniques, parallelism, however, is not so emphasized, This thesis gives a framework to unify methods for constructing programs and improving efficiency.
Reference: [24] <author> R. Paige and F. Henglein, </author> <title> Mechanical translation of set theoretic problem specifications into efficient RAM code a case study, </title> <journal> Journal of Symbolic Computation, </journal> <volume> 4:2, </volume> <pages> pp. 207-232, </pages> <year> 1987. </year>
Reference-contexts: The method constructs a semantic verification program for a specification. Few syntactic derivation is needed in constructing the program. A method for improving efficiency is presented in [23]. Related works include RAPTS system based on the SETL language and derivation techniques based on "generate-and-test" algorithms <ref> [24, 25, 26, 27, 28] </ref>. In these techniques, parallelism, however, is not so emphasized, This thesis gives a framework to unify methods for constructing programs and improving efficiency. Parallelism is emphasized in program construction.
Reference: [25] <author> A. Kaldewaij and B. Schoenmakers, </author> <title> Searching by elimination, </title> <journal> SCP, </journal> <volume> 14, </volume> <pages> pp. 243-254, </pages> <year> 1990. </year>
Reference-contexts: The method constructs a semantic verification program for a specification. Few syntactic derivation is needed in constructing the program. A method for improving efficiency is presented in [23]. Related works include RAPTS system based on the SETL language and derivation techniques based on "generate-and-test" algorithms <ref> [24, 25, 26, 27, 28] </ref>. In these techniques, parallelism, however, is not so emphasized, This thesis gives a framework to unify methods for constructing programs and improving efficiency. Parallelism is emphasized in program construction.
Reference: [26] <author> D.R. Smith and M.R. Lowry, </author> <title> Algorithm theories and design tactics, </title> <journal> SCP, </journal> <volume> 14, </volume> <pages> pp. 305-321, </pages> <year> 1990. </year>
Reference-contexts: The method constructs a semantic verification program for a specification. Few syntactic derivation is needed in constructing the program. A method for improving efficiency is presented in [23]. Related works include RAPTS system based on the SETL language and derivation techniques based on "generate-and-test" algorithms <ref> [24, 25, 26, 27, 28] </ref>. In these techniques, parallelism, however, is not so emphasized, This thesis gives a framework to unify methods for constructing programs and improving efficiency. Parallelism is emphasized in program construction.
Reference: [27] <author> D.R. Smith, KIDS: </author> <title> a semi-automatic program development system, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 16:9, </volume> <pages> pp. 1024-1043, </pages> <year> 1990. </year>
Reference-contexts: The method constructs a semantic verification program for a specification. Few syntactic derivation is needed in constructing the program. A method for improving efficiency is presented in [23]. Related works include RAPTS system based on the SETL language and derivation techniques based on "generate-and-test" algorithms <ref> [24, 25, 26, 27, 28] </ref>. In these techniques, parallelism, however, is not so emphasized, This thesis gives a framework to unify methods for constructing programs and improving efficiency. Parallelism is emphasized in program construction.
Reference: [28] <author> H. Lin, </author> <title> Synthesizing loop structure in JOOADL formalism, Application and Software of Computer, </title> <note> to appear. </note>
Reference-contexts: The method constructs a semantic verification program for a specification. Few syntactic derivation is needed in constructing the program. A method for improving efficiency is presented in [23]. Related works include RAPTS system based on the SETL language and derivation techniques based on "generate-and-test" algorithms <ref> [24, 25, 26, 27, 28] </ref>. In these techniques, parallelism, however, is not so emphasized, This thesis gives a framework to unify methods for constructing programs and improving efficiency. Parallelism is emphasized in program construction.
Reference: [29] <author> M. Reynolds, </author> <title> Temporal semantics for Gamma, </title> <editor> in: J.M. Andresli, and C. Hankin (eds.), </editor> <title> Coordination Programming: Mechanisms, Models and Semantics, </title> <publisher> Imperial College Press, </publisher> <year> 1996, </year> <note> to appear. </note>
Reference-contexts: Efficiency issues can be dealt with in a totally separated phase and framework of the program need not be changed in reforming the program. 1.3 Semantics 1.3.1 Temporal semantics Studies in semantics of Gamma are currently in themes of operational semantics [9, 10, 7] and temporal semantics <ref> [29, 30] </ref>. Temporal logics are very useful to reason about temporal properties such as safety and liveness, and thus are widely used in program specification and verification [31, 32]. Recently, temporal logic has been used to provide the temporal semantics to a Gamma programs [33, 34, 35, 36].
Reference: [30] <author> L. Errington, C.L. Hankin and T.P. Jensen, </author> <title> Reasoning about Gamma programs, </title> <booktitle> Proc. of the First Workshop on Theory and Formal Methods, </booktitle> <institution> Imperial College, Department of Computing, </institution> <note> Workshops in Computing, Springer-Verlag, </note> <year> 1993. </year>
Reference-contexts: Efficiency issues can be dealt with in a totally separated phase and framework of the program need not be changed in reforming the program. 1.3 Semantics 1.3.1 Temporal semantics Studies in semantics of Gamma are currently in themes of operational semantics [9, 10, 7] and temporal semantics <ref> [29, 30] </ref>. Temporal logics are very useful to reason about temporal properties such as safety and liveness, and thus are widely used in program specification and verification [31, 32]. Recently, temporal logic has been used to provide the temporal semantics to a Gamma programs [33, 34, 35, 36].
Reference: [31] <author> E.A. Emerson, </author> <title> Temporal and modal logic. </title> <editor> in: J. van Leeuwen (Ed.), </editor> <booktitle> Handbook of Theoretical Computer Science: Formal Models and Semantics, </booktitle> <volume> Vol. </volume> <editor> B, </editor> <publisher> Elsevier, The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Temporal logics are very useful to reason about temporal properties such as safety and liveness, and thus are widely used in program specification and verification <ref> [31, 32] </ref>. Recently, temporal logic has been used to provide the temporal semantics to a Gamma programs [33, 34, 35, 36]. In this thesis, a more precise temporal semantics is presented. The temporal semantics of a Gamma program is defined by logic specification (a set of temporal logic formulas).
Reference: [32] <author> Z. Manna and A. Pnueli, </author> <title> The temporal logic of reactive and concurrent systems: specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Temporal logics are very useful to reason about temporal properties such as safety and liveness, and thus are widely used in program specification and verification <ref> [31, 32] </ref>. Recently, temporal logic has been used to provide the temporal semantics to a Gamma programs [33, 34, 35, 36]. In this thesis, a more precise temporal semantics is presented. The temporal semantics of a Gamma program is defined by logic specification (a set of temporal logic formulas).
Reference: [33] <author> W. Ma, E.V. Krishnamurthy, and M.A. Orgun, </author> <title> On providing temporal semantics for the Gamma programming model, </title> <editor> in: C. Barry Jay (ed.), CATS: </editor> <booktitle> Proc. Computing: the Australian Theory Seminar, </booktitle> <pages> pp. 121-132, </pages> <year> 1994. </year> <note> BIBLIOGRAPHY 103 </note>
Reference-contexts: Temporal logics are very useful to reason about temporal properties such as safety and liveness, and thus are widely used in program specification and verification [31, 32]. Recently, temporal logic has been used to provide the temporal semantics to a Gamma programs <ref> [33, 34, 35, 36] </ref>. In this thesis, a more precise temporal semantics is presented. The temporal semantics of a Gamma program is defined by logic specification (a set of temporal logic formulas). <p> We prove the accordance between operational semantics and temporal semantics for Gamma. 1.3.2 Categorical semantics Categorical semantics for Gamma Although operational semantics and temporal semantics make reasoning about properties of Gamma programs feasible <ref> [33, 34, 35, 36] </ref>, we still are lack of a unified model of Gamma semantics with sought-after succinct and expressive notions. In this thesis, categorical semantics of Gamma programs are proposed [37]. <p> PROGRAM SYNTHESIS FOR GAMMA Chapter 3 Temporal semantics 3.1 Introduction This thesis uses the discrete linear temporal logic to specify the semantics of the Gamma languages. This work is an elaboration on the initial work in <ref> [33, 34] </ref>. The semantic specification presented here is in total congruence to the computation sequence of the corresponding program. Operational semantics and temporal semantics of Gamma are presented in Section 3.2 and Section 3.3 respectively.
Reference: [34] <author> W. Ma, and M. Orgun, </author> <title> Verifying Multran programs with temporal logic, </title> <booktitle> Proc. the 8th Int'l Symposium on Languages for Intensional Programming (ISLIP'95), World-Scientific, </booktitle> <pages> pp. 120-134, </pages> <year> 1995. </year>
Reference-contexts: Temporal logics are very useful to reason about temporal properties such as safety and liveness, and thus are widely used in program specification and verification [31, 32]. Recently, temporal logic has been used to provide the temporal semantics to a Gamma programs <ref> [33, 34, 35, 36] </ref>. In this thesis, a more precise temporal semantics is presented. The temporal semantics of a Gamma program is defined by logic specification (a set of temporal logic formulas). <p> We prove the accordance between operational semantics and temporal semantics for Gamma. 1.3.2 Categorical semantics Categorical semantics for Gamma Although operational semantics and temporal semantics make reasoning about properties of Gamma programs feasible <ref> [33, 34, 35, 36] </ref>, we still are lack of a unified model of Gamma semantics with sought-after succinct and expressive notions. In this thesis, categorical semantics of Gamma programs are proposed [37]. <p> PROGRAM SYNTHESIS FOR GAMMA Chapter 3 Temporal semantics 3.1 Introduction This thesis uses the discrete linear temporal logic to specify the semantics of the Gamma languages. This work is an elaboration on the initial work in <ref> [33, 34] </ref>. The semantic specification presented here is in total congruence to the computation sequence of the corresponding program. Operational semantics and temporal semantics of Gamma are presented in Section 3.2 and Section 3.3 respectively.
Reference: [35] <author> H. Lin, and M. Wang, </author> <title> Axiomatizing semantics of Gamma programs, </title> <booktitle> Proc. Hongkong-Chengdu Int'l Computer Conf. </booktitle> <address> (HCICC'96), Chengdu, China, Oct.23-24, </address> <year> 1996, </year> <month> pp.318-316. </month>
Reference-contexts: Temporal logics are very useful to reason about temporal properties such as safety and liveness, and thus are widely used in program specification and verification [31, 32]. Recently, temporal logic has been used to provide the temporal semantics to a Gamma programs <ref> [33, 34, 35, 36] </ref>. In this thesis, a more precise temporal semantics is presented. The temporal semantics of a Gamma program is defined by logic specification (a set of temporal logic formulas). <p> We prove the accordance between operational semantics and temporal semantics for Gamma. 1.3.2 Categorical semantics Categorical semantics for Gamma Although operational semantics and temporal semantics make reasoning about properties of Gamma programs feasible <ref> [33, 34, 35, 36] </ref>, we still are lack of a unified model of Gamma semantics with sought-after succinct and expressive notions. In this thesis, categorical semantics of Gamma programs are proposed [37].
Reference: [36] <author> H. Lin, and M. Wang, </author> <title> On Gamma semantics, </title> <institution> Computer Engineering & Science, Vol.18, No.4, </institution> <year> 1996, </year> <month> pp7-15. </month>
Reference-contexts: Temporal logics are very useful to reason about temporal properties such as safety and liveness, and thus are widely used in program specification and verification [31, 32]. Recently, temporal logic has been used to provide the temporal semantics to a Gamma programs <ref> [33, 34, 35, 36] </ref>. In this thesis, a more precise temporal semantics is presented. The temporal semantics of a Gamma program is defined by logic specification (a set of temporal logic formulas). <p> We prove the accordance between operational semantics and temporal semantics for Gamma. 1.3.2 Categorical semantics Categorical semantics for Gamma Although operational semantics and temporal semantics make reasoning about properties of Gamma programs feasible <ref> [33, 34, 35, 36] </ref>, we still are lack of a unified model of Gamma semantics with sought-after succinct and expressive notions. In this thesis, categorical semantics of Gamma programs are proposed [37].
Reference: [37] <author> H. Lin, Y. Chen, and M. Wang, </author> <title> Categorical semantics of Gamma, </title> <booktitle> Proc. 17th International Conference on Computer Processing of Oriental Languages, </booktitle> <address> Hong Kong, </address> <month> April 2-4, </month> <year> 1997, </year> <note> to appear. </note>
Reference-contexts: In this thesis, categorical semantics of Gamma programs are proposed <ref> [37] </ref>. We find this semantic framework highly descriptive: behaviors of programs can be described in categorical semantic models, with their relationships (orderings and equivalence) reflected with functor; composition 6 CHAPTER 1.
Reference: [38] <author> H. Lin, G. Chen, and M. Wang, </author> <title> Flattening Higher-Order Gamma, </title> <journal> Chinese Journal of Advanced Software Research, </journal> <note> to appear. </note>
Reference-contexts: It will be shown that programs in higher-order Gamma can be transformed to ones in Gamma <ref> [38] </ref>; and Gamma programs can be further transformed to Unity ones [39]. It is well-known that an efficient implementation for Gamma is a hard issue [40].
Reference: [39] <author> H. Lin, G. Chen, and M. Wang, </author> <title> Program transformation from Unity to Gamma based on temporal semantics, Neural, Parallel, and Scientific Computations, </title> <note> to appear. </note>
Reference-contexts: It will be shown that programs in higher-order Gamma can be transformed to ones in Gamma [38]; and Gamma programs can be further transformed to Unity ones <ref> [39] </ref>. It is well-known that an efficient implementation for Gamma is a hard issue [40]. The techniques presented here will, however, show their effect in improving the efficiency of the programs. 1.4.1 Flattening higher-order Gamma Higher-order Gamma (written HoGamma in this thesis) unifies the program and data syntactic categories.
Reference: [40] <author> C. Creveuil, </author> <title> Implementation of Gamma on the Connection Machine, </title> <booktitle> Proc. Workshop on Research Directions in High-Level Parallel Programming Languages, Mont-Saint Michel, 1991, </booktitle> <publisher> Springer-Verlag, LNCS 574, </publisher> <pages> 219-230. </pages>
Reference-contexts: It will be shown that programs in higher-order Gamma can be transformed to ones in Gamma [38]; and Gamma programs can be further transformed to Unity ones [39]. It is well-known that an efficient implementation for Gamma is a hard issue <ref> [40] </ref>. The techniques presented here will, however, show their effect in improving the efficiency of the programs. 1.4.1 Flattening higher-order Gamma Higher-order Gamma (written HoGamma in this thesis) unifies the program and data syntactic categories. <p> However, implementing Gamma in existing running environments is still the main trend of research on this topic and improvement of efficiency of the programs is the central issue [76]. Gamma has been implemented on Connection Machine <ref> [40] </ref>, Intel iPSC2 [74, 75], and Maspar [77, 78]. Because Gamma language is more descriptive than Unity language. We are to discuss the method of implementing Gamma by Unity and study the effect of this method for efficiency improvement. <p> The implementation is more natural on machines with shared memory than on ones with distributed memory, because Gamma is suitable for describing data parallelism <ref> [40] </ref> and Unity is in shared variable paradigm. However, efficiency of implementing them on message-passing (MP) environments can also be satisfiable when appropriate techniques are used [3, 18]. We implement Gamma and Unity on a MP-machine, Dawning-1000. <p> The tuple exchange process passes local tuples to the next processor. The processors are assumed to form a ring. These two processes go on until no more possible reaction exists. To ensure that all possible tuple combinations are tested, the technique used in the Connection Machine <ref> [40] </ref> is refered to. <p> An essential profit of the translation is to make the data structure "explicit", thus fuels tactic arrangements of the evaluation. This approach is better than directly implementiny Gamma on concrete architecture, e.g., on the Connection Machine <ref> [40] </ref> (there, strong assumptions on forms of (R; A) pairs are made). * Unity Logic and the corresponding refinement methodology can be applied to derivation of an efficient final code. Techniques for "detection of neighborhood relationships" [3] can be used in the derivation.
Reference: [41] <author> P. Martin-Lof, </author> <title> Intuitionistic type theory, Notes by Giovanni Sambin of a series of lectures given in Padua, </title> <month> June </month> <year> 1980, </year> <pages> Bibliopolis. </pages>
Reference-contexts: INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory <ref> [41, 42] </ref>, algebraic specification [43], program transformation [16], deductive synthesis [14, 44], term rewriting system [45, 46, 47], and other methods in automatic software engineering [48, 49, 50, 51, 52], automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53,
Reference: [42] <author> C. Aarts, et al., </author> <title> A relational theory of datatypes, </title> <type> Technical report, </type> <institution> Utrecht University, </institution> <address> the Netherlands, </address> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory <ref> [41, 42] </ref>, algebraic specification [43], program transformation [16], deductive synthesis [14, 44], term rewriting system [45, 46, 47], and other methods in automatic software engineering [48, 49, 50, 51, 52], automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53,
Reference: [43] <author> H. Ehrig and B. Mahr, </author> <title> Fundamentals of Algebraic Specification, </title> <editor> W. Brauer, G. Rozenberg and A. Salomaa (eds.), </editor> <booktitle> EATCS Monographs on Theoretical Computer Science, </booktitle> <volume> Vol. 21, </volume> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory [41, 42], algebraic specification <ref> [43] </ref>, program transformation [16], deductive synthesis [14, 44], term rewriting system [45, 46, 47], and other methods in automatic software engineering [48, 49, 50, 51, 52], automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53, 54], and details of
Reference: [44] <author> J. Traugott, </author> <title> Deductive synthesis of sorting programs, </title> <journal> Journal of Symbolic Computation, </journal> <volume> Vol. 7, </volume> <year> 1989, </year> <pages> pp. 533-572. </pages>
Reference-contexts: INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory [41, 42], algebraic specification [43], program transformation [16], deductive synthesis <ref> [14, 44] </ref>, term rewriting system [45, 46, 47], and other methods in automatic software engineering [48, 49, 50, 51, 52], automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53, 54], and details of parallel architectures have to be considered <p> Another problem is that skills are needed in inferences for improving efficiency. Compared to the deductive-tableau method [14], where a proof in syntax of the first-order logic is required to be constructed in an intelligent strategy <ref> [44] </ref>, the method presented in this 2.5. CONCLUSION 27 thesis constructs a program from the process of semantically proving the specification. The process follows a general routine and does not need much efforts in constructing the proof.
Reference: [45] <author> J.W. Klop, </author> <title> Term rewriting systems, </title> <editor> in: S. Abramsky, D. Gabbay, and T. Maibaum (eds.), </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> Vol. 1, </volume> <publisher> Oxford University Press, </publisher> <year> 1990. </year>
Reference-contexts: INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory [41, 42], algebraic specification [43], program transformation [16], deductive synthesis [14, 44], term rewriting system <ref> [45, 46, 47] </ref>, and other methods in automatic software engineering [48, 49, 50, 51, 52], automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53, 54], and details of parallel architectures have to be considered when efficiency of the programs <p> In other words, g is confluent if given any state ! fl satisfies the diamond property <ref> [45] </ref>. The diamond property is quite strong and will not hold in general. <p> By appealing to Newman's Lemma <ref> [45] </ref>, we have W cr (g; M ) ^ &lt; g; M &gt;# must ) Con (g; M ) or W cr (g) ^ g # must ) Con (g) Proposition 4.6 (Properties of confluence) 1.
Reference: [46] <author> J. Meseguer, </author> <title> Conditional rewriting logic as a unified model of concurrency, </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 96, </volume> <pages> pp. 73-155, </pages> <year> 1992. </year>
Reference-contexts: INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory [41, 42], algebraic specification [43], program transformation [16], deductive synthesis [14, 44], term rewriting system <ref> [45, 46, 47] </ref>, and other methods in automatic software engineering [48, 49, 50, 51, 52], automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53, 54], and details of parallel architectures have to be considered when efficiency of the programs <p> To deal with these difficulties, a wide-spectrum logic framework, as well as a high-level programming language such as Gamma, should be developped. Gamma is a special kind of rewriting system <ref> [46] </ref>. It should be straightforward to construct Gamma programs from rewriting logic. If we can bridge first-order predicate logic and rewriting logic, we should be able to do better in this field. 28 CHAPTER 2. <p> D g 1 ffi (D g 2 + D g 3 ) v (D g 1 ffi D g 2 ) + (D g 1 ffi D g 3 ). 2 4.4 Related and future work The computation model of Gamma is closely related to conditional term rewriting <ref> [9, 46, 47] </ref>. In [46, 47], Gamma is considered as a speciality of concurrent rewriting logic. Therefore, categorical semantics for rewriting logic can be specialized to Gamma. <p> In <ref> [46, 47] </ref>, Gamma is considered as a speciality of concurrent rewriting logic. Therefore, categorical semantics for rewriting logic can be specialized to Gamma.
Reference: [47] <author> J. Meseguer, and T. Winkler, </author> <title> Parallel programming in Maude, </title> <editor> in: J.-P. Ban^atre, and D. Le Metayer (eds.), </editor> <booktitle> Proc. of the Workshop on Research Directions in High-level Parallel Programming Languages, </booktitle> <address> Mont Saint-Michel, France, June 1991, </address> <publisher> Springer-Verlag, </publisher> <pages> pp. 253-293. </pages>
Reference-contexts: INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory [41, 42], algebraic specification [43], program transformation [16], deductive synthesis [14, 44], term rewriting system <ref> [45, 46, 47] </ref>, and other methods in automatic software engineering [48, 49, 50, 51, 52], automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53, 54], and details of parallel architectures have to be considered when efficiency of the programs <p> D g 1 ffi (D g 2 + D g 3 ) v (D g 1 ffi D g 2 ) + (D g 1 ffi D g 3 ). 2 4.4 Related and future work The computation model of Gamma is closely related to conditional term rewriting <ref> [9, 46, 47] </ref>. In [46, 47], Gamma is considered as a speciality of concurrent rewriting logic. Therefore, categorical semantics for rewriting logic can be specialized to Gamma. <p> In <ref> [46, 47] </ref>, Gamma is considered as a speciality of concurrent rewriting logic. Therefore, categorical semantics for rewriting logic can be specialized to Gamma.
Reference: [48] <author> Y. Feng, C. Zhong and Y. Chen, </author> <title> Programming Methodology, </title> <institution> Beijing Science and Technology Publishing House, </institution> <year> 1989. </year>
Reference-contexts: INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory [41, 42], algebraic specification [43], program transformation [16], deductive synthesis [14, 44], term rewriting system [45, 46, 47], and other methods in automatic software engineering <ref> [48, 49, 50, 51, 52] </ref>, automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53, 54], and details of parallel architectures have to be considered when efficiency of the programs is to be improved [55].
Reference: [49] <editor> D. Gries, </editor> <booktitle> The Science of Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory [41, 42], algebraic specification [43], program transformation [16], deductive synthesis [14, 44], term rewriting system [45, 46, 47], and other methods in automatic software engineering <ref> [48, 49, 50, 51, 52] </ref>, automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53, 54], and details of parallel architectures have to be considered when efficiency of the programs is to be improved [55].
Reference: [50] <editor> C.E. Hackl (ed.), </editor> <booktitle> Programming Methodology, 4th Informatik Symposium, </booktitle> <institution> IBM Germany Wild-bad, </institution> <month> Sep. </month> <pages> 25-27, </pages> <year> 1974, </year> <editor> G. Goos and J. Hartmanis (eds.), </editor> <volume> LNCS 23. </volume> <pages> 104 BIBLIOGRAPHY </pages>
Reference-contexts: INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory [41, 42], algebraic specification [43], program transformation [16], deductive synthesis [14, 44], term rewriting system [45, 46, 47], and other methods in automatic software engineering <ref> [48, 49, 50, 51, 52] </ref>, automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53, 54], and details of parallel architectures have to be considered when efficiency of the programs is to be improved [55].
Reference: [51] <editor> R.T. Yeh, (ed.), </editor> <booktitle> Current Trends in Programming Methodology, Vol. IV: Data Structuring, </booktitle> <publisher> Prentice-Hall Inc., </publisher> <year> 1978. </year>
Reference-contexts: INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory [41, 42], algebraic specification [43], program transformation [16], deductive synthesis [14, 44], term rewriting system [45, 46, 47], and other methods in automatic software engineering <ref> [48, 49, 50, 51, 52] </ref>, automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53, 54], and details of parallel architectures have to be considered when efficiency of the programs is to be improved [55].
Reference: [52] <editor> P.J.L. Wallis (ed.), </editor> <booktitle> Software Engineering: Developments, </booktitle> <publisher> Pergamon Infotech Ltd., </publisher> <year> 1983. </year>
Reference-contexts: INTRODUCTION Chapter 2 Program synthesis for Gamma 2.1 Introduction In contrast to classical methods for constructing sequential programs: type theory [41, 42], algebraic specification [43], program transformation [16], deductive synthesis [14, 44], term rewriting system [45, 46, 47], and other methods in automatic software engineering <ref> [48, 49, 50, 51, 52] </ref>, automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53, 54], and details of parallel architectures have to be considered when efficiency of the programs is to be improved [55].
Reference: [53] <author> L.G. Valiant, </author> <title> A bridging model for parallel computation, </title> <journal> CACM, </journal> <volume> Vol. 33, No. 8, </volume> <month> Aug. </month> <year> 1990, </year> <pages> pp. 103-111. </pages>
Reference-contexts: [41, 42], algebraic specification [43], program transformation [16], deductive synthesis [14, 44], term rewriting system [45, 46, 47], and other methods in automatic software engineering [48, 49, 50, 51, 52], automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency <ref> [53, 54] </ref>, and details of parallel architectures have to be considered when efficiency of the programs is to be improved [55]. The irregularity and dynamic property of control parallelism, which is manifested in the form of "parallel of sequence", is considered harmful to programming [56, 57].
Reference: [54] <author> D. Culler, et al., </author> <title> LogP: towards a realistic model of parallel computation, </title> <booktitle> 4th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: [41, 42], algebraic specification [43], program transformation [16], deductive synthesis [14, 44], term rewriting system [45, 46, 47], and other methods in automatic software engineering [48, 49, 50, 51, 52], automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency <ref> [53, 54] </ref>, and details of parallel architectures have to be considered when efficiency of the programs is to be improved [55]. The irregularity and dynamic property of control parallelism, which is manifested in the form of "parallel of sequence", is considered harmful to programming [56, 57].
Reference: [55] <author> R. Paige, J. Reif and R. Wachter (eds.), </author> <title> Parallel Algorithm Derivation and Program Transformation, </title> <booktitle> The Kluwer International Series in Engineering and Computer Science, </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: methods in automatic software engineering [48, 49, 50, 51, 52], automatic parallel programming is a much harder issue, because there is not a unified computation model for parallelism and concurrency [53, 54], and details of parallel architectures have to be considered when efficiency of the programs is to be improved <ref> [55] </ref>. The irregularity and dynamic property of control parallelism, which is manifested in the form of "parallel of sequence", is considered harmful to programming [56, 57]. Functional programming [58], which aims at developping data parallelism, has elegant mathematical properties and is suitable for program derivation [59, 60].
Reference: [56] <author> L. Bouge, </author> <title> The data-parallel programming model: a semantic perspective, </title> <institution> Research Report No-92-45, LIP, France, </institution> <year> 1992. </year>
Reference-contexts: The irregularity and dynamic property of control parallelism, which is manifested in the form of "parallel of sequence", is considered harmful to programming <ref> [56, 57] </ref>. Functional programming [58], which aims at developping data parallelism, has elegant mathematical properties and is suitable for program derivation [59, 60]. Gamma can be considered a functional style high-level programming language and suitable to describe data parallelism [61].
Reference: [57] <author> W. Yuan, </author> <title> Structured Parallel Functional Programming|Model, Language and Implementation, </title> <institution> Graduate dissertation, Shanghai Jiaotong University, </institution> <year> 1995. </year>
Reference-contexts: The irregularity and dynamic property of control parallelism, which is manifested in the form of "parallel of sequence", is considered harmful to programming <ref> [56, 57] </ref>. Functional programming [58], which aims at developping data parallelism, has elegant mathematical properties and is suitable for program derivation [59, 60]. Gamma can be considered a functional style high-level programming language and suitable to describe data parallelism [61].
Reference: [58] <author> B.J. MacLennan, </author> <title> Functional Programming|Practice and Theory, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1990. </year>
Reference-contexts: The irregularity and dynamic property of control parallelism, which is manifested in the form of "parallel of sequence", is considered harmful to programming [56, 57]. Functional programming <ref> [58] </ref>, which aims at developping data parallelism, has elegant mathematical properties and is suitable for program derivation [59, 60]. Gamma can be considered a functional style high-level programming language and suitable to describe data parallelism [61]. The succinctness of the computation model makes parallel program derivation feasible [1].
Reference: [59] <author> J. Backus, </author> <title> Can programming be liberated from the von Neumann style? A functional style and its algebra of programs, </title> <journal> CACM, </journal> <volume> Vol. 21, No. 8, </volume> <year> 1978, </year> <pages> pp. 613-641. </pages>
Reference-contexts: The irregularity and dynamic property of control parallelism, which is manifested in the form of "parallel of sequence", is considered harmful to programming [56, 57]. Functional programming [58], which aims at developping data parallelism, has elegant mathematical properties and is suitable for program derivation <ref> [59, 60] </ref>. Gamma can be considered a functional style high-level programming language and suitable to describe data parallelism [61]. The succinctness of the computation model makes parallel program derivation feasible [1].
Reference: [60] <author> R.S. Bird, </author> <title> Algebraic identities for program calculation, </title> <journal> The Computer Journal, </journal> <volume> Vol. 32, No. 2, </volume> <year> 1989. </year>
Reference-contexts: The irregularity and dynamic property of control parallelism, which is manifested in the form of "parallel of sequence", is considered harmful to programming [56, 57]. Functional programming [58], which aims at developping data parallelism, has elegant mathematical properties and is suitable for program derivation <ref> [59, 60] </ref>. Gamma can be considered a functional style high-level programming language and suitable to describe data parallelism [61]. The succinctness of the computation model makes parallel program derivation feasible [1].
Reference: [61] <author> R. Harrison, </author> <title> Parallel programming with pure functional languages. </title> <editor> in: J.-P. Ban^atre and D. Le Metayer (Eds.), </editor> <booktitle> Proc. of Workshop on Research Directions in High-Level Parallel Programming Languages, </booktitle> <year> 1992. </year>
Reference-contexts: Functional programming [58], which aims at developping data parallelism, has elegant mathematical properties and is suitable for program derivation [59, 60]. Gamma can be considered a functional style high-level programming language and suitable to describe data parallelism <ref> [61] </ref>. The succinctness of the computation model makes parallel program derivation feasible [1]. <p> It is well known that imperative programs show higher efficiency. And implementing Gamma with pure functional programs shows rather limited performance <ref> [61] </ref>. 7.7. CONCLUSION 95 * The translation is suitable for MIMD machine as well as for SIMD machine. An essential profit of the translation is to make the data structure "explicit", thus fuels tactic arrangements of the evaluation.
Reference: [62] <author> L. Lamport, </author> <title> Verification and specification of concurrent programs. </title> <editor> in: J.W. de Bakker, et.al. (Eds.), </editor> <title> A Decade of Concurrency: Reflections and Perspectives, </title> <publisher> LNCS 803, </publisher> <pages> pp. 347-374, </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: For Gamma model, temporal properties of the programs are to be described with semantic specification. Safety properties are expressed by Gamma programs, which will be translated into a set of temporal logic formulas. Temporal logic is very useful to prove liveness properties from the corresponding safety properties <ref> [62] </ref>, usually under the fairness hypothesis. We assume a "fair Gamma", which means all fl-commands in the tuple space have the equal opportunity to be chosen and the choice is atomic. Any fl-command will be infinitely often chosen. The choice gives favor to the currently oldest tuples.
Reference: [63] <author> F. Kroger, </author> <title> Temporal logic of programs. </title> <editor> in: W. Brauer, G. Rozenberg, and A. Salomaa (Eds.), </editor> <booktitle> EATCS Monographs on Theoretical Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Basic temporal operators are 2; 3; fl; U ; W They are not all independent. Actually we can only use fl and W as primitive operators and define 2p = pWf alse 3p = :2:p 4 For notational simplicity we establish a priority order of the operators <ref> [63] </ref>. We list them from the highest to the lowest, operators in same group have the same priority: (1) :, 8, 9, 2, 3, fl; (2) U , W; (3) ^; (4) _; (5) !; (6) $. We use F to denote the set of formulas of temporal logic.
Reference: [64] <author> B. Michael and W. Charles, </author> <title> Category Theory for Computing Science, </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: We prove the accordance between operational semantics and temporal semantics for Gamma. Chapter 4 Categorical semantics of Gamma 4.1 Introduction Category theory <ref> [64, 65] </ref>, with its succinct and descriptive notions, provides a useful tool for semantic description [66]. In this chapter, semantics in category theory for Gamma is presented. This semantics provides a general view on the behaviors of Gamma programs.
Reference: [65] <author> Y. Chen, </author> <booktitle> Category Theory in Computer Science, </booktitle> <publisher> USTC Press, </publisher> <year> 1993. </year>
Reference-contexts: We prove the accordance between operational semantics and temporal semantics for Gamma. Chapter 4 Categorical semantics of Gamma 4.1 Introduction Category theory <ref> [64, 65] </ref>, with its succinct and descriptive notions, provides a useful tool for semantic description [66]. In this chapter, semantics in category theory for Gamma is presented. This semantics provides a general view on the behaviors of Gamma programs.
Reference: [66] <author> T. Huang, </author> <title> On Object Semantics, </title> <institution> Graduate dissertation, University of Science and Technology of China, </institution> <year> 1994. </year>
Reference-contexts: We prove the accordance between operational semantics and temporal semantics for Gamma. Chapter 4 Categorical semantics of Gamma 4.1 Introduction Category theory [64, 65], with its succinct and descriptive notions, provides a useful tool for semantic description <ref> [66] </ref>. In this chapter, semantics in category theory for Gamma is presented. This semantics provides a general view on the behaviors of Gamma programs. It will be shown how the relations between the programs as well as properties of the programs are manifested in their category semantic domain.
Reference: [67] <author> D.W. Barnes and J.M. Mack, </author> <title> An Algebraic Introduction to Mathematical Logic, </title> <year> 1975. </year>
Reference-contexts: Then Section 6.4 proves that HoGamma can be expressed within CoGamma. 6.2 Gamma and Turing Machine Before comparing Gamma to HoGamma, we examine the power of Gamma. Turing Proposition <ref> [67, 68] </ref> says: algorithmic computability equals Turing computability. In other words, if any feasible computation model, say Gamma, is not less powerful than Turing Machine, it is not less powerful than any other computation models. We will show that Gamma is not less powerful than Turing Machine.
Reference: [68] <author> F. Wang, </author> <title> Mathematical Logic: Principles for Discrete Mathematics, Part III, </title> <publisher> USTC Press, </publisher> <year> 1990. </year>
Reference-contexts: Then Section 6.4 proves that HoGamma can be expressed within CoGamma. 6.2 Gamma and Turing Machine Before comparing Gamma to HoGamma, we examine the power of Gamma. Turing Proposition <ref> [67, 68] </ref> says: algorithmic computability equals Turing computability. In other words, if any feasible computation model, say Gamma, is not less powerful than Turing Machine, it is not less powerful than any other computation models. We will show that Gamma is not less powerful than Turing Machine.
Reference: [69] <author> H. Lin, G. Chen and M. Wang, </author> <title> Comparing expressivity of Unity and Gamma, </title> <booktitle> Proc. of China-Italy Workshop on High-Performance Computing, </booktitle> <address> Beijing, China, </address> <month> Oct. </month> <pages> 28-29, </pages> <year> 1996. </year> <note> BIBLIOGRAPHY 105 </note>
Reference-contexts: Thus the expressivity of Gamma is proved more powerful than that of Unity <ref> [69] </ref>. A method for transformation from Gamma to Unity is also presented.
Reference: [70] <author> H. Lin, G. Chen and M. Wang, </author> <title> Implementing Gamma with Unity: an experiment, </title> <booktitle> Proc. of International Workshop on Computational Science and Engineering, </booktitle> <address> Hefei, China, </address> <month> May 27-28, </month> <year> 1997, </year> <note> to appear. </note>
Reference-contexts: An experiment on a typical problem, sorting, is done on a message-passing besed multi-processor environment, Dawning-1000, and the results show that it is beneficial to the efficiency of the program by executing the Unity translation of a Gamma program instead of implementing it directly on the machine <ref> [70] </ref>. The temporal semantic specification of a Gamma program is presented in Chapter 3. Abstract syntax of Gamma is presented in Section 7.2. In Section 7.3, the same formalism of semantic specification is applied to Unity programs, and it is proved congruent with Unity Logic.
Reference: [71] <author> D. A. Schmidt, </author> <title> Denotational Semantics: A Methodology for Languages Development. </title> <publisher> Allyn and Bacon Inc., </publisher> <year> 1986. </year>
Reference-contexts: We conclude the paper in Section 7.7 with some discussion on the implementation of Gamma by Unity. 7.2 Abstract syntax of Gamma and its temporal semantics Program transformation will be defined by denotational functions <ref> [71, 72] </ref>. We present the abstract syntax of the Gamma language first, and then specify its semantics. 7.2.1 Abstract syntax In this chapter, we only consider Gamma with parallel composition operator "+". Sequential composition operator "ffi" and higher-order Gamma are irrelevant.
Reference: [72] <author> Y. Chen, </author> <title> Foundations of Formal Semantics. </title> <publisher> USTC Press, </publisher> <year> 1994. </year>
Reference-contexts: We conclude the paper in Section 7.7 with some discussion on the implementation of Gamma by Unity. 7.2 Abstract syntax of Gamma and its temporal semantics Program transformation will be defined by denotational functions <ref> [71, 72] </ref>. We present the abstract syntax of the Gamma language first, and then specify its semantics. 7.2.1 Abstract syntax In this chapter, we only consider Gamma with parallel composition operator "+". Sequential composition operator "ffi" and higher-order Gamma are irrelevant.
Reference: [73] <author> E.V. Krishnamurthy and V.K. Murthy, </author> <title> Parallel programming paradigm based on multiset transformation. </title> <editor> in: D. Arnold (Ed.), </editor> <booktitle> Parallel Computing and Transputers, PCAT-93, </booktitle> <pages> pp. 43-51, </pages> <publisher> IOS Press, </publisher> <address> Amsterdam, Netherland, </address> <year> 1993. </year>
Reference-contexts: Gamma 4 = L list L list 4 L = rp : T uple list; if : R; by : A R = Expression A = T uple list T uple list 4 = T uple fl T uple 4 = Expression fl Expression 4 = : : :(omitted) types <ref> [73] </ref>. This paper leave this absent, because a direct extension of the program transformation function provided in this paper will convert the variable type declaration into tuple type declaration.
Reference: [74] <author> J.-P. Ban^atre, A. Coutant and D. Le Metayer, </author> <title> A parallel machine for multiset transformation and their programming style, </title> <booktitle> Future Generation Computer Systems, </booktitle> <year> 1988, </year> <pages> pp. 133-144. </pages>
Reference-contexts: ( u 1 ) ffi ) fP roposition 7:12g 0 j= u ffi ) fpremise u ffi 1 ` pg "(" Symmetric to ")". 2 Proposition 7.14 indicates that function M Unity holds local equivalence. 7.5 Implementing Gamma by Unity A special architecture may be established for running Gamma programs <ref> [74, 75] </ref>. However, implementing Gamma in existing running environments is still the main trend of research on this topic and improvement of efficiency of the programs is the central issue [76]. Gamma has been implemented on Connection Machine [40], Intel iPSC2 [74, 75], and Maspar [77, 78]. <p> special architecture may be established for running Gamma programs <ref> [74, 75] </ref>. However, implementing Gamma in existing running environments is still the main trend of research on this topic and improvement of efficiency of the programs is the central issue [76]. Gamma has been implemented on Connection Machine [40], Intel iPSC2 [74, 75], and Maspar [77, 78]. Because Gamma language is more descriptive than Unity language. We are to discuss the method of implementing Gamma by Unity and study the effect of this method for efficiency improvement.
Reference: [75] <author> J.-P. Ban^atre, A. Coutant and D. Le Metayer, </author> <title> Parallel machines for multiset transformation and their programming style, </title> <publisher> Informationstechnik, </publisher> <address> Oldenburg-Verlag, Vol.2/88, </address> <year> 1988, </year> <month> pp.99-109. </month>
Reference-contexts: ( u 1 ) ffi ) fP roposition 7:12g 0 j= u ffi ) fpremise u ffi 1 ` pg "(" Symmetric to ")". 2 Proposition 7.14 indicates that function M Unity holds local equivalence. 7.5 Implementing Gamma by Unity A special architecture may be established for running Gamma programs <ref> [74, 75] </ref>. However, implementing Gamma in existing running environments is still the main trend of research on this topic and improvement of efficiency of the programs is the central issue [76]. Gamma has been implemented on Connection Machine [40], Intel iPSC2 [74, 75], and Maspar [77, 78]. <p> special architecture may be established for running Gamma programs <ref> [74, 75] </ref>. However, implementing Gamma in existing running environments is still the main trend of research on this topic and improvement of efficiency of the programs is the central issue [76]. Gamma has been implemented on Connection Machine [40], Intel iPSC2 [74, 75], and Maspar [77, 78]. Because Gamma language is more descriptive than Unity language. We are to discuss the method of implementing Gamma by Unity and study the effect of this method for efficiency improvement.
Reference: [76] <author> K. Gladitz and H. Kuchen, </author> <title> Parallel implementation of the Gamma-operation on bags, </title> <booktitle> Proc. of the PASCO conference, </booktitle> <address> Linz, Austria, </address> <year> 1994. </year>
Reference-contexts: However, implementing Gamma in existing running environments is still the main trend of research on this topic and improvement of efficiency of the programs is the central issue <ref> [76] </ref>. Gamma has been implemented on Connection Machine [40], Intel iPSC2 [74, 75], and Maspar [77, 78]. Because Gamma language is more descriptive than Unity language. We are to discuss the method of implementing Gamma by Unity and study the effect of this method for efficiency improvement. <p> How these combinations are related to the synthesis methods for logic programs [85] and to those for Gamma programs is a topic deserves deep studies. As a special conditional term rewriting system <ref> [76, 77] </ref>, how Gamma is related to the existing work, especially on issues such as Church-Rosser property, termination, and composition theory, is also an aspect of future work.
Reference: [77] <author> L. Huang, K.-W. Ng and Y. Sun, </author> <title> Implementing Gamma on MasPar MP-1, </title> <journal> Journal of Computer Science and Technology, </journal> <note> to appear. </note>
Reference-contexts: However, implementing Gamma in existing running environments is still the main trend of research on this topic and improvement of efficiency of the programs is the central issue [76]. Gamma has been implemented on Connection Machine [40], Intel iPSC2 [74, 75], and Maspar <ref> [77, 78] </ref>. Because Gamma language is more descriptive than Unity language. We are to discuss the method of implementing Gamma by Unity and study the effect of this method for efficiency improvement. <p> How these combinations are related to the synthesis methods for logic programs [85] and to those for Gamma programs is a topic deserves deep studies. As a special conditional term rewriting system <ref> [76, 77] </ref>, how Gamma is related to the existing work, especially on issues such as Church-Rosser property, termination, and composition theory, is also an aspect of future work.
Reference: [78] <author> L. Huang, K.-W. Ng and Y. Sun, </author> <title> Implementing higher-order Gamma on MasPar: a case study, </title> <journal> Journal of Systems Engineering and Electronics, </journal> <volume> Vol. 16, No.4, </volume> <year> 1995. </year>
Reference-contexts: However, implementing Gamma in existing running environments is still the main trend of research on this topic and improvement of efficiency of the programs is the central issue [76]. Gamma has been implemented on Connection Machine [40], Intel iPSC2 [74, 75], and Maspar <ref> [77, 78] </ref>. Because Gamma language is more descriptive than Unity language. We are to discuss the method of implementing Gamma by Unity and study the effect of this method for efficiency improvement.
Reference: [79] <author> D. Gelernter, </author> <title> Generative communication in Linda, </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> Vol. 7, No. 1, </volume> <month> Jan. </month> <year> 1985, </year> <pages> pp. 80-112. </pages>
Reference-contexts: For implementing Gamma, we propose a method of transforming Gamma programs to Unity programs and test the effect of this transformation on a sorting problem. The results support the expectation that using Unity as an implementation level of Gamma benefit the improvement of the efficiency of the programs. Linda <ref> [4, 79] </ref> is a related approach to Gamma. Linda's model is based on generative communications, which are done via the tuple space. Both data and program objects are represented as tuples. Linda is a very simple communication model that can easily be incorporated into existing programming language.
Reference: [80] <author> J.M. Andreoli and R. Pareschi, </author> <title> Linear Object: logical processes with built-in inheritence, </title> <journal> New Generation Computing, </journal> <volume> Vol. 9, </volume> <year> 1991, </year> <pages> pp. 445-473. </pages>
Reference-contexts: It may be suitable to consider program languages to whom Linda primitives are implanted as potential implementation machines of Gamma. Relationship between Unity and Linda can be viewed from this point. Linear Objects (or LO) was originally proposed as an integration of logic programming and object-oriented programming <ref> [80] </ref>. In [81], LO is used as a foundation for interaction abstract machines, extending the chemical reaction metaphor with a notion of broadcast communication. Another integration of generative communication and logic programming appears in [82]. More recent works can be seen in [83, 84].
Reference: [81] <author> J.M. Andreoli, P. Ciancarini and R. Pareschi, </author> <title> Interaction abstract machines, </title> <booktitle> Proc. of the Workshop on Research Directions in Concurrent Object Oriented Programming, </booktitle> <year> 1992. </year>
Reference-contexts: It may be suitable to consider program languages to whom Linda primitives are implanted as potential implementation machines of Gamma. Relationship between Unity and Linda can be viewed from this point. Linear Objects (or LO) was originally proposed as an integration of logic programming and object-oriented programming [80]. In <ref> [81] </ref>, LO is used as a foundation for interaction abstract machines, extending the chemical reaction metaphor with a notion of broadcast communication. Another integration of generative communication and logic programming appears in [82]. More recent works can be seen in [83, 84].
Reference: [82] <author> P. Ciancarini, </author> <title> Parallel logic programming using the Linda model of computation, </title> <editor> in: J.-P. Ban^atre and D. Le Metayer (Eds.), </editor> <booktitle> Proc. of Workshop on Research Directions in High-Level Parallel Programming Languages, </booktitle> <year> 1992. </year>
Reference-contexts: In [81], LO is used as a foundation for interaction abstract machines, extending the chemical reaction metaphor with a notion of broadcast communication. Another integration of generative communication and logic programming appears in <ref> [82] </ref>. More recent works can be seen in [83, 84]. In [83], multisets are used as terms and conditions and actions are described as predicates. In [84], the objects in the multisets are used as goal formulas and the (condition; action) pairs as goal-directed deduction rules, which results in LO.
Reference: [83] <author> P. Ciancarini, D. Fogli and M. Gaspari, </author> <title> A logic language based on multiset rewriting, </title> <editor> in: J.M. Andresli, and C. Hankin (eds.), </editor> <title> Coordination Programming: Mechanisms, Models and Semantics, </title> <publisher> Imperial College Press, </publisher> <year> 1996, </year> <note> to appear. </note>
Reference-contexts: In [81], LO is used as a foundation for interaction abstract machines, extending the chemical reaction metaphor with a notion of broadcast communication. Another integration of generative communication and logic programming appears in [82]. More recent works can be seen in <ref> [83, 84] </ref>. In [83], multisets are used as terms and conditions and actions are described as predicates. In [84], the objects in the multisets are used as goal formulas and the (condition; action) pairs as goal-directed deduction rules, which results in LO. <p> In [81], LO is used as a foundation for interaction abstract machines, extending the chemical reaction metaphor with a notion of broadcast communication. Another integration of generative communication and logic programming appears in [82]. More recent works can be seen in [83, 84]. In <ref> [83] </ref>, multisets are used as terms and conditions and actions are described as predicates. In [84], the objects in the multisets are used as goal formulas and the (condition; action) pairs as goal-directed deduction rules, which results in LO.
Reference: [84] <author> L. Van Aertryck and O. Ridoux, </author> <title> Gammalog as goal-directed proofs, </title> <editor> in: J.M. Andresli, and C. Hankin (eds.), </editor> <title> Coordination Programming: Mechanisms, Models and Semantics, </title> <publisher> Imperial College Press, </publisher> <year> 1996, </year> <note> to appear. </note>
Reference-contexts: In [81], LO is used as a foundation for interaction abstract machines, extending the chemical reaction metaphor with a notion of broadcast communication. Another integration of generative communication and logic programming appears in [82]. More recent works can be seen in <ref> [83, 84] </ref>. In [83], multisets are used as terms and conditions and actions are described as predicates. In [84], the objects in the multisets are used as goal formulas and the (condition; action) pairs as goal-directed deduction rules, which results in LO. <p> Another integration of generative communication and logic programming appears in [82]. More recent works can be seen in [83, 84]. In [83], multisets are used as terms and conditions and actions are described as predicates. In <ref> [84] </ref>, the objects in the multisets are used as goal formulas and the (condition; action) pairs as goal-directed deduction rules, which results in LO. How these combinations are related to the synthesis methods for logic programs [85] and to those for Gamma programs is a topic deserves deep studies.
Reference: [85] <author> J.-M. Jacquet (ed.), </author> <title> Constructing Logic Programs, </title> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: In [84], the objects in the multisets are used as goal formulas and the (condition; action) pairs as goal-directed deduction rules, which results in LO. How these combinations are related to the synthesis methods for logic programs <ref> [85] </ref> and to those for Gamma programs is a topic deserves deep studies. As a special conditional term rewriting system [76, 77], how Gamma is related to the existing work, especially on issues such as Church-Rosser property, termination, and composition theory, is also an aspect of future work.
Reference: [86] <author> P. Fradet and D. Le Metayer, </author> <title> Type checking for a multiset language, </title> <note> INRIA Research Report, 1996. 106 BIBLIOGRAPHY </note>
Reference-contexts: As a special conditional term rewriting system [76, 77], how Gamma is related to the existing work, especially on issues such as Church-Rosser property, termination, and composition theory, is also an aspect of future work. Structured Gamma <ref> [8, 86] </ref> is the result of an attempt to solve the problem that the fact of Gamma's lack of structuring may lead to to programs which are unnecessary complex when the programmer needs to encode specific data structures and is detrimental both for reasoning about programs and for implementing them, without
Reference: [87] <author> R. Allen and D. Garlan, </author> <title> Formalising architectural connection, </title> <booktitle> Proc. of the IEEE 16th International Conference on Software Engineering, </booktitle> <year> 1994, </year> <pages> pp. 71-80. </pages>
Reference-contexts: The significance of the approach is that the programmer can define his own types and programs can be checked according to the type definitions. The application of this idea to the definition and the analysis of software architectures <ref> [87, 88] </ref> (or, in other terminologies, configuration programming [89], coordination programming [4, 90]) is an important aspect of current research [91, 8, 5].
Reference: [88] <author> D. Garlan and D. Perry, </author> <title> Editor's Introduction, </title> <journal> IEEE Trans. on Software Engineering, Special Issue on Software Architectures, </journal> <year> 1995. </year>
Reference-contexts: The significance of the approach is that the programmer can define his own types and programs can be checked according to the type definitions. The application of this idea to the definition and the analysis of software architectures <ref> [87, 88] </ref> (or, in other terminologies, configuration programming [89], coordination programming [4, 90]) is an important aspect of current research [91, 8, 5].
Reference: [89] <author> J. Kramer, </author> <title> Configuration programming, A framework for the development of distributable systems, </title> <booktitle> Proc. COMPEURO'90, IEEE, </booktitle> <year> 1990, </year> <pages> pp. 374-384. </pages>
Reference-contexts: The significance of the approach is that the programmer can define his own types and programs can be checked according to the type definitions. The application of this idea to the definition and the analysis of software architectures [87, 88] (or, in other terminologies, configuration programming <ref> [89] </ref>, coordination programming [4, 90]) is an important aspect of current research [91, 8, 5]. Significance of this application is based on the fact that common and formally based language is lack for describing software architectures and the chemical reaction model can be used as a candidate [92, 8].
Reference: [90] <author> A.A. Holzbacher, </author> <title> A software environment for concurrent coordinated programming, </title> <booktitle> Proc. of the 1st Int. Conf. on Coordination Models, Languages and Applications, </booktitle> <publisher> Springer-Verlag, LNCS 1061, </publisher> <month> Apr. </month> <year> 1996, </year> <pages> pp. 249-266. </pages>
Reference-contexts: The significance of the approach is that the programmer can define his own types and programs can be checked according to the type definitions. The application of this idea to the definition and the analysis of software architectures [87, 88] (or, in other terminologies, configuration programming [89], coordination programming <ref> [4, 90] </ref>) is an important aspect of current research [91, 8, 5]. Significance of this application is based on the fact that common and formally based language is lack for describing software architectures and the chemical reaction model can be used as a candidate [92, 8].
Reference: [91] <author> D. Le Metayer, </author> <title> Software architecture styles as graph grammars, </title> <booktitle> Proc. of the ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <address> San Francisco, California, </address> <month> Oct. </month> <year> 1996, </year> <note> to appear. </note>
Reference-contexts: The application of this idea to the definition and the analysis of software architectures [87, 88] (or, in other terminologies, configuration programming [89], coordination programming [4, 90]) is an important aspect of current research <ref> [91, 8, 5] </ref>. Significance of this application is based on the fact that common and formally based language is lack for describing software architectures and the chemical reaction model can be used as a candidate [92, 8].
Reference: [92] <author> P. Inverardi and A. Wolf, </author> <title> Formal specification and analysis of software architectures using the chemical abstract machine model, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. 21, No. 4, </volume> <month> Apr. </month> <year> 1995, </year> <pages> pp. 373-386. </pages>
Reference-contexts: Significance of this application is based on the fact that common and formally based language is lack for describing software architectures and the chemical reaction model can be used as a candidate <ref> [92, 8] </ref>. Acknowledgement First of all, I would like to express gratitude to my supervisor, Professor Guoliang Chen, for his persistent guidance. His dilligence in work gives me much influence. It is he who encouraged me when I was disheartened.
References-found: 92

