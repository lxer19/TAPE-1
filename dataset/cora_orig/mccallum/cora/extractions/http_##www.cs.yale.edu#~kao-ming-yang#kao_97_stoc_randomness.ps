URL: http://www.cs.yale.edu/~kao-ming-yang/kao_97_stoc_randomness.ps
Refering-URL: http://www.cs.yale.edu/~kao-ming-yang/papers.html
Root-URL: http://www.cs.yale.edu
Title: Reducing Randomness via Irrational Numbers  
Author: Zhi-Zhong Chen Ming-Yang Kao 
Address: Berkeley, CA 94720-1776  Durham, NC 27708  
Affiliation: Computer Science Division University of California at Berkeley  Department of Computer Science Duke University  
Abstract: We propose a general methodology for testing whether a polynomial with integer coefficients is identically zero. The methodology is to evaluate the polynomial at suitable approximations of easily computable irrational points. An innovative feature of the methodology is that the error probability of the testing algorithm can be decreased by increasing the precision of the approximations of the chosen irrational numbers, instead of increasing the number of random bits as usual. To explain our methodology, we discuss the problem of deciding whether a graph has a perfect matching. Our new randomized NC algorithm uses fewer random bits without doing more work than all the previous randomized NC algorithms for the problem. We also apply the methodology to the problem of checking the equivalence of two multisets of integers. Our new randomized algorithm for this problem runs faster and uses fewer random bits than one of the two algorithms of Blum and Kannan. It also runs faster than the other for a large range of inputs on a more realistic model of computation than theirs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Berge. </author> <title> Graphs and Hypergraphs. </title> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1973, </year> <pages> pp. 142-143. </pages>
Reference-contexts: The model reflects many sorting scenarios more closely than the usual RAM model. One of their algorithms needs to select a random prime among the primes in the range <ref> [1; 3adlog (n+1)e] </ref>, where n and a are respectively the number and the largest value of elements in the two given multisets. Their other algorithm needs to select a random prime among the primes in [1; 3ndlog (a + 2n)e]. <p> Their other algorithm needs to select a random prime among the primes in <ref> [1; 3ndlog (a + 2n)e] </ref>. How to select such random primes was not mentioned in their paper [3]. To the best of our knowledge, there are two possible methods for this task. One method computes all primes in the desired ranges, and then randomly selects one. <p> Our algorithm also runs efficiently in a more realistic model than Blum and Kannan's model. In our model, each of the O (log n + log a) words in the random access memory can hold an integer in the range <ref> [1; maxfdlog ne; dlog aeg] </ref>, while in their model each word can hold an integer in [1; a]. <p> In our model, each of the O (log n + log a) words in the random access memory can hold an integer in the range [1; maxfdlog ne; dlog aeg], while in their model each word can hold an integer in <ref> [1; a] </ref>. In our model of computation, sorting the given two multisets by comparisons (respectively, by radix) takes time O (n log n log a log log n+log log a ) (respectively, O (n log a log a log log n+log log a )). <p> It runs faster than the other for a = O (2 p and uses fewer random bits for a = O ( n 3 log 4 nlog log 2 n ). Note that the range <ref> [1; 2 p n= log n ] </ref> is sufficiently large for practical purposes. 2 A generic algorithm for testing poly nomials Let Q (x 1 ; : : : ; x m ) be a polynomial with integer co efficients. <p> Theorem 3.3 (1961, Fisher and Kasteleyn <ref> [1] </ref>) det M = (Pf (M )) . Let G 0 be the acyclic digraph obtained from G by replacing each edge fi; jg with the arc (minfi; jg; maxfi; jg). <p> S and T each have at most n elements, and each element is an integer in f1; 2; : : : ; ag. The random access memory has O (log n + log a) words each of which can hold an integer in the range <ref> [1; maxfdlog ne; dlog aeg] </ref>. The allowed elementary operations are +, , fi, =, &lt;, =, and two bit operations shif t-to-lef t and shif t-toright. Here, = is "integer divide". Each of the operations takes one step on integers that are one word long. <p> Hence, we hereafter assume n &lt; 2 a . Note that the only difference between our model and Blum and Kannan's is that our model has shorter word length. In Blum and Kannan's model, each word can hold an integer in the range <ref> [1; a] </ref>. In our model, sorting S and T by comparisons takes O (n log n log a log log n+log log a ) time, and sorting them by radix takes O (n log a log a log log n+log log a ) time. <p> We briefly describe the two algorithms of Blum and Kannan for multiset equality test [3]. One algorithm selects a ran-dom prime p uniformly from the primes in the range <ref> [1; 3adlog (n + 1)e] </ref>, and then checks whether P n 1) s i i=1 (n + 1) t i mod p. <p> Their other algorithm tests whether the polynomial Q (x) = n i=1 (xt i ) is identically zero. To do this, it uniformly selects a random integer z 2 f1; 2; : : : ; 2ng and a random prime q from the primes in the range <ref> [1; 3ndlog (a + 2n)e] </ref>, and then checks whether Q (z) 0 mod q.
Reference: [2] <author> M. Blum, A. K. Chandra, and M. N. Wegman. </author> <title> Equivalence of Free Boolean Graphs Can Be Decided Probabilistically in Polynomial Time. </title> <journal> Information Processing Letters, </journal> <volume> 10 </volume> <pages> 80-82, </pages> <year> 1980. </year>
Reference-contexts: The probability of error can be made inverse polynomially small while maintaining the same number of random bits. The other is the problem of testing equivalence of ordered Boolean decision diagrams <ref> [2] </ref>. An ordered Boolean decision diagram (OBDD) of n variables x 1 , ..., x n is a labeled directed acyclic graph D = (V; A) with two distinguished nodes called start and finish. There is no arc entering start and no arc leaving finish. <p> Two OBDD's are equivalent iff the Boolean functions they represent are equivalent. Blum et al. gave a randomized polynomial-time algorithm for testing the equivalence of two given OBDD's <ref> [2] </ref>. Their algorithm uses n (dlog t + log ne) random bits and achieves a probability of error at most 1 t for any positive integer t. We can reduce the problem to the problem of polynomial testing.
Reference: [3] <author> M. Blum and S. Kannan. </author> <title> Designing Programs that Check Their Work. </title> <journal> J. ACM, </journal> <volume> 42 (1995), </volume> <pages> 269-291. </pages>
Reference-contexts: 1 Introduction Many algorithms involve testing whether certain polynomials with integer coefficients are identically zero <ref> [3, 13, 16] </ref>. Often times, these polynomials have fl On leave from Department of Mathematical Sciences, Tokyo Denki University, Hatoyama, Saitama 350-03, Japan. Email: zchen@cs.berkeley.edu. y Research supported in part by NSF Grant CCR-9101385. Email: kao@cs.duke.edu. exponential-sized standard representations but have very succinct nonstandard representations. <p> doing more work than all the previous randomized NC algorithms for the perfect matching problem [4, 8]. 1.3 Application to multiset equality test To further demonstrate the methodology, we discuss the problem of checking whether two given multisets of integers are equivalent. (See x4.) To design a checker for sorting <ref> [3] </ref>, Blum and Kannan proposed two randomized algorithms for solving this problem on a special model of computation. The model reflects many sorting scenarios more closely than the usual RAM model. <p> Their other algorithm needs to select a random prime among the primes in [1; 3ndlog (a + 2n)e]. How to select such random primes was not mentioned in their paper <ref> [3] </ref>. To the best of our knowledge, there are two possible methods for this task. One method computes all primes in the desired ranges, and then randomly selects one. <p> Blum and Kannan gave two algorithms for this problem <ref> [3] </ref>. Their algorithms are designed for a special model of computation that reflects many sorting scenarios more closely than the usual RAM model. Here, we employ an even more realistic model of computation. <p> We briefly describe the two algorithms of Blum and Kannan for multiset equality test <ref> [3] </ref>. One algorithm selects a ran-dom prime p uniformly from the primes in the range [1; 3adlog (n + 1)e], and then checks whether P n 1) s i i=1 (n + 1) t i mod p.
Reference: [4] <author> S. Chari, P. Rohatgi, and A. Srinivasan. </author> <title> Randomness-Optimal Unique Element Isolation with Applications to Perfect Matching and Related Problems. </title> <journal> SIAM J. Computing, </journal> <volume> 24 (1995), </volume> <pages> 1036-1050. </pages>
Reference-contexts: His algorithm achieves an error probability at most 1 2 , using m dlog (2n)e random bits. The algorithm of Chari et al <ref> [4] </ref> uses the fewest random bits among all the previous randomized NC algorithms. <p> The number of random bits used is only P n i=1 dlog maxf1; n i ge, where n i is the number of neighbors v j of the i-th vertex v i in G such that j &gt; i. This bound significantly improves Chari et al's <ref> [4] </ref>. The time and processor complexities of our algorithm are dominated by those of computing the determinant of an n by n matrix whose entries are 3ndlog m n log 2 ne bit integers. The error probability achieved is at most 1 2 . <p> Hence, we need only O (log n) additional random bits to generate a desired modulo integer. In summary, our algorithm uses fewer random bits without doing more work than all the previous randomized NC algorithms for the perfect matching problem <ref> [4, 8] </ref>. 1.3 Application to multiset equality test To further demonstrate the methodology, we discuss the problem of checking whether two given multisets of integers are equivalent. (See x4.) To design a checker for sorting [3], Blum and Kannan proposed two randomized algorithms for solving this problem on a special model <p> Let b 1 , : : :, b k be k random bits. Then, with probability at least 1 ndlog 2m n e+d k log k 2 e+kdlog log ke lk1 , Proof. Let Z be the number of perfect matchings in G. As observed in <ref> [4] </ref>, Z &lt; ( 2m n ) n . Moreover, by the proof of Lemma 3.4, Q has exactly Z monomials, the degree of each indeterminate y i in Q is at most 1, and the largest absolute value of a coefficient in Q is no more than 1. <p> In contrast, to guarantee an error probability at most 3 4 , the algorithm in <ref> [4] </ref> computes the determinant of a matrix with O (n 7 )- bit integer entries and uses minf24 P n i=1 dlog d i e; 5m + 4 i=1 dlog d i eg + O (log n) random bits, where d i is the degree of vertex i in G. <p> Thus, Algorithm 1 uses fewer random bits and performs less work than the algorithm in <ref> [4] </ref>. Recall that Theorems 3.1 and 3.2 together yield a randomized NC algorithm for the perfect matching problem. To guarantee an error probability at most 1 t for t 2, this algorithm uses m log (tn) random bits.
Reference: [5] <author> R. Freivalds. </author> <title> Fast Probabilistic algorithms. </title> <booktitle> Lecture Notes in Computer Science 74: Proceedings of Symposium on Mathematical Foundations of Computer Science, </booktitle> <pages> pages 57-69. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: This may greatly decrease the running time. 6 Further applications Here, we briefly mention two other problems to which our methodology applies. One problem is to test whether three given n by n matrices A, B, and C satisfy AB = C. This problem was first considered by Freivalds <ref> [5] </ref> who suggested a randomized algorithm of complexity O (n 2 ), but it required n random bits. In 1990, Noar and Noar [10] proposed a randomized algorithm of complexity O (n 2 ), and it required 3 log n random bits.
Reference: [6] <author> T. Kimbrel and R. K. Sinha. </author> <title> A Probabilistic Algorithm for Verifying Matrix Products Using O(n 2 ) time and log n + O(1) random bits. </title> <journal> Information Processing Letters, </journal> <volume> 45 </volume> <pages> 107-110, </pages> <year> 1993. </year>
Reference: [7] <author> W. J. LeVeque. </author> <booktitle> Topics in Number Theory, </booktitle> <volume> volume 1. </volume> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1956. </year>
Reference-contexts: The probability that the generated integer is a prime is O ( 1 log a+log log n ) (respectively, O ( 1 log n+log log a )) by the Prime Number Theorem <ref> [7] </ref>. Consequently, the second process of generating a random prime must repeat O (log a + log log n) (respectively, O (log n + log log a)) expected times. But then, the algorithms use a large number of random bits. <p> Thus, the absolute value of each conjugate does not exceed c (d + 1)m d s 2d , since each p p s ln s by the Prime Number Theorem <ref> [7] </ref>. Thus, ff (l 0 )+fi (log (c + cd) + d log m + 2d log s) 0. Therefore, fi 2 s l 0 l 0 +log (c+cd)+d log m+2d log s . <p> When G has a perfect matching, Algorithm 1 outputs the correct answer with probability at least 1 1 t . For Algorithm 1 to work, we need to answer some questions. How do we generate p 1 , : : :, p k ? By the Prime Number Theorem <ref> [7] </ref>, for some positive constant * 1, there are at least k primes p 1 , : : :, p k among 2, 3, : : :, k (ln k) 1+* .
Reference: [8] <author> L. Lovasz. </author> <title> On Determinants, Matchings and Random Algorithms. </title> <editor> In L. Budach, editor, </editor> <booktitle> Fundamentals of Computing Theory. </booktitle> <address> Akademia-Verlag, Berlin, </address> <year> 1979. </year>
Reference-contexts: It remains open whether this problem has a deterministic NC algorithm. The algorithm of Lovasz <ref> [8] </ref> performs the least work among all the previous randomized NC algorithms for this problem. <p> Our methodology yields a new randomized NC algorithm for testing G. Like Lovasz's algorithm <ref> [8] </ref>, our algorithm tests whether the Tutte matrix M of G is a nonzero polynomial. <p> For example, if we increase the bit-length of the entries to 2n 7 , i.e., as large as Chari et al's, then the error probability is O ( log m n 6 ). Our algorithm can also be modified to perform the same amount of work as Lovasz's <ref> [8] </ref> by computing a numerical determinant of M modulo a reasonably small random integer. It suffices for the modulo integer to be O (log n)-bit long. Hence, we need only O (log n) additional random bits to generate a desired modulo integer. <p> Hence, we need only O (log n) additional random bits to generate a desired modulo integer. In summary, our algorithm uses fewer random bits without doing more work than all the previous randomized NC algorithms for the perfect matching problem <ref> [4, 8] </ref>. 1.3 Application to multiset equality test To further demonstrate the methodology, we discuss the problem of checking whether two given multisets of integers are equivalent. (See x4.) To design a checker for sorting [3], Blum and Kannan proposed two randomized algorithms for solving this problem on a special model
Reference: [9] <author> N. Nisan and D. Zuckerman. </author> <title> Randomness is Linear in Space. </title> <journal> JCSS, </journal> <volume> 52 (1996), </volume> <pages> 43-52. </pages>
Reference-contexts: But then, the algorithms use a large number of random bits. Although the number of ran dom bits used by the algorithms can be reduced to O (log a + log log n) (respectively, O (log n + log log a)) as shown by Nisan and Zuckerman <ref> [9] </ref>, the constants hidden by the big-O notations are not small. Thus, neither method for generating a random prime works well. To overcome the above difficulty in Blum and Kan-nan's algorithms, we observe that it is unnecessary to use a random prime there.
Reference: [10] <author> J. Noar and M. Noar. </author> <title> Small-Bias Probability Spaces: Effcient Constructions and Applications. </title> <journal> SIAM Journal on Computing, </journal> <volume> 22(4) </volume> <pages> 838-856, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: This problem was first considered by Freivalds [5] who suggested a randomized algorithm of complexity O (n 2 ), but it required n random bits. In 1990, Noar and Noar <ref> [10] </ref> proposed a randomized algorithm of complexity O (n 2 ), and it required 3 log n random bits. Later in 1993, Kimbrel and Sinha came up with a randomized algorithm of complexity O (n 2 ), and it required dlog ne + 1 random bits.
Reference: [11] <author> V. Pan. </author> <title> Complexity of Parallel Matrix Computations. </title> <journal> TCS, </journal> <volume> 54 (1987), </volume> <pages> 65-85. </pages>
Reference-contexts: Let T A det (h) be the numbers of parallel arithmetic steps and processors to compute the determinant of an h by h integer matrix whose entries each have a bit-length polynomial in h. Currently, T A det (h) = O (h 2:376 ) <ref> [11] </ref>. Similarly, let T B det (h; b) and P B det (h; b) be the numbers of parallel Boolean steps and processors to compute the determinant of an h by h matrix whose entries are b-bit integers. <p> Currently, T B det (h; b) = O (log h log d) det (h; b) = O (h 2:86 d log d log log d) <ref> [11] </ref>, where d = hb + h log h. Summarizing the above discussions in this section, we obtain the following theorem. Theorem 3.6 Let l be an arbitrary integer larger than ndlog 2m n e + d k log k 2 e + kdlog log ke + k + 1. <p> Recall that T B det (n; O (log n)) = O (log 2 n) and det (n; O (log n)) = O (n 3:86 log 2 n log log n) <ref> [11] </ref> at present.
Reference: [12] <author> J. H. Reif and S. R. Tate. </author> <title> Optimal size integer division circuits. </title> <journal> SIAM Journal on Computing, </journal> <volume> 19(5) </volume> <pages> 912-924, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: They can also be found in O (log n) parallel Boolean steps with O cessors, since division of O (log n)-bit integers takes O (log log n log log log n) parallel Boolean steps with O (log n log log log n) processors <ref> [12] </ref>. To compute r i from each p i , we use Newton's method. For completeness, we briefly sketch the method as follows. To compute r i , we start with g 0 = p i as the initial estimate. <p> (k (l + log k) log log (l + log k)) processors, since division of O (l + log k)-bit numbers takes O (log (l + log k) log log (l + log k)) parallel Boolean steps with O ((l + log k) log log (l + log k)) processors <ref> [12] </ref>. We can evaluate 2 terms of operations on integers as follows.
Reference: [13] <author> J. T. Schwartz. </author> <title> Fast Probabilistic Algorithms for Verification of Polynomial Identities. </title> <journal> J. ACM, </journal> <volume> 27 (1980), </volume> <pages> 701-717. </pages>
Reference-contexts: 1 Introduction Many algorithms involve testing whether certain polynomials with integer coefficients are identically zero <ref> [3, 13, 16] </ref>. Often times, these polynomials have fl On leave from Department of Mathematical Sciences, Tokyo Denki University, Hatoyama, Saitama 350-03, Japan. Email: zchen@cs.berkeley.edu. y Research supported in part by NSF Grant CCR-9101385. Email: kao@cs.duke.edu. exponential-sized standard representations but have very succinct nonstandard representations. <p> Let d Q be the degree of Q (x 1 ; : : : ; x m ). An advanced method is to evaluate Q (i 1 ; : : : ; i m ) <ref> [13, 16] </ref>, where i 1 , : : :, i m are uniformly and independently chosen at random from a set S of 2d Q integers. <p> It is not obvious how to test det M , because det M may have an exponential number of monomials. The next theorem allows this test to be performed efficiently with randomization. Theorem 3.2 (1978, Schwartz <ref> [13] </ref>, Zippel [16]) Let Q (y 1 ; : : : ; y m ) be a polynomial with integer coefficients and degree d Q . Let S be a set of 2d Q integers.
Reference: [14] <author> W. Thrash. </author> <title> A Note on the Least Common Multiples of Dense Sets of Integers. </title> <type> Technical Report #93-02-04, </type> <institution> Department of Computer Science, University of Washington, </institution> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: Can we modify Algorithm 1 so that it needs to compute the determinant of only a matrix with O (log n)-bit integer entries? The rest of this section is devoted to answering this question. Theorem 3.7 (Thrash <ref> [14] </ref>) Let h 3. Let H be a subset of f1; 2; : : : ; h 2 g such that jHj h 2 2 . Then, the least common multiple of the elements in H exceeds 2 h .
Reference: [15] <author> W. T. Tutte. </author> <title> The Factors of Graphs. </title> <journal> Canadian Journal of Mathematics, </journal> <volume> 4 (1952), </volume> <pages> 314-328. </pages>
Reference-contexts: Email: zchen@cs.berkeley.edu. y Research supported in part by NSF Grant CCR-9101385. Email: kao@cs.duke.edu. exponential-sized standard representations but have very succinct nonstandard representations. The determinant of the Tutte matrix of a graph is an example <ref> [15] </ref>. <p> Theorem 3.1 (Tutte <ref> [15] </ref>) G has a perfect matching if and only if det M 6= 0. By this theorem, testing whether G has a perfect matching is equivalent to testing whether det M is a nonzero polynomial.
Reference: [16] <author> R. E. Zippel. </author> <title> Probabilistic Algorithms for Sparse Polynomials. </title> <booktitle> In Proceedings of EUROSAM 79. Lecture Notes in Computer Science, </booktitle> <volume> vol. 72. </volume> <publisher> Springer-Verlag, </publisher> <year> 1979, </year> <pages> pp. 216-226. </pages>
Reference-contexts: 1 Introduction Many algorithms involve testing whether certain polynomials with integer coefficients are identically zero <ref> [3, 13, 16] </ref>. Often times, these polynomials have fl On leave from Department of Mathematical Sciences, Tokyo Denki University, Hatoyama, Saitama 350-03, Japan. Email: zchen@cs.berkeley.edu. y Research supported in part by NSF Grant CCR-9101385. Email: kao@cs.duke.edu. exponential-sized standard representations but have very succinct nonstandard representations. <p> Let d Q be the degree of Q (x 1 ; : : : ; x m ). An advanced method is to evaluate Q (i 1 ; : : : ; i m ) <ref> [13, 16] </ref>, where i 1 , : : :, i m are uniformly and independently chosen at random from a set S of 2d Q integers. <p> It is not obvious how to test det M , because det M may have an exponential number of monomials. The next theorem allows this test to be performed efficiently with randomization. Theorem 3.2 (1978, Schwartz [13], Zippel <ref> [16] </ref>) Let Q (y 1 ; : : : ; y m ) be a polynomial with integer coefficients and degree d Q . Let S be a set of 2d Q integers.
References-found: 16

