URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/related-papers/moggi.ps.Z
Refering-URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/home.html
Root-URL: 
Title: An Abstract View of Programming Languages  
Author: Eugenio Moggi 
Keyword: feedback.  
Note: 1 These Notes were produced at Stanford University as part of the course CS 359 taught in Spring Term 1989. A special thank to John Mitchell, who made my visit to Stanford possible, and to all students who attended the course and provided  
Address: EH9 3JZ Edinburgh, UK  
Affiliation: Lab. for Found. of Comp. Sci. University of Edinburgh  
Email: em@lfcs.edinburgh.ac.uk  
Date: June 1989  
Web: useful  
Abstract-found: 0
Intro-found: 1
Reference: [Abr87] <author> S. Abramsky. </author> <title> Domain Theory and the Logic of Observable Properties. </title> <type> PhD thesis, </type> <institution> University of London, </institution> <year> 1987. </year>
Reference-contexts: The two semantics are related by a correspondence theorem between (operational) termination and (denotational) existence, inspired by a similar result due to Martin-Lof (see [ML83] and Chapter 6 of <ref> [Abr87] </ref>). The choice of eager evaluation makes it easier to translate programming languages into the metalanguage correctly, i.e. so that the operational and denota-tional semantics obtained via the translation are the intended ones.
Reference: [Bar81] <author> H.P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North Holland, </publisher> <year> 1981. </year>
Reference-contexts: In particular, there are problems in establishing a clear relation between denotational and operational semantics. * modifications of the -calculus based on operational considerations are cor rect, but they lack a completeness result. 3.1 Calculi and programming languages The direct connections between the pure -calculus (i.e. the subject of <ref> [Bar81] </ref>) and functional programming languages sometimes do not go beyond the binding mechanism of -abstraction (see [McC62, Lan64]). This is not surprising if we look at the history of the type free lambda calculus (Preface of [Bar81]): "Around 1930 the type free lambda calculus was introduced as a foundation for logic <p> and programming languages The direct connections between the pure -calculus (i.e. the subject of <ref> [Bar81] </ref>) and functional programming languages sometimes do not go beyond the binding mechanism of -abstraction (see [McC62, Lan64]). This is not surprising if we look at the history of the type free lambda calculus (Preface of [Bar81]): "Around 1930 the type free lambda calculus was introduced as a foundation for logic and mathematics. Due to the appearance of paradoxes, this aim was not fulfilled, however. Nevertheless a consistent part of the theory turned out to be quite successful as a theory of computations.
Reference: [BW85] <author> M. Barr and C. Wells. </author> <title> Toposes, Triples and Theories. </title> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: A Categorical Manifesto (see [Gog89]) with a textbook on Category Theory (e.g. <ref> [Mac71, Gol79, BW85] </ref>): * basic concepts of Category Theory * their manifestations in areas related to Computer Science * methodological guidelines The paradigm of Categorical Logic (see [KR77]) applied to programming languages 2. <p> Actually there are two general constructions, that given a monad over C return an adjunction inducing that monad. We will use only the construction due to Kleisli; however, the Eilenberg-Moore construction as well as additional information on monads can be found in most textbooks on Category Theory (see <ref> [Mac71, BW85] </ref>). 19 Proposition 3.2.5 Given a monad (T; ; ) over C, or equivalently a Kleisli triple, the quadruple (F T ; G T ; ; *), defined below, is an adjunction from C to the Kleisli category C T which induces the monad (T; ; ): * F T <p> The definition of monad morphism given above is very general. Since we are interested only in relating monads or strong monads over some fixed category C, we simplify the definition by requiring U to be the identity functor on C (as done in <ref> [BW85] </ref>).
Reference: [FFKD86] <author> M. Felleisen, D.P. Friedman, E. Kohlbecker, and B. Duba. </author> <title> Reasoning with continuations. </title> <booktitle> In 1st LICS Conf. IEEE, </booktitle> <year> 1986. </year>
Reference-contexts: The idea of starting from operational considerations, and then develop a calculus has been followed by several people to take account of mor complex features of programming languages like non-determinism, side-effects, control-mechanisms (see <ref> [Sha84, FFKD86, MT89] </ref>). 13 The partial -calculus The p -calculus is a formal system presented in [Mog86] and (with minor differences) in Chapter 4 of [Ros86], which is sound and complete w.r.t. interpretation in partial cartesian closed categories.
Reference: [Flo67] <author> R. Floyd. </author> <title> Assigning meaning to programs. </title> <editor> In Schwartz, editor, </editor> <booktitle> Proc. Symp. in Applied Math., </booktitle> <year> 1967. </year>
Reference-contexts: In [Mog88] various modifications of the p -calculus are considered that are sound and complete w.r.t. other classes of models, e.g. classical type structures of (monotonic) partial functionals. Logics for computable functions and domain theory The use of logics for proving correctness of programs was pioneered in <ref> [Flo67, Hoa69] </ref>. The programming languages considered in these early approaches are very simple (while programs) and the formal languages of expressing properties of programs are a mixture of programming language and predicate calculus (Hoare's triples). The main feature of these logics, e.g.
Reference: [GMW79] <author> M.J.C. Gordon, R. Milner, </author> <title> and C.P. </title> <publisher> Wadsworth. Edinburgh LCF: </publisher>
Reference-contexts: (denotational model) * documents the design of a programming language * establishes a standard for implementations, but does not specify the tech niques used in implementations * provides a basis for reasoning about the correctness (but not the com plexity) of programs either directly or indirectly, like in LCF (see <ref> [GMW79] </ref>) * promotes insight regarding concepts underlying programming languages (design with formal semantics in mind) 1 There is another application that I would have liked to consider in this course, namely the study data-refinement via natural transformations (see [HJ]). <p> A first attempt at a logic for reasoning about cpos and continuous functions was the logic for computable functions (see [Sco69]), which was subsequently extended to the polymorphic predicate -calculus P P (see <ref> [GMW79, Pau85] </ref>).
References-found: 6

