URL: http://www-sal.cs.uiuc.edu/~pitt/Papers/dualization.ps
Refering-URL: http://www-sal.cs.uiuc.edu/~pitt/
Root-URL: http://www.cs.uiuc.edu
Email: carlos@lsi.upc.es  nmishra@hpl.hp.com  pitt@cs.uiuc.edu  
Title: Efficient Read-Restricted Monotone CNF/DNF Dualization by Learning with Membership Queries  
Author: Carlos Domingo Nina Mishra Leonard Pitt 
Date: July 10, 1998  
Address: Campus Nord, Modul C5 Jordi Girona Salgado 1-5, 08034-Barcelona, Spain  1501 Page Mill Rd, MS 1U-4A Palo Alto, CA 94304  Urbana, IL 61801  
Affiliation: Universitat Politecnica de Catalunya Department de LSI  Hewlett Packard Laboratories  Dept. of Computer Science University of Illinois  
Abstract: We consider exact learning monotone CNF formulas in which each variable appears at most some constant k times ("read-k" monotone CNF). Let f : f0; 1g n ! f0; 1g be expressible as a read-k monotone CNF formula for some natural number k. We give an incremental output polynomial time algorithm for exact learning both the read-k CNF and (not necessarily read restricted) DNF descriptions of f. The algorithm's only method of obtaining information about f is through membership queries, i.e., by inquiring about the value f(x) for points x 2 f0; 1g n . The algorithm yields an incremental polynomial output time solution to the bounded degree hypergraph transversal problem, and the problem of (read-k) monotone CNF/DNF dualization, which remain open problems of importance in the unrestricted case. 
Abstract-found: 1
Intro-found: 1
Reference: [ABK + 97] <author> H. Aizenstein, A. Blum, R. Khardon, E. Kushilevitz, L. Pitt, and D. Roth. </author> <note> On learning read-k-satisfy-j dnf. To appear, SIAM Journal on Computing. Preliminary version appears in Proceedings of the Seventh Annual ACM Conference on Computational Learning Theory, </note> <year> 1997. </year>
Reference-contexts: The restriction considered in this paper is based on limiting the number of "reads" (occurrences of each variable) in a formula, a restriction that has been well-investigated in the learning-theory literature <ref> [AHK93, PR95, PR96, BHH95a, BHH95b, ABK + 97, AHHP97] </ref>. Previous work has shown that it is possible to find the minterms of an arbitrary monotone read-once (^; _) formula under a stronger notion of polynomial time [AHK93, GK95].
Reference: [AHHP97] <author> H. Aizenstein, T. Hegedus, L. Hellerstein, and L. Pitt. </author> <title> Complexity theoretic hardness results for query learning. Computational Complexity, </title> <note> To appear, </note> <year> 1997. </year>
Reference-contexts: The restriction considered in this paper is based on limiting the number of "reads" (occurrences of each variable) in a formula, a restriction that has been well-investigated in the learning-theory literature <ref> [AHK93, PR95, PR96, BHH95a, BHH95b, ABK + 97, AHHP97] </ref>. Previous work has shown that it is possible to find the minterms of an arbitrary monotone read-once (^; _) formula under a stronger notion of polynomial time [AHK93, GK95].
Reference: [AHK93] <author> Dana Angluin, Lisa Hellerstein, and Marek Karpinski. </author> <title> Learning read-once formulas with queries. </title> <journal> Journal of the ACM, </journal> <volume> 40(1) </volume> <pages> 185-210, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The restriction considered in this paper is based on limiting the number of "reads" (occurrences of each variable) in a formula, a restriction that has been well-investigated in the learning-theory literature <ref> [AHK93, PR95, PR96, BHH95a, BHH95b, ABK + 97, AHHP97] </ref>. Previous work has shown that it is possible to find the minterms of an arbitrary monotone read-once (^; _) formula under a stronger notion of polynomial time [AHK93, GK95]. <p> Previous work has shown that it is possible to find the minterms of an arbitrary monotone read-once (^; _) formula under a stronger notion of polynomial time <ref> [AHK93, GK95] </ref>.
Reference: [AIS93] <author> R. Agrawal, T. Imielinski, and A. Swami. </author> <title> Mining Associations between Sets of Items in Massive Databases. </title> <booktitle> In Proc. of the ACM-SIGMOD 1993 International Conference on Management of Data, </booktitle> <address> Washington D.C., </address> <month> May </month> <year> 1993, </year> <pages> 207-216. 22 </pages>
Reference-contexts: Efficiently enumerating association rules has become an important topic in data mining. Typically, a heuristic approach is taken wherein one first enumerates all of the "frequent sets" of T <ref> [AIS93, AS94, GMS97, MT97, AMS + 96, SA95] </ref>. A frequent set is any set of attributes S such that the fraction of rows that have all attributes of S set to 1 is at least .
Reference: [AMS + 96] <author> R. Agrawal, H. Mannila, R. Srikant, H. Toivonen, and I. Verkamo. </author> <title> Fast discovery of association rules. In Advances in Knowledge Discovery and Data Mining, </title> <publisher> pp.307-328. AAAI Press, </publisher> <address> Menlo Park, CA, </address> <year> 1996. </year>
Reference-contexts: The time required is polynomial in the size of the relation and the number of minimal keys. Another recently studied problem in data mining is that of finding association rules that hold in a relation (table) T , where typically each row of the table contains binary data <ref> [AMS + 96] </ref>. Let ff be a subset of the attributes of T , and let X be a single attribute, not in ff. Let A denote the number of rows of T for which each attribute of ff has value 1. <p> Efficiently enumerating association rules has become an important topic in data mining. Typically, a heuristic approach is taken wherein one first enumerates all of the "frequent sets" of T <ref> [AIS93, AS94, GMS97, MT97, AMS + 96, SA95] </ref>. A frequent set is any set of attributes S such that the fraction of rows that have all attributes of S set to 1 is at least .
Reference: [Ang88] <author> D. Angluin. </author> <title> Queries and concept learning. </title> <journal> Machine Learning, </journal> <volume> 2(4) </volume> <pages> 319-342, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: One may well wonder if it is possible to efficiently learn just one of the expressions, say the DNF, with membership queries alone. In fact, results of Angluin <ref> [Ang88] </ref> show that no algorithm exists for learning the class of CNF formulas in time polynomial in the size of the DNF formula with membership queries alone. <p> The converse is more interesting. First, we describe the exact learning with queries framework due to Angluin <ref> [Ang88] </ref>. In this learning framework, a learner tries to learn a function f from a known class C by asking queries to a teacher that knows f . <p> equivalence query takes as input a hypothesis h and returns "yes" if h is equivalent to f and otherwise an arbitrary counterexample y 2 f0; 1g n such that h (y) 6= f (y) is returned. 20 One of the early positive results in this model is due to Angluin <ref> [Ang88] </ref> (see also [Val84]) and states that the class of monotone DNF formulas is exactly learnable using membership and equivalence queries. The time and number of queries is polynomial in the number of terms of the DNF D to be learned.
Reference: [AS94] <author> R. Agrawal and R. Srikant. </author> <title> Fast Algorithms for Mining Association Rules. </title> <booktitle> In Proc. of the 20th International Conference on Very Large Databases. </booktitle> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Efficiently enumerating association rules has become an important topic in data mining. Typically, a heuristic approach is taken wherein one first enumerates all of the "frequent sets" of T <ref> [AIS93, AS94, GMS97, MT97, AMS + 96, SA95] </ref>. A frequent set is any set of attributes S such that the fraction of rows that have all attributes of S set to 1 is at least .
Reference: [BCG + 96] <author> Nader H. Bshouty, Richard Cleve, Ricard Gavalda, Sampath Kannan, and Christino Tamon. </author> <title> Oracles and queries that are sufficient for exact learning. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 52(3) </volume> <pages> 421-433, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Her result implies also that there are information theoretic barriers to learning the class of read-k DNF 9 formulas with membership queries alone (in time polynomial in the size of the read-k DNF). The result also holds for CNF. Furthermore, Bshouty et al. <ref> [BCG + 96] </ref> (Theorem 22) show that any algorithm that learns the class of monotone functions with membership queries must pose (maxfjcnf (f )j; jdnf (f )jg) queries (where f is the monotone function to be compiled).
Reference: [BHH95a] <author> Nader H. Bshouty, Thomas R. Hancock, and Lisa Hellerstein. </author> <title> Learning arithmetic read-once formulas. </title> <journal> SIAM Journal on Computing, </journal> <volume> 24(4) </volume> <pages> 706-735, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: The restriction considered in this paper is based on limiting the number of "reads" (occurrences of each variable) in a formula, a restriction that has been well-investigated in the learning-theory literature <ref> [AHK93, PR95, PR96, BHH95a, BHH95b, ABK + 97, AHHP97] </ref>. Previous work has shown that it is possible to find the minterms of an arbitrary monotone read-once (^; _) formula under a stronger notion of polynomial time [AHK93, GK95].
Reference: [BHH95b] <author> Nader H. Bshouty, Thomas R. Hancock, and Lisa Hellerstein. </author> <title> Learning Boolean read-once formulas over generalized bases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 50(3) </volume> <pages> 521-542, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The restriction considered in this paper is based on limiting the number of "reads" (occurrences of each variable) in a formula, a restriction that has been well-investigated in the learning-theory literature <ref> [AHK93, PR95, PR96, BHH95a, BHH95b, ABK + 97, AHHP97] </ref>. Previous work has shown that it is possible to find the minterms of an arbitrary monotone read-once (^; _) formula under a stronger notion of polynomial time [AHK93, GK95].
Reference: [BI95] <author> Jan C. Bioch and Toshihide Ibaraki. </author> <title> Complexity of identification and dualization of positive Boolean functions. </title> <journal> Information and Computation, </journal> <volume> 123(1) </volume> <pages> 50-63, </pages> <month> 15 November </month> <year> 1995. </year>
Reference-contexts: An efficient algorithm for the monotone function identification problem can be used to efficiently solve the monotone CNF conversion problem, since the input CNF expression for the conversion problem can be used to answer the required membership queries for the identification problem. Furthermore, results of Bioch and Ibaraki <ref> [BI95] </ref> show that an efficient algorithm for the conversion problem also may be used to obtain an efficient algorithm for the identification problem. What do we mean by an efficient algorithm? We will be more careful about defining efficiency in Section 2. <p> While this problem appears to be more difficult than the read-k-CNF conversion problem, results of Bioch and Ibaraki <ref> [BI95] </ref> imply that the problems are in fact equivalent. 2 Preliminaries 2.1 Boolean formulas, etc. Monotone functions Let V = fv 1 ; : : : ; v n g be a collection of Boolean variables.
Reference: [EG95] <author> Thomas Eiter and Georg Gottlob. </author> <title> Identifying the minimal transversals of a hypergraph and related problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 24(6) </volume> <pages> 1278-1304, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: For example, in the event that each clause of the CNF has at most two variables, efficient solutions have been given under various definitions of efficiency [JPY88, LLK80, TIAS77, KW85]. Extending this work, Eiter and Gottlob <ref> [EG95] </ref> give an efficient algorithm when the size of each clause is bounded by some constant. <p> The minimal vertex covers are precisely the complements of the maximal independent sets. In the literature, generating all minimal vertex covers of a hypergraph is also referred to as the hypergraph transversal problem <ref> [EG95] </ref>. The read restriction we consider here in the CNF/DNF setting is equivalent to the natural restriction of limiting the degree of each vertex in the hypergraph in both the hypergraph transversal and independent set problems. <p> Our result complements output polynomial time algorithms for versions of these hypergraph problems restricted by constant edge-size <ref> [EG95] </ref>. Reasoning and Knowledge Representation Another example of the utility of the conversion problem arises in the context of reasoning. <p> A more thorough review of applications of both the monotone CNF/DNF conversion problem, and the monotone function identification problem, can be found in <ref> [EG95] </ref>. 1.2 Overview The remainder of this paper is organized as follows. Section 2 reviews standard definitions, special terminology, complexity issues, and some related results on learning with membership queries. <p> Given that the output may be significantly larger than the input, a more reasonable measure of complexity allows an algorithm to run in time polynomial in both its input and output sizes. Such an algorithm is called a total (or output) polynomial time algorithm <ref> [JPY88, EG95] </ref>. A stronger definition of a total polynomial time algorithm is an incremental polynomial time algorithm | one that in between all consecutive outputs spends time polynomial in the input n, and what it has output so far.
Reference: [FK96] <author> Michael L. Fredman and Leonid Khachiyan. </author> <title> On the complexity of dualization of monotone disjunctive normal forms. </title> <journal> Journal of Algorithms, </journal> <volume> 21(3) </volume> <pages> 618-628, </pages> <month> November </month> <year> 1996. </year>
Reference-contexts: Whether or not an efficient algorithm exists for either the conversion or identification problems is currently an open question. Recently, Fredman and Khachiyan <ref> [FK96] </ref> gave an O (m o (log m) ) time algorithm for the identification problem, where m is the sum of the size of the desired CNF and 2 DNF, providing evidence that neither of the two problems are likely to be NP-hard. <p> A hypergraph H is a collection of subsets (edges) 1 In the case of a single relation, the problem is easily shown to be equivalent to the conversion problem, hence unlikely to be NP-complete, given the recent results of Fredman and Khachiyan <ref> [FK96] </ref>. 4 E of a finite set of vertices V . An independent set of a hypergraph is a subset of vertices, V 0 V such that no edge in E is contained in V 0 .
Reference: [Gai84] <author> D. N. Gainanov. </author> <title> On one criterion of optimality of an algorithm for evaluating monotonic boolean functions. In U.S.S.R. </title> <journal> Comput. Math. and Math. Phys., </journal> <volume> volume 24, </volume> <pages> pages 176-181, </pages> <year> 1984. </year>
Reference-contexts: Their result also applies to the class of monotone functions representable as read-k CNF formulas, for k 2. Finally, we note that while there is currently no known efficient algorithm for learning the class of monotone functions with O (maxfjcnf (f )j; jdnf (f )jg) membership queries, Gainanov <ref> [Gai84] </ref> has given an inefficient algorithm that realizes this membership query bound. 3 The conversion problem Throughout the rest of this paper, we will be manipulating DNF and CNF expressions. We assume that any such expression is monotone, and that it has been put into reduced (minimal) form.
Reference: [GJ79] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and intractability | A guide to the theory of NP-completeness. </title> <institution> Freeman; Bell Lab, </institution> <address> Murray Hill NJ, </address> <year> 1979. </year> <month> 23 </month>
Reference-contexts: An independent set I is maximal if no superset I 0 of I is also an independent set. Given a hypergraph H, the hypergraph independent set problem is that of enumerating all maximal independent sets of H. Note that while finding the maximum cardinality independent set is NP-hard <ref> [GJ79] </ref>, finding a maximal independent set I is easy: iteratively add vertices to I while maintaining the property that I is an independent set. We consider here the problem of enumerating all maximal independent sets.
Reference: [GK95] <author> Vladimir Gurvich and Leonid Khachiyan. </author> <title> Generating the irredundant conjunctive and disjunctive normal forms of monotone boolean functions. </title> <type> Technical Report, </type> <institution> LCSR-TR-251, Dept of Computer Science, Rutgers University, </institution> <note> Discrete Applied Math, to appear, </note> <month> August </month> <year> 1995. </year>
Reference-contexts: Previous work has shown that it is possible to find the minterms of an arbitrary monotone read-once (^; _) formula under a stronger notion of polynomial time <ref> [AHK93, GK95] </ref>.
Reference: [GMS97] <author> D. Gunopulos, H. Mannila and S. Saluja. </author> <title> Discovering All Most Specific Sentences by Randomized Algorithms. </title> <booktitle> In Proceedings of International Conference on Database Theory. Delphi, </booktitle> <address> Greece, </address> <month> January </month> <year> 1997, </year> <editor> F. Afrati and P. </editor> <publisher> Kolaitis (eds.). </publisher>
Reference-contexts: Efficiently enumerating association rules has become an important topic in data mining. Typically, a heuristic approach is taken wherein one first enumerates all of the "frequent sets" of T <ref> [AIS93, AS94, GMS97, MT97, AMS + 96, SA95] </ref>. A frequent set is any set of attributes S such that the fraction of rows that have all attributes of S set to 1 is at least . <p> A frequent set is any set of attributes S such that the fraction of rows that have all attributes of S set to 1 is at least . Efficient algorithms for the conversion problem would be useful as a heuristic for enumerating all maximal frequent sets <ref> [GMS97] </ref>. Our read-k restriction translates in this context to finding maximal frequent sets, assuming that each variable appears in at most k of the sets. A final database-related application is to the problem of enumerating all minimal failing sub-queries of a given conjunctive query to a database.
Reference: [God98] <author> Parke Godfrey. </author> <title> Minimization in Cooperative Response to Failing Database Queries. </title> <type> Manuscript, </type> <year> 1998. </year>
Reference-contexts: It has recently been shown that the general problem of enumerating all such minimal failing subqueries is NP-hard (even when there are only polynomially many minimal failing subqueries) <ref> [God98] </ref> when the database consists of more than a constant number of relations. 1 It is also shown how to enumerate failing subqueries in order of increasing size, with time increasing exponentially in the size k of the subqueries.
Reference: [HM91] <author> T. Hancock and Y. Mansour. </author> <title> Learning monotone k-DNF formulas on product distributions. </title> <booktitle> In Proc. 4th Annu. Workshop on Comput. Learning Theory, </booktitle> <pages> pages 179-183, </pages> <address> San Mateo, CA, 1991. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: The algorithm runs in time polynomial in the sum of the sizes of C and D. Before giving the main theorem of this section, we need the following definition and results adapted from the ones in <ref> [HM91] </ref>. Definition 1 A function f : f0; 1g n ! f0; 1g depends on the variable x i if there exists an assignment y 2 f0; 1g n such that f x i 0 (y) 6= f x i 1 (y).
Reference: [HMP97] <author> Haym Hirsh, Nina Mishra, and Leonard Pitt. </author> <title> Version spaces without boundary sets. </title> <booktitle> Proceedings of the 14th National Conference on Artificial Intelligence, </booktitle> <pages> pages 491-496, </pages> <year> 1997. </year>
Reference-contexts: A version space V has converged if jV j = 1. An efficient solution to the CNF/DNF conversion problem could be used to efficiently determine if a version space has converged for the class of monotone functions <ref> [HMP97] </ref>. The term knowledge compilation is used to denote methods by which one type of representation of knowledge is translated into another, so as to make it easier to use that knowledge.
Reference: [JPY88] <author> D. S. Johnson, C. H. Papadimitriou, and M. Yannakakis. </author> <title> On generating all maximal independent sets. </title> <journal> Information Processing Letters, </journal> <volume> 27(3) </volume> <pages> 119-123, </pages> <year> 1988. </year>
Reference-contexts: For example, in the event that each clause of the CNF has at most two variables, efficient solutions have been given under various definitions of efficiency <ref> [JPY88, LLK80, TIAS77, KW85] </ref>. Extending this work, Eiter and Gottlob [EG95] give an efficient algorithm when the size of each clause is bounded by some constant. <p> Given that the output may be significantly larger than the input, a more reasonable measure of complexity allows an algorithm to run in time polynomial in both its input and output sizes. Such an algorithm is called a total (or output) polynomial time algorithm <ref> [JPY88, EG95] </ref>. A stronger definition of a total polynomial time algorithm is an incremental polynomial time algorithm | one that in between all consecutive outputs spends time polynomial in the input n, and what it has output so far.
Reference: [Kha95] <author> Roni Khardon. </author> <title> Translating between horn representations and their characteristic models. </title> <journal> Journal of AI Research, </journal> <volume> 3 </volume> <pages> 349-372, </pages> <year> 1995. </year>
Reference-contexts: be represented as a conjunction of propositional Horn clauses (with empty consequents), an efficient solution to the conversion problem could be used to efficiently generate a collection of characteristic models [KKS93, KR94] to use in various reasoning tasks (for example, determining whether a query is entailed by a knowledge base) <ref> [Kha95, KMR95] </ref>. The conversion problem is also related to the problem of determining if a version space has converged.
Reference: [KKS93] <author> H. A. Kautz, M. J. Kearns, and B. Selman. </author> <title> Reasoning with characteristic models. </title> <booktitle> In Proceedings of the 11th National Conference on Artificial Intelligence, </booktitle> <pages> pages 34-39, </pages> <address> Washington, DC, July 1993. </address> <publisher> AAAI Press. </publisher>
Reference-contexts: Given a knowledge base that can be represented as a conjunction of propositional Horn clauses (with empty consequents), an efficient solution to the conversion problem could be used to efficiently generate a collection of characteristic models <ref> [KKS93, KR94] </ref> to use in various reasoning tasks (for example, determining whether a query is entailed by a knowledge base) [Kha95, KMR95]. The conversion problem is also related to the problem of determining if a version space has converged.
Reference: [KM95] <author> Jyrki Kivinen and Heikki Mannila. </author> <title> Approximate inference of functional dependencies from relations. </title> <journal> Theoretical Computer Science, </journal> <volume> 149(1) </volume> <pages> 129-149, </pages> <month> 18 September </month> <year> 1995. </year>
Reference-contexts: Similarly, key enumeration is related to the problem of finding a small cover for the set of functional dependencies that hold in a database; a problem useful in database design or query processing <ref> [MR92b, MR92a, KM95] </ref>. Our read-k algorithm can be used to enumerate all of the keys of a single relation, provided that no attribute participates in more than k (constant) minimal keys. The time required is polynomial in the size of the relation and the number of minimal keys.
Reference: [KMR95] <author> Roni Khardon, Heikki Mannila, and Dan Roth. </author> <title> Reasoning with examples: Propositional formulae and database dependencies. </title> <type> Technical Report, </type> <institution> TR-15-95, Harvard University, </institution> <year> 1995. </year>
Reference-contexts: be represented as a conjunction of propositional Horn clauses (with empty consequents), an efficient solution to the conversion problem could be used to efficiently generate a collection of characteristic models [KKS93, KR94] to use in various reasoning tasks (for example, determining whether a query is entailed by a knowledge base) <ref> [Kha95, KMR95] </ref>. The conversion problem is also related to the problem of determining if a version space has converged.
Reference: [KR94] <author> R. Khardon and D. Roth. </author> <title> Reasoning with models. </title> <booktitle> In Proceedings of the 12th National Conference on Artificial Intelligence, </booktitle> <volume> volume 2, </volume> <pages> pages 1148-1153, </pages> <address> Seattle, Washington, July-August 1994. </address> <publisher> AAAI Press. </publisher>
Reference-contexts: Given a knowledge base that can be represented as a conjunction of propositional Horn clauses (with empty consequents), an efficient solution to the conversion problem could be used to efficiently generate a collection of characteristic models <ref> [KKS93, KR94] </ref> to use in various reasoning tasks (for example, determining whether a query is entailed by a knowledge base) [Kha95, KMR95]. The conversion problem is also related to the problem of determining if a version space has converged.
Reference: [KW85] <author> Richard M. Karp and Avi Wigderson. </author> <title> A fast parallel algorithm for the maximal independent set problem. </title> <journal> Journal of the ACM, </journal> <volume> 32(4) </volume> <pages> 762-773, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: For example, in the event that each clause of the CNF has at most two variables, efficient solutions have been given under various definitions of efficiency <ref> [JPY88, LLK80, TIAS77, KW85] </ref>. Extending this work, Eiter and Gottlob [EG95] give an efficient algorithm when the size of each clause is bounded by some constant.
Reference: [LLK80] <author> E. L. Lawler, J. K. Lenstra, and A. H. G. Rinnooy Kan. </author> <title> Generating all maximal independent sets: NP-hardness and polynomial-time algorithms. </title> <journal> SIAM Journal on Computing, </journal> <volume> 9(3) </volume> <pages> 558-565, </pages> <month> August </month> <year> 1980. </year>
Reference-contexts: For example, in the event that each clause of the CNF has at most two variables, efficient solutions have been given under various definitions of efficiency <ref> [JPY88, LLK80, TIAS77, KW85] </ref>. Extending this work, Eiter and Gottlob [EG95] give an efficient algorithm when the size of each clause is bounded by some constant.
Reference: [MI95] <author> Kazuhisa Makino and Toshihide Ibaraki. </author> <title> A fast and simple algorithm for identifying 2-monotonic positive Boolean functions. ISAAC' 95 Algorithms and Computation, </title> <note> edited by J. Staples et al., Springer Lecture Notes in Computer Science, 1004 (1995) 291-300; to appear in Journal of Algorithms. </note>
Reference-contexts: Makino and Ibaraki [MI97] have also shown that an efficient solution exists for the class of monotone formulas with "constant maximum latency" The set of such formulas includes important classes like 2-monotonic formulas (for which a more efficient algorithm has also been found <ref> [MI95] </ref>), threshold formulas or matroid formulas. The restriction considered in this paper is based on limiting the number of "reads" (occurrences of each variable) in a formula, a restriction that has been well-investigated in the learning-theory literature [AHK93, PR95, PR96, BHH95a, BHH95b, ABK + 97, AHHP97].
Reference: [MI97] <author> Kazuhisa Makino and Toshihide Ibaraki. </author> <title> The maximum latency and identification of positive Boolean functions, </title> <journal> SIAM Journal on Computing, </journal> <month> 26 </month> <year> (1997) </year> <month> 1363-1383. </month>
Reference-contexts: Extending this work, Eiter and Gottlob [EG95] give an efficient algorithm when the size of each clause is bounded by some constant. Makino and Ibaraki <ref> [MI97] </ref> have also shown that an efficient solution exists for the class of monotone formulas with "constant maximum latency" The set of such formulas includes important classes like 2-monotonic formulas (for which a more efficient algorithm has also been found [MI95]), threshold formulas or matroid formulas.
Reference: [Mit82] <author> T. M. Mitchell. </author> <title> Generalization as search. Art. </title> <journal> Int., </journal> <volume> 18 </volume> <pages> 203-226, </pages> <year> 1982. </year>
Reference-contexts: The conversion problem is also related to the problem of determining if a version space has converged. For a concept class C the version space <ref> [Mit82] </ref> induced by positive example set P and negative example set N is the set of concepts in C consistent with P and N . A version space V has converged if jV j = 1.
Reference: [MR92a] <author> Mannila and Raiha. </author> <title> On the complexity of inferring functional dependencies. </title> <journal> DAMATH: Discrete Applied Mathematics and Combinatorial Operations Research and Computer Science, </journal> <volume> 40, </volume> <year> 1992. </year>
Reference-contexts: Similarly, key enumeration is related to the problem of finding a small cover for the set of functional dependencies that hold in a database; a problem useful in database design or query processing <ref> [MR92b, MR92a, KM95] </ref>. Our read-k algorithm can be used to enumerate all of the keys of a single relation, provided that no attribute participates in more than k (constant) minimal keys. The time required is polynomial in the size of the relation and the number of minimal keys.
Reference: [MR92b] <author> H. Mannila and K.-J. Raiha. </author> <title> The Design of Relational Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Similarly, key enumeration is related to the problem of finding a small cover for the set of functional dependencies that hold in a database; a problem useful in database design or query processing <ref> [MR92b, MR92a, KM95] </ref>. Our read-k algorithm can be used to enumerate all of the keys of a single relation, provided that no attribute participates in more than k (constant) minimal keys. The time required is polynomial in the size of the relation and the number of minimal keys.
Reference: [MT96] <author> Heikki Mannila and Hannu Toivonen. </author> <title> On an algorithm for finding all interesting sentences. </title> <journal> Cybernetics and Systems, R. Trappl, ed., </journal> <pages> pages 973-978, </pages> <year> 1996. </year>
Reference-contexts: In addition to providing high-level information about a relation, the keys can be used for verifying that a collection of mined rules are in fact all 3 of the interesting rules in a relation <ref> [MT96] </ref>. Similarly, key enumeration is related to the problem of finding a small cover for the set of functional dependencies that hold in a database; a problem useful in database design or query processing [MR92b, MR92a, KM95].
Reference: [MT97] <author> Heikki Mannila and Hannu Toivonen. </author> <title> Levelwise Search and Borders of Theories in Knowledge Discovery. </title> <type> Report C-1997-8, </type> <institution> University of Helsinki, Department of Computer Science, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: Efficiently enumerating association rules has become an important topic in data mining. Typically, a heuristic approach is taken wherein one first enumerates all of the "frequent sets" of T <ref> [AIS93, AS94, GMS97, MT97, AMS + 96, SA95] </ref>. A frequent set is any set of attributes S such that the fraction of rows that have all attributes of S set to 1 is at least .
Reference: [PR96] <author> K. Pillaipakkamnatt and V. Raghavan. </author> <title> On the limits of proper learnability of subclasses of DNF formulas. </title> <journal> Machine Learning, </journal> <volume> 25 </volume> <pages> 237-263, </pages> <year> 1996. </year> <month> 25 </month>
Reference-contexts: The restriction considered in this paper is based on limiting the number of "reads" (occurrences of each variable) in a formula, a restriction that has been well-investigated in the learning-theory literature <ref> [AHK93, PR95, PR96, BHH95a, BHH95b, ABK + 97, AHHP97] </ref>. Previous work has shown that it is possible to find the minterms of an arbitrary monotone read-once (^; _) formula under a stronger notion of polynomial time [AHK93, GK95].
Reference: [PR95] <author> K. Pillaipakkamnatt and V. Raghavan. </author> <title> Read-twice DNF formulas are properly learn-able. </title> <journal> Information and Computation, </journal> <volume> 122(2) </volume> <pages> 236-267, </pages> <year> 1995. </year>
Reference-contexts: The restriction considered in this paper is based on limiting the number of "reads" (occurrences of each variable) in a formula, a restriction that has been well-investigated in the learning-theory literature <ref> [AHK93, PR95, PR96, BHH95a, BHH95b, ABK + 97, AHHP97] </ref>. Previous work has shown that it is possible to find the minterms of an arbitrary monotone read-once (^; _) formula under a stronger notion of polynomial time [AHK93, GK95].
Reference: [SA95] <author> R. Srikant, R. Agrawal. </author> <title> Mining Generalized Association Rules. </title> <booktitle> In Proceedings of the 21st International Conference on Very Large Databases. </booktitle> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Efficiently enumerating association rules has become an important topic in data mining. Typically, a heuristic approach is taken wherein one first enumerates all of the "frequent sets" of T <ref> [AIS93, AS94, GMS97, MT97, AMS + 96, SA95] </ref>. A frequent set is any set of attributes S such that the fraction of rows that have all attributes of S set to 1 is at least .
Reference: [SK91] <author> Bart Selman and Henry Kautz. </author> <title> Knowledge compilation using horn approximations. </title> <editor> In Kathleen Dean, Thomas L.; McKeown, editor, </editor> <booktitle> Proceedings of the 9th National Conference on Artificial Intelligence, </booktitle> <pages> pages 904-909. </pages> <publisher> MIT Press, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: The term knowledge compilation is used to denote methods by which one type of representation of knowledge is translated into another, so as to make it easier to use that knowledge. One example, discussed in <ref> [SK91] </ref>, considers compiling arbitrary (non-monotone) CNF formulas into Horn lower and upper bounds in order to make answering entailment questions easier.
Reference: [TIAS77] <author> Shuji Tsukiyama, Mikio Ide, Hiromu Ariyoshi, and Isao Shirakawa. </author> <title> A new algorithm for generating all the maximal independent sets. </title> <journal> SIAM Journal on Computing, </journal> <volume> 6(3) </volume> <pages> 505-517, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: For example, in the event that each clause of the CNF has at most two variables, efficient solutions have been given under various definitions of efficiency <ref> [JPY88, LLK80, TIAS77, KW85] </ref>. Extending this work, Eiter and Gottlob [EG95] give an efficient algorithm when the size of each clause is bounded by some constant.
Reference: [Val84] <author> L. G. Valiant. </author> <title> A theory of the learnable. </title> <journal> Commun. ACM, </journal> <volume> 27(11) </volume> <pages> 1134-1142, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: as input a hypothesis h and returns "yes" if h is equivalent to f and otherwise an arbitrary counterexample y 2 f0; 1g n such that h (y) 6= f (y) is returned. 20 One of the early positive results in this model is due to Angluin [Ang88] (see also <ref> [Val84] </ref>) and states that the class of monotone DNF formulas is exactly learnable using membership and equivalence queries. The time and number of queries is polynomial in the number of terms of the DNF D to be learned.
References-found: 41

