URL: http://www.cse.psu.edu/~catuscia/teaching/cg520/papers_and_books/lambda-trees.ps.gz
Refering-URL: http://www.cse.psu.edu/~catuscia/teaching/cg520/98Fall/references.html
Root-URL: http://www.cse.psu.edu
Email: dale@cse.psu.edu, catuscia@cse.psu.edu  
Phone: Phone: (814) 865-9505, FAX: (814) 865-3176  
Title: Foundational Aspects of Syntax  
Author: Dale Miller and Catuscia Palamidessi 
Web: http://www.cse.psu.edu/~dale http://www.cse.psu.edu/~catuscia  
Address: Park, PA 16802-6106 USA  
Affiliation: Department of Computer Science and Engineering The Pennsylvania State University 220 Pond Laboratory University  
Abstract-found: 0
Intro-found: 1
Reference: [Chu40] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: For example, x:p (a; x) oe q (f (x); a) represents an abstraction of a term over a formula and this expression has the type term ! formula. As Church argued in <ref> [Chu40] </ref>, most binding operators can be encoded by using -abstraction. For instance, both the universal and existential quantifier in the example above would be modified to take one argument of type term ! formula instead of the two arguments of type variable and formula.
Reference: [HHP93] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the ACM, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <year> 1993. </year>
Reference-contexts: Inference rules such as the second one are easily expressible in hereditary Harrop formulas [MNPS91], the logical foundations of Isabelle [Pau90] and Prolog [NM88], and in the dependent typed -calculus <ref> [HHP93] </ref>, which has been mechanized by Pfenning in Elf [Pfe89]. The conventional approach to specifying such a typing judgment would involve an explicit context of typing assumptions and an explicit treatment of bound variables names, either as strings or deBruijn numbers.
Reference: [Mil91] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <journal> Journal of Logic and Computation, </journal> <volume> 1(4) </volume> <pages> 497-536, </pages> <year> 1991. </year>
Reference-contexts: If meta-variables are applied only to distinct bound variables, then fi 0 is complete with respect to fi, matching and unification are decidable and unitary <ref> [Mil91] </ref>, and can actually be solved in linear time [Qia93]. Recursion over -trees. A second major aspect of computing with -trees is how to define recursion over them: namely, how does one compute on subex-pressions of a -abstraction to determine a value for the full expression.
Reference: [MM97] <author> Raymond McDowell and Dale Miller. </author> <title> A logic for reasoning with higher-order abstract syntax. </title> <editor> In Glynn Winskel, editor, </editor> <booktitle> Proceedings of teh 1997 Symposium on Logic and Computer Science, </booktitle> <year> 1997. </year>
Reference-contexts: Using induction to reason about computations specified using hypothetical and generic judgments is difficult, but some approaches have been proposed recently <ref> [MM97] </ref>. Logic programming languages and rewriting systems [Nip91] are the only ones programming language paradigms that have successfully supported -tree syntax: it would be quite interesting to see if other programming languages can encompass this approach to representation.
Reference: [MMP96] <author> Raymond McDowell, Dale Miller, and Catuscia Palamidessi. </author> <title> Encoding transition systems in sequent calculus: Preliminary report. </title> <booktitle> Electronic Notes in Theoretical Computer Science, </booktitle> <volume> 3, </volume> <year> 1996. </year>
Reference-contexts: We use j (written as infix) of type proc ! proc ! proc to denote parallel composition and of type (name ! proc) ! proc to denote restriction. To encode the labeled transition system <ref> [MMP96] </ref> of the -calculus, we introduce another type action with three constructors for it: o of type action denotes the silent action and # and ", both of type name ! name ! action, denote the input and output, respectively, on one named channel with a named value.
Reference: [MN87] <author> Dale Miller and Gopalan Nadathur. </author> <title> A logic programming approach to manipulating formulas and programs. </title> <editor> In Seif Haridi, editor, </editor> <booktitle> IEEE Symposium on Logic Programming, </booktitle> <pages> pages 379-388, </pages> <address> San Francisco, </address> <month> September </month> <year> 1987. </year>
Reference-contexts: Fortunately, there have been a large number of advances in the theory of syntax, particularly resulting from proof theory of intuitionistic logic, higher-type quantification, and dependent -calculus, that suggest an alternative approach <ref> [MN87, PE88] </ref>, which we call here the -tree syntax. The -tree syntax This approach enriches the parse tree representation in the following two ways. (1) Bindings are denoted by -abstractions and the abstracted expressions are given new syntactic categories formed using the type arrow constructor.
Reference: [MNPS91] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year> <month> 5 </month>
Reference-contexts: Inference rules such as the second one are easily expressible in hereditary Harrop formulas <ref> [MNPS91] </ref>, the logical foundations of Isabelle [Pau90] and Prolog [NM88], and in the dependent typed -calculus [HHP93], which has been mechanized by Pfenning in Elf [Pfe89].
Reference: [MPW92] <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A calculus of mobile processes, Part I. </title> <booktitle> Information and Computation, </booktitle> <pages> pages 1-40, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: An additional example We show here how to use -trees to encode the -calculus <ref> [MPW92] </ref>. We need two syntactic categories, name for channels and proc for processes. <p> P output in x M * M input 8y (M y ! M 0 y) "x open P * M Q * N o close P * M A par #x "xy P jQ ! (M y)jQ 0 4 One advantage of this style of specification over the traditional one <ref> [MPW92] </ref> is the absence of complicated side-conditions on variables: they are handled directly by the logical mechanisms described above. Open Problems There are many open questions, however, regarding -tree syntax.
Reference: [Nip91] <author> Tobias Nipkow. </author> <title> Higher-order critical pairs. </title> <editor> In G. Kahn, editor, </editor> <booktitle> Sixth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 342-349. </pages> <publisher> IEEE, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: Using induction to reason about computations specified using hypothetical and generic judgments is difficult, but some approaches have been proposed recently [MM97]. Logic programming languages and rewriting systems <ref> [Nip91] </ref> are the only ones programming language paradigms that have successfully supported -tree syntax: it would be quite interesting to see if other programming languages can encompass this approach to representation.
Reference: [NM88] <author> Gopalan Nadathur and Dale Miller. </author> <title> An Overview of Prolog. </title> <booktitle> In Fifth International Logic Programming Conference, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Washington, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Inference rules such as the second one are easily expressible in hereditary Harrop formulas [MNPS91], the logical foundations of Isabelle [Pau90] and Prolog <ref> [NM88] </ref>, and in the dependent typed -calculus [HHP93], which has been mechanized by Pfenning in Elf [Pfe89]. The conventional approach to specifying such a typing judgment would involve an explicit context of typing assumptions and an explicit treatment of bound variables names, either as strings or deBruijn numbers.
Reference: [Pau90] <author> Lawrence C. Paulson. </author> <title> Isabelle: The next 700 theorem provers. </title> <editor> In Piergiorgio Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 361-386. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: Inference rules such as the second one are easily expressible in hereditary Harrop formulas [MNPS91], the logical foundations of Isabelle <ref> [Pau90] </ref> and Prolog [NM88], and in the dependent typed -calculus [HHP93], which has been mechanized by Pfenning in Elf [Pfe89].
Reference: [PE88] <author> Frank Pfenning and Conal Elliot. </author> <title> Higher-order abstract syntax. </title> <booktitle> In Proceedings of the ACM-SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 199-208. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: Fortunately, there have been a large number of advances in the theory of syntax, particularly resulting from proof theory of intuitionistic logic, higher-type quantification, and dependent -calculus, that suggest an alternative approach <ref> [MN87, PE88] </ref>, which we call here the -tree syntax. The -tree syntax This approach enriches the parse tree representation in the following two ways. (1) Bindings are denoted by -abstractions and the abstracted expressions are given new syntactic categories formed using the type arrow constructor.
Reference: [Pfe89] <author> Frank Pfenning. </author> <title> Elf: A language for logic definition and verified metaprogramming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 313-321, </pages> <address> Monterey, CA, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Inference rules such as the second one are easily expressible in hereditary Harrop formulas [MNPS91], the logical foundations of Isabelle [Pau90] and Prolog [NM88], and in the dependent typed -calculus [HHP93], which has been mechanized by Pfenning in Elf <ref> [Pfe89] </ref>. The conventional approach to specifying such a typing judgment would involve an explicit context of typing assumptions and an explicit treatment of bound variables names, either as strings or deBruijn numbers.
Reference: [Qia93] <author> Zhenyu Qian. </author> <title> Linear unification of higher-order patterns. </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Proc. 1993 Coll. Trees in Algebra and Programming. </booktitle> <publisher> Springer Verlag LNCS, </publisher> <year> 1993. </year> <month> 6 </month>
Reference-contexts: If meta-variables are applied only to distinct bound variables, then fi 0 is complete with respect to fi, matching and unification are decidable and unitary [Mil91], and can actually be solved in linear time <ref> [Qia93] </ref>. Recursion over -trees. A second major aspect of computing with -trees is how to define recursion over them: namely, how does one compute on subex-pressions of a -abstraction to determine a value for the full expression.
References-found: 14

