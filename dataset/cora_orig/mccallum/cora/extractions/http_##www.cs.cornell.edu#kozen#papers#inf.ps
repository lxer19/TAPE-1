URL: http://www.cs.cornell.edu/kozen/papers/inf.ps
Refering-URL: http://www.cs.cornell.edu/kozen/papers/papers.html
Root-URL: 
Email: kozen@cs.cornell.edu  palsberg@daimi.aau.dk  mis@daimi.aau.dk  
Title: Efficient Inference of Partial Types  
Author: Dexter Kozen Jens Palsberg Michael I. Schwartzbach 
Address: Ithaca, New York 14853-7501 USA  Denmark  Denmark  
Affiliation: Computer Science Department Cornell University  Computer Science Department Aarhus University 8000 Aarhus C  Computer Science Department Aarhus University 8000 Aarhus C  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <booktitle> In Proc. 18th Symp. Princip. Programming Lang., </booktitle> <pages> pages 104-118. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: The result now follows from (iii) and the definitions of e and on types. 2 11 Amadio and Cardelli <ref> [1] </ref> give an alternative definition of a partial order on recursive types involving infinite chains of finite approximations. Definition 4 is equivalent to theirs [4]. <p> if both (a) [s; ff] ! [v; 0] ff (ii) (s) ! (t) if and only if ff = R k for some k and [s; 0] ff (iii) (s) ! ( ) if and only if ff = R k L for some k and [s; 0] ff ! <ref> [t; 1] </ref> for some t. Proof. We prove the three parts in turn. <p> Proof. We prove the three parts in turn. In each case we proceed by induction on ff. 16 (i) If ff = * then (s; s) ! (u; v) , u ! s ^ s ! v * * , [s; *] ! [v; 0] ^ [s; *] ! <ref> [u; 1] </ref> : If ff = fiL then (s; s) ! (p; q) ! (q 0 ; p 0 ) ! (u; v) : By the induction hypothesis, this is equivalent to [s; fi] ! [q; 0] ^ [s; fi] ! [p; 1] ^ L L ! v fi L * <p> [s; *] ! [v; 0] ^ [s; *] ! [u; 1] : If ff = fiL then (s; s) ! (p; q) ! (q 0 ; p 0 ) ! (u; v) : By the induction hypothesis, this is equivalent to [s; fi] ! [q; 0] ^ [s; fi] ! <ref> [p; 1] </ref> ^ L L ! v fi L * [s; fi] ! [p; 1] ! [p 0 ; 0] ! [v; 0] fiL fiL , [s; fiL] ! [v; 0] ^ [s; fiL] ! [u; 1] : If ff = fiR then (s; s) ! (p; q) ! (p 0 <p> ff = fiL then (s; s) ! (p; q) ! (q 0 ; p 0 ) ! (u; v) : By the induction hypothesis, this is equivalent to [s; fi] ! [q; 0] ^ [s; fi] ! <ref> [p; 1] </ref> ^ L L ! v fi L * [s; fi] ! [p; 1] ! [p 0 ; 0] ! [v; 0] fiL fiL , [s; fiL] ! [v; 0] ^ [s; fiL] ! [u; 1] : If ff = fiR then (s; s) ! (p; q) ! (p 0 ; q 0 ) ! (u; v) : By the induction hypothesis, this <p> induction hypothesis, this is equivalent to [s; fi] ! [q; 0] ^ [s; fi] ! [p; 1] ^ L L ! v fi L * [s; fi] ! [p; 1] ! [p 0 ; 0] ! [v; 0] fiL fiL , [s; fiL] ! [v; 0] ^ [s; fiL] ! <ref> [u; 1] </ref> : If ff = fiR then (s; s) ! (p; q) ! (p 0 ; q 0 ) ! (u; v) : By the induction hypothesis, this is equivalent to [s; fi] ! [q; 0] ^ [s; fi] ! [p; 1] ^ R R ! v fi R * <p> [s; fiL] ! [v; 0] ^ [s; fiL] ! [u; 1] : If ff = fiR then (s; s) ! (p; q) ! (p 0 ; q 0 ) ! (u; v) : By the induction hypothesis, this is equivalent to [s; fi] ! [q; 0] ^ [s; fi] ! <ref> [p; 1] </ref> ^ R R ! v fi R * [s; fi] ! [p; 1] ! [p 0 ; 1] ! [u; 1] fiR fiR , [s; fiR] ! [v; 0] ^ [s; fiR] ! [u; 1] : (ii) If ff = * then (s) ! (t) , s ! t <p> ff = fiR then (s; s) ! (p; q) ! (p 0 ; q 0 ) ! (u; v) : By the induction hypothesis, this is equivalent to [s; fi] ! [q; 0] ^ [s; fi] ! <ref> [p; 1] </ref> ^ R R ! v fi R * [s; fi] ! [p; 1] ! [p 0 ; 1] ! [u; 1] fiR fiR , [s; fiR] ! [v; 0] ^ [s; fiR] ! [u; 1] : (ii) If ff = * then (s) ! (t) , s ! t * 17 If ff = fiR then (s) ! (p) ! (p 0 <p> then (s; s) ! (p; q) ! (p 0 ; q 0 ) ! (u; v) : By the induction hypothesis, this is equivalent to [s; fi] ! [q; 0] ^ [s; fi] ! [p; 1] ^ R R ! v fi R * [s; fi] ! [p; 1] ! <ref> [p 0 ; 1] </ref> ! [u; 1] fiR fiR , [s; fiR] ! [v; 0] ^ [s; fiR] ! [u; 1] : (ii) If ff = * then (s) ! (t) , s ! t * 17 If ff = fiR then (s) ! (p) ! (p 0 ) ! (t) <p> q) ! (p 0 ; q 0 ) ! (u; v) : By the induction hypothesis, this is equivalent to [s; fi] ! [q; 0] ^ [s; fi] ! [p; 1] ^ R R ! v fi R * [s; fi] ! [p; 1] ! [p 0 ; 1] ! <ref> [u; 1] </ref> fiR fiR , [s; fiR] ! [v; 0] ^ [s; fiR] ! [u; 1] : (ii) If ff = * then (s) ! (t) , s ! t * 17 If ff = fiR then (s) ! (p) ! (p 0 ) ! (t) : By the induction hypothesis, <p> induction hypothesis, this is equivalent to [s; fi] ! [q; 0] ^ [s; fi] ! [p; 1] ^ R R ! v fi R * [s; fi] ! [p; 1] ! [p 0 ; 1] ! <ref> [u; 1] </ref> fiR fiR , [s; fiR] ! [v; 0] ^ [s; fiR] ! [u; 1] : (ii) If ff = * then (s) ! (t) , s ! t * 17 If ff = fiR then (s) ! (p) ! (p 0 ) ! (t) : By the induction hypothesis, this is equivalent to fi = R k ^ [s; 0] ! [p; 0] <p> ^ [s; 0] ! [p; 0] ^ p ! t fiL 2 Lemma 14 For any string ff, ff 2 L (s) if and only if there exist fi; k; u; v such that (i) ff = fiR k or ff = fiR k L, ff (iii) [s; fi] ! <ref> [u; 1] </ref>. Here denotes addition mod 2. Proof. First assume ff 2 L (s). Then (s; s) ff ! p for some state p. <p> Here denotes addition mod 2. Proof. First assume ff 2 L (s). Then (s; s) ff ! p for some state p. If p = (u; v) then (s; s) ff ! (u; v), so by Lemma 13 we have [s; ff] ! [v; 0] ^ [s; ff] ! <ref> [u; 1] </ref> : But then we can choose ff = fi and k = 0. <p> If p = (v) then for some fi; fl we have (s; s) ! (u; q) ! (q) ! (v) so by Lemma 13 we have fl = R k ^ [s; fi] ! [q; 0] ! [v; 0] ^ [s; fi] ! <ref> [u; 1] </ref> : Since ff = fi, this is equivalent to ff = fiR k ^ [s; fi] ! [v; ff fi] ^ [s; fi] ! [u; 1] and we are done. <p> (v) so by Lemma 13 we have fl = R k ^ [s; fi] ! [q; 0] ! [v; 0] ^ [s; fi] ! <ref> [u; 1] </ref> : Since ff = fi, this is equivalent to ff = fiR k ^ [s; fi] ! [v; ff fi] ^ [s; fi] ! [u; 1] and we are done. <p> If p = ( ) then for some fi; fl we have (s; s) ! (u; q) ! (q) ! ( ) so by Lemma 13 we have fl = R k L ^ [s; fi] ! [q; 0] ! <ref> [v; 1] </ref> ^ [s; fi] ! [u; 1] : Since ff 6= fi, this is equivalent to ff = fiR k L ^ [s; fi] ! [v; ff fi] ^ [s; fi] ! [u; 1] and we are done. Conversely, assume (i)-(iii). <p> If p = ( ) then for some fi; fl we have (s; s) ! (u; q) ! (q) ! ( ) so by Lemma 13 we have fl = R k L ^ [s; fi] ! [q; 0] ! [v; 1] ^ [s; fi] ! <ref> [u; 1] </ref> : Since ff 6= fi, this is equivalent to ff = fiR k L ^ [s; fi] ! [v; ff fi] ^ [s; fi] ! [u; 1] and we are done. Conversely, assume (i)-(iii). <p> by Lemma 13 we have fl = R k L ^ [s; fi] ! [q; 0] ! [v; 1] ^ [s; fi] ! <ref> [u; 1] </ref> : Since ff 6= fi, this is equivalent to ff = fiR k L ^ [s; fi] ! [v; ff fi] ^ [s; fi] ! [u; 1] and we are done. Conversely, assume (i)-(iii). We have ff = fifl where fl = R k or R k L, and [s; fi] ! [v; fl] fi We must have [s; fi] ! [p; 0] ! [v; fl] for some p. <p> If ff = Lfi then from Lemma 14 there exist fl, k, p, and q such that fi = flR k or fi = flR k L and [u; Lfl] ! [p; ff Lfl] ^ [u; Lfl] ! <ref> [q; 1] </ref> Since [u; Lfl] L L follows that [v; fl] ! [p; fi fl] ^ [v; fl] ! [q; 1] so fi 2 L (v) and ff 2 L (v) L (w). <p> 14 there exist fl, k, p, and q such that fi = flR k or fi = flR k L and [u; Lfl] ! [p; ff Lfl] ^ [u; Lfl] ! <ref> [q; 1] </ref> Since [u; Lfl] L L follows that [v; fl] ! [p; fi fl] ^ [v; fl] ! [q; 1] so fi 2 L (v) and ff 2 L (v) L (w). <p> If ff = Rfi then from Lemma 14 there exist fl, k, p, and q such that fi = flR k or fi = flR k L and [u; Rfl] ! [p; ff Rfl] ^ [u; Rfl] ! <ref> [q; 1] </ref> Since [u; Rfl] R R follows that [w; fl] ! [p; fi fl] ^ [w; fl] ! [q; 1] Second, we show (ii). <p> 14 there exist fl, k, p, and q such that fi = flR k or fi = flR k L and [u; Rfl] ! [p; ff Rfl] ^ [u; Rfl] ! <ref> [q; 1] </ref> Since [u; Rfl] R R follows that [w; fl] ! [p; fi fl] ^ [w; fl] ! [q; 1] Second, we show (ii). <p> for some k and ffR = fi 0 ; thus from (8) and [s; ff] * [s; ff] ! [u 0 ; 0] : (9) [s; fi] ! [u 0 ; ff fi] fi 21 If ff 6= fi, we use (9) and (6) to get ffR [s; ff] ! <ref> [u; 1] </ref> : In either case we have ffR 2 L (s) by Lemma 14. To show that L is minimal, we need to show that for any other solution h : S ! b T , L (s) h (s) for all s. <p> To show that L is minimal, we need to show that for any other solution h : S ! b T , L (s) h (s) for all s. This follows directly from Lemma 11. 2 Recursive types are just regular trees <ref> [1] </ref>. The canonical solution we have constructed, although possibly infinite, is a regular tree. Thus we have solved the type inference problem for recursive types left open in [5]. Specifically, given a -term, we construct the corresponding constraint graph and automaton M.
Reference: [2] <author> Fritz Henglein. </author> <type> Personal communication, </type> <year> 1992. </year>
Reference-contexts: Thus the typability question reduces essentially to the finiteness problem for regular sets. Our construction works equally well for recursive types; this solves an open problem stated in [5]. Henglein <ref> [2] </ref> has shown that the type inference problem for partial types is P -hard; thus it is P -complete. It can also be shown that every -term with a partial type is strongly normalizing [9] and that every -term in normal form has a partial type [6].
Reference: [3] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient inference of partial types. </title> <booktitle> In Proc. 33rd Symp. Found. Comput. Sci., </booktitle> <pages> pages 363-371. </pages> <publisher> IEEE, </publisher> <month> October </month> <year> 1992. </year>
Reference-contexts: Army Research Office through ACSyAM, Mathematical Sciences Institute, Cornell University, contract DAAL03-91-C-0027. These results were obtained while he was on sabbatical at Aarhus University, Denmark. A preliminary version of this paper appeared as <ref> [3] </ref>.
Reference: [4] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient recursive subtyping. </title> <booktitle> In Proc. 20th ACM Symp. Princip. Programming Lang., </booktitle> <pages> pages 419-428. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: The result now follows from (iii) and the definitions of e and on types. 2 11 Amadio and Cardelli [1] give an alternative definition of a partial order on recursive types involving infinite chains of finite approximations. Definition 4 is equivalent to theirs <ref> [4] </ref>. Lemma 6 The following properties hold for all ; t . (i) (R 2 ^ R 2 t ^ t ) ) ( # L t # L) ^ ( # R t # R); Proof.
Reference: [5] <author> Patrick M. O'Keefe and Mitchell Wand. </author> <title> Type inference for partial types is decidable. </title> <booktitle> In Proc. ESOP'92, European Symposium on Programming, volume 582 of Lect. Notes in Comput. Sci., </booktitle> <pages> pages 408-417. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: We give this reduction and prove its correctness in Section 2. In his original paper [8], Thatte showed that the type inference problem for partial types is semidecidable. The problem of decidability remained unsolved until quite recently, when O'Keefe and Wand <ref> [5] </ref> presented an exponential time algorithm. Their algorithm involves iterated substitution and gives no hint of the possibility of the existence of canonical solutions; indeed, there exist satisfiable constraint systems with no -minimal solution. <p> Thus the typability question reduces essentially to the finiteness problem for regular sets. Our construction works equally well for recursive types; this solves an open problem stated in <ref> [5] </ref>. Henglein [2] has shown that the type inference problem for partial types is P -hard; thus it is P -complete. It can also be shown that every -term with a partial type is strongly normalizing [9] and that every -term in normal form has a partial type [6]. <p> This follows directly from Lemma 11. 2 Recursive types are just regular trees [1]. The canonical solution we have constructed, although possibly infinite, is a regular tree. Thus we have solved the type inference problem for recursive types left open in <ref> [5] </ref>. Specifically, given a -term, we construct the corresponding constraint graph and automaton M. Every subterm corresponds to a node s in the constraint graph, and its Bohm-minimal type annotation is represented by the language L (s). Note that the Bohm-minimal type of any typable -term trivially is . <p> our algorithm computes, is f : ( ! ( ! )):(f (x : :y : :x)(f (z : :z))) In the following section we give an efficient decision procedure for the exis tence of a finite type. 7 An Algorithm We have argued that the type inference problem studied in <ref> [8, 5] </ref> is equivalent to the following: given a finite constraint graph G, does G have a finite solution? Using the characterization of the previous section, we can answer this question easily.
Reference: [6] <author> Jens Palsberg. </author> <title> Normal forms have partial types. </title> <journal> Information Processing Letters, </journal> <volume> 45(1) </volume> <pages> 1-3, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Henglein [2] has shown that the type inference problem for partial types is P -hard; thus it is P -complete. It can also be shown that every -term with a partial type is strongly normalizing [9] and that every -term in normal form has a partial type <ref> [6] </ref>.
Reference: [7] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference for partial types. </title> <journal> Infor. Processing Letters, </journal> <volume> 43(4) </volume> <pages> 175-180, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The rule (2) must have been applied to obtain a judgement of the form B 0 ` x : L (x) and only rule (5) 8 applied to that occurrence of x thereafter, thus L (x) L ([[x]]). 2 A similar constraint system was used without proof in <ref> [7] </ref>. Except for a minor misstatement in the formulation of [7], the two constraint systems are equivalent. 3 From Types to Trees Partial types are essentially binary trees, which can be represented as as certain sets of strings over the binary alphabet fL; Rg. <p> obtain a judgement of the form B 0 ` x : L (x) and only rule (5) 8 applied to that occurrence of x thereafter, thus L (x) L ([[x]]). 2 A similar constraint system was used without proof in <ref> [7] </ref>. Except for a minor misstatement in the formulation of [7], the two constraint systems are equivalent. 3 From Types to Trees Partial types are essentially binary trees, which can be represented as as certain sets of strings over the binary alphabet fL; Rg. In this section we develop some elementary properties of this representation and generalize to infinite trees.
Reference: [8] <author> Satish Thatte. </author> <title> Type inference with partial types. </title> <booktitle> In Proc. International Colloquium on Automata, Languages, and Programming 1988, volume 317 of Lect. Notes in Comput. Sci., </booktitle> <pages> pages 615-629. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <month> 25 </month>
Reference-contexts: 1 Introduction Partial types for the pure -calculus were introduced by Thatte in 1988 <ref> [8] </ref> as a way to type certain -terms that are untypable in the simply-typed -calculus. They are of substantial pragmatic value, since they allow the typing of such constructs as heterogeneous lists and persistent data that would otherwise be untypable. <p> Formally, this holds when the judgement (1) is derivable using the following four rules, first proposed by Thatte <ref> [8] </ref>: A ` x : t (provided A (x) = t) (2) A [x s] ` E : t (3) A ` E : s ! t A ` F : s (4) A ` E : t The first three rules are the usual rules for simple types and the <p> We give this reduction and prove its correctness in Section 2. In his original paper <ref> [8] </ref>, Thatte showed that the type inference problem for partial types is semidecidable. The problem of decidability remained unsolved until quite recently, when O'Keefe and Wand [5] presented an exponential time algorithm. <p> our algorithm computes, is f : ( ! ( ! )):(f (x : :y : :x)(f (z : :z))) In the following section we give an efficient decision procedure for the exis tence of a finite type. 7 An Algorithm We have argued that the type inference problem studied in <ref> [8, 5] </ref> is equivalent to the following: given a finite constraint graph G, does G have a finite solution? Using the characterization of the previous section, we can answer this question easily.
Reference: [9] <author> Mitchell Wand and Patrick M. O'Keefe. </author> <title> Partially typed terms are strongly normalizing. </title> <type> Manuscript, </type> <month> December </month> <year> 1991. </year> <month> 26 </month>
Reference-contexts: Henglein [2] has shown that the type inference problem for partial types is P -hard; thus it is P -complete. It can also be shown that every -term with a partial type is strongly normalizing <ref> [9] </ref> and that every -term in normal form has a partial type [6].
References-found: 9

