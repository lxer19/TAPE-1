URL: http://www.cs.wisc.edu/~shoup/papers/db2.ps.Z
Refering-URL: http://www.cs.wisc.edu/~shoup/papers/
Root-URL: 
Email: Email: rafail@bellcore.com  Email: sho@zurich.ibm.com  
Title: Private Information Storage (Extended Abstract)  
Author: Rafail Ostrovsky Victor Shoup 
Address: MCC-1C365B, Morristown, NJ 07960-6438, USA.  8803 Ruschlikon, Switzerland.  
Note: Bell Communications Research,  Work done while at Bellcore. Current addr: IBM Research-Zurich, Saumerstr. 4,  
Date: May 1997  
Affiliation: Bellcore Bellcore, IBM  
Abstract: This paper deals with the problem of efficiently and privately storing and retrieving information that is distributively maintained in several databases that do not communicate with one another. The goal is to minimize the communication complexity while maintaining privacy (i.e., so that individual databases do not get any information about the data or the nature of the users' queries). The question of private retrieval from multiple databases was introduced in a very nice paper of Chor, Goldreich, Kushilevitz and Sudan (FOCS '95), but the question whether it is possible to perform both reading and writing in a communication-efficient manner remained open. In this paper, we answer this question in the affirmative, and show that efficient read/write schemes are indeed possible. In fact, we show a general information-theoretic reduction from reading and writing to any read-only scheme that preserves the communication complexity of the read scheme to within a poly-logarithmic factor (in the size of the database), thus establishing that read/write schemes could be implemented as efficiently (up to poly-log factors) as read-only schemes. Additionally, we consider the question of both reading and writing in the computational security setting. 
Abstract-found: 1
Intro-found: 1
Reference: [AFK-89] <author> M. Abadai, J. Feigenbaum, and J. Kilian. </author> <title> On hiding information from an oracle. </title> <journal> JCSS 39(1) </journal> <pages> 21-50, </pages> <year> 1989. </year>
Reference-contexts: S. Government's Clipper Chip proposal [U.S.-93], Micali's fair-cryptosystems [M-92], secret-sharing schemes [S-79], and instance-hiding schemes <ref> [RAD-78, AFK-89, BF-90, BFKL-90] </ref>. Closely related to the private storage problem is the oblivious RAM simulation problem, studied in [G-87, Ost-90, GO-96], and indeed the techniques we employ here build on those used to solve the oblivious RAM simulation problem. So, let us mention that setting here.
Reference: [N-89] <author> N. Adam and J. Wortmann. </author> <title> Security control methods for statistical databases: a comparative study. </title> <journal> ACM Computing Surveys 21(4) </journal> <pages> 515-555, </pages> <year> 1989. </year>
Reference: [Amb-96] <author> A. Ambainis. </author> <title> Upper bound on the communication complexity of private information retrieval. </title> <note> On-line version published in Theory of Cryptography Library, http://theory.lcs.mit.edu/~tcryptol, May 1996. </note>
Reference-contexts: The advantage of this setting is that the users need not keep any state information, and the security achieved is information-theoretic. This is the approach we follow in this paper. The case of reading-only schemes was considered in <ref> [CGKS-95, Amb-96, CG-97] </ref>; here we address the question of both writing and reading. <p> Throughout this paper, communication complexity will be expressed as a function R (k; n) of k and n, and measured in terms of worst-case (as opposed to amortized or average-case) behavior. VARIANTS OF THE PROBLEM: There are several variants of the above setting: * Number of Constituent Databases. In <ref> [CGKS-95, Amb-96, CG-97] </ref> as well as in the current paper, we examine the dependence between the number of constituent databases k and the total commu nication complexity, between the user and all the databases. * Identical vs. Distinct Databases. <p> In case of writing, 5 where we wish to hide the data as well, we allow constituent databases to hold "shares" [S-79] of the actual database. Thus, in our setting we allow (and utilize the fact) that constituent databases need not be identical. * Rounds. In the setting of <ref> [CGKS-95, Amb-96, CG-97] </ref>, a single round of interaction between the user and the constituent databases (where the user sends a single message to each constituent database and gets an answer back) is used. In our solutions, we use multiple rounds. * Privacy. <p> We remark that the private reading schemes of <ref> [CGKS-95, Amb-96] </ref> (where all constituent databases are identical) are resistant against this stronger type of an adversary. However, if constituent databases keep different "shares" of the actual database, and for the case of writing, more care must be exercised against this stronger adversary. * Computational Efficiency. <p> INFORMATION-THEORETIC SETTING. As mentioned above, our work builds on that of [CGKS-95]. They consider a restricted version of our problem where users are only allowed to perform read operations (further efficiency improvement was suggested by <ref> [Amb-96] </ref>.) All of their schemes have the additional property that each constituent database simply maintains identical copies of the composite database. We will call such a scheme a private read scheme. <p> of certifying (with overwhelming probability) if data has been tampered with, as long as there exists at least one non-corrupted database. * Our reductions "preserve" active security, in the sense that if the underlying read-only scheme is secure against such an active attack (which does hold in the case of <ref> [CGKS-95, Amb-96] </ref>) then our resulting read/write scheme is also secure in this stronger active security model. * In case of writing, one can consider the number of bits not to be fixed, but grow as a function of time. In this case, we get poly-log overhead results as well. <p> Moreover, all the solutions for the Oblivious RAM model of [GO-96] are amortized, where as all our solutions are not. Combining our general reductions with the private read schemes of [CGKS-95] and of <ref> [Amb-96] </ref>, we obtain the following corollary: Corollary 3 To store n bits of data, we have * a three-database private read/write scheme with active security and communication complexity O (n 1=3 (log n) 3 ); 8 * for all constants k 2, a (k + 1)-database private read/write scheme with active <p> Comparison with Previous Work The general approach of distributing information to maintain privacy has been used in many situations, including the previous work on reading from 9 a distributed database <ref> [CGKS-95, Amb-96, CG-97] </ref>, the U. S. Government's Clipper Chip proposal [U.S.-93], Micali's fair-cryptosystems [M-92], secret-sharing schemes [S-79], and instance-hiding schemes [RAD-78, AFK-89, BF-90, BFKL-90]. <p> The problem of performing private database queries with multiple databases that do not interact with one other was studied in two other settings: in instance hiding schemes of [BF-90, BFKL-90] and on private database queries of <ref> [CGKS-95, Amb-96, CG-97] </ref>. In both of these settings, the contents of the database is static, and each constituent database maintains exact copies of the database. Our work shows how to support dynamic databases, while maintaining privacy.
Reference: [BF-90] <author> D. Beaver and J. Feigenbaum. </author> <title> Hiding instances in multi-oracle queries. </title> <booktitle> In Proc. of 7th STACS, Springer-Verlag LNCS, </booktitle> <volume> Vol. 415, </volume> <pages> pp. 37-48, </pages> <year> 1990. </year>
Reference-contexts: S. Government's Clipper Chip proposal [U.S.-93], Micali's fair-cryptosystems [M-92], secret-sharing schemes [S-79], and instance-hiding schemes <ref> [RAD-78, AFK-89, BF-90, BFKL-90] </ref>. Closely related to the private storage problem is the oblivious RAM simulation problem, studied in [G-87, Ost-90, GO-96], and indeed the techniques we employ here build on those used to solve the oblivious RAM simulation problem. So, let us mention that setting here. <p> The problem of performing private database queries with multiple databases that do not interact with one other was studied in two other settings: in instance hiding schemes of <ref> [BF-90, BFKL-90] </ref> and on private database queries of [CGKS-95, Amb-96, CG-97]. In both of these settings, the contents of the database is static, and each constituent database maintains exact copies of the database. Our work shows how to support dynamic databases, while maintaining privacy.
Reference: [BFKL-90] <author> D. Beaver, J. Feigenbaum, J. Kilian, and P. Rogaway. </author> <title> Security with low communication overhead. </title> <booktitle> In Advances in Cryptology|Proc. Crypto '90, </booktitle> <year> 1990. </year>
Reference-contexts: S. Government's Clipper Chip proposal [U.S.-93], Micali's fair-cryptosystems [M-92], secret-sharing schemes [S-79], and instance-hiding schemes <ref> [RAD-78, AFK-89, BF-90, BFKL-90] </ref>. Closely related to the private storage problem is the oblivious RAM simulation problem, studied in [G-87, Ost-90, GO-96], and indeed the techniques we employ here build on those used to solve the oblivious RAM simulation problem. So, let us mention that setting here. <p> The problem of performing private database queries with multiple databases that do not interact with one other was studied in two other settings: in instance hiding schemes of <ref> [BF-90, BFKL-90] </ref> and on private database queries of [CGKS-95, Amb-96, CG-97]. In both of these settings, the contents of the database is static, and each constituent database maintains exact copies of the database. Our work shows how to support dynamic databases, while maintaining privacy.
Reference: [BGKW-88] <author> M. Ben-or, S. Goldwasser, J. Kilian and A. Wigderson. </author> <title> Multi prover interactive proofs: How to remove intractability. </title> <note> STOC 88. </note>
Reference-contexts: Formally, we model the above setting in a way similar to the multi-prover interactive proof setting of <ref> [BGKW-88] </ref>.
Reference: [B-79] <author> G. R. Blakley. </author> <title> Safeguarding cryptographic keys. </title> <booktitle> In Proc. NCC AFIPS, </booktitle> <pages> pp. 313-317, </pages> <year> 1979. </year>
Reference: [CG-97] <author> B. Chor and N. Gilboa. </author> <note> Computationally Private Information Retrieval In this proceedings - STOC '97. </note>
Reference-contexts: The advantage of this setting is that the users need not keep any state information, and the security achieved is information-theoretic. This is the approach we follow in this paper. The case of reading-only schemes was considered in <ref> [CGKS-95, Amb-96, CG-97] </ref>; here we address the question of both writing and reading. <p> Throughout this paper, communication complexity will be expressed as a function R (k; n) of k and n, and measured in terms of worst-case (as opposed to amortized or average-case) behavior. VARIANTS OF THE PROBLEM: There are several variants of the above setting: * Number of Constituent Databases. In <ref> [CGKS-95, Amb-96, CG-97] </ref> as well as in the current paper, we examine the dependence between the number of constituent databases k and the total commu nication complexity, between the user and all the databases. * Identical vs. Distinct Databases. <p> In case of writing, 5 where we wish to hide the data as well, we allow constituent databases to hold "shares" [S-79] of the actual database. Thus, in our setting we allow (and utilize the fact) that constituent databases need not be identical. * Rounds. In the setting of <ref> [CGKS-95, Amb-96, CG-97] </ref>, a single round of interaction between the user and the constituent databases (where the user sends a single message to each constituent database and gets an answer back) is used. In our solutions, we use multiple rounds. * Privacy. <p> We remark that prior to the current paper no trivial (i.e., sub-linear) bounds for private information storage were known. COMPUTATIONAL SETTING. Chor and Gilboa <ref> [CG-97] </ref> show how in the computational setting, one can keep two identical databases and in one-round perform private reading with O (n * ) communication complexity. We consider a weaker model, where we allow constituent databases to keep different data and allow a multi-round scheme. <p> Comparison with Previous Work The general approach of distributing information to maintain privacy has been used in many situations, including the previous work on reading from 9 a distributed database <ref> [CGKS-95, Amb-96, CG-97] </ref>, the U. S. Government's Clipper Chip proposal [U.S.-93], Micali's fair-cryptosystems [M-92], secret-sharing schemes [S-79], and instance-hiding schemes [RAD-78, AFK-89, BF-90, BFKL-90]. <p> The problem of performing private database queries with multiple databases that do not interact with one other was studied in two other settings: in instance hiding schemes of [BF-90, BFKL-90] and on private database queries of <ref> [CGKS-95, Amb-96, CG-97] </ref>. In both of these settings, the contents of the database is static, and each constituent database maintains exact copies of the database. Our work shows how to support dynamic databases, while maintaining privacy. <p> This should be contrasted with the reading scheme of Chor and Gilboa <ref> [CG-97] </ref>, where they only assume the existence of general one-way functions, keep identical databases and use only a single round of interaction.
Reference: [CGKS-95] <author> B. Chor, O. Goldreich, E. Kushilevitz, and M. Sudan. </author> <title> Private information retrieval. </title> <booktitle> In Proc. 36th Annual IEEE Symp. Foundations Comp. Sci., </booktitle> <pages> pp. 41-50, </pages> <year> 1995. </year>
Reference-contexts: Their scheme, however, still suffers from the second and third drawbacks. A suggestion made in the paper of Chor, Goldreich, Kushilevitz 2 and Sudan <ref> [CGKS-95] </ref> is to use multiple databases that do not talk to one another: MULTIPLE DATABASES [CGKS-95]: The second way to proceed is to distribute the database, so that the composite database is implemented as a number of non-communicating, constituent databases. <p> Their scheme, however, still suffers from the second and third drawbacks. A suggestion made in the paper of Chor, Goldreich, Kushilevitz 2 and Sudan <ref> [CGKS-95] </ref> is to use multiple databases that do not talk to one another: MULTIPLE DATABASES [CGKS-95]: The second way to proceed is to distribute the database, so that the composite database is implemented as a number of non-communicating, constituent databases. The advantage of this setting is that the users need not keep any state information, and the security achieved is information-theoretic. <p> The advantage of this setting is that the users need not keep any state information, and the security achieved is information-theoretic. This is the approach we follow in this paper. The case of reading-only schemes was considered in <ref> [CGKS-95, Amb-96, CG-97] </ref>; here we address the question of both writing and reading. <p> Throughout this paper, communication complexity will be expressed as a function R (k; n) of k and n, and measured in terms of worst-case (as opposed to amortized or average-case) behavior. VARIANTS OF THE PROBLEM: There are several variants of the above setting: * Number of Constituent Databases. In <ref> [CGKS-95, Amb-96, CG-97] </ref> as well as in the current paper, we examine the dependence between the number of constituent databases k and the total commu nication complexity, between the user and all the databases. * Identical vs. Distinct Databases. <p> In [CGKS-95, Amb-96, CG-97] as well as in the current paper, we examine the dependence between the number of constituent databases k and the total commu nication complexity, between the user and all the databases. * Identical vs. Distinct Databases. In the original model of <ref> [CGKS-95] </ref>, there was no distinction made between a constituent database and a global database. That is, since the objective there was to hide the reading pattern only, each constituent database simply held an identical copy of the actual database. <p> In case of writing, 5 where we wish to hide the data as well, we allow constituent databases to hold "shares" [S-79] of the actual database. Thus, in our setting we allow (and utilize the fact) that constituent databases need not be identical. * Rounds. In the setting of <ref> [CGKS-95, Amb-96, CG-97] </ref>, a single round of interaction between the user and the constituent databases (where the user sends a single message to each constituent database and gets an answer back) is used. In our solutions, we use multiple rounds. * Privacy. <p> We remark that the private reading schemes of <ref> [CGKS-95, Amb-96] </ref> (where all constituent databases are identical) are resistant against this stronger type of an adversary. However, if constituent databases keep different "shares" of the actual database, and for the case of writing, more care must be exercised against this stronger adversary. * Computational Efficiency. <p> In addition to communication complexity, we also consider computational complexity needed to execute the protocol by both the user and the constituent databases. 6 Our Results We consider both information-theoretic and computational setting. INFORMATION-THEORETIC SETTING. As mentioned above, our work builds on that of <ref> [CGKS-95] </ref>. They consider a restricted version of our problem where users are only allowed to perform read operations (further efficiency improvement was suggested by [Amb-96].) All of their schemes have the additional property that each constituent database simply maintains identical copies of the composite database. <p> of certifying (with overwhelming probability) if data has been tampered with, as long as there exists at least one non-corrupted database. * Our reductions "preserve" active security, in the sense that if the underlying read-only scheme is secure against such an active attack (which does hold in the case of <ref> [CGKS-95, Amb-96] </ref>) then our resulting read/write scheme is also secure in this stronger active security model. * In case of writing, one can consider the number of bits not to be fixed, but grow as a function of time. In this case, we get poly-log overhead results as well. <p> Moreover, all the solutions for the Oblivious RAM model of [GO-96] are amortized, where as all our solutions are not. Combining our general reductions with the private read schemes of <ref> [CGKS-95] </ref> and of [Amb-96], we obtain the following corollary: Corollary 3 To store n bits of data, we have * a three-database private read/write scheme with active security and communication complexity O (n 1=3 (log n) 3 ); 8 * for all constants k 2, a (k + 1)-database private read/write <p> Comparison with Previous Work The general approach of distributing information to maintain privacy has been used in many situations, including the previous work on reading from 9 a distributed database <ref> [CGKS-95, Amb-96, CG-97] </ref>, the U. S. Government's Clipper Chip proposal [U.S.-93], Micali's fair-cryptosystems [M-92], secret-sharing schemes [S-79], and instance-hiding schemes [RAD-78, AFK-89, BF-90, BFKL-90]. <p> The problem of performing private database queries with multiple databases that do not interact with one other was studied in two other settings: in instance hiding schemes of [BF-90, BFKL-90] and on private database queries of <ref> [CGKS-95, Amb-96, CG-97] </ref>. In both of these settings, the contents of the database is static, and each constituent database maintains exact copies of the database. Our work shows how to support dynamic databases, while maintaining privacy. <p> Recall that <ref> [CGKS-95] </ref> show that with two databases which contain identical n bits of data, it is possible to privately read a bit with O (n 1=3 ) communication complexity. <p> Now, writing still takes O (n) steps, since we still must re-write the entire database (and in fact maintain two copies), but reading can be done in O (n 1=3 ) steps just by reading the appropriate bit from both identical pairs of databases using twice the reading scheme of <ref> [CGKS-95] </ref> and then just computing the exclusive-or of these two bits. An Elementary Sub-linear Scheme In this subsection, we present an elementary 8-database private read/write scheme with communication complexity O (n 1=2 ) for writing and O (n 1=3 ) for reading. <p> The communication complexity is O (n 1=2 ). To complete the discussion, we observe that each of the four constituent databases, which support private reading, can be implemented using a pair of identical, ordinary databases. Using a result of <ref> [CGKS-95] </ref>, a private query can then be implemented with communication complexity O (n 1=3 ). <p> Remark: Michael Fischer independently discovered this 8-database method also (communicated by Oded Goldreich [G-96].) Remark: The above method could be naturally extended to higher dimensions, similar to <ref> [CGKS-95] </ref> approach for constant k. However, our general reductions in the next two sections yield asymptotically better results, and thus we do not present this simple extension. 13 3 Proof of Theorem 2 In this section, we present the proof of theorem 2. <p> We do so for every bit. * Notice that the original bit b is still hidden from each constituent database. On the other hand every bit b i appears in two different databases, so we can use the <ref> [CGKS-95] </ref> reading scheme with O (n 1=3 ) communication complexity. We now generalize this in a strait-forward manner as follows. Each bit in the private read/semi-private write database is split into k + 1 random bits, or "shares," whose exclusive-or is the value of the bit. <p> In the information-theoretic setting we have shown that the communication complexity of private reading and writing is within a poly-logarithmic factor of private reading. Many of the extensions in <ref> [CGKS-95] </ref> (such as privacy against coalitions and efficient, private access to blocks of data) apply to our constructions as well. One of our schemes achieves a communication complexity of O (n 1=3 (log n) 3 ) using just three databases.
Reference: [G-96] <author> O. Goldreich. </author> <type> Personal communication, </type> <note> June of 1996. </note>
Reference-contexts: In this setting, we model constituent databases as probabilistic polynomial time Turing machines, and rely on complexity assumptions. Hence, we only require that the views of the constituent databases will be computationally indistinguishable instead of identical. * Isolated vs. Active Security <ref> [G-96] </ref>: In the model described above, constituent databases are not allowed to communicate with one another and are only allowed to communicate with the user. We call such a model an "isolated" model. A stronger type of an adversary, suggested by Oded Goldreich [G-96], is the one where databases are also <p> Active Security <ref> [G-96] </ref>: In the model described above, constituent databases are not allowed to communicate with one another and are only allowed to communicate with the user. We call such a model an "isolated" model. A stronger type of an adversary, suggested by Oded Goldreich [G-96], is the one where databases are also allowed to "hire users" and query all other databases, pretending to be legitimate users. Indeed, in such an "active" model, any constituent database can find out all the data of the actual database. <p> We consider a weaker model, where we allow constituent databases to keep different data and allow a multi-round scheme. In this setting, Gene Itkis (private communication by Goldreich <ref> [G-96] </ref>) has shown a four-database scheme which achieves poly-logarithmic amortized overhead for both reading and writing. We extend his result, and show how to achieve poly-logarithmic overhead without amortization and with just two constituent databases: Theorem 4 Suppose one-way trapdoor permutations exist, and let g be a security parameter. <p> Putting all of this together, we get an 8-database scheme where private read operations have a communication complexity of O (n 1=3 ), and private write operations have a communication complexity of O (n 1=2 ). Remark: Michael Fischer independently discovered this 8-database method also (communicated by Oded Goldreich <ref> [G-96] </ref>.) Remark: The above method could be naturally extended to higher dimensions, similar to [CGKS-95] approach for constant k. <p> That is, (as pointed out by Goldreich <ref> [G-96] </ref>) in case if the database that represents the memory is malicious and is allowed to hire a "user" and accesses the value of the "CPU" database component (i.e., if we consider active security see introduction), then the database that represents the memory learns the value of the key of the <p> In the computational setting, the way around this problem (of active security) was suggested by Gene Itkis (communicated by <ref> [G-96] </ref>): Itkis suggested to use three databases to represent the CPU, and the fourth database to represent the memory, where the key new observation (due to Itkis) is that the three DB's that hold "shares" of the state of the CPU can engage in a multi-party secure function evaluation (communicating through
Reference: [RAD-78] <author> R. L. Rivest, L. Adleman, and M. L. Dertouzos. </author> <title> On data banks and privacy homomorphisms. In Foundations of Secure Computation (eds. </title> <editor> R. DeMillo, D. Dobkin, A. Jones, and R. Lipton). </editor> <publisher> Academic Press, </publisher> <year> 1978. </year>
Reference-contexts: S. Government's Clipper Chip proposal [U.S.-93], Micali's fair-cryptosystems [M-92], secret-sharing schemes [S-79], and instance-hiding schemes <ref> [RAD-78, AFK-89, BF-90, BFKL-90] </ref>. Closely related to the private storage problem is the oblivious RAM simulation problem, studied in [G-87, Ost-90, GO-96], and indeed the techniques we employ here build on those used to solve the oblivious RAM simulation problem. So, let us mention that setting here.
Reference: [G-87] <author> O. Goldreich. </author> <title> Towards a theory of software protection and simulation by oblivious RAMs. </title> <booktitle> In Proc. 19th Annual ACM Symp. Theory Comp., </booktitle> <year> 1987. </year>
Reference-contexts: That is, they wish to conceal from the database administrator not only the contents of the data, but also the access pattern, i.e., which particular addresses of the database are being read from or written to. This could be done in two different settings, as explained below: SINGLE DATABASE <ref> [G-87, Ost-90, GO-96] </ref>: In a single database scheme there is only one database from which users wish to hide information, while still using it to store data. In this setting, all participating users agree on an encryption/decryption scheme which they use to encrypt every value stored in the database. <p> In this case, we get poly-log overhead results as well. For example, we get an analog of information-theoretically secure Oblivious RAM simulation (see <ref> [G-87, Ost-90, GO-96] </ref>), where t steps of the original program can be simulated in an oblivious manner using O (R (k; t) (log t) 3 ) overhead per step using k databases. <p> S. Government's Clipper Chip proposal [U.S.-93], Micali's fair-cryptosystems [M-92], secret-sharing schemes [S-79], and instance-hiding schemes [RAD-78, AFK-89, BF-90, BFKL-90]. Closely related to the private storage problem is the oblivious RAM simulation problem, studied in <ref> [G-87, Ost-90, GO-96] </ref>, and indeed the techniques we employ here build on those used to solve the oblivious RAM simulation problem. So, let us mention that setting here.
Reference: [GMR-85] <author> S. Goldwasser, S. Micali and C. Rackoff, </author> <title> The Knowledge Complexity of Interactive Proof-Systems, </title> <journal> SIAM J. Comput. </journal> <volume> 18 (1989), </volume> <pages> pp. </pages> <note> 186-208; (also in STOC 85, pp. 291-304.) </note>
Reference-contexts: Formally, we model the above setting in a way similar to the multi-prover interactive proof setting of [BGKW-88]. That is, we model k constituent databases and the user as k + 1 interactive Turing machines DB 1 ; : : : ; DB k and U of <ref> [GMR-85] </ref> defined as follows: * Let DB 1 ; DB 2 ; : : : ; DB k are interactive Turing machines.
Reference: [GMW-87] <author> O. Goldreich, S. Micali, and A. Wigderson. </author> <title> "How to Play Any Mental Game". </title> <booktitle> Proc. of 19th STOC, </booktitle> <pages> pp. 218-229, </pages> <year> 1987. </year>
Reference-contexts: For every step of the CPU computation, both databases execute secure two-party function evaluation of <ref> [Y-82, GMW-87] </ref> which can be implemented based on any one-way trapdoor permutation family (again communicating through the user) in order to both update their shares and output re-encrypted value stored in a tamper-resistant way in Oblivious RAM memory component. <p> Thus, the proof reduces to the software protection proof of [GO-96] and we are done. Note that since we use two-party secure function evaluation of <ref> [Y-82, GMW-87] </ref>, we need stronger cryptographic assumptions (i.e., the existence of trapdoor permutations instead of general one-way functions needed for four databases).
Reference: [GO-96] <author> O. Goldreich and R. Ostrovsky. </author> <title> Software protection and simulation by oblivious RAMs. </title> <journal> JACM, </journal> <year> 1996. </year>
Reference-contexts: That is, they wish to conceal from the database administrator not only the contents of the data, but also the access pattern, i.e., which particular addresses of the database are being read from or written to. This could be done in two different settings, as explained below: SINGLE DATABASE <ref> [G-87, Ost-90, GO-96] </ref>: In a single database scheme there is only one database from which users wish to hide information, while still using it to store data. In this setting, all participating users agree on an encryption/decryption scheme which they use to encrypt every value stored in the database. <p> The first drawback (i.e., communication complexity) was resolved in <ref> [Ost-90, GO-96] </ref>, where they show how to construct a communication-efficient scheme, where communication for each read or write operation is poly-logarithmic in the size of the database times the security parameter of the underlying cryptographic scheme. Their scheme, however, still suffers from the second and third drawbacks. <p> In this case, we get poly-log overhead results as well. For example, we get an analog of information-theoretically secure Oblivious RAM simulation (see <ref> [G-87, Ost-90, GO-96] </ref>), where t steps of the original program can be simulated in an oblivious manner using O (R (k; t) (log t) 3 ) overhead per step using k databases. <p> Moreover, all the solutions for the Oblivious RAM model of <ref> [GO-96] </ref> are amortized, where as all our solutions are not. <p> In fact, in order to show the above result, we exhibit how to make all the results in the Oblivious RAM simulation paper of <ref> [GO-96] </ref> non-amortized, which we believe is of interest in its own right. Comparison with Previous Work The general approach of distributing information to maintain privacy has been used in many situations, including the previous work on reading from 9 a distributed database [CGKS-95, Amb-96, CG-97], the U. S. <p> S. Government's Clipper Chip proposal [U.S.-93], Micali's fair-cryptosystems [M-92], secret-sharing schemes [S-79], and instance-hiding schemes [RAD-78, AFK-89, BF-90, BFKL-90]. Closely related to the private storage problem is the oblivious RAM simulation problem, studied in <ref> [G-87, Ost-90, GO-96] </ref>, and indeed the techniques we employ here build on those used to solve the oblivious RAM simulation problem. So, let us mention that setting here. <p> our general reduction, we require information-theoretic privacy, whereas in the oblivious RAM simulation problem, complexity-theoretic assumptions are used and only computational privacy is achieved (either that, or access to a random oracle is required); (3) unlike the CPU, the user does not maintain any state; (4) whereas the techniques of <ref> [Ost-90, GO-96] </ref> yield bounds on the amortized communication complexity, our techniques yield worst-case bounds. <p> A TECHNICAL REMARK: why can't we do it much easier? At a first glance, the following (incorrect) argument seem to give a much stronger result in a trivial manner. Take the Oblivious RAM solution of <ref> [Ost-90, GO-96] </ref> and implement it using two databases: one to represent the RAM memory and another one to represent the CPU memory. This seems to trivially give us a solution with poly-logarithmic amortized overhead, using just two databases. However, this does not work. The reason 10 is that [Ost-90, GO-96] use <p> solution of <ref> [Ost-90, GO-96] </ref> and implement it using two databases: one to represent the RAM memory and another one to represent the CPU memory. This seems to trivially give us a solution with poly-logarithmic amortized overhead, using just two databases. However, this does not work. The reason 10 is that [Ost-90, GO-96] use in an essential way pseudo-random functions of [GGM-86] in order to implement a random oracle in their construction. Thus, the guarantees are only computational by the nature of the [Ost-90, GO-96] construction. <p> However, this does not work. The reason 10 is that <ref> [Ost-90, GO-96] </ref> use in an essential way pseudo-random functions of [GGM-86] in order to implement a random oracle in their construction. Thus, the guarantees are only computational by the nature of the [Ost-90, GO-96] construction. Moreover, even if we are willing to opt for the computational security only and are willing to settle for an amortized solution, this does not work if we require Active Security (see "variants of the problem" section of the introduction). <p> Second, we will show how to implement the private read/semi-private write scheme using just a private read scheme. Part 1: using a private read/semi-private write scheme We make use of a variant of the memory-hierarchy idea used in <ref> [Ost-90, GO-96] </ref> for the oblivious RAM simulation problem. However, there are several obstacles that we must overcome: * in the oblivious RAM simulation solution, the user (i.e. <p> the user is allowed to flip coins, but she does not has access to a random oracle; * in the oblivious RAM simulation solution, the user has local storage, whereas in our case the user is completely memoryless from one read/write operation to the next; * the solution presented in <ref> [Ost-90, GO-96] </ref> is amortized while here we do not allow any amortization. Offsetting these difficulties is our assumption that we already have a private read/semi-private write scheme at our disposal: all we have to do is hide the access pattern of the write operations. <p> Notice also that the sizes of each of the k + 1 databases is O (nk). The above construction, combined with the construction in the previous section, proves Theorem 1. 5 Computational case Our starting point is the Oblivious RAM simulation of <ref> [Ost-90, GO-96] </ref>, which consists of a protected CPU and an encrypted memory. We also remark that their scheme is tamper-proof (for definitions, see [GO-96].) Unfortunately, their scheme is amortized. <p> The above construction, combined with the construction in the previous section, proves Theorem 1. 5 Computational case Our starting point is the Oblivious RAM simulation of [Ost-90, GO-96], which consists of a protected CPU and an encrypted memory. We also remark that their scheme is tamper-proof (for definitions, see <ref> [GO-96] </ref>.) Unfortunately, their scheme is amortized. Our first step is to get rid of the amortization in the manner similar to our information-theoretic reduction of section x3 as follows. First it is easy to note that except for the smallest level, the oblivious re-hash operations of [GO-96] always move data from <p> tamper-proof (for definitions, see <ref> [GO-96] </ref>.) Unfortunately, their scheme is amortized. Our first step is to get rid of the amortization in the manner similar to our information-theoretic reduction of section x3 as follows. First it is easy to note that except for the smallest level, the oblivious re-hash operations of [GO-96] always move data from the previous (i.e., smaller) level, which is available beforehand, and is only changed during such move. <p> Thus, we are able to realize the Oblivious RAM and the software protection results of <ref> [GO-96] </ref> in a non-amortized sense. <p> one of the constituent databases to keep both the "share" of the CPU and the Oblivious RAM memory and still show that the view of this constituent database is computationally indistinguishable for all executions is that the Oblivious RAM memory component is kept in an encrypted (and tamper-resistant) form (see <ref> [GO-96] </ref>), according to a distributed (be 22 tween both databases) private-key stored in the CPU. <p> Hence, it can not modify the memory component in any way, accept via the CPU access, which, in turn, requires secure function evaluation and thus can not be modified without both databases. Thus, the proof reduces to the software protection proof of <ref> [GO-96] </ref> and we are done. Note that since we use two-party secure function evaluation of [Y-82, GMW-87], we need stronger cryptographic assumptions (i.e., the existence of trapdoor permutations instead of general one-way functions needed for four databases).
Reference: [GGM-86] <author> Goldreich, O., S. Goldwasser, and S. Micali, </author> <title> "How To Construct Random Functions," </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> Vol. 33, No. </volume> <month> 4 (October </month> <year> 1986), </year> <pages> 792-807. </pages>
Reference-contexts: This seems to trivially give us a solution with poly-logarithmic amortized overhead, using just two databases. However, this does not work. The reason 10 is that [Ost-90, GO-96] use in an essential way pseudo-random functions of <ref> [GGM-86] </ref> in order to implement a random oracle in their construction. Thus, the guarantees are only computational by the nature of the [Ost-90, GO-96] construction.
Reference: [M-92] <author> S. Micali. </author> <title> Fair public-key cryptosystems. </title> <booktitle> In Advances in Cryptology| Proc. Crypto '92, </booktitle> <pages> pp. 113-138, </pages> <year> 1992. </year>
Reference-contexts: Comparison with Previous Work The general approach of distributing information to maintain privacy has been used in many situations, including the previous work on reading from 9 a distributed database [CGKS-95, Amb-96, CG-97], the U. S. Government's Clipper Chip proposal [U.S.-93], Micali's fair-cryptosystems <ref> [M-92] </ref>, secret-sharing schemes [S-79], and instance-hiding schemes [RAD-78, AFK-89, BF-90, BFKL-90]. Closely related to the private storage problem is the oblivious RAM simulation problem, studied in [G-87, Ost-90, GO-96], and indeed the techniques we employ here build on those used to solve the oblivious RAM simulation problem.
Reference: [Ost-90] <author> R. Ostrovsky. </author> <title> Software protection and simulation on oblivious RAMs. </title> <publisher> M.I.T. </publisher> <editor> Ph. D. </editor> <booktitle> Thesis in Computer Science, </booktitle> <month> June </month> <year> 1992. </year> <note> Preliminary version in Proc. 22nd Annual ACM Symp. Theory Comp., </note> <year> 1990. </year>
Reference-contexts: That is, they wish to conceal from the database administrator not only the contents of the data, but also the access pattern, i.e., which particular addresses of the database are being read from or written to. This could be done in two different settings, as explained below: SINGLE DATABASE <ref> [G-87, Ost-90, GO-96] </ref>: In a single database scheme there is only one database from which users wish to hide information, while still using it to store data. In this setting, all participating users agree on an encryption/decryption scheme which they use to encrypt every value stored in the database. <p> The first drawback (i.e., communication complexity) was resolved in <ref> [Ost-90, GO-96] </ref>, where they show how to construct a communication-efficient scheme, where communication for each read or write operation is poly-logarithmic in the size of the database times the security parameter of the underlying cryptographic scheme. Their scheme, however, still suffers from the second and third drawbacks. <p> In this case, we get poly-log overhead results as well. For example, we get an analog of information-theoretically secure Oblivious RAM simulation (see <ref> [G-87, Ost-90, GO-96] </ref>), where t steps of the original program can be simulated in an oblivious manner using O (R (k; t) (log t) 3 ) overhead per step using k databases. <p> S. Government's Clipper Chip proposal [U.S.-93], Micali's fair-cryptosystems [M-92], secret-sharing schemes [S-79], and instance-hiding schemes [RAD-78, AFK-89, BF-90, BFKL-90]. Closely related to the private storage problem is the oblivious RAM simulation problem, studied in <ref> [G-87, Ost-90, GO-96] </ref>, and indeed the techniques we employ here build on those used to solve the oblivious RAM simulation problem. So, let us mention that setting here. <p> our general reduction, we require information-theoretic privacy, whereas in the oblivious RAM simulation problem, complexity-theoretic assumptions are used and only computational privacy is achieved (either that, or access to a random oracle is required); (3) unlike the CPU, the user does not maintain any state; (4) whereas the techniques of <ref> [Ost-90, GO-96] </ref> yield bounds on the amortized communication complexity, our techniques yield worst-case bounds. <p> A TECHNICAL REMARK: why can't we do it much easier? At a first glance, the following (incorrect) argument seem to give a much stronger result in a trivial manner. Take the Oblivious RAM solution of <ref> [Ost-90, GO-96] </ref> and implement it using two databases: one to represent the RAM memory and another one to represent the CPU memory. This seems to trivially give us a solution with poly-logarithmic amortized overhead, using just two databases. However, this does not work. The reason 10 is that [Ost-90, GO-96] use <p> solution of <ref> [Ost-90, GO-96] </ref> and implement it using two databases: one to represent the RAM memory and another one to represent the CPU memory. This seems to trivially give us a solution with poly-logarithmic amortized overhead, using just two databases. However, this does not work. The reason 10 is that [Ost-90, GO-96] use in an essential way pseudo-random functions of [GGM-86] in order to implement a random oracle in their construction. Thus, the guarantees are only computational by the nature of the [Ost-90, GO-96] construction. <p> However, this does not work. The reason 10 is that <ref> [Ost-90, GO-96] </ref> use in an essential way pseudo-random functions of [GGM-86] in order to implement a random oracle in their construction. Thus, the guarantees are only computational by the nature of the [Ost-90, GO-96] construction. Moreover, even if we are willing to opt for the computational security only and are willing to settle for an amortized solution, this does not work if we require Active Security (see "variants of the problem" section of the introduction). <p> Second, we will show how to implement the private read/semi-private write scheme using just a private read scheme. Part 1: using a private read/semi-private write scheme We make use of a variant of the memory-hierarchy idea used in <ref> [Ost-90, GO-96] </ref> for the oblivious RAM simulation problem. However, there are several obstacles that we must overcome: * in the oblivious RAM simulation solution, the user (i.e. <p> the user is allowed to flip coins, but she does not has access to a random oracle; * in the oblivious RAM simulation solution, the user has local storage, whereas in our case the user is completely memoryless from one read/write operation to the next; * the solution presented in <ref> [Ost-90, GO-96] </ref> is amortized while here we do not allow any amortization. Offsetting these difficulties is our assumption that we already have a private read/semi-private write scheme at our disposal: all we have to do is hide the access pattern of the write operations. <p> Notice also that the sizes of each of the k + 1 databases is O (nk). The above construction, combined with the construction in the previous section, proves Theorem 1. 5 Computational case Our starting point is the Oblivious RAM simulation of <ref> [Ost-90, GO-96] </ref>, which consists of a protected CPU and an encrypted memory. We also remark that their scheme is tamper-proof (for definitions, see [GO-96].) Unfortunately, their scheme is amortized.
Reference: [S-79] <author> A. Shamir. </author> <title> How to Share a Secret. </title> <journal> CACM 22 </journal> <pages> 612-613, </pages> <year> 1979. </year>
Reference-contexts: That is, since the objective there was to hide the reading pattern only, each constituent database simply held an identical copy of the actual database. In case of writing, 5 where we wish to hide the data as well, we allow constituent databases to hold "shares" <ref> [S-79] </ref> of the actual database. Thus, in our setting we allow (and utilize the fact) that constituent databases need not be identical. * Rounds. <p> Moreover, the savings on reading schemes for blocks could be used to achieve savings in our schemes when reading/writing blocks of bits. * Using secret sharing <ref> [S-79] </ref>, our results could be adopted to the case where coalitions of databases are allowed to communicate. <p> Comparison with Previous Work The general approach of distributing information to maintain privacy has been used in many situations, including the previous work on reading from 9 a distributed database [CGKS-95, Amb-96, CG-97], the U. S. Government's Clipper Chip proposal [U.S.-93], Micali's fair-cryptosystems [M-92], secret-sharing schemes <ref> [S-79] </ref>, and instance-hiding schemes [RAD-78, AFK-89, BF-90, BFKL-90]. Closely related to the private storage problem is the oblivious RAM simulation problem, studied in [G-87, Ost-90, GO-96], and indeed the techniques we employ here build on those used to solve the oblivious RAM simulation problem.
Reference: [U.S.-93] <institution> A proposed federal information processing standard for an escrowed encryption standard. Federal Register, </institution> <month> July 30, </month> <year> 1993. </year>
Reference-contexts: Comparison with Previous Work The general approach of distributing information to maintain privacy has been used in many situations, including the previous work on reading from 9 a distributed database [CGKS-95, Amb-96, CG-97], the U. S. Government's Clipper Chip proposal <ref> [U.S.-93] </ref>, Micali's fair-cryptosystems [M-92], secret-sharing schemes [S-79], and instance-hiding schemes [RAD-78, AFK-89, BF-90, BFKL-90]. Closely related to the private storage problem is the oblivious RAM simulation problem, studied in [G-87, Ost-90, GO-96], and indeed the techniques we employ here build on those used to solve the oblivious RAM simulation problem.
Reference: [Y-82] <author> Yao, </author> <title> A.C., "Theory and Applications of Trapdoor Functions", </title> <booktitle> 23rd FOCS, </booktitle> <year> 1982, </year> <pages> pp. 80-91. 25 </pages>
Reference-contexts: For every step of the CPU computation, both databases execute secure two-party function evaluation of <ref> [Y-82, GMW-87] </ref> which can be implemented based on any one-way trapdoor permutation family (again communicating through the user) in order to both update their shares and output re-encrypted value stored in a tamper-resistant way in Oblivious RAM memory component. <p> Thus, the proof reduces to the software protection proof of [GO-96] and we are done. Note that since we use two-party secure function evaluation of <ref> [Y-82, GMW-87] </ref>, we need stronger cryptographic assumptions (i.e., the existence of trapdoor permutations instead of general one-way functions needed for four databases).
References-found: 21

