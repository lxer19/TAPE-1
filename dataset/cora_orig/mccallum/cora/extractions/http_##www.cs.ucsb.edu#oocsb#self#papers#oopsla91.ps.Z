URL: http://www.cs.ucsb.edu/oocsb/self/papers/oopsla91.ps.Z
Refering-URL: http://www.cs.ucsb.edu/oocsb/self/papers/practical.html
Root-URL: http://www.cs.ucsb.edu
Title: Making Pure Object-Oriented Languages Practical  
Author: Craig Chambers David Ungar 
Affiliation: Stanford University**  
Date: October, 1991.  
Note: To appear in OOPSLA91 Conference Proceedings,  
Abstract: In the past, object-oriented language designers and programmers have been forced to choose between pure message passing and performance. Last year, our SELF system achieved close to half the speed of optimized C but suffered from impractically long compile times. Two new optimization techniques, deferred compilation of uncommon cases and non-backtracking splitting using path objects, have improved compilation speed by more than an order of magnitude. SELF now compiles about as fast as an optimizing C compiler and runs at over half the speed of optimized C. This new level of performance may make pure object-oriented languages practical. 
Abstract-found: 1
Intro-found: 1
Reference: [BHJL86] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object Structure in the Emerald System. </title> <booktitle> In OOPSLA86 Conference Proceedings, </booktitle> <pages> pp. 78-86, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Even statically-typed (but pure) object-oriented languages like Trellis/Owl [SCW85, SCB+86], Eiffel [Mey86, Mey88], and Emerald <ref> [BHJL86, Hut87] </ref> must overcome the overhead of dynamically-dispatched message passing. ** Static typing allows the compiler to check that an object will understand every message sent to it and perhaps to use a somewhat faster dispatching mechanism to implement messages.
Reference: [BDG+88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> In SIGPLAN Notices 23(Special Issue), </journal> <month> September, </month> <year> 1988. </year>
Reference-contexts: Since static typing alone does not enable static binding and inlining of messages, it cannot significantly reduce the overhead of message passing. Hybrid object-oriented languages such as C++ [Str86, ES90] and CLOS <ref> [BDG+88] </ref> short-circuit the overhead (and consequently the benefits) of passing messages by including statically-bound procedure calls and primitive, non-object-oriented data types for simple things like numbers, arrays, and cons cells.
Reference: [CU89] <author> Craig Chambers and David Ungar. </author> <title> Customization: Optimizing Compiler Technology for SELF, a Dynamically-Typed Object-Oriented Programming Language. </title> <booktitle> In Proceedings of the SIGPLAN89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 146-160, </pages> <address> Portland, OR, </address> <month> June, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(7), </note> <month> July, </month> <year> 1989. </year>
Reference-contexts: The following chart summarizes our progress to date, compared against optimized C (faster execution speed is higher on the graph, and faster compilation speed is farther to the right on the graph): In 1989, we presented early results <ref> [CU89, CUL89] </ref> showing how our SELF system ran the same set of small C-style benchmarks at 20% the speed of optimized C, twice as fast as the ParcPlace Smalltalk-80 system. <p> Over 150 sites around the world have a copy of our SELF implementation, and several medium-sized projects in SELF have been pursued by people outside our group. Two compilers are distributed with this system: the latest SELF compiler described in this paper and the original SELF compiler described in <ref> [CU89] </ref> and [CUL89], which is less optimizing than the latest SELF compiler but compiles faster. When using the previous SELF compiler described in [CU90], a user would have to take a coffee break during a compilation, and many programs would fail to compile.
Reference: [CUL89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA89 Conference Proceedings, </booktitle> <pages> pp. 49-70, </pages> <address> New Orleans, LA, </address> <month> October, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year>
Reference-contexts: The following chart summarizes our progress to date, compared against optimized C (faster execution speed is higher on the graph, and faster compilation speed is farther to the right on the graph): In 1989, we presented early results <ref> [CU89, CUL89] </ref> showing how our SELF system ran the same set of small C-style benchmarks at 20% the speed of optimized C, twice as fast as the ParcPlace Smalltalk-80 system. <p> In each copy, there is but a single class for self, and this knowledge * Since SELF has no classes, our implementation introduces maps transparently to the user to provide similar information and space efficiency as classes <ref> [CUL89] </ref>. Thus in our system customization is based on the internal map of the receiver rather than its class. We will continue to use the class terminology in the rest of the paper for pedagogical reasons. <p> Two compilers are distributed with this system: the latest SELF compiler described in this paper and the original SELF compiler described in [CU89] and <ref> [CUL89] </ref>, which is less optimizing than the latest SELF compiler but compiles faster. When using the previous SELF compiler described in [CU90], a user would have to take a coffee break during a compilation, and many programs would fail to compile.
Reference: [CU90] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <booktitle> In Proceedings of the SIGPLAN90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 150-164, </pages> <address> White Plains, NY, </address> <month> June, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(6), </note> <month> June, </month> <year> 1990. </year>
Reference-contexts: In 1990 we described more recent work <ref> [CU90] </ref> in which our SELF system ran the same benchmarks at 40% the speed of optimized C, another factor of two improvement over the early SELF system and a factor of four faster than ParcPlace Smalltalk-80. <p> path 2 loop head loop tail 10 5 Performance Results 5.1 Methodology In order to evaluate the performance impact of deferred compilation of uncommon cases and non-backtracking type analysis with loop unrolling and path objects, we compared the performance of three versions of SELF: SELF90 is last years SELF system <ref> [CU90] </ref>, lacking both deferred compilation and non-backtracking type analysis. Partly because of lengthy compilation times, this system could not generate multiple copies of loops. SELF91 (not deferred) is the current system, with non-backtracking type analysis, but with deferred compilation disabled. <p> Two compilers are distributed with this system: the latest SELF compiler described in this paper and the original SELF compiler described in [CU89] and [CUL89], which is less optimizing than the latest SELF compiler but compiles faster. When using the previous SELF compiler described in <ref> [CU90] </ref>, a user would have to take a coffee break during a compilation, and many programs would fail to compile. With paths, the elimination of backtracking in the compilers type analysis, and deferral of the compilation of uncommon cases, compile times for the latest compiler are merely distracting.
Reference: [Cha91] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> Ph.D. thesis, </type> <institution> Stanford University, </institution> <note> in preparation. </note>
Reference-contexts: In the cases where this early path combining makes a difference, local reluctant splitting saves up to 30% of the compile time at a cost of up to 30% extra run time over global reluctant splitting <ref> [Cha91] </ref>. Perhaps surprisingly, global reluctant splitting sometimes enables optimizations which significantly shrink the size of the control ow graph and consequently occasionally compiles faster (and runs faster) than with local reluctant splitting.
Reference: [DS84] <author> L. Peter Deutsch and Allan M. Schiffman. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> In Proceedings of the 11th Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pp. 297-302, </pages> <address> Salt Lake City, UT, </address> <year> 1984. </year>
Reference-contexts: For example, the fastest commercial implementation of a pure dynamically-typed object-oriented language, ParcPlace Smalltalk-80 * [GR83], runs a set of small C-style benchmarks at only 10% the speed of optimized C; this implementation contains techniques developed by Deutsch and Schiffman <ref> [DS84] </ref> that are widely considered to be the state of the art in software techniques for building fast implementations of pure object-oriented languages. <p> past work may wish to skip this section. 2.1 Dynamic Compilation The SELF system employs dynamic compilation to obtain better run-time performance than an interpreter while reducing compile-time and code-space costs over a conventional static compiler; dynamic compilation in SELF is similar to dynamic translation in the Deutsch-Schiffman Smalltalk-80 system <ref> [DS84] </ref>. When a programmer types in a program, a parser (corresponding to the Deutsch-Schiffman compiler) translates it into a simple byte-coded intermediate representation. <p> In order to compare our approach to implementing a pure object-oriented language with competing approaches, we measured the ParcPlace Smalltalk-80 system (version 2.4) incorporating the Deutsch-Schiffman techniques <ref> [DS84] </ref>. * As far as we know, this is the fastest implementation of any other system in which nearly every operation is performed by sending a dynamically-dispatched message. Variable accesses and some low-level control structures do not use messages in Smalltalk-80, unlike SELF.
Reference: [Deu88] <author> L. Peter Deutsch. </author> <title> Richards benchmark source code. </title> <type> Personal communication, </type> <month> October, </month> <year> 1988. </year>
Reference-contexts: Stanford Suite Puzzle Richards 125% 75% 25% Code Density % of optimized C 10% 51% 39 4.4% 22% 27% 7.4 35% 173% 37% 38% 2.5 4.2 175% 52% 36% 73% 51% 2.4 36% 9.0 98% We measured the eight Stanford integer benchmarks [Hen88] and the Richards operating system simulation benchmark <ref> [Deu88] </ref>. The C version of the richards benchmark is actually written in C++ version 1.2, translated into C using the standard cfront filter, and then optimized using the Sun C compiler.
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Since static typing alone does not enable static binding and inlining of messages, it cannot significantly reduce the overhead of message passing. Hybrid object-oriented languages such as C++ <ref> [Str86, ES90] </ref> and CLOS [BDG+88] short-circuit the overhead (and consequently the benefits) of passing messages by including statically-bound procedure calls and primitive, non-object-oriented data types for simple things like numbers, arrays, and cons cells.
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: For example, the fastest commercial implementation of a pure dynamically-typed object-oriented language, ParcPlace Smalltalk-80 * <ref> [GR83] </ref>, runs a set of small C-style benchmarks at only 10% the speed of optimized C; this implementation contains techniques developed by Deutsch and Schiffman [DS84] that are widely considered to be the state of the art in software techniques for building fast implementations of pure object-oriented languages.
Reference: [Gra89] <author> Justin Owen Graver. </author> <title> Type-Checking and Type-Inference for Object-Oriented Programming Languages. </title> <type> Ph.D. thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1989. </year>
Reference-contexts: Users must annotate programs with type declarations for instance variables, class variables, global variables, and primitives, and then either run an inferencer to compute the types of methods and local variables <ref> [Gra89, GJ90] </ref> (which, like type inference in ML, provides the compiler with little information to support optimizations) or hand-declare selected methods and local variables with more specific representation-level type information. This representation-level type information is used by the TS optimizing compiler to perform run-time type casing and message inlining.
Reference: [GJ90] <author> Justin O. Graver and Ralph E. Johnson. </author> <title> A Type System for Smalltalk. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 136-150, </pages> <address> San Fran-cisco, CA, </address> <month> January, </month> <year> 1990. </year>
Reference-contexts: Users must annotate programs with type declarations for instance variables, class variables, global variables, and primitives, and then either run an inferencer to compute the types of methods and local variables <ref> [Gra89, GJ90] </ref> (which, like type inference in ML, provides the compiler with little information to support optimizations) or hand-declare selected methods and local variables with more specific representation-level type information. This representation-level type information is used by the TS optimizing compiler to perform run-time type casing and message inlining.
Reference: [Hen88] <author> John Hennessy. </author> <title> Stanford benchmark suite source code. </title> <type> Personal communication, </type> <month> June, </month> <year> 1988. </year>
Reference-contexts: % of optimized C Stanford Suite Puzzle Richards Stanford Suite Puzzle Richards 125% 75% 25% Code Density % of optimized C 10% 51% 39 4.4% 22% 27% 7.4 35% 173% 37% 38% 2.5 4.2 175% 52% 36% 73% 51% 2.4 36% 9.0 98% We measured the eight Stanford integer benchmarks <ref> [Hen88] </ref> and the Richards operating system simulation benchmark [Deu88]. The C version of the richards benchmark is actually written in C++ version 1.2, translated into C using the standard cfront filter, and then optimized using the Sun C compiler.
Reference: [HCU91] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Optimizing Dynamically-Typed Object-Oriented Programs using Polymorphic Inline Caches. </title> <booktitle> In ECOOP91 Conference Proceedings, </booktitle> <address> Geneva, Switzerland, </address> <month> July, </month> <year> 1991. </year>
Reference-contexts: The richards benchmark runs at over a third the speed of optimized C, four times faster than Smalltalk-80; this level of performance is achieved partially because of recent work primarily by Urs Hlzle on extending the SELF system to speed polymorphic messages <ref> [HCU91] </ref>. These measurements suggest that our techniques would improve the speed of generic arithmetic even in non-object-oriented languages. Our SELF system runs between 50% and 250% faster than normal T programs compiled using the ORBIT compiler, and faster by 10% to 20% than even hand-tuned integer-specific T programs. <p> With paths, the elimination of backtracking in the compilers type analysis, and deferral of the compilation of uncommon cases, compile times for the latest compiler are merely distracting. To minimize this distraction, we are investigating adaptive recompilation strategies that reserve optimization for heavily-used methods <ref> [HCU91] </ref>; a crude form of this which first compiles methods using the original SELF compiler and later recompiles often-used methods using the latest SELF compiler is the standard configuration of our current system. 7 Previous Work Other systems perform type inference over programs without explicit type declarations.
Reference: [Hut87] <author> Norman C. Hutchinson. </author> <title> Emerald: An Object-Based Language for Distributed Programming. </title> <type> Ph.D. thesis, </type> <institution> University of Washington, </institution> <year> 1987. </year>
Reference-contexts: Even statically-typed (but pure) object-oriented languages like Trellis/Owl [SCW85, SCB+86], Eiffel [Mey86, Mey88], and Emerald <ref> [BHJL86, Hut87] </ref> must overcome the overhead of dynamically-dispatched message passing. ** Static typing allows the compiler to check that an object will understand every message sent to it and perhaps to use a somewhat faster dispatching mechanism to implement messages.
Reference: [Joh86] <author> Ralph E. Johnson. </author> <title> Type-Checking Smalltalk. </title> <booktitle> In OOPSLA86 Conference Proceedings, </booktitle> <pages> pp. 315-321, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Our type analysis is more akin to traditional data ow analysis than type inference, in that it computes precise, time-varying, representation-level types for objects suitable for optimizations. 13 A different approach is taken by the Typed Smalltalk project <ref> [Joh86, JGZ88] </ref>.
Reference: [JGZ88] <author> Ralph E. Johnson, Justin O. Graver, and Lawrence W. Zurawski. </author> <title> TS: An Optimizing Compiler for Smalltalk. </title> <booktitle> In OOPSLA88 Conference Proceedings, </booktitle> <pages> pp. 18-26, </pages> <address> San Diego, CA, </address> <month> October, </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(11), </note> <month> November, </month> <year> 1988. </year>
Reference-contexts: Our type analysis is more akin to traditional data ow analysis than type inference, in that it computes precise, time-varying, representation-level types for objects suitable for optimizations. 13 A different approach is taken by the Typed Smalltalk project <ref> [Joh86, JGZ88] </ref>.
Reference: [KKR+86] <author> David Kranz, Richard Kelsey, Jonathan Rees, Paul Hudak, James Philbin, and Norman Adams. </author> <title> ORBIT: An Optimizing Compiler for Scheme. </title> <booktitle> In Proceedings of the SIGPLAN86 Symposium on Compiler Construction, </booktitle> <pages> pp. 219-233, </pages> <address> Palo Alto, CA, </address> <month> June, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(7), </note> <month> July, </month> <year> 1986. </year>
Reference-contexts: Variable accesses and some low-level control structures do not use messages in Smalltalk-80, unlike SELF. In order to compare our techniques against other systems supporting generic arithmetic, we also measured the ORBIT compiler (version 3.1) <ref> [KKR+86, Kra88] </ref> for T [RA82, Sla87], a dialect of Scheme [RC86]. ORBIT is well respected as a good optimizing compiler for a Scheme-like language. These data are labeled T/ORBIT (normal).
Reference: [Kra88] <author> David Andrew Kranz. </author> <title> ORBIT: An Optimizing Compiler for Scheme. </title> <type> Ph.D. thesis, </type> <institution> Yale University, </institution> <year> 1988. </year>
Reference-contexts: Variable accesses and some low-level control structures do not use messages in Smalltalk-80, unlike SELF. In order to compare our techniques against other systems supporting generic arithmetic, we also measured the ORBIT compiler (version 3.1) <ref> [KKR+86, Kra88] </ref> for T [RA82, Sla87], a dialect of Scheme [RC86]. ORBIT is well respected as a good optimizing compiler for a Scheme-like language. These data are labeled T/ORBIT (normal).
Reference: [McC90] <author> Carl McConnell. </author> <title> TS performance data. </title> <type> Personal communication, </type> <month> October, </month> <year> 1990. </year>
Reference-contexts: benchmarks (smaller than any of the benchmarks we report in this paper) indicate that the current speed of Typed Smalltalk is close to the speed of our current SELF system, but unfortunately the current Typed Smalltalk system does not support generic arithmetic (integer arithmetic primitives do not check for over-ow) <ref> [McC90] </ref>.
Reference: [Mey86] <author> Bertrand Meyer. </author> <title> Genericity versus Inheritance. </title> <booktitle> In OOPSLA86 Conference Proceedings, </booktitle> <pages> pp. 391-405, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Even statically-typed (but pure) object-oriented languages like Trellis/Owl [SCW85, SCB+86], Eiffel <ref> [Mey86, Mey88] </ref>, and Emerald [BHJL86, Hut87] must overcome the overhead of dynamically-dispatched message passing. ** Static typing allows the compiler to check that an object will understand every message sent to it and perhaps to use a somewhat faster dispatching mechanism to implement messages.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Even statically-typed (but pure) object-oriented languages like Trellis/Owl [SCW85, SCB+86], Eiffel <ref> [Mey86, Mey88] </ref>, and Emerald [BHJL86, Hut87] must overcome the overhead of dynamically-dispatched message passing. ** Static typing allows the compiler to check that an object will understand every message sent to it and perhaps to use a somewhat faster dispatching mechanism to implement messages.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: ML <ref> [MTH90] </ref> is a statically-typed function-oriented language in which the compiler is able to infer the types of all procedures and expressions and do static type checking with virtually no type declarations. Researchers have attempted to extend type inference to object-oriented languages, with some success [Wan87, Wan88, Wan89, OB89, Rou90].
Reference: [OB89] <author> Atsushi Ohori and Peter Buneman. </author> <title> Static Type Inference for Parametric Classes. </title> <booktitle> In OOPSLA89 Conference Proceedings, </booktitle> <pages> pp. 445-456, </pages> <address> New Orleans, LA, </address> <month> October, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year>
Reference-contexts: ML [MTH90] is a statically-typed function-oriented language in which the compiler is able to infer the types of all procedures and expressions and do static type checking with virtually no type declarations. Researchers have attempted to extend type inference to object-oriented languages, with some success <ref> [Wan87, Wan88, Wan89, OB89, Rou90] </ref>. These approaches use type systems that describe an objects interface or protocol, not the objects representation or implementation. This abstract view of an objects type is best for exible polymorphic type-checking, but provides little information for an optimizing compiler to speed programs.
Reference: [RA82] <author> Jonathan A. Rees and Norman I. Adams IV. </author> <title> T: a Dialect of Lisp or, LAMBDA: the Ultimate Software Tool. </title> <booktitle> In Proceedings of the 1982 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pp. 114-122, </pages> <month> August, </month> <year> 1982. </year> <month> 15 </month>
Reference-contexts: Variable accesses and some low-level control structures do not use messages in Smalltalk-80, unlike SELF. In order to compare our techniques against other systems supporting generic arithmetic, we also measured the ORBIT compiler (version 3.1) [KKR+86, Kra88] for T <ref> [RA82, Sla87] </ref>, a dialect of Scheme [RC86]. ORBIT is well respected as a good optimizing compiler for a Scheme-like language. These data are labeled T/ORBIT (normal).
Reference: [RC86] <editor> Jonathan Rees and William Clinger, editors. </editor> <title> Revised 3 Report on the Algorithmic Language Scheme. </title> <booktitle> In SIGPLAN Notices 21(12), </booktitle> <month> December, </month> <year> 1986. </year>
Reference-contexts: Variable accesses and some low-level control structures do not use messages in Smalltalk-80, unlike SELF. In order to compare our techniques against other systems supporting generic arithmetic, we also measured the ORBIT compiler (version 3.1) [KKR+86, Kra88] for T [RA82, Sla87], a dialect of Scheme <ref> [RC86] </ref>. ORBIT is well respected as a good optimizing compiler for a Scheme-like language. These data are labeled T/ORBIT (normal).
Reference: [Rou90] <author> Francois Rouaix. </author> <title> Safe Run-Time Overloading. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 355-366, </pages> <address> San Francisco, CA, </address> <month> January, </month> <year> 1990. </year>
Reference-contexts: ML [MTH90] is a statically-typed function-oriented language in which the compiler is able to infer the types of all procedures and expressions and do static type checking with virtually no type declarations. Researchers have attempted to extend type inference to object-oriented languages, with some success <ref> [Wan87, Wan88, Wan89, OB89, Rou90] </ref>. These approaches use type systems that describe an objects interface or protocol, not the objects representation or implementation. This abstract view of an objects type is best for exible polymorphic type-checking, but provides little information for an optimizing compiler to speed programs.
Reference: [SCW85] <author> Craig Schaffert, Topher Cooper, and Carrie Wilpolt. </author> <title> Trellis Object-Based Environment, Language Reference Manual. </title> <type> Technical report DEC-TR-372, </type> <month> November, </month> <year> 1985. </year>
Reference-contexts: Even statically-typed (but pure) object-oriented languages like Trellis/Owl <ref> [SCW85, SCB+86] </ref>, Eiffel [Mey86, Mey88], and Emerald [BHJL86, Hut87] must overcome the overhead of dynamically-dispatched message passing. ** Static typing allows the compiler to check that an object will understand every message sent to it and perhaps to use a somewhat faster dispatching mechanism to implement messages.
Reference: [SCB+86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In OOPSLA86 Conference Proceedings, </booktitle> <pages> pp. 9-16, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Even statically-typed (but pure) object-oriented languages like Trellis/Owl <ref> [SCW85, SCB+86] </ref>, Eiffel [Mey86, Mey88], and Emerald [BHJL86, Hut87] must overcome the overhead of dynamically-dispatched message passing. ** Static typing allows the compiler to check that an object will understand every message sent to it and perhaps to use a somewhat faster dispatching mechanism to implement messages.
Reference: [Sla87] <author> Stephen Slade. </author> <title> The T Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1987. </year>
Reference-contexts: Variable accesses and some low-level control structures do not use messages in Smalltalk-80, unlike SELF. In order to compare our techniques against other systems supporting generic arithmetic, we also measured the ORBIT compiler (version 3.1) [KKR+86, Kra88] for T <ref> [RA82, Sla87] </ref>, a dialect of Scheme [RC86]. ORBIT is well respected as a good optimizing compiler for a Scheme-like language. These data are labeled T/ORBIT (normal).
Reference: [Str86] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Since static typing alone does not enable static binding and inlining of messages, it cannot significantly reduce the overhead of message passing. Hybrid object-oriented languages such as C++ <ref> [Str86, ES90] </ref> and CLOS [BDG+88] short-circuit the overhead (and consequently the benefits) of passing messages by including statically-bound procedure calls and primitive, non-object-oriented data types for simple things like numbers, arrays, and cons cells.
Reference: [US87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year>
Reference-contexts: Over the last few years we have been working on bridging the gap between the performance of traditional languages and the performance of pure object-oriented languages. We are developing new implementation techniques and compiler optimizations for our implementation of SELF <ref> [US87] </ref>, a pure dynamically-typed object-oriented language even harder to compile efficiently than Smalltalk-80.
Reference: [Wan87] <author> Mitchell Wand. </author> <title> Complete Type Inference for Simple Objects. </title> <booktitle> In Proceedings of the Second Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pp. 37-44, </pages> <address> Ithaca, NY, </address> <month> June, </month> <year> 1987. </year>
Reference-contexts: ML [MTH90] is a statically-typed function-oriented language in which the compiler is able to infer the types of all procedures and expressions and do static type checking with virtually no type declarations. Researchers have attempted to extend type inference to object-oriented languages, with some success <ref> [Wan87, Wan88, Wan89, OB89, Rou90] </ref>. These approaches use type systems that describe an objects interface or protocol, not the objects representation or implementation. This abstract view of an objects type is best for exible polymorphic type-checking, but provides little information for an optimizing compiler to speed programs.
Reference: [Wan88] <author> Mitchell Wand. </author> <title> Corrigendum: Complete Type Inference for Simple Objects. </title> <booktitle> In Proceedings of the Third Annual IEEE Symposium on Logic in Computer Science, </booktitle> <address> p. 132, Edinburgh, Scotland, </address> <month> July, </month> <year> 1988. </year>
Reference-contexts: ML [MTH90] is a statically-typed function-oriented language in which the compiler is able to infer the types of all procedures and expressions and do static type checking with virtually no type declarations. Researchers have attempted to extend type inference to object-oriented languages, with some success <ref> [Wan87, Wan88, Wan89, OB89, Rou90] </ref>. These approaches use type systems that describe an objects interface or protocol, not the objects representation or implementation. This abstract view of an objects type is best for exible polymorphic type-checking, but provides little information for an optimizing compiler to speed programs.
Reference: [Wan89] <author> Mitchell Wand. </author> <title> Type Inference for Record Concatenation and Multiple Inheritance. </title> <booktitle> In Proceedings of the Fourth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pp. 92-97, </pages> <year> 1989. </year>
Reference-contexts: ML [MTH90] is a statically-typed function-oriented language in which the compiler is able to infer the types of all procedures and expressions and do static type checking with virtually no type declarations. Researchers have attempted to extend type inference to object-oriented languages, with some success <ref> [Wan87, Wan88, Wan89, OB89, Rou90] </ref>. These approaches use type systems that describe an objects interface or protocol, not the objects representation or implementation. This abstract view of an objects type is best for exible polymorphic type-checking, but provides little information for an optimizing compiler to speed programs.
References-found: 35

