URL: ftp://ftp.eecs.umich.edu/groups/gasm/typedasm.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.eecs.umich.edu
Email: giusp@uni-paderborn.de)  gurevich@eecs.umich.edu)  Karl.Stroetmann@mchp.siemens.de)  
Title: Typed Abstract State Machines  
Author: Giuseppe Del Castillo Yuri Gurevich Karl Stroetmann 
Address: Germany  USA  Germany  
Affiliation: (Universitat-GH Paderborn,  (University of Michigan,  (Siemens AG,  
Abstract: As introduced in the Lipari guide, Abstract State Machines (abbreviated as ASMs) are untyped. This is useful for many purposes. However, typed languages have their own advantages. Types structure the data, type checking uncovers errors. Here we propose a typed version of ASMs. Key Words: abstract state machine, type system, polymorphism Category: D.3.1, F.1.1, F.3.2, F.3.3 
Abstract-found: 1
Intro-found: 1
Reference: [ASM] <institution> Abstract state machines. Web site of the University of Michigan at http://www.eecs.umich.edu/gasm/. </institution>
Reference: [Bei95a] <author> Christoph Beierle. </author> <title> Concepts, implementation, and applications of a typed logic programming language. </title> <editor> In Beierle and Plumer [BP95], </editor> <volume> chapter 5, </volume> <pages> pages 139-167. </pages>
Reference-contexts: BCPL, the untyped forerunner of C, has been completely replaced by C and C ++ . Similarly Lisp is being gradually replaced by ML and Haskell. Concerning logic programming, the last years have seen the development of several typed logic programming languages, e.g., Mercury [HSC96], Protos-L <ref> [Bei95a] </ref>, and Godel [HL92]. Among others, there are the following important reasons for the introduction of types: 1. To facilitate structuring of the data of an application. 2. To have a type checker that automatically detects errors at compile time. Detecting errors automatically when writing a program is certainly useful.
Reference: [Bei95b] <author> Christoph Beierle. </author> <title> Type inferencing for polymorphic order-sorted logic programs. </title> <editor> In Leon Sterling, editor, </editor> <booktitle> Proceedings of the 1995 International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: In [GS98], we will extend our type system in the direction of inclusion polymorphism along the lines of <ref> [Bei95b] </ref>. One of the important features of the ASM approach is that specifications can be given at any level of abstraction. To keep this freedom for typed ASMs, 19 we have left the interpretation of types abstract. The only requirement is that every closed type is interpreted as a set.
Reference: [BP95] <editor> Christoph Beierle and Lutz Plumer, editors. </editor> <booktitle> Logic Programming: Formal Methods and Practical Applications. Studies in Computer Science and Artificial Intelligence. </booktitle> <publisher> Elsevier Science B.V./North-Holland, Amsterdam, Holland, </publisher> <year> 1995. </year>
Reference: [Cas98] <author> Giuseppe Del Castillo. ASM-SL, </author> <title> a specification language based on Gure-vich's Abstract State Machines: Introduction and tutorial. </title> <type> Technical report, </type> <institution> Universitat-GH Paderborn, </institution> <year> 1998. </year> <note> to appear. 21 </note>
Reference-contexts: Our unpretentious appendix may be useful to them. There was a division of labour among the authors of this paper. The second and third authors did the theoretical part. The first author implemented the type checking algorithm <ref> [Cas98] </ref> and provided the example in Section 4. 2 Types and Terms In this section we define the syntax of terms and types, define typeable terms, and present the amount of type theory that is needed for the development of typed ASMs. <p> This can be checked mechanically using a type checker. For example, we have used the type checker that has been implemented as part of a workbench for ASMs developed at the University of Paderborn <ref> [Cas98] </ref>. Of course, the benefit of type checking gets most obvious when dealing with ill-typed terms.
Reference: [Fit95] <author> Melvin Fitting. </author> <title> First-order logic and automated theorem proving. Texts and monographs in computer science. </title> <publisher> Springer, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1995. </year>
Reference: [FM90] <author> You-Chin Fuh and Prateek Mishra. </author> <title> Type inference with subtypes. </title> <journal> Theoretical Computer Science, </journal> <volume> 73(2) </volume> <pages> 155-175, </pages> <year> 1990. </year>
Reference-contexts: Our type system can be described as the type system of the programming language ML [MTH90] restricted to the first order case and without the let-construct. A followup paper [GS98] extends our type system in several ways including casting <ref> [FM90] </ref> and a modest version of type classes [NHN80, WB89]. This paper is organized as follows. Section 2 introduces types and terms. The notion of a typeable term is given and we discuss the concept of a principal type. Section 3 presents typed ASMs.
Reference: [GS98] <author> Yuri Gurevich and Karl Stroetmann. </author> <title> Typed ASMs: Adding casting and overloading (tentative title), </title> <note> 1998. In preparation. </note>
Reference-contexts: We present a type system that introduces parametric polymorphism as suggested by [Mor68] and [Mil78]. Our type system can be described as the type system of the programming language ML [MTH90] restricted to the first order case and without the let-construct. A followup paper <ref> [GS98] </ref> extends our type system in several ways including casting [FM90] and a modest version of type classes [NHN80, WB89]. This paper is organized as follows. Section 2 introduces types and terms. The notion of a typeable term is given and we discuss the concept of a principal type. <p> For example, a satisfactory integration of parametric polymorphism (which plays an important role in functional programming) and inclusion polymorphism (which plays an important role in the object oriented approach) is an open problem, and the type system of ML lacks inclusion polymorphism. In <ref> [GS98] </ref>, we will extend our type system in the direction of inclusion polymorphism along the lines of [Bei95b]. One of the important features of the ASM approach is that specifications can be given at any level of abstraction.
Reference: [Gur95] <author> Yuri Gurevich. </author> <title> Evolving algebras 1993: Lipari guide. </title> <editor> In Egon Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 3-36. </pages> <publisher> Oxford University Press, </publisher> <year> 1995. </year> <note> Available at [ASM]. </note>
Reference-contexts: With most specification languages, the notion of a partial function is difficult to handle. In fact, much of the intricacies of modern specification languages have their origin in the treatment of partial functions. Fortunately, in the framework of ASMs <ref> [Gur95] </ref> this problem has been solved: formally speaking, all functions are total. This is achieved by providing a default value. As a consequence, the richness of a type system is less vital for ASMs than it is for many other specification languages. <p> This annotated term ff is called the full annotation of t. 9 2.4 Quantifiers According to the Lipari Guide <ref> [Gur95] </ref>, terms may have quantifiers. For the simplicity of exposition, up to now we have considered only quantifier-free terms. Next, we extend the definition of terms and the related definitions to the general case. First, extend the definition of terms to include quantifiers as well. <p> First, we introduce states. Essentially, a state is a many-sorted algebra, so there is not much difference between the notion of a state in the context of a typed ASM and the same notion as defined in the Lipari Guide <ref> [Gur95] </ref> for untyped ASMs. States are used to de fine the semantics of terms. Then, we proceed to give the syntax of rules.
Reference: [Gur97] <author> Yuri Gurevich. </author> <title> May 1997 draft of the ASM guide. </title> <type> Technical Report CSE-TR-336-97, </type> <institution> University of Michigan, EECS Department, </institution> <year> 1997. </year> <note> Available at [ASM]. </note>
Reference-contexts: Firing a rule is then done by non-deterministically choosing an update set from this family and then firing this update set. Here, we forgo a formal definition and refer to <ref> [Gur97] </ref> for the details. It is straightforward to adapt the definition given in the above reference to the typed case. 4 An Example A specification language that is easy to reason about should be concise. But one needs syntactic sugar to ease the work of specification writing. <p> Thus we have decided to drop the import construct. Import was convenient to extend, for example, the current set of nodes. There are alternative ways to achieve the same goals. Dropping the reserve renders a number of definitions simpler. For example, the May 1997 Draft of the ASM Guide <ref> [Gur97] </ref> defines the denotation of a deterministic rule as an equivalence class of update sets: two update sets that differ merely in the choice of reserve elements are equivalent. Here, we do not have reserve elements around and can define the denotation of a deterministic rule as an update set.
Reference: [Hin96] <author> Roger Hindley. </author> <title> Basic Simple Type Theory. </title> <publisher> Cambridge University Press, </publisher> <year> 1996. </year>
Reference-contexts: a typeable term. (This algorithm is based on unification [Rob65].) Since this paper is concerned mainly with the concept of a typed ASM, we do not discuss the implementation of the algorithm.) There is no pretence on originality here; the algorithm can be derived from the relevant text books, e.g., <ref> [Hin96, Mit96] </ref>. However, the derivation may be not completely obvious to some readers interested in ASMs but not familiar with lambda calculus. Our unpretentious appendix may be useful to them. There was a division of labour among the authors of this paper. <p> For the readers convenience we prove a number of known facts, for example the uniqueness of principal types is proved. Of course, this is standard material that can also be found in text books dealing with type theory, e.g., <ref> [Hin96, Mit96] </ref>. 2.1 Syntax of Types Definition 1 (Type Vocabulary, Types) A type vocabulary is a pair hT; arityi such that Tis a set of type constructors and arity is a function arity: T! N 2 assigning an arity to every type constructor F 2 T.
Reference: [HL92] <author> Patricia M. Hill and John W. Lloyd. </author> <title> The Godel programming language. </title> <type> Technical Report CSTR-92-27, </type> <institution> Department of Computer Science, University of Bristol, </institution> <year> 1992. </year>
Reference-contexts: BCPL, the untyped forerunner of C, has been completely replaced by C and C ++ . Similarly Lisp is being gradually replaced by ML and Haskell. Concerning logic programming, the last years have seen the development of several typed logic programming languages, e.g., Mercury [HSC96], Protos-L [Bei95a], and Godel <ref> [HL92] </ref>. Among others, there are the following important reasons for the introduction of types: 1. To facilitate structuring of the data of an application. 2. To have a type checker that automatically detects errors at compile time. Detecting errors automatically when writing a program is certainly useful.
Reference: [HSC96] <author> Fergus Henderson, Zoltan Somogyi, and Thomas Conway. </author> <title> Determinism analysis in the mercury compiler. </title> <booktitle> In Proceedings of the Australian Computer Science Conference, </booktitle> <pages> pages 337-346, </pages> <address> Melbourne, Australia, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: BCPL, the untyped forerunner of C, has been completely replaced by C and C ++ . Similarly Lisp is being gradually replaced by ML and Haskell. Concerning logic programming, the last years have seen the development of several typed logic programming languages, e.g., Mercury <ref> [HSC96] </ref>, Protos-L [Bei95a], and Godel [HL92]. Among others, there are the following important reasons for the introduction of types: 1. To facilitate structuring of the data of an application. 2. To have a type checker that automatically detects errors at compile time.
Reference: [LP97] <author> Leslie Lamport and Lawrence C. Paulson. </author> <title> Should your specification language be typed. </title> <type> Report 147, </type> <institution> DEC Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: Furthermore, following the object oriented software engineering approach one starts building a complex system by building the object model. It is obvious that this process is facilitated by a suitable type system. However, typing a specification language is not without its own pitfalls; cf. <ref> [LP97] </ref>. The same richness of types that makes it convenient to describe types in applications may become an impediment. In the worst case, it may lead to inconsistencies of the type system. [LP97] cites some examples. <p> However, typing a specification language is not without its own pitfalls; cf. <ref> [LP97] </ref>. The same richness of types that makes it convenient to describe types in applications may become an impediment. In the worst case, it may lead to inconsistencies of the type system. [LP97] cites some examples. Also, for a rich type system the well-typedness problem tends to get hard and might even be undecidable.
Reference: [Mil78] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <year> 1978. </year>
Reference-contexts: As a consequence, the richness of a type system is less vital for ASMs than it is for many other specification languages. For these reasons, we propose a simple type system for ASMs. We present a type system that introduces parametric polymorphism as suggested by [Mor68] and <ref> [Mil78] </ref>. Our type system can be described as the type system of the programming language ML [MTH90] restricted to the first order case and without the let-construct. A followup paper [GS98] extends our type system in several ways including casting [FM90] and a modest version of type classes [NHN80, WB89].
Reference: [Mit96] <author> John C. Mitchell. </author> <title> Foundations for Programming Languages. </title> <publisher> The MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: a typeable term. (This algorithm is based on unification [Rob65].) Since this paper is concerned mainly with the concept of a typed ASM, we do not discuss the implementation of the algorithm.) There is no pretence on originality here; the algorithm can be derived from the relevant text books, e.g., <ref> [Hin96, Mit96] </ref>. However, the derivation may be not completely obvious to some readers interested in ASMs but not familiar with lambda calculus. Our unpretentious appendix may be useful to them. There was a division of labour among the authors of this paper. <p> For the readers convenience we prove a number of known facts, for example the uniqueness of principal types is proved. Of course, this is standard material that can also be found in text books dealing with type theory, e.g., <ref> [Hin96, Mit96] </ref>. 2.1 Syntax of Types Definition 1 (Type Vocabulary, Types) A type vocabulary is a pair hT; arityi such that Tis a set of type constructors and arity is a function arity: T! N 2 assigning an arity to every type constructor F 2 T.
Reference: [MM82] <author> Alberto Martelli and Ugo Montanari. </author> <title> An efficient unification algorithm. </title> <journal> ACM Transactions on Programming Language Systems, </journal> <volume> 4 </volume> <pages> 258-282, </pages> <year> 1982. </year>
Reference: [Mor68] <author> Jim H. Morris. </author> <title> Lambda Calculus Models of Programming Languages. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1968. </year>
Reference-contexts: As a consequence, the richness of a type system is less vital for ASMs than it is for many other specification languages. For these reasons, we propose a simple type system for ASMs. We present a type system that introduces parametric polymorphism as suggested by <ref> [Mor68] </ref> and [Mil78]. Our type system can be described as the type system of the programming language ML [MTH90] restricted to the first order case and without the let-construct.
Reference: [MTH90] <author> Robin Milner, Mats Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: For these reasons, we propose a simple type system for ASMs. We present a type system that introduces parametric polymorphism as suggested by [Mor68] and [Mil78]. Our type system can be described as the type system of the programming language ML <ref> [MTH90] </ref> restricted to the first order case and without the let-construct. A followup paper [GS98] extends our type system in several ways including casting [FM90] and a modest version of type classes [NHN80, WB89]. This paper is organized as follows. Section 2 introduces types and terms. <p> For example, this is done in the literature on the programming language ML <ref> [MTH90] </ref>. For notational simplicity, we make these universal quantifiers implicit. 4 profile T , we have to determine the context in which default appears in order to instantiate the type parameter T .
Reference: [NHN80] <author> R. Nakajima, M. Honda, and H. Nakahara. </author> <title> Hierarchical program specification: a many-sorted logical approach. </title> <journal> Acta Informatica, </journal> <volume> 14 </volume> <pages> 135-155, </pages> <year> 1980. </year>
Reference-contexts: Our type system can be described as the type system of the programming language ML [MTH90] restricted to the first order case and without the let-construct. A followup paper [GS98] extends our type system in several ways including casting [FM90] and a modest version of type classes <ref> [NHN80, WB89] </ref>. This paper is organized as follows. Section 2 introduces types and terms. The notion of a typeable term is given and we discuss the concept of a principal type. Section 3 presents typed ASMs. Section 4 elaborates the previously introduced concepts with an example.
Reference: [Rob65] <author> John Alan Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the ACM, </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: We discuss his work in Section 5. In order for this paper to be self contained, we give, in the appendix, an algorithm for computing the principal type of a typeable term. (This algorithm is based on unification <ref> [Rob65] </ref>.) Since this paper is concerned mainly with the concept of a typed ASM, we do not discuss the implementation of the algorithm.) There is no pretence on originality here; the algorithm can be derived from the relevant text books, e.g., [Hin96, Mit96].
Reference: [Str97] <author> Karl Stroetmann. </author> <title> The constrained shortest path problem: A case study in using ASMs. </title> <journal> J.UCS, </journal> <volume> 3(4) </volume> <pages> 304-319, </pages> <year> 1997. </year>
Reference-contexts: In general, an algorithm for computing the shortest path does not need to know the nature of the vertices of the graph. It is no problem to formulate a general algorithm of this kind as an ASM <ref> [Str97] </ref>. The idea is to have a nullary type constructor Vertex whose interpretation is left abstract. Using this abstract type, we can formulate an algorithm that is essentially polymorphic in the type Vertex, although formally Vertex is not a type parameter.
Reference: [Wan87] <author> Mitchell Wand. </author> <title> A simple algorithm and proof for type inference. </title> <journal> Fundamenta Infomaticae, </journal> <volume> 10 </volume> <pages> 115-122, </pages> <year> 1987. </year>
Reference: [WB89] <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad hoc. </title> <booktitle> ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: Our type system can be described as the type system of the programming language ML [MTH90] restricted to the first order case and without the let-construct. A followup paper [GS98] extends our type system in several ways including casting [FM90] and a modest version of type classes <ref> [NHN80, WB89] </ref>. This paper is organized as follows. Section 2 introduces types and terms. The notion of a typeable term is given and we discuss the concept of a principal type. Section 3 presents typed ASMs. Section 4 elaborates the previously introduced concepts with an example.
Reference: [Zam97] <author> Alexandre V. Zamulin. </author> <title> Typed Gurevich machines revisited. </title> <journal> Joint NCC and IIS Bulletin of Computer Science, </journal> <volume> 5 </volume> <pages> 1-30, </pages> <year> 1997. </year> <note> Acknowledgements We thank Egon Borger, </note> <author> Bertil A. Brandin, Sabine Glesner, Jim Huggins, Martin Mul-ler, Peter Pappinghaus, and Alexandre V. </author> <note> Zamulin for commenting on drafts of this paper. </note> <author> Furthermore, </author> <title> we would like to thank three anonymous referees, who have given very detailed and helpful comments. The second author has been partially supported by NSF grant CCR 95-04375 and ONR grant N00014-94-1-1137. The third author has been partially supported by BMBF grant 01 IS 519 A 9. </title> <type> 22 </type>
Reference-contexts: Section 3 presents typed ASMs. Section 4 elaborates the previously introduced concepts with an example. Finally, Section 5 is a concluding discussions. This is not the first paper on typed ASMs. In the pioneering paper <ref> [Zam97] </ref>, Zamulin presented a different and more ambitious approach. We discuss his work in Section 5. <p> But we do not want to confine the user to the algebraic style of defining data types. This is the main difference between our approach and the work of Zamulin <ref> [Zam97] </ref>. Zamulin offers a system that is not confined to the specification of the dynamic parts of an algorithm. He also introduces a specification language for specifying the static part of an ASM.
References-found: 25

