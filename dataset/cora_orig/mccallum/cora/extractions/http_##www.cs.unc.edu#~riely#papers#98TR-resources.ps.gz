URL: http://www.cs.unc.edu/~riely/papers/98TR-resources.ps.gz
Refering-URL: http://www.cs.unc.edu/~riely/
Root-URL: http://www.cs.unc.edu
Title: Resource Access Control in Systems of Mobile Agents  
Author: Matthew Hennessy and James Riely 
Address: Brighton BN1 9QH ISSN 13503170  
Date: 2/98 February 1998  
Affiliation: UNIVERSITY OF SUSSEX COMPUTER SCIENCE  Computer Science School of Cognitive and Computing Sciences University of Sussex  
Pubnum: Report  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Amadio and S. Prasad. </author> <title> Localities and failures. </title> <booktitle> In Proc. 14th Foundations of Software Technology and Theoretical Computer Science, volume 880 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: We take agents to be located threads, which are simply terms of the ordinary polyadic p-calculus [20], extended with primitives for movement between locations and for the creation of new locations. The language is similar to that studied by Amadio <ref> [3, 1] </ref>. There are two major differences: we ignore location failure and we restrict communication to be local. The second of these differences is more important. <p> Second, we introduce a move operator that allows a thread to move from one location to another; for example, the thread k :: p must move to location k before continuing to execute p. The move operator is also studied by Amadio <ref> [1, 3] </ref>, who writes k :: p as spawn (k; p). All of the operators but move are well known from the p-calculus.
Reference: [2] <author> R. Amadio and S. Prasad. </author> <title> Modelling IP mobility. </title> <type> Internal Report 244, </type> <institution> Labo-ratoire d'Informatique de Marseille, </institution> <year> 1997. </year>
Reference-contexts: A number of programming languages, APIs and protocols have recently emerged which seek to provide high-level support for mobile agents. These include Java [27], Odyssey [14], Aglets [17], Voyager [22] and the latest revisions of the Internet protocol <ref> [23, 2] </ref>. In addition to these commercial efforts, many prototype languages have been developed and implemented within the programming language research community examples include Linda [7, 8], Facile [15], Obliq [6], Infospheres [10], and the join calculus [12].
Reference: [3] <author> Roberto Amadio. </author> <title> An asynchronous model of locality, failure, and process mobility. In COORDINATION '97, </title> <booktitle> volume 1282 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: We take agents to be located threads, which are simply terms of the ordinary polyadic p-calculus [20], extended with primitives for movement between locations and for the creation of new locations. The language is similar to that studied by Amadio <ref> [3, 1] </ref>. There are two major differences: we ignore location failure and we restrict communication to be local. The second of these differences is more important. <p> Second, we introduce a move operator that allows a thread to move from one location to another; for example, the thread k :: p must move to location k before continuing to execute p. The move operator is also studied by Amadio <ref> [1, 3] </ref>, who writes k :: p as spawn (k; p). All of the operators but move are well known from the p-calculus. <p> Communication between agents occurs along channels. As discussed in the example at the beginning of this section, communication is purely local (unlike <ref> [3, 11, 26] </ref>) in that agents can only communicate with other agents at the same location, using channels that have been allocated at that location. In the concrete syntax, move has greater binding power than composition. Thus ` :: p j q should be read (` :: p) j q. <p> The tagged language and the associated reduction relation appear to be novel. Related Work. There are numerous languages now in the literature for describing distributed systems; Dp is perhaps closest in spirit to <ref> [12, 3, 26, 5] </ref> which also take as their point of departure the p-calculus, although with each there are significant differences. For example in the join calculus [12] message routing is automatic as the restricted syntax ensures that all channels have a unique location at which they are serviced. <p> Sewell [26] generalizes the type system of [24] to distinguish between local communication, which can be efficiently implemented, and non-local communication. Fournet et al. [13] have developed an ML-style typing system for the join calculus where channels are allowed a certain amount of polymorphism. Amadio <ref> [3] </ref> has presented a type system that guarantees that channel names are defined at exactly one location, whereas the type system of Kobayashi et al. [19] Resource Access Control in Systems of Mobile Agents 44 ensures that some channels are used linearly.
Reference: [4] <author> Gerard Berry and Gerard Boudol. </author> <title> The chemical abstract machine. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 8194, </pages> <address> San Francisco, </address> <month> January </month> <year> 1990. </year> <note> ACM Press. </note>
Reference-contexts: Information thus acquired may be returned to the primary agent later via communication. We discuss this further in Example 4 of Section 3. The structural equivalence <ref> [4, 20] </ref>, defined in Table 3, relates closed systems (P Q). The purpose of the structural equivalence is to abstract from the static structure of terms, i.e. from the irrelevant details of the syntactic relation between composition (p j q), restriction ((ne) p) and location (`JpK).
Reference: [5] <author> L. Cardelli and A. D. Gordon. Mobile ambients, </author> <year> 1997. </year> <note> Draft, Available from http://www.cl.cam.ac.uk/users/adg/. </note>
Reference-contexts: The tagged language and the associated reduction relation appear to be novel. Related Work. There are numerous languages now in the literature for describing distributed systems; Dp is perhaps closest in spirit to <ref> [12, 3, 26, 5] </ref> which also take as their point of departure the p-calculus, although with each there are significant differences. For example in the join calculus [12] message routing is automatic as the restricted syntax ensures that all channels have a unique location at which they are serviced. <p> In Dp, to send a message to a remote location, an agent must first spawn a sub-agent which moves to that location; locations are more visible in Dp. In addition, several of these languages <ref> [12, 26, 5] </ref> adopt location movement as the mechanism for agent mobility. We describe this further when we discuss open issues, below. Many channel-based typing systems for p-calculi and related languages have been proposed. <p> A more satisfying account of physical distribution is obtained using a hierarchical representation of locality as in the join calculus [12], the ambient calculus <ref> [5] </ref> and some distributed p-calculi [25, 26]. In a hierarchical model, machines can be viewed as locations which contain objects (which are locations), which contain sub-objects, and so on. In such languages, it is locations which move, rather than threads, and thus agents are identified with locations, rather than threads. <p> This has the advantage that agents may be multi-threaded, and thus agents that may move at any time are easier to express. While location movement is in some sense more general than code movement (at least if the language is enriched with other operators of sufficient power <ref> [5] </ref>), we have chosen to concentrate on code movement because it is supports a clear distinction between resource and agent which is well understood from decades of work in concurrency theory; it is also a special case of extreme practical importance. <p> In variants of the distributed join calculus [12, 26, 25], in addition to location movement, code movement is allowed, often in the restricted form of message movement i.e. the move operator is of the form ` :: a!hVi rather than ` :: p. 7 In the ambient calculus <ref> [5] </ref>, an open operator is introduced: open (`) dissolves location ` (or, if you prefer, the boundary around location `) causing all of the threads in ` to move to `'s parent. Thus code movement is hidden inside the open operator.
Reference: [6] <author> Luca Cardelli. </author> <title> A language with distributed scope. </title> <booktitle> Computing Systems, </booktitle> <address> 8(1):2759, </address> <month> January </month> <year> 1995. </year> <note> A preliminary version appeared in Proceedings of the 22nd ACM Symposium on Principles of Programming. </note>
Reference-contexts: These include Java [27], Odyssey [14], Aglets [17], Voyager [22] and the latest revisions of the Internet protocol [23, 2]. In addition to these commercial efforts, many prototype languages have been developed and implemented within the programming language research community examples include Linda [7, 8], Facile [15], Obliq <ref> [6] </ref>, Infospheres [10], and the join calculus [12]. In this paper we address the issue of resource access control for such languages. Central to the paradigm of mobile computation are the notions of agent, resource and location. Agents are effective entities that perform computation and interact with other agents. <p> This is most apparent when considering the restriction operator, by which an agent can dynamically create an arbitrary number of new, independent locations. In this respect the language is similar to Obliq <ref> [6] </ref>, were sites are not directly represented in the language and instead are discussed as an auxiliary or meta concept.
Reference: [7] <author> N. Carriero and D. Gelernter. </author> <title> Linda in context. </title> <journal> Communications of the ACM, </journal> <volume> 32(4):444458, </volume> <year> 1989. </year>
Reference-contexts: These include Java [27], Odyssey [14], Aglets [17], Voyager [22] and the latest revisions of the Internet protocol [23, 2]. In addition to these commercial efforts, many prototype languages have been developed and implemented within the programming language research community examples include Linda <ref> [7, 8] </ref>, Facile [15], Obliq [6], Infospheres [10], and the join calculus [12]. In this paper we address the issue of resource access control for such languages. Central to the paradigm of mobile computation are the notions of agent, resource and location.
Reference: [8] <author> N. Carriero, D. Gelernter, and L. Zuck. Bauhaus Linda. </author> <title> In Object-Based Models and Languages for Concurrent Systems, </title> <booktitle> number 924 in Lecture Notes in Computer Science, </booktitle> <pages> pages 6676. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: These include Java [27], Odyssey [14], Aglets [17], Voyager [22] and the latest revisions of the Internet protocol [23, 2]. In addition to these commercial efforts, many prototype languages have been developed and implemented within the programming language research community examples include Linda <ref> [7, 8] </ref>, Facile [15], Obliq [6], Infospheres [10], and the join calculus [12]. In this paper we address the issue of resource access control for such languages. Central to the paradigm of mobile computation are the notions of agent, resource and location. <p> The work closest to ours is that of de Nicola, Ferrari and Pugliese [9]. Their goals are the same as ours, but the specifics of their solution are quite different. They work with a variant of Linda <ref> [8] </ref> with multiple tuple spaces. Tuple spaces correspond to locations in our setting, and tuples (named data) correspond to resources. The type system of [9] controls access to tuple spaces, rather than to specific tuples, and thus provides coarser-grained control of resource access than that provided by our typing system.
Reference: [9] <author> Rocco De Nicola, GainLuigi Ferrari, and Rosario Pugliese. </author> <title> Coordinating mobile agents via blackboards and access rights. In COORDINATION '97, </title> <booktitle> volume 1282 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: The work closest to ours is that of de Nicola, Ferrari and Pugliese <ref> [9] </ref>. Their goals are the same as ours, but the specifics of their solution are quite different. They work with a variant of Linda [8] with multiple tuple spaces. Tuple spaces correspond to locations in our setting, and tuples (named data) correspond to resources. The type system of [9] controls access <p> and Pugliese <ref> [9] </ref>. Their goals are the same as ours, but the specifics of their solution are quite different. They work with a variant of Linda [8] with multiple tuple spaces. Tuple spaces correspond to locations in our setting, and tuples (named data) correspond to resources. The type system of [9] controls access to tuple spaces, rather than to specific tuples, and thus provides coarser-grained control of resource access than that provided by our typing system. Static analyses for proving various security properties of programs have also been proposed by several authors; two recent references are [18, 16].
Reference: [10] <author> K. Mani Chandy et al. </author> <title> A world-wide distributed system using java and the internet. </title> <booktitle> In IEEE International Symposium on High Performance Distributed Computing. IEEE, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: In addition to these commercial efforts, many prototype languages have been developed and implemented within the programming language research community examples include Linda [7, 8], Facile [15], Obliq [6], Infospheres <ref> [10] </ref>, and the join calculus [12]. In this paper we address the issue of resource access control for such languages. Central to the paradigm of mobile computation are the notions of agent, resource and location. Agents are effective entities that perform computation and interact with other agents.
Reference: [11] <author> C. Fournet and G. Gonthier. </author> <booktitle> The refliexive CHAM and the join-calculus. In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <address> Paris, </address> <month> January </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: Communication between agents occurs along channels. As discussed in the example at the beginning of this section, communication is purely local (unlike <ref> [3, 11, 26] </ref>) in that agents can only communicate with other agents at the same location, using channels that have been allocated at that location. In the concrete syntax, move has greater binding power than composition. Thus ` :: p j q should be read (` :: p) j q. <p> Recursive definitions are known to be codeable using iteration (as long as the number of definitions is finite) [20]; the coding of let-expressions is straightforward (see e.g. <ref> [11] </ref>).
Reference: [12] <author> C. Fournet, G. Gonthier, J.J. Levy, L. Marganget, and D. Remy. </author> <title> A calculus of mobile agents. </title> <editor> In U. Montanari and V. Sassone, editors, </editor> <booktitle> CONCUR: Proceedings of the International Conference on Concurrency Theory, volume 1119 of Lecture Notes in Computer Science, </booktitle> <pages> pages 406421, </pages> <address> Pisa, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: In addition to these commercial efforts, many prototype languages have been developed and implemented within the programming language research community examples include Linda [7, 8], Facile [15], Obliq [6], Infospheres [10], and the join calculus <ref> [12] </ref>. In this paper we address the issue of resource access control for such languages. Central to the paradigm of mobile computation are the notions of agent, resource and location. Agents are effective entities that perform computation and interact with other agents. <p> The language is similar to that studied by Amadio [3, 1]. There are two major differences: we ignore location failure and we restrict communication to be local. The second of these differences is more important. In Amadio's language and in most other distributed versions of the p-calculus <ref> [26, 12] </ref>, there are two forms of movement: one for agents and another for messages, which can be seen as very simple agents consisting only of a value that is to be communicated remotely. <p> The tagged language and the associated reduction relation appear to be novel. Related Work. There are numerous languages now in the literature for describing distributed systems; Dp is perhaps closest in spirit to <ref> [12, 3, 26, 5] </ref> which also take as their point of departure the p-calculus, although with each there are significant differences. For example in the join calculus [12] message routing is automatic as the restricted syntax ensures that all channels have a unique location at which they are serviced. <p> Related Work. There are numerous languages now in the literature for describing distributed systems; Dp is perhaps closest in spirit to [12, 3, 26, 5] which also take as their point of departure the p-calculus, although with each there are significant differences. For example in the join calculus <ref> [12] </ref> message routing is automatic as the restricted syntax ensures that all channels have a unique location at which they are serviced. In Dp, to send a message to a remote location, an agent must first spawn a sub-agent which moves to that location; locations are more visible in Dp. <p> In Dp, to send a message to a remote location, an agent must first spawn a sub-agent which moves to that location; locations are more visible in Dp. In addition, several of these languages <ref> [12, 26, 5] </ref> adopt location movement as the mechanism for agent mobility. We describe this further when we discuss open issues, below. Many channel-based typing systems for p-calculi and related languages have been proposed. <p> In this respect the language is similar to Obliq [6], were sites are not directly represented in the language and instead are discussed as an auxiliary or meta concept. A more satisfying account of physical distribution is obtained using a hierarchical representation of locality as in the join calculus <ref> [12] </ref>, the ambient calculus [5] and some distributed p-calculi [25, 26]. In a hierarchical model, machines can be viewed as locations which contain objects (which are locations), which contain sub-objects, and so on. <p> However, location movement, in a simple language such as Dp, is not powerful enough to express interaction between agents. This is because all interaction occurs within a location, and therefore interaction between locations is not possible without some extension to the language. In variants of the distributed join calculus <ref> [12, 26, 25] </ref>, in addition to location movement, code movement is allowed, often in the restricted form of message movement i.e. the move operator is of the form ` :: a!hVi rather than ` :: p. 7 In the ambient calculus [5], an open operator is introduced: open (`) dissolves location <p> Example 5 was originally presented to us by Alan Jeffrey in the context of active networks; we have adapted the example to our language. The type extrusion example, given in the conclusion, was developed during a discussion with Peter Sewell. 7 In fact, in the languages of <ref> [12, 26] </ref>, ` :: a!hVi is written simply as a!hVi. Since every channel name can be used by at most one location, the explicit use of move is unnecessary.
Reference: [13] <author> Cedric Fournet, Cosimo Laneve, Luc Maranget, and Didier Remy. </author> <title> Implicit typing a la ml for the join-calculus. </title> <booktitle> In CONCUR: Proceedings of the International Conference on Concurrency Theory, Lecture Notes in Computer Science, </booktitle> <address> Warsaw, </address> <month> August </month> <year> 1997. </year> <note> Springer-Verlag. </note>
Reference-contexts: Sewell [26] generalizes the type system of [24] to distinguish between local communication, which can be efficiently implemented, and non-local communication. Fournet et al. <ref> [13] </ref> have developed an ML-style typing system for the join calculus where channels are allowed a certain amount of polymorphism.
Reference: [14] <institution> General Magic Inc. Agent technology. hhtp://www.genmagic.com/html/agent_overview.html, </institution> <year> 1997. </year> <title> Resource Access Control in Systems of Mobile Agents 57 </title>
Reference-contexts: 1 Introduction Mobile computation, where independent agents roam widely distributed networks in search of resources and information, is fast becoming a reality. A number of programming languages, APIs and protocols have recently emerged which seek to provide high-level support for mobile agents. These include Java [27], Odyssey <ref> [14] </ref>, Aglets [17], Voyager [22] and the latest revisions of the Internet protocol [23, 2].
Reference: [15] <author> A. Giacalone, P. Mishra, and S. Prasad. </author> <title> A symmetric integration of concurrent and functional programming. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 18(2):121160, </volume> <year> 1989. </year>
Reference-contexts: These include Java [27], Odyssey [14], Aglets [17], Voyager [22] and the latest revisions of the Internet protocol [23, 2]. In addition to these commercial efforts, many prototype languages have been developed and implemented within the programming language research community examples include Linda [7, 8], Facile <ref> [15] </ref>, Obliq [6], Infospheres [10], and the join calculus [12]. In this paper we address the issue of resource access control for such languages. Central to the paradigm of mobile computation are the notions of agent, resource and location.
Reference: [16] <author> Nevin Heintz and Jon G. Riecke. </author> <title> The SLam calculus: Programming with secrecy and integrity. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <month> January </month> <year> 1998. </year> <note> ACM Press. </note>
Reference-contexts: Static analyses for proving various security properties of programs have also been proposed by several authors; two recent references are <ref> [18, 16] </ref>. Open Issues Partially-Typed Systems. The p-calculus [21] itself is a language for resource access control, using the mechanisms of restriction and scope extrusion to regulate the availability of resources.
Reference: [17] <institution> IBM Corp. The IBM aglets workbench. </institution> <note> http://www.trl.ibm.co.jp/aglets/, 1996. </note>
Reference-contexts: 1 Introduction Mobile computation, where independent agents roam widely distributed networks in search of resources and information, is fast becoming a reality. A number of programming languages, APIs and protocols have recently emerged which seek to provide high-level support for mobile agents. These include Java [27], Odyssey [14], Aglets <ref> [17] </ref>, Voyager [22] and the latest revisions of the Internet protocol [23, 2]. In addition to these commercial efforts, many prototype languages have been developed and implemented within the programming language research community examples include Linda [7, 8], Facile [15], Obliq [6], Infospheres [10], and the join calculus [12].
Reference: [18] <author> Gunter Karjoth, Danny B. Lange, and Mitsuru Oshima. </author> <title> A security model for aglets. </title> <journal> IEEE Internet Computing, </journal> <volume> 1(4), </volume> <year> 1997. </year>
Reference-contexts: Static analyses for proving various security properties of programs have also been proposed by several authors; two recent references are <ref> [18, 16] </ref>. Open Issues Partially-Typed Systems. The p-calculus [21] itself is a language for resource access control, using the mechanisms of restriction and scope extrusion to regulate the availability of resources.
Reference: [19] <author> Naoki Kobayashi, Benjamin C. Pierce, and David N. Turner. </author> <title> Linearity and the pi-calculus. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <address> Paris, </address> <month> January </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: Fournet et al. [13] have developed an ML-style typing system for the join calculus where channels are allowed a certain amount of polymorphism. Amadio [3] has presented a type system that guarantees that channel names are defined at exactly one location, whereas the type system of Kobayashi et al. <ref> [19] </ref> Resource Access Control in Systems of Mobile Agents 44 ensures that some channels are used linearly. The work closest to ours is that of de Nicola, Ferrari and Pugliese [9]. Their goals are the same as ours, but the specifics of their solution are quite different. <p> To eliminate such problems, one might adopt the notion of linear channels <ref> [19] </ref> and require that channels such as a and b have at most one sender. Type Extrusion. One limitation of our language is that names can be extruded, but types cannot. To show this we study a modification of the counter server described in Example 2 of Section 3.
Reference: [20] <author> Robin Milner. </author> <title> The polyadic p-calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh, UK, </institution> <month> October </month> <year> 1991. </year> <title> Also in Logic and Algebra of Specification, </title> <editor> ed. F. L. Bauer, W. Brauer and H. Schwichtenberg, </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The language studied in this paper, called Dp, 1 is a distributed variant of the p-calculus [21], and thus the resources of interest are channels which support binary communication between agents. We take agents to be located threads, which are simply terms of the ordinary polyadic p-calculus <ref> [20] </ref>, extended with primitives for movement between locations and for the creation of new locations. The language is similar to that studied by Amadio [3, 1]. There are two major differences: we ignore location failure and we restrict communication to be local. The second of these differences is more important. <p> Systems are combined using the static combinators of the p-calculus, namely parallel composition j and restriction (ne) . We further discuss the form of the restriction operator below, after describing types. The syntax of threads is similar to that of the synchronous polyadic p-calculus <ref> [20] </ref>, with some small extensions to deal with locations. First, locations are names and thus many of the usual operators of the p-calculus apply to them. <p> Information thus acquired may be returned to the primary agent later via communication. We discuss this further in Example 4 of Section 3. The structural equivalence <ref> [4, 20] </ref>, defined in Table 3, relates closed systems (P Q). The purpose of the structural equivalence is to abstract from the static structure of terms, i.e. from the irrelevant details of the syntactic relation between composition (p j q), restriction ((ne) p) and location (`JpK). <p> To make the program readable, we assume some additional syntactic conventions, including recursive definitions, let-expressions and the notation for remote channel creation introduced in the previous example. Recursive definitions are known to be codeable using iteration (as long as the number of definitions is finite) <ref> [20] </ref>; the coding of let-expressions is straightforward (see e.g. [11]). <p> In reactive languages which lack such canonical forms, such as the polyadic p-calculus, the statement of type safety is more delicate. Milner <ref> [20] </ref> describes type safety as freedom from arity mismatches. For example, the system `Jc!ha; biK j `Jc?(z:loc) z :: qK gives rise to a runtime error because the first thread sends a pair of channels, whereas the second expects a singleton location.
Reference: [21] <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A calculus of mobile processes, Parts I and II. Information and Computation, </title> <address> 100:177, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: Using this tagged language, we capture resource access violations as runtime errors and show that well-typed terms are incapable of such errors. The language studied in this paper, called Dp, 1 is a distributed variant of the p-calculus <ref> [21] </ref>, and thus the resources of interest are channels which support binary communication between agents. We take agents to be located threads, which are simply terms of the ordinary polyadic p-calculus [20], extended with primitives for movement between locations and for the creation of new locations. <p> Static analyses for proving various security properties of programs have also been proposed by several authors; two recent references are [18, 16]. Open Issues Partially-Typed Systems. The p-calculus <ref> [21] </ref> itself is a language for resource access control, using the mechanisms of restriction and scope extrusion to regulate the availability of resources. Distributed p-calculi such as Dp inherit the same mechanisms, so one might wonder why location types are needed at all.
Reference: [22] <institution> ObjectSpace Inc. </institution> <note> Objectspace voyager. http://www.objectspace.com/voyager, 1997. </note>
Reference-contexts: A number of programming languages, APIs and protocols have recently emerged which seek to provide high-level support for mobile agents. These include Java [27], Odyssey [14], Aglets [17], Voyager <ref> [22] </ref> and the latest revisions of the Internet protocol [23, 2]. In addition to these commercial efforts, many prototype languages have been developed and implemented within the programming language research community examples include Linda [7, 8], Facile [15], Obliq [6], Infospheres [10], and the join calculus [12].
Reference: [23] <author> C. Perkins. </author> <title> IP mobility support. </title> <booktitle> RFC 2002, </booktitle> <year> 1996. </year>
Reference-contexts: A number of programming languages, APIs and protocols have recently emerged which seek to provide high-level support for mobile agents. These include Java [27], Odyssey [14], Aglets [17], Voyager [22] and the latest revisions of the Internet protocol <ref> [23, 2] </ref>. In addition to these commercial efforts, many prototype languages have been developed and implemented within the programming language research community examples include Linda [7, 8], Facile [15], Obliq [6], Infospheres [10], and the join calculus [12].
Reference: [24] <author> Benjamin Pierce and Davide Sangiorgi. </author> <title> Typing and subtyping for mobile processes. </title> <note> Mathematical Structures in Computer Science, 6(5):409454, 1996. Extended abstract in LICS '93. </note>
Reference-contexts: In Section 6 we extend the improved type system to a language with channel subtyping, based on read and write capabilities. The extended type system is based on that of Pierce and Sangiorgi <ref> [24] </ref>, who first studied channel subtyping for p-calculi. Pierce and Sangiorgi's definition of subtyping, however, is not bounded complete. To rectify this, we use a type language and subtyping relation which generalize those of [24]. <p> The extended type system is based on that of Pierce and Sangiorgi <ref> [24] </ref>, who first studied channel subtyping for p-calculi. Pierce and Sangiorgi's definition of subtyping, however, is not bounded complete. To rectify this, we use a type language and subtyping relation which generalize those of [24]. In this section we also augment location types with explicit capabilities for channel creation and agent movement. The paper concludes with a discussion of related work and open issues. <p> This definition of type safety is related to that for the lambda calculus: arity matching is required for substitution (and therefore the reduction rule r-comm) to be defined. Type safety for p-calculi with capabilities was first studied by Pierce and San-giorgi <ref> [24] </ref>; we presented an alternative formulation in [25], which we now recount. <p> We discuss this further in the conclusion. Resource Access Control in Systems of Mobile Agents 33 6 Type Extensions In this section we show how to extend our results to a richer type system with nontrivial subtyping on channel types. Following Pierce and Sangiorgi <ref> [24] </ref>, channel subtyping is defined using read and write capabilities. Our requirement that all types be FBC, however, forces us to follow a more general approach than that of [24]. Examples of the use of these extended types may be found towards the end of the section. Types and Subtyping. <p> Following Pierce and Sangiorgi <ref> [24] </ref>, channel subtyping is defined using read and write capabilities. Our requirement that all types be FBC, however, forces us to follow a more general approach than that of [24]. Examples of the use of these extended types may be found towards the end of the section. Types and Subtyping. The definition of extended pre-types is given in Table 9, where we explicitly introduce syntactic categories for location capabilities k-l and channel capabilities a-b. <p> On simple types, the subtyping relation of Table 9 degenerates to that of Table 4. To establish chanfrhzi; whzig chanfrhxi; whxig, it is required that both z x and x z; therefore z and x must be identical. Readers that are familiar with <ref> [24] </ref> will notice that Pierce and Sangiorgi's channel types PS types are also representable in our type system (ignoring recursion). <p> Crucial in the development of the typing systems has been the presence of a partial meet operator at all types. The need for such an operator forced us to abandon the notion of resource types proposed by Pierce and Sangiorgi <ref> [24] </ref> in favor of more general types. The usefulness of the typing systems has been shown by introducing a tagged language in which agents are annotated with their capability sets. The tagged language and the associated reduction relation appear to be novel. Related Work. <p> In addition, several of these languages [12, 26, 5] adopt location movement as the mechanism for agent mobility. We describe this further when we discuss open issues, below. Many channel-based typing systems for p-calculi and related languages have been proposed. For example in <ref> [24] </ref>, discussed at length in Section 6, Pierce and Sangiorgi define a type system for the p-calculus with read and write capabilities on channels. Sewell [26] generalizes the type system of [24] to distinguish between local communication, which can be efficiently implemented, and non-local communication. <p> Many channel-based typing systems for p-calculi and related languages have been proposed. For example in <ref> [24] </ref>, discussed at length in Section 6, Pierce and Sangiorgi define a type system for the p-calculus with read and write capabilities on channels. Sewell [26] generalizes the type system of [24] to distinguish between local communication, which can be efficiently implemented, and non-local communication. Fournet et al. [13] have developed an ML-style typing system for the join calculus where channels are allowed a certain amount of polymorphism. <p> Note that without recursive types, many interesting systems cannot be expressed. These include encodings of recursive data structures, such as lists, and encodings of other calculi, such as the l-calculus <ref> [24] </ref>; a toy example is a!hai. Linear Types. At the end of Section 5, we described a server which creates a location with three channels and then communicates the names of these channels, one at a time.
Reference: [25] <author> James Riely and Matthew Hennessy. </author> <title> A typed language for distributed mobile processes. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <month> January </month> <year> 1998. </year> <note> ACM Press. </note>
Reference-contexts: Of course for such communication to be sound, the sender must have, for the value it is sending, all of the capabilities that the channel requires. Otherwise a sender could forge 1 The language is somewhat different from that of <ref> [25] </ref>, although we use the same name. Resource Access Control in Systems of Mobile Agents 3 arbitrary capabilities. To formalize this requirement we introduce a subtyping relation on types. <p> This definition of type safety is related to that for the lambda calculus: arity matching is required for substitution (and therefore the reduction rule r-comm) to be defined. Type safety for p-calculi with capabilities was first studied by Pierce and San-giorgi [24]; we presented an alternative formulation in <ref> [25] </ref>, which we now recount. The basic idea is that every instance of a name is tagged with certain capabilities and each instance may only be used as its capabilities allow; attempts to use a name without the proper capability result in runtime error. <p> To do so, the language must be enriched with permissions; a runtime error occurs, then, when a name is used without permission. In <ref> [25] </ref> we defined such an enriched language by placing tags on every instance of a name. Here we take an alternative approach. Rather than tag every instance of a name, we tag threads; thus as a thread evolves, its accumulated capabilities are explicitly recorded. <p> The new capabilities are: * move, the ability to move to the location, and * newc, the ability to create a new local channel. In other languages, such as that considered in <ref> [25] </ref> other capabilities might be defined, such as the capability to halt or migrate a location or the ability to create sublocations. Since we allow subtyping on channel types the definition of subtyping on location types must generalize that of previous sections. <p> A more satisfying account of physical distribution is obtained using a hierarchical representation of locality as in the join calculus [12], the ambient calculus [5] and some distributed p-calculi <ref> [25, 26] </ref>. In a hierarchical model, machines can be viewed as locations which contain objects (which are locations), which contain sub-objects, and so on. In such languages, it is locations which move, rather than threads, and thus agents are identified with locations, rather than threads. <p> However, location movement, in a simple language such as Dp, is not powerful enough to express interaction between agents. This is because all interaction occurs within a location, and therefore interaction between locations is not possible without some extension to the language. In variants of the distributed join calculus <ref> [12, 26, 25] </ref>, in addition to location movement, code movement is allowed, often in the restricted form of message movement i.e. the move operator is of the form ` :: a!hVi rather than ` :: p. 7 In the ambient calculus [5], an open operator is introduced: open (`) dissolves location
Reference: [26] <author> Peter Sewell. </author> <title> Global/local subtyping for a distributed p-calculus. </title> <type> Technical Report 435, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> August </month> <year> 1997. </year>
Reference-contexts: The language is similar to that studied by Amadio [3, 1]. There are two major differences: we ignore location failure and we restrict communication to be local. The second of these differences is more important. In Amadio's language and in most other distributed versions of the p-calculus <ref> [26, 12] </ref>, there are two forms of movement: one for agents and another for messages, which can be seen as very simple agents consisting only of a value that is to be communicated remotely. <p> Communication between agents occurs along channels. As discussed in the example at the beginning of this section, communication is purely local (unlike <ref> [3, 11, 26] </ref>) in that agents can only communicate with other agents at the same location, using channels that have been allocated at that location. In the concrete syntax, move has greater binding power than composition. Thus ` :: p j q should be read (` :: p) j q. <p> The tagged language and the associated reduction relation appear to be novel. Related Work. There are numerous languages now in the literature for describing distributed systems; Dp is perhaps closest in spirit to <ref> [12, 3, 26, 5] </ref> which also take as their point of departure the p-calculus, although with each there are significant differences. For example in the join calculus [12] message routing is automatic as the restricted syntax ensures that all channels have a unique location at which they are serviced. <p> In Dp, to send a message to a remote location, an agent must first spawn a sub-agent which moves to that location; locations are more visible in Dp. In addition, several of these languages <ref> [12, 26, 5] </ref> adopt location movement as the mechanism for agent mobility. We describe this further when we discuss open issues, below. Many channel-based typing systems for p-calculi and related languages have been proposed. <p> Many channel-based typing systems for p-calculi and related languages have been proposed. For example in [24], discussed at length in Section 6, Pierce and Sangiorgi define a type system for the p-calculus with read and write capabilities on channels. Sewell <ref> [26] </ref> generalizes the type system of [24] to distinguish between local communication, which can be efficiently implemented, and non-local communication. Fournet et al. [13] have developed an ML-style typing system for the join calculus where channels are allowed a certain amount of polymorphism. <p> We speculate that the extension to recursive types, however, will be smooth. To do so, one would need to replace every instance of type equality in the paper with a weaker relation such as bisimilarity [28] or equality up to unfolding <ref> [26] </ref>. We do not expect that the proofs of subject reduction and type safety would be much effected by this change; nor do we foresee any difficulty in extending the proof of finite bounded completeness. Note that without recursive types, many interesting systems cannot be expressed. <p> A more satisfying account of physical distribution is obtained using a hierarchical representation of locality as in the join calculus [12], the ambient calculus [5] and some distributed p-calculi <ref> [25, 26] </ref>. In a hierarchical model, machines can be viewed as locations which contain objects (which are locations), which contain sub-objects, and so on. In such languages, it is locations which move, rather than threads, and thus agents are identified with locations, rather than threads. <p> However, location movement, in a simple language such as Dp, is not powerful enough to express interaction between agents. This is because all interaction occurs within a location, and therefore interaction between locations is not possible without some extension to the language. In variants of the distributed join calculus <ref> [12, 26, 25] </ref>, in addition to location movement, code movement is allowed, often in the restricted form of message movement i.e. the move operator is of the form ` :: a!hVi rather than ` :: p. 7 In the ambient calculus [5], an open operator is introduced: open (`) dissolves location <p> Example 5 was originally presented to us by Alan Jeffrey in the context of active networks; we have adapted the example to our language. The type extrusion example, given in the conclusion, was developed during a discussion with Peter Sewell. 7 In fact, in the languages of <ref> [12, 26] </ref>, ` :: a!hVi is written simply as a!hVi. Since every channel name can be used by at most one location, the explicit use of move is unnecessary.
Reference: [27] <institution> Sun Microsystems Inc. Java home page. </institution> <note> http://www.javasoft.com/, 1995. </note>
Reference-contexts: 1 Introduction Mobile computation, where independent agents roam widely distributed networks in search of resources and information, is fast becoming a reality. A number of programming languages, APIs and protocols have recently emerged which seek to provide high-level support for mobile agents. These include Java <ref> [27] </ref>, Odyssey [14], Aglets [17], Voyager [22] and the latest revisions of the Internet protocol [23, 2].
Reference: [28] <author> David Turner. </author> <title> The Polymorphic Pi-Calculus: Theory and Implementation. </title> <type> PhD thesis, </type> <institution> Edinburgh University, </institution> <year> 1995. </year>
Reference-contexts: We speculate that the extension to recursive types, however, will be smooth. To do so, one would need to replace every instance of type equality in the paper with a weaker relation such as bisimilarity <ref> [28] </ref> or equality up to unfolding [26]. We do not expect that the proofs of subject reduction and type safety would be much effected by this change; nor do we foresee any difficulty in extending the proof of finite bounded completeness.
References-found: 28

