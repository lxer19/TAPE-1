URL: http://www.cs.columbia.edu/~sal/hpapers/alexsys.ps
Refering-URL: http://www.cs.columbia.edu/~sal/alexsys.html
Root-URL: http://www.cs.columbia.edu
Title: The ALEXSYS Mortgage Pool Allocation Expert System: A Case Study of Speeding Up Rule-based Programs  
Author: Salvatore J. Stolfo Leland Woodbury Jason Glazier and Philip Chan 
Date: July 1990  
Address: New York, N.Y. 10027  
Affiliation: Columbia University Department of Computer Science and Center for Advanced Technology  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Brownston, L., R. Farrell, E. Kant, and N. Martin. </author> <title> Programming Expert Systems in OPS5: An Introduction to Rule-Based Programming. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mass., </address> <year> 1985. </year>
Reference-contexts: Lastly, although rule-based formalisms appear at first glance to be highly parallel by virtue of their declarative expression, closer inspection reveals that too often sequentialities are programmed into the rule base to force desirable sequences of rule firings (see <ref> [1] </ref> for example). These sequentialities are represented by "control elements" that serve to activate or deactivate rules as these elements are added to or deleted from the working memory.
Reference: [2] <author> Davis, R. </author> <title> Meta-rules: Reasoning about control. </title> <booktitle> Artificial Intelligence </booktitle> (15):179-222, 1980. 
Reference-contexts: The earliest work in this direction was reported over a decade ago in the form of "controled" rule languages [17, 4] and in the form of "meta-rules" <ref> [2] </ref>. Another synergistic path is parallelizing the rule base to gain efficient parallel performance by removing unnecessary sequentialities.
Reference: [3] <author> Forgy C. L. </author> <title> OPS5 User's Manual. </title> <type> Technical Report CMU-CS-81-135, </type> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <month> July, </month> <year> 1981. </year>
Reference-contexts: Indeed, we have reported a number of parallel algorithms for the high speed execution of rule-based systems, several having been implemented on the DADO2 parallel computer and reported in various articles [20, 18, 21]. Many others have reported similar approaches and results including shared-memory parallel systems <ref> [3, 5, 8, 12] </ref>. Considerable work has already been done in an effort to determine the available parallelism in rule-based programs, and of the speedup to be expected from their execution on parallel machines.
Reference: [4] <author> Georgeff, M. P. </author> <title> Procedural Control in Production Systems. </title> <booktitle> Artificial Intelligence 18(2) </booktitle> <pages> 175-201, </pages> <month> March, </month> <year> 1982. </year>
Reference-contexts: These problems may be ameliorated by improving the rule languages in the first place to allow programmer-specified execution semantics in a language added to the base rule language. The earliest work in this direction was reported over a decade ago in the form of "controled" rule languages <ref> [17, 4] </ref> and in the form of "meta-rules" [2]. Another synergistic path is parallelizing the rule base to gain efficient parallel performance by removing unnecessary sequentialities.
Reference: [5] <author> Gupta, A. </author> <title> Parallelism in Production Systems. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> March, </month> <year> 1986. </year>
Reference-contexts: Indeed, we have reported a number of parallel algorithms for the high speed execution of rule-based systems, several having been implemented on the DADO2 parallel computer and reported in various articles [20, 18, 21]. Many others have reported similar approaches and results including shared-memory parallel systems <ref> [3, 5, 8, 12] </ref>. Considerable work has already been done in an effort to determine the available parallelism in rule-based programs, and of the speedup to be expected from their execution on parallel machines. <p> One example of this is the "copy and constrain" technique (a data reduction technique) that has been demonstrated to elicit much more parallelism from a rule set than was previously believed possible (see [19, 14]). We suspect that several well-known reported studies (see <ref> [5] </ref>, for example) produced disappointing results in parallelizing rule sets solely because of unnecessary sequentialities encoded in those rule sets. These studies have unfortunately concentrated on a very few sample OPS5 programs executed under the RETE match algorithm.
Reference: [6] <author> Ishida T., and S. J. Stolfo. </author> <title> Simultaneous Firing of Production Rules on Tree-structured Machines. </title> <type> Technical Report CUCS-109-84, </type> <institution> Department of Computer Science, Columbia University, </institution> <year> 1984. </year>
Reference-contexts: This results in added savings by reducing the amount of "overhead" in synchronizing the processors to collectively operate in the interpreter's rule selection phase. One of the earliest approaches of multiple rule firing in parallel was reported by <ref> [6, 7] </ref>, where these concepts are discussed more fully, and was shown to produce performance gains in one large program studied. This performance gain, however, required rewriting the rule set to remove unnecessary sequentialities.
Reference: [7] <author> Ishida T. and S. J. Stolfo. </author> <title> Towards the Parallel Execution of Rules in Production System Programs. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing. IEEE, </booktitle> <year> 1985. </year>
Reference-contexts: This results in added savings by reducing the amount of "overhead" in synchronizing the processors to collectively operate in the interpreter's rule selection phase. One of the earliest approaches of multiple rule firing in parallel was reported by <ref> [6, 7] </ref>, where these concepts are discussed more fully, and was shown to produce performance gains in one large program studied. This performance gain, however, required rewriting the rule set to remove unnecessary sequentialities. <p> This performance gain, however, required rewriting the rule set to remove unnecessary sequentialities. This task can be partially accomplished by statically analyzing the rule base, as reported in <ref> [7, 11, 10] </ref>.
Reference: [8] <author> Miranker, D. P. </author> <title> Treat: A New and Efficient Match Algorithm for AI Production Systems. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <month> October, </month> <year> 1986. </year>
Reference-contexts: Indeed, we have reported a number of parallel algorithms for the high speed execution of rule-based systems, several having been implemented on the DADO2 parallel computer and reported in various articles [20, 18, 21]. Many others have reported similar approaches and results including shared-memory parallel systems <ref> [3, 5, 8, 12] </ref>. Considerable work has already been done in an effort to determine the available parallelism in rule-based programs, and of the speedup to be expected from their execution on parallel machines. <p> the entire set of programs have not been conducted since most of these programs are not available for study by a wide community.) However, we were able to acquire some of these programs and demonstrated that indeed significant performance improvements are possible by using a different match algorithm (Miranker's TREAT <ref> [8] </ref>, for example) and modifying the programs to remove sequentialities (see [14]). In fact, what our studies indicate is the success of language designers in removing the parallelism from the problem in order to allow the efficient execution of the resulting encoding on a sequential machine.
Reference: [9] <author> Miranker, D. P. and B. J. Lafaso. </author> <title> The Organization and Performance of a TREAT Based Production System Compiler. </title> <year> 1990. </year>
Reference-contexts: The goal is simply to make rule-based systems fast and efficient, obviating the need for reimplementation in fast and efficient serial, imperative languages. Others have been investigating means of speeding up rule-based systems in serial environments by improved matching algorithms and compilation techniques (see <ref> [9] </ref>). The primary advantage of these approaches is to maintain applications in a high-level rule formalism to help ameliorate some of the problems in software specification, coding, maintenance and modification, while enjoying the benefits of fast performance. <p> Secondly, OPS5 has been the subject of considerable study in the research community and provides a well-known baseline language for comparative work. Lastly, an OPS5 compiler has become available that translates what is typically a less efficient LISP-based OPS5 program into a faster C-based implementation. The OPS5c compiler <ref> [9] </ref> also provides an alternative match algorithm called TREAT that has been shown by Miranker to be faster than the "standard" RETE match algorithm. As noted above, an alternative solution method, simulated annealing, was also applied to the problem and is separately reported in [16].
Reference: [10] <author> D. Miranker, C. Kuo, and J.C. Browne. </author> <title> Parallelizing Transformations for a Concurrent Rule Execution Language. </title> <type> Technical Report TR-89-30, </type> <institution> Department of Computer Science, University of Texas at Austin, </institution> <year> 1989. </year>
Reference-contexts: This performance gain, however, required rewriting the rule set to remove unnecessary sequentialities. This task can be partially accomplished by statically analyzing the rule base, as reported in <ref> [7, 11, 10] </ref>.
Reference: [11] <author> Moldovan, D. RUBIC: </author> <title> A Multiprocessor for Rule-Based Systems. </title> <journal> IEEE Transactions on Systems, Man and Cybernetics , 1989. </journal>
Reference-contexts: This performance gain, however, required rewriting the rule set to remove unnecessary sequentialities. This task can be partially accomplished by statically analyzing the rule base, as reported in <ref> [7, 11, 10] </ref>.
Reference: [12] <author> Oflazer, K. </author> <title> Partitioning in Parallel Processing of Production Systems. </title> <booktitle> In Proceedings of the IEEE International Conference on Parallel Processing, </booktitle> <pages> pages 92-99. </pages> <publisher> IEEE, </publisher> <year> 1984. </year>
Reference-contexts: Indeed, we have reported a number of parallel algorithms for the high speed execution of rule-based systems, several having been implemented on the DADO2 parallel computer and reported in various articles [20, 18, 21]. Many others have reported similar approaches and results including shared-memory parallel systems <ref> [3, 5, 8, 12] </ref>. Considerable work has already been done in an effort to determine the available parallelism in rule-based programs, and of the speedup to be expected from their execution on parallel machines.
Reference: [13] <author> Pasik, A. </author> <title> Improving Production System Performance on Parallel Architectures by Creating Constrained Copies of Culprit Rules. </title> <type> Technical Report CUCS-313-87, </type> <institution> Department of Computer Science, Columbia University, </institution> <year> 1987. </year> <month> 34 </month>
Reference-contexts: The techniques we described in section 3.4 to reduce the matching time of ALEXSYS' fill rules are related to a "data reduction" technique we reported several years ago, called "copy and constrain". The essence of the approach, detailed in <ref> [19, 13] </ref>, is to create multiple copies of the same rule, but each version constrained to match a smaller set of working memory elements. <p> To implement this strategy, each copied and constrained version of a fill rule is simply concurrently matched under the full distribution strategy. Other programs that we have studied under the copy and constrain paradigm have been shown to increase in performance dramatically. The reader is encouraged to review <ref> [13] </ref> where a number of performance studies were conducted that demonstrate the principles definitively. We expect ALEXSYS will similarly demonstrate dramatic performance improvements. 4.2.3. Multiple Rule Firing The prior parallelization techniques concentrate on improving the time to match rules in a rule-based program.
Reference: [14] <editor> Pasik, </editor> <publisher> A. </publisher>
Reference-contexts: One example of this is the "copy and constrain" technique (a data reduction technique) that has been demonstrated to elicit much more parallelism from a rule set than was previously believed possible (see <ref> [19, 14] </ref>). We suspect that several well-known reported studies (see [5], for example) produced disappointing results in parallelizing rule sets solely because of unnecessary sequentialities encoded in those rule sets. These studies have unfortunately concentrated on a very few sample OPS5 programs executed under the RETE match algorithm. <p> of these programs are not available for study by a wide community.) However, we were able to acquire some of these programs and demonstrated that indeed significant performance improvements are possible by using a different match algorithm (Miranker's TREAT [8], for example) and modifying the programs to remove sequentialities (see <ref> [14] </ref>). In fact, what our studies indicate is the success of language designers in removing the parallelism from the problem in order to allow the efficient execution of the resulting encoding on a sequential machine.
References-found: 14

