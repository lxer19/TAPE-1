URL: http://www.win.tue.nl/cs/pa/rikvdw/papers/Leupers97.ps.gz
Refering-URL: http://www.win.tue.nl/cs/pa/rikvdw/bibl.html
Root-URL: http://www.win.tue.nl
Title: Time-Constrained Code Compaction for DSPs  
Author: Rainer Leupers, Peter Marwedel 
Keyword: Retargetable compilation, embedded DSPs, code compaction  
Date: 1, 1997 1  
Note: c IEEE TRANSACTIONS ON VLSI SYSTEMS, VOL. 5, NO.  
Abstract: This paper addresses instruction-level parallelism in code generation for DSPs. In presence of potential parallelism, the task of code generation includes code compaction, which parallelizes primitive processor operations under given dependency and resource constraints. Furthermore, DSP algorithms in most cases are required to guarantee real-time response. Since the exact execution speed of a DSP program is only known after compaction, real-time constraints should be taken into account during the compaction phase. While previous DSP code generators rely on rigid heuristics for compaction, we propose a novel approach to exact local code compaction based on an Integer Programming model, which handles time constraints. Due to a general problem formulation, the IP model also captures encoding restrictions and handles instructions having alternative encodings and side effects, and therefore applies to a large class of instruction formats. Capabilities and limitations of our approach are discussed for different DSPs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Paulin, M. Cornero, C. Liem, et al., </author> <title> Trends in Embedded Systems Technology, </title> <editor> in: M.G. Sami, G. De Micheli (eds.): Hardware/Software Codesign, </editor> <publisher> Kluwer Academic Publishers, </publisher> <year> 1996. </year>
Reference-contexts: N-variables (double-indexed): For the set N OP = fN OP 1 ; : : : ; N OP r g of no-operations, the following N-variables (NOP variables) are used: fn s;t j s 2 f1; : : : ; rg ^ t 2 <ref> [1; T max ] </ref>g The interpretation of N-variables is n s;t = 1 :, Control step number t contains NOP for destination register X s . B. <p> Vertical code for complex multiply program address assignment is MEM [0] $ ci; MEM <ref> [1] </ref> $ br; MEM [2] $ ai; After insertion of AGU operations, the vertical code consists of 25 RTs, as shown in figure 3. The TMS320C25 has eight address registers, which in turn are addressed by address register pointer ARP. In this case, only address register AR [0] is used.
Reference: [2] <author> V. Zivojnovic, J.M. Velarde, C. Schlager, </author> <title> DSPStone A DSP-oriented Benchmarking Methodology, </title> <type> Technical Report, </type> <institution> Dept. of Electrical Engineering, Institute for Integrated Systems for Signal Processing, University of Aachen, Germany, </institution> <year> 1994. </year>
Reference-contexts: 1. Effective global compaction techniques need to employ local techniques as subroutines. However, as indicated by experimental surveys <ref> [2] </ref>, even local compaction is not a well-solved problem for DSPs. Therefore, it seems reasonable to first study local techniques in more detail. 2. <p> The TMS320C25 shows a very restrictive type of instruction-level parallelism, making compaction a non-trivial task even for small programs. We demonstrate exploitation of potential parallelism for the complex multiply program taken from the DSPStone benchmark suite <ref> [2] </ref>, which computes the product of two complex numbers and consists of two lines of code: cr = ar * br - ai * bi ; The vertical code generated by code selection, register allocation, and scheduling is shown in figure 2. <p> Vertical code for complex multiply program address assignment is MEM [0] $ ci; MEM [1] $ br; MEM <ref> [2] </ref> $ ai; After insertion of AGU operations, the vertical code consists of 25 RTs, as shown in figure 3. The TMS320C25 has eight address registers, which in turn are addressed by address register pointer ARP. In this case, only address register AR [0] is used. <p> For tight time constraints, IP-based compaction produces extremely compact code within acceptable amounts of computation time: Figure 4 shows the parallel schedule constructed for T max = 16. Both compilation by the TMS320C25-specific C compiler and manual assembly programming did not yield higher code quality in the DSPStone project <ref> [2] </ref>. B.
Reference: [3] <author> P. Marwedel, G. Goossens (eds.), </author> <title> Code Generation for Embedded Processors, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference: [4] <author> L. Nowak, P. Marwedel: </author> <title> Verification of Hardware Descriptions by Retargetable Code Generation, </title> <booktitle> 26th Design Automation Conference (DAC), </booktitle> <year> 1989, </year> <pages> pp. 441-447. </pages>
Reference: [5] <author> P. Marwedel, </author> <title> Tree-based Mapping of Algorithms to Predefined Structures, </title> <booktitle> Int. Conf. on Computer-Aided Design (ICCAD), </booktitle> <year> 1993, </year> <pages> pp. 586-993. </pages>
Reference-contexts: The special demands on code compaction techniques for DSPs are discussed in the following. A. Conflict representation In presence of datapath resource and encoding conflicts, it is desirable to have a uniform conflict representation. As already observed for earlier MIMOLA-based compilers <ref> [5] </ref>, checking for inter-RT conflicts in case of single-cycle RTs can be performed in a uniform way by checking for conflicts in the partial instructions associated with RTs. <p> In contrast to more rigid handling of side effects in previous work <ref> [5] </ref>, we permit to tolerate side effects, i.e., NOPs for registers are activated only if two data-dependent RTs are not scheduled in consecutive control steps. c fl IEEE TRANSACTIONS ON VLSI SYSTEMS, VOL. 5, NO. 1, 1997 8 Conversely, we enforce to schedule these RTs consecutively, if no NOP for the
Reference: [6] <author> Mentor Graphics Corporation, </author> <title> DSP Architect DFL User's and Reference Manual, </title> <booktitle> V 8.2 6, </booktitle> <year> 1993. </year>
Reference: [7] <author> A.V. Aho, R. Sethi, J.D. Ullman, </author> <title> Compilers - Priciples, Techniques, and Tools, </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference: [8] <author> S. Bashford, U. Bieker, et al., </author> <title> The MIMOLA Language V 4.1, </title> <type> Technical Report, </type> <institution> University of Dortmund, Dept. of Computer Science, </institution> <month> September </month> <year> 1994. </year>
Reference: [9] <author> R. Leupers, P. Marwedel: </author> <title> Instruction Set Extraction from Programmable Structures, </title> <booktitle> European Design Automation Conference (EURO-DAC), </booktitle> <year> 1994, </year> <pages> pp. 156-161. </pages>
Reference: [10] <author> R. Leupers, P. Marwedel, </author> <title> A BDD-based Frontend for Retar-getable Compilers, </title> <booktitle> European Design & Test Conference (ED & TC), </booktitle> <year> 1995, </year> <pages> pp. 239-243. </pages>
Reference: [11] <editor> D. Lanneer, J. Van Praet, et al., </editor> <title> CHESS: Retargetable Code Generation for Embedded DSP Processors, </title> <note> chapter 5 in [3]. </note>
Reference-contexts: The range of possible instruction formats that can be handled is however not reported. For the CodeSyn compiler [12], only compaction for horizontal machines has been described. The CHESS compiler <ref> [11] </ref> uses a list scheduling algorithm which takes into account encoding conflicts, alternative versions, and vertical side effects. Horizontal side effects and bus conflicts are a priori excluded due to limitations of the processor modelling language.
Reference: [12] <author> P. Paulin, C. Liem, et al., FlexWare: </author> <title> A Flexible Firmware Development Environment for Embedded Systems, </title> <note> chapter 4 in [3]. </note>
Reference-contexts: Wess' compiler [15] uses the critical path algorithm, which achieves code size reductions between 30 % and 50 % compared to vertical code for an ADSP210x DSP. The range of possible instruction formats that can be handled is however not reported. For the CodeSyn compiler <ref> [12] </ref>, only compaction for horizontal machines has been described. The CHESS compiler [11] uses a list scheduling algorithm which takes into account encoding conflicts, alternative versions, and vertical side effects. Horizontal side effects and bus conflicts are a priori excluded due to limitations of the processor modelling language.
Reference: [13] <author> R.E. Bryant, </author> <title> Symbolic Manipulation of Boolean Functions Using a Graphical Representation, </title> <booktitle> 22nd Design Automation Conference (DAC), </booktitle> <year> 1985, </year> <pages> pp. 688-694. </pages>
Reference: [14] <author> C.W. Fraser, D.R. Hanson, T.A. Proebsting, </author> <title> Engineering a Simple, Efficient Code Generator Generator, </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> vol. 1, no. 3, </volume> <year> 1992, </year> <pages> pp. 213-226. </pages>
Reference-contexts: Experimental results are given for a sum-of-products computation consisting of 45 RTs, including AGU operations, with a critical path length of 14. The ASIP executes up to 4 RTs per machine cycle, so that the actual lower bound meets the theoretical limit. For T max 2 <ref> [14; 17] </ref>, schedules are computed very fast. Beyond T max = 17, run-times are much higher and also less predictable than in the previous experiments.
Reference: [15] <author> B. Wess, </author> <title> Automatic Instruction Code Generation based on Trellis Diagrams, </title> <booktitle> IEEE Int. Symp. on Circuits and Systems (ISCAS), </booktitle> <year> 1992, </year> <pages> pp. 645-648. </pages>
Reference-contexts: Approaches to DSP code compaction Heuristic compaction algorithms have been adopted for several recent DSP code generators. Wess' compiler <ref> [15] </ref> uses the critical path algorithm, which achieves code size reductions between 30 % and 50 % compared to vertical code for an ADSP210x DSP. The range of possible instruction formats that can be handled is however not reported. <p> The critical path length L c imposed by inter-RT dependencies is 15. Table I shows experimental data (CPU seconds 1 , number of V- and N-variables) for IP-based compaction of the complex multiply code for T max values in <ref> [15; 21] </ref>. For the theoretical lower bound T max = 15, no solution exists, while for T max = 16 (the actual lower bound) a schedule is constructed in less that 1 CPU second.
Reference: [16] <author> G. Araujo, S. Malik, </author> <title> Optimal Code Generation for Embedded Memory Non-Homogeneous Register Architectures, </title> <booktitle> 8th Int. Symp. on System Synthesis (ISSS), </booktitle> <year> 1995, </year> <pages> pp. 36-41. </pages>
Reference: [17] <author> H. Emmelmann, </author> <title> Code Selection by Regular Controlled Term Rewriting, </title> <editor> in: R. Giegerich, S. Graham, </editor> <title> Code Generation: Concepts, Tools, Techniques, </title> <publisher> Springer, </publisher> <year> 1992, </year> <pages> pp. </pages> <month> 3-29. </month> <journal> c fl IEEE TRANSACTIONS ON VLSI SYSTEMS, </journal> <volume> VOL. 5, NO. 1, </volume> <year> 1997 </year> <month> 12 </month>
Reference-contexts: Experimental results are given for a sum-of-products computation consisting of 45 RTs, including AGU operations, with a critical path length of 14. The ASIP executes up to 4 RTs per machine cycle, so that the actual lower bound meets the theoretical limit. For T max 2 <ref> [14; 17] </ref>, schedules are computed very fast. Beyond T max = 17, run-times are much higher and also less predictable than in the previous experiments.
Reference: [18] <author> E. Pelegri-Llopart, S. Graham, </author> <title> Optimal Code Generation for Expression Trees, </title> <booktitle> 15th Ann. ACM Symp. on Priciples of Programming Languages, </booktitle> <year> 1988, </year> <pages> pp. 294-308. </pages>
Reference: [19] <author> S. Liao, S. Devadas, K. Keutzer, et al., </author> <title> Storage Assignment to Decrease Code Size, </title> <booktitle> ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), </booktitle> <year> 1995. </year>
Reference: [20] <author> R. Leupers, P. Marwedel, </author> <title> Algorithms for Address Assignment in DSP Code Generation, </title> <booktitle> Int. Conf. on Computer-Aided Design (ICCAD), </booktitle> <year> 1996. </year>
Reference-contexts: Based on the variables access sequence in the basic block, a permutation of variables to memory cells is computed, which maximizes AGU utilization in form of auto-increment/decrement operation of address registers <ref> [20] </ref>.
Reference: [21] <author> J.A. Fisher, </author> <title> Trace Scheduling: A Technique for Global Microcode Compaction, </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. 30, no. 7, </volume> <year> 1981, </year> <pages> pp. 478-490. </pages>
Reference-contexts: 1. Effective global compaction techniques need to employ local techniques as subroutines. However, as indicated by experimental surveys [2], even local compaction is not a well-solved problem for DSPs. Therefore, it seems reasonable to first study local techniques in more detail. 2. Popular global techniques, such as Trace Scheduling <ref> [21] </ref>, Percolation Scheduling [22], and Mutation Scheduling [23], have been shown to be effective mainly for highly parallel and regular architectures, in particular VLIWs. Contemporary DSPs, however, are not highly parallel and tend to have an irregular architec ture. 3. <p> The critical path length L c imposed by inter-RT dependencies is 15. Table I shows experimental data (CPU seconds 1 , number of V- and N-variables) for IP-based compaction of the complex multiply code for T max values in <ref> [15; 21] </ref>. For the theoretical lower bound T max = 15, no solution exists, while for T max = 16 (the actual lower bound) a schedule is constructed in less that 1 CPU second.
Reference: [22] <author> A. Aiken, A. Nicolau, </author> <title> A Development Environment for Horizontal Microcode, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> no. 14, </volume> <year> 1988, </year> <pages> pp. 584-594. </pages>
Reference-contexts: However, as indicated by experimental surveys [2], even local compaction is not a well-solved problem for DSPs. Therefore, it seems reasonable to first study local techniques in more detail. 2. Popular global techniques, such as Trace Scheduling [21], Percolation Scheduling <ref> [22] </ref>, and Mutation Scheduling [23], have been shown to be effective mainly for highly parallel and regular architectures, in particular VLIWs. Contemporary DSPs, however, are not highly parallel and tend to have an irregular architec ture. 3.
Reference: [23] <author> S. Novack, A. Nicolau, N. Dutt, </author> <title> A Unified Code Generation Approach using Mutation Scheduling, </title> <note> chapter 12 in [3]. </note>
Reference-contexts: However, as indicated by experimental surveys [2], even local compaction is not a well-solved problem for DSPs. Therefore, it seems reasonable to first study local techniques in more detail. 2. Popular global techniques, such as Trace Scheduling [21], Percolation Scheduling [22], and Mutation Scheduling <ref> [23] </ref>, have been shown to be effective mainly for highly parallel and regular architectures, in particular VLIWs. Contemporary DSPs, however, are not highly parallel and tend to have an irregular architec ture. 3.
Reference: [24] <author> M.R. Gary, D.S. Johnson, </author> <title> Computers and Intractability A Guide to the Theory of NP-Completeness, </title> <address> Freemann, </address> <year> 1979. </year>
Reference-contexts: Incompatibilities impose the additional constraint 8r i ; r j 2 V : r i 6 r j ) CS (r i ) 6= CS (r j ) on code compaction, in which case compaction becomes a resource-constrained scheduling problem, known to be NP-hard <ref> [24] </ref>. Heuristic code compaction techniques became important with appearance of VLIW machines in the early eighties. Popular heuristics include first-come first-served, critical path, and list scheduling. These three O (n 2 ) algorithms have been empirically evaluated by Mallett et al. [25].
Reference: [25] <editor> S. Mallett, D. Landskov, B.D. Shriver, P.W. Mallett, </editor> <title> Some Experiments in Local Microcode Compaction for Horizontal Machines, </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. 30, no. 7, </volume> <year> 1981, </year> <pages> pp. 460-477. </pages>
Reference-contexts: Heuristic code compaction techniques became important with appearance of VLIW machines in the early eighties. Popular heuristics include first-come first-served, critical path, and list scheduling. These three O (n 2 ) algorithms have been empirically evaluated by Mallett et al. <ref> [25] </ref>. It was concluded, that each algorithm is capable of producing close-to-optimum results in most cases, while differing in speed, simplicity, and quality in relation to the basic block length n. <p> Three RTs r i ; r j ; r k may have pairwise compatible versions, but scheduling r i ; r j ; r k in parallel may be impossible. Therefore, careful selection of encoding versions during compaction is of outstanding importance for DSPs. In <ref> [25] </ref>, version shu*ing was proposed as a technique for version selection, which can be integrated into heuristic algorithms: Whenever some RT r i is to be assigned to a control step t, the cross product of all versions for r i and all versions of RTs already assigned to t are
Reference: [26] <institution> Texas Instruments, </institution> <note> TMS320C2x User's Guide, rev. </note> <institution> B, Texas Instruments, </institution> <year> 1990. </year>
Reference-contexts: Alternative encodings may arise from alternative routes for moving a value through the datapath. In other cases, alternatives are due to instruction format: The TMS320C2x DSP <ref> [26] </ref>, for instance, permits execution of address register updates in parallel to different arithmetic or data move instructions. Each address register update is represented by a different opcode, resulting in a number of alternative encodings to be considered.
Reference: [27] <author> Motorola Inc., </author> <title> DSP 56156 Digital Signal Processor User's Manual, </title> <institution> Motorola, </institution> <year> 1992. </year>
Reference-contexts: A special aspect of vertical side effects are multiply-accumulates (MACs) on DSPs. A MAC executes two operations P = Y * Z and A = A + P within a single cycle. On some DSPs, for instance Motorola DSP56xxx <ref> [27] </ref>, MACs are data-stationary, i.e. multiplication and addition are executed in chained mode. In contrast, the TMS320C2x incorporates time-stationary MACs, in which case value P is buffered in a register.
Reference: [28] <author> A. Sudarsanam, S. Malik, </author> <title> Memory Bank and Register Allocation in Software Synthesis for ASIPs, </title> <booktitle> Int. Conf. on Computer-Aided Design (ICCAD), </booktitle> <year> 1995, </year> <pages> pp. 388-392. </pages>
Reference-contexts: The CHESS compiler [11] uses a list scheduling algorithm which takes into account encoding conflicts, alternative versions, and vertical side effects. Horizontal side effects and bus conflicts are a priori excluded due to limitations of the processor modelling language. In <ref> [28] </ref>, a Motorola 56xxx specific compaction method is described, however excluding out-of-order execution, i.e. the schedule satisfies i &lt; j ) CS (r i ) CS (r j ) for any two RTs r i ; r j , independent of dependency relations. <p> Note that in case of the M56000 a higher exploitation of parallelism can be achieved by late assignment of variables to different memory banks during compaction <ref> [28] </ref>, which is not yet included in our approach. C.
Reference: [29] <author> T. Wilson, G. Grewal, B. Halley, D. Banerji, </author> <title> An Integrated Approach to Retargetable Code Generation, </title> <booktitle> 7th Int. Symp. on High-Level Synthesis (HLSS), </booktitle> <year> 1994, </year> <pages> pp. 70-75. </pages>
Reference-contexts: An exact (non-heuristic) compaction method, which does take into account time constraints, has been reported by Wilson et al. <ref> [29] </ref>. The proposed Integer Programming (IP) approach integrates code selection, register allocation, and compaction. The IP model comprises alternative versions and vertical side effects, but no bus conflicts and horizontal side effects. <p> Using an appropriate IP formulation thus often permits to optimally solve NP-hard problems of practical relevance. Our approach to TCC is therefore largely based on IP. In contrast to Wilson's approach <ref> [29] </ref>, the IP instances are not created manually, but are automatically derived from the given compaction problem and target processor model and an externally specified time constraint. Furthermore, it focusses only on the problem of code compaction, which extends the size of basic blocks which can be handled in practice.
Reference: [30] <author> A. Timmer, M. Strik, J. van Meerbergen, J. Jess, </author> <title> Conflict Modelling and Instruction Scheduling in Code Generation for In-House DSP Cores, </title> <booktitle> 32nd Design Automation Conference (DAC), </booktitle> <year> 1995, </year> <pages> pp. 593-598. </pages>
Reference-contexts: Furthermore, the IP model at least in its entirety turned out to be too complex for realistic target processors, and requires a large amount of manual description effort. The graph-based compaction technique presented by Timmer <ref> [30] </ref> achieves comparatively low runtimes for exact code compaction under time constraints by pruning the search space in advance. The pruning procedure is based on the assumption, that inter-RT conflicts are fixed before compaction. <p> As indicated by previous work <ref> [30] </ref>, significant runtime reductions can be expected for more restricted classes of instruction formats. VII. Conclusions F UTURE system-level CAD environments will need to incorporate code generation tools for embedded processors, including DSPs, in order to support hardware/software codesign of VLSI systems.
Reference: [31] <author> C. Gebotys, M. Elmasry, </author> <title> Optimal VLSI Architectural Synthesis, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: In the next section, we present a solution technique, which permits to compact basic blocks of relevant size in a retargetable manner. V. Integer Programming formulation R ECENTLY , several approaches have been published, which map NP-complete VLSI-design related problems into an Integer (Linear) Programming model (e.g. <ref> [31] </ref>, [32]), in order to study the potential gains of optimal solution methods compared to heuristics.
Reference: [32] <author> B. Landwehr, P. Marwedel, R. Domer, OSCAR: </author> <title> Optimum Simultaneous Scheduling, Allocation, and Resource Binding based on Integer Programming, </title> <booktitle> European Design Automation Conference (EURO-DAC), </booktitle> <year> 1994. </year>
Reference-contexts: In the next section, we present a solution technique, which permits to compact basic blocks of relevant size in a retargetable manner. V. Integer Programming formulation R ECENTLY , several approaches have been published, which map NP-complete VLSI-design related problems into an Integer (Linear) Programming model (e.g. [31], <ref> [32] </ref>), in order to study the potential gains of optimal solution methods compared to heuristics.

References-found: 32

