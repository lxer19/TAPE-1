URL: http://ptolemy.eecs.berkeley.edu/~girault/Publications/Pdcs94/main.ps
Refering-URL: http://ptolemy.eecs.berkeley.edu/~girault/Publications/Pdcs94/
Root-URL: 
Email: Paul.Caspi@imag.fr Alain.Girault@imag.fr Pilaud@verilog.fr  
Phone: (33) 76.90.96.33 (33) 76.60.57.55 (33) 76.90.96.17  
Title: Distributing reactive systems  
Author: Paul Caspi Alain Girault Daniel Pilaud VERIMAG MERLIN GERIN VERILOG Miniparc ZIRST PLI/SES Miniparc ZIRST 
Address: Lavoisier usine M3 rue Lavoisier 38330 Montbonnot 38050 Grenoble cedex 09 38330 Montbonnot FRANCE FRANCE FRANCE  
Affiliation: rue  
Abstract: This paper addresses the problem of distributing reactive systems. We first show that the use of synchronous languages allows a natural parallel description of such systems, regardless of any distribution problems. Then, a desired distribution can be easily specified, and achieved with the algorithm presented here. This distribution technique provides distributed programs with the same safety, test and debug facilities as ordinary sequential programs. Finally, the implementation of such distributed programs only requires a very simple communication protocol (first in first out queues), thereby reducing the need for large distributed real-time executives. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.-L. Bergerand and E. Pilaud. </author> <title> SAGA : A software development environment for dependability in automatic control. In IFAC-SAFECOMP'88. </title> <publisher> Pergamon Press, </publisher> <year> 1988. </year>
Reference-contexts: These transitions, whose execution time is statically computable, correspond to the system reactions to an input. The main languages based upon the synchrony hypothesis are ESTEREL [3], LUSTRE [11], SIGNAL [14], the STATECHARTS [12], SML [4], SAGA <ref> [1] </ref> and ARGOS [16]. Research on synchronous languages compilation has led to the OC encoding format for automata (OC standing for object code [17]). OC is the output format of the ESTEREL, LUSTRE and ARGOS compilers.
Reference: [2] <author> G. Berry. </author> <title> Real time programming: Special purpose or general purpose languages. </title> <booktitle> 89 </booktitle> <pages> 11-17, </pages> <year> 1989. </year>
Reference-contexts: Classical real-time languages (ADA, OCCAM: : : ) use various forms of rendez-vous. Rendez-vous are often said to be synchronous; message passing is indeed synchronous, but the establishment of the rendez-vous is asynchronous <ref> [2] </ref>. Moreover, rendez-vous lead to useless waiting times and reduce parallelism and efficiency [7]. That is why we didn't choose rendez-vous. On the other hand, queues allow for putting back sendings and moving forward receivings, therefore minimizing the waiting time induced by the communication network.
Reference: [3] <author> G. Berry and G. Gonthier. </author> <title> The ESTEREL synchronous programming language, design, semantics, </title> <booktitle> implementation. Science Of Computer Programming, </booktitle> <volume> 19(2) </volume> <pages> 87-152, </pages> <year> 1992. </year>
Reference-contexts: These transitions, whose execution time is statically computable, correspond to the system reactions to an input. The main languages based upon the synchrony hypothesis are ESTEREL <ref> [3] </ref>, LUSTRE [11], SIGNAL [14], the STATECHARTS [12], SML [4], SAGA [1] and ARGOS [16]. Research on synchronous languages compilation has led to the OC encoding format for automata (OC standing for object code [17]). OC is the output format of the ESTEREL, LUSTRE and ARGOS compilers.
Reference: [4] <author> M.C. Browne and E.M. Clarke. Sml: </author> <title> a high-level language for the design and verification of finite state machines. In International Working Conference from HDL Descriptions to Guaranteed Correct Circuit Designs, </title> <address> Grenoble, France, </address> <month> September </month> <year> 1986. </year> <pages> IFIP. </pages>
Reference-contexts: These transitions, whose execution time is statically computable, correspond to the system reactions to an input. The main languages based upon the synchrony hypothesis are ESTEREL [3], LUSTRE [11], SIGNAL [14], the STATECHARTS [12], SML <ref> [4] </ref>, SAGA [1] and ARGOS [16]. Research on synchronous languages compilation has led to the OC encoding format for automata (OC standing for object code [17]). OC is the output format of the ESTEREL, LUSTRE and ARGOS compilers.
Reference: [5] <author> D. Callahan and K. Kennedy. </author> <title> Compiling programs for distributed memory multiprocessors. </title> <journal> Journal of Supercomputing, </journal> <volume> 2(2) </volume> <pages> 151-169, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: This is 2 the abstract graph method used for SIGNAL pro-grams [15]. Compiling the source program into a single object program, and then distributing this centralized program towards as many programs as locations, so that each location only has to perform its own computations <ref> [5] </ref>. Owning to the common format OC, this method can be applied to any synchronous language.
Reference: [6] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> TOPLAS, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: Compiling the program into a single transition system may be useful, in any case, for debugging and verification purposes <ref> [18, 6] </ref>. Synchronous parallelism is not well-behaved for separate compiling matters. Thus, if communicating deterministic transition systems are wanted, their direct synthesis may not be easier than the proposed method.
Reference: [7] <author> G.C. Fox. </author> <title> Domain decomposition in distributed and shared memory environments. </title> <type> Technical Report C3P-392, </type> <institution> California Institute of Technology, </institution> <year> 1987. </year>
Reference-contexts: Classical real-time languages (ADA, OCCAM: : : ) use various forms of rendez-vous. Rendez-vous are often said to be synchronous; message passing is indeed synchronous, but the establishment of the rendez-vous is asynchronous [2]. Moreover, rendez-vous lead to useless waiting times and reduce parallelism and efficiency <ref> [7] </ref>. That is why we didn't choose rendez-vous. On the other hand, queues allow for putting back sendings and moving forward receivings, therefore minimizing the waiting time induced by the communication network. We choose to have two queues for each pair of locations, one in each direction.
Reference: [8] <author> N. Ghezal, S. Matiatos, P. Piovesan, Y. Sorel, and M. Sorine. </author> <title> Un environnement de programmation pour multiprocesseur de traitement du signal. </title> <type> Technical Report 1236, </type> <institution> INRIA, </institution> <year> 1990. </year>
Reference-contexts: Synchronous parallelism is not well-behaved for separate compiling matters. Thus, if communicating deterministic transition systems are wanted, their direct synthesis may not be easier than the proposed method. In contrast, separate compiling towards nonsequential programs is always feasible: this is the solution presented in <ref> [8] </ref>. 1.4 Distribution methods There exist a priori three ways to achieve the distribution motivated in the previous section: Compiling separately each piece of source program (i.e. independently from its context) and making them communicate. This could be the ideal solution because it seems to be the easiest one. <p> However, [19] proposes some criteria for determining whether or not a piece of LUSTRE program is separately compilable. Also, ESTEREL gives criteria for compiling separately modules (cascade mode). On the other hand, separate compiling into non sequential programs is always possible <ref> [8] </ref>. Globally compiling a source program into one sequential program for each location, so that each program may communicate with the others. This is 2 the abstract graph method used for SIGNAL pro-grams [15].
Reference: [9] <author> A. Girault. </author> <title> Sur la r epartition de programmes syn-chrones. </title> <type> Thesis, </type> <institution> INPG, Grenoble, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: A more precise comparison of the two strategies can be found in <ref> [9] </ref>. <p> For each location s, the algorithm consists in placing a full set Need s at each leaf of the DAG, and then propagating these sets backward to the root of the DAG in a way similar to the preceding ones. More details on this step can be found in <ref> [9] </ref>. <p> Up to now, all the processors obtained share the same control structure, which is the same as the initial program. A more complex algorithm based on observational equivalence and on the fly bisimulation can be found in <ref> [9] </ref>, which allows local minimization of each distributed process by suppressing branchings whose branches behave the same. Secondly, we have stated that an OC program needs an interface to react to the environment. Distributing the program implies that its interface must also be distributed. <p> Secondly, we have stated that an OC program needs an interface to react to the environment. Distributing the program implies that its interface must also be distributed. An interface distribution method can be found in <ref> [9] </ref>. Finally, distributed real-time executives are also expected to provide important fault-tolerance facilities, such as recovery data storage, error detection and masking, backward and forward recovery, and dynamic system reconfiguration.
Reference: [10] <author> N. Halbwachs. </author> <title> Synchronous programming of reactive systems. </title> <publisher> Kluwer Academic Pub., </publisher> <year> 1993. </year>
Reference-contexts: Reliability: This is perhaps their most important feature as these systems are often critical ones. Therefore these systems require rigorous design methods as well as formal verification. 1.2 The synchronous approach Classical approaches do not meet these requirements <ref> [10] </ref>. It is obvious for assembly programming, albeit the most widely used method. Other methods 1 mainly consist either in programming, with a classi-cal language, sequential tasks that communicate with each other through a real-time operating system, or in using a general purpose parallel language such as ADA or OCCAM.
Reference: [11] <author> N. Halbwachs, P. Caspi, P. Raymond, and D. Pi-laud. </author> <title> The synchronous data flow programming language LUSTRE. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9) </volume> <pages> 1305-1320, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: These transitions, whose execution time is statically computable, correspond to the system reactions to an input. The main languages based upon the synchrony hypothesis are ESTEREL [3], LUSTRE <ref> [11] </ref>, SIGNAL [14], the STATECHARTS [12], SML [4], SAGA [1] and ARGOS [16]. Research on synchronous languages compilation has led to the OC encoding format for automata (OC standing for object code [17]). OC is the output format of the ESTEREL, LUSTRE and ARGOS compilers.
Reference: [12] <author> D. Harel. Statecharts: </author> <title> a visual approach to complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8(3), </volume> <year> 1987. </year>
Reference-contexts: These transitions, whose execution time is statically computable, correspond to the system reactions to an input. The main languages based upon the synchrony hypothesis are ESTEREL [3], LUSTRE [11], SIGNAL [14], the STATECHARTS <ref> [12] </ref>, SML [4], SAGA [1] and ARGOS [16]. Research on synchronous languages compilation has led to the OC encoding format for automata (OC standing for object code [17]). OC is the output format of the ESTEREL, LUSTRE and ARGOS compilers.
Reference: [13] <author> D. Harel and A. Pnueli. </author> <title> On the development of reactive systems. In Logic and Models of Concurrent Systems, NATO Advanced Study Institute on Logics and Models for Verification and Specification of Concurrent Systems. </title> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: 1 Introduction 1.1 Reactive systems Reactive systems are computer systems that react continuously to their environment, at a speed determined by the latter <ref> [13] </ref>.
Reference: [14] <author> P. LeGuernic, T. Gautier, M. LeBorgne, and C. LeMaire. </author> <title> Programming real-time applications with SIGNAL. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9) </volume> <pages> 1321-1336, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: These transitions, whose execution time is statically computable, correspond to the system reactions to an input. The main languages based upon the synchrony hypothesis are ESTEREL [3], LUSTRE [11], SIGNAL <ref> [14] </ref>, the STATECHARTS [12], SML [4], SAGA [1] and ARGOS [16]. Research on synchronous languages compilation has led to the OC encoding format for automata (OC standing for object code [17]). OC is the output format of the ESTEREL, LUSTRE and ARGOS compilers.
Reference: [15] <author> O. Maffes. </author> <title> Ordonnancements de graphes de flots syn-chrones ; application a la mise en oeuvre de SIGNAL. </title> <type> Thesis, </type> <institution> Universit e Rennes 1, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: This could be the ideal solution because it seems to be the easiest one. Unfortunately it has been shown that, in general, compiling separately pieces of programs into sequential deterministic programs is incorrect <ref> [15] </ref>. However, [19] proposes some criteria for determining whether or not a piece of LUSTRE program is separately compilable. Also, ESTEREL gives criteria for compiling separately modules (cascade mode). On the other hand, separate compiling into non sequential programs is always possible [8]. <p> On the other hand, separate compiling into non sequential programs is always possible [8]. Globally compiling a source program into one sequential program for each location, so that each program may communicate with the others. This is 2 the abstract graph method used for SIGNAL pro-grams <ref> [15] </ref>. Compiling the source program into a single object program, and then distributing this centralized program towards as many programs as locations, so that each location only has to perform its own computations [5]. Owning to the common format OC, this method can be applied to any synchronous language.
Reference: [16] <author> F. Maraninchi. </author> <title> Operational and compositional semantics of synchronous automaton compositions. In CONCUR'92. </title> <publisher> LNCS 630, Springer Verlag, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: These transitions, whose execution time is statically computable, correspond to the system reactions to an input. The main languages based upon the synchrony hypothesis are ESTEREL [3], LUSTRE [11], SIGNAL [14], the STATECHARTS [12], SML [4], SAGA [1] and ARGOS <ref> [16] </ref>. Research on synchronous languages compilation has led to the OC encoding format for automata (OC standing for object code [17]). OC is the output format of the ESTEREL, LUSTRE and ARGOS compilers.
Reference: [17] <author> J.P. Paris and al. </author> <title> Les formats communs des langages synchrones. </title> <type> Technical Report 157, </type> <institution> INRIA, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: The main languages based upon the synchrony hypothesis are ESTEREL [3], LUSTRE [11], SIGNAL [14], the STATECHARTS [12], SML [4], SAGA [1] and ARGOS [16]. Research on synchronous languages compilation has led to the OC encoding format for automata (OC standing for object code <ref> [17] </ref>). OC is the output format of the ESTEREL, LUSTRE and ARGOS compilers. It was recently extended to handle SIGNAL and SAGA programs as well [17]. 1.3 Distribution problems Many reactive systems have to be distributed on several computing locations, for various reasons: performance increase, location of sensors and actuators, fault <p> Research on synchronous languages compilation has led to the OC encoding format for automata (OC standing for object code <ref> [17] </ref>). OC is the output format of the ESTEREL, LUSTRE and ARGOS compilers. It was recently extended to handle SIGNAL and SAGA programs as well [17]. 1.3 Distribution problems Many reactive systems have to be distributed on several computing locations, for various reasons: performance increase, location of sensors and actuators, fault tolerance. This is the case of the CO3N4 con trol system, developped at MERLIN GERIN for nuclear plants.
Reference: [18] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in CESAR. </title> <booktitle> In International Symposium on Programming, </booktitle> <volume> LNCS 137, </volume> <pages> pages 337-351. </pages> <publisher> Springer Verlag, </publisher> <month> April </month> <year> 1982. </year>
Reference-contexts: Compiling the program into a single transition system may be useful, in any case, for debugging and verification purposes <ref> [18, 6] </ref>. Synchronous parallelism is not well-behaved for separate compiling matters. Thus, if communicating deterministic transition systems are wanted, their direct synthesis may not be easier than the proposed method.
Reference: [19] <author> P. Raymond. </author> <title> Compilation s epar ee de programmes LUSTRE. </title> <type> Technical Report SPECTRE L5, </type> <institution> VERIMAG, Grenoble, </institution> <month> June </month> <year> 1988. </year> <month> 7 </month>
Reference-contexts: This could be the ideal solution because it seems to be the easiest one. Unfortunately it has been shown that, in general, compiling separately pieces of programs into sequential deterministic programs is incorrect [15]. However, <ref> [19] </ref> proposes some criteria for determining whether or not a piece of LUSTRE program is separately compilable. Also, ESTEREL gives criteria for compiling separately modules (cascade mode). On the other hand, separate compiling into non sequential programs is always possible [8].
References-found: 19

