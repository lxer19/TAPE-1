URL: http://www.cs.purdue.edu/homes/muckel/performance.ps
Refering-URL: http://www.cs.purdue.edu/people/muckel/
Root-URL: http://www.cs.purdue.edu
Email: fmuckel|russog@cs.purdue.edu  
Title: Draft: The Performance of a Distributed System Using Structural-Based Conformance Checking  
Author: Patrick A. Muckelbauer and Vincent F. Russo 
Address: West Lafayette, IN 47907  
Affiliation: Department of Computer Sciences Purdue University  
Abstract: This paper details the design and implementation of an object-oriented distributed system in which the interactions between clients and servers are implemented as method invocations on objects in separate components (autonomous collections of objects). While this approach has been adopted by a number of other efforts including OMG's CORBA, Microsoft's OLE-II, IBM's SOM/DSOM, and Sun's Spring System, our work differs in a substantial way: the structure of interfaces is used for conformance checking rather than interface names or hierarchies of names. This paper illustrates the design of our system and details the impact structural-based conformance has on the implementation and performance of a distributed object system.
Abstract-found: 1
Intro-found: 1
Reference: [A + 86] <author> Mike Accetta et al. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> In Proceedings of the USENIX Conference, </booktitle> <pages> pages 93-111, </pages> <year> 1986. </year>
Reference-contexts: Customizing the transport module to optimize communication costs has been used successfully to improve performance in many other systems including Mach <ref> [A + 86, BALL89] </ref> and Spring [MGH + 94]. 4.7 An Alternate Approach: Inheritance-Typed Systems 4.7.1 Conformance Algorithm With inheritance subtyping, types are named interfaces arranged in type hierarchies.
Reference: [AC90] <author> Roberto Amadio and Luca Cardelli. </author> <title> Subtyping Recursive Types. </title> <type> Technical Report 62, </type> <institution> DEC SRC, </institution> <year> 1990. </year>
Reference-contexts: check (e x :to; e y :to) else check (e y :to; e x :to) g initialize () return check (n ff ; n fi ) g The conformance rules are recursive and when applied to recursive types equate to testing whether the infinite expansions of the types structurally conform <ref> [AC90] </ref>. The recursive nature of the conformance rules is evident in the recursive calls to function check . <p> Except for the added cost of function initialize, the anticipated-case complexity of the boolean array implementation is order the anticipated-case complexity of the hash table implementation. In <ref> [AC90] </ref>, an O N 2 algorithm for checking structural subtyping is given. However, the set of types used in their analysis is not as rich as the set of Lingua Franca types. In particular, the only types supported are top, bottom, and unary functions. <p> Complete common subgraph elimination in type graphs in a single component is possible by canonicalizing the type graphs <ref> [AC90, AHU74b] </ref>. Canonicalization eliminates all remaining common subgraphs of the type graphs but only within a single component. 4.4.2 Caching Two client-side caches are used to avoid the computational and/or communication costs of the distributed conformance algorithm: a conformance result cache and a type information cache. <p> For example: recursive type LinkedList = record of value : Integer; next : pointer to LinkedList; end record; The conformance rules are recursive and when applied to recursive types equate to testing that the infinite expansions of the two types structurally conform <ref> [AC90] </ref>. This implies that an algorithm implementing the conformance rules may fail to terminate for recursive types. However, an algorithm for these conformance rules that terminates for all Lingua Franca types is described in Section 4.2. A discussion of a similar structural-based conformance algorithm can be found in [AC90]. 31 <p> structurally conform <ref> [AC90] </ref>. This implies that an algorithm implementing the conformance rules may fail to terminate for recursive types. However, an algorithm for these conformance rules that terminates for all Lingua Franca types is described in Section 4.2. A discussion of a similar structural-based conformance algorithm can be found in [AC90]. 31
Reference: [AHU74a] <author> Alfred Aho, John Hopcroft, and Jeffrey Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1974. </year>
Reference-contexts: recursive types. 6 4.2.1 Complexity Analysis The complexity of an algorithm (or a piece of the algorithm) will refer to the time needed to execute the algorithm (or that piece) as a function of the size of the input and will be given in big O notation as defined in <ref> [AHU74a] </ref>. For the conformance algorithm, the size of the input is the number of nodes and edges of the type graphs being compared. Let N x be the set of nodes and E x be the set of edges of the type graph rooted at a node n x .
Reference: [AHU74b] <author> Alfred Aho, John Hopcroft, and Jeffrey Ullman. </author> <title> The Design and Analysis of Computer Algorithms, </title> <booktitle> chapter 4, </booktitle> <pages> pages 157-162. </pages> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1974. </year>
Reference-contexts: Complete common subgraph elimination in type graphs in a single component is possible by canonicalizing the type graphs <ref> [AC90, AHU74b] </ref>. Canonicalization eliminates all remaining common subgraphs of the type graphs but only within a single component. 4.4.2 Caching Two client-side caches are used to avoid the computational and/or communication costs of the distributed conformance algorithm: a conformance result cache and a type information cache.
Reference: [BALL89] <author> Brian Bershad, Thomas Anderson, Edward Lazowska, and Henry Levy. </author> <title> Lightweight Remote Procedure call. </title> <type> Technical Report 89-04-02, </type> <institution> University of Washington, </institution> <year> 1989. </year>
Reference-contexts: Customizing the transport module to optimize communication costs has been used successfully to improve performance in many other systems including Mach <ref> [A + 86, BALL89] </ref> and Spring [MGH + 94]. 4.7 An Alternate Approach: Inheritance-Typed Systems 4.7.1 Conformance Algorithm With inheritance subtyping, types are named interfaces arranged in type hierarchies.
Reference: [Ben87] <author> John Bennett. </author> <title> The Design and Implementation of Distributed Smalltalk. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 318-330, </pages> <year> 1987. </year>
Reference-contexts: Runtime type errors are generated when clients access server values in an inconsistent manner. This form of checking is referred to as dynamic type checking [Set89]. For example, in Distributed Smalltalk <ref> [Ben87] </ref>, a dynamically typed-checked distributed object system, a client can invoke the method m on a remote object and if the method is not in the remote object's interface the exception "message not understood " is raised.
Reference: [Ber93] <author> Edward Berard. </author> <booktitle> Essays on Object-Oriented Software Engineering, </booktitle> <volume> volume 1. </volume> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Object-oriented programming increases program modularity and data abstraction by supporting encapsulation through narrow, rigidly defined, and strongly enforced interfaces to objects <ref> [Ber93] </ref>. An object consists of an encapsulated state and a set of operations, or methods, that modify or access the state. The interface of an object is defined by the collection of all its methods.
Reference: [BHJ + 87] <author> Andrew Black, Norman Hutchinson, Eric Jul, Henry Levy, and Larry Carter. </author> <title> Distribution and Abstract Types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 65-76, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Support for typed references has several software engineering advantages: they catch errors earlier (during narrowing), they guarantee a sense of correctness to the system by not allowing clients and servers to interact in an inconsistent manner, and they allow better performance to be achieved for remote accesses <ref> [CW85, BHJ + 87] </ref>.
Reference: [BHJL86] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object Structure in the Emerald System. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 78-86, </pages> <year> 1986. </year>
Reference-contexts: to decode the handle and is not included. 4.6 Optimizations of Remote Method Invocation 4.6.1 Method Dispatching The method name lookup by the server during method dispatching can be avoided by constructing a method map which maps methods in the proxy's interface to methods in the principal's interface by position <ref> [BHJL86] </ref>. The method map is used to identify the method to dispatch by position and avoids a method name lookup. The method map is calculated during narrowing by the conformance algorithm. <p> The C ++ support libraries have been integrated into several systems, such as UNIX applications and the Primavera kernel and applications. Appendix A: Structural-Based Conformance Rules The conformance rules define the structural subtype relationship between types and are based on the conformance rules in the Emerald <ref> [BHJL86] </ref> and Amber [Car85] programming languages. Briefly, the conformance rules are type equivalence for primitive types, recursive subtyping for optional and sequence types, recursive subtyping of field subsets for record and case types, and recursive 30 subtyping of method subsets for interfaces.
Reference: [BR95] <author> Gerald Baumgartner and Vincent Russo. </author> <title> Signatures: a Language Extension for Improving Type Abstractions and Subtype Polymorphism in C++. </title> <journal> Software Practice and Experience, </journal> <pages> pages 863-889, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: A C ++ translator for Lingua Franca has been built which maps Lingua Franca types into C ++ types. C ++ was chosen due to its availability and the previous work on integrating the signature concept into the language <ref> [GR91, BR95] </ref>. The support libraries for C ++ applications have been designed and built. The libraries provide runtime conformance checking and remote method invocation using a shared memory transport module (when possible) or a UDP-based transport module.
Reference: [Car85] <author> Luca Cardelli. </author> <title> Amber, </title> <booktitle> Combinators and Functional Programming Languages. In Proceedings of the 13th Summer School of the LITP, </booktitle> <address> Le Val D'Ajol, Vosges (France), </address> <year> 1985. </year>
Reference-contexts: The C ++ support libraries have been integrated into several systems, such as UNIX applications and the Primavera kernel and applications. Appendix A: Structural-Based Conformance Rules The conformance rules define the structural subtype relationship between types and are based on the conformance rules in the Emerald [BHJL86] and Amber <ref> [Car85] </ref> programming languages. Briefly, the conformance rules are type equivalence for primitive types, recursive subtyping for optional and sequence types, recursive subtyping of field subsets for record and case types, and recursive 30 subtyping of method subsets for interfaces.
Reference: [Coh91] <author> Norman Cohen. </author> <title> Type-Extension Type Tests Can Be Performed in Constant Time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <pages> pages 626-629, </pages> <year> 1991. </year>
Reference-contexts: If the names are not sorted, the set can be searched in linear time. If the names are sorted, the set can be searched in O (log N ) time. Assuming single inheritance, the names can be searched in constant time <ref> [Coh91] </ref>. The space requirement for the algorithm is O (1) while the space requirement for the type information is O (N ) for N s and O (1) for N c . For efficiency, the names can be represented as integers so they may be efficiently stored and compared.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction, and Polymorphism. </title> <journal> ACM Computing Surveys, </journal> <pages> pages 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Support for typed references has several software engineering advantages: they catch errors earlier (during narrowing), they guarantee a sense of correctness to the system by not allowing clients and servers to interact in an inconsistent manner, and they allow better performance to be achieved for remote accesses <ref> [CW85, BHJ + 87] </ref>. <p> Subtyping is a relationship on types defining when a type ff can be asserted to be at least a type fi and, consequently, values of type ff can be correctly substituted for values of type fi <ref> [CW85] </ref>. The subtyping relationship is defined by a programming language's conformance rules. If ff conforms to fi then ff is said to be a subtype of fi and fi is said to be a supertype of ff.
Reference: [GJM91] <author> Carlo Ghezzi, Mehdi Jazayeri, and Dino Mandrioli. </author> <title> Fundamentals of Software Engineering. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: Dynamically evolving systems should 1 minimize the degree of coupling between interacting components in order to help maintain component compatibility during their evolution. Reducing coupling between components decreases their interdependencies and makes them easier to separate and understand <ref> [GJM91] </ref>. Furthermore, decreased interdependencies resulting from reduced coupling make a system easier to maintain by helping to minimize the effect that changes in components have on their interoperability.
Reference: [GR91] <author> Elana Granston and Vincent Russo. </author> <title> Signature-Based Polymorphism for C++. </title> <booktitle> In Proceedings of the USENIX C ++ Conference, </booktitle> <year> 1991. </year> <month> 32 </month>
Reference-contexts: A C ++ translator for Lingua Franca has been built which maps Lingua Franca types into C ++ types. C ++ was chosen due to its availability and the previous work on integrating the signature concept into the language <ref> [GR91, BR95] </ref>. The support libraries for C ++ applications have been designed and built. The libraries provide runtime conformance checking and remote method invocation using a shared memory transport module (when possible) or a UDP-based transport module.
Reference: [HPM93] <author> Graham Hamilton, Michael Powell, and James Mitchell. Subcontract: </author> <title> A Flexible Base for Distributed Programming. </title> <booktitle> In Proceedings of the ACM Symposium on Operating System Principles, </booktitle> <pages> pages 69-79, </pages> <year> 1993. </year>
Reference-contexts: While the overall approach taken in this paper has been adopted by a number of other efforts including OMG's CORBA [OMG91], IBM's SOM/DSOM [IBM93], Microsoft's OLE-II [Mic94], and Sun's Spring System <ref> [HPM93] </ref>, our work differs in one substantial way: the structure of interfaces is used for conformance checking rather than interface names or hierarchies of names. It is argued that structural subtyping is more expressive than inheritance subtyping and leads to less coupled components.
Reference: [IBM93] <institution> IBM. </institution> <note> SOMobjects Developer Toolkit Users Guide Version 2.0, </note> <year> 1993. </year>
Reference-contexts: While the overall approach taken in this paper has been adopted by a number of other efforts including OMG's CORBA [OMG91], IBM's SOM/DSOM <ref> [IBM93] </ref>, Microsoft's OLE-II [Mic94], and Sun's Spring System [HPM93], our work differs in one substantial way: the structure of interfaces is used for conformance checking rather than interface names or hierarchies of names.
Reference: [Ion95] <author> Iona Technologies, </author> <title> Dublin, Ireland. Orbix Programmer's Guide, </title> <month> July </month> <year> 1995. </year>
Reference-contexts: Also, the added costs to value encoding and decoding is avoided whenever the optimized coding module can be used. Table 3 compares remote method invocation times in the Renaissance System to two other systems, Sun RPC and Orbix <ref> [Ion95] </ref>. Orbix is a CORBA-based inheritance-typed distributed object system. For the Renaissance System, the remote method invocation times are given for both the optimized case (with a method map and the optimized coding module) and the unoptimized case (without a method map and the unoptimized coding module).
Reference: [JR86] <author> Michael Jones and Richard Rashid. </author> <title> Mach and Matchmaker: Kernel and Language Support for Object-Oriented Distributed Systems. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 67-86, </pages> <year> 1986. </year>
Reference-contexts: Unfortunately, object-oriented mechanisms are usually only acces-sible and enforced through programming language support. Relying on programming language support would severely limit the degree to which disjoint, unrelated components can interact in a multilingual, loosely coupled distributed system. The use of a high-level interface description language (IDL) <ref> [JR86] </ref> solves this problem by providing a mechanism for specifying an object's interface independently of the programming languages used to implement or access the object. A translator maps these specifications into a target language's notion of objects and interfaces (for most object-oriented languages, a class).
Reference: [MGH + 94] <author> James Mitchell, Jonathan Gibbons, Graham Hamilton, Peter Kessler, Yousef Khalidi, Panos Kougiouris, Peter Madany, Michael Nelson, Michael Powell, and Sanjay Radia. </author> <title> An Overview of the Spring System. </title> <booktitle> In Proceedings of Compcon Spring 1994, </booktitle> <year> 1994. </year>
Reference-contexts: The types used in the experiment are interfaces taken from the Renaissance System and Spring System <ref> [MGH + 94] </ref>. 7 The types ranged in complexity from the simplest interface (a type graph with 1 node and no edges) to the most complex interface found in either system (a type graph with 251 nodes and 600 edges). <p> Customizing the transport module to optimize communication costs has been used successfully to improve performance in many other systems including Mach [A + 86, BALL89] and Spring <ref> [MGH + 94] </ref>. 4.7 An Alternate Approach: Inheritance-Typed Systems 4.7.1 Conformance Algorithm With inheritance subtyping, types are named interfaces arranged in type hierarchies.
Reference: [Mic94] <author> Microsoft Corporation. </author> <title> OLE2 Programmer's Reference, volume 2. </title> <publisher> Microsoft Press, </publisher> <year> 1994. </year>
Reference-contexts: While the overall approach taken in this paper has been adopted by a number of other efforts including OMG's CORBA [OMG91], IBM's SOM/DSOM [IBM93], Microsoft's OLE-II <ref> [Mic94] </ref>, and Sun's Spring System [HPM93], our work differs in one substantial way: the structure of interfaces is used for conformance checking rather than interface names or hierarchies of names. It is argued that structural subtyping is more expressive than inheritance subtyping and leads to less coupled components.
Reference: [Muc96] <author> Patrick A. Muckelbauer. </author> <title> Structural Subtyping in a Distributed Object System. </title> <type> PhD thesis, </type> <institution> Department of Computer Sciences, Purdue University, </institution> <year> 1996. </year>
Reference-contexts: The resulting type hierarchy would allow clients to specify the precise set of methods expected of objects of type N s as a named interface and could be used to help minimize component coupling. In <ref> [Muc96] </ref>, the construction of such a hierarchy is explained as modeling the structural subtyping relationships for a type N s with inheritance subtyping. However, building such hierarchies has several problems. First, it does not work in general. <p> First, it does not work in general. There are types that have an infinite number of distinct structural 2 The sharing of interfaces and their meaning is typically accomplished by sharing specifications for the interfaces via either files or an interface repository [OMG91]. 5 supertypes <ref> [Muc96] </ref>. For such types, it is not possible to model all their structural subtyping relationships with inheritance subtyping. Second, programmers building such hierarchies would add exponentially to the complexity of the hierarchies. <p> These extensions would provide programmers added functionality to select an appropriate set of semantics based on the requirements of a program. In practice, however, these extensions have not been necessary because, as is shown in <ref> [Muc96] </ref>, many of the value passing semantics for data values can be simulated. <p> The complexity of the conformance algorithm is obviously the sum of the complexities of functions initialize and check . Let C initialize denote the complexity of function initialize. The complexity of function check depends on the complexities of functions mark and isMarked and, in <ref> [Muc96] </ref>,. is shown to be: O @ C isMarked X (out (n x ) + out (n y )) + C mark jSj 1 where C isMarked and C mark denote the complexities of the functions mark and isMarked respectively, out (n x ) is the number of outgoing edges of <p> The data collected and analysis given indicate the decrease in performance is marginal. 6 Current Status The design and specification of Lingua Franca is complete and is described in <ref> [Muc96] </ref>. A C ++ translator for Lingua Franca has been built which maps Lingua Franca types into C ++ types. C ++ was chosen due to its availability and the previous work on integrating the signature concept into the language [GR91, BR95].
Reference: [MW88] <author> J. Eliot Moss and Alexander Wolf. </author> <title> Toward Principles of Inheritance and Subtyping in Programming Languages. </title> <type> Technical Report COINS 88-95, </type> <institution> University of Massachusetts, </institution> <year> 1988. </year>
Reference-contexts: The subtyping relationship varies from language to language depending on the conformance rules used. However, there are two common approaches to conformance in object-oriented programming languages <ref> [MW88, Sny86] </ref>: name-based conformance and structural-based conformance.
Reference: [OMG91] <author> Object Managment Group, </author> <title> Framingham, MA. The Common Object Request Broker: Architecture and Specification (Revision 2.0), </title> <month> July </month> <year> 1991. </year>
Reference-contexts: The interface of an object is defined by the collection of all its methods. The only way to modify or access an object's state is to invoke a method in the object's interface. In distributed object systems <ref> [OMG91] </ref> clients access servers by invoking methods on objects in a server's component via remote references. Components are self-contained and usually implemented in a single programming language (or at least a single consistent object model). Each component may be executing in an independent address space and/or on a separate machine. <p> While the overall approach taken in this paper has been adopted by a number of other efforts including OMG's CORBA <ref> [OMG91] </ref>, IBM's SOM/DSOM [IBM93], Microsoft's OLE-II [Mic94], and Sun's Spring System [HPM93], our work differs in one substantial way: the structure of interfaces is used for conformance checking rather than interface names or hierarchies of names. <p> However, building such hierarchies has several problems. First, it does not work in general. There are types that have an infinite number of distinct structural 2 The sharing of interfaces and their meaning is typically accomplished by sharing specifications for the interfaces via either files or an interface repository <ref> [OMG91] </ref>. 5 supertypes [Muc96]. For such types, it is not possible to model all their structural subtyping relationships with inheritance subtyping. Second, programmers building such hierarchies would add exponentially to the complexity of the hierarchies.
Reference: [Set89] <author> Ravi Sethi. </author> <title> Programming Languages: Concepts and Constructs. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: When clients access server values through untyped references, checking is performed at access time to guarantee consistent use of those values. Runtime type errors are generated when clients access server values in an inconsistent manner. This form of checking is referred to as dynamic type checking <ref> [Set89] </ref>. For example, in Distributed Smalltalk [Ben87], a dynamically typed-checked distributed object system, a client can invoke the method m on a remote object and if the method is not in the remote object's interface the exception "message not understood " is raised.
Reference: [Sha86] <author> Marc Shapiro. </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <booktitle> In Proceedings of the Sixth International Conference on Distributed Computer Systems, </booktitle> <year> 1986. </year>
Reference-contexts: A translator maps these specifications into a target language's notion of objects and interfaces (for most object-oriented languages, a class). The generated language-specific modules are used by programmers to implement objects and/or to generate typed references to remote objects via proxy objects <ref> [Sha86] </ref> (see Section 4 for details about proxy objects). <p> server-side cost for encoding ranged from 4% for simple type graphs up to 43% as the size of the type graphs increased. 22 23 24 4.5 Performance of Remote Method Invocation 4.5.1 Proxy Objects In the Renaissance System, all remote method invocations occur indirectly through local invocations on proxy objects <ref> [Sha86] </ref>. As shown in Figure 7, a proxy is a local representation of a remote object and maps the language's notion of procedure call or method invocation transparently into a remote method invocation.
Reference: [Sny86] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 38-45, </pages> <year> 1986. </year> <month> 33 </month>
Reference-contexts: The subtyping relationship varies from language to language depending on the conformance rules used. However, there are two common approaches to conformance in object-oriented programming languages <ref> [MW88, Sny86] </ref>: name-based conformance and structural-based conformance.
References-found: 27

