URL: ftp://ftp.cs.washington.edu/tr/1998/01/UW-CSE-98-01-01.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Phone: (206) 685-2094; fax: (206) 543-2969  
Title: Constraint-Based Polymorphism in Cecil  
Author: Vassily Litvinov and Craig Chambers 
Note: -vass,chambers-@cs.washington.edu  
Address: Box 352350 Seattle, Washington 98195-2350 USA  
Affiliation: Department of Computer Science and Engineering University of Washington,  
Abstract: Technical Report UW-CSE-98-01-01 January 1998 
Abstract-found: 1
Intro-found: 1
Reference: [Agesen et al. 97] <author> Ole Agesen, Stephen N. Freund, and John C. Mitchell. </author> <title> Adding Type Parameterization to the Java Language. </title> <booktitle> In Proceedings OOPSLA 97, </booktitle> <address> Atlanta, GA, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: Nevertheless, we too have been working on syntactic sugars that would make the more sophisticated uses of F-bounded polymorphism simpler. Agesen, Freund, and Mitchell propose a similar extension to Java <ref> [Agesen et al. 97] </ref>. It differs from Pizza and from our system in being able to parameterize a class over its superclass. However, this feature cannot be typechecked once when the abstraction is declared, but instead must be rechecked at each instantiation.
Reference: [Bourdoncle & Merz 97] <author> Franois Bourdoncle and Stephan Merz. </author> <title> Type Checking Higher-Order Polymorphic Multi-Methods. </title> <booktitle> In Conference Record of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 302315. </pages>
Reference-contexts: Strongtalk [Bracha & Griswold 93] and ML <ref> [Bourdoncle & Merz 97] </ref> introduce specialized constructs to declare this relation; we do not. Array types in Java [Gosling et al. 96] and virtual types as in Thorups proposal in effect treat all type parameters as covariant, which is a source of static unsoundness that necessitates run-time checking. <p> ML is a powerful polymorphic object-oriented language supporting multi-methods <ref> [Bourdoncle & Merz 97] </ref>. Their language support subtyping directly, but treats inheritance as a separate syntactic sugar (which must follow the subtyping relation).
Reference: [Bracha & Griswold 93] <author> Gilad Bracha and David Griswold. Strongtalk: </author> <title> Typechecking Smalltalk in a Production Environment. </title> <booktitle> In Proceedings OOPSLA 93, </booktitle> <pages> pages 215230, </pages> <month> October </month> <year> 1993. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 28, number 10. </volume>
Reference-contexts: Strongtalk <ref> [Bracha & Griswold 93] </ref> and ML [Bourdoncle & Merz 97] introduce specialized constructs to declare this relation; we do not. <p> Their language is purely functional and side-effect-free. 5.2 Languages Based on SelfType or Matching Some languages provide only restricted forms of F-bounded polymorphism. In TOOPLE [Bruce et al. 93] and Strongtalk <ref> [Bracha & Griswold 93] </ref>, a special type SelfType is introduced, which can be used as the type of method arguments, results, or variables; roughly speaking, a class C with references to SelfType can be modeled with the F-bounded declaration forall SelfType where SelfType subtypes C [SelfType]: class C [SelfType] SelfType supports
Reference: [Bracha 96] <author> Gilad Bracha. </author> <title> The Strongtalk Type System for Smalltalk, 1996. OOPSLA 96 Workshop on Extending the Smalltalk Language, </title> <note> available from http://java.sun.com/people/gbracha/nwst.html. </note>
Reference-contexts: To avoid accidental subtyping, a class may be branded with one or more protocols. Like Cecil, type declarations and typechecking is optional in Strongtalk. Interestingly, a later version of Strongtalk appears to have dropped inferred structural subtyping and brands in favor of explicit by-name subtyping <ref> [Bracha 96] </ref>. This later version also introduces the ability to declare that different instantiations of a parameterized type are subtype-related either co- or contravariantly with respect to its parameter types. Both Strongtalk systems are subsets of our type system.
Reference: [Bruce et al. 93] <author> Kim B. Bruce, Jon Crabtree, Thomas P. Murtagh, Robert van Gent, Allyn Dimock, and Robert Muller. </author> <title> Safe and decidable type checking in an object-oriented language. </title> <booktitle> In Proceedings OOPSLA 93, </booktitle> <pages> pages 2946, </pages> <month> October </month> <year> 1993. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 28, number 10. </volume>
Reference-contexts: Our type system supports multiple polymorphic signature declarations for the same message, while they allow only a single signature declaration per message. Their language is purely functional and side-effect-free. 5.2 Languages Based on SelfType or Matching Some languages provide only restricted forms of F-bounded polymorphism. In TOOPLE <ref> [Bruce et al. 93] </ref> and Strongtalk [Bracha & Griswold 93], a special type SelfType is introduced, which can be used as the type of method arguments, results, or variables; roughly speaking, a class C with references to SelfType can be modeled with the F-bounded declaration forall SelfType where SelfType subtypes C
Reference: [Bruce et al. 95a] <author> Kim Bruce, Luca Cardelli, Giuseppe Castagna, The Hopkins Objects Group, Gary T. Leavens, and Benjamin Pierce. </author> <title> On Binary Methods. Theory and Practice of Object Systems, </title> <address> 1(3):217238, </address> <year> 1995. </year>
Reference-contexts: variables, modules and encapsulation, analogues of Smalltalks super and non-local return constructs [Goldberg & Robson 83], mixed dynamically and statically typed code, and various syntactic conveniences such as infix and dot notation and simultaneous declaration of parallel inheritance and subtyping hierarchies. 3 classic challenges such as the binary methods problem <ref> [Bruce et al. 95a] </ref>.
Reference: [Bruce et al. 95b] <author> Kim B. Bruce, Angela Schuett, and Robert van Gent. PolyToil: </author> <title> A Type-Safe Polymorphic Object-Oriented Language. </title> <booktitle> In Proceedings ECOOP 95, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: Other languages provide a related notion called matching, which allows a kind of F-bounded polymorphism where a single type variable is bounded by a function of itself (but of no other type variables); languages including matching include PolyTOIL <ref> [Bruce et al. 95b] </ref> and LOOM [Bruce et al. 97]. The key advantage of SelfType and matching is convenient syntactic support for a common idiom, but it is less powerful than F-bounded polymorphism.
Reference: [Bruce et al. 97] <author> Kim B. Bruce, Adrian Fiech, and Leaf Petersen. </author> <title> Subtyping is not a good Match for object-oriented languages. </title> <booktitle> In Proceedings ECOOP 97. </booktitle> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: Additionally, different representations of numbers (such as integers and oats) can be intermixed in the collection and compared to each other; subtyping is still available after instantiating the polymorphic declarations, unlike LOOM <ref> [Bruce et al. 97] </ref> and Haskell [Wadler & Blott 89]. type Num Num subtypes Ordered [Num] -- classes conforming to Num can be compared to each other abstract class NumClass NumClass conforms Num NumClass inherits OrderedClass [Num] -- inherit default implementations of operations sig convert_to_float (Num):Num method equal (x1@NumClass:Num, x2@NumClass:Num):Bool - <p> Languages based on matching, such as the TOOPLE, TOIL, PolyTOIL, and LOOM series of languages <ref> [Bruce et al. 97] </ref>, support a subset of F-bounded polymorphism that only allows the receiver argument to be constrained by itself, and as a result they cannot express these sorts of constraints over multiple types. <p> Other languages provide a related notion called matching, which allows a kind of F-bounded polymorphism where a single type variable is bounded by a function of itself (but of no other type variables); languages including matching include PolyTOIL [Bruce et al. 95b] and LOOM <ref> [Bruce et al. 97] </ref>. The key advantage of SelfType and matching is convenient syntactic support for a common idiom, but it is less powerful than F-bounded polymorphism. For example, neither SelfType nor matching are powerful enough to support families of mutually dependent classes such as the Subject/Observer family.
Reference: [Bruce et al. 98] <author> Kim B. Bruce, Martin Odersky, and Philip Wadler. </author> <title> A Statically Safe Alternative to Virtual Types. </title> <note> 1998. Submission to ECOOP 98, available from http://www.cs.williams.edu/ kim/README.html. </note>
Reference-contexts: Multi-methods as in Cecil enable both new representations and new operations to be added easily, avoiding the need for new language constructs. Bruce, Odersky, and Wadler <ref> [Bruce et al. 98] </ref> recently proposed to extend Pizza with special support for declaring families of mutually recursive classes. They argue that pure F-bounded polymorphism is too cumbersome for programmers to use in practice.
Reference: [Canning et al. 89] <author> Peter Canning, William Cook, Walter Hill, John Mitchell, and Walter Olthoff. </author> <title> F-Bounded Polymorphism for Object-Oriented Programming. </title> <booktitle> In Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273280. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Polymorphic abstractions are written and typechecked once, not repeatedly for each instantiation or for each subclass. The bounds on the allowed polymorphism of type variables can be expressed using a mixture of recursive subtype and signature constraints, supporting both F-bounded polymorphism <ref> [Canning et al. 89] </ref> and Theta-style where clauses [Day et al. 95, Liskov et al. 94] as special cases.
Reference: [Chambers & Leavens 94] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and Modules for Multi-Methods. </title> <booktitle> In Proceedings OOPSLA 94, </booktitle> <pages> pages 115, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: The following subsection provides background by describing the monomorphic core of Mini-Cecil ignoring these polymorphic features; a version of this monomorphic language and the issues involved in typechecking it have been discussed previously <ref> [Chambers & Leavens 94, Chambers & Leavens 95] </ref>. Later subsections reintroduce the polymorphic features. 2.1 Monomorphic Host Language A Mini-Cecil program is a collection of (mutually recursive, unordered) declarations followed by an expression to evaluate. <p> each c i argument class conforms to the corresponding declared formal type T i ', and that the methods result type T r ' is a subtype of the signatures result type T r . (An efficient algorithm to achieve the effect of this enumeration-based specification has been described previously <ref> [Chambers & Leavens 94, Chambers & Leavens 95] </ref>). If these tests succeed, then the type interface is known to be completely and unambiguously implemented. <p> Client-side typechecking is reasonably fast, taking about 7.5 minutes to typecheck all of Vortex from scratch on an UltraSPARC-1/170 workstation; implementation-side typechecking is missing several important but known optimizations <ref> [Chambers & Leavens 94, Chambers & Leavens 95] </ref> and so is slow. For the most part, code (other than type declarations) did not need rewriting to meet the constraints of the static typechecker. F-bounded polymorphism was crucial to achieving this.
Reference: [Chambers & Leavens 95] <author> Craig Chambers and Gary Leavens. </author> <title> Typechecking and Modules for Multi-Methods. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(9), </volume> <month> November </month> <year> 1995. </year> <month> 26 </month>
Reference-contexts: The following subsection provides background by describing the monomorphic core of Mini-Cecil ignoring these polymorphic features; a version of this monomorphic language and the issues involved in typechecking it have been discussed previously <ref> [Chambers & Leavens 94, Chambers & Leavens 95] </ref>. Later subsections reintroduce the polymorphic features. 2.1 Monomorphic Host Language A Mini-Cecil program is a collection of (mutually recursive, unordered) declarations followed by an expression to evaluate. <p> each c i argument class conforms to the corresponding declared formal type T i ', and that the methods result type T r ' is a subtype of the signatures result type T r . (An efficient algorithm to achieve the effect of this enumeration-based specification has been described previously <ref> [Chambers & Leavens 94, Chambers & Leavens 95] </ref>). If these tests succeed, then the type interface is known to be completely and unambiguously implemented. <p> Client-side typechecking is reasonably fast, taking about 7.5 minutes to typecheck all of Vortex from scratch on an UltraSPARC-1/170 workstation; implementation-side typechecking is missing several important but known optimizations <ref> [Chambers & Leavens 94, Chambers & Leavens 95] </ref> and so is slow. For the most part, code (other than type declarations) did not need rewriting to meet the constraints of the static typechecker. F-bounded polymorphism was crucial to achieving this.
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Proceedings ECOOP 92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 3356, </pages> <address> Utrecht, The Netherlands, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We have implemented this type system in the Cecil language <ref> [Chambers 92, Chambers 93a] </ref>, and we have used its features to successfully typecheck a 100,000-line Cecil program, the Vortex optimizing compiler system [Dean et al. 96] (which includes the Cecil typechecker itself as a component).
Reference: [Chambers 93a] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale. </title> <type> Technical Report TR-93-03-05, </type> <institution> Department of Computer Science and Engineering. University of Washington, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: We have implemented this type system in the Cecil language <ref> [Chambers 92, Chambers 93a] </ref>, and we have used its features to successfully typecheck a 100,000-line Cecil program, the Vortex optimizing compiler system [Dean et al. 96] (which includes the Cecil typechecker itself as a component).
Reference: [Chambers 93b] <author> Craig Chambers. </author> <title> Predicate Classes. </title> <editor> In O. Nierstrasz, editor, </editor> <booktitle> Proceedings ECOOP 93, </booktitle> <volume> LNCS 707, </volume> <pages> pages 268296, </pages> <address> Kaiserslautern, Germany, July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The var v:T declaration declares a new mutable variable named v holding values of type T. Mini-Cecil is based on multiple dispatching; multi-methods generalize undispatched procedures, singly-dispatched methods, and functions overloaded on different argument types, and multi-methods can resolve * Omitted features include a classless object model, predicate objects <ref> [Chambers 93b] </ref>, initialized variable and field declarations, initialization of fields as part of object creation, immutable variables and fields, invocation of function objects via messages, nested declarations other than variables, modules and encapsulation, analogues of Smalltalks super and non-local return constructs [Goldberg & Robson 83], mixed dynamically and statically typed code,
Reference: [Chambers et al. 96] <author> Craig Chambers, Jeffrey Dean, and David Grove. </author> <title> Frameworks for Intra- and Interprocedural Dataflow Analysis. </title> <type> Technical Report UW-CSE-96-11-02, </type> <institution> University of Washington, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: |- E : T 2 19 node representation (with different possible instantiations of node representation), the program call graph representation (with mutually recursive classes for procedure nodes, call sites, and call edges), and intraprocedural and interprocedural analysis frameworks (with mutually recursive classes for analysis domains, transformation selections, and traversal state) <ref> [Chambers et al. 96] </ref>.
Reference: [Day et al. 95] <author> Mark Day, Robert Gruber, Barbara Liskov, and Andrew C. Myers. </author> <title> Subtypes vs. Where Clauses: Constraining Parametric Polymorphism. </title> <booktitle> In OOPSLA95 Conference Proceedings, </booktitle> <pages> pages 156168, </pages> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Polymorphic abstractions are written and typechecked once, not repeatedly for each instantiation or for each subclass. The bounds on the allowed polymorphism of type variables can be expressed using a mixture of recursive subtype and signature constraints, supporting both F-bounded polymorphism [Canning et al. 89] and Theta-style where clauses <ref> [Day et al. 95, Liskov et al. 94] </ref> as special cases. <p> examples to reect the fact that their type parameters are contravariant. forall S, T where S subtypes T: Comparable [T] subtypes Comparable [S] forall S, T where S subtypes T: Ordered [T] subtypes Ordered [S] Few other languages can express this (for example, Pizza [Odersky & Wadler 97] and Theta <ref> [Day et al. 95, Liskov et al. 94] </ref> cannot). Strongtalk [Bracha & Griswold 93] and ML [Bourdoncle & Merz 97] introduce specialized constructs to declare this relation; we do not. <p> This later version also introduces the ability to declare that different instantiations of a parameterized type are subtype-related either co- or contravariantly with respect to its parameter types. Both Strongtalk systems are subsets of our type system. The Theta language <ref> [Day et al. 95, Liskov et al. 94] </ref> and the similar proposed extension to Java [Myers et al. 97] support signature constraints called where clauses. Unlike our type system, only explicit type variables are supported, and clients must provide instantiations of all type variables when using a parameterized abstraction.
Reference: [Dean et al. 96] <author> Jeffrey Dean, Greg DeFouw, Dave Grove, Vassily Litvinov, and Craig Chambers. </author> <title> Vortex: An Optimizing Compiler for Object-Oriented Languages. </title> <booktitle> In OOPSLA96 Conference Proceedings, </booktitle> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: We have implemented this type system in the Cecil language [Chambers 92, Chambers 93a], and we have used its features to successfully typecheck a 100,000-line Cecil program, the Vortex optimizing compiler system <ref> [Dean et al. 96] </ref> (which includes the Cecil typechecker itself as a component). The next section of this paper presents our host language and the type system informally, illustrating the capabilities of our type system on several examples, and comparing it to other type systems.
Reference: [Eifrig et al. 94] <author> Jonathan Eifrig, Scott Smith, Valery Trifonov, and Amy Zwarico. </author> <title> Application of OOP Type Theory: State, Decid-ability, Integration. </title> <booktitle> In Proceedings OOPSLA 94, </booktitle> <pages> pages 1630, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: This open/closed distinction for recursive references to a type was noted previously by Eifrig et al. <ref> [Eifrig et al. 94] </ref>. 5.3 Languages Based on Signature Constraints and Implicit Structural Subtyping Some languages use collections of signatures to constrain polymorphism, where any type which supports the required signatures can instantiate the parameterized declaration.
Reference: [Eifrig et al. 95] <author> Jonathan Eifrig, Scott Smith, and Valery Trifonov. </author> <title> Sound Polymorphic Type Inference for Objects. </title> <booktitle> In OOPSLA95 Conference Proceedings, </booktitle> <pages> pages 169184, </pages> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: No subtype relation holds between different instantiations of the same parameterized type, preventing idioms such as the covariantly related read-only collection interfaces. Recursively constrained types are the heart of a very sophisticated type system <ref> [Eifrig et al. 95] </ref>. In this system, type variables and sets of constraints over them are automatically inferred by the system. Subtyping is inferred structurally, viewing objects as records and using standard record subtyping rules.
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Lanaguge and its Implementation. </title> <address> Addision-Wes-ley, Reading, MA, </address> <year> 1983. </year>
Reference-contexts: Omitted features include a classless object model, predicate objects [Chambers 93b], initialized variable and field declarations, initialization of fields as part of object creation, immutable variables and fields, invocation of function objects via messages, nested declarations other than variables, modules and encapsulation, analogues of Smalltalks super and non-local return constructs <ref> [Goldberg & Robson 83] </ref>, mixed dynamically and statically typed code, and various syntactic conveniences such as infix and dot notation and simultaneous declaration of parallel inheritance and subtyping hierarchies. 3 classic challenges such as the binary methods problem [Bruce et al. 95a]. <p> Other examples occur with control structures, with the types of the argument function objects inducing other types. As a simple example, the following declarations illustrate how the polymorphic if expression is programmed in Mini-Cecil, following the model of ifTrue:ifFalse: in Smalltalk <ref> [Goldberg & Robson 83] </ref>. 7 type Bool; forall T: sig if (Bool, l ():T, l ():T):T concrete class True; True conforms Bool; forall T: method if (t@True:Bool, if_true@Any:l ():T, if_false@Any:l ():T):T - apply (if_true) - concrete class False; False conforms Bool; forall T: method if (f@False:Bool, if_true@Any:l ():T, if_false@Any:l ():T):T -
Reference: [Gosling et al. 96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: Strongtalk [Bracha & Griswold 93] and ML [Bourdoncle & Merz 97] introduce specialized constructs to declare this relation; we do not. Array types in Java <ref> [Gosling et al. 96] </ref> and virtual types as in Thorups proposal in effect treat all type parameters as covariant, which is a source of static unsoundness that necessitates run-time checking. <p> Beta supports virtual patterns as anchor classes [Madsen & Mller-Pederse 89, Madsen et al. 93], and Thorup adapted this idea in his proposed virtual types extension to Java <ref> [Gosling et al. 96] </ref>. While all of these mechanisms seem natural to programmers in many cases and are syntactically concise, they suffer from a loss of static type safety.
Reference: [Liskov et al. 94] <author> Barbara Liskov, Dorthoy Curtis, Mark Day, Sanjay Ghemawhat, Robert Gruber, Paul Johnson, and Andrew C. Myers. </author> <title> Theta Reference Manual. </title> <type> Technical Report Programming Methodology Group Memo 88, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Polymorphic abstractions are written and typechecked once, not repeatedly for each instantiation or for each subclass. The bounds on the allowed polymorphism of type variables can be expressed using a mixture of recursive subtype and signature constraints, supporting both F-bounded polymorphism [Canning et al. 89] and Theta-style where clauses <ref> [Day et al. 95, Liskov et al. 94] </ref> as special cases. <p> examples to reect the fact that their type parameters are contravariant. forall S, T where S subtypes T: Comparable [T] subtypes Comparable [S] forall S, T where S subtypes T: Ordered [T] subtypes Ordered [S] Few other languages can express this (for example, Pizza [Odersky & Wadler 97] and Theta <ref> [Day et al. 95, Liskov et al. 94] </ref> cannot). Strongtalk [Bracha & Griswold 93] and ML [Bourdoncle & Merz 97] introduce specialized constructs to declare this relation; we do not. <p> This later version also introduces the ability to declare that different instantiations of a parameterized type are subtype-related either co- or contravariantly with respect to its parameter types. Both Strongtalk systems are subsets of our type system. The Theta language <ref> [Day et al. 95, Liskov et al. 94] </ref> and the similar proposed extension to Java [Myers et al. 97] support signature constraints called where clauses. Unlike our type system, only explicit type variables are supported, and clients must provide instantiations of all type variables when using a parameterized abstraction.
Reference: [Madsen & Mller-Pederse 89] <author> Ole Lehrmann Madsen and Birger Mller-Pedersen. </author> <title> Virtual Classes: A Powerful Mechanism in Object-Oriented Programming. </title> <booktitle> In Proceedings OOPSLA 89, </booktitle> <pages> pages 397406, </pages> <month> October </month> <year> 1989. </year> <journal> Published as ACM SIG-PLAN Notices, </journal> <volume> volume 24, number 10. </volume>
Reference-contexts: in the following declarations, the bound will ensure that numbers can be compared to numbers, and collections of numbers can be compared to other collections of numbers, but will disallow comparing numbers to collections of numbers, unlike covariant typing as in Eiffel [Meyer 92] or virtual types as in Beta <ref> [Madsen & Mller-Pederse 89, Madsen et al. 93] </ref> and Thorups proposal for Java [Thorup 97]. <p> d is known to be a (subtype of) Drawing, and therefore has a bitmap plot (screen, bitmap (d)) - method set_pixel (d@ViewClass [D,V]:V, p@Any:Position, c@Any:Color):Void - plot_pixel (screen, p, c) - - Systems based on covariant method typing such as Eiffel [Meyer 92] or covariant type refinement such as Beta <ref> [Madsen & Mller-Pederse 89] </ref> and Thorups proposed extension to Java allow this program, but also allow many other programs that are not type-safe; these languages either insert run-time typechecking or are unsafe. <p> Instances may themselves be further subclassed and their anchor types narrowed. Eiffel supports covariant overriding of methods and instance variables, and uses the like construct to refer to anchors [Meyer 92]; Eiffel also supports unbounded parameterized classes as well. Beta supports virtual patterns as anchor classes <ref> [Madsen & Mller-Pederse 89, Madsen et al. 93] </ref>, and Thorup adapted this idea in his proposed virtual types extension to Java [Gosling et al. 96]. While all of these mechanisms seem natural to programmers in many cases and are syntactically concise, they suffer from a loss of static type safety.
Reference: [Madsen et al. 93] <author> Ole Lehrmann Madsen, Birger Mller-Pedersen, and Krysten Nygaard. </author> <title> Object-Oriented Programming in the Beta Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: in the following declarations, the bound will ensure that numbers can be compared to numbers, and collections of numbers can be compared to other collections of numbers, but will disallow comparing numbers to collections of numbers, unlike covariant typing as in Eiffel [Meyer 92] or virtual types as in Beta <ref> [Madsen & Mller-Pederse 89, Madsen et al. 93] </ref> and Thorups proposal for Java [Thorup 97]. <p> Instances may themselves be further subclassed and their anchor types narrowed. Eiffel supports covariant overriding of methods and instance variables, and uses the like construct to refer to anchors [Meyer 92]; Eiffel also supports unbounded parameterized classes as well. Beta supports virtual patterns as anchor classes <ref> [Madsen & Mller-Pederse 89, Madsen et al. 93] </ref>, and Thorup adapted this idea in his proposed virtual types extension to Java [Gosling et al. 96]. While all of these mechanisms seem natural to programmers in many cases and are syntactically concise, they suffer from a loss of static type safety.
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: the language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: For example, in the following declarations, the bound will ensure that numbers can be compared to numbers, and collections of numbers can be compared to other collections of numbers, but will disallow comparing numbers to collections of numbers, unlike covariant typing as in Eiffel <ref> [Meyer 92] </ref> or virtual types as in Beta [Madsen & Mller-Pederse 89, Madsen et al. 93] and Thorups proposal for Java [Thorup 97]. <p> [D,V] method notify (v@ViewClass [D,V]:V, d@Any:D):Void - -- here d is known to be a (subtype of) Drawing, and therefore has a bitmap plot (screen, bitmap (d)) - method set_pixel (d@ViewClass [D,V]:V, p@Any:Position, c@Any:Color):Void - plot_pixel (screen, p, c) - - Systems based on covariant method typing such as Eiffel <ref> [Meyer 92] </ref> or covariant type refinement such as Beta [Madsen & Mller-Pederse 89] and Thorups proposed extension to Java allow this program, but also allow many other programs that are not type-safe; these languages either insert run-time typechecking or are unsafe. <p> Instances may themselves be further subclassed and their anchor types narrowed. Eiffel supports covariant overriding of methods and instance variables, and uses the like construct to refer to anchors <ref> [Meyer 92] </ref>; Eiffel also supports unbounded parameterized classes as well. Beta supports virtual patterns as anchor classes [Madsen & Mller-Pederse 89, Madsen et al. 93], and Thorup adapted this idea in his proposed virtual types extension to Java [Gosling et al. 96].
Reference: [Myers et al. 97] <author> Andrew C. Myers, Joseph A. Bank, and Barbara Liskov. </author> <title> Parameterized Types for Java. </title> <booktitle> In Conference Record of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 132145. </pages>
Reference-contexts: Both Strongtalk systems are subsets of our type system. The Theta language [Day et al. 95, Liskov et al. 94] and the similar proposed extension to Java <ref> [Myers et al. 97] </ref> support signature constraints called where clauses. Unlike our type system, only explicit type variables are supported, and clients must provide instantiations of all type variables when using a parameterized abstraction.
Reference: [Odersky & Wadler 97] <author> Martin Odersky and Philip Wadler. </author> <title> Pizza into Java: Translating Theory into Practice. </title> <booktitle> In Conference Record of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 146159. </pages>
Reference-contexts: extend the earlier Comparable and Ordered examples to reect the fact that their type parameters are contravariant. forall S, T where S subtypes T: Comparable [T] subtypes Comparable [S] forall S, T where S subtypes T: Ordered [T] subtypes Ordered [S] Few other languages can express this (for example, Pizza <ref> [Odersky & Wadler 97] </ref> and Theta [Day et al. 95, Liskov et al. 94] cannot). Strongtalk [Bracha & Griswold 93] and ML [Bourdoncle & Merz 97] introduce specialized constructs to declare this relation; we do not. <p> Also, the other languages do not support multi-methods, complete separation of inheritance from subtyping, and least-upper-bound and greatest-lower-bound type expressions, except where noted below. 5.1 Languages Based on F-Bounded Polymorphism Pizza is an extension to Java based on F-bounded polymorphism <ref> [Odersky & Wadler 97] </ref>. Like our system, Pizza supports classes with mutually recursive bounds, crucial for supporting interrelated families of classes such as the Subject/Observer example from section 2.6.
Reference: [SRC] <institution> DEC SRC Modula-3 Implementation. Digital Equipment Corporation Systems Research Center. </institution> <note> http://www.research.digital.com/SRC/modula-3/html/home.html. </note>
Reference-contexts: appear to ensure that such constraints can always be solved, while our system places no syntactic limits but may report a type error due to incompleteness of the particular deterministic algorithm used by the typechecker. 24 5.4 Languages Based on Instantiation-Time Checking Some languages, including C++ [Stroustrup 91] and Modula-3 <ref> [SRC] </ref>, dispense with specifying constraints on type variables entirely, relying instead on checking each instantiation separately.
Reference: [Stroustrup 91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language (second edition). </title> <address> Addision-Wesley, Reading, MA, </address> <year> 1991. </year>
Reference-contexts: glb subtype constraints can appear to ensure that such constraints can always be solved, while our system places no syntactic limits but may report a type error due to incompleteness of the particular deterministic algorithm used by the typechecker. 24 5.4 Languages Based on Instantiation-Time Checking Some languages, including C++ <ref> [Stroustrup 91] </ref> and Modula-3 [SRC], dispense with specifying constraints on type variables entirely, relying instead on checking each instantiation separately.
Reference: [Thorup 97] <author> Kresten Krab Thorup. </author> <title> Genericity in Java with Virtual Types. </title> <booktitle> In Proceedings ECOOP 97, </booktitle> <address> Jyvaskyla, Finland, June 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: to numbers, and collections of numbers can be compared to other collections of numbers, but will disallow comparing numbers to collections of numbers, unlike covariant typing as in Eiffel [Meyer 92] or virtual types as in Beta [Madsen & Mller-Pederse 89, Madsen et al. 93] and Thorups proposal for Java <ref> [Thorup 97] </ref>. <p> methods presented earlier. (Multiple dispatching allows a different solution to the binary method problem, which offers a different semantics than the solution enabled by F-bounded polymorphism; our type system supports both solutions, allowing the programmers to choose the desired effect for different practical examples.) The following example, adapted from Thorup <ref> [Thorup 97] </ref>, shows how mutually recursive subtype bounds can express the requirement that several interrelated types in a framework must be refined as a family to preserve type-safety. * * Recall that Mini-Cecil uses an unsugared syntax that separates types and classes, for clarity of semantics.
Reference: [Wadler & Blott 89] <author> Philip Wadler and Stephen Blott. </author> <title> How to Make ad-hoc Polymorphism Less ad-hoc. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 6076, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Additionally, different representations of numbers (such as integers and oats) can be intermixed in the collection and compared to each other; subtyping is still available after instantiating the polymorphic declarations, unlike LOOM [Bruce et al. 97] and Haskell <ref> [Wadler & Blott 89] </ref>. type Num Num subtypes Ordered [Num] -- classes conforming to Num can be compared to each other abstract class NumClass NumClass conforms Num NumClass inherits OrderedClass [Num] -- inherit default implementations of operations sig convert_to_float (Num):Num method equal (x1@NumClass:Num, x2@NumClass:Num):Bool - equal (convert_to_float (x1), convert_to_float (x2)) - <p> However, this feature cannot be typechecked once when the abstraction is declared, but instead must be rechecked at each instantiation. Haskells type classes can be viewed as a kind of F-bounded polymorphism <ref> [Wadler & Blott 89] </ref>.
References-found: 32

