URL: http://www.cs.iastate.edu/tech-reports/TR92-01.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: 3x 1 Search Programs  
Author: Gary T. Leavens and Mike Vermeulen 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa Sate University  
Note: To appear in Computers and Mathematics with Applications. cfl 1992 Pergamon Press.  
Date: March, 1992  
Pubnum: TR #92-01  
Abstract: Keywords: 3x + 1 problem, Collatz problem, optimization, algorithmic improvement, efficiency, performance. 1991 CR Categories: C.4 [Performance of Systems] Design studies, performance attributes; F.2.1 [Analysis of Algorithms and Problem Complexity] Numerical Algorithms and Problems | computations on polynomials, number-theoretic computations; I.1.2 [Algebraic Manipulation] Algorithms | algebraic algorithms; J.2 [Physical Sciences and Engineering ] Mathematics and statistics. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. L. Bentley. </author> <title> Writing Efficient Programs. Software Series. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1982. </year>
Reference-contexts: We are interested in the behavior of these statistics as n varies. Many facts are known about them, see Lagarias [5]. A number of researchers have observed that if the input n is drawn randomly, say with the uniform distribution on an interval <ref> [1; N ] </ref>, then these statistics appear to have nice limiting distributions as N approaches infinity (see, for example, Rawsthorne [10] and Wagon [11]). Lagarias and Weiss [6] describe various random walk models intended to simulate 3x + 1 function iterates. <p> comments about the relative speeds of Argus and C are still accurate, because in Argus integers must be decoded before they can be processed by the CPU's native instruction set, and then encoded on return.) Our optimizations can be analyzed in terms of Bentley's taxonomy of program efficiency improvement strategies <ref> [1] </ref>. This comparison shows that we used some standard strategies in interesting ways. <p> This comparison shows that we used some standard strategies in interesting ways. Bentley's logic rule 1 "exploit algebraic identities" states that: "If the evaluation of a logical expression is costly, replace it by an algebraically equivalent expression that is cheaper to evaluate" <ref> [1, page 148] </ref>. (This strategy is often called "strength reduction" when one replaces the expression with one entirely equivalent.) We used this strategy several times. <p> of not making a comparison for peaks in max value after a step of division by 2, described in Section 2.2., is similar to Bentley's logic rule 5 "boolean variable elimination." Bentley remarks that his rule can be generalized to the idea of storing arbitrary conditions in the program counter <ref> [1, page 73] </ref>. We like to think that instead of storing conditions in the program counter, one pushes desired assertions about the program state back through earlier statements.
Reference: 2. <author> B. Hayes. </author> <title> Computer recreations: On the ups and downs of hailstone numbers. </title> <journal> Scientific American, </journal> <volume> 250(1) </volume> <pages> 10-16, </pages> <month> Jan. </month> <year> 1984. </year>
Reference-contexts: + 1 problem considers iterates of the function H that does not map odd integers n to (3n + 1)=2, but rather to 3n + 1: H (n) = 3n + 1; if n 1 (mod 2), (2) The function H is modeled after the so-called hailstone algorithm, see Hayes <ref> [2] </ref>. One defines the iterates of H in the same way as T . <p> Proof: by induction on i, respectively j, for (a) and (b). There are graphs in the article by Hayes that show the wildly erratic and unpredicatable behavior of the iterates of H <ref> [2] </ref>. The behavior of T is, of course, similarly wild and unpredictable. We define certain statistics that measure various attributes of the iterates of the functions T and H.
Reference: 3. <author> E. Horowitz and S. Sahni. </author> <booktitle> Fundamentals of Computer Algorithms. Computer Software Engineering Series. </booktitle> <publisher> Computer Science Press, Inc., </publisher> <address> Potomac, Maryland, </address> <year> 1978. </year>
Reference-contexts: We do this by using precomputed results, the value of steps for all known peaks. This is an application of Bentley's space-for-time rule 2 "store precomputed results". (This strategy is classically called "dynamic programming" <ref> [3, Chapter 5] </ref>.) To see this as an instance of Bentley's strategy, one has to imagine that our search algorithms was originally recursive, checking the precomputed results on each call. This recursive process is then transformed to an iterative one (Bentley's procedure rule 4).
Reference: 4. <author> D. E. Knuth. </author> <title> Seminumerical Algorithms, </title> <booktitle> volume 2 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1969. </year> <month> 23 </month>
Reference-contexts: Algorithms and data structures for large precision integers were important practical considerations, because the searches went well past the usual 32 bit integers, and because the iterates exceed these limits quickly. For example, max value (159,487) = 17,202,377,752. Such algorithms and data structures are well known <ref> [4] </ref>. The benefits of the optimizations discussed in this section are summarized in Table 2. The speedup due to a particular optimization depends on the order in which optimizations are applied.
Reference: 5. <author> J. C. Lagarias. </author> <title> The 3x+1 problem and its generalizations. </title> <journal> The American Mathematical Monthly, </journal> <volume> 92(1) </volume> <pages> 3-23, </pages> <month> Jan. </month> <year> 1985. </year>
Reference-contexts: 1. Introduction The 3x + 1 problem concerns iterates of the following function: T (n) = (3n + 1)=2; if n 1 (mod 2), (1) which takes odd integers n to (3n + 1)=2 and even integers n to n=2 <ref> [5] </ref>. The 3x + 1 Conjecture asserts that, starting from any positive integer n, repeated iteration of this function eventually produces the value 1. This conjecture is apparently intractable. The iterates of T are simply defined. <p> We are interested in the behavior of these statistics as n varies. Many facts are known about them, see Lagarias <ref> [5] </ref>. A number of researchers have observed that if the input n is drawn randomly, say with the uniform distribution on an interval [1; N ], then these statistics appear to have nice limiting distributions as N approaches infinity (see, for example, Rawsthorne [10] and Wagon [11]). <p> The idea of looking at convergence between the trajectories of smaller numbers and the number in question is related to the Collatz graph discussed in <ref> [5] </ref>. Lemma 15 Let j and k be given so that 0 &lt; j &lt; k. If there is some m &gt; 0 such that H (m) (j) = k, then k cannot be a peak in steps or max value.
Reference: 6. <author> J. C. Lagarias and A. Weiss. </author> <title> The 3x + 1 problem: Two stochastic models. </title> <journal> Annals of Applied Probability, </journal> <volume> 2, </volume> <year> 1992. </year> <note> to appear. </note>
Reference-contexts: A number of researchers have observed that if the input n is drawn randomly, say with the uniform distribution on an interval [1; N ], then these statistics appear to have nice limiting distributions as N approaches infinity (see, for example, Rawsthorne [10] and Wagon [11]). Lagarias and Weiss <ref> [6] </ref> describe various random walk models intended to simulate 3x + 1 function iterates. Particularly interesting statistics concern the behavior of extreme values of these statistics as n varies, which we call peaks. <p> Unlike the peaks in steps, the maximum values reached by peaks in stopping time, , rarely repeat. See also Lagarias and Weiss for more detailed comparisons in a similar vein <ref> [6] </ref>. 2. Small Scale Design Issues This section describes algorithms for iterating H and T . Another issue of practical importance, how to efficiently distribute the search among several computers, will not be discussed in this paper (see [7]). A fundamental observation is that peaks are extremely rare.
Reference: 7. <author> G. T. Leavens. </author> <title> A distributed search program for the 3x + 1 problem. </title> <type> Technical Report 89-22, </type> <institution> Iowa State University, Department of Computer Science, Ames, Iowa, </institution> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: Small Scale Design Issues This section describes algorithms for iterating H and T . Another issue of practical importance, how to efficiently distribute the search among several computers, will not be discussed in this paper (see <ref> [7] </ref>). A fundamental observation is that peaks are extremely rare. For example, in the first 50 billion positive integers, there are only 49 peaks in max value and only 78 peaks in steps. <p> Finally, we also used his procedure rule 5 "parallelism" extensively, although we did not discuss that aspect of our programs in Section 2., see <ref> [7] </ref>. A final conclusion is that even with the ability to distribute the search programs on many fairly fast computers, and even with the ability to run such programs for years (literally), algorithmic improvements are necessary to achieve interesting results.
Reference: 8. <author> B. Liskov, M. Day, M. Herlihy, P. Johnson, G. Leavens, R. Scheifler, and W. Weihl. </author> <title> Argus reference manual. </title> <type> Technical Report 400, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> Oct. </month> <year> 1987. </year> <note> An earlier version appeared as Programming Methodology Group Memo 54 in March 1987. </note>
Reference-contexts: Each author developed a program, and so many of our results have been validated by more than one program. The first program (by Leavens) designed to experiment with the Argus distributed programming language and system [9] <ref> [8] </ref>. A second program (by Vermeulen) was written in C, to understand the inherent costs of Argus as opposed to C. Various distributed programs have been running since 1986, although only Vermeulen's program is currently running. <p> Thus these trajectories must be computed efficiently. The hailstone algorithm in Figure 1, which finds the values of steps (n) and max value (n) is coded in Argus <ref> [8] </ref>. This algorithm is does not save the entire H-trajectory of n, but just records the values of the statistics. (In the code % starts a comment, // is a modulo operator and ~= means "not equal".
Reference: 9. <author> B. Liskov and R. Scheifler. </author> <title> Guardians and actions: Linguistic support for robust, distributed programs. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 5(3) </volume> <pages> 381-404, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: Each author developed a program, and so many of our results have been validated by more than one program. The first program (by Leavens) designed to experiment with the Argus distributed programming language and system <ref> [9] </ref> [8]. A second program (by Vermeulen) was written in C, to understand the inherent costs of Argus as opposed to C. Various distributed programs have been running since 1986, although only Vermeulen's program is currently running.
Reference: 10. <author> D. Rawsthorne. </author> <title> Imitation of an iteration. </title> <journal> Mathematics Magazine, </journal> <volume> 58(3) </volume> <pages> 172-176, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: A number of researchers have observed that if the input n is drawn randomly, say with the uniform distribution on an interval [1; N ], then these statistics appear to have nice limiting distributions as N approaches infinity (see, for example, Rawsthorne <ref> [10] </ref> and Wagon [11]). Lagarias and Weiss [6] describe various random walk models intended to simulate 3x + 1 function iterates. Particularly interesting statistics concern the behavior of extreme values of these statistics as n varies, which we call peaks.
Reference: 11. <author> S. Wagon. </author> <title> The collatz problem. </title> <journal> Mathematical Intelligencer, </journal> <volume> 7(1) </volume> <pages> 72-76, </pages> <year> 1985. </year>
Reference-contexts: A number of researchers have observed that if the input n is drawn randomly, say with the uniform distribution on an interval [1; N ], then these statistics appear to have nice limiting distributions as N approaches infinity (see, for example, Rawsthorne [10] and Wagon <ref> [11] </ref>). Lagarias and Weiss [6] describe various random walk models intended to simulate 3x + 1 function iterates. Particularly interesting statistics concern the behavior of extreme values of these statistics as n varies, which we call peaks.
References-found: 11

