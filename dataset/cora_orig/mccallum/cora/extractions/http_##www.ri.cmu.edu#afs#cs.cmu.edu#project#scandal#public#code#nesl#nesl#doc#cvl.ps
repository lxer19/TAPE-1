URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/scandal/public/code/nesl/nesl/doc/cvl.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/scandal/public/code/nesl/nesl/doc/
Root-URL: 
Title: Cvl: A C Vector Library Manual Version 2.1  
Author: Guy E. Blelloch Siddhartha Chatterjee Jonathan C. Hardwick Margaret Reid-Miller Jay Sipelstein Marco Zagha 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: June 1995  (Revised)  
Pubnum: CMU-CS-93-114  
Abstract: Cvl is a library of low-level vector routines callable from C. This library includes a wide variety of vector operations such as elementwise function applications, scans, reduces and permutations. Most Cvl routines are defined for segmented and unsegmented vectors. This paper is intended for Cvl users and implementors, and assumes familiarity with vector operations and the scan-vector model of parallel computation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Guy E. Blelloch. </author> <title> Vector Models for Data-Parallel Computing. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Cvl includes a rich set of vector operations including both elementwise computations, and more global operations such as scans, reductions, and permutations. The library also includes segmented versions of these global operations; segmented operations are crucial for the implementation of nested data-parallel languages <ref> [1, 7, 4] </ref>. The vector machine model provided by Cvl is very low-level and was designed so that efficient versions of the library could be developed for a wide variety of parallel architectures. <p> This paper is intended for Cvl users and implementors. We also assume familiarity with vector operations and the scan-vector model of parallel computation <ref> [1] </ref>. Because of its intended audience and the low-level nature of the Cvl abstractions, this paper has lots of grungy details that would probably not be interesting to a casual reader. <p> We strongly urge the reader to read the Nesl implementation paper [4], in order to understand the context in which Cvl was designed. A high-level description of the vector operations provided by Cvl can be found either in Blelloch's thesis <ref> [1] </ref> or in the published descriptions of Vcode [3, 6]. Low-level details on how scans and segmented operations can be efficiently implemented on vector machines are also available [8]. 2 Cvl Cvl is a C library implementing a variety of vector operations on elements of a homogeneous vector memory. <p> Cvl is low-level and has (at best) minimal error detection; failure to use the correct function may lead to unpredictable results or compile- or run-time failures. There are two varieties of Cvl vectors: segmented and unsegmented <ref> [1] </ref>. An unsegmented vector is a standard vector: a one-dimensional data structure containing elements of the same type. A segmented vector is a data structure consisting of a group of vectors of the same element type.
Reference: [2] <author> Guy E. Blelloch. NESL: </author> <title> A nested data-parallel language (version 2.6). </title> <type> Technical Report CMU-CS-93-129, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: This allows Cvl to be used as an efficient stand-alone library. Cvl was designed to provide a vector abstraction that can be used for the implementation of higher-level data-parallel languages. The authors have designed and implemented the nested data-parallel language Nesl <ref> [2] </ref>. This language compiles into an intermediate language, Vcode [3, 6], which is then interpreted. The interpreter uses Cvl to implement the required vector routines.

Reference: [4] <author> Guy E. Blelloch, Siddhartha Chatterjee, Jonathan C. Hardwick, Jay Sipelstein, and Marco Zagha. </author> <title> Implementation of a portable nested data-parallel language. </title> <booktitle> In Proceedings 4th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 102-111, </pages> <address> San Diego, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Cvl includes a rich set of vector operations including both elementwise computations, and more global operations such as scans, reductions, and permutations. The library also includes segmented versions of these global operations; segmented operations are crucial for the implementation of nested data-parallel languages <ref> [1, 7, 4] </ref>. The vector machine model provided by Cvl is very low-level and was designed so that efficient versions of the library could be developed for a wide variety of parallel architectures. <p> Because of its intended audience and the low-level nature of the Cvl abstractions, this paper has lots of grungy details that would probably not be interesting to a casual reader. We strongly urge the reader to read the Nesl implementation paper <ref> [4] </ref>, in order to understand the context in which Cvl was designed. A high-level description of the vector operations provided by Cvl can be found either in Blelloch's thesis [1] or in the published descriptions of Vcode [3, 6].
Reference: [5] <author> Guy E. Blelloch, Siddhartha Chatterjee, Jonathan C. Hardwick, Jay Sipelstein, and Marco Zagha. </author> <title> Implementation of a portable nested data-parallel language. </title> <type> Technical Report CMU-CS-93-112, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: It is the responsibility of programs using Cvl to break up the block returned by alo_foz into pieces for storing individual vectors. One way of doing this, used in an interpreter for Vcode, is described in <ref> [5] </ref>. Cvl instructions generally take handles to all their source and destination vectors. In addition, there is a length argument for each vector (except when several arguments are required to have the same length), and a segment descriptor argument for each segmented operand.
Reference: [6] <author> Guy E. Blelloch, Siddhartha Chatterjee, Fritz Knabe, Jay Sipelstein, and Marco Zagha. </author> <title> VCODE reference manual (version 1.1). </title> <type> Technical Report CMU-CS-90-146, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Cvl was designed to provide a vector abstraction that can be used for the implementation of higher-level data-parallel languages. The authors have designed and implemented the nested data-parallel language Nesl [2]. This language compiles into an intermediate language, Vcode <ref> [3, 6] </ref>, which is then interpreted. The interpreter uses Cvl to implement the required vector routines. <p> We strongly urge the reader to read the Nesl implementation paper [4], in order to understand the context in which Cvl was designed. A high-level description of the vector operations provided by Cvl can be found either in Blelloch's thesis [1] or in the published descriptions of Vcode <ref> [3, 6] </ref>. Low-level details on how scans and segmented operations can be efficiently implemented on vector machines are also available [8]. 2 Cvl Cvl is a C library implementing a variety of vector operations on elements of a homogeneous vector memory.
Reference: [7] <author> Guy E. Blelloch and Gary W. Sabot. </author> <title> Compiling collection-oriented languages onto massively parallel computers. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 8(2) </volume> <pages> 119-134, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: Cvl includes a rich set of vector operations including both elementwise computations, and more global operations such as scans, reductions, and permutations. The library also includes segmented versions of these global operations; segmented operations are crucial for the implementation of nested data-parallel languages <ref> [1, 7, 4] </ref>. The vector machine model provided by Cvl is very low-level and was designed so that efficient versions of the library could be developed for a wide variety of parallel architectures.
Reference: [8] <author> Siddhartha Chatterjee, Guy E. Blelloch, and Marco Zagha. </author> <title> Scan primitives for vector computers. </title> <booktitle> In Proceedings Supercomputing '90, </booktitle> <pages> pages 666-675, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: A high-level description of the vector operations provided by Cvl can be found either in Blelloch's thesis [1] or in the published descriptions of Vcode [3, 6]. Low-level details on how scans and segmented operations can be efficiently implemented on vector machines are also available <ref> [8] </ref>. 2 Cvl Cvl is a C library implementing a variety of vector operations on elements of a homogeneous vector memory. This vector memory should be viewed as distinct from the standard C heap or stack, and should only be accessed and modified through the Cvl routines.
Reference: [9] <author> Johan Fagerstrom, Peter Fritzson, Johan Ringstrom, and Mikael Pettersson. </author> <title> A data-parallel language and its compilation to a formally defined intermediate language. </title> <booktitle> In Proceedings Fourth International Conference on Computing and Information, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: The interpreter uses Cvl to implement the required vector routines. In addition to our work, a research group at Linkoping University in Sweden has targeted Vcode and Cvl as compiler backends for the Predula parallel language <ref> [9] </ref>, and researchers at the University of North Carolina, Chapel Hill, have targeted Cvl for the data-parallel portion of the Proteus [12, 13] language. This paper is intended for Cvl users and implementors. We also assume familiarity with vector operations and the scan-vector model of parallel computation [1].
Reference: [10] <author> Rickard E. Faith, Doug L. Hoffman, and David G. Stahl. UnCvl: </author> <title> The University of North Carolina C Vector Library. </title> <note> Version 1.1, </note> <month> May </month> <year> 1993. </year>
Reference-contexts: Currently, optimized versions of the library are available for the Connection Machine CM-2 and CM-5, and the Cray Y-MP and Y-MP/C90. We and others are developing versions for the MASPAR MP-1 <ref> [10] </ref> and for a network of workstations communicating with PVM [11]. There is also a portable serial version of the library. Many of the primitives provided by the library (in particular the scan operations) are much faster than could be easily achieved with Fortran or C implementations on these machines.
Reference: [11] <author> Al Geist, Adam Beguelin, Jack Dongarra, Weicheng Jiang, Robert Manchek, and Vaidy Sun-deram. </author> <title> PVM 3.0 User's Guide and Refernce Manual, </title> <month> February </month> <year> 1993. </year>
Reference-contexts: Currently, optimized versions of the library are available for the Connection Machine CM-2 and CM-5, and the Cray Y-MP and Y-MP/C90. We and others are developing versions for the MASPAR MP-1 [10] and for a network of workstations communicating with PVM <ref> [11] </ref>. There is also a portable serial version of the library. Many of the primitives provided by the library (in particular the scan operations) are much faster than could be easily achieved with Fortran or C implementations on these machines.
Reference: [12] <author> Peter H. Mills, Lars S. Nyland, Jan F. Prins, John H. Reif, and Robert A. Wagner. </author> <title> Prototyping parallel and distributed programs in Proteus. </title> <type> Technical Report UNC-CH TR90-041, </type> <institution> Computer Science Department, University of North Carolina, </institution> <year> 1990. </year>
Reference-contexts: In addition to our work, a research group at Linkoping University in Sweden has targeted Vcode and Cvl as compiler backends for the Predula parallel language [9], and researchers at the University of North Carolina, Chapel Hill, have targeted Cvl for the data-parallel portion of the Proteus <ref> [12, 13] </ref> language. This paper is intended for Cvl users and implementors. We also assume familiarity with vector operations and the scan-vector model of parallel computation [1].
Reference: [13] <author> Jan F. Prins and Daniel W. Palmer. </author> <title> Transforming high-level data-parallel programs into vector operations. </title> <booktitle> In Proceedings 4th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 119-128, </pages> <month> May </month> <year> 1993. </year> <month> 15 </month>
Reference-contexts: In addition to our work, a research group at Linkoping University in Sweden has targeted Vcode and Cvl as compiler backends for the Predula parallel language [9], and researchers at the University of North Carolina, Chapel Hill, have targeted Cvl for the data-parallel portion of the Proteus <ref> [12, 13] </ref> language. This paper is intended for Cvl users and implementors. We also assume familiarity with vector operations and the scan-vector model of parallel computation [1].
References-found: 12

