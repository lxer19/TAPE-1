URL: http://www.cs.wustl.edu/~schmidt/JSAC-98.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/tri-dove.html
Root-URL: 
Email: fharrison,coryan,levine,schmidtg@cs.wustl.edu  
Title: The Design and Performance of a Real-time CORBA Event Service  
Author: Timothy H. Harrison, Carlos O'Ryan, David L. Levine, and Douglas C. Schmidt 
Keyword: Real-time CORBA event systems, object-oriented communication frameworks.  
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science, Washington University  
Abstract: This paper has been submitted to the IEEE Journal on Selected Areas in Communications special issue on Service Enabling Platforms for Networked Multimedia Systems. Abstract The CORBA Event Service provides a flexible model for asynchronous and group communication among distributed and collocated objects. However, the standard CORBA Event Service specification lacks important features required by applications with real-time requirements, such as low latency, predictability, event filtering, priority, and event correlation. This paper describes the design and performance of an object-oriented, real-time implementation of the CORBA Event Service that is designed to meet these requirements. This paper makes four contributions to the design and performance measurement of object-oriented real-time systems. First, it illustrates how to extend the CORBA Event Service so that it is suitable for real-time systems. These extensions support low latency, periodic rate-based event processing and efficient event filtering and correlation. Second, it describes how to develop object-oriented event dispatching and scheduling mechanisms that can provide real-time guarantees. Third, it describes how to distribute the Event Service effectively and provide low latency for collocated suppliers/consumers. Finally, the paper presents benchmarks that empirically demonstrate the predictability, low latency, and high utilization of our real-time Event Service. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.2 ed., </editor> <month> Feb. </month> <year> 1998. </year>
Reference-contexts: many real-time application fl This work was funded in part by Boeing, NSF grant NCR-9628218, and DARPA contract 9701516. domains, such as avionics, telecommunications, process control, and distributed interactive simulation, can leverage the benefits of flexible and open distributed object computing architectures, such as those defined in the CORBA specification <ref> [1] </ref>. If these architectures can be implemented in an efficient and predictable manner, then their benefits make them very compelling for real-time systems. In this paper, we describe the design and performance of a real-time Event Service, which is a key CORBA-based architecture for push-driven real-time event systems.
Reference: [2] <author> T. H. Harrison, D. L. Levine, and D. C. Schmidt, </author> <title> The Design and Performance of a Real-time CORBA Event Service, </title> <booktitle> in Proceedings of OOPSLA '97, </booktitle> <address> (Atlanta, GA), </address> <publisher> ACM, </publisher> <month> October </month> <year> 1997. </year>
Reference-contexts: Our results desmonstrate that the efficiency and predictability of our real-time Event Service is sufficient for applications in the domain of real-time systems such as avionics mission computing <ref> [2] </ref> and high-speed network monitoring [3]. This paper also empirically evaluates the dynamic binding properties of OO programming languages like C++. Historically, dynamic binding has been viewed as antithetical to real-time systems, which require deterministic execution behavior and low latency. <p> Our prior work on CORBA explored several dimensions of real-time ORB endsystem design including real-time scheduling [5], real-time request demultiplexing [6], real-time I/O subsystem integration [7], and real-time concurrency and connection architectures [8]. This paper extends our previous work <ref> [2] </ref> on real-time extensions to the CORBA Event Service by showing how to distribute the Event Service without incurring extra overhead for collocated supplier/consumer pairs and presenting benchmarks for a federated Event Service configuration. 2.2 Synopsis of the CORBA Event Service Many distributed applications exchange asynchronous requests using event-based execution models <p> TAO's Off-line Scheduler initially implements the rate monotonic scheduling policy. Section 5 illustrates how adding new dispatching implementations is straightforward since this module is well-encapsulated from other components in the Event Channel's OO real-time event dispatching framework. 4.3 Federated Event Channels The original implementation of TAO's RT Event Channel <ref> [2] </ref> was limited to a single processor configuration. However, modern avionics hardware typically comprises several processor boards connected through a high-speed interconnect, such as a fiber channel network or a VME bus. <p> Therefore, object operations with higher priorities will preempt object operations with lower priorities. These priority values are computed by the Off-line Scheduler and are stored in a table that is queried by the Run-time Scheduler at execution time. 6 Performance Tests In our previous work <ref> [2] </ref> we benchmarked the utilization of a single processor prototype of TAO's real-time Event Service. In the following sections, we extend these benchmarks to to illustrate how performance is not affected by a complete ORB and RT Event Channel implementation.
Reference: [3] <author> G. Parulkar, D. C. Schmidt, E. Kraemer, J. Turner, and A. Kantawala, </author> <title> An Architecture for Monitoring, Visualization, and Control and Gigabit Networks, </title> <journal> IEEE Network, </journal> <volume> vol. 11, </volume> <month> September/October </month> <year> 1997. </year>
Reference-contexts: Our results desmonstrate that the efficiency and predictability of our real-time Event Service is sufficient for applications in the domain of real-time systems such as avionics mission computing [2] and high-speed network monitoring <ref> [3] </ref>. This paper also empirically evaluates the dynamic binding properties of OO programming languages like C++. Historically, dynamic binding has been viewed as antithetical to real-time systems, which require deterministic execution behavior and low latency.
Reference: [4] <author> S. Vinoski, </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments, </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 14, </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: Reference Model architecture <ref> [4] </ref>. At the heart of the OMG Reference Model is the Object Request Broker (ORB). <p> CORBA ORBs allow clients to invoke operations on target object implementations without concern for where the object resides, what language the object is written in, the OS/hardware platform, or the type of communication protocols and networks used to interconnect distributed objects <ref> [4] </ref>. Our prior work on CORBA explored several dimensions of real-time ORB endsystem design including real-time scheduling [5], real-time request demultiplexing [6], real-time I/O subsystem integration [7], and real-time concurrency and connection architectures [8].
Reference: [5] <author> D. C. Schmidt, D. L. Levine, and S. Mungee, </author> <title> The Design and Performance of Real-Time Object Request Brokers, </title> <journal> Computer Communications, </journal> <volume> vol. 21, </volume> <pages> pp. 294324, </pages> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: Our prior work on CORBA explored several dimensions of real-time ORB endsystem design including real-time scheduling <ref> [5] </ref>, real-time request demultiplexing [6], real-time I/O subsystem integration [7], and real-time concurrency and connection architectures [8]. <p> To alleviate the limitations with the standard CORBA Event Service, we have developed a Real-time Event Service (RT Event Service) as part of the TAO project <ref> [5] </ref> at Washington University. TAO is a real-time ORB endsystem that provides end-to-end quality of service guarantees to applications by vertically integrating CORBA middleware with OS I/O subsystems, communication protocols, and network interfaces. and their relationship to the real-time Event Service. <p> This functionality is implemented using TAO's real-time dispatching mechanism that coordinates with its system-wide real-time Scheduling Service <ref> [5] </ref>. TAO's RT Event Service runs on real-time OS platforms such as VxWorks, LynxOS, and CHORUS/ClassiX, which provide features and performance suited to real-time systems. <p> However, QoS research at the network and OS layers has not necessarily addressed key requirements and usage characteristics of distributed object computing middleware <ref> [5] </ref>. For instance, research on QoS for network infrastructure has focused largely on policies for allocating bandwidth on a per-connection basis. Likewise, research on real-time operating systems has focused largely on avoiding priority inversions and non-determinism in synchronization and scheduling mechanisms. <p> Our approach is based on emerging distributed object computing standards like OMG CORBA ORBs we focus on the design and performance of various strategies for implementing QoS in real-time ORBs <ref> [5] </ref>. The QuO project at BBN [24] has defined a model for communicating changes in QoS characteristics between applications, middleware, and the underlying endsystems and network. <p> Chief among these missing features include real-time event dispatching and scheduling, periodic event processing, and centralized event filtering and correlations. To resolve these limitations, we have developed a Real-time Event Service (RT Event Service) as part of the TAO project <ref> [5] </ref>. TAO's RT Event Service extends the COS Event Service specification to satisfy the quality of service (QoS) needs of real-time applications in domains like avionics, telecommunications, and process control. <p> As a result, TAO's RT Event Channel utilizes a real-time Scheduling Service <ref> [5] </ref> to ensure that events are processed before deadlines are missed. Most real-time scheduling policies, such as rate monotonic and earliest deadline first (EDF), require priority-based event dispatching and preemption. <p> In general, our results illustrate that it is feasible to apply CORBA Object Services to develop real-time systems. The implementation of TAO's Real-time Event Service described in this paper is written in C++ as one of the services in TAO <ref> [5] </ref>. TAO is a real-time implementation of CORBA based on the ACE framework [28]. ACE is a widely used communication framework that contains a rich set of high-performance and real-time reusable software components.
Reference: [6] <author> A. Gokhale and D. C. Schmidt, </author> <title> Evaluating the Performance of Demultiplexing Strategies for Real-time CORBA, </title> <booktitle> in Proceedings of GLOBECOM '97, </booktitle> <address> (Phoenix, AZ), </address> <publisher> IEEE, </publisher> <month> November </month> <year> 1997. </year>
Reference-contexts: Our prior work on CORBA explored several dimensions of real-time ORB endsystem design including real-time scheduling [5], real-time request demultiplexing <ref> [6] </ref>, real-time I/O subsystem integration [7], and real-time concurrency and connection architectures [8].
Reference: [7] <author> D. C. Schmidt, R. Bector, D. Levine, S. Mungee, and G. Parulkar, </author> <title> An ORB Endsystem Architecture for Statically Scheduled Real-time Applications, </title> <booktitle> in Proceedings of the Workshop on Middleware for Real-Time Systems and Services, </booktitle> <address> (San Francisco, CA), </address> <publisher> IEEE, </publisher> <month> December </month> <year> 1997. </year>
Reference-contexts: Our prior work on CORBA explored several dimensions of real-time ORB endsystem design including real-time scheduling [5], real-time request demultiplexing [6], real-time I/O subsystem integration <ref> [7] </ref>, and real-time concurrency and connection architectures [8].
Reference: [8] <author> D. C. Schmidt, S. Mungee, S. Flores-Gaitan, and A. Gokhale, </author> <title> Alleviating Priority Inversion and Non-determinism in Real-time CORBA ORB Core Architectures, </title> <booktitle> in Proceedings of the Fourth IEEE Real-Time Technology and Applications Symposium, </booktitle> <address> (San Francisco, CA), </address> <publisher> IEEE, </publisher> <month> December </month> <year> 1997. </year>
Reference-contexts: Our prior work on CORBA explored several dimensions of real-time ORB endsystem design including real-time scheduling [5], real-time request demultiplexing [6], real-time I/O subsystem integration [7], and real-time concurrency and connection architectures <ref> [8] </ref>.
Reference: [9] <author> R. Rajkumar, M. Gagliardi, and L. Sha, </author> <title> The Real-Time Publisher/Subscriber Inter-Process Communication Model for Distributed Real-Time Systems: </title> <booktitle> Design and Implementation, in First IEEE Real-Time Technology and Applications Symposium, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: on real-time extensions to the CORBA Event Service by showing how to distribute the Event Service without incurring extra overhead for collocated supplier/consumer pairs and presenting benchmarks for a federated Event Service configuration. 2.2 Synopsis of the CORBA Event Service Many distributed applications exchange asynchronous requests using event-based execution models <ref> [9] </ref>. To support these common use-cases, the OMG defined a CORBA Event Service component in the CORBA Object Services (COS) layer in Figure 1. The COS specification [10] presents architectural models and interfaces that factor out common services for developing distributed applications. <p> As with QuO, the focus of this work is not on guaranteeing CPU processing for events with hard real-time deadlines. Rajkumar, et al., describe a real-time publisher/subscriber prototype developed at CMU SEI <ref> [9] </ref>. Their Publisher/Subscriber model is functionally similar to the COS Event Service, though it uses real-time threads to prevent priority inversion within the communication framework.
Reference: [10] <institution> Object Management Group, </institution> <month> CORBAServices: </month> <title> Common Object Services Specification, </title> <note> Revised Edition, </note> <editor> 95-3-31 ed., </editor> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: To support these common use-cases, the OMG defined a CORBA Event Service component in the CORBA Object Services (COS) layer in Figure 1. The COS specification <ref> [10] </ref> presents architectural models and interfaces that factor out common services for developing distributed applications. The CORBA Event Service defines supplier and consumer participants. Suppliers generate events and consumers process events received from suppliers.
Reference: [11] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The CORBA Event Service defines supplier and consumer participants. Suppliers generate events and consumers process events received from suppliers. In addition, the CORBA Event Service defines an Event Channel, which is a mediator <ref> [11] </ref> that propagates events to consumers on behalf of suppliers. The CORBA Event Service model simplifies application software by allowing decoupled suppliers and consumers, asynchronous event delivery, and distributed group communication [12]. In theory, this model seems to address many common needs of event-based, real-time applications. <p> The benefit of using the Event Channel is that Sensor Proxies are unaffected when I/O 5 Facades are added or removed. This architectural decoupling is described concisely by the Observer pattern <ref> [11] </ref>. Another benefit of an Event Channel-based architecture is that an I/O Facade need not know which Sensor Proxies supply its data.
Reference: [12] <author> S. Maffeis, </author> <title> Adding Group Communication and Fault-Tolerance to CORBA, </title> <booktitle> in Proceedings of the Conference on Object-Oriented Technologies, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: In addition, the CORBA Event Service defines an Event Channel, which is a mediator [11] that propagates events to consumers on behalf of suppliers. The CORBA Event Service model simplifies application software by allowing decoupled suppliers and consumers, asynchronous event delivery, and distributed group communication <ref> [12] </ref>. In theory, this model seems to address many common needs of event-based, real-time applications. In practice, however, the standard CORBA Event Service specification lacks other important features required by real-time applications such as real-time event dispatching and scheduling, periodic event processing, and efficient event filtering and correlation mechanisms.
Reference: [13] <author> C. Liu and J. Layland, </author> <title> Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment, </title> <journal> JACM, </journal> <volume> vol. 20, </volume> <pages> pp. 4661, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: TAO's RT Event Service augments the CORBA Event Service model by providing source-based and type-based filtering, event correlations, and real-time dispatching. To facilitate real-time scheduling policies, such as rate monotonic (RMS) <ref> [13] </ref> and maximum urgency first (MUF) [14], TAO's RT Event Channels can be configured to support various strategies for priority-based event dispatching and preemption. This functionality is implemented using TAO's real-time dispatching mechanism that coordinates with its system-wide real-time Scheduling Service [5]. <p> General-purpose operating systems like Windows NT and So-laris 2.x also provide real-time threads, though they lack cer tain features required for hard real-time systems [15, 16]. 2 2.3 Related Work Conventional approaches to quality of service (QoS) enforcement have typically adopted existing solutions from the domain of real-time scheduling, <ref> [13] </ref>, fair queuing in network routers [17], or OS support for continuous media applications [18]. In addition, there have been efforts to implement new concurrency mechanisms for real-time processing, such as the real-time threads of Mach [19] and real-time CPU scheduling priorities of Solaris [16]. <p> Once task interdependency compilation is complete, the Off-line Scheduler assigns priorities to each object operation. The implementation of the Event Service described in this paper utilizes a rate monotonic scheduling policy <ref> [13, 33] </ref>. Therefore, priorities are assigned based on task rates, i.e., higher priorities are assigned to threads with faster rates.
Reference: [14] <author> D. B. Stewart, D. E. Schmitz, and P. K. Khosla, </author> <title> Implementing Real-Time Robotic Systems using CHIMERA II, </title> <booktitle> in Proceedings of 1990 IEEE International Conference on Robotics and Automation, </booktitle> <address> (Cincinnatti, OH), </address> <year> 1992. </year> <month> 19 </month>
Reference-contexts: TAO's RT Event Service augments the CORBA Event Service model by providing source-based and type-based filtering, event correlations, and real-time dispatching. To facilitate real-time scheduling policies, such as rate monotonic (RMS) [13] and maximum urgency first (MUF) <ref> [14] </ref>, TAO's RT Event Channels can be configured to support various strategies for priority-based event dispatching and preemption. This functionality is implemented using TAO's real-time dispatching mechanism that coordinates with its system-wide real-time Scheduling Service [5].
Reference: [15] <author> M. Timmerman and J.-C. Monfret, </author> <title> Windows NT as Real-Time OS?, Real-Time Magazine, </title> <note> 2Q 1997. http://www.realtime-info.be/encyc/magazine/97q2/winntasrtos.htm. </note>
Reference-contexts: TAO's RT Event Service runs on real-time OS platforms such as VxWorks, LynxOS, and CHORUS/ClassiX, which provide features and performance suited to real-time systems. General-purpose operating systems like Windows NT and So-laris 2.x also provide real-time threads, though they lack cer tain features required for hard real-time systems <ref> [15, 16] </ref>. 2 2.3 Related Work Conventional approaches to quality of service (QoS) enforcement have typically adopted existing solutions from the domain of real-time scheduling, [13], fair queuing in network routers [17], or OS support for continuous media applications [18].
Reference: [16] <author> S. Khanna and et. al., </author> <title> Realtime Scheduling in SunOS 5.0, </title> <booktitle> in Proceedings of the USENIX Winter Conference, </booktitle> <pages> pp. 375390, </pages> <publisher> USENIX Association, </publisher> <year> 1992. </year>
Reference-contexts: TAO's RT Event Service runs on real-time OS platforms such as VxWorks, LynxOS, and CHORUS/ClassiX, which provide features and performance suited to real-time systems. General-purpose operating systems like Windows NT and So-laris 2.x also provide real-time threads, though they lack cer tain features required for hard real-time systems <ref> [15, 16] </ref>. 2 2.3 Related Work Conventional approaches to quality of service (QoS) enforcement have typically adopted existing solutions from the domain of real-time scheduling, [13], fair queuing in network routers [17], or OS support for continuous media applications [18]. <p> In addition, there have been efforts to implement new concurrency mechanisms for real-time processing, such as the real-time threads of Mach [19] and real-time CPU scheduling priorities of Solaris <ref> [16] </ref>. However, QoS research at the network and OS layers has not necessarily addressed key requirements and usage characteristics of distributed object computing middleware [5]. For instance, research on QoS for network infrastructure has focused largely on policies for allocating bandwidth on a per-connection basis. <p> In both tests, there was no other significant activity on the workstation during the benchmark-ing. All tests were run in the Solaris real-time scheduling class so they had the highest software priority (but below hardware interrupts) <ref> [16] </ref>. In the single process case, we determined the best-case supplier-to-consumer latency was ~60 secs. In each case, as the number of suppliers and/or consumers increased, the latency increased as well, as shown in Table 1 and Table 2.
Reference: [17] <author> L. Zhang, </author> <title> Virtual Clock: A New Traffic Control Algorithm for Packet Switched Networks, </title> <booktitle> in Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), </booktitle> <address> (Philadelphia, PA), </address> <pages> pp. </pages> <year> 1929, </year> <note> ACM, </note> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: NT and So-laris 2.x also provide real-time threads, though they lack cer tain features required for hard real-time systems [15, 16]. 2 2.3 Related Work Conventional approaches to quality of service (QoS) enforcement have typically adopted existing solutions from the domain of real-time scheduling, [13], fair queuing in network routers <ref> [17] </ref>, or OS support for continuous media applications [18]. In addition, there have been efforts to implement new concurrency mechanisms for real-time processing, such as the real-time threads of Mach [19] and real-time CPU scheduling priorities of Solaris [16].
Reference: [18] <author> G. Coulson, G. Blair, J.-B. Stefani, F. Horn, and L. </author> <title> Hazard, Supporting the Real-time Requirements of Continuous Media in Open Distributed Processing, </title> <booktitle> Computer Networks and ISDN Systems, </booktitle> <pages> pp. 12311246, </pages> <year> 1995. </year>
Reference-contexts: though they lack cer tain features required for hard real-time systems [15, 16]. 2 2.3 Related Work Conventional approaches to quality of service (QoS) enforcement have typically adopted existing solutions from the domain of real-time scheduling, [13], fair queuing in network routers [17], or OS support for continuous media applications <ref> [18] </ref>. In addition, there have been efforts to implement new concurrency mechanisms for real-time processing, such as the real-time threads of Mach [19] and real-time CPU scheduling priorities of Solaris [16].
Reference: [19] <author> H. Tokuda, T. Nakajima, and P. Rao, </author> <title> Real-Time Mach: Towards Predictable Real-time Systems, </title> <booktitle> in USENIX Mach Workshop, USENIX, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: In addition, there have been efforts to implement new concurrency mechanisms for real-time processing, such as the real-time threads of Mach <ref> [19] </ref> and real-time CPU scheduling priorities of Solaris [16]. However, QoS research at the network and OS layers has not necessarily addressed key requirements and usage characteristics of distributed object computing middleware [5].
Reference: [20] <institution> Object Management Group, Notification Service Request For Proposal, OMG Document telecom/97-01-03 ed., </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: Since the CORBA Event Service specification does not address issues critical for real-time applications, however, the QoS behavior of these implementations are not acceptable solutions for many application domains. The OMG has issued a request for proposals (RFP) on a new Notification Service <ref> [20] </ref> that has generated several responses [21].
Reference: [21] <institution> Object Management Group Telecommunications Domain Task Force, Notification Service RFP (Telecom RFP3), </institution> <year> 1997. </year>
Reference-contexts: Since the CORBA Event Service specification does not address issues critical for real-time applications, however, the QoS behavior of these implementations are not acceptable solutions for many application domains. The OMG has issued a request for proposals (RFP) on a new Notification Service [20] that has generated several responses <ref> [21] </ref>. The RFP specifies that a proposed Notification Service must be a superset of the COS Event Service with interfaces for the following features: event filtering, event delivery semantics, e.g., at least once, or at most once, security, event channel federations, and event delivery QoS.
Reference: [22] <author> D. C. Schmidt and S. Vinoski, </author> <title> Object Interconnections: Overcoming Drawbacks in the OMG Events Service, </title> <journal> C++ Report, </journal> <volume> vol. 9, </volume> <month> July-August </month> <year> 1997. </year>
Reference-contexts: The organizations contributing to this effort have done excellent work in addressing many of the shortcomings of the CORBA Event Service <ref> [22] </ref>. However, the OMG RFP documents do not address the implementation issues related to the Notification Service. Although there has been research on formalisms for real-time objects [23], relatively little published research on the design and performance of real-time OO systems exists.
Reference: [23] <author> I. Satoh and M. Tokoro, </author> <title> Time and Asynchrony in Interactions among Distributed Real-Time Objects, </title> <booktitle> in Proceedings of 9th European Conference on Object-Oriented Programming, </booktitle> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: The organizations contributing to this effort have done excellent work in addressing many of the shortcomings of the CORBA Event Service [22]. However, the OMG RFP documents do not address the implementation issues related to the Notification Service. Although there has been research on formalisms for real-time objects <ref> [23] </ref>, relatively little published research on the design and performance of real-time OO systems exists. Our approach is based on emerging distributed object computing standards like OMG CORBA ORBs we focus on the design and performance of various strategies for implementing QoS in real-time ORBs [5].
Reference: [24] <author> J. A. Zinky, D. E. Bakken, and R. Schantz, </author> <title> Architectural Support for Quality of Service for CORBA Objects, </title> <journal> Theory and Practice of Object Systems, </journal> <volume> vol. 3, no. 1, </volume> <year> 1997. </year>
Reference-contexts: Our approach is based on emerging distributed object computing standards like OMG CORBA ORBs we focus on the design and performance of various strategies for implementing QoS in real-time ORBs [5]. The QuO project at BBN <ref> [24] </ref> has defined a model for communicating changes in QoS characteristics between applications, middleware, and the underlying endsystems and network. The QuO architecture differs from our work on RT Event Channels, however, since QuO does not provide hard real-time guarantees of ORB endsystem CPU scheduling.
Reference: [25] <author> Y. Aahlad, B. Martin, M. Marathe, and C. Lee, </author> <title> Asynchronous Notification Among Distributed Objects, </title> <booktitle> in Proceedings of the 2 nd Conference on Object-Oriented Technologies and Systems, </booktitle> <institution> (Toronto, Canada), USENIX, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: The QuO architecture differs from our work on RT Event Channels, however, since QuO does not provide hard real-time guarantees of ORB endsystem CPU scheduling. Other research on the CORBA Event Service <ref> [25, 26] </ref> describe techniques for optimizing event service performance for filtering and message delivery. As with QuO, the focus of this work is not on guaranteeing CPU processing for events with hard real-time deadlines. Rajkumar, et al., describe a real-time publisher/subscriber prototype developed at CMU SEI [9].
Reference: [26] <author> C. Ma and J. Bacon, COBEA: </author> <title> A CORBA-Based Event Architecture, </title> <booktitle> in Proceedings of the 4 rd Conference on Object-Oriented Technologies and Systems, USENIX, </booktitle> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: The QuO architecture differs from our work on RT Event Channels, however, since QuO does not provide hard real-time guarantees of ORB endsystem CPU scheduling. Other research on the CORBA Event Service <ref> [25, 26] </ref> describe techniques for optimizing event service performance for filtering and message delivery. As with QuO, the focus of this work is not on guaranteeing CPU processing for events with hard real-time deadlines. Rajkumar, et al., describe a real-time publisher/subscriber prototype developed at CMU SEI [9].
Reference: [27] <author> A. Gokhale and D. C. Schmidt, </author> <title> The Performance of the CORBA Dynamic Invocation Interface and Dynamic Skeleton Interface over High-Speed ATM Networks, </title> <booktitle> in Proceedings of GLOBECOM '96, </booktitle> <address> (London, England), </address> <pages> pp. 5056, </pages> <publisher> IEEE, </publisher> <month> November </month> <year> 1996. </year>
Reference-contexts: Moreover, standard oneway invocations are not necessarily reliable and deferred synchronous invocations require the use of the CORBA Dynamic Invocation Interface (DII), which yields excessive overhead for most real-time applications <ref> [27] </ref>. The Event Service is a CORBA Object Service that is designed to alleviate some of the restrictions with standard CORBA invocation models. In particular, the COS Event Service supports asynchronous message delivery and allows one or more suppliers to send messages to one or more consumers.
Reference: [28] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: Internally, the channel is comprised of several processing modules based on the ACE Streams framework <ref> [28] </ref>. As described below, each module encapsulates independent tasks of the channel. 4.2.2 Consumer Proxy Module The interface to the Consumer Proxy Module is identical to ConsumerAdmin interface defined in the COS Event Service CosEventChannelAdmin module. It provides factory methods for creating objects that support the ProxyPushSupplier interface. <p> The implementation of TAO's Real-time Event Service described in this paper is written in C++ as one of the services in TAO [5]. TAO is a real-time implementation of CORBA based on the ACE framework <ref> [28] </ref>. ACE is a widely used communication framework that contains a rich set of high-performance and real-time reusable software components. These components automate common communication tasks such as connection establishment, event demultiplexing and event handler dispatching, message routing, dynamic configuration of services, and flexible concurrency control for network services.
Reference: [29] <author> D. C. Schmidt, D. L. Levine, and T. H. Harrison, </author> <title> An ORB Endsystem Architecture for Hard Real-Time Scheduling, </title> <month> Feb. </month> <year> 1997. </year> <note> Submitted to OMG in response to RFI ORBOS/96-09-02. </note>
Reference-contexts: Adding filtering to an Event Channel requires a well-defined event type system that includes source ID, type, data, and timestamp fields. The complete schema for this type system is beyond the scope of this paper (it is fully described in <ref> [29] </ref>). The RT Event Channel uses the event type system in the following ways: Supplier-based filtering: Not all consumers that connect to an Event Channel are interested in the same events. In this case, consumers only register for events generated by certain suppliers.
Reference: [30] <author> R. E. Barkley and T. P. Lee, </author> <title> A Heap-Based Callout Implementation to Meet Real-Time Needs, </title> <booktitle> in Proceedings of the USENIX Summer Conference, </booktitle> <pages> pp. 213222, </pages> <publisher> USENIX Association, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: When a consumer registers for a timeout, the Priority Timers Proxy cooperates with the Run-time Scheduler to ensure that timeouts are dispatched according to the priority of their corresponding consumer. The Priority Timers Proxy uses a heap-based callout queue <ref> [30] </ref> provided by ACE. Therefore, in the average and worst case, the time required to schedule, cancel, and expire a timer is O (log N) (where N is the total number of timers). The timer mechanism preallocates all its memory, which eliminates the need for dynamic memory allocation at run-time.
Reference: [31] <author> J.-B. Stefani, </author> <title> Requirements for a real-time ORB, </title> <type> tech. rep., ReTINA, </type> <year> 1996. </year>
Reference-contexts: In these contexts, it may be unacceptable to completely terminate a running Event Channel when a scheduling or concurrency policy is updated. In general, therefore, an RT Event Channel framework must support dynamic reconfiguration of policies without interruption while continuing to service communication operations <ref> [31] </ref>. Basing TAO's RT Event Channel on the ACE Streams framework supports both static and dynamic (re)configuration. 5 An Object-Oriented Framework for Real-time Event Service Dispatching and Scheduling Applications and middleware components using TAO's RT Event Service can have deterministic and/or statistical deadlines.
Reference: [32] <author> R. Gopalakrishnan and G. Parulkar, </author> <title> Bringing Real-time Scheduling Theory and Practice Closer for Multimedia Computing, </title> <booktitle> in SIGMETRICS Conference, </booktitle> <address> (Philadelphia, PA), </address> <publisher> ACM, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: This requires that consumers cooperatively preempt themselves when a higher priority consumer becomes runnable. This model of deferred preemption is based on a Real-time Upcall (RTU) concurrency mechanism <ref> [32] </ref>. The primary benefit of the RTU model is its ability to reduce the context switching, synchronization, and data movement overhead incurred by preemptive multi-threading implementations. However, preemption is deferred to the extent that consumers check to see if they must preempt themselves. <p> An important metric for evaluating the performance of the RT Event Service is the schedulable bound. The schedulable bound of a real-time schedule is the maximum resource utilization possible without deadlines being missed <ref> [32] </ref>. Likewise, the schedulable bound of the RT Event Service is the maximum CPU utilization that suppliers and consumers can achieve without missing deadlines. For TAO's Real-time Scheduling Service to guarantee the schedulability of a system, i.e., that all tasks meet their deadlines, high-priority tasks must preempt lower priority tasks.
Reference: [33] <author> M. H. Klein, T. Ralya, B. Pollak, R. Obenza, and M. G. Har-bour, </author> <title> A Practitioner's Handbook for Real-Time Analysis: Guide to Rate Monotonic Analysis for Real-Time Systems. </title> <publisher> Norwell, </publisher> <address> Massachusetts: </address> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Once task interdependency compilation is complete, the Off-line Scheduler assigns priorities to each object operation. The implementation of the Event Service described in this paper utilizes a rate monotonic scheduling policy <ref> [13, 33] </ref>. Therefore, priorities are assigned based on task rates, i.e., higher priorities are assigned to threads with faster rates.
Reference: [34] <author> A. Gokhale and D. C. Schmidt, </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks, </title> <booktitle> in Proceedings of SIGCOMM '96, </booktitle> <address> (Stanford, CA), </address> <pages> pp. 306317, </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: In particular, no extra overhead is incurred due to possible remote consumers. In contrast, the remote consumer performance is several times higher than the local events, though it is still close to the performance of a typical oneway RPC request <ref> [34] </ref>. 6.2.2 Minimal Event Spacing Results Another important performance metric is the minimum event spacing, i.e., the maximum rate at which the Event Channel can deliver messages before its overhead introduces extra la 16 Latency, sec First Consumer Last Consumer Sup. Con.
Reference: [35] <author> S. Porat, D. Bernstein, Y. Fedorov, J. Rodrigue, and E. Yahav, </author> <title> Compiler Optimization of C++ Virtual Function Calls, </title> <booktitle> in Proceedings of the 2 nd Conference on Object-Oriented Technologies and Systems, </booktitle> <institution> (Toronto, Canada), USENIX, </institution> <month> June </month> <year> 1996. </year> <month> 20 </month>
Reference-contexts: Our experience has been that this is not an impediment to real-time system performance, though we avoid virtual methods where not needed. Furthermore, modern compilers implement strategies for replacing indirect virtual method calls with direct non-virtual calls <ref> [35] </ref>. The results for the IRIX C++ and Microsoft VC++ compilers indicate well-optimized virtual method calls. 7.2 The Cost of Polymorphism Polymorphism facilitates run-time changes in object behavior. Real-time systems often require predictable behavior of all components.
References-found: 35

