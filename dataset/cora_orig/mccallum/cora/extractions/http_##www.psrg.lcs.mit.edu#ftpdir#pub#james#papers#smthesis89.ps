URL: http://www.psrg.lcs.mit.edu/ftpdir/pub/james/papers/smthesis89.ps
Refering-URL: http://www.psrg.lcs.mit.edu/~james/whoami.html
Root-URL: 
Title: Polymorphic Type Reconstruction  
Author: by James William O'Toole Jr. David K. Gifford Arthur C. Smith 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Master of Science at the  Signature of Author  Certified by  Associate Professor of Computer Science Thesis Supervisor Accepted by  Department Committee  
Note: c Massachusetts Institute of Technology  
Date: (December 1984)  May 1989  1989  May 22, 1989  
Affiliation: B.S., Computer Science University of Maryland  MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [Atkinson 78] <author> Russell R. Atkinson, Barbara H. Liskov, Robert W. Scheifler. </author> <title> Aspects of Implementing CLU. </title> <booktitle> ACM 1978 Annual Conference Proceedings, </booktitle> <month> December </month> <year> 1978. </year>
Reference: [Berendregt 84] <author> H. P. Berendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <year> 1984. </year>
Reference: [Berlin 89] <author> Andrew A. </author> <title> Berlin, "A Compilation Strategy for Numerical Programs based on Partial Evaluation", </title> <type> Master's Thesis, </type> <institution> MIT Department of Electrical Engineering and Computer Science, </institution> <month> February </month> <year> 1989. </year>
Reference: [Boehm 80] <author> H. Boehm, A. Demers, and J. Donahue. </author> <title> An Informal Description of Russell. </title> <type> Technical Report TR80-430, </type> <institution> Cornell University, CS Department, </institution> <year> 1980. </year>
Reference: [Boehm 85] <author> H. J. Boehm, </author> <title> "Partial polymorphic type inference is undecidable", </title> <booktitle> 26th Annual Symposium on Foundations of Computer Science, Oc-tober 1985, </booktitle> <pages> pages 339-345. </pages>
Reference-contexts: Both [McCracken 84] and [Leivant 83] attempted to provide automatic type abstraction in more general type systems, but these results are flawed (see sections 2.3.3 and 2.3.4). The general partial polymorphic type inference problem was shown to be undecidable by <ref> [Boehm 85] </ref>. More recent work [Kfoury 88] has shown that conservative extensions to ML providing restricted polymorphism are possible, but has not provided a practical type reconstruction algorithm.
Reference: [Boehm 89] <author> H. J. Boehm, </author> <title> "Type Inference in the Presence of Type Abstraction", </title> <booktitle> To appear in the Proceedings of the SIGPLAN '89 Symposium, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: Substitute solutions into second-order constraints, simplify, and repeat. The existence of the base cases in all recursive definitions ensures that there will be first-order constraints to solve in stage 2, thus ensuring that progress towards termination is being made by the reconstruction algorithm. 3 A proof sketch in <ref> [Boehm 89] </ref> describes how recursive type signatures can be computed using a similar method. 5.3.2 Implicit Projection The version of my IAPPL rule presented in [McCracken 84] does not restrict the type arguments to be M types, but instead requires that all type arguments appear in the types of the formal
Reference: [Burstall 84] <author> R. Burstall and B. W. Lampson. </author> <title> A Kernel Language for Abstract Data Types and Modules. In Semantics of Data Types. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference: [Cardelli 86] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction, and Polymorphism. </title> <note> To appear in Computing Surveys. 49 </note>
Reference: [Damas 82] <author> L. Damas, R. Milner, </author> <title> "Principal type-schemes for functional pro-grams", </title> <booktitle> Proceedings of the 9th Annual Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1982, </year> <pages> pages 207-212. </pages>
Reference-contexts: The combination of universal polymorphism and automatic type computation was a significant advance in programming language research. The ML type system is based on type schemes, and uses the generic let construct to provide polymorphism. ML, as presented in <ref> [Damas 82] </ref>, uses generic type variables to express polymorphism. The ML type discipline is not as powerful as the type discipline of the second-order polymorphic lambda calculus [Fortune 83].
Reference: [Damas 85] <author> L. Damas, </author> <title> "Type Assignment in Programming Lanuages", </title> <type> Ph.D. Thesis CST-33-85, </type> <institution> University of Edinburgh, </institution> <month> April </month> <year> 1985. </year>
Reference: [Fages 83] <author> F. Fages, </author> <title> `Associative-Communtative Unification", </title> <booktitle> Proceedings of the 7th CADE, </booktitle> <year> 1983. </year>
Reference-contexts: The algebra of effect specifications defined in FX-87 complicates type reconstruction efforts because it is associative and commutative. Unification algorithms for systems of equations which include associative and commutative operators are well-known <ref> [Fages 83] </ref>, and could in principle be used to automatically compute effect specifications. The IFX typing rules permit monomorphic types to be omitted from formal argument type declarations.
Reference: [Fateman 73] <author> Richard J. Fateman, </author> <title> "Reply to an Editorial." </title> <journal> SIGSAM Bulletin 25, </journal> <month> March </month> <year> 1973. </year>
Reference: [Fortune 83] <author> S. Fortune, D. Leivant, and M. O'Donnell, </author> <title> "Simple and Second-order Type Structures", </title> <journal> Journal of the Association for Computing Machinery, </journal> <month> January </month> <year> 1983. </year>
Reference-contexts: The ML type system is based on type schemes, and uses the generic let construct to provide polymorphism. ML, as presented in [Damas 82], uses generic type variables to express polymorphism. The ML type discipline is not as powerful as the type discipline of the second-order polymorphic lambda calculus <ref> [Fortune 83] </ref>. Type quantifiers are not explicit in ML, and it is therefore not possible to express the type of a function which expects a polymorphic value as an argument.
Reference: [Gifford and Lucassen 86] <author> David K. Gifford and John M. Lucassen. </author> <title> Integrating Functional and Imperative Programming. </title> <booktitle> Proceedings of the 1986 ACM Conference on Lisp and Functional Programming. </booktitle> <pages> Pages 28-38. </pages>
Reference: [Gifford, et al. 87] <author> David K. Gifford, Pierre Jouvelot, John M. Lucassen, Mark A. Sheldon. </author> <title> FX- Reference Manual. </title> <address> MIT/LCS/TR-407. </address> <month> September </month> <year> 1987. </year>
Reference-contexts: However, present systems for type reconstruction, such as the ML type system [Milner 78], do not permit the use of first-class polymorphic values. Explicitly-typed languages, such as FX-87 <ref> [Gifford, et al. 87] </ref>, do permit first-class polymorphic values, but they do not provide the programmer with the convenience of implicitly-typed languages such as ML. The FX-89 programming language is a revision and extension of FX-87.
Reference: [Girard 71] <author> J.-Y. Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <booktitle> In Proceedings of the Second Scandinavian Logic Symposium (edited by J. </booktitle> <editor> E. Fenstad). </editor> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference: [Goldfarb 81] <author> W. D. Goldfarb, </author> <title> "The undecidability of the second-order unification problem", </title> <journal> Theoretical Computer Science, </journal> <volume> vol. 13, </volume> <year> 1981, </year> <pages> pages 225-230. </pages>
Reference-contexts: Recently, [Pfenning 88] related the complexity of the partial type reconstruction prob 13 lem for the second-order polymorphic lambda calculus to that of second-order unification, which is well-known to be undecidable <ref> [Goldfarb 81] </ref>. 1.3 Summary I believe my type reconstruction method is the first to combine the implicit typing of ML with the full power of the second-order polymorphic lambda calculus in a statically checkable type system.
Reference: [Hindley 69] <author> R. Hindley, </author> <title> "The principal type-scheme of an object in combi-natory logic", </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> vol. 146, </volume> <year> 1969, </year> <pages> pages 29-60. </pages>
Reference-contexts: However, this frustrates programmers and leads to bad design practices. Providing a general and powerful type system attacks this problem while retaining the benefits of static typing. 12 1.2 Previous Work Early contributions by [Morris 68] and <ref> [Hindley 69] </ref> provided the basis for the automatic computation of types. Morris showed that in the simple type system he studied, valid typings of programs are types which satisfy recursive linear equations which are related to the syntactic structure of the program. <p> Because a represents an M type, it cannot be unified with type expressions containing 8. 3.2.1 Extended Unification This type reconstruction algorithm makes extensive use of a unification algorithm for this type system. The unification algorithm and its implementation are based on the work of <ref> [Morris 68, Hindley 69] </ref>. As in [McCracken 84], we require that the unification algorithm be extended to support alpha-renaming of bound type variables, including generic type variables.
Reference: [Huet 75] <author> G. P. Huet, </author> <title> "A Unification Algorithm for Typed -Calculus", </title> <note> Theoretical Computer Science 1 (1975) 27-57. 50 </note>
Reference-contexts: However, the completeness of the resulting algorithm remains an open question. 3 Whenever stage 2 is reached with only second-order constraints available, an optimistic (i.e., potentially non-terminating) implementation can apply heuristic algorithms to attempt a solution. <ref> [Huet 75] </ref> describes a semi-decision procedure for such second-order equations, and [Pfenning/Lee 89] is an example of such an approach. 45 5.3.3 Type Closure w.r.t. User Type Identifiers The CLOSE rule of IFX does not permit closure with respect to type variables which appear in user-supplied types.
Reference: [Hypercard] <author> Apple Computer, Hypercard Stacks:Help:HyperTalk, </author> <title> online electronic documentation, </title> <publisher> undated. </publisher>
Reference-contexts: For 1 These programming languages are described in <ref> [Lotus123, SQL, Hypercard, Rees 86, Ingalls 78] </ref>. 42 example, floating point type assertions are used in numerical Lisp pro- grams so that unboxed 2 values will be used. 5.2 Type Reconstruction with First-Class Polymorphism I have developed a type reconstruction system which combines the convenience of ML-style typing with the full
Reference: [Ingalls 78] <author> Daniel H. H. Ingalls, </author> <title> "The Smalltalk-76 Programming System Design and Implementation", </title> <booktitle> Proceedings of the 5th Annual Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1978. </year>
Reference-contexts: For 1 These programming languages are described in <ref> [Lotus123, SQL, Hypercard, Rees 86, Ingalls 78] </ref>. 42 example, floating point type assertions are used in numerical Lisp pro- grams so that unboxed 2 values will be used. 5.2 Type Reconstruction with First-Class Polymorphism I have developed a type reconstruction system which combines the convenience of ML-style typing with the full
Reference: [Kanellakis/Mitchell 89] <author> P. C. Kanellakis and John C. Mitchell, </author> <title> "Polymorphic Unification and ML Typing", </title> <booktitle> Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: i. (let (x e b ) e) let fff i g = FGV (t b ) FGV (S b A) return hSS b ; t i. endcase. 31 3.3 Complexity of the Algorithm The complexity of Algorithm R appears to be similar to that of the ML type inference algorithm. <ref> [Kanellakis/Mitchell 89] </ref> has shown that short programs in ML can have large types. It follows from this result that all of the known ML type reconstruction algorithms have worst-case running times which are at least exponential in the size of the input program.
Reference: [Kfoury 88] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn, </author> <title> "A Proper Extension of ML with an effective Type-Assignment", </title> <booktitle> Proceedings of the 15th Annual Symposium on the Principles of Programming Languages, </booktitle> <year> 1988. </year>
Reference-contexts: Both [McCracken 84] and [Leivant 83] attempted to provide automatic type abstraction in more general type systems, but these results are flawed (see sections 2.3.3 and 2.3.4). The general partial polymorphic type inference problem was shown to be undecidable by [Boehm 85]. More recent work <ref> [Kfoury 88] </ref> has shown that conservative extensions to ML providing restricted polymorphism are possible, but has not provided a practical type reconstruction algorithm.
Reference: [Leivant 83] <author> D. Leivant, </author> <title> "Polymorphic Type Inference", </title> <booktitle> Proceedings of the 10th Annual Symposium on Principles of Programming Languages, </booktitle> <year> 1983. </year>
Reference-contexts: McCracken's system did not provide the generic let construct of ML, although it did attempt to support the automatic instantiation of explicitly typed polymorphic functions in application position. Both [McCracken 84] and <ref> [Leivant 83] </ref> attempted to provide automatic type abstraction in more general type systems, but these results are flawed (see sections 2.3.3 and 2.3.4). The general partial polymorphic type inference problem was shown to be undecidable by [Boehm 85].
Reference: [Liskov 81] <author> Barbara Liskov, Russell Atkinson, Toby Bloom, Eliot Moss, J. Craig Schaffert, Robert Scheifler, Alan Snyder. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference: [Lotus123] <author> Lotus Development Corporation, </author> <title> "Lotus 1-2-3 Reference Manual", Standard Documentation, </title> <publisher> undated. </publisher>
Reference-contexts: For 1 These programming languages are described in <ref> [Lotus123, SQL, Hypercard, Rees 86, Ingalls 78] </ref>. 42 example, floating point type assertions are used in numerical Lisp pro- grams so that unboxed 2 values will be used. 5.2 Type Reconstruction with First-Class Polymorphism I have developed a type reconstruction system which combines the convenience of ML-style typing with the full
Reference: [Lucassen 87] <author> John M. Lucassen. </author> <title> Types and Effects: Towards the Integration of Functional and Imperative Programming. </title> <type> Ph.D. Thesis. </type> <institution> MIT/LCS/TR-408, </institution> <month> August </month> <year> 1987. </year>
Reference: [Lucassen and Gifford 88] <author> John M. Lucassen and David K. Gifford. </author> <title> "Polymorphic Effect Systems" in POPL 88. </title>
Reference: [MacQueen 84] <author> David MacQueen, </author> <title> "Modules for Standard ML", </title> <booktitle> Proceedings ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 198-207, </pages> <year> 1984. </year>
Reference-contexts: The ML programming language provides automatic type inference. Type reconstruction has proven to be the most popular feature of ML. However, the ML type system is not powerful enough for some applications, and this has led to the introduction of a module system <ref> [MacQueen 84] </ref>. 1.1.3 Expressive Typing Section 1.1.1 described the inflexibility of type systems as an important disadvantage of static typing. Much more software has been written in programming languages which do not provide strictly enforced typing than in languages which do.
Reference: [MacQueen 88] <editor> David MacQueen, </editor> <booktitle> "An Implementation of Standard ML Modules" Proceedings ACM Symposium on Lisp and Functional Programming, </booktitle> <year> 1988. </year> <month> 51 </month>
Reference: [Matthews 82] <author> David C. J. Matthews. </author> <type> POLY Report. Technical Report TR--28, </type> <institution> University of Cambridge Computer Laboratory, </institution> <year> 1982. </year>
Reference: [McAllester 87] <author> David A. McAllester, "ONTIC: </author> <title> A Knowledge Representation System for Mathematics", </title> <type> AI Technical Report 979, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> May </month> <year> 1987. </year>
Reference: [McCracken 79] <author> McCracken, N. J. </author> <title> An Investigation of a Programming Language with a Polymorphic Type Structure. </title> <type> Ph.D. Thesis, </type> <institution> Syracuse University, </institution> <year> 1979. </year>
Reference: [McCracken 79] <author> Nancy Jean McCracken. </author> <title> An Investigation of a Programming Language with a Polymorphic Type Structure. </title> <type> Dissertation. </type> <institution> Syracuse University. </institution> <year> 1979. </year>
Reference: [McCracken 84] <author> McCracken, N. J., </author> <title> "The Typechecking of Programs with Implicit Type Structure", Semantics of Data Types, </title> <booktitle> vol. 173 of Lecture Notes in Computer Science, </booktitle> <month> June </month> <year> 1984, </year> <pages> pages 301-315. </pages>
Reference-contexts: Type quantifiers are not explicit in ML, and it is therefore not possible to express the type of a function which expects a polymorphic value as an argument. For this reason, ML does not provide first-class polymorphism. <ref> [McCracken 84] </ref> introduced a type reconstruction system for the second-order polymorphic lambda calculus. McCracken's system did not provide the generic let construct of ML, although it did attempt to support the automatic instantiation of explicitly typed polymorphic functions in application position. Both [McCracken 84] and [Leivant 83] attempted to provide automatic <p> this reason, ML does not provide first-class polymorphism. <ref> [McCracken 84] </ref> introduced a type reconstruction system for the second-order polymorphic lambda calculus. McCracken's system did not provide the generic let construct of ML, although it did attempt to support the automatic instantiation of explicitly typed polymorphic functions in application position. Both [McCracken 84] and [Leivant 83] attempted to provide automatic type abstraction in more general type systems, but these results are flawed (see sections 2.3.3 and 2.3.4). The general partial polymorphic type inference problem was shown to be undecidable by [Boehm 85]. <p> McCracken introduced the close operator to allow the programmer to indicate where type abstraction should occur without having to specify precisely what those type abstractions should be. A discussion of the formal typing rule for the close operator and why my modification to the rule in <ref> [McCracken 84] </ref> is necessary appears in sections 2.3.3 and 2.3.4. Unlike McCracken's system, the IFX type system contains both ML-style generic types and explicitly quantified types, and therefore requires that the programmer indicate where explicit quantifiers should be removed from a type. <p> This restriction is enforced by the CLOSE rule, which contains as an antecedent that the type used for the closure be the most general type of the expression. This restriction did not appear in <ref> [McCracken 84] </ref>, and precludes the completeness of the typechecking algorithm W presented there. 2.3.4 Only the Most General Type The difficulty with the CLOSE rule (and similarly PLAMBDA and ILET), is that in the absence of the most general type restriction, a more specific type may be chosen, leading to a <p> The unification algorithm and its implementation are based on the work of [Morris 68, Hindley 69]. As in <ref> [McCracken 84] </ref>, we require that the unification algorithm be extended to support alpha-renaming of bound type variables, including generic type variables. <p> first-order constraints to solve in stage 2, thus ensuring that progress towards termination is being made by the reconstruction algorithm. 3 A proof sketch in [Boehm 89] describes how recursive type signatures can be computed using a similar method. 5.3.2 Implicit Projection The version of my IAPPL rule presented in <ref> [McCracken 84] </ref> does not restrict the type arguments to be M types, but instead requires that all type arguments appear in the types of the formal subroutine arguments: IPA A ` e a : t a t a = t f [t i =t i ] This extension corresponds to a
Reference: [Milner 78] <author> R. Milner, </author> <title> "A Theory of Type Polymorphism in Programming", </title> <journal> Journal of Computer and System Sciences, </journal> <volume> vol. 17, </volume> <year> 1978, </year> <pages> pages 349-375. </pages>
Reference-contexts: Hindley developed a method for computing the type of a term in the lambda calculus by applying Robinson's unification algorithm [Robinson 65]. Milner applied these results to the design of the type discipline of the programming language ML <ref> [Milner 78] </ref>. The ML system provides a type discipline which permits functions to have polymorphic types, and which automatically computes the typing of programs without the necessity of type declarations. The combination of universal polymorphism and automatic type computation was a significant advance in programming language research. <p> However, present systems for type reconstruction, such as the ML type system <ref> [Milner 78] </ref>, do not permit the use of first-class polymorphic values. Explicitly-typed languages, such as FX-87 [Gifford, et al. 87], do permit first-class polymorphic values, but they do not provide the programmer with the convenience of implicitly-typed languages such as ML. <p> For convenience, the notation R (A; e) ! hS; t i will be used to indicate that "Algorithm R halts on input A and e, yielding S and t ." 1 This is syntactic soundness, in the terminology of <ref> [Milner 78] </ref>. 33 4.1 Termination Theorem (Termination). Algorithm R terminates on all (finite) inputs. Proof: Observe that Algorithm R is a syntax-directed algorithm. R (A; e) recursively traverses the syntax of the input expression e, which is finite.
Reference: [Morris 68] <author> Morris, J. H., </author> <title> Lambda-Calculus Models of Programming Languages, </title> <institution> Massachusetts Institute of Technology, MAC-TR-57, </institution> <year> 1968. </year>
Reference-contexts: However, this frustrates programmers and leads to bad design practices. Providing a general and powerful type system attacks this problem while retaining the benefits of static typing. 12 1.2 Previous Work Early contributions by <ref> [Morris 68] </ref> and [Hindley 69] provided the basis for the automatic computation of types. Morris showed that in the simple type system he studied, valid typings of programs are types which satisfy recursive linear equations which are related to the syntactic structure of the program. <p> Because a represents an M type, it cannot be unified with type expressions containing 8. 3.2.1 Extended Unification This type reconstruction algorithm makes extensive use of a unification algorithm for this type system. The unification algorithm and its implementation are based on the work of <ref> [Morris 68, Hindley 69] </ref>. As in [McCracken 84], we require that the unification algorithm be extended to support alpha-renaming of bound type variables, including generic type variables.
Reference: [O'Toole/Gifford 89] <author> James William O'Toole Jr. and David K. Gifford, </author> <title> Type Reconstruction with First-Class Polymorphic Values, </title> <booktitle> SIGPLAN Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1989. </year>
Reference: [O'Toole 89] <author> O'Toole, James William, Jr., </author> <title> Type Abstraction Rules for References: A Comparison, </title> <address> MIT/LCS/TM-390, </address> <year> 1989. </year>
Reference-contexts: This type abstraction rule permits different type abstractions than does the FX-87 pure-plambda rule. A thorough comparison of these type abstraction rules is beyond the scope of this report, but is pursued in <ref> [O'Toole 89] </ref>. I believe that the imperative typing discipline introduced in [Tofte 87] can be combined with IFX. 47 5.3.6 IFX as a Design Point The language IFX may be viewed as one point in a design space of languages.
Reference: [Pfenning 88] <author> Frank Pfenning, </author> <title> "Partial Polymorphic Type Inference and Higher Order Unification", </title> <booktitle> Proceedings of ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1988. </year>
Reference-contexts: The general partial polymorphic type inference problem was shown to be undecidable by [Boehm 85]. More recent work [Kfoury 88] has shown that conservative extensions to ML providing restricted polymorphism are possible, but has not provided a practical type reconstruction algorithm. Recently, <ref> [Pfenning 88] </ref> related the complexity of the partial type reconstruction prob 13 lem for the second-order polymorphic lambda calculus to that of second-order unification, which is well-known to be undecidable [Goldfarb 81]. 1.3 Summary I believe my type reconstruction method is the first to combine the implicit typing of ML with
Reference: [Pfenning/Lee 89] <author> Frank Pfenning and Peter Lee, </author> <title> "LEAP: a language with eval and polymorphism", </title> <booktitle> Proceedings of the International Joint Conference on Theory and Practice in Software Development, </booktitle> <month> March </month> <year> 1989. </year> <month> 52 </month>
Reference-contexts: However, the completeness of the resulting algorithm remains an open question. 3 Whenever stage 2 is reached with only second-order constraints available, an optimistic (i.e., potentially non-terminating) implementation can apply heuristic algorithms to attempt a solution. [Huet 75] describes a semi-decision procedure for such second-order equations, and <ref> [Pfenning/Lee 89] </ref> is an example of such an approach. 45 5.3.3 Type Closure w.r.t. User Type Identifiers The CLOSE rule of IFX does not permit closure with respect to type variables which appear in user-supplied types.
Reference: [Rees 86] <editor> Jonathan Rees, et al. </editor> <title> Revised 3 Report on the Algorithmic Lan--guage Scheme. AI Memo 848a. MIT, </title> <journal> Artificial Intelligence Laboratory, </journal> <month> September </month> <year> 1986. </year>
Reference-contexts: These constructs can be added to the type inference system described below. 2.2 Type Reconstruction in IFX 2.2.1 Syntax IFX is a polymorphically typed language which is functional, lexically scoped, and permits first-class procedures. Its syntax and most of its standard operations are strongly inspired by Scheme <ref> [Rees 86] </ref>. <p> For 1 These programming languages are described in <ref> [Lotus123, SQL, Hypercard, Rees 86, Ingalls 78] </ref>. 42 example, floating point type assertions are used in numerical Lisp pro- grams so that unboxed 2 values will be used. 5.2 Type Reconstruction with First-Class Polymorphism I have developed a type reconstruction system which combines the convenience of ML-style typing with the full
Reference: [Reynolds 74] <author> John C. Reynolds. </author> <title> Towards a Theory of Type Structure. </title> <booktitle> In Programming Symposium: Proceedings, Colloque sur la Programmation. </booktitle> <address> Paris, </address> <month> April 9-11, </month> <title> 1974 (edited by Robinet). </title> <publisher> Springer-Verlag. </publisher> <address> New York 1974. </address> <pages> pp. 408-425. </pages>
Reference: [Reynolds 78] <author> J. C. Reynolds, </author> <title> "Definitional Interpreters for higher order programming languages", </title> <booktitle> Proceedings of the 5th Annual Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1978, </year> <pages> pages 39-46. </pages>
Reference: [Robinson 65] <author> Robinson, J. A., </author> <title> "A machine-oriented logic based on the resolution principle", </title> <journal> JACM 12,1 (1965), </journal> <pages> pages 23-41. </pages>
Reference-contexts: Hindley developed a method for computing the type of a term in the lambda calculus by applying Robinson's unification algorithm <ref> [Robinson 65] </ref>. Milner applied these results to the design of the type discipline of the programming language ML [Milner 78]. The ML system provides a type discipline which permits functions to have polymorphic types, and which automatically computes the typing of programs without the necessity of type declarations.
Reference: [Sheldon 89] <author> Mark A. Sheldon, </author> <title> "Static Dependent Types for First-Class Modules", </title> <type> Master's Thesis, </type> <institution> MIT Department of Electrical Engineering and Computer Science, </institution> <month> May </month> <year> 1989. </year>
Reference: [SQL] <author> International Business Machines, </author> <title> "A Relational Data System for Application Development", G320-6590-0, and "SQL/Data System General Information", GH24-5012-1, File No. </title> <address> S370/4300-50, </address> <month> February </month> <year> 1982. </year>
Reference-contexts: For 1 These programming languages are described in <ref> [Lotus123, SQL, Hypercard, Rees 86, Ingalls 78] </ref>. 42 example, floating point type assertions are used in numerical Lisp pro- grams so that unboxed 2 values will be used. 5.2 Type Reconstruction with First-Class Polymorphism I have developed a type reconstruction system which combines the convenience of ML-style typing with the full
Reference: [Steele 77] <author> Guy Lewis Steele Jr., </author> <title> "Fast Arithmentic in MACLISP", AI Memo 421, MIT, </title> <journal> Artificial Intelligence Laboratory, </journal> <month> September </month> <year> 1977. </year>
Reference: [Tofte 87] <author> Tofte, Mads, </author> <title> Operational Semantics and Polymorphic Type Inference, </title> <type> Ph.D. Thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year> <month> 53 </month>
Reference-contexts: Effect specifications can be included in such a classification; such an approach is adopted by the current design of FX-89. 5.3.5 Applicative Types In FX-87, type abstraction is permitted only when the side-effect specifications ensure that the polymorphic expression is referentially transparent. <ref> [Tofte 87] </ref> takes a different approach, based on the concept of applicative types. Tofte classifies certain expressions as expansive, and permits type abstraction of these expressions only with respect to applicative type variables. This type abstraction rule permits different type abstractions than does the FX-87 pure-plambda rule. <p> This type abstraction rule permits different type abstractions than does the FX-87 pure-plambda rule. A thorough comparison of these type abstraction rules is beyond the scope of this report, but is pursued in [O'Toole 89]. I believe that the imperative typing discipline introduced in <ref> [Tofte 87] </ref> can be combined with IFX. 47 5.3.6 IFX as a Design Point The language IFX may be viewed as one point in a design space of languages. The rules comprising IFX provide certain language constructs which define the behavior and interactions of generic and explicitly polymorphic types.
References-found: 49

