URL: ftp://ftp.cs.man.ac.uk/pub/IPG/gws96.ps.Z
Refering-URL: http://www.cs.man.ac.uk/ipg/publications.html
Root-URL: http://www.cs.man.ac.uk
Email: email: markg,brian@cs.man.ac.uk  email: j-sa@csm.uwe.ac.uk  
Title: Cooperating Evolving Components a rigorous approach to evolving large software systems  
Author: R.M. Greenwood, B.C. Warboys J. Sa 
Keyword: product evolution, process evolution, process modelling, design hierarchy  
Address: Manchester, Manchester M13 9PL UK  England, Bristol BS16 1QY UK  
Affiliation: Department of Computer Science, The University of  Department of Computing, University of the West of  
Abstract: Large software systems have a large number of components and are developed over a long time period frequently by a large number of people. We describe a framework approach to evolving such systems based on an integration of product and process modelling. The evolving system is represented as a Product Tower, a hierarchy of components which provides views of the product at multiple levels of refinement. The evolution process is component based with the cooperation between components being mediated by the Product Tower. This ensures that the evolution process is scaleable and that it maintains, and evolves, the design model. We illustrate our approach with an example, outlining an evolution both of the product and of the process. The reflexive facilities of the process are shown to be key in ensuring the framework's ability to evolve. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.-M. Aumaitre, M. Dowson, and D.-R. Harjani. </author> <title> Lessons Learned from Formalizing and Implementing a Large Process Model. </title> <booktitle> In Proceedings EWSPT'94, volume 772 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In general the style is project-based. It is expected that a software development company would have a set of generic process models which are spe-cialised to the task in hand. An effect of this is that attempts to address large systems have resulted in large and complex process models <ref> [1, 5] </ref>. This contrasts with the component-based approach descibed in this paper. We are able to keep the component process simple by re-using the information in the Product Tower to identify where cooperation is required.
Reference: [2] <author> S. Bandinelli and A. Fuggetta. </author> <title> Computational Reflection in Software Process Modelling: the SLANG Approach. </title> <booktitle> In Proceedings of ICSE 15, </booktitle> <address> Baltimore, Maryland, </address> <year> 1993. </year>
Reference-contexts: The ability to cope with such reflexive processes was a major design criteria of PWI, and examples exploiting this are described in [25, 23]. The SLANG process modelling language also adopts a similar approach to evolving processes <ref> [2] </ref>. 7 Conclusions Our prime objective was the production of a framework within which large software systems could be developed. We have shown that this framework is both implementable and verifiable.
Reference: [3] <author> H. Barringer, R. Kuiper, and A. Pnueli. </author> <title> Now you may compose temporal logic specifications. </title> <booktitle> In Proceedings of the 16th A.C.M. Symposium on Theory of Computing, </booktitle> <year> 1984. </year>
Reference-contexts: The particular temporal logic we chose offered a compositional approach <ref> [3] </ref>. Using that approach, a system is considered as a collection of components. Each component is specified as a temporal logic formula. The specification of the overall system is obtained by composing all the component specifications.
Reference: [4] <author> R.F. Bruynooghe, R.M. Greenwood, I. Robert-son, J. Sa, R.A. Snowdon, and B.C. Warboys. Padm: </author> <title> Towards a total process modelling system. </title> <editor> In A. Finklestein, J. Kramer, and B. Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technol--ogy, </booktitle> <pages> pages 293-334. </pages> <publisher> Research Studies Press, </publisher> <year> 1994. </year>
Reference-contexts: This forms an active model ensuring that the OBM for the EPOS application part is evolved as prescribed by the hdev process. In addition, the dynamic change capabilities of PWI's PML are used to implement changeself ensuring that hdev itself can evolve. 5.1 ProcessWise Integrator ProcessWise Integrator (PWI) <ref> [4, 22, 25] </ref> originated in the Alvey IPSE 2.5 project which concluded in 1989. ICL subsequently took up the software rights and continued its commercial exploitation to the present day. PWI's PML is based on a combination of Holt's Role Activity Diagrams [9] and Greenspan's RML [8].
Reference: [5] <author> D.C. Carr, A. Dandekar and D.E. Perry. </author> <title> Experiments in Process Interface Descriptions, Visualization and Analyses. </title> <booktitle> In Proceedings EWSPT'95, volume 913 of Lecture Notes in Computer Science, </booktitle> <pages> pages 119-137, </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: In general the style is project-based. It is expected that a software development company would have a set of generic process models which are spe-cialised to the task in hand. An effect of this is that attempts to address large systems have resulted in large and complex process models <ref> [1, 5] </ref>. This contrasts with the component-based approach descibed in this paper. We are able to keep the component process simple by re-using the information in the Product Tower to identify where cooperation is required.
Reference: [6] <author> B. Curtis, M.I. Kellner and J.Over. </author> <title> Process Modeling. </title> <journal> In Communications of the ACM, </journal> <volume> 35 (9): </volume> <pages> 75-90, </pages> <year> 1992. </year>
Reference-contexts: Process modelling, and particularly the use of explicit process models in a software engineering environment, has grown as a research area since Oster-weil's keynote speech at ICSE 9 [15]. A good introduction is provided in <ref> [6] </ref>, and [7] describes a range of systems. In general the style is project-based. It is expected that a software development company would have a set of generic process models which are spe-cialised to the task in hand.
Reference: [7] <author> A. Finklestein, J. Kramer and B. Nuseibeh, </author> <title> editors. Software Process Modelling and Technology. </title> <publisher> Research Studies Press, </publisher> <year> 1994. </year>
Reference-contexts: Process modelling, and particularly the use of explicit process models in a software engineering environment, has grown as a research area since Oster-weil's keynote speech at ICSE 9 [15]. A good introduction is provided in [6], and <ref> [7] </ref> describes a range of systems. In general the style is project-based. It is expected that a software development company would have a set of generic process models which are spe-cialised to the task in hand.
Reference: [8] <author> S.J. Greenspan, </author> <title> Requirements Modelling. </title> <note> In Technical Report CSRG-155, </note> <institution> University of Toronto, </institution> <month> March, </month> <year> 1984. </year>
Reference-contexts: ICL subsequently took up the software rights and continued its commercial exploitation to the present day. PWI's PML is based on a combination of Holt's Role Activity Diagrams [9] and Greenspan's RML <ref> [8] </ref>. The language has four principal classes: entities (records), activities (procedures), roles (encapsulations of data and behaviour), and interactions (unidirectional communication channels). These principal classes, along with numerous primitive classes, are used to define the process as a network of role instances.
Reference: [9] <author> A.W. Holt, H.R. Ramsey, and J.D. Grimes. </author> <title> Coordination system technology as the basis for a programming environment. </title> <journal> In Electrical Communication, </journal> <volume> 57(4) </volume> <pages> 308-314, </pages> <year> 1983. </year>
Reference-contexts: ICL subsequently took up the software rights and continued its commercial exploitation to the present day. PWI's PML is based on a combination of Holt's Role Activity Diagrams <ref> [9] </ref> and Greenspan's RML [8]. The language has four principal classes: entities (records), activities (procedures), roles (encapsulations of data and behaviour), and interactions (unidirectional communication channels). These principal classes, along with numerous primitive classes, are used to define the process as a network of role instances.
Reference: [10] <author> K.E. Huff. </author> <title> On the Relationship between Software Processes and Software Products. </title> <booktitle> In Proceedings of the 6th International Software Process Workshop, </booktitle> <pages> pp. 109-111, </pages> <address> Hakodate, Japan, </address> <year> 1990. </year>
Reference-contexts: We are able to keep the component process simple by re-using the information in the Product Tower to identify where cooperation is required. The use of a product representation which is aligned with a process model is also described in <ref> [10] </ref>. In a project-based approach, process evolution is often viewed as the feedback which is incorporated in the generic processes ready for future specialisations. Having a single process to support the ongoing evolution of a component means that the process must evolve itself; it must be reflexive.
Reference: [11] <author> J.A.Keane, J.Sa and B.C.Warboys, </author> <title> Applying a Concurrent Formal Framework to Process Mod-elling. </title> <booktitle> In Proceedings of FME'94, volume 873 of Lecture Notes in Computer Science, </booktitle> <pages> pages 291-305, </pages> <publisher> Springer Verlag, </publisher> <year> 1994 </year>
Reference-contexts: In addition, the ability of hdev to evolve itself is illustrated. Finally we compare our approach with related work, and describe our conclusions and plans for future work. 2 OBM | the specification language OBM <ref> [11, 19] </ref> is a formal development method. It provides a specification language. In the rest of this paper, we refer to both the language and the method as OBM. OBM is used to specify both the development process and the product to be developed. <p> The behaviour of an abstract object is determined by the execution of its operations. The order of these executions must conform to the operation pattern. The temporal semantics of abstract objects are given in <ref> [11] </ref>. An abstract object may be refined by decomposing it into a number of sub-components. In order to justify the refinement, it is necessary to show that the composition of the sub-components is consistent with the abstract object. <p> The behaviour of a boxed object is the concurrent executions of all the contained components. The behaviour of the internal operations is not visible. The temporal semantics of boxed objects, and how they are used in checking refinement consistency, are given in <ref> [11] </ref>. A Product Tower of components can be formed from a single top node by repeated refinement by decomposition. <p> Experience with the latter also highlighted the inter-relationship between process and product in large systems evolution. The desire to support formal reasoning at multiple levels of abstraction has been one main aim in the development of OBM <ref> [18, 20, 11] </ref>. The Product Tower provides an explicit structural description of the software as a unifying framework. It is thus very similar to the approach advocated in [12], although in our case the full hierarchy may not be obvious from the final product.
Reference: [12] <author> J. </author> <title> Kramer Exoskeletal Software Panel Presentation In Proceedings of ICSE 16, </title> <address> Sorrento, Italy, </address> <year> 1994 </year>
Reference-contexts: The desire to support formal reasoning at multiple levels of abstraction has been one main aim in the development of OBM [18, 20, 11]. The Product Tower provides an explicit structural description of the software as a unifying framework. It is thus very similar to the approach advocated in <ref> [12] </ref>, although in our case the full hierarchy may not be obvious from the final product. Process modelling, and particularly the use of explicit process models in a software engineering environment, has grown as a research area since Oster-weil's keynote speech at ICSE 9 [15].
Reference: [13] <author> M.M.Lehman, </author> <title> Programs, life cycles, and laws of software evolution. </title> <booktitle> In Proceedings of the IEEE 68, </booktitle> <month> 9 </month> <year> (1980) </year> <month> 1060-1076 </month>
Reference-contexts: 1 Introduction Modern large software systems are systems which: * Have a large number of components some of which are commodity, some are specially commissioned, and some are developed in-house. * Are developed over a long time period, in fact Lehman's <ref> [13] </ref> classification of software system types argues that they never stop developing. His so-called E-type systems. fl Copyright 1996 IEEE. Published in the Proceedings of the 18th International Conference on Software Engineering (ICSE-18), March 25-29, 1996, Berlin, Germany. Personal use of this material is permitted. <p> It will probably be more of a review than a formal proof of consistency. 6 Related Work In <ref> [13, 14] </ref> Lehman argues that the ongoing evolution of large (E-type) systems is inevitable. Similarly Parnas cites the problems of Software Aging [16], especially for successful systems. This is certainly the experience of VME/B [24] and supports the view that initial development is just one stage of product evolution.
Reference: [14] <author> M.M. Lehman. </author> <title> Software engineering, the software process and their support. </title> <journal> In Software Engineering Journal, </journal> <volume> 6 (5): </volume> <pages> 243-258. </pages>
Reference-contexts: It will probably be more of a review than a formal proof of consistency. 6 Related Work In <ref> [13, 14] </ref> Lehman argues that the ongoing evolution of large (E-type) systems is inevitable. Similarly Parnas cites the problems of Software Aging [16], especially for successful systems. This is certainly the experience of VME/B [24] and supports the view that initial development is just one stage of product evolution.
Reference: [15] <author> L.J. Osterweil. </author> <title> Software Processes are Software Too. </title> <booktitle> In Proceeding of ICSE9, </booktitle> <address> Monterey, Califor-nia, </address> <year> 1987. </year>
Reference-contexts: Process modelling, and particularly the use of explicit process models in a software engineering environment, has grown as a research area since Oster-weil's keynote speech at ICSE 9 <ref> [15] </ref>. A good introduction is provided in [6], and [7] describes a range of systems. In general the style is project-based. It is expected that a software development company would have a set of generic process models which are spe-cialised to the task in hand.
Reference: [16] <author> D.L. Parnas. </author> <title> Software Aging. </title> <booktitle> In Proceedings of ICSE 16, </booktitle> <address> Sorrento, Italy, </address> <year> 1994. </year>
Reference-contexts: It will probably be more of a review than a formal proof of consistency. 6 Related Work In [13, 14] Lehman argues that the ongoing evolution of large (E-type) systems is inevitable. Similarly Parnas cites the problems of Software Aging <ref> [16] </ref>, especially for successful systems. This is certainly the experience of VME/B [24] and supports the view that initial development is just one stage of product evolution.
Reference: [17] <author> D.T. Ross and K.E. Schoman Jr. </author> <title> "Structured Analysis for requirements definition". </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> 3 (1), </volume> <year> 1977. </year>
Reference-contexts: The use of hierarchy to manage complexity is a central tenet of systems theory [21, 26] and has been incorporated in several software development methods, such as SADT <ref> [17] </ref> and CADES [25]. Experience with the latter also highlighted the inter-relationship between process and product in large systems evolution. The desire to support formal reasoning at multiple levels of abstraction has been one main aim in the development of OBM [18, 20, 11].
Reference: [18] <author> J. Sa and B.C. Warboys. </author> <title> Specifying Concurrent Object-based Systems using Combined Specification Notations. </title> <note> In Technical Report UMCS-91-9-2, </note> <institution> Department of Computer Science, University of Manchester, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: The interface of an abstract object consists of a list of provided operations, required operations and an operation pattern defined in terms of the provided operations. Operation patterns are defined using an ordering expression. The detailed definition of ordering expressions can be found in <ref> [18] </ref>. The body of an abstract object consists of a call template for each required operation and a definition for each provided operation which contains its type, i.e. active or passive, its call pattern, and its pre and post-conditions. <p> Experience with the latter also highlighted the inter-relationship between process and product in large systems evolution. The desire to support formal reasoning at multiple levels of abstraction has been one main aim in the development of OBM <ref> [18, 20, 11] </ref>. The Product Tower provides an explicit structural description of the software as a unifying framework. It is thus very similar to the approach advocated in [12], although in our case the full hierarchy may not be obvious from the final product.
Reference: [19] <author> J. Sa and B.C.Warboys. </author> <title> A Reflexive Formal Software Process Model. </title> <booktitle> In Proceedings EWSPT'95, volume 913 of Lecture Notes in Computer Science, </booktitle> <pages> pages 241-254. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: In addition, the ability of hdev to evolve itself is illustrated. Finally we compare our approach with related work, and describe our conclusions and plans for future work. 2 OBM | the specification language OBM <ref> [11, 19] </ref> is a formal development method. It provides a specification language. In the rest of this paper, we refer to both the language and the method as OBM. OBM is used to specify both the development process and the product to be developed. <p> check the consistency of refinements is used to support the cooperative evolution of components. 2.2 Reflexive OBM Based on the original OBM, a new feature is added so that the OBM development process is reflexive, that is it has the ability to modify itself, the notion was initially explored in <ref> [19] </ref>. Each object has two parts: the method part (or the meta-part) and the application part. The method part defines how to develop the object.
Reference: [20] <author> J. Sa and B.C. Warboys. </author> <title> Modelling Processes Using a Stepwise Refinement Technique. </title> <booktitle> In Proceedings EWSPT'94, volume 772 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Experience with the latter also highlighted the inter-relationship between process and product in large systems evolution. The desire to support formal reasoning at multiple levels of abstraction has been one main aim in the development of OBM <ref> [18, 20, 11] </ref>. The Product Tower provides an explicit structural description of the software as a unifying framework. It is thus very similar to the approach advocated in [12], although in our case the full hierarchy may not be obvious from the final product.
Reference: [21] <author> H.A. Simon. </author> <booktitle> The Sciences of the Artificial. </booktitle> <publisher> MIT Press, </publisher> <address> second edition, </address> <year> 1981. </year>
Reference-contexts: Similarly Parnas cites the problems of Software Aging [16], especially for successful systems. This is certainly the experience of VME/B [24] and supports the view that initial development is just one stage of product evolution. The use of hierarchy to manage complexity is a central tenet of systems theory <ref> [21, 26] </ref> and has been incorporated in several software development methods, such as SADT [17] and CADES [25]. Experience with the latter also highlighted the inter-relationship between process and product in large systems evolution.
Reference: [22] <author> R.A. Snowdon. </author> <title> An Introduction to the IPSE 2.5 Project. </title> <note> In ICL Technical Journal 6 (3): 467-478, </note> <year> 1989. </year>
Reference-contexts: This forms an active model ensuring that the OBM for the EPOS application part is evolved as prescribed by the hdev process. In addition, the dynamic change capabilities of PWI's PML are used to implement changeself ensuring that hdev itself can evolve. 5.1 ProcessWise Integrator ProcessWise Integrator (PWI) <ref> [4, 22, 25] </ref> originated in the Alvey IPSE 2.5 project which concluded in 1989. ICL subsequently took up the software rights and continued its commercial exploitation to the present day. PWI's PML is based on a combination of Holt's Role Activity Diagrams [9] and Greenspan's RML [8].
Reference: [23] <author> R.A. Snowdon. </author> <title> An Example of Process Change. </title> <booktitle> In Proceedings EWSPT'92, volume 635 of Lecture Notes in Computer Science, </booktitle> <pages> pages 179-195. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Having a single process to support the ongoing evolution of a component means that the process must evolve itself; it must be reflexive. The ability to cope with such reflexive processes was a major design criteria of PWI, and examples exploiting this are described in <ref> [25, 23] </ref>. The SLANG process modelling language also adopts a similar approach to evolving processes [2]. 7 Conclusions Our prime objective was the production of a framework within which large software systems could be developed. We have shown that this framework is both implementable and verifiable. <p> Our work to date, in this area, has concentrated on the specification of a meta-process for managing these changes. The work is based on the notion of a Process Model for Management Support (PMMS), which originated during the IPSE 2.5 project [25], and which was further developed in <ref> [23] </ref>. The framework reported here gives us a general basis for managing the way in which an appropriate development process is attached to a new component. In the current system this process is inherited from its parent component and can be changed using the changeself construct.
Reference: [24] <author> B.C. Warboys. </author> <title> VME/B a model for the realisa-tion of a total system concept. </title> <note> In ICL Technical Journal November 1980. </note>
Reference-contexts: Similarly Parnas cites the problems of Software Aging [16], especially for successful systems. This is certainly the experience of VME/B <ref> [24] </ref> and supports the view that initial development is just one stage of product evolution. The use of hierarchy to manage complexity is a central tenet of systems theory [21, 26] and has been incorporated in several software development methods, such as SADT [17] and CADES [25].
Reference: [25] <author> B.C. Warboys. </author> <title> The IPSE2.5 Project: Process Modelling as the Basis for a Support Environment. </title> <booktitle> In Proceedings of the First International Conference on System Development Environment and Factories, </booktitle> <address> Berlin, </address> <month> May </month> <year> 1989 </year>
Reference-contexts: This forms an active model ensuring that the OBM for the EPOS application part is evolved as prescribed by the hdev process. In addition, the dynamic change capabilities of PWI's PML are used to implement changeself ensuring that hdev itself can evolve. 5.1 ProcessWise Integrator ProcessWise Integrator (PWI) <ref> [4, 22, 25] </ref> originated in the Alvey IPSE 2.5 project which concluded in 1989. ICL subsequently took up the software rights and continued its commercial exploitation to the present day. PWI's PML is based on a combination of Holt's Role Activity Diagrams [9] and Greenspan's RML [8]. <p> The use of hierarchy to manage complexity is a central tenet of systems theory [21, 26] and has been incorporated in several software development methods, such as SADT [17] and CADES <ref> [25] </ref>. Experience with the latter also highlighted the inter-relationship between process and product in large systems evolution. The desire to support formal reasoning at multiple levels of abstraction has been one main aim in the development of OBM [18, 20, 11]. <p> Having a single process to support the ongoing evolution of a component means that the process must evolve itself; it must be reflexive. The ability to cope with such reflexive processes was a major design criteria of PWI, and examples exploiting this are described in <ref> [25, 23] </ref>. The SLANG process modelling language also adopts a similar approach to evolving processes [2]. 7 Conclusions Our prime objective was the production of a framework within which large software systems could be developed. We have shown that this framework is both implementable and verifiable. <p> Our work to date, in this area, has concentrated on the specification of a meta-process for managing these changes. The work is based on the notion of a Process Model for Management Support (PMMS), which originated during the IPSE 2.5 project <ref> [25] </ref>, and which was further developed in [23]. The framework reported here gives us a general basis for managing the way in which an appropriate development process is attached to a new component.
Reference: [26] <author> B. </author> <title> Wilson Systems: concepts, methodologies, and applications. </title> <publisher> John Wiley and Sons Ltd, </publisher> <year> 1984. </year>
Reference-contexts: Similarly Parnas cites the problems of Software Aging [16], especially for successful systems. This is certainly the experience of VME/B [24] and supports the view that initial development is just one stage of product evolution. The use of hierarchy to manage complexity is a central tenet of systems theory <ref> [21, 26] </ref> and has been incorporated in several software development methods, such as SADT [17] and CADES [25]. Experience with the latter also highlighted the inter-relationship between process and product in large systems evolution.
References-found: 26

