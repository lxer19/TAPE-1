URL: http://polaris.cs.uiuc.edu/reports/1527.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/polaris/rep2.html
Root-URL: http://www.cs.uiuc.edu
Email: paek@cis.njit.edu  fhoefling,paduag@uiuc.edu  
Title: Simplification of Array Access Patterns for Compiler Optimizations  
Author: Yunheung Paekz Jay Hoeflingery David Paduay 
Affiliation: New Jersey Institute of Technology  University of Illinois at Urbana-Champaign  
Abstract: Existing array region representation techniques are sensitive to the complexity of array subscripts. In general, these techniques are very accurate and efficient for simple subscript expressions, but lose accuracy or require potentially expensive algorithms for complex subscripts. We found that in scientific applications, many access patterns are simple even when the subscript expressions are complex. In this work, we present a new, general array access representation and define operations for it. This allows us to aggregate and simplify the representation enough that precise region operations may be applied to enable compiler optimizations. Our experiments show that these techniques hold promise for speeding up applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> V. Balasundaram and K. Kennedy. </author> <title> A Technique for Summarizing Data Access and its Use in Parallelism Enhancing Transformations. </title> <booktitle> Proceedings of the SIG-PLAN Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: The notion of MUST/MAY approximations helps a compiler to determine when a result is accurate or inaccurate. Linear constraint-based techniques are generally considered more precise than triplet notation in handling access patterns with non-rectangular expressions (see requires worst-case exponential time algorithms [2]. Bal-asundaram and Kennedy <ref> [1] </ref> proposed a simplified form of linear constraint representation, called simple sections, that eliminates the need for such expensive algorithms, but at the cost of accuracy.
Reference: [2] <author> U. Banerjee. </author> <title> Dependence Analysis. </title> <publisher> Kluwer Academic Publishers, Norwell, </publisher> <address> MA, </address> <year> 1997. </year>
Reference-contexts: The notion of MUST/MAY approximations helps a compiler to determine when a result is accurate or inaccurate. Linear constraint-based techniques are generally considered more precise than triplet notation in handling access patterns with non-rectangular expressions (see requires worst-case exponential time algorithms <ref> [2] </ref>. Bal-asundaram and Kennedy [1] proposed a simplified form of linear constraint representation, called simple sections, that eliminates the need for such expensive algorithms, but at the cost of accuracy.
Reference: [3] <author> W. Blume. </author> <title> Symbolic Analysis Techniques for Effective Automatic Parallelization. </title> <type> PhD thesis, </type> <institution> Univ. of Illi-nois at Urbana-Champaign, Dept. of Computer Science, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: In many cases, the simplicity of the real access is hidden inside the subscript expressions, making it difficult to discover. Sometimes originally simple subscript expressions are converted to complex ones during compiler transformations, such as induction variable substitution, value propagation <ref> [3] </ref>, and subroutine inlin-ing [18, 13], although the original access patterns remain intact. Previous techniques sometimes fail to recognize these simple patterns and, as a result, lose accuracy in their access analysis. <p> In order for the difference between the last offset and the first offset (the span) to represent the true distance moved for a dimension, the subscript function must cause movement to be consistently in the same direction. Such a function is called monotonic <ref> [3] </ref>, which will be formally defined in Section 4. This implies that the LMAD can be accurate only when the subscripting functions are monotonic. Thus, to see how often the LMAD can be accurate in reality, we determined the percentage of array accesses that were provably monotonic at compile time. <p> This is, in fact, the reason why many researchers, including several in our own research group at Illinois, have used the notation to implement their compiler techniques (including array privatization, dependence analysis, and message generation <ref> [3, 7, 16, 31] </ref>). However, as discussed in Section 1.2, the limited expressive power of the triplet notation often hinders analysis in some important cases. To alleviate this problem, researchers at Rice University [6] have devised several variants of regular section descriptors (RSDs), with operations defined on a lattice. <p> The results, presented in Figure 12, show that a significant amount of simplification can be achieved in most cases. 6 Applications of LMADs for Compiler Techniques Typically, array privatization and dependence analysis <ref> [3, 9, 14, 29] </ref> are based on array region operations. Thus, their accuracy is heavily dependent on array access analysis. According to our experiments with Po-laris, current techniques are limited in some cases by the complexity of subscripts. To illustrate this, consider the loop in Figure 13.
Reference: [4] <author> W. Blume, R. Doallo, R. Eigenmann, J. Grout, J. Hoe-flinger, T. Lawrence, J. Lee, D. Padua, Y. Paek, W. Pot-tenger, L. Rauchwerger, and P. Tu. </author> <title> Parallel Programming with Polaris. </title> <journal> IEEE Computer, </journal> <volume> 29(12) </volume> <pages> 78-82, </pages> <month> De-cember </month> <year> 1996. </year>
Reference-contexts: Notice that when A 0 (with access region R 0 ) is the k-subLMAD of A (with access region R), then R 0 R. 1.2 Analysis of Subscripting Patterns The development of the access region notation was originally motivated by the project [24, 25] to retarget the Polaris compiler <ref> [4] </ref> at distributed memory multiprocessors. In that project, the triplet notation used by Po-laris for array access analysis prevented us from generating efficient code for our target multiprocessors because subscript expressions that could not be represented accurately in triplet notation limited our compiler optimizations.
Reference: [5] <author> M. Burke and R. Cytron. </author> <title> Interprocedural Dependence Analysis and Parallelization. </title> <booktitle> Proceedings of the SIG-PLAN Symposium on Compiler Construction, </booktitle> <pages> pages 162-175, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Burke and Cytron represented array references in one-dimensional form by linearization <ref> [5] </ref>. These reference-list based techniques lose no precision for any array access because they rely on making a list of each individual array reference in a program section.
Reference: [6] <author> D. Callahan and K. Kennedy. </author> <title> Analysis of Interproce-dural Side Effects in a Parallel Programming Environment. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 5 </volume> <pages> 517-550, </pages> <year> 1988. </year>
Reference-contexts: However, as discussed in Section 1.2, the limited expressive power of the triplet notation often hinders analysis in some important cases. To alleviate this problem, researchers at Rice University <ref> [6] </ref> have devised several variants of regular section descriptors (RSDs), with operations defined on a lattice. RSDs are able to express single array elements, complete rows and columns, and diagonals.
Reference: [7] <author> S. Chatterjee, J. Gilbert, F. Long, R. Schreiber, and S. Teng. </author> <title> Generating Local Address and Communication Sets for Data-Parallel Programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 26(1) </volume> <pages> 72-84, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: This is, in fact, the reason why many researchers, including several in our own research group at Illinois, have used the notation to implement their compiler techniques (including array privatization, dependence analysis, and message generation <ref> [3, 7, 16, 31] </ref>). However, as discussed in Section 1.2, the limited expressive power of the triplet notation often hinders analysis in some important cases. To alleviate this problem, researchers at Rice University [6] have devised several variants of regular section descriptors (RSDs), with operations defined on a lattice.
Reference: [8] <institution> Cray Research Inc. SHMEM Technical Note for Fortran, </institution> <year> 1994. </year>
Reference-contexts: The get works the same way except that the source and destination of data movement are reversed. Most communication primitives supported in existing languages or machines <ref> [8, 10 10, 22, 23] </ref> require triplet notation for fast vector copying between distributed memories. Without simplification of access patterns, we could not generate efficient Put/Get primitives for codes with complex subscript expressions, such as those shown in Figures 2 and 13.
Reference: [9] <author> B. Creusillet and F. Irigoin. </author> <title> Exact vs. Approximate Array Region Analyses. </title> <booktitle> In Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> New York, New York, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: for the access in "X (s 1 (i); s 2 (i); ; s m (i)) subject to l k i k u k ; for k = 1; 2; ; d." Next, the compiler would summarize all the RDs in the section and store their union in some standard representation <ref> [9, 15, 19] </ref>. Simple accesses can be summarized with simple representations without losing precision in access analysis. For example, in Figure 2, the region accessed by reference b (i 1 ; i 2 ) can be represented by b (0:n b :1,0:n b :1) using the traditional triplet notation. <p> The Omega Test [26] is an example of a dependence test built in this way. The PIPS project at Ecole des Mines de Paris <ref> [9] </ref> has added an indicator of the accuracy of the representation, referred to as MUST/MAY, to the representation itself. The notion of MUST/MAY approximations helps a compiler to determine when a result is accurate or inaccurate. <p> The results, presented in Figure 12, show that a significant amount of simplification can be achieved in most cases. 6 Applications of LMADs for Compiler Techniques Typically, array privatization and dependence analysis <ref> [3, 9, 14, 29] </ref> are based on array region operations. Thus, their accuracy is heavily dependent on array access analysis. According to our experiments with Po-laris, current techniques are limited in some cases by the complexity of subscripts. To illustrate this, consider the loop in Figure 13.
Reference: [10] <author> D. Culler, A. Dusseau, S. Goldstein, A. Krishnamurthy, S. Lumetta, T. Eicken, and K. Yelick. </author> <title> Parallel Programming in Split-C. </title> <booktitle> Proceedings of Supercomputing '93, </booktitle> <pages> pages 262-273, </pages> <month> November </month> <year> 1993. </year>
Reference: [11] <author> G. Dantzig and B.Eaves. </author> <title> Fourier-Motzkin Elimination and its Dual. </title> <journal> Journal of Combinatorial Theory, </journal> <pages> pages 288-297, </pages> <year> 1973. </year>
Reference-contexts: In particular, these techniques have been used for dependence analysis. When a potential dependence between two array references is being tested, the linear inequalities associated with the two references are aggregated to form a linear system and the feasibility of the system is tested using Fourier-Motzkin elimination <ref> [11] </ref> techniques. The Omega Test [26] is an example of a dependence test built in this way. The PIPS project at Ecole des Mines de Paris [9] has added an indicator of the accuracy of the representation, referred to as MUST/MAY, to the representation itself.
Reference: [12] <author> R. Graham, D. Knuth, and O. Patashnik. </author> <title> Concrete Mathematics: A Foundation for Computer Science. </title> <publisher> Addison-Wesley Pub. Co., </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: i k fi = fi fi m P (s j (i 1 ; ; i k + 1; ; i d ) s j (i 1 ; ; i k ; ; i d )) j fi fi where h is set to 1, as it is in finite calculus <ref> [12] </ref>. As stated in Section 1, the span i k is the distance moved in the memory region accessed during the iteration of i k from l k to u k .
Reference: [13] <author> J. Grout. </author> <title> Inline Expansion for the Polaris Research Compiler. </title> <type> Master's thesis, </type> <institution> Univ. of Illinois at Urbana-Champaign, Dept. of Computer Science, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: In many cases, the simplicity of the real access is hidden inside the subscript expressions, making it difficult to discover. Sometimes originally simple subscript expressions are converted to complex ones during compiler transformations, such as induction variable substitution, value propagation [3], and subroutine inlin-ing <ref> [18, 13] </ref>, although the original access patterns remain intact. Previous techniques sometimes fail to recognize these simple patterns and, as a result, lose accuracy in their access analysis.
Reference: [14] <author> J. Gu, Z. Li, and G. Lee. </author> <title> Symbolic Array Dataflow Analysis for Array Privatization and Program Paral-lelization. </title> <booktitle> Proceedings of Supercomputing '95, </booktitle> <month> Decem-ber </month> <year> 1995. </year>
Reference-contexts: RSDs are able to express single array elements, complete rows and columns, and diagonals. Restricted RSDs [15] were devised to handle coupled subscripts, and then Bounded RSDs were devised to further improve the accuracy with symbolic bound information. Researchers at the University of Minnesota have used Guarded Array Regions <ref> [14] </ref>, which are equivalent to Bounded RSDs with an additional predicate (guard). <p> The results, presented in Figure 12, show that a significant amount of simplification can be achieved in most cases. 6 Applications of LMADs for Compiler Techniques Typically, array privatization and dependence analysis <ref> [3, 9, 14, 29] </ref> are based on array region operations. Thus, their accuracy is heavily dependent on array access analysis. According to our experiments with Po-laris, current techniques are limited in some cases by the complexity of subscripts. To illustrate this, consider the loop in Figure 13.
Reference: [15] <author> P. Havlak. </author> <title> Interprocedural Symbolic Analysis. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: for the access in "X (s 1 (i); s 2 (i); ; s m (i)) subject to l k i k u k ; for k = 1; 2; ; d." Next, the compiler would summarize all the RDs in the section and store their union in some standard representation <ref> [9, 15, 19] </ref>. Simple accesses can be summarized with simple representations without losing precision in access analysis. For example, in Figure 2, the region accessed by reference b (i 1 ; i 2 ) can be represented by b (0:n b :1,0:n b :1) using the traditional triplet notation. <p> To alleviate this problem, researchers at Rice University [6] have devised several variants of regular section descriptors (RSDs), with operations defined on a lattice. RSDs are able to express single array elements, complete rows and columns, and diagonals. Restricted RSDs <ref> [15] </ref> were devised to handle coupled subscripts, and then Bounded RSDs were devised to further improve the accuracy with symbolic bound information. Researchers at the University of Minnesota have used Guarded Array Regions [14], which are equivalent to Bounded RSDs with an additional predicate (guard).
Reference: [16] <author> S. Hiranandani, K. Kennedy, and C. Tseng. </author> <title> Evaluating Compiler Optimizations for Fortran D. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <pages> pages 27-45, </pages> <year> 1994. </year>
Reference-contexts: This is, in fact, the reason why many researchers, including several in our own research group at Illinois, have used the notation to implement their compiler techniques (including array privatization, dependence analysis, and message generation <ref> [3, 7, 16, 31] </ref>). However, as discussed in Section 1.2, the limited expressive power of the triplet notation often hinders analysis in some important cases. To alleviate this problem, researchers at Rice University [6] have devised several variants of regular section descriptors (RSDs), with operations defined on a lattice.
Reference: [17] <author> J. Hoeflinger. </author> <type> PhD thesis, </type> <institution> Univ. of Illinois at Urbana-Champaign, Dept. of Computer Science, forthcoming. </institution>
Reference-contexts: A more detailed description of these techniques and their implementations will be presented in a forthcoming PhD thesis <ref> [17] </ref>. We believe that our techniques will subsume the existing Polaris intra-procedural parallelization and priva-tization techniques because of the increased precision of the representation.
Reference: [18] <author> C. Huson. </author> <title> An In-line Subroutine Expander for Parafrase. </title> <type> Master's thesis, </type> <institution> Univ. of Illinois at Urbana-Champaign, Dept. of Computer Science, </institution> <month> May </month> <year> 1982. </year>
Reference-contexts: In many cases, the simplicity of the real access is hidden inside the subscript expressions, making it difficult to discover. Sometimes originally simple subscript expressions are converted to complex ones during compiler transformations, such as induction variable substitution, value propagation [3], and subroutine inlin-ing <ref> [18, 13] </ref>, although the original access patterns remain intact. Previous techniques sometimes fail to recognize these simple patterns and, as a result, lose accuracy in their access analysis.
Reference: [19] <author> Z. Li and P. Yew. </author> <title> Efficient Interprocedural Analysis for Program Parallelization and Restructuring. </title> <booktitle> Proceedings of the SIGPLAN Symposium on Parallel Programming: Experience with Applications, Languages and Systems, </booktitle> <month> July </month> <year> 1988. </year>
Reference-contexts: for the access in "X (s 1 (i); s 2 (i); ; s m (i)) subject to l k i k u k ; for k = 1; 2; ; d." Next, the compiler would summarize all the RDs in the section and store their union in some standard representation <ref> [9, 15, 19] </ref>. Simple accesses can be summarized with simple representations without losing precision in access analysis. For example, in Figure 2, the region accessed by reference b (i 1 ; i 2 ) can be represented by b (0:n b :1,0:n b :1) using the traditional triplet notation. <p> More information can be added to the guard to sharpen the accuracy in a given situation. 2.2 Reference-list based techniques Li and Yew proposed a reference-list based representation, called an atom image <ref> [19] </ref>, which captures the coefficients of the loop indices and the loop bounds of each surrounding loop. Burke and Cytron represented array references in one-dimensional form by linearization [5].
Reference: [20] <author> Z. Li, P. Yew, and C. Zhu. </author> <title> An Efficient Data Dependence Analysis for Parallelizing Compilers. </title> <journal> IEEE Transaction on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 26-34, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: not be represented by triplet notation into the following five categories: subscripted-subscripts : accesses due to references with subscripted-subscript expressions; non-affine : accesses due to references with non-affine subscript expressions; triangular affine : accesses due to references within a triangular loop; coupled-subscripts : accesses due to references with coupled-subscript expressions <ref> [20] </ref>; multiple index affine : accesses due to references con taining multiple indices in a subscript position. In this classification, each category excludes those above it. For instance, a reference with a subscripted-subscript inside a triangular loop would be counted as subscripted-subscript, and not triangular affine.
Reference: [21] <author> D. Maydan, S. Amarasinghe, and M. Lam. </author> <title> Array Data-Flow Analysis and its Use in Array Privatization. </title> <booktitle> Proceedings of ACM SIGPLAN Symposium on Principles of Programming Languges, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: Third, Fourier-Motzkin requires that the linear inequalities form a convex hull, forcing a loss of accuracy when regions must be altered to maintain the convex form. Work on the SUIF system at Stanford uses a representation <ref> [21] </ref> very similar to that of PIPS. SUIF uses a set of region operations for systems of linear inequalities and special algorithms for maintaining the convex shape of the regions during the analysis. <p> The difficulty here is that the subscript expressions for array Y are non-affine, and the accesses are made by multiple indices, J and K. Due to these complications, existing array privatization techniques <ref> [21, 31] </ref> cannot identify the exact access region for Y; as a consequence, they could not privatize Y and thus would fail to parallelize the loop. We found that the LMAD is often effective to overcome these limitations.
Reference: [22] <author> Message Passing Interface Forum. </author> <title> MPI-2: Extensions to the Message-Passing Interface, </title> <month> January 12, </month> <year> 1996. </year>
Reference-contexts: The get works the same way except that the source and destination of data movement are reversed. Most communication primitives supported in existing languages or machines <ref> [8, 10 10, 22, 23] </ref> require triplet notation for fast vector copying between distributed memories. Without simplification of access patterns, we could not generate efficient Put/Get primitives for codes with complex subscript expressions, such as those shown in Figures 2 and 13.
Reference: [23] <author> J. Nielocha, R. Harrison, and R. Littlefield. </author> <title> Global Arrays: A Portable Shared-Memory Programming Model for Distributed Memory Computers. </title> <booktitle> Proceedings of Supercomputing '94, </booktitle> <pages> pages 340-349, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: The get works the same way except that the source and destination of data movement are reversed. Most communication primitives supported in existing languages or machines <ref> [8, 10 10, 22, 23] </ref> require triplet notation for fast vector copying between distributed memories. Without simplification of access patterns, we could not generate efficient Put/Get primitives for codes with complex subscript expressions, such as those shown in Figures 2 and 13.
Reference: [24] <author> Y. Paek. </author> <title> Automatic Parallelization for Distributed Memory Machines Based on Access Region Analysis. </title> <type> PhD thesis, </type> <institution> Univ. of Illinois at Urbana-Champaign, Dept. of Computer Science, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: Notice that when A 0 (with access region R 0 ) is the k-subLMAD of A (with access region R), then R 0 R. 1.2 Analysis of Subscripting Patterns The development of the access region notation was originally motivated by the project <ref> [24, 25] </ref> to retarget the Polaris compiler [4] at distributed memory multiprocessors. <p> descriptors of A 5;1 In our distributed memory multiprocessor code gen eration project, mentioned in Section 1.2, the notion of interleaving has been useful to perform three region op erations (aggregation, intersection and subtraction) on the LMAD notations, as will be briefly discussed in Section 6, and to determine subregions <ref> [24] </ref>. <p> A (ij) represents the aggregated region of those represented by A (i) and A (j) ; that is, A (ij) A (i) [ A (j) . 5.4 Other operations In addition to the operations described in this paper, we have devised LMAD algorithms for several other region operations <ref> [24] </ref>: union, intersection, and subtraction. <p> But, by showing that the actual access patterns are just simple consecutive memory accesses, we significantly reduced communication overhead in our target code. In <ref> [24] </ref>, we presented the experimental evidence that the LMAD can be useful to simplify various access patterns with complex subscripts and, thereby, facilitate the application of compiler techniques.
Reference: [25] <author> Y. Paek and D. Padua. </author> <title> Experimental Study of Compiler Techniques for NUMA Machines. </title> <booktitle> IEEE International Parallel Processing Symposium & Symposium on Parallel and Distributed Processing, </booktitle> <month> April </month> <year> 1998. </year>
Reference-contexts: Notice that when A 0 (with access region R 0 ) is the k-subLMAD of A (with access region R), then R 0 R. 1.2 Analysis of Subscripting Patterns The development of the access region notation was originally motivated by the project <ref> [24, 25] </ref> to retarget the Polaris compiler [4] at distributed memory multiprocessors. <p> The LMAD representation is useful not only for array privatization, but also for other techniques depending on array access analysis, including dependence analysis and the generation of communication primitives such as Send/Receive or Put/Get. For instance, in our code transformation <ref> [25] </ref> for multiprocessors with physically distributed memory, we used the LMAD to generate Put/Get primitives of the general form put/get (x (l x :u x :s x ),y (l y :u y :s y ),p).
Reference: [26] <author> W. Pugh. </author> <title> A Practical Algorithm for Exact Array Dependence Analysis. </title> <journal> Communications of the ACM, </journal> <volume> 35(8), </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: When a potential dependence between two array references is being tested, the linear inequalities associated with the two references are aggregated to form a linear system and the feasibility of the system is tested using Fourier-Motzkin elimination [11] techniques. The Omega Test <ref> [26] </ref> is an example of a dependence test built in this way. The PIPS project at Ecole des Mines de Paris [9] has added an indicator of the accuracy of the representation, referred to as MUST/MAY, to the representation itself.
Reference: [27] <author> W. Pugh and D. Wonnacott. </author> <title> Nonlinear Array Dependence Analysis. </title> <type> Technical Report 123, </type> <institution> Univ of Maryland at College Park, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: Second, Fourier-Motzkin is limited to affine expressions. To overcome this limitation, Pugh and Wonnacott <ref> [27] </ref> have developed techniques for replacing non-affine terms occurring in array subscripts with uninterpreted function symbols, but this does not handle all situations involving non-affine terms.
Reference: [28] <author> Z. Shen, Z. Li, and P. Yew. </author> <title> An Empirical Study of Fortran Programs for Parallelizing Compilers. </title> <journal> IEEE Transaction on Parallel and Distributed Systems, </journal> <volume> 1(3) </volume> <pages> 350-364, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Triplet notation is simple, yet practical. Typically, the region operations (e.g., union, subtraction, and intersection) defined on the notation can be implemented with fast linear algorithms. The study of Shen et al <ref> [28] </ref> indicated that most real-world access patterns in scientific programs are representable by triplet notation.
Reference: [29] <author> P. Tang. </author> <title> Exact Side Effects for Interprocedural Dependence Analysis. </title> <journal> Communications of the ACM, </journal> <volume> 35(8) </volume> <pages> 102-114, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: The results, presented in Figure 12, show that a significant amount of simplification can be achieved in most cases. 6 Applications of LMADs for Compiler Techniques Typically, array privatization and dependence analysis <ref> [3, 9, 14, 29] </ref> are based on array region operations. Thus, their accuracy is heavily dependent on array access analysis. According to our experiments with Po-laris, current techniques are limited in some cases by the complexity of subscripts. To illustrate this, consider the loop in Figure 13.
Reference: [30] <author> R. Triolet, F. Irigoin, and P. Feautrier. </author> <title> Direct Paral-lelization of Call Statements. </title> <booktitle> Proceedings of the SIG-PLAN Symposium on Compiler Construction, </booktitle> <pages> pages 176-185, </pages> <year> 1986. </year>
Reference-contexts: The linear constraint-based techniques that were first proposed by Triolet, et al <ref> [30] </ref> have been widely used as an alternative way to summarize array accesses. In particular, these techniques have been used for dependence analysis.
Reference: [31] <author> P. Tu. </author> <title> Automatic Array Privatization and Demand-Driven Symbolic Analysis. </title> <type> PhD thesis, </type> <institution> Univ. of Illinois at Urbana-Champaign, Dept. of Computer Science, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: This is, in fact, the reason why many researchers, including several in our own research group at Illinois, have used the notation to implement their compiler techniques (including array privatization, dependence analysis, and message generation <ref> [3, 7, 16, 31] </ref>). However, as discussed in Section 1.2, the limited expressive power of the triplet notation often hinders analysis in some important cases. To alleviate this problem, researchers at Rice University [6] have devised several variants of regular section descriptors (RSDs), with operations defined on a lattice. <p> The difficulty here is that the subscript expressions for array Y are non-affine, and the accesses are made by multiple indices, J and K. Due to these complications, existing array privatization techniques <ref> [21, 31] </ref> cannot identify the exact access region for Y; as a consequence, they could not privatize Y and thus would fail to parallelize the loop. We found that the LMAD is often effective to overcome these limitations.
References-found: 31

