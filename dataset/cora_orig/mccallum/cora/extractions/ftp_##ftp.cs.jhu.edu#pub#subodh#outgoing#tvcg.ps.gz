URL: ftp://ftp.cs.jhu.edu/pub/subodh/outgoing/tvcg.ps.gz
Refering-URL: http://www.cs.jhu.edu/~subodh/657/ref.html
Root-URL: http://www.cs.jhu.edu
Title: Interactive Display of Large NURBS Models  for Public Release Distribution Unlimited  
Author: Subodh Kumar Dinesh Manocha Anselmo Lastra 
Keyword: NURBS, Tessellation, Triangulation, Visibility, Interactive Display, CAD, Parallel algorithm.  
Note: Supported in part by Alfred P. Sloan Foundation Fellowship, ARO Contract P-34982-MA, DARPA ISTO Order A410, NSF Grant MIP-9306208, DARPA Contract DABT63-93-C-0048, NSF Grants CCR-9319957 and CCR-9625217, ONR Contract N00014-94-1-0738 and NSF/DARPA Science and Technology Center for Computer Graphics and Scientific Visualization, NSF Prime Contract 8920219, and ARO Grant DAAH04-96-1-0013. Approved by ARPA  
Abstract: We present algorithms for interactive rendering of large-scale NURBS models. The algorithms convert the NURBS surfaces to Bezier surfaces, tessellate each Bezier surface into triangles and render them using the triangle-rendering capabilities common to current graphics systems. This paper presents algorithms for computing tight bounds on surface properties in order to generate high quality tessellation of Bezier surfaces. We introduce enhanced visibility determination techniques and present methods to make efficient use of coherence between successive frames. In addition, we also discuss issues in parallelization of these techniques. The algorithm also avoids polygonization anomalies like cracks. Our algorithms work well in practice and, on high-end graphics systems, are able to display models described using thousands of Bezier surfaces at interactive frame rates. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Akeley, </author> <title> "Reality Engine Graphics", </title> <booktitle> in Proceedings of ACM SIGGRAPH, </booktitle> <year> 1993, </year> <pages> pp. 109-116. </pages>
Reference-contexts: Carolina, Department of Computer Sc, Chapel Hill, NC 27599-3175. manocha@cs.unc.edu, http:www.cs.unc.edu/~manocha. 3 University of N. Carolina, Department of Computer Sc, Chapel Hill, NC 27599-3175. lastra@cs.unc.edu, http:www.cs.unc.edu/~lastra. I. Introduction Current graphics systems are capable of rendering millions of transformed, shaded and z-buffered triangles per second <ref> [1] </ref>, [2]. However, in many applications involving CAD/CAM, virtual reality, animation and visualization, the geometric models are described in terms of non-uniform rational B-spline (NURBS) surfaces, not polygons. This class includes Bezier surfaces and other rational parametric surfaces like tensor product and triangular patches. <p> Knots spaced closer than a user specified tolerance 5 are coerced to the same value before knot insertion. Each NURBS surface is thus decomposed into a set of Bezier surfaces. A Bezier patch F of degree m fi n defined by parameters u; v 2 <ref> [0; 1] </ref>, is specified by a mesh of control points C ij ; 0 i m; 0 j n: F (u; v) = i=0 j=0 i (u)B n where the Bernstein polynomial B is given by B n 0 @ i C We drop u and v from the notation, whenever <p> In general, a point p on a patch with normal ~n is backfacing if ~ep ~n &gt; 0; where e is the eye point. In other words, a patch, F, is backfacing if, 8u; v 2 <ref> [0; 1] </ref>; ~n (u; v) makes an acute angle with the vector joining the eye to F (u; v). 7 If S is a bounding sphere for the patch, with radius r and center C, we can find the region in space such that a the point p (u; v) in <p> As a result k C (t + ffi) C (t) k= ffi k X (t 1 ); Y (t 2 ); Z (t 3 ) k 0 0 0 where X 0 0 0 (t) represent the maximum magnitude of X 0 0 0 (t), respectively, in the domain <ref> [0; 1] </ref> and kV k is the L 2 norm of the vector V . <p> F (u; v), the tessellation parameters are computed in object space as: fl fl X (u;v) ; W (u;v) u Z (u;v) fl fl T OL where X (u;v) corresponds to the maximum magnitude of the partial derivative of X (u;v) W (u;v) with respect to u in the domain <ref> [0; 1] </ref> fi [0; 1]. n v is computed analogously. 13 The maximum values of the partial derivates are computed in the following way. <p> the tessellation parameters are computed in object space as: fl fl X (u;v) ; W (u;v) u Z (u;v) fl fl T OL where X (u;v) corresponds to the maximum magnitude of the partial derivative of X (u;v) W (u;v) with respect to u in the domain <ref> [0; 1] </ref> fi [0; 1]. n v is computed analogously. 13 The maximum values of the partial derivates are computed in the following way. <p> Based on the solutions of these equations, we compute the maximum values of f x (u; v) in 14 the domain <ref> [0; 1] </ref> fi [0; 1]. Let the maximum value be at [u x ; v x ]. Similar computations are performed on f y (u; v) and f z (u; v). <p> Based on the solutions of these equations, we compute the maximum values of f x (u; v) in 14 the domain <ref> [0; 1] </ref> fi [0; 1]. Let the maximum value be at [u x ; v x ]. Similar computations are performed on f y (u; v) and f z (u; v). <p> It is applied in a similar manner along the v-axis. Let us first consider the case when n u &gt; n u . We need to choose n u n u additional points in the domain <ref> [0; 1] </ref>, such that the resulting polygonization is smooth. One simple solution is to use tessellations that are powers of two. Thus we need to introduce n u new tessellants subdividing the old tessellation, thereby halving the step size. <p> Currently, we are able to render models consisting of seven to eight hundred Bezier patches at 12 16 frames a second. A. Parallel Implementation Pixel-Planes 5 [2] uses extensive parallelism to increase rendering performance. This has become the practice in high-performance graphics accelerators <ref> [1] </ref>. Figure 4 presents a block diagram of the Pixel-Planes 5 system. Front-end geometry processing, such as transformation, clipping, and setup for rasterization, is performed on the Graphics Processors (GPs) which contain Intel i860 RISC microprocessors running at 40 MHz, 8 MB of main memory, and communications hardware.
Reference: [2] <author> H. Fuchs and J. Poulton et al., </author> <title> "Pixel-Planes 5: A heterogeneous multiprocessor graphics system using processor-enhanced memories", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 23, no. 3, </volume> <pages> pp. 79-88, </pages> <year> 1989, </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Carolina, Department of Computer Sc, Chapel Hill, NC 27599-3175. manocha@cs.unc.edu, http:www.cs.unc.edu/~manocha. 3 University of N. Carolina, Department of Computer Sc, Chapel Hill, NC 27599-3175. lastra@cs.unc.edu, http:www.cs.unc.edu/~lastra. I. Introduction Current graphics systems are capable of rendering millions of transformed, shaded and z-buffered triangles per second [1], <ref> [2] </ref>. However, in many applications involving CAD/CAM, virtual reality, animation and visualization, the geometric models are described in terms of non-uniform rational B-spline (NURBS) surfaces, not polygons. This class includes Bezier surfaces and other rational parametric surfaces like tensor product and triangular patches. <p> Our current implementation on a 1 processor Silicon Graphics Onyx with RealityEngine 2 can display more than a thousand Bezier surfaces and on Pixel-Planes 5 <ref> [2] </ref>, about thirty thousand Bezier surfaces at interactive frame rates. These surfaces were of degrees varying from two to 15. See color images for examples. On multiple-processor machines the algorithm statically partitions the model, distributing it to the processors to balance the load. <p> Currently, we are able to render models consisting of seven to eight hundred Bezier patches at 12 16 frames a second. A. Parallel Implementation Pixel-Planes 5 <ref> [2] </ref> uses extensive parallelism to increase rendering performance. This has become the practice in high-performance graphics accelerators [1]. Figure 4 presents a block diagram of the Pixel-Planes 5 system. <p> Triangle rasterization, and shading is performed on renderer boards which contain arrays of 128 by 128 1-bit processors with local memory <ref> [2] </ref> and an instruction sequencer. The processing units are connected by a 160 million word per second 23 ring communications network. Since we have access to the GPs of Pixel-Planes 5, a parallel implementation of the tessellation algorithm seemed natural.
Reference: [3] <author> E. Catmull, </author> <title> A Subdivision Algorithm for Computer Display of Curved Surfaces, </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1974. </year>
Reference-contexts: Curved surface rendering has been an active area of research for more than two decades. The main techniques are based on pixel-level surface subdivision, ray tracing, scan-line display and polygonization <ref> [3] </ref>, [4], [5], [6], [7], [8], [9]. Techniques based on ray tracing, scan-line display and pixel-level display do not make efficient use of the hardware capabilities available on current graphics systems. As a result, algorithms based on polygonization are, in general, faster.
Reference: [4] <author> J. H. Clark, </author> <title> "A fast algorithm for rendering parametric surfaces", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 13, no. 2, </volume> <pages> pp. 289-299, </pages> <year> 1979, </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Curved surface rendering has been an active area of research for more than two decades. The main techniques are based on pixel-level surface subdivision, ray tracing, scan-line display and polygonization [3], <ref> [4] </ref>, [5], [6], [7], [8], [9]. Techniques based on ray tracing, scan-line display and pixel-level display do not make efficient use of the hardware capabilities available on current graphics systems. As a result, algorithms based on polygonization are, in general, faster.
Reference: [5] <author> J.M. Lane and R.F. Riesenfeld, </author> <title> "Bounds on polynomials", </title> <journal> BIT, </journal> <volume> vol. 21, no. 1, </volume> <pages> pp. 112-117, </pages> <year> 1981. </year>
Reference-contexts: Curved surface rendering has been an active area of research for more than two decades. The main techniques are based on pixel-level surface subdivision, ray tracing, scan-line display and polygonization [3], [4], <ref> [5] </ref>, [6], [7], [8], [9]. Techniques based on ray tracing, scan-line display and pixel-level display do not make efficient use of the hardware capabilities available on current graphics systems. As a result, algorithms based on polygonization are, in general, faster. <p> As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces <ref> [5] </ref>, [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces. <p> Normal Deviation criterion: The deviation of triangle normals from the surface normals should be bounded. To compute the bound on the step size in the parametric domain to satisfy these criteria, we need to compute bounds on polynomials. There is considerable literature on computation of such bounds. <ref> [5] </ref>, [21], [22], [23]. The criteria listed above are related to each other and not all of them need to be used. Further, these criteria are functions of the first, second and higher order derivatives of the surface vector. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters <ref> [5] </ref>, [22], [23]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size as a function of these bounds [20], [21]. <p> Note that all these computations are part of the preprocessing stage. Similarly, the maxima of f x (0; v) corresponds to computing the roots of f x v (0; v) = 0, which can be computed using root-finders or subdivision properties of Bezier curves <ref> [5] </ref>. Based on the solutions of these equations, we compute the maximum values of f x (u; v) in 14 the domain [0; 1] fi [0; 1]. Let the maximum value be at [u x ; v x ].
Reference: [6] <author> A.R. Forrest, </author> <title> "On the rendering of surfaces", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 13, no. 2, </volume> <pages> pp. 253-259, </pages> <year> 1979, </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Curved surface rendering has been an active area of research for more than two decades. The main techniques are based on pixel-level surface subdivision, ray tracing, scan-line display and polygonization [3], [4], [5], <ref> [6] </ref>, [7], [8], [9]. Techniques based on ray tracing, scan-line display and pixel-level display do not make efficient use of the hardware capabilities available on current graphics systems. As a result, algorithms based on polygonization are, in general, faster. <p> Uniform tessellation involves choosing constant step sizes along each parameter, and evaluating points on a regular grid in the parametric domain of a patch. It normally generates more polygons than are necessary for a given viewpoint. By comparison, adaptive tessellation may generate fewer polygons. In general, adaptive tessellation algorithms <ref> [6] </ref>, [14], [16], [17], [18], [19], [25] recursively subdivide patches until each patch is flat or small enough. Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. <p> Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature <ref> [6] </ref>, [14], [16], [17], [18], [19], [25]. We stored the sequence of viewpoints from a user-run of the system. For each of these viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1. Transform the control points of the patch to screen space. 2.
Reference: [7] <author> J. Kajiya, </author> <title> "Ray tracing parametric patches", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 16, no. 3, </volume> <pages> pp. 245-254, </pages> <year> 1982, </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Curved surface rendering has been an active area of research for more than two decades. The main techniques are based on pixel-level surface subdivision, ray tracing, scan-line display and polygonization [3], [4], [5], [6], <ref> [7] </ref>, [8], [9]. Techniques based on ray tracing, scan-line display and pixel-level display do not make efficient use of the hardware capabilities available on current graphics systems. As a result, algorithms based on polygonization are, in general, faster.
Reference: [8] <author> T. Nishita, T.W. Sederberg, and M. Kakimoto, </author> <title> "Ray tracing trimmed rational surface patches", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 24, no. 4, </volume> <pages> pp. 337-345, </pages> <year> 1990, </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Curved surface rendering has been an active area of research for more than two decades. The main techniques are based on pixel-level surface subdivision, ray tracing, scan-line display and polygonization [3], [4], [5], [6], [7], <ref> [8] </ref>, [9]. Techniques based on ray tracing, scan-line display and pixel-level display do not make efficient use of the hardware capabilities available on current graphics systems. As a result, algorithms based on polygonization are, in general, faster.
Reference: [9] <author> J.M. Lane, L.C. Carpenter, J. T. Whitted, and J.F. </author> <title> Blinn, "Scan line methods for displaying parametrically defined surfaces", </title> <journal> Communications of ACM, </journal> <volume> vol. 23, no. 1, </volume> <pages> pp. 23-34, </pages> <year> 1980. </year>
Reference-contexts: Curved surface rendering has been an active area of research for more than two decades. The main techniques are based on pixel-level surface subdivision, ray tracing, scan-line display and polygonization [3], [4], [5], [6], [7], [8], <ref> [9] </ref>. Techniques based on ray tracing, scan-line display and pixel-level display do not make efficient use of the hardware capabilities available on current graphics systems. As a result, algorithms based on polygonization are, in general, faster.
Reference: [10] <author> C.L. Bajaj, </author> <title> "Rational hypersurface display", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 24, no. 2, </volume> <pages> pp. 117-127, </pages> <year> 1990, </year> <title> (Symposium on Interactive 3D Graphics). </title>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], <ref> [10] </ref>, [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces.
Reference: [11] <author> S.S. Abi-Ezzi and L.A. Shirman, </author> <title> "The scaling behavior of viewing transformations", </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> vol. 13, no. 3, </volume> <pages> pp. 48-54, </pages> <year> 1993. </year>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], <ref> [11] </ref>, [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces. <p> However, the bounds used for tessellating the Bezier surfaces are, in general, not tight for rational surfaces and in some cases even undersample the surface. Some techniques to improve the quality of tessellation and the efficiency of its computation are presented in <ref> [11] </ref>, [22], [23]. The algorithm presented in this paper exhibits considerable improvements over previous algorithms. This paper presents the components of an algorithm for interactive 4 display of large-scale NURBS models (see Color plate B) on current graphics systems. <p> Bound Computation We compute improved bounds for the rational surfaces in object space as part of a preprocessing phase. They are used to compute the step sizes as a function of the viewing parameters as shown in <ref> [11] </ref>, [23]. An algorithm for computation of bounds based on the size criterion is presented in [22]. However, we must modify the bounds presented in [22] to use the mean value theorem for vector valued functions. <p> These bounds are invariant to rigid body transformations like rotations and translations. They vary with the perspective transformation matrix as shown in <ref> [11] </ref>. The bounds for the other difference criteria can be computed similarly. In one case we seek to bound the length of the vector connecting two points on the surface, and in the others we seek to bound the angle between tangents or normals.
Reference: [12] <author> R. Bedichek, C. Ebeling, G. Winkenbach, and T. DeRose, </author> <title> "Rapid low-cost display of spline surfaces", </title> <booktitle> in Proceedings of advanced reseach in VLSI, </booktitle> <editor> C. Sequin, Ed., </editor> <publisher> MIT Press, </publisher> <year> 1991, </year> <pages> pp. 340-355. </pages>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], [11], <ref> [12] </ref>, [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces.
Reference: [13] <author> T. DeRose, M. Bailey, B. Barnard, R. Cypher, D. Dobrikin, C. Ebeling, S. Konstantinidou, L. McMurchie, H. Mizrahi, and B. Yost, "Apex: </author> <title> two architectures for generating parametric curves and surfaces", </title> <journal> The Visual Computer, </journal> <volume> vol. 5, no. 5, </volume> <pages> pp. 264-276, </pages> <year> 1989. </year>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], [11], [12], <ref> [13] </ref>, [14], [15], [16], [17], [18], [19], [20], [21], [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces.
Reference: [14] <institution> W.L. Luken, "Tessellation of trimmed NURB surfaces", Computer science research report 19322(84059), IBM Research Division, </institution> <year> 1993. </year>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], [11], [12], [13], <ref> [14] </ref>, [15], [16], [17], [18], [19], [20], [21], [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces. A variant of this algorithm has been implemented as SGI GL and OpenGL primitives. <p> It normally generates more polygons than are necessary for a given viewpoint. By comparison, adaptive tessellation may generate fewer polygons. In general, adaptive tessellation algorithms [6], <ref> [14] </ref>, [16], [17], [18], [19], [25] recursively subdivide patches until each patch is flat or small enough. Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. <p> Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], <ref> [14] </ref>, [16], [17], [18], [19], [25]. We stored the sequence of viewpoints from a user-run of the system. For each of these viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1. Transform the control points of the patch to screen space. 2.
Reference: [15] <author> W.L. Luken and Fuhua Cheng, </author> <title> "Rendering trimmed NURB surfaces", </title> <institution> Computer science research report 18669(81711), IBM Research Division, </institution> <year> 1993. </year>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], [11], [12], [13], [14], <ref> [15] </ref>, [16], [17], [18], [19], [20], [21], [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces. A variant of this algorithm has been implemented as SGI GL and OpenGL primitives.
Reference: [16] <author> F. Cheng, </author> <title> "Computation techniques on NURBS surfaces", </title> <booktitle> in SIAM Conference on Geometric Design, </booktitle> <address> Tempe, AZ, </address> <year> 1993. </year>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], [11], [12], [13], [14], [15], <ref> [16] </ref>, [17], [18], [19], [20], [21], [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces. A variant of this algorithm has been implemented as SGI GL and OpenGL primitives. <p> It normally generates more polygons than are necessary for a given viewpoint. By comparison, adaptive tessellation may generate fewer polygons. In general, adaptive tessellation algorithms [6], [14], <ref> [16] </ref>, [17], [18], [19], [25] recursively subdivide patches until each patch is flat or small enough. Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. <p> Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], [14], <ref> [16] </ref>, [17], [18], [19], [25]. We stored the sequence of viewpoints from a user-run of the system. For each of these viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1. Transform the control points of the patch to screen space. 2.
Reference: [17] <author> M. Shantz and S. Chang, </author> <title> "Rendering trimmed NURBS with adaptive forward differencing", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 22, no. 4, </volume> <pages> pp. 189-198, </pages> <year> 1988, </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], [11], [12], [13], [14], [15], [16], <ref> [17] </ref>, [18], [19], [20], [21], [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces. A variant of this algorithm has been implemented as SGI GL and OpenGL primitives. <p> It normally generates more polygons than are necessary for a given viewpoint. By comparison, adaptive tessellation may generate fewer polygons. In general, adaptive tessellation algorithms [6], [14], [16], <ref> [17] </ref>, [18], [19], [25] recursively subdivide patches until each patch is flat or small enough. Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. <p> Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], [14], [16], <ref> [17] </ref>, [18], [19], [25]. We stored the sequence of viewpoints from a user-run of the system. For each of these viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1. Transform the control points of the patch to screen space. 2.
Reference: [18] <author> M. Shantz and S. Lien, </author> <title> "Shading bicubic patches", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 21, no. 4, </volume> <pages> pp. 189-196, </pages> <year> 1987, </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], [11], [12], [13], [14], [15], [16], [17], <ref> [18] </ref>, [19], [20], [21], [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces. A variant of this algorithm has been implemented as SGI GL and OpenGL primitives. <p> It normally generates more polygons than are necessary for a given viewpoint. By comparison, adaptive tessellation may generate fewer polygons. In general, adaptive tessellation algorithms [6], [14], [16], [17], <ref> [18] </ref>, [19], [25] recursively subdivide patches until each patch is flat or small enough. Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. <p> Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], [14], [16], [17], <ref> [18] </ref>, [19], [25]. We stored the sequence of viewpoints from a user-run of the system. For each of these viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1. Transform the control points of the patch to screen space. 2.
Reference: [19] <author> D.R. Forsey and V. Klassen, </author> <title> "An adaptive subdivision algorithm for crack prevention in the display of parametric surfaces", </title> <booktitle> in Proceedings of Graphics Interface, </booktitle> <year> 1990, </year> <pages> pp. 1-8. </pages>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], [11], [12], [13], [14], [15], [16], [17], [18], <ref> [19] </ref>, [20], [21], [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces. A variant of this algorithm has been implemented as SGI GL and OpenGL primitives. <p> It normally generates more polygons than are necessary for a given viewpoint. By comparison, adaptive tessellation may generate fewer polygons. In general, adaptive tessellation algorithms [6], [14], [16], [17], [18], <ref> [19] </ref>, [25] recursively subdivide patches until each patch is flat or small enough. Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. <p> Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], [14], [16], [17], [18], <ref> [19] </ref>, [25]. We stored the sequence of viewpoints from a user-run of the system. For each of these viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1. Transform the control points of the patch to screen space. 2.
Reference: [20] <author> A. Rockwood, K. Heaton, and T. Davis, </author> <title> "Real-time rendering of trimmed surfaces", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 23, no. 3, </volume> <pages> pp. 107-117, </pages> <year> 1989, </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], <ref> [20] </ref>, [21], [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces. A variant of this algorithm has been implemented as SGI GL and OpenGL primitives. <p> A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], <ref> [20] </ref>, [21], [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces. A variant of this algorithm has been implemented as SGI GL and OpenGL primitives. However, the bounds used for tessellating the Bezier surfaces are, in general, not tight for rational surfaces and in some cases even undersample the surface. <p> The step size is computed as a function of these bounds and viewing parameters [5], [22], [23]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size as a function of these bounds <ref> [20] </ref>, [21]. We require only two mathematical formulations: one for the computation of the `deviation' bounds, and another for the `difference' bounds. Let us first consider the bound computations for the size criterion. <p> Crack Prevention Since the bound for required tessellation for each patch is evaluated independently, different tessellations on two adjacent patches are possible. This could result in cracks in the rendered image. To address this issue <ref> [20] </ref>, [23] suggested that the amount of tessellation at the boundary be based solely on the boundary curve, and a strip of filling triangles be generated at the boundary. <p> The Pixel-Planes implementation is fully parallel, using the maximum number of available processors. The performance of the algorithm on the SGI Onyx is shown in Table IV. The images were rendered with Gouraud shading. The standard SGI-GL implementation is based on the algorithm presented in <ref> [20] </ref>, [31] and has a microcoded geometry engine implementation for surface evaluations. Although it is difficult to compare two different algorithms and implementations (for example, the design constraints may be different), we performed the following experiments using identical sets of viewing parameters.
Reference: [21] <author> A. Rockwood, </author> <title> "A generalized scanning technique for display of parametrically defined surface", </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> vol. 7, no. 8, </volume> <pages> pp. 15-26, </pages> <year> 1987. </year> <month> 30 </month>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], <ref> [21] </ref>, [22], [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces. A variant of this algorithm has been implemented as SGI GL and OpenGL primitives. <p> Normal Deviation criterion: The deviation of triangle normals from the surface normals should be bounded. To compute the bound on the step size in the parametric domain to satisfy these criteria, we need to compute bounds on polynomials. There is considerable literature on computation of such bounds. [5], <ref> [21] </ref>, [22], [23]. The criteria listed above are related to each other and not all of them need to be used. Further, these criteria are functions of the first, second and higher order derivatives of the surface vector. <p> The step size is computed as a function of these bounds and viewing parameters [5], [22], [23]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size as a function of these bounds [20], <ref> [21] </ref>. We require only two mathematical formulations: one for the computation of the `deviation' bounds, and another for the `difference' bounds. Let us first consider the bound computations for the size criterion. <p> Let T OL be the user-specified tolerance in screen space. The step sizes along the u and v directions are given as <ref> [21] </ref>: n u = m max T OL fl min (W ij ) k W ij R ij W i;j+1 R i;j+1 k for (1 i m, 1 j n). In practice these bounds are good for polynomial surfaces only, when W ij = 1. <p> Most surfaces do not have highly varying curvature and are uniformly parametrized. E. Comparison of Methods We empirically compared our bound with those of Rockwood et. al. <ref> [21] </ref> and Abi-Ezzi & Shirman [22]. For each model, these comparisons were performed over a large number of 16 user-driven model inspection runs with different user-specified tolerance values. We collated the averages of the number of triangles generated for each model. <p> The degrees of the patches in these models were between two and three in u as well as v. Some models, e.g. Dragon, contained no rational patches, keeping <ref> [21] </ref>'s bounds tight. For a given tolerance, our bounds result in about 31% fewer triangles than [21] and about 20% fewer than [22]. Color plate B displays the wireframes and shaded images of the pencil and goblet models computed using the three methods. Model Number of Our Algorithm [21]'s Algorithm [22]'s Algorithm Patches Num. Tris. Ratio Num. Tris. Ratio Num. Tris.
Reference: [22] <author> S.S. Abi-Ezzi and L.A. Shirman, </author> <title> "Tessellation of curved surfaces under highly varying transformations", </title> <booktitle> Pro--ceedings of Eurographics, </booktitle> <pages> pp. 385-397, </pages> <year> 1991. </year>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], <ref> [22] </ref>, [23]. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces. A variant of this algorithm has been implemented as SGI GL and OpenGL primitives. <p> However, the bounds used for tessellating the Bezier surfaces are, in general, not tight for rational surfaces and in some cases even undersample the surface. Some techniques to improve the quality of tessellation and the efficiency of its computation are presented in [11], <ref> [22] </ref>, [23]. The algorithm presented in this paper exhibits considerable improvements over previous algorithms. This paper presents the components of an algorithm for interactive 4 display of large-scale NURBS models (see Color plate B) on current graphics systems. <p> Normal Deviation criterion: The deviation of triangle normals from the surface normals should be bounded. To compute the bound on the step size in the parametric domain to satisfy these criteria, we need to compute bounds on polynomials. There is considerable literature on computation of such bounds. [5], [21], <ref> [22] </ref>, [23]. The criteria listed above are related to each other and not all of them need to be used. Further, these criteria are functions of the first, second and higher order derivatives of the surface vector. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters [5], <ref> [22] </ref>, [23]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size as a function of these bounds [20], [21]. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in [11], [23]. An algorithm for computation of bounds based on the size criterion is presented in <ref> [22] </ref>. However, we must modify the bounds presented in [22] to use the mean value theorem for vector valued functions. By performing exact extrema computation, for a given T OL, we improve the tightness of their bounds. We illustrate the derivation of tighter bounds for Bezier curves. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in [11], [23]. An algorithm for computation of bounds based on the size criterion is presented in <ref> [22] </ref>. However, we must modify the bounds presented in [22] to use the mean value theorem for vector valued functions. By performing exact extrema computation, for a given T OL, we improve the tightness of their bounds. We illustrate the derivation of tighter bounds for Bezier curves. It is applied in a similar manner to surfaces. <p> Most surfaces do not have highly varying curvature and are uniformly parametrized. E. Comparison of Methods We empirically compared our bound with those of Rockwood et. al. [21] and Abi-Ezzi & Shirman <ref> [22] </ref>. For each model, these comparisons were performed over a large number of 16 user-driven model inspection runs with different user-specified tolerance values. We collated the averages of the number of triangles generated for each model. <p> Some models, e.g. Dragon, contained no rational patches, keeping [21]'s bounds tight. For a given tolerance, our bounds result in about 31% fewer triangles than [21] and about 20% fewer than <ref> [22] </ref>. Color plate B displays the wireframes and shaded images of the pencil and goblet models computed using the three methods. Model Number of Our Algorithm [21]'s Algorithm [22]'s Algorithm Patches Num. Tris. Ratio Num. Tris. Ratio Num. Tris.
Reference: [23] <author> D. Filip, R. Magedson, and R. Markot, </author> <title> "Surface algorithms using bounds on derivatives", </title> <booktitle> Computer Aided Geometric Design, </booktitle> <volume> vol. 3, no. 4, </volume> <pages> pp. 295-311, </pages> <year> 1986. </year>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. A number of different methods, based on adaptive or uniform subdivision, have been proposed for polygonization of surfaces [5], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], <ref> [23] </ref>. These are based on adaptive or uniform subdivision of NURBS surfaces. In particular, Rockwood et. al. [20] have proposed a real time algorithm for trimmed surfaces. A variant of this algorithm has been implemented as SGI GL and OpenGL primitives. <p> However, the bounds used for tessellating the Bezier surfaces are, in general, not tight for rational surfaces and in some cases even undersample the surface. Some techniques to improve the quality of tessellation and the efficiency of its computation are presented in [11], [22], <ref> [23] </ref>. The algorithm presented in this paper exhibits considerable improvements over previous algorithms. This paper presents the components of an algorithm for interactive 4 display of large-scale NURBS models (see Color plate B) on current graphics systems. <p> In general, adaptive tessellation algorithms [6], [14], [16], [17], [18], [19], [25] recursively subdivide patches until each patch is flat or small enough. Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see <ref> [23] </ref>.) A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], [14], [16], [17], [18], [19], [25]. We stored the sequence of viewpoints from a user-run of the system. <p> To compute the bound on the step size in the parametric domain to satisfy these criteria, we need to compute bounds on polynomials. There is considerable literature on computation of such bounds. [5], [21], [22], <ref> [23] </ref>. The criteria listed above are related to each other and not all of them need to be used. Further, these criteria are functions of the first, second and higher order derivatives of the surface vector. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters [5], [22], <ref> [23] </ref>. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size as a function of these bounds [20], [21]. <p> Bound Computation We compute improved bounds for the rational surfaces in object space as part of a preprocessing phase. They are used to compute the step sizes as a function of the viewing parameters as shown in [11], <ref> [23] </ref>. An algorithm for computation of bounds based on the size criterion is presented in [22]. However, we must modify the bounds presented in [22] to use the mean value theorem for vector valued functions. <p> For example see Fig 3: the curve C is tessellated into two segments P Q and QR, each of magnitude less than T OL. The optimal solution to that problem would be based on the deviation criterion. The bound on deviation is computed using results from <ref> [23] </ref>: For a linearly parametrized triangle T = l (u; v) between three points on a surface at l (0; 0); l (l 1 ; 0) and l (0; l 2 ): (u;v)2T 1 (l 2 2 M 3 ); where M 1 = max kF uu (u; v)k; M 2 <p> Crack Prevention Since the bound for required tessellation for each patch is evaluated independently, different tessellations on two adjacent patches are possible. This could result in cracks in the rendered image. To address this issue [20], <ref> [23] </ref> suggested that the amount of tessellation at the boundary be based solely on the boundary curve, and a strip of filling triangles be generated at the boundary.
Reference: [24] <author> S. Kumar, D. Manocha, and A. Lastra, </author> <title> "Interactive display of large scale NURBS models", in Symposium on Interactive 3D Graphics, </title> <address> Monterey, CA, </address> <year> 1995, </year> <pages> pp. 51-58. </pages>
Reference-contexts: These surfaces were of degrees varying from two to 15. See color images for examples. On multiple-processor machines the algorithm statically partitions the model, distributing it to the processors to balance the load. A preliminary version of this paper has appeared as <ref> [24] </ref>. In the rest of this paper, a basic familiarity with NURBS and Bezier surfaces is assumed. In Section II we analyze the problem of computing polygonal approximations to surface models and give an overview of our approach. In Section III, we consider visibility processing and explain back-patch culling.
Reference: [25] <author> G. Farin, </author> <title> Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide, </title> <publisher> Academic Press Inc., </publisher> <year> 1993. </year>
Reference-contexts: Finally, screen space refers to the 2D coordinate system defined by projecting the image space onto the plane of the screen. Given a NURBS model, we use knot insertion to decompose each NURBS surface into a 5 series of rational Bezier patches <ref> [25] </ref>. Knots spaced closer than a user specified tolerance 5 are coerced to the same value before knot insertion. Each NURBS surface is thus decomposed into a set of Bezier surfaces. <p> A Bezier surface, F (u; v) = (X (u; v); Y (u; v); Z (u; v); W (u; v)); is contained in the convex polytope of the control points <ref> [25] </ref>. Let us denote this convex polytope as P F . We also compute an axis-aligned bounding box, B F , defined by eight vertices as the smallest volume bounding box enclosing P F . 5 We used a value of 2 fi 10 5 6 Fig. 2. <p> It normally generates more polygons than are necessary for a given viewpoint. By comparison, adaptive tessellation may generate fewer polygons. In general, adaptive tessellation algorithms [6], [14], [16], [17], [18], [19], <ref> [25] </ref> recursively subdivide patches until each patch is flat or small enough. Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. <p> Empirical results, which we describe next, suggest that, for lage models, uniform subdivision methods are faster in practice than adaptive subdivision methods. (Also see [23].) A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], [14], [16], [17], [18], [19], <ref> [25] </ref>. We stored the sequence of viewpoints from a user-run of the system. For each of these viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1. Transform the control points of the patch to screen space. 2.
Reference: [26] <author> M.F. Deering and S.R. Nelson, "Leo: </author> <title> A system for cost effective 3d shaded graphics", </title> <booktitle> in Proceedings of ACM SIGGRAPH, </booktitle> <year> 1993, </year> <pages> pp. 101-108. </pages>
Reference: [27] <author> S. Krishnan and D. Manocha, </author> <title> "Global visibility and hidden surface algorithms for free form surfaces", </title> <type> Tech. Rep. </type> <institution> TR94-063, Department of Computer Science, University of North Carolina, </institution> <year> 1994. </year>
Reference-contexts: On the other hand if we detect that a Bezier patch is invisible from a given viewpoint, we don't need to even generate the triangles for that patch. In general, the exact computation of the visible portions of a NURBS model is a non-trivial problem requiring silhouette computation <ref> [27] </ref>. In this section, we show that it is relatively simple to perform a visibility check to find most of the patches that are completely invisible.
Reference: [28] <author> S. Kumar and D. Manocha, </author> <title> "Hierarchical visibility culling for spline models", </title> <booktitle> in Proceedings of Graphics Interface, </booktitle> <address> Toronto, Canada, </address> <year> 1996, </year> <pages> pp. 142-150. </pages>
Reference-contexts: Each point on N (u; v) corresponds to a direction on F (u; v) and P N and B N define a multi-faced pyramid in which all these directions lie <ref> [28] </ref>. Testing for visibility reduces to checking whether each of these control points, or just the bounding box B N , is in the half-space H. In fact, we may use a rectangular box or the convex hull to bound the surface as well.
Reference: [29] <author> D. Manocha and J. Demmel, </author> <title> "Algorithms for intersecting parametric and algebraic curves", </title> <booktitle> in Proceedings of Graphics Interface, </booktitle> <year> 1992, </year> <pages> pp. 232-241. </pages>
Reference-contexts: We compute all roots of these equations and pick the maxima of those. Therefore, the problem of computing the maximum derivative vector is equivalent to computing zeros of polynomial equations. In fact, it geometrically corresponds to curve intersection <ref> [29] </ref>, [30].
Reference: [30] <author> T.W. </author> <title> Sederberg, "Algorithms for algebraic curve intersection", </title> <booktitle> Computer-Aided Design, </booktitle> <volume> vol. 21, no. 9, </volume> <pages> pp. 547-555, </pages> <year> 1989. </year>
Reference-contexts: We compute all roots of these equations and pick the maxima of those. Therefore, the problem of computing the maximum derivative vector is equivalent to computing zeros of polynomial equations. In fact, it geometrically corresponds to curve intersection [29], <ref> [30] </ref>.
Reference: [31] <author> R. Nash, </author> ", <year> 1993, </year> <title> Silicon Graphics, </title> <type> Personal Communication. </type>
Reference-contexts: The Pixel-Planes implementation is fully parallel, using the maximum number of available processors. The performance of the algorithm on the SGI Onyx is shown in Table IV. The images were rendered with Gouraud shading. The standard SGI-GL implementation is based on the algorithm presented in [20], <ref> [31] </ref> and has a microcoded geometry engine implementation for surface evaluations. Although it is difficult to compare two different algorithms and implementations (for example, the design constraints may be different), we performed the following experiments using identical sets of viewing parameters.
Reference: [32] <author> D. </author> <title> Banks, "Interactive manipulation and display of two-dimensional surfaces in four-dimensional space", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 26, </volume> <pages> pp. 197-207, </pages> <year> 1992, </year> <title> (Special Issue on Symposium on Interactive 3D Graphics). </title>
Reference-contexts: These routines may generate arbitrary geometry in immediate mode for the rendering engine to display. This feature has been used successfully for problems which require close coupling between computation and the generation of geometry <ref> [32] </ref>. The tessellation algorithm is implemented as a set of user functions running on the GPs. The algorithm does not require any inter-processor communication during execution. This property not only improves the parallel speedup, but also will make it easier to port the code to another multi-processor machine.
Reference: [33] <author> D. Ellsworth, H. Good, and B. Tebbs, </author> <title> "Distributing display lists on a multicomputer", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 24, no. 2, </volume> <year> 1990, </year> <title> (In Symposium on Interactive 3D Graphics). </title>
Reference-contexts: At the same time, processors with patches occupying a small area on screen may be idle. We experimented with a number of distribution schemes. A random distribution scheme <ref> [33] </ref> does not perform well for our application. The reason is that the cost of rendering a patch can vary significantly. We made an explicit adjacency-based distribution and achieved better performance (see Table V).
Reference: [34] <author> S. Kumar and D. Manocha, </author> <title> "Efficient rendering of trimmed NURBS surfaces", </title> <booktitle> Computer-Aided Design, </booktitle> <volume> vol. 27, no. 7, </volume> <pages> pp. 509-521, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: The preprocessing is costly for applications involving interactive design. It would be useful to extend some of techniques presented in this paper to cases when models can be modified on-line. The techniques described in this paper have been extended to trimmed Bezier surfaces <ref> [34] </ref>. In particular, coherence allows us to efficiently triangulate simple polygons without any artifacts.
Reference: [35] <author> D. Forsey and R.H. Bartels, </author> <title> "Heirarchical b-spline refinement", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 22, no. 4, </volume> <pages> pp. 205-212, </pages> <year> 1988, </year> <note> (SIGGRAPH Proceedings). </note>
Reference: [36] <author> B. O'Neill, </author> <title> Elementary Differential Geometry, </title> <publisher> Academic Press, </publisher> <year> 1966. </year>
Reference: [37] <author> J.V. Uspensky, </author> <title> Theory of Equations, </title> <publisher> McGraw Hill, </publisher> <address> New York, </address> <year> 1948. </year>
References-found: 37

