URL: http://www.cs.indiana.edu/l/www/classes/b622/readings/notes.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/classes/b622/readings/
Root-URL: http://www.cs.indiana.edu
Email: pierce@cs.indiana.edu  
Title: Type Systems  
Author: Benjamin C. Pierce 
Note: Working draft of  This manuscript is an early draft of a book-in-progress on type systems. Some sections are more polished than others, but nothing is really finished: there are numerous bits missing, notational and technical inconsistencies, etc. Comments, suggestions, and corrections areof coursewelcome.  
Date: Spring 1998  June 3, 1998  
Pubnum: CSCI B622,  
Abstract-found: 0
Intro-found: 1
Reference: [AC93] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> 15(4):575631, 1993. A preliminary version appeared in POPL '91 (pp. 104118) and as DEC Systems Research Center Research Report number 62, </note> <month> August </month> <year> 1990. </year>
Reference-contexts: This means that we can represent it using a (finite) cyclic graph: Unfortunately, considering recursive types as regular trees does considerably complicate the syntactic properties of the system. These complications have been addressed for simple languages (in the most definitive example, by Amadio and Cardelli <ref> [AC93] </ref> and Cardone and Coppo [CC91] for the simply typed lambda-calculus with subtyping and recursive types), but significant questions remain open regarding their behavior in more complex contexts. 15.1.2 Recursive Types via Explicit Isomorphisms A more tractable (though, for the programmer, somewhat heavier) solution is to stop short of saying that
Reference: [AC94a] <author> Martjn Abadi and Luca Cardelli. </author> <title> A theory of primitive objects: Second-order systems. </title> <booktitle> In European Symposium on Programming (ESOP), </booktitle> <address> Edinburgh, Scotland, </address> <year> 1994. </year>
Reference-contexts: All of these projects can be done in Pas-cal, C, or C++, but you'll spend more time than you can imagine chasing pointer bugs. E.1 Object Encodings 1. [I] In their book, A Theory of Objects [AC96], and in various earlier articles <ref> [AC94b, AC94a] </ref>, Abadi and Cardelli have proposed a primitive calculus analogous to the lambda-calculus, but with objects (rather than functions) as the basic terms and message passing (rather than application) as the basic mechanism for computation. They develop several type systems for their object-calculus (OC).
Reference: [AC94b] <author> Martjn Abadi and Luca Cardelli. </author> <title> A theory of primitive objects: Untyped and first-order systems. </title> <booktitle> In Theoretical Aspects of Computer Software (TACS), Sendai, </booktitle> <address> Japan, </address> <year> 1994. </year>
Reference-contexts: All of these projects can be done in Pas-cal, C, or C++, but you'll spend more time than you can imagine chasing pointer bugs. E.1 Object Encodings 1. [I] In their book, A Theory of Objects [AC96], and in various earlier articles <ref> [AC94b, AC94a] </ref>, Abadi and Cardelli have proposed a primitive calculus analogous to the lambda-calculus, but with objects (rather than functions) as the basic terms and message passing (rather than application) as the basic mechanism for computation. They develop several type systems for their object-calculus (OC).
Reference: [AC96] <author> Martjn Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: = (F) r+1 , where the induction hypothesis is used in the penultimate step. 2 18.3.3.7 Proposition: All functions on CUPERs definable from the operations in Definition 18.3.2.3 plus are nonexpansive; they are contractive if their outermost operation is record formation or function space formation. 2 Proof: Straightforward induction (see <ref> [AC96] </ref>). 2 18.3.3.8 Exercise [Possibly difficult]: We believe that the only nonexpansive but not contractive function that can be constructed using these operators is the identity. <p> A good reference with pointers to related topics of historical interest is Troelstra and van Dalen's book [TvD88]. A standard reference on PER models in a computer science context is Mitchell's book [Mit96]. Our presentation of CUPERs is a simplified version of the one used by Abadi and Cardelli <ref> [AC96] </ref>. Other treatments of CUPERs can be found in [?, ?] The concept of full abstraction was introduced by Plotkin in [Plo77], which is still well worth reading. Recent progress in the construction of fully abstract models (albeit not yet for F &lt;: ) is reported in [AJM94, HO94, OR94]. <p> All of these projects can be done in Pas-cal, C, or C++, but you'll spend more time than you can imagine chasing pointer bugs. E.1 Object Encodings 1. [I] In their book, A Theory of Objects <ref> [AC96] </ref>, and in various earlier articles [AC94b, AC94a], Abadi and Cardelli have proposed a primitive calculus analogous to the lambda-calculus, but with objects (rather than functions) as the basic terms and message passing (rather than application) as the basic mechanism for computation.
Reference: [ACPP91] <author> Martjn Abadi, Luca Cardelli, Benjamin Pierce, and Gordon Plotkin. </author> <title> Dynamic typing in a statically typed language. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 13(2):237268, </volume> <month> April </month> <year> 1991. </year> <booktitle> Preliminary version in Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages (Austin, </booktitle> <address> TX), </address> <month> January, </month> <year> 1989. </year>
Reference-contexts: These accounts place powerful module systems like those of Standard ML [MTH90] and Objective Caml [Ler95b] on a well-understood and tractable theoretical foundation. Read and implement one of these papers. 4. [I] A series of papers <ref> [ACPP91, LM91, ACPR95] </ref> have proposed adding a type Dynamic to statically typed languages, in order to provide a smooth interface between statically typed and dynamically typed data. (a) Add Dynamic to the implementation of the simply typed lambda-calculus, following [ACPP91]. (b) Extend this implementation to System F (or even Fomega), using <p> implement one of these papers. 4. [I] A series of papers [ACPP91, LM91, ACPR95] have proposed adding a type Dynamic to statically typed languages, in order to provide a smooth interface between statically typed and dynamically typed data. (a) Add Dynamic to the implementation of the simply typed lambda-calculus, following <ref> [ACPP91] </ref>. (b) Extend this implementation to System F (or even Fomega), using ideas in [ACPR95] and your own creativity. 247 E.5 Normalization 1. Numerous proofs, based on different techniques, have been given of the strong normalization of !. Choose three or four and compare them.
Reference: [ACPR95] <author> Martjn Abadi, Luca Cardelli, Benjamin Pierce, and Didier Remy. </author> <title> Dynamic typing in polymorphic languages. </title> <journal> Journal of Functional Programming, </journal> <note> 5(1):111130, January 1995. Preliminary version in Proceedings of the ACM SIGPLAN Workshop on ML and its Applications, </note> <month> June </month> <year> 1992. </year>
Reference-contexts: These accounts place powerful module systems like those of Standard ML [MTH90] and Objective Caml [Ler95b] on a well-understood and tractable theoretical foundation. Read and implement one of these papers. 4. [I] A series of papers <ref> [ACPP91, LM91, ACPR95] </ref> have proposed adding a type Dynamic to statically typed languages, in order to provide a smooth interface between statically typed and dynamically typed data. (a) Add Dynamic to the implementation of the simply typed lambda-calculus, following [ACPP91]. (b) Extend this implementation to System F (or even Fomega), using <p> have proposed adding a type Dynamic to statically typed languages, in order to provide a smooth interface between statically typed and dynamically typed data. (a) Add Dynamic to the implementation of the simply typed lambda-calculus, following [ACPP91]. (b) Extend this implementation to System F (or even Fomega), using ideas in <ref> [ACPR95] </ref> and your own creativity. 247 E.5 Normalization 1. Numerous proofs, based on different techniques, have been given of the strong normalization of !. Choose three or four and compare them. Which of them can be extended to prove strong normalization for 8?
Reference: [AG96] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison Wes-ley, </publisher> <year> 1996. </year>
Reference-contexts: The ML language [MTH90, ?] has a special type called exn that is used for this purpose (cf. [MT91]). Java <ref> [AG96, GJS96] </ref> provides a type Throwable for the same purpose. 60 Finally, the inner evaluation relation is extended with the following rules: try v with e i v R [throw v] i throw v try throw v with e i e v The first rule shows how the handler frame is
Reference: [AJM94] <author> Samson Abramsky, Radha Jagadeesan, and Pasquale Malacaria. </author> <title> Full abstraction for PCF (extended abstract). </title> <editor> In Masami Hagiya and John C. Mitchell, editors, </editor> <booktitle> Theoretical Aspects of Computer Software. International Symposium TACS'94, number 789 in Lecture Notes in Computer Science, </booktitle> <pages> pages 115, </pages> <address> Sendai, Japan, April 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Other treatments of CUPERs can be found in [?, ?] The concept of full abstraction was introduced by Plotkin in [Plo77], which is still well worth reading. Recent progress in the construction of fully abstract models (albeit not yet for F &lt;: ) is reported in <ref> [AJM94, HO94, OR94] </ref>. Parametricity was first studied by Reynolds in the context of representation independence [Rey83]. Parametric models of System F are described in [BFSS90, RR94]. Parametricity in System F &lt;: is considered in [CMMS94]. Good general textbooks on semantics include [Sch86, Gun92, Ten81, Win93, Mit96].
Reference: [AM94] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Separate compilation for Standard ML. </title> <booktitle> In Conference on Programming Language Design and Implementation, </booktitle> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference: [Apo93] <author> Marja Virginia Aponte. </author> <title> Extending record typing to type parametric modules with sharing. </title> <booktitle> In Proceedings 20th Symposium on Principles of Programming Languages. ACM, </booktitle> <month> January </month> <year> 1993. </year> <pages> 248 249 </pages>
Reference: [Bar] <author> H. P. Barendregt. </author> <title> Functional programming and lambda calculus. </title> <journal> volume B, </journal> <volume> chapter 7, </volume> <pages> pages 321364. </pages>
Reference-contexts: The standard text for all aspects of the untyped lambda-calculus is Barendregt [Bar84]. Hindley and Seldin [HS86] is less comprehensive, but somewhat more accessible. Barendregt's article in the Handbook of Theoretical Computer Science <ref> [Bar] </ref> is a compact survey. The simply typed lambda-calculus is studied in Hindley and Seldin [HS86] and in even greater detail in Hindley's more recent book [?].
Reference: [Bar84] <author> H. P. Barendregt. </author> <title> The Lambda Calculus. </title> <address> North Holland, </address> <note> revised edition, </note> <year> 1984. </year>
Reference-contexts: We will adopt a Church-style presentation throughout. 2.7 Further Reading The untyped lambda-calculus was developed by Church and his co-workers in the 1930s [Chu41]. The standard text for all aspects of the untyped lambda-calculus is Barendregt <ref> [Bar84] </ref>. Hindley and Seldin [HS86] is less comprehensive, but somewhat more accessible. Barendregt's article in the Handbook of Theoretical Computer Science [Bar] is a compact survey. The simply typed lambda-calculus is studied in Hindley and Seldin [HS86] and in even greater detail in Hindley's more recent book [?].
Reference: [Bar92a] <author> Henk Barendregt. </author> <title> Introduction to generalized type systems. </title> <journal> Journal of Functional Programming, </journal> <year> 1992. </year>
Reference-contexts: and add a fourth level to classify kind expressions according to their functionality? In fact, why stop there? We could go on adding levels indefinitely! The answer is that we could very well do this, and such systems (without subtyping) have been studied under the heading of pure type systems <ref> [Bar92a, Bar92b, JMP94, MP93, Pol94, etc.] </ref> and used in computer science for applications such as theorem proving. For purposes of this book, though, there is no need to go beyond three levels. 20.2 Definitions We now define a core calculus with type operators.
Reference: [Bar92b] <author> Henk Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In Gabbay Abramsky and Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, volume II. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: and add a fourth level to classify kind expressions according to their functionality? In fact, why stop there? We could go on adding levels indefinitely! The answer is that we could very well do this, and such systems (without subtyping) have been studied under the heading of pure type systems <ref> [Bar92a, Bar92b, JMP94, MP93, Pol94, etc.] </ref> and used in computer science for applications such as theorem proving. For purposes of this book, though, there is no need to go beyond three levels. 20.2 Definitions We now define a core calculus with type operators.
Reference: [BCGS91] <author> Val Breazu-Tannen, Thierry Coquand, Carl Gunter, and Andre Scedrov. </author> <title> Inheritance as implicit coercion. Information and Computation, </title> <address> 93:172221, </address> <year> 1991. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: Curien and Ghelli [CG92, Ghe90] address a number of syntactic properties of F &lt;: . Semantic aspects of closely related systems have been studied by Bruce and Longo [BL90], Martini [Mar88], Breazu-Tannen, Coquand, Gunter, and Scedrov <ref> [BCGS91] </ref>, Cardone [Car89], Cardelli and Longo [CL91], Cardelli, Martini, Mitchell, and Scedrov [?], Curien and Ghelli [CG92, CG], and Bruce and 126 Mitchell [BM92].
Reference: [BCP97] <author> Kim B. Bruce, Luca Cardelli, and Benjamin C. Pierce. </author> <title> Comparing object encodings. </title> <booktitle> In Theoretical Aspects of Computer Software (TACS), Sendai, </booktitle> <address> Japan, </address> <month> September </month> <year> 1997. </year> <note> An earlier version was presented as an invited lecture at the Third International Workshop on Foundations of Object Oriented Languages (FOOL 3), </note> <month> July </month> <year> 1996. </year>
Reference-contexts: They develop several type systems for their object-calculus (OC). Implement one or more of these. 2. [T] Bruce, Cardelli, and Pierce have recently written a paper <ref> [BCP97] </ref> com 244 245 paring four different lambda-calculus encodings of objectsthe existential encoding presented in Chapters 24 and ??, the recursive record encoding mentioned in Chapter 15, and two other, hybrid, models with more refined properties. <p> A number of different points of comparison are addressed in the paper, but different encodings of classes in the four object models are not considered. (a) Using the typechecker that we've used for exercises and for the exam ples in the notes, implement the examples in <ref> [BCP97] </ref>. (b) Extend these examples to include encodings of classes and inheritance, following Chapter 24 in the case of the existential encoding and other papers (see the bibliography of [BCP97]) for the other encodings. (c) Compare and contrast. (d) If time remains, it would also be very interesting to compare and <p> (a) Using the typechecker that we've used for exercises and for the exam ples in the notes, implement the examples in <ref> [BCP97] </ref>. (b) Extend these examples to include encodings of classes and inheritance, following Chapter 24 in the case of the existential encoding and other papers (see the bibliography of [BCP97]) for the other encodings. (c) Compare and contrast. (d) If time remains, it would also be very interesting to compare and contrast the imperative variants of these four encodingsi.e., versions of the encodings where the instance variables of objects can be mutable Ref cells. 3. [I] Chapter ?? shows how
Reference: [BDMN79] <author> Graham M. Birtwistle, Ole-Johan Dahl, Bjorn Myhrhaug, and Kristen Nygaard. </author> <title> Simula Begin. </title> <institution> Studentlitteratur (Lund, Sweden), Bratt Institut fuer neues Lernen (Goch, FRG), Chartwell-Bratt Ltd (Kent, </institution> <address> England), </address> <year> 1979. </year>
Reference: [BFSS90] <author> S. Bainbridge, P. Freyd, A. Scedrov, and P. Scott. </author> <title> Functorial polymorphism. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 70:3564, </address> <year> 1990. </year>
Reference-contexts: Recent progress in the construction of fully abstract models (albeit not yet for F &lt;: ) is reported in [AJM94, HO94, OR94]. Parametricity was first studied by Reynolds in the context of representation independence [Rey83]. Parametric models of System F are described in <ref> [BFSS90, RR94] </ref>. Parametricity in System F &lt;: is considered in [CMMS94]. Good general textbooks on semantics include [Sch86, Gun92, Ten81, Win93, Mit96].
Reference: [Bis95] <author> Sandip K. Biswas. </author> <title> Higher-order functors with transparent signatures. </title> <booktitle> In Conference record of POPL '95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM, </booktitle> <month> January </month> <year> 1995. </year>
Reference: [BL90] <author> Kim B. Bruce and Giuseppe Longo. </author> <title> A modest model of records, inheritance, and bounded quantification. Information and Computation, </title> <address> 87:196240, </address> <year> 1990. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year> <note> An earlier version appeared in the proceedings of the IEEE Symposium on Logic in Computer Science, </note> <year> 1988. </year>
Reference-contexts: Curien and Ghelli [CG92, Ghe90] address a number of syntactic properties of F &lt;: . Semantic aspects of closely related systems have been studied by Bruce and Longo <ref> [BL90] </ref>, Martini [Mar88], Breazu-Tannen, Coquand, Gunter, and Scedrov [BCGS91], Cardone [Car89], Cardelli and Longo [CL91], Cardelli, Martini, Mitchell, and Scedrov [?], Curien and Ghelli [CG92, CG], and Bruce and 126 Mitchell [BM92]. <p> Bounded quantification also plays a key role in Cardelli's programming language Quest [Car91, CL91] and in the Abel language developed at HP Labs [CCHO89, CCH + 89, CHO88, CHC90]. The original Fun was simplified and slightly generalized by Bruce and Longo <ref> [BL90] </ref>, and again by Curien and Ghelli [CG92]. We will discuss both Cardelli and Weg-ner's original language, now commonly called kernel F &lt;: (F-sub) and Curien and Ghelli's formulation, called full F &lt;: . We use the name F &lt;: to refer ambiguously to both systems.
Reference: [BM92] <author> Kim Bruce and John Mitchell. </author> <title> PER models of subtyping, recursive types and higher-order polymorphism. </title> <booktitle> In Proceedings of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albequerque, NM, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Semantic aspects of closely related systems have been studied by Bruce and Longo [BL90], Martini [Mar88], Breazu-Tannen, Coquand, Gunter, and Scedrov [BCGS91], Cardone [Car89], Cardelli and Longo [CL91], Cardelli, Martini, Mitchell, and Scedrov [?], Curien and Ghelli [CG92, CG], and Bruce and 126 Mitchell <ref> [BM92] </ref>. F &lt;: has been extended to include record types and richer notions of inheritance by Cardelli and Mitchell [CM91], Bruce [Bru91], Cardelli [Car92], and Canning, Cook, Hill, Olthoff, and Mitchell [CCH + 89]. <p> Simple models have been given by Cardelli and Longo [CL91] and Compagnoni and Pierce [CP96]. A model for an extension of F ! &lt;: with recur sive types has been given by Bruce and Mitchell <ref> [BM92] </ref>. <p> method of an emtpy list object needs to return an empty list. 25.0.1.1 Exercise: Define cons. 2 199 The observation that lists with a map method demand recursively defined type operators is discussed by Bruce and Mitchell in their paper on the semantics of F ! &lt;: with recursive types <ref> [BM92] </ref>; they credit this example to Luca Cardelli and members of the Abel group at HP. 25.0.2 Generic Treatment of Recursive Objects ...
Reference: [Bru91] <author> Kim B. Bruce. </author> <title> The equivalence of two semantic definitions for inheritance in object-oriented languages. </title> <booktitle> In Proceedings of Mathematical Foundations of Programming Semantics, </booktitle> <address> Pittsburgh, PA, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: F &lt;: has been extended to include record types and richer notions of inheritance by Cardelli and Mitchell [CM91], Bruce <ref> [Bru91] </ref>, Cardelli [Car92], and Canning, Cook, Hill, Olthoff, and Mitchell [CCH + 89]. Bounded quantification also plays a key role in Cardelli's programming language Quest [Car91, CL91] and in the Abel language developed at HP Labs [CCHO89, CCH + 89, CHO88, CHC90].
Reference: [Car84] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In G. Kahn, D. MacQueen, and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 5167. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <note> Full version in Information and Computation 76(2/3):138164, </note> <year> 1988. </year>
Reference-contexts: Based on informal ideas by Cardelli and formalized using techniques developed by Mitchell [Mit84b], Fun integrated Girard-Reynolds polymorphism [Gir72, Rey74] with Cardelli's first-order calculus of subtyping <ref> [?, Car84] </ref>. Fun and its relatives have been studied extensively by programming language theorists and designers. Cardelli and Wegner's survey paper gives the first programming examples using bounded quantification; more are developed in Cardelli's study of power kinds [Car88].
Reference: [Car86] <author> Luca Cardelli. </author> <title> Amber. </title> <editor> In Guy Cousineau, Pierre-Louis Curien, and Bernard Robinet, editors, </editor> <booktitle> Combinators and Functional Programming Languages, </booktitle> <pages> pages 21 47. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <booktitle> Lecture Notes in Computer Science No. </booktitle> <volume> 242. </volume> <pages> 250 </pages>
Reference-contexts: The correct rule is this one: + &lt;: : Recursive types and subtyping Requires 2 &lt;: Subtyping: (X) = X&lt;:T (S-TVAR-LEQ) ;Y&lt;:Top; X&lt;:Y ` S &lt;: T (S-REC) This rule was first used by Cardelli in the language Amber <ref> [Car86] </ref>, and is now commonly called the Amber rule for subtyping recursive types. It captures the intuition of consistency: two recursive types are in the subtype relation if it is consistent for them to bei.e., if assuming they are allows us to prove that they are.
Reference: [Car88] <author> Luca Cardelli. </author> <title> Structural subtyping and the notion of power type. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 7079, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: Fun and its relatives have been studied extensively by programming language theorists and designers. Cardelli and Wegner's survey paper gives the first programming examples using bounded quantification; more are developed in Cardelli's study of power kinds <ref> [Car88] </ref>. Curien and Ghelli [CG92, Ghe90] address a number of syntactic properties of F &lt;: .
Reference: [Car89] <author> Felice Cardone. </author> <title> Relational semantics for recursive types and bounded quantification. </title> <booktitle> In Proceedings of the Sixteenth International Colloquium on Automata, Languages, and Programming, volume 372 of Lecture Notes in Computer Science, </booktitle> <pages> pages 164178, </pages> <address> Stresa, Italy, July 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Curien and Ghelli [CG92, Ghe90] address a number of syntactic properties of F &lt;: . Semantic aspects of closely related systems have been studied by Bruce and Longo [BL90], Martini [Mar88], Breazu-Tannen, Coquand, Gunter, and Scedrov [BCGS91], Cardone <ref> [Car89] </ref>, Cardelli and Longo [CL91], Cardelli, Martini, Mitchell, and Scedrov [?], Curien and Ghelli [CG92, CG], and Bruce and 126 Mitchell [BM92].
Reference: [Car90] <author> Luca Cardelli. </author> <title> Notes about F ! &lt;: </title> . <type> Unpublished manuscript, </type> <month> October </month> <year> 1990. </year>
Reference: [Car91] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> An earlier version appeared as DEC Systems Research Center Research Report #45, </note> <month> February </month> <year> 1989. </year>
Reference-contexts: F &lt;: has been extended to include record types and richer notions of inheritance by Cardelli and Mitchell [CM91], Bruce [Bru91], Cardelli [Car92], and Canning, Cook, Hill, Olthoff, and Mitchell [CCH + 89]. Bounded quantification also plays a key role in Cardelli's programming language Quest <ref> [Car91, CL91] </ref> and in the Abel language developed at HP Labs [CCHO89, CCH + 89, CHO88, CHC90]. The original Fun was simplified and slightly generalized by Bruce and Longo [BL90], and again by Curien and Ghelli [CG92].
Reference: [Car92] <author> Luca Cardelli. </author> <title> Extensible records in a pure calculus of subtyping. </title> <type> Research report 81, </type> <institution> DEC Systems Research Center, </institution> <month> January </month> <year> 1992. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: The encoding presented here was discovered by Cardelli <ref> [Car92] </ref>. We begin by defining flexible tuples as follows: 16.3.2.1 Definition: For each n 0 and types T 1 through T n , let Ti def = Pair T 1 (Pair T 2 ... (Pair T n Top)...): In particular, - = Top. <p> F &lt;: has been extended to include record types and richer notions of inheritance by Cardelli and Mitchell [CM91], Bruce [Bru91], Cardelli <ref> [Car92] </ref>, and Canning, Cook, Hill, Olthoff, and Mitchell [CCH + 89]. Bounded quantification also plays a key role in Cardelli's programming language Quest [Car91, CL91] and in the Abel language developed at HP Labs [CCHO89, CCH + 89, CHO88, CHC90].
Reference: [Car96] <author> Luca Cardelli. </author> <title> Type systems. </title> <editor> In Allen B. Tucker, editor, </editor> <booktitle> Handbook of Computer Science and Engineering. </booktitle> <publisher> CRC Press, </publisher> <year> 1996. </year> <note> To appear. </note>
Reference: [CC91] <author> Felice Cardone and Mario Coppo. </author> <title> Type inference with recursive types: Syntax and semantics. Information and Computation, </title> <address> 92(1):4880, </address> <year> 1991. </year>
Reference-contexts: These complications have been addressed for simple languages (in the most definitive example, by Amadio and Cardelli [AC93] and Cardone and Coppo <ref> [CC91] </ref> for the simply typed lambda-calculus with subtyping and recursive types), but significant questions remain open regarding their behavior in more complex contexts. 15.1.2 Recursive Types via Explicit Isomorphisms A more tractable (though, for the programmer, somewhat heavier) solution is to stop short of saying that a recursive type and its
Reference: [CCH + 89] <author> Peter Canning, William Cook, Walter Hill, Walter Olthoff, and John Mitchell. </author> <title> F-bounded quantification for object-oriented programming. </title> <booktitle> In Fourth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273280, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: F &lt;: has been extended to include record types and richer notions of inheritance by Cardelli and Mitchell [CM91], Bruce [Bru91], Cardelli [Car92], and Canning, Cook, Hill, Olthoff, and Mitchell <ref> [CCH + 89] </ref>. Bounded quantification also plays a key role in Cardelli's programming language Quest [Car91, CL91] and in the Abel language developed at HP Labs [CCHO89, CCH + 89, CHO88, CHC90]. <p> Bounded quantification also plays a key role in Cardelli's programming language Quest [Car91, CL91] and in the Abel language developed at HP Labs <ref> [CCHO89, CCH + 89, CHO88, CHC90] </ref>. The original Fun was simplified and slightly generalized by Bruce and Longo [BL90], and again by Curien and Ghelli [CG92].
Reference: [CCHO89] <author> Peter Canning, William Cook, Walt Hill, and Walter Olthoff. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <booktitle> In Object Oriented Programing: Systems, Languages, and Applications (OOPSLA), </booktitle> <pages> pages 457467, </pages> <year> 1989. </year>
Reference-contexts: Bounded quantification also plays a key role in Cardelli's programming language Quest [Car91, CL91] and in the Abel language developed at HP Labs <ref> [CCHO89, CCH + 89, CHO88, CHC90] </ref>. The original Fun was simplified and slightly generalized by Bruce and Longo [BL90], and again by Curien and Ghelli [CG92].
Reference: [CDC78] <author> M. Coppo and M. Dezani-Ciancaglini. </author> <title> A new type-assignment for -terms. </title> <journal> Archiv Math. Logik, </journal> <volume> 19:139156, </volume> <year> 1978. </year>
Reference: [CDS79] <author> M. Coppo, M. Dezani, and P. </author> <title> Salle. Functional characterization of some semantic equalities inside -calculus. </title> <booktitle> Number 81 in Lecture Notes in Computer Science, </booktitle> <pages> pages 133146. </pages> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference: [CF58] <author> H. B. Curry and R. </author> <title> Feys. </title> <booktitle> Combinatory Logic, </booktitle> <volume> volume 1. </volume> <publisher> North Holland, </publisher> <year> 1958. </year>
Reference: [CG] <author> Pierre-Louis Curien and Giorgio Ghelli. </author> <title> Subtyping + extensionality: </title> <booktitle> Conflu ence of fij-reductions in F . pages 731749. </booktitle>
Reference-contexts: Semantic aspects of closely related systems have been studied by Bruce and Longo [BL90], Martini [Mar88], Breazu-Tannen, Coquand, Gunter, and Scedrov [BCGS91], Cardone [Car89], Cardelli and Longo [CL91], Cardelli, Martini, Mitchell, and Scedrov [?], Curien and Ghelli <ref> [CG92, CG] </ref>, and Bruce and 126 Mitchell [BM92]. F &lt;: has been extended to include record types and richer notions of inheritance by Cardelli and Mitchell [CM91], Bruce [Bru91], Cardelli [Car92], and Canning, Cook, Hill, Olthoff, and Mitchell [CCH + 89].
Reference: [CG92] <author> Pierre-Louis Curien and Giorgio Ghelli. </author> <title> Coherence of subsumption: Minimum typing and type-checking in F . Mathematical Structures in Computer Science, </title> <address> 2:5591, </address> <year> 1992. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: Fun and its relatives have been studied extensively by programming language theorists and designers. Cardelli and Wegner's survey paper gives the first programming examples using bounded quantification; more are developed in Cardelli's study of power kinds [Car88]. Curien and Ghelli <ref> [CG92, Ghe90] </ref> address a number of syntactic properties of F &lt;: . <p> Semantic aspects of closely related systems have been studied by Bruce and Longo [BL90], Martini [Mar88], Breazu-Tannen, Coquand, Gunter, and Scedrov [BCGS91], Cardone [Car89], Cardelli and Longo [CL91], Cardelli, Martini, Mitchell, and Scedrov [?], Curien and Ghelli <ref> [CG92, CG] </ref>, and Bruce and 126 Mitchell [BM92]. F &lt;: has been extended to include record types and richer notions of inheritance by Cardelli and Mitchell [CM91], Bruce [Bru91], Cardelli [Car92], and Canning, Cook, Hill, Olthoff, and Mitchell [CCH + 89]. <p> Bounded quantification also plays a key role in Cardelli's programming language Quest [Car91, CL91] and in the Abel language developed at HP Labs [CCHO89, CCH + 89, CHO88, CHC90]. The original Fun was simplified and slightly generalized by Bruce and Longo [BL90], and again by Curien and Ghelli <ref> [CG92] </ref>. We will discuss both Cardelli and Weg-ner's original language, now commonly called kernel F &lt;: (F-sub) and Curien and Ghelli's formulation, called full F &lt;: . We use the name F &lt;: to refer ambiguously to both systems.
Reference: [CH88] <author> Thierry Coquand and Gerard Huet. </author> <title> The Calculus of Constructions. </title> <booktitle> Information and Computation, 76(2/3):95120, February/March 1988. </booktitle> <pages> 251 </pages>
Reference: [CHC90] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not sub-typing. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125135, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: Bounded quantification also plays a key role in Cardelli's programming language Quest [Car91, CL91] and in the Abel language developed at HP Labs <ref> [CCHO89, CCH + 89, CHO88, CHC90] </ref>. The original Fun was simplified and slightly generalized by Bruce and Longo [BL90], and again by Curien and Ghelli [CG92].
Reference: [CHO88] <author> Peter Canning, Walt Hill, and Walter Olthoff. </author> <title> A kernel language for object-oriented programming. </title> <type> Technical Report STL-88-21, </type> <institution> Hewlett-Packard Labs, </institution> <year> 1988. </year>
Reference-contexts: Bounded quantification also plays a key role in Cardelli's programming language Quest [Car91, CL91] and in the Abel language developed at HP Labs <ref> [CCHO89, CCH + 89, CHO88, CHC90] </ref>. The original Fun was simplified and slightly generalized by Bruce and Longo [BL90], and again by Curien and Ghelli [CG92].
Reference: [Chu40] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5:5668, </volume> <year> 1940. </year>
Reference: [Chu41] <author> Alonzo Church. </author> <title> The Calculi of Lambda Conversion. </title> <publisher> Princeton University Press, </publisher> <year> 1941. </year>
Reference-contexts: To a large degree, the choice is a matter of taste, though Church-style systems generally pose fewer algorithmic problems for typecheckers. We will adopt a Church-style presentation throughout. 2.7 Further Reading The untyped lambda-calculus was developed by Church and his co-workers in the 1930s <ref> [Chu41] </ref>. The standard text for all aspects of the untyped lambda-calculus is Barendregt [Bar84]. Hindley and Seldin [HS86] is less comprehensive, but somewhat more accessible. Barendregt's article in the Handbook of Theoretical Computer Science [Bar] is a compact survey.
Reference: [CL90] <author> Luca Cardelli and Xavier Leroy. </author> <title> Abstract types and the dot notation. </title> <type> Technical Report report 56, </type> <institution> DEC SRC, </institution> <year> 1990. </year>
Reference: [CL91] <author> Luca Cardelli and Giuseppe Longo. </author> <title> A semantic basis for Quest. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(4):417458, </volume> <month> October </month> <year> 1991. </year> <note> Preliminary version in ACM Conference on Lisp and Functional Programming, June 1990. Also available as DEC SRC Research Report 55, </note> <month> Feb. </month> <year> 1990. </year>
Reference-contexts: Curien and Ghelli [CG92, Ghe90] address a number of syntactic properties of F &lt;: . Semantic aspects of closely related systems have been studied by Bruce and Longo [BL90], Martini [Mar88], Breazu-Tannen, Coquand, Gunter, and Scedrov [BCGS91], Cardone [Car89], Cardelli and Longo <ref> [CL91] </ref>, Cardelli, Martini, Mitchell, and Scedrov [?], Curien and Ghelli [CG92, CG], and Bruce and 126 Mitchell [BM92]. <p> F &lt;: has been extended to include record types and richer notions of inheritance by Cardelli and Mitchell [CM91], Bruce [Bru91], Cardelli [Car92], and Canning, Cook, Hill, Olthoff, and Mitchell [CCH + 89]. Bounded quantification also plays a key role in Cardelli's programming language Quest <ref> [Car91, CL91] </ref> and in the Abel language developed at HP Labs [CCHO89, CCH + 89, CHO88, CHC90]. The original Fun was simplified and slightly generalized by Bruce and Longo [BL90], and again by Curien and Ghelli [CG92]. <p> Simple models have been given by Cardelli and Longo <ref> [CL91] </ref> and Compagnoni and Pierce [CP96]. A model for an extension of F ! &lt;: with recur sive types has been given by Bruce and Mitchell [BM92].
Reference: [CM91] <author> Luca Cardelli and John Mitchell. </author> <note> Operations on records. Mathematical Structures in Computer Science, 1:348, 1991. </note> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design (MIT Press, </title> <note> 1994); available as DEC Systems Research Center Research Report #48, </note> <month> August, </month> <year> 1989, </year> <booktitle> and in the proceedings of MFPS '89, </booktitle> <publisher> Springer LNCS volume 442. </publisher>
Reference-contexts: F &lt;: has been extended to include record types and richer notions of inheritance by Cardelli and Mitchell <ref> [CM91] </ref>, Bruce [Bru91], Cardelli [Car92], and Canning, Cook, Hill, Olthoff, and Mitchell [CCH + 89]. Bounded quantification also plays a key role in Cardelli's programming language Quest [Car91, CL91] and in the Abel language developed at HP Labs [CCHO89, CCH + 89, CHO88, CHC90].
Reference: [CMMS94] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An extension of system F with subtyping. </title> <journal> Information and Computation, </journal> <note> 109(12):456, 1994. A preliminary version appeared in TACS '91 (Sendai, Japan, pp. 750770). </note>
Reference-contexts: Parametricity was first studied by Reynolds in the context of representation independence [Rey83]. Parametric models of System F are described in [BFSS90, RR94]. Parametricity in System F &lt;: is considered in <ref> [CMMS94] </ref>. Good general textbooks on semantics include [Sch86, Gun92, Ten81, Win93, Mit96].
Reference: [Com94] <author> Adriana B. Compagnoni. </author> <title> Decidability of higher-order subtyping with intersection types. </title> <booktitle> In Computer Science Logic, </booktitle> <month> September </month> <year> 1994. </year> <title> Kazimierz, </title> <booktitle> Poland. Springer Lecture Notes in Computer Science 933, </booktitle> <month> June </month> <year> 1995. </year> <note> Also available as University of Edinburgh, LFCS technical report ECS-LFCS-94-281, titled Subtyp-ing in F ! ^ is decidable. </note>
Reference-contexts: each K, define the type expression Top K as follows: Top * = Top Show that ` S : K implies ` S &lt;: Top K . 2 23.2 Historical Notes F ! The metatheory of pure F ! &lt;: has been studied by Steffen and Pierce [PS94] and Compagnoni <ref> [Com94] </ref>. Simple models have been given by Cardelli and Longo [CL91] and Compagnoni and Pierce [CP96]. A model for an extension of F ! &lt;: with recur sive types has been given by Bruce and Mitchell [BM92].
Reference: [Con86] <author> Robert L. Constable, et. al. </author> <title> Implementing Mathematics with the NuPRL Proof De velopment System. </title> <address> PrenticeHall, Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference: [Coq85] <author> Thierry Coquand. </author> <title> Une Theorie des Constructions. </title> <type> PhD thesis, </type> <institution> University Paris VII, </institution> <month> January </month> <year> 1985. </year>
Reference: [CP96] <author> Adriana B. Compagnoni and Benjamin C. Pierce. </author> <title> Intersection types and multiple inheritance. </title> <note> Mathematical Structures in Computer Science, 6(5):469501, Oc-tober 1996. Preliminary version available as University of Edinburgh technical report ECS-LFCS-93-275 and Catholic University Nijmegen computer science technical report 93-18, </note> <month> Aug. </month> <year> 1993, </year> <title> under the title Multiple Inheritance via Intersec tion Types. </title>
Reference-contexts: Simple models have been given by Cardelli and Longo [CL91] and Compagnoni and Pierce <ref> [CP96] </ref>. A model for an extension of F ! &lt;: with recur sive types has been given by Bruce and Mitchell [BM92].
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year> <month> 252 </month>
Reference-contexts: We give here the simplest variant, called the kernel subtyping rule for universal quantifiers, in which the bounds of the two quantifiers being compared must be identical. (The term kernel comes from Cardelli and Wegner's original paper <ref> [CW85] </ref>, where this variant of F &lt;: was called Kernel Fun.) 8 &lt;:k : Bounded universals (kernel system) Includes 8 + &lt;: Syntax: T ::= T!T type of functions X type variable 8 [ X&lt;:T ]T polymorphic function type t ::= x variable [x:T]t abstraction t t application [ X&lt;:T ]t <p> Show that S-REC-WRONG and S-REC actually agree whenever S is covariant in X and T is covariant in Y. (See 9.1.2 for the definition of covariant.) 2 16.6 Historical Notes The idea of bounded quantification was introduced by Cardelli and Wegner <ref> [CW85] </ref> in the language Fun. Based on informal ideas by Cardelli and formalized using techniques developed by Mitchell [Mit84b], Fun integrated Girard-Reynolds polymorphism [Gir72, Rey74] with Cardelli's first-order calculus of subtyping [?, Car84]. Fun and its relatives have been studied extensively by programming language theorists and designers.
Reference: [dB80] <author> Nicolas G. de Bruijn. </author> <title> A survey of the project AUTOMATH. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays in Combinatory Logic, Lambda Calculus, and Formalism, </booktitle> <pages> pages 589606. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference: [DM82] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207212, </pages> <year> 1982. </year>
Reference: [Fre89] <author> Peter J. Freyd. </author> <title> POLYNAT in PER. </title> <editor> In John W. Gray and Andre Scedrov, editors, </editor> <booktitle> Categories in Computer Science and Logic, volume 92 of Contemporary Mathematics, </booktitle> <pages> pages 6768, </pages> <address> Providence, Rhode Island, 1989. </address> <publisher> American Mathematical Society. </publisher>
Reference-contexts: The other cases are left as exercises. 2 152 Similar in spirit but more complex is Freyd's proof that every element of the type [[8 [X] (X!X)!X!X]] must be related to the interpretation of a Church numeral <ref> [Fre89] </ref>.
Reference: [Ghe90] <author> Giorgio Ghelli. </author> <title> Proof Theoretic Studies about a Minimal Type System Integrating Inclusion and Parametric Polymorphism. </title> <type> PhD thesis, </type> <institution> UniversitOEa di Pisa, </institution> <month> March </month> <year> 1990. </year> <type> Technical report TD6/90, </type> <institution> Dipartimento di Informatica, UniversitOEa di Pisa. </institution>
Reference-contexts: Fun and its relatives have been studied extensively by programming language theorists and designers. Cardelli and Wegner's survey paper gives the first programming examples using bounded quantification; more are developed in Cardelli's study of power kinds [Car88]. Curien and Ghelli <ref> [CG92, Ghe90] </ref> address a number of syntactic properties of F &lt;: . <p> Consider S!Top and T!Top. The types in part (2) were discovered by Ghelli <ref> [Ghe90, p. 92] </ref>. 243 Solution to 17.4.2.4: Note that the two kinds of quantifiersbounded and unbounded should not be allowed to mix: there should be a subtyping rule for comparing two bounded quantifiers and another for two unbounded quantifiers, but no rule for comparing a bounded to an unbounded quantifier.
Reference: [Ghe95] <author> Giorgio Ghelli. </author> <title> Divergence of F type checking. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 139(1,2):131162, </address> <year> 1995. </year>
Reference-contexts: Solution on page 239. 2 17.4.2 Undecidability The earlier proof of termination of the subtyping algorithm does not work for the full system 8 &lt;:f . (Exercise: why?) Indeed, this subtype relation can actually be shown to be undecidable! For example, here is an input, due to Ghelli <ref> [Ghe95] </ref>, that makes the subtype algorithm diverge.
Reference: [Gir72] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arith-metique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: It was developed, independently, in the early 1970s by a computer scientist, John Reynolds, who called it the polymorphic lambda-calculus [Rey74], and by a logician, Jean-Yves Girard, who called it System F <ref> [Gir72] </ref>. It has been used extensively as a primary research vehicle for foundational work on polymorphism and as the basis for numerous programming language designs. 12.2 Definitions The definition of the polymorphic lambda-calculus is actually a very straightforward extension of the simply typed lambda-calculus. <p> Based on informal ideas by Cardelli and formalized using techniques developed by Mitchell [Mit84b], Fun integrated Girard-Reynolds polymorphism <ref> [Gir72, Rey74] </ref> with Cardelli's first-order calculus of subtyping [?, Car84]. Fun and its relatives have been studied extensively by programming language theorists and designers. Cardelli and Wegner's survey paper gives the first programming examples using bounded quantification; more are developed in Cardelli's study of power kinds [Car88].
Reference: [Gir87] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 50:1102, </address> <year> 1987. </year>
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: The ML language [MTH90, ?] has a special type called exn that is used for this purpose (cf. [MT91]). Java <ref> [AG96, GJS96] </ref> provides a type Throwable for the same purpose. 60 Finally, the inner evaluation relation is extended with the following rules: try v with e i v R [throw v] i throw v try throw v with e i e v The first rule shows how the handler frame is
Reference: [GLT89] <author> Jean-Yves Girard, Yves Lafont, and Paul Taylor. </author> <title> Proofs and Types, </title> <booktitle> volume 7 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1989. </year>
Reference-contexts: If not, explain why not. Solution on page 233. 2 5.3 Strong Normalization The presentation in this section follows the structure of of Girard's adaptation <ref> [GLT89] </ref> of Tait's original proof [Tai67]. 5.3.1 Definition: When s is strongly normalizable, we write (s) for the length of the longest reduction sequence starting from s. 2 The key problem in proving strong normalization lies in finding a strong enough induction hypothesis. <p> the proof of strong normalization to handle records. 2 5.3.10 Exercise [Easy]: Show how to extend the proof of strong normalization to handle booleans and conditionals. 2 5.3.11 Exercise [Moderate]: Show how to extend the proof of strong normalization to handle numbers and iteration. (The solution can be found in <ref> [GLT89] </ref>.) 2 Chapter 6 Type Reconstruction Given an explicitly typed term in the simply typed lambda-calculus, we have seen an algorithm for determining its type, if it has one.
Reference: [GMW79] <author> Michael J. Gordon, Robin Milner, and Christopher P. </author> <title> Wadsworth. </title> <publisher> Edinburgh LCF. Springer-Verlag LNCS 78, </publisher> <year> 1979. </year>
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: Using the typechecker from class, develop a more sig nificant object-oriented program following the same lines. (a) To get started, implement a group of collection classes (for example, using the collection classes of Smalltalk <ref> [GR83] </ref> as a model). Some hints for how to do this can be found in [PT94]. (b) Use these classes as a library to implement a larger object-oriented pro gram of your choice.
Reference: [Gun92] <author> C. A. Gunter. </author> <title> Semantics of Programming Languages: Structures and Techniques. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: of D in the following sense: (a) r+1 (nat (n)) = nat (n) if n r ? otherwise (b) r+1 (fun (f)) = fun (x: r (f ( r (x)))). 156 (c) r+1 (rcd (f)) = rcd (l: if l r then r (f (l)) else ?) 2 Proof: See <ref> [Gun92] </ref> or any other standard text on domain theory. 2 In other words, D has N ? , Rcd (D), andin particularits own function space [D!D] as subdomains, and D is obtained as the limit of an increasing sequence of finite subsetsthe ranges D r of the r . <p> Parametricity was first studied by Reynolds in the context of representation independence [Rey83]. Parametric models of System F are described in [BFSS90, RR94]. Parametricity in System F &lt;: is considered in [CMMS94]. Good general textbooks on semantics include <ref> [Sch86, Gun92, Ten81, Win93, Mit96] </ref>.
Reference: [HHP92] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the ACM, </journal> <note> 40(1):143184, 1992. Preliminary version in LICS'87. </note>
Reference-contexts: it.) 26.1.3 Exercise [Recommended]: Extend the logic above with conjunction and the following rules: p q (AND-I) p p ^ q (AND-E-2) Write an LF term encoding a proof of the proposition (P^Q) ) (Q^P). 2 26.2 Definitions Close to the Simplified variant of LF introduced in Appendix A of <ref> [HHP92] </ref>. : Dependent functions Requires ! Syntax: K ::= * kind of proper types 8 [x:T]K kind of dependent type operators T ::= X type variable 8 [x:T]T type of functions [x:T]T dependent type operator T t dependent operator application t ::= x variable [x:T]t abstraction t t application ::= ; <p> Some hints for how to do this can be found in [PT94]. (b) Use these classes as a library to implement a larger object-oriented pro gram of your choice. E.2 Encodings of Logics 1. [I] The Logical Framework of Harper, Honsell, and Plotkin <ref> [HHP92] </ref> is a typed lambda-calculus intended to be used as a meta-language for defining logics and proving theorems in them. (a) Implement LF (b) Use your implementation to encode a simple propositional logic and prove a small theorem. 2. [T] A generalization of the LF logic has been used as the
Reference: [HL94a] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Proceedings of the Twenty-First ACM Symposium on Principles of Programming Languages (POPL), Portland, Oregon, </booktitle> <pages> pages 123137, </pages> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Implement one of these pro posals. E.4 Other Type Systems 1. [T] Implement a lambda-calculus with intersection types (or, harder: with intersection and union types). 2. [T] Implement a linear type system for the lambda-calculus [Wad91, Wad90, TWM95]. 3. [T] Harper and Lillibridge <ref> [HL94a] </ref> and Leroy [Ler96] have independently proposed similar accounts of modules (in the style of ML) using the type-theoretic tools of existential types and (a limited form of) dependent types.
Reference: [HL94b] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Conference record of POPL '94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 123137, </pages> <address> Port-land, OR, </address> <month> January </month> <year> 1994. </year>
Reference: [HMM90] <author> Robert Harper, John C. Mitchell, and Eugenio Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Conference record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 341354, </pages> <address> San Fran-cisco, CA, </address> <month> January </month> <year> 1990. </year> <month> 253 </month>
Reference: [HO94] <author> J. M. E. Hyland and C.-H. L. Ong. </author> <title> On full abstraction for PCF: I, II and III. </title> <note> Submitted for publication; electronic draft available through ftp://ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Luke.Ong/, </note> <year> 1994. </year>
Reference-contexts: Other treatments of CUPERs can be found in [?, ?] The concept of full abstraction was introduced by Plotkin in [Plo77], which is still well worth reading. Recent progress in the construction of fully abstract models (albeit not yet for F &lt;: ) is reported in <ref> [AJM94, HO94, OR94] </ref>. Parametricity was first studied by Reynolds in the context of representation independence [Rey83]. Parametric models of System F are described in [BFSS90, RR94]. Parametricity in System F &lt;: is considered in [CMMS94]. Good general textbooks on semantics include [Sch86, Gun92, Ten81, Win93, Mit96].
Reference: [Hoo84] <author> J.G. Hook. </author> <title> Understanding Russell a first attempt. </title> <booktitle> In Proc. Int. Symp. on Semantics of Data Types, Sophia-Antipolis (France), </booktitle> <publisher> Springer LNCS 173, </publisher> <pages> pages 6985. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference: [How80] <author> W. A. Howard. </author> <title> The formulas-as-types notion of construction. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus, and Formalism, </booktitle> <pages> pages 479490. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1980. </year> <note> Reprint of 1969 article. </note>
Reference: [HP95a] <author> Martin Hofmann and Benjamin Pierce. </author> <title> Positive subtyping. </title> <booktitle> In Proceedings of Twenty-Second Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 186197. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1995. </year> <note> Full version in Information and Computation, volume 126, number 1, April 1996. Also available as University of Edinburgh technical report ECS-LFCS-94-303, </note> <month> September </month> <year> 1994. </year>
Reference-contexts: the syntax of F &lt;: , as we shall see in Chapter 19, but such extensions cannot be interpreted in the PER model as it stands; it is, however, possible to construct a more refined PER model, using a different interpretation of subtyping, in which polymorphic update functions do exist <ref> [HP95a, Pol96, ?] </ref>. Next we examine the interpretations of impredicative encodings of algebraic datatypes, such as the Church booleans and Church numerals introduced in Section 12.5. 18.2.2.9 Proposition: Let CBool be the PER [[8 [X] X!X!X]]. Let tt = x: y: x and ff = x: y: y.
Reference: [HP95b] <author> Martin Hofmann and Benjamin Pierce. </author> <title> A unifying type-theoretic framework for objects. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(4):593635, </volume> <month> October </month> <year> 1995. </year> <note> Previous versions appeared in the Symposium on Theoretical Aspects of Computer Science, </note> <year> 1994, </year> <title> (pages 251262) and, under the title An Abstract View of Objects and Subtyping (Preliminary Report), as University of Edinburgh, </title> <type> LFCS technical report ECS-LFCS-92-226, </type> <year> 1992. </year>
Reference: [HS86] <author> J. Roger Hindley and Jonathan P. Seldin. </author> <title> Introduction to Combinators and - Calculus, volume 1 of London Mathematical Society Student Texts. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: We will adopt a Church-style presentation throughout. 2.7 Further Reading The untyped lambda-calculus was developed by Church and his co-workers in the 1930s [Chu41]. The standard text for all aspects of the untyped lambda-calculus is Barendregt [Bar84]. Hindley and Seldin <ref> [HS86] </ref> is less comprehensive, but somewhat more accessible. Barendregt's article in the Handbook of Theoretical Computer Science [Bar] is a compact survey. The simply typed lambda-calculus is studied in Hindley and Seldin [HS86] and in even greater detail in Hindley's more recent book [?]. <p> The standard text for all aspects of the untyped lambda-calculus is Barendregt [Bar84]. Hindley and Seldin <ref> [HS86] </ref> is less comprehensive, but somewhat more accessible. Barendregt's article in the Handbook of Theoretical Computer Science [Bar] is a compact survey. The simply typed lambda-calculus is studied in Hindley and Seldin [HS86] and in even greater detail in Hindley's more recent book [?]. Material on both typed and untyped lambda-calculus can also be found in many textbooks on functional programming languages (e.g. [PJL92]) and programming language semantics (e.g.[Sch86, Gun92, Win93, Mit96]).
Reference: [JMP94] <author> L.S. van Benthem Jutting, James McKinna, and Robert Pollack. </author> <title> Checking algorithms for Pure Type Systems. </title> <editor> In Henk Barendregt and Tobias Nipkow, editors, </editor> <booktitle> Proceedings of the International Workshop on Types for Proofs and Programs, pages 1961, </booktitle> <address> Nijmegen, The Netherlands, </address> <month> May </month> <year> 1994. </year> <note> Springer-Verlag LNCS 806. </note>
Reference-contexts: and add a fourth level to classify kind expressions according to their functionality? In fact, why stop there? We could go on adding levels indefinitely! The answer is that we could very well do this, and such systems (without subtyping) have been studied under the heading of pure type systems <ref> [Bar92a, Bar92b, JMP94, MP93, Pol94, etc.] </ref> and used in computer science for applications such as theorem proving. For purposes of this book, though, there is no need to go beyond three levels. 20.2 Definitions We now define a core calculus with type operators.
Reference: [Jon96] <author> Mark P. Jones. </author> <title> Using parameterized signatures to express modular structure. </title> <booktitle> In Conference Record of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'96), </booktitle> <address> St. Petersburg, Florida, </address> <month> January 2124, </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: We will return to the issue with much more powerful tools at our command in Chapter 30. 22.8 Further Reading Mark Jones's paper Using Parameterized Signatures to Express Modular Structure <ref> [Jon96] </ref> includes a good summary of recent type-theoretic approaches to modularity and a 182 detailed comparison of their strengths and weaknesses, as well as a number of arguments in favor of the sharing by parameterization approach. (Unfortunately, the proliferation of parameters to type operators, which I feel is the most damaging
Reference: [KS92] <author> Dinesh Katiyar and Sriram Sankar. </author> <title> Completely bounded quantification is decidable. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Otherwise we'd be right back where we started! 1. See <ref> [KS92] </ref> for details. 2. No. In any practical language with subtyping, we will want to allow width subtyping on record types.
Reference: [LAB + 81] <author> B. Liskov, R. Atkinson, T. Bloom, E. Moss, J.C. Schaffert, R. Scheifler, and A. Sny-der. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference: [Ler94a] <author> Xavier Leroy. </author> <title> Manifest types, modules and separate compilation. </title> <booktitle> In Conference record of POPL '94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109122, </pages> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference: [Ler94b] <author> Xavier Leroy. </author> <title> A syntactic theory of type generativity and sharing. </title> <booktitle> In Record of the 1994 ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year> <month> 254 </month>
Reference: [Ler95a] <author> Xavier Leroy. </author> <title> Applicative functors and fully transparent higher-order modules. </title> <booktitle> In Conference record of POPL '95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM, </booktitle> <month> January </month> <year> 1995. </year>
Reference: [Ler95b] <author> Xavier Leroy. </author> <title> Applicative functors and fully transparent higher-order modules. </title> <booktitle> In Proceedings of the Twenty-Second ACM Symposium on Principles of Programming Languages (POPL), Portland, Oregon, </booktitle> <pages> pages 142153, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: These accounts place powerful module systems like those of Standard ML [MTH90] and Objective Caml <ref> [Ler95b] </ref> on a well-understood and tractable theoretical foundation.
Reference: [Ler96] <author> Xavier Leroy. </author> <title> A syntactic theory of type generativity and sharing. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(5):667698, </volume> <month> September </month> <year> 1996. </year>
Reference-contexts: Implement one of these pro posals. E.4 Other Type Systems 1. [T] Implement a lambda-calculus with intersection types (or, harder: with intersection and union types). 2. [T] Implement a linear type system for the lambda-calculus [Wad91, Wad90, TWM95]. 3. [T] Harper and Lillibridge [HL94a] and Leroy <ref> [Ler96] </ref> have independently proposed similar accounts of modules (in the style of ML) using the type-theoretic tools of existential types and (a limited form of) dependent types. These accounts place powerful module systems like those of Standard ML [MTH90] and Objective Caml [Ler95b] on a well-understood and tractable theoretical foundation.
Reference: [LM91] <author> Xavier Leroy and Michel Mauny. </author> <title> Dynamics in ML. </title> <editor> In John Hughes, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture 1991, volume 523 of Lecture Notes in Computer Science, </booktitle> <pages> pages 406426. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: These accounts place powerful module systems like those of Standard ML [MTH90] and Objective Caml [Ler95b] on a well-understood and tractable theoretical foundation. Read and implement one of these papers. 4. [I] A series of papers <ref> [ACPP91, LM91, ACPR95] </ref> have proposed adding a type Dynamic to statically typed languages, in order to provide a smooth interface between statically typed and dynamically typed data. (a) Add Dynamic to the implementation of the simply typed lambda-calculus, following [ACPP91]. (b) Extend this implementation to System F (or even Fomega), using
Reference: [Luo90] <author> Zhaohui Luo. </author> <title> An Extended Calculus of Constructions. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <month> June </month> <year> 1990. </year>
Reference: [Mac86] <author> David MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In 13th Annual ACM Symposium on Principles of Programming languages, </booktitle> <pages> pages 277286, </pages> <address> St. Petersburg Beach, FL, </address> <month> January </month> <year> 1986. </year>
Reference: [Mar73] <author> Per Martin-Lof. </author> <title> An intuitionistic theory of types: predicative part. </title> <editor> In H. E. Rose and J. C. Shepherdson, editors, </editor> <booktitle> Logic Colloquium, </booktitle> <volume> '73, </volume> <pages> pages 73118, </pages> <address> Amsterdam, 1973. </address> <publisher> North Holland. </publisher>
Reference: [Mar82] <author> Per Martin-L of. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In Logic, Methodology and Philosophy of Science, VI. </booktitle> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1982. </year>
Reference: [Mar88] <author> Simone Martini. </author> <title> Bounded quantifiers have interval models. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 174183, </pages> <address> Snowbird, Utah, </address> <month> July </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: Curien and Ghelli [CG92, Ghe90] address a number of syntactic properties of F &lt;: . Semantic aspects of closely related systems have been studied by Bruce and Longo [BL90], Martini <ref> [Mar88] </ref>, Breazu-Tannen, Coquand, Gunter, and Scedrov [BCGS91], Cardone [Car89], Cardelli and Longo [CL91], Cardelli, Martini, Mitchell, and Scedrov [?], Curien and Ghelli [CG92, CG], and Bruce and 126 Mitchell [BM92].
Reference: [MH88] <author> John Mitchell and Robert Harper. </author> <title> The essence of ML. </title> <booktitle> In Fiftheenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, CA, </address> <month> January </month> <year> 1988. </year>
Reference: [Mil78] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17:348375, </volume> <month> August </month> <year> 1978. </year>
Reference: [Mit84a] <author> John C. Mitchell. </author> <title> Coercion and type inference (summary). </title> <booktitle> In Proc. 11th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 175185, </pages> <month> January </month> <year> 1984. </year>
Reference: [Mit84b] <author> John C. Mitchell. </author> <title> Type inference and type containment. </title> <booktitle> In Proc. Int. Symp. on Semantics of Data Types, Sophia-Antipolis (France), </booktitle> <pages> pages 257278, </pages> <address> Berlin, </address> <month> June </month> <year> 1984. </year> <note> Springer LNCS 173. Full version in Information and Computation, vol. 76, no. 2/3, </note> <year> 1988, </year> <pages> pp. </pages> <month> 211249. </month> <title> Reprinted in Logical Foundations of Functional Programming, </title> <editor> ed. G. Huet, </editor> <publisher> Addison-Wesley (1990) 153194. </publisher>
Reference-contexts: Based on informal ideas by Cardelli and formalized using techniques developed by Mitchell <ref> [Mit84b] </ref>, Fun integrated Girard-Reynolds polymorphism [Gir72, Rey74] with Cardelli's first-order calculus of subtyping [?, Car84]. Fun and its relatives have been studied extensively by programming language theorists and designers.
Reference: [Mit90] <author> J. C. Mitchell. </author> <title> Type systems for programming languages. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Volume B, </volume> <pages> pages 365458. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference: [Mit96] <author> John C. Mitchell. </author> <booktitle> Foundations of Programming Languages. </booktitle> <publisher> The MIT Press, </publisher> <address> Cam-bridge, MA, </address> <year> 1996. </year> <month> 255 </month>
Reference-contexts: A good reference with pointers to related topics of historical interest is Troelstra and van Dalen's book [TvD88]. A standard reference on PER models in a computer science context is Mitchell's book <ref> [Mit96] </ref>. Our presentation of CUPERs is a simplified version of the one used by Abadi and Cardelli [AC96]. Other treatments of CUPERs can be found in [?, ?] The concept of full abstraction was introduced by Plotkin in [Plo77], which is still well worth reading. <p> Parametricity was first studied by Reynolds in the context of representation independence [Rey83]. Parametric models of System F are described in [BFSS90, RR94]. Parametricity in System F &lt;: is considered in [CMMS94]. Good general textbooks on semantics include <ref> [Sch86, Gun92, Ten81, Win93, Mit96] </ref>.
Reference: [MMH96] <author> Yasuhiko Minamide, Greg Morrisett, and Robert Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Twenty-third ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 271283, </pages> <address> St. Petersburg, FL, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: This connection between existential objects and closures has been explored in detail by Minamide, Morrisett, and Harper <ref> [MMH96] </ref>. 103 104 Notice that this declaration is recursive: the type being defined appears at part of the definition. So, strictly, speaking, we should not call this a definition at all, but rather an equation that we wish to be satisfied by the type Counter, if it exists.
Reference: [MMM91] <author> John Mitchell, Sigurd Meldal, and Neel Madhav. </author> <title> An extension of Standard ML modules with subtyping and inheritance. </title> <booktitle> In Conference record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Orlando, FL, </address> <month> January </month> <year> 1991. </year>
Reference: [Mog89] <author> Eugenio Moggi. </author> <title> A category-theoretic account of program modules. </title> <booktitle> In Summer conference on category theory and computer science, </booktitle> <pages> pages 101117, </pages> <address> New York, </address> <year> 1989. </year> <note> Springer-Verlag. Lecture Notes in Computer Science, 389. </note>
Reference: [MP88] <author> John C. Mitchell and Gordon D. Plotkin. </author> <title> Abstract types have existential types. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <note> 10(3):470502, 1988. Preliminary version appeared in Proc. 12th ACM Symp. on Principles of Programming Languages, </note> <year> 1985. </year>
Reference-contexts: The declared typings of the operations show which instances of -x:Nat-in their actual (concrete) types should be hidden. The following programming style with existential types, due to Mitchell and Plotkin <ref> [MP88] </ref>, mimics the above definition exactly: counterADT = -/Counter = -x:Ref (Nat)-, -new : Unit! * Counter = [_:Unit] -x=ref Nat 0-, get : Counter! * Nat = [i:-x:Ref (Nat)-] !(i.x), inc : Counter! * Counter = [i:-x:Ref (Nat)-] ((i.x) := succ (!(i.x)); i)--; eval let -/Counter,/counter-=counterADT in counter.get (counter.inc (counter.new
Reference: [MP91] <author> Spiro Michaylov and Frank Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <editor> In L.-H. Eriksson, L. Hallnas, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 299344, </pages> <address> Stockholm, Sweden, </address> <month> January </month> <year> 1991. </year> <note> Springer-Verlag LNAI 596. </note>
Reference-contexts: of Frank Pfen ning's logic programming language ELF [Pfe89, Pfe91, Pfe94, Pfe96]. (a) Download and install the ELF system. 246 (b) Use it to encode the syntax and typing rules of the simply typed lambda-calculus with subtyping and prove some simple theorems about the sys tem, along the lines of <ref> [MP91] </ref>. E.3 Type Inference 1. [T] Implement a type inference system for the simply typed lambda-calculus (or ML) with subtyping. (The literature on approaches to this problem is huge.
Reference: [MP93] <author> James McKinna and Robert Pollack. </author> <title> Pure Type Sytems formalized. </title> <editor> In M. Bezem and J. F. Groote, editors, </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <pages> pages 289305. </pages> <publisher> Springer-Verlag LNCS 664, </publisher> <month> March </month> <year> 1993. </year>
Reference-contexts: and add a fourth level to classify kind expressions according to their functionality? In fact, why stop there? We could go on adding levels indefinitely! The answer is that we could very well do this, and such systems (without subtyping) have been studied under the heading of pure type systems <ref> [Bar92a, Bar92b, JMP94, MP93, Pol94, etc.] </ref> and used in computer science for applications such as theorem proving. For purposes of this book, though, there is no need to go beyond three levels. 20.2 Definitions We now define a core calculus with type operators.
Reference: [MT91] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: The ML language [MTH90, ?] has a special type called exn that is used for this purpose (cf. <ref> [MT91] </ref>).
Reference: [MT94] <author> David B. MacQueen and Mads Tofte. </author> <title> A semantics for higher-order functors. </title> <editor> In D. Sannella, editor, </editor> <booktitle> Programming languages and systems ESOP '94, </booktitle> <address> New York, </address> <month> April </month> <year> 1994. </year> <note> Springer-Verlag. Lecture Notes in Computer Science, 788. </note>
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The ML language <ref> [MTH90, ?] </ref> has a special type called exn that is used for this purpose (cf. [MT91]). <p> These accounts place powerful module systems like those of Standard ML <ref> [MTH90] </ref> and Objective Caml [Ler95b] on a well-understood and tractable theoretical foundation.
Reference: [N + 63] <author> P. Naur et al. </author> <title> Revised report on the algorithmic language algol 60. </title> <journal> Communications of the ACM, </journal> <volume> 6:117, </volume> <month> January </month> <year> 1963. </year>
Reference: [OR94] <author> Peter W. O'Hearn and Jon G. Riecke. </author> <title> Fully abstract translations and parametric polymorphism. </title> <booktitle> In ESOP '94: 6th European Symposium on Programming, </booktitle> <month> April </month> <year> 1994. </year> <booktitle> Springer Lecture Notes in Computer Science, </booktitle> <volume> volume 788. </volume>
Reference-contexts: Other treatments of CUPERs can be found in [?, ?] The concept of full abstraction was introduced by Plotkin in [Plo77], which is still well worth reading. Recent progress in the construction of fully abstract models (albeit not yet for F &lt;: ) is reported in <ref> [AJM94, HO94, OR94] </ref>. Parametricity was first studied by Reynolds in the context of representation independence [Rey83]. Parametric models of System F are described in [BFSS90, RR94]. Parametricity in System F &lt;: is considered in [CMMS94]. Good general textbooks on semantics include [Sch86, Gun92, Ten81, Win93, Mit96].
Reference: [PA93] <author> Gordon Plotkin and Martjn Abadi. </author> <title> A logic for parametric polymorphism. </title> <editor> In M. Bezem and J. F. Groote, editors, </editor> <booktitle> International Conference on Typed Lambda Calculi and Applications, number 664 in Lecture Notes in Computer Science, </booktitle> <pages> pages 361375, </pages> <address> Utrecht, The Netherlands, March 1993. </address> <publisher> Springer-Verlag. TLCA'93. </publisher>
Reference-contexts: A model in which such relation based reasoning principles are valid for arbitrary polymorphic types (not only booleans) is called parametric [Rey83, ?]. In a parametric model, very powerful principles for polymorphic encodings of inductive types and abstract datatypes are available (cf. <ref> [PA93] </ref>). However, it is an open problem whether the PER model is parametric, and the only known parametric models are rather syntactic in flavor.
Reference: [Pfe89] <author> Frank Pfenning. </author> <title> Elf: A language for logic definition and verified meta-programming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 313322, </pages> <address> Pacific Grove, California, June 1989. </address> <publisher> IEEE Computer Society Press. </publisher> <pages> 256 </pages>
Reference-contexts: a meta-language for defining logics and proving theorems in them. (a) Implement LF (b) Use your implementation to encode a simple propositional logic and prove a small theorem. 2. [T] A generalization of the LF logic has been used as the core of Frank Pfen ning's logic programming language ELF <ref> [Pfe89, Pfe91, Pfe94, Pfe96] </ref>. (a) Download and install the ELF system. 246 (b) Use it to encode the syntax and typing rules of the simply typed lambda-calculus with subtyping and prove some simple theorems about the sys tem, along the lines of [MP91].
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149181. </pages> <publisher> Cam-bridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: a meta-language for defining logics and proving theorems in them. (a) Implement LF (b) Use your implementation to encode a simple propositional logic and prove a small theorem. 2. [T] A generalization of the LF logic has been used as the core of Frank Pfen ning's logic programming language ELF <ref> [Pfe89, Pfe91, Pfe94, Pfe96] </ref>. (a) Download and install the ELF system. 246 (b) Use it to encode the syntax and typing rules of the simply typed lambda-calculus with subtyping and prove some simple theorems about the sys tem, along the lines of [MP91].
Reference: [Pfe94] <author> Frank Pfenning. </author> <title> Elf: A meta-language for deductive systems. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 811815, </pages> <address> Nancy, France, </address> <month> June </month> <year> 1994. </year> <note> Springer-Verlag LNAI 814. System abstract. </note>
Reference-contexts: a meta-language for defining logics and proving theorems in them. (a) Implement LF (b) Use your implementation to encode a simple propositional logic and prove a small theorem. 2. [T] A generalization of the LF logic has been used as the core of Frank Pfen ning's logic programming language ELF <ref> [Pfe89, Pfe91, Pfe94, Pfe96] </ref>. (a) Download and install the ELF system. 246 (b) Use it to encode the syntax and typing rules of the simply typed lambda-calculus with subtyping and prove some simple theorems about the sys tem, along the lines of [MP91].
Reference: [Pfe96] <author> Frank Pfenning. </author> <title> The practice of logical frameworks. </title> <editor> In HelOEene Kirchner, editor, </editor> <booktitle> Proceedings of the Colloquium on Trees in Algebra and Programming, </booktitle> <pages> pages 119134, </pages> <address> Link oping, Sweden, </address> <month> April </month> <year> 1996. </year> <note> Springer-Verlag LNCS 1059. Invited talk. </note>
Reference-contexts: a meta-language for defining logics and proving theorems in them. (a) Implement LF (b) Use your implementation to encode a simple propositional logic and prove a small theorem. 2. [T] A generalization of the LF logic has been used as the core of Frank Pfen ning's logic programming language ELF <ref> [Pfe89, Pfe91, Pfe94, Pfe96] </ref>. (a) Download and install the ELF system. 246 (b) Use it to encode the syntax and typing rules of the simply typed lambda-calculus with subtyping and prove some simple theorems about the sys tem, along the lines of [MP91].
Reference: [PJL92] <author> Simon L. Peyton Jones and David R. Lester. </author> <title> Implementing Functional Languages. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: The simply typed lambda-calculus is studied in Hindley and Seldin [HS86] and in even greater detail in Hindley's more recent book [?]. Material on both typed and untyped lambda-calculus can also be found in many textbooks on functional programming languages (e.g. <ref> [PJL92] </ref>) and programming language semantics (e.g.[Sch86, Gun92, Win93, Mit96]).
Reference: [Plo77] <author> G. D. Plotkin. </author> <title> LCF considered as a programming language. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 5:223255, </address> <year> 1977. </year>
Reference-contexts: Our presentation of CUPERs is a simplified version of the one used by Abadi and Cardelli [AC96]. Other treatments of CUPERs can be found in [?, ?] The concept of full abstraction was introduced by Plotkin in <ref> [Plo77] </ref>, which is still well worth reading. Recent progress in the construction of fully abstract models (albeit not yet for F &lt;: ) is reported in [AJM94, HO94, OR94]. Parametricity was first studied by Reynolds in the context of representation independence [Rey83].
Reference: [Pol94] <author> Robert Pollack. </author> <title> The Theory of LEGO: A Proof Checker for the Extended Calculus of Constructions. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1994. </year>
Reference-contexts: and add a fourth level to classify kind expressions according to their functionality? In fact, why stop there? We could go on adding levels indefinitely! The answer is that we could very well do this, and such systems (without subtyping) have been studied under the heading of pure type systems <ref> [Bar92a, Bar92b, JMP94, MP93, Pol94, etc.] </ref> and used in computer science for applications such as theorem proving. For purposes of this book, though, there is no need to go beyond three levels. 20.2 Definitions We now define a core calculus with type operators.
Reference: [Pol96] <author> Erik Poll. </author> <title> Width-subtyping and polymorphic record update. </title> <type> Manuscript, </type> <month> June </month> <year> 1996. </year>
Reference-contexts: the syntax of F &lt;: , as we shall see in Chapter 19, but such extensions cannot be interpreted in the PER model as it stands; it is, however, possible to construct a more refined PER model, using a different interpretation of subtyping, in which polymorphic update functions do exist <ref> [HP95a, Pol96, ?] </ref>. Next we examine the interpretations of impredicative encodings of algebraic datatypes, such as the Church booleans and Church numerals introduced in Section 12.5. 18.2.2.9 Proposition: Let CBool be the PER [[8 [X] X!X!X]]. Let tt = x: y: x and ff = x: y: y.
Reference: [Pot80] <author> Garrell Pottinger. </author> <title> A type assignment for the strongly normalizable -terms. In To H. </title> <editor> B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus, and Formalism, </booktitle> <pages> pages 561577. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference: [PS94] <author> Benjamin Pierce and Martin Steffen. </author> <title> Higher-order subtyping. </title> <booktitle> In IFIP Working Conference on Programming Concepts, Methods and Calculi (PROCOMET), </booktitle> <year> 1994. </year> <note> Full version in Theoretical Computer Science, vol. 176, no. 12, pp. 235282, 1997 (corrigendum in TCS vol. 184 (1997), p. 247). </note>
Reference-contexts: 23.1.1 Exercise: For each K, define the type expression Top K as follows: Top * = Top Show that ` S : K implies ` S &lt;: Top K . 2 23.2 Historical Notes F ! The metatheory of pure F ! &lt;: has been studied by Steffen and Pierce <ref> [PS94] </ref> and Compagnoni [Com94]. Simple models have been given by Cardelli and Longo [CL91] and Compagnoni and Pierce [CP96]. A model for an extension of F ! &lt;: with recur sive types has been given by Bruce and Mitchell [BM92].
Reference: [PT94] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2):207247, </volume> <month> April </month> <year> 1994. </year> <note> A preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title Object-Oriented Programming Without Recursive Types. </title>
Reference-contexts: Using the typechecker from class, develop a more sig nificant object-oriented program following the same lines. (a) To get started, implement a group of collection classes (for example, using the collection classes of Smalltalk [GR83] as a model). Some hints for how to do this can be found in <ref> [PT94] </ref>. (b) Use these classes as a library to implement a larger object-oriented pro gram of your choice.
Reference: [PT98] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Local type inference. </title> <booktitle> In Conference Record of POPL '98: the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <year> 1998. </year> <note> Full version available as Indiana University CSCI technical report #493. </note>
Reference-contexts: See me for suggestions.) 2. [I] There have been some interesting proposals recently for partial type infer ence methods for systems combining polymorphism and subtyping. Check <ref> [PT98] </ref> for one proposal and pointers to several others. Implement one of these pro posals.
Reference: [Rem89] <author> Didier Remy. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> In Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, Austin, </booktitle> <pages> pages 242249. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: An elegant solution was proposed by Wand [Wan87] and further developed by Wand [Wan88, Wan89], Remy <ref> [Rem89, Rem90] </ref>, and others. We introduce a new kind of unification variable, called a row variable, ranging not over types but over rows of field labels and associated types.
Reference: [Rem90] <author> Didier Remy. </author> <title> AlgOEebres Touffues. Application au Typage Polymorphe des Objets En-registrements dans les Langages Fonctionnels. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1990. </year> <month> 257 </month>
Reference-contexts: An elegant solution was proposed by Wand [Wan87] and further developed by Wand [Wan88, Wan89], Remy <ref> [Rem89, Rem90] </ref>, and others. We introduce a new kind of unification variable, called a row variable, ranging not over types but over rows of field labels and associated types.
Reference: [Rey74] <author> John Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proc. Colloque sur la Programmation, </booktitle> <pages> pages 408425, </pages> <address> New York, 1974. </address> <publisher> Springer-Verlag LNCS 19. </publisher>
Reference-contexts: It was developed, independently, in the early 1970s by a computer scientist, John Reynolds, who called it the polymorphic lambda-calculus <ref> [Rey74] </ref>, and by a logician, Jean-Yves Girard, who called it System F [Gir72]. <p> Based on informal ideas by Cardelli and formalized using techniques developed by Mitchell [Mit84b], Fun integrated Girard-Reynolds polymorphism <ref> [Gir72, Rey74] </ref> with Cardelli's first-order calculus of subtyping [?, Car84]. Fun and its relatives have been studied extensively by programming language theorists and designers. Cardelli and Wegner's survey paper gives the first programming examples using bounded quantification; more are developed in Cardelli's study of power kinds [Car88].
Reference: [Rey80] <author> John Reynolds. </author> <title> Using category theory to design implicit conversions and generic operators. </title> <editor> In N. D. Jones, editor, </editor> <booktitle> Proceedings of the Aarhus Workshop on Semantics-Directed Compiler Generation, number 94 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1980. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference: [Rey83] <author> John C. Reynolds. </author> <title> Types, abstraction, and parametric polymorphism. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing 83, </booktitle> <pages> pages 513523, </pages> <address> Amsterdam, 1983. </address> <publisher> Else-vier Science Publishers B. V. (North-Holland). </publisher>
Reference-contexts: We could then directly use the relation defined by 0 R x and 1 R y and wouldn't need any case distinctions. A model in which such relation based reasoning principles are valid for arbitrary polymorphic types (not only booleans) is called parametric <ref> [Rey83, ?] </ref>. In a parametric model, very powerful principles for polymorphic encodings of inductive types and abstract datatypes are available (cf. [PA93]). However, it is an open problem whether the PER model is parametric, and the only known parametric models are rather syntactic in flavor. <p> Recent progress in the construction of fully abstract models (albeit not yet for F &lt;: ) is reported in [AJM94, HO94, OR94]. Parametricity was first studied by Reynolds in the context of representation independence <ref> [Rey83] </ref>. Parametric models of System F are described in [BFSS90, RR94]. Parametricity in System F &lt;: is considered in [CMMS94]. Good general textbooks on semantics include [Sch86, Gun92, Ten81, Win93, Mit96].
Reference: [Rey84] <author> J. C. Reynolds. </author> <title> Polymorphism is not set-theoretic. </title> <editor> In G. Kahn, D. B. MacQueen, and G. D. Plotkin, editors, </editor> <booktitle> Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 145156, </pages> <address> Berlin, 1984. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: A more refined strategy would be to restrict the domain of polymorphic functions to only those sets which actually arise as interpretations of types in our programming language. However, Reynolds <ref> [Rey84, RP] </ref> has shown that, no matter how we interpret universal types, there cannot exist a model of System F in which a function type S!T is interpreted as the full set of functions from [[S]] to [[T]].
Reference: [Rey88] <author> John C. Reynolds. </author> <title> Preliminary design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-88-159, </type> <institution> Carnegie Mellon University, </institution> <month> June </month> <year> 1988. </year>
Reference: [RP] <author> John C. Reynolds and Gordon D. Plotkin. </author> <title> On functors expressible in the polymorphic lambda calculus. </title> <note> Submitted to Information and Computation. Also available as CMU School of Computer Science technical report number CMU-CS-90-147. </note>
Reference-contexts: A more refined strategy would be to restrict the domain of polymorphic functions to only those sets which actually arise as interpretations of types in our programming language. However, Reynolds <ref> [Rey84, RP] </ref> has shown that, no matter how we interpret universal types, there cannot exist a model of System F in which a function type S!T is interpreted as the full set of functions from [[S]] to [[T]].
Reference: [RR94] <author> E. P. Robinson and G. Rosolini. </author> <title> Reflexive graphs and parametric polymor-phism. </title> <booktitle> In Proceedings, Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 364371, </pages> <address> Paris, France, 47 July 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Recent progress in the construction of fully abstract models (albeit not yet for F &lt;: ) is reported in [AJM94, HO94, OR94]. Parametricity was first studied by Reynolds in the context of representation independence [Rey83]. Parametric models of System F are described in <ref> [BFSS90, RR94] </ref>. Parametricity in System F &lt;: is considered in [CMMS94]. Good general textbooks on semantics include [Sch86, Gun92, Ten81, Win93, Mit96].
Reference: [SA93] <author> Z. Shao and A. Appel. </author> <title> Smartest recompilation. </title> <booktitle> In Proceedings 20th Symposium on Principles of Programming Languages. ACM, </booktitle> <month> January </month> <year> 1993. </year>
Reference: [Sch86] <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, </publisher> <year> 1986. </year>
Reference-contexts: Parametricity was first studied by Reynolds in the context of representation independence [Rey83]. Parametric models of System F are described in [BFSS90, RR94]. Parametricity in System F &lt;: is considered in [CMMS94]. Good general textbooks on semantics include <ref> [Sch86, Gun92, Ten81, Win93, Mit96] </ref>.
Reference: [SNP90] <author> Jan Smith, Bengt Nordstr om, and Kent Petersson. </author> <title> Programming in Martin-Lof's Type Theory. An Introduction. </title> <publisher> Oxford University Press, </publisher> <year> 1990. </year>
Reference: [Tai67] <author> W. W. Tait. </author> <title> Intensional interpretations of functionals of finite type I. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 32(2):198212, </volume> <month> June </month> <year> 1967. </year>
Reference-contexts: If not, explain why not. Solution on page 233. 2 5.3 Strong Normalization The presentation in this section follows the structure of of Girard's adaptation [GLT89] of Tait's original proof <ref> [Tai67] </ref>. 5.3.1 Definition: When s is strongly normalizable, we write (s) for the length of the longest reduction sequence starting from s. 2 The key problem in proving strong normalization lies in finding a strong enough induction hypothesis.
Reference: [Tar55] <author> Alfred Tarski. </author> <title> A lattice-theoretical fixpoint theorem and its applications. </title> <journal> Pacific Journal of Mathematics, </journal> <volume> 5:285309, </volume> <year> 1955. </year>
Reference: [Ten81] <author> R. D. Tennent. </author> <booktitle> Principles of Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Parametricity was first studied by Reynolds in the context of representation independence [Rey83]. Parametric models of System F are described in [BFSS90, RR94]. Parametricity in System F &lt;: is considered in [CMMS94]. Good general textbooks on semantics include <ref> [Sch86, Gun92, Ten81, Win93, Mit96] </ref>.
Reference: [Tof92] <author> Mads Tofte. </author> <title> Principal signatures for higher-order program modules. </title> <booktitle> In Conference record of the Nineteenth annual ACM SIGPLAN-SIGACT symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1992. </year>
Reference: [TvD88] <author> A. S. Troelstra and D. van Dalen. </author> <title> Constructivism in Mathematics, An Introduction (vol I). </title> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: A good reference with pointers to related topics of historical interest is Troelstra and van Dalen's book <ref> [TvD88] </ref>. A standard reference on PER models in a computer science context is Mitchell's book [Mit96]. Our presentation of CUPERs is a simplified version of the one used by Abadi and Cardelli [AC96].
Reference: [TWM95] <author> David N Turner, Philip Wadler, and Christian Mossin. </author> <title> Once upon a type. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <address> San Diego, Cali-fornia, </address> <year> 1995. </year> <month> 258 </month>
Reference-contexts: Check [PT98] for one proposal and pointers to several others. Implement one of these pro posals. E.4 Other Type Systems 1. [T] Implement a lambda-calculus with intersection types (or, harder: with intersection and union types). 2. [T] Implement a linear type system for the lambda-calculus <ref> [Wad91, Wad90, TWM95] </ref>. 3. [T] Harper and Lillibridge [HL94a] and Leroy [Ler96] have independently proposed similar accounts of modules (in the style of ML) using the type-theoretic tools of existential types and (a limited form of) dependent types.
Reference: [Wad90] <author> Philip Wadler. </author> <title> Linear types can change the world. </title> <booktitle> In TC 2 Working Conference on Programming Concepts and Methods (Preprint), </booktitle> <pages> pages 546566, </pages> <year> 1990. </year>
Reference-contexts: Check [PT98] for one proposal and pointers to several others. Implement one of these pro posals. E.4 Other Type Systems 1. [T] Implement a lambda-calculus with intersection types (or, harder: with intersection and union types). 2. [T] Implement a linear type system for the lambda-calculus <ref> [Wad91, Wad90, TWM95] </ref>. 3. [T] Harper and Lillibridge [HL94a] and Leroy [Ler96] have independently proposed similar accounts of modules (in the style of ML) using the type-theoretic tools of existential types and (a limited form of) dependent types.
Reference: [Wad91] <author> Philip Wadler. </author> <title> Is there a use for linear logic? In Proceedings of ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </title> <booktitle> pages 255273, </booktitle> <year> 1991. </year>
Reference-contexts: Check [PT98] for one proposal and pointers to several others. Implement one of these pro posals. E.4 Other Type Systems 1. [T] Implement a lambda-calculus with intersection types (or, harder: with intersection and union types). 2. [T] Implement a linear type system for the lambda-calculus <ref> [Wad91, Wad90, TWM95] </ref>. 3. [T] Harper and Lillibridge [HL94a] and Leroy [Ler96] have independently proposed similar accounts of modules (in the style of ML) using the type-theoretic tools of existential types and (a limited form of) dependent types.
Reference: [Wan87] <author> Mitchell Wand. </author> <title> Complete type inference for simple objects. </title> <booktitle> In Proceedings of the IEEE Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: An elegant solution was proposed by Wand <ref> [Wan87] </ref> and further developed by Wand [Wan88, Wan89], Remy [Rem89, Rem90], and others. We introduce a new kind of unification variable, called a row variable, ranging not over types but over rows of field labels and associated types.
Reference: [Wan88] <author> Mitchell Wand. </author> <title> Corrigendum: Complete type inference for simple objects. </title> <booktitle> In Proceedings of the IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1988. </year>
Reference-contexts: An elegant solution was proposed by Wand [Wan87] and further developed by Wand <ref> [Wan88, Wan89] </ref>, Remy [Rem89, Rem90], and others. We introduce a new kind of unification variable, called a row variable, ranging not over types but over rows of field labels and associated types.
Reference: [Wan89] <author> Mitchell Wand. </author> <title> Type inference for record concatenation and multiple inheritance. </title> <booktitle> In Fourth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 9297, </pages> <address> Pacific Grove, CA, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: An elegant solution was proposed by Wand [Wan87] and further developed by Wand <ref> [Wan88, Wan89] </ref>, Remy [Rem89, Rem90], and others. We introduce a new kind of unification variable, called a row variable, ranging not over types but over rows of field labels and associated types.
Reference: [Win93] <author> Glynn Winskel. </author> <title> The Formal Semantics of Programming Languages: An Introduction. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Parametricity was first studied by Reynolds in the context of representation independence [Rey83]. Parametric models of System F are described in [BFSS90, RR94]. Parametricity in System F &lt;: is considered in [CMMS94]. Good general textbooks on semantics include <ref> [Sch86, Gun92, Ten81, Win93, Mit96] </ref>.

References-found: 143

