URL: http://www.cs.purdue.edu/homes/palsberg/paper/esop92.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: palsberg@daimi.aau.dk  
Title: A Provably Correct Compiler Generator  
Author: Jens Palsberg 
Address: Ny Munkegade, DK-8000 Aarhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Note: In Proc. ESOP'92, Springer-Verlag (LNCS 582), pages 418-434.  
Abstract: We have designed, implemented, and proved the correctness of a compiler generator that accepts action semantic descriptions of imperative programming languages. The generated compilers emit absolute code for an abstract RISC machine language that currently is assembled into code for the SPARC and the HP Precision Architecture. Our machine language needs no run-time type-checking and is thus more realistic than those considered in previous compiler proofs. We use solely algebraic specifications; proofs are given in the initial model.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Harald Abelson, Gerald Jay Sussman, and Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: In practice, a session with Cantor looks as follows on the screen: cantor syntax semantics compiler compiler program code code input output The compiler generator cantor is written in Perl [61], and the generated compilers are written in Scheme <ref> [1] </ref>. Examples of a syntax and a semantics are given in appendix B; it is the L A T E X source of the appendix that is processed by cantor.
Reference: [2] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year> <note> Also in Proc. POPL'91. </note>
Reference-contexts: In the case of cyclic structures, the relation between semantic values seems to be impossible to define in the unified meta-notation. This is because the meta-notation only allows the expression of Horn clauses. Evidence for this is found in Amadio and Cardelli's paper on subtyping recursive types <ref> [2] </ref>.
Reference: [3] <author> Rudolf Berghammer, Herbert Ehler, and Hans Zierer. </author> <title> Towards an algebraic specification of code generation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 11 </volume> <pages> 45-63, </pages> <year> 1988. </year>
Reference-contexts: Let us therefore examine the major previous approaches to compiler correctness proofs. 2.2 Compiler Correctness Proofs The traditional approach to proving compiler correctness is based on deno-tational semantics [24, 26, 58, 51, 39] or algebraic variations hereof <ref> [7, 28, 59, 3, 30] </ref>. The correctness statement can be pictured as a commuting diagram, see figure 2. It has been demonstrated that complete proofs of compiler correctness can be automatically checked.
Reference: [4] <author> William R. Bevier, Warren A. Hunt, J. Strother Moore, and William D. Young. </author> <title> An approach to systems verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 411-428, </pages> <year> 1989. </year>
Reference-contexts: In both cases, the target code of the translation is a non-idealized machine-level architecture whose implementation has been verified with respect to a low level of the computer, see for example [17, 27]. The verification of both architectures has even been automatically checked. These examples of systems verification <ref> [4] </ref> are important: they minimize the amount of distrust one need have to such a verified system. Of course, one can still suspect errors in the implementation of the gate-level of the computer, or in the implementation of the theorem prover, but many other sources of errors have been eliminated.
Reference: [5] <author> Anders Bondorf. </author> <title> Automatic autoprojection of higher order recursive equations. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 17(1-3):3-34, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: The Ceres system of Tofte [60] is an early example of this, demonstrating that even compiler generators can be automatically generated. Ceres uses a language of flowcharts with an implicit state as the notation for defining source languages. Another notable partial evaluator is the Similix of Bondorf and Danvy <ref> [5, 6] </ref> which treats a subset of Scheme. Gomard and Jones implemented a self-applicable partial evaluator, called mix, for an untyped lambda notation [13]. It has been used to generate a compiler for a language of while-programs. The generated compiler emits programs in lambda notation.
Reference: [6] <author> Anders Bondorf and Olivier Danvy. </author> <title> Automatic autoprojection of recursive equations with global variables and abstract data types. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 16 </volume> <pages> 151-195, </pages> <year> 1991. </year>
Reference-contexts: The Ceres system of Tofte [60] is an early example of this, demonstrating that even compiler generators can be automatically generated. Ceres uses a language of flowcharts with an implicit state as the notation for defining source languages. Another notable partial evaluator is the Similix of Bondorf and Danvy <ref> [5, 6] </ref> which treats a subset of Scheme. Gomard and Jones implemented a self-applicable partial evaluator, called mix, for an untyped lambda notation [13]. It has been used to generate a compiler for a language of while-programs. The generated compiler emits programs in lambda notation.
Reference: [7] <author> Rod M. Burstall and Peter J. Landin. </author> <title> Programs and their proofs: an algebraic approach. </title> <editor> In B. Meltzer and D. Mitchie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> Vol. 4, </volume> <pages> pages 17-43. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year>
Reference-contexts: Let us therefore examine the major previous approaches to compiler correctness proofs. 2.2 Compiler Correctness Proofs The traditional approach to proving compiler correctness is based on deno-tational semantics [24, 26, 58, 51, 39] or algebraic variations hereof <ref> [7, 28, 59, 3, 30] </ref>. The correctness statement can be pictured as a commuting diagram, see figure 2. It has been demonstrated that complete proofs of compiler correctness can be automatically checked.
Reference: [8] <author> G. Cousineau, P.-L. Curien, and M. Mauny. </author> <title> The categorical abstract machine. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 173-202, </pages> <year> 1987. </year>
Reference-contexts: After these systems were built, several translations of lambda notation into other abstract machines have been proved correct. Notable instances are the categorical abstract machine <ref> [8] </ref> and the abstract machines that can be derived systematically from an operational semantics of lambda notation, using Hannan's method [16, 14, 15]. It remains to be demonstrated, however, if a compiler which incorporates one of them will be more efficient than the classical systems.
Reference: [9] <author> Mads Dam and Frank Jensen. </author> <title> Compiler generation from relational semantics. </title> <booktitle> In Proc. ESOP'86, European Symposium on Programming, </booktitle> <pages> pages 1-29. </pages> <publisher> Springer-Verlag (LNCS 213), </publisher> <year> 1986. </year>
Reference-contexts: They indicate, however, that better performance of the produced compiler is obtained when: * Some model details are omitted from a language definition; and * The notation for defining languages is biased towards "compilable lan guages". A radically different approach to compiler generation is taken by Dam and Jensen <ref> [9] </ref>. They consider the use of natural semantics [20] (which they call "relational semantics") as the basis of a compiler generator. They devise an algorithm for transforming a natural semantic definition into a compiling specification.
Reference: [10] <author> Joelle Despeyroux. </author> <title> Proof of translation in natural semantics. </title> <booktitle> In LICS'86, First Symposium on Logic in Computer Science, </booktitle> <pages> pages 193-205, </pages> <month> June </month> <year> 1986. </year> <month> 33 </month>
Reference-contexts: In comparison with structural operational semantics and natural semantics, we replace inference rules by Horn clauses. The notational difference is minor, and only superficial differences appear in the proofs of theorems about unified specifications. Where Despeyroux <ref> [10] </ref> could prove lemmas by induction in the length of inference, we instead adopt an axiomatization of Horn logic and prove lemmas by induction in the number of occurrences of "modus ponens" in the proof in the initial model. <p> In a special form of structural operational semantics, called natural semantics [20], one considers only steps from configurations to final states. When both the source and target languages have a natural semantics, then there is hope for proving the correctness of a compiler using the proof technique of Despeyroux <ref> [10] </ref>. As with the proof techniques used when dealing with denotational semantics, Despeyroux's technique amounts to giving a proof by induction on the length of a computation. The correctness statement is different, though.
Reference: [11] <author> Anders Gammelgaard and Flemming Nielson. </author> <title> Verification of the level 0 compiling specification. </title> <type> Technical report, </type> <institution> Department of Computer Science, Aarhus University, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: For a survey of recent work on proving the correctness of compilers for such languages, see the paper by Gammelgaard and Nielson <ref> [11] </ref>, which also contains a detailed account of the approach taken in the ProCoS project, where the source language considered is Occam2. In a special form of structural operational semantics, called natural semantics [20], one considers only steps from configurations to final states.
Reference: [12] <author> Joseph A. Goguen, James W. Thatcher, and Eric G. Wagner. </author> <title> An initial algebra approach to the specification, correctness, and implementation of abstract data types. </title> <editor> In Raymond T. Yeh, editor, </editor> <booktitle> Current Trends in Programming Methodology, Volume IV, </booktitle> <pages> pages 80-149. </pages> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference-contexts: In section 4 we state the correctness theorem, and finally in section 5 we survey our approach to proving correctness in the absence of run-time type-checking in the target language. We also discuss why we do not treat recursion. The reader is assumed to be familiar with algebraic specification <ref> [12] </ref>, compilation of block structured languages [64], and the notion of a RISC architecture [57]. 2 Previous Work 2.1 Compiler Generation The problem of compiler generation is usually approached by choosing a particular definition of a specific target language [46].
Reference: [13] <author> Carsten K. Gomard and Neil D. Jones. </author> <title> A partial evaluator for the untyped lambda-calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1) </volume> <pages> 21-69, </pages> <year> 1991. </year>
Reference-contexts: Another notable partial evaluator is the Similix of Bondorf and Danvy [5, 6] which treats a subset of Scheme. Gomard and Jones implemented a self-applicable partial evaluator, called mix, for an untyped lambda notation <ref> [13] </ref>. It has been used to generate a compiler for a language of while-programs. The generated compiler emits programs in lambda notation.
Reference: [14] <author> John Hannan. </author> <title> Making abstract machines less abstract. </title> <booktitle> In Proc. Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 618-635. </pages> <publisher> Springer-Verlag (LNCS 523), </publisher> <year> 1991. </year>
Reference-contexts: After these systems were built, several translations of lambda notation into other abstract machines have been proved correct. Notable instances are the categorical abstract machine [8] and the abstract machines that can be derived systematically from an operational semantics of lambda notation, using Hannan's method <ref> [16, 14, 15] </ref>. It remains to be demonstrated, however, if a compiler which incorporates one of them will be more efficient than the classical systems. Also, the correctness of implementations of these abstract 5 machines has not been considered.
Reference: [15] <author> John Hannan. </author> <title> Staging transformations for abstract machines. </title> <booktitle> In Proc. ACM SIGPLAN Symposium on Partial Evaluation and Semantics Based Program Manipulation, </booktitle> <pages> pages 130-141. </pages> <booktitle> Sigplan Notices, </booktitle> <year> 1991. </year>
Reference-contexts: After these systems were built, several translations of lambda notation into other abstract machines have been proved correct. Notable instances are the categorical abstract machine [8] and the abstract machines that can be derived systematically from an operational semantics of lambda notation, using Hannan's method <ref> [16, 14, 15] </ref>. It remains to be demonstrated, however, if a compiler which incorporates one of them will be more efficient than the classical systems. Also, the correctness of implementations of these abstract 5 machines has not been considered.
Reference: [16] <author> John Hannan and Dale Miller. </author> <title> From operational semantics to abtract machines. </title> <note> Journal of Mathmatical Structures in Computer Science, To appear, </note> <year> 1991. </year>
Reference-contexts: After these systems were built, several translations of lambda notation into other abstract machines have been proved correct. Notable instances are the categorical abstract machine [8] and the abstract machines that can be derived systematically from an operational semantics of lambda notation, using Hannan's method <ref> [16, 14, 15] </ref>. It remains to be demonstrated, however, if a compiler which incorporates one of them will be more efficient than the classical systems. Also, the correctness of implementations of these abstract 5 machines has not been considered.
Reference: [17] <author> Warren A. Hunt. </author> <title> Microprocessor design verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 429-460, </pages> <year> 1989. </year>
Reference-contexts: In both cases, the target code of the translation is a non-idealized machine-level architecture whose implementation has been verified with respect to a low level of the computer, see for example <ref> [17, 27] </ref>. The verification of both architectures has even been automatically checked. These examples of systems verification [4] are important: they minimize the amount of distrust one need have to such a verified system.
Reference: [18] <author> Jeffrey J. Joyce. </author> <title> Totally verified systems: Linking verified software to verified hardware. In Proc. Hardware Specification, Verification and Synthesis: </title> <booktitle> Mathmatical Aspects, </booktitle> <pages> pages 177-201, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: The correctness statement can be pictured as a commuting diagram, see figure 2. It has been demonstrated that complete proofs of compiler correctness can be automatically checked. Two significant instances are Young's [65] work, using the Boyer-Moore theorem prover, and Joyce's <ref> [19, 18] </ref> work using the HOL system. In both cases, the target code of the translation is a non-idealized machine-level architecture whose implementation has been verified with respect to a low level of the computer, see for example [17, 27]. The verification of both architectures has even been automatically checked. <p> We call this property "code well-behavedness". We will use a variation of Despeyroux's technique, adapted to the framework of unified algebras, see later. A major deficiency of all the previous approaches to compiler correctness, except that of Joyce <ref> [19, 18] </ref>, is their using a target language that performs run-time type-checking, as explained above. Joyce considers only a language of while-programs, and it is not clear how to generalize his approach.
Reference: [19] <author> Jeffrey J. Joyce. </author> <title> A verified compiler for a verified microprocessor. </title> <type> Technical report, </type> <institution> University of Cambridge, Computer Laboratory, </institution> <address> England, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: The correctness statement can be pictured as a commuting diagram, see figure 2. It has been demonstrated that complete proofs of compiler correctness can be automatically checked. Two significant instances are Young's [65] work, using the Boyer-Moore theorem prover, and Joyce's <ref> [19, 18] </ref> work using the HOL system. In both cases, the target code of the translation is a non-idealized machine-level architecture whose implementation has been verified with respect to a low level of the computer, see for example [17, 27]. The verification of both architectures has even been automatically checked. <p> We call this property "code well-behavedness". We will use a variation of Despeyroux's technique, adapted to the framework of unified algebras, see later. A major deficiency of all the previous approaches to compiler correctness, except that of Joyce <ref> [19, 18] </ref>, is their using a target language that performs run-time type-checking, as explained above. Joyce considers only a language of while-programs, and it is not clear how to generalize his approach.
Reference: [20] <author> Gilles Kahn. </author> <title> Natural semantics. </title> <booktitle> In Proc. STACS'87, </booktitle> <pages> pages 22-39. </pages> <publisher> Springer-Verlag (LNCS 247), </publisher> <year> 1987. </year>
Reference-contexts: A radically different approach to compiler generation is taken by Dam and Jensen [9]. They consider the use of natural semantics <ref> [20] </ref> (which they call "relational semantics") as the basis of a compiler generator. They devise an algorithm for transforming a natural semantic definition into a compiling specification. <p> In a special form of structural operational semantics, called natural semantics <ref> [20] </ref>, one considers only steps from configurations to final states. When both the source and target languages have a natural semantics, then there is hope for proving the correctness of a compiler using the proof technique of Despeyroux [10].
Reference: [21] <author> Richard Kelsey and Paul Hudak. </author> <title> Realistic compilation by program transformation. </title> <booktitle> In Sixteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 281-292, </pages> <year> 1989. </year>
Reference-contexts: A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller [55, 56], the compiler generator of Kelsey and Hudak <ref> [21] </ref>, and the Mess system of Pleban and Lee [47, 23, 49, 22]. These approaches are based on rather ad hoc notations for defining languages, and they lack correctness proofs, like the classical systems.
Reference: [22] <author> Peter Lee. </author> <title> Realistic Compiler Generation. </title> <publisher> MIT Press, </publisher> <year> 1989. </year> <month> 34 </month>
Reference-contexts: The target programs produced by these systems have been reported to run at least three orders of magnitude slower than corresponding target programs produced by handwritten compilers <ref> [22] </ref>. After these systems were built, several translations of lambda notation into other abstract machines have been proved correct. Notable instances are the categorical abstract machine [8] and the abstract machines that can be derived systematically from an operational semantics of lambda notation, using Hannan's method [16, 14, 15]. <p> A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller [55, 56], the compiler generator of Kelsey and Hudak [21], and the Mess system of Pleban and Lee <ref> [47, 23, 49, 22] </ref>. These approaches are based on rather ad hoc notations for defining languages, and they lack correctness proofs, like the classical systems. <p> The input file is a sequence of integers, as is the output file. The HypoPL language, defined in appendix B, is taken from Lee's book on realistic compiler generation <ref> [22] </ref>, with the difference that we treat nesting of procedures in its full generality but do not allow recursion. (For a discussion of why recursion is problematic, see later.) * Generating a compiler for HypoPL takes 3 seconds. <p> This is somewhat dis-appointing but still an improvement compared to the classical systems of Mosses, Paulson, and Wand where a slow-down of three orders of magnitude has been reported <ref> [22] </ref>. Inspection of the code emitted by Cantor-generated compilers reveals that the inefficiency mainly stems from three sources: * Lack of compile time constant propagation; * Poor register allocation; and * Naive representation of bindings, closures, and lists.
Reference: [23] <author> Peter Lee and Uwe F. Pleban. </author> <title> A realistic compiler generator based on high--level semantics. </title> <booktitle> In Fourteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 284-295, </pages> <year> 1987. </year>
Reference-contexts: A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller [55, 56], the compiler generator of Kelsey and Hudak [21], and the Mess system of Pleban and Lee <ref> [47, 23, 49, 22] </ref>. These approaches are based on rather ad hoc notations for defining languages, and they lack correctness proofs, like the classical systems.
Reference: [24] <author> John McCarthy and James Painter. </author> <title> Correctness of a compiler for arithmetic expressions. </title> <booktitle> In Proc. Symposium in Applied Mathematics of the American Mathmatical Society, </booktitle> <pages> pages 33-41, </pages> <month> April </month> <year> 1966. </year>
Reference-contexts: The lack of correctness proofs for the realistic compiler generators limits the confidence we can have in a generated compiler. Let us therefore examine the major previous approaches to compiler correctness proofs. 2.2 Compiler Correctness Proofs The traditional approach to proving compiler correctness is based on deno-tational semantics <ref> [24, 26, 58, 51, 39] </ref> or algebraic variations hereof [7, 28, 59, 3, 30]. The correctness statement can be pictured as a commuting diagram, see figure 2. It has been demonstrated that complete proofs of compiler correctness can be automatically checked.
Reference: [25] <author> Sun Microsystems. </author> <title> A RISC tutorial. </title> <type> Technical Report 800-1795-10, </type> <institution> revision A, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: For an example of a language description that has been processed by Cantor, see appendix B. The abstract RISC machine language can easily be expanded into code for existing RISC processors. Currently, implementations exist for the SPARC <ref> [25] </ref> and the HP Precision Architecture [42].
Reference: [26] <author> Robert E. Milne and Christopher Strachey. </author> <title> A Theory of Programming Language Semantics. </title> <publisher> Chapman and Hall, </publisher> <year> 1976. </year>
Reference-contexts: The lack of correctness proofs for the realistic compiler generators limits the confidence we can have in a generated compiler. Let us therefore examine the major previous approaches to compiler correctness proofs. 2.2 Compiler Correctness Proofs The traditional approach to proving compiler correctness is based on deno-tational semantics <ref> [24, 26, 58, 51, 39] </ref> or algebraic variations hereof [7, 28, 59, 3, 30]. The correctness statement can be pictured as a commuting diagram, see figure 2. It has been demonstrated that complete proofs of compiler correctness can be automatically checked.
Reference: [27] <author> J. Strother Moore. </author> <title> A mechanically verified language implementation. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 461-492, </pages> <year> 1989. </year>
Reference-contexts: In both cases, the target code of the translation is a non-idealized machine-level architecture whose implementation has been verified with respect to a low level of the computer, see for example <ref> [17, 27] </ref>. The verification of both architectures has even been automatically checked. These examples of systems verification [4] are important: they minimize the amount of distrust one need have to such a verified system.
Reference: [28] <author> Francis Lockwood Morris. </author> <title> Advice on structuring compilers and proving them correct. </title> <booktitle> In Symposium on Principles of Programming Languages, </booktitle> <pages> pages 144-152, </pages> <year> 1973. </year>
Reference-contexts: Let us therefore examine the major previous approaches to compiler correctness proofs. 2.2 Compiler Correctness Proofs The traditional approach to proving compiler correctness is based on deno-tational semantics [24, 26, 58, 51, 39] or algebraic variations hereof <ref> [7, 28, 59, 3, 30] </ref>. The correctness statement can be pictured as a commuting diagram, see figure 2. It has been demonstrated that complete proofs of compiler correctness can be automatically checked.
Reference: [29] <author> Peter D. Mosses. </author> <title> SIS|semantics implementation system. </title> <type> Technical Report Daimi MD-30, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1979. </year> <title> Out of print. </title>
Reference-contexts: It accepts language definitions written in action notation, and it outputs compilers that emit code in an abstract RISC machine language. The traditional approach to compiler generation is based on denotational semantics [53]. Examples of existing compiler generators based on this idea include Mosses' Semantics Implementation System (SIS) <ref> [29] </ref>, Paulson's Semantics Processor (PSP) [45, 46], and Wand's Semantic Prototyping System (SPS) [62]. In SIS, the lambda expressions are executed by a direct implementation of beta-reduction; in PSP and SPS they are compiled into SECD and Scheme code, respectively.
Reference: [30] <author> Peter D. Mosses. </author> <title> A constructive approach to compiler correctness. </title> <booktitle> In Proc. Seventh Colloquium of Automata, Languages, and Programming, </booktitle> <pages> pages 449-469, </pages> <month> July </month> <year> 1980. </year>
Reference-contexts: Let us therefore examine the major previous approaches to compiler correctness proofs. 2.2 Compiler Correctness Proofs The traditional approach to proving compiler correctness is based on deno-tational semantics [24, 26, 58, 51, 39] or algebraic variations hereof <ref> [7, 28, 59, 3, 30] </ref>. The correctness statement can be pictured as a commuting diagram, see figure 2. It has been demonstrated that complete proofs of compiler correctness can be automatically checked.
Reference: [31] <author> Peter D. Mosses. </author> <booktitle> Abstract semantic algebras! In Proc. IFIP TC2 Working Conference on Formal Description of Programming Concepts II (Garmisch-Partenkirchen, </booktitle> <year> 1982), </year> <pages> pages 45-70. </pages> <publisher> North-Holland, </publisher> <year> 1983. </year>
Reference-contexts: It appears that the poor performance characteristics of the classical compiler generators do not simply stem from inefficient implementations of lambda notation. Mosses observed that denotational semantics intertwine model details with the semantic description, thus blurring the underlying conceptual analysis <ref> [31] </ref>. Pleban and Lee further observed that not only a human reader but also an automatic compiler generator will have difficulty in recovering the underlying analysis [48]. <p> The Cantor system is based on the use of such a machine language. 3 The Cantor System Our compiler generator accepts action semantic descriptions. Action semantics is a framework for formal semantics of programming languages, developed by Mosses <ref> [31, 32, 33, 36, 37] </ref> and Watt [38, 63]. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in using semantic entities called actions, rather than higher-order functions.
Reference: [32] <author> Peter D. Mosses. </author> <title> A basic abstract semantic algebra. </title> <booktitle> In Proc. Int. Symp. on Semantics of Data Types (Sophia-Antipolis), </booktitle> <pages> pages 87-107. </pages> <publisher> Springer-Verlag (LNCS 173), </publisher> <year> 1984. </year>
Reference-contexts: The Cantor system is based on the use of such a machine language. 3 The Cantor System Our compiler generator accepts action semantic descriptions. Action semantics is a framework for formal semantics of programming languages, developed by Mosses <ref> [31, 32, 33, 36, 37] </ref> and Watt [38, 63]. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in using semantic entities called actions, rather than higher-order functions.
Reference: [33] <author> Peter D. Mosses. </author> <title> Unified algebras and action semantics. </title> <booktitle> In Proc. STACS'89, </booktitle> <pages> pages 17-35. </pages> <publisher> Springer-Verlag (LNCS 349), </publisher> <year> 1989. </year>
Reference-contexts: The specification and proof of correctness of the Cantor system is an experiment in using the framework of unified algebras, developed by Mosses 3 <ref> [35, 33, 34] </ref>. Unified algebras allows the algebraic specification of both ab-stract data types and operational semantics in a way such that initial models are guaranteed to exist, except when axioms contradict constraints, in which case no models of the specification exist. <p> The Cantor system is based on the use of such a machine language. 3 The Cantor System Our compiler generator accepts action semantic descriptions. Action semantics is a framework for formal semantics of programming languages, developed by Mosses <ref> [31, 32, 33, 36, 37] </ref> and Watt [38, 63]. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in using semantic entities called actions, rather than higher-order functions.
Reference: [34] <author> Peter D. Mosses. </author> <title> Unified algebras and institutions. </title> <booktitle> In LICS'89, Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 304-312, </pages> <year> 1989. </year> <month> 35 </month>
Reference-contexts: The specification and proof of correctness of the Cantor system is an experiment in using the framework of unified algebras, developed by Mosses 3 <ref> [35, 33, 34] </ref>. Unified algebras allows the algebraic specification of both ab-stract data types and operational semantics in a way such that initial models are guaranteed to exist, except when axioms contradict constraints, in which case no models of the specification exist. <p> Further, let be a set of Horn clauses built up from . Any specification of such Horn clauses will be augmented with some basic Horn clauses, stating for example the reflexivity of ` ', see <ref> [34] </ref>. Finally, let F be a formula built up from . We will then write (; ) ` F (read F is (; )-deducible) if (; ) ` F can be obtained by finitely many applications of the deduction rules shown in figure 5.
Reference: [35] <author> Peter D. Mosses. </author> <title> Unified algebras and modules. </title> <booktitle> In Sixteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 329-343, </pages> <year> 1989. </year>
Reference-contexts: The specification and proof of correctness of the Cantor system is an experiment in using the framework of unified algebras, developed by Mosses 3 <ref> [35, 33, 34] </ref>. Unified algebras allows the algebraic specification of both ab-stract data types and operational semantics in a way such that initial models are guaranteed to exist, except when axioms contradict constraints, in which case no models of the specification exist.
Reference: [36] <author> Peter D. Mosses. </author> <title> An introduction to action semantics. </title> <type> Technical Report DAIMI PB-370, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1991. </year> <booktitle> Lecture Notes for the Marktoberdorf'91 Summer School, to be published in the Proceedings of the Summer School by Springer-Verlag (Series F). </booktitle>
Reference-contexts: The Cantor system is based on the use of such a machine language. 3 The Cantor System Our compiler generator accepts action semantic descriptions. Action semantics is a framework for formal semantics of programming languages, developed by Mosses <ref> [31, 32, 33, 36, 37] </ref> and Watt [38, 63]. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in using semantic entities called actions, rather than higher-order functions.
Reference: [37] <author> Peter D. Mosses. </author> <title> Action Semantics. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year> <note> Number 26 Tracts in Theoretical Computer Science. </note>
Reference-contexts: The Cantor system is based on the use of such a machine language. 3 The Cantor System Our compiler generator accepts action semantic descriptions. Action semantics is a framework for formal semantics of programming languages, developed by Mosses <ref> [31, 32, 33, 36, 37] </ref> and Watt [38, 63]. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in using semantic entities called actions, rather than higher-order functions. <p> It differs from denotational semantics, however, in using semantic entities called actions, rather than higher-order functions. We have designed a subset of action notation which is amenable to compilation and which we have given a natural semantics, by a systematic transformation of its structural operational semantics <ref> [37] </ref>. The syntax of this subset is given in appendix A together with a brief overview of the principles behind action semantics. <p> Appendix B presents a complete description of a toy programming language. (Readers who are unfamiliar with action semantics are not expected to understand the details in appendix B, despite the suggestiveness of the symbols used. See <ref> [37] </ref> for a full presentation of action semantics.) The central part of the Cantor system is a compiler from action notation to an abstract RISC machine language. This section presents both the 9 machine language and the compiler, and it states some performance mea-surements of the Cantor system. <p> This section presents both the 9 machine language and the compiler, and it states some performance mea-surements of the Cantor system. All specifications in this paper, including those of syntax, are given in Mosses' meta-notation for unified algebras <ref> [37] </ref>. 3.1 An Abstract RISC Machine Language The machine language is patterned after the SPARC architecture; it is called Pseudo SPARC.
Reference: [38] <author> Peter D. Mosses and David A. Watt. </author> <title> The use of action semantics. </title> <booktitle> In Proc. IFIP TC2 Working Conference on Formal Description of Programming Concepts III (Gl. </booktitle> <address> Averns, </address> <year> 1986), </year> <pages> pages 135-163. </pages> <publisher> North-Holland, </publisher> <year> 1987. </year>
Reference-contexts: The Cantor system is based on the use of such a machine language. 3 The Cantor System Our compiler generator accepts action semantic descriptions. Action semantics is a framework for formal semantics of programming languages, developed by Mosses [31, 32, 33, 36, 37] and Watt <ref> [38, 63] </ref>. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in using semantic entities called actions, rather than higher-order functions.
Reference: [39] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> Two-level semantics and code generation. </title> <journal> Theoretical Computer Science, </journal> <volume> 56 </volume> <pages> 59-133, </pages> <year> 1988. </year>
Reference-contexts: The lack of correctness proofs for the realistic compiler generators limits the confidence we can have in a generated compiler. Let us therefore examine the major previous approaches to compiler correctness proofs. 2.2 Compiler Correctness Proofs The traditional approach to proving compiler correctness is based on deno-tational semantics <ref> [24, 26, 58, 51, 39] </ref> or algebraic variations hereof [7, 28, 59, 3, 30]. The correctness statement can be pictured as a commuting diagram, see figure 2. It has been demonstrated that complete proofs of compiler correctness can be automatically checked.
Reference: [40] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> Two-Level Functional Languages. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: In this case, our operation will yield a sort containing precisely that truth-value-list, when given the integer, the type "truth-value-list", and the heap. In contrast, for example Nielson and Nielson <ref> [40] </ref> does not involve the machine state when relating semantic values. Instead, they require target values to be "self-contained". Hence, they need to have several types of target values and a target machine that does run-time type checking.
Reference: [41] <author> Hanne R. Nielson and Flemming Nielson. </author> <title> Automatic binding time analysis for a typed -calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 10 </volume> <pages> 139-176, </pages> <year> 1988. </year>
Reference-contexts: Attempts to recover useful information from lambda expressions include Schmidt's work on detecting so-called single-threaded store arguments and stack single-threaded environment arguments [52, 54], and the binding-time analysis of Nielson and Nielson <ref> [41] </ref>. Despite that, it seems unlikely that the performance characteristics of compiler generators based on denotational semantics soon will be improved beyond that of existing such systems. A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers.
Reference: [42] <author> Hewlett Packard. </author> <title> Precision architecture and instruction. </title> <type> Technical Report 09740-90014, </type> <month> June </month> <year> 1987. </year>
Reference-contexts: For an example of a language description that has been processed by Cantor, see appendix B. The abstract RISC machine language can easily be expanded into code for existing RISC processors. Currently, implementations exist for the SPARC [25] and the HP Precision Architecture <ref> [42] </ref>.
Reference: [43] <author> Jens Palsberg. </author> <title> An automatically generated and provably correct compiler for a subset of Ada. </title> <booktitle> In Proc. ICCL'92, Fourth IEEE International Conference on Computer Languages, </booktitle> <pages> pages 117-126, </pages> <address> Oakland, California, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: This paper gives an overview of the author's forthcoming PhD thesis [44]. Most definitions and proofs are omitted. For an overview of our experiments with generating a compiler for a subset of Ada, see <ref> [43] </ref>. In the following section we examine the major previous approaches to compiler generation and compiler correctness proofs. In section 3 we outline the structure of the Cantor system, including the abstract RISC machine language and the action compiler, and we give some performance measures. <p> These figures indicate that the system is rather tedious to work with in practice. Additional experiments, see <ref> [43] </ref>, have shown that the code runs at least two orders of magnitude slower than a corresponding target program 14 produced by the C compiler (without optimization).
Reference: [44] <author> Jens Palsberg. </author> <title> Provably Correct Compiler Generation. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1992. </year>
Reference-contexts: This paper gives an overview of the author's forthcoming PhD thesis <ref> [44] </ref>. Most definitions and proofs are omitted. For an overview of our experiments with generating a compiler for a subset of Ada, see [43]. In the following section we examine the major previous approaches to compiler generation and compiler correctness proofs. <p> Type analysis and calculation of code size; and 12 2. Code generation. For each pass there is a function defined for every syntactic category. Those defined for `Act' have the following signatures (we cheat a little bit here, compared to <ref> [44] </ref>, to improve the readability): a-count :: Act, data-type, symbol-table ! (natural, truth-value, data-type, truth-value, data-type, block) . perform :: Act, data-type, general-register, frozen, symbol-table, cleanup, cleanup, cleanup, linenumber, linenumber-complete, linenumber-escape, linenumber-fail ! (program, general-register, general-register) . <p> Improving the action compiler to avoid this inefficiency would significantly complicate the correctness theorem, which we consider next. 4 The Correctness Theorem To give an overview of the correctness theorem, we will introduce a bit of notation, as follows (we cheat a little bit again, compared to <ref> [44] </ref>, to improve the readability): run :: Act, [integer] list ! state . sparc-run :: program, natural, page ! sparc-state . compile :: Act ! (program, truth-value, data-type, truth-value, data-type, general-register, general-register) . abstract :: sparc-state, truth-value, data-type, truth-value, data-type, general-register, general-register ! state . i-abs :: natural, page ! [integer]
Reference: [45] <author> Lawrence Paulson. </author> <title> A semantics-directed compiler generator. </title> <booktitle> In Ninth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 224-233, </pages> <year> 1982. </year>
Reference-contexts: The traditional approach to compiler generation is based on denotational semantics [53]. Examples of existing compiler generators based on this idea include Mosses' Semantics Implementation System (SIS) [29], Paulson's Semantics Processor (PSP) <ref> [45, 46] </ref>, and Wand's Semantic Prototyping System (SPS) [62]. In SIS, the lambda expressions are executed by a direct implementation of beta-reduction; in PSP and SPS they are compiled into SECD and Scheme code, respectively.
Reference: [46] <author> Uwe F. Pleban. </author> <title> Compiler prototyping using formal semantics. </title> <booktitle> In Proc. ACM SIGPLAN'84 Symposium on Compiler Construction, </booktitle> <pages> pages 94-105. </pages> <booktitle> Sigplan Notices, </booktitle> <year> 1984. </year>
Reference-contexts: The reader is assumed to be familiar with algebraic specification [12], compilation of block structured languages [64], and the notion of a RISC architecture [57]. 2 Previous Work 2.1 Compiler Generation The problem of compiler generation is usually approached by choosing a particular definition of a specific target language <ref> [46] </ref>. The task is then to write and prove the correctness of a compiler for a notation for defining source languages. Such a compiler can then be composed with a language definition to yield a correct compiler for the language, see figure 1. <p> The traditional approach to compiler generation is based on denotational semantics [53]. Examples of existing compiler generators based on this idea include Mosses' Semantics Implementation System (SIS) [29], Paulson's Semantics Processor (PSP) <ref> [45, 46] </ref>, and Wand's Semantic Prototyping System (SPS) [62]. In SIS, the lambda expressions are executed by a direct implementation of beta-reduction; in PSP and SPS they are compiled into SECD and Scheme code, respectively.
Reference: [47] <author> Uwe F. Pleban and Peter Lee. </author> <title> On the use of LISP in implementing de-notational semantics. </title> <booktitle> In Proc. ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 233-248, </pages> <month> August </month> <year> 1986. </year> <month> 36 </month>
Reference-contexts: A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller [55, 56], the compiler generator of Kelsey and Hudak [21], and the Mess system of Pleban and Lee <ref> [47, 23, 49, 22] </ref>. These approaches are based on rather ad hoc notations for defining languages, and they lack correctness proofs, like the classical systems.
Reference: [48] <author> Uwe F. Pleban and Peter Lee. </author> <title> High-level semantics, an integrated approach to programming language semantics and the specification of implementations. </title> <booktitle> In Proc. Mathmatical Foundations of Programming Language Semantics, </booktitle> <pages> pages 550-571, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: Mosses observed that denotational semantics intertwine model details with the semantic description, thus blurring the underlying conceptual analysis [31]. Pleban and Lee further observed that not only a human reader but also an automatic compiler generator will have difficulty in recovering the underlying analysis <ref> [48] </ref>. Attempts to recover useful information from lambda expressions include Schmidt's work on detecting so-called single-threaded store arguments and stack single-threaded environment arguments [52, 54], and the binding-time analysis of Nielson and Nielson [41].
Reference: [49] <author> Uwe F. Pleban and Peter Lee. </author> <title> An automatically generated, realistic compiler for an imperative programming language. </title> <booktitle> In Proc. SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 222-232, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller [55, 56], the compiler generator of Kelsey and Hudak [21], and the Mess system of Pleban and Lee <ref> [47, 23, 49, 22] </ref>. These approaches are based on rather ad hoc notations for defining languages, and they lack correctness proofs, like the classical systems.
Reference: [50] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: The use of denotational semantics renders difficult the specification of languages with non-determinism and parallelism. Such features can be specified easily, however, by adopting the framework of structural operational 7 ?? - semantics target semantics source encode compiler meanings target meanings source syntax target syntax source semantics <ref> [50] </ref>. For a survey of recent work on proving the correctness of compilers for such languages, see the paper by Gammelgaard and Nielson [11], which also contains a detailed account of the approach taken in the ProCoS project, where the source language considered is Occam2.
Reference: [51] <author> Wolfgang Polak. </author> <title> Compiler Specification and Verification. </title> <publisher> Springer-Verlag (LNCS 213), </publisher> <year> 1981. </year>
Reference-contexts: The lack of correctness proofs for the realistic compiler generators limits the confidence we can have in a generated compiler. Let us therefore examine the major previous approaches to compiler correctness proofs. 2.2 Compiler Correctness Proofs The traditional approach to proving compiler correctness is based on deno-tational semantics <ref> [24, 26, 58, 51, 39] </ref> or algebraic variations hereof [7, 28, 59, 3, 30]. The correctness statement can be pictured as a commuting diagram, see figure 2. It has been demonstrated that complete proofs of compiler correctness can be automatically checked.
Reference: [52] <author> David A. Schmidt. </author> <title> Detecting global variables in denotational specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(2) </volume> <pages> 299-310, </pages> <year> 1985. </year>
Reference-contexts: Pleban and Lee further observed that not only a human reader but also an automatic compiler generator will have difficulty in recovering the underlying analysis [48]. Attempts to recover useful information from lambda expressions include Schmidt's work on detecting so-called single-threaded store arguments and stack single-threaded environment arguments <ref> [52, 54] </ref>, and the binding-time analysis of Nielson and Nielson [41]. Despite that, it seems unlikely that the performance characteristics of compiler generators based on denotational semantics soon will be improved beyond that of existing such systems.
Reference: [53] <author> David A. Schmidt. </author> <title> Denotational Semantics. </title> <publisher> Allyn and Bacon, </publisher> <year> 1986. </year>
Reference-contexts: The Cantor system described in this paper is an example of a semantics-directed compiler generator. It accepts language definitions written in action notation, and it outputs compilers that emit code in an abstract RISC machine language. The traditional approach to compiler generation is based on denotational semantics <ref> [53] </ref>. Examples of existing compiler generators based on this idea include Mosses' Semantics Implementation System (SIS) [29], Paulson's Semantics Processor (PSP) [45, 46], and Wand's Semantic Prototyping System (SPS) [62].
Reference: [54] <author> David A. Schmidt. </author> <title> Detecting stack-based environments in denotational semantics. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 11 </volume> <pages> 107-131, </pages> <year> 1988. </year>
Reference-contexts: Pleban and Lee further observed that not only a human reader but also an automatic compiler generator will have difficulty in recovering the underlying analysis [48]. Attempts to recover useful information from lambda expressions include Schmidt's work on detecting so-called single-threaded store arguments and stack single-threaded environment arguments <ref> [52, 54] </ref>, and the binding-time analysis of Nielson and Nielson [41]. Despite that, it seems unlikely that the performance characteristics of compiler generators based on denotational semantics soon will be improved beyond that of existing such systems.
Reference: [55] <author> Uwe Schmidt and Reinhard Voller. </author> <title> A multi-language compiler system with automatically generated codegenerators. </title> <booktitle> In Proc. ACM SIGPLAN'84 Symposium on Compiler Construction. Sigplan Notices, </booktitle> <year> 1984. </year>
Reference-contexts: A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller <ref> [55, 56] </ref>, the compiler generator of Kelsey and Hudak [21], and the Mess system of Pleban and Lee [47, 23, 49, 22]. These approaches are based on rather ad hoc notations for defining languages, and they lack correctness proofs, like the classical systems.
Reference: [56] <author> Uwe Schmidt and Reinhard Voller. </author> <title> Experience with VDM in Norsk Data. </title> <booktitle> In VDM'87. VDM|A Formal Method at Work, </booktitle> <pages> pages 49-62. </pages> <publisher> Springer-Verlag (LNCS 252), </publisher> <month> March </month> <year> 1987. </year>
Reference-contexts: A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller <ref> [55, 56] </ref>, the compiler generator of Kelsey and Hudak [21], and the Mess system of Pleban and Lee [47, 23, 49, 22]. These approaches are based on rather ad hoc notations for defining languages, and they lack correctness proofs, like the classical systems.
Reference: [57] <author> William Stallings. </author> <title> Reduced Instruction Set Computers. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1986. </year>
Reference-contexts: We have overcome these problems. We have designed, implemented, and proved the correctness of a compiler generator, called Cantor, that accepts action semantic descriptions of programming languages. The generated compilers emit absolute code for an abstract RISC <ref> [57] </ref> machine language without run-time type-checking. The considered subset of action notation, see appendix A, is suitable for describing imperative programming languages featuring: * Complicated control flow; * Block structure; * Non-recursive abstractions, such as procedures and functions; and * Static typing. <p> We also discuss why we do not treat recursion. The reader is assumed to be familiar with algebraic specification [12], compilation of block structured languages [64], and the notion of a RISC architecture <ref> [57] </ref>. 2 Previous Work 2.1 Compiler Generation The problem of compiler generation is usually approached by choosing a particular definition of a specific target language [46]. The task is then to write and prove the correctness of a compiler for a notation for defining source languages.
Reference: [58] <author> Joseph E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: The lack of correctness proofs for the realistic compiler generators limits the confidence we can have in a generated compiler. Let us therefore examine the major previous approaches to compiler correctness proofs. 2.2 Compiler Correctness Proofs The traditional approach to proving compiler correctness is based on deno-tational semantics <ref> [24, 26, 58, 51, 39] </ref> or algebraic variations hereof [7, 28, 59, 3, 30]. The correctness statement can be pictured as a commuting diagram, see figure 2. It has been demonstrated that complete proofs of compiler correctness can be automatically checked.
Reference: [59] <author> James W. Thatcher, Eric G. Wagner, and Jesse B. Wright. </author> <title> More on advice on structuring compilers and proving them correct. </title> <journal> Theoretical Computer Science, </journal> <volume> 15 </volume> <pages> 223-249, </pages> <year> 1981. </year> <month> 37 </month>
Reference-contexts: Let us therefore examine the major previous approaches to compiler correctness proofs. 2.2 Compiler Correctness Proofs The traditional approach to proving compiler correctness is based on deno-tational semantics [24, 26, 58, 51, 39] or algebraic variations hereof <ref> [7, 28, 59, 3, 30] </ref>. The correctness statement can be pictured as a commuting diagram, see figure 2. It has been demonstrated that complete proofs of compiler correctness can be automatically checked.
Reference: [60] <author> Mads Tofte. </author> <title> Compiler Generators. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The generated compilers emit code for a stack machine; the correctness of these compilers has been sketched, whereas the implementation of the stack machine is not considered. 6 Finally, compiler generation can be obtained by self-application of a par-tial evaluator. The Ceres system of Tofte <ref> [60] </ref> is an early example of this, demonstrating that even compiler generators can be automatically generated. Ceres uses a language of flowcharts with an implicit state as the notation for defining source languages.
Reference: [61] <author> Larry Wall and Randal L. Schwartz. </author> <title> Programming Perl. </title> <address> O'Reilly, </address> <year> 1991. </year>
Reference-contexts: In practice, a session with Cantor looks as follows on the screen: cantor syntax semantics compiler compiler program code code input output The compiler generator cantor is written in Perl <ref> [61] </ref>, and the generated compilers are written in Scheme [1]. Examples of a syntax and a semantics are given in appendix B; it is the L A T E X source of the appendix that is processed by cantor.
Reference: [62] <author> Mitchell Wand. </author> <title> A semantic prototyping system. </title> <booktitle> In Proc. ACM SIGPLAN'84 Symposium on Compiler Construction, </booktitle> <pages> pages 213-221. </pages> <booktitle> Sigplan Notices, </booktitle> <year> 1984. </year>
Reference-contexts: The traditional approach to compiler generation is based on denotational semantics [53]. Examples of existing compiler generators based on this idea include Mosses' Semantics Implementation System (SIS) [29], Paulson's Semantics Processor (PSP) [45, 46], and Wand's Semantic Prototyping System (SPS) <ref> [62] </ref>. In SIS, the lambda expressions are executed by a direct implementation of beta-reduction; in PSP and SPS they are compiled into SECD and Scheme code, respectively.
Reference: [63] <author> David A. Watt. </author> <title> Programming Language Syntax and Semantics. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: The Cantor system is based on the use of such a machine language. 3 The Cantor System Our compiler generator accepts action semantic descriptions. Action semantics is a framework for formal semantics of programming languages, developed by Mosses [31, 32, 33, 36, 37] and Watt <ref> [38, 63] </ref>. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in using semantic entities called actions, rather than higher-order functions.
Reference: [64] <author> Niklaus Wirth. </author> <title> Algorithms + Data Structures = Programs. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: We also discuss why we do not treat recursion. The reader is assumed to be familiar with algebraic specification [12], compilation of block structured languages <ref> [64] </ref>, and the notion of a RISC architecture [57]. 2 Previous Work 2.1 Compiler Generation The problem of compiler generation is usually approached by choosing a particular definition of a specific target language [46].
Reference: [65] <author> William D. Young. </author> <title> A mechanically verified code generator. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 493-518, </pages> <year> 1989. </year> <month> 38 </month>
Reference-contexts: The correctness statement can be pictured as a commuting diagram, see figure 2. It has been demonstrated that complete proofs of compiler correctness can be automatically checked. Two significant instances are Young's <ref> [65] </ref> work, using the Boyer-Moore theorem prover, and Joyce's [19, 18] work using the HOL system. In both cases, the target code of the translation is a non-idealized machine-level architecture whose implementation has been verified with respect to a low level of the computer, see for example [17, 27].
References-found: 65

