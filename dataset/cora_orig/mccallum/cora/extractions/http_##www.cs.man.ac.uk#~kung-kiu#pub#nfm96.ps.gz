URL: http://www.cs.man.ac.uk/~kung-kiu/pub/nfm96.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: kung-kiu@cs.man.ac.uk  cdsm@doc.ic.ac.uk  ornaghi@dsi.unimi.it  
Title: Formal Development of Correct Classes in Computational Logic  
Author: Kung-Kiu Lau Chris Moss Mario Ornaghi 
Address: Oxford Road, Manchester M13 9PL, United Kingdom  Gate, London SW7 2BZ, United Kingdom  Via Comelico 39/41, Milano, Italy  
Affiliation: Department of Computer Science, University of Manchester  Department of Computing, Imperial College 180 Queen's  Dipartimento di Scienze dell'Informazione Universita' degli studi di Milano  
Abstract: Quality software must be reusable, extensible and reliable. In computational logic , we have developed an approach to constructing programs that are formally correct. Our approach can provide a basis for constructing software that is (formally) reusable and extensible, and not just reliable but formally correct. In this paper, we explain our notion of correct classes, and how to develop them. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Deville and K.K. Lau. </author> <title> Logic program synthesis. </title> <journal> J. Logic Programming 19,20:321-350, </journal> <note> 1994. Special issue: Ten years of logic programming. </note>
Reference-contexts: Of course for proving correctness, we use proof-theoretic versions of these correctness criteria. * A synthesis process that employs synthesis methods to derive correct programs from their specifications. (A survey of such methods can be found in <ref> [1] </ref>.) Typically an explicit specification of a new relation in F takes the form: 1 8 (r (x) $ R (x)) where R (x) is a formula of the language of F .
Reference: [2] <author> J.A. Goguen and R.M. Burstall. Institutions: </author> <title> Abstract model theory for specification and programming. </title> <editor> J. </editor> <booktitle> ACM 39(1) </booktitle> <pages> 95-146, </pages> <year> 1992. </year> <title> BCS-FACS Northern Formal Methods Workshop, 1996 13 Formal Development of Correct Classes in Computational Logic </title>
Reference-contexts: Our definition of composition essentially coincides with that of institutions <ref> [2] </ref>. However, the theory of institutions is not useful for our purposes, since it does not deal with the problem of preserving consistency. 8 Example 4.3 In our approach, framework composition is effected via parameter instantiation.
Reference: [3] <author> J. Goguen and J. Meseguer. </author> <title> Unifying functional, object-oriented and relational programming with logical semantics. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: In LIST , we can also use induction on lists. This illustrates the fact that in a framework we may have more than just ADT definitions. The syntax of a framework is thus similar to that of an algebraic ADT (e.g. <ref> [3, 16] </ref>). However, whereas an algebraic ADT is an initial model of its specification, the intended model of a closed framework is an isoinitial model, and an open framework has a class of isoinitial models. <p> Like initial semantics (e.g. <ref> [3] </ref>), isoinitial semantics also guarantees `no junk' and `no confusion', but has the additional capability to handle negation, which is important in database applications. <p> the closed instance LIST (I nt; &lt;) of the framework LIST (E lem; ) is the composition of the latter with the framework that defines the integer type I nt with the total ordering &lt;. 7 The p-axioms of F 1 are therefore like proof obligations, or requirement theories in <ref> [3] </ref>. 8 Equational or strict Horn axioms are guaranteed to be consistent.
Reference: [4] <author> C. Kreitz, K.K. Lau, and M. Ornaghi. </author> <title> Formal reasoning about modules, reuse and their correctness. In D.M. </title> <editor> Gab-bay and H.J. Ohlbach, editors, </editor> <booktitle> Proc. Int. Conf. on Formal and Applied Practical Reasoning, LNAI 1085 </booktitle> <pages> 384-399, </pages> <publisher> Springer-Verlag 1996. </publisher>
Reference-contexts: We can show that framework composition preserves adequacy: Theorem 4.1 If F 1 ( 1 ) and F 2 ( 2 ) are adequate, and F 1 [ae; F 2 ] is defined, then F 1 [ae; F 2 ] is adequate. (A proof is given in <ref> [4] </ref>.) Theorem 4.1 provides the basis for our strategy to start from small adequate (closed or open) frameworks, and incrementally construct larger adequate frameworks. The following basic adequate frameworks form a sufficient set of such building blocks: Example 4.4 (Term models) Consider a set K of constant and function symbols.
Reference: [5] <author> K.K. Lau and M. Ornaghi. </author> <title> On specification frameworks and deductive synthesis of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. LOPSTR 94 and META 94, </booktitle> <volume> LNCS 883 </volume> <pages> 104-121, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: So we say a framework is adequate if it is constructed only from adequate expansions. A useful criterion for the adequacy of an expansion is the existence of a steadfast program to compute the relation defined by the expansion (see <ref> [5] </ref>). Thus program synthesis itself provides a means of adequately expanding a framework. To extend this discussion to open frameworks, we need to address closed instances of an open framework F , i.e. compositions of F with closed frameworks C's that are closed frameworks themselves.
Reference: [6] <author> K.K. Lau, M. Ornaghi and S.- A. </author> <title> Tarnlund. The halting problem for deductive synthesis of logic programs. </title> <editor> In P. van Hentenryck, editor, </editor> <booktitle> Proc. 11 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 665-683, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: For lack of space, we shall assume some familiarity with basic logic programming terminology, as in e.g. [10]. 2 Overview of Our Approach to Logic Program Synthesis Our approach to program synthesis in computational logic has the following key components (more details can be found in <ref> [6, 8] </ref>): fl Part of this work was done during the first author's visit to Computing Science Department, Uppsala University, Sweden, supported by the European Union HCM project on Logic Program Synthesis and Transformation, contract no. 93/414. He wishes to thank Jonas Barklund for his invitation and hospitality.
Reference: [7] <author> K.K. Lau and M. Ornaghi. </author> <title> Towards an object-oriented methodology for deductive synthesis of logic programs. </title> <editor> In M. Proietti, editor, </editor> <booktitle> Proc. </booktitle> <volume> LOPSTR 95, LNCS 1048 </volume> <pages> 152-169, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: [8] <author> K.K. Lau and M. Ornaghi. </author> <title> A formal approach to deductive synthesis of constraint logic programs. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proc. 1995 Int. Logic Programming Symp., </booktitle> <pages> pages 543-557, </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: For lack of space, we shall assume some familiarity with basic logic programming terminology, as in e.g. [10]. 2 Overview of Our Approach to Logic Program Synthesis Our approach to program synthesis in computational logic has the following key components (more details can be found in <ref> [6, 8] </ref>): fl Part of this work was done during the first author's visit to Computing Science Department, Uppsala University, Sweden, supported by the European Union HCM project on Logic Program Synthesis and Transformation, contract no. 93/414. He wishes to thank Jonas Barklund for his invitation and hospitality.
Reference: [9] <author> K.K. Lau, M. Ornaghi and S.-. A. </author> <title> Tarnlund. Steadfast logic programs. </title> <note> Submitted to J. Logic Programming. </note>
Reference-contexts: In an open framework F (), the meaning of the defined symbols is characterised in terms of the parameters . Since the latter are supplied by a closed framework, steadfastness can be defined as follows (a more abstract, model-theoretic characterisation, can be found in <ref> [9] </ref>): Definition 4.6 Let F () be an open framework, and P : ffi ( be an open program. P is steadfast in F () iff it is steadfast in every closed instance F () [ C, where C is a closed framework.
Reference: [10] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: In this paper, we explain our notion of correct classes, and how to develop them. For lack of space, we shall assume some familiarity with basic logic programming terminology, as in e.g. <ref> [10] </ref>. 2 Overview of Our Approach to Logic Program Synthesis Our approach to program synthesis in computational logic has the following key components (more details can be found in [6, 8]): fl Part of this work was done during the first author's visit to Computing Science Department, Uppsala University, Sweden, supported
Reference: [11] <author> F.G. McCabe. </author> <title> L& O: Logic and Objects. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: It would be interesting to study how the advantages of both approaches could be combined, perhaps through the vehicle of object-oriented logic programming languages such as <ref> [11, 13] </ref>. Acknowledgements We wish to thank the referees for pointing out a number of minor errors in an earlier version of this paper.
Reference: [12] <author> B. Meyer. </author> <title> Eiffel the Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: As illustrated in Figure 1, such a module (Parameterised) Module = Framework + Programs # # # (Generic) Class = ADT + Methods contains ADT's as well as programs or methods that work on these ADT's, and is therefore a generic class in object-oriented terminology (e.g. <ref> [15, 12] </ref>). (It is, however, not a class of objects with internal states.) However, in contrast to classes in object-oriented programming, which usually have a type-theoretic characterisation, our classes have a model-theoretic semantics. Furthermore, in a class M, the programs also have intended models, viz. their minimum Herbrand models.
Reference: [13] <author> C.D.S. Moss. </author> <title> Prolog++: The Power of Object-Oriented and Logic Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference-contexts: It would be interesting to study how the advantages of both approaches could be combined, perhaps through the vehicle of object-oriented logic programming languages such as <ref> [11, 13] </ref>. Acknowledgements We wish to thank the referees for pointing out a number of minor errors in an earlier version of this paper.
Reference: [14] <author> J.C. Shepherdson. </author> <title> Negation in logic programming. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 19-88. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference: [15] <author> P. Wegner. </author> <title> The object-oriented classification paradigm. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 479-560, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: As illustrated in Figure 1, such a module (Parameterised) Module = Framework + Programs # # # (Generic) Class = ADT + Methods contains ADT's as well as programs or methods that work on these ADT's, and is therefore a generic class in object-oriented terminology (e.g. <ref> [15, 12] </ref>). (It is, however, not a class of objects with internal states.) However, in contrast to classes in object-oriented programming, which usually have a type-theoretic characterisation, our classes have a model-theoretic semantics. Furthermore, in a class M, the programs also have intended models, viz. their minimum Herbrand models.
Reference: [16] <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year> <booktitle> BCS-FACS Northern Formal Methods Workshop, </booktitle> <year> 1996 </year> <month> 14 </month>
Reference-contexts: In LIST , we can also use induction on lists. This illustrates the fact that in a framework we may have more than just ADT definitions. The syntax of a framework is thus similar to that of an algebraic ADT (e.g. <ref> [3, 16] </ref>). However, whereas an algebraic ADT is an initial model of its specification, the intended model of a closed framework is an isoinitial model, and an open framework has a class of isoinitial models.
References-found: 16

