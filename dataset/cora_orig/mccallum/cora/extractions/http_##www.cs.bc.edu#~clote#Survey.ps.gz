URL: http://www.cs.bc.edu/~clote/Survey.ps.gz
Refering-URL: http://www.cs.bc.edu/techreps.html
Root-URL: http://www.cs.bc.edu
Title: Computation Models and Function Algebras  
Author: P. Clote 
Note: Contents  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> W. </author> <title> Ackermann. </title> <journal> Zum Hilbertschen Aufbau der reelen Zahlen. Mathematische An-nalen, </journal> <volume> 99 </volume> <pages> 118-133, </pages> <year> 1928. </year>
Reference-contexts: In 1923, Th. Skolem [128] introduced the primitive recursive functions, and in 1925, as a technical tool in his claimed sketch proof of the continuum hypothesis, D. Hilbert [69] defined classes of higher type functionals by recursion. In 1928, W. Ack-ermann <ref> [1] </ref> furnished a proof that the diagonal function ' a (a; a) of Hilbert [69], a variant of the Ackermann function, is not primitive recursive. In 1931, K.
Reference: [2] <author> M. Ajtai. </author> <title> 1 1 -formulae on finite structures. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 24:1 - 48, </volume> <year> 1983. </year>
Reference-contexts: O (n), resp. n O (1) ] with at most O (1) alternations. 5 4 Divide and conquer algorithms are generally space efficient. The parallel computation thesis states that sequential space equals parallel time (see [17]). In this sense, atm's provide a parallel computation model. 5 It follows from <ref> [50, 2] </ref> that lh is a hierarchy, where the collection of languages accepted by k-alternations is properly contained in the collection of languages accepted by k + 1-alternations. <p> (f (n)) [ c&gt;0 atime (c f (n) 2 ): For f (n) log n, aspace (f (n)) [ c&gt;0 dtime (c f (n) ): From definitions, it is clear that lh alogtime logspace ptime ph pspace and lh lth alintime dlinspace pspace: By Furst, Saxe, Sipser [50] and Ajtai <ref> [2] </ref>, integer multiplication does not belong to lh (since multiplication fi is a function, what is meant is that fi 62 flh, where 10 the latter is the class of functions of linear growth rate, whose bitgraph belongs to lh; this is defined later).
Reference: [3] <author> B. Allen. </author> <title> Arithmetizing uniform N C. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 53(1) </volume> <pages> 1-50, </pages> <year> 1991. </year>
Reference-contexts: B. Thompson [132] in 1972 on polynomial space, of K. Wagner [138] in 1979 on general time complexity classes. Function algebra characterizations of parallel complexity classes were given more recently by the author [38] in 1990 and B. Allen <ref> [3] </ref> in 1991, while certain small boolean circuit complexity classes were treated by the author and G. Takeuti [36] in 1995. Higher type analogues of certain characterizations were given in 1976 by K. Mehlhorn [95], in 1991 by S. Cook and B. <p> Theorem 3.27 (P. Clote [38]) nc = [0; I; s 0 ; s 1 ; jxj; bit; #; comp; crn; wbrn] ac k = ff 2 nc : rk wbrn (f ) kg: It should be mentioned that independently and at about the same time, B. Allen <ref> [3] </ref> characterized nc by a function algebra using a form of divide and conquer recursion, and noticed without giving details that over a basis of appropriate initial functions, nc could also be characterized by the scheme of wbrn. 13 A precise statement of Allen's characterization is given later in Theorem 3.77. <p> The above functions, for n 3, were taken from [12]. 13 See remark at bottom of p. 13 of <ref> [3] </ref>. 29 A number of characterizations of Grzegorczyk's classes E n E n , for n 3, have been given. A. Meyer and D. Ritchie [96] characterized E n in terms of certain loop programming languages, H. <p> For every k 3, there is a family F of functions such that CW k (F) fl ae CW k+1 (F fl ). Parallel algorithms often employ a divide and conquer strategy. B. Allen <ref> [3] </ref> formalized this approach to characterize nc. Definition 3.76 The front half fh (x) is defined by msp (x; bjxj=2c) and the back half bh (x) by lsp (x; bjxj=2c). <p> Define the bounded shift left function by shl (x; i; y) = x 2 min (i;jyj) . Theorem 3.77 (B. Allen <ref> [3] </ref>) nc is characterized by the function algebra [0; I; s; +; . ; jxj; bit; cond; c ; Seq; fi; msp; shl; comp; map; pbbr]: Allen explicitly did not attempt to find the smallest set of initial functions, but went on to develop a proof theory for nc functions, similar <p> As our definition of k-bounded recursion corresponds to Kuty lowski's definition of k + 1-bounded recursion, the indices of W k (F) and CW k (F) differ by 1 from [86]. 22 Here, we use the earlier defined sequence numbers, though Allen <ref> [3] </ref> uses a different sequence encoding technique. 41 Definition 3.78 (F. <p> Theorem 3.103 (S. Bellantoni [9]) nc = [0; I; S 0 ; S 1 ; C; L; bit; # 0 ; scomp; crn; swrn]: Following <ref> [3] </ref>, define bh (x) = x mod 2 djxj=2e and fh (x) = msp (x; bh (x)). The back half bh (x) consists of the djxj=2e rightmost bits of x, while the front half fh (x) consists of the bjxj=2c leftmost bits of x. In [14] S.
Reference: [4] <author> G. Asser. </author> <title> Primitive recursive word-functions of one variable. </title> <editor> In Egon Borger, editor, </editor> <booktitle> Computaion Theory and Logic, </booktitle> <pages> pages 14-19. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <note> Lecture Notes in Computer Science 270. </note>
Reference-contexts: Robinson [113]) Define the operation add by add (f; g)(x) = f (x) + g (x), and let q (x) = x b xc 2 . Let PR 1 denote the collection of one-place primitive recursive functions. Then PR 1 equals [0; s; q; comp; iter; add]. In <ref> [4] </ref> G. Asser recently presented a version of the previous theorem for primitive recursive word functions of one variable.
Reference: [5] <author> L. Babai and L. Fortnow. Arithmetization: </author> <title> a new method in structural complexity theory. </title> <journal> Computational Complexity, </journal> <volume> 1 </volume> <pages> 41-66, </pages> <year> 1991. </year>
Reference-contexts: Unless P = N P , it is unlikely that #P is closed under composition. Using the arithmetization of boolean formulas from A. Shamir (see <ref> [5] </ref>), H. Vollmer and K. Wagner gave the following characterization of #P . 20 Theorem 3.70 (H. Vollmer, K.
Reference: [6] <author> D. Mix Barrington, N. Immerman, and H. Straubing. </author> <title> On uniformity in N C 1 . Journal of Computer and System Science, </title> <booktitle> 41(3) </booktitle> <pages> 274-306, </pages> <year> 1990. </year>
Reference-contexts: In the following, the function value f (u) = v is computed by a logtime Turing machine in the sense that on input (k; u), the machine outputs the k-th bit of v in time logarithmic in the length of the input. Fact 2.4 (Barrington-Immerman-Straubing <ref> [6] </ref>) Given an input of length n, a deterministic logtime ratm can (i) compute the length of its input, (ii) add and subtract integers of O (log n) bits, (iii) decode a simple pairing function on strings of length O (n). Proof. <p> Various notions of uniformity have been suggested (ptime-uniformity [8], logspace-uniformity [17], U E fl -uniformity [116], etc.), but the most robust (and strictest) appears to be that of logtime-uniformity <ref> [18, 6] </ref>, which is adopted in this paper. Definition 2.17 (W. <p> Various notions of uniformity have been suggested (ptime-uniformity [8], logspace-uniformity [17], U E fl -uniformity [116], etc.), but the most robust (and strictest) appears to be that of logtime-uniformity [18, 6], which is adopted in this paper. Definition 2.17 (W. Ruzzo [116], also <ref> [6] </ref>) The direct connection language (dcl) of a circuit family (C n : n 2 N) is the set of (a; b; `; 0 n ), where a is the parent of b in the circuit C n , and the label of gate a is `. <p> Rose [114] and K. Wagner and G. Wechsung [139] (chapters 2, 10). Since newer results concerning smaller complexity classes yield older results concerning larger classes as corollaries, we begin with a function algebra introduced by the author for the class F lh of functions in the logtime hierarchy. By <ref> [6] </ref>, this class is equal to the class ac 0 of functions computable on a concurrent random access machine in constant parallel time with a polynomial number of processors. 3.1 An algebra for the logtime hierarchy lh Definition 3.3 The successor function satisfies s (x) = x + 1; the binary <p> It follows that F lh A 0 . In Furst et al. [50], integer multiplication was shown to be ac 0 reducible to maj, where maj (x) is 1 if P i&lt;jxj bit (i; x) djxj=2e, else 0. In Chandra et al. [25] as refined by Barrington et al. <ref> [6] </ref>, maj was shown to be ac 0 reducible to integer multiplication. The following characterization of polysize, constant depth threshold circuits tc 0 is proved by formalizing these reductions, using the previous techniques. <p> Theorem 3.16 (Clote-Takeuti [36]) tc 0 = [0; I; s 0 ; s 1 ; jxj; bit; fi; #; comp; crn]: Remark 3.17 Theorem 3.15 was first obtained by combining the author's result [38] that A 0 equals fo definable functions, and the Barrington-Immerman-Straubing result <ref> [6] </ref> that fo = lh, an analogue of Bennett's Theorem 3.56. 11 The current proof is direct, influenced by A. Woods' presentation in [141], and simplifies the argument of [6] by using Lemma 3.13 and Lemma 3.14, both of which were generalized from Lemma 3.55. <p> 3.15 was first obtained by combining the author's result [38] that A 0 equals fo definable functions, and the Barrington-Immerman-Straubing result <ref> [6] </ref> that fo = lh, an analogue of Bennett's Theorem 3.56. 11 The current proof is direct, influenced by A. Woods' presentation in [141], and simplifies the argument of [6] by using Lemma 3.13 and Lemma 3.14, both of which were generalized from Lemma 3.55. Lemma 3.55 was first proved by Nepomnjascii [100] (a related result proved by Bennett [13]), though R. Kannan [78] later rediscovered this result. <p> Definition 3.18 The function f is defined by bounded recursion on notation (brn) from g; h 0 ; h 1 ; k if f (0; ~y) = g (~y); f (s 1 (x); ~y) = h 1 (x; ~y; f (x; ~y)) 11 See <ref> [6] </ref> for definition of fo. 26 provided that f (x; ~y) k (x; ~y) for all x; ~y. Theorem 3.19 ( A. Cobham [39], see H. Rose [114]) Fptime = [0; I; s 0 ; s 1 ; #; comp; brn]: Proof.
Reference: [7] <author> D.A. Barrington. </author> <title> Bounded-width polynomial-size branching programs recognize exactly those languages in N C 1 . Journal of Computer and System Sciences, </title> <address> 38:150 164, </address> <year> 1989. </year>
Reference-contexts: Here, the function value f (u) = v is computed by a logtime Turing machine in the sense that on input (k; u), the machine outputs the k-th bit of v in time logarithmic in the length of the input. Theorem 2.10 (D. Barrington <ref> [7] </ref>) Let G be any finite non-solvable permutation group (for example S 5 ). <p> (6) = [0; I; s 0 ; s 1 ; jxj; bit; #; comp; crn; 2 brn](28) acc (6) = [0; I; s 0 ; s 1 ; jxj; bit; #; comp; crn; 3 brn]:(29) The following characterization of F alogtime uses earlier techniques with a formalization of Barrington's trick <ref> [7] </ref> in Theorem 2.10 of expressing boolean connectives and, or by permutation group word problems. Theorem 3.26 (P.
Reference: [8] <author> P.W. Beame, S.A. Cook, and H.J. </author> <title> Hoover. Log depth circuits for division and related problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 15 </volume> <pages> 994-1003, </pages> <year> 1986. </year>
Reference-contexts: Various notions of uniformity have been suggested (ptime-uniformity <ref> [8] </ref>, logspace-uniformity [17], U E fl -uniformity [116], etc.), but the most robust (and strictest) appears to be that of logtime-uniformity [18, 6], which is adopted in this paper. Definition 2.17 (W.
Reference: [9] <author> S. Bellantoni. </author> <title> Predicative recursion and computational complexity. </title> <type> Technical Report 264/92, </type> <institution> University of Toronto, Computer Science Department, </institution> <month> September </month> <year> 1992. </year> <pages> 164 pages. </pages>
Reference-contexts: Thus srn may be simulated using brn. Corollary 3.95 ptime = (normal " [0; I; S 0 ; S 1 ; P; C; scomp; srn]) fl : This approach has led to other characterizations of familiar complexity classes using safe variants of unbounded recursion schemes. Theorem 3.96 (Bellantoni <ref> [9] </ref>) Let f (~x) be a function satisfying jf (~x)j = O (log jxj). <p> The algebra B = [0; I; S 0 ; S 1 ; P; C; scomp; srn; smin]. Let B i denote the set of functions derivable in B using at most i applications of safe minimization. Theorem 3.99 (Bellantoni [10]) 2 P Definition 3.100 (Bellantoni <ref> [9] </ref>) The function f is defined by safe recursion 24 (sr) from the functions g; h if f (0; ~y; ~a) = g (~y; ~a) Define the following initial functions by (successor) S (; a) = a + 1 (41) (predecessor) P r (; a) = a . 1 (42) (conditional) <p> Theorem 3.101 (Bellantoni <ref> [9] </ref>) E 2 = normal " [0; I; S; P r; K; scomp; sr]: W. Handley (unpublished) and D. Leivant (unpublished) both independently obtained Theorem 3.101. Building on Bellantoni's proof, in her work on linear space reasoning, A.P. Nguyen [102] gave a slightly different characterization of this class. <p> The idea is that one admits various copies or tiers W 0 , W 1 , . . . of the word algebra W (generated from 0 by s 0 ; s 1 ), 25 and defines ramified recurrence by 24 In <ref> [9] </ref> this scheme is called predicative primitive recursion. 25 Leivant considers more general algebras defined from finitely many constructors. 50 where the tier of the first argument s i (x) is larger than the tier of the value f (x; ~y). <p> In particular, can one characterize M 2 by [0; I; S; P r; K; scomp; smin]? (Note that the conditional function cond 2 E 1 E 0 .) Turning to parallel computation, by building on Theorem 3.27, S. Bellantoni <ref> [9] </ref> characterizes nc as those functions with normal variables in an algebra built up from 0, I, S 0 , S 1 , the conditional C, the bit function bit, the length function L (; a) = jaj, a variant # 0 of the smash function, and closed under safe composition, <p> The function f is defined by safe weak recursion on notation (swrn) 26 from the functions g; h if f (0; ~y; ~a) = g (~y; ~a) f (x; ~y; ~a) = h (x; ~y; ~a; f (H (x); ~y; ~a)); provided x 6= 0. Theorem 3.103 (S. Bellantoni <ref> [9] </ref>) nc = [0; I; S 0 ; S 1 ; C; L; bit; # 0 ; scomp; crn; swrn]: Following [3], define bh (x) = x mod 2 djxj=2e and fh (x) = msp (x; bh (x)). <p> Note that in vsdcr the iteration function h has no normal parameters, and hence cannot itself be defined by recursion. 26 In <ref> [9] </ref> this scheme is called log recursion. 51 Theorem 3.105 (S. Bloch [14]) There is a collection base of initial functions, for which alogtime = (normal " [base; scomp; vsdcr]) fl polylogtime = (normal " [base; scomp; sdcr]) fl : Sketch of Proof. <p> Against this, in [122] A. Seth proves that the type-1 section of the closure of type-2 exponential time with L is not the class of exponential time computable functions, and hence L should not be considered a feasible functional. It is worth noting that Bellantoni (p. 85 in <ref> [9] </ref>) showed that if one adds the length function jxj to a modification of class B from [9], and closes under lambda abstraction and application, then the resulting higher type class does compute the functional L. S. <p> It is worth noting that Bellantoni (p. 85 in <ref> [9] </ref>) showed that if one adds the length function jxj to a modification of class B from [9], and closes under lambda abstraction and application, then the resulting higher type class does compute the functional L. S. Bellantoni (private correspondence) has raised the question whether the class obtained by omitting jxj is equivalent to bff.
Reference: [10] <author> S. Bellantoni. </author> <title> Predicative recursion and the polytime hierarchy. </title> <editor> In P. Clote and J. Remmel, editors, </editor> <booktitle> Feasible Mathematics II, </booktitle> <pages> pages 15-29. </pages> <publisher> Birkhauser, </publisher> <year> 1995. </year>
Reference-contexts: Fol lowing S. Buss [18] let 2 P i denote the class of functions computed in polynomial time on a Turing machine with oracle A, for some set A 2 P i . With this notation, F ph = [ i 2 P Definition 3.61 (S. Bellantoni <ref> [10] </ref>) Let F P i denote the algebra ff 2 [0; I; s 0 ; s 1 ; #; comp; brn; bmin] : rk bmin (f ) ig: Theorem 3.62 (S. Bellantoni [10]) For i 0, 2 P i = F P i . 3.5 Divide and conquer, course-of-values and miscellaneous <p> With this notation, F ph = [ i 2 P Definition 3.61 (S. Bellantoni <ref> [10] </ref>) Let F P i denote the algebra ff 2 [0; I; s 0 ; s 1 ; #; comp; brn; bmin] : rk bmin (f ) ig: Theorem 3.62 (S. Bellantoni [10]) For i 0, 2 P i = F P i . 3.5 Divide and conquer, course-of-values and miscellaneous Definition 3.63 (Grzegorczyk [57], Constable [40]) The function f is defined by bounded summation (bsum) [resp. bounded product (bprod)] from g; k if f (x; ~y) equals x i=0 g (i; ~y) <p> The algebra B = [0; I; S 0 ; S 1 ; P; C; scomp; srn; smin]. Let B i denote the set of functions derivable in B using at most i applications of safe minimization. Theorem 3.99 (Bellantoni <ref> [10] </ref>) 2 P Definition 3.100 (Bellantoni [9]) The function f is defined by safe recursion 24 (sr) from the functions g; h if f (0; ~y; ~a) = g (~y; ~a) Define the following initial functions by (successor) S (; a) = a + 1 (41) (predecessor) P r (; a)
Reference: [11] <author> S. Bellantoni and S. Cook. </author> <title> A new recursion-theoretic characterization of the polytime functions. </title> <journal> Computational Complexity, </journal> <volume> 2 </volume> <pages> 97-110, </pages> <year> 1992. </year>
Reference-contexts: Sometimes, to help distinguish normal from safe positions, the letters u; v; w; x; y; z; : : : denote normal variables, while a; b; c; : : : denote safe variables. This terminology, due to Bellantoni-Cook <ref> [11] </ref>, was chosen to indicate that a safe position is one where it is safe to substitute an impredicative value. Related tiering notions, though technically different, have occurred in the literature, as in the author's work with G. <p> Definition 3.87 (Bellantoni-Cook <ref> [11] </ref>) The function f is defined by safe compo sition (scomp) from g; u 1 ; : : : ; u n ; v 1 ; : : : ; v m if f (~x; ~a) = g (u 1 ( ~x;); : : : ; u n ( ~x;); v <p> 0 (x; ~y; ~a; f (x; ~y; ~a)); provided x 6= 0 f (s 1 (x); ~y; ~a) = h 1 (x; ~y; ~a; f (x; ~y; ~a)): The function algebra B is defined by [0; I; S 0 ; S 1 ; P; C; scomp; srn]: Theorem 3.89 (Bellantoni-Cook <ref> [11] </ref>) The polynomial time computable functions are exactly those functions of B having only normal arguments, i.e. F ptime = normal " B: The difficult direction of the proof is the inclusion from left to right. <p> : ; y n ) for jwj p g (jy 1 j; : : : ; jy n j)(34) i (w; ~x) for jwj p h i (j~xj):(35) Define f 0 (w; ~x) = g 0 (w; h 0 n (w; ~x))(36) n X p h i (j~xj):(37) 23 In <ref> [11] </ref> this scheme is called predicative notational recursion. 46 It follows that f (~x) = f 0 (w; ~x) for all jwj p f (j~xj). <p> Lemma 3.93 Let f belong to B. There is a monotone increasing polynomial q f such that jf (~x; ~y)j q f (j~xj) + max i jy i j for all ~x; ~y. Theorem 3.94 (Bellantoni-Cook <ref> [11] </ref>) If f (~x; ~y) 2 B then there is f 0 (~x; ~y) 2 F ptime such that f (~x; ~y) = f 0 (~x; ~y) for all ~x; ~y. Proof. By induction on the construction of f in B. The case for initial functions and composition is straightforward.
Reference: [12] <author> A. Bel'tyukov. </author> <title> A computer description and a hierarchy of initial Grzegorczyk classes. </title> <journal> Journal of Soviet Mathematics, </journal> <volume> 20:2280 - 2289, </volume> <year> 1982. </year> <title> Translation from Zap. </title> <journal> Nauk. Sem. Lening. Otd. Mat. Inst., V. A. Steklova AN SSSR, </journal> <volume> Vol. 88, </volume> <pages> pp. 30 - 46, </pages> <year> 1979. </year>
Reference-contexts: Remark 3.30 For n 3, Grzegorczyk's [57] original functions were defined by f n+1 (0; y) = f n (y + 1; y + 1), and f n+1 (x + 1; y) = f n+1 (x; f n+1 (x; y)). The above functions, for n 3, were taken from <ref> [12] </ref>. 13 See remark at bottom of p. 13 of [3]. 29 A number of characterizations of Grzegorczyk's classes E n E n , for n 3, have been given. A. Meyer and D. Ritchie [96] characterized E n in terms of certain loop programming languages, H. <p> An interesting partial result concerning the containment of the first two relational classes is the following. Theorem 3.32 (A. Bel'tyukov <ref> [12] </ref>) For s 1, let fi s (x) = max (1; x + dx 11=s e). Then for s 1, E 0 fl = (Efi s ) fl .
Reference: [13] <author> J.H. Bennett. </author> <title> On Spectra. </title> <type> PhD thesis, </type> <institution> Princeton University, 1962. Department of Mathematics. </institution>
Reference-contexts: Jones and A. Selman [76] to equal ntime (2 O (n) ), was the starting point for J.H. Bennett's work <ref> [13] </ref> in 1962. <p> The proof relies on arithmetizing computations via Godel numbers, a technique introduced in [52] by Godel, and with which Turing computable functions can be shown equivalent to -recursive functions. Since then, there have been a number of arithmetizations of machine models <ref> [81, 82, 13, 39, 111, 132, 138, 38, 36] </ref>, etc. <p> Primitive recursion defines f (x + 1) in terms of f (x), so that the computation of f (x) requires approximately 2 jxj many steps, an exponential number in the length of x. To define smaller complexity classes of functions, Bennett <ref> [13] </ref> introduced the scheme of recursion on notation, which Cobham [39] later used to characterize the polynomial time computable functions. 10 In this paper, for uniformity of notation, a number of operations are introduced as bounded instead of limited operations. <p> Woods' presentation in [141], and simplifies the argument of [6] by using Lemma 3.13 and Lemma 3.14, both of which were generalized from Lemma 3.55. Lemma 3.55 was first proved by Nepomnjascii [100] (a related result proved by Bennett <ref> [13] </ref>), though R. Kannan [78] later rediscovered this result. <p> Robinson's definition of addition from successor and multiplication, the following easily follows. Proposition 3.52 (Harrow [67]) M 2 fl = ca and M 2 = Gca. While it is obvious that rf fl = ca, it is non-trivial and surprising that ca equals the linear time hierarchy . In <ref> [13] </ref>, J.H. Bennett showed that the collection of constructive arithmetic sets ( 0 definable) is equal to rud, the class of rudimentary sets in the sense of [129]. Later, C. Wrathall [142] proved that the rudimentary sets are exactly those in the linear time hierarchy lth. Theorem 3.53 (J. Bennett [13]) <p> <ref> [13] </ref>, J.H. Bennett showed that the collection of constructive arithmetic sets ( 0 definable) is equal to rud, the class of rudimentary sets in the sense of [129]. Later, C. Wrathall [142] proved that the rudimentary sets are exactly those in the linear time hierarchy lth. Theorem 3.53 (J. Bennett [13]) The ternary relation G (x; y; z) for the graph x y = z of exponentiation is in constructive arithmetic. 17 The result is proved in [68] for [0; I; s; x y ; f n ; comp; bmin], but as, previously explained, the exponential is unnecessary. 18 In the
Reference: [14] <author> S. Bloch. </author> <title> Function-algebraic characterizations of log and polylog parallel time. </title> <journal> Com putational Complexity, </journal> <volume> 4(2) </volume> <pages> 175-205, </pages> <year> 1994. </year>
Reference-contexts: The back half bh (x) consists of the djxj=2e rightmost bits of x, while the front half fh (x) consists of the bjxj=2c leftmost bits of x. In <ref> [14] </ref> S. Bloch defines two distinct safe versions of Allen's divide and conquer recursion. Definition 3.104 (S. Bloch [14]) The function f is defined by safe divide and conquer recursion (sdcr) from the functions g; h if f (x; y; ~z; ~a) = g (x; ~z; ~a) if jxj max (jyj; <p> The back half bh (x) consists of the djxj=2e rightmost bits of x, while the front half fh (x) consists of the bjxj=2c leftmost bits of x. In <ref> [14] </ref> S. Bloch defines two distinct safe versions of Allen's divide and conquer recursion. Definition 3.104 (S. Bloch [14]) The function f is defined by safe divide and conquer recursion (sdcr) from the functions g; h if f (x; y; ~z; ~a) = g (x; ~z; ~a) if jxj max (jyj; 1) h (x; y; ~z; ~a; f (fh (; x); y; ~z; ~a); f (bh (; x); y; <p> Note that in vsdcr the iteration function h has no normal parameters, and hence cannot itself be defined by recursion. 26 In [9] this scheme is called log recursion. 51 Theorem 3.105 (S. Bloch <ref> [14] </ref>) There is a collection base of initial functions, for which alogtime = (normal " [base; scomp; vsdcr]) fl polylogtime = (normal " [base; scomp; sdcr]) fl : Sketch of Proof. <p> The collection base of initial functions consists of nc 0 computable versions of msp, lsp, fh, bh, a conditional function, and some string manipulating functions (see <ref> [14] </ref> for details). Only the proof of the first assertion will be sketched. Consider first the inclusion [base; scomp; vsdcr] fl alogtime. Show that base nc 0 alogtime.
Reference: [15] <author> Stephen Bloch, Jonathan Buss, and Judy Goldsmith. </author> <title> Sharply bounded alternation within P. </title> <note> To appear in Proceedings, DMTCS '96; submitted for journal publication, </note> <year> 1995. </year>
Reference-contexts: Details have been worked out by S. Bloch <ref> [15] </ref>, and a related category theoretic characterization has been announced by J. Otto [105]. 4 Type 2 functionals Many programming languages allow functions to be passed as parameters to other functions or procedures.
Reference: [16] <author> R. Boppana and M. Sipser. </author> <title> The complexity of finite functions. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume A, </booktitle> <pages> pages 759-804. </pages> <address> Else vier, </address> <publisher> MIT Press, </publisher> <address> 1990. </address> <publisher> Elsevier (Amsterdam), MIT Press (Cambridge). </publisher>
Reference-contexts: The following containments are known: nc k ac k nc k+1 nc 1 = alogtime logspace nlogspace ac 1 : None of the inclusions are known to be strict or not. For more information on circuits, see the excellent survey article by R. Boppana and M. Sipser <ref> [16] </ref>.
Reference: [17] <author> A. Borodin. </author> <title> On relating time and space to size and depth. </title> <journal> SIAM Journal on Computing, </journal> <volume> 6 </volume> <pages> 733-744, </pages> <year> 1973. </year>
Reference-contexts: O (n), resp. n O (1) ] with at most O (1) alternations. 5 4 Divide and conquer algorithms are generally space efficient. The parallel computation thesis states that sequential space equals parallel time (see <ref> [17] </ref>). In this sense, atm's provide a parallel computation model. 5 It follows from [50, 2] that lh is a hierarchy, where the collection of languages accepted by k-alternations is properly contained in the collection of languages accepted by k + 1-alternations. <p> Various notions of uniformity have been suggested (ptime-uniformity [8], logspace-uniformity <ref> [17] </ref>, U E fl -uniformity [116], etc.), but the most robust (and strictest) appears to be that of logtime-uniformity [18, 6], which is adopted in this paper. Definition 2.17 (W.
Reference: [18] <author> S. Buss. </author> <title> Bounded Arithmetic, volume 3 of Studies in Proof Theory. </title> <publisher> Bibliopolis, </publisher> <year> 1986. </year> <pages> 221 pages. </pages>
Reference-contexts: Various notions of uniformity have been suggested (ptime-uniformity [8], logspace-uniformity [17], U E fl -uniformity [116], etc.), but the most robust (and strictest) appears to be that of logtime-uniformity <ref> [18, 6] </ref>, which is adopted in this paper. Definition 2.17 (W. <p> Bellantoni as follows. Fol lowing S. Buss <ref> [18] </ref> let 2 P i denote the class of functions computed in polynomial time on a Turing machine with oracle A, for some set A 2 P i . With this notation, F ph = [ i 2 P Definition 3.61 (S. <p> Buss <ref> [18] </ref>. Independently and at the same time, an equivalent theory of arithmetic for nc functions was given by the author [27], later appearing in joint work with G. Takeuti [35]. In [109] F. Pitt considered a variant of B.
Reference: [19] <author> S. Buss. </author> <title> The polynomial hierarchy and intuitionistic bounded arithmetic. </title> <editor> In A.L. Selman, editor, </editor> <booktitle> Structure in Complexity Theory, </booktitle> <volume> volume 223, </volume> <pages> pages 77-103. </pages> <publisher> Springer Verlag, </publisher> <year> 1986. </year> <booktitle> Springer Lecture Notes in Computer Science. </booktitle>
Reference-contexts: In [123] Seth further investigated closure conditions for feasible functionals. In [115], J. Royer studied a polynomial time counterpart to the Kreisel-Lacombe-Shoenfield theorem [85]. Complexity theory for functionals of all finite types was initiated by S. Buss, who in <ref> [19] </ref> introduced a polynomial time analogue of the hereditarily recursive operations hro to define polynomial time functionals of all finite types decorated with runtime bounds. A. Nerode, J. Remmel and A. Scedrov [101] studied a polynomially graded type system. In [51], J.-Y. Girard, A. Scedrov and P.
Reference: [20] <author> S. Buss. </author> <title> The boolean formula value problem is in ALOGTIME. </title> <booktitle> In Proceedings of the 19th Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1987. </year> <pages> pp. 123 - 131. </pages>
Reference-contexts: Using such techniques, for instance, in [131] G. Takeuti provided a simpler proof of the existence of an alternating logtime algorithm for the boolean formula evaluation problem, a result first proved by S. Buss <ref> [20, 22] </ref> (see Theorem 2.11). For a further discussion of such applications, see the recent monograph by J. Krajicek [84]. Historically, Cobham's machine independent characterization of the polynomial time computable functions was the start of modern complexity theory, indicating a robust and mathematically interesting field. <p> The proof of (i) uses binary search, and according to <ref> [20] </ref>, appears to have been first noticed by M. Dowd. The proof of (ii) is clear, since addition and subtraction take time linear in the input length. <p> On the other hand, the word problem is clearly in alogtime, since one can compose n permutations by associating them with the leaves of a binary tree, whose internal nodes compute the composition of their children. Theorem 2.11 (S. Buss <ref> [20, 22] </ref>) The boolean formula valuation problem ffi : fi is a true variable-free propositional logic formulag is complete for alogtime under dlogtime reductions. The proof of Theorem 2.11 is long and difficult, so cannot be sketched here.
Reference: [21] <author> S.R. Buss. </author> <title> The graph of multiplication is equivalent to counting. </title> <journal> Information Pro cessing Letters, </journal> <volume> 41 </volume> <pages> 199-201, </pages> <year> 1992. </year> <month> 64 </month>
Reference-contexts: Note that Buss <ref> [21] </ref> has even shown that the graph of multiplication does not belong to lh. Since the graph of integer multiplication belongs to alogtime, the first containment above is proper. With this exception, nothing else is known about whether the other containments are proper.
Reference: [22] <author> S.R. Buss. </author> <title> Algorithms for boolean formula evaluation and for tree contraction. </title> <editor> In P. Clote and J. Krajicek, editors, </editor> <booktitle> Arithmetic, Proof Theory and Computational Complexity, </booktitle> <pages> pages 96-115. </pages> <publisher> Oxford University Press, </publisher> <year> 1993. </year>
Reference-contexts: Using such techniques, for instance, in [131] G. Takeuti provided a simpler proof of the existence of an alternating logtime algorithm for the boolean formula evaluation problem, a result first proved by S. Buss <ref> [20, 22] </ref> (see Theorem 2.11). For a further discussion of such applications, see the recent monograph by J. Krajicek [84]. Historically, Cobham's machine independent characterization of the polynomial time computable functions was the start of modern complexity theory, indicating a robust and mathematically interesting field. <p> On the other hand, the word problem is clearly in alogtime, since one can compose n permutations by associating them with the leaves of a binary tree, whose internal nodes compute the composition of their children. Theorem 2.11 (S. Buss <ref> [20, 22] </ref>) The boolean formula valuation problem ffi : fi is a true variable-free propositional logic formulag is complete for alogtime under dlogtime reductions. The proof of Theorem 2.11 is long and difficult, so cannot be sketched here.
Reference: [23] <author> J.-Y. Cai and M.L. Furst. </author> <title> P SP ACE survives three-bit bottlenecks. </title> <booktitle> In Proceedings of 3th Annual IEEE Conference on Structure in Complexity Theory, </booktitle> <pages> pages 94-102, </pages> <year> 1988. </year>
Reference-contexts: The following characterization results from the method of the proof of Barrington's Theorem 2.10, arithmetization techniques of this paper, and Theorem 2.12 implying that atime (n O (1) ) = pspace. In <ref> [23] </ref>, J.-Y. Cai and M. Furst give a related characterization of pspace using safe-storage Turing machines, a model related to Bel'tyukov's earlier stack register machines. The next result follows from a characterization of pspace by a variant of the stack register machine model. Theorem 3.41 (P.
Reference: [24] <author> A. Chandra, D. Kozen, and L. J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the Association of Computing Machinery, </journal> <volume> 28:114 - 133, </volume> <year> 1981. </year>
Reference-contexts: However, by allowing a tm to access its input bitwise via pointers or random access, sublinear runtimes can be achieved, as shown by Chandra et al. <ref> [24] </ref>. Definition 2.3 A Turing machine M with random access (ratm) is given by a finite set Q of states, an input tape having no tape head, k work tapes, an index query tape and an index answer tape . <p> A NP T B] if A can be computed by a deterministic [resp. nondeterministic] oracle Turing machine with oracle B in polynomial time. Let P 0 = P and P fA : (9B 2 P T B)g: 3 Logarithms are with respect to base 2. 7 In <ref> [24] </ref>, A. Chandra, D. Kozen and L. <p> In [117], W. Savitch proved that nspace (S (n)) dspace (S 2 (n)), for any space constructible S (n) log n. The following theorem, due to Chandra, Kozen and Stockmeyer <ref> [24] </ref>, is in part a generalization of Savitch's result that pspace = npspace, and relates alternating time and space to deterministic time and space. Theorem 2.12 (Chandra, Kozen, Stockmeyer [24]) For f (n) n, atime (f (n)) dspace (f (n)) nspace (f (n)) [ c&gt;0 atime (c f (n) 2 ): <p> The following theorem, due to Chandra, Kozen and Stockmeyer <ref> [24] </ref>, is in part a generalization of Savitch's result that pspace = npspace, and relates alternating time and space to deterministic time and space. Theorem 2.12 (Chandra, Kozen, Stockmeyer [24]) For f (n) n, atime (f (n)) dspace (f (n)) nspace (f (n)) [ c&gt;0 atime (c f (n) 2 ): For f (n) log n, aspace (f (n)) [ c&gt;0 dtime (c f (n) ): From definitions, it is clear that lh alogtime logspace ptime ph pspace and lh
Reference: [25] <author> A. Chandra, L. J. Stockmeyer, and U. Vishkin. </author> <title> Constant depth reducibility. </title> <journal> SIAM Journal on Computing, </journal> <volume> 13 </volume> <pages> 423-439, </pages> <year> 1984. </year>
Reference-contexts: It follows that F lh A 0 . In Furst et al. [50], integer multiplication was shown to be ac 0 reducible to maj, where maj (x) is 1 if P i&lt;jxj bit (i; x) djxj=2e, else 0. In Chandra et al. <ref> [25] </ref> as refined by Barrington et al. [6], maj was shown to be ac 0 reducible to integer multiplication. The following characterization of polysize, constant depth threshold circuits tc 0 is proved by formalizing these reductions, using the previous techniques.
Reference: [26] <author> A. Church. </author> <title> An unsolvable problem in elementary number theory. </title> <journal> American Journal of Mathematics, </journal> <volume> 58:345 - 363, </volume> <year> 1936. </year>
Reference-contexts: Generalizing Ackermann's work, in 1936 R. Peter [108] defined and studied the k-fold recursive functions. The same year saw the introduction of the fundamental concepts of Turing machine (A.M. Turing [134]), -calculus (A. Church <ref> [26] </ref>) and -recursive functions (S.C. Kleene [81]). By restricting the scheme of primitive recursion to allow only limited summations and limited products, the elementary functions were introduced in 1943 by L. Kalmar [77]. In 1953, A. <p> Nevertheless, definitions are given in sufficient detail to provide an idea of the required initial functions and closure operations which permit function algebra characterizations of complexity classes. 2.1 Turing machines In proving the recursive unsolvability of Hilbert's Entscheidungsproblem (independently established as well by A. Church <ref> [26] </ref> using the -calculus), A.M. Turing [134] introduced the Turing machine, largely motivated by his attempt to make precise the notion of computable (real) number, i.e., "those whose decimals which are calculable by finite means".
Reference: [27] <author> P. Clote. </author> <title> A first order theory for the parallel complexity class NC. </title> <type> Technical Report BCCS-89-01, </type> <institution> Boston College, Computer Science Department, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: Buss [18]. Independently and at the same time, an equivalent theory of arithmetic for nc functions was given by the author <ref> [27] </ref>, later appearing in joint work with G. Takeuti [35]. In [109] F. Pitt considered a variant of B. Allen's polynomial bounded branching recursion, where the function value is bounded by a constant. 21 What is here called a k-function is called a k + 1-function in [86].
Reference: [28] <author> P. Clote. </author> <title> ALOGT IME and a conjecture of S.A. Cook. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 6 </volume> <pages> 57-106, </pages> <year> 1992. </year>
Reference-contexts: All the function algebras defined in this paper could be used to define free variable equational calculi. For instance, S. Cook's system P V [42] comes from Theorem 3.19, the author's systems AV , ALV , ALV 0 <ref> [28, 30] </ref> come from Theorems 3.26 and 3.27, J. Johannsen's [74] systems T V; A2V come from Theorem 3.16, while M. O'Donnell [104] has proposed equational calculus as a programming language. In this paper, we will survey a selection of results which illustrate the arithme 2 According to [95], K. <p> fh; bh can be defined from the initial functions, and then by defining the function tree in the above function algebra, where tree is a function evaluating a full binary tree with alternating levels of and's and or's, and whose leaves are the bits of a given input x (see <ref> [38, 28] </ref> for details of definition). In [38], the author characterized alogtime as [0; I; s 0 ; s 1 ; jxj; bit; #; sc tree; comp; crn], so the proof sketch is complete. It is often useful to define two or more functions simultaneously.
Reference: [29] <author> P. Clote. </author> <title> A time-space hierarchy between P and PSPACE. </title> <journal> Math. Systems Theory, </journal> <volume> 25 </volume> <pages> 77-92, </pages> <year> 1992. </year>
Reference-contexts: Using such techniques, two characterizations of nc k were given in [38, 36]. Levels of a natural time-space hierarchy between Fptime and F pspace were characterized in <ref> [29] </ref>. 3.3 Bounded recursion In 1953, A. Grzegorczyk [57] investigated a hierarchy of subclasses E n of primitive recursive functions, defined as the closure of certain initial functions under composition and bounded recursion.
Reference: [30] <author> P. Clote. </author> <title> Polynomial size frege proofs of certain combinatorial principles. </title> <editor> In P. Clote and J. Krajicek, editors, </editor> <booktitle> Arithmetic, Proof Theory and Computational Complexity, </booktitle> <pages> pages 162 - 184. </pages> <publisher> Oxford University Press, </publisher> <year> 1993. </year>
Reference-contexts: All the function algebras defined in this paper could be used to define free variable equational calculi. For instance, S. Cook's system P V [42] comes from Theorem 3.19, the author's systems AV , ALV , ALV 0 <ref> [28, 30] </ref> come from Theorems 3.26 and 3.27, J. Johannsen's [74] systems T V; A2V come from Theorem 3.16, while M. O'Donnell [104] has proposed equational calculus as a programming language. In this paper, we will survey a selection of results which illustrate the arithme 2 According to [95], K. <p> Finally define `h (z) = fi (0; z) = 2 (z) if z encodes a pair 0 else (23) (24) 1 (z) c); b `h (z) Using the techniques introduced, the following can be proved. Theorem 3.12 (Clote <ref> [30] </ref>) If f 2 A 0 then there exists g 2 A 0 such that for all x, g (x; ~y) = hf (0; ~y); : : : ; f (jxj 1; ~y)i: The following two lemmas, together with the sequence encoding machinery of A 0 , will allow us soon <p> Theorem 3.26 (P. Clote <ref> [30] </ref>) F alogtime = [0; I; s 0 ; s 1 ; jxj; bit; #; comp; crn; 4 brn]: A natural question arising from work in vectorizing compilers is whether there is a recursive procedure to effectively parallelize sequential code (i.e. from sequential code, generate optimal code for a parallel machine).
Reference: [31] <author> P. Clote. </author> <title> Nondeterministic stack register machines. </title> <journal> Theoretical Computer Science A, </journal> <volume> 178, </volume> <year> 1996. </year>
Reference-contexts: Apart from characterizing E 2 fl or linspace, Bel'tyukov characterized the linear time hierarchy lth. The papers of Paris, Wilkie [107] and Handley, Paris, Wilkie [62] study counting classes between lth and linspace defined by stack register machines. Recent work of the author <ref> [31] </ref> and of W. Handley [64, 63] further study the effect of nondeterminism for this model. Lemma 3.33 (Grzegorczyk [57]) The functions x . y, sg (x), sg (x), sg (x)y, sg (x) y belong to E 0 . <p> In [23], J.-Y. Cai and M. Furst give a related characterization of pspace using safe-storage Turing machines, a model related to Bel'tyukov's earlier stack register machines. The next result follows from a characterization of pspace by a variant of the stack register machine model. Theorem 3.41 (P. Clote <ref> [31] </ref>) For k 4, pspace = [0; I; s 0 ; s 1 ; jxj; bit; #; comp; crn; k-br] fl : In [138] K. Wagner extended Ritchie's characterization to more general complexity classes. Theorem 3.42 (K. <p> In [107, 62], J. Paris, A. Wilkie and later W. Handley studied the effect of adding k-bounded recursion to lth. Using the techniques of Barrington, Paris, Wilkie and Handley, together with those of this paper, the following result can be proved. Theorem 3.59 (P. Clote <ref> [31] </ref>) For any k 4, alintime = [0; I; s; +; . ; fi; comp; bmin; k-br] fl . As in Corollary 3.57, F ph can similarly be characterized. <p> The following result was proved by the Paris-Wilkie modification of Bel'tyukov's stack register machines. Theorem 3.72 (Paris, Wilkie [107]) (R 2 ) fl = (R 3 ) fl . The next theorem follows from the author's work in <ref> [31] </ref> and is based on Barrington's trick. Theorem 3.73 (P. Clote [31]) For n 4, (R n ) fl = (R n+1 ) fl = alintime: In [86], Kuty lowski considered oracle versions of the Paris-Wilkie work. 20 In the notation of [137], the characterization reads #P = fi [+; . <p> The following result was proved by the Paris-Wilkie modification of Bel'tyukov's stack register machines. Theorem 3.72 (Paris, Wilkie [107]) (R 2 ) fl = (R 3 ) fl . The next theorem follows from the author's work in <ref> [31] </ref> and is based on Barrington's trick. Theorem 3.73 (P. Clote [31]) For n 4, (R n ) fl = (R n+1 ) fl = alintime: In [86], Kuty lowski considered oracle versions of the Paris-Wilkie work. 20 In the notation of [137], the characterization reads #P = fi [+; . ; fi; :] Sub, WProd fl , and fi fl WProd,Sum
Reference: [32] <author> P. Clote. </author> <title> A note on the relation between polynomial time functionals and Constable's class K. </title> <editor> In Kleine-Buning, editor, </editor> <booktitle> Computer Science Logic. Springer Lecture Notes in Computer Science, 1996. Result presented at CSL in Paderborn, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: It now appears that this assertion is doubtful, since K N C and it is currently conjectured that N C is properly contained in F ptime. Moreover, using an oracle separation of N C A from P A , the author <ref> [32] </ref> provided a counterexample to the previous claim. Theorem 3.68 (P. Clote [32]) There exists a non-decreasing function f for which K (f ) = F P (f ). Nevertheless, Constable's class K is very natural, suggesting the following question. <p> Moreover, using an oracle separation of N C A from P A , the author <ref> [32] </ref> provided a counterexample to the previous claim. Theorem 3.68 (P. Clote [32]) There exists a non-decreasing function f for which K (f ) = F P (f ). Nevertheless, Constable's class K is very natural, suggesting the following question. Question 3.69 What complexity class corresponds to [0; I; s; +; . ; fi; bx=yc; comp; sbsum; sbprod]? H.-J.
Reference: [33] <author> P. Clote, B. Kapron, and A. Ignjatovic. </author> <title> Parallel computable higher type function-als. </title> <booktitle> In Proceedings of IEEE 34th Annual Symposium on Foundations of Computer Science, </booktitle> <address> Nov 3-5, 1993. Palo Alto CA. </address> <pages> pp. 72-83. </pages>
Reference-contexts: Takeuti [36] in 1995. Higher type analogues of certain characterizations were given in 1976 by K. Mehlhorn [95], in 1991 by S. Cook and B. Kapron [79, 43] for sequential computation, and in 1993 by the author, A. Ignjatovic, B. Kapron <ref> [33] </ref> for parallel computation. In 1995 H. Vollmer and K. Wagner [137] Valiant's class #P . Though distinct, the arithmetization techniques of function algebras are related to those used in proving numerous results like (i) np equals generalized first order spectra (R. <p> functionals Q c ; 1 c d, and P such that Q c and For 1 c d define maxquery c M of rank (1,2) by maxquery c M (f; x; r) = q c 2 Q (M; f; x; t)[q c satisfies (44) and (45)]; 31 As noted in <ref> [33] </ref>, this result holds as well for unit cost. 56 where t is the least time satisfying jQ (M; f; x; t)j r or M halts in t steps. <p> But this follows from the type 2 version of Theorem 3.86. This completes the proof of Theorem 4.12. The oracle concurrent random access machine (ocram), introduced by the author, A. Ignjatovic and B. Kapron in <ref> [33] </ref> has instructions for (i) local operations | addition, cutoff subtraction, shift, (ii) global and local indirect reading and writing, (iii) control instructions | goto, conditional goto and halt, (iv) oracle calls, where in one step, all active processors simultaneously can retrieve f (x i x j ) = f ( <p> The following theorem is the type 2 analogue of the fact that ac 0 (or equivalently lh) is characterized by the function algebra A 0 . Theorem 4.18 (Clote, Kapron, Ignjatovic <ref> [33] </ref>) A functional F ( ~ f ; ~x) belongs to A 0 if and only if it is computable on an ocram in constant time with at most P (j ~ f j; j~xj) many processors, for some second-order polynomial P . <p> 7 17 if (M 1 M 5 ) then M g 1 = B % erase trailing 0's 18 HALT % Now X i = RBIT (f (x), i) The type 2 analogue of Theorem 3.27 was established by the author (in prepa ration), and strengthens the principal result of <ref> [33] </ref>. In his attempted proof of the continuum hypothesis, D. Hilbert [69] studied classes of higher type functionals defined by the operations of composition and primitive recursion. <p> In [43] S. Cook and B. Kapron characterized the higher type functionals in P V ! by certain kinds of programming language constructs, typed while programs and bounded loop programs. This kind of characterization was extended by P. Clote, B. Kapron and A. Ignjatovic in <ref> [33] </ref> to the higher type functionals in nc ! , relating bounded loop programs with higher type parallel complexity classes. In [124] A. Seth extended his definition of counter Turing machine to all finite types, thus characterizing P V ! by a machine model.
Reference: [34] <author> P. Clote and G. Takeuti. </author> <title> Exponential time and bounded arithmetic. </title> <editor> In A.L. Selman, editor, </editor> <booktitle> Structure in Complexity Theory, </booktitle> <volume> volume 223, </volume> <pages> pages 125-143. </pages> <booktitle> Springer Lecture Notes in Computer Science, </booktitle> <year> 1986. </year>
Reference-contexts: This terminology, due to Bellantoni-Cook [11], was chosen to indicate that a safe position is one where it is safe to substitute an impredicative value. Related tiering notions, though technically different, have occurred in the literature, as in the author's work with G. Takeuti <ref> [34] </ref> (k sorted variables used in defining k-fold multiple exponential time), but most especially in H. Simmons [127] (control variables, i.e. those used for recursion, are distinguished from usual variables; by separating their function, one prevents diagonalization as in the Ackermann function) and in D.
Reference: [35] <author> P. Clote and G. Takeuti. </author> <title> Bounded arithmetics for NC, ALOGT IM E, L and N L. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 56 </volume> <pages> 73-117, </pages> <year> 1992. </year>
Reference-contexts: Buss [18]. Independently and at the same time, an equivalent theory of arithmetic for nc functions was given by the author [27], later appearing in joint work with G. Takeuti <ref> [35] </ref>. In [109] F. Pitt considered a variant of B. Allen's polynomial bounded branching recursion, where the function value is bounded by a constant. 21 What is here called a k-function is called a k + 1-function in [86].
Reference: [36] <author> P. Clote and G. Takeuti. </author> <title> First order bounded arithmetic and small boolean circuit complexity classes. </title> <editor> In P. Clote and J. Remmel, editors, </editor> <booktitle> Feasible Mathematics II, </booktitle> <pages> pages 154-218. </pages> <publisher> Birkhauser Boston Inc., </publisher> <year> 1995. </year>
Reference-contexts: Wagner [138] in 1979 on general time complexity classes. Function algebra characterizations of parallel complexity classes were given more recently by the author [38] in 1990 and B. Allen [3] in 1991, while certain small boolean circuit complexity classes were treated by the author and G. Takeuti <ref> [36] </ref> in 1995. Higher type analogues of certain characterizations were given in 1976 by K. Mehlhorn [95], in 1991 by S. Cook and B. Kapron [79, 43] for sequential computation, and in 1993 by the author, A. Ignjatovic, B. Kapron [33] for parallel computation. In 1995 H. Vollmer and K. <p> The proof relies on arithmetizing computations via Godel numbers, a technique introduced in [52] by Godel, and with which Turing computable functions can be shown equivalent to -recursive functions. Since then, there have been a number of arithmetizations of machine models <ref> [81, 82, 13, 39, 111, 132, 138, 38, 36] </ref>, etc. <p> In Chandra et al. [25] as refined by Barrington et al. [6], maj was shown to be ac 0 reducible to integer multiplication. The following characterization of polysize, constant depth threshold circuits tc 0 is proved by formalizing these reductions, using the previous techniques. Theorem 3.16 (Clote-Takeuti <ref> [36] </ref>) tc 0 = [0; I; s 0 ; s 1 ; jxj; bit; fi; #; comp; crn]: Remark 3.17 Theorem 3.15 was first obtained by combining the author's result [38] that A 0 equals fo definable functions, and the Barrington-Immerman-Straubing result [6] that fo = lh, an analogue of Bennett's <p> An arithmetic version of Lind's characterization is the following. 12 In <ref> [36] </ref>, this scheme was denoted B 2 RN. 27 Theorem 3.22 F logspace = [0; I; s 0 ; s 1 ; jxj; bit; #; comp; crn; sbrn] = [0; I; s 0 ; s 1 ; mod2; msp; #; comp; crn; sbrn]: The first statement appeared in [37, 36] and <p> 12 In [36], this scheme was denoted B 2 RN. 27 Theorem 3.22 F logspace = [0; I; s 0 ; s 1 ; jxj; bit; #; comp; crn; sbrn] = [0; I; s 0 ; s 1 ; mod2; msp; #; comp; crn; sbrn]: The first statement appeared in <ref> [37, 36] </ref> and the second can be proved using similar techniques. Recently, function algebras have been found for small parallel complexity classes. Consider the following variants of recursion on notation. <p> The characterization of polynomial size, constant depth boolean circuits with parity gates (resp. mod6 gates) uses sequence encoding techniques of A 0 together with logtime hierarchy analogues of work of Handley, Paris, Wilkie [62]. Theorem 3.25 (Clote-Takeuti <ref> [36] </ref>) acc (2) = [0; I; s 0 ; s 1 ; jxj; bit; #; comp; crn; 1 brn](27) acc (6) = [0; I; s 0 ; s 1 ; jxj; bit; #; comp; crn; 2 brn](28) acc (6) = [0; I; s 0 ; s 1 ; jxj; bit; #; <p> Using such techniques, two characterizations of nc k were given in <ref> [38, 36] </ref>. Levels of a natural time-space hierarchy between Fptime and F pspace were characterized in [29]. 3.3 Bounded recursion In 1953, A. Grzegorczyk [57] investigated a hierarchy of subclasses E n of primitive recursive functions, defined as the closure of certain initial functions under composition and bounded recursion.
Reference: [37] <author> P.G. Clote. </author> <title> A sequential characterization of the parallel complexity class N C. </title> <type> Technical Report BCCS-88-07, </type> <institution> Department of Computer Science, Boston College, </institution> <year> 1988. </year>
Reference-contexts: 12 In [36], this scheme was denoted B 2 RN. 27 Theorem 3.22 F logspace = [0; I; s 0 ; s 1 ; jxj; bit; #; comp; crn; sbrn] = [0; I; s 0 ; s 1 ; mod2; msp; #; comp; crn; sbrn]: The first statement appeared in <ref> [37, 36] </ref> and the second can be proved using similar techniques. Recently, function algebras have been found for small parallel complexity classes. Consider the following variants of recursion on notation.
Reference: [38] <author> P.G. Clote. </author> <title> Sequential, machine-independent characterizations of the parallel complexity classes ALOGT IM E; AC k ; N C k and N C. </title> <editor> In P.J. Scott S.R. Buss, editor, </editor> <booktitle> Feasible Mathematics, </booktitle> <pages> pages 49-70. </pages> <publisher> Birkhauser, </publisher> <year> 1990. </year>
Reference-contexts: B. Thompson [132] in 1972 on polynomial space, of K. Wagner [138] in 1979 on general time complexity classes. Function algebra characterizations of parallel complexity classes were given more recently by the author <ref> [38] </ref> in 1990 and B. Allen [3] in 1991, while certain small boolean circuit complexity classes were treated by the author and G. Takeuti [36] in 1995. Higher type analogues of certain characterizations were given in 1976 by K. Mehlhorn [95], in 1991 by S. Cook and B. <p> The proof relies on arithmetizing computations via Godel numbers, a technique introduced in [52] by Godel, and with which Turing computable functions can be shown equivalent to -recursive functions. Since then, there have been a number of arithmetizations of machine models <ref> [81, 82, 13, 39, 111, 132, 138, 38, 36] </ref>, etc. <p> g; h 0 ; h 1 if f (0; ~y) = g (~y) f (s 1 (x); ~y) = s h 1 (x;~y) (f (x; ~y)): This scheme can be written in the abbreviated form f (0; ~y) = g (~y) The scheme crn was introduced by the author in <ref> [38] </ref>, though motivated by a similar scheme due to J. Lind [93]. <p> Theorem 3.16 (Clote-Takeuti [36]) tc 0 = [0; I; s 0 ; s 1 ; jxj; bit; fi; #; comp; crn]: Remark 3.17 Theorem 3.15 was first obtained by combining the author's result <ref> [38] </ref> that A 0 equals fo definable functions, and the Barrington-Immerman-Straubing result [6] that fo = lh, an analogue of Bennett's Theorem 3.56. 11 The current proof is direct, influenced by A. <p> Theorem 3.27 (P. Clote <ref> [38] </ref>) nc = [0; I; s 0 ; s 1 ; jxj; bit; #; comp; crn; wbrn] ac k = ff 2 nc : rk wbrn (f ) kg: It should be mentioned that independently and at about the same time, B. <p> Using such techniques, two characterizations of nc k were given in <ref> [38, 36] </ref>. Levels of a natural time-space hierarchy between Fptime and F pspace were characterized in [29]. 3.3 Bounded recursion In 1953, A. Grzegorczyk [57] investigated a hierarchy of subclasses E n of primitive recursive functions, defined as the closure of certain initial functions under composition and bounded recursion. <p> fh; bh can be defined from the initial functions, and then by defining the function tree in the above function algebra, where tree is a function evaluating a full binary tree with alternating levels of and's and or's, and whose leaves are the bits of a given input x (see <ref> [38, 28] </ref> for details of definition). In [38], the author characterized alogtime as [0; I; s 0 ; s 1 ; jxj; bit; #; sc tree; comp; crn], so the proof sketch is complete. It is often useful to define two or more functions simultaneously. <p> In <ref> [38] </ref>, the author characterized alogtime as [0; I; s 0 ; s 1 ; jxj; bit; #; sc tree; comp; crn], so the proof sketch is complete. It is often useful to define two or more functions simultaneously.
Reference: [39] <author> A. Cobham. </author> <title> The intrinsic computational difficulty of functions. </title> <editor> In Y. Bar-Hillel, editor, </editor> <booktitle> Logic, Methodology and Philosophy of Science II, </booktitle> <pages> pages 24-30. </pages> <publisher> North-Holland, </publisher> <year> 1965. </year>
Reference-contexts: In 1963 R. W. Ritchie [111] proved that Grze-gorczyk's class E 2 is the collection of functions computable in linear space on a Turing machine. In 1965, A. Cobham <ref> [39] </ref> characterized the polynomial time computable functions as the smallest function algebra closed under Bennett's scheme 1 In [69], Hilbert stated that "substitution (i.e. replacement of an argument by a new variable or function) and recursion (the scheme of deriving the function value for n + 1 from that of n)" <p> The proof relies on arithmetizing computations via Godel numbers, a technique introduced in [52] by Godel, and with which Turing computable functions can be shown equivalent to -recursive functions. Since then, there have been a number of arithmetizations of machine models <ref> [81, 82, 13, 39, 111, 132, 138, 38, 36] </ref>, etc. <p> To define smaller complexity classes of functions, Bennett [13] introduced the scheme of recursion on notation, which Cobham <ref> [39] </ref> later used to characterize the polynomial time computable functions. 10 In this paper, for uniformity of notation, a number of operations are introduced as bounded instead of limited operations. <p> Theorem 3.19 ( A. Cobham <ref> [39] </ref>, see H. Rose [114]) Fptime = [0; I; s 0 ; s 1 ; #; comp; brn]: Proof. Temporarily denote the algebra [0; I; s 0 ; s 1 ; #; comp; brn] by F . Consider first the inclusion from left to right.
Reference: [40] <author> R. Constable. </author> <title> Type 2 computational complexity. </title> <booktitle> In 5th Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1973. </year> <pages> pp. 108-121. </pages>
Reference-contexts: Bellantoni [10]) For i 0, 2 P i = F P i . 3.5 Divide and conquer, course-of-values and miscellaneous Definition 3.63 (Grzegorczyk [57], Constable <ref> [40] </ref>) The function f is defined by bounded summation (bsum) [resp. bounded product (bprod)] from g; k if f (x; ~y) equals x i=0 g (i; ~y) [resp. x i=0 g (i; ~y)] provided that f (x; ~y) k (x; ~y) for all x; ~y. <p> Marcenkov [94], while the second statement to J.P. Jones and Y. Matijasevic [75]. Theorem 3.66 E 3 fl = ([0; I; s; . ; bx=yc; x y ; comp]) fl = ([0; I; +; . ; bx=yc; x!; 2 x ; comp]) fl : In <ref> [40] </ref>, R. Constable defined the class K by [0; I; s; +; . ; fi; bx=yc; comp; sbsum; sbprod] a polynomial analogue of the definition of Kalmar elementary functions. The class K (f ) is defined as above, but with f as an additional initial function. <p> Let F P (f ) denote the collection of functions polynomial time computable in f (F P (f ) can equivalently be defined as the set of type 1 functions in BF F (f ); see Definition 4.6). On p. 118 of <ref> [40] </ref>, the following claim is stated as a theorem without proof. 19 Sharply bounded summation [resp. product] is called weak sum [resp. product in [139], and bounded summation [resp. product] is called limited sum [resp. product in [57]. 39 Claim 3.67 For all non-decreasing f , K (f ) = F <p> The statement F ptime = K was then claimed as a corollary in <ref> [40] </ref>. This statement was again cited as a theorem (without proof) in [139]. It now appears that this assertion is doubtful, since K N C and it is currently conjectured that N C is properly contained in F ptime. <p> Upon entering the oracle query state, there seem to be two natural measures for the time to complete the function query f (x). The unit cost, considered by Mehlhorn [95], charges unit time, while the function length cost, considered by Constable <ref> [40] </ref> and later Kapron and Cook [79], charges maxf1; jf (x)jg time.
Reference: [41] <author> S. Cook. </author> <title> Computability and complexity of higher type functions. </title> <editor> In Y.N. Moschovakis, editor, </editor> <booktitle> Logic from Computer Science, </booktitle> <pages> pages 51-72. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: For 27 Polymorphism allows function and procedures to abstract over data types | e.g. a generic sorting algorithm for any data type having a comparison function. 52 reasons of space, only a few recent directions in higher type functional complexity will be presented. For more information, see the survey <ref> [41] </ref> by S.A. Cook and the volume edited by D. Leivant [91] (higher type complexity theory) and the articles by D. Norman and H. Schwichtenberg in this volume (higher type recursion theory). <p> Define the rank (1; 0) functional L by L (f ) = i [(9j &lt; i)(f (j) f (i))]. Note that defines a well quasi-ordering on N fi N, so L is well defined. Theorem 4.9 (S. Cook <ref> [41] </ref>) The functional L belongs to opt yet not to bff. S. Cook [41] points out that the type-1 section of the closure of opt with L is just the type-1 section of opt, i.e. the class of polynomial time computable functions, and so L should be considered a feasible functional. <p> Note that defines a well quasi-ordering on N fi N, so L is well defined. Theorem 4.9 (S. Cook <ref> [41] </ref>) The functional L belongs to opt yet not to bff. S. Cook [41] points out that the type-1 section of the closure of opt with L is just the type-1 section of opt, i.e. the class of polynomial time computable functions, and so L should be considered a feasible functional. <p> Higher type functional complexity theory is an emerging field. For reasons of space, only references to a few recent papers will be given. In [83], Ker-I Ko surveyed the theory of sequential complexity theory of real valued functions. In [71], H.J. Hoover investigated parallel computable real valued functions. In <ref> [41] </ref>, S. Cook gave a survey of higher type computational approaches, and proved Theorem 4.9. Cook further proposed that any class C of feasible type 2 functionals must satisfy the following two conditions: 1. bff C opt, 2. C is closed under abstraction and application. In [122] A.
Reference: [42] <author> S. A. Cook. </author> <title> The complexity of theorem proving procedures. </title> <booktitle> In 3rd Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1971. </year> <pages> pp. 151-158. 65 </pages>
Reference-contexts: New kinds of operations used in defining function algebras could possibly be incorporated in small, non-universal programming languages for dedicated purposes. All the function algebras defined in this paper could be used to define free variable equational calculi. For instance, S. Cook's system P V <ref> [42] </ref> comes from Theorem 3.19, the author's systems AV , ALV , ALV 0 [28, 30] come from Theorems 3.26 and 3.27, J. Johannsen's [74] systems T V; A2V come from Theorem 3.16, while M. O'Donnell [104] has proposed equational calculus as a programming language.
Reference: [43] <author> S.A. Cook and B.M. Kapron. </author> <title> Characterizations of the feasible functionals of finite type. </title> <editor> In P.J. Scott S.R. Buss, editor, </editor> <booktitle> Feasible Mathematics, </booktitle> <pages> pages 71-98. </pages> <publisher> Birkhauser, </publisher> <year> 1990. </year>
Reference-contexts: Allen [3] in 1991, while certain small boolean circuit complexity classes were treated by the author and G. Takeuti [36] in 1995. Higher type analogues of certain characterizations were given in 1976 by K. Mehlhorn [95], in 1991 by S. Cook and B. Kapron <ref> [79, 43] </ref> for sequential computation, and in 1993 by the author, A. Ignjatovic, B. Kapron [33] for parallel computation. In 1995 H. Vollmer and K. Wagner [137] Valiant's class #P . <p> Definition 4.6 (Townsend [133], Kapron, Cook <ref> [43] </ref>) Let X be a class of type 2 functionals. <p> Their system P V ! provided a natural class of polynomial time higher type functionals (called the basic feasible functionals of higher type), whose type-2 section of P V ! is bff. In [66], V. Harnik extended Cook-Urquhart's func-tionals to levels of the polynomial time hierarchy. In <ref> [43] </ref> S. Cook and B. Kapron characterized the higher type functionals in P V ! by certain kinds of programming language constructs, typed while programs and bounded loop programs. This kind of characterization was extended by P. Clote, B. Kapron and A.
Reference: [44] <author> S.A. Cook and A. Urquhart. </author> <title> Functional interpretations of feasibly constructive arithmetic. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 63(2):pp. </volume> <pages> 103-200, </pages> <year> 1993. </year>
Reference-contexts: In [51], J.-Y. Girard, A. Scedrov and P. Scott introduced bounded linear logic, and proved a normalization theorem which yielded a characterization of a feasible class of type 2 functionals, whose type 1 section is the class of polytime computable functions. In <ref> [44] </ref>, S. Cook and A. Urquhart introduced an analogue of Godel's system T by admitting a recursor for bounded recursion on notation for type 1 objects.
Reference: [45] <author> P. Csillag. </author> <title> Eine Bemerkung zur Auflosung der eingeschachtelten Rekursion. </title> <journal> Acta Sci. Math. Szeged., </journal> <volume> 11 </volume> <pages> 169-173, </pages> <year> 1947. </year>
Reference-contexts: is defined by sharply bounded summation (sbsum) [resp. sharply bounded product (sbprod)] from g; k if f (x; ~y) equals i=0 g (i; ~y) [resp. jxj provided that f (x; ~y) k (x; ~y) for all x; ~y. 19 The elementary functions were first introduced by Kalmar [77] and Csillag <ref> [45] </ref>. Definition 3.64 The class E of elementary functions is the algebra [0; I; s; +; . ; comp; bsum; bprod]: The elementary functions have many alternate characterizations, among them that E = E 3 .
Reference: [46] <author> D. Deutsch. </author> <title> Quantum theory, the Church-Turing principle and the universal quantum computer. </title> <journal> Proc. R. Soc. Lond., </journal> <pages> pages 73-90, </pages> <year> 1985. </year> <note> Vol. A 400. </note>
Reference-contexts: Pudlak [110], who showed that polynomial time bounded genetic tm's compute exactly pspace), and the quantum Turing machine (first introduced by D. Deutsch <ref> [46] </ref>, and for which P. Shor [126] recently proved that integer factorization is computable in bounded error probabilistic quantum polynomial time bqp). 2.2 Parallel machine model "Having one processor per data element changes the way one thinks." W.D. Hillis and G.L.
Reference: [47] <author> R. Fagin. </author> <title> Generalized first-order spectra and polynomial-time recognizable sets. </title> <editor> In R. M. Karp, editor, </editor> <booktitle> Complexity of Computation, SIAM-AMS Proceedings, </booktitle> <volume> Vol. 7, </volume> <pages> pages 43-73, </pages> <year> 1974. </year>
Reference-contexts: Ignjatovic, B. Kapron [33] for parallel computation. In 1995 H. Vollmer and K. Wagner [137] Valiant's class #P . Though distinct, the arithmetization techniques of function algebras are related to those used in proving numerous results like (i) np equals generalized first order spectra (R. Fagin <ref> [47] </ref>), (ii) the characterization of complexity classes via finite models (the program of descriptive complexity theory investigated by R. Fagin [48], N. Immerman [72, 73], Y. Gurevich and S. Shelah [59], and others).
Reference: [48] <author> R. Fagin. </author> <title> Finite-model theory|a personal perspective. </title> <editor> In S. Abiteboul and P. Kanel-lakis, editors, </editor> <booktitle> Proc. 1990 International Conference on Database Theory, </booktitle> <pages> pages 3-24. </pages> <note> Springer-Verlag Lecture Notes in Computer Science 470, 1990. Journal version to appear in Theoretical Computer Science. </note>
Reference-contexts: Though distinct, the arithmetization techniques of function algebras are related to those used in proving numerous results like (i) np equals generalized first order spectra (R. Fagin [47]), (ii) the characterization of complexity classes via finite models (the program of descriptive complexity theory investigated by R. Fagin <ref> [48] </ref>, N. Immerman [72, 73], Y. Gurevich and S. Shelah [59], and others). From this short historical overview, it clearly emerges that function algebras and computation models are intimately related as the software (class of programs) and hardware (machine model) counterparts of each other.
Reference: [49] <author> S. Fortune and J. Wyllie. </author> <title> Parallelism in random access machines. </title> <booktitle> In 10th Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1978. </year> <pages> pp. 114-118. </pages>
Reference-contexts: Hillis and G.L. Steele, Jr. [70] Emerging around 1976-77 from the work of Goldschlager [55, 56], Fortune-Wyllie <ref> [49] </ref>, and Shiloach-Vishkin [125], the parallel random access machine (pram) provides an abstract model of parallel computation for algorithm development.
Reference: [50] <author> M. Furst, J. B. Saxe, and M. Sipser. </author> <title> Parity circuits and the polynomial time hierarchy. </title> <journal> Mathematical Systems Theory, </journal> <volume> 17 </volume> <pages> 13-27, </pages> <year> 1984. </year> <booktitle> Preliminary version in Proceedings of the 22nd IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1981. </year>
Reference-contexts: O (n), resp. n O (1) ] with at most O (1) alternations. 5 4 Divide and conquer algorithms are generally space efficient. The parallel computation thesis states that sequential space equals parallel time (see [17]). In this sense, atm's provide a parallel computation model. 5 It follows from <ref> [50, 2] </ref> that lh is a hierarchy, where the collection of languages accepted by k-alternations is properly contained in the collection of languages accepted by k + 1-alternations. <p> (f (n)) nspace (f (n)) [ c&gt;0 atime (c f (n) 2 ): For f (n) log n, aspace (f (n)) [ c&gt;0 dtime (c f (n) ): From definitions, it is clear that lh alogtime logspace ptime ph pspace and lh lth alintime dlinspace pspace: By Furst, Saxe, Sipser <ref> [50] </ref> and Ajtai [2], integer multiplication does not belong to lh (since multiplication fi is a function, what is meant is that fi 62 flh, where 10 the latter is the class of functions of linear growth rate, whose bitgraph belongs to lh; this is defined later). <p> It follows that F lh A 0 . In Furst et al. <ref> [50] </ref>, integer multiplication was shown to be ac 0 reducible to maj, where maj (x) is 1 if P i&lt;jxj bit (i; x) djxj=2e, else 0. In Chandra et al. [25] as refined by Barrington et al. [6], maj was shown to be ac 0 reducible to integer multiplication.
Reference: [51] <author> J.-Y. Girard, A. Scedrov, and P. Scott. </author> <title> Bounded linear logic. </title> <editor> In P.J. Scott S.R. Buss, editor, </editor> <booktitle> Feasible Mathematics, </booktitle> <pages> pages 195-210. </pages> <publisher> Birkhauser, </publisher> <year> 1990. </year>
Reference-contexts: Buss, who in [19] introduced a polynomial time analogue of the hereditarily recursive operations hro to define polynomial time functionals of all finite types decorated with runtime bounds. A. Nerode, J. Remmel and A. Scedrov [101] studied a polynomially graded type system. In <ref> [51] </ref>, J.-Y. Girard, A. Scedrov and P. Scott introduced bounded linear logic, and proved a normalization theorem which yielded a characterization of a feasible class of type 2 functionals, whose type 1 section is the class of polytime computable functions. In [44], S. Cook and A.
Reference: [52] <author> K. </author> <title> Godel. Uber formal unentscheidbare Satze der Principia Mathematica und ver-wandter Systeme. </title> <journal> J. Monat. Math. Phys., </journal> <volume> 38:173 - 198, </volume> <year> 1931. </year>
Reference-contexts: Hilbert [69] defined classes of higher type functionals by recursion. In 1928, W. Ack-ermann [1] furnished a proof that the diagonal function ' a (a; a) of Hilbert [69], a variant of the Ackermann function, is not primitive recursive. In 1931, K. Godel <ref> [52] </ref> defined the primitive recursive functions, there calling them "rekursive Funk-tionen", and used them to arithmetize logical syntax via Godel numbers for his incompleteness theorem. Generalizing Ackermann's work, in 1936 R. Peter [108] defined and studied the k-fold recursive functions. <p> The proof relies on arithmetizing computations via Godel numbers, a technique introduced in <ref> [52] </ref> by Godel, and with which Turing computable functions can be shown equivalent to -recursive functions. Since then, there have been a number of arithmetizations of machine models [81, 82, 13, 39, 111, 132, 138, 38, 36], etc.
Reference: [53] <author> K. </author> <title> Godel. Conversation with G.E. </title> <type> Sacks. </type> <institution> Institute for Advanced Study, </institution> <year> 1975. </year>
Reference-contexts: Historically, these notions are among the central concepts of recursion theory, proof theory and theoretical computer science. Perhaps this is the reason that K. Godel <ref> [53] </ref> claimed in 1975 that the most important open problem in recursion theory is the classification of all total recursive functions, presumably in a hierarchy of function algebras determined by admitting more and more complex operations. While much work characterizing ever larger subrecursive hierarchies has been done by W.
Reference: [54] <author> A. Goerdt. </author> <title> Characterizing complexity classes by general recursive definitions in higher types. </title> <journal> Information and Computation, </journal> <volume> 101(2) </volume> <pages> 202-218, </pages> <year> 1992. </year>
Reference-contexts: Another direction of finite model theory is the investigation of function algebras, as interpreted over finite structures, rather than over N. Here Y. Gurevich [58] showed that logspace "global" functions can be characterized by primitive recursion over finite structures. In <ref> [54] </ref> A.
Reference: [55] <author> L. Goldschlager. </author> <title> Synchronous parallel computation. </title> <type> Technical Report 114, </type> <institution> University of Toronto, </institution> <month> December </month> <year> 1977. </year> <pages> 131 pages. </pages>
Reference-contexts: Shor [126] recently proved that integer factorization is computable in bounded error probabilistic quantum polynomial time bqp). 2.2 Parallel machine model "Having one processor per data element changes the way one thinks." W.D. Hillis and G.L. Steele, Jr. [70] Emerging around 1976-77 from the work of Goldschlager <ref> [55, 56] </ref>, Fortune-Wyllie [49], and Shiloach-Vishkin [125], the parallel random access machine (pram) provides an abstract model of parallel computation for algorithm development.
Reference: [56] <author> L. Goldschlager. </author> <title> A unified approach to models of synchronous parallel machines. </title> <journal> Journal of the Association of Computing Machinery, </journal> <volume> 29(4):pp. </volume> <pages> 1073-1086, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: Shor [126] recently proved that integer factorization is computable in bounded error probabilistic quantum polynomial time bqp). 2.2 Parallel machine model "Having one processor per data element changes the way one thinks." W.D. Hillis and G.L. Steele, Jr. [70] Emerging around 1976-77 from the work of Goldschlager <ref> [55, 56] </ref>, Fortune-Wyllie [49], and Shiloach-Vishkin [125], the parallel random access machine (pram) provides an abstract model of parallel computation for algorithm development.
Reference: [57] <author> A. Grzegorczyk. </author> <title> Some clases of recursive functions. </title> <journal> Rozprawy Matematyczne, </journal> <volume> 4, </volume> <year> 1953. </year>
Reference-contexts: Turing [134]), -calculus (A. Church [26]) and -recursive functions (S.C. Kleene [81]). By restricting the scheme of primitive recursion to allow only limited summations and limited products, the elementary functions were introduced in 1943 by L. Kalmar [77]. In 1953, A. Grzegorczyk <ref> [57] </ref> studied the classes E k obtained by closing certain fast growing "diagonal" functions under composition and bounded primitive recursion or bounded minimization. H. <p> That is, we write nc in place of Fnc, etc. NC is an acronym for "Nick's Class", as this class was first studied by N. Pippenger. AC k was studied by W.L. Ruzzo, using the alternating Turing machine model. 9 In <ref> [57] </ref>, Grzegorczyk defined F fl as the collection of predicates P for which there is a function f 2 F satisfying P (~x) () f (~x) = 0. <p> Using such techniques, two characterizations of nc k were given in [38, 36]. Levels of a natural time-space hierarchy between Fptime and F pspace were characterized in [29]. 3.3 Bounded recursion In 1953, A. Grzegorczyk <ref> [57] </ref> investigated a hierarchy of subclasses E n of primitive recursive functions, defined as the closure of certain initial functions under composition and bounded recursion. <p> Remark 3.30 For n 3, Grzegorczyk's <ref> [57] </ref> original functions were defined by f n+1 (0; y) = f n (y + 1; y + 1), and f n+1 (x + 1; y) = f n+1 (x; f n+1 (x; y)). <p> Schwichtenberg [120] for n 3 and to H. Muller [99] for n = 2. 14 Theorem 3.31 (Schwichtenberg [120], Muller [99]) Let H n be the set ff : f primitive recursive, rk pr (f ) ng: Then for n 2, H n = E n+1 . In <ref> [57] </ref> Grzegorczyk proved that for all n 0, E n is properly contained in E n+1 by demonstrating that f n+1 62 E n . <p> The papers of Paris, Wilkie [107] and Handley, Paris, Wilkie [62] study counting classes between lth and linspace defined by stack register machines. Recent work of the author [31] and of W. Handley [64, 63] further study the effect of nondeterminism for this model. Lemma 3.33 (Grzegorczyk <ref> [57] </ref>) The functions x . y, sg (x), sg (x), sg (x)y, sg (x) y belong to E 0 . <p> Corollary 3.35 (Grzegorczyk <ref> [57] </ref>) For n 0, E n fl is closed under boolean connec-tives and bounded quantification, and E n is closed under bounded minimization. Proof. <p> Their algebra, defined over words from a finite alphabet, is the closure under composition of certain initial functions and weak iterates f (jxj) (x) of certain string manipulating initial functions. 3.4 Bounded minimization In <ref> [57] </ref>, Grzegorczyk considered function classes defined by bounded minimization, defined in Definition 3.34. Definition 3.47 For n 0, define M n = [0; I; s; f n ; comp; bmin]. 16 16 In [114], following work of K. <p> For this reason, exponentiation is not included in our definition of M n . 34 Though implicitly asserted in <ref> [57] </ref>, the details for the proof of the following result, which follow those in the proof of Theorem 3.65, are given by K. Harrow [68]. 17 The idea of the proof is simply to encode via sequence numbers a definition by bounded primitive recursion and apply the bounded minimization operator. <p> Harrow [68]. 17 The idea of the proof is simply to encode via sequence numbers a definition by bounded primitive recursion and apply the bounded minimization operator. Theorem 3.48 (Grzegorczyk <ref> [57] </ref>, Harrow [68]) For n 3, E n = M n . In the literature, the algebra rf of rudimentary functions is sometimes defined by rf = [0; I; s; +; fi; comp; bmin]: As noticed in [68], it follows from J. <p> Bellantoni [10]) For i 0, 2 P i = F P i . 3.5 Divide and conquer, course-of-values and miscellaneous Definition 3.63 (Grzegorczyk <ref> [57] </ref>, Constable [40]) The function f is defined by bounded summation (bsum) [resp. bounded product (bprod)] from g; k if f (x; ~y) equals x i=0 g (i; ~y) [resp. x i=0 g (i; ~y)] provided that f (x; ~y) k (x; ~y) for all x; ~y. <p> Definition 3.64 The class E of elementary functions is the algebra [0; I; s; +; . ; comp; bsum; bprod]: The elementary functions have many alternate characterizations, among them that E = E 3 . Theorem 3.65 (Grzegorczyk <ref> [57] </ref>) E = [0; I; s; f 3 ; comp; br] = [0; I; s; . ; x y ; comp; bmin] = [0; I; s; . ; fi; x y ; comp; bsum]: Grzegorczyk asked whether E had a finite basis, i.e. a finite number of functions, whose closure with <p> On p. 118 of [40], the following claim is stated as a theorem without proof. 19 Sharply bounded summation [resp. product] is called weak sum [resp. product in [139], and bounded summation [resp. product] is called limited sum [resp. product in <ref> [57] </ref>. 39 Claim 3.67 For all non-decreasing f , K (f ) = F P (f ). The statement F ptime = K was then claimed as a corollary in [40]. This statement was again cited as a theorem (without proof) in [139].
Reference: [58] <author> Y. Gurevich. </author> <title> Algebras of feasible functions. </title> <booktitle> In Proceedings of 24th IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1983. </year> <pages> pp. 210-214. </pages>
Reference-contexts: Another direction of finite model theory is the investigation of function algebras, as interpreted over finite structures, rather than over N. Here Y. Gurevich <ref> [58] </ref> showed that logspace "global" functions can be characterized by primitive recursion over finite structures. In [54] A.
Reference: [59] <author> Y. Gurevich and S. Shelah. </author> <title> Fixed-point extensions of first-order logic. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 32 </volume> <pages> 265-280, </pages> <year> 1986. </year>
Reference-contexts: Fagin [47]), (ii) the characterization of complexity classes via finite models (the program of descriptive complexity theory investigated by R. Fagin [48], N. Immerman [72, 73], Y. Gurevich and S. Shelah <ref> [59] </ref>, and others). From this short historical overview, it clearly emerges that function algebras and computation models are intimately related as the software (class of programs) and hardware (machine model) counterparts of each other.
Reference: [60] <author> Y. Gurevich and S. Shelah. </author> <title> Nearly linear time. </title> <booktitle> Symposium on Logical Foundations of Computer Science, Springer Lecture Notes in Computer Science(363):108-118, 1989. Pereslavl-Zalessky, </booktitle> <address> USSR. </address>
Reference-contexts: Schnorr in [118]. In analogy, let quasilinear space be the class dspace (n (log n) O (1) ). Though Corollary 3.43 characterizes quasilinear space via a function algebra, there appears to be no known function algebra for quasilinear time. In <ref> [60] </ref>, Y. Gurevich and S. Shelah studied the class nlt (nearly linear time) of functions computable in time O (n (log n) O (1) ) on a random access Turing machine rtm, which is allowed to change its input tape. Definition 3.46 (Gurevich-Shelah [60]) A rtm is a Turing machine with <p> In <ref> [60] </ref>, Y. Gurevich and S. Shelah studied the class nlt (nearly linear time) of functions computable in time O (n (log n) O (1) ) on a random access Turing machine rtm, which is allowed to change its input tape. Definition 3.46 (Gurevich-Shelah [60]) A rtm is a Turing machine with one-way infinite main tape, address tape and auxiliary tape, such that the head of the main tape is at all times in the cell whose position is given by the contents of the address tape. <p> In <ref> [60] </ref>, Gurevich and Shelah show the robustness of nlt by proving the equivalence of this class with respect to different machine models, and give a function algebra for nlt.
Reference: [61] <author> P. Hajek and P. Pudlak. </author> <title> Metamathematics of first order arithmetic. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The main lines of this proof were influenced by Wilkie's presentation in [140]. See <ref> [61] </ref> for other proofs. Corollary 3.54 The function algebra [0; I; s 0 ; s 1 ; jxj; bit; comp; crn] is contained in M 2 . Proof.
Reference: [62] <author> W. Handley, J. B. Paris, and A. J. Wilkie. </author> <title> Characterizing some low arithmetic classes. </title> <booktitle> In Theory of Algorithms, </booktitle> <pages> pages 353 - 364. </pages> <address> Akademie Kyado, Budapest, </address> <year> 1984. </year> <note> Colloquia Societatis Janos Bolyai. </note>
Reference-contexts: The characterization of polynomial size, constant depth boolean circuits with parity gates (resp. mod6 gates) uses sequence encoding techniques of A 0 together with logtime hierarchy analogues of work of Handley, Paris, Wilkie <ref> [62] </ref>. <p> A program is a finite list of instructions, where for each i there is at most one incremental instruction for S i . Apart from characterizing E 2 fl or linspace, Bel'tyukov characterized the linear time hierarchy lth. The papers of Paris, Wilkie [107] and Handley, Paris, Wilkie <ref> [62] </ref> study counting classes between lth and linspace defined by stack register machines. Recent work of the author [31] and of W. Handley [64, 63] further study the effect of nondeterminism for this model. <p> While linspace is clearly closed under counting, this may not be the case for lth. A typical open question is whether (x) 2 M 2 , where (x) is the number of primes less than x. In <ref> [107, 62] </ref>, J. Paris, A. Wilkie and later W. Handley studied the effect of adding k-bounded recursion to lth. Using the techniques of Barrington, Paris, Wilkie and Handley, together with those of this paper, the following result can be proved. Theorem 3.59 (P.
Reference: [63] <author> W.G. Handley. </author> <title> LTH plus nondeterministic summation mod M 3 yields ALINTIME. </title> <note> Submitted, </note> <month> 22 December </month> <year> 1994. </year>
Reference-contexts: Apart from characterizing E 2 fl or linspace, Bel'tyukov characterized the linear time hierarchy lth. The papers of Paris, Wilkie [107] and Handley, Paris, Wilkie [62] study counting classes between lth and linspace defined by stack register machines. Recent work of the author [31] and of W. Handley <ref> [64, 63] </ref> further study the effect of nondeterminism for this model. Lemma 3.33 (Grzegorczyk [57]) The functions x . y, sg (x), sg (x), sg (x)y, sg (x) y belong to E 0 .
Reference: [64] <author> W.G. Handley. </author> <title> Deterministic summation modulo B n , the semi-group of binary relations on f0; 1; : : : ; n 1g. </title> <note> Submitted, </note> <month> May </month> <year> 1994. </year> <month> 66 </month>
Reference-contexts: Apart from characterizing E 2 fl or linspace, Bel'tyukov characterized the linear time hierarchy lth. The papers of Paris, Wilkie [107] and Handley, Paris, Wilkie [62] study counting classes between lth and linspace defined by stack register machines. Recent work of the author [31] and of W. Handley <ref> [64, 63] </ref> further study the effect of nondeterminism for this model. Lemma 3.33 (Grzegorczyk [57]) The functions x . y, sg (x), sg (x), sg (x)y, sg (x) y belong to E 0 .
Reference: [65] <author> G.H. Hardy. </author> <title> A theorem concerning the infinite cardinal numbers. </title> <journal> Q.J. Math., </journal> <pages> pages 87-94, </pages> <year> 1904. </year>
Reference-contexts: Kleene's -recursive functions. One recurring theme in recursion theory is that of a function algebra | i.e. a smallest class of functions containing certain initial functions and closed under certain operations (especially substitution and primitive recursion). 1 In 1904, G.H. Hardy <ref> [65] </ref> used related concepts to define sets of real numbers of cardinality @ 1 . In 1923, Th. Skolem [128] introduced the primitive recursive functions, and in 1925, as a technical tool in his claimed sketch proof of the continuum hypothesis, D.
Reference: [66] <author> V. Harnik. </author> <title> Provably total functions of intuitionistic bounded arithmetic. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 57(2) </volume> <pages> 466-477, </pages> <year> 1992. </year>
Reference-contexts: Their system P V ! provided a natural class of polynomial time higher type functionals (called the basic feasible functionals of higher type), whose type-2 section of P V ! is bff. In <ref> [66] </ref>, V. Harnik extended Cook-Urquhart's func-tionals to levels of the polynomial time hierarchy. In [43] S. Cook and B. Kapron characterized the higher type functionals in P V ! by certain kinds of programming language constructs, typed while programs and bounded loop programs.
Reference: [67] <author> K. Harrow. </author> <title> Small Grzegorczyk classes and limited minimum. </title> <journal> Zeit. Math. Logik, </journal> <volume> 21 </volume> <pages> 417-426, </pages> <year> 1975. </year>
Reference-contexts: Definition 3.47 For n 0, define M n = [0; I; s; f n ; comp; bmin]. 16 16 In [114], following work of K. Harrow <ref> [67, 68] </ref>, for n 3, M n is defined to be [0; I; s; x y ; f n ; comp; bmin]. <p> The following theorem is proved by using quantifier elimination for Presburger arithmetic to show the equivalence between first order formulas and bounded formulas in a richer language allowing congruences, and then exploiting the correspondence between bounded quantification and bounded minimization. Theorem 3.51 (Harrow <ref> [67] </ref>) M 1 fl equals the collection of Presburger definable sets . From J. Robinson's definition of addition from successor and multiplication, the following easily follows. Proposition 3.52 (Harrow [67]) M 2 fl = ca and M 2 = Gca. <p> Theorem 3.51 (Harrow <ref> [67] </ref>) M 1 fl equals the collection of Presburger definable sets . From J. Robinson's definition of addition from successor and multiplication, the following easily follows. Proposition 3.52 (Harrow [67]) M 2 fl = ca and M 2 = Gca. While it is obvious that rf fl = ca, it is non-trivial and surprising that ca equals the linear time hierarchy . In [13], J.H.
Reference: [68] <author> K. Harrow. </author> <title> Equivalence of some hierarchies of primitive recursive functions. </title> <journal> Zeit. Math. Logik, </journal> <volume> 25 </volume> <pages> 411-418, </pages> <year> 1979. </year>
Reference-contexts: Definition 3.47 For n 0, define M n = [0; I; s; f n ; comp; bmin]. 16 16 In [114], following work of K. Harrow <ref> [67, 68] </ref>, for n 3, M n is defined to be [0; I; s; x y ; f n ; comp; bmin]. <p> For this reason, exponentiation is not included in our definition of M n . 34 Though implicitly asserted in [57], the details for the proof of the following result, which follow those in the proof of Theorem 3.65, are given by K. Harrow <ref> [68] </ref>. 17 The idea of the proof is simply to encode via sequence numbers a definition by bounded primitive recursion and apply the bounded minimization operator. Theorem 3.48 (Grzegorczyk [57], Harrow [68]) For n 3, E n = M n . <p> Harrow <ref> [68] </ref>. 17 The idea of the proof is simply to encode via sequence numbers a definition by bounded primitive recursion and apply the bounded minimization operator. Theorem 3.48 (Grzegorczyk [57], Harrow [68]) For n 3, E n = M n . In the literature, the algebra rf of rudimentary functions is sometimes defined by rf = [0; I; s; +; fi; comp; bmin]: As noticed in [68], it follows from J. <p> Theorem 3.48 (Grzegorczyk [57], Harrow <ref> [68] </ref>) For n 3, E n = M n . In the literature, the algebra rf of rudimentary functions is sometimes defined by rf = [0; I; s; +; fi; comp; bmin]: As noticed in [68], it follows from J. Robinson's [112] bounded quantifier definition of addition from successor and multiplication that M 2 = rf. As is well-known, there is a close relationship between (bounded) minimization and (bounded) quantification. This is formalized as follows. <p> Later, C. Wrathall [142] proved that the rudimentary sets are exactly those in the linear time hierarchy lth. Theorem 3.53 (J. Bennett [13]) The ternary relation G (x; y; z) for the graph x y = z of exponentiation is in constructive arithmetic. 17 The result is proved in <ref> [68] </ref> for [0; I; s; x y ; f n ; comp; bmin], but as, previously explained, the exponential is unnecessary. 18 In the literature, especially in [107], a function f is defined to be N 0 if its graph G f belongs to N 0 and f is of linear
Reference: [69] <author> D. </author> <title> Hilbert. Uber das Unendliche. </title> <journal> Mathematische Annalen, </journal> <volume> 95 </volume> <pages> 161-190, </pages> <year> 1925. </year>
Reference-contexts: Hardy [65] used related concepts to define sets of real numbers of cardinality @ 1 . In 1923, Th. Skolem [128] introduced the primitive recursive functions, and in 1925, as a technical tool in his claimed sketch proof of the continuum hypothesis, D. Hilbert <ref> [69] </ref> defined classes of higher type functionals by recursion. In 1928, W. Ack-ermann [1] furnished a proof that the diagonal function ' a (a; a) of Hilbert [69], a variant of the Ackermann function, is not primitive recursive. In 1931, K. <p> Hilbert <ref> [69] </ref> defined classes of higher type functionals by recursion. In 1928, W. Ack-ermann [1] furnished a proof that the diagonal function ' a (a; a) of Hilbert [69], a variant of the Ackermann function, is not primitive recursive. In 1931, K. Godel [52] defined the primitive recursive functions, there calling them "rekursive Funk-tionen", and used them to arithmetize logical syntax via Godel numbers for his incompleteness theorem. Generalizing Ackermann's work, in 1936 R. <p> In 1963 R. W. Ritchie [111] proved that Grze-gorczyk's class E 2 is the collection of functions computable in linear space on a Turing machine. In 1965, A. Cobham [39] characterized the polynomial time computable functions as the smallest function algebra closed under Bennett's scheme 1 In <ref> [69] </ref>, Hilbert stated that "substitution (i.e. replacement of an argument by a new variable or function) and recursion (the scheme of deriving the function value for n + 1 from that of n)" are "the elementary operations for the construction of functions". 2 of bounded recursion on notation. 2 These arithmetization <p> In his attempted proof of the continuum hypothesis, D. Hilbert <ref> [69] </ref> studied classes of higher type functionals defined by the operations of composition and primitive recursion. Hilbert's general scheme ([69], p. 186) was of the form F (G; H; 0) = H where F ; G; H are higher type functionals of appropriate types possibly having other parameters not indicated.
Reference: [70] <author> W.D. Hillis and G.L. Steele, Jr. </author> <title> Data parallel algorithms. </title> <journal> Communications of the ACM, </journal> <pages> pages 1170-1183, </pages> <month> December </month> <year> 1986. </year> <pages> 29 (12). </pages>
Reference-contexts: Deutsch [46], and for which P. Shor [126] recently proved that integer factorization is computable in bounded error probabilistic quantum polynomial time bqp). 2.2 Parallel machine model "Having one processor per data element changes the way one thinks." W.D. Hillis and G.L. Steele, Jr. <ref> [70] </ref> Emerging around 1976-77 from the work of Goldschlager [55, 56], Fortune-Wyllie [49], and Shiloach-Vishkin [125], the parallel random access machine (pram) provides an abstract model of parallel computation for algorithm development.
Reference: [71] <author> H.J. </author> <title> Hoover. Computational models for feasible real analysis. In S.R. </title> <editor> Buss and P.J. Scott, editors, </editor> <booktitle> Feasible Mathematics, </booktitle> <pages> pages 221-238. </pages> <publisher> Birkhauser, </publisher> <year> 1990. </year>
Reference-contexts: Higher type functional complexity theory is an emerging field. For reasons of space, only references to a few recent papers will be given. In [83], Ker-I Ko surveyed the theory of sequential complexity theory of real valued functions. In <ref> [71] </ref>, H.J. Hoover investigated parallel computable real valued functions. In [41], S. Cook gave a survey of higher type computational approaches, and proved Theorem 4.9. Cook further proposed that any class C of feasible type 2 functionals must satisfy the following two conditions: 1. bff C opt, 2.
Reference: [72] <author> N. Immerman. </author> <title> Languages that capture complexity classes. </title> <journal> SIAM Journal of Computing, </journal> <volume> 16 </volume> <pages> 760-778, </pages> <year> 1987. </year>
Reference-contexts: Fagin [47]), (ii) the characterization of complexity classes via finite models (the program of descriptive complexity theory investigated by R. Fagin [48], N. Immerman <ref> [72, 73] </ref>, Y. Gurevich and S. Shelah [59], and others). From this short historical overview, it clearly emerges that function algebras and computation models are intimately related as the software (class of programs) and hardware (machine model) counterparts of each other.
Reference: [73] <author> N. Immerman. </author> <title> Expressibility and parallel complexity. </title> <journal> SIAM J. Comput., </journal> <volume> 18(3) </volume> <pages> 625-638, </pages> <year> 1989. </year>
Reference-contexts: Fagin [47]), (ii) the characterization of complexity classes via finite models (the program of descriptive complexity theory investigated by R. Fagin [48], N. Immerman <ref> [72, 73] </ref>, Y. Gurevich and S. Shelah [59], and others). From this short historical overview, it clearly emerges that function algebras and computation models are intimately related as the software (class of programs) and hardware (machine model) counterparts of each other. <p> The shift operators MSP and LSP are defined by * MSP (x; y) = bx=2 y c, provided that y &lt; jxj, otherwise `B', * LSP (x; y) = x 2 y (bx=2 y c), provided that y jxj, otherwise `B'. The cram model is due to N. Immerman <ref> [73] </ref>, though there slightly different conventions are made. Instructions with `fl' concern indirect addressing. The instruction M res = flM op1 assigns to local register M res the contents of local register with address given by the value M op1 . <p> Stockmeyer and U. Vishkin related pram time and processors to boolean circuit depth and size. The logtime-uniform version of that result was proved by N. Immerman <ref> [73] </ref> and follows. Theorem 2.18 For k 0, ac k equals TimeProc (O (log k n); n O (1) ) on a cram.
Reference: [74] <author> J. Johannsen. </author> <title> Schwache Fragmente der Arithmetik und Schwellwertschaltkreise beschrankter Tiefe. </title> <type> PhD thesis, </type> <institution> Universitat Erlangen-Nurnberg, </institution> <month> 13 May </month> <year> 1996. </year>
Reference-contexts: All the function algebras defined in this paper could be used to define free variable equational calculi. For instance, S. Cook's system P V [42] comes from Theorem 3.19, the author's systems AV , ALV , ALV 0 [28, 30] come from Theorems 3.26 and 3.27, J. Johannsen's <ref> [74] </ref> systems T V; A2V come from Theorem 3.16, while M. O'Donnell [104] has proposed equational calculus as a programming language. In this paper, we will survey a selection of results which illustrate the arithme 2 According to [95], K.
Reference: [75] <author> J.P. Jones and Y. Matijasivic. </author> <title> A new representation for the symmetric binomial coefficient and its applications. </title> <journal> Ann. Sc. Math., Quebec, </journal> <volume> 6(1) </volume> <pages> 81-97, </pages> <year> 1982. </year>
Reference-contexts: In the following theorem, the first statement is due to S.S. Marcenkov [94], while the second statement to J.P. Jones and Y. Matijasevic <ref> [75] </ref>. Theorem 3.66 E 3 fl = ([0; I; s; . ; bx=yc; x y ; comp]) fl = ([0; I; +; . ; bx=yc; x!; 2 x ; comp]) fl : In [40], R.
Reference: [76] <author> N.D. Jones and A.L. Selman. </author> <title> Turing machines and the spectra of first-order formulas. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 39 </volume> <pages> 139-150, </pages> <year> 1974. </year>
Reference-contexts: H. Scholz's 1952 [119] question concerning the characterization of spectra fn 2 N : (9 model M of n elements)(M j= OE)g of first order sentences OE, which was shown in 1974 by N. Jones and A. Selman <ref> [76] </ref> to equal ntime (2 O (n) ), was the starting point for J.H. Bennett's work [13] in 1962.
Reference: [77] <editor> L. Kalmar. Egyszeru pelda eldonthetetlen aritmetikai problemara. Mate es Fizikai Lapok, </editor> <volume> 50 </volume> <pages> 1-23, </pages> <year> 1943. </year> <title> [In Hungarian with German abstract]. </title>
Reference-contexts: Turing [134]), -calculus (A. Church [26]) and -recursive functions (S.C. Kleene [81]). By restricting the scheme of primitive recursion to allow only limited summations and limited products, the elementary functions were introduced in 1943 by L. Kalmar <ref> [77] </ref>. In 1953, A. Grzegorczyk [57] studied the classes E k obtained by closing certain fast growing "diagonal" functions under composition and bounded primitive recursion or bounded minimization. H. <p> The function f is defined by sharply bounded summation (sbsum) [resp. sharply bounded product (sbprod)] from g; k if f (x; ~y) equals i=0 g (i; ~y) [resp. jxj provided that f (x; ~y) k (x; ~y) for all x; ~y. 19 The elementary functions were first introduced by Kalmar <ref> [77] </ref> and Csillag [45]. Definition 3.64 The class E of elementary functions is the algebra [0; I; s; +; . ; comp; bsum; bprod]: The elementary functions have many alternate characterizations, among them that E = E 3 .
Reference: [78] <author> R. Kannan. </author> <title> Towards separating nondeterministic time from deterministic time. </title> <booktitle> In Proceedings of 22nd IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1981. </year> <pages> 235-243. </pages>
Reference-contexts: Woods' presentation in [141], and simplifies the argument of [6] by using Lemma 3.13 and Lemma 3.14, both of which were generalized from Lemma 3.55. Lemma 3.55 was first proved by Nepomnjascii [100] (a related result proved by Bennett [13]), though R. Kannan <ref> [78] </ref> later rediscovered this result.
Reference: [79] <author> B. Kapron and S. Cook. </author> <title> A new characterization of Mehlhorn's poly time function-als. </title> <booktitle> In Proceedings of IEEE 32th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages pp. 342-347, </pages> <year> 1991. </year> <note> to appear in SIAM J. on Comput. </note>
Reference-contexts: Allen [3] in 1991, while certain small boolean circuit complexity classes were treated by the author and G. Takeuti [36] in 1995. Higher type analogues of certain characterizations were given in 1976 by K. Mehlhorn [95], in 1991 by S. Cook and B. Kapron <ref> [79, 43] </ref> for sequential computation, and in 1993 by the author, A. Ignjatovic, B. Kapron [33] for parallel computation. In 1995 H. Vollmer and K. Wagner [137] Valiant's class #P . <p> For instance, the following is straightforward to establish. Proposition 3.81 (Kapron-Cook <ref> [79] </ref>) The Cobham algebra [0; I; s 0 ; s 1 ; #; comp; brn] is closed under simultaneous bounded recursion on notation. Proof. For notational simplicity, suppose that n = 2. <p> It follows that any function of the algebra G is computable in exponential time. A more powerful version of simultaneous recursion was introduced in <ref> [79] </ref>. <p> Theorem 3.86 (Kapron-Cook <ref> [79] </ref>) The Cobham algebra [0; I; s 0 ; s 1 ; #; comp; brn] is closed under multiple bounded recursion on notation. 3.6 Safe recursion All the function algebras from the previous subsection are defined from specific initial functions, using some version of bounded recursion. <p> Upon entering the oracle query state, there seem to be two natural measures for the time to complete the function query f (x). The unit cost, considered by Mehlhorn [95], charges unit time, while the function length cost, considered by Constable [40] and later Kapron and Cook <ref> [79] </ref>, charges maxf1; jf (x)jg time. <p> S. Bellantoni (private correspondence) has raised the question whether the class obtained by omitting jxj is equivalent to bff. In <ref> [79] </ref>, Kapron and Cook lift Cobham's characterization of polynomial time computable functions to functionals of level 2. To state their result, the notion of length of a function and that of second order polynomial must be introduced. <p> The preceding fact is clear, since in (i) M on inputs f; x makes identical moves as M on f Q ; x, and in (ii) if Q = Q 0 , then apply (i) with Q 0 in place of Q. Theorem 4.12 (B. Kapron and S. Cook <ref> [79] </ref>) bff is the collection of function-als F (f 1 ; : : : ; f n ; x 1 ; : : : ; x m ) computable in time P (jf 1 j; : : : ; jf n j; jx 1 j; : : : ; jx m
Reference: [80] <author> R.M. Karp and V. Ramachandran. </author> <title> Parallel algorithms for shared-memory machines. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume A, </booktitle> <pages> pages 871-942. </pages> <publisher> Elsevier, MIT Press, </publisher> <address> 1990. </address> <publisher> Elsevier (Amsterdam), MIT Press (Cam-bridge). </publisher>
Reference-contexts: This yields erew, crew, and crcw models, according to whether exclusive read, exclusive write, concurrent read or concurrent write are allowed. An excellent survey of parallel algorithms and models is R.M. Karp and V. Ramachandran <ref> [80] </ref>. The formal development follows. A concurrent random access machine cram has a sequence R 0 ; R 1 ; : : : of random access machines which operate in a synchronous fashion in parallel.
Reference: [81] <author> S.C. Kleene. </author> <title> General recursive functions of natural numbers. </title> <journal> Math. Ann., </journal> <volume> 112 </volume> <pages> 727-742, </pages> <year> 1936. </year>
Reference-contexts: Generalizing Ackermann's work, in 1936 R. Peter [108] defined and studied the k-fold recursive functions. The same year saw the introduction of the fundamental concepts of Turing machine (A.M. Turing [134]), -calculus (A. Church [26]) and -recursive functions (S.C. Kleene <ref> [81] </ref>). By restricting the scheme of primitive recursion to allow only limited summations and limited products, the elementary functions were introduced in 1943 by L. Kalmar [77]. In 1953, A. <p> For more information on circuits, see the excellent survey article by R. Boppana and M. Sipser [16]. From this point on, we will assume that all language and function complexity classes are over the alphabet f0; 1g. 3 Some recursion schemes Kleene's normal form theorem <ref> [81] </ref> states that for each recursive (partial) function f there is an index e for which f (~x) = U (y [T (e; ~x; y) = 0]), where T; U are primitive recursive. <p> The proof relies on arithmetizing computations via Godel numbers, a technique introduced in [52] by Godel, and with which Turing computable functions can be shown equivalent to -recursive functions. Since then, there have been a number of arithmetizations of machine models <ref> [81, 82, 13, 39, 111, 132, 138, 38, 36] </ref>, etc.
Reference: [82] <author> S.C. </author> <title> Kleene. </title> <journal> Lambda-definability and recursiveness. Duke Mathematical Journal, </journal> <volume> 2 </volume> <pages> 340-353, </pages> <year> 1936. </year>
Reference-contexts: The proof relies on arithmetizing computations via Godel numbers, a technique introduced in [52] by Godel, and with which Turing computable functions can be shown equivalent to -recursive functions. Since then, there have been a number of arithmetizations of machine models <ref> [81, 82, 13, 39, 111, 132, 138, 38, 36] </ref>, etc.
Reference: [83] <author> Ker-I Ko. </author> <title> Applying techniques of discrete complexity theory to numerical computation. </title> <editor> In R.V. Book, editor, </editor> <booktitle> Studies in Complexity Theory, </booktitle> <pages> pages 1-62. </pages> <publisher> John Wiley and Sons, Inc, </publisher> <year> 1986. </year>
Reference-contexts: Higher type functional complexity theory is an emerging field. For reasons of space, only references to a few recent papers will be given. In <ref> [83] </ref>, Ker-I Ko surveyed the theory of sequential complexity theory of real valued functions. In [71], H.J. Hoover investigated parallel computable real valued functions. In [41], S. Cook gave a survey of higher type computational approaches, and proved Theorem 4.9.
Reference: [84] <author> J. Krajicek. </author> <title> Bounded Arithmetic, Propositional Logic, and Complexity Theory. </title> <publisher> Cam-bridge University Press, </publisher> <year> 1995. </year>
Reference-contexts: Takeuti provided a simpler proof of the existence of an alternating logtime algorithm for the boolean formula evaluation problem, a result first proved by S. Buss [20, 22] (see Theorem 2.11). For a further discussion of such applications, see the recent monograph by J. Krajicek <ref> [84] </ref>. Historically, Cobham's machine independent characterization of the polynomial time computable functions was the start of modern complexity theory, indicating a robust and mathematically interesting field.
Reference: [85] <author> G. Kreisel, D. Lacombe, and J.R. Shoenfield. </author> <title> Partial recursive functionals and effective operations. </title> <editor> In A. Heyting, editor, </editor> <booktitle> Constructivity in Mathematics: Proceedings of a colloquium held in Amsterdam, </booktitle> <pages> pages 195-207. </pages> <publisher> North Holland, </publisher> <year> 1957. </year>
Reference-contexts: In [123] Seth further investigated closure conditions for feasible functionals. In [115], J. Royer studied a polynomial time counterpart to the Kreisel-Lacombe-Shoenfield theorem <ref> [85] </ref>. Complexity theory for functionals of all finite types was initiated by S. Buss, who in [19] introduced a polynomial time analogue of the hereditarily recursive operations hro to define polynomial time functionals of all finite types decorated with runtime bounds. A. Nerode, J. Remmel and A.
Reference: [86] <author> M. Kuty lowski. </author> <title> Finite automata, real time processes and counting problems in bounded arithmetics. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 53(1) </volume> <pages> 243-258, </pages> <year> 1988. </year>
Reference-contexts: The next theorem follows from the author's work in [31] and is based on Barrington's trick. Theorem 3.73 (P. Clote [31]) For n 4, (R n ) fl = (R n+1 ) fl = alintime: In <ref> [86] </ref>, Kuty lowski considered oracle versions of the Paris-Wilkie work. 20 In the notation of [137], the characterization reads #P = fi [+; . ; fi; :] Sub, WProd fl , and fi fl WProd,Sum . This formulation is equivalent to that given in Theorem 3.70. 40 Definition 3.74 (M. <p> This formulation is equivalent to that given in Theorem 3.70. 40 Definition 3.74 (M. Kuty lowski <ref> [86] </ref>) f is a k-function 21 if for all x 1 ; : : : ; x n f (x 1 ; ; x n ) = f (min (x 1 ; k); ; min (x n ; k)) k: For a family F of functions, W k (F) is the <p> Theorem 3.75 (M. Kuty lowski <ref> [86] </ref>) For every class F of functions, W 2 (F) fl = W 3 (F ) fl . For every k 3, there exists a family F of functions, such that W k (F) fl ae W k+1 (F) fl . <p> Takeuti [35]. In [109] F. Pitt considered a variant of B. Allen's polynomial bounded branching recursion, where the function value is bounded by a constant. 21 What is here called a k-function is called a k + 1-function in <ref> [86] </ref>. As our definition of k-bounded recursion corresponds to Kuty lowski's definition of k + 1-bounded recursion, the indices of W k (F) and CW k (F) differ by 1 from [86]. 22 Here, we use the earlier defined sequence numbers, though Allen [3] uses a different sequence encoding technique. 41 <p> is bounded by a constant. 21 What is here called a k-function is called a k + 1-function in <ref> [86] </ref>. As our definition of k-bounded recursion corresponds to Kuty lowski's definition of k + 1-bounded recursion, the indices of W k (F) and CW k (F) differ by 1 from [86]. 22 Here, we use the earlier defined sequence numbers, though Allen [3] uses a different sequence encoding technique. 41 Definition 3.78 (F.
Reference: [87] <author> D. Leivant. </author> <title> Stratified polymorphism. </title> <booktitle> In Proceedings of IEEE 4th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 39-47, </pages> <year> 1989. </year> <note> Journal version: Finitely stratified polymorphism, Information and Computation 93 (1991) 93-113. 67 </note>
Reference-contexts: Takeuti [34] (k sorted variables used in defining k-fold multiple exponential time), but most especially in H. Simmons [127] (control variables, i.e. those used for recursion, are distinguished from usual variables; by separating their function, one prevents diagonalization as in the Ackermann function) and in D. Leivant <ref> [87, 88, 89, 90] </ref> (stratified polymorphism, second order system L 2 (QF + ) corresponding to polynomial time computable functions, stratified functional programs, ramified recurrence over 2 tiered word algebras corresponding to polynomial time). Of these, [127] and [88] are the most related to the Bellantoni-Cook work described below.
Reference: [88] <author> D. Leivant. </author> <title> A foundational delineation of computational feasibility. </title> <booktitle> In Proceedings of IEEE 6th Annual Symposium on Logic in Computer Science, </booktitle> <year> 1991. </year>
Reference-contexts: Takeuti [34] (k sorted variables used in defining k-fold multiple exponential time), but most especially in H. Simmons [127] (control variables, i.e. those used for recursion, are distinguished from usual variables; by separating their function, one prevents diagonalization as in the Ackermann function) and in D. Leivant <ref> [87, 88, 89, 90] </ref> (stratified polymorphism, second order system L 2 (QF + ) corresponding to polynomial time computable functions, stratified functional programs, ramified recurrence over 2 tiered word algebras corresponding to polynomial time). Of these, [127] and [88] are the most related to the Bellantoni-Cook work described below. <p> Leivant [87, 88, 89, 90] (stratified polymorphism, second order system L 2 (QF + ) corresponding to polynomial time computable functions, stratified functional programs, ramified recurrence over 2 tiered word algebras corresponding to polynomial time). Of these, [127] and <ref> [88] </ref> are the most related to the Bellantoni-Cook work described below.
Reference: [89] <author> D. Leivant. </author> <title> Stratified functional programs and computational complexity. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: Takeuti [34] (k sorted variables used in defining k-fold multiple exponential time), but most especially in H. Simmons [127] (control variables, i.e. those used for recursion, are distinguished from usual variables; by separating their function, one prevents diagonalization as in the Ackermann function) and in D. Leivant <ref> [87, 88, 89, 90] </ref> (stratified polymorphism, second order system L 2 (QF + ) corresponding to polynomial time computable functions, stratified functional programs, ramified recurrence over 2 tiered word algebras corresponding to polynomial time). Of these, [127] and [88] are the most related to the Bellantoni-Cook work described below.
Reference: [90] <author> D. Leivant. </author> <title> Ramified recurrence and computational complexity I: word recurrence and poly-time. </title> <editor> In P. Clote and J. Remmel, editors, </editor> <booktitle> Feasible Mathematics II, </booktitle> <pages> pages 320-343. </pages> <publisher> Birkhauser, </publisher> <year> 1994. </year>
Reference-contexts: Takeuti [34] (k sorted variables used in defining k-fold multiple exponential time), but most especially in H. Simmons [127] (control variables, i.e. those used for recursion, are distinguished from usual variables; by separating their function, one prevents diagonalization as in the Ackermann function) and in D. Leivant <ref> [87, 88, 89, 90] </ref> (stratified polymorphism, second order system L 2 (QF + ) corresponding to polynomial time computable functions, stratified functional programs, ramified recurrence over 2 tiered word algebras corresponding to polynomial time). Of these, [127] and [88] are the most related to the Bellantoni-Cook work described below. <p> Building on Bellantoni's proof, in her work on linear space reasoning, A.P. Nguyen [102] gave a slightly different characterization of this class. Recently, the author has given a safe characterization of etime functions of linear growth, by adapting the proof of Theorem 3.84. In <ref> [90] </ref> D. Leivant gave an alternative formulation of the safe characterizations of polynomial time and of linear space, by introducing a tiering notion to arbitrary word algebras. <p> Leivant and J.-Y. Marion gave various characterizations of ptime by typed -calculi with pairing over an algebra W of words over f0; 1g. Recently, Leivant and Marion showed how a natural restriction of functional recurrence with substitution generates exactly pspace. In a series of papers (see for instance <ref> [90] </ref>) D. Leivant investigated various tiering schemes of recursion (extensions of safe recursion) and related complexity classes. Such investigations may have some applicability to programming language design. In [103], building on work of H. Schwicht-enberg [121], K.-H.
Reference: [91] <author> D. Leivant. </author> <title> Logic and Computational Complexity. </title> <publisher> Springer Verlag, </publisher> <year> 1995. </year> <note> Lecture Notes in Computer Science 960. </note>
Reference-contexts: For more information, see the survey [41] by S.A. Cook and the volume edited by D. Leivant <ref> [91] </ref> (higher type complexity theory) and the articles by D. Norman and H. Schwichtenberg in this volume (higher type recursion theory). Definition 4.1 A type 2 functional F of rank (k; `) is a total mapping from (N N ) k fi N ` into N. <p> Such investigations may have some applicability to programming language design. In [103], building on work of H. Schwicht-enberg [121], K.-H. Niggl investigated certain subrecursive hierarchies (analogues of primitive recursive) of partial continuous functionals on Scott domains. As evidenced by the articles in the conference proceedings <ref> [91] </ref>, edited by D. Leivant, higher type functional complexity is an exciting area with many interesting theoretical questions, and the possibility of contributing to new programming language features. 5 Acknowledgements Many thanks to T. Altenkirch, S. Bellantoni, M. Hofmann, H. Schwichtenberg, and especially N. Danner and K.-H.
Reference: [92] <author> D. Leivant and J.-Y. Marion. </author> <title> Lambda-calculus characterizations of poly-time. </title> <journal> Fun-damenta Informaticae, </journal> <volume> 19 </volume> <pages> 167-184, </pages> <year> 1993. </year>
Reference-contexts: Goerdt generalized this to prove that type level k + 1 recursive definitions over finite structures characterize global functions in the class Dtime (exp k (n O (1) ) where exp 0 (n) = n and exp k+1 (n) = 2 exp k (n) . 62 In <ref> [92] </ref> D. Leivant and J.-Y. Marion gave various characterizations of ptime by typed -calculi with pairing over an algebra W of words over f0; 1g. Recently, Leivant and Marion showed how a natural restriction of functional recurrence with substitution generates exactly pspace.
Reference: [93] <author> J.C. Lind. </author> <title> Computing in logarithmic space. </title> <type> Technical Report Project MAC Technical Memorandum 52, </type> <institution> Massachusetts Institute of Technology, </institution> <month> September </month> <year> 1974. </year>
Reference-contexts: Lind <ref> [93] </ref>. <p> In <ref> [93] </ref>, J.
Reference: [94] <author> S.S. Marcenkov. </author> <title> A superposition basis in the class of Kalmar elementary functions. </title> <journal> Matematicheskie Zametki, </journal> <volume> 27(3) </volume> <pages> 321-332, </pages> <year> 1980. </year> <booktitle> Translation in Mathematical Notes of the Academy of Sciences of the USSR, </booktitle> <publisher> Plenum Publishing Company. </publisher>
Reference-contexts: As surveyed in [139], D. Rodding first gave a positive answer, which was refined by C. Parsons. In <ref> [94] </ref>, S.S. <p> In the following theorem, the first statement is due to S.S. Marcenkov <ref> [94] </ref>, while the second statement to J.P. Jones and Y. Matijasevic [75]. Theorem 3.66 E 3 fl = ([0; I; s; . ; bx=yc; x y ; comp]) fl = ([0; I; +; . ; bx=yc; x!; 2 x ; comp]) fl : In [40], R.
Reference: [95] <author> K. Mehlhorn. </author> <title> Polynomial and abstract subrecursive classes. </title> <journal> Journal of Computer and System Science, </journal> <volume> 12 </volume> <pages> 147-178, </pages> <year> 1976. </year>
Reference-contexts: Allen [3] in 1991, while certain small boolean circuit complexity classes were treated by the author and G. Takeuti [36] in 1995. Higher type analogues of certain characterizations were given in 1976 by K. Mehlhorn <ref> [95] </ref>, in 1991 by S. Cook and B. Kapron [79, 43] for sequential computation, and in 1993 by the author, A. Ignjatovic, B. Kapron [33] for parallel computation. In 1995 H. Vollmer and K. Wagner [137] Valiant's class #P . <p> Johannsen's [74] systems T V; A2V come from Theorem 3.16, while M. O'Donnell [104] has proposed equational calculus as a programming language. In this paper, we will survey a selection of results which illustrate the arithme 2 According to <ref> [95] </ref>, K. <p> Upon entering the oracle query state, there seem to be two natural measures for the time to complete the function query f (x). The unit cost, considered by Mehlhorn <ref> [95] </ref>, charges unit time, while the function length cost, considered by Constable [40] and later Kapron and Cook [79], charges maxf1; jf (x)jg time. <p> Schwichten berg's article in this volume. 53 Example 4.4 (1) F (f; x) = maxff (y) : y jxjg belongs to opt. (2) G (f; x) = maxff (y) : jyj jxjg does not belong to opt. (3) H (f; x) = f (jxj) (x) belongs to opt. In <ref> [95] </ref> K. Mehlhorn extended Cobham's function algebra to type 2 functionals. A modern presentation of Mehlhorn's definition uses the following schemes. <p> If F 2 bff (X), then F is basic feasible in X. The class bff of basic feasible functionals 30 is bff (;). In <ref> [95] </ref> Mehlhorn introduced the Turing machine model with function oracle, charging unit cost for a function oracle call, independent of the length of the function value returned. <p> Using the techniques of low-level arithmeti-zation from the proof of Theorem 3.19, the following result is proved. Theorem 4.7 (Mehlhorn <ref> [95] </ref>) For every functional F in bff, there is a unit cost model otm M which computes F , i.e.
Reference: [96] <author> A.R. Meyer and D. Ritchie. </author> <title> The complexity of loop programs. </title> <booktitle> Proc. ACM Nat. Conf., </booktitle> <pages> pages 465-469, </pages> <year> 1967. </year>
Reference-contexts: The above functions, for n 3, were taken from [12]. 13 See remark at bottom of p. 13 of [3]. 29 A number of characterizations of Grzegorczyk's classes E n E n , for n 3, have been given. A. Meyer and D. Ritchie <ref> [96] </ref> characterized E n in terms of certain loop programming languages, H. Schwichtenberg [120] investigated the number of nested bounded recursions used in function definitions (the so-called Heinemann hierarchy), S.S. Muchnick [98] investigated vectorized Grzegorczyk classes (essentially related to simultaneous bounded recursion schemes), etc.
Reference: [97] <author> B. Monien. </author> <title> A recursive and grammatical characterization of exponential time languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 61-74, </pages> <year> 1977. </year>
Reference-contexts: Definition 3.83 The function f is defined from functions g; h; r; k by bounded 2-value recursion (bvr) if f (0; ~y) = g (~y) provided that f (x; ~y) k (x; ~y) and r (x; ~y) &lt; x for all x; ~y. Theorem 3.84 (Monien <ref> [97] </ref>) Let f 2 (x; y) = (x + 1) (y + 1). Then ff 2 etime : f has linear growth rateg = [0; I; s; f 2 ; comp; bvr]: Proof. Our exposition follows [139].
Reference: [98] <author> S.S. Muchnick. </author> <title> The vectorized Grzegorczyk hierarchy. </title> <journal> Zeit. Math. Logik., </journal> <volume> 22 </volume> <pages> 441-80, </pages> <year> 1976. </year>
Reference-contexts: A. Meyer and D. Ritchie [96] characterized E n in terms of certain loop programming languages, H. Schwichtenberg [120] investigated the number of nested bounded recursions used in function definitions (the so-called Heinemann hierarchy), S.S. Muchnick <ref> [98] </ref> investigated vectorized Grzegorczyk classes (essentially related to simultaneous bounded recursion schemes), etc. The following theorem is due to H. Schwichtenberg [120] for n 3 and to H.
Reference: [99] <author> Helmut Muller. Klassifizierungen der primitiv rekursiven Funktionen. </author> <type> PhD thesis, </type> <institution> Universitat Munster, </institution> <year> 1974. </year>
Reference-contexts: Schwichtenberg [120] investigated the number of nested bounded recursions used in function definitions (the so-called Heinemann hierarchy), S.S. Muchnick [98] investigated vectorized Grzegorczyk classes (essentially related to simultaneous bounded recursion schemes), etc. The following theorem is due to H. Schwichtenberg [120] for n 3 and to H. Muller <ref> [99] </ref> for n = 2. 14 Theorem 3.31 (Schwichtenberg [120], Muller [99]) Let H n be the set ff : f primitive recursive, rk pr (f ) ng: Then for n 2, H n = E n+1 . <p> Muchnick [98] investigated vectorized Grzegorczyk classes (essentially related to simultaneous bounded recursion schemes), etc. The following theorem is due to H. Schwichtenberg [120] for n 3 and to H. Muller <ref> [99] </ref> for n = 2. 14 Theorem 3.31 (Schwichtenberg [120], Muller [99]) Let H n be the set ff : f primitive recursive, rk pr (f ) ng: Then for n 2, H n = E n+1 .
Reference: [100] <author> V.A. Nepomnjascii. </author> <title> Rudimentary predicates and turing calculations. </title> <journal> Dokl. Akad. Nauk SSSR, </journal> <volume> 195 </volume> <pages> 29-35, </pages> <year> 1970. </year> <note> Translated in Soviet Math. Dokl. 11 (1970) 1462-1465. </note>
Reference-contexts: Woods' presentation in [141], and simplifies the argument of [6] by using Lemma 3.13 and Lemma 3.14, both of which were generalized from Lemma 3.55. Lemma 3.55 was first proved by Nepomnjascii <ref> [100] </ref> (a related result proved by Bennett [13]), though R. Kannan [78] later rediscovered this result. <p> Using these functions and bounded minimiza tion, it is easy to show that M 2 is closed under crn. The following is proved in a manner similar to that of Lemma 3.13 and Lemma 3.14. Lemma 3.55 (Nepomnjascii <ref> [100] </ref>) For every k; m &gt; 1, NTimeSpace (n k ; n 11=m ) on a tm is contained in ca. Moreover, nspace (O (log (n))) lth. Theorem 3.56 lth = ca. Proof. Consider first the direction from left to right.
Reference: [101] <author> A. Nerode, J. Remmel, and A. Scedrov. </author> <title> Polynomially graded logic I a graded version of system T. </title> <booktitle> In Proceedings of IEEE 4th Annual Symposium on Logic in Computer Science, </booktitle> <year> 1989. </year>
Reference-contexts: Complexity theory for functionals of all finite types was initiated by S. Buss, who in [19] introduced a polynomial time analogue of the hereditarily recursive operations hro to define polynomial time functionals of all finite types decorated with runtime bounds. A. Nerode, J. Remmel and A. Scedrov <ref> [101] </ref> studied a polynomially graded type system. In [51], J.-Y. Girard, A. Scedrov and P. Scott introduced bounded linear logic, and proved a normalization theorem which yielded a characterization of a feasible class of type 2 functionals, whose type 1 section is the class of polytime computable functions.
Reference: [102] <author> A.P. Nguyen. </author> <title> A formal system for linear space reasoning. </title> <type> Technical Report 300/96, </type> <institution> University of Toronto, </institution> <year> 1996. </year>
Reference-contexts: Theorem 3.101 (Bellantoni [9]) E 2 = normal " [0; I; S; P r; K; scomp; sr]: W. Handley (unpublished) and D. Leivant (unpublished) both independently obtained Theorem 3.101. Building on Bellantoni's proof, in her work on linear space reasoning, A.P. Nguyen <ref> [102] </ref> gave a slightly different characterization of this class. Recently, the author has given a safe characterization of etime functions of linear growth, by adapting the proof of Theorem 3.84. In [90] D.
Reference: [103] <author> K.-H. Niggl. </author> <title> Subrecursive hierarchies on Scott domains. </title> <journal> Archive for Mathematical Logic, </journal> <volume> 32 </volume> <pages> 239-257, </pages> <year> 1993. </year>
Reference-contexts: In a series of papers (see for instance [90]) D. Leivant investigated various tiering schemes of recursion (extensions of safe recursion) and related complexity classes. Such investigations may have some applicability to programming language design. In <ref> [103] </ref>, building on work of H. Schwicht-enberg [121], K.-H. Niggl investigated certain subrecursive hierarchies (analogues of primitive recursive) of partial continuous functionals on Scott domains. As evidenced by the articles in the conference proceedings [91], edited by D.
Reference: [104] <author> M.J. O'Donnell. </author> <title> Equational logic as a programming language. </title> <publisher> M.I.T. Press, </publisher> <year> 1985. </year>
Reference-contexts: For instance, S. Cook's system P V [42] comes from Theorem 3.19, the author's systems AV , ALV , ALV 0 [28, 30] come from Theorems 3.26 and 3.27, J. Johannsen's [74] systems T V; A2V come from Theorem 3.16, while M. O'Donnell <ref> [104] </ref> has proposed equational calculus as a programming language. In this paper, we will survey a selection of results which illustrate the arithme 2 According to [95], K.
Reference: [105] <author> J. Otto. Tiers, tensors, </author> <booktitle> and 0 0 . Talk at meeting LCC, </booktitle> <address> Indianapolis, organizer D. Leivant, </address> <month> October 13-16 </month> <year> 1994. </year>
Reference-contexts: Details have been worked out by S. Bloch [15], and a related category theoretic characterization has been announced by J. Otto <ref> [105] </ref>. 4 Type 2 functionals Many programming languages allow functions to be passed as parameters to other functions or procedures.
Reference: [106] <author> S.V. Pakhomov. </author> <title> Machine independent description of some machine complexity classes (in Russian). </title> <journal> Issledovanija po konstrukt. </journal> <note> matemat. i mat. logike, VIII:176 185, LOMI 1979. </note>
Reference-contexts: As referenced in [139], S.V. Pakhomov <ref> [106] </ref> has characterized general complexity classes DTimeSpace (T; S), dtime (T ), and dspace (S) for suitable classes S; T of unary functions. The class ql = dtime (n (log n) O (1) ) of quasilinear time was studied by C.P. Schnorr in [118].
Reference: [107] <author> J. B. Paris and A. J. Wilkie. </author> <title> Counting problems in bounded arithmetic. </title> <editor> In C. A. di Prisco, editor, </editor> <booktitle> Methods in Mathematical Logic, pages 317 - 340. Springer Ver-lag Lecture Notes in Mathematics, 1983. Proceedings of Logic Conference held in Caracas, </booktitle> <year> 1983. </year>
Reference-contexts: A program is a finite list of instructions, where for each i there is at most one incremental instruction for S i . Apart from characterizing E 2 fl or linspace, Bel'tyukov characterized the linear time hierarchy lth. The papers of Paris, Wilkie <ref> [107] </ref> and Handley, Paris, Wilkie [62] study counting classes between lth and linspace defined by stack register machines. Recent work of the author [31] and of W. Handley [64, 63] further study the effect of nondeterminism for this model. <p> G (x; y; z) for the graph x y = z of exponentiation is in constructive arithmetic. 17 The result is proved in [68] for [0; I; s; x y ; f n ; comp; bmin], but as, previously explained, the exponential is unnecessary. 18 In the literature, especially in <ref> [107] </ref>, a function f is defined to be N 0 if its graph G f belongs to N 0 and f is of linear growth. It easily follows from Corollary 3.54 that f 2 Gca () f 2 N 0 . Proof. <p> While linspace is clearly closed under counting, this may not be the case for lth. A typical open question is whether (x) 2 M 2 , where (x) is the number of primes less than x. In <ref> [107, 62] </ref>, J. Paris, A. Wilkie and later W. Handley studied the effect of adding k-bounded recursion to lth. Using the techniques of Barrington, Paris, Wilkie and Handley, together with those of this paper, the following result can be proved. Theorem 3.59 (P. <p> The following result was proved by the Paris-Wilkie modification of Bel'tyukov's stack register machines. Theorem 3.72 (Paris, Wilkie <ref> [107] </ref>) (R 2 ) fl = (R 3 ) fl . The next theorem follows from the author's work in [31] and is based on Barrington's trick. Theorem 3.73 (P.
Reference: [108] <author> R. Peter. </author> <title> Uber die mehrfache Rekursion. </title> <journal> Mathematische Annalen, </journal> <volume> 113 </volume> <pages> 489-526, </pages> <year> 1936. </year>
Reference-contexts: In 1931, K. Godel [52] defined the primitive recursive functions, there calling them "rekursive Funk-tionen", and used them to arithmetize logical syntax via Godel numbers for his incompleteness theorem. Generalizing Ackermann's work, in 1936 R. Peter <ref> [108] </ref> defined and studied the k-fold recursive functions. The same year saw the introduction of the fundamental concepts of Turing machine (A.M. Turing [134]), -calculus (A. Church [26]) and -recursive functions (S.C. Kleene [81]).
Reference: [109] <author> F. Pitt. b N 0 and ALOGT IM E. typeset manuscript, </author> <year> 1995. </year>
Reference-contexts: Buss [18]. Independently and at the same time, an equivalent theory of arithmetic for nc functions was given by the author [27], later appearing in joint work with G. Takeuti [35]. In <ref> [109] </ref> F. Pitt considered a variant of B. Allen's polynomial bounded branching recursion, where the function value is bounded by a constant. 21 What is here called a k-function is called a k + 1-function in [86]. <p> Pitt <ref> [109] </ref>) The function f is defined by k-bounded tree recur-sion on notation (k-btrn) from functions g; h if f (0; ~y) = g 0 (~y) f (x; ~y) = h (x; ~y; f (fh (x); ~y); f (bh (x); ~y)); if x &gt; 1 provided that f (x; ~y) k, for <p> When k is unspecified, the scheme k-btrn is meant to allow all constants k 2 N. Theorem 3.79 (F. Pitt <ref> [109] </ref>) F alogtime = [0; I; s 0 ; s 1 ; jxj; #; msp; lsp; comp; crn; k btrn]: The theorem is proved by showing that fh; bh can be defined from the initial functions, and then by defining the function tree in the above function algebra, where tree is
Reference: [110] <author> P. Pudlak. </author> <title> Complexity theory and genetics. </title> <booktitle> In Proceedings of 9th Annual IEEE Conference on Structure in Complexity Theory, </booktitle> <year> 1994. </year> <month> 68 </month>
Reference-contexts: There are other extensions of the Turing machine model not covered in this survey, such as the probabilistic Turing machine (yielding classes such as r and bpp, see [136]), the genetic Turing machine (defined by P. Pudlak <ref> [110] </ref>, who showed that polynomial time bounded genetic tm's compute exactly pspace), and the quantum Turing machine (first introduced by D. Deutsch [46], and for which P.
Reference: [111] <author> R.W. Ritchie. </author> <title> Classes of predictably computable functions. </title> <journal> Trans. Am. Math. Soc., </journal> <volume> 106 </volume> <pages> 139-173, </pages> <year> 1963. </year>
Reference-contexts: Only much later in 1976 did C. Wrathall [142] connect these concepts to computer science by proving that the linear time hierarchy lth coincides with rudimentary, hence constructive arithmetic, sets. In 1963 R. W. Ritchie <ref> [111] </ref> proved that Grze-gorczyk's class E 2 is the collection of functions computable in linear space on a Turing machine. In 1965, A. <p> The proof relies on arithmetizing computations via Godel numbers, a technique introduced in [52] by Godel, and with which Turing computable functions can be shown equivalent to -recursive functions. Since then, there have been a number of arithmetizations of machine models <ref> [81, 82, 13, 39, 111, 132, 138, 38, 36] </ref>, etc. <p> Then f (x; ~y) = sg (( ix X sg (h (i; ~y)): The following characterization of linspace in terms of the Grzegorczyk hierarchy was proved by R.W. Ritchie <ref> [111] </ref>. Theorem 3.36 F linspace = E 2 . Proof. Consider first the direction from right to left. The initial functions of E 2 are computable in linspace, and Flinspace is closed under composition and bounded recursion. Now consider the direction from left to right. <p> Thus T is definable using bounded recursion from functions belonging to E 2 . It follows that F linspace E 2 . Corollary 3.37 (R. Ritchie <ref> [111] </ref>) linspace = E 2 fl .
Reference: [112] <author> J. Robinson. </author> <title> Definability and decision problems in arithmetic. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 14 </volume> <pages> 98-114, </pages> <year> 1949. </year>
Reference-contexts: Theorem 3.48 (Grzegorczyk [57], Harrow [68]) For n 3, E n = M n . In the literature, the algebra rf of rudimentary functions is sometimes defined by rf = [0; I; s; +; fi; comp; bmin]: As noticed in [68], it follows from J. Robinson's <ref> [112] </ref> bounded quantifier definition of addition from successor and multiplication that M 2 = rf. As is well-known, there is a close relationship between (bounded) minimization and (bounded) quantification. This is formalized as follows.
Reference: [113] <author> R.M. Robinson. </author> <title> Primitive recursive functions. </title> <journal> Bulletin of the Amer. Math. Society, </journal> <volume> 53 </volume> <pages> 923-943, </pages> <year> 1947. </year>
Reference-contexts: The function f is defined by iteration (iter) from functions g if f (0) = 0 Theorem 3.5 (R.M. Robinson <ref> [113] </ref>) Define the operation add by add (f; g)(x) = f (x) + g (x), and let q (x) = x b xc 2 . Let PR 1 denote the collection of one-place primitive recursive functions. Then PR 1 equals [0; s; q; comp; iter; add]. In [4] G.
Reference: [114] <author> H. E. Rose. Subrecursion: </author> <title> Function and Hierarchies, </title> <booktitle> volume 9 of Oxford Logic Guides. </booktitle> <publisher> Clarendon Press, Oxford, </publisher> <year> 1984. </year> <pages> 191 pages. </pages>
Reference-contexts: Rose <ref> [114] </ref> and K. Wagner and G. Wechsung [139] (chapters 2, 10). Since newer results concerning smaller complexity classes yield older results concerning larger classes as corollaries, we begin with a function algebra introduced by the author for the class F lh of functions in the logtime hierarchy. <p> To our knowledge, the first published proof of Cobham's result, additionally formulated for functions on the integers, appeared in <ref> [114] </ref>. <p> Theorem 3.19 ( A. Cobham [39], see H. Rose <ref> [114] </ref>) Fptime = [0; I; s 0 ; s 1 ; #; comp; brn]: Proof. Temporarily denote the algebra [0; I; s 0 ; s 1 ; #; comp; brn] by F . Consider first the inclusion from left to right. <p> Definition 3.47 For n 0, define M n = [0; I; s; f n ; comp; bmin]. 16 16 In <ref> [114] </ref>, following work of K. Harrow [67, 68], for n 3, M n is defined to be [0; I; s; x y ; f n ; comp; bmin].
Reference: [115] <author> J.S. Royer. </author> <title> Semantics vs. syntax vs. computation. </title> <address> Typescript, </address> <month> November 29, </month> <year> 1994. </year>
Reference-contexts: In [123] Seth further investigated closure conditions for feasible functionals. In <ref> [115] </ref>, J. Royer studied a polynomial time counterpart to the Kreisel-Lacombe-Shoenfield theorem [85]. Complexity theory for functionals of all finite types was initiated by S.
Reference: [116] <author> W.L. Ruzzo. </author> <title> On uniform circuit complexity. </title> <journal> J. Comput. System Sci., </journal> <volume> 22:pp. </volume> <pages> 365-383, </pages> <year> 1981. </year>
Reference-contexts: Various notions of uniformity have been suggested (ptime-uniformity [8], logspace-uniformity [17], U E fl -uniformity <ref> [116] </ref>, etc.), but the most robust (and strictest) appears to be that of logtime-uniformity [18, 6], which is adopted in this paper. Definition 2.17 (W. Ruzzo [116], also [6]) The direct connection language (dcl) of a circuit family (C n : n 2 N) is the set of (a; b; `; <p> Various notions of uniformity have been suggested (ptime-uniformity [8], logspace-uniformity [17], U E fl -uniformity <ref> [116] </ref>, etc.), but the most robust (and strictest) appears to be that of logtime-uniformity [18, 6], which is adopted in this paper. Definition 2.17 (W. Ruzzo [116], also [6]) The direct connection language (dcl) of a circuit family (C n : n 2 N) is the set of (a; b; `; 0 n ), where a is the parent of b in the circuit C n , and the label of gate a is `.
Reference: [117] <author> W. J. Savitch. </author> <title> Relationship between nondeterministic and deterministic tape complexities. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 4:177 - 192, </volume> <year> 1970. </year>
Reference-contexts: The results of Barrington and Buss are complementary in the sense that the word problem for S 5 is clearly in alogtime, but not obviously complete, while the boolean formula evaluation problem is clearly complete but not obviously in alogtime. In <ref> [117] </ref>, W. Savitch proved that nspace (S (n)) dspace (S 2 (n)), for any space constructible S (n) log n.
Reference: [118] <author> C. P. Schnorr. </author> <title> Satisfiability is quasilinear complete in NQL. </title> <journal> Journal of the Association of Computing Machinery, </journal> <volume> 25(1) </volume> <pages> 136-145, </pages> <year> 1978. </year>
Reference-contexts: As referenced in [139], S.V. Pakhomov [106] has characterized general complexity classes DTimeSpace (T; S), dtime (T ), and dspace (S) for suitable classes S; T of unary functions. The class ql = dtime (n (log n) O (1) ) of quasilinear time was studied by C.P. Schnorr in <ref> [118] </ref>. In analogy, let quasilinear space be the class dspace (n (log n) O (1) ). Though Corollary 3.43 characterizes quasilinear space via a function algebra, there appears to be no known function algebra for quasilinear time. In [60], Y. Gurevich and S.
Reference: [119] <author> H. Scholz. </author> <title> Ein ungelostes Problem in der symbolischen Logik. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 17:160, </volume> <year> 1952. </year>
Reference-contexts: Kalmar [77]. In 1953, A. Grzegorczyk [57] studied the classes E k obtained by closing certain fast growing "diagonal" functions under composition and bounded primitive recursion or bounded minimization. H. Scholz's 1952 <ref> [119] </ref> question concerning the characterization of spectra fn 2 N : (9 model M of n elements)(M j= OE)g of first order sentences OE, which was shown in 1974 by N. Jones and A. Selman [76] to equal ntime (2 O (n) ), was the starting point for J.H.
Reference: [120] <author> H. Schwichtenberg. </author> <title> Rekursionszahlen und die Grzegorczyk-Hierarchie. </title> <journal> Arch. Math. Logik., </journal> <volume> 12 </volume> <pages> 85-97, </pages> <year> 1969. </year>
Reference-contexts: A. Meyer and D. Ritchie [96] characterized E n in terms of certain loop programming languages, H. Schwichtenberg <ref> [120] </ref> investigated the number of nested bounded recursions used in function definitions (the so-called Heinemann hierarchy), S.S. Muchnick [98] investigated vectorized Grzegorczyk classes (essentially related to simultaneous bounded recursion schemes), etc. The following theorem is due to H. Schwichtenberg [120] for n 3 and to H. <p> Schwichtenberg <ref> [120] </ref> investigated the number of nested bounded recursions used in function definitions (the so-called Heinemann hierarchy), S.S. Muchnick [98] investigated vectorized Grzegorczyk classes (essentially related to simultaneous bounded recursion schemes), etc. The following theorem is due to H. Schwichtenberg [120] for n 3 and to H. Muller [99] for n = 2. 14 Theorem 3.31 (Schwichtenberg [120], Muller [99]) Let H n be the set ff : f primitive recursive, rk pr (f ) ng: Then for n 2, H n = E n+1 . <p> Muchnick [98] investigated vectorized Grzegorczyk classes (essentially related to simultaneous bounded recursion schemes), etc. The following theorem is due to H. Schwichtenberg <ref> [120] </ref> for n 3 and to H. Muller [99] for n = 2. 14 Theorem 3.31 (Schwichtenberg [120], Muller [99]) Let H n be the set ff : f primitive recursive, rk pr (f ) ng: Then for n 2, H n = E n+1 . <p> Lemma 3.33 (Grzegorczyk [57]) The functions x . y, sg (x), sg (x), sg (x)y, sg (x) y belong to E 0 . If f 2 E 0 then P P ix sg (f (i)) belong to E 0 . 14 It should be mentioned that <ref> [120] </ref> used slightly different functions f i ; there f i is the i-th Ackermann branch A i . 15 See Corollary 3.37. 30 Definition 3.34 The function f is defined by bounded minimization (bmin) from the function g, denoted by f (x; ~y) = i x [g (i; ~y) =
Reference: [121] <author> H. Schwichtenberg. </author> <title> Primitive recursion on the partial continuous functionals. </title> <editor> In M. Broy, editor, </editor> <booktitle> Informatik und Mathematik, </booktitle> <pages> pages 251-259. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In a series of papers (see for instance [90]) D. Leivant investigated various tiering schemes of recursion (extensions of safe recursion) and related complexity classes. Such investigations may have some applicability to programming language design. In [103], building on work of H. Schwicht-enberg <ref> [121] </ref>, K.-H. Niggl investigated certain subrecursive hierarchies (analogues of primitive recursive) of partial continuous functionals on Scott domains. As evidenced by the articles in the conference proceedings [91], edited by D.
Reference: [122] <author> A. Seth. </author> <title> There is no recursive axiomatization for feasible functionals of type 2. </title> <booktitle> In Proceedings of IEEE 7th Annual Symposium on Logic in Computer Science, </booktitle> <year> 1992. </year> <pages> pp. 286-295. </pages>
Reference-contexts: In particular, substituting the polytime computable function y:y 2 for f in H, where H (f; x) = f (jxj) (x), above yields H (y:y 2 ; x) = x 2 jxj which is not a polytime computable type 1 function (example due to A. Seth <ref> [122] </ref>). The following example, due to S. Cook, provides a functional which belongs to opt yet not to bff. Let quasi-order N fi N by length first difference; i.e. (a; b) (c; d) iff jaj &lt; jcj or (jaj = jcj and jbj jdj). <p> This argument suggests that bff should not be considered the class of all feasible type-2 functionals. Against this, in <ref> [122] </ref> A. Seth proves that the type-1 section of the closure of type-2 exponential time with L is not the class of exponential time computable functions, and hence L should not be considered a feasible functional. <p> In [41], S. Cook gave a survey of higher type computational approaches, and proved Theorem 4.9. Cook further proposed that any class C of feasible type 2 functionals must satisfy the following two conditions: 1. bff C opt, 2. C is closed under abstraction and application. In <ref> [122] </ref> A. Seth defined a class C 2 of type 2 functionals defined by counter Tur-ing machines with polynomial bounds, which satisfies the previous conditions, and proved that no recursively presentable class of functionals exists which contains C 2 and satisfies the previous conditions.
Reference: [123] <author> A. Seth. </author> <title> Some desirable conditions for feasible functionals of type 2. </title> <booktitle> In Proceedings of IEEE 8th Annual Symposium on Logic in Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: In [122] A. Seth defined a class C 2 of type 2 functionals defined by counter Tur-ing machines with polynomial bounds, which satisfies the previous conditions, and proved that no recursively presentable class of functionals exists which contains C 2 and satisfies the previous conditions. In <ref> [123] </ref> Seth further investigated closure conditions for feasible functionals. In [115], J. Royer studied a polynomial time counterpart to the Kreisel-Lacombe-Shoenfield theorem [85]. Complexity theory for functionals of all finite types was initiated by S.
Reference: [124] <author> A. Seth. </author> <title> Turing machine characterizations of feasible functionals of all finite types. </title> <editor> In P. Clote and J. Remmel, editors, </editor> <booktitle> Feasible Mathematics II, </booktitle> <pages> pages 407-428. </pages> <publisher> Birkhauser, </publisher> <year> 1994. </year>
Reference-contexts: This kind of characterization was extended by P. Clote, B. Kapron and A. Ignjatovic in [33] to the higher type functionals in nc ! , relating bounded loop programs with higher type parallel complexity classes. In <ref> [124] </ref> A. Seth extended his definition of counter Turing machine to all finite types, thus characterizing P V ! by a machine model.
Reference: [125] <author> Y. Shiloach and U. Vishkin. </author> <title> Finding the maximum, merging and sorting in a parallel computation model. </title> <journal> Journal of Algorithms, </journal> <volume> 3 </volume> <pages> 57-67, </pages> <year> 1982. </year>
Reference-contexts: Hillis and G.L. Steele, Jr. [70] Emerging around 1976-77 from the work of Goldschlager [55, 56], Fortune-Wyllie [49], and Shiloach-Vishkin <ref> [125] </ref>, the parallel random access machine (pram) provides an abstract model of parallel computation for algorithm development.
Reference: [126] <author> P. Shor. </author> <title> Algorithms for quantum computation: discrete log and factoring. </title> <booktitle> In Proceedings of IEEE 35th Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1994. </year>
Reference-contexts: Pudlak [110], who showed that polynomial time bounded genetic tm's compute exactly pspace), and the quantum Turing machine (first introduced by D. Deutsch [46], and for which P. Shor <ref> [126] </ref> recently proved that integer factorization is computable in bounded error probabilistic quantum polynomial time bqp). 2.2 Parallel machine model "Having one processor per data element changes the way one thinks." W.D. Hillis and G.L.
Reference: [127] <author> Harold Simmons. </author> <title> The realm of primitive recursion. </title> <journal> Archive for Mathematical Logic, </journal> <volume> 27 </volume> <pages> 177-188, </pages> <year> 1988. </year>
Reference-contexts: Related tiering notions, though technically different, have occurred in the literature, as in the author's work with G. Takeuti [34] (k sorted variables used in defining k-fold multiple exponential time), but most especially in H. Simmons <ref> [127] </ref> (control variables, i.e. those used for recursion, are distinguished from usual variables; by separating their function, one prevents diagonalization as in the Ackermann function) and in D. <p> Leivant [87, 88, 89, 90] (stratified polymorphism, second order system L 2 (QF + ) corresponding to polynomial time computable functions, stratified functional programs, ramified recurrence over 2 tiered word algebras corresponding to polynomial time). Of these, <ref> [127] </ref> and [88] are the most related to the Bellantoni-Cook work described below.
Reference: [128] <editor> Th. Skolem. Begrundung der elementaren Arithmetik durch die rekurrierende Denkweise ohne Anwendung scheinbarer Veranderlichen mit unendlichem Aus-dehnungsbereich. Skrifter utgit av Videnskapsselskapet, I. Mate. Klasse, </editor> <volume> 6, </volume> <year> 1923. </year> <pages> Oslo. </pages>
Reference-contexts: Hardy [65] used related concepts to define sets of real numbers of cardinality @ 1 . In 1923, Th. Skolem <ref> [128] </ref> introduced the primitive recursive functions, and in 1925, as a technical tool in his claimed sketch proof of the continuum hypothesis, D. Hilbert [69] defined classes of higher type functionals by recursion. In 1928, W.
Reference: [129] <author> R. </author> <title> Smullyan. </title> <journal> Theory of Formal Systems. Annals of Mathematical Studies, </journal> <volume> no. 47. </volume> <publisher> Princeton University Press, </publisher> <year> 1961. </year>
Reference-contexts: In [13], J.H. Bennett showed that the collection of constructive arithmetic sets ( 0 definable) is equal to rud, the class of rudimentary sets in the sense of <ref> [129] </ref>. Later, C. Wrathall [142] proved that the rudimentary sets are exactly those in the linear time hierarchy lth. Theorem 3.53 (J.
Reference: [130] <author> L. Stockmeyer and U. Vishkin. </author> <title> Simulation of parallel random access machines by circuits. </title> <journal> SIAM Journal on Computing, </journal> <volume> 13 </volume> <pages> 409-422, </pages> <year> 1984. </year>
Reference-contexts: O (1) ; O (1)) over the basis ^, _, :, mod k;n , where ^,_ have unbounded fan-in, and acc = [ k2 acc (k). tc 0 is the class of languages in logtime-uniform SizeDepth (n O (1) ; O (1)) over the basis th k;n . 8 In <ref> [130] </ref>, L. Stockmeyer and U. Vishkin related pram time and processors to boolean circuit depth and size. The logtime-uniform version of that result was proved by N. Immerman [73] and follows. <p> In characterizing ac k in the non-oracle case, Stockmeyer and Vishkin <ref> [130] </ref> require a polynomial bound p (n) on the number of active processors on inputs of length n.
Reference: [131] <author> G. Takeuti. </author> <title> Frege proof system and T N C 0 . In D. Leivant, editor, </title> <booktitle> Logic and Computational Complexity, </booktitle> <pages> pages 221-252. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year> <note> Lecture Notes in Computer Science 960. </note>
Reference-contexts: Using such techniques, for instance, in <ref> [131] </ref> G. Takeuti provided a simpler proof of the existence of an alternating logtime algorithm for the boolean formula evaluation problem, a result first proved by S. Buss [20, 22] (see Theorem 2.11). For a further discussion of such applications, see the recent monograph by J. Krajicek [84].
Reference: [132] <author> D.B. Thompson. Subrecursiveness: </author> <title> machine independent notions of computability in restricted time and storage. </title> <journal> Math. Systems Theory, </journal> <volume> 6 </volume> <pages> 3-15, </pages> <year> 1972. </year>
Reference-contexts: B. Thompson <ref> [132] </ref> in 1972 on polynomial space, of K. Wagner [138] in 1979 on general time complexity classes. Function algebra characterizations of parallel complexity classes were given more recently by the author [38] in 1990 and B. <p> The proof relies on arithmetizing computations via Godel numbers, a technique introduced in [52] by Godel, and with which Turing computable functions can be shown equivalent to -recursive functions. Since then, there have been a number of arithmetizations of machine models <ref> [81, 82, 13, 39, 111, 132, 138, 38, 36] </ref>, etc. <p> The inclusion from right to left is proved by an easy induction on term formation in the Cobham algebra. Using the same techniques, one can characterize the class Gptime of polynomial time computable functions of linear growth as follows. The first assertion is due to D.B. Thompson <ref> [132] </ref> (recall that fl is concatenation), and the other assertions follow by alternate functions in bounding the recursion on notation. <p> Theorem 3.39 (D.B. Thompson <ref> [132] </ref>) F pspace = [0; I; s; #; comp; br] = [0; I; s; max; x jxj ; comp; br]: Definition 3.40 Let k be an integer.
Reference: [133] <author> M. Townsend. </author> <title> Complexity for type-2 relations. </title> <journal> Notre Dame Journal of Formal Logic, </journal> <volume> 31 </volume> <pages> 241-262, </pages> <year> 1990. </year>
Reference-contexts: In [95] K. Mehlhorn extended Cobham's function algebra to type 2 functionals. A modern presentation of Mehlhorn's definition uses the following schemes. Definition 4.5 (Townsend <ref> [133] </ref>) F is defined from H; G 1 ; : : : ; G m by functional composition if for all ~ f; ~x, F ( ~ f ; ~x) = H ( ~ f ; G 1 ( ~ f ; ~x); : : : ; G m ( ~ <p> Definition 4.6 (Townsend <ref> [133] </ref>, Kapron, Cook [43]) Let X be a class of type 2 functionals. <p> ; ~x has runtime at most jG ( ~ f ; ~x)j for some G belonging to bff, then F 2 bff. 29 This scheme is clearly equivalent to that of bounded recursion on notation brn for functionals, yet notationally easier to manipulate in the proofs which follow. 30 Townsend <ref> [133] </ref> calls this class POLY. Cook and Kapron call this class basic feasible, leaving open the possibility that with future research a more natural class of feasible functionals may be investigated. <p> The original definition of basic feasible functional required closure under functional substitution, but this can be defined from the remaining schemes, as noted in <ref> [133] </ref>. 54 Definition 4.8 A class F of type 2 functionals has the Ritchie-Cobham property if F = fF : there exist G 2 F and otm M which on any input ~ f ; ~x computes F ( ~ f ; ~x) within time jG ( ~ f ; ~x)jg:
Reference: [134] <author> A.M. </author> <title> Turing. On computable numbers, with an application to the Entschei--dungsproblem. </title> <journal> Proc. Lond. Math. Soc., </journal> <volume> Series 2, 42 </volume> <pages> 230-265, 1936-37. </pages>
Reference-contexts: Generalizing Ackermann's work, in 1936 R. Peter [108] defined and studied the k-fold recursive functions. The same year saw the introduction of the fundamental concepts of Turing machine (A.M. Turing <ref> [134] </ref>), -calculus (A. Church [26]) and -recursive functions (S.C. Kleene [81]). By restricting the scheme of primitive recursion to allow only limited summations and limited products, the elementary functions were introduced in 1943 by L. Kalmar [77]. In 1953, A. <p> Church [26] using the -calculus), A.M. Turing <ref> [134] </ref> introduced the Turing machine, largely motivated by his attempt to make precise the notion of computable (real) number, i.e., "those whose decimals which are calculable by finite means". <p> In (iii), for u; v 2 fl the pair (u; v) can be encoded by o (juj)11o (jvj)11uv, where o replaces each 0 [resp. 1] by 00 [resp. 01]. Decoding can then be done by using addition and random access. A.M. Turing <ref> [134] </ref> introduced the notion of relative computation using an oracle Tur-ing machine . Definition 2.5 Let B fl .
Reference: [135] <author> L. Valiant. </author> <title> The complexity of computing the permanent. </title> <journal> Theoretical Computer Science, </journal> <volume> 8 </volume> <pages> 189-201, </pages> <year> 1979. </year>
Reference-contexts: Burtschick (personal correspondence) suggested that polynomial size uniform arithmetic circuits could be related to the class K. Somewhat related is the recent work on counting classes. The class #P , introduced by Valiant <ref> [135] </ref>, is the set of functions f , for which there exists a nondeterministic polynomial time bounded Turing machine M , such that f (x) is the number of accepting paths in the computation tree of M on input x.
Reference: [136] <author> P. van Emde Boas. </author> <title> Machine models and simulations. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume A, </booktitle> <pages> pages 1-66. </pages> <publisher> Elsevier, MIT Press, </publisher> <address> 1990. </address> <publisher> Elsevier (Amsterdam), MIT Press (Cambridge). </publisher>
Reference-contexts: Weihrauch independently proved a similar characterization in 1972. 3 tization techniques used in characterizing certain computation models by function algebras. 2 Machine Models Despite the immense diversity of abstract machine models and complexity classes (see for instance <ref> [136] </ref> or [139]), only the most natural and robust models and classes will be treated in this paper. Many of the following machine models are familiar. <p> There are other extensions of the Turing machine model not covered in this survey, such as the probabilistic Turing machine (yielding classes such as r and bpp, see <ref> [136] </ref>), the genetic Turing machine (defined by P. Pudlak [110], who showed that polynomial time bounded genetic tm's compute exactly pspace), and the quantum Turing machine (first introduced by D. Deutsch [46], and for which P.
Reference: [137] <author> H. Vollmer and K. Wagner. </author> <title> Recursion theoretic characterizations of complexity classes of counting functions. </title> <note> Theoretical Computer Science, to appear. </note>
Reference-contexts: Higher type analogues of certain characterizations were given in 1976 by K. Mehlhorn [95], in 1991 by S. Cook and B. Kapron [79, 43] for sequential computation, and in 1993 by the author, A. Ignjatovic, B. Kapron [33] for parallel computation. In 1995 H. Vollmer and K. Wagner <ref> [137] </ref> Valiant's class #P . Though distinct, the arithmetization techniques of function algebras are related to those used in proving numerous results like (i) np equals generalized first order spectra (R. <p> Unless P = N P , it is unlikely that #P is closed under composition. Using the arithmetization of boolean formulas from A. Shamir (see [5]), H. Vollmer and K. Wagner gave the following characterization of #P . 20 Theorem 3.70 (H. Vollmer, K. Wagner <ref> [137] </ref>) #P = [[0; I; S; +; . ; fi; bx=yc; #; comp; sbprod]; bsum] = [[0; I; S; +; . ; fi; #; comp]; sbprod; bsum]: Definition 3.71 Let R k be the smallest class of functions definable from the constant functions 0; : : : ; k, the projections <p> Theorem 3.73 (P. Clote [31]) For n 4, (R n ) fl = (R n+1 ) fl = alintime: In [86], Kuty lowski considered oracle versions of the Paris-Wilkie work. 20 In the notation of <ref> [137] </ref>, the characterization reads #P = fi [+; . ; fi; :] Sub, WProd fl , and fi fl WProd,Sum . This formulation is equivalent to that given in Theorem 3.70. 40 Definition 3.74 (M.
Reference: [138] <author> K. Wagner. </author> <title> Bounded recursion and complexity classes. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> volume 74, </volume> <pages> pages 492-498. </pages> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: B. Thompson [132] in 1972 on polynomial space, of K. Wagner <ref> [138] </ref> in 1979 on general time complexity classes. Function algebra characterizations of parallel complexity classes were given more recently by the author [38] in 1990 and B. Allen [3] in 1991, while certain small boolean circuit complexity classes were treated by the author and G. Takeuti [36] in 1995. <p> The proof relies on arithmetizing computations via Godel numbers, a technique introduced in [52] by Godel, and with which Turing computable functions can be shown equivalent to -recursive functions. Since then, there have been a number of arithmetizations of machine models <ref> [81, 82, 13, 39, 111, 132, 138, 38, 36] </ref>, etc. <p> The next result follows from a characterization of pspace by a variant of the stack register machine model. Theorem 3.41 (P. Clote [31]) For k 4, pspace = [0; I; s 0 ; s 1 ; jxj; bit; #; comp; crn; k-br] fl : In <ref> [138] </ref> K. Wagner extended Ritchie's characterization to more general complexity classes. Theorem 3.42 (K. Wagner [138]) Let f be an increasing function such that for some r &gt; 1 and for all but finitely many x, it is the case that f (x) x r . <p> Theorem 3.41 (P. Clote [31]) For k 4, pspace = [0; I; s 0 ; s 1 ; jxj; bit; #; comp; crn; k-br] fl : In <ref> [138] </ref> K. Wagner extended Ritchie's characterization to more general complexity classes. Theorem 3.42 (K. Wagner [138]) Let f be an increasing function such that for some r &gt; 1 and for all but finitely many x, it is the case that f (x) x r . Let F temporarily denote the algebra [jf (2 n )j; comp]. <p> Corollary 3.43 (K. Wagner <ref> [138] </ref>) For k 1, dspace (n (log (k) n) O (1) ) = [0; I; s; max; x jxj k+1 ; comp; br]: Definition 3.44 (K. Wagner [138]) The function f is defined by weak bounded primitive recursion (wbpr) from g; h; k if f (x; ~y) = F (jxj; ~y), <p> Corollary 3.43 (K. Wagner <ref> [138] </ref>) For k 1, dspace (n (log (k) n) O (1) ) = [0; I; s; max; x jxj k+1 ; comp; br]: Definition 3.44 (K. Wagner [138]) The function f is defined by weak bounded primitive recursion (wbpr) from g; h; k if f (x; ~y) = F (jxj; ~y), where F is defined by bounded primitive recursion, i.e. <p> Using this observation, Wagner characterized certain general complexity classes as follows. Theorem 3.45 (K. Wagner <ref> [138] </ref>) Let f be an increasing function such that f (x) x r for some r &gt; 1, and temporarily let F denote the algebra [jf (2 n )j; comp] and G denote fg k : g 2 F; k 2 Ng.
Reference: [139] <author> K. Wagner and G. Wechsung. </author> <title> Computational Complexity. </title> <publisher> Reidel Publishing Co., </publisher> <year> 1986. </year>
Reference-contexts: Weihrauch independently proved a similar characterization in 1972. 3 tization techniques used in characterizing certain computation models by function algebras. 2 Machine Models Despite the immense diversity of abstract machine models and complexity classes (see for instance [136] or <ref> [139] </ref>), only the most natural and robust models and classes will be treated in this paper. Many of the following machine models are familiar. <p> Rose [114] and K. Wagner and G. Wechsung <ref> [139] </ref> (chapters 2, 10). Since newer results concerning smaller complexity classes yield older results concerning larger classes as corollaries, we begin with a function algebra introduced by the author for the class F lh of functions in the logtime hierarchy. <p> As referenced in <ref> [139] </ref>, S.V. Pakhomov [106] has characterized general complexity classes DTimeSpace (T; S), dtime (T ), and dspace (S) for suitable classes S; T of unary functions. The class ql = dtime (n (log n) O (1) ) of quasilinear time was studied by C.P. Schnorr in [118]. <p> As surveyed in <ref> [139] </ref>, D. Rodding first gave a positive answer, which was refined by C. Parsons. In [94], S.S. <p> On p. 118 of [40], the following claim is stated as a theorem without proof. 19 Sharply bounded summation [resp. product] is called weak sum [resp. product in <ref> [139] </ref>, and bounded summation [resp. product] is called limited sum [resp. product in [57]. 39 Claim 3.67 For all non-decreasing f , K (f ) = F P (f ). The statement F ptime = K was then claimed as a corollary in [40]. <p> The statement F ptime = K was then claimed as a corollary in [40]. This statement was again cited as a theorem (without proof) in <ref> [139] </ref>. It now appears that this assertion is doubtful, since K N C and it is currently conjectured that N C is properly contained in F ptime. Moreover, using an oracle separation of N C A from P A , the author [32] provided a counterexample to the previous claim. <p> Theorem 3.84 (Monien [97]) Let f 2 (x; y) = (x + 1) (y + 1). Then ff 2 etime : f has linear growth rateg = [0; I; s; f 2 ; comp; bvr]: Proof. Our exposition follows <ref> [139] </ref>. Temporarily, let F denote ff 2 etime : f has linear growth rateg and G denote [0; I; s; f 2 ; comp; bvr]. Consider first the inclusion F G.
Reference: [140] <author> A.J. Wilkie. </author> <title> Modeles non standard de l'arithmetique, </title> <editor> et complexite algorithmique. In A.J. Wilkie and J.-P. Ressayre, editors, </editor> <title> Modeles non standard en Arithmetique et en Theorie des ensembles, </title> <type> pages 5-45. </type> <institution> Publications Mathematiques de l'Universite Paris VII, </institution> <year> 1983. </year>
Reference-contexts: The main lines of this proof were influenced by Wilkie's presentation in <ref> [140] </ref>. See [61] for other proofs. Corollary 3.54 The function algebra [0; I; s 0 ; s 1 ; jxj; bit; comp; crn] is contained in M 2 . Proof.
Reference: [141] <author> A. Woods. </author> <title> Bounded arithmetic formulas and Turing machines of constant alternation. </title> <editor> In J.B. Paris, A.J. Wilkie, and G.M. Wilmers, editors, </editor> <booktitle> Logic Coloquium 1984. </booktitle> <publisher> North Holland, </publisher> <year> 1986. </year>
Reference-contexts: Woods' presentation in <ref> [141] </ref>, and simplifies the argument of [6] by using Lemma 3.13 and Lemma 3.14, both of which were generalized from Lemma 3.55. Lemma 3.55 was first proved by Nepomnjascii [100] (a related result proved by Bennett [13]), though R. Kannan [78] later rediscovered this result. <p> Corollary 3.57 M 2 fl = lth, and M 2 = F lth. Though the linear time hierarchy equals the bounded arithmetic hierarchy, there is no known exact level-by-level result. The sharpest result we know is due to A. Woods <ref> [141] </ref>. If is a class of first order formulas, then N denotes the collection of predicates definable by a formula in . <p> Thus 0;0 is the collection of quantifier free formulas. In the following theorem, recall the definition of n time (T (n)) from Definition 2.8. Theorem 3.58 (A. Woods <ref> [141] </ref>) For m 1, N 0;m m+2 time (n). Sketch of Proof. The inclusion N 0;0 2 time (O (n)) is shown as follows. Given an atomic formula OE (n), suppose that all terms appearing in OE (n) are bounded by a polynomial in n.

References-found: 141

