URL: file://ftp.di.unipi.it/pub/Papers/giacobazzi/ic-oracle.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: barbuti@di.unipi.it  codish@bengus.bgu.ac.il  giaco@di.unipi.it  mjm@watson.ibm.com  
Title: Oracle Semantics for Prolog  
Author: Roberto Barbuti Michael Codish Roberto Giacobazzi and Michael J. Maher 
Address: Corso Italia 40, I-56125 Pisa, Italy  P.O. Box 653, Beer-Sheba, Israel  Corso Italia 40, I-56125 Pisa, Italy  P.O. Box 704, Yorktown Heights NY 10598  
Affiliation: Dipartimento di Informatica, Universita di Pisa  Department of Mathematics Computer Science Ben-Gurion University of the Negev  Dipartimento di Informatica, Universita di Pisa  IBM T.J. Watson Research Center  
Abstract-found: 0
Intro-found: 1
Reference: [Apt 90] <author> K. R. Apt. </author> <title> Introduction to logic programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: The standard reference works by Apt <ref> [Apt 90] </ref> and Lloyd [Lloyd 87] provide the necessary background material. Given a possibly infinite set X, we denote by X fl the set of finite sequences of symbols in X. The concatenation of sequences 1 and 2 is denoted 1 :: 2 . <p> If G f P G 0 with associated substitution #, then G# f P G 00 and G 00 ~ G 0 . Proof. By downward closure of the oracle, the proof boils down into the standard one for logic programs (e.g. see <ref> [Apt 90] </ref>). Lemma 4.4. Let P be a program and f be an oracle. If [C] ~ 2 lf p (U f P ) then lwr (f [C] ~ g) lf p (U f Proof.
Reference: [Apt, Bol and Klop 89] <author> K. R. Apt, R. N. Bol, and J. W. Klop. </author> <title> On the safe termination of Prolog programs. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Proceedings of the Sixth International Conference on Logic Programming, </booktitle> <pages> pages 353-368, </pages> <address> Lisbon, 1989. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: This approach results in simple and concise semantic definitions which are useful in proving properties of programs and in the context of semantic based techniques for analysis and debugging. By factoring the semantics into two components, we provide a semantic foundation to combine results on termination analysis (e.g. see <ref> [Apt, Bol and Klop 89] </ref>, [Apt and Pedreschi 93], [Smith, Genesereth and Ginsberg 86], [Verschaetse and De Schreye 91], and 23 G @ @ @ @ @ B B B B B B B B B | -z - prolog J J J J JJ f b f a slp leftmost
Reference: [Apt and van Emden 82] <author> K. R. Apt and M. H. van Emden. </author> <title> Contributions to the theory of logic programming. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <month> July </month> <year> 1982. </year>
Reference: [Apt and Pedreschi 93] <author> K. R. Apt and D. Pedreschi. </author> <title> Reasoning about termination of pure Prolog programs. </title> <journal> Information and Computation, </journal> <volume> 106(1) </volume> <pages> 109-157, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: By factoring the semantics into two components, we provide a semantic foundation to combine results on termination analysis (e.g. see [Apt, Bol and Klop 89], <ref> [Apt and Pedreschi 93] </ref>, [Smith, Genesereth and Ginsberg 86], [Verschaetse and De Schreye 91], and 23 G @ @ @ @ @ B B B B B B B B B | -z - prolog J J J J JJ f b f a slp leftmost infinite branch [De Schreye and
Reference: [Arbab and Berry 87] <author> B. Arbab and D. M. Berry. </author> <title> Operational and denotational semantics of Prolog. </title> <journal> The Journal of Logic Programming, </journal> <volume> 4(4) </volume> <pages> 309-330, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: For this reason the semantic definition of Prolog is usually given by encoding operational semantics in frameworks such as dynamic algebra [Borger 90], deterministic transition systems [de Bruin and de Vink 89], and denotational semantics [Jones and Mycroft 84], <ref> [Arbab and Berry 87] </ref>, and [Debray and Mishra 87]. In [Barbuti, Codish, Giacobazzi and Levi 92] a new approach to defining the semantics of 1 real logic programs is considered. Prolog control features are modeled in a constraint-based language called t belonging to the ask/tell paradigm of Saraswat [Saraswat 90].
Reference: [Barbuti, Codish, Giacobazzi and Levi 92] <author> R. Barbuti, M. Codish, R. Giacobazzi, and G. Levi. </author> <title> Modeling Prolog control. </title> <booktitle> In Proceedings of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 95-104, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: For this reason the semantic definition of Prolog is usually given by encoding operational semantics in frameworks such as dynamic algebra [Borger 90], deterministic transition systems [de Bruin and de Vink 89], and denotational semantics [Jones and Mycroft 84], [Arbab and Berry 87], and [Debray and Mishra 87]. In <ref> [Barbuti, Codish, Giacobazzi and Levi 92] </ref> a new approach to defining the semantics of 1 real logic programs is considered. Prolog control features are modeled in a constraint-based language called t belonging to the ask/tell paradigm of Saraswat [Saraswat 90]. <p> However, since we are interested to provide a semantic basis for the analysis of Prolog pro grams, for this purpose approximations of prolog both from above and from below can be useful. A similar argument has been considered in <ref> [Barbuti, Codish, Giacobazzi and Levi 92] </ref> and [Barbuti, Codish, Giacobazzi and Levi 93], which also provides a semantic basis for Prolog program analysis.
Reference: [Barbuti, Codish, Giacobazzi and Levi 93] <author> R. Barbuti, M. Codish, R. Giacobazzi, and G. Levi. </author> <title> Modeling Prolog control. </title> <journal> Journal of Logic and Computation, </journal> <volume> 3(6) </volume> <pages> 579-603, </pages> <year> 1993. </year>
Reference-contexts: However, since we are interested to provide a semantic basis for the analysis of Prolog pro grams, for this purpose approximations of prolog both from above and from below can be useful. A similar argument has been considered in [Barbuti, Codish, Giacobazzi and Levi 92] and <ref> [Barbuti, Codish, Giacobazzi and Levi 93] </ref>, which also provides a semantic basis for Prolog program analysis.
Reference: [Barbuti, Codish, Giacobazzi and Maher 92] <author> R. Barbuti, M. Codish, R. Giacobazzi, and M. J. Maher. </author> <title> Oracle semantics for Prolog. </title> <booktitle> In [Levi and Kirchner 92], </booktitle> <pages> pages 100-114. </pages>
Reference-contexts: We close with a short conclusion. For continuity and ease of readability, the proofs together with auxiliary lemmata, have been moved to the appendix. This paper is an extended and revised version of <ref> [Barbuti, Codish, Giacobazzi and Maher 92] </ref>: in particular the ideas of [Barbuti, Codish, Giacobazzi and Maher 92] are reported in Sections 3 and 4.1. 2 Preliminaries In the following we assume familiarity with the standard definitions and notation for logic programs. <p> We close with a short conclusion. For continuity and ease of readability, the proofs together with auxiliary lemmata, have been moved to the appendix. This paper is an extended and revised version of <ref> [Barbuti, Codish, Giacobazzi and Maher 92] </ref>: in particular the ideas of [Barbuti, Codish, Giacobazzi and Maher 92] are reported in Sections 3 and 4.1. 2 Preliminaries In the following we assume familiarity with the standard definitions and notation for logic programs. The standard reference works by Apt [Apt 90] and Lloyd [Lloyd 87] provide the necessary background material.
Reference: [Barbuti and Giacobazzi 92] <author> R. Barbuti and R. Giacobazzi. </author> <title> A bottom-up polymorphic type inference in logic programming. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 19(3) </volume> <pages> 281-313, </pages> <year> 1992. </year> <month> 36 </month>
Reference-contexts: Now, consider a simple semantic-based type analysis of the Prolog program P and query positive sum list (X,Y), like those proposed in <ref> [Barbuti and Giacobazzi 92] </ref>, [Pyo and Reddy 89], and [Kanomori and Horiuchi 88], which ignore Prolog's search strategy.
Reference: [Barbuti, Giacobazzi and Levi 93] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A general framework for semantics-based bottom-up abstract interpretation of logic programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 133-181, </pages> <year> 1993. </year>
Reference-contexts: We are motivated by the relative simplicity in constructing program analyses as abstractions of T P semantics, as proposed in <ref> [Barbuti, Giacobazzi and Levi 93] </ref> and [Codish, Dams and Yardeni 94]. We aim to provide a semantics basis for more precise program analyses by introducing specific control issues into the semantics, following the approach illustrated above for transition systems.
Reference: [Borger 90] <author> E. Borger. </author> <title> A logical operational semantics of full Prolog. </title> <editor> In E.Borger, H. Kleine, H. Buning, and M. Richter, editors, </editor> <booktitle> CSL 89. 3rd workshop on Computer Science Logic, volume 440 of Lecture Notes in Computer Science, </booktitle> <pages> pages 36-64. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: For this reason the semantic definition of Prolog is usually given by encoding operational semantics in frameworks such as dynamic algebra <ref> [Borger 90] </ref>, deterministic transition systems [de Bruin and de Vink 89], and denotational semantics [Jones and Mycroft 84], [Arbab and Berry 87], and [Debray and Mishra 87]. In [Barbuti, Codish, Giacobazzi and Levi 92] a new approach to defining the semantics of 1 real logic programs is considered.
Reference: [Bossi, Gabbrielli, Levi and Meo 94] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. Meo. </author> <title> A compositional semantics for logic programs. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 122(1-2):3-47, </address> <year> 1994. </year>
Reference-contexts: Declarative semantics with selection rules for logic programs are independently proposed also in [Gabbrielli and Meo 92], by considering the more general family of local selection rules. We follow the approach of <ref> [Bossi, Gabbrielli, Levi and Meo 94] </ref> which defines a bottom-up semantics in which interpretations consist of clauses instead of atoms. Each clause in an interpretation represents a partial computation from its head to its body. <p> This interpretation associates any goal G with the corresponding empty partial computations. As in <ref> [Bossi, Gabbrielli, Levi and Meo 94] </ref>, it is used to simplify the presentation of the semantics of partial computations given below. 4.1 Top-down unfolding-based oracle semantics The unfolding semantics mimics the operational semantics by a top-down construction in which a clause (h B; ) represents a partial computation from h to
Reference: [de Bruin and de Vink 89] <author> A. de Bruin and E. de Vink. </author> <title> Continuation semantics for Prolog with cut. </title> <editor> In J. Diaz and F. Orejas, editors, </editor> <booktitle> Proc. CAAP 89, volume 351 of Lecture Notes in Computer Science, </booktitle> <pages> pages 178-192. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference-contexts: For this reason the semantic definition of Prolog is usually given by encoding operational semantics in frameworks such as dynamic algebra [Borger 90], deterministic transition systems <ref> [de Bruin and de Vink 89] </ref>, and denotational semantics [Jones and Mycroft 84], [Arbab and Berry 87], and [Debray and Mishra 87]. In [Barbuti, Codish, Giacobazzi and Levi 92] a new approach to defining the semantics of 1 real logic programs is considered.
Reference: [Bruynooghe 91] <author> M. Bruynooghe. </author> <title> A practical framework for the abstract interpretation of logic programs. </title> <journal> The Journal of Logic Programming, 10(1,2,3 and </journal> 4):91-124, 1991. 
Reference-contexts: Now, consider a simple semantic-based type analysis of the Prolog program P and query positive sum list (X,Y), like those proposed in [Barbuti and Giacobazzi 92], [Pyo and Reddy 89], and [Kanomori and Horiuchi 88], which ignore Prolog's search strategy. Current implementations, such as those proposed in <ref> [Bruynooghe 91] </ref> and [Le Charlier and Van Hentenryck 94], easily detect that any answer for the call list of numbers (X) binds X to a list of numbers. However, a more accurate analysis based on a Prolog semantics could detect that clause (5) in the Prolog program is never applied.
Reference: [Le Charlier and Van Hentenryck 94] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental evaluation of a generic abstract interpretation algorithm for Prolog. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 35-101, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Current implementations, such as those proposed in [Bruynooghe 91] and <ref> [Le Charlier and Van Hentenryck 94] </ref>, easily detect that any answer for the call list of numbers (X) binds X to a list of numbers. However, a more accurate analysis based on a Prolog semantics could detect that clause (5) in the Prolog program is never applied.
Reference: [Codish, Dams and Yardeni 94] <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Bottom-up abstract interpretation of logic programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 124(1) </volume> <pages> 93-126, </pages> <year> 1994. </year>
Reference-contexts: We are motivated by the relative simplicity in constructing program analyses as abstractions of T P semantics, as proposed in [Barbuti, Giacobazzi and Levi 93] and <ref> [Codish, Dams and Yardeni 94] </ref>. We aim to provide a semantics basis for more precise program analyses by introducing specific control issues into the semantics, following the approach illustrated above for transition systems. The reader is reminded that proofs have been deferred to the appendix.
Reference: [Debray and Lin 91] <author> S. K. Debray and N.-W. Lin. </author> <title> Automatic complexity analysis of logic programs. </title> <booktitle> In [Furukawa 91], </booktitle> <pages> pages 599-613. </pages>
Reference-contexts: In this case we have lf p (U f b prolog P ), hence providing an approximation from below of the (Prolog) success set for P which can be useful for example in the context of the complexity analysis described in <ref> [Debray and Lin 91] </ref>; or to estimate a lower bound to the number of solutions of P . selection rule in which the left most infinite branch is indicated. The solutions for G correspond to the success branches of the entire tree.
Reference: [Debray and Mishra 87] <author> S. K. Debray and P. Mishra. </author> <title> Denotational and operational semantics for Prolog. </title> <editor> In M. Wirsing, editor, </editor> <booktitle> Formal Description of Programming Concepts III, </booktitle> <pages> pages 245-269. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1987. </year>
Reference-contexts: For this reason the semantic definition of Prolog is usually given by encoding operational semantics in frameworks such as dynamic algebra [Borger 90], deterministic transition systems [de Bruin and de Vink 89], and denotational semantics [Jones and Mycroft 84], [Arbab and Berry 87], and <ref> [Debray and Mishra 87] </ref>. In [Barbuti, Codish, Giacobazzi and Levi 92] a new approach to defining the semantics of 1 real logic programs is considered. Prolog control features are modeled in a constraint-based language called t belonging to the ask/tell paradigm of Saraswat [Saraswat 90].
Reference: [Debray and Warren 89] <author> S. K. Debray and D. S. Warren. </author> <title> Functional computations in logic programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(3) </volume> <pages> 451-481, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: However, the transformed program has a preferable behaviour as it does not diverge. Moreover it is deterministic and can be compiled more efficiently as described in <ref> [Debray and Warren 89] </ref>. The transformation described in this example can be viewed as transforming infinite failure into finite failure. Observe that similar transformations can be applied to introduce cuts to the predicates defining sum and add.
Reference: [De Schreye and Decorte 94] <author> D. De Schreye and S. Decorte. </author> <title> Termination of Logic Programs: the Never-Ending Story, </title> <journal> Journal of Logic Programming, </journal> <volume> 19 & 20 </volume> <pages> 199-260, </pages> <year> 1994. </year>
Reference-contexts: Approximation from below corresponds to the use of knowledge concerning definite (universal) termination of subgoals, whereas approximation from above corresponds to the use of knowledge concerning definite non-termination of subgoals. A survey of techniques for estab lishing termination and non-termination is given in <ref> [De Schreye and Decorte 94] </ref>. Example 5.5. In this example we consider approximations from below and above in the dataflow analysis of variable aliasing for a simple logic program. <p> Klop 89], [Apt and Pedreschi 93], [Smith, Genesereth and Ginsberg 86], [Verschaetse and De Schreye 91], and 23 G @ @ @ @ @ B B B B B B B B B | -z - prolog J J J J JJ f b f a slp leftmost infinite branch <ref> [De Schreye and Decorte 94] </ref>) with semantics-based analysis (e.g. abstract interpretation, type inference). We believe that the oracle approach is of general value in specifying the semantics of nondeterministic languages which are implemented in terms of a specific control strategy.
Reference: [Eder 85] <author> E. Eder. </author> <title> Properties of substitutions and unifications. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 1 </volume> <pages> 31-46, </pages> <year> 1985. </year>
Reference-contexts: It is well known that the mgu of a set of equations is unique up to renaming (see <ref> [Eder 85] </ref> and [Lassez, Maher, and Marriott 88]). Let # = fx 1 7! t 1 ; :::; x n 7! t n g be a substitution. We denote E (#) = fx 1 = t 1 ; :::; x n = t n g.
Reference: [van Emden and Kowalski 76] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: This construction abstracts away from operational aspects of the interpreter, for example answer substitutions, goal dependence and search strategy. Although declarative semantics can be specified in different frameworks, they are typically defined in terms of an immediate consequence operator such as the classic T P operator <ref> [van Emden and Kowalski 76] </ref>. While this approach captures the logical meaning of a program it does not adequately model one of the fundamental aspects of a logic program, namely its ability to compute substitutions.
Reference: [Falaschi, Levi, Martelli and Palamidessi 89] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative modeling of the operational behavior of logic languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year> <month> 37 </month>
Reference-contexts: While this approach captures the logical meaning of a program it does not adequately model one of the fundamental aspects of a logic program, namely its ability to compute substitutions. The work in <ref> [Falaschi, Levi, Martelli and Palamidessi 89] </ref> and [Falaschi, Levi, Martelli and Palamidessi 93] fills this gap by proposing a declarative semantics for logic programs that makes explicit the correspondence between computed answer substitutions and declarative meaning (model-theoretic and fixpoint) of the programs. <p> It is easy to see that slp is downward-closed and sound and complete with respect to unfolding. The declarative semantics defined as the set of most general answers in ff (lf p (T slp P )) corresponds precisely to the semantics in <ref> [Falaschi, Levi, Martelli and Palamidessi 89] </ref> of computed answer substitutions. This equivalence is based on the observation that in slp-computations the Lifting Lemma holds [Lloyd 87]; i.e. it cannot be the case that a clause is not applicable while some of its instantiations are.
Reference: [Falaschi, Levi, Martelli and Palamidessi 93] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A model-theoretic reconstruction of the operational semantics of logic programs. </title> <journal> Information and Computation, </journal> <volume> 102(1) </volume> <pages> 86-113, </pages> <year> 1993. </year>
Reference-contexts: While this approach captures the logical meaning of a program it does not adequately model one of the fundamental aspects of a logic program, namely its ability to compute substitutions. The work in [Falaschi, Levi, Martelli and Palamidessi 89] and <ref> [Falaschi, Levi, Martelli and Palamidessi 93] </ref> fills this gap by proposing a declarative semantics for logic programs that makes explicit the correspondence between computed answer substitutions and declarative meaning (model-theoretic and fixpoint) of the programs. The idea is to enhance the semantic domain by introducing variables to the Herbrand Universe.
Reference: [Furukawa 91] <editor> K. Furukawa, editor. </editor> <booktitle> Proceedings of the Eighth International Conference on Logic Programming, </booktitle> <address> Paris, France, 1991. </address> <publisher> The MIT Press. </publisher>
Reference: [Gabbrielli and Meo 92] <author> M. Gabbrielli and M. C. Meo. </author> <title> Fixpoint semantics for partial computed answer substitutions and call patterns. </title> <booktitle> In Levi and Kirchner [Levi and Kirchner 92], </booktitle> <pages> pages 84-99. </pages>
Reference-contexts: This facilitates the specification of both logic and control in a similar approach. As partial computations are dependent on the selection rule, we assume a left-to-right selection rule in what follows. Declarative semantics with selection rules for logic programs are independently proposed also in <ref> [Gabbrielli and Meo 92] </ref>, by considering the more general family of local selection rules. We follow the approach of [Bossi, Gabbrielli, Levi and Meo 94] which defines a bottom-up semantics in which interpretations consist of clauses instead of atoms.
Reference: [Gaifman, Maher and Shapiro 91] <author> H. Gaifman, M. J. Maher and E. Shapiro. </author> <title> Replay, Recovery, Replication and Snapshots of Nondeterministic Concurrent Programs, </title> <booktitle> Proceedings of the ACM Symposium on Principles of Distributed Computation, </booktitle> <year> 1991. </year>
Reference-contexts: Proposition 4.1 (~-congruence). Let f be a downward closed oracle for a program. Then, for any interpretation I and goals G; G 0 : G ~ G 0 ) f (I; G) = f (I; G 0 ). The following property is similar to properties of stability <ref> [Gaifman, Maher and Shapiro 91] </ref> and monotonicity [Saraswat, Weinbaum, Kahn and Shapiro 88] in relation to concurrent languages. 12 Proposition 4.2. Let P be a program and f be a downward closed oracle for P .
Reference: [Griswold 93] <author> R. E. Griswold. </author> <title> The evaluation of expressions in Icon, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(4) </volume> <pages> 563-584, </pages> <year> 1993. </year>
Reference-contexts: They include constraint logic programming languages [Jaffar and Lassez 87, Jaffar and Maher 94], set-based languages [Jayaraman 92], and equational languages [Jayaraman 89], among others. The technique also applies to a subset of the string processing languages SNOBOL [Griswold, Poage and Polonsky 71] and Icon <ref> [Griswold 93] </ref>. However it does not apply to the full languages, nor to full Prolog, because of the existence of constructs which allow the execution of one branch to affect another (non-backtrackable assignment in SNOBOL and Icon, assert and retract in full Prolog).
Reference: [Griswold, Poage and Polonsky 71] <author> R. E. Griswold, J. F. Poage and I. P. Polonsky. </author> <title> The SNOBOL4 Programming Language, </title> <publisher> Prentice-Hall, </publisher> <year> 1971. </year>
Reference-contexts: They include constraint logic programming languages [Jaffar and Lassez 87, Jaffar and Maher 94], set-based languages [Jayaraman 92], and equational languages [Jayaraman 89], among others. The technique also applies to a subset of the string processing languages SNOBOL <ref> [Griswold, Poage and Polonsky 71] </ref> and Icon [Griswold 93]. However it does not apply to the full languages, nor to full Prolog, because of the existence of constructs which allow the execution of one branch to affect another (non-backtrackable assignment in SNOBOL and Icon, assert and retract in full Prolog).
Reference: [Haridi and Janson 90] <author> S. Haridi and S. Janson. </author> <title> Kernel Andorra Prolog and its computation model. </title> <editor> In David H. D. Warren and Peter Szeredi, editors, </editor> <booktitle> Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <pages> pages 31-46, </pages> <address> Jerusalem, 1990. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: There remain open questions whether and/or how the oracle approach can be applied to other aspects of control in logic programming languages such as negation-as-failure, once and cut in Prolog; dynamic scheduling as in MU-Prolog [Naish 86] and languages based on the Andorra principle <ref> [Haridi and Janson 90] </ref>); and extra-logical predicates such as var and nonvar in various logic languages. Finally, we note that our approach may contribute to the derivation of parallel implementations (e.g. of Prolog).
Reference: [Jaffar and Lassez 87] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint Logic Programming, </title> <booktitle> Proc. 14th ACM Symposium on Principles of Programming Languages, Munich (January 1987), </booktitle> <pages> 111-119. </pages>
Reference-contexts: Similarly, the technique applies to grammar formalisms, where the top-down and bottom-up semantics correspond to parsing and sentence generation respectively. Of greater practical interest are current implemented languages to which this technique applies. They include constraint logic programming languages <ref> [Jaffar and Lassez 87, Jaffar and Maher 94] </ref>, set-based languages [Jayaraman 92], and equational languages [Jayaraman 89], among others. The technique also applies to a subset of the string processing languages SNOBOL [Griswold, Poage and Polonsky 71] and Icon [Griswold 93].
Reference: [Jaffar and Maher 94] <author> J. Jaffar and M. J. Maher. </author> <title> Constraint Logic Programming: A Survey, </title> <journal> Journal of Logic Programming, </journal> <volume> 19 & 20 </volume> <pages> 503-581, </pages> <year> 1994. </year>
Reference-contexts: Similarly, the technique applies to grammar formalisms, where the top-down and bottom-up semantics correspond to parsing and sentence generation respectively. Of greater practical interest are current implemented languages to which this technique applies. They include constraint logic programming languages <ref> [Jaffar and Lassez 87, Jaffar and Maher 94] </ref>, set-based languages [Jayaraman 92], and equational languages [Jayaraman 89], among others. The technique also applies to a subset of the string processing languages SNOBOL [Griswold, Poage and Polonsky 71] and Icon [Griswold 93].
Reference: [Jayaraman 89] <author> B. Jayaraman. Eql: </author> <title> The Language and Its Implementation, </title> <journal> IEEE Transactions on Software Engineering 15(6) </journal> <pages> 771-779, </pages> <year> 1989. </year>
Reference-contexts: Of greater practical interest are current implemented languages to which this technique applies. They include constraint logic programming languages [Jaffar and Lassez 87, Jaffar and Maher 94], set-based languages [Jayaraman 92], and equational languages <ref> [Jayaraman 89] </ref>, among others. The technique also applies to a subset of the string processing languages SNOBOL [Griswold, Poage and Polonsky 71] and Icon [Griswold 93].
Reference: [Jayaraman 92] <author> B. Jayaraman. </author> <title> Implementation of Subset-Equational Programs, </title> <journal> Journal of Logic Programming 12(4) </journal> <pages> 299-324, </pages> <year> 1992. </year>
Reference-contexts: Similarly, the technique applies to grammar formalisms, where the top-down and bottom-up semantics correspond to parsing and sentence generation respectively. Of greater practical interest are current implemented languages to which this technique applies. They include constraint logic programming languages [Jaffar and Lassez 87, Jaffar and Maher 94], set-based languages <ref> [Jayaraman 92] </ref>, and equational languages [Jayaraman 89], among others. The technique also applies to a subset of the string processing languages SNOBOL [Griswold, Poage and Polonsky 71] and Icon [Griswold 93].
Reference: [Jones and Mycroft 84] <author> N. D. Jones and A. Mycroft. </author> <title> Stepwise development of operational and denotational semantics for Prolog. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming, </booktitle> <pages> pages 281-288, </pages> <address> Atlantic City, 1984. </address> <publisher> IEEE, Computer Society Press. </publisher>
Reference-contexts: For this reason the semantic definition of Prolog is usually given by encoding operational semantics in frameworks such as dynamic algebra [Borger 90], deterministic transition systems [de Bruin and de Vink 89], and denotational semantics <ref> [Jones and Mycroft 84] </ref>, [Arbab and Berry 87], and [Debray and Mishra 87]. In [Barbuti, Codish, Giacobazzi and Levi 92] a new approach to defining the semantics of 1 real logic programs is considered.
Reference: [Kanomori and Horiuchi 88] <author> T. Kanomori and K. Horiuchi. </author> <title> Polymorphic type inference in pro-log by abstract interpretation. </title> <booktitle> In Logic Programming 87- Tokyo, volume 315 of Lecture Notes in Computer Science, </booktitle> <pages> pages 195-214. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year>
Reference-contexts: Now, consider a simple semantic-based type analysis of the Prolog program P and query positive sum list (X,Y), like those proposed in [Barbuti and Giacobazzi 92], [Pyo and Reddy 89], and <ref> [Kanomori and Horiuchi 88] </ref>, which ignore Prolog's search strategy. Current implementations, such as those proposed in [Bruynooghe 91] and [Le Charlier and Van Hentenryck 94], easily detect that any answer for the call list of numbers (X) binds X to a list of numbers.
Reference: [Lassez, Maher, and Marriott 88] <author> J.-L. Lassez, M. J. Maher, and K. Marriott. </author> <title> Unification revisited. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 587-625. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year> <month> 38 </month>
Reference-contexts: This is because the difference between unification and equation solving is only a matter of representation <ref> [Lassez, Maher, and Marriott 88] </ref>. An equation has the form t = u where t; u are syntactic objects and = is interpreted as syntactic equality. Given a set E of equations, E is unifiable iff there exists # such that for each (t = u) 2 E, (t#) (u#). <p> It is well known that the mgu of a set of equations is unique up to renaming (see [Eder 85] and <ref> [Lassez, Maher, and Marriott 88] </ref>). Let # = fx 1 7! t 1 ; :::; x n 7! t n g be a substitution. We denote E (#) = fx 1 = t 1 ; :::; x n = t n g. <p> We denote E (#) = fx 1 = t 1 ; :::; x n = t n g. For non-trivial Herbrand universes, # = mgu (E) iff E has the same solutions as E (#) (denoted E (#) E) <ref> [Lassez, Maher, and Marriott 88] </ref>. 3 Operational oracle semantics This section presents an operational semantics for logic programs defined in terms of transition systems. The semantics is standard except for the fact that an oracle is introduced providing a uniform approach to capture different control strategies.
Reference: [Lever 91] <author> J. M. Lever. </author> <title> Proving program properties by means of SLS-resolution. </title> <booktitle> In Furukawa [Furukawa 91], </booktitle> <pages> pages 614-628. </pages>
Reference-contexts: Moreover, approximations of Prolog semantics are derived by determining that a given clause is not chosen (for a given goal) by the Prolog oracle. This boils down to determining that a corresponding computation tree is infinite. This is similar to 8 the proposal described in <ref> [Lever 91] </ref> to reason about SLS resolution [Przymusinski 89] applying loop-checking techniques. Some applications in dataflow analysis will be discussed in Section 5. Example 3.1. Consider the program P from Example 1.1 and the goal positive list sum (X; Y). The Prolog computation tree is illustrated in Figure 2.
Reference: [Levi 88] <author> G. Levi. </author> <title> Models, unfolding rules and fixpoint semantics. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1649-1665, </pages> <address> Seattle, 1988. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: In order to specify the oracle from within the semantics we enhance the semantic objects to capture also partial computations and derivation paths. Our approach is based on the observation that both top-down and bottom-up semantics of logic programs can be expressed in terms of program unfolding <ref> [Levi 88] </ref>. Section 4.1 introduces a top-down unfolding semantics for logic programs with oracles. Later, in Section 4.3, a bottom-up unfolding semantics is introduced by allowing the same oracle to be applied in the process of unfolding, in a "reversed way".
Reference: [Levi and Kirchner 92] <editor> G. Levi and H. Kirchner, editors. </editor> <booktitle> Algebraic and Logic Programming, Third International Conference, LNCS 632, Volterra, </booktitle> <address> Italy, September 2-4, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference: [Lloyd 87] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2 nd edition, </address> <year> 1987. </year>
Reference-contexts: The standard reference works by Apt [Apt 90] and Lloyd <ref> [Lloyd 87] </ref> provide the necessary background material. Given a possibly infinite set X, we denote by X fl the set of finite sequences of symbols in X. The concatenation of sequences 1 and 2 is denoted 1 :: 2 . <p> The substitution ' is referred to as the associated substitution of the transition G lp The standard notion of a computation tree for an initial goal G and a program P is captured by T ( P ; G). Definition 3.5 is often refined (e.g. <ref> [Lloyd 87] </ref>) by introducing a selection rule on the atoms in a state. In particular, Prolog assumes a left-to-right selection rule. In addition logic programming languages typically introduce a control strategy to specify which clauses should be applied to the selected atom. <p> Let P be a program and f be a downward closed oracle for P . If G f P G 0 with associated substitution #, then G# f P G 00 and G 00 ~ G 0 . The converse (i.e. Lifting Lemma 8.2 in <ref> [Lloyd 87] </ref>) may not hold (e.g. for the Prolog oracle), as shown in the following example: Example 4.1. Consider the following Prolog program P : p (s (x)) p (x). While the goal p (0) succeeds in a Prolog transition system semantics, p (x) does not. <p> The declarative semantics defined as the set of most general answers in ff (lf p (T slp P )) corresponds precisely to the semantics in [Falaschi, Levi, Martelli and Palamidessi 89] of computed answer substitutions. This equivalence is based on the observation that in slp-computations the Lifting Lemma holds <ref> [Lloyd 87] </ref>; i.e. it cannot be the case that a clause is not applicable while some of its instantiations are. Thus, applying all the instances (by lwr) of a clause and taking the most general computations corresponds to simply applying the clause itself. <p> Consider the Prolog program P : p (a,b). % (1) p (x,y) p (y,x). % (3) This program is used by Lloyd <ref> [Lloyd 87] </ref> to illustrate the incompleteness of Prolog's search strategy. The claim is that: "no matter how the clauses of P are ordered and no matter what the computation rule, a depth-first search with fixed order of program clauses will never find a solution for p (a; c)". <p> Because clauses (3) and (4) have completely general heads, they match with any partial computation. Thus if (3) is before (4) in the program, the system will never consider (4) and viceversa <ref> [Lloyd 87] </ref>. This behaviour is captured in our semantics construction.
Reference: [Maher and Ramakrishnan 89] <author> M. J. Maher and R. Ramakrishnan. </author> <title> Deja Vu in Fixpoints of Logic Programs, </title> <booktitle> Proc. North American Conference on Logic Programming, </booktitle> <address> Cleveland, Oc-tober, </address> <year> 1989, </year> <pages> pages 963-980. </pages>
Reference-contexts: Thus, applying all the instances (by lwr) of a clause and taking the most general computations corresponds to simply applying the clause itself. Similarly, the multiset semantics of <ref> [Maher and Ramakrishnan 89] </ref> computed by NSN evaluation can be extracted from lf p (T P ). 5.2 The oracle for Prolog The Prolog oracle is defined, as in the operational case, in terms of the logic programming semantics with left-to-right selection.
Reference: [Naish 86] <author> L. Naish. </author> <title> Negation and Control in Prolog, </title> <booktitle> volume 238 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: There remain open questions whether and/or how the oracle approach can be applied to other aspects of control in logic programming languages such as negation-as-failure, once and cut in Prolog; dynamic scheduling as in MU-Prolog <ref> [Naish 86] </ref> and languages based on the Andorra principle [Haridi and Janson 90]); and extra-logical predicates such as var and nonvar in various logic languages. Finally, we note that our approach may contribute to the derivation of parallel implementations (e.g. of Prolog).
Reference: [Palamidessi 90] <author> C. Palamidessi. </author> <title> Algebraic properties of idempotent substitutions. </title> <editor> In M. S. Paterson, editor, </editor> <booktitle> Proceedings of the 17th International Colloquium on Automata, Languages and Programming, volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 386-399. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference: [Przymusinski 89] <author> T. Przymusinski. </author> <title> On the declarative and procedural semantics of logic programs. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(2) </volume> <pages> 201-228, </pages> <year> 1989. </year>
Reference-contexts: This boils down to determining that a corresponding computation tree is infinite. This is similar to 8 the proposal described in [Lever 91] to reason about SLS resolution <ref> [Przymusinski 89] </ref> applying loop-checking techniques. Some applications in dataflow analysis will be discussed in Section 5. Example 3.1. Consider the program P from Example 1.1 and the goal positive list sum (X; Y). The Prolog computation tree is illustrated in Figure 2.
Reference: [Pyo and Reddy 89] <author> C. Pyo and U. S. Reddy. </author> <title> Inference of Polymorphic Types for Logic Programs. </title> <editor> In Ewing L. Lusk and Ross A. Overbeek, editors, </editor> <booktitle> Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pages 1115-1134, </pages> <address> Cleveland, Ohio, USA, </address> <year> 1989. </year>
Reference-contexts: Now, consider a simple semantic-based type analysis of the Prolog program P and query positive sum list (X,Y), like those proposed in [Barbuti and Giacobazzi 92], <ref> [Pyo and Reddy 89] </ref>, and [Kanomori and Horiuchi 88], which ignore Prolog's search strategy. Current implementations, such as those proposed in [Bruynooghe 91] and [Le Charlier and Van Hentenryck 94], easily detect that any answer for the call list of numbers (X) binds X to a list of numbers.
Reference: [Saraswat 90] <author> V. A. Saraswat. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proceedings of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: In [Barbuti, Codish, Giacobazzi and Levi 92] a new approach to defining the semantics of 1 real logic programs is considered. Prolog control features are modeled in a constraint-based language called t belonging to the ask/tell paradigm of Saraswat <ref> [Saraswat 90] </ref>. A transformation from Prolog to t is defined to describe the meaning of a Prolog program P in terms of the declarative semantics of the corresponding t -program. Ask constraints are used to specify the conditions for a clause to be chosen for reduction.
Reference: [Saraswat, Weinbaum, Kahn and Shapiro 88] <author> V. A. Saraswat, D. Weinbaum, K. Kahn and E. Shapiro. </author> <title> Detecting stable properties of networks in concurrent logic programming languages. </title> <booktitle> Proceedings of the ACM Symposium PODC , 1988. </booktitle>
Reference-contexts: Then, for any interpretation I and goals G; G 0 : G ~ G 0 ) f (I; G) = f (I; G 0 ). The following property is similar to properties of stability [Gaifman, Maher and Shapiro 91] and monotonicity <ref> [Saraswat, Weinbaum, Kahn and Shapiro 88] </ref> in relation to concurrent languages. 12 Proposition 4.2. Let P be a program and f be a downward closed oracle for P .
Reference: [Smith, Genesereth and Ginsberg 86] <author> D. E. Smith, M. R. Genesereth, and M. L. Ginsberg. </author> <title> Controlling recursive inference. </title> <journal> Artificial Intellingence, </journal> <volume> 30 </volume> <pages> 343-389, </pages> <year> 1986. </year>
Reference-contexts: By factoring the semantics into two components, we provide a semantic foundation to combine results on termination analysis (e.g. see [Apt, Bol and Klop 89], [Apt and Pedreschi 93], <ref> [Smith, Genesereth and Ginsberg 86] </ref>, [Verschaetse and De Schreye 91], and 23 G @ @ @ @ @ B B B B B B B B B | -z - prolog J J J J JJ f b f a slp leftmost infinite branch [De Schreye and Decorte 94]) with semantics-based
Reference: [Sterling and Shapiro 86] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: Different notions of control are specified by different choices of oracles. In particular we focus on an oracle for pure Prolog. A pure Prolog program is a logic program in which an order is fixed for both clauses and goals in the body of clauses <ref> [Sterling and Shapiro 86] </ref>. Its meaning can be obtained by combining leftmost selection rule and sequential search for unifiable clauses. While the selection rule can easily be specified within the semantics, the specification of sequential search is done by an oracle.
Reference: [Vasak and Potter 86] <author> T. Vasak and J. Potter. </author> <title> Characterisation of terminating logic programs. </title> <booktitle> In Symposium on Logic Programming, </booktitle> <pages> pages 140-147. </pages> <publisher> IEEE Computer Society, The Computer Society Press, </publisher> <month> September </month> <year> 1986. </year>
Reference-contexts: It is straightforward to show that the Prolog computation tree for a goal G and program P ` terminates universally iff T ( slp P ; G) terminates universally <ref> [Vasak and Potter 86] </ref>. Furthermore, by Konig's Lemma, T ( slp P ; G) terminates universally iff it is finite because slp ! P has finite branching. Hence, Definition 3.8 (Prolog oracle). Let P be a logic program ordered textually by ` and G a goal.
Reference: [Verschaetse and De Schreye 91] <author> K. Verschaetse and D. De Schreye. </author> <title> Deriving termination proofs for logic programs, using abstract procedures. </title> <booktitle> In [Furukawa 91], </booktitle> <pages> pages 301-315. 39 </pages>
Reference-contexts: By factoring the semantics into two components, we provide a semantic foundation to combine results on termination analysis (e.g. see [Apt, Bol and Klop 89], [Apt and Pedreschi 93], [Smith, Genesereth and Ginsberg 86], <ref> [Verschaetse and De Schreye 91] </ref>, and 23 G @ @ @ @ @ B B B B B B B B B | -z - prolog J J J J JJ f b f a slp leftmost infinite branch [De Schreye and Decorte 94]) with semantics-based analysis (e.g. abstract interpretation, type
References-found: 52

