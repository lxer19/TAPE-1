URL: http://www.cs.wisc.edu/~navin/research/opt++.ps
Refering-URL: http://www.cs.wisc.edu/shore/shore.papers.html
Root-URL: 
Email: fnavin, dewittg@cs.wisc.edu  
Title: OPT++ An Object-Oriented Implementation for Extensible Database Query Optimization  
Author: Navin Kabra David J. DeWitt 
Date: 323  
Note: Paper Number  
Address: Wisconsin, Madison  
Affiliation: Computer Sciences Department University of  
Abstract: In this paper we describe the design and implementation of OPT++, a tool for Extensible Database Query Optimization that uses an object-oriented design to simplify the task of implementing, extending, and modifying an optimizer. Building an optimizer using OPT++ makes it easy to extend the query algebra (to add new query algebra operators and physical implementation algorithms to the system), easy to change the search space explored, and also easy to change the search strategy used. Furthermore, OPT++ comes equipped with a number of search strategies that are available for use by an Optimizer-Implementor. OPT++ considerably simplifies both, the task of implementing an optimizer for a new database system, and the task of experimenting with various optimization techniques and strategies to decide what techniques are best suited for that database system. We present the results of performance studies which validate our design and show that, in spite of its flexibility, OPT++ can be used to build efficient optimizers. 
Abstract-found: 1
Intro-found: 1
Reference: [BMG93] <author> Jose A. Blakeley, William J. McKenna, and Goetz Graefe. </author> <title> "Experiences Building the Open OODB Query Optimizer". </title> <booktitle> In Proceedings of the 1993 ACM-SIGMOD Conference, </booktitle> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The new algebra allows reference-valued attributes, set-valued attributes, and the use of path-indices. We extended the optimizer to implement the optimization techniques described in <ref> [BMG93] </ref>. We added a Materialize query algebra operator that represents materialization of a reference-valued attribute (in other words, dereferencing a pointer). A corresponding Assembly algorithm class is used to represent the physical execution algorithm used to implement Materialize [KGM91]. <p> For example, if a path-index exists on city.mayor.name, the predicate city.mayor.name = "Lee" can be evaluated without having to materialize the city or mayor objects (see <ref> [BMG93] </ref> for details). A new PathIndexSelect algorithm was derived from the Algorithm class to capture such path-index scans. <p> The implementation is very similar to the scheme described in <ref> [BMG93] </ref>. 7 In the next section we shall see that a switch from the Transformative strategy to one of the Randomized strategies is much easier than this. 22 4.4 Randomized Strategies Finally, we modified the transformative optimizer to use the randomized search strategies available with OPT++.
Reference: [FG91] <author> Beatrice Finance and Georges Gardarin. </author> <title> "A Rule Based Query Rewriter in an Extensible DBMS". </title> <booktitle> In Proceedings of the 7th International Conference on Data Engineering. IEEE, </booktitle> <year> 1991. </year>
Reference-contexts: Most optimizers that allow extensibility of the query algebra propose some form of a rule-based system that uses rewrite rules to describe transformations that can be performed to optimize a query expression <ref> [Fre87, Gra87, PHH92, FG91] </ref>. These systems usually offer a more-or-less fixed search strategy that is difficult to modify or extend. Freytag [Fre87] describes an architecture in which the translation of a query into an executable plan is completely based on rules.
Reference: [Fre87] <author> Johann Christoph Freytag. </author> <title> "A Rule-Based View of Query Optimization". </title> <booktitle> In Proceedings of the 1987 ACM-SIGMOD Conference, </booktitle> <address> San Francisco, Californai, </address> <month> May </month> <year> 1987. </year> <month> 25 </month>
Reference-contexts: Most optimizers that allow extensibility of the query algebra propose some form of a rule-based system that uses rewrite rules to describe transformations that can be performed to optimize a query expression <ref> [Fre87, Gra87, PHH92, FG91] </ref>. These systems usually offer a more-or-less fixed search strategy that is difficult to modify or extend. Freytag [Fre87] describes an architecture in which the translation of a query into an executable plan is completely based on rules. <p> These systems usually offer a more-or-less fixed search strategy that is difficult to modify or extend. Freytag <ref> [Fre87] </ref> describes an architecture in which the translation of a query into an executable plan is completely based on rules. He describes a System-R style optimizer that can be built using various sets of rules. One set of rules is used to convert the query into an algebraic tree.
Reference: [GD87] <author> G. Graefe and D. J. DeWitt. </author> <title> "The EXODUS Optimizer Generator". </title> <booktitle> In Proceedings of the 1987 ACM-SIGMOD Conference, </booktitle> <address> San Francisco, California, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: While this approach is well suited for access method and join enumeration, it is not clear how this can be used to optimize queries containing non-relational operators and complicated transformations. The optimizers generated by the Exodus Optimizer Generator <ref> [GD87] </ref> and the Volcano Optimizer Generator [GM93] use algebraic equivalence rules to transform an operator tree for a query into other, equivalent operator trees, and use implementation rules to determine what algorithms are used to implement the various operators.
Reference: [GM93] <author> G. Graefe and W. J. McKenna. </author> <title> "The Volcano Optimizer Generator: Extensibility and Efficient Search". </title> <booktitle> In Proc. IEEE Conf. on Data Eng., </booktitle> <address> Vienna, Austria, </address> <year> 1993. </year>
Reference-contexts: While this approach is well suited for access method and join enumeration, it is not clear how this can be used to optimize queries containing non-relational operators and complicated transformations. The optimizers generated by the Exodus Optimizer Generator [GD87] and the Volcano Optimizer Generator <ref> [GM93] </ref> use algebraic equivalence rules to transform an operator tree for a query into other, equivalent operator trees, and use implementation rules to determine what algorithms are used to implement the various operators. <p> The purpose of these algorithms is not to perform any logical data manipulation but to enforce physical properties in their outputs that are required for subsequent query processing algorithms. These are referred to as enforcers in the Volcano Optimizer Generator <ref> [GM93] </ref>, and are comparable to the glue operators in Starburst [LFL88]. Classes corresponding to such enforcers should also be derived from the Algorithm class. <p> We describe below the various search strategies that are currently implemented in OPT++. The "Bottom-up" search strategy is similar to the one used by the System-R optimizer [SAC + 79]. The "Transformative" search strategy is based upon the search engine of the Volcano Optimizer Generator <ref> [GM93] </ref>. Finally, three randomized search strategies, Iterated Improvement [SG88], Simulated Annealing [IW87], and Two Phase Optimization [IK90], have been implemented. 3.4.1 The Bottom-up Search Strategy This search strategy can be used to implement optimizers that use bottom-up dynamic-programming similar to the System-R optimizer [SAC + 79]. <p> The procedure for generation of access plans corresponding to an operator tree, and for their pruning is similar to that used in the bottom-up search strategy. Note that our TreeToPlanGenerator classes are analogous to the implementation rules of the Volcano Optimizer Generator <ref> [GM93] </ref>. Optimization is complete when none of the existing operator trees can be further transformed. 16 3.4.3 Randomized Search Strategies In this section, we briefly describe the implementation of the randomized search strategies in OPT++. <p> This was done with the intention of illustrating the ease of use and extensibility of OPT++. We also report on some performance studies including a performance comparison with an optimizer generated using the Volcano Optimizer Generator <ref> [GM93] </ref> to show that, in spite of its flexibility, OPT++ is efficient. 4.1 Join Enumeration In this section we consider a simple relational optimizer that does System-R style join enumeration, and describe how it was easily extended to consider the space of bushy join trees, and also to consider cartesian products.
Reference: [Gra87] <author> Goetz Graefe. </author> <title> "Rule-Based Query Optimization in Extensible Database Systems". </title> <type> PhD thesis, </type> <institution> Uni versity of Wisconsin-Madison, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: Most optimizers that allow extensibility of the query algebra propose some form of a rule-based system that uses rewrite rules to describe transformations that can be performed to optimize a query expression <ref> [Fre87, Gra87, PHH92, FG91] </ref>. These systems usually offer a more-or-less fixed search strategy that is difficult to modify or extend. Freytag [Fre87] describes an architecture in which the translation of a query into an executable plan is completely based on rules.
Reference: [Hel94] <author> Joseph M. Hellerstein. </author> <title> "Practical Predicate Placement". </title> <booktitle> In Proceedings of the 1994 ACM-SIGMOD Conference, </booktitle> <address> Minneapolis, Minnesota, </address> <month> May </month> <year> 1994. </year>
Reference: [HP88] <author> Waqar Hasan and Hamid Pirahesh. </author> <title> "Query Rewrite Optimization in Starburst". </title> <type> Research Report RJ 6367 (62349), </type> <institution> IBM, </institution> <year> 1988. </year>
Reference-contexts: One set of rules is used to convert the query into an algebraic tree. Other sets of rules are used to generate access paths, join orderings, and join methods in that order. The optimizer developed as a part of the Starburst project <ref> [LFL88, HP88] </ref> uses a two step process to optimize queries. The first phase uses a set of production rules to transform the query heuristically into an equivalent new query that (hopefully) offers both faster execution than the old query and is better suited for cost-based optimization.
Reference: [IK90] <author> Yannis E. Ioannidis and Younkyung Cha Kang. </author> <title> "Randomized Algorithms for Optimizing Large Join Queries". </title> <booktitle> In Proceedings of the 1990 ACM-SIGMOD Conference, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: The "Bottom-up" search strategy is similar to the one used by the System-R optimizer [SAC + 79]. The "Transformative" search strategy is based upon the search engine of the Volcano Optimizer Generator [GM93]. Finally, three randomized search strategies, Iterated Improvement [SG88], Simulated Annealing [IW87], and Two Phase Optimization <ref> [IK90] </ref>, have been implemented. 3.4.1 The Bottom-up Search Strategy This search strategy can be used to implement optimizers that use bottom-up dynamic-programming similar to the System-R optimizer [SAC + 79]. The InitialTreeGenerator is invoked to initialize the collection of operator trees. <p> We compared the performance of all the different search strategies in terms of the time taken to optimize randomly generated queries of increasing sizes, and the quality of the plans produced. The stopping conditions and other parameters for the randomized search strategies were as described in <ref> [IK90] </ref>. Figures 21 and 22 show the performance results obtained. <p> They also confirm the findings of <ref> [IK90] </ref> that Two Phase Optimization performs better than Simulated Annealing or Iterated Improvement. In Figure 23, the memory requirements of the different strategies are presented.
Reference: [IW87] <author> Yannis E. Ioannidis and Eugene Wong. </author> <title> "Query Optimization by Simulated Annealing". </title> <booktitle> In Proceedings of the 1987 ACM-SIGMOD Conference, </booktitle> <address> San Francisco, California, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: The "Bottom-up" search strategy is similar to the one used by the System-R optimizer [SAC + 79]. The "Transformative" search strategy is based upon the search engine of the Volcano Optimizer Generator [GM93]. Finally, three randomized search strategies, Iterated Improvement [SG88], Simulated Annealing <ref> [IW87] </ref>, and Two Phase Optimization [IK90], have been implemented. 3.4.1 The Bottom-up Search Strategy This search strategy can be used to implement optimizers that use bottom-up dynamic-programming similar to the System-R optimizer [SAC + 79]. The InitialTreeGenerator is invoked to initialize the collection of operator trees.
Reference: [Kan91] <author> Younkyung Cha Kang. </author> <title> "Randomized Algorithms for Query Optimization". </title> <type> Technical Report TR 1053, </type> <institution> Computer Sciences Department, University of Wisconsin-Madison, </institution> <year> 1991. </year>
Reference-contexts: The stopping conditions and other parameters for the randomized search strategies were as described in [IK90]. Figures 21 and 22 show the performance results obtained. Qualitatively, they confirm the findings of <ref> [Kan91] </ref> that for smaller queries the exhaustive algorithms consume much less time for optimization than the randomized algorithms and yet produce equivalent or better plans, while for larger queries, the randomized algorithms take much less time to find plans that are almost as good as those found by the exhaustive algorithms.
Reference: [KGM91] <author> Tom Keller, Goetz Graefe, and David Maier. </author> <title> "Efficient Assembly of Complex Objects". </title> <booktitle> In Proceedings of the 1991 ACM-SIGMOD Conference, </booktitle> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: We extended the optimizer to implement the optimization techniques described in [BMG93]. We added a Materialize query algebra operator that represents materialization of a reference-valued attribute (in other words, dereferencing a pointer). A corresponding Assembly algorithm class is used to represent the physical execution algorithm used to implement Materialize <ref> [KGM91] </ref>. An Unnest operator class and the corresponding UnnestAlgorithm class is used to represent unnesting of set-valued attributes. The MaterializeExpand class derived from the TreeToTreeGenerator class takes an operator tree and expands it by adding a materialize operation that dereferences a reference-valued attribute present in its input.
Reference: [KMP93] <author> Alfons Kemper, Guido Moerkotte, and Klaus Peithner. </author> <title> "A Blackboard Architecture for Query Opti mization in Object Bases". </title> <booktitle> In Proc. of the 19th VLDB Conf., </booktitle> <year> 1993. </year>
Reference-contexts: Various architectures have been proposed to allow extensible control over the search strategy of an optimizer. The region-based optimizer architecture of Mitchell et al. [MDZ93], the modular optimizer architecture by Sciore and Sieg [SJ90], and the blackboard architecture of Kemper, Moerkotte and Peithner <ref> [KMP93] </ref>, are all based on the concept of dividing an optimizer into regions that carry out different parts of the optimization. A query then has to pass through these various regions to be optimized. They differ in the methods used to pass control between the various regions. <p> In [SJ90] control passes from one region to another in a fixed sequence. In [MDZ93] there is a hierarchy of regions in which the parent region dynamically controls the sequence in which the query passes through the various regions while being optimized. In the blackboard approach <ref> [KMP93] </ref>, knowledge sources are responsible for moving the queries between regions. All these architectures describe very general frameworks for extensible query optimization that support multiple optimizer control strategies and allow addition of new control strategies. <p> Thus OPT++ can be used to build a smart query optimizer that dynamically customizes its optimization strategy depending upon the input. We plan to add some more search strategies to the repertoire of strategies available in OPT++. In particular, the A* heuristic <ref> [Pea84, KMP93] </ref>, and the heuristics described in [Swa89] seem promising. We also plan to add debugging support to OPT++. Debugging an optimizer remains a complex and time-consuming task.
Reference: [LFL88] <author> Mavis K. Lee, Johann Christoph Freytag, and Guy M. Lohman. </author> <title> "Implementing an Interpreter for Functional Rules in a Query Optimizer". </title> <booktitle> In Proc. of the 14th VLDB Conf., </booktitle> <address> Los Angeles, California, </address> <year> 1988. </year>
Reference-contexts: One set of rules is used to convert the query into an algebraic tree. Other sets of rules are used to generate access paths, join orderings, and join methods in that order. The optimizer developed as a part of the Starburst project <ref> [LFL88, HP88] </ref> uses a two step process to optimize queries. The first phase uses a set of production rules to transform the query heuristically into an equivalent new query that (hopefully) offers both faster execution than the old query and is better suited for cost-based optimization. <p> These are referred to as enforcers in the Volcano Optimizer Generator [GM93], and are comparable to the glue operators in Starburst <ref> [LFL88] </ref>. Classes corresponding to such enforcers should also be derived from the Algorithm class. For example, in a relational query optimizer, the Sort algorithm is an enforcer that can be used to ensure that the inputs of the MergeJoin algorithm are sorted on the join attribute.
Reference: [LV91] <author> Rosana S. G. Lanzelotte and Patrick Valduriez. </author> <title> "Extending the Search Strategy in a Query Opti mizer". </title> <booktitle> In Proc. of the 17th VLDB Conf., </booktitle> <address> Barcelona, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: In spite of these assumptions, a number of different search strategies can be implemented in OPT++ quite easily. Finally, while addition of algorithms and operators for any search strategy remains easy in OPT++, it is not clear how easy it is in these other systems. Lanzelotte and Valduriez <ref> [LV91] </ref> also describe an object-oriented design for an extensible query optimizer. The design of the search strategy code in OPT++ is inspired by this work. However, OPT++ differs in its modeling of the query algebra and the search space. <p> In particular, OPT++ has a clear separation between the logical algebra (operator trees) and the physical algebra (access plans). We believe this separation is necessary for efficiency of the optimizer as well as for clarity and extensibility. Although <ref> [LV91] </ref> discusses extensibility of the search strategy in detail, it is not clear how extensible their design is in terms of adding new operators and algorithms and modifying the search space explored, or how such changes would interact with one another or with the search strategy. 3 OPT++ System Design 3.1 <p> A number of search strategies have been implemented in OPT++ in this query-algebra-independent manner. The implementation of the various search strategies is loosely modeled on the object-oriented scheme described in <ref> [LV91] </ref>. OPT++ defines a SearchStrategy abstract class with virtual methods, and each of the search strategies in OPT++ is actually implemented as a class derived from the Search 14 Strategy abstract class. <p> Another consequence of this design is that Optimizer-Implementor can modify the behavior of any search strategy by deriving a new class from it and redefining some of the virtual methods. Due to space constraints, we do not describe this in detail. Refer to <ref> [LV91] </ref> to get an idea of how this works.
Reference: [MDZ93] <author> Gail Mitchell, Umeshwar Dayal, and Stanley B. Zdonik. </author> <title> "Control of an Extensible Query Optimizer: </title>
Reference-contexts: Our experience with the implementation of an optimizer using OPT++ shows that this flexibility is achieved without sacrificing performance. Various architectures have been proposed to allow extensible control over the search strategy of an optimizer. The region-based optimizer architecture of Mitchell et al. <ref> [MDZ93] </ref>, the modular optimizer architecture by Sciore and Sieg [SJ90], and the blackboard architecture of Kemper, Moerkotte and Peithner [KMP93], are all based on the concept of dividing an optimizer into regions that carry out different parts of the optimization. <p> A query then has to pass through these various regions to be optimized. They differ in the methods used to pass control between the various regions. In [SJ90] control passes from one region to another in a fixed sequence. In <ref> [MDZ93] </ref> there is a hierarchy of regions in which the parent region dynamically controls the sequence in which the query passes through the various regions while being optimized. In the blackboard approach [KMP93], knowledge sources are responsible for moving the queries between regions.
References-found: 16

