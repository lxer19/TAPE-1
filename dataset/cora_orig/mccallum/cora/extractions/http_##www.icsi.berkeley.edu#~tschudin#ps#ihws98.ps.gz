URL: http://www.icsi.berkeley.edu/~tschudin/ps/ihws98.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/~tschudin/
Root-URL: http://www.icsi.berkeley.edu
Email: fsander|tschuding@icsi.berkeley.edu  
Title: On Software Protection Via Function Hiding  
Author: Tomas Sander and Christian F. Tschudin 
Address: 1947 Center Street, Berkeley, CA 94704, USA  
Affiliation: International Computer Science Institute  
Note: Dec 1998. Submitted to the 2nd International Workshop on Information Hiding  
Abstract: Software piracy is a major economic problem: it leads to revenue losses, it favors big software houses that are less hurt by these losses and it prevents new software economy models where small enterprises can sell software on a per-usage basis. Proprietary algorithms are currently hard to protect, both at the technical as well as the legal level. In this paper we show how encrypted programs can be used to achieve protection of algorithms against disclosure. Moreover, using this approach we describe a protocol that ensures under reasonable conditions - that only licensed users are able to obtain the cleartext output of the program. This protocol also allows to charge clients on a per-usage basis. These results are applied to a special class of functions for which we obtain a secure and computationally feasible solution: the key point is to encrypt functions such that they remain executable. We further show how to robustly fingerprint the resulting programs. Our approach is fully software based and does not rely on tamper resistant hardware.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Abadi and J. Feigenbaum. </author> <title> Secure circuit evaluation. </title> <journal> Journal of Cryptology, </journal> <volume> 2(1) </volume> <pages> 1-12, </pages> <year> 1990. </year>
Reference-contexts: The general importance of homomorphic encryption functions for these type of problems was pointed out by Rivest, Adleman and Dertouzos (cf. [8]). An important step was done by Abadi and Feigenbaum <ref> [1] </ref> who described a protocol how to securely evaluate a Boolean circuit in encrypted data. Their protocol however requires a high amount of communication rounds between Alice and Bob.
Reference: 2. <author> David Aucsmith. </author> <title> Tamper resistant software: An implementation. </title> <editor> In Ross Anderson, editor, </editor> <booktitle> Information Hiding Proceedings of the First International Workshop, May/June 1996, number 1174 in LNCS, </booktitle> <pages> pages 317-333, </pages> <year> 1996. </year>
Reference-contexts: This is achieved by the same hiding techniques we use in this paper. However, in the mobile code context the additionally difficulty of the coefficient attack does not occur. Aucsmith <ref> [2] </ref> describes a different software-only approach based on code analysis frustration techniques like obfuscation, code rearrangement and gradual code decryption. 5 Summary Encrypted functions that can be executed without prior decryption give way to surprising solutions for seemingly unsolvable problems of software protection.
Reference: 3. <author> P. Burgisser, M. Clausen, and M. A. Shokrollahi. </author> <title> Algebraic Complexity Theory. Number 315 in Grundlehren der mathematischen Wissenschaften. </title> <publisher> Springer, </publisher> <year> 1997. </year>
Reference-contexts: Mathematically speaking Alice works with the easy to evaluate representation of g as a so called Straight Line Program but she encodes via H the dense representation of g. More about the theory of straight line programs can be found in <ref> [3] </ref>.
Reference: 4. <author> O. Goldreich and R. Ostrovsky. </author> <title> Software protection and simulation on oblivious RAMs. </title> <note> revised October 1995, ftp://theory.lcs.mit.edu/pub/people/oded/soft.ps. </note>
Reference-contexts: Adaptions of this techniques to evaluate encrypted circuits would intrinsically put a high communication burden on Alice and can thus not be considered to be satisfactory for our purposes. Provable software protection via special software-hardware packaging was proposed by Goldreich and Ostrovsky <ref> [4] </ref>. The authors of this paper studied in [9] the problem how to cryptographically make mobile code tamper-resistant without recurring to hardware. This is achieved by the same hiding techniques we use in this paper.
Reference: 5. <author> S. Goldwasser and S. Micali. </author> <title> Probabilistic encryption. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 28(2) </volume> <pages> 270-299, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: For this we rely on the Goldwasser-Micali scheme <ref> [5] </ref> that, when applied to a one bit message, is an additive homomorphic encryption scheme E on Z=2Z. In the Goldwasser-Micali public key crypto system, Alice's secret key are two large primes P and Q. <p> Assume further that the used encryption scheme E is polynomial time indistinguishable. Then no information is leaked about f except its skeleton. Proof. See [9, 6] for a more detailed proof. 6 The Goldwasser-Micali scheme is polynomial time indistinguishable under the assumed hardness of the Quadratic Residue Hypothesis <ref> [5] </ref>. Thus the above constructed program Prog hides everything about the polynomial f 2 Z=2Z [X 1 ; : : : ; X s ] except it's skeleton (the skeleton may even be increased before encryption for additional security).
Reference: 6. <author> Richard Lipton and Tomas Sander. </author> <title> An additively homomorphic encryption scheme or how to introduce a partial trapdoor in the discrete log, </title> <month> November </month> <year> 1997. </year> <note> Submitted for publication. </note>
Reference-contexts: The scheme is additive because the encrypted sum of two values x and y is obtained by multiplying their encrypted values modulo N i.e., E (x + y) = E (x)E (y). Lipton and Sander described in <ref> [6] </ref> a more general additive homomorphic encryption scheme on rings Z=M Zfor smooth integers M . For ease of presentation we work in the following only with the Goldwasser-Micali scheme but want to note that the subsequent constructions generalize to the scheme described in [6]. <p> Lipton and Sander described in <ref> [6] </ref> a more general additive homomorphic encryption scheme on rings Z=M Zfor smooth integers M . For ease of presentation we work in the following only with the Goldwasser-Micali scheme but want to note that the subsequent constructions generalize to the scheme described in [6]. Using the Goldwasser-Micali scheme (or its generalization), Alice can encrypt a polynomial f inside a program Prog such that Bob can execute the program on his input x and obtains the encrypted value of f (x). <p> Then the program constructed in proposition 2 hides polynomials f 2 Z=N Z [X 1 ; : : : ; X s ]. Assume further that the used encryption scheme E is polynomial time indistinguishable. Then no information is leaked about f except its skeleton. Proof. See <ref> [9, 6] </ref> for a more detailed proof. 6 The Goldwasser-Micali scheme is polynomial time indistinguishable under the assumed hardness of the Quadratic Residue Hypothesis [5]. <p> Using the additive homomorphic encryption scheme described in <ref> [6] </ref> this ideas generalize to hide polynomials over rings Z=M Zfor smooth integers M . However, considering only polynomial functions may be a restriction. This restriction is motivated by our requirement for rigorous security proofs.
Reference: 7. <author> S. Micali, C. Rackoff, and B. Sloan. </author> <title> The notion of security for probabilistic cryptosystems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17(2) </volume> <pages> 412-426, </pages> <year> 1988. </year>
Reference-contexts: Recall that an encryption scheme that does not leak any information about the messages is called polynomial time indistinguishable (see <ref> [7] </ref> for further details). Theorem 3. Let E be an additively homomorphic encryption scheme. Then the program constructed in proposition 2 hides polynomials f 2 Z=N Z [X 1 ; : : : ; X s ]. Assume further that the used encryption scheme E is polynomial time indistinguishable.
Reference: 8. <author> Ronald L. Rivest, Len Adleman, and Michael L. Dertouzos. </author> <title> On data banks and privacy homomorphisms. </title> <editor> In R. A. DeMillo, D. P. Dobkin, A. K. Jones, and R. J. Lipton, editors, </editor> <booktitle> Foundations of Secure Computation, </booktitle> <pages> pages 169-179. </pages> <publisher> Academic Press, </publisher> <year> 1978. </year>
Reference-contexts: The general importance of homomorphic encryption functions for these type of problems was pointed out by Rivest, Adleman and Dertouzos (cf. <ref> [8] </ref>). An important step was done by Abadi and Feigenbaum [1] who described a protocol how to securely evaluate a Boolean circuit in encrypted data. Their protocol however requires a high amount of communication rounds between Alice and Bob.
Reference: 9. <author> T. Sander and Chr. Tschudin. </author> <title> Towards mobile cryptography. </title> <type> Technical Report 97-049, ICSI, </type> <month> November </month> <year> 1997. </year>
Reference-contexts: Using an additive and mixed multiplicative encryption function one can hide polynomials over rings Z=M Zin a program as was pointed out by the authors in <ref> [9] </ref>. We review this technique here briefly. Proposition 2. Let E : Z=N Z! R be an additively homomorphic encryption scheme. Then we can hide polynomials p 2 Z=N Z [X 1 ; : : : ; X s ] with the help of E in a program Prog. <p> Then the program constructed in proposition 2 hides polynomials f 2 Z=N Z [X 1 ; : : : ; X s ]. Assume further that the used encryption scheme E is polynomial time indistinguishable. Then no information is leaked about f except its skeleton. Proof. See <ref> [9, 6] </ref> for a more detailed proof. 6 The Goldwasser-Micali scheme is polynomial time indistinguishable under the assumed hardness of the Quadratic Residue Hypothesis [5]. <p> We note here that there are cases where the leakage of the skeleton is not tolerable (see <ref> [9] </ref>). 3.3 A Naive Protocol for Protecting Polynomials Hiding a polynomial f in a program Prog according to the method described above enables Alice to realize the basic protocol of section 2: Bob runs Alice's program Prog on his private input x 1 ; : : : ; x s and <p> Provable software protection via special software-hardware packaging was proposed by Goldreich and Ostrovsky [4]. The authors of this paper studied in <ref> [9] </ref> the problem how to cryptographically make mobile code tamper-resistant without recurring to hardware. This is achieved by the same hiding techniques we use in this paper. However, in the mobile code context the additionally difficulty of the coefficient attack does not occur.
Reference: 10. <author> Ingo Wegener. </author> <title> The Complexity of Boolean Functions. </title> <address> Eiley-Teubner, </address> <year> 1987. </year>
Reference-contexts: If one succeeds to hide Boolean circuits, major problems of software protection would at least theoretically be solved for general programs because every Turing machine program can (for a fixed input size) be efficiently simulated by Boolean circuits <ref> [10] </ref>. The first major obstacle for such a general solution is that we do not know of an encryption function E on Z=2Zsuch that both E (x + y) and E (xy) can be easily computed from E (x) and E (y).
Reference: 11. <author> R. E. Zippel. </author> <title> Interpolating polynomials from their values. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 9 </volume> <pages> 375-403, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: In the case of polynomials studied in this paper, the hidden polynomial f may be reconstructed from O (]U ) input/output pairs by obvious interpolation techniques. Moreover, more sophisticated sparse interpolation techniques apply in cases where the degree of the polynomial f is low <ref> [11] </ref>.
References-found: 11

