URL: http://www.cs.clemson.edu/~malloy/sim386/paper.ps
Refering-URL: http://www.cs.clemson.edu/~malloy/sim386/sim386.html
Root-URL: http://www.cs.clemson.edu
Email: fmhaungs,malloyg@cs.clemson.edu  
Title: Extending Sim286 to the Intel386 Architecture with 32-bit processing and Elf Binary input  
Author: Michael L. Haungs and Brian A. Malloy 
Address: Clemson, SC 29634  
Affiliation: Dept. of Computer Science  
Abstract: The trend in processor development is that each new processor is soon replaced by a newer and more powerful processor. To facilitate processor development, the design and implementation of a processor is typically paralleled by the design and implementation of a simulator that can be used to avoid errors in the development process. The ideal is that the family of processors should be accompanied by the design and implementation of a family of simulators where each successive simulator can be derived from the previous by an incremental change in both the design and implementation of the simulator. In this paper, we report the addition of Sim386 to a family of simulators, Simx86, for the Intel 80x86 family of processors. The construction of Sim386 involved two important extension over its predecessor. First, Sim386 performs both 16 and 32-bit processing; the predecessor of Sim386, Sim286, performed 16-bit processing. Second, Sim386 can accept both COM and ELF binary file input; the predecessor of Sim386, Sim286, accepted only COM file input. The second extension makes Sim386 a more viable tool, since ELF binaries are more widely accessible than COM files. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Intel Corporation. </author> <title> Intel386 SX Microprocessor Programmer's Reference Manual. Intel Literature Sales, </title> <year> 1998. </year>
Reference-contexts: The prefix bytes are optional. specifies the based indexed and scaled indexed forms of 32-bit addressing. 3.2.1 Adding additional addressing modes and the SIB byte The instruction format for the Intel386 is shown in Figure 12 <ref> [1] </ref>. The major change from the format for Sim286 is that a new byte, the SIB byte, is now a part of the instruction format. The SIB byte encodes an additional 32 forms of addressing available for each instruction. Figure 13 describes and shows the layout of the SIB byte [1]. <p> <ref> [1] </ref>. The major change from the format for Sim286 is that a new byte, the SIB byte, is now a part of the instruction format. The SIB byte encodes an additional 32 forms of addressing available for each instruction. Figure 13 describes and shows the layout of the SIB byte [1]. In addition to the 32 addressing modes added by SIB byte, the ModR/M byte can now be used to specify 32 new 32-bit addressing forms along with its original 32 16-bit addressing forms. Thus, there are a total of 96 address forms that can be used in Sim386.
Reference: [2] <author> M. Lam, E. E. Rothberg, and M. E. Wolf. </author> <title> The cache performance and optimizations of blocked algorithms. </title> <booktitle> Proceedings of Fourth Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 63-74, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: that uses Gaussian elimination without pivoting, gauss [10]; an insertion sort, isort; the first Livermore loop, livermore [5]; matrix multiplication, matmult [10]; a program to transform a matrix into Hermite normal form, normal [10]; the sieve of Erosthothenes, sieve; a program that uses tiling to optimize data cache references, tiling <ref> [2] </ref>; and a program to perform matrix transposition, transpose. Our experiments indicate that for COM file input, Sim286 is, on average, 2.06 percent faster than Sim386 when using the test suite of nine programs. Additional logic is included in Sim386 to check for operand size during processing.
Reference: [3] <author> Hongjiu Lu. </author> <title> ELF: From the programmer's perspective. </title> <address> www.cinfo.ru:8030/linux/WWW/www debian.org/Documentation/elf/elf.html, </address> <year> 1998. </year>
Reference-contexts: The ELF standard is growing in popularity because it has greater power and flexibility than the a.out and COFF binary formats <ref> [3] </ref>. ELF now appears as the default binary format on operating systems such as Linux, Solaris 2.x, and SVR4. Some of the capabilities of ELF are dynamic linking, dynamic loading, imposing runtime control on a program, and an improved method for creating shared libraries [3]. <p> the a.out and COFF binary formats <ref> [3] </ref>. ELF now appears as the default binary format on operating systems such as Linux, Solaris 2.x, and SVR4. Some of the capabilities of ELF are dynamic linking, dynamic loading, imposing runtime control on a program, and an improved method for creating shared libraries [3]. The ELF representation of control data in an object file is platform independent, an additional improvement over previous binary formats. The ELF representation permits object files to be identified, parsed, and interpreted similarly, making the ELF object files compatible across multiple platforms and architectures of different size.
Reference: [4] <author> B. A. Malloy and S. Chitre. </author> <title> Extending simx86 to include prefetching, segmentation, virtual memory addressing and protection mode. </title> <booktitle> Proceedings of the 1998 Conference on Object-Oriented Simulation, </booktitle> <pages> pages 39-44, </pages> <month> January </month> <year> 1998. </year>
Reference-contexts: All too often, the family of simulators ideal is not achieved. In this paper, we report on the development of a family of simulators, Simx86, for the Intel 80x86 family of processors. We begin by reviewing previous simulators in the family, Sim8088 [7] and Sim286 <ref> [4] </ref>. We then 1 describe the effort involved in building Sim386, the successor to Sim286. The construction of Sim386 involved two important extension over its predecessor. First, Sim386 performs both 16 and 32-bit processing; the predecessor of Sim386, Sim286, performed 16-bit processing. <p> In Section 3, we describe our implementation of Sim386 to include 32-bit processing and to accept ELF binary input. In Section 4 we report the results of some experiments comparing the COM file executions of the test suite described in reference <ref> [4] </ref> using COM and ELF binaries as input. In Section 5 we describe an approach to the redesign of Sim386 and to incorporating dynamic linking of ELF. <p> We also provide background about previous 2 and Sim286 accept COM input files as input; Sim386 accepts both COM and ELF input files. versions of Simx86 simulators including Sim8088 [7], and Sim286 <ref> [4] </ref>. 2.1 The 80x86 Processor Family The origin of the 80x86 family of processors began in 1978 with the introduction of the 8086 processor. Shortly thereafter, the 8088 processor was added to the family. <p> We adopt the naming convention used in reference <ref> [4] </ref> to refer to these two frameworks as the Architecture Framework, captured in Figure 4, and the Simulation Framework. The extensions to Sim286 that we report in this paper focus on the Architecture Framework. The interested reader may consult reference [4] for a description of the simulation framework. <p> We adopt the naming convention used in reference <ref> [4] </ref> to refer to these two frameworks as the Architecture Framework, captured in Figure 4, and the Simulation Framework. The extensions to Sim286 that we report in this paper focus on the Architecture Framework. The interested reader may consult reference [4] for a description of the simulation framework. The CPU class for Sim286 is extended to include a global descriptor table register, a local descriptor table 6 architecture of Sim286, the simulator for the Intel 80286 processor.
Reference: [5] <author> F. H. McMahon. </author> <title> FORTRAN CPU performance analysis. </title> <institution> Lawrence Livermore Laboratories, </institution> <year> 1972. </year>
Reference-contexts: The test programs listed in column one of the table in Figure 20 include a program to compute Fibonacci numbers, fibbk; a program that uses Gaussian elimination without pivoting, gauss [10]; an insertion sort, isort; the first Livermore loop, livermore <ref> [5] </ref>; matrix multiplication, matmult [10]; a program to transform a matrix into Hermite normal form, normal [10]; the sieve of Erosthothenes, sieve; a program that uses tiling to optimize data cache references, tiling [2]; and a program to perform matrix transposition, transpose.
Reference: [6] <author> James Rumbaugh, Michael Blaha, William Premerlani, Fredrick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: The Sim286 simulator extended Sim8088 to include both real mode and protected mode. This extension is illustrated in Figure 4 with classes RealModeBIU and VirtualModBIU derived from the BIU class; the arrow connector in the figure represents the inheritance relationship <ref> [6] </ref>. The figure also illustrates that the BIU is related to class PrefetchQueue through aggregation.
Reference: [7] <author> A. R. Shealy, B. A. Malloy, and D. A. Sykes. Simx86: </author> <title> An extensible simulator for the intel 80x86 processor family. </title> <booktitle> Proceedings of the 30th Annual Simulation Symposium, </booktitle> <pages> pages 157-166, </pages> <month> April </month> <year> 1997. </year>
Reference-contexts: All too often, the family of simulators ideal is not achieved. In this paper, we report on the development of a family of simulators, Simx86, for the Intel 80x86 family of processors. We begin by reviewing previous simulators in the family, Sim8088 <ref> [7] </ref> and Sim286 [4]. We then 1 describe the effort involved in building Sim386, the successor to Sim286. The construction of Sim386 involved two important extension over its predecessor. First, Sim386 performs both 16 and 32-bit processing; the predecessor of Sim386, Sim286, performed 16-bit processing. <p> We also provide background about previous 2 and Sim286 accept COM input files as input; Sim386 accepts both COM and ELF input files. versions of Simx86 simulators including Sim8088 <ref> [7] </ref>, and Sim286 [4]. 2.1 The 80x86 Processor Family The origin of the 80x86 family of processors began in 1978 with the introduction of the 8086 processor. Shortly thereafter, the 8088 processor was added to the family.
Reference: [8] <author> Tool Interface Standards. </author> <title> ELF: Executable and Linkable Format. </title> <address> ftp://ftp.intel.com/pub/tis, </address> <year> 1998. </year>
Reference-contexts: feature of Sim286 is the ability to simulate the prefetch and decode of instructions in parallel with other CPU operations. 7 2.4 The Executable and Linking Format (ELF) The executable and linking format (ELF) was originally developed by Unix System Laboratories and is rapidly becoming the standard in file formats <ref> [8] </ref>. The ELF standard is growing in popularity because it has greater power and flexibility than the a.out and COFF binary formats [3]. ELF now appears as the default binary format on operating systems such as Linux, Solaris 2.x, and SVR4. <p> These five types are (1) the ELF header, (2) the program header table, (3) the section header table, (4) the ELF sections, and (5) the ELF segments. In Section 2.4.2, we describe the representation of data in an ELF file. The interested reader may consult reference <ref> [8] </ref> for additional information about the ELF format. 2.4.1 The ELF File Format There are two views for each of the three file types described in the previous section. These views support both the linking and execution of a program. <p> All data structures that the object file format defines follow the size and alignment guidelines for the relevant storage class <ref> [8] </ref>. If necessary, data structures are padded to ensure alignment; for example, a data structure might contain explicit padding to ensure 4-byte alignment for 4-byte objects, to force structure sizes to be a multiple of 4 [8]. <p> file format defines follow the size and alignment guidelines for the relevant storage class <ref> [8] </ref>. If necessary, data structures are padded to ensure alignment; for example, a data structure might contain explicit padding to ensure 4-byte alignment for 4-byte objects, to force structure sizes to be a multiple of 4 [8]. Alignment information is also included in the structures for sections and segments so that these structures, when placed in memory, can be properly aligned.
Reference: [9] <author> Eric Tauck. WASM 1.0: </author> <title> Wolfware Assembler for the IBM Personal Computer. </title> <address> Wolfware, </address> <year> 1985. </year>
Reference-contexts: To create COM binary executables for both Sim286 and Sim386, we use the Borland 4.5 C compiler to produce 8086 assembly code. The 8086 assembly code is assembled using Wolfware Assembler, or WASM <ref> [9] </ref>, to create an executable COM file. To create ELF binary executables for Sim386, we use the gcc C compiler version 2.7.2.3 with O2 optimizations.
Reference: [10] <author> M. Wolfe. </author> <title> High Performance Compilers for Parallel Computing. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> first edition, </address> <year> 1996. </year> <month> 27 </month>
Reference-contexts: To create ELF binary executables for Sim386, we use the gcc C compiler version 2.7.2.3 with O2 optimizations. The test programs listed in column one of the table in Figure 20 include a program to compute Fibonacci numbers, fibbk; a program that uses Gaussian elimination without pivoting, gauss <ref> [10] </ref>; an insertion sort, isort; the first Livermore loop, livermore [5]; matrix multiplication, matmult [10]; a program to transform a matrix into Hermite normal form, normal [10]; the sieve of Erosthothenes, sieve; a program that uses tiling to optimize data cache references, tiling [2]; and a program to perform matrix transposition, <p> The test programs listed in column one of the table in Figure 20 include a program to compute Fibonacci numbers, fibbk; a program that uses Gaussian elimination without pivoting, gauss <ref> [10] </ref>; an insertion sort, isort; the first Livermore loop, livermore [5]; matrix multiplication, matmult [10]; a program to transform a matrix into Hermite normal form, normal [10]; the sieve of Erosthothenes, sieve; a program that uses tiling to optimize data cache references, tiling [2]; and a program to perform matrix transposition, transpose. <p> one of the table in Figure 20 include a program to compute Fibonacci numbers, fibbk; a program that uses Gaussian elimination without pivoting, gauss <ref> [10] </ref>; an insertion sort, isort; the first Livermore loop, livermore [5]; matrix multiplication, matmult [10]; a program to transform a matrix into Hermite normal form, normal [10]; the sieve of Erosthothenes, sieve; a program that uses tiling to optimize data cache references, tiling [2]; and a program to perform matrix transposition, transpose.
References-found: 10

