URL: http://www.cs.mu.oz.au/tr_db/mu_97_08.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: (flee,leong@cs.mu.oz.au, http://www.cs.mu.oz.au/~flee,leong)  
Title: A Higher Order Reconstruction of Stepwise Enhancement  
Author: Lee Naish and Leon Sterling 
Address: Parkville, Victoria 3052 Australia  
Affiliation: Department of Computer Science University of Melbourne  
Pubnum: Technical Report 97/8  
Abstract: This paper presents two views of stepwise enhancement, one a pragmatic syntax-based approach and the other a semantic approach based on higher order functions and relating to shape and polytypism. The approaches are outlined, and the perhaps surprisingly close relationship between the two described. By combining the advantages of both approaches, it is shown how more code in both functional and logic programming languages can be constructed in a systematic and partially automated way. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Gegg-Harrison, T. </author> <title> Learning Prolog in a Schema-Based Environment, </title> <journal> Instructional Science, </journal> <volume> 20 </volume> <pages> 173-192, </pages> <year> 1991. </year>
Reference: <author> Gegg-Harrison, T. </author> <title> Representing Logic Program Schemata in Lambda-Prolog, </title> <booktitle> Proc. 12th International Logic Programming Conference (ed. L. Sterling), </booktitle> <pages> pp. 467-481, </pages> <publisher> MIT Press, </publisher> <editor> 1995 P. Jansson and J. Jeuring. </editor> <title> PolyP | a polytypic programming language extension. </title> <booktitle> In Conference Record of POPL '97: The 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 470-482, </pages> <note> 1997 15 Jay, </note> <author> B., </author> <title> A semantics for shape, </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 25, </volume> <pages> pp. 251-283, </pages> <note> 1995 J. </note> <editor> Jeuring and P. Jansson. Polytypic programming. In J. Launchbury, E. Meijer and T. </editor> <booktitle> Sheard Advanced Functional Programming, </booktitle> <volume> LNCS 1129, </volume> <pages> pp. 68-114, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: <author> Jay, C.B. and Cockett, J.R.B. </author> <title> Shapely Types and Shape Polymorphism, </title> <booktitle> Proc. Programming Languages and Systems | ESOP '94: 5th European Symposium on Programming, </booktitle> <editor> (ed. D. Sannella), </editor> <publisher> Springer LNCS, </publisher> <pages> pp. 302-316, </pages> <address> Edinburgh, U.K., April 1994 Jay, </address> <month> C.B., </month> <title> A semantics for shape, </title> <booktitle> Science of Computer Programming, </booktitle> <pages> 25, </pages> <note> 1995 Kirschenbaum, </note> <author> M., Michaylov, S. and Sterling, </author> <title> L.S. Skeletons and Techniques as a Normative Approach to Program Development in Logic-Based Languages, </title> <journal> Proc. ACSC'96, Australian Computer Science Communications, </journal> <volume> 18(1), </volume> <pages> pp. 516-524, </pages> <note> 1996 Lakhotia, </note> <author> A. </author> <title> A Workbench for Developing Logic Programs by Stepwise Enhancement, </title> <type> Ph.D. Thesis, </type> <institution> Case Western Reserve University, </institution> <year> 1989. </year>
Reference-contexts: We show how this is closely related to the new ideas on shape and polytypism being discussed in the functional programming community <ref> (Jay and Cockett, 1994) </ref>, (Jay, 1995), (Belle et al., 1996) (Jeuring and Jansson, 1996), (Jansson and Jeuring, 1997). <p> These higher order definitions can be optimised very effectively using a partial evaluator such as Mixtus (Sahlin, 1993). Further examples are given to show how predicates which are analogous to foldr can be constructed. 5 Incorporating Shape Recent work on shape <ref> (Jay and Cockett, 1994) </ref>, (Jay, 1995), (Belle et al., 1996) and poly-typism (Jeuring and Jansson, 1996), (Jansson and Jeuring, 1997) has formalised how many data types have certain higher order functions naturally associated with them. For example, map takes a list and produces another list of the same length.
Reference: <author> Nadathur, G., Miller D., </author> <title> An Overview of Lambda-Prolog, </title> <booktitle> Proceedings of JICSLP (eds. </booktitle>
Reference: <editor> Bowen, K. and Kowlaski, </editor> <booktitle> R.), </booktitle> <pages> pp. 810-827, </pages> <publisher> MIT Press, </publisher> <editor> 1988 Naish, L. </editor> <title> Higher Order Logic Programming in Prolog, </title> <booktitle> Proc. Workshop on Multi-Paradigm Logic Programming, </booktitle> <address> JICSLP'96, Bonn, </address> <note> 1996 (Also available as Tech. Report 96/2, </note> <institution> Dept. Computer Science, University of Melbourne, </institution> <year> 1996.) </year> <editor> O'Keefe, R. </editor> <title> The Craft of Prolog, </title> <publisher> MIT Press, </publisher> <address> 1990 Sahlin, D. </address> <month> Mixtus: </month> <title> An Automatic Partial Evaluator for Full Prolog, </title> <journal> New Generation Computing, </journal> <volume> 12(1), </volume> <pages> pp. 7-51, </pages> <note> 1993 Sterling, </note> <author> L. and Kirschenbaum, M. </author> <title> Applying Techniques to Skeletons, in Constructing Logic Programs, </title> <editor> (ed. J.M. </editor> <booktitle> Jacquet), </booktitle> <pages> pp. 127-140, </pages> <publisher> Wiley, </publisher> <year> 1993. </year>
Reference: <author> Sterling, L.S. and Shapiro, E.Y. </author> <title> The Art of Prolog, 2nd edition, </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: A logical specification is (somehow) arrived at, and then schemas are used to guide the transformation of the specification to a program. 1 5. Stepwise enhancement (Lakhotia, 1989), (Sterling and Kirschenbaum, 1993), and <ref> (Sterling and Shapiro, 1994) </ref> was introduced by Sterling and colleagues in an attempt to simplify the teaching of complicated Prolog programs. Rather than have to explain higher order concepts, programmers and novices were taught programming techniques which at all times manipulated concrete Prolog programs. 6. <p> The current work was sparked by the challenge to use the higher order approach to explain a `complicated' program, the rule interpreter described in Section 17.4 of the second edition of The Art of Prolog <ref> (Sterling and Shapiro, 1994) </ref>. In explaining the program, a new method was formulated: the final program is built around an output type rather than an input type. In this paper we give another example of this technique, using a different interpreter. <p> The most common data structure for logic programs is the list, and many programs are based on skeletons for traversing lists. A tutorial example of using stepwise enhancement to develop a simple program is given in Chapter 13 of <ref> (Sterling and Shapiro, 1994) </ref>. In this section we give the basic list processing program as Program 1 for reference, and a (slightly) more elaborate example with binary trees. is_list ([]). is_list ([X|Xs]) :- is_list (Xs). <p> The result argument of foldr can be a pair of terms, one of which can be used as an input, and the accumulator style of programming can be used. If the accumulator is a list, we can think of foldr returning a difference list <ref> (Sterling and Shapiro, 1994) </ref> instead of a list. With this style of programming, the data dependencies are such that the instances of call/N in the foldr definitions can be executed before the recursive call (s), allowing tail recursion. <p> The call/N is the leftmost atom in the body and the accumulator and output arguments are `threaded' through this and the recursive calls in the clause body in the familiar way <ref> (Sterling and Shapiro, 1994) </ref>. The accumulator and output arguments can be made implicit by using the standard Definite Clause Grammar notation.
Reference: <author> Sterling, L.S. and Yal~cinalp, U. </author> <title> Logic Programming and Software Engineering | Implications for Software Design, </title> <journal> Knowledge Engineering Review, </journal> <volume> 11(4), </volume> <pages> pp. 333-345, </pages> <note> 1996 Vasconcelos, </note> <author> W. and Fuchs, N.E. </author> <title> An Opportunistic Approach for Logic Program Analysis and Optimisation using Enhanced Schema-based Transformations, </title> <booktitle> Proc. </booktitle> <address> LOPSTR'95, </address> <publisher> (ed. </publisher>
Reference: <author> M. </author> <title> Proietti), </title> <publisher> Springer LNCS, </publisher> <pages> pp. 174-188, </pages> <note> 1995 Yardeni, </note> <author> E. and Shapiro E.Y., </author> <title> A Type System for Logic Programs, </title> <journal> Journal of Logic Programming, </journal> <volume> 10(2), </volume> <pages> pp. 125-154, </pages> <year> 1990 </year> <month> 16 </month>
References-found: 8

