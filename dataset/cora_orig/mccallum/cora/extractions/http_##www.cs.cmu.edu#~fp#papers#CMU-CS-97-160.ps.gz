URL: http://www.cs.cmu.edu/~fp/papers/CMU-CS-97-160.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/fp/www/courses/linear/lectures/lecture26.html
Root-URL: 
Title: Linear Higher-Order Pre-Unification  
Author: Iliano Cervesato and Frank Pfenning 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: July 20, 1997  
Pubnum: CMU-CS-97-160  
Abstract: We develop a pre-unification algorithm in the style of Huet for the linear -calculus !ffi&&gt; which includes intuitionistic functions (!), linear functions (ffi), additive pairing (&), and additive unit (&gt;). This procedure conveniently operates on an efficient representation of !ffi&&gt; , the spine calculus S !ffi&&gt; for which we define the concept of weak head-normal form. We prove the soundness and completeness of our algorithm with respect to the proper notion of definitional equality for S !ffi&&gt; , and illustrate the distinctive aspects of linear higher-order unification by means of examples. We also show that, surprisingly, a similar pre-unification algorithm does not exist for certain sublanguages. Applications lie in proof search, logic programming, and logical frameworks based on linear type theories. 
Abstract-found: 1
Intro-found: 1
Reference: [AL91] <author> Andrea Asperti and Giuseppe Longo. </author> <title> Categories, Types, and Structures: An Introduction to Category Theory for the Working Computer Scientist. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In particular, !& coincides with the simply-typed -calculus with pairs while !&&gt; corresponds to its extension with a unit type and unit element; the latter calculus is tightly related to the notion of Cartesian closed categories <ref> [AL91] </ref>. Unification in the restricted setting of higher-order patterns has been studied for these two languages in [Dug93] and [FL96], respectively. The appropriate restrictions of the rules in Figures 8-10 implement a general pre-unification procedure for these calculi.
Reference: [Bar80] <author> H. P. Barendregt. </author> <title> The Lambda-Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <year> 1980. </year>
Reference-contexts: This has the desirable effect of permitting only -long terms to be derivable in this calculus [CP97]: allowing arbitrary types on the right-hand side of the spine typing judgment corresponds to dropping this property, as we will see in Section 2.5. Abstract Bohm trees <ref> [Bar80, Her95a] </ref> are obtained in this manner. The mutual definition of the two typing judgments of S !ffi&&gt; is given in Figure 2. <p> We treat ~ E as a multiset with elements the derivations E ~ . We call an equation well-typed if the corresponding equality judgment is well-typed. This notion extends naturally to equation systems. The usual definitions concerning substitutions <ref> [Bar80] </ref> are trivially extended to our language. <p> We write fi ffi fi 0 for the composition of substitutions fi and fi 0 . These operations retain their usual semantics <ref> [Bar80] </ref> also in our setting. We will take particular advantage of the following properties.
Reference: [Bar96] <author> Andrew Barber. </author> <title> Dual intuitionistic linear logic. </title> <type> Technical Report ECS-LFCS-96-347, </type> <institution> Laboratory for Foundations of Computer Sciences, University if Edinburgh, </institution> <month> September </month> <year> 1996. </year>
Reference-contexts: Curry-Howard isomorphism, to the fragment of intuitionistic linear logic freely generated from the connectives !, ffi, & and &gt;, which constitutes the propositional core of Lolli [HM94] and LLF [CP96]. !ffi&&gt; is also the simply-typed variant of the term language of LLF and shares similarities with the calculus proposed in <ref> [Bar96] </ref>. Its theoretical relevance derives from the fact that it is the largest linear -calculus that admits unique long fi-normal forms.
Reference: [Cer96] <author> Iliano Cervesato. </author> <title> A Linear Logical Framework. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Torino, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. More recent proposals, such as the language of the linear logical framework LLF <ref> [Cer96, CP96] </ref> and the system RLF [IP96], introduce linearity not only at the level of formulas, but also within terms. Consequently, implementations of these languages must solve higher-order equations on linear terms in order to instantiate existential variables. <p> Linear terms provide a statically checkable notation for natural deductions [IP96] or sequent derivations [CP96] in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [CP96] or sequences of moves in games <ref> [Cer96] </ref>. When we want to specify, manipulate, or reason about such objects (which is common in logic and the theory of programming languages), then internal linearity constraints are critical in practice (see, for example, the first formalizations of cut-elimination in linear logic and type preservation for Mini-ML with references [CP96]). <p> The reduction semantics of !ffi&&gt; is given by the transitive and reflexive closure of the congruence relation built on the following fi-reduction rules: fst hM; N i ! M ( ^ x : A: M )^N ! [N=x]M Similarly to ! , !ffi&&gt; enjoys a number of highly desirable properties <ref> [Cer96] </ref>. <p> It states that linear hypotheses can be viewed as intuitionistic assumptions with additional properties. An analogous result is proved in <ref> [Cer96] </ref>. <p> If ; ` S : A &gt; a and S ! S 0 , then ; ` S 0 : A &gt; a. 2 The following technical result is proved as in !ffi&&gt; <ref> [Cer96] </ref>. Lemma 2.4 (Substitution) i. If U ! fl U 0 and V ! fl V 0 , then [V =x]U ! fl [V 0 =x]U 0 . ii .
Reference: [CH88] <author> Thierry Coquand and Gerard Huet. </author> <title> The Calculus of Constructions. </title> <journal> Information and Computation, </journal> 76(2/3):95-120, February/March 1988. 
Reference-contexts: The individuation of the pattern fragment by Miller [Mil91] and of a terminating and unitary algorithm for it had extensive applications and will influence the direction of our future work. These ideas have been extended in [Pfe91b] to more general languages such as the calculus of constructions <ref> [CH88] </ref>, which includes dependent types, polymorphism and type constructors definition. Of some relevance in our context is Prehofer's thesis [Pre95] where he considers the specific case of unification in ! where the occurrences of logical variables are subject to linear restrictions.
Reference: [CHP96] <author> Iliano Cervesato, Joshua S. Hodas, and Frank Pfenning. </author> <title> Efficient resource management for linear logic proof search. </title> <editor> In R. Dyckhoff, H. Herre, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the 5th International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 67-81, </pages> <address> Leipzig, Germany, March 1996. </address> <publisher> Springer-Verlag LNAI 1050. </publisher>
Reference-contexts: The only new aspect in the operational semantics of most proposals, such as Lolli [HM94], Lygon [HP94] and Forum [Mil96], concerns the management of linear context formulas <ref> [CHP96] </ref>. In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. <p> As expected, equations among intuitionistic operands are created with an empty linear context (pu iapp). Context splitting in rule pu lapp represents a new form of "don't know" non-determinism not present in Huet's algorithm. Standard techniques of lazy context management <ref> [CHP96] </ref> can however be used in order to handle it efficiently and deterministically in an actual implementation. A new inherent form of non-determinism arises in the generation of the spine of substitution terms.
Reference: [CP96] <author> Iliano Cervesato and Frank Pfenning. </author> <title> A linear logical framework. </title> <editor> In E. Clarke, editor, </editor> <booktitle> Proceedings of the Eleventh Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 264-275, </pages> <address> New Brunswick, New Jersey, July 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. More recent proposals, such as the language of the linear logical framework LLF <ref> [Cer96, CP96] </ref> and the system RLF [IP96], introduce linearity not only at the level of formulas, but also within terms. Consequently, implementations of these languages must solve higher-order equations on linear terms in order to instantiate existential variables. <p> The problem representation would therefore be more direct and compact in this language. The introduction of linear term languages in LLF and RLF has been motivated by a number of applications. Linear terms provide a statically checkable notation for natural deductions [IP96] or sequent derivations <ref> [CP96] </ref> in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [CP96] or sequences of moves in games [Cer96]. <p> Linear terms provide a statically checkable notation for natural deductions [IP96] or sequent derivations <ref> [CP96] </ref> in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [CP96] or sequences of moves in games [Cer96]. <p> When we want to specify, manipulate, or reason about such objects (which is common in logic and the theory of programming languages), then internal linearity constraints are critical in practice (see, for example, the first formalizations of cut-elimination in linear logic and type preservation for Mini-ML with references <ref> [CP96] </ref>). Differently from the first-order case, higher-order unification in Church's simply typed -calculus ! is undecidable and does not admit most general unifiers [Gol81]. Nevertheless sound and complete (although 1 possibly non-terminating) procedures have been proposed in order to enumerate solutions [JP76]. <p> be devised for linear sublanguages deprived of &gt; and of the corresponding constructor. !ffi&&gt; corresponds, via a natural extension of the Curry-Howard isomorphism, to the fragment of intuitionistic linear logic freely generated from the connectives !, ffi, & and &gt;, which constitutes the propositional core of Lolli [HM94] and LLF <ref> [CP96] </ref>. !ffi&&gt; is also the simply-typed variant of the term language of LLF and shares similarities with the calculus proposed in [Bar96]. Its theoretical relevance derives from the fact that it is the largest linear -calculus that admits unique long fi-normal forms. <p> If ; ; x : B ` S : A &gt; a, then there is a derivation of ; x : B; ` S : A &gt; a. 2 The reduction semantics of S !ffi&&gt; is based on the following fi-reductions, which are obtained from the analogous rules of !ffi&&gt; <ref> [CP96, CP97] </ref> by means of the mentioned translation. hU; V i ( 1 S) ! U S ( ^ x : A: U ) (V ^; S) ! [V =x]U S The trailing spine in the reductions for S !ffi&&gt; is a consequence of the fact that this language reverses the
Reference: [CP97] <author> Iliano Cervesato and Frank Pfenning. </author> <title> A linear spine calculus. </title> <type> Technical Report CMU-CS-97-125, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: of compound type can have several heads (e.g. c 1 and c 2 in hc 1 ; c 2 i), possibly none (e.g. hi), and on the other hand destructors can be interleaved arbitrarily in a term of base type (e.g. fst ((snd c)^x y)) The spine calculus S !ffi&&gt; <ref> [CP97] </ref> permits recovering both efficient head accesses and notational convenience. Every !ffi&&gt; term M of base type is written in this presentation as a root H S, where H corresponds to the head of M and the spine S collects the sequence of destructors applied to it. <p> Notice that the target type of a well-typed spine is a base type. This has the desirable effect of permitting only -long terms to be derivable in this calculus <ref> [CP97] </ref>: allowing arbitrary types on the right-hand side of the spine typing judgment corresponds to dropping this property, as we will see in Section 2.5. Abstract Bohm trees [Bar80, Her95a] are obtained in this manner. <p> There exists a structural translation of terms in !ffi&&gt; to terms in S !ffi&&gt; , and vice versa. This mapping and the proofs of soundness and completeness for the respective typing derivations can be found in <ref> [CP97] </ref>. In the sequel, we will need the following simple property of typing derivations, which states that the intuitionistic context of any valid derivation can be arbitrarily weakened. Lemma 2.1 (Intuitionistic weakening) i. <p> If ; ; x : B ` S : A &gt; a, then there is a derivation of ; x : B; ` S : A &gt; a. 2 The reduction semantics of S !ffi&&gt; is based on the following fi-reductions, which are obtained from the analogous rules of !ffi&&gt; <ref> [CP96, CP97] </ref> by means of the mentioned translation. hU; V i ( 1 S) ! U S ( ^ x : A: U ) (V ^; S) ! [V =x]U S The trailing spine in the reductions for S !ffi&&gt; is a consequence of the fact that this language reverses the <p> The fi-reduction rules above preserve not only well-typedness, but also long forms so that -expansion steps never need to be performed. This property is formalized in the following lemma, whose proof can be found in <ref> [CP97] </ref>. Lemma 2.3 (Subject reduction) i. If ; ` U : A and U ! V , then ; ` V : A. ii . <p> This fact is formalized in the following theorem <ref> [CP97] </ref>. Theorem 2.5 (Confluence) i. If U ! fl U 1 and U ! fl U 2 , then there is a term U 0 such that U 1 ! fl U 0 and U 2 ! fl U 0 . ii . <p> We have indeed the following theorem, proved in <ref> [CP97] </ref>. Theorem 2.6 (Strong normalization) i. If ; ` U : A, then U is strongly normalizing. ii . <p> We observed that, by strong normalization and the Church-Rosser theorem <ref> [CP97] </ref>, it suffices to compute Can (U 1 ) and Can (U 2 ) and check whether they are syntactically equal (modulo renaming of bound variables).
Reference: [DHKP96] <author> Gilles Dowek, Therese Hardin, Claude Kirchner, and Frank Pfenning. </author> <title> Unification via explicit substitutions: The case of higher-order patterns. </title> <editor> In M. Maher, editor, </editor> <booktitle> Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 259-273, </pages> <address> Bonn, Germany, September 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The second equation above would simply be postponed as a solvable equational constraint. Based on our experience with constraint simplification in Elf [Pfe91a] and preliminary experiments, we believe that this will be a practical solution. In particular, the use of explicit substitutions, investigated in <ref> [DHKP96] </ref> relatively to Elf, seems to provide a hook for the required linearity constraints. 4.3 Related Work So far, only a very limited amount of research has been dedicated to unification algorithms for linear languages.
Reference: [DJ90] <editor> Nachum Dershowitz and Jean-Pierre Jouannaud. </editor> <booktitle> Handbook of Theoretical Computer Science, volume B, chapter Rewrite Systems, </booktitle> <pages> pages 243-320. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Well-known results in term-rewriting theory <ref> [DJ90] </ref> permit lifting this property, in the presence of termination (Theorem 2.8 here), to the reflexive and transitive closure of the above relation.
Reference: [Dug93] <author> Dominic Duggan. </author> <title> Unification with extended patterns. </title> <type> Technical Report CS-93-37, </type> <institution> University of Waterloo, Waterloo, </institution> <address> Ontario, Canada, </address> <month> July </month> <year> 1993. </year> <month> Revised March </month> <year> 1994 </year> <month> and September </month> <year> 1994. </year>
Reference-contexts: Lazy strategies are not 50 !ffi no pre-unification ! pre-unification [Hue75] patterns [Mil91] !ffi& no pre-unification !& pre-unification patterns <ref> [Dug93] </ref> !ffi&&gt; pre-unification (this paper) !&&gt; pre-unification patterns [FL96] ffi pre-unification? [Lev96] ? ? ? -& -&gt; viable in general this time because the heads of these operands are logical variables. Therefore, we must be prepared to non-deterministically consider all possible splits. <p> Unification in the restricted setting of higher-order patterns has been studied for these two languages in <ref> [Dug93] </ref> and [FL96], respectively. The appropriate restrictions of the rules in Figures 8-10 implement a general pre-unification procedure for these calculi. Differently from these proposals, our algorithm can solve any unification problem that admits a solution. <p> Despite these difficulties, the natural generalization of the notion of higher-order pattern introduced by <ref> [Dug93] </ref> and [FL96] for products to the linear case leads to a decidable unification problem for !ffi&&gt; . <p> Of some relevance in our context is Prehofer's thesis [Pre95] where he considers the specific case of unification in ! where the occurrences of logical variables are subject to linear restrictions. Duggan in <ref> [Dug93] </ref> extends Miller's work to a calculus akin to !& that includes product types and impredicative polymorphism [Pfe91b]. These two additions are orthogonal.
Reference: [FL96] <author> Roland Fettig and Bernd Lochner. </author> <title> Unification of higher-order patterns in a simply typed lambda-calculus with finite products and terminal type. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of the Seventh International Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 347-361, </pages> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year> <note> Springer-Verlag LNCS 1103. </note>
Reference-contexts: Lazy strategies are not 50 !ffi no pre-unification ! pre-unification [Hue75] patterns [Mil91] !ffi& no pre-unification !& pre-unification patterns [Dug93] !ffi&&gt; pre-unification (this paper) !&&gt; pre-unification patterns <ref> [FL96] </ref> ffi pre-unification? [Lev96] ? ? ? -& -&gt; viable in general this time because the heads of these operands are logical variables. Therefore, we must be prepared to non-deterministically consider all possible splits. <p> Unification in the restricted setting of higher-order patterns has been studied for these two languages in [Dug93] and <ref> [FL96] </ref>, respectively. The appropriate restrictions of the rules in Figures 8-10 implement a general pre-unification procedure for these calculi. Differently from these proposals, our algorithm can solve any unification problem that admits a solution. <p> Despite these difficulties, the natural generalization of the notion of higher-order pattern introduced by [Dug93] and <ref> [FL96] </ref> for products to the linear case leads to a decidable unification problem for !ffi&&gt; . <p> He implicitly formalizes this idea by giving an alternative formulation of this calculus that emphasizes the role of projections. Fettig and Lochner push this idea further in <ref> [FL96] </ref> by defining a calculus that replaces the need for projections with the possibility of abstracting over pairs and more generally tuples. Therefore, they admit terms of the form hx 1 ; : : : x n i: M .
Reference: [Gir87] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Linear logic <ref> [Gir87] </ref> enriches more traditional logical formalisms with a notion of consumable resource, which provides direct means for expressing and reasoning about mutable state. Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. <p> We study the unification problem in sublanguages of !ffi&&gt; and hint at the possibility of a practical implementation in Section 4. In order to facilitate our description in the available space, we must assume the reader familiar with traditional higher-order unification [Hue75] and linear logic <ref> [Gir87] </ref>. 2 A Linear Simply-Typed -Calculus This section defines the simply-typed linear -calculus !ffi&&gt; (Section 2.1) and presents an equivalent formulation, S !ffi&&gt; (Section 2.2), which is more convenient for describing and implementing unification.
Reference: [Gol81] <author> Warren D. Goldfarb. </author> <title> The undecidability of the second-order unification problem. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 225-230, </pages> <year> 1981. </year>
Reference-contexts: Differently from the first-order case, higher-order unification in Church's simply typed -calculus ! is undecidable and does not admit most general unifiers <ref> [Gol81] </ref>. Nevertheless sound and complete (although 1 possibly non-terminating) procedures have been proposed in order to enumerate solutions [JP76]. In particular, Huet's pre-unification algorithm [Hue75] computes unifiers in a non-redundant manner as constraints and has therefore been adopted in the implementation of higher-order logic programming languages [NM88].
Reference: [Her95a] <author> Hugo Herbelin. </author> <title> A -calculus structure isomorphic to Genzten-style sequent calculus structure. </title> <editor> In L. Pacholski and J. Tiuryn, editors, </editor> <booktitle> Computer Science Logic, Eighth Workshop | CSL'94, </booktitle> <pages> pages 61-75, </pages> <address> Kazimierz, Poland, 1995. </address> <publisher> Springer Verlag LNCS 933. </publisher>
Reference-contexts: This approach was suggested by an empirical study of higher-order logic programs based on ! terms [MP92] and is reminiscent of the notion of abstract Bohm trees <ref> [Her95a, Her95b] </ref>; its practical merits in our setting are currently assessed in an experimental implementation. The following grammar describes the syntax of S !ffi&&gt; : we write constructors as in !ffi&&gt; , but use new symbols to distinguish a spine operator from the corresponding term destructor. <p> This has the desirable effect of permitting only -long terms to be derivable in this calculus [CP97]: allowing arbitrary types on the right-hand side of the spine typing judgment corresponds to dropping this property, as we will see in Section 2.5. Abstract Bohm trees <ref> [Bar80, Her95a] </ref> are obtained in this manner. The mutual definition of the two typing judgments of S !ffi&&gt; is given in Figure 2.
Reference: [Her95b] <institution> Hugo Herbelin. Sequents qu'on calcule: de l'interpretation du calcul des sequents comme cal-cul de lambda-termes et comme calcul de strategies gagnantes. </institution> <type> PhD thesis, </type> <institution> Universite Paris 7, </institution> <year> 1995. </year>
Reference-contexts: This approach was suggested by an empirical study of higher-order logic programs based on ! terms [MP92] and is reminiscent of the notion of abstract Bohm trees <ref> [Her95a, Her95b] </ref>; its practical merits in our setting are currently assessed in an experimental implementation. The following grammar describes the syntax of S !ffi&&gt; : we write constructors as in !ffi&&gt; , but use new symbols to distinguish a spine operator from the corresponding term destructor.
Reference: [HM94] <author> Joshua Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic. </title> <journal> Information and Computation, </journal> <volume> 110(2) </volume> <pages> 327-365, </pages> <year> 1994. </year> <booktitle> A preliminary version appeared in the Proceedings of the Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 32-42, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. The only new aspect in the operational semantics of most proposals, such as Lolli <ref> [HM94] </ref>, Lygon [HP94] and Forum [Mil96], concerns the management of linear context formulas [CHP96]. In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. <p> such algorithm can be devised for linear sublanguages deprived of &gt; and of the corresponding constructor. !ffi&&gt; corresponds, via a natural extension of the Curry-Howard isomorphism, to the fragment of intuitionistic linear logic freely generated from the connectives !, ffi, & and &gt;, which constitutes the propositional core of Lolli <ref> [HM94] </ref> and LLF [CP96]. !ffi&&gt; is also the simply-typed variant of the term language of LLF and shares similarities with the calculus proposed in [Bar96]. Its theoretical relevance derives from the fact that it is the largest linear -calculus that admits unique long fi-normal forms. <p> The inference rules for this judgment are displayed in Figure 1. Deleting the terms that appear in them results in the usual rules for the (! ffi&&gt;) fragment of intuitionistic linear logic, ILL !ffi&&gt; <ref> [HM94] </ref>, in a natural deduction formulation. !ffi&&gt; and ILL !ffi&&gt; are related by a form of the Curry-Howard isomorphism.
Reference: [HP94] <author> James Harland and David Pym. </author> <title> A uniform proof-theoretic investigation of linear logic programming. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(2) </volume> <pages> 175-207, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. The only new aspect in the operational semantics of most proposals, such as Lolli [HM94], Lygon <ref> [HP94] </ref> and Forum [Mil96], concerns the management of linear context formulas [CHP96]. In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language.
Reference: [HP97] <author> James Harland and David Pym. </author> <title> Resource distribution via boolean constraints. </title> <editor> In W. McCune, editor, </editor> <booktitle> Proceedings of the Fourteenth International Conference on Automated Deduction | CADE-14, Townsville, </booktitle> <address> Australia, </address> <month> July </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: An actual implementation would avoid this addi tional non-determinism by postponing the choices between the four imitations. A detailed treatment of the necessary constraints between variables occurrences is beyond the scope of this paper (see Section 4.2 for further discussion; a similar technique is used in <ref> [HP97] </ref>). 4 Discussion In this section, we consider various sublanguages of S !ffi&&gt; (or equivalently !ffi&&gt; ) obtained by eliding some of the type operators and the corresponding term constructors and destructors (Section 4.1). <p> example above, the solution would be F ^ x 0 : a: c^(F 1 ^x 0 )^(F 2 ^x 0 ) with the additional constraint that if x 0 occurs in F 1 ^x 0 then it must be absorbed (by hi) in F 2 ^x 0 and vice versa <ref> [HP97] </ref>. The second equation above would simply be postponed as a solvable equational constraint. Based on our experience with constraint simplification in Elf [Pfe91a] and preliminary experiments, we believe that this will be a practical solution.
Reference: [Hue75] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: Differently from the first-order case, higher-order unification in Church's simply typed -calculus ! is undecidable and does not admit most general unifiers [Gol81]. Nevertheless sound and complete (although 1 possibly non-terminating) procedures have been proposed in order to enumerate solutions [JP76]. In particular, Huet's pre-unification algorithm <ref> [Hue75] </ref> computes unifiers in a non-redundant manner as constraints and has therefore been adopted in the implementation of higher-order logic programming languages [NM88]. Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. <p> We study the unification problem in sublanguages of !ffi&&gt; and hint at the possibility of a practical implementation in Section 4. In order to facilitate our description in the available space, we must assume the reader familiar with traditional higher-order unification <ref> [Hue75] </ref> and linear logic [Gir87]. 2 A Linear Simply-Typed -Calculus This section defines the simply-typed linear -calculus !ffi&&gt; (Section 2.1) and presents an equivalent formulation, S !ffi&&gt; (Section 2.2), which is more convenient for describing and implementing unification. <p> An algorithm that returns a set of solvable residual equations, besides a substitution with the above properties, is called a pre-unification procedure <ref> [Hue75] </ref>. The idea behind this approach is to postpone some solvable equations (the so called flex-flex equations) as constraints instead of enumerating their solutions, as done by a unification algorithm. Pre-unification is undecidable in both ! and !ffi&&gt; since it subsumes deciding whether a set of equations has a solution. <p> In particular, we must split 0 among the linear operands (rules fri llam and frp llam) so that, when the end of spine is generated, no linear parameter is left (rules fri nil and frp nil). Lazy strategies are not 50 !ffi no pre-unification ! pre-unification <ref> [Hue75] </ref> patterns [Mil91] !ffi& no pre-unification !& pre-unification patterns [Dug93] !ffi&&gt; pre-unification (this paper) !&&gt; pre-unification patterns [FL96] ffi pre-unification? [Lev96] ? ? ? -& -&gt; viable in general this time because the heads of these operands are logical variables. <p> First of all, the elision of ffi, & and &gt; reduces !ffi&&gt; to ! . The few applicable rules in Figures 8-10 constitute then a new presentation of Huet's procedure <ref> [Hue75] </ref>. The combined use of inference rules and of a spine calculus results in an elegant formulation that can be translated almost immediately into an efficient implementation. <p> However, we achieve only pre-unifiers since we keep flex-flex equations as constraints. Instead, when Levy's procedure terminates, it always produces a fully worked-out solution. Most research on higher-order unification has focused on the simply typed -calculus ! . The most influential work is still the seminal paper <ref> [Hue75] </ref> by Huet. The individuation of the pattern fragment by Miller [Mil91] and of a terminating and unitary algorithm for it had extensive applications and will influence the direction of our future work.
Reference: [IP96] <author> Samin Ishtiaq and David Pym. </author> <title> A relevant analysis of natural deduction, </title> <month> December </month> <year> 1996. </year> <type> Manuscript. </type>
Reference-contexts: In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. More recent proposals, such as the language of the linear logical framework LLF [Cer96, CP96] and the system RLF <ref> [IP96] </ref>, introduce linearity not only at the level of formulas, but also within terms. Consequently, implementations of these languages must solve higher-order equations on linear terms in order to instantiate existential variables. <p> The problem representation would therefore be more direct and compact in this language. The introduction of linear term languages in LLF and RLF has been motivated by a number of applications. Linear terms provide a statically checkable notation for natural deductions <ref> [IP96] </ref> or sequent derivations [CP96] in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [CP96] or sequences of moves in games [Cer96].
Reference: [JP76] <author> D. C. Jensen and T. Pietrzykowski. </author> <title> Mechanizing !-order type theory through unification. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 123-171, </pages> <year> 1976. </year>
Reference-contexts: Differently from the first-order case, higher-order unification in Church's simply typed -calculus ! is undecidable and does not admit most general unifiers [Gol81]. Nevertheless sound and complete (although 1 possibly non-terminating) procedures have been proposed in order to enumerate solutions <ref> [JP76] </ref>. In particular, Huet's pre-unification algorithm [Hue75] computes unifiers in a non-redundant manner as constraints and has therefore been adopted in the implementation of higher-order logic programming languages [NM88]. Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. <p> The possibility of achieving an algorithm a la Huet depends crucially on flex-flex equations being always solvable. If this property does not hold, as in some sublanguages of S !ffi&&gt; we will discuss in this paper, these equations must be analyzed with techniques similar to <ref> [JP76] </ref> or [Mil91]. We will now discuss a number of simple examples in order to gain familiarity with this algorithm. We will focus our attention on the flex-rigid and rigid-rigid cases.
Reference: [Lev96] <author> Jordi Levy. </author> <title> Linear second-order unification. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of the Seventh International Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 332-346, </pages> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year> <note> Springer-Verlag LNCS 1103. </note>
Reference-contexts: An example are Miller's higher-order patterns [Mil91], that have been implemented in the higher-order constraint logic programming language Elf [Pfe91a]. Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated <ref> [Lev96] </ref>. Unification in ! with linear restrictions on existential variables has been studied in [Pre95]. In this extended abstract, we investigate the unification problem in the linear simply-typed -calculus !ffi&&gt; . <p> Lazy strategies are not 50 !ffi no pre-unification ! pre-unification [Hue75] patterns [Mil91] !ffi& no pre-unification !& pre-unification patterns [Dug93] !ffi&&gt; pre-unification (this paper) !&&gt; pre-unification patterns [FL96] ffi pre-unification? <ref> [Lev96] </ref> ? ? ? -& -&gt; viable in general this time because the heads of these operands are logical variables. Therefore, we must be prepared to non-deterministically consider all possible splits. <p> In conclusion, pre-unification procedures in the sense of Huet are not achievable in the calculi with ffi but without &gt;. Finally, a restricted form of unification in the purely linear calculus ffi has been studied in <ref> [Lev96] </ref>. The above counterexamples clearly apply also in this setting, but we have no result about the decidability of higher-order unification in this fragment. and their properties as far as the existence of a pre-unification algorithm is concerned. <p> To our knowledge, the only strictly related work, besides the extensive treatment in this paper, is due to Levy. In <ref> [Lev96] </ref>, he studies a generalization of the contextual unification problem that corresponds to second-order unification in a formalism akin to the purely linear language ffi . He provides a sound and complete unification algorithm (flex-flex equations are indeed simplified) and proves its termination for three specific classes of equations.
Reference: [Mil91] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <journal> Journal of Logic and Computation, </journal> <volume> 1(4) </volume> <pages> 497-536, </pages> <year> 1991. </year>
Reference-contexts: Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. An example are Miller's higher-order patterns <ref> [Mil91] </ref>, that have been implemented in the higher-order constraint logic programming language Elf [Pfe91a]. Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated [Lev96]. <p> The possibility of achieving an algorithm a la Huet depends crucially on flex-flex equations being always solvable. If this property does not hold, as in some sublanguages of S !ffi&&gt; we will discuss in this paper, these equations must be analyzed with techniques similar to [JP76] or <ref> [Mil91] </ref>. We will now discuss a number of simple examples in order to gain familiarity with this algorithm. We will focus our attention on the flex-rigid and rigid-rigid cases. <p> In particular, we must split 0 among the linear operands (rules fri llam and frp llam) so that, when the end of spine is generated, no linear parameter is left (rules fri nil and frp nil). Lazy strategies are not 50 !ffi no pre-unification ! pre-unification [Hue75] patterns <ref> [Mil91] </ref> !ffi& no pre-unification !& pre-unification patterns [Dug93] !ffi&&gt; pre-unification (this paper) !&&gt; pre-unification patterns [FL96] ffi pre-unification? [Lev96] ? ? ? -& -&gt; viable in general this time because the heads of these operands are logical variables. Therefore, we must be prepared to non-deterministically consider all possible splits. <p> However, the non-determinism it introduces remains a problem, especially in logic programming. This issue is exacerbated in !ffi&&gt; due to its additional resource non-determinism during imitation and projections. For ! , this problem has been addressed by Miller's language of higher-order patterns L <ref> [Mil91] </ref>, which allows occurrences of logical variables to be applied to distinct parameters only. This syntactic restriction guarantees decidability and the existence of most general unifiers. <p> Instead, when Levy's procedure terminates, it always produces a fully worked-out solution. Most research on higher-order unification has focused on the simply typed -calculus ! . The most influential work is still the seminal paper [Hue75] by Huet. The individuation of the pattern fragment by Miller <ref> [Mil91] </ref> and of a terminating and unitary algorithm for it had extensive applications and will influence the direction of our future work. These ideas have been extended in [Pfe91b] to more general languages such as the calculus of constructions [CH88], which includes dependent types, polymorphism and type constructors definition.
Reference: [Mil96] <author> Dale Miller. </author> <title> A multiple-conclusion specification logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 165(1) </volume> <pages> 201-232, </pages> <year> 1996. </year>
Reference-contexts: Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. The only new aspect in the operational semantics of most proposals, such as Lolli [HM94], Lygon [HP94] and Forum <ref> [Mil96] </ref>, concerns the management of linear context formulas [CHP96]. In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language.
Reference: [Min98] <author> Grigori Mints. </author> <title> Linear lambda-terms and natural deduction. </title> <journal> Studia Logica, </journal> <note> 1998. To appear. </note>
Reference-contexts: However, non-standard presentations bypass commutative conversions and therefore extend the class of strongly normalizing languages (for example allowing as a type constructor), although at the cost of added complexity <ref> [Min98] </ref>. We will not pursue this thread.
Reference: [MP92] <author> Spiro Michaylov and Frank Pfenning. </author> <title> An empirical study of the runtime behavior of higher-order logic programs. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings of the Workshop on the Prolog Programming Language, </booktitle> <pages> pages 257-271, </pages> <address> Philadelphia, Pennsylvania, </address> <month> July </month> <year> 1992. </year> <institution> University of Pennsylvania. </institution> <note> Available as Technical Report MS-CIS-92-86. </note>
Reference-contexts: Application and ";" have opposite associativity so that M 1 is the innermost subterm of M while U 1 is outermost in the spine of U . This approach was suggested by an empirical study of higher-order logic programs based on ! terms <ref> [MP92] </ref> and is reminiscent of the notion of abstract Bohm trees [Her95a, Her95b]; its practical merits in our setting are currently assessed in an experimental implementation.
Reference: [NM88] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Fifth International Logic Programming Conference, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Washington, August 1988. </address> <publisher> MIT Press. </publisher> <pages> 55 </pages>
Reference-contexts: Nevertheless sound and complete (although 1 possibly non-terminating) procedures have been proposed in order to enumerate solutions [JP76]. In particular, Huet's pre-unification algorithm [Hue75] computes unifiers in a non-redundant manner as constraints and has therefore been adopted in the implementation of higher-order logic programming languages <ref> [NM88] </ref>. Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. An example are Miller's higher-order patterns [Mil91], that have been implemented in the higher-order constraint logic programming language Elf [Pfe91a]. <p> Patterns in linear language have not been investigated yet. Some considerations can be found in the next section. 4.2 Towards a Practical Implementation Huet's algorithm for pre-unification in ! has been implemented in general proof search engines such as Isabelle [NP92] and logic programming languages such as Prolog <ref> [NM88] </ref> and shown itself to be reasonably efficient in practice. However, the non-determinism it introduces remains a problem, especially in logic programming. This issue is exacerbated in !ffi&&gt; due to its additional resource non-determinism during imitation and projections.
Reference: [NP92] <editor> Tobias Nipkow and Lawrence C. Paulson. Isabelle-91. In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 673-676, </pages> <address> Saratoga Springs, NY, </address> <year> 1992. </year> <note> Springer-Verlag LNAI 607. System abstract. </note>
Reference-contexts: Patterns in linear language have not been investigated yet. Some considerations can be found in the next section. 4.2 Towards a Practical Implementation Huet's algorithm for pre-unification in ! has been implemented in general proof search engines such as Isabelle <ref> [NP92] </ref> and logic programming languages such as Prolog [NM88] and shown itself to be reasonably efficient in practice. However, the non-determinism it introduces remains a problem, especially in logic programming. This issue is exacerbated in !ffi&&gt; due to its additional resource non-determinism during imitation and projections.
Reference: [Pfe91a] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. An example are Miller's higher-order patterns [Mil91], that have been implemented in the higher-order constraint logic programming language Elf <ref> [Pfe91a] </ref>. Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated [Lev96]. Unification in ! with linear restrictions on existential variables has been studied in [Pre95]. <p> This syntactic restriction guarantees decidability and the existence of most general unifiers. An algorithm that solves equations in the pattern fragment but postpones as constraints any non L equation has been successfully implemented in the higher-order logic programming language Elf <ref> [Pfe91a] </ref>. Unfortunately, an analogous restriction for !ffi&&gt; which would cover the situations arising in practice does not admit most general unifiers. <p> The second equation above would simply be postponed as a solvable equational constraint. Based on our experience with constraint simplification in Elf <ref> [Pfe91a] </ref> and preliminary experiments, we believe that this will be a practical solution.
Reference: [Pfe91b] <author> Frank Pfenning. </author> <title> Unification and anti-unification in the Calculus of Constructions. </title> <booktitle> In Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 74-85, </pages> <address> Amsterdam, The Nether-lands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: The most influential work is still the seminal paper [Hue75] by Huet. The individuation of the pattern fragment by Miller [Mil91] and of a terminating and unitary algorithm for it had extensive applications and will influence the direction of our future work. These ideas have been extended in <ref> [Pfe91b] </ref> to more general languages such as the calculus of constructions [CH88], which includes dependent types, polymorphism and type constructors definition. <p> Duggan in [Dug93] extends Miller's work to a calculus akin to !& that includes product types and impredicative polymorphism <ref> [Pfe91b] </ref>. These two additions are orthogonal. The basic intuition behind Duggan's treatment of the pairing constructs is that distinct projection sequences applied to a given parameter can be viewed as distinct parameters as far as Miller's definition of patterns is concerned.
Reference: [Pre95] <author> Christian Prehofer. </author> <title> Solving Higher-Order Equations: From Logic to Programming. </title> <type> PhD thesis, </type> <institution> Technische Universitat Munchen, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated [Lev96]. Unification in ! with linear restrictions on existential variables has been studied in <ref> [Pre95] </ref>. In this extended abstract, we investigate the unification problem in the linear simply-typed -calculus !ffi&&gt; . We give a pre-unification procedure in the style of Huet and discuss the new sources of non-determinism due to linearity. <p> These ideas have been extended in [Pfe91b] to more general languages such as the calculus of constructions [CH88], which includes dependent types, polymorphism and type constructors definition. Of some relevance in our context is Prehofer's thesis <ref> [Pre95] </ref> where he considers the specific case of unification in ! where the occurrences of logical variables are subject to linear restrictions. Duggan in [Dug93] extends Miller's work to a calculus akin to !& that includes product types and impredicative polymorphism [Pfe91b]. These two additions are orthogonal.

References-found: 32

