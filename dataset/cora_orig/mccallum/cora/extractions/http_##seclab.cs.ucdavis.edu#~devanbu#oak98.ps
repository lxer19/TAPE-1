URL: http://seclab.cs.ucdavis.edu/~devanbu/oak98.ps
Refering-URL: http://seclab.cs.ucdavis.edu/papers.html
Root-URL: http://www.cs.ucdavis.edu
Email: stubblebine@research.att.com devanbu@cs.ucdavis.edu  
Title: Stack and Queue Integrity on Hostile Platforms  
Author: Premkumar T. Devanbu Stuart G. Stubblebine 
Address: Florham Park, NJ 07932 USA Davis, California CA 95616 USA  
Affiliation: Department of Computer Science AT&T Laboratories|Research University of California  
Abstract: When computationally intensive tasks have to be carried out on trusted, but limited, platforms such as smart cards, it becomes necessary to compensate for the limited resources (memory, CPU speed) by offloading implementations of data structures on to an available (but insecure, untrusted) fast co-processor. However, data structures such as stacks, queues, RAMS, and hash tables can be corrupted (and made to behave incorrectly) by a potentially hostile implementation platform or by an adversary knowing or choosing data structure operations. This paper examines approaches that can detect violations of datastructure invariants, while placing limited demands on the resources of the secure computing platform. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Javacard 2.0 Application Programming Interfaces, Sun Micro-systems, Inc., </institution> <month> October 13, </month> <year> 1997. </year> <note> (See also: http://java.sun.com/java/- products/javacard). </note>
Reference-contexts: 1 Introduction Smart cards, set-top boxes, consumer electronics and other forms of trusted hardware [2, 3, 16] have been available (or are being proposed <ref> [1] </ref>) for applications such as electronic commerce. We shall refer to these devices as T . These devices are typically composed of a circuit card encased in epoxy or a similar substance, that has been strewn with various electronic tamper-detection devices.
Reference: [2] <institution> Spyrus Product Guide, Spyrus, Inc. </institution> <note> (See also: http://www.spyrus.com). </note>
Reference-contexts: 1 Introduction Smart cards, set-top boxes, consumer electronics and other forms of trusted hardware <ref> [2, 3, 16] </ref> have been available (or are being proposed [1]) for applications such as electronic commerce. We shall refer to these devices as T .
Reference: [3] <institution> The Mondex Magazine, Mondex International Limited, </institution> <month> July </month> <year> 1997. </year> <note> (See also: http://www .mondex.com). </note>
Reference-contexts: 1 Introduction Smart cards, set-top boxes, consumer electronics and other forms of trusted hardware <ref> [2, 3, 16] </ref> have been available (or are being proposed [1]) for applications such as electronic commerce. We shall refer to these devices as T .
Reference: [4] <author> Nancy M. Amato and Michael C. Loui. </author> <title> Checking linked data structures. </title> <booktitle> In Proceedings of the 24th Annual International Symposium on Fault-Tolerant Computing (FTCS), </booktitle> <year> 1994. </year>
Reference-contexts: Data structure operations are performed in conjunctions with modifications on the signatures to maintain a "digested" form of the invariants. This approach differs from earlier work <ref> [4, 5] </ref>. Our protocols are much simpler. We use O (1) memory in the trusted computer, and transfer only O (1) amount of data for each push and pop operation in an on-line mode. <p> Previous approaches used a O (log (n)) trusted memory and O (log (n)) data transfer for each operation (where n is the size of the stack or queue). However, previous work <ref> [4, 5] </ref> assumed extremely powerful adversaries (information theoretic bounds). We do follow in this line of work, but with quite different techniques that are applicable with computationally bounded adversaries. This paper is organized as follows. In Section 2, we present goals, threats, and related work. <p> Thus, we do not attempt to replicate data structures and operations. The sharing of data structures by multiple secure processors is also beyond the scope of this paper. 2.1 Related Work This work follows the memory protection investigations of <ref> [4, 5] </ref>, which considered the problem of verifying the correctness of a large memory of size n bits maintained by an all-powerful adversary P , subject to update requests from originator V with only a limited amount of trusted memory. (Most of these schemes are based on Merkle signature trees [12] <p> This area is a topic of future research. 8 Conclusion We have described protocols by which resource-limited, trusted computers can store stacks and queues on untrusted hosts while retaining only a constant amount of memory in the trusted machine. Tahis approach differs from earlier work <ref> [4, 5] </ref>. Our protocols are much simpler. We use O (1) memory in the trusted computer, and transfer only O (1) amount of data for each push and pop operation in an on-line mode.
Reference: [5] <author> Manuel Blum, William Evans, Peter Gemmell, Sampath Kannan, and Moni Noar. </author> <title> Checking the correctness of memories. </title> <journal> Algorithmica, </journal> 12(2/3):225-244, 1994. Originally appeared in FOCS <volume> 91. </volume>
Reference-contexts: Data structure operations are performed in conjunctions with modifications on the signatures to maintain a "digested" form of the invariants. This approach differs from earlier work <ref> [4, 5] </ref>. Our protocols are much simpler. We use O (1) memory in the trusted computer, and transfer only O (1) amount of data for each push and pop operation in an on-line mode. <p> Previous approaches used a O (log (n)) trusted memory and O (log (n)) data transfer for each operation (where n is the size of the stack or queue). However, previous work <ref> [4, 5] </ref> assumed extremely powerful adversaries (information theoretic bounds). We do follow in this line of work, but with quite different techniques that are applicable with computationally bounded adversaries. This paper is organized as follows. In Section 2, we present goals, threats, and related work. <p> Thus, we do not attempt to replicate data structures and operations. The sharing of data structures by multiple secure processors is also beyond the scope of this paper. 2.1 Related Work This work follows the memory protection investigations of <ref> [4, 5] </ref>, which considered the problem of verifying the correctness of a large memory of size n bits maintained by an all-powerful adversary P , subject to update requests from originator V with only a limited amount of trusted memory. (Most of these schemes are based on Merkle signature trees [12] <p> They also describe implementations of stacks and queues <ref> [5] </ref>. The stack implementation uses log (H) memory accesses for operations on a stack of height H. Our approach also relates to, but differs from the work of Lamport [10]. <p> Therefore, an incorrect queue operation will be detected via a bad signature. 5 Schemes for RAM and Trees There have been several schemes proposed in the literature to handle a random access memory (RAM) <ref> [5] </ref>. Most of these schemes are based on Merkle signature trees [12]. <p> This area is a topic of future research. 8 Conclusion We have described protocols by which resource-limited, trusted computers can store stacks and queues on untrusted hosts while retaining only a constant amount of memory in the trusted machine. Tahis approach differs from earlier work <ref> [4, 5] </ref>. Our protocols are much simpler. We use O (1) memory in the trusted computer, and transfer only O (1) amount of data for each push and pop operation in an on-line mode.
Reference: [6] <author> P. Devanbu, P. W. Fong, and S. Stubblebine. </author> <title> Techniques for trusted software engineering. </title> <booktitle> In Proceedings of the Twentieth International Conference on Software Engineering, </booktitle> <year> 1998. </year>
Reference-contexts: These resources are not a limitation in a few applications areas as such as cash cards, identity cards etc. However, for general purpose multi-application cards, these resource limitations are significant. We have been exploring the use of trusted hardware in software engineering <ref> [7, 6] </ref>. (see Section 6). In this context, it becomes necessary store large amounts of data in the form of various data structures (stacks, queues, arrays, dynamic/static symbol tables, various types of trees, etc.). Such data structures cannot fit into the limited resources on the T device. <p> Unlike secure virtual memory schemes, which must be carefully implemented and tuned, our schemes are relatively simple, and can be built by an application programmer. 6 Applications The problem of checking large data structures with limited memory was motivated by new applications for software tools <ref> [7, 6] </ref>. The goal of this work is to place trusted software tools (static analyzers, type checkers, proof checkers, compilers/instrumenters, etc.) in trusted hardware; the output of these tools would be attested by a signature in a public-key crypto system. One particular application concerns Java T M byte-code verification [11]. <p> This resource-intensive data usage taxes the resources of all but the most powerful (and expensive) T devices. Another application discussed in <ref> [6] </ref> is placing a proof checker in a T device. Necula [13] suggests that mobile code should carry with it a proof of an applicable safety property. Unfortunately, such proofs reveal a great deal about data structure and layouts, loop invariants and algorithms.
Reference: [7] <author> P. Devanbu and S. G. Stubblebine. </author> <title> Cryptographic verification of test coverage claims. </title> <booktitle> In Proceedings of The Fifth ACM/SIGSOFT Symposium on the foundations of software engineering, </booktitle> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1997. </year>
Reference-contexts: These resources are not a limitation in a few applications areas as such as cash cards, identity cards etc. However, for general purpose multi-application cards, these resource limitations are significant. We have been exploring the use of trusted hardware in software engineering <ref> [7, 6] </ref>. (see Section 6). In this context, it becomes necessary store large amounts of data in the form of various data structures (stacks, queues, arrays, dynamic/static symbol tables, various types of trees, etc.). Such data structures cannot fit into the limited resources on the T device. <p> Unlike secure virtual memory schemes, which must be carefully implemented and tuned, our schemes are relatively simple, and can be built by an application programmer. 6 Applications The problem of checking large data structures with limited memory was motivated by new applications for software tools <ref> [7, 6] </ref>. The goal of this work is to place trusted software tools (static analyzers, type checkers, proof checkers, compilers/instrumenters, etc.) in trusted hardware; the output of these tools would be attested by a signature in a public-key crypto system. One particular application concerns Java T M byte-code verification [11].
Reference: [8] <author> O. Goldreich. </author> <title> Towards a theory of software protection and simulation by oblivious rams. </title> <booktitle> In Proceedings of the 19th Annual Symposium on Theory of Computing. ACM, </booktitle> <year> 1987. </year>
Reference-contexts: We also perform only a constant number of untrusted memory operations for each stack push and pop. We assume a "signature scheme" that is collision/computation resistant and 2 nd preim-age resistant. Goldreich <ref> [8] </ref> and Ostrovsky [14] give solutions for oblivious machines. A machine is oblivious if the sequence in which it accesses memory locations is equivalent for any two programs with the same running time.
Reference: [9] <author> John V. Guttag and James J. Horning. </author> <title> LARCH: Languages and Tools for Formal Specification. </title> <publisher> Springer Verlag. </publisher>
Reference-contexts: Definition 1 An ideal stack is one which works correctly according to the standard specification of a stack. Specifications of a stack can be found on page 2, and in <ref> [9] </ref> (page 170). Non-ideal stacks only show their flaws when a pop is executed that returns a value other than what should be on the top of an ideal stack. <p> hT i Interface nq : QueuehT i fi T ! QueuehT i dq: QueuehT i ! T newhT i : unit ! QueuehT i deletehT i : QueuehT i ! unit Axiomatization is not provided; it can be found in standard texts on formal specification, such as Gut-tag & Horning <ref> [9] </ref>. As in the case of stacks, we assume messages between T and H are sent over an authenticated channel having message stream integrity, bit-string entries on the queue, and (for simplicity) a new signing key for each queue instance.
Reference: [10] <author> L. Lamport. </author> <title> Password Identification with Insecure Communications. </title> <journal> Communications of the ACM, </journal> <month> Nov </month> <year> 1981. </year>
Reference-contexts: They also describe implementations of stacks and queues [5]. The stack implementation uses log (H) memory accesses for operations on a stack of height H. Our approach also relates to, but differs from the work of Lamport <ref> [10] </ref>. His one-time password scheme precomputes a chain of hashes on a secret w with the sequence: w; H (w); H (H (w)); : : : ; H t (w).
Reference: [11] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java T M Virtual Machine specification. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mass., USA, </address> <year> 1996. </year>
Reference-contexts: The goal of this work is to place trusted software tools (static analyzers, type checkers, proof checkers, compilers/instrumenters, etc.) in trusted hardware; the output of these tools would be attested by a signature in a public-key crypto system. One particular application concerns Java T M byte-code verification <ref> [11] </ref>. This is a process similar to type-checking that is carried out on Java T M virtual machine (JVM) programs. The JVM is a stack-oriented machine. <p> Performance, security, configuration management, and intellectual property protection advantages are claimed when bytecode verification and similar static analysis processes are conducted by a a trusted T machine. The result of the analysis is attested by a (pubic-key based) cryptographic signature on the mobile code. The bytecode verification algorithm <ref> [11] </ref> involves, inter alia a) maintaining an agenda of control flow paths to be expanded, b) computing the state of evaluation stack, c) looking up the typing rules for various types of instructions d) maintaining symbol tables of variables.
Reference: [12] <author> R. C. Merkle. </author> <title> A certified digital signature. </title> <booktitle> In Advances in Cryptology-Crypto '89, </booktitle> <year> 1989. </year>
Reference-contexts: [4, 5], which considered the problem of verifying the correctness of a large memory of size n bits maintained by an all-powerful adversary P , subject to update requests from originator V with only a limited amount of trusted memory. (Most of these schemes are based on Merkle signature trees <ref> [12] </ref> which is described in further detail in Section 5.) It is shown that P can fool V with an incorrect memory whenever V has access to less than log (n) bits of trusted memory. They also describe implementations of stacks and queues [5]. <p> Therefore, an incorrect queue operation will be detected via a bad signature. 5 Schemes for RAM and Trees There have been several schemes proposed in the literature to handle a random access memory (RAM) [5]. Most of these schemes are based on Merkle signature trees <ref> [12] </ref>.
Reference: [13] <author> George Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Proceedings of POPL 97. ACM SIGPLAN, </booktitle> <year> 1997. </year>
Reference-contexts: This resource-intensive data usage taxes the resources of all but the most powerful (and expensive) T devices. Another application discussed in [6] is placing a proof checker in a T device. Necula <ref> [13] </ref> suggests that mobile code should carry with it a proof of an applicable safety property. Unfortunately, such proofs reveal a great deal about data structure and layouts, loop invariants and algorithms. Vendors may balk at revealing such intimate details of their products.
Reference: [14] <author> R. Ostrovsky. </author> <title> Efficient computations on oblivious rams. </title> <booktitle> In Proceedings of the 19th Annual Symposium on Theory of Computing. ACM, </booktitle> <year> 1990. </year>
Reference-contexts: We also perform only a constant number of untrusted memory operations for each stack push and pop. We assume a "signature scheme" that is collision/computation resistant and 2 nd preim-age resistant. Goldreich [8] and Ostrovsky <ref> [14] </ref> give solutions for oblivious machines. A machine is oblivious if the sequence in which it accesses memory locations is equivalent for any two programs with the same running time.
Reference: [15] <author> Robert Wahbe, Steven Lucco, Thomas Anderson, and Susan Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the Symposium on Operating Systems Principles, </booktitle> <year> 1993. </year>
Reference-contexts: Yet another application is the creation of trusted, signed analysis products (control dependency graphs, data dependency graphs, slices etc.) to accompany mobile code. Such trusted analysis products can be used by security environments to optimally "sandbox" <ref> [15] </ref> mobile code. Techniques such as the ones we suggest will form a useful implementation technique in placing trusted software analysis tools in trusted hardware.
Reference: [16] <author> Bennet Yee and Doug Tygar. </author> <title> Secure coprocessors in electronic commerce applications. </title> <booktitle> In Proceedings of The First USENIX Workshop on Electronic Commerce, </booktitle> <address> New York, New York, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Smart cards, set-top boxes, consumer electronics and other forms of trusted hardware <ref> [2, 3, 16] </ref> have been available (or are being proposed [1]) for applications such as electronic commerce. We shall refer to these devices as T .
References-found: 16

