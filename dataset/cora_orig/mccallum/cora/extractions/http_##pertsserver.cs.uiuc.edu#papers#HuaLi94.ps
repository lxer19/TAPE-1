URL: http://pertsserver.cs.uiuc.edu/papers/HuaLi94.ps
Refering-URL: http://pertsserver.cs.uiuc.edu/papers/
Root-URL: http://www.cs.uiuc.edu
Email: fthuang, janeliug@cs.uiuc.edu  
Title: Predicting the Worst-Case Execution Time of the Concurrent Execution of Instructions and Cycle-Stealing DMA I/O Operations  
Author: Tai-Yi Huang and Jane W.-S. Liu 
Address: Urbana, IL 61801  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Date: June 1995.  May 3, 1995  
Note: ACM SIGPLAN Workshop on Languages, Compilers and Tools for Real-Time Systems, La Jolla, California,  
Abstract: This paper describes an efficient algorithm which gives a bound on the worst-case execution times of the concurrent execution of CPU instructions and cycle-stealing DMA I/O operations. Simulations of several programs were conducted to evaluate this algorithm. Compared with the traditional pessimistic approach, the bound on the worst-case execution time produced by the algorithm is significantly tighter. For a sample program that multiplies two matrices while the I/O bus is fully utilized, our algorithm achieves a 39% improvement in the accuracy of the prediction. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> MC68000 Family: </author> <title> CPU32 reference manual. </title> <address> Mo-torola, </address> <year> 1990. </year>
Reference-contexts: We execute these programs in a simulator to obtain their execution traces. The timing information of each instruction in the traces is given by <ref> [1] </ref>. Since the clock frequency of MC68332 microprocessor is 16.78 MHz, the period of a clock cycle T c is 60 ns. Assuming that a 0-wait memory is used and the size of data in each DMA transfer is equal to the bus bandwidth, we set DT to 120 ns. <p> For example, the instructions MULU.W D1,D2 and DIVU.W D2,D0 are long instructions, and MOVE.L (A3)+,D0 and ADD.L D0,D1 are short instructions. Because the delay caused by cycle-stealing on each instruction is bounded by Eq. (2), Input: thenumber of CPU instructions, N , and the instructions inst <ref> [1] </ref>, inst [2],: : : , inst [N ] in the stream S. thenumber of data transfers, M , required in the cycle-stealing DMA I/O operation. the execution time of each instruction, inst [i].execution time, and its machine cycles, for i = 1; 2; : : :; N . - BMT
Reference: [2] <author> Mark H. Klein and Thomas Ralya. </author> <title> An analysis of input/output paradigms for real-time systems. </title> <type> Technical Report CMU/SEI-90-TR-19, </type> <institution> CMU Software Engineering Institute, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: For example, the instructions MULU.W D1,D2 and DIVU.W D2,D0 are long instructions, and MOVE.L (A3)+,D0 and ADD.L D0,D1 are short instructions. Because the delay caused by cycle-stealing on each instruction is bounded by Eq. (2), Input: thenumber of CPU instructions, N , and the instructions inst [1], inst <ref> [2] </ref>,: : : , inst [N ] in the stream S. thenumber of data transfers, M , required in the cycle-stealing DMA I/O operation. the execution time of each instruction, inst [i].execution time, and its machine cycles, for i = 1; 2; : : :; N . - BMT and DT, <p> Our work encourages the inclusion of I/O instructions in real-time programs. Because of the hardware-dependent features of I/O instructions, determining their WCET becomes extremely difficult. Traditionally, I/O instructions are not allowed or restricted to appear at the predefined areas such as the beginning and end of a program <ref> [2] </ref> [10]. By decomposing timing related information in a table-driven manner, our work can be used to predict the WCET of a program containing DMA I/O instructions. The future work will build a tool capable of predicting the WCET of programs containing any I/O instruction in a table-driven manner.
Reference: [3] <author> Aloysius K. Mok, Prasanna Amerasinghe, Moyer Chen, and Kamtorn Tantisirivat. </author> <title> Evaluating tight execution time bounds of programs by annotations. </title> <booktitle> In Proceedings of the Sixth IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 272-279, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: A task which overruns may lead to missed deadlines and the failure of the whole system. For this reason, how to bound the WCET of programs has received a great deal of attention in recent years. Mok et al. <ref> [3] </ref> developed a graphical tool to analyze the timing behavior of assembly language programs and to bound their WCET. This tool requires that the maximum iteration number of each loop structure be known. Park and Shaw [6, 7] developed a similar method for source-level programs.
Reference: [4] <author> Frank Mueller, David Whalley, and Marion Har-mon. </author> <title> Predicting instruction cache behavior. </title> <booktitle> In ACM SIGPLAN Workshop on Language, Compiler, and Tool Support for Real-Time Systems, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: To predict the WCET of concurrent programs, Niehaus [5] developed a semantics-preserving transformation for concurrent programming language constructs such as critical sections and synchronous communication. Zhang, Burns and Nichol-son [11] developed a mathematical model to predict the WCET of programs executed on a two-stage pipeline. Mueller, Whalley and Harmon <ref> [4] </ref> developed a static cache simulation method to predict instruction cache behavior and bound its worst-case performance. This paper first analyzes the delay caused by cycle-stealing direct-memory access (DMA) I/O activities.
Reference: [5] <author> Douglas Niehaus. </author> <title> Program representation and translation for predictable real-time systems. </title> <booktitle> In Proceedings of Real-Time Systems Symposium, </booktitle> <pages> pages 53-63, </pages> <year> 1991. </year>
Reference-contexts: Their experiment showed that with this valuable information, the gap between the calculated WCET and the real WCET can be reduced significantly. To predict the WCET of concurrent programs, Niehaus <ref> [5] </ref> developed a semantics-preserving transformation for concurrent programming language constructs such as critical sections and synchronous communication. Zhang, Burns and Nichol-son [11] developed a mathematical model to predict the WCET of programs executed on a two-stage pipeline.
Reference: [6] <author> Chang Yun Park. </author> <title> Predicting program execution times by analyzing static and dynamic program paths. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 5 </volume> <pages> 31-62, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Mok et al. [3] developed a graphical tool to analyze the timing behavior of assembly language programs and to bound their WCET. This tool requires that the maximum iteration number of each loop structure be known. Park and Shaw <ref> [6, 7] </ref> developed a similar method for source-level programs. Their dynamic path analysis method eliminates infeasible execution paths and thus tightens the prediction of the WCET. Pusher and Koza [8] introduced several new language constructs with which programmers can describe the timing behavior of their programs.
Reference: [7] <author> Chang Yun Park and Alan C. Shaw. </author> <title> Experiments with a program timing tool based on source-level timing schema. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 48-57, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Mok et al. [3] developed a graphical tool to analyze the timing behavior of assembly language programs and to bound their WCET. This tool requires that the maximum iteration number of each loop structure be known. Park and Shaw <ref> [6, 7] </ref> developed a similar method for source-level programs. Their dynamic path analysis method eliminates infeasible execution paths and thus tightens the prediction of the WCET. Pusher and Koza [8] introduced several new language constructs with which programmers can describe the timing behavior of their programs.
Reference: [8] <author> P. Puschner and C. Koza. </author> <title> Calculating the maximum execution time of real-time programs. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 1 </volume> <pages> 159-176, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: This tool requires that the maximum iteration number of each loop structure be known. Park and Shaw [6, 7] developed a similar method for source-level programs. Their dynamic path analysis method eliminates infeasible execution paths and thus tightens the prediction of the WCET. Pusher and Koza <ref> [8] </ref> introduced several new language constructs with which programmers can describe the timing behavior of their programs. Their experiment showed that with this valuable information, the gap between the calculated WCET and the real WCET can be reduced significantly.
Reference: [9] <institution> The VMEbus Specification. Motorola, </institution> <year> 1985. </year>
Reference-contexts: In this mode, it is allowed to access the bus only when the CPU is in an E cycle. The protocol we use to regulate the bus contention between the DMA controller and the CPU is based on the VMEbus specification <ref> [9] </ref>. Because this protocol is sufficiently general, the analysis method presented in Section 3 for bounding the delay caused by cycle-stealing DMA I/O activities is applicable to many other commonly used buses. To become the bus master, the DMA controller first sends a bus request.
Reference: [10] <author> A. Vrchoticky and P. Puschner. </author> <title> On the feasi-biity of response time predictions-an experimental evaluation. </title> <type> Technical Report 2/91, </type> <institution> Institute fur Technische Informatik Technische Universitat Wien, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Our work encourages the inclusion of I/O instructions in real-time programs. Because of the hardware-dependent features of I/O instructions, determining their WCET becomes extremely difficult. Traditionally, I/O instructions are not allowed or restricted to appear at the predefined areas such as the beginning and end of a program [2] <ref> [10] </ref>. By decomposing timing related information in a table-driven manner, our work can be used to predict the WCET of a program containing DMA I/O instructions. The future work will build a tool capable of predicting the WCET of programs containing any I/O instruction in a table-driven manner.
Reference: [11] <author> N. Zhang, A. Burns, and M. Nicholson. </author> <title> Pipelined processors and worst case execution times. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 5 </volume> <pages> 319-343, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: To predict the WCET of concurrent programs, Niehaus [5] developed a semantics-preserving transformation for concurrent programming language constructs such as critical sections and synchronous communication. Zhang, Burns and Nichol-son <ref> [11] </ref> developed a mathematical model to predict the WCET of programs executed on a two-stage pipeline. Mueller, Whalley and Harmon [4] developed a static cache simulation method to predict instruction cache behavior and bound its worst-case performance.
References-found: 11

