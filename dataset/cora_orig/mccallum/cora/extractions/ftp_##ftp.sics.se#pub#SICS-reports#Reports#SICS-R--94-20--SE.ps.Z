URL: ftp://ftp.sics.se/pub/SICS-reports/Reports/SICS-R--94-20--SE.ps.Z
Refering-URL: http://www.sics.se/libindex.html
Root-URL: 
Title: On the Decidability of Process Equivalences for the -calculus  
Author: Mads Dam 
Note: 1 Work supported by ESPRIT BRA project 8130 "LOMAPS"  
Date: November 14, 1994  
Affiliation: Swedish Institute of Computer Science  
Pubnum: SICS Research Report RR:94-20  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Amadio. </author> <title> A uniform presentation of CHOCS and -calculus. </title> <institution> Rapport de Recherche 1726, INRIA-Lorraine, Nancy, </institution> <year> 1992. </year>
Reference-contexts: In this paper we provide the basic tools to show decidability for the finite control fragment for a number of equivalences, including late or early, strong or weak bisimulation equivalence (c.f. [12]), and open (or uniform <ref> [1] </ref>) bisimulation equivalence [17] 2 .
Reference: [2] <author> D. </author> <title> Caucal. </title> <journal> Graphes canoniques des graphes algebriques. Informatique Theorique et Applications (RAIRO), </journal> <volume> 24(4) </volume> <pages> 339-352, </pages> <year> 1990. </year>
Reference-contexts: Though the technical details differ, the basic approach we use to show decidability is quite familiar from other recent decidability results in process algebra such as <ref> [2, 3, 6, 7] </ref>, namely by showing that up to the equivalence concerned the state space can be represented in a finitary manner. The tools consist of two key Lemmas, proofs of which are given in the paper: 1.
Reference: [3] <author> S. Christensen, H. Huttel, and C. Stirling. </author> <title> Bisimulation equivalence is decidable for all context-free processes. </title> <booktitle> In Proc. </booktitle> <editor> CONCUR'92, W. R. Cleaveland (ed.), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 630 </volume> <pages> 138-147, </pages> <year> 1992. </year>
Reference-contexts: Though the technical details differ, the basic approach we use to show decidability is quite familiar from other recent decidability results in process algebra such as <ref> [2, 3, 6, 7] </ref>, namely by showing that up to the equivalence concerned the state space can be represented in a finitary manner. The tools consist of two key Lemmas, proofs of which are given in the paper: 1.
Reference: [4] <author> M. Dam. </author> <title> Model checking mobile processes. </title> <booktitle> In Proc. CONCUR'93, Lecture Notes in Computer Science, </booktitle> <volume> 715 </volume> <pages> 22-36, </pages> <year> 1993. </year> <note> Full version in SICS report RR94:1, </note> <year> 1994. </year>
Reference-contexts: The notion of open bisimulation equivalence was specifically formulated with an eye on efficiency concerns. In the area of model checking a close relative to the present work is the decidability result with respect to an extended version of the modal -calculus of <ref> [4] </ref>. 2 For open bisimulation equivalence decidability is already known [17] 2 2 The Polyadic -calculus, syntax We use a slight extension of Milner's polyadic -calculus, introduced in [4]. <p> a close relative to the present work is the decidability result with respect to an extended version of the modal -calculus of <ref> [4] </ref>. 2 For open bisimulation equivalence decidability is already known [17] 2 2 The Polyadic -calculus, syntax We use a slight extension of Milner's polyadic -calculus, introduced in [4]. Letters x; y; z; : : : range over names of which there is a countably infinite supply, A; B range over agents, and D over agent identifiers. Actions, ff; fi, are either names, co-names of the form x, or the distinguished constant t .
Reference: [5] <author> M. Hennessy and H. Lin. </author> <title> Symbolic bisimulations. </title> <institution> Dept. of Computer Science, University of Sussex, </institution> <type> Report 1/92, </type> <year> 1992. </year>
Reference-contexts: CCS, in a single exponential worst case complexity. Our results very considerably strengthens previous results in the area of value-passing process calculi. Besides the decidability result of Jonsson and Parrow [7] for data-independent programs, Hennessy and Lin <ref> [5] </ref> showed decidability of bisim-ulation equivalence for a certain class of symbolic transition graphs. Both these results are subsumed by the work presented here. The notion of open bisimulation equivalence was specifically formulated with an eye on efficiency concerns. <p> It may well be that alternative characterisations of the equivalences can be exploited to improve the efficiency of our algorithms, along the lines of for instance the efficient characterisation of strong open bisimulation equivalence [17], or the symbolic bisimulations of Hennessy and Lin <ref> [5] </ref>. For the weak equivalences in particular we expect such efficient characterisations to be indisposable.
Reference: [6] <author> Y. Hirschfeld and F. Moller. </author> <title> A fast algorithm for deciding bisimilarity of normed context-free processes. </title> <booktitle> In Proc. </booktitle> <editor> CONCUR'94, B. jonsson, J. Parrow (eds.), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 836 </volume> <pages> 48-63, </pages> <year> 1994. </year> <month> 15 </month>
Reference-contexts: Though the technical details differ, the basic approach we use to show decidability is quite familiar from other recent decidability results in process algebra such as <ref> [2, 3, 6, 7] </ref>, namely by showing that up to the equivalence concerned the state space can be represented in a finitary manner. The tools consist of two key Lemmas, proofs of which are given in the paper: 1.
Reference: [7] <author> B. Jonsson and J. Parrow. </author> <title> Deciding bisimulation equivalences for a class of non-finite-state programs. </title> <booktitle> Information and Computation, </booktitle> <year> 1992. </year>
Reference-contexts: This is an example of a data-independent agent such as those considered previously by Jonsson and Parrow <ref> [7] </ref>. However, the finite-control fragment goes beyond this, since it allows synchronisation, or testing, on channel names passed as parameters. <p> Though the technical details differ, the basic approach we use to show decidability is quite familiar from other recent decidability results in process algebra such as <ref> [2, 3, 6, 7] </ref>, namely by showing that up to the equivalence concerned the state space can be represented in a finitary manner. The tools consist of two key Lemmas, proofs of which are given in the paper: 1. <p> CCS, in a single exponential worst case complexity. Our results very considerably strengthens previous results in the area of value-passing process calculi. Besides the decidability result of Jonsson and Parrow <ref> [7] </ref> for data-independent programs, Hennessy and Lin [5] showed decidability of bisim-ulation equivalence for a certain class of symbolic transition graphs. Both these results are subsumed by the work presented here. The notion of open bisimulation equivalence was specifically formulated with an eye on efficiency concerns. <p> However, even though some interference does take place because of scope extrusion, our results show that this fear is unfounded. Lower bounds. Concerning lower bounds Jonsson and Parrow <ref> [7] </ref> shows that the bisimulation problem for data-independent programs (not including the parallel combinator j) is NP-hard. Since data-independent programs are subsumed by those considered here that lower bound applies here as well. Efficiency.
Reference: [8] <author> P. C. Kannellakis and S. A. Smolka. </author> <title> CCS expressions, finite state processes, and three problems of equivalence. </title> <journal> Information and Computation, </journal> <volume> 86 </volume> <pages> 43-68, </pages> <year> 1990. </year>
Reference-contexts: It is therefore important to investigate to what extent methods and tools developed for, say, CCS lift to the more expressive setting of the -calculus. One such set of tools of fundamental importance are process equivalence checking algorithms, as exemplified by the Paige-Tarjan algorithm <ref> [15, 8] </ref>. Algorithms like these apply in general only to finite-state processes, characterised, in the case of CCS, by disallowing occurrences of the parallel combinator as well as unguarded occurrences of process identifiers in recursive definitions. The corresponding fragment of the -calculus is termed the finite control fragment. <p> Strong early bisimulation equivalence is decidable. 2. Weak late and early bisimulation equivalence are decidable. 2 7 Complexity and Discussion The obvious backtracking-based algorithm for deciding name-bounded bisimula-tion equivalence is quite inefficient. As for standard bisimulation equivalence a better solution is obtained using the Paige-Tarjan algorithm <ref> [15, 8] </ref> with a worst-case running time of O (n t log n s + n s ) where n t is the number of transitions and n s the number of states.
Reference: [9] <author> R. Milner. </author> <title> The polyadic -calculus: A tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> Laboratory for the Foundations of Computer Science, Department of Computer Science, University of Edinburgh, </institution> <year> 1991. </year>
Reference-contexts: The -calculus [11] was proposed as a calculus for mobile processes, i.e. processes whose interconnection topology may be dynamically changed. It extends CCS by features for the transmission and generation of channel names. Considerable expressive power is gained by this. For instance, data types <ref> [9] </ref>, lambda calculus [10], object-oriented programming languages [18], and higher-order processes [16] can all be captured, underlining the foundational importance of the calculus. Moreover the practical usefulness of the calculus have been demonstrated in application studies on mobile telecommunication networks and high speed networks [14, 13]. <p> We establish this result for all the equivalences mentioned above with particular focus on strong late bisimulation equivalence <ref> [9] </ref>. For this equivalence we show how the partition refinement algorithm of Paige and Tarjan [15] can be applied resulting, as for the case of e.g. CCS, in a single exponential worst case complexity. Our results very considerably strengthens previous results in the area of value-passing process calculi. <p> The intended meaning of connectives is familiar from CCS and the -calculus. The present version is based on the polyadic -calculus of <ref> [9] </ref>. There are three main differences: Recursion. We use recursive definitions rather than replication. <p> It is accomodated (though not required) in our framework by a relativisation of the operational semantics to complete descriptions of name identities and inequalities. Well-formedness. A well-formedness condition is imposed, reflecting the stratified syntax of <ref> [9] </ref>. Agents A that are to be considered well-formed are assigned an integer arity n, written A : n. Processes are agents of arity 0, abstractions are agents of negative arity, and concretions are agents of positive arity. <p> A : n B : n A : n n 0 A : n 1 n 0 A : n D : n A : n fixD:A : n A : n n 0 For the remainder of the paper we restrict attention to well-formed agents. 3 Operational Semantics In <ref> [9] </ref> the semantics of the -calculus is given in terms of a structural congruence relation together with a relation of commitment. Here we choose a different, more operational approach, replacing the structural congruence relation with a normalisation procedure. Name partitionings. <p> For all well-formed A and ", nf (A,") is in normal form. Restricting to well-formed agents in the conditional-free fragment it is possible to compare the normalisation procedure with the structural congruence relation of <ref> [9] </ref>. It is quite easy to show, appealing to [9] for the definition of , that for all well-formed, conditional-free agents A, nf (A,") is independent of ", and for all ", A nf (A,"). Commitment. <p> For all well-formed A and ", nf (A,") is in normal form. Restricting to well-formed agents in the conditional-free fragment it is possible to compare the normalisation procedure with the structural congruence relation of <ref> [9] </ref>. It is quite easy to show, appealing to [9] for the definition of , that for all well-formed, conditional-free agents A, nf (A,") is independent of ", and for all ", A nf (A,"). Commitment. <p> " B comm: A 1 " x:B 1 A 2 " y:B 2 " j= x = y par: A 1 j A 2 " ff:(nf (B,") k A 2 ) A (-x)" t:B res-2: (-x)A " ff:(-x)B 5 + symmetrical versions of rules sum, comm and par Relating to <ref> [9] </ref> let the full name partitioning " f be the one containing only singleton sets. The full partitioning identifies names only if they are literally the same. It can then be shown for the well-formed fragment without conditionals that A B according to [9] if and only if for some B <p> rules sum, comm and par Relating to <ref> [9] </ref> let the full name partitioning " f be the one containing only singleton sets. The full partitioning identifies names only if they are literally the same. It can then be shown for the well-formed fragment without conditionals that A B according to [9] if and only if for some B 0 , nf (A," f ) " f B 0 , and nf (B," f ) = nf (B 0 ," f ). <p> The following is stated without proof: Proposition 3.2 For the fragment of well-formed, conditional-free agents, ~ " f is the (strong) bisimulation equivalence of <ref> [9] </ref>, and ~ is strong congruence. 2 4 A Finite Reachability Theorem The main ingredient in the decidability proof is a finite reachability Theorem, showing that for finite control agents, if names are always chosen from a fixed finite number of candidates then only a finite number of distinct agent expressions
Reference: [10] <author> R. Milner. </author> <title> Functions as processes. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2 </volume> <pages> 119-141, </pages> <year> 1992. </year>
Reference-contexts: The -calculus [11] was proposed as a calculus for mobile processes, i.e. processes whose interconnection topology may be dynamically changed. It extends CCS by features for the transmission and generation of channel names. Considerable expressive power is gained by this. For instance, data types [9], lambda calculus <ref> [10] </ref>, object-oriented programming languages [18], and higher-order processes [16] can all be captured, underlining the foundational importance of the calculus. Moreover the practical usefulness of the calculus have been demonstrated in application studies on mobile telecommunication networks and high speed networks [14, 13].
Reference: [11] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, I and II. </title> <journal> Information and Computation, </journal> <volume> 100(1) </volume> <pages> 1-40 and 41-77, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction The problem of obtaining a unified view of on the one hand sequential computation as embodied by the -calculus, and reactive systems such as CCS or CSP on the other has recently had considerable attention. The -calculus <ref> [11] </ref> was proposed as a calculus for mobile processes, i.e. processes whose interconnection topology may be dynamically changed. It extends CCS by features for the transmission and generation of channel names. Considerable expressive power is gained by this.
Reference: [12] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> Modal logics for mobile processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 114 </volume> <pages> 149-171, </pages> <year> 1993. </year>
Reference-contexts: In this paper we provide the basic tools to show decidability for the finite control fragment for a number of equivalences, including late or early, strong or weak bisimulation equivalence (c.f. <ref> [12] </ref>), and open (or uniform [1]) bisimulation equivalence [17] 2 . <p> However, open bisimulation equivalence is already known to be decidable (indeed it was formulated with this as a central concern). Early equivalence is characterised by permuting the quantifications over transitions and inputs which is implicit in clauses (3) and (4) of Def. 3.1 (c.f. <ref> [12] </ref> for a definition of early equivalence). The proofs of Theorems 6.1 and 6.2 are only minimally affected by this modification. For the weak late and early equivalences again only small modifications are needed (though alternative characterisations of these equivalences are likely to be mandatory for reasons of efficiency).
Reference: [13] <author> F. Orava. </author> <title> On the Formal Analysis of Telecommunication Protocols. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Systems, Uppsala University and Swedish Institute of Computer Science, </institution> <year> 1994. </year> <month> Forthcoming. </month>
Reference-contexts: For instance, data types [9], lambda calculus [10], object-oriented programming languages [18], and higher-order processes [16] can all be captured, underlining the foundational importance of the calculus. Moreover the practical usefulness of the calculus have been demonstrated in application studies on mobile telecommunication networks and high speed networks <ref> [14, 13] </ref>. It is therefore important to investigate to what extent methods and tools developed for, say, CCS lift to the more expressive setting of the -calculus. One such set of tools of fundamental importance are process equivalence checking algorithms, as exemplified by the Paige-Tarjan algorithm [15, 8].
Reference: [14] <author> F. Orava and J. Parrow. </author> <title> An algebraic verification of a mobile network. </title> <journal> Formal Aspects of Computing, </journal> <pages> pages 497-543, </pages> <year> 1992. </year>
Reference-contexts: For instance, data types [9], lambda calculus [10], object-oriented programming languages [18], and higher-order processes [16] can all be captured, underlining the foundational importance of the calculus. Moreover the practical usefulness of the calculus have been demonstrated in application studies on mobile telecommunication networks and high speed networks <ref> [14, 13] </ref>. It is therefore important to investigate to what extent methods and tools developed for, say, CCS lift to the more expressive setting of the -calculus. One such set of tools of fundamental importance are process equivalence checking algorithms, as exemplified by the Paige-Tarjan algorithm [15, 8].
Reference: [15] <author> R. Paige and R. E. Tarjan. </author> <title> Three partition refinement algorithms. </title> <journal> SIAM Journal of Computing, </journal> <volume> 16(6) </volume> <pages> 973-989, </pages> <year> 1987. </year>
Reference-contexts: It is therefore important to investigate to what extent methods and tools developed for, say, CCS lift to the more expressive setting of the -calculus. One such set of tools of fundamental importance are process equivalence checking algorithms, as exemplified by the Paige-Tarjan algorithm <ref> [15, 8] </ref>. Algorithms like these apply in general only to finite-state processes, characterised, in the case of CCS, by disallowing occurrences of the parallel combinator as well as unguarded occurrences of process identifiers in recursive definitions. The corresponding fragment of the -calculus is termed the finite control fragment. <p> We establish this result for all the equivalences mentioned above with particular focus on strong late bisimulation equivalence [9]. For this equivalence we show how the partition refinement algorithm of Paige and Tarjan <ref> [15] </ref> can be applied resulting, as for the case of e.g. CCS, in a single exponential worst case complexity. Our results very considerably strengthens previous results in the area of value-passing process calculi. <p> Strong early bisimulation equivalence is decidable. 2. Weak late and early bisimulation equivalence are decidable. 2 7 Complexity and Discussion The obvious backtracking-based algorithm for deciding name-bounded bisimula-tion equivalence is quite inefficient. As for standard bisimulation equivalence a better solution is obtained using the Paige-Tarjan algorithm <ref> [15, 8] </ref> with a worst-case running time of O (n t log n s + n s ) where n t is the number of transitions and n s the number of states.
Reference: [16] <author> D. Sangiorgi. </author> <title> From -calculus to higher-order -calculus|and back. </title> <note> To appear in Proc. TAPSOFT'93, </note> <year> 1993. </year>
Reference-contexts: It extends CCS by features for the transmission and generation of channel names. Considerable expressive power is gained by this. For instance, data types [9], lambda calculus [10], object-oriented programming languages [18], and higher-order processes <ref> [16] </ref> can all be captured, underlining the foundational importance of the calculus. Moreover the practical usefulness of the calculus have been demonstrated in application studies on mobile telecommunication networks and high speed networks [14, 13].
Reference: [17] <author> D. Sangiorgi. </author> <title> A theory of bisimulation for the -calculus. </title> <booktitle> in Proc. CONCUR'93 Lecture Notes in Computer Science, </booktitle> <volume> 715 </volume> <pages> 127-142, </pages> <year> 1993. </year>
Reference-contexts: In this paper we provide the basic tools to show decidability for the finite control fragment for a number of equivalences, including late or early, strong or weak bisimulation equivalence (c.f. [12]), and open (or uniform [1]) bisimulation equivalence <ref> [17] </ref> 2 . <p> In the area of model checking a close relative to the present work is the decidability result with respect to an extended version of the modal -calculus of [4]. 2 For open bisimulation equivalence decidability is already known <ref> [17] </ref> 2 2 The Polyadic -calculus, syntax We use a slight extension of Milner's polyadic -calculus, introduced in [4]. Letters x; y; z; : : : range over names of which there is a countably infinite supply, A; B range over agents, and D over agent identifiers. <p> We admit the conditional [x = y]AB, identified with A when x = y, and B when x 6= y. The admission of negative as well as positive matching has been an issue of some controversy in the -calculus (c.f. <ref> [17] </ref>). It is accomodated (though not required) in our framework by a relativisation of the operational semantics to complete descriptions of name identities and inequalities. Well-formedness. A well-formedness condition is imposed, reflecting the stratified syntax of [9]. <p> Whether this in fact turns out to be the case remains to be seen. It may well be that alternative characterisations of the equivalences can be exploited to improve the efficiency of our algorithms, along the lines of for instance the efficient characterisation of strong open bisimulation equivalence <ref> [17] </ref>, or the symbolic bisimulations of Hennessy and Lin [5]. For the weak equivalences in particular we expect such efficient characterisations to be indisposable.
Reference: [18] <author> D. Walker. </author> <title> Objects in the -calculus. </title> <journal> Information and Computation, </journal> <note> 1994. (To appear). 16 </note>
Reference-contexts: It extends CCS by features for the transmission and generation of channel names. Considerable expressive power is gained by this. For instance, data types [9], lambda calculus [10], object-oriented programming languages <ref> [18] </ref>, and higher-order processes [16] can all be captured, underlining the foundational importance of the calculus. Moreover the practical usefulness of the calculus have been demonstrated in application studies on mobile telecommunication networks and high speed networks [14, 13].
References-found: 18

