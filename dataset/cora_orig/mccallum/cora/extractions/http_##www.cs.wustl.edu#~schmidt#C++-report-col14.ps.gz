URL: http://www.cs.wustl.edu/~schmidt/C++-report-col14.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: http://www.cs.wustl.edu
Email: schmidt@cs.wustl.edu vinoski@iona.com  
Title: Object Interconnections C++ Servant Managers for the Portable Object Adapter (Column 14)  
Author: Douglas C. Schmidt Steve Vinoski 
Note: This column will appear in the September 1998 issue of the SIGS C++ Report magazine.  
Address: St. Louis, MO 63130 60 Aberdeen Ave., Cambridge, MA 02138  
Affiliation: Department of Computer Science IONA Technologies, Inc. Washington University,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. C. Schmidt and S. Vinoski, </author> <title> Object Adapters: Concepts and Terminology, </title> <journal> C++ Report, </journal> <volume> vol. 11, </volume> <month> November/December </month> <year> 1997. </year>
Reference-contexts: The POA is a component of CORBA visible solely to a server, i.e., clients are not directly aware of the POA's existence or structure. The first column in this series <ref> [1] </ref> discussed the concepts and terminology used in the POA specification. It described how the lifetime of a CORBA object can be decoupled from the lifetime of any C++ servant (s) that implement it.
Reference: [2] <author> D. C. Schmidt and S. Vinoski, </author> <title> Using the Portable Object Adapter for Transient and Persistent CORBA Objects, </title> <journal> C++ Report, </journal> <volume> vol. 12, </volume> <month> April </month> <year> 1998. </year>
Reference-contexts: The first column in this series [1] discussed the concepts and terminology used in the POA specification. It described how the lifetime of a CORBA object can be decoupled from the lifetime of any C++ servant (s) that implement it. The second column <ref> [2] </ref> expanded this discussion by exploring the two lifespans that are possible for CORBA objects: transient and persistent. These lifespans differ entirely by how long a CORBA object lives. Lifespan issues often arise when discussing object adapters since that's where the worlds of CORBA objects and programming language servants intersect. <p> It might be best to use the approach of creating a server main that can either serve as a factory to initially create our objects or as a regular server, as we showed in <ref> [2] </ref>. We leave the creation of such a server main as an exercise for the reader. 5 6 Conclusion This column addressed yet another aspect of the creation and management of C++ servants using the POA.
Reference: [3] <author> D. C. Schmidt and S. Vinoski, </author> <title> Developing C++ Servant Classes Using the Portable Object Adapter, </title> <journal> C++ Report, </journal> <volume> vol. 12, </volume> <month> June </month> <year> 1998. </year>
Reference-contexts: These lifespans differ entirely by how long a CORBA object lives. Lifespan issues often arise when discussing object adapters since that's where the worlds of CORBA objects and programming language servants intersect. Our third column <ref> [3] </ref> of the series described how to create C++ servants and register them in order to incarnate CORBA objects. For some applications, explicitly registering a servant for each CORBA object is prohibitively expensive; for others, it is virtually impossible.
Reference: [4] <institution> Object Management Group, Trading ObjectService Specification, 1.0 ed., </institution> <month> Mar. </month> <year> 1997. </year>
Reference-contexts: Without something like a Quoter object, how can we obtain object references for the stocks we're interested in? Fortunately, we already have a solution that is far more flexible than the Quoter interface: the OMG Trading Service <ref> [4] </ref>. A Trader allows objects to advertise themselves using many more characteristics than just their names. For instance, a stock object could advertise itself via price, number of shares bought and sold, rating, or any other characteristic.
Reference: [5] <author> P. Jain and D. C. Schmidt, </author> <title> Service Configurator: A Pattern for Dynamic Configuration of Services, </title> <booktitle> in Proceedings of the 3 rd Conference on Object-Oriented Technologies and Systems, USENIX, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: This allows a server to avoid creating all of its servants before listening for requests. When combined with patterns like Service Configurator <ref> [5] </ref> and OS features like explicit 3 dynamic linking [6], the POA servant managers make it pos-sible to dynamically configure servants into CORBA servers. Existing ORBs support dynamic configuration of servants.
Reference: [6] <author> D. C. Schmidt and T. Suda, </author> <title> An Object-Oriented Framework for Dynamically Configuring Extensible Distributed Communication Systems, </title> <journal> IEE/BCS Distributed Systems Engineering Journal (Special Issue on Configurable Distributed Systems), </journal> <volume> vol. 2, </volume> <pages> pp. 280293, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: This allows a server to avoid creating all of its servants before listening for requests. When combined with patterns like Service Configurator [5] and OS features like explicit 3 dynamic linking <ref> [6] </ref>, the POA servant managers make it pos-sible to dynamically configure servants into CORBA servers. Existing ORBs support dynamic configuration of servants. For instance, Orbix Loaders essentially allow objects to be loaded into a server on demand when requests arrive for them.
Reference: [7] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Asynchronous Completion Token: an Object Behavioral Pattern for Efficient Asynchronous Event Handling, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: Implementing the postinvoke () Method Our implementation of postinvoke is also almost exactly like its ServantActivator::etherealize counterpart: void MyStockActivator::postinvoke (const PortableServer::ObjectId &id, PortableServer::POA_ptr poa, const char *operation, PortableServer::Cookie cookie, PortableServer::Servant servant) throw (CORBA::SystemException) - delete servant; - 3 This cookie is an example of the Asynchronous Completion Token pat tern <ref> [7] </ref>. 6 Just like preinvoke, we don't make use of the poa, operation, or cookie parameters. We simply delete the servant and return.
Reference: [8] <author> S. Vinoski and M. Henning, </author> <title> Advanced CORBA Programming With C++. </title> <publisher> Addison-Wesley Longman, </publisher> <year> 1998. </year> <month> 9 </month>
Reference-contexts: For instance, the preinvoke and postinvoke hooks allow persistent state to be loaded before an operation call on the servant and written back to the persistent store after the operation completes <ref> [8] </ref>. 5 Default Servants 5.1 Overview When all objects in a POA support the same interface, it is sometimes possible to support them all using only a single servant. This situation typically arises when the application uses the Dynamic Skeleton Interface (DSI).
References-found: 8

