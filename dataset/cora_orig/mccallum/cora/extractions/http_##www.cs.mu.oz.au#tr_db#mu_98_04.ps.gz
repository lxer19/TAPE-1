URL: http://www.cs.mu.oz.au/tr_db/mu_98_04.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: (lee@cs.mu.OZ.AU, http://www.cs.mu.oz.au/~lee)  
Title: A three-valued semantics for Horn clause programs  
Author: Lee Naish 
Address: Parkville, Victoria 3052 Australia  
Affiliation: Department of Computer Science University of Melbourne  
Pubnum: Technical Report 98/4  
Abstract: The study of semantics of logic programs has shown strong links between the model theoretic semantics (truth and falsity of atoms in the programmer's interpretation of a program), procedural semantics (for example, SLD resolution) and fixpoint semantics (which is useful for program analysis and alternative execution mechanisms). Nearly all of this work assumes that intended interpretations are two-valued: a ground atom is true (and should succeed according to the procedural semantics) or false (and should not succeed). In reality, intended interpretations are less precise. Programmers consider that some atoms "should not occur" or are "ill-typed" or "inadmissible". Programmers don't know and don't care whether such atoms succeed. In this paper we propose a three-valued semantics for (essentially) Horn clause programs which reflects this. It is simpler and more flexible than previously proposed type schemes which implicitly recognise this third truth value. It provides tools to reason about correctness of programs without the need for unnatural precision or undue restrictions on programming style. This work has been motivated by work on declarative debugging, where it has been recognised that inadmissible calls are important. 
Abstract-found: 1
Intro-found: 1
Reference: [Cla78] <author> Keith L. Clark. </author> <title> Negation as failure. </title> <editor> In Herve Gallaire and Jack Minker, editors, </editor> <booktitle> Logic and data bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <year> 1978. </year>
Reference-contexts: Horn clauses programs can easily be mapped to disjunctive clause programs by renaming variables, converting some head unification into calls to an equality predicate and combining all clauses for a predicate into a single disjunctive clause. This is similar to the 4 completion of a program <ref> [Cla78] </ref>, but the equality predicate can be defined using disjunctive clauses in the normal way, X=X, rather than being treated specially. An intended interpretation associates each atom with one of three truth values: true, false or inadmissible. We sometimes abbreviate these to T , F and I. <p> However, the more common solution is to change the program! The first and simplest approach to negation was to use the negation as failure rule for the operational semantics and Clark's completion for the declarative semantics <ref> [Cla78] </ref>. Here we sketch how this approach could be adapted to our three-valued scheme.
Reference: [FBJ88] <author> Melvin Fitting and Marion Ben-Jacob. </author> <title> Stratified and three-valued logic programming semantics. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Proceedings of the Fifth International Conference/Symposium on Logic Programming, </booktitle> <pages> pages 1054-1069, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference: [HL94] <author> P.M. Hill and J.W. Lloyd. </author> <title> The Godel programming language. </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: Type definition languages are normally designed with static checking in mind and since sortedness is very difficult to check statically it cannot be expressed in most type languages. 2.2 Traditional typed semantics Some logic languages, such as Godel <ref> [HL94] </ref> and Mercury [SHC95] have used type systems similar to those used in functional programming languages, after [MO84]. Types are declared (or possibly inferred) and the type checker rejects programs which may result in atoms with incorrect argument types.
Reference: [Kun87] <author> Kenneth Kunen. </author> <title> Negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(4) </volume> <pages> 289-308, </pages> <month> December </month> <year> 1987. </year>
Reference: [Llo84] <author> John W. Lloyd. </author> <booktitle> Foundations of logic programming. Springer series in symbolic computation. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: Here our aim is to provide theoretical support which can allow programmers to reason about the correctness of their code more easily. The starting point for this work was declarative debugging of logic programs. The conventional view of the semantics of logic programs <ref> [Llo84] </ref> and declarative debugging [Sha83] [Llo87] is as follows. Every ground atom is either true or false in the intended interpretation of the program. True atoms should succeed and false atoms should fail. <p> We make some comments about how negation could be handled before concluding. 2 Previous approaches to semantics 2.1 Traditional untyped semantics The traditional approach to the semantics of logic programs, described in <ref> [Llo84] </ref>, includes model theory, fixpoint theory and an operational semantics. Here we just discuss the theory as it applies to successful computations using Horn Clauses. That is, we do not deal with failure or negation, which lead to significant additional complication and various conflicting proposed semantics. <p> Thus (assuming that the intended interpretation is a model) the computed answers of a program are true in the intended interpretation. The major flaw in this otherwise beautiful picture is that, in practice, the intended interpretation is generally not a model. Consider the example from <ref> [Llo84] </ref> in which intended interpretations are discussed: perm ([], []). perm (X.Y, U.V) :- delete (U, X.Y, Z), perm (Z, V). delete (X, X.Y, Y). delete (X, Y.Z, Y.W) :- delete (X, Z, W). <p> Computations are represented as trees and debuggers search the tree for a buggy node. For diagnosing wrong answers in Prolog, the tree is a proof tree (see <ref> [Llo84] </ref>): each node contains an atom which was proved in the computation and the children of the node contain the atoms in the body of the clause instance which was used at the top level of the proof.
Reference: [Llo87] <author> J.W. Lloyd. </author> <title> Declarative error diagnosis. </title> <journal> New Generation Computing, </journal> <volume> 5(2) </volume> <pages> 133-154, </pages> <year> 1987. </year>
Reference-contexts: Here our aim is to provide theoretical support which can allow programmers to reason about the correctness of their code more easily. The starting point for this work was declarative debugging of logic programs. The conventional view of the semantics of logic programs [Llo84] and declarative debugging [Sha83] <ref> [Llo87] </ref> is as follows. Every ground atom is either true or false in the intended interpretation of the program. True atoms should succeed and false atoms should fail.
Reference: [MO84] <author> Alan Mycroft and Richard O'Keefe. </author> <title> A polymorphic type system for prolog. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 295-307, </pages> <year> 1984. </year>
Reference-contexts: designed with static checking in mind and since sortedness is very difficult to check statically it cannot be expressed in most type languages. 2.2 Traditional typed semantics Some logic languages, such as Godel [HL94] and Mercury [SHC95] have used type systems similar to those used in functional programming languages, after <ref> [MO84] </ref>. Types are declared (or possibly inferred) and the type checker rejects programs which may result in atoms with incorrect argument types. The intended interpretation is typed and atoms with incorrect argument types have no meaning: they are considered ill-formed rather than true or false.
Reference: [Nai92] <author> Lee Naish. </author> <title> Types and the intended meaning of logic programs. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Types in logic programming, </booktitle> <pages> pages 189-216. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: However, strong type checking also rejects many programs which would otherwise work correctly. Programmers who are used to the flexibility of untyped languages such as Prolog often object to such restrictions on their programming style. 2.3 More flexible typed semantics The type scheme of <ref> [Nai92] </ref> was designed to solve the semantic difficulties discussed so far, while restricting correct programs as little as possible. Types in this scheme can be defined by arbitrary Horn clause programs. This allows the assumptions of predicates such as merge to be expressed by types. <p> We simply assume that the programmer has some notion of (in)admissibility and that admissibility is closed under instantiation. If inadmissibility is identified with ill-typedness (as suggested in [Per86] and <ref> [Nai92] </ref>) then the second class of bugs correspond to clauses which are not type correct. However, this definition of inadmissibility does not lead to ideal behaviour of debuggers [Nai97b] and does not quite capture the intentions of programmers. As well as considering types, programmers consider modes. <p> Programs are restricted so that all derivations are well typed, not just successful ones (distinguishing between these two cases cannot be done statically). The choice of F is similar to less restrictive type schemes which only restrict successful derivations; this is discussed further in <ref> [Nai92] </ref>. It allows runtime checking of types (or other assertions) to be supported. The body of a clause instance can have checks which fail (have truth value F ) as well as inadmissible calls, that is, the clause is of the form F F ^ I. <p> For disjunction, the key question is whether I _ T should equal I or T . In strict type schemes a disjunction containing an ill-typed atom is ill-typed even if a well-typed disjunct succeeds. Even in the less strict scheme of <ref> [Nai92] </ref> disjunctions must be implemented as separate clauses and each clause must be type correct. This is the reason we introduced disjunctive clauses: by choosing T we can have a less restrictive condition. In some cases the type correctness condition of [Nai92] is less restrictive than our condition for an interpretation <p> Even in the less strict scheme of <ref> [Nai92] </ref> disjunctions must be implemented as separate clauses and each clause must be type correct. This is the reason we introduced disjunctive clauses: by choosing T we can have a less restrictive condition. In some cases the type correctness condition of [Nai92] is less restrictive than our condition for an interpretation to be a model. Comparison of the two is simplified if we identify admissibility with well-typedness. Our definition of a model is purely declarative, relying 1 Technically, P I may be an infinite program.
Reference: [Nai96] <author> Lee Naish. </author> <title> A declarative view of modes. </title> <booktitle> In Proceedings of the 1996 Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 185-199. </pages> <publisher> MIT Press, </publisher> <month> September </month> <year> 1996. </year>
Reference-contexts: A more natural definition of inadmissibility for ground atoms is that the "input" arguments of the atom are ill-typed (or violate some assumption). In [Nai97b] this definition of inadmissibility is related to a declarative view of modes <ref> [Nai96] </ref>, which gives a more technical definition that captures the intuitive idea of input arguments being ill-typed. 4 Three-valued semantics Our aim is to provide a semantics for Horn clause programs.
Reference: [Nai97a] <author> Lee Naish. </author> <title> A declarative debugging scheme. </title> <journal> Journal of Functional and Logic Programming, </journal> <volume> 1997(3), </volume> <month> April </month> <year> 1997. </year> <month> 10 </month>
Reference-contexts: A type incorrect clause whose head is true just results in a dubious "proof" of a true atom. 3 3 Three-valued declarative debugging A general scheme for declarative debugging using three truth values is described in [Nai97b]; it is based on a more traditional two-valued scheme <ref> [Nai97a] </ref>. Computations are represented as trees and debuggers search the tree for a buggy node.
Reference: [Nai97b] <author> Lee Naish. </author> <title> A three-valued declarative debugging scheme. </title> <type> Technical Report 97/5, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: There are some atoms encountered during debugging which simply should not occur (for example, "ill-typed" atoms). Whether they succeed or fail is not the issue. A third truth value, inadmissible, has been introduced into declarative debugging for such atoms [Per86] [PC88] <ref> [Nai97b] </ref>. This is a recognition that, in practice, intended interpretations are three-valued rather than two-valued. Similarly, most work on formal specifications allows for the behaviour of a module to be unspecified if preconditions are violated. <p> Note that type correctness is not a necessary condition for soundness. A type incorrect clause whose head is true just results in a dubious "proof" of a true atom. 3 3 Three-valued declarative debugging A general scheme for declarative debugging using three truth values is described in <ref> [Nai97b] </ref>; it is based on a more traditional two-valued scheme [Nai97a]. Computations are represented as trees and debuggers search the tree for a buggy node. <p> This class of bugs was identified in the first work on declarative debugging [Sha83]. Another class of bugs, related to inadmissibility, was identified in [Per86] and formalised more in <ref> [Nai97b] </ref>: nodes which are erroneous with no erroneous children but at least one inadmissible child. In a top-down execution this corresponds to a clause instance which causes a transition from admissible atoms to inadmissible atoms. <p> If inadmissibility is identified with ill-typedness (as suggested in [Per86] and [Nai92]) then the second class of bugs correspond to clauses which are not type correct. However, this definition of inadmissibility does not lead to ideal behaviour of debuggers <ref> [Nai97b] </ref> and does not quite capture the intentions of programmers. As well as considering types, programmers consider modes. A successful call to merge in which the first argument is not a sorted list is very different from a successful call where the just last argument is not a sorted list. <p> A more natural definition of inadmissibility for ground atoms is that the "input" arguments of the atom are ill-typed (or violate some assumption). In <ref> [Nai97b] </ref> this definition of inadmissibility is related to a declarative view of modes [Nai96], which gives a more technical definition that captures the intuitive idea of input arguments being ill-typed. 4 Three-valued semantics Our aim is to provide a semantics for Horn clause programs.
Reference: [PC88] <author> Luis Moniz Pereira and Miguel Calejo. </author> <title> A framework for prolog debugging. </title> <editor> In Ken-neth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Proceedings of the Fifth International Conference/Symposium on Logic Programming, </booktitle> <pages> pages 481-495, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: There are some atoms encountered during debugging which simply should not occur (for example, "ill-typed" atoms). Whether they succeed or fail is not the issue. A third truth value, inadmissible, has been introduced into declarative debugging for such atoms [Per86] <ref> [PC88] </ref> [Nai97b]. This is a recognition that, in practice, intended interpretations are three-valued rather than two-valued. Similarly, most work on formal specifications allows for the behaviour of a module to be unspecified if preconditions are violated.
Reference: [Per86] <author> Luis Moniz Pereira. </author> <title> Rational debugging in logic programming. </title> <editor> In Ehud Shapiro, editor, </editor> <booktitle> Proceedings of the Third International Conference on Logic Programming, </booktitle> <pages> pages 203-210, </pages> <address> London, England, </address> <month> July </month> <year> 1986. </year> <note> published as Lecture Notes in Computer Science 225 by Springer-Verlag. </note>
Reference-contexts: There are some atoms encountered during debugging which simply should not occur (for example, "ill-typed" atoms). Whether they succeed or fail is not the issue. A third truth value, inadmissible, has been introduced into declarative debugging for such atoms <ref> [Per86] </ref> [PC88] [Nai97b]. This is a recognition that, in practice, intended interpretations are three-valued rather than two-valued. Similarly, most work on formal specifications allows for the behaviour of a module to be unspecified if preconditions are violated. <p> This class of bugs was identified in the first work on declarative debugging [Sha83]. Another class of bugs, related to inadmissibility, was identified in <ref> [Per86] </ref> and formalised more in [Nai97b]: nodes which are erroneous with no erroneous children but at least one inadmissible child. In a top-down execution this corresponds to a clause instance which causes a transition from admissible atoms to inadmissible atoms. <p> We simply assume that the programmer has some notion of (in)admissibility and that admissibility is closed under instantiation. If inadmissibility is identified with ill-typedness (as suggested in <ref> [Per86] </ref> and [Nai92]) then the second class of bugs correspond to clauses which are not type correct. However, this definition of inadmissibility does not lead to ideal behaviour of debuggers [Nai97b] and does not quite capture the intentions of programmers. As well as considering types, programmers consider modes.
Reference: [Sha83] <author> Ehud Y. Shapiro. </author> <title> Algorithmic program debugging. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1983. </year>
Reference-contexts: Here our aim is to provide theoretical support which can allow programmers to reason about the correctness of their code more easily. The starting point for this work was declarative debugging of logic programs. The conventional view of the semantics of logic programs [Llo84] and declarative debugging <ref> [Sha83] </ref> [Llo87] is as follows. Every ground atom is either true or false in the intended interpretation of the program. True atoms should succeed and false atoms should fail. <p> If a node is erroneous but all its children are correct, it corresponds to an incorrect clause instance: the body is valid but the head is not. This class of bugs was identified in the first work on declarative debugging <ref> [Sha83] </ref>. Another class of bugs, related to inadmissibility, was identified in [Per86] and formalised more in [Nai97b]: nodes which are erroneous with no erroneous children but at least one inadmissible child. <p> Negation must be defined for the third truth value: :I = I. Clauses of the form T $ F are a source of incompleteness (a class of bugs called uncovered atoms <ref> [Sha83] </ref>) which can translate to unsoundness when negation as failure is used. Models of the completion would therefore not include such clauses.
Reference: [SHC95] <author> Zoltan Somogyi, Fergus J. Henderson, and Thomas Conway. </author> <title> Mercury: an efficient purely declarative logic programming language. </title> <booktitle> In Proceedings of the Australian Computer Science Conference, </booktitle> <pages> pages 499-512, </pages> <address> Glenelg, Australia, </address> <month> February </month> <year> 1995. </year> <month> 11 </month>
Reference-contexts: Type definition languages are normally designed with static checking in mind and since sortedness is very difficult to check statically it cannot be expressed in most type languages. 2.2 Traditional typed semantics Some logic languages, such as Godel [HL94] and Mercury <ref> [SHC95] </ref> have used type systems similar to those used in functional programming languages, after [MO84]. Types are declared (or possibly inferred) and the type checker rejects programs which may result in atoms with incorrect argument types.
References-found: 15

