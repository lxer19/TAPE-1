URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-21.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-21.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [BaM] <author> R. Bayer and E. McCreight, </author> <title> "Organization of Large Ordered Indexes," </title> <booktitle> Acta Infor-matica 1 (1972), </booktitle> <pages> 173-189. </pages>
Reference-contexts: Most importantly, these language features can be supported by data structures for searching and updating that make effective use of secondary storage (i.e., use I/O time logarithmic or faster in the size of input relations). B-trees and their variants B + -trees <ref> [BaM, Com] </ref> are examples of such data structures and have been an unqualified success in supporting external dynamic 1-dimensional range searching in relational database systems. The general data structure problem underlying efficient secondary storage manipulation for many data models is external dynamic k-dimensional range searching.
Reference: [ChT] <author> Y.-J. Chiang and R. Tamassia, </author> <title> "Dynamic Algorithms in Computational Geometry," </title> <booktitle> Proceedings of IEEE, Special Issue on Computational Geometry 80(9) (1992), </booktitle> <pages> 362-381. </pages>
Reference-contexts: O (n log 2 n) space, static query time O (log 2 n + t), dynamic query time O (log 2 n log 2 log 2 n + t) and update time O (log 2 n log 2 log 2 n) (due to space limitations we refer the reader to <ref> [ChT] </ref> for a detailed survey of the topic). The ideal worst-case I/O bounds would involve making all the above logarithms base B and compacting the output term to t=B; any other improvements would of course imply improvements to the in-core bounds. <p> The basis of this observation is a reduction of indexing constraints (for a fairly general class of constraints) to dynamic interval management on secondary storage, which is a special case of external dynamic 2-dimensional 3 range searching. Dynamic interval management has been examined in the literature (see <ref> [ChT] </ref>). The best in-core bounds have been achieved using the priority search tree data structure of [McC], yielding O (n) space, dynamic query time O (log 2 n + t) and update time O (log 2 n), which are all optimal.
Reference: [Cod] <author> E. F. Codd, </author> <title> "A Relational Model for Large Shared Data Banks," </title> <booktitle> CACM 13(6) (1970), </booktitle> <pages> 377-387. </pages>
Reference-contexts: 1 Introduction Motivation and Background: The successful realization of any data model in a large scale database requires supporting its language features with efficient secondary storage manipulation. For example, the relational data model, <ref> [Cod] </ref> includes declarative programming (i.e., in the relational calculus and algebra) and expresses low data complexity queries (i.e., every fixed relational calculus query is evaluable in Logspace and Ptime in the size of the input database).
Reference: [Com] <author> D. Comer, </author> <title> "The Ubiquitous B-tree," </title> <booktitle> Computing Surveys 11(2) (1979), </booktitle> <pages> 121-137. </pages>
Reference-contexts: Most importantly, these language features can be supported by data structures for searching and updating that make effective use of secondary storage (i.e., use I/O time logarithmic or faster in the size of input relations). B-trees and their variants B + -trees <ref> [BaM, Com] </ref> are examples of such data structures and have been an unqualified success in supporting external dynamic 1-dimensional range searching in relational database systems. The general data structure problem underlying efficient secondary storage manipulation for many data models is external dynamic k-dimensional range searching.
Reference: [IKO] <author> C. Icking, R. Klein, and T. Ottmann, </author> <title> Priority Search Trees in Secondary Memory (Extended Abstract), </title> <booktitle> Lecture Notes In Computer Science #314, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: It is open whether dynamic interval management on secondary storage can be achieved optimally in O (n=B) pages, dynamic query I/O time O (log B n + t=B) and update time O (log B n). Note that, various suboptimal solutions are proposed in <ref> [IKO] </ref>, for a slightly more general problem, as well as a claimed optimal static solution. Unfortunately, the [IKO] static solution has static query time O (log 2 n + t=B) instead of O (log B n + t=B) and the claimed optimal solution is incorrect. <p> Note that, various suboptimal solutions are proposed in <ref> [IKO] </ref>, for a slightly more general problem, as well as a claimed optimal static solution. Unfortunately, the [IKO] static solution has static query time O (log 2 n + t=B) instead of O (log B n + t=B) and the claimed optimal solution is incorrect. In this paper we provide an optimal static solution for external dynamic interval management. <p> Unfortunately, we do not know of any algorithm with a performance bound like that of Theorem 3.2. The method of <ref> [IKO] </ref> solves an instance of this problem of size m with a worst case query time of O (log 2 m + t=B). Their scheme uses O (m=B) storage. We use their scheme to deal with type IV and type V metablocks and build auxiliary structures for each metablock. <p> Whether they can be asymptotically improved is an open question. The performance for the case of deletes is open. We should note that, using the techniques in this paper to dynamize the static structure of <ref> [IKO] </ref> it is possible to achieve the following dynamic bounds: (1) indexing constraints in O (n=B) pages, dynamic query I/O time O (log 2 n + t=B) and amortized update time O (log 2 n + (log 2 2 n)=B), and (2) indexing classes in O (log 2 c (n=B)) pages,
Reference: [JaL] <author> J. Jaffar and J. L. Lassez, </author> <title> "Constraint Logic Programming," </title> <booktitle> Proc. 14th ACM POPL (1987), </booktitle> <pages> 111-119. </pages>
Reference-contexts: A general constraint programming framework for database query languages (called Constraint Query Languages or CQLs) was presented in [KKR]. This framework adapts ideas of Constraint Logic Programming or CLP, e.g., from <ref> [JaL] </ref>, to databases, provides a calculus and algebra, guarantees low data complexity, and is applicable to managing spatial data. It is, of course, important to index constraints and, thus, support these new language features with efficient secondary storage manipulation (see Section 2.1 for a more detailed explanation of the problem).
Reference: [KKR] <author> P. C. Kanellakis, G. M. Kuper, and P. Z. Revesz, </author> <title> "Constraint Query Languages," </title> <booktitle> Proc. 9th ACM PODS (1990), </booktitle> <pages> 299-313. </pages>
Reference-contexts: studied problem. (McCreight calls the 2-dimensional as opposed to the 1-dimensional case "one of the persistent puzzles of computer science" [McC].) In this paper we examine new I/O-efficient data structures for special cases of this general problem, which are important for supporting new language features, such as constraint query languages <ref> [KKR] </ref> and class hierarchies in object-oriented databases [KiL, ZdM]. <p> Indexing Constraints: Constraint programming paradigms are inherently "declarative", since they describe computations by specifying how these computations are constrained. A general constraint programming framework for database query languages (called Constraint Query Languages or CQLs) was presented in <ref> [KKR] </ref>. This framework adapts ideas of Constraint Logic Programming or CLP, e.g., from [JaL], to databases, provides a calculus and algebra, guarantees low data complexity, and is applicable to managing spatial data. <p> It is, of course, important to index constraints and, thus, support these new language features with efficient secondary storage manipulation (see Section 2.1 for a more detailed explanation of the problem). Fortunately, it is possible to combine CQLs with existing 2-dimensional range searching data structures <ref> [KKR] </ref>. The basis of this observation is a reduction of indexing constraints (for a fairly general class of constraints) to dynamic interval management on secondary storage, which is a special case of external dynamic 2-dimensional 3 range searching. Dynamic interval management has been examined in the literature (see [ChT]).
Reference: [KKD] <author> W. Kim, K. C. Kim, and A. Dale, </author> <title> "Indexing Techniques for Object-Oriented Databases," in Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. H. Lo-chovsky, eds., </editor> <publisher> Addison-Wesley, </publisher> <year> 1989, </year> <pages> 371-394. </pages>
Reference-contexts: Together with the different problem of indexing nested objects, as in [MaS], it constitutes the basis for indexing in object-oriented databases. Indexing classes has been examined in <ref> [KKD] </ref> and more recently in [LOL], but the solutions offered there are largely heuristic with poor worst-case performance. In Section 2.2, we reduce indexing classes to a special case of external dynamic 2-dimensional range searching.
Reference: [KiL] <editor> W. Kim and F. H. Lochovsky, eds., </editor> <title> Object-Oriented Concepts, Databases, and Applications, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year> <month> 15 </month>
Reference-contexts: opposed to the 1-dimensional case "one of the persistent puzzles of computer science" [McC].) In this paper we examine new I/O-efficient data structures for special cases of this general problem, which are important for supporting new language features, such as constraint query languages [KKR] and class hierarchies in object-oriented databases <ref> [KiL, ZdM] </ref>.
Reference: [LOL] <author> C. C. Low, B. C. Ooi, and H. Lu, "H-trees: </author> <title> A Dynamic Associative Search Index for OODB," </title> <booktitle> Proc. ACM SIGMOD (1992), </booktitle> <pages> 134-143. </pages>
Reference-contexts: Together with the different problem of indexing nested objects, as in [MaS], it constitutes the basis for indexing in object-oriented databases. Indexing classes has been examined in [KKD] and more recently in <ref> [LOL] </ref>, but the solutions offered there are largely heuristic with poor worst-case performance. In Section 2.2, we reduce indexing classes to a special case of external dynamic 2-dimensional range searching. We also assume that the class-subclass relationship is static, although objects can be inserted or deleted from classes.
Reference: [MaS] <author> D. Maier and J. Stein, </author> <title> "Indexing in an Object-Oriented DBMS," </title> <booktitle> IEEE Proc. International Workshop on Object-Oriented Database Systems (1986), </booktitle> <pages> 171-182. </pages>
Reference-contexts: Indexing Classes: Indexing by one attribute and by class name in an object-oriented model, where objects are organized as a static forest hierarchy of classes, is also a special case of external dynamic 2-dimensional range searching. Together with the different problem of indexing nested objects, as in <ref> [MaS] </ref>, it constitutes the basis for indexing in object-oriented databases. Indexing classes has been examined in [KKD] and more recently in [LOL], but the solutions offered there are largely heuristic with poor worst-case performance.
Reference: [McC] <author> E. M. McCreight, </author> <title> "Priority Search Trees," </title> <note> SIAM Journal of Computing 14(2) (May 1985), 257-276. </note>
Reference-contexts: The general data structure problem underlying efficient secondary storage manipulation for many data models is external dynamic k-dimensional range searching. This has been a well studied problem. (McCreight calls the 2-dimensional as opposed to the 1-dimensional case "one of the persistent puzzles of computer science" <ref> [McC] </ref>.) In this paper we examine new I/O-efficient data structures for special cases of this general problem, which are important for supporting new language features, such as constraint query languages [KKR] and class hierarchies in object-oriented databases [KiL, ZdM]. <p> Dynamic interval management has been examined in the literature (see [ChT]). The best in-core bounds have been achieved using the priority search tree data structure of <ref> [McC] </ref>, yielding O (n) space, dynamic query time O (log 2 n + t) and update time O (log 2 n), which are all optimal.
Reference: [OSB] <author> M. H. Overmars, M. H. M. Smid, M. T. de Berg, and M. J. van Kreveld, </author> <title> "Maintaining Range Trees in Secondary Memory: Part I: Partitions," </title> <journal> Acta Informatica 27 (1990), </journal> <pages> 423-452. </pages>
Reference-contexts: Unfortunately, the various in-core algorithms do not map to secondary storage in as smooth a fashion as balanced binary trees map to B + -trees. For example, <ref> [OSB, SmO] </ref> examine mappings which maintain the logarithmic overheads and make the logarithms base B; however, their model does not compact the t-sized output on t=B pages.
Reference: [Sama] <author> Hanan Samet, </author> <title> Applications of Spatial Data Structures: Computer Graphics, Image Processing, </title> <publisher> and GIS , Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Examples are the grid-file, various quad-trees, z-orders and other space filling curves, k-d-B trees, hB-trees, cell-trees, and various R-trees (due to space limitations we refer the reader to <ref> [Sama, Samb] </ref> for a recent survey and applications). For these external data structures there has been a lot of experimentation but relatively little algorithmic analysis.
Reference: [Samb] <author> Hanan Samet, </author> <title> The Design and Analysis of Spatial Data Structures, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Examples are the grid-file, various quad-trees, z-orders and other space filling curves, k-d-B trees, hB-trees, cell-trees, and various R-trees (due to space limitations we refer the reader to <ref> [Sama, Samb] </ref> for a recent survey and applications). For these external data structures there has been a lot of experimentation but relatively little algorithmic analysis.
Reference: [SlT] <author> D. D. Sleator and R. E. Tarjan, </author> <title> "A Data Structure for Dynamic Trees," </title> <editor> J. </editor> <booktitle> Computer and System Sciences 24 (1983), </booktitle> <pages> 362-381. </pages>
Reference-contexts: The procedure trivially extends to forest hierarchies. Before that, we need an algorithm that enables us to decide which of the two lemmas to apply on which part of the hierarchy. The idea for the hierarchy tree labeling algorithm is from <ref> [SlT] </ref>. The following lemma is easily proved using induction. Lemma 4.3 Let Algorithm 1 be applied to an arbitrary hierarchy tree of size c. The number of thin edges from a leaf of this hierarchy tree to the root is no more than log 2 c.
Reference: [SmO] <author> M. H. M. Smid and M. H. Overmars, </author> <title> "Maintaining Range Trees in Secondary Memory: Part II: Lower Bounds," </title> <journal> Acta Informatica 27 (1990), </journal> <pages> 453-480. </pages>
Reference-contexts: Unfortunately, the various in-core algorithms do not map to secondary storage in as smooth a fashion as balanced binary trees map to B + -trees. For example, <ref> [OSB, SmO] </ref> examine mappings which maintain the logarithmic overheads and make the logarithms base B; however, their model does not compact the t-sized output on t=B pages.
Reference: [Vit] <author> J. S. Vitter, </author> <title> "Efficient Memory Access in Large-Scale Computation," </title> <booktitle> 1991 Symposium on Theoretical Aspects of Computer Science (STACS), Lecture Notes in Computer Science, </booktitle> <month> (February </month> <year> 1991), </year> <type> invited paper. </type>
Reference-contexts: Our I/O bounds will be expressed in terms of n; c; t and B (i.e., all constants are independent of these four parameters); for a survey of state of the art I/O complexity see <ref> [Vit] </ref>. We first review external dynamic k-dimensional range searching, with B + -tree performance as our point of reference whose performance we refer to as optimal. A B + -tree on attribute x of the n-tuple relation R uses O (n=B) pages (of secondary storage).
Reference: [ZdM] <author> S. Zdonik and D. Maier, </author> <title> Readings in Object-Oriented Database Systems, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year> <month> 16 </month>
Reference-contexts: opposed to the 1-dimensional case "one of the persistent puzzles of computer science" [McC].) In this paper we examine new I/O-efficient data structures for special cases of this general problem, which are important for supporting new language features, such as constraint query languages [KKR] and class hierarchies in object-oriented databases <ref> [KiL, ZdM] </ref>.
References-found: 19

