URL: http://www.cs.wvu.edu/~atkinson/pubs/tr95-41.ps.gz
Refering-URL: http://www.cs.wvu.edu/~atkinson/publications.html
Root-URL: http://www.cs.wvu.edu
Email: E-mail: atkis@cs.uq.edu.au  
Phone: Phone: +61 7 3365 1003 Fax: +61 7 3365 1533  
Title: A Unifying Model for Retrieval from Reusable Software Libraries  
Author: Steven Atkinson 
Keyword: software libraries, components, retrieval, reuse, formal methods.  
Address: AUSTRALIA  
Affiliation: Software Verification Research Centre Department of Computer Science University of Queensland QLD 4072  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Atkinson and R. Duke. </author> <title> Behavioural retrieval from class libraries. </title> <journal> Australian Computer Science Communications, </journal> <volume> 17(1) </volume> <pages> 13-20, </pages> <month> January </month> <year> 1995. </year> <note> An extended version appears as Software Verification Research Centre Technical Report 94-28, </note> <year> 1994. </year>
Reference-contexts: Internal Dynamic Indices: Behavioural retrieval techniques seek to take advantage of the distinguishing property of software | executability. Behaviour-based techniques <ref> [1, 18, 10] </ref> seek to find relevant components by comparing input and output spaces of components. The retrieval methods formally specified in this paper each exemplify an approach from each of the above three points on the spectrum. The rest of this paper is organized as follows. <p> The model is based upon the schemes proposed in <ref> [18, 1] </ref>. Behaviour-based retrieval schemes for software reuse are based on the notion of exploiting the executability of software components to classify the components. The process of sending a program to a component yields dynamic responses which are collected. <p> The collected responses are what is called the behaviour of the component. An ordering on behaviours is then used to classify components and to search through a library of components. The formal model of behavioural retrieval in this section is based upon the object-based methodology presented in <ref> [1] </ref>. Let Class denote the set of all object-oriented classes. A class can be envisaged as a collection of objects, where each object has a common set of operations and responds in a similar way to a given program. <p> The ordering is defined in such a way that behaviours having only small differences in the number of responses exhibited (determinism) and the position and number of rejected messages (failures) are more closely related than others. The precise definition of the ordering is given in <ref> [1] </ref>. It is formally modelled here as a relationship between behaviours: BehaviourOrdering == Behaviour $ Behaviour In order to complete the model of a behavioural retrieval method, concrete representations for a query, component, ordering and a matching formaula must be defined. <p> Hence the required ordering is modelled as: Ordering == ExecuteFunc fi BehaviourOrdering The matching scheme specified here is presented in detail in <ref> [1] </ref>. Depending on the choice of representation for Class and Val , a number of different matching schemes 11 can be defined, but in general behaviour-based matching searches the behaviour--space of components searching for a behaviour which is close to the behaviour desired. <p> The set of behaviours chosen are those which are closest to a given behaviour using a behavioural ordering. The select function can be formally modelled as: select : PBehaviour fi Behaviour fi BehavOrder ! PBehaviour In <ref> [1] </ref> the ordering formed a lattice, and lattice operations were used to achieve selection. In [17] theorem prover results establish a metric which was used for selection, while the selection scheme of [18] was based on variance between actual and expected outputs.
Reference: [2] <author> T.J. Biggerstaff and A.J. Perlis. </author> <title> Software Reusability: Concepts and Models, vol I. Frontier Series. </title> <publisher> ACM (Addison Wesley), </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction The problem of retrieval from component libraries has long been considered to be the central technical issue surrounding the task of software library construction <ref> [15, 2] </ref>. However the recent movement towards organization and domain-specific software reuse strategies has simplified the retrieval problem by narrowing the scope of the universe of discourse. This has enabled specialist techniques such as domain-modelling [21] and controlled-vocabulary [8] retrieval methods to be applied with some success.
Reference: [3] <author> J. Borstler. </author> <title> Feature-Oriented Classification for Software Reuse. </title> <booktitle> In Proc. Seventh International Conference of Software Engineering and Knowledge Engineering (SEKE'95), </booktitle> <year> 1995. </year>
Reference-contexts: This will be done by examining their similarities and differences, and from that formulating some principles governing their use. There exists a spectrum of retrieval methods, based upon the nature of the indices used as representations of (i.e. surrogates for) components. 1. External Indices: Keywords, faceted [22] and feature-based <ref> [3] </ref> classification techniques all seek to find relevant components based upon controlled vo cabularies, properties and ontologies external to the class; 2. <p> Faceted-classification retrieval schemes are one of many retrieval methods based upon external classification of software components. Examples of similar external classification schemes include retrieval using frames [4], features <ref> [3] </ref>, descriptors [16] and lexical affinity [14]. The formal model presented here could be modified and extended within the abstract framework of Section 2 to model these retrieval methods as well. 4 Signature-Matching Retrieval In this section a formal model for a signature-matching retrieval is presented.
Reference: [4] <author> M. del Rosario Girardi and B. Ibrahim. </author> <title> A similarity measure for retrieving software artifacts. </title> <booktitle> In Proceedings of the Sixth International Conference on Software Engineering and Knowledge Engineering (SEKE'94), </booktitle> <pages> pages 478-485. </pages> <address> Jurmala, Latvia, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Faceted-classification retrieval schemes are one of many retrieval methods based upon external classification of software components. Examples of similar external classification schemes include retrieval using frames <ref> [4] </ref>, features [3], descriptors [16] and lexical affinity [14]. The formal model presented here could be modified and extended within the abstract framework of Section 2 to model these retrieval methods as well. 4 Signature-Matching Retrieval In this section a formal model for a signature-matching retrieval is presented.
Reference: [5] <author> R. Duke, G. Rose, and G. Smith. Object-Z: </author> <title> a Specification Language Advocated for the Description of Standards. </title> <type> Technical Report 94-45, </type> <institution> Software Verification Research Centre, Dept. of Computer Science , Univ. of Queensland, Australia, </institution> <year> 1994. </year> <note> To appear in a special issue of Computer Standards and Interfaces on Formal Methods and Standards, </note> <month> September </month> <year> 1995. </year>
Reference-contexts: Components (i.e. classes) are represented by declaring classes in an object-oriented language. A component is therefore modelled as a class: Component == Class An example of a component specified in the formal specification language Object-Z <ref> [5] </ref> which may be returned as the result of the above query is: ChangeDispenser Note == f$10; $20; $50; $100g [Other dispenser operations omitted] Change note? : Note notes! : bag Note note? = $100 ) notes! = [[$50; $50]] note? = $50 ) notes! = [[$20; $20; $10]] note? =
Reference: [6] <author> D.A. Eichmann. </author> <title> A Hybrid Approach to Software Repository Retrieval: Blending Faceted Classification and Type Signatures. </title> <booktitle> In Proc. International Conference on Software Engineering and Knowledge Engineering (SEKE'91), </booktitle> <pages> pages 236-240, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: A behaviour-conversion takes the behaviour as specified by terms in a facet, a type-signature or an input-output pair and converts the behaviour into a corresponding behaviour in one of the other representations. This assists the retrieval process by taking advantage of 13 multiple and hybrid <ref> [6] </ref> retrieval methods with one query. This leads to the statement of the second principle: Principle of Behaviour Representation: Each retrieval method is obliged to utilize some representation of component behaviour, because it is the behaviour of components that is of most concern when building applications.
Reference: [7] <author> D.A. Eichmann. </author> <title> Supporting Multiple Domains in a Single Reuse Repository. </title> <booktitle> In Proc. Fourth International Conference of Software Engineering and Knowledge Engineering (SEKE'92), </booktitle> <pages> pages 164-169, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: This has enabled specialist techniques such as domain-modelling [21] and controlled-vocabulary [8] retrieval methods to be applied with some success. However there remains the desire to develop software retrieval strategies suited for large scale domain-spanning repositories <ref> [7, 11] </ref>. In such an environment, there are obvious advantages to having many retrieval methods available, the major advantage being that of maximizing assistance to the library searcher locating components of interest.
Reference: [8] <author> W.B. Frakes and P.B. Gandel. </author> <title> Representing reusable software. </title> <journal> Information and Software Technology, </journal> <volume> 32(10), </volume> <year> 1990. </year>
Reference-contexts: However the recent movement towards organization and domain-specific software reuse strategies has simplified the retrieval problem by narrowing the scope of the universe of discourse. This has enabled specialist techniques such as domain-modelling [21] and controlled-vocabulary <ref> [8] </ref> retrieval methods to be applied with some success. However there remains the desire to develop software retrieval strategies suited for large scale domain-spanning repositories [7, 11].
Reference: [9] <author> W.B. </author> <title> Frakes and T.P. Pole. An Empirical Study of Representation Methods for Reusable Software Components. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 20(8) </volume> <pages> 617-630, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: The formal models are used to identify similarities, differences and to formulate four important principles. Frakes and Pole <ref> [9] </ref> make the point that not many comparative studies of different retrieval methods have been undertaken.
Reference: [10] <author> R. J. Hall. </author> <title> Generalized behavior-based retrieval. </title> <booktitle> In Proceedings of the 15th International Conference on Software Engineering, </booktitle> <pages> pages 371-380, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Internal Dynamic Indices: Behavioural retrieval techniques seek to take advantage of the distinguishing property of software | executability. Behaviour-based techniques <ref> [1, 18, 10] </ref> seek to find relevant components by comparing input and output spaces of components. The retrieval methods formally specified in this paper each exemplify an approach from each of the above three points on the spectrum. The rest of this paper is organized as follows. <p> Removing unwanted responses and extending rejected responses are processes which frequently occur during code development, so having precise differences between actual and desired responses is a solid foundation upon which adaptation can take place. A different style of behaviour-based retrieval has been proposed in <ref> [10] </ref>. The major difference in this approach is that functional compositions of component behaviour are also searched, allowing small programs consisting of composed components to be selected.
Reference: [11] <author> R. Helm and Y.S. Maarek. </author> <title> Integrating information retrieval and domain specific approaches for browsing and retrieval in object-oriented class libraries. </title> <booktitle> In Proc. 7th ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (OOPSLA'91), </booktitle> <pages> pages 47-61, </pages> <year> 1991. </year>
Reference-contexts: This has enabled specialist techniques such as domain-modelling [21] and controlled-vocabulary [8] retrieval methods to be applied with some success. However there remains the desire to develop software retrieval strategies suited for large scale domain-spanning repositories <ref> [7, 11] </ref>. In such an environment, there are obvious advantages to having many retrieval methods available, the major advantage being that of maximizing assistance to the library searcher locating components of interest.
Reference: [12] <author> J. Jeng and B. H. C. Cheng. </author> <title> Using analogy to determine program modifications based on specification changes. </title> <booktitle> In Proc. of IEEE 5th Int'l Conf. on Tools with Artificial Intelligence, </booktitle> <pages> pages 113-116, </pages> <address> Boston, MA, </address> <month> November </month> <year> 1993. </year> <month> 17 </month>
Reference-contexts: External Indices: Keywords, faceted [22] and feature-based [3] classification techniques all seek to find relevant components based upon controlled vo cabularies, properties and ontologies external to the class; 2. Internal Static Indices: Structural-matching techniques, most notably signature [25] and specification matching <ref> [12, 23] </ref> techniques, seek to find relevant components based upon elements of the structure of software components; 3. Internal Dynamic Indices: Behavioural retrieval techniques seek to take advantage of the distinguishing property of software | executability. <p> Variances between the queries and the retrieved components can be analyzed (either in a pre-computed or dynamic fashion) to assist the library searcher to adapt the retrieved component (s) into the context implied by the query (e.g. <ref> [12] </ref>). However, because behaviour is represented in varying degrees of concentration, the adaptation engine will vary in the precision of the advice given. The higher the concentration of behaviour representation, the less specific the adaptation assistance.
Reference: [13] <author> J. Jeng and B. H. C. Cheng. </author> <title> A formal approach to reusing more general compo-nents. </title> <booktitle> In IEEE 9th Knowledge-Based Software Engineering Conference, </booktitle> <address> Mon-terey, California, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Signature-matching retrieval schemes are one of a number of retrieval methods based upon internal, static properties of software components. Other such retrieval methods include specification matching using higher order unification [23] and specification matching using order-sorted logics <ref> [13] </ref> which build upon signature matching but also match using pre- and post- condition assertions of components. 5 Behavioural Retrieval In this section a formal model for behavioural retrieval is presented. The model is based upon the schemes proposed in [18, 1].
Reference: [14] <author> Y.S. Maarek, D.M. Berry, and G.E. Kaiser. </author> <title> An information retrieval approach for automatically constructing software libraries. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 17(8) </volume> <pages> 800-813, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Faceted-classification retrieval schemes are one of many retrieval methods based upon external classification of software components. Examples of similar external classification schemes include retrieval using frames [4], features [3], descriptors [16] and lexical affinity <ref> [14] </ref>. The formal model presented here could be modified and extended within the abstract framework of Section 2 to model these retrieval methods as well. 4 Signature-Matching Retrieval In this section a formal model for a signature-matching retrieval is presented. The model is based upon the scheme proposed in [25].
Reference: [15] <author> M. D. McIlroy. </author> <title> Mass produced software components. </title> <booktitle> Proceedings of the 1969 NATO Conference on Software Engineeering, </booktitle> <year> 1969. </year>
Reference-contexts: 1 Introduction The problem of retrieval from component libraries has long been considered to be the central technical issue surrounding the task of software library construction <ref> [15, 2] </ref>. However the recent movement towards organization and domain-specific software reuse strategies has simplified the retrieval problem by narrowing the scope of the universe of discourse. This has enabled specialist techniques such as domain-modelling [21] and controlled-vocabulary [8] retrieval methods to be applied with some success.
Reference: [16] <author> B. Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall Object-Oriented Series. Prentice Hall (UK) Ltd, </publisher> <address> 66 Wood Lane End, Hertforshire HP24RG, </address> <year> 1992. </year>
Reference-contexts: Faceted-classification retrieval schemes are one of many retrieval methods based upon external classification of software components. Examples of similar external classification schemes include retrieval using frames [4], features [3], descriptors <ref> [16] </ref> and lexical affinity [14]. The formal model presented here could be modified and extended within the abstract framework of Section 2 to model these retrieval methods as well. 4 Signature-Matching Retrieval In this section a formal model for a signature-matching retrieval is presented.
Reference: [17] <author> A. Mili, R. Mili, and R. Mittermeir. </author> <title> Storing and retrieving software components: A refinement based system. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 91-100. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: The select function can be formally modelled as: select : PBehaviour fi Behaviour fi BehavOrder ! PBehaviour In [1] the ordering formed a lattice, and lattice operations were used to achieve selection. In <ref> [17] </ref> theorem prover results establish a metric which was used for selection, while the selection scheme of [18] was based on variance between actual and expected outputs.
Reference: [18] <author> A. Podgurski and L. Pierce. </author> <title> Behaviour sampling: A technique for automated retrieval of reusable components. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <pages> pages 349-360, </pages> <year> 1992. </year>
Reference-contexts: Internal Dynamic Indices: Behavioural retrieval techniques seek to take advantage of the distinguishing property of software | executability. Behaviour-based techniques <ref> [1, 18, 10] </ref> seek to find relevant components by comparing input and output spaces of components. The retrieval methods formally specified in this paper each exemplify an approach from each of the above three points on the spectrum. The rest of this paper is organized as follows. <p> The model is based upon the schemes proposed in <ref> [18, 1] </ref>. Behaviour-based retrieval schemes for software reuse are based on the notion of exploiting the executability of software components to classify the components. The process of sending a program to a component yields dynamic responses which are collected. <p> In [17] theorem prover results establish a metric which was used for selection, while the selection scheme of <ref> [18] </ref> was based on variance between actual and expected outputs. Component behaviour is an internal, dynamic property of a component, since be-haviour is derived from the internal structure of a component, and behaviour is exhibited within the context of a program execution.
Reference: [19] <author> B. Potter, J. Sinclair, and D. Till. </author> <title> An Introduction to Formal Specification and Z. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: The paper concludes with a summary of the issues raised by the formal models. Throughout this paper, the Z notation is used to specify concepts. In the 1 main, Z is much like standard mathematical notation; readers unfamiliar with the notation may wish to consult <ref> [19, 24] </ref>. 2 An Abstract Retrieval Model In this section an abstract model of retrieval is formalized. This model comprises the concepts which occur in any retrieval method.
Reference: [20] <author> R. Prieto-Diaz. </author> <title> Implementing faceted classification for software reuse. </title> <journal> Com-mun. ACM, </journal> <volume> 34(5) </volume> <pages> 88-97, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Such a facet may be called Object and a term in its term space may be Stack . All components which could be used to affect a Stack in some way would have the term Stack in their Object facet. Prieto-Diaz's classification system <ref> [20] </ref> for software reuse is the best known system based on a faceted scheme. Six facets for describing software components were chosen; three describe component functionality and three describe component environment. They are Function, Object , Medium, System-Type, Functional Area and Setting.
Reference: [21] <author> R. Prieto-Diaz and G. Arango, </author> <title> editors. Domain Analysis and Software Systems Modeling, </title> <publisher> Los Alamitos, </publisher> <address> CA, 1991. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: However the recent movement towards organization and domain-specific software reuse strategies has simplified the retrieval problem by narrowing the scope of the universe of discourse. This has enabled specialist techniques such as domain-modelling <ref> [21] </ref> and controlled-vocabulary [8] retrieval methods to be applied with some success. However there remains the desire to develop software retrieval strategies suited for large scale domain-spanning repositories [7, 11].
Reference: [22] <author> R. Prieto-Diaz and P. Freeman. </author> <title> Classifying Software for Reusability. </title> <journal> IEEE Software, </journal> <volume> 4(1) </volume> <pages> 6-16, </pages> <year> 1987. </year>
Reference-contexts: This will be done by examining their similarities and differences, and from that formulating some principles governing their use. There exists a spectrum of retrieval methods, based upon the nature of the indices used as representations of (i.e. surrogates for) components. 1. External Indices: Keywords, faceted <ref> [22] </ref> and feature-based [3] classification techniques all seek to find relevant components based upon controlled vo cabularies, properties and ontologies external to the class; 2. <p> Each model is an instantiation of the abstract model discussed in this section. 3 Faceted Retrieval In this section a formal model for faceted retrieval is presented. The model is based upon the scheme proposed in <ref> [22] </ref>. Faceted classification schemes for software reuse consist of a collection of facets, or classifications, which represent the type of information which is relevant for identifying reusable components. Each facet has 3 an associated term-space, which is an ordered collection of terms used to describe aspects of a facet.
Reference: [23] <author> E. J. Rollins and J. M. Wing. </author> <title> Specifications as search keys for software libraries: A case study using lambda prolog. </title> <type> Technical Report CMU-CS-90-159, </type> <institution> Carnegie Mellon University, School of Computer Science Carnegie Mellon University Pittsburgh, </institution> <address> PA 15213-3890, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: External Indices: Keywords, faceted [22] and feature-based [3] classification techniques all seek to find relevant components based upon controlled vo cabularies, properties and ontologies external to the class; 2. Internal Static Indices: Structural-matching techniques, most notably signature [25] and specification matching <ref> [12, 23] </ref> techniques, seek to find relevant components based upon elements of the structure of software components; 3. Internal Dynamic Indices: Behavioural retrieval techniques seek to take advantage of the distinguishing property of software | executability. <p> Signature-matching retrieval schemes are one of a number of retrieval methods based upon internal, static properties of software components. Other such retrieval methods include specification matching using higher order unification <ref> [23] </ref> and specification matching using order-sorted logics [13] which build upon signature matching but also match using pre- and post- condition assertions of components. 5 Behavioural Retrieval In this section a formal model for behavioural retrieval is presented. The model is based upon the schemes proposed in [18, 1].
Reference: [24] <author> J.M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: The paper concludes with a summary of the issues raised by the formal models. Throughout this paper, the Z notation is used to specify concepts. In the 1 main, Z is much like standard mathematical notation; readers unfamiliar with the notation may wish to consult <ref> [19, 24] </ref>. 2 An Abstract Retrieval Model In this section an abstract model of retrieval is formalized. This model comprises the concepts which occur in any retrieval method.
Reference: [25] <author> A. M. Zaremski and J. M. Wing. </author> <title> Signature matching: A key to reuse. </title> <type> Technical Report CMU-CS-93-151, </type> <institution> Carnegie Mellon University, School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh , PA 15213, </address> <month> May </month> <year> 1993. </year> <month> 18 </month>
Reference-contexts: External Indices: Keywords, faceted [22] and feature-based [3] classification techniques all seek to find relevant components based upon controlled vo cabularies, properties and ontologies external to the class; 2. Internal Static Indices: Structural-matching techniques, most notably signature <ref> [25] </ref> and specification matching [12, 23] techniques, seek to find relevant components based upon elements of the structure of software components; 3. Internal Dynamic Indices: Behavioural retrieval techniques seek to take advantage of the distinguishing property of software | executability. <p> The formal model presented here could be modified and extended within the abstract framework of Section 2 to model these retrieval methods as well. 4 Signature-Matching Retrieval In this section a formal model for a signature-matching retrieval is presented. The model is based upon the scheme proposed in <ref> [25] </ref>. The signature-matching scheme for reuse of module components primarily relies upon type-matching under type-transformations. Modules of functions are represented by a multiset of function signatures, where a function signature records the input and output types of a function in a module. <p> Such transformations are introduced in order to increase the recall of signature-matching by allowing type-matching between transformed types. A type transformation is modelled as a relation between Types: TypeTransform == Type $ Type Examples of type transformations used in <ref> [25] </ref> are: flip; curry; uncurry; generalize; specialize : TypeTransform Type transformations will be used in the definition of the matching formula given later in this section. <p> It should also be noted that the curry type transformation has been applied to the signatures labelled add and remove in the query in order to match those signatures in the component. There are many module matching mechanisms proposed in <ref> [25] </ref>. The matching specified here is called generalized relaxed fl match. Generalized relaxed fl match is mentioned as the module matching mechanism most likely to be commonly used in practice.
References-found: 25

