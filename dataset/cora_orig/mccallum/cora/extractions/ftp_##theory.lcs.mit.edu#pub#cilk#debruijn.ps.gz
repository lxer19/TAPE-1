URL: ftp://theory.lcs.mit.edu/pub/cilk/debruijn.ps.gz
Refering-URL: http://theory.lcs.mit.edu/~cilk/abstracts/debruijn.html
Root-URL: 
Email: fcel,prokop,randallg@lcs.mit.edu  
Title: Using de Bruijn Sequences to Index a 1 in a Computer Word  
Author: Charles E. Leiserson Harald Prokop Keith H. Randall 
Date: July 7, 1998  
Address: Cambridge, MA 02139, USA  
Affiliation: MIT Laboratory for Computer Science,  
Abstract: Some computers provide an instruction to find the index of a 1 in a computer word, but many do not. This paper provides a fast and novel algorithm based on de Bruijn sequences to solve this problem. The algorithm involves little more than an integer multiply and a lookup in a small table. We compare the performance of our algorithm with other popular strategies that use table lookups or floating-point conversion.
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Cilk-5.2 (Beta 1) Reference Manual. </institution> <note> Available on the Internet from http://theory.lcs.mit.edu/ ~ cilk. </note>
Reference-contexts: Is there a hash function that would allow us to index the 1's with only a single multiplication and table lookup on a table not much larger than n We have written a Cilk <ref> [1, 6] </ref> parallel backtracking program to search for a hashing constant that could be used in a multiplicative hash function to index two or fewer bits.
Reference: [2] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Idea #3: de Bruijn sequences. The final idea uses de Bruijn sequences [3] to satisfy all three criteria. The size of the hash table is exactly n, the minimum possible. The hash function is a typical multiplicative hash function <ref> [2, pp. 228-229] </ref> that involves a single unsigned integer multiplication of the key by a "de Bruijn" constant. Surprisingly, no two single-1 words hash to the same location. Let us briefly review de Bruijn sequences before seeing how they are used in this application.
Reference: [3] <author> Nicolaas G. de Bruijn. </author> <title> A combinatorial problem. </title> <journal> In Indagationes Mathematicae, </journal> <volume> volume VIII, </volume> <pages> pages 461-467. </pages> <publisher> Koninklije Nederlandsche Akademie van Wetenschappen, </publisher> <year> 1946. </year>
Reference-contexts: Idea #3: de Bruijn sequences. The final idea uses de Bruijn sequences <ref> [3] </ref> to satisfy all three criteria. The size of the hash table is exactly n, the minimum possible. The hash function is a typical multiplicative hash function [2, pp. 228-229] that involves a single unsigned integer multiplication of the key by a "de Bruijn" constant.
Reference: [4] <institution> Digital Equipment Corporation, Maynard, Massachusetts. Alpha Architecture Handbook, </institution> <note> Version 3, 1996. 7 </note>
Reference-contexts: The problem is to provide a fast algorithm that given such a word, outputs either 1 or 5 in binary. Some computers provide instructions FFO (Find First One) or FLO (Find Last One) to find the index of the high-order or low-order 1 in a computer word <ref> [4] </ref>. <p> 16 entries and 4-bit keys. (The deBruijn strategy itself uses a table with 32 entries and 5-bit keys.) We implemented the algorithms in C, and where necessary in assembly language, on four machines: a 167-MHz Sun Ultra-SPARC II [10], a 300-Mhz Pentium II [7, 8], a 466-MHz Alpha 21164 4 <ref> [4] </ref>, and a 194-MHz R10000. The results are tabulated in Figure 2. To compare the strategies we measured the average number of clock cycles to find the index of a 1 in a circular shifted test number with seven 1 bits.
Reference: [5] <author> Peter W. Frey and Larry Atkin. </author> <title> Creating a Chess Player, </title> <address> pages 226-324. </address> <publisher> Springer--Verlag, </publisher> <address> New York, </address> <year> 1998. </year>
Reference-contexts: Many chess programs represent the pieces of a given type as a 64-bit word, each bit of which indicates the presence or absence of the piece type on a particular square of the chessboard <ref> [5] </ref>. To determine which square a piece occupies as a row/column index, the index of a 1 bit must be determined. To illustrate this indexing problem, suppose an 8-bit word contains 00100010. This word contains 1's in positions 1 and 5, where we count from the low-order (rightmost) bit.
Reference: [6] <author> Matteo Frigo, Charles E. Leiserson, and Keith H. Randall. </author> <booktitle> The implementation of the Cilk-5 multithreaded language. In ACM SIGPLAN '98 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 212-223, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: Is there a hash function that would allow us to index the 1's with only a single multiplication and table lookup on a table not much larger than n We have written a Cilk <ref> [1, 6] </ref> parallel backtracking program to search for a hashing constant that could be used in a multiplicative hash function to index two or fewer bits.
Reference: [7] <author> Intel Corp. </author> <title> Pentium Pro Family Developer's Manual, </title> <journal> Vol. </journal> <volume> 3, </volume> <year> 1995. </year> <note> Available at http://developer.intel.com/design/pro/MANUALS/refer1.htm. </note>
Reference-contexts: and lookup4, which uses a table with 16 entries and 4-bit keys. (The deBruijn strategy itself uses a table with 32 entries and 5-bit keys.) We implemented the algorithms in C, and where necessary in assembly language, on four machines: a 167-MHz Sun Ultra-SPARC II [10], a 300-Mhz Pentium II <ref> [7, 8] </ref>, a 466-MHz Alpha 21164 4 [4], and a 194-MHz R10000. The results are tabulated in Figure 2. To compare the strategies we measured the average number of clock cycles to find the index of a 1 in a circular shifted test number with seven 1 bits.
Reference: [8] <author> Intel Corp. </author> <title> Intel Architecture Software Developer's Manual, </title> <booktitle> Vol. 1, 1997. Available at http://developer.intel.com/design/pro/MANUALS/243190.htm. [9] 1998 ACM SIGPLAN conference on programming language design and implementation (PLDI), </booktitle> <year> 1998. </year> <title> Architecture Panel Session. </title>
Reference-contexts: and lookup4, which uses a table with 16 entries and 4-bit keys. (The deBruijn strategy itself uses a table with 32 entries and 5-bit keys.) We implemented the algorithms in C, and where necessary in assembly language, on four machines: a 167-MHz Sun Ultra-SPARC II [10], a 300-Mhz Pentium II <ref> [7, 8] </ref>, a 466-MHz Alpha 21164 4 [4], and a 194-MHz R10000. The results are tabulated in Figure 2. To compare the strategies we measured the average number of clock cycles to find the index of a 1 in a circular shifted test number with seven 1 bits.
Reference: [10] <author> David L. Weaver and Tom Germond, </author> <title> editors. The SPARC Architecture Manual, Version 9. </title> <publisher> PTR Prentice Hall, </publisher> <year> 1994. </year> <month> 8 </month>
Reference-contexts: (256K bytes) and 16-bit keys; and lookup4, which uses a table with 16 entries and 4-bit keys. (The deBruijn strategy itself uses a table with 32 entries and 5-bit keys.) We implemented the algorithms in C, and where necessary in assembly language, on four machines: a 167-MHz Sun Ultra-SPARC II <ref> [10] </ref>, a 300-Mhz Pentium II [7, 8], a 466-MHz Alpha 21164 4 [4], and a 194-MHz R10000. The results are tabulated in Figure 2.
References-found: 9

