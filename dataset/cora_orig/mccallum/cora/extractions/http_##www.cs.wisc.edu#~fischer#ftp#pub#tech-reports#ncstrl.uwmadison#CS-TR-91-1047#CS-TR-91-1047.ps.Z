URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1047/CS-TR-91-1047.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1047/
Root-URL: http://www.cs.wisc.edu
Email: fsrinivas, careyg@cs.wisc.edu  
Title: Performance of On-Line Index Construction Algorithms  
Author: V. Srinivasan Michael J. Carey 
Address: Madison, WI 53706  
Affiliation: Department of Computer Sciences University of Wisconsin  
Abstract: In this paper, we study the performance of several on-line index construction algorithms that have recently been proposed. These algorithms each permit an index to be built while the corresponding data is concurrently accessed and updated. We use a detailed simulation model of a centralized DBMS to quantify the performance impact of various factors, including the amount of update activity, resource contention, background load, and the size of a record compared to the size of an index entry. The performance comparison makes use of two new metrics, one of which is a "loss" metric that reflects the amount of on-line work lost due to interference with the index construction activity. In our analysis, we find that there is an important trade-off between the time required to build the index and the throughput achieved by update transactions during the index construction period. An important conclusion of our study is that certain on-line algorithms perform very well in all but extremely resource-bound situations.
Abstract-found: 1
Intro-found: 1
Reference: [Baye72] <author> Bayer, R. and McCreight, </author> <title> E.M. "Organization and Maintainance of Large Ordered Indices", </title> <journal> Acta Informatica, </journal> <volume> 1(3), </volume> <month> 173-189 </month> <year> (1972). </year>
Reference: [Come79] <author> Comer, D. </author> <title> "The Ubiquitous B-Tree", </title> <journal> ACM Computing Surveys, </journal> <volume> 11(4), </volume> <year> (1979). </year>
Reference-contexts: The third and final step involves creating the non-leaf pages of the index in a bottom-up fashion from the leaf page list created in the previous step. 1 By B-tree we mean the variant in which all keys are stored at the leaves, often called B + -trees <ref> [Come79] </ref>. 2 2.1 Off-Line Algorithm The simplest way to construct a new index on a relation would be to lock the relation in Share mode, build the index using the three basic steps outlined above, and then release the lock.
Reference: [Dewi90] <author> DeWitt, D. J. and Gray, J. </author> <title> "Parallel Database Systems: The Future of Database Processing or a Passing Fad?", </title> <booktitle> SIGMOD Record, </booktitle> <volume> 19(4), </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: Thus, there is a need for these utilities to operate in an on-line fashion <ref> [Dewi90] </ref>. In terms of related work, algorithms for on-line checkpointing of a global database state have been discussed [Pu85] and their performance has been studied [Pu88]. Also, the problem of on-line index reorganization has been discussed briefly in [Ston88].
Reference: [Gray79] <author> Gray, J. </author> <title> "Notes On Database Operating Systems", Operating Systems: An Advanced Course, </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Updaters are assumed to hold an Intention-exclusive lock on the relation while modifying a page of the relation (a la the hierarchical locking scheme of <ref> [Gray79] </ref>) and would therefore be unable to execute concurrently with the index building process. On the other hand, readers only acquire an Intention-share lock on the relation, and can access the relation's pages concurrently with the building process.
Reference: [Lehm81] <author> Lehman, P., and Yao, S. </author> <title> "Efficient Locking for Concurrent Operations on B-trees", </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(4), </volume> <month> December </month> <year> 1981. </year> <month> 19 </month>
Reference: [Livn90] <author> Livny, M. </author> <note> "DeNet User's Guide", version, 1.5, </note> <year> (1990). </year>
Reference-contexts: This model, which is a closed queueing model with a fixed multi-programming level (MPL), was implemented using the DeNet simulation language <ref> [Livn90] </ref>. The central focus of the model is the relation on which a new index is being built. The model of the system hardware assumes a computer system with one or more CPUs and disks. Requests for the CPUs are scheduled using an FCFS (first-come, first-served) discipline with no preemption.
Reference: [Moha91] <author> Mohan, C. and Narang, I. </author> <title> "Algorithms for Creating Indexes for Very Large Tables Without Quiescing Updates", </title> <journal> IBM Research Report, </journal> <volume> RJ 8016, </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: Only recently, however, have algorithms been proposed to tackle the problem This research was partially supported by the National Science Foundation under grant IRI-8657323 and by a University of Wisconsin Vilas Fellowship. 1 of on-line index construction <ref> [Srin91b, Moha91] </ref>. Since B-trees 1 are the most common dynamic index structure in database systems, the existing work has concentrated on algorithms for on-line construction of B-tree indices. <p> The main difference here is the absence of the sort step that was needed earlier for sorting update-list entries. Apart from the above algorithms, two other on-line algorithms have also recently been proposed in the literature <ref> [Moha91] </ref>. <p> Finally, using the above results, we can now make informed projections about the performance of other on-line algorithms that have been proposed in the literature. 6.1 Other Candidate Algorithms Mohan and Narang have proposed two algorithms for on-line index construction <ref> [Moha91] </ref>. Their first algorithm is index-based and allows updaters and the build process to share the same index throughout. In this algorithm, the build process first initializes a public index into which updaters concurrently insert their index updates. <p> Also, at the end of the index construction process, the new index may still contain superfluous pseudo-deleted entries. The second algorithm described in <ref> [Moha91] </ref> is list-based and does not have the above disadvantages. It uses an update-list, like the List-C-Basic strategy, but the index building process performs catch-up differently. <p> Also, their algorithm further optimizes the amount of catch-up work required by only having updaters record their updates in the update-list if the building process has already finished processing the relation page involved in the update. While we have not explicitly simulated the two <ref> [Moha91] </ref> algorithms in our experiments, we believe that their performance can be inferred from that of the Index-C-Basic and the List-C-Basic algorithms. First, the performance of our Index-C-Basic algorithm should be comparable to (or better than) the performance of their index-based algorithm. <p> Appropriate recovery strategies thus have to be designed for this purpose. (Recovery strategies are described for the algorithms in <ref> [Moha91] </ref> and could be adapted for the algorithms studied in this paper.) Also, since a terabyte relation is likely to be declustered across several disks, it is necessary to parallelize the various on-line algorithms for use in parallel database systems.
Reference: [Pu85] <author> Pu, C. </author> <title> "On-the-Fly, Incremental, Consistent Reading of Entire Databases", </title> <booktitle> Proceedings of the International Conference on Very Large Data Bases, </booktitle> <month> 369-375 </month> <year> (1985). </year>
Reference-contexts: Thus, there is a need for these utilities to operate in an on-line fashion [Dewi90]. In terms of related work, algorithms for on-line checkpointing of a global database state have been discussed <ref> [Pu85] </ref> and their performance has been studied [Pu88]. Also, the problem of on-line index reorganization has been discussed briefly in [Ston88].
Reference: [Pu88] <author> Pu, C., Hong, C. H. and Wha, J.M. </author> <title> "Performance Evaluation of Global Reading of Entire Databases", </title> <booktitle> Proceedings of the International Symposium on Databases in Parallel and Distributed Systems, </booktitle> <month> 167-176 </month> <year> (1988). </year>
Reference-contexts: Thus, there is a need for these utilities to operate in an on-line fashion [Dewi90]. In terms of related work, algorithms for on-line checkpointing of a global database state have been discussed [Pu85] and their performance has been studied <ref> [Pu88] </ref>. Also, the problem of on-line index reorganization has been discussed briefly in [Ston88].
Reference: [Silb90] <author> Silberschatz, A., Stonebraker, M. and Ullman, J. D. </author> <title> "Database Systems: Achievements and Opportunities", </title> <booktitle> SIGMOD Record, </booktitle> <volume> 19(4), </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Future databases are expected to be several orders of magnitude larger than the largest databases in operation today. In particular, databases on the order of terabytes (10 12 bytes) are soon expected to be in active use <ref> [Silb90] </ref>. In such databases, the utilities for index construction, database reorganization, and checkpointing will take enormous amounts of time to run due to the time it takes to scan the data itself (since scanning a 1-terabyte table may take days).
Reference: [Srin91a] <author> Srinivasan, V. and Carey, M. J. </author> <title> "Performance of B-tree Concurrency Control Algorithms", </title> <booktitle> Proceedings of the ACM SIGMOD Conference, </booktitle> <month> May </month> <year> 1991. </year>
Reference: [Srin91b] <author> Srinivasan, V. and Carey, M. J. </author> <title> "On-Line Index Construction Algorithms", </title> <booktitle> Proceedings of the High Performance Transaction Systems Workshop, </booktitle> <month> September </month> <year> 1991, </year> <note> to appear. </note>
Reference-contexts: Only recently, however, have algorithms been proposed to tackle the problem This research was partially supported by the National Science Foundation under grant IRI-8657323 and by a University of Wisconsin Vilas Fellowship. 1 of on-line index construction <ref> [Srin91b, Moha91] </ref>. Since B-trees 1 are the most common dynamic index structure in database systems, the existing work has concentrated on algorithms for on-line construction of B-tree indices. <p> A comprehensive set of on-line index construction algorithms were described in an earlier paper <ref> [Srin91b] </ref>. In this paper, we evaluate the relative performance of these on-line index construction algorithms. Using a detailed simulation model of a centralized DBMS, we compare the performance of these on-line index construction algorithms with that of a good off-line algorithm as well as amongst themselves. <p> It should be mentioned that this approach to transaction execution handles situations like transaction aborts in a straightforward manner (see <ref> [Srin91b] </ref> for details). Given that concurrent update transactions behave as described above, we now describe the online index construction algorithms of interest here. <p> We will subdivide the on-line algorithms into two classes, list-based algorithms and index-based algorithms, depending on whether they use a list or an index for storing concurrent updates. More details about the on-line algorithms discussed here can be found in an earlier paper <ref> [Srin91b] </ref>. 2 A way to relax this restriction is described in [Srin91b]. 3 2.3 List-Based Algorithms The list-based algorithms for on-line index construction use a list, called the update-list, to record concurrent updates. <p> More details about the on-line algorithms discussed here can be found in an earlier paper <ref> [Srin91b] </ref>. 2 A way to relax this restriction is described in [Srin91b]. 3 2.3 List-Based Algorithms The list-based algorithms for on-line index construction use a list, called the update-list, to record concurrent updates. <p> updates with the scanned entries is to first sort both the scanned entries and the update-list entries, producing two sorted lists; the index is then built in a bottom-up manner by merging these two sorted lists together, thus producing the leaf pages of the final index in one pass (see <ref> [Srin91b] </ref> for details). In situations where the update-list is large, this merge strategy has some advantages over the sort strategy, as we shall see later. As mentioned earlier and indicated in Table 1, the list-based algorithms also vary in the amount of concurrency allowed after the scan phase. <p> The build process then sorts the list of build phase updates and applies them to the intermediate index concurrently with other updaters. A normal B-tree concurrency control algorithm is used to resolve conflicting accesses to the index by the build process and update transactions during the catchup phase <ref> [Srin91b] </ref>. After the build process completes processing all of the build phase updates, it makes the index available for normal use. <p> To ensure that the final index does not contain any inconsistencies, specially marked entries may need to be entered into this index by updaters; such marked entries are later 5 removed by the build process (see <ref> [Srin91b] </ref> for details). 2.4 Index-Based Algorithms The second class of on-line index construction algorithms is the class of index-based algorithms. In these algorithms, updaters use an index to store concurrent updates instead of the update-list used by the list-based algorithms. <p> A difference that arises from using an index, as opposed to an update-list, is that updaters need to leave behind special index entries in certain situations; this avoids any inconsistencies that might otherwise be caused due to repeated inserts and deletes of the same index entry (see <ref> [Srin91b] </ref> for details). <p> Updaters in the Index-C-* algorithms behave slightly differently (in terms of leaving marked entries in the public index) during the build phase than they do in the scan phase <ref> [Srin91b] </ref>. In the catchup phase, where updaters share an index with the build process, updaters in the Index-C-* algorithms behave just like updaters in the catchup phase of the List-C-* algorithms. <p> Note, however, that our list-based and index-based algorithms can also be modified to make use of a similar optimization <ref> [Srin91b] </ref>.
Reference: [Ston88] <author> Stonebraker, M., Katz, R., Patterson, D. and Ousterhout, J. </author> <booktitle> "The Design of XPRS", Proceedings of the 14th VLDB Conference, </booktitle> <address> Los Angeles, CA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: In terms of related work, algorithms for on-line checkpointing of a global database state have been discussed [Pu85] and their performance has been studied [Pu88]. Also, the problem of on-line index reorganization has been discussed briefly in <ref> [Ston88] </ref>. Only recently, however, have algorithms been proposed to tackle the problem This research was partially supported by the National Science Foundation under grant IRI-8657323 and by a University of Wisconsin Vilas Fellowship. 1 of on-line index construction [Srin91b, Moha91].
Reference: [Yao78] <author> Yao, A. C. </author> " <title> On Random 2-3 Trees", </title> <journal> Acta Informatica, </journal> <volume> 9, 159-170 (1978). 20 21 22 23 24 25 26 27 </volume>
References-found: 14

