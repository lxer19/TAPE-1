URL: http://www.csl.sri.com/~gong/papers/newhash.ps.Z
Refering-URL: http://www.csl.sri.com/~gong/papers/newhash-abs.html
Root-URL: 
Email: (gong@csl.sri.com)  
Title: Collisionful Keyed Hash Functions with Selectable Collisions  
Author: Li Gong 
Keyword: Security in digital systems, distributed systems, data authentication, passwords, guessing attacks, one-way hash functions.  
Date: January 12, 1995  
Address: 333 Ravenswood Avenue Menlo Park, California 94025, U.S.A.  
Affiliation: SRI International Computer Science Laboratory  
Abstract: One-way hash functions (keyed and unkeyed) are often required to be also collision-resistant that is, finding two inputs that map to the same output is computationally hard. Recently, applications using user-chosen passwords suggest that keyed one-way hash functions be collisionful instead of collision-resistant on the key component in order to protect the passwords from guessing attacks. We give a new construction of collisionful keyed one-way hash function where one can select and reuse some of the collisions to better confuse a guessing attack. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T.A. Berson, L. Gong, and T.M.A. Lomas. </author> <title> Secure, Keyed, and Collisionful Hash Functions. </title> <month> December </month> <year> 1993. </year> <note> Included in Technical Report SRI-CSL-94-08, </note> <institution> Computer Science Laboratory, SRI International, Menlo Park, California. </institution>
Reference-contexts: 1 Introduction One-way hash functions (keyed and unkeyed) are often required to be collision-resistant (e.g., see references in <ref> [1, 7] </ref>), so that falsifying a hash value is computationally very hard. However, recently proposed security applications suggest that keyed one-way hash functions be collisionful instead of collision-resistant on the key component [5]. <p> Thus the attacker must gamble on one of the many possibilities of the key and, because the hash function is still collision-resistant on the text component, is highly likely to be detected if he attempts to substitute a different binary. Berson et al. <ref> [1] </ref> give a definition of collisionful one-way hash function and propose a construction of a collisionful function based on the following idea. <p> Given x, it is easy to compute f (x); 2. Given f (x), it is hard to compute x; 3. It is hard to find two values x and y such that f (x) = f (y), but x 6= y. Secure keyed one-way hash function <ref> [1] </ref>. A function g () that maps a key and a second bit string to a string of a fixed length is a secure keyed hash function if it satisfies the following five properties: 1. Given k and x, it is easy to compute g (k; x); 2. <p> Without knowledge of k, it is hard to compute q (k,x) for an arbitrary x. This definition is adapted from that in <ref> [1] </ref>. The main difference is that we only require a pair, instead of possibly many pairs, of x and its hash value in Property 3, because we do not recommend the reuse of passwords in our target applications, such as the secure booting example we mentioned in Section 1. <p> Definition 2 (Collisionful Keyed One-Way Hash Function) A collisionful keyed hash function q () is one way if it is hard to compute x, given k and q (k,x). Berson et al. <ref> [1] </ref> provide a general construction method to add this one-way property to a collisionful keyed hash function. We will summarize this method at the end of Section 3. <p> We now summarize a method that can build a collisionful keyed one-way hash function from v () <ref> [1] </ref>. Suppose we have a one-way hash function f (), a secure keyed one-way hash function F (), and a collisionful keyed hash function v ().
Reference: [2] <author> L. Gong. </author> <title> New Protocols for Third-Party-Based Authentication and Secure Broadcast. </title> <booktitle> In Proceedings of the 2nd ACM Conference on Computer and Communications Security, </booktitle> <pages> pages 176-183, </pages> <address> Fairfax, Virginia, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: Although this property is not needed in the earlier example we gave, it may be important for some other applications. 3 A New Construction Our new construction is based on polynomial interpolation [4], which has been used elsewhere in protocols for secret sharing, authentication, key distribution, and secure broadcast <ref> [8, 2] </ref>. Suppose a user with password k 1 is to compute a collisionful secure checksum of a system binary code x.
Reference: [3] <author> L. Gong, T.M.A. Lomas, R.M. Needham, and J.H. Saltzer. </author> <title> Protecting Poorly Chosen Secrets from Guessing Attacks. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 11(5) </volume> <pages> 648-656, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Thus the collision-resistant property can in fact be a liability, especially when the user's secret is a normal password that is typically chosen from a relatively small space, of which the attacker may be able to conduct an exhaustive search <ref> [3] </ref>. The existence of easy-to-find collisions, on the other hand, protects a user's password in that an attacker cannot determine which is the user's real password.
Reference: [4] <author> D.E. Knuth. </author> <title> The Art of Computer Programming, Vol.2: Seminumerical Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1969. </year> <note> Revised edition. </note>
Reference-contexts: We will summarize this method at the end of Section 3. Although this property is not needed in the earlier example we gave, it may be important for some other applications. 3 A New Construction Our new construction is based on polynomial interpolation <ref> [4] </ref>, which has been used elsewhere in protocols for secret sharing, authentication, key distribution, and secure broadcast [8, 2]. Suppose a user with password k 1 is to compute a collisionful secure checksum of a system binary code x. <p> The user now solves the following set of equations to obtain a 1 ; : : : ; a n . All computations are performed mod (p) where p is a suitably large prime number, although other fields can also be used <ref> [4] </ref>. 8 &gt; &gt; &gt; : k 0 + a 1 fi g (k 2 ; x) + : : : + a n fi (g (k 2 ; x)) n = k 2 k 0 + a 1 fi g (k n ; x) + : : : + a <p> He then uses this value and w (1); w (2); : : : ; w (n) in the checksum to compute k 0 by solving the following set of equations using polynomial interpolation (again all computations are performed mod (p)) <ref> [4] </ref>. 8 &gt; &gt; &gt; : k 0 + a 1 fi 1 + : : : + a n fi 1 n = w (1) k 0 + a 1 fi n + : : : + a n fi n n = w (n) Finally, he computes g (k
Reference: [5] <author> T.M.A. Lomas and B. Christianson. </author> <title> To Whom Am I Speaking? Remote Booting in a Hostile World. </title> <journal> IEEE Computer, </journal> <volume> 28(1) </volume> <pages> 50-54, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: 1 Introduction One-way hash functions (keyed and unkeyed) are often required to be collision-resistant (e.g., see references in [1, 7]), so that falsifying a hash value is computationally very hard. However, recently proposed security applications suggest that keyed one-way hash functions be collisionful instead of collision-resistant on the key component <ref> [5] </ref>. For example, suppose a user reboots his workstation whenever he suspects that the computer may have been compromised. During the reboot, a clean binary is downloaded from a storage device, probably via a network.
Reference: [6] <author> R. Morris and K. Thompson. </author> <title> Password Security: A Case History. </title> <journal> Communications of the ACM, </journal> <volume> 22(11) </volume> <pages> 594-597, </pages> <month> November </month> <year> 1979. </year>
Reference-contexts: Suppose we have a one-way hash function f (), a secure keyed one-way hash function F (), and a collisionful keyed hash function v (). For each x, we choose a salt value s of a suitable length (to make dictionary attacks more difficult <ref> [6] </ref>) and define r (k; x) = s j F (v (k; s); f (x)). Theorem 2 Function r (k; x) is a collisionful keyed one-way hash function. Proof. First, r () is easy to compute.
Reference: [7] <author> B. Preneel. </author> <title> Cryptographic Hash Functions. </title> <journal> European Transactions on Telecommunications, </journal> <volume> 5(4) </volume> <pages> 431-448, </pages> <month> July-August </month> <year> 1994. </year>
Reference-contexts: 1 Introduction One-way hash functions (keyed and unkeyed) are often required to be collision-resistant (e.g., see references in <ref> [1, 7] </ref>), so that falsifying a hash value is computationally very hard. However, recently proposed security applications suggest that keyed one-way hash functions be collisionful instead of collision-resistant on the key component [5]. <p> If the checksum function is collision-resistant, then it is hard - computationally infeasible to find two different keys that would map the same input (binary) to identical hash value. Being collision-resistant is often stated as a desirable requirement <ref> [7] </ref>, but the property also means that if the attacker stumbles upon a string that, used as a key and together with the binary, would produce 1 a checksum identical to the original, then the attacker is highly confident that he has found the right secret, and his subsequent substitution has <p> Moreover, to protect the reuse of the password, the user can reuse some of the collisions to help prevent the attacker from reducing the search space. 2 Definitions For comparison, we first recall the definitions for keyed and unkeyed collision-resistant one-way hash functions. Collision-resistant one-way hash function <ref> [7] </ref>. A function f () that maps bit strings, either of an arbitrary length or a predetermined length, to strings of a fixed length is a collision-resistant one-way hash function if it satisfies the following three properties: 1. Given x, it is easy to compute f (x); 2. <p> Given (possibly many) pairs of x and g (k; x), it is hard to compute k; 5. Without knowledge of k, it is hard to compute g (k; x) for an arbitrary x. There is a similar but different definition, called manipulation detection code <ref> [7] </ref>, which does not require property 2 and interprets hardness in property 5 specifically to be as hard as random guessing. A collisionful function is collision-resistant on the text component but has easy-to-find collisions on the key component.
Reference: [8] <author> A. Shamir. </author> <title> How to Share a Secret. </title> <journal> Communications of the ACM, </journal> <volume> 22(11) </volume> <pages> 612-613, </pages> <month> November </month> <year> 1979. </year>
Reference-contexts: Although this property is not needed in the earlier example we gave, it may be important for some other applications. 3 A New Construction Our new construction is based on polynomial interpolation [4], which has been used elsewhere in protocols for secret sharing, authentication, key distribution, and secure broadcast <ref> [8, 2] </ref>. Suppose a user with password k 1 is to compute a collisionful secure checksum of a system binary code x.
References-found: 8

