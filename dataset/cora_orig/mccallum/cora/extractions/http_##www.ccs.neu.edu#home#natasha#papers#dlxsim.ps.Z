URL: http://www.ccs.neu.edu/home/natasha/papers/dlxsim.ps.Z
Refering-URL: http://www.ccs.neu.edu/home/natasha/resume.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Chapter 1 Implementation of a Vectorized DLX Simulator 1.1 Introduction characteristics of the DLXV architecture
Author: and others. 
Note: 1.2 The DLXV Architecture The DLXV architecture simulated is basically the one described in Chapter 7 of [1]. The major  others described later). The number of vector registers can be anything from 0 to 16, and the maximum vector length supported by the simulator is 1024 doublewords. This covers the  
Abstract: This project involved extending the DLXsim, the simulator written in the University of California at Berkeley, to incorporate the simulation of a vector machine. The vector architecture simulated is the DLXV architecture described in Computer Architecture, A Quantitative Approach by Hennessy and Patterson ([1]). The DLXVsim (the DLXV architecture simulator) uses the same user interface as DLXsim described in [2], augmented by few more commands to examine vector machine behavior. When extending the DLXsim there were two major tasks to consider: creating and operating on the data structures for vector architecture simulation and extending the instruction set already implemented in DLXsim. These two issues will be addressed in this report along with the description of the machine simulated and the design decisions and assumptions made. This will be followed by some examples of how to use the simulator. We expect that a major use of this tool will be in Computer Architecture classes to help in understanding of vector architecture. Few sample exercises that can be used in these classes, may be found at the end of this report. * There are special vector functional units to carry out vector operations. These units are: vector add/subtract unit, vector multiply unit, vector divide unit and the logical unit. All the units are fully pipelined and can start a new operation on every clock cycle. Each 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> John L. hennessy & David A. Patterson. </author> <title> Computer Architecture A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers, Inc. </publisher> <address> San Mateo, CA </address>
Reference-contexts: Few sample exercises that can be used in these classes, may be found at the end of this report. 1.2 The DLXV Architecture The DLXV architecture simulated is basically the one described in Chapter 7 of <ref> [1] </ref>. The major characteristics of the DLXV architecture are as follows. * There are 8 vector registers. Each register is a fixed-length bank holding a single vector. A vector consists of 64 double precision floating point numbers. However, these are just default values. <p> The default start-up cost for this unit is 12 clock cycles but can be changed by the user. The DLXVsim supports all the instructions described on p. 356 of <ref> [1] </ref>. All the instructions work on double-precision floating point numbers. 1.3 Extending The Instruction Set Of DLXsim The DLXsim simulator gives you the opportunity to extend the standard instruction set. Obviously, this had to be done in order to incorporate vector machine simulator. <p> The first is opTable. It contains entries corresponding to possible opCodes. Each entry consists of the opCode itself and the type of the instruction: I-type, R-type or J-type. (See p. 166 of <ref> [1] </ref> for the description of these types). Several entries in the table have the opcode OP RES and are reserved for new instructions. So, if you want to have a new instruction in the instruction set, you put its opcode instead of any OP RES. <p> The bits in the middle should remain zeroes (these are the bits for the operands information). The more detailed description of the bit patterns for the operations can be found in Appendix E of <ref> [1] </ref>. * Various flags are used to give more information about the instruction, such as type of operands (general purpose register, floating point register, immediate) or range checking information. <p> The arrays described in the last item are accessed via the array of pointers vect units. Special Vector Registers For efficient operation of the vector machine two special registers are required: vector-mask register and vector-length register . (See sections 7.3 and 7.6 of <ref> [1] </ref> for detailed description of their use.) The value of the vector length register is stored in the VLR variable. The vector-mask register is an array of bytes pointed by VM where the number of bits is equal to the maximum vector length. <p> This is the reason why various refinements are used to improve the performance: vector-mask capability, load/store with stride or with index. The influence of these improvements 13 can be explored by using this simulator. All the instructions described on the p. 356 of <ref> [1] </ref> can be used in the assembly codes to be run on the simulator. For better understanding of the details of vector architecture and DLXV instruction set, the exercises after this section can be used. 14 Exercises Exercise 1. <p> How would you explain the results? Exercise 2. In this exercise you will see how different hardware parameters can effect performance of the machine. The DLXV simulator has default hardware parameters as described on pp. 353-354 of <ref> [1] </ref>. That is by examining configuration of the machine you will see the following: dlxsim % dlxsim (dlxsim) stats vhw Memory size: 65536 bytes. <p> The simulator gives the opportunity to use integer and floating point instructions and supports the whole DLX instruction set introduced in <ref> [1] </ref>. It also gives additional statistics values as compared to the ones described in [2]. This report contains a brief overview of the DLX pipeline architecture followed by the detailed discussion on the simulator implementation issues. <p> use of this tool will be in Computer Architecture classes to help the students in understanding what pipeline is, what problems it may cause and how to deal with them. 2.2 DLX Pipeline Architecture The pipeline implemented in this simulator is the standard DLX pipeline described in Chapter 6 of <ref> [1] </ref>. <p> The instruction which is stalled is the one with the smaller latency. This was just a brief overview of DLX pipeline and we assumed that the user is familiar with the general concept of pipelining. For detailed discussion on this topic refer to Chapter 6 of <ref> [1] </ref>. 19 2.3 The Main Simulation Loop The core function of the pipeline Simulator is the function Pipe Simulate contained in the file pipe.c. Here we discuss the main points of this function. 2.3.1 Data structures The information about each pipeline stage is contained in the array machPtr-&gt;stages. <p> It will become valid again if anything is passed from the earlier stages. Events that happen on each pipe stage are close to the ones described on p. 256 of <ref> [1] </ref>. Here is a detailed description of what the simulator does at each pipe stage: WB The value is getting written to the destination register (if any). <p> Floating Point Loads Another design decision which was to be made is about the status of floating point load: whether to consider it as integer or floating point instruction. If we follow the terminology of <ref> [1] </ref> and consider all loads, no matter integer or fp, to be integer instructions, fp load can overlap with some other floating point instruction in MEM and WB stage. <p> At the beginning the pipeline is empty: (dlxsim) stats pipeline 27 PIPELINE STATE no instruction starting WB no instruction starting MEM no instruction starting EX no instruction starting ID no instruction starting IF The abbreviations are the standard abbreviations adopted in <ref> [1] </ref>: IF Instruction Fetch ID Instruction Decode EX Execute MEM Memory Access WB Write Back Here is the pipeline state after the first step (the step here is always one clock cycle). (dlxsim) step _main stopped after single step, pc = _main+0x4: addi r2,r0,0x108 (dlxsim) stats pipeline PIPELINE STATE no instruction <p> Which? What are the pipeline stalls occurring here? Trace the execution of the program using the simulator and explain the reasons for all the stalls in it. 32 Exercise 2. Do the exercise 6.16 from <ref> [1] </ref>. You may use the DLXsim to collect the data and to try various ordering of instructions to maximize performance. 33
Reference: [2] <author> Larry B. Hostetler & Brian Mirtich. </author> <title> DLXsim | A Simulator for DLX 34 </title>
Reference-contexts: The vector architecture simulated is the DLXV architecture described in Computer Architecture, A Quantitative Approach by Hennessy and Patterson ([1]). The DLXVsim (the DLXV architecture simulator) uses the same user interface as DLXsim described in <ref> [2] </ref>, augmented by few more commands to examine vector machine behavior. When extending the DLXsim there were two major tasks to consider: creating and operating on the data structures for vector architecture simulation and extending the instruction set already implemented in DLXsim. <p> There is one extra element in each of the arrays to keep track of the status of the vector-mask register . Pending Vector Operations List The list VectOpsList is very similar to the list FPopsList used for floating point operations (see <ref> [2] </ref>). It is a linked list of structures of type Vectop, where each element contains all the information needed about pending vector operation. <p> instruction is easy because the lists of instructions in execution are ordered with respect to the cycle when they will be ready. 7 1.5 Additions To the Manual of DLXsim to Examine Vector Machine Behavior Few more commands were added to the user interface of DLXsim (see manual entry of <ref> [2] </ref>). <p> It can be examined now and we will do one more step after that. (dlxsim) vget v1 [0..7] v1 [0] : 1.000000 12 v1 <ref> [2] </ref> : 3.000000 v1 [4] : 5.000000 v1 [6] : 7.000000 (dlxsim) step stopped after single step, pc = _main+0x1c: sync (dlxsim) stats pending Pending Floating Point Operations: none. <p> Pending Vector Operations: none. And to finish: (dlxsim) step TRAP #0 received (dlxsim) vget A [0..2] A [0] : 2.000000 A <ref> [2] </ref> : 4.000000 The values of the elements of vector A have been modified. One could notice the big number of stalls in this example. The vector machine does not look very efficient here. <p> The simulator gives the opportunity to use integer and floating point instructions and supports the whole DLX instruction set introduced in [1]. It also gives additional statistics values as compared to the ones described in <ref> [2] </ref>. This report contains a brief overview of the DLX pipeline architecture followed by the detailed discussion on the simulator implementation issues. It also includes an example of an interactive session with DLXsim with the focus on examining pipeline features. <p> 2.4 Additions to The Manual of DLXsim to Examine Pipeline Behavior To make DLXsim execute its pipelined version one should call it with -PIPE option: % dlxsim -PIPE There is a number of changes and additions made to the user interface of DLXsim session introduced in the manual entry of <ref> [2] </ref>. This is their description: step The meaning of this command is changed: it executes single clock cycle, not single in struction as in original DLXsim ; stats New option is added to this command: pipeline.
References-found: 2

