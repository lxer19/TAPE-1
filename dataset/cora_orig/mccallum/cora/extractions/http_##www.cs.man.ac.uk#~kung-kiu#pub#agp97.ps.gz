URL: http://www.cs.man.ac.uk/~kung-kiu/pub/agp97.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: kung-kiu@cs.man.ac.uk ornaghi@dsi.unimi.it  
Title: On the Relationship between Logic Programs and Specifications  
Author: Kung-Kiu Lau Mario Ornaghi 
Address: Oxford Road, Manchester M13 9PL Via Comelico 39/41, Milano United Kingdom Italy  
Affiliation: Dept. of Computer Science DSI University of Manchester Universita degli studi di Milano  
Abstract: The fundamental relation between a program P and its specification S is correctness: P satisfies S if and only if P is correct with respect to S. In logic programming, this relationship can be particularly close, since logic can be used to express both specifications and programs. Indeed logic programs are often regarded and used as (executable) specifications themselves. In this paper, we argue that the relation between S and P should be firmly set in the context of the underlying problem domain, which we call a framework F, and we give a model-theoretic view of the correctness relation between specifications and programs in F. We show that the correctness relation between S and P is always well-defined. It thus provides a basis for properly distinguishing between S and P . We use the subset example throughout, to illustrate our model-theoretic approach. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bertoni, G. Mauri and P. Miglioli. </author> <title> On the power of model theory in specifying abstract data types and in capturing their recursiveness. </title> <note> Fundamenta Informaticae VI(2):127-170, </note> <year> 1983. </year>
Reference-contexts: It is easy to see that these two meanings of subset coincide completely, i.e. P1 is correct with respect to S1. For example, for the query Q1: ? subset ([A; B]; <ref> [1; 2; 3] </ref>): (Q1) P1 produces the following nine expected answers (i.e. values of A, B such that subset ([A,B], [1,2,3]) is true according to S1): A=1,B=1; A=1,B=2; A=1,B=3; A=3,B=1; A=3,B=2; A=3,B=3. <p> This is a useful existence condition for isoinitial models. Furthermore, it can be shown that if F is a (possibly infinite) recursively enumerable axiomatization, then there 3 This holds only for reachable models. For non-reachable models initiality and isoinitiality are independent properties (see <ref> [1] </ref>). exists an isoinitial model in which relation symbols are interpreted by decidable relations, and function symbols by total computable functions. Indeed, we only ever construct such frameworks. To construct such a framework F n for axiomatizing a type T , we proceed incrementally.
Reference: [2] <author> A. Bossi, M. Gabbrielli, G. Levi and M.C. Meo. </author> <title> A compositional semantics for logic programs. </title> <booktitle> Theoretical Computer Science 122 </booktitle> <pages> 3-47, </pages> <year> 1994. </year>
Reference-contexts: It is easy to see that these two meanings of subset coincide completely, i.e. P1 is correct with respect to S1. For example, for the query Q1: ? subset ([A; B]; <ref> [1; 2; 3] </ref>): (Q1) P1 produces the following nine expected answers (i.e. values of A, B such that subset ([A,B], [1,2,3]) is true according to S1): A=1,B=1; A=1,B=2; A=1,B=3; A=3,B=1; A=3,B=2; A=3,B=3. <p> This kind of correctness, which we call steadfastness ([13]), that is preserved through inheritance hierarchies seems to be a promising tool for formal object-oriented software engineering. Our semantics for open programs, their correctness, and the correctness of their composition is also different from other model-theoretic approaches such as <ref> [3, 2] </ref>. Again, the main difference lies in our use of a framework that allows us to reason about the correctness of program composition. This enables us to define steadfastness, which is the basis of formal correctness of object-oriented programs.
Reference: [3] <author> A. Brogi, E. Lamma and P. Mello. </author> <title> Composing open logic programs. </title> <editor> J. </editor> <booktitle> Logic and Computation 3(4) </booktitle> <pages> 417-439, </pages> <year> 1993. </year>
Reference-contexts: It is easy to see that these two meanings of subset coincide completely, i.e. P1 is correct with respect to S1. For example, for the query Q1: ? subset ([A; B]; <ref> [1; 2; 3] </ref>): (Q1) P1 produces the following nine expected answers (i.e. values of A, B such that subset ([A,B], [1,2,3]) is true according to S1): A=1,B=1; A=1,B=2; A=1,B=3; A=3,B=1; A=3,B=2; A=3,B=3. <p> This kind of correctness, which we call steadfastness ([13]), that is preserved through inheritance hierarchies seems to be a promising tool for formal object-oriented software engineering. Our semantics for open programs, their correctness, and the correctness of their composition is also different from other model-theoretic approaches such as <ref> [3, 2] </ref>. Again, the main difference lies in our use of a framework that allows us to reason about the correctness of program composition. This enables us to define steadfastness, which is the basis of formal correctness of object-oriented programs.
Reference: [4] <author> Y. Deville and K.-K. Lau. </author> <title> Logic program synthesis. </title> <journal> J. Logic Programming 19,20:321-350, </journal> <note> 1994. Special issue: Ten years of logic programming. </note>
Reference-contexts: In general, model-theoretic correctness is based on the comparison between specifications and the intended models of programs (see e.g. <ref> [4] </ref> for a brief survey). The distinguishing feature of our approach is that specifications, programs and correctness are defined within a framework F (the use of frameworks is discussed in [9, 11]).
Reference: [5] <author> J.H. Gallier. </author> <title> Logic for Computer Science: Foundations for Automatic Theorem Proving. </title> <publisher> Harper and Row, </publisher> <year> 1986. </year>
Reference-contexts: The latter is not quite satisfactory, since the meaning of correctness must be defined in terms of something other than logic programs themselves (see e.g. <ref> [5, p. 410] </ref>). We have shown that in a framework, we can define correctness in a semantic way, either informally or formally. Informal correctness allows us to relate programs to their informal specifications. Formal correctness involves full first-order logical theories, and is defined in terms of model theory.
Reference: [6] <author> P.M. Hill and J.W. Lloyd. </author> <title> The Godel Programming Language. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Axioms for the old sorts are imported, and new ones are added to define new functions and relations on T . The syntax of a framework F is similar to that used in algebraic abstract data types (e.g. [17]), or in typed logic programming languages such as Godel <ref> [6] </ref>. However, whilst an algebraic abstract data type is an initial model (defined below) of its specification, the intended model of F , i.e. the abstract data type it axiomatizes, is an isoinitial model.
Reference: [7] <author> W. Hodges. </author> <title> Logical features of Horn clauses. In D.M. </title> <editor> Gabbay, C.J. Hogger, and J.A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <volume> Vol 1, </volume> <pages> pages 449-503, </pages> <publisher> Oxford University Press, </publisher> <year> 1993. </year>
Reference: [8] <author> R.A. Kowalski. </author> <title> The relation between logic programming and logic specification. In C.A.R. Hoare and J.C. </title> <editor> Shepherdson, editors, </editor> <booktitle> Mathematical Logic and Programming Languages, </booktitle> <pages> pages 11-27, </pages> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: The precise nature of this relationship depends on the chosen specification language L S (and the notion of correctness that has been adopted). For instance, if L S is also a logic language, then this relation could be very close (see e.g. <ref> [8] </ref>). Indeed logic programs are often regarded and used as (executable) specifications themselves. After all, a logic program is a Horn clause theory ([7]), and as such it can double as a definition.
Reference: [9] <author> K.-K. Lau and M. Ornaghi. </author> <title> On specification frameworks and deductive synthesis of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. LOPSTR 94 and META 94 , Lecture Notes in Computer Science 883, </booktitle> <pages> pages 104-121, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In general, model-theoretic correctness is based on the comparison between specifications and the intended models of programs (see e.g. [4] for a brief survey). The distinguishing feature of our approach is that specifications, programs and correctness are defined within a framework F (the use of frameworks is discussed in <ref> [9, 11] </ref>). We shall define F to be a full first-order logical theory, S a first-order formula in F that defines a (set of) relation (s) r, and P a Horn theory whose language contains the relation (s) r.
Reference: [10] <author> K.-K. Lau, M. Ornaghi and S.- A. </author> <title> Tarnlund. The halting problem for deductive synthesis of logic programs. </title> <editor> In P. van Hentenryck, editor, </editor> <booktitle> Proc. 11 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 665-683, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: In this section, we shall consider the model-theoretic correctness relation between S and P , within a formal framework F , following our approach to deductive synthesis of (both standard and constraint) logic programs (see e.g. <ref> [10, 12] </ref>). In general, model-theoretic correctness is based on the comparison between specifications and the intended models of programs (see e.g. [4] for a brief survey).
Reference: [11] <author> K.-K. Lau and M. Ornaghi. </author> <title> Towards an object-oriented methodology for deductive synthesis of logic programs. </title> <editor> In M. Proietti, editor, </editor> <booktitle> Proc. </booktitle> <volume> LOPSTR 95 , LNCS 1048 </volume> <pages> 152-169, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: In general, model-theoretic correctness is based on the comparison between specifications and the intended models of programs (see e.g. [4] for a brief survey). The distinguishing feature of our approach is that specifications, programs and correctness are defined within a framework F (the use of frameworks is discussed in <ref> [9, 11] </ref>). We shall define F to be a full first-order logical theory, S a first-order formula in F that defines a (set of) relation (s) r, and P a Horn theory whose language contains the relation (s) r. <p> In general we can use our approach to specify what are called generic classes in object-oriented programming, and define correctness of open methods with respect to to their specifications when they are inherited (see <ref> [11] </ref>). This kind of correctness, which we call steadfastness ([13]), that is preserved through inheritance hierarchies seems to be a promising tool for formal object-oriented software engineering.
Reference: [12] <author> K.-K. Lau and M. Ornaghi. </author> <title> A formal approach to deductive synthesis of constraint logic programs. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proc. 1995 Int. Logic Programming Symp., </booktitle> <pages> pages 543-557, </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: In this section, we shall consider the model-theoretic correctness relation between S and P , within a formal framework F , following our approach to deductive synthesis of (both standard and constraint) logic programs (see e.g. <ref> [10, 12] </ref>). In general, model-theoretic correctness is based on the comparison between specifications and the intended models of programs (see e.g. [4] for a brief survey).
Reference: [13] <author> K.-K. Lau, M. Ornaghi and S.-. A. </author> <title> Tarnlund. Steadfast logic programs. </title> <note> Submitted to J. Logic Programming. </note>
Reference-contexts: (:nocc 1 (H) _ (nocc 1 (X) ^ fXg fHg)) $ select (x; Y; H) ^ sublist (X; H) 8 Indeed, in this case, the clauses of P are theorems of SET [ f8 (sublist (X; Y ) $ big (X; Y ))g. 9 A proof can be found in <ref> [13] </ref>. 10 nocc 1 (L) means L does not contain duplicates. In the second proof, select can be chosen in different ways.
Reference: [14] <author> K.-K. Lau, M. Ornaghi. </author> <title> The Relationship between Logic Programs and Specifications | The Subset Example Revisited. </title> <note> To appear in J. Logic Programming. </note>
Reference-contexts: The full meaning of S, including the specified relation r, is defined in F . Since P does not contain axioms for fl This paper has been extracted from <ref> [14] </ref>. F , we can always distinguish between S and P . Nevertheless, P is correct with respect to S if P computes r according to S. This approach makes sense not only for (closed) informal and formal frameworks, but also for open, or parameterized frameworks.
Reference: [15] <author> P. Miglioli, U. Moscato and M. Ornaghi. </author> <title> Abstract parametric classes and abstract data types defined by classical and constructive logical methods. </title> <journal> J. Symb. Comp. </journal> <volume> 18 </volume> <pages> 41-81, </pages> <year> 1994. </year>
Reference: [16] <author> J.C. Shepherdson. </author> <title> Negation in logic programming. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 19-88. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Indeed, we only ever construct such frameworks. To construct such a framework F n for axiomatizing a type T , we proceed incrementally. We start with a small framework F 0 with an obvious isoinitial model I 0 . For instance, if the freeness axioms (see <ref> [16] </ref>) hold in T , then F 0 consists of just the constructor symbols in F n together with their freeness axioms. The term model generated by the constructors is of course just the set of ground terms of T .
Reference: [17] <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: T is constructed from constructors (e.g. f g), declared as functions. Axioms for the old sorts are imported, and new ones are added to define new functions and relations on T . The syntax of a framework F is similar to that used in algebraic abstract data types (e.g. <ref> [17] </ref>), or in typed logic programming languages such as Godel [6]. However, whilst an algebraic abstract data type is an initial model (defined below) of its specification, the intended model of F , i.e. the abstract data type it axiomatizes, is an isoinitial model.
References-found: 17

