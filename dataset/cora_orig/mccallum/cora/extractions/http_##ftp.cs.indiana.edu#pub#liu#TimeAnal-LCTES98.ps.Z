URL: http://ftp.cs.indiana.edu/pub/liu/TimeAnal-LCTES98.ps.Z
Refering-URL: http://www.cs.indiana.edu/hyplan/liu.html
Root-URL: http://www.cs.indiana.edu
Email: fliu,ggomezesg@cs.indiana.edu  
Title: Automatic Accurate Time-Bound Analysis for High-Level Languages  
Author: Yanhong A. Liu and Gustavo Gomez 
Address: Bloomington, IN 47405  
Affiliation: Computer Science Department, Indiana University,  
Abstract: This paper describes a general approach for automatic and accurate time-bound analysis. The approach consists of transformations for building time-bound functions in the presence of partially known input structures, symbolic evaluation of the time-bound function based on input parameters, optimizations to make the overall analysis efficient as well as accurate, and measurements of primitive parameters, all at the source-language level. We have implemented this approach and performed a number of experiments for analyzing Scheme programs. The measured worst-case times are closely bounded by the calculated bounds.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> P. Altenbernd. </author> <title> On the false path problem in hard real-time programs. </title> <booktitle> In Proceedings of the 8th EuroMicro Workshop on Real-Time Systems, </booktitle> <pages> pages 102-107, </pages> <address> L'Aquila, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis <ref> [18, 1] </ref>. For example, the inaccurate loop bounds cause the calculated worst-case time to be as much as 67% higher than the measured worst-case time in [19], while the manual way of providing such information is potentially an even larger source of error, in addition to its inconvenience [18]. <p> Various program analysis methods have been proposed to provide loop bounds or execution paths <ref> [1, 6, 9] </ref>. <p> However, if we consider only the two realizable execution paths, we know that the worst case is tF ibonacci (2000) plus some small constants. This is known as the false-path elimination problem <ref> [1] </ref>. Two transformations, lifting conditions and simplifying conditionals, allow us to achieve the accurate analysis results above. In each function definition, the former lifts conditions to the outmost scope that the test does not depend on, and the latter simplifies conditionals according to the lifted condition. <p> There is also work for measuring primitive parameters of Fortran programs for the purpose of general performance prediction [21], not worst-case analysis. A number of techniques have been studied for obtaining loop bounds or execution paths <ref> [18, 1, 6, 9] </ref>. Manual annotations [18, 13] are inconvenient and error-prone [1]. Automatic analysis of such information has two main problems. First, separating the loop and path information from the rest of the analysis [6] is in general less accurate than an integrated analysis [17]. <p> There is also work for measuring primitive parameters of Fortran programs for the purpose of general performance prediction [21], not worst-case analysis. A number of techniques have been studied for obtaining loop bounds or execution paths [18, 1, 6, 9]. Manual annotations [18, 13] are inconvenient and error-prone <ref> [1] </ref>. Automatic analysis of such information has two main problems. First, separating the loop and path information from the rest of the analysis [6] is in general less accurate than an integrated analysis [17].
Reference: 2. <editor> B. Bjtrner, A. P. Ershov, and N. D. Jones, editors. </editor> <title> Partial Evaluation and Mixed Computation. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1988. </year>
Reference-contexts: The idea of using partially known input structures originates from Rosendahl [20]. We have extended it to manipulate primitive parameters. We also handle binding constructs, which is simple but necessary for efficient computation. An innovation in our method is to optimize the time-bound function using partial evaluation <ref> [2, 10] </ref>, incremental computation [16, 15], and transformations of conditionals to make the analysis more efficient and more accurate. We are starting to explore a suite of new language-based techniques for timing analysis, in particular, analyses and optimizations for further speeding up the evaluation of the time-bound function.
Reference: 3. <author> Cadence Research Systems. </author> <title> Chez Scheme System Manual. </title> <institution> Cadence Research Systems, Bloomington, Indiana, </institution> <address> revision 2.4 edition, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: They are discussed further in [14]. 6 Implementation and experimentation We have implemented the analysis approach in a prototype system, ALPA (Automatic Language-based Performance Analyzer). The implementation is for a subset of Scheme. The measurements and analyses are performed for source programs compiled with Chez Scheme compiler <ref> [3] </ref>. The particular numbers below are taken on a Sun Ultra 1 with 167MHz UltraSPARC CPU and 64MB main memory, but we have also performed the analysis for several other kinds of SPARC stations, and the results are similar.
Reference: 4. <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Note that side effects caused by these features often cause other analysis to be difficult <ref> [4] </ref>. For pure functional languages, higher-order functions and lazy evaluations are important. Time-bound functions that accommodate these features have been studied [24, 22]. The symbolic evaluation and optimizations we describe apply to them as well. 3 Constructing time-bound functions Constructing timing functions.
Reference: 5. <author> J. Engblom, P. Altenbernd, and A. Ermedahl. </author> <title> Facilitating worst-case execution time analysis for optimized code. </title> <booktitle> In Proceedings of the 10th EuroMicro Workshop on Real-Time Systems, </booktitle> <address> Berlin, Germany, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: Since Shaw proposed timing schema for analyzing system running time based on high-level languages [23], a number of people have extended it for analysis in the presence of compiler optimizations <ref> [5] </ref>, pipelining [13], cache memory [13, 7], etc. However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis [18, 1].
Reference: 6. <author> A. Ermedahl and J. Gustafsson. </author> <title> Deriving annotations for tight calculation of execution time. </title> <booktitle> In In Proceedings of Euro-Par'97, volume 1300 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1298-1307. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> Aug. </month> <year> 1997. </year>
Reference-contexts: Various program analysis methods have been proposed to provide loop bounds or execution paths <ref> [1, 6, 9] </ref>. <p> There is also work for measuring primitive parameters of Fortran programs for the purpose of general performance prediction [21], not worst-case analysis. A number of techniques have been studied for obtaining loop bounds or execution paths <ref> [18, 1, 6, 9] </ref>. Manual annotations [18, 13] are inconvenient and error-prone [1]. Automatic analysis of such information has two main problems. First, separating the loop and path information from the rest of the analysis [6] is in general less accurate than an integrated analysis [17]. <p> A number of techniques have been studied for obtaining loop bounds or execution paths [18, 1, 6, 9]. Manual annotations [18, 13] are inconvenient and error-prone [1]. Automatic analysis of such information has two main problems. First, separating the loop and path information from the rest of the analysis <ref> [6] </ref> is in general less accurate than an integrated analysis [17]. Second, approximations for merging paths from loops, or recursions, very often lead to nontermination of the time analysis, not just looser bounds [6, 17]. Some new methods, while powerful, apply only to certain classes of programs [9]. <p> First, separating the loop and path information from the rest of the analysis [6] is in general less accurate than an integrated analysis [17]. Second, approximations for merging paths from loops, or recursions, very often lead to nontermination of the time analysis, not just looser bounds <ref> [6, 17] </ref>. Some new methods, while powerful, apply only to certain classes of programs [9]. In contrast, our method allows recursions, or loops, to be considered naturally in the overall execution-time analysis based on partially known input structures.
Reference: 7. <author> C. Ferdinand, F. Martin, and R. Wilhelm. </author> <title> Applying compiler techniques to cache behavior prediction. </title> <booktitle> In Proceedings of the ACM SIGPLAN 1997 Workshop on Languages, Compilers, and Tools for Real-Time Systems, </booktitle> <pages> pages 37-46, </pages> <year> 1997. </year>
Reference-contexts: Since Shaw proposed timing schema for analyzing system running time based on high-level languages [23], a number of people have extended it for analysis in the presence of compiler optimizations [5], pipelining [13], cache memory <ref> [13, 7] </ref>, etc. However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis [18, 1]. <p> We also believe that the lower-bound analysis is entirely symmetric to the upper-bound analysis, by replacing maximum with minimum at all conditional points. Finally, we plan to accommodate more lower-level dynamic factors for timing at the source-language level <ref> [13, 7] </ref>. In particular, we plan to apply our general approach to analyze space consumption and hence to help predict garbage-collection and caching behavior.
Reference: 8. <author> P. Flajolet, B. Salvy, and P. Zimmermann. </author> <title> Automatic average-case analysis of algorithms. </title> <journal> Theoretical Computer Science, Series A, </journal> <volume> 79(1) </volume> <pages> 37-109, </pages> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms <ref> [11, 8] </ref>, programming languages [25, 12, 20, 22], and systems [23, 19, 21].
Reference: 9. <author> C. Healy, M. Sjodin, V. Rustagi, and D. Whalley. </author> <title> Bounding loop iterations for timing analysis. </title> <booktitle> In Proceedings of the IEEE Real-Time Applications Symposium. </booktitle> <publisher> IEEE CS Press, Los Alamitos, </publisher> <address> Calif., </address> <month> June </month> <year> 1998. </year>
Reference-contexts: Various program analysis methods have been proposed to provide loop bounds or execution paths <ref> [1, 6, 9] </ref>. <p> There is also work for measuring primitive parameters of Fortran programs for the purpose of general performance prediction [21], not worst-case analysis. A number of techniques have been studied for obtaining loop bounds or execution paths <ref> [18, 1, 6, 9] </ref>. Manual annotations [18, 13] are inconvenient and error-prone [1]. Automatic analysis of such information has two main problems. First, separating the loop and path information from the rest of the analysis [6] is in general less accurate than an integrated analysis [17]. <p> Second, approximations for merging paths from loops, or recursions, very often lead to nontermination of the time analysis, not just looser bounds [6, 17]. Some new methods, while powerful, apply only to certain classes of programs <ref> [9] </ref>. In contrast, our method allows recursions, or loops, to be considered naturally in the overall execution-time analysis based on partially known input structures. The most recent work by Lundqvist and Stenstrom [17] is based on essentially the same ideas as ours.
Reference: 10. <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1993. </year>
Reference-contexts: The idea of using partially known input structures originates from Rosendahl [20]. We have extended it to manipulate primitive parameters. We also handle binding constructs, which is simple but necessary for efficient computation. An innovation in our method is to optimize the time-bound function using partial evaluation <ref> [2, 10] </ref>, incremental computation [16, 15], and transformations of conditionals to make the analysis more efficient and more accurate. We are starting to explore a suite of new language-based techniques for timing analysis, in particular, analyses and optimizations for further speeding up the evaluation of the time-bound function.
Reference: 11. <author> D. E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> volume 1. </volume> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1968. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms <ref> [11, 8] </ref>, programming languages [25, 12, 20, 22], and systems [23, 19, 21].
Reference: 12. <author> D. Le Metayer. </author> <title> Ace: An automatic complexity evaluator. </title> <journal> ACM Trans. Program. Lang. Syst., </journal> <volume> 10(2) </volume> <pages> 248-266, </pages> <month> Apr. </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [11, 8], programming languages <ref> [25, 12, 20, 22] </ref>, and systems [23, 19, 21]. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [23, 19]. <p> Constructing time-bound functions. Characterizing program inputs and capturing them in the timing function are difficult to automate <ref> [25, 12, 23] </ref>. However, partially known input structures provide a natural means [20]. A special value unknown represents unknown values. <p> We are implementing that algorithm. We also noticed that static analysis can be exploited to identify sources of nonter-mination. 7 Related work and conclusion Compared to work in algorithm analysis and program complexity analysis <ref> [12, 22] </ref>, this work consistently pushes through symbolic primitive parameters, so it allows us to calculate actual time bounds and validate the results with experimental measurements.
Reference: 13. <author> S.-S. Lim, Y. H. Bae, G. T. Jang, B.-D. Rhee, S. L. Min, C. Y. Park, H. Shin, K. Park, S.-M. Moon, and C.-S. Kim. </author> <title> An accurate worst case timing analysis for RISC processors. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 21(7) </volume> <pages> 593-604, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Since Shaw proposed timing schema for analyzing system running time based on high-level languages [23], a number of people have extended it for analysis in the presence of compiler optimizations [5], pipelining <ref> [13] </ref>, cache memory [13, 7], etc. However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis [18, 1]. <p> Since Shaw proposed timing schema for analyzing system running time based on high-level languages [23], a number of people have extended it for analysis in the presence of compiler optimizations [5], pipelining [13], cache memory <ref> [13, 7] </ref>, etc. However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis [18, 1]. <p> We believe that this is the effect of garbage collection, which we have not analyzed specifically. Examples such as sorting are classified as complex examples in previous study <ref> [19, 13] </ref>, where calculated time is as much as 67% higher than measured time, and where only the result for one sorting program on a single input (of size 10 [19] or 20 [13]) is reported in each experiment. <p> Examples such as sorting are classified as complex examples in previous study [19, 13], where calculated time is as much as 67% higher than measured time, and where only the result for one sorting program on a single input (of size 10 [19] or 20 <ref> [13] </ref>) is reported in each experiment. We found that when inputs are extremely small, the measured time is occasionally above the calculated time for some examples. Also, when inputs are large, the measured times for some examples are above the calculated time. <p> Compared to work in systems <ref> [23, 19, 18, 13] </ref>, this work explores program analysis and transformation techniques to overcome the difficulties caused by the inability to obtain loop bounds, recursion depths, or execution paths automatically and precisely. <p> There is also work for measuring primitive parameters of Fortran programs for the purpose of general performance prediction [21], not worst-case analysis. A number of techniques have been studied for obtaining loop bounds or execution paths [18, 1, 6, 9]. Manual annotations <ref> [18, 13] </ref> are inconvenient and error-prone [1]. Automatic analysis of such information has two main problems. First, separating the loop and path information from the rest of the analysis [6] is in general less accurate than an integrated analysis [17]. <p> We also believe that the lower-bound analysis is entirely symmetric to the upper-bound analysis, by replacing maximum with minimum at all conditional points. Finally, we plan to accommodate more lower-level dynamic factors for timing at the source-language level <ref> [13, 7] </ref>. In particular, we plan to apply our general approach to analyze space consumption and hence to help predict garbage-collection and caching behavior.
Reference: 14. <author> Y. A. Liu and G. Gomezes. </author> <title> Automatic accurate time-bound analysis for high-level languages. </title> <type> Technical Report TR 508, </type> <institution> Computer Science Department, Indiana University, Bloomington, Indiana, </institution> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: In each function definition, the former lifts conditions to the outmost scope that the test does not depend on, and the latter simplifies conditionals according to the lifted condition. These transformations are not needed for the examples in this paper. They are discussed further in <ref> [14] </ref>. 6 Implementation and experimentation We have implemented the analysis approach in a prototype system, ALPA (Automatic Language-based Performance Analyzer). The implementation is for a subset of Scheme. The measurements and analyses are performed for source programs compiled with Chez Scheme compiler [3].
Reference: 15. <author> Y. A. Liu, S. D. Stoller, and T. Teitelbaum. </author> <title> Static caching for incremental computation. </title> <journal> ACM Trans. Program. Lang. Syst., </journal> <volume> 20(3), </volume> <month> May </month> <year> 1998. </year>
Reference-contexts: We have extended it to manipulate primitive parameters. We also handle binding constructs, which is simple but necessary for efficient computation. An innovation in our method is to optimize the time-bound function using partial evaluation [2, 10], incremental computation <ref> [16, 15] </ref>, and transformations of conditionals to make the analysis more efficient and more accurate. We are starting to explore a suite of new language-based techniques for timing analysis, in particular, analyses and optimizations for further speeding up the evaluation of the time-bound function.
Reference: 16. <author> Y. A. Liu and T. Teitelbaum. </author> <title> Systematic derivation of incremental programs. </title> <journal> Sci. Comput. Program., </journal> <volume> 24(1) </volume> <pages> 1-39, </pages> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: We have extended it to manipulate primitive parameters. We also handle binding constructs, which is simple but necessary for efficient computation. An innovation in our method is to optimize the time-bound function using partial evaluation [2, 10], incremental computation <ref> [16, 15] </ref>, and transformations of conditionals to make the analysis more efficient and more accurate. We are starting to explore a suite of new language-based techniques for timing analysis, in particular, analyses and optimizations for further speeding up the evaluation of the time-bound function.
Reference: 17. <author> T. Lundqvist and P. Stenstrom. </author> <title> Integrating path and timing analysis using instruction-level simulation techniques. </title> <type> Technical Report No. 98-3, </type> <institution> Department of Computer Engineering, Chalmers University of Technology, Goteborg, Sweden, </institution> <year> 1998. </year>
Reference-contexts: the problem but can not completely solve it, because they apply only to some classes of programs or use approximations that are too crude for the analysis, and because separating the loop and path information from the rest of the analysis is in general less accurate than an integrated analysis <ref> [17] </ref>. This paper describes a general approach for automatic and accurate time-bound analysis. The approach combines methods and techniques studied in theory, languages, and systems. <p> Manual annotations [18, 13] are inconvenient and error-prone [1]. Automatic analysis of such information has two main problems. First, separating the loop and path information from the rest of the analysis [6] is in general less accurate than an integrated analysis <ref> [17] </ref>. Second, approximations for merging paths from loops, or recursions, very often lead to nontermination of the time analysis, not just looser bounds [6, 17]. Some new methods, while powerful, apply only to certain classes of programs [9]. <p> First, separating the loop and path information from the rest of the analysis [6] is in general less accurate than an integrated analysis [17]. Second, approximations for merging paths from loops, or recursions, very often lead to nontermination of the time analysis, not just looser bounds <ref> [6, 17] </ref>. Some new methods, while powerful, apply only to certain classes of programs [9]. In contrast, our method allows recursions, or loops, to be considered naturally in the overall execution-time analysis based on partially known input structures. <p> Some new methods, while powerful, apply only to certain classes of programs [9]. In contrast, our method allows recursions, or loops, to be considered naturally in the overall execution-time analysis based on partially known input structures. The most recent work by Lundqvist and Stenstrom <ref> [17] </ref> is based on essentially the same ideas as ours.
Reference: 18. <author> C. Y. Park. </author> <title> Predicting program execution times by analyzing static and dynamic program paths. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 5 </volume> <pages> 31-62, </pages> <year> 1993. </year>
Reference-contexts: However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis <ref> [18, 1] </ref>. For example, the inaccurate loop bounds cause the calculated worst-case time to be as much as 67% higher than the measured worst-case time in [19], while the manual way of providing such information is potentially an even larger source of error, in addition to its inconvenience [18]. <p> For example, the inaccurate loop bounds cause the calculated worst-case time to be as much as 67% higher than the measured worst-case time in [19], while the manual way of providing such information is potentially an even larger source of error, in addition to its inconvenience <ref> [18] </ref>. Various program analysis methods have been proposed to provide loop bounds or execution paths [1, 6, 9]. <p> Compared to work in systems <ref> [23, 19, 18, 13] </ref>, this work explores program analysis and transformation techniques to overcome the difficulties caused by the inability to obtain loop bounds, recursion depths, or execution paths automatically and precisely. <p> There is also work for measuring primitive parameters of Fortran programs for the purpose of general performance prediction [21], not worst-case analysis. A number of techniques have been studied for obtaining loop bounds or execution paths <ref> [18, 1, 6, 9] </ref>. Manual annotations [18, 13] are inconvenient and error-prone [1]. Automatic analysis of such information has two main problems. First, separating the loop and path information from the rest of the analysis [6] is in general less accurate than an integrated analysis [17]. <p> There is also work for measuring primitive parameters of Fortran programs for the purpose of general performance prediction [21], not worst-case analysis. A number of techniques have been studied for obtaining loop bounds or execution paths [18, 1, 6, 9]. Manual annotations <ref> [18, 13] </ref> are inconvenient and error-prone [1]. Automatic analysis of such information has two main problems. First, separating the loop and path information from the rest of the analysis [6] is in general less accurate than an integrated analysis [17].
Reference: 19. <author> C. Y. Park and A. C. Shaw. </author> <title> Experiments with a program timing tool based on source-level timing schema. </title> <journal> IEEE Computer, </journal> <volume> 24(5) </volume> <pages> 48-57, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [11, 8], programming languages [25, 12, 20, 22], and systems <ref> [23, 19, 21] </ref>. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [23, 19]. <p> It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages <ref> [23, 19] </ref>. Since Shaw proposed timing schema for analyzing system running time based on high-level languages [23], a number of people have extended it for analysis in the presence of compiler optimizations [5], pipelining [13], cache memory [13, 7], etc. <p> This is the inability to provide loop bounds, recursion depths, or execution paths automatically and accurately for the analysis [18, 1]. For example, the inaccurate loop bounds cause the calculated worst-case time to be as much as 67% higher than the measured worst-case time in <ref> [19] </ref>, while the manual way of providing such information is potentially an even larger source of error, in addition to its inconvenience [18]. Various program analysis methods have been proposed to provide loop bounds or execution paths [1, 6, 9]. <p> Even though this language is small, it is sufficiently powerful and convenient to write sophisticated programs. Structured data is essentially records in Pascal and C. We can also see that time analysis in the presence of arrays and pointers is not fundamentally harder <ref> [19] </ref>, because the running times of the program constructs for them can be measured in the same way as times of other constructs. Note that side effects caused by these features often cause other analysis to be difficult [4]. For pure functional languages, higher-order functions and lazy evaluations are important. <p> We believe that this is the effect of garbage collection, which we have not analyzed specifically. Examples such as sorting are classified as complex examples in previous study <ref> [19, 13] </ref>, where calculated time is as much as 67% higher than measured time, and where only the result for one sorting program on a single input (of size 10 [19] or 20 [13]) is reported in each experiment. <p> Examples such as sorting are classified as complex examples in previous study [19, 13], where calculated time is as much as 67% higher than measured time, and where only the result for one sorting program on a single input (of size 10 <ref> [19] </ref> or 20 [13]) is reported in each experiment. We found that when inputs are extremely small, the measured time is occasionally above the calculated time for some examples. Also, when inputs are large, the measured times for some examples are above the calculated time. <p> Compared to work in systems <ref> [23, 19, 18, 13] </ref>, this work explores program analysis and transformation techniques to overcome the difficulties caused by the inability to obtain loop bounds, recursion depths, or execution paths automatically and precisely. <p> To make the analysis even more accurate and efficient, we can automatically generate measurement programs for all maximum subexpressions that do not include transfers of control; this corresponds to the large atomic-blocks method <ref> [19] </ref>. We also believe that the lower-bound analysis is entirely symmetric to the upper-bound analysis, by replacing maximum with minimum at all conditional points. Finally, we plan to accommodate more lower-level dynamic factors for timing at the source-language level [13, 7].
Reference: 20. <author> M. Rosendahl. </author> <title> Automatic complexity analysis. </title> <booktitle> In Proceedings of the 4th International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 144-156. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [11, 8], programming languages <ref> [25, 12, 20, 22] </ref>, and systems [23, 19, 21]. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [23, 19]. <p> In general, due to imperfect knowledge about the input, the timing function is transformed into a time-bound function. In programming-language area, Rosendahl proposed the use of partially known input structures to characterize input data <ref> [20] </ref>. For example, instead of replacing an input list l with its length n, as done in algorithm analysis, or annotating loops with numbers related to n, as done in systems, we simply use as input a list of n unknown elements. <p> 2 ]] end) function call: T e [[f (e 1 ; :::; e n )]] = add (T call ; T e [[e 1 ]] ;:::;T e [[e n ]] ; tf (e 1 ; :::;e n )) This transformation is similar to the local cost assignment [25], step-counting function <ref> [20] </ref>, cost function [22], etc. in other work. Our transformation handles bindings and makes all primitive parameters explicit at the source-language level. For example, each primitive operation p is given a different symbol T p , and each constructor c is given a different symbol T c . <p> Constructing time-bound functions. Characterizing program inputs and capturing them in the timing function are difficult to automate [25, 12, 23]. However, partially known input structures provide a natural means <ref> [20] </ref>. A special value unknown represents unknown values. <p> Our experiments show that we can calculate more accurate time bound and for many more programs than merging paths, and the calculation is still efficient. The idea of using partially known input structures originates from Rosendahl <ref> [20] </ref>. We have extended it to manipulate primitive parameters. We also handle binding constructs, which is simple but necessary for efficient computation.
Reference: 21. <author> R. H. Saavedra and A. J. Smith. </author> <title> Analysis of benchmark characterization and benchmark performance prediction. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 14(4) </volume> <pages> 344-384, </pages> <month> Nov. </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [11, 8], programming languages [25, 12, 20, 22], and systems <ref> [23, 19, 21] </ref>. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [23, 19]. <p> There is also work for measuring primitive parameters of Fortran programs for the purpose of general performance prediction <ref> [21] </ref>, not worst-case analysis. A number of techniques have been studied for obtaining loop bounds or execution paths [18, 1, 6, 9]. Manual annotations [18, 13] are inconvenient and error-prone [1]. Automatic analysis of such information has two main problems.
Reference: 22. <author> D. Sands. </author> <title> Complexity analysis for a lazy higher-order language. </title> <booktitle> In Proceedings of the 3rd European Symposium on Programming, volume 432 of Lecture Notes in Computer Science, </booktitle> <pages> pages 361-376. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [11, 8], programming languages <ref> [25, 12, 20, 22] </ref>, and systems [23, 19, 21]. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [23, 19]. <p> Note that side effects caused by these features often cause other analysis to be difficult [4]. For pure functional languages, higher-order functions and lazy evaluations are important. Time-bound functions that accommodate these features have been studied <ref> [24, 22] </ref>. The symbolic evaluation and optimizations we describe apply to them as well. 3 Constructing time-bound functions Constructing timing functions. We first transform the original program to construct a timing function, which takes the original input and primitive parameters as arguments and returns the running time. <p> function call: T e [[f (e 1 ; :::; e n )]] = add (T call ; T e [[e 1 ]] ;:::;T e [[e n ]] ; tf (e 1 ; :::;e n )) This transformation is similar to the local cost assignment [25], step-counting function [20], cost function <ref> [22] </ref>, etc. in other work. Our transformation handles bindings and makes all primitive parameters explicit at the source-language level. For example, each primitive operation p is given a different symbol T p , and each constructor c is given a different symbol T c . <p> We are implementing that algorithm. We also noticed that static analysis can be exploited to identify sources of nonter-mination. 7 Related work and conclusion Compared to work in algorithm analysis and program complexity analysis <ref> [12, 22] </ref>, this work consistently pushes through symbolic primitive parameters, so it allows us to calculate actual time bounds and validate the results with experimental measurements.
Reference: 23. <author> A. Shaw. </author> <title> Reasoning about time in higher level language software. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 15(7) </volume> <pages> 875-889, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [11, 8], programming languages [25, 12, 20, 22], and systems <ref> [23, 19, 21] </ref>. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [23, 19]. <p> It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages <ref> [23, 19] </ref>. Since Shaw proposed timing schema for analyzing system running time based on high-level languages [23], a number of people have extended it for analysis in the presence of compiler optimizations [5], pipelining [13], cache memory [13, 7], etc. <p> Since Shaw proposed timing schema for analyzing system running time based on high-level languages <ref> [23] </ref>, a number of people have extended it for analysis in the presence of compiler optimizations [5], pipelining [13], cache memory [13, 7], etc. However, there remains an obvious and serious limitation of the timing schema, even in the absence of low-level complications. <p> This is done easily by associating a parameter with each program construct representing its running time and by summing these parameters based on the semantics of the constructs <ref> [25, 23] </ref>. We call parameters that describe the running times of program constructs primitive parameters. Since the goal is to calculate running time without being given particular inputs, the calculation must be based on certain assumptions about inputs. <p> Constructing time-bound functions. Characterizing program inputs and capturing them in the timing function are difficult to automate <ref> [25, 12, 23] </ref>. However, partially known input structures provide a natural means [20]. A special value unknown represents unknown values. <p> Compared to work in systems <ref> [23, 19, 18, 13] </ref>, this work explores program analysis and transformation techniques to overcome the difficulties caused by the inability to obtain loop bounds, recursion depths, or execution paths automatically and precisely.
Reference: 24. <author> P. Wadler. </author> <title> Strictness analysis aids time analysis. </title> <booktitle> In Conference Record of the 15th Annual ACM Symposium on Principles of Programming Languages. ACM, </booktitle> <address> New York, </address> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: Note that side effects caused by these features often cause other analysis to be difficult [4]. For pure functional languages, higher-order functions and lazy evaluations are important. Time-bound functions that accommodate these features have been studied <ref> [24, 22] </ref>. The symbolic evaluation and optimizations we describe apply to them as well. 3 Constructing time-bound functions Constructing timing functions. We first transform the original program to construct a timing function, which takes the original input and primitive parameters as arguments and returns the running time.
Reference: 25. <author> B. Wegbreit. </author> <title> Mechanical program analysis. </title> <journal> Commun. ACM, </journal> <volume> 18(9) </volume> <pages> 528-538, </pages> <month> Sept. </month> <year> 1975. </year>
Reference-contexts: 1 Introduction Analysis of program running time is important for real-time systems, interactive environments, compiler optimizations, performance evaluation, and many other computer applications. It has been extensively studied in many fields of computer science: algorithms [11, 8], programming languages <ref> [25, 12, 20, 22] </ref>, and systems [23, 19, 21]. It is particularly important for many applications, such as real-time systems, to be able to predict accurate time bounds automatically and efficiently, and it is particularly desirable to be able to do so for high-level languages [23, 19]. <p> This is done easily by associating a parameter with each program construct representing its running time and by summing these parameters based on the semantics of the constructs <ref> [25, 23] </ref>. We call parameters that describe the running times of program constructs primitive parameters. Since the goal is to calculate running time without being given particular inputs, the calculation must be based on certain assumptions about inputs. <p> T e [[e 2 ]] end) function call: T e [[f (e 1 ; :::; e n )]] = add (T call ; T e [[e 1 ]] ;:::;T e [[e n ]] ; tf (e 1 ; :::;e n )) This transformation is similar to the local cost assignment <ref> [25] </ref>, step-counting function [20], cost function [22], etc. in other work. Our transformation handles bindings and makes all primitive parameters explicit at the source-language level. <p> Constructing time-bound functions. Characterizing program inputs and capturing them in the timing function are difficult to automate <ref> [25, 12, 23] </ref>. However, partially known input structures provide a natural means [20]. A special value unknown represents unknown values.
Reference: 26. <author> D. Weise, R. F. Crew, M. Ernst, and B. Steensgaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <booktitle> In Conference Record of the 21st Annual ACM Symposium on Principles of Programming Languages. ACM, </booktitle> <address> New York, </address> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Functional programming languages, together with features like automatic garbage collection, have become increasingly widely used, yet work for calculating actual running time of functional programs has been lacking. Analyses and transformations developed for functional language can be applied to improve analyses of imperative languages as well <ref> [26] </ref>. Language. We use a first-order, call-by-value functional language that has struc-tured data, primitive arithmetic, Boolean, and comparison operations, conditionals, bindings, and mutually recursive function calls.
References-found: 26

