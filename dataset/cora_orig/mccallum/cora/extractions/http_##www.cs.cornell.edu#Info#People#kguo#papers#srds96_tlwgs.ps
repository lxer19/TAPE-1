URL: http://www.cs.cornell.edu/Info/People/kguo/papers/srds96_tlwgs.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/kguo/home.html
Root-URL: 
Email: ler@inesc.pt  kguo@cs.cornell.edu  amgs@pandora.inesc.pt  rvr@cs.cornell.edu  glade@isis.com  paulov@inesc.pt  ken@cs.cornell.edu  
Title: A Transparent Light-Weight Group Service  
Author: Lu s Rodrigues Katherine Guo Antonio Sargento Robbert van Renesse Brad Glade Paulo Ver ssimo Kenneth Birman 
Abstract: The virtual synchrony model for group communication has proven to be a powerful paradigm for building distributed applications. Implementations of virtual synchrony usually require the use of failure detectors and failure recovery protocols. In applications that require the use of a large number of groups, significant performance gains can be attained if these groups share the resources required to provide virtual synchrony. A service that maps user groups onto instances of a virtually synchronous implementation is called a Light-Weight Group Service. This paper proposes a new design for the Light-Weight Group protocols that enables the usage of this service in a transparent manner. As a test case, the new design was implemented in the Horus system, although the underlying principles can be applied to other architectures as well. The paper also presents performance results from this implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Birman and T. Joseph. </author> <title> Exploiting replication in distributed systems. </title> <editor> In S. Mullender, editor, </editor> <booktitle> Distributed Systems, </booktitle> <pages> pages 319-366. </pages> <publisher> ACM Press Frontier Series, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Virtually synchronous group communication <ref> [1, 2, 13] </ref> has proven to be a powerful paradigm for developing distributed applications. This paradigm allows processes to be organized in groups within which messages are exchanged to achieve a common goal.
Reference: [2] <author> K. Birman and R. van Renesse, </author> <title> editors. Reliable Distributed Computing With the ISIS Toolkit. Number ISBN 0-8186-5342-6. </title> <publisher> IEEE CS Press, </publisher> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Virtually synchronous group communication <ref> [1, 2, 13] </ref> has proven to be a powerful paradigm for developing distributed applications. This paradigm allows processes to be organized in groups within which messages are exchanged to achieve a common goal.
Reference: [3] <author> M. Castro and N. Neves. </author> <title> Group communication support for parallel applications in a cluster of workstations. </title> <type> Technical report, </type> <institution> INESC-IST, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: Such opportunities appear in many applications [6, 11], in particular when object-oriented programming styles are used [9, 15]. For instance, a parallel application programmed using an distributed object memory can create hundreds of groups with similar membership <ref> [3] </ref>. A technique that allows the previous type of optimization consists of mapping several user level groups onto a single virtually synchronous group. Since these groups share common resources, they can be implemented more efficiently than standalone groups and are called Light-Weight Groups (LWGs ).
Reference: [4] <author> D. Dolev, D. Malki, and R. </author> <title> Strong. An asynchronous membership protocol that tolerates partitions. </title> <type> Technical Report Research Report, </type> <institution> The Hebrew University of Jerusalem, </institution> <year> 1993. </year>
Reference-contexts: However, protocols exist that allow the continuation of the message flow during view changes [5]. It is also possible to implement a membership service that addresses explicitly the problem of network partitions <ref> [4, 10] </ref>. Downcalls Name Parameters Join GroupId gid, Pid pid Leave GroupId gid, Pid pid Send GroupId gid, BitArray data HoldOk GroupId gid Upcalls Name Parameters View GroupId gid, PidList view Data GroupId gid, Pid src, BitArray data Hold GroupId gid Table 1.
Reference: [5] <author> R. Friedman and R. van Renesse. </author> <title> Strong and weak virtual synchrony in horus. </title> <booktitle> In 15th Symposium on Reliable Distributed Systems, </booktitle> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: However, protocols exist that allow the continuation of the message flow during view changes <ref> [5] </ref>. It is also possible to implement a membership service that addresses explicitly the problem of network partitions [4, 10].
Reference: [6] <author> B. Glade, K. Birman, R. Cooper, and R. van Renesse. </author> <title> Lightweight process groups in the isis system. </title> <journal> Distributed System Engineering, </journal> (1):29-36, 1993. 
Reference-contexts: Although the impact of these services in the overall system performance is usually small, there are opportunities for optimization when several groups have a large percentage of common members, because these groups can share common services. Such opportunities appear in many applications <ref> [6, 11] </ref>, in particular when object-oriented programming styles are used [9, 15]. For instance, a parallel application programmed using an distributed object memory can create hundreds of groups with similar membership [3]. <p> Here LWGs play a key role in reducing the costs of object groups by amortizing many light-weight membership changes over HWGs . Light-Weight Group Services have been implemented be-fore in different group based communication systems <ref> [6, 11] </ref>. Unfortunately, in the previous work, LWGs did not preserve the exact interface of the underlying virtually synchronous group, imposing restrictions on group usage. <p> As a test case, the new protocols were implemented in the Horus system [14] (as a new protocol layer) but the underlying principles can be applied to other architectures (including the Isis <ref> [6] </ref> and NAVTECH [16] systems). The paper is organized as follows. Related work is surveyed in Section 2. The design of the Light-Weight Group Service is described in Section 3 and the protocols are presented in Section 4. <p> The Isis system has extended this principle, offering a Light-Weight Group Service that supports dynamic associations between user level groups and core Isis groups <ref> [6] </ref>. Still, in order to make appropriate mapping decisions, Isis LWGs require the specification of the target membership of a user group. Neither of these approaches is transparent, in the sense that they do not preserve the original HWG interface. <p> The other approach consists of using some form of selective address mechanism, which allows to multicast a message in a HWG just to a subset of all the members of the HWG . An approach similar to this was used in the Delta-4 [11] and Isis lightweight group mechanisms <ref> [6] </ref>. 4.7 The switch protocol While this paper does not focus on policies or heuristics for deciding when to change a LWG to HWG mapping, the algorithm for switching between HWGs is briefly described.
Reference: [7] <author> G. Gray and D. Cheriton. Leases: </author> <title> An efficient fault-tolerant mechanism for distributed file cache consistency. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 202-210, </pages> <address> Litchfield Park, Arizona, </address> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: Forward-pointers are discarded based on the passage of time. Thus, we assume that when a process gets a mapping from the name service, this information is valid just for some reasonable period of time (in some sense, it works as a lease <ref> [7] </ref>). 700 when hwg.Hold.int (hwg) do 701 forall lwg in hwg.mappedLwg 702 lwg.Hold.int (lwg); 703 endfor 704 od 706 when lwg.HoldOk.req (lwg) do 707 hwg.nHoldOk := hwg.nHoldOk +1; 708 if hwg.nHoldOk = # hwg.mappedLwg then 709 hwg.HoldOk.req (hwg.hwgId); 710 fi 712 713 when hwg.View.int (hwgId, newview) do 714 hwg.currentView := newview;
Reference: [8] <author> K. Guo, W. Vogels, and R. van Renesse. </author> <title> Structured virtual synchrony: Exploring the bounds of virtually synchronous group communication. </title> <booktitle> In Proceedings of the 7th ACM SIGOPS European Workshop, </booktitle> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: This small linear increase is due to the fact that, in any case, all LWGs need to be notified of the group membership change. For readability, a scaled illustration of this relatively flat slop is shown in 2 In Horus, failure detection is performed at the lower layers <ref> [8] </ref>. 5.3.3 Data transfer. To evaluate the impact of LWG on data transfer, we measured one-way latency when one member is multicasting 10-Byte messages in one of the n four-member groups. <p> Experiments show that the network bandwidth is more than enough to handle n=2 IP multicasts per second of small background messages even when n = 200. The bottleneck is the receiver processing speed <ref> [8] </ref>. As n increases, the process is not fast enough to handle all the incoming messages, therefore, it drops them from the input buffer. The resulting requests for retransmis-sions and retransmissions themselves add even more load to the system.
Reference: [9] <author> O. Hagsand, H. Herzog, K. Birman, and R. Cooper. </author> <booktitle> Object-oriented reliable distributed programming. In Proceedings of 2nd International Workshop on Object-Orientation in Operating Systems, </booktitle> <year> 1992. </year>
Reference-contexts: Such opportunities appear in many applications [6, 11], in particular when object-oriented programming styles are used <ref> [9, 15] </ref>. For instance, a parallel application programmed using an distributed object memory can create hundreds of groups with similar membership [3]. A technique that allows the previous type of optimization consists of mapping several user level groups onto a single virtually synchronous group.
Reference: [10] <author> L. Moser, Y. Amir, P. Melliar-Smith, and D. Agarwal. </author> <title> Extended virtual synchrony. </title> <booktitle> In Proceedings of the 14th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 56-65, </pages> <address> Poznan, Poland, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: However, protocols exist that allow the continuation of the message flow during view changes [5]. It is also possible to implement a membership service that addresses explicitly the problem of network partitions <ref> [4, 10] </ref>. Downcalls Name Parameters Join GroupId gid, Pid pid Leave GroupId gid, Pid pid Send GroupId gid, BitArray data HoldOk GroupId gid Upcalls Name Parameters View GroupId gid, PidList view Data GroupId gid, Pid src, BitArray data Hold GroupId gid Table 1.
Reference: [11] <author> D. Powell, </author> <title> editor. Delta-4 A Generic Architecture for Dependable Distributed Computing. ESPRIT Research Reports. </title> <publisher> Springer Verlag, </publisher> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Although the impact of these services in the overall system performance is usually small, there are opportunities for optimization when several groups have a large percentage of common members, because these groups can share common services. Such opportunities appear in many applications <ref> [6, 11] </ref>, in particular when object-oriented programming styles are used [9, 15]. For instance, a parallel application programmed using an distributed object memory can create hundreds of groups with similar membership [3]. <p> Here LWGs play a key role in reducing the costs of object groups by amortizing many light-weight membership changes over HWGs . Light-Weight Group Services have been implemented be-fore in different group based communication systems <ref> [6, 11] </ref>. Unfortunately, in the previous work, LWGs did not preserve the exact interface of the underlying virtually synchronous group, imposing restrictions on group usage. <p> Related work is surveyed in Section 2. The design of the Light-Weight Group Service is described in Section 3 and the protocols are presented in Section 4. An implementation in Horus is presented in Section 5 and Section 6 concludes the paper. 2 Related work To our knowledge, Delta-4 <ref> [11] </ref> was the first system to offer some form of Light-Weight Group Service. The Delta-4 group communication subsystem was structured as a layered architecture, in a fashion similar to that of the ISO stack. <p> The other approach consists of using some form of selective address mechanism, which allows to multicast a message in a HWG just to a subset of all the members of the HWG . An approach similar to this was used in the Delta-4 <ref> [11] </ref> and Isis lightweight group mechanisms [6]. 4.7 The switch protocol While this paper does not focus on policies or heuristics for deciding when to change a LWG to HWG mapping, the algorithm for switching between HWGs is briefly described.
Reference: [12] <author> L. Rodrigues, K. Guo, A. Sargento, R. van Renesse, B. Glade, P. Ver ssimo, and K. Birman. </author> <title> A dynamic light weight group service. </title> <type> Technical report, </type> <institution> INESC/Cornell Univ., </institution> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: In this paper we describe the protocol for switching between groups but not the decision process that leads to the invocation of this protocol (mapping and switching heuristics are discussed in another report <ref> [12] </ref>). 4 Protocols This section describes the protocols that implement the Light-Weight Group Service. These protocols perform sev eral tasks required to offer virtual synchrony: join a group, leave a group, and multicast messages in a group. For self-containment, the switching protocol is also presented. <p> In the first step, a map is established between the LWG and some HWG (l. 401). To minimize accesses to the name service, the joining process proposes a mapping based on its own local HWGs according to the mapping heuristics <ref> [12] </ref>. Then, in a single access to the name service it commits this mapping or, in the case where the LWG is already mapped onto some other HWG, obtains the existing mapping (l. 404). <p> The complete protocols are not presented here due to lack of space but can be found in the full report <ref> [12] </ref>. 5 An implementation in Horus 5.1 Horus overview Horus is a group communication system which offers great flexibility in the properties provided by protocols. It uses virtually synchronous protocols to support dynamic group membership, message ordering, synchronization and failure handling.
Reference: [13] <author> A. Schiper and A. Ricciardi. </author> <title> Virtually-synchronous communication based on a weak failure suspector. </title> <booktitle> In Digest of Papers, The 23th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 534-543, </pages> <address> Toulouse, France, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Virtually synchronous group communication <ref> [1, 2, 13] </ref> has proven to be a powerful paradigm for developing distributed applications. This paradigm allows processes to be organized in groups within which messages are exchanged to achieve a common goal. <p> Informally, virtual synchrony provides group membership information to each process in the form of views and guarantees that all processes that install two consecutive views deliver the same set of messages between these views. More formally, virtually synchronous multicast communication can be defined as follows <ref> [13] </ref>: vs-multicast: Consider a set of processes g, a view V i (g), and a message m multicast to the members of group V i (g). The multicast of message m is called a vs-multicast iff the following property is satisfied.
Reference: [14] <author> R. van Renesse, K. Birman, R. Cooper, B. Glade, and P. Stephenson. </author> <title> Reliable multicast between microkernels. </title> <booktitle> In Proceedings of the USENIX Workshop on Micro-Kernels and Other Architectures, </booktitle> <pages> pages 269-283, </pages> <address> Seattle, Washing-ton, </address> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: As a test case, the new protocols were implemented in the Horus system <ref> [14] </ref> (as a new protocol layer) but the underlying principles can be applied to other architectures (including the Isis [6] and NAVTECH [16] systems). The paper is organized as follows. Related work is surveyed in Section 2.
Reference: [15] <author> R. van Renesse, K. Birman, and S. Maffeis. Horus, </author> <title> a flexible group communication system. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 76-83, </pages> <month> Apr. </month> <year> 1996. </year>
Reference-contexts: Such opportunities appear in many applications [6, 11], in particular when object-oriented programming styles are used <ref> [9, 15] </ref>. For instance, a parallel application programmed using an distributed object memory can create hundreds of groups with similar membership [3]. A technique that allows the previous type of optimization consists of mapping several user level groups onto a single virtually synchronous group.
Reference: [16] <author> P. Ver ssimo and L. Rodrigues. </author> <title> The NavTech large-scale distributed computing platform. </title> <type> Technical report, </type> <note> FCUL/IST. (in preparation). </note>
Reference-contexts: As a test case, the new protocols were implemented in the Horus system [14] (as a new protocol layer) but the underlying principles can be applied to other architectures (including the Isis [6] and NAVTECH <ref> [16] </ref> systems). The paper is organized as follows. Related work is surveyed in Section 2. The design of the Light-Weight Group Service is described in Section 3 and the protocols are presented in Section 4.
References-found: 16

