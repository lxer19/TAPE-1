URL: http://www.cs.utexas.edu/users/moore/publications/bdd.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/moore/classes/cs395t-acl2/index.html
Root-URL: 
Title: for the ATP Community  
Phone: (512) 322-9951  
Author: J Strother Moore 
Note: This work was supported in part at Computational Logic, Inc., by the National Computer Security Center (Contract MDA904-92-C-5167). The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the National Computer Security Center, or the U.S. Government.  
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic Inc.  
Abstract: Technical Report 84 October, 1992 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: If the normal form is T the expression is a tautology; otherwise it is not. When the normal form is not T, a counterexample can be read off any branch concluding with F. This obvious theorem relating tautologies and normalization was proved by Nqthm in 1976 <ref> [1] </ref>. IF-normal forms are not canonical: an expression may have multiple non-identical but equivalent normal forms. For example, (IF A (IF B F T) (IF B T F)) and (IF B (IF A F T) (IF A T F)) are both in IF-normal form and are equivalent. <p> Next it defines five output variables, O <ref> [1] </ref>-O [4] and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR <p> it defines five output variables, O <ref> [1] </ref>-O [4] and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR <p> = (OR (AND (NOT N30) (NOT N4)) (AND (NOT N36) (NOT N33))) N40 = (NOT (OR (AND N39 (NOT N38)) (AND (NOT N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 <p> (NOT (OR (AND N39 (NOT N38)) (AND (NOT N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR <p> (AND N39 (NOT N38)) (AND (NOT N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 <p> N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] <p> (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = <p> N37)) (AND (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] <p> (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] <p> COUT1 = (OR (AND CARRYIN B <ref> [1] </ref>) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) <p> CARRYIN B <ref> [1] </ref>) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of <p> <ref> [1] </ref>) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD
Reference: 2. <author> R. S. Boyer and J S. Moore. </author> <title> Integrating Decision Procedures into Heuristic Theorem Provers: A Case Study with Linear Arithmetic. </title> <booktitle> In Machine Intelligence 11, </booktitle> <publisher> Oxford University Press, </publisher> <year> 1988. </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703.. </address>
Reference-contexts: Even if they are, much work must be done to integrate any decision procedure into our systems and, as illustrated in <ref> [2] </ref> sometimes less efficient procedures can produce better overall performance because it is cheaper to invoke them from the general setting. But, having said all this, it should be added that OBDDs can be very effective at deciding propositional equivalence problems. <p> Next it defines five output variables, O [1]-O [4] and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A <ref> [2] </ref> A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT <p> The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A <ref> [2] </ref> A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 <p> this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A <ref> [2] </ref> A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))) N32 = (NOT (OR (AND N8 (NOT N4)) (AND (NOT N8) N4))) N24 = (OR (AND (NOT N28))) N42 <p> (NOT N38)) (AND (NOT N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A <ref> [2] </ref> B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) <p> (AND (NOT N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A <ref> [2] </ref> B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 <p> (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A <ref> [2] </ref> B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] <p> (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A <ref> [2] </ref> B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <p> (N44) @end @invar (CARRYIN A [1] B [1] A <ref> [2] </ref> B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR <p> @invar (CARRYIN A [1] B [1] A <ref> [2] </ref> B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] <p> A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B <ref> [2] </ref>) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in <p> [1] A [1])) COUT2 = (OR (AND COUT1 B <ref> [2] </ref>) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been <p> [1])) COUT2 = (OR (AND COUT1 B <ref> [2] </ref>) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in
Reference: 3. <author> K.S. Brace and R.L. Rudell and R.E. Bryant. </author> <title> Efficient Implementation of a BDD Package. </title> <booktitle> 27th ACM/IEEE Design Automation Conference, </booktitle> <year> 1990, </year> <pages> pp. 40-45. </pages>
Reference-contexts: More importantly to me, I would like to encourage the generalization of the technique so that general-purpose theorem provers can be improved. In closing this preface I would like to urge readers to read the original Bryant paper, [4], as well as <ref> [3] </ref> in which Brace, Rudell and Bryant present, quite clearly, the if-then-else perspective and the ``coding tricks'' described here. In addition, Bryant has recently written an excellent survey of current OBDD techniques and applications, [5]. 2. <p> Next it defines five output variables, O [1]-O [4] and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A <ref> [3] </ref> A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 <p> The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A <ref> [3] </ref> A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 (NOT N3)) <p> The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A <ref> [3] </ref> A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))) N32 = (NOT <p> The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A <ref> [3] </ref> A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))) N32 = (NOT (OR (AND N8 (NOT N4)) (AND (NOT N8) N4))) N24 = (OR <p> N30) (NOT N4)) (AND (NOT N36) (NOT N33))) N40 = (NOT (OR (AND N39 (NOT N38)) (AND (NOT N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O <ref> [3] </ref> = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 <p> N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O <ref> [3] </ref> = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) <p> N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O <ref> [3] </ref> = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B <p> [2] B [2] A <ref> [3] </ref> B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND <p> <ref> [3] </ref> B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND <p> A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B <ref> [3] </ref>) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) <p> B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B <ref> [3] </ref>) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B <p> (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B <ref> [3] </ref>) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language <p> [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B <ref> [3] </ref>) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic <p> COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B <ref> [3] </ref>) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an
Reference: 4. <author> R.E. Bryant. </author> <title> "Graph-Based Algorithms for Boolean Function Manipulation". </title> <journal> IEEE Transactions on Computers C-35, </journal> <month> 8 (August </month> <year> 1986), </year> <month> 677--691. </month>
Reference-contexts: Preface This paper explains briefly the algorithm published by Bryant in <ref> [4] </ref>. Since 1986, so-called ``OBDD'' algorithms have been remarkably successfull at handling propositional equivalence problems arising in the context of digital hardware design. <p> More importantly to me, I would like to encourage the generalization of the technique so that general-purpose theorem provers can be improved. In closing this preface I would like to urge readers to read the original Bryant paper, <ref> [4] </ref>, as well as [3] in which Brace, Rudell and Bryant present, quite clearly, the if-then-else perspective and the ``coding tricks'' described here. In addition, Bryant has recently written an excellent survey of current OBDD techniques and applications, [5]. 2. <p> The same hash array can be used. ``Memo-izing,'' which is also just another form of caching, was proposed for theorem-proving applications by Donald Michie. The OBDD algorithm as described in <ref> [4] </ref> is canonicalization implemented with ``merge sort,'' ``hash cons'' and ``memo-izing.'' 5. A Few Experiments In 1990 the IFIP WG 10.2/WG 10.5 International Workshop on Applied Formal Methods for Correct VLSI Design was held in Houthalen, Belgium [6]. At the workshop, many OBDD algorithms were compared. <p> Therefore, readers interested in the IFIP benchmarks should contact me (moore@cli.com). Below we reproduce the simplest file, add1.be, simply to illustrate the syntactic form of these benchmarks. The file contains two Boolean expressions, labeled BE1 and BE2. BE1 involves nine input variables, CARRYIN, A [1]-A <ref> [4] </ref> and B [1]-B [4]. It then defines forty-two internal variables as Boolean expressions in terms of the nine inputs and previously defined internal variables. For example, N18 is defined to be (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))). Next it defines five output variables, O [1]-O [4] <p> Therefore, readers interested in the IFIP benchmarks should contact me (moore@cli.com). Below we reproduce the simplest file, add1.be, simply to illustrate the syntactic form of these benchmarks. The file contains two Boolean expressions, labeled BE1 and BE2. BE1 involves nine input variables, CARRYIN, A [1]-A <ref> [4] </ref> and B [1]-B [4]. It then defines forty-two internal variables as Boolean expressions in terms of the nine inputs and previously defined internal variables. For example, N18 is defined to be (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))). Next it defines five output variables, O [1]-O [4] and COUT. <p> <ref> [4] </ref> and B [1]-B [4]. It then defines forty-two internal variables as Boolean expressions in terms of the nine inputs and previously defined internal variables. For example, N18 is defined to be (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))). Next it defines five output variables, O [1]-O [4] and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A [3] A [4] B [1] B [2] B [3] B [4]) @sub <p> Next it defines five output variables, O [1]-O <ref> [4] </ref> and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = <p> [1]-O <ref> [4] </ref> and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 (NOT N3)) (AND (NOT <p> The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A [3] A <ref> [4] </ref> B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))) N32 = (NOT (OR (AND N8 (NOT <p> (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A <ref> [4] </ref> B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A <p> (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A <ref> [4] </ref> B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out <p> (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), <p> [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), an applicative subset of <p> = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), an applicative subset of Common Lisp <p> A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), an applicative subset of Common Lisp being developed at Computational Logic, Inc. <p> [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), an applicative subset of Common Lisp being developed at Computational Logic, Inc. <p> @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), an applicative subset of Common Lisp being developed at Computational Logic, Inc. <p> [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), an applicative subset of Common Lisp being developed at Computational Logic, Inc.
Reference: 5. <author> R.E. Bryant. </author> <title> Symbolic Boolean Manipulation with Ordered Binary Decision Diagrams. </title> <type> Tech. </type> <institution> Rept. CMU-CS-92-160, School of Computer Science, Carnegie Mellon University, </institution> <month> July, </month> <year> 1992. </year>
Reference-contexts: In addition, Bryant has recently written an excellent survey of current OBDD techniques and applications, <ref> [5] </ref>. 2. Logical Basis I base my description on the Nqthm (i.e., Boyer-Moore) logic because it is familiar to me. For readers unfamiliar to it, I offer the following remarks. Consider propositional calculus with function symbols and equality.
Reference: 6. <author> L.J.M. Claesen (Ed.) </author> <title> Formal VLSI Correctness Verification, VLSI Design Methods - II. </title> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: The OBDD algorithm as described in [4] is canonicalization implemented with ``merge sort,'' ``hash cons'' and ``memo-izing.'' 5. A Few Experiments In 1990 the IFIP WG 10.2/WG 10.5 International Workshop on Applied Formal Methods for Correct VLSI Design was held in Houthalen, Belgium <ref> [6] </ref>. At the workshop, many OBDD algorithms were compared. To facilitate this comparison, the participants agreed in advance on a set of benchmark problems. A set of files was prepared. Each file essentially presents two propositionally equivalent expressions of some combinational logic circuit in an easy to parse lisp-like notation. <p> The column labeled ``norm'' shows the times for each benchmark file done by our IF normalization procedure. When the column contains *** it means the procedure was aborted before it completed. The next four columns are taken from the indicated pages of <ref> [6] </ref>. However, the experiments reported in [6] were conducted on a Sun Microsystems 3/60 and while our tests were conducted on a Sparc2. In our experience, the Sparc2 is roughly 4 times faster than the 3/60. Therefore, the times taken from [6] were quartered for Figure 2 so they would be <p> The column labeled ``norm'' shows the times for each benchmark file done by our IF normalization procedure. When the column contains *** it means the procedure was aborted before it completed. The next four columns are taken from the indicated pages of <ref> [6] </ref>. However, the experiments reported in [6] were conducted on a Sun Microsystems 3/60 and while our tests were conducted on a Sparc2. In our experience, the Sparc2 is roughly 4 times faster than the 3/60. Therefore, the times taken from [6] were quartered for Figure 2 so they would be roughly comparable to our experiments. <p> four columns are taken from the indicated pages of <ref> [6] </ref>. However, the experiments reported in [6] were conducted on a Sun Microsystems 3/60 and while our tests were conducted on a Sparc2. In our experience, the Sparc2 is roughly 4 times faster than the 3/60. Therefore, the times taken from [6] were quartered for Figure 2 so they would be roughly comparable to our experiments. The right-most column, labeled ``can,'' shows the times for our applicative OBDD algorithm.
Reference: 7. <author> L.P. Deutsch. </author> <title> An Interactive Program Verifier. </title> <type> Tech. </type> <institution> Rept. CSL-73-1, Xerox Palo Alto Research Center, </institution> <month> May, </month> <year> 1973. </year>
Reference-contexts: Furthermore, the check is very common; in the simple example above seven IF expressions are created. We can speed up this identity check which after all is the fundamental operation on canonical forms by the ``hash cons'' idea. Hash consing, introduced for theorem-proving purposes by Peter Deutsch in <ref> [7] </ref>, is the idea of representing each distinct term by a unique concrete object, so that syntactic identity can be checked in constant time by checking for pointer identity. Hashing is used when (the representations of) new terms are ``consed up.'' Our implementation of this idea is as follows.
Reference: 8. <author> D. Michie. </author> <title> Memo functions: a language feature with rote learning properties. </title> <type> Tech. </type> <institution> Rept. MIP-R-29, Department of Artificial Intelligence, University of Edinburgh, </institution> <address> Scotland, </address> <year> 1967. </year>
Reference-contexts: To distribute the IF we form (op tx y) and (op fx y). But if tx and fx share some substructure, say sx, then we may have to canonicalize (op sx y) twice. 7 ``Memo-izing'' a function, introduced in a general setting by Donald Michie in <ref> [8, 9] </ref>, is just the idea of remembering the arguments to and results produced by past applications of the function and looking up the answer (when possible) before recomputing it.
Reference: 9. <author> D. Michie. </author> <title> "`Memo' functions and machine learning". </title> <booktitle> Nature 218 (1968), </booktitle> <pages> 19-22. </pages>
Reference-contexts: To distribute the IF we form (op tx y) and (op fx y). But if tx and fx share some substructure, say sx, then we may have to canonicalize (op sx y) twice. 7 ``Memo-izing'' a function, introduced in a general setting by Donald Michie in <ref> [8, 9] </ref>, is just the idea of remembering the arguments to and results produced by past applications of the function and looking up the answer (when possible) before recomputing it.
Reference: 10. <author> J. Slaney and M. Fujita and M. Stickel. </author> <title> "Automated Reasoning and Exhaustive Search: Quasigroup Existence Problems". </title> <note> Computer Mathematics and Applications (1993?). (to appear). </note>
Reference-contexts: Before proceeding I would like to make it clear that I am not here advocating OBDDs as the end-all of propositional tautology checking. For example, recent improvements of the Davis-Putnam procedure by Stickel <ref> [10] </ref> and by Zhang [11] show promise. In addition, propositional decision procedures are notoriously sensitive to apparently minor restatements of the input problem, so it is unclear that OBDDs will be of use in our more general settings.
Reference: 11. <author> H. Zhang. "Sato: </author> <title> A Decision Procedure for Propositional Logic". Association for Automated Reasoning Newsletter , 22 (March 1993), 1-3. i Table of Contents </title>
Reference-contexts: Before proceeding I would like to make it clear that I am not here advocating OBDDs as the end-all of propositional tautology checking. For example, recent improvements of the Davis-Putnam procedure by Stickel [10] and by Zhang <ref> [11] </ref> show promise. In addition, propositional decision procedures are notoriously sensitive to apparently minor restatements of the input problem, so it is unclear that OBDDs will be of use in our more general settings.
Reference: 1. <institution> Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 </institution>
Reference-contexts: If the normal form is T the expression is a tautology; otherwise it is not. When the normal form is not T, a counterexample can be read off any branch concluding with F. This obvious theorem relating tautologies and normalization was proved by Nqthm in 1976 <ref> [1] </ref>. IF-normal forms are not canonical: an expression may have multiple non-identical but equivalent normal forms. For example, (IF A (IF B F T) (IF B T F)) and (IF B (IF A F T) (IF A T F)) are both in IF-normal form and are equivalent. <p> Next it defines five output variables, O <ref> [1] </ref>-O [4] and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR <p> it defines five output variables, O <ref> [1] </ref>-O [4] and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR <p> = (OR (AND (NOT N30) (NOT N4)) (AND (NOT N36) (NOT N33))) N40 = (NOT (OR (AND N39 (NOT N38)) (AND (NOT N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 <p> (NOT (OR (AND N39 (NOT N38)) (AND (NOT N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR <p> (AND N39 (NOT N38)) (AND (NOT N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 <p> N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] <p> (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = <p> N37)) (AND (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] <p> (NOT N43) (NOT N38))) O <ref> [1] </ref> = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] <p> COUT1 = (OR (AND CARRYIN B <ref> [1] </ref>) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) <p> CARRYIN B <ref> [1] </ref>) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of <p> <ref> [1] </ref>) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD
Reference: 2. <institution> Logical Basis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 </institution>
Reference-contexts: Even if they are, much work must be done to integrate any decision procedure into our systems and, as illustrated in <ref> [2] </ref> sometimes less efficient procedures can produce better overall performance because it is cheaper to invoke them from the general setting. But, having said all this, it should be added that OBDDs can be very effective at deciding propositional equivalence problems. <p> Next it defines five output variables, O [1]-O [4] and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A <ref> [2] </ref> A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT <p> The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A <ref> [2] </ref> A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 <p> this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A <ref> [2] </ref> A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))) N32 = (NOT (OR (AND N8 (NOT N4)) (AND (NOT N8) N4))) N24 = (OR (AND (NOT N28))) N42 <p> (NOT N38)) (AND (NOT N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A <ref> [2] </ref> B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) <p> (AND (NOT N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A <ref> [2] </ref> B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 <p> (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A <ref> [2] </ref> B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] <p> (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A <ref> [2] </ref> B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <p> (N44) @end @invar (CARRYIN A [1] B [1] A <ref> [2] </ref> B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR <p> @invar (CARRYIN A [1] B [1] A <ref> [2] </ref> B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] <p> A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B <ref> [2] </ref>) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in <p> [1] A [1])) COUT2 = (OR (AND COUT1 B <ref> [2] </ref>) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been <p> [1])) COUT2 = (OR (AND COUT1 B <ref> [2] </ref>) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in
Reference: 3. <institution> IF-Normal Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 </institution>
Reference-contexts: More importantly to me, I would like to encourage the generalization of the technique so that general-purpose theorem provers can be improved. In closing this preface I would like to urge readers to read the original Bryant paper, [4], as well as <ref> [3] </ref> in which Brace, Rudell and Bryant present, quite clearly, the if-then-else perspective and the ``coding tricks'' described here. In addition, Bryant has recently written an excellent survey of current OBDD techniques and applications, [5]. 2. <p> Next it defines five output variables, O [1]-O [4] and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A <ref> [3] </ref> A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 <p> The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A <ref> [3] </ref> A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 (NOT N3)) <p> The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A <ref> [3] </ref> A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))) N32 = (NOT <p> The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A <ref> [3] </ref> A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))) N32 = (NOT (OR (AND N8 (NOT N4)) (AND (NOT N8) N4))) N24 = (OR <p> N30) (NOT N4)) (AND (NOT N36) (NOT N33))) N40 = (NOT (OR (AND N39 (NOT N38)) (AND (NOT N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O <ref> [3] </ref> = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 <p> N39) N38))) N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O <ref> [3] </ref> = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) <p> N35 = (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O <ref> [3] </ref> = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B <p> [2] B [2] A <ref> [3] </ref> B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND <p> <ref> [3] </ref> B [3] A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND <p> A [4] B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B <ref> [3] </ref>) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) <p> B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B <ref> [3] </ref>) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B <p> (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B <ref> [3] </ref>) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language <p> [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B <ref> [3] </ref>) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic <p> COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B <ref> [3] </ref>) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O [4] = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an
Reference: 4. <institution> Efficiency Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 </institution>
Reference-contexts: Preface This paper explains briefly the algorithm published by Bryant in <ref> [4] </ref>. Since 1986, so-called ``OBDD'' algorithms have been remarkably successfull at handling propositional equivalence problems arising in the context of digital hardware design. <p> More importantly to me, I would like to encourage the generalization of the technique so that general-purpose theorem provers can be improved. In closing this preface I would like to urge readers to read the original Bryant paper, <ref> [4] </ref>, as well as [3] in which Brace, Rudell and Bryant present, quite clearly, the if-then-else perspective and the ``coding tricks'' described here. In addition, Bryant has recently written an excellent survey of current OBDD techniques and applications, [5]. 2. <p> The same hash array can be used. ``Memo-izing,'' which is also just another form of caching, was proposed for theorem-proving applications by Donald Michie. The OBDD algorithm as described in <ref> [4] </ref> is canonicalization implemented with ``merge sort,'' ``hash cons'' and ``memo-izing.'' 5. A Few Experiments In 1990 the IFIP WG 10.2/WG 10.5 International Workshop on Applied Formal Methods for Correct VLSI Design was held in Houthalen, Belgium [6]. At the workshop, many OBDD algorithms were compared. <p> Therefore, readers interested in the IFIP benchmarks should contact me (moore@cli.com). Below we reproduce the simplest file, add1.be, simply to illustrate the syntactic form of these benchmarks. The file contains two Boolean expressions, labeled BE1 and BE2. BE1 involves nine input variables, CARRYIN, A [1]-A <ref> [4] </ref> and B [1]-B [4]. It then defines forty-two internal variables as Boolean expressions in terms of the nine inputs and previously defined internal variables. For example, N18 is defined to be (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))). Next it defines five output variables, O [1]-O [4] <p> Therefore, readers interested in the IFIP benchmarks should contact me (moore@cli.com). Below we reproduce the simplest file, add1.be, simply to illustrate the syntactic form of these benchmarks. The file contains two Boolean expressions, labeled BE1 and BE2. BE1 involves nine input variables, CARRYIN, A [1]-A <ref> [4] </ref> and B [1]-B [4]. It then defines forty-two internal variables as Boolean expressions in terms of the nine inputs and previously defined internal variables. For example, N18 is defined to be (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))). Next it defines five output variables, O [1]-O [4] and COUT. <p> <ref> [4] </ref> and B [1]-B [4]. It then defines forty-two internal variables as Boolean expressions in terms of the nine inputs and previously defined internal variables. For example, N18 is defined to be (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))). Next it defines five output variables, O [1]-O [4] and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A [3] A [4] B [1] B [2] B [3] B [4]) @sub <p> Next it defines five output variables, O [1]-O <ref> [4] </ref> and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = <p> [1]-O <ref> [4] </ref> and COUT. The definition of BE2 is analogous and has the same inputs and outputs. The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A [3] A [4] B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 (NOT N3)) (AND (NOT <p> The problem implicit in this file is to show that the corresponding outputs are equivalent. @BE1 @invar (CARRYIN A [1] A [2] A [3] A <ref> [4] </ref> B [1] B [2] B [3] B [4]) @sub N4 = (A [3]) N6 = (A [4]) N7 = (not CARRYIN) N8 = (B [3]) N10 = (B [2]) N17 = (OR (AND (NOT N3))) N29 = (OR (AND (NOT N5))) N43 = (OR (AND (NOT N6))) 8 N18 = (NOT (OR (AND N9 (NOT N3)) (AND (NOT N9) N3))) N32 = (NOT (OR (AND N8 (NOT <p> (NOT (OR (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A <ref> [4] </ref> B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A <p> (AND N34 N30) (AND (NOT N34) (NOT N30)))) N44 = (OR (AND (NOT N41) (NOT N37)) (AND (NOT N43) (NOT N38))) O [1] = (N15) O [3] = (N14) COUT = (N44) @end @invar (CARRYIN A [1] B [1] A [2] B [2] A [3] B [3] A <ref> [4] </ref> B [4]) @sub COUT1 = (OR (AND CARRYIN B [1]) (AND CARRYIN A [1]) (AND B [1] A [1])) COUT2 = (OR (AND COUT1 B [2]) (AND COUT1 A [2]) (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out <p> (AND B [2] A [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), <p> [2])) COUT3 = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), an applicative subset of <p> = (OR (AND COUT2 B [3]) (AND COUT2 A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), an applicative subset of Common Lisp <p> A [3]) (AND B [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), an applicative subset of Common Lisp being developed at Computational Logic, Inc. <p> [3] A [3])) @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), an applicative subset of Common Lisp being developed at Computational Logic, Inc. <p> @out O [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), an applicative subset of Common Lisp being developed at Computational Logic, Inc. <p> [1] = (EXOR A [1] B [1] CARRYIN) O [2] = (EXOR A [2] B [2] COUT1) O [3] = (EXOR A [3] B [3] COUT2) O <ref> [4] </ref> = (EXOR A [4] B [4] COUT3) COUT = (OR (AND COUT3 B [4]) (AND COUT3 A [4]) (AND B [4] A [4])) @end The implementation of the OBDD algorithm described in this paper has been coded in the applicative language Acl2 (``A Computational Logic for an Applicative Core Language''), an applicative subset of Common Lisp being developed at Computational Logic, Inc.
Reference: 5. <institution> A Few Experiments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 ii </institution>
Reference-contexts: In addition, Bryant has recently written an excellent survey of current OBDD techniques and applications, <ref> [5] </ref>. 2. Logical Basis I base my description on the Nqthm (i.e., Boyer-Moore) logic because it is familiar to me. For readers unfamiliar to it, I offer the following remarks. Consider propositional calculus with function symbols and equality.
References-found: 16

