URL: file://ftp.cs.wisc.edu/coral/doc/coral.ps
Refering-URL: http://www.cs.wisc.edu/coral/coral.papers.html
Root-URL: 
Title: The CORAL Deductive System  
Author: Raghu Ramakrishnan Divesh Srivastava S. Sudarshan Praveen Seshadri 
Address: Wisconsin, Madison  Murray Hill  Murray Hill  Wisconsin, Madison  
Affiliation: University of  AT&T Bell Laboratories,  AT&T Bell Laboratories,  University of  
Abstract: CORAL is a deductive system which supports a rich declarative language, and an interface to C++ which allows for a combination of declarative and imperative programming. The declarative query language supports general Horn clauses augmented with complex terms, set-grouping, aggregation, negation, and relations with tuples that contain (universally quantified) variables. A CORAL declarative program can be organized as a collection of interacting modules. The CORAL implementation supports a wide range of evaluation strategies, and automatically chooses an efficient evaluation strategy for each module in the program. In addition, users are permitted to guide query optimization, if desired, by selecting from among a wide range of control choices at the level of each module. The CORAL system provides imperative constructs such as update, insert and delete rules. CORAL also has an interface with C++, and users can program in a combination of declarative CORAL and C++ extended with CORAL primitives. A high degree of extensibility is provided by allowing C++ programmers to use the class structure of C++ to enhance the CORAL implementation. CORAL provides support for both main-memory and disk-resident data. Disk-resident data is supported using the EXODUS storage manager, which also provides transaction management in a client-server environment. The paper presents a comprehensive view of the system from broad design goals, the language, and the architecture of the system down to language interfaces and implementation details.
Abstract-found: 1
Intro-found: 1
Reference: [AK91] <author> Hassan Ait-Kaci. </author> <title> Warren's Abstract Machine ATutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: However, these systems provide a fixed control strategy, and fixed data types, unlike CORAL which has a number of different control strategies and an extensible type system. We are currently studying how some of the WAM optimizations (see <ref> [AK91] </ref>, for example) can be extended to support these CORAL features; This would require changes in, for example, internal representations of terms, memory management and code for rule evaluation.
Reference: [AO93] <author> Natraj Arni and Kayliang Ong. </author> <title> The LDL++ User's Guide, </title> <address> 2.0 edition, </address> <month> January </month> <year> 1993. </year> <note> MCC Technical Report Carnot-012-93(P). </note>
Reference-contexts: These include (in alphabetical order) Aditi [VRK + 91], ConceptBase [JS93], EKS-V1 [VBKL90], Glue-NAIL! [MUVG86, PDR91], LDL [NT89, CGK + 90], LDL++ <ref> [AO93] </ref>, LOLA [FSS91], Starburst SQL [MPR90] and XSB [SSW93]. There are many similarities between CORAL and these systems. However, there are several important differences, and CORAL extends the above systems in the following ways: 1. <p> Unlike Glue-NAIL! and LDL, where modules have only a compile-time meaning and no run-time meaning, modules in CORAL have important run-time semantics. Several run-time optimizations are done at the module level. Modules with run-time semantics are also available in several production rule systems (for example, RDL1 [KdMS90]). LDL++ <ref> [AO93] </ref>, a successor to LDL, has moved in the direction taken by CORAL in several respects. It is interpreted, supports abstract data types, and uses a local semantics for choice (Carlo Zaniolo, personal 31 communication). XSB [SSW93] is a system being developed at SUNY, Stony Brook.
Reference: [ARR + 93] <author> Tarun Arora, Raghu Ramakrishnan, William G. Roth, Praveen Seshadri, and Divesh Srivastava. </author> <title> Explaining program evaluation in deductive systems. </title> <booktitle> In Proceedings of the International Conference on Deductive and Object-Oriented Databases, </booktitle> <year> 1993. </year>
Reference-contexts: This allows Mimsy to be customized with complex analysis strategies by individual users, which is a very desirable feature in an environment where many traders use sophisticated proprietary strategies for buying and selling securities. A second application is an explanation and debugging package for CORAL called Explain <ref> [ARR + 93] </ref>, which is itself implemented using CORAL. The implementation of Explain uses the C++ interface of CORAL extensively. However, the implementation of Explain does not utilize CORAL's deductive capabilities.
Reference: [Ban85] <author> Francois Bancilhon. </author> <title> Naive evaluation of recursively defined relations. </title> <editor> In Brodie and Mylopoulos, editors, </editor> <title> On Knowledge Base Management Systems | Integrating Database and AI Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: In order to perform incremental evaluation of rules across multiple iterations, CORAL uses semi-naive evaluation <ref> [Bay85, Ban85, BR87a, RSS94] </ref>.
Reference: [Bay85] <author> R. Bayer. </author> <title> Query evaluation and recursion in deductive database systems. </title> <note> Unpublished Memorandum, </note> <year> 1985. </year>
Reference-contexts: In order to perform incremental evaluation of rules across multiple iterations, CORAL uses semi-naive evaluation <ref> [Bay85, Ban85, BR87a, RSS94] </ref>.
Reference: [BNST91] <author> Catriel Beeri, Shamim Naqvi, Oded Shmueli, and Shalom Tsur. </author> <title> Set constructors in a logic database language. </title> <journal> Journal of Logic Programming, </journal> 10(3&4):181-232, 1991. 
Reference-contexts: Sets and multisets can contain arbitrary values as elements. Since CORAL allows arbitrarily nested structures, the universe of discourse is an extended Herbrand universe which includes sets <ref> [BNST91] </ref>, as in LDL, and multisets, rather than the Herbrand universe which is standard in logic programming.
Reference: [BR87a] <author> I. Balbin and K. Ramamohanarao. </author> <title> A generalization of the differential approach to recursive query evaluation. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(3), </volume> <month> September </month> <year> 1987. </year>
Reference-contexts: In order to perform incremental evaluation of rules across multiple iterations, CORAL uses semi-naive evaluation <ref> [Bay85, Ban85, BR87a, RSS94] </ref>.
Reference: [BR87b] <author> Catriel Beeri and Raghu Ramakrishnan. </author> <title> On the power of Magic. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year> <month> 34 </month>
Reference-contexts: In Ordered Search, sub-queries and answers to sub-queries are generated asynchronously, as in bottom-up evaluation of programs rewritten using Magic rewriting <ref> [BR87b, Ram88] </ref>. However, sub-queries are not made available for use immediately | the order in which generated sub-queries are made available for use is somewhat similar to a top-down evaluation.
Reference: [Bry89] <author> Francois Bry. </author> <title> Logic programming as constructivism: A formalization and its application to databases. </title> <booktitle> In Proceedings of the ACM SIGACT-SIGART-SIGMOD Symposium on Principles of Database Systems, </booktitle> <pages> pages 34-50, </pages> <address> Philadelphia, Pennsylvania, </address> <month> March </month> <year> 1989. </year>
Reference: [CD85] <author> J.H. Chang and A. M. Despain. </author> <title> Semi-intelligent backtracking of Prolog based on static data-dependency analysis. </title> <booktitle> In Proc. Symposium on Logic Programming, </booktitle> <pages> pages 10-21, </pages> <year> 1985. </year>
Reference-contexts: 6.7.1 Intelligent Backtracking Both pipelining and materialization involve indexed nested-loops joins of relations. (For materialization, this is local to the joins in a single rule; for pipelining, it is effectively global, and over the sequence of all rules in the current execution path.) CORAL tries to perform intelligent backtracking (see, <ref> [CD85] </ref>, for example) during rule execution in both cases. Get-first-failure (or, get-first) backtracking provides the ability to "jump back" over several levels of nesting if no matching facts are found for a predicate in an inner level of a nested-loops join.
Reference: [CDRS86] <author> Michael Carey, David DeWitt, Joel Richardson, and Eugene Shekita. </author> <title> Object and file management in the EXODUS extensible database system. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1986. </year>
Reference-contexts: New implementations of relations and indices can also be added easily. Thus the CORAL deductive system is extensible. Extensibility has proven very useful in several CORAL applications. The CORAL system utilizes the EXODUS client-server storage manager <ref> [CDRS86] </ref> to provide support for disk-resident relations; however, it can run in a stand-alone mode, without EXODUS, if all data is in main memory. <p> CORAL is designed primarily as a single-user database system, and can be used in a stand-alone mode; however, data can be shared with other users via the EXODUS storage manager. Persistent data is stored either in text files, or using the EXODUS storage manager <ref> [CDRS86] </ref>, which has a client-server architecture. Each CORAL process can act as an EXODUS client that accesses the common persistent data from the server. Multiple CORAL processes could interact by accessing persistent data stored using the EXODUS storage manager. <p> However we have chosen to discuss them separately since the interface between the query evaluation system and the data manager is particularly important when it involves relations and indices. 22 7.2.1 Relations CORAL currently supports in-memory hash-relations, as well as disk-resident relations (the latter by using the EXODUS storage manager <ref> [CDRS86] </ref>). Multiple indices can be created on relations, and can be added to existing relations. The relation interface is designed to make the addition of new relation implementations (as sub-classes of the generic class Relation) relatively easy.
Reference: [CGK89] <author> D. Chimenti, R. Gamboa, and R. Krishnamurthy. </author> <title> Abstract machine for LDL. </title> <type> Technical Report ACT-ST-268-89, </type> <institution> MCC, Austin, TX, </institution> <year> 1989. </year>
Reference-contexts: Intelligent backtracking for pipelined evaluation is also done on a per-rule basis, although there is the potential for doing it on a global basis. We note that LDL also implements a form of intelligent backtracking <ref> [CGK89] </ref>. 19 Assuming that the edge costs are non-negative. 19 6.7.2 Join Orders CORAL uses a default left-to-right join order, except that for semi-naive rewritten rules the "delta" relation is moved to the beginning of the join order.
Reference: [CGK + 90] <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 76-90, </pages> <year> 1990. </year>
Reference-contexts: The query evaluation system interprets the internal form of the optimized program. We also developed a fully compiled version of CORAL, in which a C++ program was generated from each user program. (This is similar to the approach taken by LDL <ref> [NT89, CGK + 90] </ref>.) We found that this approach took a significantly longer time to compile programs, and the resulting gain in execution speed was minimal 11 . <p> Functor terms are important for representing structured information. For instance, lists (which are a special type of functor term) can be used to represent DNA sequences or stock quote sequences. The current implementation of CORAL uses hash-consing [Got74] to speed up unification of functor terms. (LDL <ref> [CGK + 90] </ref> also implements hash-consing.) Hash-consing assigns unique identifiers to each (ground) functor term, such that two (ground) functor terms unify if and only if their unique identifiers are the same. We note that such identifiers cannot be assigned to functor terms that contain free variables. <p> These include (in alphabetical order) Aditi [VRK + 91], ConceptBase [JS93], EKS-V1 [VBKL90], Glue-NAIL! [MUVG86, PDR91], LDL <ref> [NT89, CGK + 90] </ref>, LDL++ [AO93], LOLA [FSS91], Starburst SQL [MPR90] and XSB [SSW93]. There are many similarities between CORAL and these systems. However, there are several important differences, and CORAL extends the above systems in the following ways: 1.
Reference: [Der93] <author> Marcia A. Derr. </author> <title> Adaptive optimization in a deductive database system. </title> <editor> In Bharat Bhargava, Timothy Finin, and Yelena Yesha, editors, </editor> <booktitle> Proceedings of the Second International Conference on Information and Knowledge Management, </booktitle> <pages> pages 206-215, </pages> <address> Arlington, VA, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: cost-based query optimizer (e.g., for choosing a good join order in each rule) is another major gap in the current system, and again, this can be remedied with some effort. (However, some difficult issues remain little understood; for instance, should the join order be determined afresh on each iteration? Derr <ref> [Der93] </ref> suggests some heuristics.) CORAL supports an interface to C++, and can be embedded in C++. C++ can be used to define new relations as well as manipulate relations computed using declarative CORAL rules.
Reference: [FSS91] <author> B. Freitag, H. Sch-utz, and G. Specht. LOLA: </author> <title> A logic language for deductive databases and its implementation. </title> <booktitle> In Proceedings of 2nd International Symposium on Database Systems for Advanced Applications (DASFAA), </booktitle> <year> 1991. </year>
Reference-contexts: These include (in alphabetical order) Aditi [VRK + 91], ConceptBase [JS93], EKS-V1 [VBKL90], Glue-NAIL! [MUVG86, PDR91], LDL [NT89, CGK + 90], LDL++ [AO93], LOLA <ref> [FSS91] </ref>, Starburst SQL [MPR90] and XSB [SSW93]. There are many similarities between CORAL and these systems. However, there are several important differences, and CORAL extends the above systems in the following ways: 1.
Reference: [Got74] <author> E. Goto. </author> <title> Monocopy and associative algorithms in an extended lisp. </title> <type> Technical Report 74-03, </type> <institution> Information Science Laboratory, Univ. of Tokyo, </institution> <address> Tokyo, Japan, </address> <month> May </month> <year> 1974. </year>
Reference-contexts: Functor terms are important for representing structured information. For instance, lists (which are a special type of functor term) can be used to represent DNA sequences or stock quote sequences. The current implementation of CORAL uses hash-consing <ref> [Got74] </ref> to speed up unification of functor terms. (LDL [CGK + 90] also implements hash-consing.) Hash-consing assigns unique identifiers to each (ground) functor term, such that two (ground) functor terms unify if and only if their unique identifiers are the same.
Reference: [GPSZ91] <author> Fosca Giannotti, Dino Pedreschi, Domenico Sacca, and Carlo Zaniolo. </author> <title> Non-determinism in deductive databases. </title> <editor> In C. Delobel, M. Kifer, and Y. Masunaga, editors, </editor> <booktitle> Proceedings of the Second International Conference on Deductive and Object-Oriented Databases DOOD'91, </booktitle> <address> Munich, Germany, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Unlike in LDL, the choice made is final | CORAL does not backtrack and try different ways to make the choice. We believe this semantics can be implemented more efficiently in a bottom-up evaluation than the LDL semantics. Giannotti et al. <ref> [GPSZ91] </ref> have investigated the connections between this "local" version of choice and stable models, and Greco et al. [GZG92] have shown that it is useful in a variety of "greedy" algorithms. 6.6.5 Controlling the Order of Deductions The use of facts computed during bottom-up evaluation can be prioritized. 18 Consider the
Reference: [GRS93] <author> Nat Goodman, Steve Rozen, and Lincoln Stein. </author> <title> Requirements for a deductive query language in MapBase genome-mapping database. </title> <editor> In Raghu Ramakrishnan, editor, </editor> <booktitle> Proceedings of the Workshop on Programming with Logic Databases, </booktitle> <year> 1993. </year>
Reference-contexts: rich class of natural queries over graphs (e.g., flight queries, and class library dependency queries) is supported, and queries are evaluated by translation into CORAL queries. 29 Genome Sequence Analysis : A group at MIT's Genome Lab is considering the use of CORAL for maintain-ing and querying genome sequence data <ref> [GRS93] </ref>. They report that deductive databases are well-suited for their application since many of their queries are naturally recursive. They have used CORAL for posing some queries on their data, and mention that CORAL's features and performance in terms of speed are very good for their application.
Reference: [GZG92] <author> Sergio Greco, Carlo Zaniolo, and Sumit Ganguly. </author> <title> Greedy by choice. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <year> 1992. </year>
Reference-contexts: We believe this semantics can be implemented more efficiently in a bottom-up evaluation than the LDL semantics. Giannotti et al. [GPSZ91] have investigated the connections between this "local" version of choice and stable models, and Greco et al. <ref> [GZG92] </ref> have shown that it is useful in a variety of "greedy" algorithms. 6.6.5 Controlling the Order of Deductions The use of facts computed during bottom-up evaluation can be prioritized. 18 Consider the shortest path program from Figure 5, which uses the predicate path (Source; Destination; P ath list; Cost).
Reference: [HRB90] <author> S. Horowitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Also at the University of Wisconsin, Madison, Tom Reps has used CORAL to implement algorithms for interprocedural slicing, a technique for identifying program statements that can affect the value of a variable at a particular program point. An algorithm for slicing was reported in <ref> [HRB90] </ref>, and implemented in about 5000 lines of C in eight months.
Reference: [JS93] <author> M. Jeusfeld and M. Staudt. </author> <title> Query optimization in deductive object bases. </title> <editor> In J.C. Freytag, G. Vossen, and D. Maier, editors, </editor> <title> Query Processing for Advanced Database Applications. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: These include (in alphabetical order) Aditi [VRK + 91], ConceptBase <ref> [JS93] </ref>, EKS-V1 [VBKL90], Glue-NAIL! [MUVG86, PDR91], LDL [NT89, CGK + 90], LDL++ [AO93], LOLA [FSS91], Starburst SQL [MPR90] and XSB [SSW93]. There are many similarities between CORAL and these systems. However, there are several important differences, and CORAL extends the above systems in the following ways: 1.
Reference: [KdMS90] <author> G. Kiernan, C. de Maindreville, and E. Simon. </author> <title> Making deductive database a practical technology: a step forward. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1990. </year>
Reference-contexts: Unlike Glue-NAIL! and LDL, where modules have only a compile-time meaning and no run-time meaning, modules in CORAL have important run-time semantics. Several run-time optimizations are done at the module level. Modules with run-time semantics are also available in several production rule systems (for example, RDL1 <ref> [KdMS90] </ref>). LDL++ [AO93], a successor to LDL, has moved in the direction taken by CORAL in several respects. It is interpreted, supports abstract data types, and uses a local semantics for choice (Carlo Zaniolo, personal 31 communication). XSB [SSW93] is a system being developed at SUNY, Stony Brook.
Reference: [KKR90] <author> Paris C. Kanellakis, Gabriel M. Kuper, and Peter Z. Revesz. </author> <title> Constraint query languages. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 299-313, </pages> <address> Nashville, Tennessee, </address> <month> April </month> <year> 1990. </year> <month> 35 </month>
Reference-contexts: Such facts are often useful in knowledge representation, natural language processing and could be particularly useful in a database that stores (and possibly manipulates) rules. Non-ground facts may also be useful to specify constraint facts <ref> [Ram88, KKR90] </ref>, although they are not supported currently in CORAL. Since CORAL allows non-ground facts, rules are not required to be range-restricted 7 . <p> In several applications, variables in facts are typically constrained by information from some domain. An important extension to CORAL is to support such constraint facts <ref> [KKR90] </ref>, and we are considering linear arithmetic constraints as one of the constraint domains to incorporate into CORAL. Acknowledgements We would like to acknowledge our debt to Aditi, EKS-V1, LDL, NAIL!, SQL, Starburst, and various implementations of Prolog from which we have borrowed numerous ideas.
Reference: [KRS90] <author> D. Kemp, K. Ramamohanarao, and Z. Somogyi. Right-, </author> <title> left-, and multi-linear rule transformations that maintain context information. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 380-391, </pages> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: Other selection-propagating rewriting techniques supported in CORAL include Magic Templates [Ram88], Supplementary Magic With GoalId Indexing [RS91], and Context Factoring <ref> [NRSU89, KRS90] </ref>. Supplementary Magic is a good choice as a default, although each technique is superior to the rest on some programs.
Reference: [Lef91] <author> Alexandre Lefebvre. </author> <title> Recursive aggregates in the EKS-V1 system. </title> <type> Technical Report TR KB 34, </type> <institution> ECRC, </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: CORAL supports a wide range of evaluation techniques, and gives the user considerable control over the choice of techniques. 3. CORAL supports a larger class of programs, including programs with non-ground facts and non-stratified set-generation. EKS-V1 supports integrity constraint checking, hypothetical reasoning and provides some support for non-stratified aggregation <ref> [Lef91, Lef92] </ref>. ConceptBase supports several object-oriented features, integrity constraint checking, and provides a one-way interface to C/Prolog, i.e., the imperative language can call ConceptBase, but not vice versa. LOLA supports integrity constraints, several join strategies, and some support for type information.
Reference: [Lef92] <author> Alexandre Lefebvre. </author> <title> Towards an efficient evaluation of recursive aggregates in deductive databases. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: CORAL supports a wide range of evaluation techniques, and gives the user considerable control over the choice of techniques. 3. CORAL supports a larger class of programs, including programs with non-ground facts and non-stratified set-generation. EKS-V1 supports integrity constraint checking, hypothetical reasoning and provides some support for non-stratified aggregation <ref> [Lef91, Lef92] </ref>. ConceptBase supports several object-oriented features, integrity constraint checking, and provides a one-way interface to C/Prolog, i.e., the imperative language can call ConceptBase, but not vice versa. LOLA supports integrity constraints, several join strategies, and some support for type information.
Reference: [Lew92] <author> Peter H. Lewis. </author> <title> A fast way to discover patterns in vast amounts of data. </title> <address> The New York Times, </address> <pages> pages 16-17, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: An example of a non-recursive query is: "Find the 4-day average of IBM whenever the price of DEC is up more than 5 per cent." The Mimsy system is inspired by MIM <ref> [Log92, Lew92] </ref>, which is a commercial package for analyzing stock market data. Mimsy has many of the features of MIM, which is a stand-alone package written in C, but Mimsy is not as fast as MIM. Nonetheless, it offers good interactive performance for typical queries.
Reference: [Llo87] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: Formal definitions of these concepts may be found in logic programming texts such as <ref> [Llo87] </ref>. 2.1 Declarative Language: Syntax and Semantics The CORAL syntax is modeled largely after Prolog. Numbers, identifiers beginning with lower-case letters and quoted strings are constants, and identifiers that begin with an upper-case letter are variables. <p> More formally, the semantics of CORAL programs is given by the least fixpoint (see Lloyd <ref> [Llo87] </ref>, for example) of the program, with the EDB as the input to the program. CORAL goes much further towards supporting this simple semantics than logic programming languages like Prolog. For programs with only constants and variables as terms and without negation, set-grouping or aggregation, i.e.
Reference: [Log92] <institution> Logical Information Machines, 8920 Business Park Drive, </institution> <note> Suite 372 Austin Texas 78759. The XMIM Reference Guide, 2.1.1 edition, </note> <month> July </month> <year> 1992. </year> <title> XMIM, Logical Information Machines and MIM are registered trademarks of Logical Information Machines, </title> <publisher> Inc. </publisher>
Reference-contexts: An example of a non-recursive query is: "Find the 4-day average of IBM whenever the price of DEC is up more than 5 per cent." The Mimsy system is inspired by MIM <ref> [Log92, Lew92] </ref>, which is a commercial package for analyzing stock market data. Mimsy has many of the features of MIM, which is a stand-alone package written in C, but Mimsy is not as fast as MIM. Nonetheless, it offers good interactive performance for typical queries.
Reference: [MPR90] <author> Inderpal S. Mumick, Hamid Pirahesh, and Raghu Ramakrishnan. </author> <title> Duplicates and aggregates in deductive databases. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: be declared to be a multiset, i.e., with as many copies of a tuple as there are derivations for it. 17 CORAL then guarantees that the number of copies of tuples in the answer to a query on the predicate is correct according to the multiset semantics of the program <ref> [MPR90] </ref>. This semantics is supported by carrying out duplicate checks only on the "magic" predicates if any version of the Magic Templates rewriting is used. 6.6.2 Index Annotations CORAL allows for the specification of two types of hash-based indices: (1) argument form indices, and (2) pattern form indices. <p> These include (in alphabetical order) Aditi [VRK + 91], ConceptBase [JS93], EKS-V1 [VBKL90], Glue-NAIL! [MUVG86, PDR91], LDL [NT89, CGK + 90], LDL++ [AO93], LOLA [FSS91], Starburst SQL <ref> [MPR90] </ref> and XSB [SSW93]. There are many similarities between CORAL and these systems. However, there are several important differences, and CORAL extends the above systems in the following ways: 1.
Reference: [MR89] <author> Michael J. Maher and Raghu Ramakrishnan. </author> <title> Deja vu in fixpoints of logic programs. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <address> Cleveland, Ohio, </address> <year> 1989. </year>
Reference-contexts: CORAL therefore permits the user to specify 16 If facts contain variables, subsumption checking may be used, rather than just duplicate elimination. CORAL performs some subsumption checking but, for efficiency reasons, does not guarantee that relations are maintained as irredundant sets of facts <ref> [MR89] </ref>. 17 On non-recursive queries, this semantics is consistent with SQL when duplicate checks are omitted. 17 module shortest path. export shortest path (bf f f; f f f f ). @aggregate selection path (X; Y; P; C) (X; Y ) min (C). shortest path (X; Y; P; C) : s
Reference: [MUVG86] <author> Katherine Morris, Jeffrey D. Ullman, and Allen Van Gelder. </author> <title> Design overview of the NAIL! system. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming, </booktitle> <year> 1986. </year>
Reference-contexts: These include (in alphabetical order) Aditi [VRK + 91], ConceptBase [JS93], EKS-V1 [VBKL90], Glue-NAIL! <ref> [MUVG86, PDR91] </ref>, LDL [NT89, CGK + 90], LDL++ [AO93], LOLA [FSS91], Starburst SQL [MPR90] and XSB [SSW93]. There are many similarities between CORAL and these systems. However, there are several important differences, and CORAL extends the above systems in the following ways: 1.
Reference: [NRSU89] <author> Jeffrey F. Naughton, Raghu Ramakrishnan, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Argument reduction through factoring. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Databases, </booktitle> <pages> pages 173-182, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: Other selection-propagating rewriting techniques supported in CORAL include Magic Templates [Ram88], Supplementary Magic With GoalId Indexing [RS91], and Context Factoring <ref> [NRSU89, KRS90] </ref>. Supplementary Magic is a good choice as a default, although each technique is superior to the rest on some programs.
Reference: [NT89] <author> Shamim Naqvi and Shalom Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <booktitle> Principles of Computer Science. </booktitle> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: There are two ways in which sets and multisets can be created using rules, namely, set-enumeration (f g) and set-grouping (&lt;&gt;); the syntax is borrowed from LDL <ref> [NT89] </ref>, but there are some differences in semantics which we discuss later. <p> The query evaluation system interprets the internal form of the optimized program. We also developed a fully compiled version of CORAL, in which a C++ program was generated from each user program. (This is similar to the approach taken by LDL <ref> [NT89, CGK + 90] </ref>.) We found that this approach took a significantly longer time to compile programs, and the resulting gain in execution speed was minimal 11 . <p> These include (in alphabetical order) Aditi [VRK + 91], ConceptBase [JS93], EKS-V1 [VBKL90], Glue-NAIL! [MUVG86, PDR91], LDL <ref> [NT89, CGK + 90] </ref>, LDL++ [AO93], LOLA [FSS91], Starburst SQL [MPR90] and XSB [SSW93]. There are many similarities between CORAL and these systems. However, there are several important differences, and CORAL extends the above systems in the following ways: 1.
Reference: [PDR91] <author> Geoffrey Phipps, Marcia A. Derr, and Kenneth A. Ross. </author> <title> Glue-NAIL!: A deductive database system. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 308-317, </pages> <year> 1991. </year>
Reference-contexts: These include (in alphabetical order) Aditi [VRK + 91], ConceptBase [JS93], EKS-V1 [VBKL90], Glue-NAIL! <ref> [MUVG86, PDR91] </ref>, LDL [NT89, CGK + 90], LDL++ [AO93], LOLA [FSS91], Starburst SQL [MPR90] and XSB [SSW93]. There are many similarities between CORAL and these systems. However, there are several important differences, and CORAL extends the above systems in the following ways: 1.
Reference: [Prz88] <author> T.C. Przymusinski. </author> <title> On the declarative semantics of stratified deductive databases. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216, </pages> <year> 1988. </year>
Reference-contexts: Intuitively, a modularly stratified program is one in which the answers and sub-queries generated during program evaluation involve no cycles through negation. This class of programs properly includes the class of programs with locally stratified negation <ref> [Prz88] </ref>. For programs without negation, this semantics coincides with the least fixpoint semantics. The keyword "not" is used as a prefix to indicate a negative body literal. For instance, given a predicate parent, we can test if a is not a parent of b by using "not parent (a; b)".
Reference: [Ram88] <author> Raghu Ramakrishnan. </author> <title> Magic templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Such facts are often useful in knowledge representation, natural language processing and could be particularly useful in a database that stores (and possibly manipulates) rules. Non-ground facts may also be useful to specify constraint facts <ref> [Ram88, KKR90] </ref>, although they are not supported currently in CORAL. Since CORAL allows non-ground facts, rules are not required to be range-restricted 7 . <p> The rewriting can be tailored to propagate bindings across sub-queries in a rule body using different body literal orderings; CORAL uses a left-to-right ordering within the body of a rule by default. Other selection-propagating rewriting techniques supported in CORAL include Magic Templates <ref> [Ram88] </ref>, Supplementary Magic With GoalId Indexing [RS91], and Context Factoring [NRSU89, KRS90]. Supplementary Magic is a good choice as a default, although each technique is superior to the rest on some programs. <p> In Ordered Search, sub-queries and answers to sub-queries are generated asynchronously, as in bottom-up evaluation of programs rewritten using Magic rewriting <ref> [BR87b, Ram88] </ref>. However, sub-queries are not made available for use immediately | the order in which generated sub-queries are made available for use is somewhat similar to a top-down evaluation.
Reference: [Ram93] <author> Raghu Ramakrishnan, </author> <title> editor. </title> <booktitle> Proceedings of the Workshop on Programming with Logic Databases, </booktitle> <address> Vancouver, BC, Canada, </address> <month> October </month> <year> 1993. </year> <note> Available as Technical Report 1183, </note> <institution> Computer Sciences Department, University of Wisconsin-Madison. </institution>
Reference-contexts: The CORAL system has been retrieved by over 200 sites and has been used in research projects as well as in courses at several universities. Some substantial research applications of CORAL, developed by others, were described in the post-ILPS93 Workshop on Programming With Logic Databases <ref> [Ram93] </ref>. These include: Support for visual querying of graph data : The Hy+/GraphLog group at the University of Toronto is using CORAL as a back-end for a system that allows users to pose queries through a visual interface [VW93].
Reference: [RBK88] <author> Raghu Ramakrishnan, Catriel Beeri, and Ravi Krishnamurthy. </author> <title> Optimizing existential Datalog queries. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 89-102, </pages> <address> Austin, Texas, </address> <month> March </month> <year> 1988. </year> <month> 36 </month>
Reference-contexts: The user can choose the rewriting to be applied through annotations. If no selection is specified, it may be appropriate to apply no rewriting, and the user can specify this as well. CORAL also supports Existential Query Rewriting <ref> [RBK88] </ref>, which seeks to propagate projections. This is applied by default in conjunction with a selection-pushing rewriting.
Reference: [RBSS90] <author> Raghu Ramakrishnan, Per Bothner, Divesh Srivastava, and S. Sudarshan. </author> <title> CORAL: A database programming language. </title> <editor> In Jan Chomicki, editor, </editor> <booktitle> Proceedings of the NACLP `90 Workshop on Deductive Databases, </booktitle> <month> October </month> <year> 1990. </year> <note> Available as Report TR-CS-90-14, </note> <institution> Department of Computing and Information Sciences, Kansas State University. </institution>
Reference-contexts: paper appeared in the Proceedings of the International Conference on Very Large Databases, 1992 ([RSS92b]), and in the Proceedings of the ACM SIGMOD International Conference on Management of Data, 1993 ([RSSS93b]). 1 The CORAL project was initiated in 88-89 under the name Conlog, and an initial overview was presented in <ref> [RBSS90] </ref>. 1 Applications in which large amounts of data must be analyzed, and the analysis is too complex to be performed using a less expressive language such as SQL, are likely to benefit from the combination of features provided by CORAL. <p> In the next section, we discuss how to further improve the efficiency of this program using additional annotations. 6.6.4 Using Aggregate Selections to Express Choice CORAL's aggregate selection mechanism provides a version of the choice operator of LDL, but with a different semantics <ref> [RBSS90] </ref>. Consider again the shortest path program from Figure 5.
Reference: [RLK86] <author> J. Rohmer, R. Lescoeur, and J. M. Kerisit. </author> <title> The Alexander method | a technique for the processing of recursive axioms in deductive database queries. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 522-528, </pages> <year> 1986. </year>
Reference-contexts: By specifying that all arguments are "free", in contrast, bindings in the query are ignored, except for a final selection. Bindings in certain arguments can be selectively propagated by choosing other query forms. The default rewriting technique is Supplementary Magic Templates ([BR87b, Ram88]; see also <ref> [RLK86, Sek89] </ref>). The rewriting can be tailored to propagate bindings across sub-queries in a rule body using different body literal orderings; CORAL uses a left-to-right ordering within the body of a rule by default.
Reference: [Ros90] <author> Kenneth Ross. </author> <title> Modular Stratification and Magic Sets for DATALOG programs with negation. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 161-171, </pages> <year> 1990. </year>
Reference-contexts: For instance, given a predicate parent, we can test if a is not a parent of b by using "not parent (a; b)". Such a literal can be used in a query, or in the body of a rule. The following example from <ref> [Ros90] </ref> illustrates the use of modularly stratified negation in a program. Suppose we have a complex mechanism constructed out of a number of components that may themselves be constructed from smaller components. Let the component-of relationship be expressed in the relation part. <p> Without such a restriction, it is possible to write programs whose meaning is hard to define, or whose evaluation would be inefficient. 8 The modularly stratified semantics <ref> [Ros90] </ref>, although originally described for negation, can be easily extended to set-generation. General matching or unification of sets (where one or both of the sets can have variables) is not supported in CORAL, unlike in LDL, which supports set-matching.
Reference: [Ros91] <author> Kenneth Ross. </author> <title> Modular acyclicity and tail recursion in logic programs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year>
Reference-contexts: We performed timing measurements for appending ground lists of different sizes; three evaluation techniques were used | pipelining, materialization using Supplementary Magic rewriting, and materialization using a version of Supplementary Magic rewriting with last-call optimization <ref> [Ros91] </ref>. Factoring is not applicable for this program, The timings are shown in Table 2. As the data indicates, append runs in linear time on CORAL with all three evaluation techniques.
Reference: [RRS93] <author> William G. Roth, Raghu Ramakrishnan, and Praveen Seshadri. MIMSY: </author> <title> A system for analyzing time series data in the stock market domain. </title> <editor> In Raghu Ramakrishnan, editor, </editor> <booktitle> Proceedings of the Workshop on Programming with Logic Databases, </booktitle> <year> 1993. </year>
Reference-contexts: In addition, several CORAL applications have been developed at the University of Wisconsin, which we now describe. 11.1 Applications Developed at the University of Wisconsin The CORAL group has developed two substantial applications of CORAL. The first application is the Mimsy package <ref> [RRS93] </ref> for analyzing sequence data in the stock market domain. Mimsy allows users to write queries using a menu-driven pseudo-English language interface (with no knowledge of CORAL). Mimsy queries are implemented by translating them into CORAL queries and passing them over a socket to a server executing CORAL.
Reference: [RS91] <author> Raghu Ramakrishnan and S. Sudarshan. </author> <title> Top-Down vs. Bottom-Up Revisited. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <year> 1991. </year>
Reference-contexts: The rewriting can be tailored to propagate bindings across sub-queries in a rule body using different body literal orderings; CORAL uses a left-to-right ordering within the body of a rule by default. Other selection-propagating rewriting techniques supported in CORAL include Magic Templates [Ram88], Supplementary Magic With GoalId Indexing <ref> [RS91] </ref>, and Context Factoring [NRSU89, KRS90]. Supplementary Magic is a good choice as a default, although each technique is superior to the rest on some programs. <p> For example, suppose a relation employee had two arguments, the first a name and the second a complex term address (Street; City). A pattern-form index can be used to efficiently retrieve employees named "J ohn", who stay in "M adison", without knowing their street <ref> [RS91] </ref>. The following annotation can be used to create a pattern-form index as above: @make index employee (N ame; address (Street; City)) (N ame; City). Pattern-form indices are implemented in CORAL using hash-indices, and are almost as fast as argument-form indices.
Reference: [RSS92a] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Controlling the search in bottom-up evaluation. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <year> 1992. </year>
Reference-contexts: However, the part relation is acyclic, and hence the working status of a component is defined negatively in terms of sub-components, but not negatively in terms of itself. CORAL provides an evaluation mechanism called Ordered Search <ref> [RSS92a] </ref> that evaluates programs with left-to-right modularly stratified negation efficiently. This is described further in Section 6.5.1. 6 The current CORAL implementation by default performs certain optimizations that assume the absence of non-ground facts. These optimizations do not affect this query. <p> Two basic evaluation approaches are supported, namely materialization and pipelining. Materialization stores facts and looks them up to avoid recomputation. Several variants of materialized evaluation are supported: Basic Semi-Naive, Predicate Semi-Naive [RSS94], and Ordered Search <ref> [RSS92a] </ref>. Pipelining uses facts "on-the-fly" and does not store them, at the potential cost of recomputation. This section presents the interface between modules and the run-time data structures used. <p> We have already seen the issue of materialization versus pipelining. 6.5.1 Ordered Search CORAL uses the Ordered Search evaluation mechanism to order the use of generated sub-queries in a program. The reader is referred to <ref> [RSS92a] </ref> for details. However, some of the features of Ordered Search are mentioned here: 1. It maintains information about dependencies between sub-queries, and can be used to evaluate a large class of programs with negation, set-grouping and aggregation. 2. It provides an ordering to the computation by "hiding" sub-queries.
Reference: [RSS92b] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> CORAL: Control, Relations and Logic. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1992. </year>
Reference-contexts: For a summary of the virtual member functions that constitute the abstract data type interface, see <ref> [RSS92b, RSSS93a] </ref>. The user can define predicates (using C++) to manipulate (and possibly display in novel ways) objects belonging to the abstract data types.
Reference: [RSS93] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> The Save Module facility in CORAL. </title> <type> Manuscript, </type> <year> 1993. </year>
Reference-contexts: While the details are omitted here for lack of space, they can be found in <ref> [RSS93] </ref>.
Reference: [RSS94] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Rule ordering in bottom-up fixpoint evaluation of logic programs. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> August </month> <year> 1994. </year> <note> To appear. (A shorter version appeared in VLDB, </note> <year> 1990). </year>
Reference-contexts: The optimizer analyzes the (rewritten) program, and identifies some evaluation and optimization choices that appear appropriate. The default fixpoint evaluation strategy is called Basic Semi-Naive evaluation (BSN), but a variant, called Predicate Semi-Naive evaluation (PSN) <ref> [RSS94] </ref>, which is better for programs with many mutually recursive predicates, is also available. <p> Two basic evaluation approaches are supported, namely materialization and pipelining. Materialization stores facts and looks them up to avoid recomputation. Several variants of materialized evaluation are supported: Basic Semi-Naive, Predicate Semi-Naive <ref> [RSS94] </ref>, and Ordered Search [RSS92a]. Pipelining uses facts "on-the-fly" and does not store them, at the potential cost of recomputation. This section presents the interface between modules and the run-time data structures used. <p> In order to perform incremental evaluation of rules across multiple iterations, CORAL uses semi-naive evaluation <ref> [Bay85, Ban85, BR87a, RSS94] </ref>.
Reference: [RSSS93a] <author> Raghu Ramakrishnan, Praveen Seshadri, Divesh Srivastava, and S. Sudarshan. </author> <title> The CORAL user manual: A tutorial introduction to CORAL. </title> <type> Manuscript, </type> <year> 1993. </year>
Reference-contexts: Annotations control query evaluation and guide query optimization. Since they are expressed at a high level, they give the programmer the power to control optimization and evaluation in a relatively abstract manner. A detailed description of the annotations provided by CORAL may be found in <ref> [RSSS93a] </ref>; we mention some of them when discussing the query evaluation techniques. The CORAL programmer decides (on a per-module basis) whether to use one of two basic evaluation approaches, namely pipelining or materialization, which are discussed in Section 6. <p> The complete interface specification is provided in the user manual <ref> [RSSS93a] </ref>. However, this simple program demonstrates the fact that the C ScanDesc abstraction, along with the Relation, Tuple and Arg abstractions, gives the C++ programmer a convenient way of accessing data stored in CORAL relations. <p> The CORAL primitive types are the only types that can be used in a coral export declaration; user-defined types are not allowed. An alternative mechanism is available to define more complex predicates using C++; details may be found in the CORAL manual <ref> [RSSS93a] </ref>. However, the export mechanism makes it very easy to define simple predicates using C++. 9 Extensibility in CORAL The implementation of the declarative language of CORAL is designed to be extensible. <p> For a summary of the virtual member functions that constitute the abstract data type interface, see <ref> [RSS92b, RSSS93a] </ref>. The user can define predicates (using C++) to manipulate (and possibly display in novel ways) objects belonging to the abstract data types. <p> A query on this database which resulted in all 100 basic parts being accessed ran in 12.36 seconds. 25 This is available as part of the CORAL system. The additional code involved is included and discussed in the CORAL user manual <ref> [RSSS93a] </ref>. 27 Program Dataset Rewriting Timing Left Linear Ancestor Tree1110 Supplementary Magic 0.50s Factoring 0.40s Chain160 Supplementary Magic 0.09s Factoring 0.07s Right Linear Ancestor Tree1000 Supplementary Magic 1.65s Factoring 0.77s Chain160 Supplementary Magic 4.88s Factoring 0.11s Non Linear Ancestor Tree1000 Supplementary Magic 4.00s Factoring 0.74s Chain160 Supplementary Magic 149.25s Factoring 0.14s <p> We briefly describe major CORAL applications that we are aware of. In addition, we have developed and tested a large suite of programs; these are described in the user manual <ref> [RSSS93a] </ref>. The CORAL system has been retrieved by over 200 sites and has been used in research projects as well as in courses at several universities. Some substantial research applications of CORAL, developed by others, were described in the post-ILPS93 Workshop on Programming With Logic Databases [Ram93].
Reference: [RSSS93b] <author> Raghu Ramakrishnan, Divesh Srivastava, S. Sudarshan, and Praveen Seshadri. </author> <title> Implementation of the CORAL deductive database system. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1993. </year>
Reference: [Sek89] <author> H. Seki. </author> <title> On the power of Alexander templates. </title> <booktitle> In Proc. of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 150-159, </pages> <year> 1989. </year>
Reference-contexts: By specifying that all arguments are "free", in contrast, bindings in the query are ignored, except for a final selection. Bindings in certain arguments can be selectively propagated by choosing other query forms. The default rewriting technique is Supplementary Magic Templates ([BR87b, Ram88]; see also <ref> [RLK86, Sek89] </ref>). The rewriting can be tailored to propagate bindings across sub-queries in a rule body using different body literal orderings; CORAL uses a left-to-right ordering within the body of a rule by default.
Reference: [SKGB87] <author> H. Schmidt, W. Kiessling, U. Guntzer, and R. Bayer. </author> <title> Compiling exploratory and goal-directed deduction into sloppy delta iteration. </title> <booktitle> In IEEE International Symposium on Logic Programming, </booktitle> <pages> pages 234-243, </pages> <year> 1987. </year>
Reference-contexts: Evaluation with prioritized use of facts uses a simple extension of semi-naive evaluation, described in <ref> [SKGB87] </ref>. Using facts in a prioritized fashion reduces the cost of evaluation of a single source shortest path problem from a worst case of O (E V ) to O (E log (V )) 19 [SR91].
Reference: [SR91] <author> S. Sudarshan and Raghu Ramakrishnan. </author> <title> Aggregation and relevance in deductive databases. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Databases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: Using facts in a prioritized fashion reduces the cost of evaluation of a single source shortest path problem from a worst case of O (E V ) to O (E log (V )) 19 <ref> [SR91] </ref>. This illustrates the importance of aggregate selections and prioritizing the use of facts in a bottom-up evaluation. [SR91] describes a technique to generate such annotations automatically, but they could also be specified by the user. 6.7 Rule Level Control 6.7.1 Intelligent Backtracking Both pipelining and materialization involve indexed nested-loops joins <p> in a prioritized fashion reduces the cost of evaluation of a single source shortest path problem from a worst case of O (E V ) to O (E log (V )) 19 <ref> [SR91] </ref>. This illustrates the importance of aggregate selections and prioritizing the use of facts in a bottom-up evaluation. [SR91] describes a technique to generate such annotations automatically, but they could also be specified by the user. 6.7 Rule Level Control 6.7.1 Intelligent Backtracking Both pipelining and materialization involve indexed nested-loops joins of relations. (For materialization, this is local to the joins in a single rule; for pipelining, it is
Reference: [SR93] <author> S. Sudarshan and Raghu Ramakrishnan. </author> <title> Optimizations of bottom-up evaluation with non-ground terms. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <year> 1993. </year> <month> 37 </month>
Reference-contexts: The top-down backtracking control strategy of Prolog permits optimizations whereby answers to sub-queries need not be renamed; such optimizations are not applicable to evaluation techniques, such as bottom-up evaluation, that perform memoization of facts. Techniques for avoiding renaming and optimizing unification in bottom-up evaluation, presented in <ref> [SR93] </ref>, are implemented in CORAL. 7.1.4 Multisets CORAL allows multiset-terms (and, as a special case, set-terms). Multisets are represented using the same data structures as relations, details of which are presented in Section 7.2. <p> What is interesting is that the rewritten program generated by the version of Supplementary Magic with last-call optimization actually generates non-ground facts, even though the append program itself does not generate non-ground facts on the queries we use. Without the non-ground fact related optimizations <ref> [SR93, Sud92] </ref>, the evaluation of the above rewritten program would have taken quadratic time. With the non-ground fact optimization, not only did the program run in linear time, but it ran faster than the version of the program rewritten using Supplementary Magic rewriting.
Reference: [SRSS93] <author> Divesh Srivastava, Raghu Ramakrishnan, Praveen Seshadri, and S. Sudarshan. </author> <title> Coral++: Adding object-orientation to a logic database language. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <address> Dublin, Ireland, </address> <year> 1993. </year>
Reference-contexts: Typing is a desirable feature, especially if the language is to be used to develop large applications. This is one of the issues addressed by a proposed extension to CORAL <ref> [SRSS93] </ref>. Memory Management : In an effort to make the system as efficient as possible for main-memory operations, copying of data has largely been replaced by pointer sharing, even for primitive data types such as integers. <p> There are many challenges with respect to user interfaces for declarative language systems that could be tackled in the CORAL context. 33 * Object-oriented features such as abstract data types, encapsulation and inheritance provide very rich data modeling capabilities. Incorporating such features into CORAL <ref> [SRSS93] </ref> would be crucial in developing large applications in CORAL.
Reference: [SSW93] <author> Konstantinos Sagonas, Terrance Swift, and David S. Warren. </author> <title> XSB: An overview of its use and implementation. </title> <type> Technical report, </type> <institution> Department of Computer Science, State University of New York at Stony Brook, Stony Brook, </institution> <address> New York, 11794-4400, </address> <month> Oct </month> <year> 1993. </year> <note> Submitted for publication; available by anonymous FTP from cs.sunysb.edu in pub/TechReports/warren. </note>
Reference-contexts: Since CORAL allows non-ground facts, rules are not required to be range-restricted 7 . To the best of our knowledge, CORAL is the only deductive database system, other than XSB <ref> [SSW93] </ref>, to support non-ground facts. 2.4 Negation CORAL supports a class of programs with negation that properly contains the class of non-floundering left-to-right modularly stratified programs ([Bry89, Ros90]). <p> These include (in alphabetical order) Aditi [VRK + 91], ConceptBase [JS93], EKS-V1 [VBKL90], Glue-NAIL! [MUVG86, PDR91], LDL [NT89, CGK + 90], LDL++ [AO93], LOLA [FSS91], Starburst SQL [MPR90] and XSB <ref> [SSW93] </ref>. There are many similarities between CORAL and these systems. However, there are several important differences, and CORAL extends the above systems in the following ways: 1. CORAL is extensible | new data and relation types and index implementations can be added without modifying the rest of the system. 2. <p> LDL++ [AO93], a successor to LDL, has moved in the direction taken by CORAL in several respects. It is interpreted, supports abstract data types, and uses a local semantics for choice (Carlo Zaniolo, personal 31 communication). XSB <ref> [SSW93] </ref> is a system being developed at SUNY, Stony Brook. It supports several features similar to CORAL, such as non-ground terms and modularly stratified negation. Program evaluation in XSB uses OLDTNF resolution, and has been implemented by modifying the WAM; this implementation performs basic operations such as unification very efficiently.
Reference: [Str91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language (2nd Edition). </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: Hence, an important goal of the CORAL effort was to integrate the deductive system with a general purpose programming language, with minimal impedance mismatch. Since CORAL is implemented in C++ <ref> [Str91] </ref>, this is the language with which CORAL has been interfaced.
Reference: [STZ92] <author> Oded Shmueli, Shalom Tsur, and Carlo Zaniolo. </author> <title> Compilation of set terms in the logic data language (LDL). </title> <journal> Journal of Logic Programming, </journal> 12(1&2):89-120, 1992. 
Reference-contexts: The evaluation mechanism for set-matching in LDL generates a number of rules at compile time that is exponential in the size of the largest set-term in the program text <ref> [STZ92] </ref>. The use of set-matching is limited in CORAL to avoid this problem. A set-term is restricted to be ground (as in LDL) and to match either another (identical) ground set-term or a variable. <p> An ok team tuple additionally must contain an engineer, a pilot and a doctor. Note that a team containing a single member who is an engineer, a pilot and a doctor would qualify as an ok team. This program is a translation into CORAL of an LDL program from <ref> [STZ92] </ref>; the semantics of the original LDL program required that a team contain at most three members.
Reference: [Sud92] <author> S. Sudarshan. </author> <title> Optimizing Bottom-Up Query Evaluation for Deductive Databases. </title> <type> PhD thesis, </type> <institution> University of Wisconsin, Madison, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: What is interesting is that the rewritten program generated by the version of Supplementary Magic with last-call optimization actually generates non-ground facts, even though the append program itself does not generate non-ground facts on the queries we use. Without the non-ground fact related optimizations <ref> [SR93, Sud92] </ref>, the evaluation of the above rewritten program would have taken quadratic time. With the non-ground fact optimization, not only did the program run in linear time, but it ran faster than the version of the program rewritten using Supplementary Magic rewriting.
Reference: [VBKL90] <author> L. Vieille, P. Bayer, V. Kuchenhoff, and A. Lefebvre. EKS-V1, </author> <title> a short overview. </title> <booktitle> In AAAI-90 Workshop on Knowledge Base Management Systems, </booktitle> <year> 1990. </year>
Reference-contexts: We note that while EKS-V1 <ref> [VBKL90] </ref> does not support set-generation through grouping, it does support set-generation in conjunction with aggregate operations such as count; min and sum. <p> These include (in alphabetical order) Aditi [VRK + 91], ConceptBase [JS93], EKS-V1 <ref> [VBKL90] </ref>, Glue-NAIL! [MUVG86, PDR91], LDL [NT89, CGK + 90], LDL++ [AO93], LOLA [FSS91], Starburst SQL [MPR90] and XSB [SSW93]. There are many similarities between CORAL and these systems. However, there are several important differences, and CORAL extends the above systems in the following ways: 1.
Reference: [VRK + 91] <author> Jayen Vaghani, Kotagiri Ramamohanarao, David B. Kemp, Zoltan Somogyi, and Peter J. Stuckey. </author> <title> Design overview of the Aditi deductive database system. </title> <booktitle> In Proceedings of the Seventh International Conference on Data Engineering, </booktitle> <pages> pages 240-247, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Memory management, join ordering and low-level rule implementation seem to be the main weaknesses, although a more careful evaluation remains to be done. 12 Related Systems A number of other deductive database systems have been developed in the past few years. These include (in alphabetical order) Aditi <ref> [VRK + 91] </ref>, ConceptBase [JS93], EKS-V1 [VBKL90], Glue-NAIL! [MUVG86, PDR91], LDL [NT89, CGK + 90], LDL++ [AO93], LOLA [FSS91], Starburst SQL [MPR90] and XSB [SSW93]. There are many similarities between CORAL and these systems.
Reference: [VW93] <author> Dimitra Vista and Peter Wood. </author> <title> Efficient visual queries for deductive databases. </title> <editor> In Raghu Ramakr-ishnan, editor, </editor> <booktitle> Proceedings of the Workshop on Programming with Logic Databases, </booktitle> <year> 1993. </year> <month> 38 </month>
Reference-contexts: These include: Support for visual querying of graph data : The Hy+/GraphLog group at the University of Toronto is using CORAL as a back-end for a system that allows users to pose queries through a visual interface <ref> [VW93] </ref>.
References-found: 63

