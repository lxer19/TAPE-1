URL: ftp://ftp.cs.rutgers.edu/pub/allender/pl3.ps.Z
Refering-URL: http://www.cs.rutgers.edu/~allender/publications/
Root-URL: http://www.cs.rutgers.edu
Email: allender@cs.rutgers.edu  ogihara@cs.rochester.edu  
Title: Relationships Among PL, #L, and the Determinant  #L, and the determinant, using various notions of reducibility.  
Author: Eric Allender Mitsunori Ogihara 
Note: PL,  
Address: Campus, P.O. Box 1179 Piscataway, NJ 08855-1179, USA  Rochester, NY 14627  
Affiliation: Department of Computer Science Hill Center, Busch  Department of Computer Science University of Rochester  
Abstract: Recent results by Toda, Vinay, Damm, and Valiant have shown that the complexity of the determinant is characterized by the complexity of counting the number of accepting computations of a nondeterministic logspace-bounded machine. (This class of functions is known as #L.) By using that characterization and by establishing a few elementary closure properties, we give a very simple proof of a theorem of Jung, showing that probabilistic logspace-bounded (PL) machines lose none of their computational power if they are restricted to run in polynomial time. We also present new results comparing and contrasting the classes of functions reducible to 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Allender, </author> <title> Oracles vs Proof techniques that do not relativize, </title> <booktitle> Proc. SIGAL International Symposium on Algorithms, 1990, Lecture Notes in Computer Science 450, </booktitle> <pages> pp. 39-52. </pages>
Reference-contexts: For a discussion of some of the issues involved and a list of references, see <ref> [1] </ref>.
Reference: [2] <author> E. Allender, R. Beals, and M. Ogihara, </author> <title> The complexity of matrix rank and feasible systems of linear equations, </title> <type> manuscript. </type>
Reference-contexts: It is also worth noting that it has recently been shown that this entire hieararchy collapses to L C = L <ref> [2] </ref>. 15 Corollary 23 * #LH = AC 0 (#L) = AC 0 (DET) * PLH = AC 0 (PL) (Part 2 of this corollary was previously observed by Carsten Damm and Peter Rossmanith [24, 38].) The reader should not be alarmed by the fact that L PL is contained in
Reference: [3] <author> E. Allender and J. Jiao, </author> <title> Depth reduction for noncommutative arithmetic circuits, </title> <booktitle> Proc. 25th STOC, </booktitle> <year> 1993. </year>
Reference-contexts: Related results regarding arithmetic circuits and certain subclasses of TC 1 may be found in <ref> [3] </ref>. * Can any relationship be established between PL or #L and AC 1 (or logCFL)? * Can any any relationship be established between PL (or C = L) and bounded-error probabilistic logspace? Note in this regard that David Zuckerman and Mauricio Karchmer have recently shown that no "black-box" simulation of
Reference: [4] <author> C. Alvarez, J. Balcazar, and B. Jenner, </author> <title> Adaptive logspace reducibility and parallel time, </title> <note> Mathematical Systems Theory 28 (1995) 117-140. </note>
Reference-contexts: The class FNL of functions computable via NC 1 circuits with oracles for NL was defined and studied in <ref> [4] </ref>, where it was noted that FNL admits many alternative characterizations, including the following: * f is in FNL iff f is computed by a logspace-bounded oracle Turing machine with an oracle for NL. * f is in FNL iff jf (x)j = jxj O (1) and the language f (x; <p> Logspace-uniformity is sufficient, although the theorems also hold if more restrictive uniformity conditions are used; see [12, 10] for discussions of uniformity issues involved in low-level circuit complexity. It will turn out to be useful to consider certain refinements of AC 0 reducibility. Following <ref> [4] </ref> (see also [6]), define AC 0 i (f ) to be the class of languages accepted by AC 0 circuits with oracle gates for f , where no path from input to output goes through more than i oracle gates. <p> PL can yield a bounded-error probabilistic logspace algorithm for PL [54]. * Can anything more be said about the relationship between PLH and NC 1 (PL) (or #LH and NC 1 (#L))? Note that for many classes C of interest (including AC k , NC k , NL, L, NP <ref> [4, 34] </ref>), AC 0 (C) is equal to NC 1 (C). Acknowledgments The first author thanks Birgit Jenner for several motivating and informative discussions. Dave Bar-rington, Michelangelo Grigni, Sanjeev Saluja, Heribert Vollmer, and Pierre McKenzie also provided helpful information. We thank Carsten Damm for constructive comments on an earlier draft.
Reference: [5] <author> C. Alvarez and B. Jenner, </author> <title> A very hard log-space counting class, </title> <note> Theoretical Computer Science 107 (1993) 3-30. </note>
Reference-contexts: It is perhaps surprising that well over a decade passed before it was discovered that an equally-close connection exists between the complexity of computing the determinant of a matrix and the class #L (defined in <ref> [5] </ref>) of functions that count the number of accepting computation paths of a nondeterministic logspace-bounded machine. <p> [41], but it was not until the appearance of [8] that it was even known that PL is contained in P; [8] shows that PL is contained in NC 2 , and this can be improved slightly to TC 1 (the 1 This definition of "functional many-one reducibility" is from <ref> [5] </ref>. It should be noted that the notion of one function being "many-one reducible" to another is sometimes defined in a much less restrictive way. <p> For example, AC 0 (PL) is equal to the hierarchy PL PL: :PL . 2 Basic Facts about GapL The class #L was defined and studied in <ref> [5] </ref>; #L is the class of functions f such that, for some nondeterministic logspace-bounded machine M , f (x) is the number of accepting computation paths of M on x. As in [5] we restrict our definition to those machines M that halt on all computation paths on all inputs; clearly <p> hierarchy PL PL: :PL . 2 Basic Facts about GapL The class #L was defined and studied in <ref> [5] </ref>; #L is the class of functions f such that, for some nondeterministic logspace-bounded machine M , f (x) is the number of accepting computation paths of M on x. As in [5] we restrict our definition to those machines M that halt on all computation paths on all inputs; clearly the running time is polynomial. (Otherwise, the number of accepting computation paths can be infinite.) Let FL denote the class of functions computed in (deterministic) logspace. It is noted in [5] that <p> in <ref> [5] </ref> we restrict our definition to those machines M that halt on all computation paths on all inputs; clearly the running time is polynomial. (Otherwise, the number of accepting computation paths can be infinite.) Let FL denote the class of functions computed in (deterministic) logspace. It is noted in [5] that FL #L. The following definitions are adapted from [17]. Given a nondeterministic Turing machine M that halts on all computation paths on all inputs, let gap M (x) be [number of accepting paths of M on input x] [number of rejecting paths of M on input x]. <p> A related question is whether PLH is equal to C = LH (equivalently, whether PL is AC 0 -reducible to C = L). We close this section with an observation showing that L #L can be defined using very restricted access to the oracle. (For related observations, see <ref> [5, Proposition 2 and Section 6] </ref>.) Proposition 24 Let C be any of the classes L, NL, PL, or #L.
Reference: [6] <author> J. Balcazar, </author> <title> Adaptive logspace and depth-bounded reducibilities, </title> <booktitle> Proc. 6th IEEE Structure in Complexity Theory Conference, </booktitle> <year> 1991, </year> <pages> pp. 240-254. </pages>
Reference-contexts: Logspace-uniformity is sufficient, although the theorems also hold if more restrictive uniformity conditions are used; see [12, 10] for discussions of uniformity issues involved in low-level circuit complexity. It will turn out to be useful to consider certain refinements of AC 0 reducibility. Following [4] (see also <ref> [6] </ref>), define AC 0 i (f ) to be the class of languages accepted by AC 0 circuits with oracle gates for f , where no path from input to output goes through more than i oracle gates.
Reference: [7] <author> S. Berkowitz, </author> <title> On computing the determinant in small parallel time using a small number of processors, </title> <note> Information Processing Letters 18 (1984) 147-150. </note>
Reference-contexts: logspace such that f (x) (viewed as a number written in binary) is equal to the determinant of matrix g (x).) 1 The proof given in [44] is particularly clear and direct: Toda shows that the determinant (of integer matrices) is reducible to iterated matrix multiplication over the integers (using <ref> [7] </ref>), which in turn is reducible to iterated matrix multiplication over f0; 1; 1g, which in turn is reducible to a canonical GapL-complete problem, which in turn is reducible to the determinant.
Reference: [8] <author> A. Borodin, S. Cook, and N. Pippenger, </author> <title> Parallel computation for well-endowed rings and space-bounded probabilistic machines, </title> <note> Information and Control 48 (1983) 113-136. </note>
Reference-contexts: Gill showed in [19] that PL is contained in PSPACE. This was improved to DSPACE (log 6 n) in [41], but it was not until the appearance of <ref> [8] </ref> that it was even known that PL is contained in P; [8] shows that PL is contained in NC 2 , and this can be improved slightly to TC 1 (the 1 This definition of "functional many-one reducibility" is from [5]. <p> Gill showed in [19] that PL is contained in PSPACE. This was improved to DSPACE (log 6 n) in [41], but it was not until the appearance of <ref> [8] </ref> that it was even known that PL is contained in P; [8] shows that PL is contained in NC 2 , and this can be improved slightly to TC 1 (the 1 This definition of "functional many-one reducibility" is from [5]. <p> The proof presented in [27] is complicated; we present an easy proof in Section 3. Note that Theorem 1, combined with our easy proof of Jung's theorem, give an alternative proof of the result of <ref> [8] </ref> concerning the complexity of PL, as well as a making closure of PL under complement completely obvious. Note that it would be remarkable if a theorem analogous to Jung's theorem could also be proved in the bounded error case. <p> However, DET does not seem to have this property. In Section 6 we present characterizations of the classes reducible to PL and #L under various notions 2 The complete history of the complexity of PL is even more complicated. The interested reader may wish to consult <ref> [8, p. 115] </ref>, [25], [43, p. 111], and [20]. The related notion of probabilistic finite automata has also been studied in depth; for recent results and references, see [31, 32]. 3 of reducibility.
Reference: [9] <author> A. Borodin, S. Cook, P. Dymond, W. Ruzzo, and M. Tompa, </author> <title> Two applications of inductive counting for complementation problems, </title> <note> SIAM Journal on Computing 18 (1989) 559-578. </note>
Reference-contexts: All of these consequences would be surprising. We will not discuss bounded-error probabilistic logspace in the remainder of the paper; for more information on the bounded-error classes, see <ref> [9] </ref>.
Reference: [10] <author> S. Buss, S. Cook, A. Gupta, and V. Ramachandran, </author> <title> An optimal parallel algorithm for formula evaluation, </title> <note> SIAM Journal on Computing 21 (1992) 755-780. </note>
Reference-contexts: If the oracle is a language, then the oracle gate computes the characteristic function of the language. Our results do not depend very much on 13 the particular uniformity condition used. Logspace-uniformity is sufficient, although the theorems also hold if more restrictive uniformity conditions are used; see <ref> [12, 10] </ref> for discussions of uniformity issues involved in low-level circuit complexity. It will turn out to be useful to consider certain refinements of AC 0 reducibility.
Reference: [11] <author> A Ben-Dor and S. Halevi, </author> <title> Zero-one permanent is #P-complete, a simpler proof, </title> <booktitle> Proc. 2nd Israel Symposium on Theory of Computing and Systems (ISTCS93), </booktitle> <publisher> IEEE press. </publisher>
Reference-contexts: It should be noted that the notion of one function being "many-one reducible" to another is sometimes defined in a much less restrictive way. For example, it is shown in <ref> [53, 11] </ref> that the permanent of zero-one matrices is "many-one complete" for #P, using a less restrictive version of "many-one reductions." On the other hand, it follows from [47] that the permanent of integer matrices cannot be complete for #P or GapP using our definition of "many-one reduction" unless P =
Reference: [12] <author> D. Barrington, N. Immerman, and H. Straubing, </author> <note> On uniformity within N C 1 , Journal of Computer and System Sciences 41 (1990) 274-306. </note>
Reference-contexts: If the oracle is a language, then the oracle gate computes the characteristic function of the language. Our results do not depend very much on 13 the particular uniformity condition used. Logspace-uniformity is sufficient, although the theorems also hold if more restrictive uniformity conditions are used; see <ref> [12, 10] </ref> for discussions of uniformity issues involved in low-level circuit complexity. It will turn out to be useful to consider certain refinements of AC 0 reducibility.
Reference: [13] <author> R. Beigel, N. Reingold, and D. Spielman, </author> <note> PP is closed under intersection, Journal of Computer and System Sciences 50 (1995) 191-202. </note>
Reference-contexts: Let h be the GapL function such that h (y) &gt; 0 if y 2 B, and h (y) &lt; 0 otherwise. Let H (x; i) denote h (g (x; i)). 8 The definition of the following sequence of polynomials follows the presentation in Section 2 of <ref> [13] </ref>. <p> + (x; i) S (x; i) = D (x;i) P n c A 0 (x) = n c i=1 n c i=1 Y D (x; l))) n c i=1 S (x; i) is equivalent to the function that is called S (n c ) n k (H (x; i)) in <ref> [13] </ref>; it is proved there that A (x) is positive if all of the H (x; i) are positive, and A (x) is negative otherwise.
Reference: [14] <author> G. Buntrock, C. Damm, U. Hertrampf, and C. Meinel, </author> <title> Structure and Importance of Logspace MOD-Classes, </title> <note> Mathematical Systems Theory 25 (1992) 223-237. 18 </note>
Reference-contexts: For the fourth closure property, observe, as in [17] that if f is the difference of two #L functions h and h 0 , then g (x) = i=0 i h 0 (x) + 1 ! The result now follows from the first three closure properties and from <ref> [14, Lemma 2] </ref>, where it is shown that if a is in #L and b is in FL with b (x) = O (1), then a (x) is in GapL. <p> Closure of C = L under log dtt reductions is also sufficient to show that C = L contains the class LogFew that was defined and studied in <ref> [14] </ref>. (We refer the reader to [14] for the definition of this class.) Theorem 18 LogFew C = L. Proof. <p> Closure of C = L under log dtt reductions is also sufficient to show that C = L contains the class LogFew that was defined and studied in <ref> [14] </ref>. (We refer the reader to [14] for the definition of this class.) Theorem 18 LogFew C = L. Proof.
Reference: [15] <author> S. Cook, </author> <title> A taxonomy of problems with fast parallel algorithms, </title> <note> Information and Control 64 (1985) 2-22. </note>
Reference-contexts: All of these consequences would be surprising. We will not discuss bounded-error probabilistic logspace in the remainder of the paper; for more information on the bounded-error classes, see [9]. Let DET denote the determinant function. (Do not confuse this with the definition of <ref> [15] </ref>, where DET is used to denote the class of functions NC 1 -reducible to the determinant.) Theorem 1 allows one to show that L DET = L #L , as well as AC 0 (DET) = AC 0 (#L) and NC 1 (DET) = NC 1 (#L), etc. <p> On the other hand, it is obvious that nondeterministic logspace can be reduced to the determinant if less restrictive reductions are used (since all that is required is to check if a #L function is non-zero). 12 When Cook <ref> [15] </ref> considered the class of problems reducible to the determinant, he framed his definition using NC 1 reducibility.
Reference: [16] <author> C. Damm, </author> <title> DET = L #L ?, Informatik-Preprint 8, </title> <institution> Fachbereich Informatik der Humboldt-Universitat zu Berlin, </institution> <year> 1991. </year>
Reference-contexts: Work done in part while at University of Electro-Communications, Tokyo. 1 Although stated in different ways, the results of [49, Theorem 6.5], [44, Theorem 2.1], <ref> [16] </ref>, and [48, Theorem 2] show the following fact: Theorem 1 [44, 16, 49, 48] A function f is in GapL iff f is logspace many-one reducible to the determinant. (A function f is logspace many-one reducible to the determinant if there is a function g computable in logspace such that <p> Work done in part while at University of Electro-Communications, Tokyo. 1 Although stated in different ways, the results of [49, Theorem 6.5], [44, Theorem 2.1], [16], and [48, Theorem 2] show the following fact: Theorem 1 <ref> [44, 16, 49, 48] </ref> A function f is in GapL iff f is logspace many-one reducible to the determinant. (A function f is logspace many-one reducible to the determinant if there is a function g computable in logspace such that f (x) (viewed as a number written in binary) is equal
Reference: [17] <author> S. Fenner, L. Fortnow, and S. Kurtz, </author> <title> Gap-definable counting classes, </title> <note> Journal of Computer and System Sciences 48 (1994) 116-148. </note>
Reference-contexts: to state this connection more precisely, let us define GapL to be ff : f (x) = g (x) h (x) for some g and h in #Lg. (This definition is by analogy to the class GapP, consisting of the difference of #P functions, which is defined and studied in <ref> [17, 36, 22] </ref>.) fl A preliminary version of this paper appeared in Proc. 9th IEEE Structure in Complexity Theory Conference, 1994 y Supported in part by NSF grants CCR-9204874 and CCR-9509603. <p> It is noted in [5] that FL #L. The following definitions are adapted from <ref> [17] </ref>. Given a nondeterministic Turing machine M that halts on all computation paths on all inputs, let gap M (x) be [number of accepting paths of M on input x] [number of rejecting paths of M on input x]. <p> Given function classes C and D, let C D be the class of functions ff g : f 2 C and g 2 Dg. The following elementary results relating #L, GapL, and PL (poly) are easy to establish via trivial modifications to the proofs of the analogous results in <ref> [17] </ref> Proposition 2 GapL = #L #L = #L FL = FL #L. Proposition 3 The following are equivalent: 1. <p> Along the way, we will establish some closure properties of PL and of GapL. The following theorem and its proof are logspace-analogues of results concerning GapP that were proved in <ref> [17] </ref>. Theorem 9 Let f be any function in GapL. 1. Let g be a function in FL. Then f (g ()) is in GapL. 2. i=0 f (x; i) is in GapL. 3. i=0 f (x; i) is in GapL. 4. <p> Let g be a function in FL such that g (x) = O (1). Then f (x) is in GapL. Proof. The proofs of the first three closure properties may be taken essentially word-for-word from <ref> [17] </ref>. For the fourth closure property, observe, as in [17] that if f is the difference of two #L functions h and h 0 , then g (x) = i=0 i h 0 (x) + 1 ! The result now follows from the first three closure properties and from [14, Lemma <p> Let g be a function in FL such that g (x) = O (1). Then f (x) is in GapL. Proof. The proofs of the first three closure properties may be taken essentially word-for-word from <ref> [17] </ref>. For the fourth closure property, observe, as in [17] that if f is the difference of two #L functions h and h 0 , then g (x) = i=0 i h 0 (x) + 1 ! The result now follows from the first three closure properties and from [14, Lemma 2], where it is shown that if a is
Reference: [18] <author> L. Fortnow and N. Reingold, </author> <title> PP is closed under truth-table reductions, </title> <booktitle> Proc. 6th IEEE Structure in Complexity Theory Conference, </booktitle> <year> 1991, </year> <pages> pp. 13-15. </pages>
Reference: [19] <author> J. Gill, </author> <title> Computational complexity of probabilistic Turing machines, </title> <note> SIAM Journal on Computing 6 (1977) 675-695. </note>
Reference-contexts: In this paper we use Theorem 1 to give a very simple proof of a theorem of Jung [27], concerning the complexity class PL. PL is defined to be the class of languages A for which there exists a probabilistic Turing machine (in the sense of <ref> [19] </ref>; that is, a Turing machine with access to a source of unbiased random bits), such that on input x the machine never uses more than log jxj space, and x 2 A if and only if the probability that the machine reaches an accepting configuration is greater than one half. <p> Gill showed in <ref> [19] </ref> that PL is contained in PSPACE. <p> Theorem 6 PL = PL (poly). Proof. Let M be a PL machine accepting language A, and let input x be given. As in the proof of Theorem 6.4 of <ref> [19] </ref>, we will construct a Markov chain modeling the behavior of M on x, where state 1 of the chain is the initial configuration, state r is the (unique) accepting configuration, state r 1 is a rejecting, halting configuration, and there is a state of the Markov chain for each configuration <p> Let m be the number of states in B, other than the two absorbing states. Let x i be the probability of ending in the accepting state, starting from state i of B. Observe that x i = B i;m+2 + k As in <ref> [19] </ref>, note that this can be rewritten as (D I)X = C where X is the column vector (x 1 ; : : :; x m ), D is the upper left m fi m submatrix of B, and C is the column vector consisting of the top m elements of
Reference: [20] <author> J. Gill, J. Hunt, and J. Simon, </author> <title> Deterministic simulation of tape-bounded probabilistic Turing machine transducers, </title> <note> Theoretical Computer Science 12 (1980) 333-338. </note>
Reference-contexts: In Section 6 we present characterizations of the classes reducible to PL and #L under various notions 2 The complete history of the complexity of PL is even more complicated. The interested reader may wish to consult [8, p. 115], [25], [43, p. 111], and <ref> [20] </ref>. The related notion of probabilistic finite automata has also been studied in depth; for recent results and references, see [31, 32]. 3 of reducibility.
Reference: [21] <author> F. Green, J. Kobler, K. Regan, T. Schwentick and J. Toran, </author> <title> The power of the middle bit of a #P function, </title> <note> to appear in Journal of Computer and System Sciences. </note>
Reference: [22] <author> S. Gupta, </author> <title> The power of witness reduction, </title> <note> to appear in SIAM Journal on Computing. A preliminary version appeared in Proc. 6th IEEE Structure in Complexity Theory Conference, </note> <year> 1991, </year> <pages> pp. 43-59. </pages>
Reference-contexts: to state this connection more precisely, let us define GapL to be ff : f (x) = g (x) h (x) for some g and h in #Lg. (This definition is by analogy to the class GapP, consisting of the difference of #P functions, which is defined and studied in <ref> [17, 36, 22] </ref>.) fl A preliminary version of this paper appeared in Proc. 9th IEEE Structure in Complexity Theory Conference, 1994 y Supported in part by NSF grants CCR-9204874 and CCR-9509603.
Reference: [23] <author> D. Isaacson and R. Madsen, </author> <title> Markov Chains, Theory and Applications, </title> <publisher> Wiley and Sons, </publisher> <year> 1976. </year>
Reference-contexts: Furthermore, since B is a Markov chain with two absorbing states, D I is invertible (see, e.g., <ref> [23, Lemma III.4.1] </ref>). Let 6 E 1 = 2 (D I), and let E 2 be equal to E 1 , except with column 1 replaced by 2C.
Reference: [24] <author> B. Jenner, </author> <type> personal communication. </type>
Reference-contexts: that it has recently been shown that this entire hieararchy collapses to L C = L [2]. 15 Corollary 23 * #LH = AC 0 (#L) = AC 0 (DET) * PLH = AC 0 (PL) (Part 2 of this corollary was previously observed by Carsten Damm and Peter Rossmanith <ref> [24, 38] </ref>.) The reader should not be alarmed by the fact that L PL is contained in AC 0 (PL) (and in fact the containment may even be proper), even though AC 0 is properly contained in L; we refer the reader to the discussion in [51, 52].
Reference: [25] <author> H. Jung, </author> <title> Relationships between probabilistic and deterministic tape complexity, </title> <booktitle> Proc. 10th MFCS, Lecture Notes in Computer Science 118, </booktitle> <year> 1981, </year> <pages> pp. 339-346. </pages>
Reference-contexts: However, DET does not seem to have this property. In Section 6 we present characterizations of the classes reducible to PL and #L under various notions 2 The complete history of the complexity of PL is even more complicated. The interested reader may wish to consult [8, p. 115], <ref> [25] </ref>, [43, p. 111], and [20]. The related notion of probabilistic finite automata has also been studied in depth; for recent results and references, see [31, 32]. 3 of reducibility.
Reference: [26] <author> H. Jung, </author> <title> On probabilistic tape complexity and fast circuits for matrix inversion problems, </title> <booktitle> Proc. 11th ICALP, Lecture Notes in Computer Science 172, </booktitle> <year> 1984, </year> <pages> pp. 281-291. </pages>
Reference-contexts: It is clear that PL (poly) is closed under complement; the usual proof that PP is closed under complement carries over to this case. Thus Corollary 4 and Theorem 1 show immediately that the following sets are complete for PL (poly) under log m reductions <ref> [26] </ref>: * The set of integer matrices with determinant &gt; 0. * The set of integer matrices with determinant 0. * f (A; m) : DET (A) &gt; mg * f (A; B) : DET (A) &gt; DET (B)g 3 A simple proof of Jung's Theorem In this section we define
Reference: [27] <author> H. Jung, </author> <title> On probabilistic time and space, </title> <booktitle> Proc. 12th ICALP, Lecture Notes in Computer Science 194, </booktitle> <year> 1985, </year> <pages> pp. 310-317. </pages>
Reference-contexts: We remark that the logspace many-one reductions presented in [44], can in fact be computed by uniform AC 0 circuits; we will use this fact later. In this paper we use Theorem 1 to give a very simple proof of a theorem of Jung <ref> [27] </ref>, concerning the complexity class PL. <p> The source of all this difficulty was the fact, already alluded to, that probabilistic logspace machines cannot obviously be restricted to run in polynomial time without loss of computational power. However, Jung showed in <ref> [27] </ref> that, at least in the unbounded error model (which defines the class PL), the polynomial-time restriction causes no loss of power. The proof presented in [27] is complicated; we present an easy proof in Section 3. <p> However, Jung showed in <ref> [27] </ref> that, at least in the unbounded error model (which defines the class PL), the polynomial-time restriction causes no loss of power. The proof presented in [27] is complicated; we present an easy proof in Section 3. Note that Theorem 1, combined with our easy proof of Jung's theorem, give an alternative proof of the result of [8] concerning the complexity of PL, as well as a making closure of PL under complement completely obvious. <p> The result now follows from Theorem 5. The proof given above makes it clear that the result "PL = PL (poly)" relativizes using the appropriate notion of "relativized PL." (This was not so clear from the proof in <ref> [27] </ref>.) We will need this fact in later sections. First, however, we must define what is meant by "relativized PL." The question of what is an appropriate (or even meaningful) way to provide space-bounded machines with an oracle has been the subject of some debate.
Reference: [28] <author> H. Jung, </author> <title> Stochastische Turingmaschinen und die Kompliziertheit arithmetischer Prob-leme, </title> <type> doctoral dissertation, </type> <institution> Humboldt-Universitat, </institution> <address> East Berlin. </address> <month> 19 </month>
Reference: [29] <author> R. Ladner and N. Lynch, </author> <title> Relativization of questions about log space computability, </title> <note> Math--ematical Systems Theory 10 (1976) 19-32. </note>
Reference: [30] <author> R. Ladner, N. Lynch, and A. Selman, </author> <title> A comparison of polynomial-time reducibilities, </title> <note> Theoretical Computer Science 1 (1975) 103-123. </note>
Reference-contexts: Logspace disjunctive truth-table reductions ( log dtt ) are defined similarly, with "all" replaced by "at least one." For more formal definitions, see <ref> [30] </ref>. Corollary 10 PL is closed under log log dtt reductions. (In particular, PL is closed under intersection and union.) Proof. We present the proof for log ctt reductions. The proof of the other claim is analogous.
Reference: [31] <author> I. Macarie, </author> <title> Space-efficient deterministic simulation of probabilistic automata, </title> <booktitle> Proc. 11th STACS, Lecture Notes in Computer Science 775, </booktitle> <year> 1994, </year> <pages> pp. 109-122. </pages>
Reference-contexts: The interested reader may wish to consult [8, p. 115], [25], [43, p. 111], and [20]. The related notion of probabilistic finite automata has also been studied in depth; for recent results and references, see <ref> [31, 32] </ref>. 3 of reducibility.
Reference: [32] <author> I. Macarie, </author> <title> Space-bounded probabilistic computation: old and new stories, SIGACT News Complexity Theory Column 10 (edited by Lane Hemaspaandra), SIGACT News 26, number 3 (September, </title> <booktitle> 1995) pp. </booktitle> <pages> 2-12. </pages>
Reference-contexts: The interested reader may wish to consult [8, p. 115], [25], [43, p. 111], and [20]. The related notion of probabilistic finite automata has also been studied in depth; for recent results and references, see <ref> [31, 32] </ref>. 3 of reducibility.
Reference: [33] <author> N. Nisan, </author> <note> RL SC, Computational Complexity 4 (1994) 1-11. </note>
Reference-contexts: We have already seen that NL can be accepted with bounded (in fact zero) error; thus this would in some sense provide a non-uniform version of L=NL (i.e., L/poly = NL/poly). Furthermore, Nisan <ref> [33] </ref> has shown that bounded-error, polynomial-time logspace can be simulated in polynomial time and space log 2 n; hence extending Jung's theorem to bounded error would provide a small-space polynomial-time algorithm for transitive closure. All of these consequences would be surprising.
Reference: [34] <author> M. Ogihara, </author> <title> NC k (NP) = AC k1 (NP), </title> <booktitle> Proc. 11th STACS, Lecture Notes in Computer Science 775, </booktitle> <year> 1994, </year> <pages> pp. 313-324. </pages>
Reference-contexts: PL can yield a bounded-error probabilistic logspace algorithm for PL [54]. * Can anything more be said about the relationship between PLH and NC 1 (PL) (or #LH and NC 1 (#L))? Note that for many classes C of interest (including AC k , NC k , NL, L, NP <ref> [4, 34] </ref>), AC 0 (C) is equal to NC 1 (C). Acknowledgments The first author thanks Birgit Jenner for several motivating and informative discussions. Dave Bar-rington, Michelangelo Grigni, Sanjeev Saluja, Heribert Vollmer, and Pierre McKenzie also provided helpful information. We thank Carsten Damm for constructive comments on an earlier draft.
Reference: [35] <author> M. Ogihara, </author> <title> The PL Hierarchy collapses, </title> <institution> University of Rochester Computer Science Technical Report 587, </institution> <month> June, </month> <year> 1995. </year>
Reference-contexts: Proof. It should be stated at the outset that it has recently been shown by Ogihara that this entire hierarchy collapses to PL <ref> [35] </ref>. () Any set A 2 PL = PLH 1 can be accepted with a single oracle gate.
Reference: [36] <author> M. Ogiwara and L. Hemachandra, </author> <title> A complexity theory for feasible closure properties, </title> <note> Journal of Computer and System Sciences 46 (1993) 295-325. </note>
Reference-contexts: to state this connection more precisely, let us define GapL to be ff : f (x) = g (x) h (x) for some g and h in #Lg. (This definition is by analogy to the class GapP, consisting of the difference of #P functions, which is defined and studied in <ref> [17, 36, 22] </ref>.) fl A preliminary version of this paper appeared in Proc. 9th IEEE Structure in Complexity Theory Conference, 1994 y Supported in part by NSF grants CCR-9204874 and CCR-9509603.
Reference: [37] <author> K. Regan and T. Schwentick, </author> <title> On the power of one bit of a #P-function, </title> <booktitle> Proc. 4th Italian Conference on Theoretical Computer Science, </booktitle> <publisher> World Scientific Press, </publisher> <address> Singapore, </address> <year> 1992, </year> <pages> pp. 317-329. </pages> <note> See also [21]. </note>
Reference-contexts: By corollary 10, A is in PL. (This proof is essentially identical to the proof of the analogous result for time-bounded classes, as presented in <ref> [37] </ref>.) 9 5 Exact Counting in Logspace In this section, we introduce the class C = L as the logspace-analog of the class C = P.
Reference: [38] <author> P. Rossmanith, </author> <type> personal communication. </type>
Reference-contexts: that it has recently been shown that this entire hieararchy collapses to L C = L [2]. 15 Corollary 23 * #LH = AC 0 (#L) = AC 0 (DET) * PLH = AC 0 (PL) (Part 2 of this corollary was previously observed by Carsten Damm and Peter Rossmanith <ref> [24, 38] </ref>.) The reader should not be alarmed by the fact that L PL is contained in AC 0 (PL) (and in fact the containment may even be proper), even though AC 0 is properly contained in L; we refer the reader to the discussion in [51, 52].
Reference: [39] <author> W. Ruzzo, J. Simon, and M. Tompa, </author> <title> Space-bounded hierarchies and probabilistic computation, </title> <note> Journal of Computer and System Sciences 28 (1984) 216-230. </note>
Reference-contexts: #L is even closer than the relationship that is known to exist between the permanent and #P. 2 class computed by logarithmic-depth threshold circuits). 2 Similarly, PL was not known to be closed under complementation until a complicated proof was given in [42]; a much simpler proof subsequently appeared in <ref> [39] </ref>. The source of all this difficulty was the fact, already alluded to, that probabilistic logspace machines cannot obviously be restricted to run in polynomial time without loss of computational power. <p> For a discussion of some of the issues involved and a list of references, see [1]. It turns out that a simple and useful notion of relativization is the so-called Ruzzo-Simon-Tompa relativization <ref> [39] </ref>; briefly, using this notion of relativization, a set is in PL A if there is a probabilistic logspace machine M with an oracle tape and query states (as is usual in the definition of oracle Turing machines) along with the restriction that the machine act deterministically when it is writing
Reference: [40] <author> S. Saluja, </author> <title> A note on the permanent problem, </title> <note> Information Processing Letters 43 (1992) 1-5. </note>
Reference-contexts: More generally, the set f (A; r) : the determinant of matrix A is rg is complete for C = L, just as the set f (A; r) : the determinant of matrix A is rg is complete for PL. (For analogous results concerning C = P, see <ref> [40] </ref>.) Note that NL is contained in C = L. (This is because NL is closed under complement, and membership in a coNL set is equivalent to having zero accepting computations.) Furthermore, a proof essentially identical to the proof of Theorem 5 shows: Theorem 15 C = L NL = C
Reference: [41] <author> J. Simon, </author> <title> On tape-bounded probabilistic Turing machine acceptors, </title> <note> Theoretical Computer Science 16 (1981) 158-167. </note>
Reference-contexts: Gill showed in [19] that PL is contained in PSPACE. This was improved to DSPACE (log 6 n) in <ref> [41] </ref>, but it was not until the appearance of [8] that it was even known that PL is contained in P; [8] shows that PL is contained in NC 2 , and this can be improved slightly to TC 1 (the 1 This definition of "functional many-one reducibility" is from [5].
Reference: [42] <author> J. Simon, </author> <title> Space-bounded probabilistic Turing machine complexity classes are closed under complement, </title> <booktitle> Proc. 13th STOC, </booktitle> <year> 1981, </year> <pages> pp. 158-167. 20 </pages>
Reference-contexts: That is, the relationship between the determinant and #L is even closer than the relationship that is known to exist between the permanent and #P. 2 class computed by logarithmic-depth threshold circuits). 2 Similarly, PL was not known to be closed under complementation until a complicated proof was given in <ref> [42] </ref>; a much simpler proof subsequently appeared in [39]. The source of all this difficulty was the fact, already alluded to, that probabilistic logspace machines cannot obviously be restricted to run in polynomial time without loss of computational power.
Reference: [43] <author> J. Simon, J. Gill, and J. Hunt, </author> <title> On tape-bounded probabilistic Turing machine transduc-ers, </title> <booktitle> Proc. 19th FOCS, </booktitle> <year> 1978, </year> <pages> pp. 107-112. </pages>
Reference-contexts: In Section 6 we present characterizations of the classes reducible to PL and #L under various notions 2 The complete history of the complexity of PL is even more complicated. The interested reader may wish to consult [8, p. 115], [25], <ref> [43, p. 111] </ref>, and [20]. The related notion of probabilistic finite automata has also been studied in depth; for recent results and references, see [31, 32]. 3 of reducibility.
Reference: [44] <author> S. </author> <title> Toda, Counting problems computationally equivalent to the determinant, </title> <type> Technical Report CSIM 91-07, </type> <institution> Dept. Comp. Sci. and Inf. Math., Univ. of Electro-Communications, </institution> <address> Tokyo, </address> <year> 1991. </year>
Reference-contexts: Work done in part while at University of Electro-Communications, Tokyo. 1 Although stated in different ways, the results of [49, Theorem 6.5], <ref> [44, Theorem 2.1] </ref>, [16], and [48, Theorem 2] show the following fact: Theorem 1 [44, 16, 49, 48] A function f is in GapL iff f is logspace many-one reducible to the determinant. (A function f is logspace many-one reducible to the determinant if there is a function g computable in <p> Work done in part while at University of Electro-Communications, Tokyo. 1 Although stated in different ways, the results of [49, Theorem 6.5], [44, Theorem 2.1], [16], and [48, Theorem 2] show the following fact: Theorem 1 <ref> [44, 16, 49, 48] </ref> A function f is in GapL iff f is logspace many-one reducible to the determinant. (A function f is logspace many-one reducible to the determinant if there is a function g computable in logspace such that f (x) (viewed as a number written in binary) is equal <p> logspace many-one reducible to the determinant. (A function f is logspace many-one reducible to the determinant if there is a function g computable in logspace such that f (x) (viewed as a number written in binary) is equal to the determinant of matrix g (x).) 1 The proof given in <ref> [44] </ref> is particularly clear and direct: Toda shows that the determinant (of integer matrices) is reducible to iterated matrix multiplication over the integers (using [7]), which in turn is reducible to iterated matrix multiplication over f0; 1; 1g, which in turn is reducible to a canonical GapL-complete problem, which in turn <p> We remark that the logspace many-one reductions presented in <ref> [44] </ref>, can in fact be computed by uniform AC 0 circuits; we will use this fact later. In this paper we use Theorem 1 to give a very simple proof of a theorem of Jung [27], concerning the complexity class PL.
Reference: [45] <author> S. </author> <title> Toda, Classes of arithmetic circuits capturing the complexity of computing the determinant, </title> <journal> IEICE Trans. Inf. and Syst., </journal> <volume> vol. </volume> <month> E75-D </month> <year> (1992) </year> <month> 116-124. </month>
Reference-contexts: A number of open questions remain. Among them: * What closure properties can be established for #L and GapL? In regard to this question, it is appropriate to mention that GapL can be characterized as the class of functions computed by "skew" arithmetic circuits <ref> [45] </ref>.
Reference: [46] <author> J. Toran, </author> <title> Complexity classes defined by counting quantifiers, </title> <note> Journal of the ACM 38 (1991) 753-774. </note>
Reference-contexts: First, we need to present some definitions. Definition 2 C = L is the class of languages A for which there is a function g 2 GapL such that x 2 A iff g (x) = 0. As is the case with C = P <ref> [46] </ref>, there are several equivalent ways of defining C = L. Proposition 13 The following are equivalent: 1. A 2 C = L. 2. There is a function f 2 FL and a function g 2 GapL such that x 2 A iff f (x) = g (x). 3. <p> do not know if this class is equal to the class considered by Cook, but it follows easily from the results of this section that if NC 1 (DET) is equal to AC 0 (DET), then the #L Hierarchy we define below collapses at some level.) The counting hierarchy (see <ref> [50, 46] </ref>) consists of sets in the classes PP, PP PP , PP PP PP , etc. <p> Since PP is contained in C = P C = P <ref> [46] </ref>, it follows that the same class of sets results if the hierarchy is defined in terms of C = P instead of PP. One obtains a computationally-equivalent class of functions if one considers #P, #P #P , etc.
Reference: [47] <author> L. Valiant, </author> <title> The complexity of computing the Permanent, </title> <note> Theoretical Computer Science 8 (1979) 189-201. </note>
Reference-contexts: 1 Introduction One of the most important and influential early results of complexity theory is the theorem of <ref> [47] </ref> showing that the complexity of computing the permanent of an integer matrix is characterized by the complexity class #P of functions that count the number of accepting computation paths of a nondeterministic polynomial-time machine. <p> For example, it is shown in [53, 11] that the permanent of zero-one matrices is "many-one complete" for #P, using a less restrictive version of "many-one reductions." On the other hand, it follows from <ref> [47] </ref> that the permanent of integer matrices cannot be complete for #P or GapP using our definition of "many-one reduction" unless P = P (since the permanent and the determinant are equal mod 2).
Reference: [48] <author> L. Valiant, </author> <title> Why is Boolean complexity theory difficult? in Boolean Function Complexity, edited by M. </title> <editor> S. Paterson, </editor> <booktitle> London Mathematical Society Lecture Notes Series 169, </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Work done in part while at University of Electro-Communications, Tokyo. 1 Although stated in different ways, the results of [49, Theorem 6.5], [44, Theorem 2.1], [16], and <ref> [48, Theorem 2] </ref> show the following fact: Theorem 1 [44, 16, 49, 48] A function f is in GapL iff f is logspace many-one reducible to the determinant. (A function f is logspace many-one reducible to the determinant if there is a function g computable in logspace such that f (x) <p> Work done in part while at University of Electro-Communications, Tokyo. 1 Although stated in different ways, the results of [49, Theorem 6.5], [44, Theorem 2.1], [16], and [48, Theorem 2] show the following fact: Theorem 1 <ref> [44, 16, 49, 48] </ref> A function f is in GapL iff f is logspace many-one reducible to the determinant. (A function f is logspace many-one reducible to the determinant if there is a function g computable in logspace such that f (x) (viewed as a number written in binary) is equal
Reference: [49] <author> V. Vinay, </author> <title> Counting auxiliary pushdown automata and semi-unbounded arithmetic circuits, </title> <booktitle> Proc. 6th IEEE Structure in Complexity Theory Conference (1991) 270-284. </booktitle>
Reference-contexts: Part of this work was done while on sabbatical at Princeton University. z Supported in part by the JSPS under grant NSF-INT-9116781/JSPS-ENG-207, and by the NSF under grant CCR-9002292. Work done in part while at University of Electro-Communications, Tokyo. 1 Although stated in different ways, the results of <ref> [49, Theorem 6.5] </ref>, [44, Theorem 2.1], [16], and [48, Theorem 2] show the following fact: Theorem 1 [44, 16, 49, 48] A function f is in GapL iff f is logspace many-one reducible to the determinant. (A function f is logspace many-one reducible to the determinant if there is a function <p> Work done in part while at University of Electro-Communications, Tokyo. 1 Although stated in different ways, the results of [49, Theorem 6.5], [44, Theorem 2.1], [16], and [48, Theorem 2] show the following fact: Theorem 1 <ref> [44, 16, 49, 48] </ref> A function f is in GapL iff f is logspace many-one reducible to the determinant. (A function f is logspace many-one reducible to the determinant if there is a function g computable in logspace such that f (x) (viewed as a number written in binary) is equal
Reference: [50] <author> K. Wagner, </author> <title> The complexity of combinatorial problems with succinct input representation, </title> <note> Acta Informatica 23 (1986) 325-356. </note>
Reference-contexts: do not know if this class is equal to the class considered by Cook, but it follows easily from the results of this section that if NC 1 (DET) is equal to AC 0 (DET), then the #L Hierarchy we define below collapses at some level.) The counting hierarchy (see <ref> [50, 46] </ref>) consists of sets in the classes PP, PP PP , PP PP PP , etc.
Reference: [51] <author> C. Wilson, </author> <title> Relativized NC, </title> <note> Mathematical Systems Theory 20 (1987) 13-29. </note>
Reference-contexts: Damm and Peter Rossmanith [24, 38].) The reader should not be alarmed by the fact that L PL is contained in AC 0 (PL) (and in fact the containment may even be proper), even though AC 0 is properly contained in L; we refer the reader to the discussion in <ref> [51, 52] </ref>. Some of the motivation for this study came from the question of whether or not L #L = L DET = L PL , by analogy to the equalities that are known to hold for the related classes #P and PP.
Reference: [52] <author> C. B. Wilson, </author> <title> Decomposing NC and AC, </title> <note> SIAM Journal on Computing 19 (1990) 384-396. </note>
Reference-contexts: Damm and Peter Rossmanith [24, 38].) The reader should not be alarmed by the fact that L PL is contained in AC 0 (PL) (and in fact the containment may even be proper), even though AC 0 is properly contained in L; we refer the reader to the discussion in <ref> [51, 52] </ref>. Some of the motivation for this study came from the question of whether or not L #L = L DET = L PL , by analogy to the equalities that are known to hold for the related classes #P and PP.
Reference: [53] <author> V. Zanko, </author> <note> #P-completeness via many-one reductions, International Journal of Foundations of Computer Science 2 (1991) 77-82. </note>
Reference-contexts: It should be noted that the notion of one function being "many-one reducible" to another is sometimes defined in a much less restrictive way. For example, it is shown in <ref> [53, 11] </ref> that the permanent of zero-one matrices is "many-one complete" for #P, using a less restrictive version of "many-one reductions." On the other hand, it follows from [47] that the permanent of integer matrices cannot be complete for #P or GapP using our definition of "many-one reduction" unless P =
Reference: [54] <author> D. </author> <title> Zuckerman, </title> <type> personal communication. 21 </type>
Reference-contexts: and AC 1 (or logCFL)? * Can any any relationship be established between PL (or C = L) and bounded-error probabilistic logspace? Note in this regard that David Zuckerman and Mauricio Karchmer have recently shown that no "black-box" simulation of PL can yield a bounded-error probabilistic logspace algorithm for PL <ref> [54] </ref>. * Can anything more be said about the relationship between PLH and NC 1 (PL) (or #LH and NC 1 (#L))? Note that for many classes C of interest (including AC k , NC k , NL, L, NP [4, 34]), AC 0 (C) is equal to NC 1 (C).
References-found: 54

