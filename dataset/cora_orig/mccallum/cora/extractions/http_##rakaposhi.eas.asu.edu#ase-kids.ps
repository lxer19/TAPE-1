URL: http://rakaposhi.eas.asu.edu/ase-kids.ps
Refering-URL: http://rakaposhi.eas.asu.edu/yochan.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: fbiplav,rao,amol.malig@asu.edu  
Title: A Structured Approach for Synthesizing Planners from Specifications  
Author: Biplav Srivastava Subbarao Kambhampati Amol D. Mali 
Web: WWW: http://rakaposhi.eas.asu.edu/yochan.html  
Address: Tempe, AZ 85287-5406.  
Affiliation: Department of Computer Science and Engineering Arizona State University,  
Abstract: Plan synthesis approaches in AI fall into two categories: domain-independent and domain-dependent. The domain-independent approaches are applicable across a variety of domains, but may not be very efficient in any one given domain. The domain-dependent approaches can be very efficient for the domain for which they are designed, but would need to be written separately for each domain of interest. The tediousness and the error-proneness of manual coding have hither-to inhibited work on domain-dependent planners. In this paper, we describe a novel way of automating the development of domain dependent planners using knowledge-based software synthesis tools. Specifically, we describe an architecture called CLAY in which the Kestrel Interactive Development System (KIDS) is used in conjunction with a declarative theory of domain independent planning, and the declarative control knowledge specific to a given domain, to semi-automatically derive customized planning code. We discuss what it means to write declarative theory of planning and control knowledge for KIDS, and illustrate it by generating a range of domain-specific planners using state space and plan space refinements. We demonstrate that the synthesized planners can have superior performance compared to classical refinement planners using the same control knowledge. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Backstrom and B. Nebel. </author> <title> Complexity results in SAS+ planning. </title> <type> Research Report, </type> <institution> Dept Comp.and Info Sc., Linkoping Univ., Sweden, </institution> <year> 1993. </year>
Reference-contexts: Representing Domain Operators We now discuss how a world state is represented and how the domain operators define state transformation from one state to another. The two approaches which are popular in the planning community are the STRIPS representation [4] and the multi-valued state-variable representation <ref> [1] </ref>. In the STRIPS representation, the plan state is represented as a clause of predicates expressing some information about the world. Actions have pre-conditions which specify when the action can be executed and post-conditions which express change to the plan state when the action is executed.
Reference: [2] <author> A. Barrett and D. Weld. </author> <title> Partial order planning: Evaluating possible efficiency gains. </title> <journal> Artificial Intelligence, </journal> <volume> 67(1), </volume> <year> 1994. </year>
Reference-contexts: In this section we briefly describe our progress to-date on synthesizing plan-space planners [7] Plan space planners search in the space of partially ordered plans, introducing actions without restricting their position. Such an approach is considered to be more efficient than state space planning <ref> [2, 7] </ref>. Consequently, we have been working on synthesizing domain-dependent plan space planners.
Reference: [3] <author> A. Blum and M. Furst. </author> <title> Fast planning through planning graph analysis. </title> <booktitle> Proc IJCAI-95, </booktitle> <pages> pages 16361642, </pages> <year> 1995. </year>
Reference-contexts: In the Tyre world [15], there is a car with spare tyre and tools in the boot. Given some tyre trouble, it may be inflated or replaced with the help of the tools. We used the same domain description as used in Graphplan <ref> [3] </ref>. 4.2. Performance of Synthesized planners The synthesized state space planners were able to solve large blocks world, logistics and Tyre world problems very efficiently. <p> We have synthesized state space and shown that the synthesized planners can be superior to traditional planners when given the same domain control knowledge. We have also described the status of our efforts to synthesize plan-space planners. Even though newer breed of classical planners (e.g. Graphplan <ref> [3] </ref>) can solve the same problems in better or comparable time, in theory, even these planners can be synthesized within the CLAY architecture. Thus, the results give empirical evidence that the CLAY approach is an interesting research direction for obtaining efficient planners.
Reference: [4] <author> R. Fikes and N. Nilsson. </author> <title> STRIPS: A new approach to the application of theorem proving to problem solving. </title> <booktitle> Readings in Planning, 1990. </booktitle> <publisher> Morgan Kaufmann Publ., </publisher> <address> San Ma-teo, CA. </address>
Reference-contexts: 1. Introduction Planning is the problem of synthesizing a sequence of actions from a set of possible action templates such that when they are executed from the initial world state, all goal constraints are satisfied <ref> [4, 12] </ref>. Planning is known to be a combinatorial problem, and a variety of approaches for plan synthesis have been developed over the past twenty years. These approaches can be classified into two varieties domain independent and domain dependent. <p> Representing Domain Operators We now discuss how a world state is represented and how the domain operators define state transformation from one state to another. The two approaches which are popular in the planning community are the STRIPS representation <ref> [4] </ref> and the multi-valued state-variable representation [1]. In the STRIPS representation, the plan state is represented as a clause of predicates expressing some information about the world.
Reference: [5] <author> E. Fink and M. Veloso. </author> <title> Formalizing the prodigy planning algorithm. </title> <type> CMU CS Tech Report CMU-CS-94-123, </type> <year> 1994. </year>
Reference-contexts: Additionally, in a typical classical planner like SNLP [12], UCPOP [14] and PRODIGY <ref> [5] </ref>, domain control rules may be used to guide the search if the implementation has programming hooks at different choice points to make use of them.
Reference: [6] <author> C. P. Gomes. </author> <title> Planning in KIDS. </title> <type> Technical Report RL-TR-95-205, </type> <institution> Rome Laboratory, </institution> <year> 1995. </year>
Reference-contexts: To improve its efficiency, we are currently working on providing more effective search control during the synthesis process. 6. Related Work The research reported here straddles the two fields of automated software synthesis and AI planning. Although there has not been much work on automated planner synthesis, Gomes <ref> [6] </ref> has synthesized a state-space problem solver for the missionaries and cannibals problem on KIDS, and has shown that it outperforms general purpose problem solvers in that domain. Our framework can be seen as a generalization of the work done by Gomes.
Reference: [7] <author> S. Kambhampati. </author> <title> Refinement planning as a unifying framework for plan synthesis. </title> <journal> AI Magazine, </journal> <volume> 18(2), </volume> <month> Summer </month> <year> 1997. </year>
Reference-contexts: These are known, respectively, as Forward State Space Refinement (FSS), Backward State Space Refinement (BSS) e.g. TOPI, Plan Space Refinement (PSS) e.g. SNLP and Task Reduction Refinement (HTN) e.g. NON-LIN <ref> [7] </ref>. Given this background, the declarative theory of plan generation in CLAY corresponds to theories of these refinements. The algorithm tactic underlying plan generation corresponds to refinement search. KIDS system supports an algorithm tactic called global search [17] which can be seen as a generalization of this refinement search. <p> Progress on Synthesizing Plan Space plan ners within CLAY Until now, we have concentrated on synthesis of state-space planners. In this section we briefly describe our progress to-date on synthesizing plan-space planners <ref> [7] </ref> Plan space planners search in the space of partially ordered plans, introducing actions without restricting their position. Such an approach is considered to be more efficient than state space planning [2, 7]. Consequently, we have been working on synthesizing domain-dependent plan space planners. <p> In this section we briefly describe our progress to-date on synthesizing plan-space planners [7] Plan space planners search in the space of partially ordered plans, introducing actions without restricting their position. Such an approach is considered to be more efficient than state space planning <ref> [2, 7] </ref>. Consequently, we have been working on synthesizing domain-dependent plan space planners.
Reference: [8] <author> S. Kambhampati, C. Knoblock, and Q. Yang. </author> <title> Planning as refinement search: A unified framework for evaluating design tradeoffs in partial order planning. </title> <journal> Artificial Intelligence, 76:167238, 1995. Special Issue on Planning and Scheduling. </journal>
Reference-contexts: We answer these questions with the help of a unifying framework for plan synthesis algorithms (called Universal Classical Planning or UCP) that we have developed in our recent work <ref> [9, 8] </ref>. In this framework, plan synthesis is modeled as a process of searching in a space of sets of action sequences. These sets are represented compactly as collections of constraints called partial plans.
Reference: [9] <author> S. Kambhampati and B. Srivastava. </author> <title> Universal classical planning: An algorithm for unifying state space and plan space planning approaches. New Directions in AI Planning: EWSP 95, </title> <publisher> IOS Press, </publisher> <pages> 61-75, </pages> <year> 1995. </year>
Reference-contexts: We answer these questions with the help of a unifying framework for plan synthesis algorithms (called Universal Classical Planning or UCP) that we have developed in our recent work <ref> [9, 8] </ref>. In this framework, plan synthesis is modeled as a process of searching in a space of sets of action sequences. These sets are represented compactly as collections of constraints called partial plans.
Reference: [10] <author> S. Kambhampati and B. Srivastava. </author> <title> Unifying classical planning approaches. </title> <type> Technical Report ASU CSE TR 96-006, </type> <institution> Arizona State University, </institution> <year> 1996. </year>
Reference-contexts: The goal state has Block A on top of Block B, Block B on top of Block C and Block C on top of Table. original partial plan's action sequence set), and considers the new plans in turn. As mentioned in Kambhampati and Srivastava <ref> [10] </ref>, existing domain independent plan-synthesis algorithms correspond to four different ways of refining partial plans. These are known, respectively, as Forward State Space Refinement (FSS), Backward State Space Refinement (BSS) e.g. TOPI, Plan Space Refinement (PSS) e.g. SNLP and Task Reduction Refinement (HTN) e.g. NON-LIN [7].
Reference: [11] <author> J. L. Lauriere. </author> <title> A language and a program for stating and solving combinatorial problems. </title> <journal> Artificial Intelligence, </journal> <volume> 10:29127, </volume> <year> 1978. </year>
Reference-contexts: This makes for a fairer comparison between synthesized and general-purpose planners. There are many research projects in constraint satisfaction systems, for example, COASTOOL [19] and ALICE system <ref> [11] </ref> that take declarative description of CSPs and compile specialized algorithms for solving them. MULTI-TAC [13] does the same thing but uses distribution-oriented information and machine learning techniques to assist in the customization. We use declarative knowledge about refinement and planning domain to customize the planner. 7.
Reference: [12] <author> D. McAllester and D. Rosenblitt. </author> <title> Systematic Nonlinear Planning. </title> <booktitle> Proc. 9th NCAI-91, </booktitle> <pages> 634-639, </pages> <year> 1991. </year>
Reference-contexts: 1. Introduction Planning is the problem of synthesizing a sequence of actions from a set of possible action templates such that when they are executed from the initial world state, all goal constraints are satisfied <ref> [4, 12] </ref>. Planning is known to be a combinatorial problem, and a variety of approaches for plan synthesis have been developed over the past twenty years. These approaches can be classified into two varieties domain independent and domain dependent. <p> Similarly, in the Tyre domain [15], the fixit task was solved in under a minute. To put the performance results in perspective, we compared KIDS' synthesized planners and the instantiations of UCP (which emulate a spectrum of classical planners, including the popular SNLP planner <ref> [12] </ref>, by selecting the appropriate refinement) across many blocks world tasks [18]. In our experiments with state-space planners for the blocks world domain, the best of the KIDS' synthesized planners outperformed the best of the UCP in-stantiations when given the same domain-specific informa tion. <p> Since the algorithm is synthesized from specification, the user is freed from low-level coding, and can concentrate on declarative specification of control knowledge (e.g. pruning tests) and the way the operations mentioned in the specification combine (e.g. distributive laws). Additionally, in a typical classical planner like SNLP <ref> [12] </ref>, UCPOP [14] and PRODIGY [5], domain control rules may be used to guide the search if the implementation has programming hooks at different choice points to make use of them.
Reference: [13] <author> S. Minton. </author> <title> Automatically configuring constraint satisfaction problems: A case study. Constraints, </title> <type> 1(1), </type> <year> 1996. </year>
Reference-contexts: This makes for a fairer comparison between synthesized and general-purpose planners. There are many research projects in constraint satisfaction systems, for example, COASTOOL [19] and ALICE system [11] that take declarative description of CSPs and compile specialized algorithms for solving them. MULTI-TAC <ref> [13] </ref> does the same thing but uses distribution-oriented information and machine learning techniques to assist in the customization. We use declarative knowledge about refinement and planning domain to customize the planner. 7.
Reference: [14] <author> J. Penberthy and D. Weld. UCPOP: </author> <title> A sound, complete, partial order planner for ADL. </title> <booktitle> Proc. AAAI-94, </booktitle> <pages> 103-114, </pages> <year> 1994. </year>
Reference-contexts: Since the algorithm is synthesized from specification, the user is freed from low-level coding, and can concentrate on declarative specification of control knowledge (e.g. pruning tests) and the way the operations mentioned in the specification combine (e.g. distributive laws). Additionally, in a typical classical planner like SNLP [12], UCPOP <ref> [14] </ref> and PRODIGY [5], domain control rules may be used to guide the search if the implementation has programming hooks at different choice points to make use of them.
Reference: [15] <author> S. Russell and P. Norvig. </author> <booktitle> Artificial Intelligence AModern Approach (chap 13). </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1995. </year>
Reference-contexts: This is unheard of in traditional planners. In the logistics domain, a task with 12 packages, 4 planes and 8 places was solved in under a minute. Similarly, in the Tyre domain <ref> [15] </ref>, the fixit task was solved in under a minute. <p> The logistics domain consists of a certain number of planes and packages at different places. The goal is to find a sequence of actions such that all planes and packages are at the goal positions. In the Tyre world <ref> [15] </ref>, there is a car with spare tyre and tools in the boot. Given some tyre trouble, it may be inflated or replaced with the help of the tools. We used the same domain description as used in Graphplan [3]. 4.2.
Reference: [16] <author> D. Smith and E. </author> <title> Parra. Transformational approach to transportation scheduling. </title> <booktitle> In Proceedings of the 8th Knowledge-based Software Engineering Conference, </booktitle> <pages> pages 1417, </pages> <address> 1993. Chicago, IL, </address> <month> Sept </month> <year> 1993. </year>
Reference-contexts: Background Part of the reason for our interest in KIDS system stems from the fact that it has been used in the past to derive efficient scheduling software <ref> [16] </ref>. Using KIDS to derive planning software in CLAY involves figuring out (a) how declarative theories for different types of classical planning are specified and (b) what algorithmic design templates are best suited to planner synthesis.
Reference: [17] <author> D. R. Smith. </author> <title> Structure and design of global search algorithms. </title> <type> Kestrel Tech. Rep. </type> <institution> KES.U.87.11, </institution> <year> 1992. </year>
Reference-contexts: In this work, as is shown in Figure 1, a declarative theory of plan synthesis (theory of planning) is combined with the control knowledge specific to a given domain, in a semi-automated software synthesis system called KIDS (Kestrel Interactive Development System) <ref> [17] </ref> to derive a customized planner for the domain. We will draw the 1 declarative theory of plan synthesis from domain indepen-dent planning techniques. Domain specific information will be expressed in terms of the types of plans that are preferred in the given domain. <p> SNLP and Task Reduction Refinement (HTN) e.g. NON-LIN [7]. Given this background, the declarative theory of plan generation in CLAY corresponds to theories of these refinements. The algorithm tactic underlying plan generation corresponds to refinement search. KIDS system supports an algorithm tactic called global search <ref> [17] </ref> which can be seen as a generalization of this refinement search. As we give planning as a problem to KIDS, we have to develop a theory of planning (planning theory). <p> In practice, we map all the valid values of state variables to integers. 3.2. Specification of a planner A specification of the problem ( <ref> [17] </ref>) is represented by a quadruple F = h D, R, I, O i where D is the input type satisfying the input condition, I : D ! boolean. The output type is R and the output condition, O : D fi R ! boolean defines a feasible solution. <p> The process can be described as a tree search in which a node represents a set of candidates and an arc represents the split relationship between a set and its subset. For complete details, readers are referred to <ref> [17] </ref>. Based on the problem specification, KIDS lists pre-canned global search theories to which it can automatically map the current problem instance using deductive inference. Since our data type was a sequence, we used the specialization of global search for sequences over a finite domain.
Reference: [18] <author> B. Srivastava and S. Kambhampati. </author> <title> Synthesizing customized planners from specifications. </title> <journal> Journal of AI Research, </journal> <note> 1997 (to appear). </note>
Reference-contexts: Work on the synthesis of PSS planner is still in progress and we discuss our approach towards the end of this paper. Empirical evaluation shows that synthesized planners can be very efficient <ref> [18] </ref>. For example, in the blocks world domain where the goal was stack inversion, a KIDS synthesized planner could solve 14 blocks task in under a minute. This is unheard of in traditional planners. <p> To put the performance results in perspective, we compared KIDS' synthesized planners and the instantiations of UCP (which emulate a spectrum of classical planners, including the popular SNLP planner [12], by selecting the appropriate refinement) across many blocks world tasks <ref> [18] </ref>. In our experiments with state-space planners for the blocks world domain, the best of the KIDS' synthesized planners outperformed the best of the UCP in-stantiations when given the same domain-specific informa tion. <p> The paper is organized as follows: after a brief review of software synthesis on KIDS in Section 2, we walk-through the CLAY framework in Section 3 in the context of state space planners. Section 4 summarizes some of our empirical results (See detailed report in <ref> [18] </ref>). Section 5 presents our on-going effort to synthesize PSS planners within the CLAY framework. We cover related work in Section 6 and concluding comments in Section 7. 2. Background on KIDS KIDS is a program-transformation framework for the development of programs from formal specifications of a problem. <p> Finally, we compare the best of the synthesized planners for different tasks with the selected traditional planner. We selected two task suites: random block world tasks and stack building task (See <ref> [18] </ref> for detail). Each task class is defined in terms of the number of blocks and an average of 10 runs is shown in each plot.
Reference: [19] <author> M. Yoshikawa, K. Kaneko, Y. Nomura, and M. Watanabe. </author> <title> A constraint-based approach to high school timetabling problems: A case study. </title> <booktitle> Proc. NCAI-94, </booktitle> <pages> pages 11111116, </pages> <year> 1994. </year>
Reference-contexts: Methodologically, our work adds to Gomes' results in that we have shown that given the same control knowledge, planners generated by KIDS can outperform traditional planners. This makes for a fairer comparison between synthesized and general-purpose planners. There are many research projects in constraint satisfaction systems, for example, COASTOOL <ref> [19] </ref> and ALICE system [11] that take declarative description of CSPs and compile specialized algorithms for solving them. MULTI-TAC [13] does the same thing but uses distribution-oriented information and machine learning techniques to assist in the customization.
References-found: 19

