URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1272/CS-TR-95-1272.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1272/
Root-URL: http://www.cs.wisc.edu
Title: Implementing Generalized Transitive Closure in the Paradise Geographical Information System  
Author: Biswadeep Nag 
Date: June 14, 1995  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Abstract: The generalized transitive closure operator can be used to ask and answer a number of sophisticated queries on a database which is viewed as a directed graph. These queries cannot be expressed in SQL or relational algebra and neither can they be answered by commercially available relational or object-oriented database systems. In this report we describe the design and implementation of the generalized transitive closure operator in Paradise, an experimental geographical information system, a domain in which this operator is especially useful. We show how semi-naive evaluation, a basic technique for evaluating recursive queries, can be extended to compute aggregates and we also give a formal proof of the correctness of our method. We also discuss how selections can be used to optimize the evaluation of the query. The report concludes with a few examples of how these queries can now be expressed in the extended SQL like query language of Paradise and what the results look like. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Dar S., </author> <title> Augmenting Databases with Generalized Transitive Closure, </title> <institution> University of Wisconsin-Madison, </institution> <type> Ph.D. Dissertation, </type> <year> 1993. </year>
Reference-contexts: There are a number of experimental systems though, which support general recursive queries. One example is CORAL [6] and there are others like Starburst and LDL. In this respect however, we share the view expressed by Dar <ref> [1] </ref> and others that all the heavy machinery required to support general recursion is not really necessary for this particular class of recursive queries, and yet, most recursive queries which occur in practice are in fact expressible as generalized transitive closure. 1.4 Overview of the Report In this report we discuss <p> In that case when, for example, the source relation has been materialized by a previous query, we will say that a selection is implicit. In <ref> [1] </ref> a very elegant formal structure to classify all the various kinds of selections has been presented, and this we shall discuss in the following subsection. 8 4.2 Classifying and Utilizing Selections Classification of constraints (C) which can restrict the result of a transitive closure query: Monotonically Negative If a path <p> C intermediate During recursive enumeration of paths, restrict the set of arcs which are to be included in the transitive closure. C final After all paths have been enumerated, apply the selection. It has been shown in <ref> [1] </ref> that for certain types of constraints, certain types of selections are necessary and sufficient and these conclusions are summarised below. It is to be noted that in the case of a conjunction of constraints, there will be a corresponding superposition of selections. <p> The condensation of the path P (s; t) is the triple &lt; s; t; L (s; t) &gt;. There are restrictions about when the condensation of a path is sufficient and these are detailed in <ref> [1] </ref>. When we are dealing with aggregates, we have to consider a set of paths, and once again, this can be concisely represented by a path set condensation.
Reference: [2] <author> Dar S. and R. Ramakrishnan, </author> <title> A Performance Study of Transitive Closure Algorithms, </title> <booktitle> Proceedings of SIGMOD 94, </booktitle> <pages> pp. 454 - 465. </pages>
Reference-contexts: The cost of evaluation varies quite a bit with the size of the set of source nodes, and so it matters whether we are doing complete or partial transitive closure. The algorithms which do well on CTC have a preprocessing step usually involving a topological sort of the graph <ref> [2] </ref>. This orders the nodes in a way such that consecutively accessed nodes are placed close together on disk. In our implementation, we assumed PTC. The number of source nodes may be more than one, but in general the selectivity of this initial selection of source nodes will be high.
Reference: [3] <author> DeWitt D.J. et al, </author> <title> Client-Server Paradise, </title> <booktitle> Proceedings of VLDB 94. </booktitle>
Reference-contexts: GIS's are used by earth, atmospheric and space scientists to store and analyze satellite remote sensed data. Traditionally GIS's have used files as the medium of storage, but recently DeWitt and others have proposed the use of specialized DBMS's as GIS's <ref> [3] </ref>. There are a number of ways in which generalized transitive closure may be used in a GIS. One is the modelling of irrigation channels as directed graphs to find out the reachability and effectiveness of the irrigation network. Another is to use a GIS as a sophisticated route finder. <p> This means that the aggregate value produced by ARE is correct. 5 Implementation Experiences 5.1 If there is Paradise on Earth, ... Paradise (P arallel Data Information System) is an experimental system designed to store and manage large volumes of geographical or satellite remote sensed data <ref> [3] </ref>. Paradise is object-relational in design with support for user defined ADTs. Among the different datatypes supported by Paradise are points, polylines, arrays and raster images in addition to the usual integer, real and string data types.
Reference: [4] <editor> Melton J. (ed.), </editor> <title> (ISO-ANSI Working Draft) Database Language SQL (SQL3), ANSI X3.135-1992, </title> <month> Nov </month> <year> 1992. </year>
Reference-contexts: Perhaps one of the reasons for this is the lack of standard query languages which can express transitive closure. It is only recently that languages like SQL3 <ref> [4] </ref> and POSTQUEL [5] have been proposed to handle these queries. Among DBMS's, POSTGRES and Illustra claim to be close to achieving the goal of implementing transitive closure, but there have not been any published results. There are a number of experimental systems though, which support general recursive queries.
Reference: [5] <author> Mosher C., </author> <title> The POSTGRES Version 4.0 Reference Manual, </title> <institution> Electronics Research Laboratory, University of California, Berkeley, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: Perhaps one of the reasons for this is the lack of standard query languages which can express transitive closure. It is only recently that languages like SQL3 [4] and POSTQUEL <ref> [5] </ref> have been proposed to handle these queries. Among DBMS's, POSTGRES and Illustra claim to be close to achieving the goal of implementing transitive closure, but there have not been any published results. There are a number of experimental systems though, which support general recursive queries.
Reference: [6] <author> Ramakrishnan R. et al, </author> <title> Implementation of the CORAL Deductive Database System, </title> <booktitle> Proceedings of SIGMOD 93, </booktitle> <pages> pp. 167 - 176. </pages>
Reference-contexts: Among DBMS's, POSTGRES and Illustra claim to be close to achieving the goal of implementing transitive closure, but there have not been any published results. There are a number of experimental systems though, which support general recursive queries. One example is CORAL <ref> [6] </ref> and there are others like Starburst and LDL.
Reference: [7] <author> Stonebraker M. et al, </author> <title> The Sequoia 2000 Storage Benchmark, </title> <booktitle> Proceedings of SIGMOD 93, </booktitle> <pages> pp. 2 - 11. </pages>
Reference-contexts: Basically any kind of graph traversal and reachability problem can be reduced to a generalized transitive closure problem. Currently, the effectiveness of a DBMS in handling GIS queries is measured in terms of how well it performs on the Sequoia 2000 storage benchmark introduced by Stonebraker et al <ref> [7] </ref> . <p> This is the reason why selections are important, and this has been reiterated by Stonebraker in his analysis of Sequoia benchmark query # 11 <ref> [7] </ref>. Traditionally, selections in queries are expressed by means of the where clause in SQL. We will call these explicit selections. In addition to these, transitive closure queries can have implicit selections, where either the graph or the source set or both, have been processed before the query is issued. <p> For example, the Sequoia benchmark Query # 11 can be expressed as follows : select* from river R start startpt S closure S.p = R.b compose S (R.e, R.length.plus (S.edge.length ())) where S.length &lt; 20 If we compare it to the POSTQUEL version, shown in <ref> [7] </ref>, the queries look remarkably similar : append* to temp (GRAPH.identifier, GRAPH.segment, length=temp.length+length (GRAPH.segment)) where end (temp.segment) = begin (GRAPH.segment) and GRAPH.identifier notin -temp.identifier- and temp.length &lt; 20 The change in the query language turned out to be a pretty big task. <p> The primary benchmark for such queries is Query # 11 of the Sequoia 2000. We have been successful in running the query, but unfortunately, we do not know the starting point of the query as this is not mentioned in <ref> [7] </ref>. So the numbers we obtained have not standardized. Part of the future work involves obtaining the start point and benchmarking our system against this query. 20 Semi-naive evaluation (and its cousin ARE) are very general algorithms which are relatively easy to implement.
Reference: [8] <author> Sudarshan S. and R. Ramakrishnan, </author> <title> Aggregation and Relevance in Deductive Databases, </title> <booktitle> Proceedings of VLDB 91, </booktitle> <pages> pp. 501-511. </pages>
Reference-contexts: The basic semi-naive evaluation algorithm presented in section 3 has to be modified a bit to calculate aggregates correctly. This modified algorithm is called Aggregate Retaining Evaluation (ARE) and is also described in <ref> [8] </ref>.
References-found: 8

