URL: http://www.cs.umd.edu/~samir/grant/bkn95.ps
Refering-URL: http://www.cs.umd.edu/~samir/grant/career.html
Root-URL: 
Title: The Loading Time Scheduling Problem (Extended Abstract)  
Author: Randeep Bhatia Samir Khuller Joseph (Seffi) Naor 
Address: College Park, MD 20742 College Park, MD 20742 Haifa 32000, Israel  
Affiliation: Computer Science Department Computer Science Department Computer Science Department Univ. of Maryland Univ. of Maryland Technion  
Abstract: In this paper we study precedence constrained scheduling problems, where the tasks can only be executed on a specified subset of the machines. Each machine has a loading time that is incurred only for the first task that is scheduled on the machine in a particular run. This basic scheduling problem arises in the context of machining on numerically controlled machines, query optimization in databases, and in other artificial intelligence applications. We give the first non-trivial approximation algorithm for this problem. We also prove non-trivial lower bounds on best possible approximation ratios for these problems. These improve on the non-approximability results that are implied by the non-approximability results for the shortest common supersequence problem. We use the same algorithmic technique to obtain approximation algorithms for a problem arising in the context of code generation for parallel machines, and for the weighted shortest common supersequence problem. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Azar. </author> <type> personal communication (1995). </type>
Reference-contexts: We describe a deterministic approximation algorithm that also generates a universal sequence, based on suggestions by Yossi Azar <ref> [1] </ref>. Recall that `(m j ) is the loading time of machine m j . Let set S j = fk `(m j )jk = 1; 2; : : :g be an infinite set.
Reference: [2] <author> P. Bonizzoni, M. Duella and G. Mauri. </author> <title> Approximation complexity of longest common subsequence and shortest common supersequence over fixed alphabet. </title> <type> Technical Report 117/94, </type> <institution> Universita degli Studi di Milano, </institution> <year> (1994). </year>
Reference-contexts: this implies the size of the solution for the problem whose instance is X is at most (f (N ) OP T k ) 1=k = f 1=k (N ) OP T 4.3 Proofs of Theorems It is known that the SCS problem over a binary alphabet is MAX SNP-hard <ref> [2] </ref>. This implies that there is a constant c, such that if there exists a polynomial time c-approximation algorithm for the SCS problem, then P = N P . <p> Recently, it has been show to be MAX SNP-hard over a binary alphabet as well <ref> [2] </ref>. Theorem 19 LTSP is NP-complete and MAX SNP hard for 4. Proof: It is easy to see that the problem is in NP since we can verify a given partitioning of V easily. <p> We would like to thank Yossi Azar and Yishay Mansour for letting us include their suggestions regarding universal sequences (Subsection 3.2). We thank Amos Fiat and Uzi Vishkin for helpful discussions. We thank Tao Jiang and Ming Li for pointers to references <ref> [2, 13] </ref>.
Reference: [3] <author> D. Das, S. Gupta and D. Nau. </author> <title> Reducing setup cost by automated generation of redesign suggestions. </title> <booktitle> Proc. ASME Computers in Engineering Conference, </booktitle> <pages> pages 159-170, </pages> <year> (1994). </year>
Reference-contexts: The goal is to minimize P k p=1 `(V p ), where `(V p ) = min m k 2M (V p ) `(m k ). In many manufacturing applications <ref> [8, 3] </ref>, typically, jM (i)j = 1. The tasks, for example, could be drilling, end-milling, etc. Let the term job denote the block of metal mentioned earlier. The following simple heuristic is commonly used in such applications.
Reference: [4] <author> J. Ferannte, K. Ottenstein and J. Warren. </author> <title> The program dependence graph and its uses in optimization. </title> <journal> ACM Transactions of Programming Languages and Systems, </journal> <pages> pages 319-349, </pages> <year> (1987). </year>
Reference: [5] <author> D. Foulser, M. Li and Q. Yang. </author> <title> Theory and algorithms for plan merging. </title> <booktitle> Artificial Intelligence Vol 57 </booktitle> <pages> 143-181, </pages> <year> (1992). </year>
Reference-contexts: The optimal solution is to first go home, then to the grocery store, and finally to the post-office. An extensive survey of "operator overlap" problems in Artificial Intelligence appears in the work by Foulser, Li and Yang <ref> [5] </ref>. In particular, they discuss a variety of heuristics, with an average case analysis for them, as well as empirical results. Other applications of overlapping operators arise in databases when we try to do multiple query optimization [15].
Reference: [6] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and intractability: a guide to the theory of NP-completeness, </title> <publisher> Freeman, </publisher> <address> San Francisco, </address> <year> (1979). </year>
Reference-contexts: A problem related to the Loading Time Schedul get cash (grocery store) (post-office) (grocery store) (home) (grocery store) get coupon (post-office) recycle bags buy ice-cream buy stamps post letters ing Problem is the Shortest Common Supersequence problem <ref> [6, problem SR8] </ref>. Here, a collection of sequences over a fixed alphabet is given, and the goal is to find a shortest common supersequence (SCS), such that all given sequences appear as a subsequence in the common supersequence. <p> may spread high cost vertices between several blocks, instead of grouping them in the same one. 1.3 Our Results It is easy to show that the Loading Time Scheduling Problem is NP-complete for arbitrary M (i), even when there are no precedence constraints, by a reduction from the set-cover problem <ref> [6] </ref>. (The elements correspond to tasks, and each subset corresponds to a machine. <p> A task can be done on a machine if the corresponding element belongs to the set corresponding to the machine.) When jM (i)j = 1, and 4, the problem can be shown to be NP-complete (and MAX SNP-hard) by a reduction from the shortest common supersequence problem <ref> [6, problem SR8] </ref>. Moreover, the reduction proves the hardness results even for the case of unit loading times. <p> designed for the problem of generating code for a parallel machine. 6 NP-completeness Proof We prove that the Loading Time Scheduling Problem is NP-complete even for the case of a constant number of machines, and M (i) = 1, by a polynomial time reduction from the Shortest Common Superse-quence problem <ref> [6, problem SR8] </ref>). Shortest Common Supersequence: Given a finite alphabet , finite set R of sequences from fl , and a positive integer K.
Reference: [7] <author> S. Gupta. </author> <type> personal communication. </type>
Reference-contexts: the practical point of view, an approximation factor of is much better than an approximation factor that is a function of n, since is typically very small (4 or 5), compared to the size of the task graph that can have, for example, over 1000 features for an engine block <ref> [7] </ref>. Linear Programming Rounding: A different approach to the approximation of LTSP is via linear programming. We show how to formulate this problem as an integer program for which an optimal fractional solution can be computed in polynomial time.
Reference: [8] <author> C. C. Hayes. </author> <title> A model of planning for plan efficiency: Taking advantage of operator overlap. </title> <booktitle> Proc. of the 11th International Joint Conference of Artificial Intelligence, </booktitle> <pages> pages 949-953 (1989). </pages>
Reference-contexts: When we perform a set of tasks consecutively on a particular machine, we incur the loading time only for the first task performed on the machine. We call this basic problem the Loading Time Scheduling Problem (LTSP). A special case of this problem was first mentioned by Hayes <ref> [8] </ref> in the context of machining metal parts. The objective is to start with a block of metal, and to use a numerically controlled machining center to cut a variety of features into the block. <p> When we are able to overlap the machining operations, we do not incur the loading time delay for the machine repeatedly. (For example, when we do two drilling operations consecutively, we only have to load the block of metal on the drilling machine once.) According to Hayes <ref> [8] </ref>, this set-up time is a large fraction of the time for each operation, sometimes as much as 90% of the time is spent in setting up for one machining operation. All other times are relatively small compared to the set-up time. A second motivation given by Hayes [8] is shown <p> to Hayes <ref> [8] </ref>, this set-up time is a large fraction of the time for each operation, sometimes as much as 90% of the time is spent in setting up for one machining operation. All other times are relatively small compared to the set-up time. A second motivation given by Hayes [8] is shown in Fig. 1. Suppose we have to run a few errands. The time to do each errand can be decomposed into the time to get to the place where the errand is to be done, together with the time to actually do the task. <p> The goal is to minimize P k p=1 `(V p ), where `(V p ) = min m k 2M (V p ) `(m k ). In many manufacturing applications <ref> [8, 3] </ref>, typically, jM (i)j = 1. The tasks, for example, could be drilling, end-milling, etc. Let the term job denote the block of metal mentioned earlier. The following simple heuristic is commonly used in such applications.
Reference: [9] <author> T. Jiang and M. Li. </author> <title> On the approximation of shortest common supersequences and longest common subsequences. </title> <booktitle> Proc. of 21st International Colloq. on Automata Langs. and Programming, </booktitle> <pages> pages 191-202, </pages> <year> (1994). </year>
Reference-contexts: Here, a collection of sequences over a fixed alphabet is given, and the goal is to find a shortest common supersequence (SCS), such that all given sequences appear as a subsequence in the common supersequence. The previous results shown for the SCS problem by Jiang and Li <ref> [9] </ref> are hardness results for approximation, and a -approximation algorithm, where is the size of the alphabet. Let n denote the number of sequences. Specifically, [9] show that (i) SCS does not have a polynomial time constant factor approximation algorithm, unless P = N P ; (ii) there exists a constant <p> The previous results shown for the SCS problem by Jiang and Li <ref> [9] </ref> are hardness results for approximation, and a -approximation algorithm, where is the size of the alphabet. Let n denote the number of sequences. Specifically, [9] show that (i) SCS does not have a polynomial time constant factor approximation algorithm, unless P = N P ; (ii) there exists a constant ffi such that if SCS has a polyno mial time approximation algorithm with ratio log ffi n then N P DT IM E (2 poly <p> They also give algorithms that produce solutions close to the optimal when the supersequences are random (see <ref> [9] </ref> for more details). A generalization is the weighted shortest common supersequence (WSCS), where each letter of the alphabet has a weight, and the weight of the supersequence is the sum of the weights of its constituent letters. <p> The following definitions from <ref> [9] </ref> are extended to LDAG's. Definition 4 Let and 0 be two alphabets. Let a 2 and b 2 0 be two letters. The product a fi b is the composite letter (a; b) 2 fi 0 .
Reference: [10] <author> E. Lawler, J. Lenstra, A. Rinnooy-Kan, D. Shmoys. </author> <title> Sequencing and scheduling: algorithms and complexity. </title> <booktitle> Handbooks in Operations Research and Management Science, </booktitle> <volume> Vol 4: </volume> <booktitle> Logistics of Production and Inventory, </booktitle> <editor> (Eds: S. C. Graves, A. H. G. Rinnooy Kan and P. </editor> <publisher> Zipkin). </publisher>
Reference-contexts: As an application of our results we show that we can obtain a approximation algorithm for the WSCS problem. The literature concerning scheduling problems is very extensive (see e.g., <ref> [10] </ref>). However, it appears that the specific constraints on the Loading Time Scheduling Problem are very different from the kinds of problems that have been previously considered in the scheduling literature. A different motivation for our work stems from the design of compilers for multiprocessor architectures.
Reference: [11] <author> D. Maier. </author> <title> The complexity of some problems on subsequences and supersequences. </title> <journal> Journal of the ACM, </journal> <volume> Vol 25 </volume> <pages> 322-336, </pages> <year> (1978). </year>
Reference-contexts: a subse quence of X, i.e., X = x 0 s i 1 x 1 s i p x p where each x j 2 fl and S i = s i 2 : : : s i This problem is known to be NP-complete even when jj = 5 <ref> [11] </ref> as well as when jj = 2 [13]. Recently, it has been show to be MAX SNP-hard over a binary alphabet as well [2]. Theorem 19 LTSP is NP-complete and MAX SNP hard for 4.
Reference: [12] <author> Y. Mansour. </author> <type> personal communication (1995). </type>
Reference-contexts: Since i is added at most once to the Queue, and for i we do O ( outdeg (i)) work, the bound follows. 3.2 Universal Sequences The concept of "universal sequences" was recently suggested by Yishay Mansour <ref> [12] </ref> in the context of a randomized approximation algorithm that also achieves an approximation factor of .
Reference: [13] <author> K. J. Raiha and E. Ukkonen. </author> <title> The shortest common super-sequence problem over a binary alphabet is NP-complete. </title> <booktitle> Theoretical Computer Science Vol 16(2) </booktitle> <pages> 187-198, </pages> <year> (1981). </year>
Reference-contexts: x 0 s i 1 x 1 s i p x p where each x j 2 fl and S i = s i 2 : : : s i This problem is known to be NP-complete even when jj = 5 [11] as well as when jj = 2 <ref> [13] </ref>. Recently, it has been show to be MAX SNP-hard over a binary alphabet as well [2]. Theorem 19 LTSP is NP-complete and MAX SNP hard for 4. Proof: It is easy to see that the problem is in NP since we can verify a given partitioning of V easily. <p> We would like to thank Yossi Azar and Yishay Mansour for letting us include their suggestions regarding universal sequences (Subsection 3.2). We thank Amos Fiat and Uzi Vishkin for helpful discussions. We thank Tao Jiang and Ming Li for pointers to references <ref> [2, 13] </ref>.
Reference: [14] <author> V. Sarkar. </author> <title> Instruction reordering for fork-join parallelism. </title> <booktitle> Proc. of ACM SIGPLAN-PLDI Conf., </booktitle> <pages> pages 322-336 (1990). </pages>
Reference-contexts: There is a DAG that reflects all the data dependences among the vertices. In a fork-join model, the only operations available for expressing parallelism are fork (spawn a vertex's execution as a new thread of control), and join (wait for all previously forked threads to complete). Sarkar <ref> [14] </ref> investigated the problem of generating maximally parallel code using only fork and join operations to correctly satisfy all the control and data dependences in the program. <p> We construct an instance of the shortest common supersequence problem for which the integrality gap, i.e., the ratio of the integral and fractional optima, is at least ( 1)=4. Details will be provided in the full version of the paper. Fork-Join Problem: Sarkar <ref> [14] </ref> presents a heuristic for solving the fork-join problem, with no analysis, and conjectures that his heuristic has a constant worst case guarantee. We have been able to construct an example for which Sarkar's algorithm has a performance of (log n) times the optimal cost, disproving his conjecture.
Reference: [15] <author> T. Sellis. </author> <title> Multiple-query optimization. </title> <journal> Transactions on Database Systems, </journal> <volume> Vol 13(1): </volume> <pages> 23-52, </pages> <year> (1988). </year>
Reference-contexts: In particular, they discuss a variety of heuristics, with an average case analysis for them, as well as empirical results. Other applications of overlapping operators arise in databases when we try to do multiple query optimization <ref> [15] </ref>. A problem related to the Loading Time Schedul get cash (grocery store) (post-office) (grocery store) (home) (grocery store) get coupon (post-office) recycle bags buy ice-cream buy stamps post letters ing Problem is the Shortest Common Supersequence problem [6, problem SR8].
References-found: 15

