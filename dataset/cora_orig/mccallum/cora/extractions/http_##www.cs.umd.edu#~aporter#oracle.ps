URL: http://www.cs.umd.edu/~aporter/oracle.ps
Refering-URL: http://www.cs.umd.edu/~aporter/html/references2.html
Root-URL: 
Email: flalita,vottag@bell-labs.com  aporter@cs.umd.edu.  cpg@cs.utexas.edu.  jcr@research.att.com  
Title: Specification-based Testing of Reactive Software: Tools and Experiments  
Author: Lalita Jategaonkar Jagadeesan Adam Porter Carlos Puchol J. Christopher Ramming and Lawrence G. Votta 
Keyword: Specification-based Testing, Reactive Systems, Temporal Logic, Empirical Studies  
Affiliation: Department of Computer Science, University of Maryland at  Department of Computer Sciences, The University of Texas at  
Address: Rd., Naperville, IL 60566 (USA),  College Park.  Austin,  
Note: Software Production Research Department, Bell Laboratories, 1000 E. Warrenville  This work is supported in part by a National Science Foundation Faculty Early Career Development Award, CCR-9501354  This work was partially supported by a Fulbright fellowship at The University of Texas at Austin. This work was performed while the author was visiting Bell Laboratories Innovative Services Research Department, AT&T Laboratories,  
Abstract: Testing commercial software is expensive and time consuming. Automated testing methods promise to save a great deal of time and money throughout the software industry. One approach that is well-suited for the reactive systems found in telephone switching systems is specification-based testing. We have built a set of tools to automatically test software applications for violations of safety properties expressed in temporal logic. Our testing system automatically constructs finite state machine oracles corresponding to safety properties, builds test harnesses, and integrates them with an application. The test harness then generates inputs automatically to test the application. We describe a study examining the feasibility of this approach for testing industrial applications. To conduct this study we formally modeled an Automatic Protection Switching system (APS), which is an application common to many telephony systems. We then asked a number of computer science graduate students to develop several versions of the APS and use our tools to test them. We found that the tools are very effective, save significant amounts of human effort (at the expense of machine resources), and are easy to use. We also dis cuss improvements that are needed before we can use the tools with professional developers building commercial products. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ardis, J. Chaves, L. Jagadeesan, P. Mataga, C. Puchol, M. Staskauskas, and J. Von Olnhausen. </author> <title> A framework for evaluating specification methods for reactive systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(6) </volume> <pages> 378-389, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: The purpose of this system is to manage M redundant resources such as phone lines to ensure that N &lt; M of the highest-quality resources are always selected for use. In earlier work, Ardis et al. <ref> [1] </ref> used temporal logic safety properties to formally specify the APS requirements. Based on this specification, we developed thirty APS implementations and tested them on literally millions of test cases. We found that our toolset automatically reveals violations of the requirements. <p> A TELECOMMUNICATIONS APPLICATION The Automatic Protection Switching System As described in <ref> [1] </ref>, communication channels bridging switching systems need to interface to components manufactured by different vendors. In order to facilitate cooperation between components, standards have been established. One of the standards for maintaining connectivity is called "Automatic Protection Switching (APS)" [2]. <p> The output of the system consists of the state of the switch that selects the current communication line. As we described earlier, the requirements of the APS were formally specified as part of a formal methods case study by Ardis et al. <ref> [1] </ref>. We used this specification as the starting point for the following feasibility study. FEASIBILITY STUDY We conducted a feasibility study to understand the strengths and weaknesses of our testing tools.
Reference: [2] <author> Bellcore. </author> <title> Synchronous optical network (SONET) transport systems: Common generic criteria. </title> <type> Technical Report TR-NWT-000253, Issue 2, </type> <institution> Bellcore, </institution> <year> 1991. </year>
Reference-contexts: In order to assess the suitability and advantages of our approach on industrial systems, we have applied our toolset to several implementations of a Automatic Protection Switching (APS) system <ref> [2] </ref>. The purpose of this system is to manage M redundant resources such as phone lines to ensure that N &lt; M of the highest-quality resources are always selected for use. In earlier work, Ardis et al. [1] used temporal logic safety properties to formally specify the APS requirements. <p> In order to facilitate cooperation between components, standards have been established. One of the standards for maintaining connectivity is called "Automatic Protection Switching (APS)" <ref> [2] </ref>. The idea is to provide more than one line for each communication channel (in switching systems, reliability is often provided by duplicating critical elements). If a line degrades or fails, a backup line, called the "protection line" is used instead.
Reference: [3] <author> G. Berry and G. Gonthier. </author> <title> The esterel synchronous programming language: design, semantics, </title> <booktitle> implementation. Science of Computer Programming, </booktitle> <volume> 19 </volume> <pages> 87-152, </pages> <year> 1992. </year>
Reference-contexts: Finally, we discuss the challenges and opportunities that would come from using our tools in industrial software development. TESTING THEORY AND TOOLS The Computation Model Our tools test reactive applications [6]. Specifically, this means that applications must conform to the synchrony hypothesis <ref> [3] </ref>, which implies that applications must appear to operate in discrete "steps." The application receives a set of inputs, reacts to the inputs by computing and producing a set of outputs, and then quiesces, waiting for new inputs. <p> They are constructed through the following chain of events. First, safety properties are specified by the system engineer using the temporal logic syntax described earlier [10]. Next, as an engineering convenience, we translate the temporal logic formulae into programs written in Esterel <ref> [3] </ref>. These programs express deterministic finite-state machines, which we extract easily by invoking the Esterel compiler. The resulting information is then analyzed and eventually linked with the test harness and the application.
Reference: [4] <author> L. Dillon, G. Kutty, L. Moser, P. M. Melliar-Smith, and Y. Ramakrishna. </author> <title> A graphical interval logic for specifying concurrent systems. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 3(2) </volume> <pages> 131-165, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: We found that our toolset automatically reveals violations of the requirements. This work was inspired by Dillon&Yu [5], who present a method for testing reactive software against specifications written in a version of temporal logic ([12]) called Graphical Interval Logic <ref> [4] </ref>. Properties written in this logic are translated into FSM's whose language is the set of executions that violate the given property; the resulting FSM's are then used to generate test inputs.
Reference: [5] <author> L. Dillon and Q. Yu. </author> <title> Oracles for checking temporal properties of concurrent systems. </title> <journal> Software Engineering Notes, </journal> <volume> 19(5) </volume> <pages> 140-153, </pages> <month> December </month> <year> 1994. </year> <booktitle> Proceedings of the 2nd ACM SIGSOFT Symposium on Foundations of Software Engineering. </booktitle>
Reference-contexts: Based on this specification, we developed thirty APS implementations and tested them on literally millions of test cases. We found that our toolset automatically reveals violations of the requirements. This work was inspired by Dillon&Yu <ref> [5] </ref>, who present a method for testing reactive software against specifications written in a version of temporal logic ([12]) called Graphical Interval Logic [4].
Reference: [6] <author> N. Halbwachs. </author> <title> Synchronous Programming of Reactive Systems. </title> <publisher> Kluwer Academic, </publisher> <year> 1993. </year>
Reference-contexts: We then present a case study and empirical observations. Finally, we discuss the challenges and opportunities that would come from using our tools in industrial software development. TESTING THEORY AND TOOLS The Computation Model Our tools test reactive applications <ref> [6] </ref>. Specifically, this means that applications must conform to the synchrony hypothesis [3], which implies that applications must appear to operate in discrete "steps." The application receives a set of inputs, reacts to the inputs by computing and producing a set of outputs, and then quiesces, waiting for new inputs.
Reference: [7] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: They have constructors, destructors, and driver methods. Also, since some of the system design in the telecommunications industry is done using Object-oriented CASE tools such as Real-Time Object-Oriented Modeling (ROOM)/ObjecTime [17] and O-Charts/O-MATE [8] an object-oriented extension of Statecharts <ref> [7] </ref>, there is a clear opportunity to create test-enabled applications in conjunction with these executable design tools. This looks promising because these objects satisfy the synchrony hypothesis by design [17].
Reference: [8] <author> D. Harel and E. Gery. </author> <title> Executable object modeling with statecharts. </title> <booktitle> In Proceedings of the 18th International Symposium on Software Engineering, </booktitle> <pages> pages 246-257, </pages> <year> 1996. </year>
Reference-contexts: An interesting observation is that object-oriented designs naturally conform to our interface. They have constructors, destructors, and driver methods. Also, since some of the system design in the telecommunications industry is done using Object-oriented CASE tools such as Real-Time Object-Oriented Modeling (ROOM)/ObjecTime [17] and O-Charts/O-MATE <ref> [8] </ref> an object-oriented extension of Statecharts [7], there is a clear opportunity to create test-enabled applications in conjunction with these executable design tools. This looks promising because these objects satisfy the synchrony hypothesis by design [17].
Reference: [9] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to automata theory, languages, and computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: This finite-state machine is a finite-state acceptor of all the violating executions; using the standard view of finite-state acceptors as generators <ref> [9] </ref>, we can hence use these finite-state machines to generate offending executions and then check whether the application under test has the corresponding behavior: if so, the application violates the safety property. We refer to these finite-state machines as oracles.
Reference: [10] <author> L. Jagadeesan, C. Puchol, and J. Von Olnhausen. </author> <title> Safety property verification of esterel programs and applications to telecommunications software. </title> <booktitle> In Proceedings of the 7th International Conference on Computer Aided Verification, Volume 939 of the Lecture Notes in Computer Science, </booktitle> <pages> pages 127-140, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: We have used standard temporal logic rather than Graphical Interval Logic mainly to take advantage of some temporal logic tools that we had developed in the course of earlier work <ref> [10] </ref>. Richardson et al. [16] also presents an approach for deriving oracles from formal multi-paradigm specifications. Our approach is focused on temporal logic safety properties, and oracles are derived automatically. Our work extends these both these efforts through an industrial case study. <p> The safety properties themselves are composed of signals, the standard boolean operators, simple temporal operators: previous, since, has-always-been, once, and back-to, and a "bounded-response" operator (property S1 in Figure 1 is an example of a bounded response property). See <ref> [12, 10] </ref> for formal definitions of the operators. The Theory We have developed techniques and tools that automatically test whether a software application satisfies temporal logic safety properties. <p> Oracle State Machines Oracle state machines are the mechanism by which an application's flaws are revealed. They are constructed through the following chain of events. First, safety properties are specified by the system engineer using the temporal logic syntax described earlier <ref> [10] </ref>. Next, as an engineering convenience, we translate the temporal logic formulae into programs written in Esterel [3]. These programs express deterministic finite-state machines, which we extract easily by invoking the Esterel compiler. The resulting information is then analyzed and eventually linked with the test harness and the application.
Reference: [11] <author> L. Jagadeesan, C. Puchol, and J. Von Olnhausen. </author> <title> A formal approach to reactive systems software: A telecommunications application in Esterel. Formal Methods in System Design, </title> <type> 8(2), </type> <month> March </month> <year> 1996. </year>
Reference-contexts: Even when existing switch software is not compatible with our testing technique, it may still be possible to upgrade the software to satisfy the tool's requirements. For example, in a separate study <ref> [11] </ref>, we re-wrote part of the 5ESS software. This new system satisfied the synchrony hypothesis and would have met our testing tool's interface requirements. Modular Design Our testing technique involves a form of black-box testing.
Reference: [12] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems, Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Consequently, safety properties are sufficient to describe the intended behavior of most reactive systems. Temporal logic is a popular formalism for specifying safety properties <ref> [12] </ref>. The specifications used by our tool are written with a specially designed notation. <p> The safety properties themselves are composed of signals, the standard boolean operators, simple temporal operators: previous, since, has-always-been, once, and back-to, and a "bounded-response" operator (property S1 in Figure 1 is an example of a bounded response property). See <ref> [12, 10] </ref> for formal definitions of the operators. The Theory We have developed techniques and tools that automatically test whether a software application satisfies temporal logic safety properties.
Reference: [13] <author> K. Martersteck and A. Spencer. </author> <title> Introduction to the 5ESS(TM) switching system. </title> <journal> AT&T Technical Journal, </journal> <volume> 64(6 part </volume> 2):1305-1314, July-August 1985. 
Reference-contexts: Examples of reactive systems include elevators, traffic controllers, and avionics controllers; most real-time systems are also reactive in nature. Reactive systems are also ubiquitous in the software for Lucent Technologies' 5ESS R fl telephone switching system <ref> [13] </ref>, which provides telecommunications ser vices. Reactive systems are often safety-critical and must be thoroughly tested to ensure that they meet high-assurance requirements. Since the number of potential input sequences that a reactive system must handle is infinite, much testing is needed to establish confidence in the system.
Reference: [14] <author> J. Musa, A. Iannino, and K. Okumoto. </author> <title> Software Reliability: Measurement, Prediction, Application. </title> <publisher> McGraw-Hill Book Company, </publisher> <year> 1987. </year> <note> See pages 227ff. </note>
Reference-contexts: Another enhancement to our tool that might be useful is to allow inputs to be selected with non-uniform weights. Sometimes testers may wish to exercise the systems in conditions closely approximating its intended use, for example, using notions of operational profiling <ref> [14] </ref>. Other times they may want to overload the system with a certain type or sequence of operations, for example, when performing stress-testing. Costs and Benefits One aspect of the tool's cost-benefits is that it is designed to ensure conformance to certain specifications.
Reference: [15] <author> D. Richardson. TAOS: </author> <title> Testing with analysis and oracle support. </title> <booktitle> In Proceedings of the International Symposium on Software Testing and Analysis, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: Dillon and Yu indicate that they are currently developing tools to support this method, and that they will be integrated with Richardson's TAOS <ref> [15] </ref> test management system. We have used standard temporal logic rather than Graphical Interval Logic mainly to take advantage of some temporal logic tools that we had developed in the course of earlier work [10]. Richardson et al. [16] also presents an approach for deriving oracles from formal multi-paradigm specifications.
Reference: [16] <author> D. Richardson, S. Aha, and T. O'Malley. </author> <title> Specification-based test oracles for reactive systems. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: We have used standard temporal logic rather than Graphical Interval Logic mainly to take advantage of some temporal logic tools that we had developed in the course of earlier work [10]. Richardson et al. <ref> [16] </ref> also presents an approach for deriving oracles from formal multi-paradigm specifications. Our approach is focused on temporal logic safety properties, and oracles are derived automatically. Our work extends these both these efforts through an industrial case study. <p> We are currently exploring this connection. The Signal Mapping Problem One difficult problem that arises in practice involves mapping specification names onto implementation names. This can be necessary when the specifications are written at a higher level of abstraction than the implementation. The work of Richardson et al <ref> [16] </ref> takes a significant step towards solving this problem, but more work is still needed in this direction. Tool Enhancements Although our current tools are written in C, the test system is inherently language-independent.
Reference: [17] <author> B. Selic, G. Gullekson, and P. Ward. </author> <title> Real-Time Object Oriented Modeling. </title> <publisher> John Wiley and Sons, Inc., </publisher> <year> 1994. </year>
Reference-contexts: An interesting observation is that object-oriented designs naturally conform to our interface. They have constructors, destructors, and driver methods. Also, since some of the system design in the telecommunications industry is done using Object-oriented CASE tools such as Real-Time Object-Oriented Modeling (ROOM)/ObjecTime <ref> [17] </ref> and O-Charts/O-MATE [8] an object-oriented extension of Statecharts [7], there is a clear opportunity to create test-enabled applications in conjunction with these executable design tools. This looks promising because these objects satisfy the synchrony hypothesis by design [17]. <p> is done using Object-oriented CASE tools such as Real-Time Object-Oriented Modeling (ROOM)/ObjecTime <ref> [17] </ref> and O-Charts/O-MATE [8] an object-oriented extension of Statecharts [7], there is a clear opportunity to create test-enabled applications in conjunction with these executable design tools. This looks promising because these objects satisfy the synchrony hypothesis by design [17]. The objects are essentially hierarchical finite-state machines, whose inputs are the external inputs to the system and the outputs from other objects. We are currently exploring this connection. The Signal Mapping Problem One difficult problem that arises in practice involves mapping specification names onto implementation names.
Reference: [18] <author> P. Wolper, M. Vardi, and A. Sistla. </author> <title> Reasoning about infinite computation paths. </title> <booktitle> In IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 185-194, </pages> <year> 1983. </year>
Reference-contexts: Thus, our testing system has two goals: to generate test cases that lead to violations, and to identify violations as quickly as possible and without human intervention. To achieve these goals, our system uses the following important fact about safety properties <ref> [18] </ref>: For any safety property, there exists a finite state machine whose language is the set of all possible finite executions that violate the prop erty.
Reference: [19] <institution> Personal communication. Mary Zajac. </institution>
Reference-contexts: We need to develop a better understanding of error coverage provided by this approach. One the other hand, we saw that this approach was excellent at finding problems involving rare scenarios. Since this is the most frequent root cause of problems detected in the field <ref> [19] </ref> (when the cost to repair defects is by far the greatest), the tool is very useful in these cases. The value of this tool depends on a tradeoff between machine expense and human expense.
References-found: 19

