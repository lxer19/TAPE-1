URL: http://www.it.kth.se/docs/Reports/paradis/pu-TCS-final.ps.Z
Refering-URL: http://www.it.kth.se/docs/Reports/paradis/
Root-URL: http://www.it.kth.se
Title: Computing in Unpredictable Environments: Semantics, Reduction Strategies, and Program Transformations  
Author: Bjorn Lisper 
Keyword: formal semantics, program transformations, nondetermin-ism, reduction systems, recursive program schemes.  
Address: 204, S-164 40 Kista, SWEDEN  
Affiliation: Department of Teleinformatics, Royal Institute of Technology, Electrum  
Abstract: We study systems where deterministic computations take place in environments which may behave nondeterministically. We give a simple formalization by unions of abstract reduction systems, on which various semantics can be based in a straightforward manner. We then prove that under a simple condition on the reduction systems, the following holds: reduction strategies which are cofinal for the deterministic reduction system will implement the semantics for the combined system, provided the environment behaves in a "fair" manner, and certain program transformations, such as folding and unfolding with respect to deterministic rules, will preserve the semantics. An application is evaluation strategies and program transformations for concurrent languages. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. Levy. </author> <title> Explicit substitutions. </title> <booktitle> In Proc. Seventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 31-46, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: We believe that for such languages the correctness can be proved for combined reduction strategies, employing a normalizing (rather than cofinal) strategy for certain terms. Second, laziness also implies sharing of already computed results (call-by-need rather than call-by-name), which must be modeled in a formalism such as explicit substitutions <ref> [1] </ref> or graph reduction systems [2, 6]. The difference between call-by-need and call-by-name is indeed crucial and must be taken into account.
Reference: 2. <author> Z. M. Ariola and Arvind. </author> <title> Properties of a first-order functional language with sharing. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 146 </volume> <pages> 69-108, </pages> <year> 1995. </year>
Reference-contexts: Sometimes we will abuse notation and write a even when considered as a relation, i.e. S Consider an ARS hA; !i, a c.p.o. hC; vi (possibly without bottom), and a mapping f: A ! C which is monotone w.r.t. ! and v. Cf. <ref> [2, 27, 37] </ref>, and also [5, Lemma 14.3.7]. f is then a monotone interpretation of hA; !i into hC; vi, and v models the increase of information as a computation proceeds along !. Any !-computation a yields a l.u.b. <p> It is easy to verify that [R] is indeed a monotone interpretation of hT; ! R i into hT 1 ? ; vi. A similar construct is the interpretation of Nivat [27] for recursive applicative program schemes. For graph rewriting systems, the instant semantics of Ariola and Arvind <ref> [2] </ref> corresponds to [R]. A third example is Wadsworth's best direct approximants for -terms under fi-reduction [37] (see also [5, Definition 14.3.6]). Since [R] is a monotone interpretation, R defines a semantics S (t; [R]; ! R ), denoted S R (t), w.r.t. R for terms t in T . <p> Second, laziness also implies sharing of already computed results (call-by-need rather than call-by-name), which must be modeled in a formalism such as explicit substitutions [1] or graph reduction systems <ref> [2, 6] </ref>. The difference between call-by-need and call-by-name is indeed crucial and must be taken into account.
Reference: 3. <author> J. Armstrong, R. Virding, and M. Williams. </author> <title> Concurrent Programming in ER-LANG. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Our framework is abstract and thus potentially applicable to a range of languages, but the ones we have mainly in mind are recursive languages with concur-rency constructs. Some existing, not referentially transparent languages in this class are Concurrent ML [30], Facile [34], and Erlang <ref> [3] </ref>. A goal of our work is to support the design of recursive languages with concurrency, where the "serial part" is referentially transparent also in the presence of nondeterminism arising from the concurrency.
Reference: 4. <author> A. Arnold, P. Naudin, and M. Nivat. </author> <title> On semantics of nondeterministic recursive program schemes. </title> <editor> In M. Nivat and J. C. Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, chapter 1, </booktitle> <pages> pages 1-33. </pages> <publisher> Cambridge University Press, </publisher> <year> 1985. </year>
Reference-contexts: The semantics we use is related to the one developed by Arnold, Naudin and Nivat for nondeterministic recursive schemes <ref> [4] </ref> and in particular to the one of Boudol [8] for first order term rewriting systems. It is also related to the theory of approximate normal forms in the -calculus [26, 37, 38]. <p> Formally, a term t can be defined as a partial function from the set of sequences of natural numbers ("positions") to operator symbols, such that dom (t) is prefix-closed and respects arities; see, e.g. <ref> [4, 14] </ref>. For p =2 dom (t), we define t (p) = ?. We can relax the conditions that arities are respected and allow also terms which are undefined at leaf positions, and we denote the set of these terms by T 1 ? .
Reference: 5. <author> H. P. Barendregt. </author> <title> The Lambda Calculus Its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1981. </year>
Reference-contexts: We can relax the conditions that arities are respected and allow also terms which are undefined at leaf positions, and we denote the set of these terms by T 1 ? . We have T ae T 1 ae T 1 ? . Cf. the Bohm trees of -calculus <ref> [5, Ch. 10] </ref>. For the operator symbols, we define a flat partial order v by ? v s and s v s for all symbols s. <p> We lift this order to terms (i.e. functions from sequences) in T 1 ? by t v t 0 iff t (p) v t 0 (p) for all sequences p (cf. <ref> [5, Ch. 10.2] </ref>). It is straightforward to show that every ascending chain t 0 v t 1 v in T 1 ? has a least upper bound in T 1 ? . The maximal elements are exactly those in T 1 . <p> Sometimes we will abuse notation and write a even when considered as a relation, i.e. S Consider an ARS hA; !i, a c.p.o. hC; vi (possibly without bottom), and a mapping f: A ! C which is monotone w.r.t. ! and v. Cf. [2, 27, 37], and also <ref> [5, Lemma 14.3.7] </ref>. f is then a monotone interpretation of hA; !i into hC; vi, and v models the increase of information as a computation proceeds along !. Any !-computation a yields a l.u.b. <p> A similar construct is the interpretation of Nivat [27] for recursive applicative program schemes. For graph rewriting systems, the instant semantics of Ariola and Arvind [2] corresponds to [R]. A third example is Wadsworth's best direct approximants for -terms under fi-reduction [37] (see also <ref> [5, Definition 14.3.6] </ref>). Since [R] is a monotone interpretation, R defines a semantics S (t; [R]; ! R ), denoted S R (t), w.r.t. R for terms t in T . This semantics consists of all trees, possibly partial and/or infinite, which are limits of "fair" t-rooted computations under [R]. <p> If T is the set of pure -terms and if fi is the CRS defining fi-reduction (with reduction relation ! fi ) to head normal form, then the single element of S fi (t) is very similar to the Bohm tree for t <ref> [5] </ref>. 7 Reduction Strategies for Systems with Computational and Descriptive Components In the setting of abstract reduction systems, we can model computational and descriptive components simply as reduction systems over a set A, and a system comprised of such components as the union of the respective reduction systems.
Reference: 6. <author> H. P. Barendregt, M. C. J. D. van Eekelen, J. R. W. Glauert, J. R. Kennaway, M. J. Plasmeijer, and M. R. Sleep. </author> <title> Term graph rewriting. </title> <booktitle> In Proc. </booktitle> <volume> PARLE'87 vol. 2, </volume> <booktitle> Volume 259 of Lecture Notes in Comput. Sci., </booktitle> <pages> pages 149-158. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Second, laziness also implies sharing of already computed results (call-by-need rather than call-by-name), which must be modeled in a formalism such as explicit substitutions [1] or graph reduction systems <ref> [2, 6] </ref>. The difference between call-by-need and call-by-name is indeed crucial and must be taken into account.
Reference: 7. <author> G. Berry and G. Boudol. </author> <title> The chemical abstract machine. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 96 </volume> <pages> 217-248, </pages> <year> 1992. </year>
Reference-contexts: Furthermore, we introduce auxiliary term rewriting rules, viz.: (P jQ)jR ! P j (QjR) (4) P jQ ! QjP (6) They express equivalence modulo AC for parallel composition. (Cf. "chemical abstract machines" <ref> [7] </ref>.) Their permutative nature gives rise to cyclic, infinite computations which are in some sense artificial. However, these computations will be strictly dominated whenever progress can be made through some of the first rules. Thus, they will not contribute to the semantics.
Reference: 8. <author> G. Boudol. </author> <title> Computational semantics of term rewriting systems. </title> <editor> In M. Nivat and J. C. Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, chapter 5, </booktitle> <pages> pages 170-236. </pages> <publisher> Cambridge University Press, </publisher> <year> 1985. </year>
Reference-contexts: The semantics we use is related to the one developed by Arnold, Naudin and Nivat for nondeterministic recursive schemes [4] and in particular to the one of Boudol <ref> [8] </ref> for first order term rewriting systems. It is also related to the theory of approximate normal forms in the -calculus [26, 37, 38]. What sets our work apart is that we formulate the semantics and prove some results in the more abstract setting of binary relations. <p> We can now define the semantics for an element a 2 A, given a monotone interpretation f of hA; !i into hC; vi (cf. <ref> [8, Ch. 4.2] </ref>): Definition 7. The semantics of a 2 A w.r.t. the monotone interpretation f and !, S (a; f; !), is the set F f (a) j a is a-rooted and not strictly dominated by any computation g.
Reference: 9. <author> R. M. Burstall and J. Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <month> Jan. </month> <year> 1977. </year>
Reference-contexts: They also hold for systems with higher order operations, which is true as well for the recent work on correctness for transformations of deterministic programs by Sands [32]. Our results provide some support for program transformation systems for program optimization <ref> [9, 16] </ref> and partial evaluation of nondeterministic languages. Semantics-preserving partial evaluation of such languages is listed as the "challenging problem no. 10.9" in [19]. The only partial evaluator for such languages that we are aware of is for the concurrent constraint programming language AKL [31].
Reference: 10. <author> B. Courcelle. </author> <title> Infinite trees in normal form and recursive equations having a unique solution. </title> <journal> Math. System. Theory, </journal> <volume> 13 </volume> <pages> 131-180, </pages> <year> 1979. </year>
Reference-contexts: On the other hand, the rather detailed natural semantics of Hughes and Moran gives more information about how to actually implement a language with these operations. Our results about folding and unfolding extend classical results <ref> [10, 11, 12, 25] </ref> for deterministic systems. They also hold for systems with higher order operations, which is true as well for the recent work on correctness for transformations of deterministic programs by Sands [32].
Reference: 11. <author> B. Courcelle. </author> <title> Equivalence and transformations of regular systems. </title> <journal> Theoret. Com-put. Sci., </journal> <volume> 42 </volume> <pages> 1-122, </pages> <year> 1986. </year>
Reference-contexts: On the other hand, the rather detailed natural semantics of Hughes and Moran gives more information about how to actually implement a language with these operations. Our results about folding and unfolding extend classical results <ref> [10, 11, 12, 25] </ref> for deterministic systems. They also hold for systems with higher order operations, which is true as well for the recent work on correctness for transformations of deterministic programs by Sands [32]. <p> Folding is, however, not always correct. In the case of folding with a single rule it is sufficient to demand that a rule is not folded with itself. For folding with several rules, it is relatively straightforward to extend this condition to "restricted folding-unfolding" <ref> [11, 12] </ref>. Before we show the main theorems, we must however verify that some properties of first order substitutions carry over to valuations. Lemma 28. For all valuations OE, metaterms s, t and positions p 2 dom (t) holds that OE (s [p t]) = OE (s)[p OE (t)]. Proof. <p> We prove correctness of folding under the simplifying condition that a rule is not folded with itself. This corresponds to "restricted folding-unfolding" in <ref> [11, 12] </ref>. Theorem 35. <p> This yields the correct semantics for the unfolded term. The correctness of folding was proved under the condition that a rule would not be used to fold itself, which corresponds to the restricted folding-unfolding condition by Courcelle <ref> [11, 12] </ref>. As observed by Sands [32], this condition is quite restrictive since it essentially prohibits the formation of new recursive definitions. This limits the applicability to program transformations and partial evaluation.
Reference: 12. <author> B. Courcelle. </author> <title> Recursive applicative program schemes. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, chapter 9, </booktitle> <pages> pages 459-492. </pages> <publisher> Elsevier Science Publishers B. V., </publisher> <year> 1990. </year>
Reference-contexts: be contrasted with "don't care" nondeterminism which gives a looser, relational specification of the computational component, where a number of outcomes are allowed for a given input and the system is free to choose. 2 Related Work Our work is strongly related to the theory of recursive applicative program schemes <ref> [12, 27] </ref>. The semantics we use is related to the one developed by Arnold, Naudin and Nivat for nondeterministic recursive schemes [4] and in particular to the one of Boudol [8] for first order term rewriting systems. <p> On the other hand, the rather detailed natural semantics of Hughes and Moran gives more information about how to actually implement a language with these operations. Our results about folding and unfolding extend classical results <ref> [10, 11, 12, 25] </ref> for deterministic systems. They also hold for systems with higher order operations, which is true as well for the recent work on correctness for transformations of deterministic programs by Sands [32]. <p> For deterministic recursive applicative program schemes there is a classical theory for fold/unfold-transformations, see, e.g., <ref> [12, 25] </ref>. The results in this section can be seen as generalizations of some classical results to the nondeterministic case. Our theory is CRS based: thus, it covers also higher order programs. <p> Folding is, however, not always correct. In the case of folding with a single rule it is sufficient to demand that a rule is not folded with itself. For folding with several rules, it is relatively straightforward to extend this condition to "restricted folding-unfolding" <ref> [11, 12] </ref>. Before we show the main theorems, we must however verify that some properties of first order substitutions carry over to valuations. Lemma 28. For all valuations OE, metaterms s, t and positions p 2 dom (t) holds that OE (s [p t]) = OE (s)[p OE (t)]. Proof. <p> We prove correctness of folding under the simplifying condition that a rule is not folded with itself. This corresponds to "restricted folding-unfolding" in <ref> [11, 12] </ref>. Theorem 35. <p> This yields the correct semantics for the unfolded term. The correctness of folding was proved under the condition that a rule would not be used to fold itself, which corresponds to the restricted folding-unfolding condition by Courcelle <ref> [11, 12] </ref>. As observed by Sands [32], this condition is quite restrictive since it essentially prohibits the formation of new recursive definitions. This limits the applicability to program transformations and partial evaluation.
Reference: 13. <author> N. Dershowitz, S. Kaplan, and D. A. Plaisted. </author> <title> Rewrite, rewrite, rewrite, rewrite, </title> <journal> rewrite,. . . . Theoret. Comput. Sci., </journal> <volume> 83(1) </volume> <pages> 71-96, </pages> <year> 1991. </year>
Reference-contexts: Since CP is equivalent to confluence for countable reduction systems [23], confluence thus implies "uniqueness of infinite normal forms" for such systems. This is in contrast to the situation in transfinite term rewriting <ref> [13, 21] </ref>. There, the transfinite reduction relation may be nonconfluent even when the finite relation is, which then makes it possible to have several infinite normal forms. The reason is, roughly speaking, that the definitions of convergence for sequences of terms allow some "nonfair" infinite sequences to converge.
Reference: 14. <author> J. A. Goguen, J. W. Thatcher, E. G. Wagner, and J. B. Wright. </author> <title> Initial algebra semantics and continuous algebras. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 24(1) </volume> <pages> 68-95, </pages> <month> Jan. </month> <year> 1977. </year>
Reference-contexts: Formally, a term t can be defined as a partial function from the set of sequences of natural numbers ("positions") to operator symbols, such that dom (t) is prefix-closed and respects arities; see, e.g. <ref> [4, 14] </ref>. For p =2 dom (t), we define t (p) = ?. We can relax the conditions that arities are respected and allow also terms which are undefined at leaf positions, and we denote the set of these terms by T 1 ? .
Reference: 15. <author> G. Huet. </author> <title> Confluent reductions: Abstract properties and applications to term rewriting systems. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 27(4) </volume> <pages> 797-821, </pages> <month> Oct. </month> <year> 1980. </year>
Reference-contexts: We believe that our results can support the design of nondeterministic languages where it is more evident what "semantically correct" partial evaluation is. 3 Preliminaries In this paper, we will use (abstract) reduction systems <ref> [15, 23] </ref> to give semantics of computations. We give the definitions of the most central concepts being used here. <p> Lemma 28. For all valuations OE, metaterms s, t and positions p 2 dom (t) holds that OE (s [p t]) = OE (s)[p OE (t)]. Proof. The same lemma but for first order substitutions is stated in <ref> [15, Proposition 3.5] </ref>. The proof is by induction over the structure of s, and the extension to valuations is straightforward. Q.E.D. Lemma 28 yields the following corollary, by choosing t = s=p and considering the LHS and RHS at position p: Corollary 29. <p> Here, we have used the identity t [p t 0 ][p t 00 ] = t [p t 00 ] which follows from <ref> [15, Proposition 3.1] </ref> and the fact that t=p = (t 0 ) when s ! t is folded by s 0 ! t 0 at p. F [R](u) follows. Now assume that F [R](u) 2 S R (u).
Reference: 16. <author> G. Huet and B. Lang. </author> <title> Proving and applying program transformations expressed with second-order patterns. </title> <journal> Acta Inform., </journal> <volume> 11(1) </volume> <pages> 31-55, </pages> <month> Jan. </month> <year> 1978. </year>
Reference-contexts: They also hold for systems with higher order operations, which is true as well for the recent work on correctness for transformations of deterministic programs by Sands [32]. Our results provide some support for program transformation systems for program optimization <ref> [9, 16] </ref> and partial evaluation of nondeterministic languages. Semantics-preserving partial evaluation of such languages is listed as the "challenging problem no. 10.9" in [19]. The only partial evaluator for such languages that we are aware of is for the concurrent constraint programming language AKL [31].
Reference: 17. <author> J. Hughes and A. Moran. </author> <title> Making choices lazily. </title> <booktitle> In Proc. Seventh Conference on Functional Programming Languages and Computer Architecture. </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: A language that seem to fit this charter is Concurrent Haskell [28], a lazy functional language extended with concurrency primitives. A comparison can be made with Hughes' and Moran's work <ref> [17] </ref>, where they give a natural semantics for normal order -calculus plus McCarty's amb operator for nondeterministic choice. It seems that this combination can be modeled in our framework as well. This would give a very simple semantics in comparison, and make our results about program transformations applicable.
Reference: 18. <author> T. Johnsson. </author> <title> Lambda Lifting: Transforming Programs to Recursive Equations. </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Proc. Functional Programming Languages and Computer Architecture, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 190-203, </pages> <address> Nancy, France, Sept. 1985. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: The semantics-preserving transformations include symbolic folding and un-folding of (possibly higher order) term rewriting rules. Program transformations described by such operations include fold-unfold transformations of recursive programs, but also "program simplification" like evaluation of constant subex-pressions, and reverse fi-reduction as used in lambda lifting <ref> [18] </ref>. Our choice to consider "semantical completeness" or "preservation of semantics" as "preserving all normal forms" is because we use nondeterminism to model possible actions of an environment which can be described but not controlled.
Reference: 19. <author> N. D. Jones. </author> <title> Challenging problems in partial evaluation and mixed computation. </title> <editor> In D. Bjorner, A. P. Ershov, and N. D. Jones, editors, </editor> <title> Partial Evaluation and Mixed Computation. </title> <booktitle> Proceedings of the IFIP TC2 Workshop, </booktitle> <address> Gammel Avernaes, Den-mark, </address> <month> Oct. </month> <year> 1987, </year> <pages> pages 1-14. </pages> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Our results provide some support for program transformation systems for program optimization [9, 16] and partial evaluation of nondeterministic languages. Semantics-preserving partial evaluation of such languages is listed as the "challenging problem no. 10.9" in <ref> [19] </ref>. The only partial evaluator for such languages that we are aware of is for the concurrent constraint programming language AKL [31]. But this partial evaluator gives correct results only under a number of restrictions on the program and assumptions about the intended semantics.
Reference: 20. <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall, </publisher> <address> Hertfordshire, UK, </address> <year> 1993. </year>
Reference-contexts: A prime example is a purely functional program. Purely functional programming is highly appropriate for describing purely computational tasks (as long as explicit resource handling for efficiency is not a concern, anyway). The simple semantics makes it particularly simple to analyze and transform functional programs: see, for instance, <ref> [20, 35] </ref>. There are many situations, however, where the descriptive component cannot be neglected. Systems for control of finite resources (such as various servers), operating systems, embedded systems they all rely on the ability to model the environment where the specified computations are to take place.
Reference: 21. <author> R. Kennaway, J. W. Klop, R. Sleep, and F.-J. de Vries. </author> <title> Transfinite reductions in orthogonal term rewriting systems. </title> <journal> Information and Computation, </journal> <volume> 119(1) </volume> <pages> 18-38, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Since CP is equivalent to confluence for countable reduction systems [23], confluence thus implies "uniqueness of infinite normal forms" for such systems. This is in contrast to the situation in transfinite term rewriting <ref> [13, 21] </ref>. There, the transfinite reduction relation may be nonconfluent even when the finite relation is, which then makes it possible to have several infinite normal forms. The reason is, roughly speaking, that the definitions of convergence for sequences of terms allow some "nonfair" infinite sequences to converge.
Reference: 22. <author> J. W. Klop. </author> <title> Combinatory Reduction Systems. </title> <type> PhD thesis, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <year> 1980. </year> <note> Mathematical Centre Tracts Nr. 127. </note>
Reference-contexts: The results on fold-unfold program transformations are obtained for an instance of the abstract semantics where computations take place on terms and the binary relation is given by a Combinatory Reduction System <ref> [22, 24] </ref>. Some of our results concern referential transparency. There is an interesting discussion of referential transparency and unfoldability in [33]; one can say that commutation of the computational and descriptive reduction systems preserves referential transparency for the computational system also in a non-deterministic environment. <p> We are especially interested in reduction systems over terms - "term reduction systems" (including first order term rewriting systems (TRS), as well as -calculus with fi-reduction and more general higher order formalisms such as Klop's Combinatory Reduction Systems (CRS) <ref> [22] </ref>). We denote the set of the finite terms under discourse with T , and the set of finite and infinite terms with T 1 . <p> Therefore we give a short description of CRS here. For a full description, including formal definitions, see <ref> [22, 24] </ref>. Consider a set of terms T , constructed out of constant function symbols with fixed arity, nullary variables, and a binary abstraction operator, written [ ] (i.e., if t is a term and x is a variable, then [x]t is a term). <p> Also many results on reduction strategies carry over from orthogonal TRS'es to orthogonal CRS'es. For instance, the leftmost-outermost reduction strategy (normal order reduction) is normalizing for any left-normal CRS (all constants and functions symbols precede all metavariables in the LHS of every rule) <ref> [22] </ref>. Of particular interest are results about cofinal reduction strategies, since our results in Section 7 concern such strategies. For orthogonal CRS'es, the following result by Klop [22] applies. <p> (normal order reduction) is normalizing for any left-normal CRS (all constants and functions symbols precede all metavariables in the LHS of every rule) <ref> [22] </ref>. Of particular interest are results about cofinal reduction strategies, since our results in Section 7 concern such strategies. For orthogonal CRS'es, the following result by Klop [22] applies. A reduction strategy F is fair (or secured ) if, for any term t, there exists an n such that F n (t) does not contain any residual of any redex in t. Theorem 2 (Klop). For orthogonal CRS'es, any fair reduction strategy is co-final. <p> It is easy to verify that these rules do form an orthogonal CRS (indeed, it is even left-normal, which means that a leftmost-outermost reduction strategy is normalizing <ref> [22] </ref>). Furthermore, all these rules will be orthogonal to the rules (2) - (6) defining the semantics for the process primitives.
Reference: 23. <author> J. W. Klop. </author> <title> Term rewriting systems. </title> <editor> In S. Abramsky, D. M. Gabbay, and T. S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> vol. 2, chapter 1, </volume> <pages> pages 1-116. </pages> <publisher> Oxford University Press, Oxford, </publisher> <year> 1992. </year>
Reference-contexts: We believe that our results can support the design of nondeterministic languages where it is more evident what "semantically correct" partial evaluation is. 3 Preliminaries In this paper, we will use (abstract) reduction systems <ref> [15, 23] </ref> to give semantics of computations. We give the definitions of the most central concepts being used here. <p> Any metavariable occurring in t also occurs in s. A metavariable Z of arity k occurs only in the form Z (x 1 ; . . . ; x k ), where x 1 ; . . . ; x k are pairwise distinct variables. TRS rules <ref> [23] </ref> are exactly CRS rules with nullary metavariables only and no abstraction. But CRS rules also include reductions in systems with bound variables. <p> The limits of the computations that do contribute can be thought of as "infinite normal forms" since they represent cases where no more information can be gained. It is easy to see that if ! has the cofinality property (CP) <ref> [23] </ref>, then S (a; f; !) has a single element. Since CP is equivalent to confluence for countable reduction systems [23], confluence thus implies "uniqueness of infinite normal forms" for such systems. This is in contrast to the situation in transfinite term rewriting [13, 21]. <p> It is easy to see that if ! has the cofinality property (CP) <ref> [23] </ref>, then S (a; f; !) has a single element. Since CP is equivalent to confluence for countable reduction systems [23], confluence thus implies "uniqueness of infinite normal forms" for such systems. This is in contrast to the situation in transfinite term rewriting [13, 21]. There, the transfinite reduction relation may be nonconfluent even when the finite relation is, which then makes it possible to have several infinite normal forms.
Reference: 24. <author> J. W. Klop, V. van Oostrom, and F. van Raamsdonk. </author> <title> Combinatory reduction systems: Introduction and survey. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 121 </volume> <pages> 279-308, </pages> <year> 1993. </year>
Reference-contexts: The results on fold-unfold program transformations are obtained for an instance of the abstract semantics where computations take place on terms and the binary relation is given by a Combinatory Reduction System <ref> [22, 24] </ref>. Some of our results concern referential transparency. There is an interesting discussion of referential transparency and unfoldability in [33]; one can say that commutation of the computational and descriptive reduction systems preserves referential transparency for the computational system also in a non-deterministic environment. <p> Therefore we give a short description of CRS here. For a full description, including formal definitions, see <ref> [22, 24] </ref>. Consider a set of terms T , constructed out of constant function symbols with fixed arity, nullary variables, and a binary abstraction operator, written [ ] (i.e., if t is a term and x is a variable, then [x]t is a term).
Reference: 25. <author> L. </author> <title> Kott. Unfold/fold program transformations. </title> <editor> In M. Nivat and J. C. Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, chapter 12, </booktitle> <pages> pages 411-434. </pages> <publisher> Cambridge University Press, </publisher> <year> 1985. </year>
Reference-contexts: On the other hand, the rather detailed natural semantics of Hughes and Moran gives more information about how to actually implement a language with these operations. Our results about folding and unfolding extend classical results <ref> [10, 11, 12, 25] </ref> for deterministic systems. They also hold for systems with higher order operations, which is true as well for the recent work on correctness for transformations of deterministic programs by Sands [32]. <p> For deterministic recursive applicative program schemes there is a classical theory for fold/unfold-transformations, see, e.g., <ref> [12, 25] </ref>. The results in this section can be seen as generalizations of some classical results to the nondeterministic case. Our theory is CRS based: thus, it covers also higher order programs.
Reference: 26. <author> J.-J. Levy. </author> <title> An algebraic interpretation of the fik-calculus; and an application of a labelled -calculus. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 2(1) </volume> <pages> 97-114, </pages> <year> 1976. </year>
Reference-contexts: The semantics we use is related to the one developed by Arnold, Naudin and Nivat for nondeterministic recursive schemes [4] and in particular to the one of Boudol [8] for first order term rewriting systems. It is also related to the theory of approximate normal forms in the -calculus <ref> [26, 37, 38] </ref>. What sets our work apart is that we formulate the semantics and prove some results in the more abstract setting of binary relations.
Reference: 27. <author> M. Nivat. </author> <title> On the interpretation of recursive polyadic program schemes. </title> <journal> Symposia Mathematica, </journal> <volume> 15 </volume> <pages> 255-281, </pages> <year> 1975. </year>
Reference-contexts: be contrasted with "don't care" nondeterminism which gives a looser, relational specification of the computational component, where a number of outcomes are allowed for a given input and the system is free to choose. 2 Related Work Our work is strongly related to the theory of recursive applicative program schemes <ref> [12, 27] </ref>. The semantics we use is related to the one developed by Arnold, Naudin and Nivat for nondeterministic recursive schemes [4] and in particular to the one of Boudol [8] for first order term rewriting systems. <p> Sometimes we will abuse notation and write a even when considered as a relation, i.e. S Consider an ARS hA; !i, a c.p.o. hC; vi (possibly without bottom), and a mapping f: A ! C which is monotone w.r.t. ! and v. Cf. <ref> [2, 27, 37] </ref>, and also [5, Lemma 14.3.7]. f is then a monotone interpretation of hA; !i into hC; vi, and v models the increase of information as a computation proceeds along !. Any !-computation a yields a l.u.b. <p> R, an abstraction, or a variable. Otherwise,[R](t)(p) = ?. It is easy to verify that [R] is indeed a monotone interpretation of hT; ! R i into hT 1 ? ; vi. A similar construct is the interpretation of Nivat <ref> [27] </ref> for recursive applicative program schemes. For graph rewriting systems, the instant semantics of Ariola and Arvind [2] corresponds to [R]. A third example is Wadsworth's best direct approximants for -terms under fi-reduction [37] (see also [5, Definition 14.3.6]).
Reference: 28. <author> S. Peyton Jones, A. J. Gordon, and S. Finne. </author> <title> Concurrent Haskell. </title> <booktitle> In Proc. 23rd Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 295-308, </pages> <year> 1996. </year>
Reference-contexts: A goal of our work is to support the design of recursive languages with concurrency, where the "serial part" is referentially transparent also in the presence of nondeterminism arising from the concurrency. A language that seem to fit this charter is Concurrent Haskell <ref> [28] </ref>, a lazy functional language extended with concurrency primitives. A comparison can be made with Hughes' and Moran's work [17], where they give a natural semantics for normal order -calculus plus McCarty's amb operator for nondeterministic choice. It seems that this combination can be modeled in our framework as well.
Reference: 29. <author> J.-C. Raoult and J. Vuillemin. </author> <title> Operational and semantic equivalence between recursive programs. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 27(4) </volume> <pages> 772-796, </pages> <month> Oct. </month> <year> 1980. </year>
Reference-contexts: A CRS is orthogonal if all its rules are orthogonal (even to themselves). Two CRS'es R, R 0 are mutually orthogonal if any rule in R is orthogonal to any rule in R 0 . The following result for mutually orthogonal CRS'es was first stated for first order TRS'es <ref> [29, Proposition 10] </ref>, but the proof carries over to mutually orthogonal CRS'es [36]. Due to this theorem, our results in Sections 7, 8, and 9 are directly applicable to mutually orthogonal CRS'es. Theorem 1 (Raoult and Vuillemin).
Reference: 30. <author> J. H. Reppy. </author> <title> CML: A higher order concurrent language. </title> <booktitle> In Proc. SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 293-305, </pages> <year> 1991. </year>
Reference-contexts: Our framework is abstract and thus potentially applicable to a range of languages, but the ones we have mainly in mind are recursive languages with concur-rency constructs. Some existing, not referentially transparent languages in this class are Concurrent ML <ref> [30] </ref>, Facile [34], and Erlang [3]. A goal of our work is to support the design of recursive languages with concurrency, where the "serial part" is referentially transparent also in the presence of nondeterminism arising from the concurrency.
Reference: 31. <author> D. Sahlin. </author> <title> Partial evaluation of AKL. </title> <booktitle> In Proc. First International Workshop on Concurrent Constraint Programming, </booktitle> <address> Ca Dolfin, Venice, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Semantics-preserving partial evaluation of such languages is listed as the "challenging problem no. 10.9" in [19]. The only partial evaluator for such languages that we are aware of is for the concurrent constraint programming language AKL <ref> [31] </ref>. But this partial evaluator gives correct results only under a number of restrictions on the program and assumptions about the intended semantics.
Reference: 32. <author> D. Sands. </author> <title> Total correctness by local improvement in the transformation of functional programs. </title> <journal> ACM Trans. Program. Lang. Syst., </journal> <volume> 18(2) </volume> <pages> 175-234, </pages> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: Our results about folding and unfolding extend classical results [10, 11, 12, 25] for deterministic systems. They also hold for systems with higher order operations, which is true as well for the recent work on correctness for transformations of deterministic programs by Sands <ref> [32] </ref>. Our results provide some support for program transformation systems for program optimization [9, 16] and partial evaluation of nondeterministic languages. Semantics-preserving partial evaluation of such languages is listed as the "challenging problem no. 10.9" in [19]. <p> This yields the correct semantics for the unfolded term. The correctness of folding was proved under the condition that a rule would not be used to fold itself, which corresponds to the restricted folding-unfolding condition by Courcelle [11, 12]. As observed by Sands <ref> [32] </ref>, this condition is quite restrictive since it essentially prohibits the formation of new recursive definitions. This limits the applicability to program transformations and partial evaluation.
Reference: 33. <author> H. Sondergaard and P. Sestoft. </author> <title> Referential transparency, definiteness and unfold-ability. </title> <journal> Acta Informatica, </journal> <volume> 27 </volume> <pages> 505-517, </pages> <year> 1990. </year>
Reference-contexts: Some of our results concern referential transparency. There is an interesting discussion of referential transparency and unfoldability in <ref> [33] </ref>; one can say that commutation of the computational and descriptive reduction systems preserves referential transparency for the computational system also in a non-deterministic environment.
Reference: 34. <author> B. Thomsen, L. Leth, and A. Giacalone. </author> <title> Some Facile chemistry. </title> <type> Tech. Rep. ECRC-92-14, </type> <institution> European Computer-Industry Research Centre, </institution> <year> 1992. </year>
Reference-contexts: Our framework is abstract and thus potentially applicable to a range of languages, but the ones we have mainly in mind are recursive languages with concur-rency constructs. Some existing, not referentially transparent languages in this class are Concurrent ML [30], Facile <ref> [34] </ref>, and Erlang [3]. A goal of our work is to support the design of recursive languages with concurrency, where the "serial part" is referentially transparent also in the presence of nondeterminism arising from the concurrency.
Reference: 35. <editor> D. A. Turner, editor. </editor> <booktitle> Research Topics in Functional Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: A prime example is a purely functional program. Purely functional programming is highly appropriate for describing purely computational tasks (as long as explicit resource handling for efficiency is not a concern, anyway). The simple semantics makes it particularly simple to analyze and transform functional programs: see, for instance, <ref> [20, 35] </ref>. There are many situations, however, where the descriptive component cannot be neglected. Systems for control of finite resources (such as various servers), operating systems, embedded systems they all rely on the ability to model the environment where the specified computations are to take place.
Reference: 36. <author> V. van Oostrom. </author> <title> Private communication. </title>
Reference-contexts: Two CRS'es R, R 0 are mutually orthogonal if any rule in R is orthogonal to any rule in R 0 . The following result for mutually orthogonal CRS'es was first stated for first order TRS'es [29, Proposition 10], but the proof carries over to mutually orthogonal CRS'es <ref> [36] </ref>. Due to this theorem, our results in Sections 7, 8, and 9 are directly applicable to mutually orthogonal CRS'es. Theorem 1 (Raoult and Vuillemin). If the CRS'es R and R 0 are mutually orthogonal, then ! R and ! R 0 commute.
Reference: 37. <author> C. P. Wadsworth. </author> <title> The relation between computational and denotational properties for Scott's D 1 -models of the lambda calculus. </title> <journal> SIAM J. Comput., </journal> <volume> 5(3) </volume> <pages> 488-521, </pages> <month> Sept. </month> <year> 1976. </year>
Reference-contexts: The semantics we use is related to the one developed by Arnold, Naudin and Nivat for nondeterministic recursive schemes [4] and in particular to the one of Boudol [8] for first order term rewriting systems. It is also related to the theory of approximate normal forms in the -calculus <ref> [26, 37, 38] </ref>. What sets our work apart is that we formulate the semantics and prove some results in the more abstract setting of binary relations. <p> Sometimes we will abuse notation and write a even when considered as a relation, i.e. S Consider an ARS hA; !i, a c.p.o. hC; vi (possibly without bottom), and a mapping f: A ! C which is monotone w.r.t. ! and v. Cf. <ref> [2, 27, 37] </ref>, and also [5, Lemma 14.3.7]. f is then a monotone interpretation of hA; !i into hC; vi, and v models the increase of information as a computation proceeds along !. Any !-computation a yields a l.u.b. <p> A similar construct is the interpretation of Nivat [27] for recursive applicative program schemes. For graph rewriting systems, the instant semantics of Ariola and Arvind [2] corresponds to [R]. A third example is Wadsworth's best direct approximants for -terms under fi-reduction <ref> [37] </ref> (see also [5, Definition 14.3.6]). Since [R] is a monotone interpretation, R defines a semantics S (t; [R]; ! R ), denoted S R (t), w.r.t. R for terms t in T .
Reference: 38. <author> C. P. Wadsworth. </author> <title> Approximate reduction and lambda calculus models. </title> <journal> SIAM J. Comput., </journal> <volume> 7(3) </volume> <pages> 337-356, </pages> <month> Aug. </month> <year> 1978. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: The semantics we use is related to the one developed by Arnold, Naudin and Nivat for nondeterministic recursive schemes [4] and in particular to the one of Boudol [8] for first order term rewriting systems. It is also related to the theory of approximate normal forms in the -calculus <ref> [26, 37, 38] </ref>. What sets our work apart is that we formulate the semantics and prove some results in the more abstract setting of binary relations.
References-found: 38

