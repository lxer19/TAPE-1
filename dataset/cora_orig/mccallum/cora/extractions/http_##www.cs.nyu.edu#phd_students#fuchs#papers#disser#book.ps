URL: http://www.cs.nyu.edu/phd_students/fuchs/papers/disser/book.ps
Refering-URL: http://www.cs.nyu.edu/phd_students/fuchs/index.html
Root-URL: http://www.cs.nyu.edu
Title: Dreme: for Life in the Net  
Author: by Matthew Fuchs 
Degree: A dissertation submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy  Approved  
Note: c flAssociation for Computing Machinery, All Rights Reserved 1996  
Date: September, 1995  
Address: New York University  
Affiliation: Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Gul A. Agha. </author> <title> Actors. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: If we push this to the limit, then our (possibly unrealizable) goal should be that the processing node in the network on which an instruction is executed may be arbitrarily chosen at runtime. Several researchers have dealt with the issue of uniform distributed addressing <ref> [7, 54, 6, 1] </ref>; we shall present our variation on this, which provides some asymptotic 5 improvements, when discussing garbage collection. Placing an object, and in particular, placing an instruction, on a node, is a more complicated task. <p> passes in a row for trick := 0 to 12 do for player := 0 to 3 do game [trick][player] := playerArray [(player + leader) mod 4].playCard (); od leader := (scoreTrick (game [trick]) + leader) mod 4; od gamesWon [scoreGame (game, declarer)]++; until (gamesWon [0] = 2 or gamesWon <ref> [1] </ref> = 2); return if (gamesWon [0] = 2) then 0 else 1 endif; - 14 program or a chess game, this is not particularly onerous; where there is significant control flow, as in bridge, it is more so. The usual justification given for this transformation is user freedom. <p> so much to simply conserve computational resources, but rather to provide for their greedy exploitation in other words, to spread the computation across an extremely large-scale distributed network so that the overall parallel computation time is reduced."<ref> [1] </ref> 3.6.6 Act The most complete elaboration of the actor model is found in [1], and the following description is based on it. An actor system is built of a set of autonomous components called actors which sit around waiting for tasks (synonymous with messages in other languages). When an actor receives a task it can: 1. Create some new actors 2. <p> This is somewhat in contrast to the Lisp world, from which actors originated, in which almost everything is manipulable. Of course any given actor language could provide operations on mail addresses, although at the loss of some theoretical purity. <ref> [1] </ref> provides two bare bones actor languages, SAL (Simple Actor Language) and Act. SAL has algol-like syntax and Act has lisp-like syntax. A program in SAL is composed of a series of behavior definitions, let statements, and send statements.
Reference: [2] <author> G. T. Almes et al. </author> <title> The Eden System: A Technical Review. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(1) </volume> <pages> 43-58, </pages> <year> 1985. </year>
Reference-contexts: This adds an extra degree of complexity; the straightforward control flow of fig. 1.1 must be systematically transformed. In an application where there is little control flow, such as a drawing 13 procedure rubber (players playerArray [4]) returns integer - array gamesWon <ref> [2] </ref> of integer; do contract := 0; declarer := 0; leader := 0; array game [13][4] of card; for player := 0 to 3 do playerArray [player].deal (cards); od get the next player's bid if the bid is higher than contract then contract := the new bid declarer := the current <p> We will also examine Sun Microsystem's Java, which promises to have significant impact, despite its novelty. When development first started on Dreme, the only significant languages explicitly supporting physical mobility of objects in a network were Emerald [50, 41, 28] and, to a lesser extent, Eden <ref> [2, 6] </ref>, which we will examine first. A number of systems have come into existence contemporaneously with Dreme. <p> A number of systems have come into existence contemporaneously with Dreme. Excluding Tele-script [26], about which so little is known, the most sophisticated, and the most similar to Dreme is Obliq [10, 9], an object-oriented language which also uses lexical scoping to support correct IPC. 3.6.1 Eden Eden <ref> [6, 2] </ref> is an early example of an object-based distributed system. Although originally intended to be implemented as an operating system, it was eventually developed on top of Unix.
Reference: [3] <author> Tim Berners-Lee and Daniel Connolly. </author> <title> Hypertext Markup Language: A representation of textual information and metainformation for retrieval and interchange. </title> <type> Technical report. </type>
Reference: [4] <author> D. I. Bevan. </author> <title> Distributed garbage collection using reference counting. </title> <booktitle> In PARLE '87, </booktitle> <pages> pages 176-187. </pages> <publisher> Springer Verlag LNCS 259, </publisher> <year> 1987. </year>
Reference-contexts: This adds an extra degree of complexity; the straightforward control flow of fig. 1.1 must be systematically transformed. In an application where there is little control flow, such as a drawing 13 procedure rubber (players playerArray <ref> [4] </ref>) returns integer - array gamesWon [2] of integer; do contract := 0; declarer := 0; leader := 0; array game [13][4] of card; for player := 0 to 3 do playerArray [player].deal (cards); od get the next player's bid if the bid is higher than contract then contract := the <p> Garbage may need to be examined several times before being definitively established as garbage. Traditional RC requires increment and decrement messages; incorrectly ordered messages can lead to collection of live objects. Distributed RC algorithms, starting with weighted reference counting (WRC) <ref> [4, 59] </ref>, generally eliminate the increment messages. In WRC, each object is given a large value which is spread around when a reference is copied. Each outstanding reference contains a weight, and all 164 these weights add up to the weight of the object.
Reference: [5] <author> Andrew Birrell et al. </author> <title> Distributed garbage collection for network objects. </title> <type> Technical Report 116, </type> <institution> DEC Systems Research Center, </institution> <year> 1993. </year>
Reference-contexts: Emerald [50, 41, 28] uses addresses, but resorts to broadcast if an object isn't at the last know location. In the DEC Hermes [7] project, each object has a home site which know the current physical location, although this requires extra messages to keep consistent. Network Objects <ref> [5] </ref> maintain the child pointers, but not reference chains; each object directly knows everyone who refers to it. 3.2.2 What to Move In contrast to objects in most systems, which are totally immobile, Dreme objects are mobile by default. <p> Mark-and-sweep algorithms [33, 34, 45] first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. Reference counting techniques <ref> [15, 13, 44, 54, 5] </ref> require much less coordination. However, they do not locate distributed cycles. Both kinds of algorithms generally have two phases. In the local phase, completely unreferenced objects are garbage collected. In the second phase inter-node information is propagated through the network, identifying more garbage.
Reference: [6] <author> Andrew Black. </author> <title> Supporting Distributed Applications: Experience with Eden. </title> <journal> Operating Systems Review, </journal> <volume> 19(5) </volume> <pages> 181-193, </pages> <year> 1985. </year>
Reference-contexts: If we push this to the limit, then our (possibly unrealizable) goal should be that the processing node in the network on which an instruction is executed may be arbitrarily chosen at runtime. Several researchers have dealt with the issue of uniform distributed addressing <ref> [7, 54, 6, 1] </ref>; we shall present our variation on this, which provides some asymptotic 5 improvements, when discussing garbage collection. Placing an object, and in particular, placing an instruction, on a node, is a more complicated task. <p> We will also examine Sun Microsystem's Java, which promises to have significant impact, despite its novelty. When development first started on Dreme, the only significant languages explicitly supporting physical mobility of objects in a network were Emerald [50, 41, 28] and, to a lesser extent, Eden <ref> [2, 6] </ref>, which we will examine first. A number of systems have come into existence contemporaneously with Dreme. <p> A number of systems have come into existence contemporaneously with Dreme. Excluding Tele-script [26], about which so little is known, the most sophisticated, and the most similar to Dreme is Obliq [10, 9], an object-oriented language which also uses lexical scoping to support correct IPC. 3.6.1 Eden Eden <ref> [6, 2] </ref> is an early example of an object-based distributed system. Although originally intended to be implemented as an operating system, it was eventually developed on top of Unix.
Reference: [7] <author> Andrew Black and Yeshayahu Artsy. </author> <title> Implementing location independent invocation. </title> <booktitle> In 9th Int. Conf. on Distributed Computing Systems. IEEE, </booktitle> <year> 1989. </year>
Reference-contexts: If we push this to the limit, then our (possibly unrealizable) goal should be that the processing node in the network on which an instruction is executed may be arbitrarily chosen at runtime. Several researchers have dealt with the issue of uniform distributed addressing <ref> [7, 54, 6, 1] </ref>; we shall present our variation on this, which provides some asymptotic 5 improvements, when discussing garbage collection. Placing an object, and in particular, placing an instruction, on a node, is a more complicated task. <p> Emerald [50, 41, 28] uses addresses, but resorts to broadcast if an object isn't at the last know location. In the DEC Hermes <ref> [7] </ref> project, each object has a home site which know the current physical location, although this requires extra messages to keep consistent.
Reference: [8] <author> Jean-Pierre Briot and Jean de Ratuld. </author> <title> Design of a distributed implementation of ABCL/1. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(4) </volume> <pages> 15-17, </pages> <year> 1989. </year> <month> 187 </month>
Reference-contexts: ABCL/1 is a continually evolving experimental language. In the version discussed here it has been used for numerous programs, including English parsers, parallel discrete simulation, robotic control, and some AI work [62]. A distributed version in Lisp running on a network of Sun workstations was developed <ref> [8] </ref>. Later versions of ABCL/1 have added support for exception handling and reflection [22].
Reference: [9] <author> Luca Cardelli. Obliq: </author> <title> a language with distributed scope. </title> <type> Technical Report 122, </type> <institution> DEC SRC, </institution> <year> 1994. </year>
Reference-contexts: A number of systems have come into existence contemporaneously with Dreme. Excluding Tele-script [26], about which so little is known, the most sophisticated, and the most similar to Dreme is Obliq <ref> [10, 9] </ref>, an object-oriented language which also uses lexical scoping to support correct IPC. 3.6.1 Eden Eden [6, 2] is an early example of an object-based distributed system. Although originally intended to be implemented as an operating system, it was eventually developed on top of Unix.
Reference: [10] <author> Luca Cardelli. </author> <title> A language with distributed scope. </title> <journal> Computing Systems, </journal> <volume> 8(1) </volume> <pages> 27-60, </pages> <year> 1995. </year>
Reference-contexts: A number of systems have come into existence contemporaneously with Dreme. Excluding Tele-script [26], about which so little is known, the most sophisticated, and the most similar to Dreme is Obliq <ref> [10, 9] </ref>, an object-oriented language which also uses lexical scoping to support correct IPC. 3.6.1 Eden Eden [6, 2] is an early example of an object-based distributed system. Although originally intended to be implemented as an operating system, it was eventually developed on top of Unix.
Reference: [11] <author> David Chaiken. </author> <title> Cache coherence protocols for large-scale multiprocessors. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <year> 1990. </year>
Reference-contexts: We will show there is enough information in the IRG to collect cycles with a reasonable overhead. Maintaining the IRG has several ancillary benefits not normally considered: 1. The same information can be used to maintain consistent states among repli cated objects, as in a software cache consistency protocol <ref> [11] </ref>. 2. Nodes can implement a variety of garbage collection strategies, such as charging for the continued existence of an object, migrating objects to accessor nodes, or arbitrarily collecting an object and informing its referents of their dangling pointers.
Reference: [12] <editor> William Clinger, Jonathan Rees, et al. </editor> <title> Revised 4 Report on the Algorithmic Language Scheme. </title> <type> Technical report. </type>
Reference: [13] <author> H. Corporaal. </author> <title> Distributed heapmanagement using reference weights. </title> <booktitle> In Distributed Memory Computing, </booktitle> <pages> pages 325-336. </pages> <publisher> Springer Verlag LNCS 487, </publisher> <year> 1991. </year>
Reference-contexts: Mark-and-sweep algorithms [33, 34, 45] first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. Reference counting techniques <ref> [15, 13, 44, 54, 5] </ref> require much less coordination. However, they do not locate distributed cycles. Both kinds of algorithms generally have two phases. In the local phase, completely unreferenced objects are garbage collected. In the second phase inter-node information is propagated through the network, identifying more garbage. <p> Decrement messages are sent when remote references are collected and are accompanied by the former reference's weight. Because weights cannot be divided when they sink to one, the initial algorithm required indirection cells, proxies for the object with their own trees of references. A number of improvements and alternatives <ref> [15, 13, 44] </ref> have eliminated these. None of these algorithms handles cycles, and the object must trust the sender of the decrement message. A different approach starts with Piquer [44] and continues with Shapiro et al.[54].
Reference: [14] <author> Daniel Friedman and Mitchell Wand and Christopher T. Haynes. </author> <title> Essentials of Programming Languages. </title> <address> MIT/McGraw-Hill, </address> <year> 1992. </year>
Reference-contexts: 61 (define release-proc #f) (define monitor-proc (let ((mon (let ((flag #f)) (monitor () (if (not flag) (set! release-proc (lambda () (release))) (.... monitor-body ....)))))) (mon) elimination makes it difficult to determine exactly when a scope has been exited, although it would be possible to ensure this with a wind/unwind construct <ref> [14] </ref>. Dreme monitors are lexically-scoped but are weakened by the presence of first-class functions. The thread inside the monitor can expose the associated release statement outside its scope.
Reference: [15] <author> Benjamin Goldberg. </author> <title> Generational reference counting. </title> <booktitle> In Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 313-321. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Mark-and-sweep algorithms [33, 34, 45] first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. Reference counting techniques <ref> [15, 13, 44, 54, 5] </ref> require much less coordination. However, they do not locate distributed cycles. Both kinds of algorithms generally have two phases. In the local phase, completely unreferenced objects are garbage collected. In the second phase inter-node information is propagated through the network, identifying more garbage. <p> Decrement messages are sent when remote references are collected and are accompanied by the former reference's weight. Because weights cannot be divided when they sink to one, the initial algorithm required indirection cells, proxies for the object with their own trees of references. A number of improvements and alternatives <ref> [15, 13, 44] </ref> have eliminated these. None of these algorithms handles cycles, and the object must trust the sender of the decrement message. A different approach starts with Piquer [44] and continues with Shapiro et al.[54].
Reference: [16] <author> James Gosling and Henry McGilton. </author> <title> The java language environment. </title> <type> Technical report, </type> <institution> Sun Microsystems Computer Company, </institution> <year> 1995. </year> <month> ftp://ftp.sun.com/docs/JavaBook.ps.tar.Z. </month>
Reference-contexts: By contrast, message passing clearly distinguishes the recipient of the message as the next location of the thread of control. In addition, the message passing approach better handles encapsulation, a prerequisite for any 89 security. 3.8 Java A very recent development which deserves some mention here is Java <ref> [16] </ref>, an object-oriented language developed by Sun Microsystems. Java originally started as a project to extend C++ to support run-time linking, but then evolved into a type-safe interpreted language depending on a fast byte-coded virtual machine (VM). <p> There have been two major events since I completed the first version of Dreme in early 1993 which will significantly affect future implementations. The first is the surge in popularity of the World Wide Web, and the second is the appearance of Sun's HotJava <ref> [16] </ref> browser. Current Web technology, based on HTML, is utterly inadequate to support the information access needs of sophisticated clients, but has created a venue for hypermedia information to become generally available on the Internet.
Reference: [17] <author> Christopher Haynes and Daniel Friedman. </author> <title> Engines build process abstractions. </title> <booktitle> In Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 18-24. </pages> <publisher> ACM, </publisher> <year> 1984. </year>
Reference-contexts: Although this is not strictly required 63 by Dreme, it is necessary if the Process is going to give any guarantees of service to locally executing code. The current implementation uses a variation on engines <ref> [17] </ref> to implement preemptive scheduling. All of these add to the number of threads being controlled by Dreme Processes, although the additional threads may be remote. Although preemption is not fundamental to Dreme, the scheduler is, as it is otherwise impossible to implement certain concurrency constructs.
Reference: [18] <author> Dan Heller. </author> <title> MOTIF Programming Manual. </title> <editor> O'Reilly and Assocs., </editor> <year> 1994. </year>
Reference-contexts: This is in accord with the original philosophy of SGML, but appears to be unusual in GUI developments. Logical requirements for an interface are certainly a part of GUI design, and style guidelines <ref> [18] </ref> may approach this, but there does not seem to be any GUI work in "executable specifications." It is more frequently argued that designing a user interface is an iterative, experimental process that would be difficult to automate [40, 53].
Reference: [19] <author> Carl E. Hewitt. </author> <title> Viewing Control Structures as Patterns of Passing Messages. </title> <journal> Journal of Artificial Intelligence, </journal> <volume> 8(3) </volume> <pages> 323-364, </pages> <year> 1972. </year> <month> 188 </month>
Reference-contexts: In the last case, the signal is [:unaccepable M :from sender :to T], which is sent either to the sender or to an explicitly stated complaint destination that was 85 included in the original message. 3.6.8 Actors and Dreme In papers such as <ref> [19, 20] </ref>, it is clear that actor semantics are equivalent to a restatement of denotational sematics. As such, all languages can be seen as variants on actor languages, Dreme included.
Reference: [20] <editor> Carl E. Hewitt et al. </editor> <title> Actor Induction and Meta-evaluation. </title> <booktitle> In Symposium on Principles of Programming Languages, </booktitle> <pages> pages 169-182. </pages> <publisher> ACM, </publisher> <year> 1973. </year>
Reference-contexts: In the last case, the signal is [:unaccepable M :from sender :to T], which is sent either to the sender or to an explicitly stated complaint destination that was 85 included in the original message. 3.6.8 Actors and Dreme In papers such as <ref> [19, 20] </ref>, it is clear that actor semantics are equivalent to a restatement of denotational sematics. As such, all languages can be seen as variants on actor languages, Dreme included.
Reference: [21] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: Their concern for security may have led them to an architecture which creates unnecessary overhead when security is less of an issue. 76 3.6.5 Actors The actor model was introduced by Carl Hewitt [36] as a paradigm for distributed AI applications. As such, it predates Communicating Sequential Processes <ref> [21] </ref>, although the latter has been far more influential in the development of concur-rency in Algol-like languages. Nevertheless, actors have been very influential in the development of object-oriented concurrent languages.
Reference: [22] <author> Yuuji Ichisugi and Akinori Yonezawa. </author> <title> Exception handling and real time features in an object-oriented concurrent language. </title> <editor> In T. Ito and A. Yonezawa, editors, </editor> <booktitle> Concurrency: Theory, Languages, and Architectures. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: A distributed version in Lisp running on a network of Sun workstations was developed [8]. Later versions of ABCL/1 have added support for exception handling and reflection <ref> [22] </ref>. Exceptions are trapped by enclosing some part of a script with a catch-signal construct: (catch-signal : : : actions : : : (handler (=&gt; signal-pattern handler-body) : : : There are a few ways to raise signals.
Reference: [23] <author> Williams Ludwell Harrison III. </author> <title> The Interprocedural Analysis and Automatic Parallelization of Scheme Programs. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2(3) </volume> <pages> 179-396, </pages> <year> 1989. </year>
Reference-contexts: Although preemption is not fundamental to Dreme, the scheduler is, as it is otherwise impossible to implement certain concurrency constructs. The automatic parallelization of Scheme programs is a well-researched topic beyond the scope of the current work <ref> [23] </ref>. Any work done in that area is immediately applicable to Dreme, particularly if the parallel program is to be run over a network of workstations, as opposed to a single, shared-memory machine.
Reference: [24] <author> ISO/IEC. </author> <title> DIS 10179.2 Document Style Semantics and Specification Language. </title>
Reference-contexts: Our approach attempts to support all these by considering them as aspects of the mobility of information. 4.1.4 Documents are programs: linking the document to the application The SGML standard, and associated standards such as DSSSL <ref> [24] </ref> and HyTime [25], are explicitly application independent; no constraints are made on the structure of the application. Our applications, however, need to be as transportable as documents. We also anticipate a proliferation of document types, so applications should be easy to construct.
Reference: [25] <author> ISO/IEC. </author> <title> IS 10744 Hypermedia/Time-based Structuring Language (HyTime), </title> <year> 1992. </year>
Reference-contexts: Our approach attempts to support all these by considering them as aspects of the mobility of information. 4.1.4 Documents are programs: linking the document to the application The SGML standard, and associated standards such as DSSSL [24] and HyTime <ref> [25] </ref>, are explicitly application independent; no constraints are made on the structure of the application. Our applications, however, need to be as transportable as documents. We also anticipate a proliferation of document types, so applications should be easy to construct.
Reference: [26] <author> James E. White. </author> <title> Telescript technology: The foundation of the electronic martketplac. </title> <type> Technical report, </type> <institution> General Magic, </institution> <year> 1994. </year>
Reference-contexts: These aspects of the Memory abstraction have not been developed in the current implementation, but would fiture prominently in any commercial implementation of these concepts. It has been argued <ref> [26] </ref> that interpreted code is somehow inherently safer than object code in the context of mbility, as the interepreted code is easier to control. <p> A number of systems have come into existence contemporaneously with Dreme. Excluding Tele-script <ref> [26] </ref>, about which so little is known, the most sophisticated, and the most similar to Dreme is Obliq [10, 9], an object-oriented language which also uses lexical scoping to support correct IPC. 3.6.1 Eden Eden [6, 2] is an early example of an object-based distributed system.
Reference: [27] <author> James Gosling and David S. H. Rosenthal and Michelle J. Arden. </author> <title> The NeWS Book. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference: [28] <author> Eric Jul et al. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <year> 1988. </year>
Reference-contexts: We could also add automatic parallelization and coordination languages, such as Linda, to this list. All attempt to reduce the importance of location as a significant factor in developing computer systems. Following in the line of Emerald <ref> [50, 28] </ref>, we propose to go farther by allowing application objects to move around the network during the course of computation. With object mobility, we can support the same basic software components in a changing environment in a fashion that is much more difficult without mobility. <p> This scheme is very similar to the Scion-Stub Pointer Chains proposed by Shapiro [54], but provides additional support for mobility, without which there is no need to be concerned for cycles. Emerald <ref> [50, 41, 28] </ref> uses addresses, but resorts to broadcast if an object isn't at the last know location. In the DEC Hermes [7] project, each object has a home site which know the current physical location, although this requires extra messages to keep consistent. <p> We will also examine Sun Microsystem's Java, which promises to have significant impact, despite its novelty. When development first started on Dreme, the only significant languages explicitly supporting physical mobility of objects in a network were Emerald <ref> [50, 41, 28] </ref> and, to a lesser extent, Eden [2, 6], which we will examine first. A number of systems have come into existence contemporaneously with Dreme. <p> Other uses of concurrency are built from the Concurrent Euclid subset of EPL; a concurrent construct must be written twice if it is to be used both locally and globally. Again, this problem will be addressed by the Emerald system. 3.6.2 Emerald Emerald <ref> [50, 35, 28] </ref> is an object-based distributed language (although the complexity to support the language brings it almost to the level of a distributed operating system) whose most innovative feature is its complete support of mobility for objects of every type and granularity.
Reference: [29] <author> Dennis Kafura et al. </author> <title> Garbage collection of actors. </title> <booktitle> In OOPSLA/ECOOP Proceedings, </booktitle> <pages> pages 126-134, </pages> <year> 1990. </year> <month> 189 </month>
Reference-contexts: For scaling to larger networks, the article proposes dividing the network into areas, each with its own server and a global server to sit above for inter-area references. Puaut [45, 46] provides another client/server model for distributed collection of active objects. This extends Ka-fura's <ref> [29] </ref> algorithm for collecting agents by allowing lost messages and removing synchronization constraints. The various nodes of a system send timestamped information to a global collector containing intra-node edges. <p> In this case, some of the back edges may actually be cross edges. A slight modification is also necessary to handle active objects, as neither the IRG nor the FRG is sufficient <ref> [29, 45] </ref>. If an active object is encountered, then it must traverse both its IRG and the FRG for which it is the root.
Reference: [30] <author> R. Kessler et al. </author> <title> Implementing concurrent scheme for the mayfly distributed parallel processing system. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 5 </volume> <pages> 73-93, </pages> <year> 1992. </year>
Reference-contexts: Here we will look at some systems which assume distributed memory and even some degree of mobility. 86 3.7.1 Concurrent Scheme Concurrent Scheme (CS)[31, 56] is a dialect of Scheme developed for the Mayfly <ref> [30] </ref>, a distributed memory multiprocessor, but which also runs on networks of workstations. CS borrows the concept of a domain from Hybrid [42]. Domains are analogous to monitors.
Reference: [31] <author> Robert Kessler and Mark Swanson. </author> <title> Concurrent scheme. </title> <booktitle> In Parallel Lisp: Languages and Systems. </booktitle> <publisher> Springer Verlag LNCS 441, </publisher> <year> 1990. </year>
Reference: [32] <author> Guy L. Steele, Jr. </author> <title> Common Lisp, the Language, 2nd Edition. </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: At the lowest level, ICSLAS depends on an object-oriented system using generic dispatch, similar to CLOS <ref> [32] </ref> and the developer's own Meroon [48]. In such a system, grosso modo, objects are records and are completely separated from the code that manipulates them, which is hidden in generic functions.
Reference: [33] <author> Rivka Ladin and Barbara Liskov. </author> <title> Garbage collection of a distributed heap. </title> <booktitle> In 12th Int. Conf. on Distributed Computing Systems, </booktitle> <pages> pages 708-715. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: The final section will show some heuristics to determine when to start a collection operation. 162 5.2 Related Work Distributed garbage collection algorithms generally follow one of the two techniques used for collecting a single address space: mark-and-sweep or reference counting. Mark-and-sweep algorithms <ref> [33, 34, 45] </ref> first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. <p> However, they do not locate distributed cycles. Both kinds of algorithms generally have two phases. In the local phase, completely unreferenced objects are garbage collected. In the second phase inter-node information is propagated through the network, identifying more garbage. Ladin and Liskov <ref> [33] </ref> gives an algorithm for collecting cyclical garbage using a client/server model. Distributed references are tracked by the server, which can use them to determine where garbage is.
Reference: [34] <author> Bernard Lang et al. </author> <title> Garbage collecting the world. </title> <booktitle> In 19th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 39-50. </pages> <publisher> ACM, </publisher> <year> 1992. </year>
Reference-contexts: The final section will show some heuristics to determine when to start a collection operation. 162 5.2 Related Work Distributed garbage collection algorithms generally follow one of the two techniques used for collecting a single address space: mark-and-sweep or reference counting. Mark-and-sweep algorithms <ref> [33, 34, 45] </ref> first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage.
Reference: [35] <author> H. M. Levy and E. D. Tempero. </author> <title> Modules, objects and distributed programming: Issues in RPC and remote object invocation. </title> <journal> Software Practice and Experience, </journal> <volume> 21(1) </volume> <pages> 77-90, </pages> <year> 1991. </year>
Reference-contexts: Other uses of concurrency are built from the Concurrent Euclid subset of EPL; a concurrent construct must be written twice if it is to be used both locally and globally. Again, this problem will be addressed by the Emerald system. 3.6.2 Emerald Emerald <ref> [50, 35, 28] </ref> is an object-based distributed language (although the complexity to support the language brings it almost to the level of a distributed operating system) whose most innovative feature is its complete support of mobility for objects of every type and granularity.
Reference: [36] <author> Henry Lieberman. </author> <title> Concurrent object-oriented programming in Act 1. </title> <booktitle> In Object Oriented Concurrent Programming, </booktitle> <pages> pages 9-36. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Their concern for security may have led them to an architecture which creates unnecessary overhead when security is less of an issue. 76 3.6.5 Actors The actor model was introduced by Carl Hewitt <ref> [36] </ref> as a paradigm for distributed AI applications. As such, it predates Communicating Sequential Processes [21], although the latter has been far more influential in the development of concur-rency in Algol-like languages. Nevertheless, actors have been very influential in the development of object-oriented concurrent languages.
Reference: [37] <author> Marc Linton. Fresco tutorial. ftp://ftp.sgi.com/graphics/fresco/exug94.ps.Z, </author> <year> 1994. </year>
Reference-contexts: A UIL description, for example, is not easily transported beyond Motif. This drawback can be partly overcome by porting the toolkit to every interesting platform, as is proposed for Fresco, a CORBA compliant GUI toolkit for X11R6 <ref> [37, 38] </ref>. There are also some commercial products that have taken the same approach. However, these are currently all compile-time libraries.
Reference: [38] <author> Marc Linton and Chuck Price. </author> <title> Building distributed user interfaces with fresco. </title> <type> Technical report, </type> <institution> Silicon Graphics, </institution> <year> 1993. </year> <month> ftp://ftp.sgi.com/graphics/fresco/xconf93.ps.Z. </month>
Reference-contexts: A UIL description, for example, is not easily transported beyond Motif. This drawback can be partly overcome by porting the toolkit to every interesting platform, as is proposed for Fresco, a CORBA compliant GUI toolkit for X11R6 <ref> [37, 38] </ref>. There are also some commercial products that have taken the same approach. However, these are currently all compile-time libraries.
Reference: [39] <author> Brad Myers, </author> <title> editor. Languages for Developing User Interfaces. </title> <publisher> Jones and Bartlett Publishers, </publisher> <year> 1993. </year> <month> 190 </month>
Reference-contexts: We have also 157 developed a more sophisticated model of controlling user events in a multithreaded environment. Another multithreaded graphical user interface residing on similar principals to our approach, although not explicitly, is eXene [51], developed in Concurrent ML (CML). This is an extension of Pegasus <ref> [39] </ref>, written in PML, a predecessor of CML. Before describing eXene and Pegasus, I'll briefly describe CML. CML is an extension of Standard ML and is implemented on top the SML/NJ compiler, a continuation-passing style compiler which inspired the Dreme interpreter architecture.
Reference: [40] <author> Brad Myers. </author> <title> Why are human-computer interfaces difficult to design and imple-ment. </title> <type> Technical Report CMU-CS-93-183, </type> <institution> Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: an interface are certainly a part of GUI design, and style guidelines [18] may approach this, but there does not seem to be any GUI work in "executable specifications." It is more frequently argued that designing a user interface is an iterative, experimental process that would be difficult to automate <ref> [40, 53] </ref>. Providing a textual GUI description language, separate from application behavior, is not unusual. Motif, the OSF standard interface for X Windows, includes the User Interface Language (UIL).
Reference: [41] <author> Niels Juul and Eric Jul. </author> <title> Comprehensive and Robust Garbage Collection in a Distributed System. </title> <editor> In Y. Beckers and J. Cohen, editor, </editor> <booktitle> International Workshop on Memory Management. LNCS 637, </booktitle> <year> 1992. </year>
Reference-contexts: This scheme is very similar to the Scion-Stub Pointer Chains proposed by Shapiro [54], but provides additional support for mobility, without which there is no need to be concerned for cycles. Emerald <ref> [50, 41, 28] </ref> uses addresses, but resorts to broadcast if an object isn't at the last know location. In the DEC Hermes [7] project, each object has a home site which know the current physical location, although this requires extra messages to keep consistent. <p> We will also examine Sun Microsystem's Java, which promises to have significant impact, despite its novelty. When development first started on Dreme, the only significant languages explicitly supporting physical mobility of objects in a network were Emerald <ref> [50, 41, 28] </ref> and, to a lesser extent, Eden [2, 6], which we will examine first. A number of systems have come into existence contemporaneously with Dreme.
Reference: [42] <author> Oscar. M. Nierstrasz. </author> <title> Active Objects in Hybrid. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <pages> pages 243-253, </pages> <year> 1987. </year>
Reference-contexts: CS borrows the concept of a domain from Hybrid <ref> [42] </ref>. Domains are analogous to monitors. Only one thread can be active in a domain at a time, providing protection against concurrent access, but also elevating threads and requiring a set of primitives to handle them.
Reference: [43] <author> John K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Interpreters of type tkmap take a document and convert it to a set of widgets using the Tk <ref> [43] </ref> toolkit. This is a weakness of our current implementation, but we are examining the STFP part of the DSSSL proposal as a means of specifying a more independent geometry.
Reference: [44] <author> Jose M. Piquer. </author> <title> Indirect reference counting. </title> <booktitle> In PARLE '91, </booktitle> <pages> pages 150-165. </pages> <publisher> Springer Verlag LNCS 505, </publisher> <year> 1991. </year>
Reference-contexts: The algorithm in this paper requires little coordination beyond the already existing links between the nodes involved, and extends only as long as the algorithm requires. The algorithm can be seen as an extension of Piquer <ref> [44] </ref> and Birrell et al.[5], 161 both of which augment reference counting (RC) algorithms by maintaining the dis-tributed inverse reference graph (IRG): each object, ff, maintains a list of pointers to other sites known to have references to it. <p> Mark-and-sweep algorithms [33, 34, 45] first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. Reference counting techniques <ref> [15, 13, 44, 54, 5] </ref> require much less coordination. However, they do not locate distributed cycles. Both kinds of algorithms generally have two phases. In the local phase, completely unreferenced objects are garbage collected. In the second phase inter-node information is propagated through the network, identifying more garbage. <p> Decrement messages are sent when remote references are collected and are accompanied by the former reference's weight. Because weights cannot be divided when they sink to one, the initial algorithm required indirection cells, proxies for the object with their own trees of references. A number of improvements and alternatives <ref> [15, 13, 44] </ref> have eliminated these. None of these algorithms handles cycles, and the object must trust the sender of the decrement message. A different approach starts with Piquer [44] and continues with Shapiro et al.[54]. <p> A number of improvements and alternatives [15, 13, 44] have eliminated these. None of these algorithms handles cycles, and the object must trust the sender of the decrement message. A different approach starts with Piquer <ref> [44] </ref> and continues with Shapiro et al.[54]. Scion-Stub Pointer Chains [54] exploit the use of parent pointers (called scions) to track where distributed references to an object reside. These parent pointers establish the inverse reference chain from an object to its accessors. <p> We hope to show the amortized cost per live edge to be O (1). 182 5.9 Implementation Up to this point we have not discussed any actual implementation issues. In terms of data structures, we can reutilize the algorithms in Birrell et al.[5] and Piquer <ref> [44] </ref>. We should also be able to adapt the SSP Chains in Shapiro et al.[54]. The major local effort in producing an implementation will be establishing the IRG within each node, as this is normally not maintained.
Reference: [45] <author> Isabelle Puaut. </author> <title> Distributed Garbage Collection of Active Objects with no Global Synchronisation. </title> <booktitle> In International Workshop on Memory Management, </booktitle> <pages> pages 148-164. </pages> <publisher> Springer Verlag LNCS 637, </publisher> <year> 1992. </year>
Reference-contexts: The final section will show some heuristics to determine when to start a collection operation. 162 5.2 Related Work Distributed garbage collection algorithms generally follow one of the two techniques used for collecting a single address space: mark-and-sweep or reference counting. Mark-and-sweep algorithms <ref> [33, 34, 45] </ref> first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. <p> Distributed references are tracked by the server, which can use them to determine where garbage is. For scaling to larger networks, the article proposes dividing the network into areas, each with its own server and a global server to sit above for inter-area references. Puaut <ref> [45, 46] </ref> provides another client/server model for distributed collection of active objects. This extends Ka-fura's [29] algorithm for collecting agents by allowing lost messages and removing synchronization constraints. The various nodes of a system send timestamped information to a global collector containing intra-node edges. <p> In this case, some of the back edges may actually be cross edges. A slight modification is also necessary to handle active objects, as neither the IRG nor the FRG is sufficient <ref> [29, 45] </ref>. If an active object is encountered, then it must traverse both its IRG and the FRG for which it is the root.
Reference: [46] <author> Isabelle Puaut. </author> <title> A Distributed Garbage Collector for Active Objects. </title> <booktitle> In OOP-SLA Proceedings, </booktitle> <pages> pages 113-128. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: Distributed references are tracked by the server, which can use them to determine where garbage is. For scaling to larger networks, the article proposes dividing the network into areas, each with its own server and a global server to sit above for inter-area references. Puaut <ref> [45, 46] </ref> provides another client/server model for distributed collection of active objects. This extends Ka-fura's [29] algorithm for collecting agents by allowing lost messages and removing synchronization constraints. The various nodes of a system send timestamped information to a global collector containing intra-node edges.
Reference: [47] <author> Christian Queinnec. </author> <title> A concurrent and distributed extension of scheme. </title> <booktitle> In PARLE '92. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Semantically, CS is a restricted subset of Dreme where closures are automatically pinned upon creation at its site of origin, and all other data is copied rather than moved when sent from node to node. 3.7.2 ICSLAS ICSLAS [49], a successor to the language described in <ref> [47] </ref>, is a distributed Scheme dialect with similar goals to Dreme, but with a very different emphasis. At the lowest level, ICSLAS depends on an object-oriented system using generic dispatch, similar to CLOS [32] and the developer's own Meroon [48].
Reference: [48] <author> Christian Queinnec. </author> <title> Les langages lisp, </title> <type> chapter 11. </type> <institution> InterEditions, </institution> <year> 1994. </year>
Reference-contexts: At the lowest level, ICSLAS depends on an object-oriented system using generic dispatch, similar to CLOS [32] and the developer's own Meroon <ref> [48] </ref>. In such a system, grosso modo, objects are records and are completely separated from the code that manipulates them, which is hidden in generic functions. Each generic function contains one or more method bodies; each method body has a different signature and can be placed in a lattice accordingly.
Reference: [49] <author> Christian Queinnec. </author> <title> Locality, Causality, and Continuations. </title> <booktitle> In Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 91-102. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: Semantically, CS is a restricted subset of Dreme where closures are automatically pinned upon creation at its site of origin, and all other data is copied rather than moved when sent from node to node. 3.7.2 ICSLAS ICSLAS <ref> [49] </ref>, a successor to the language described in [47], is a distributed Scheme dialect with similar goals to Dreme, but with a very different emphasis. At the lowest level, ICSLAS depends on an object-oriented system using generic dispatch, similar to CLOS [32] and the developer's own Meroon [48].
Reference: [50] <author> R. K. Raj et al. </author> <title> Emerald: A general-purpose programming language. </title> <journal> Software Practice and Experience, </journal> <volume> 21(1) </volume> <pages> 91-117, </pages> <year> 1991. </year> <month> 191 </month>
Reference-contexts: We could also add automatic parallelization and coordination languages, such as Linda, to this list. All attempt to reduce the importance of location as a significant factor in developing computer systems. Following in the line of Emerald <ref> [50, 28] </ref>, we propose to go farther by allowing application objects to move around the network during the course of computation. With object mobility, we can support the same basic software components in a changing environment in a fashion that is much more difficult without mobility. <p> This scheme is very similar to the Scion-Stub Pointer Chains proposed by Shapiro [54], but provides additional support for mobility, without which there is no need to be concerned for cycles. Emerald <ref> [50, 41, 28] </ref> uses addresses, but resorts to broadcast if an object isn't at the last know location. In the DEC Hermes [7] project, each object has a home site which know the current physical location, although this requires extra messages to keep consistent. <p> We will also examine Sun Microsystem's Java, which promises to have significant impact, despite its novelty. When development first started on Dreme, the only significant languages explicitly supporting physical mobility of objects in a network were Emerald <ref> [50, 41, 28] </ref> and, to a lesser extent, Eden [2, 6], which we will examine first. A number of systems have come into existence contemporaneously with Dreme. <p> Other uses of concurrency are built from the Concurrent Euclid subset of EPL; a concurrent construct must be written twice if it is to be used both locally and globally. Again, this problem will be addressed by the Emerald system. 3.6.2 Emerald Emerald <ref> [50, 35, 28] </ref> is an object-based distributed language (although the complexity to support the language brings it almost to the level of a distributed operating system) whose most innovative feature is its complete support of mobility for objects of every type and granularity.
Reference: [51] <author> John H. Reppy. </author> <title> Higher-Order Concurrency. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1992. </year>
Reference-contexts: We have also 157 developed a more sophisticated model of controlling user events in a multithreaded environment. Another multithreaded graphical user interface residing on similar principals to our approach, although not explicitly, is eXene <ref> [51] </ref>, developed in Concurrent ML (CML). This is an extension of Pegasus [39], written in PML, a predecessor of CML. Before describing eXene and Pegasus, I'll briefly describe CML.
Reference: [52] <author> Jr. Robert Halstead. </author> <title> Implementation of Multilisp. </title> <booktitle> In Symposium on Lisp and Functional Programming. ACM, </booktitle> <year> 1984. </year>
Reference-contexts: Multilisp <ref> [52] </ref>, for example, is an early parallel implementation of Scheme which introduces two important constructs, the future and the pcall. These systems have tended to be on shared memory multiprocessors or multithreaded on a single processor.
Reference: [53] <author> B. Schneiderman. </author> <title> Designing the User Interface. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: an interface are certainly a part of GUI design, and style guidelines [18] may approach this, but there does not seem to be any GUI work in "executable specifications." It is more frequently argued that designing a user interface is an iterative, experimental process that would be difficult to automate <ref> [40, 53] </ref>. Providing a textual GUI description language, separate from application behavior, is not unusual. Motif, the OSF standard interface for X Windows, includes the User Interface Language (UIL).
Reference: [54] <author> Marc Shapiro et al. </author> <title> SSP Chains. </title> <booktitle> In Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 135-146. </pages> <publisher> ACM, </publisher> <year> 1992. </year>
Reference-contexts: If we push this to the limit, then our (possibly unrealizable) goal should be that the processing node in the network on which an instruction is executed may be arbitrarily chosen at runtime. Several researchers have dealt with the issue of uniform distributed addressing <ref> [7, 54, 6, 1] </ref>; we shall present our variation on this, which provides some asymptotic 5 improvements, when discussing garbage collection. Placing an object, and in particular, placing an instruction, on a node, is a more complicated task. <p> Although this can be eliminated in a closed environment, it shows an unavoidable danger of using reference chains in an open network; there is an implicit contract among all the members of the chain. This scheme is very similar to the Scion-Stub Pointer Chains proposed by Shapiro <ref> [54] </ref>, but provides additional support for mobility, without which there is no need to be concerned for cycles. Emerald [50, 41, 28] uses addresses, but resorts to broadcast if an object isn't at the last know location. <p> Mark-and-sweep algorithms [33, 34, 45] first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. Reference counting techniques <ref> [15, 13, 44, 54, 5] </ref> require much less coordination. However, they do not locate distributed cycles. Both kinds of algorithms generally have two phases. In the local phase, completely unreferenced objects are garbage collected. In the second phase inter-node information is propagated through the network, identifying more garbage. <p> A number of improvements and alternatives [15, 13, 44] have eliminated these. None of these algorithms handles cycles, and the object must trust the sender of the decrement message. A different approach starts with Piquer [44] and continues with Shapiro et al.<ref> [54] </ref>. Scion-Stub Pointer Chains [54] exploit the use of parent pointers (called scions) to track where distributed references to an object reside. These parent pointers establish the inverse reference chain from an object to its accessors.
Reference: [55] <author> Etsuya Shibayama and Akinori Yonezawa. </author> <booktitle> Distributed computing in ABCL/1. In Object Oriented Concurrent Programming, </booktitle> <pages> pages 91-128. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Force causes it to evaluate the next part of the structure (since it should then hit another delay command at some point, stopping further evaluation). 3.6.7 ABCL/1 A more "heavy duty" actor language is provided by ABCL/1 (Actor Based Concurrent Language) <ref> [62, 55] </ref>.
Reference: [56] <author> Mark R. Swanson. </author> <title> Concurrent scheme reference. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 5 </volume> <pages> 95-104, </pages> <year> 1992. </year>
Reference: [57] <author> Andrew S. Tannenbaum. </author> <title> Computer Networks, 2nd Edition. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: We will present an algorithm in which certain GCOs will block. Retreat is simpler and can be combined with a restart policy similar that used in CSMA/CD networks, such as Ethernet <ref> [57] </ref>. No performance bounds can be given for such an algorithm, but it might be quite practical in actual networks; a final judgement can only be given once real information is available about distributed object access patterns.
Reference: [58] <author> Robert E. Tarjan. </author> <title> Efficiency of a good but not linear set union algorithm. </title> <journal> Journal of the ACM, </journal> <volume> 22(2) </volume> <pages> 215-225, </pages> <year> 1975. </year>
Reference-contexts: The location mechanism here is complicated by the inability to resort to broadcast in a very large network, forcing the algorithm to track its target one step at a time. The use of path compression, as in <ref> [58] </ref>, for longer chains means the amortized worst case number of messages is nlogn if the reference graph is a tree, where n is the number of links added by Address propagation plus object movement.
Reference: [59] <author> P. Watson and I. Watson. </author> <title> An efficient garbage collection scheme for parallel computer architectures. </title> <booktitle> In PARLE '87, </booktitle> <pages> pages 432-443. </pages> <publisher> Springer Verlag LNCS 259, </publisher> <year> 1987. </year>
Reference-contexts: Garbage may need to be examined several times before being definitively established as garbage. Traditional RC requires increment and decrement messages; incorrectly ordered messages can lead to collection of live objects. Distributed RC algorithms, starting with weighted reference counting (WRC) <ref> [4, 59] </ref>, generally eliminate the increment messages. In WRC, each object is given a large value which is spread around when a reference is copied. Each outstanding reference contains a weight, and all 164 these weights add up to the weight of the object.
Reference: [60] <author> Paul Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <type> Technical report, </type> <institution> University of Texas. </institution> <month> 192 </month>
Reference-contexts: Incremental algorithms which do not halt processing, such as the one we will present, are frequently explained in terms of a tri-color marking scheme <ref> [60, 61] </ref>. In such schemes, persistent roots are initially colored grey and all other objects are white. The algorithm then describes how the children of grey objects are also turned grey. Whenever all of an object's children are grey, the object is turned black.
Reference: [61] <author> Paul Wilson. </author> <title> Uniprocessor Garbage Collection Techniques. </title> <booktitle> In International Workshop on Memory Management, </booktitle> <pages> pages 1-42. </pages> <publisher> Springer Verlag LNCS 637, </publisher> <year> 1992. </year>
Reference-contexts: Incremental algorithms which do not halt processing, such as the one we will present, are frequently explained in terms of a tri-color marking scheme <ref> [60, 61] </ref>. In such schemes, persistent roots are initially colored grey and all other objects are white. The algorithm then describes how the children of grey objects are also turned grey. Whenever all of an object's children are grey, the object is turned black.
Reference: [62] <editor> Akinori Yonezawa et al. </editor> <title> Modelling and programming in an object-oriented concurrent language ABCL/1. In Object Oriented Concurrent Programming. </title> <publisher> MIT Press, </publisher> <year> 1987. </year> <month> 193 </month>
Reference-contexts: Force causes it to evaluate the next part of the structure (since it should then hit another delay command at some point, stopping further evaluation). 3.6.7 ABCL/1 A more "heavy duty" actor language is provided by ABCL/1 (Actor Based Concurrent Language) <ref> [62, 55] </ref>. <p> ABCL/1 is a continually evolving experimental language. In the version discussed here it has been used for numerous programs, including English parsers, parallel discrete simulation, robotic control, and some AI work <ref> [62] </ref>. A distributed version in Lisp running on a network of Sun workstations was developed [8]. Later versions of ABCL/1 have added support for exception handling and reflection [22].
References-found: 62

