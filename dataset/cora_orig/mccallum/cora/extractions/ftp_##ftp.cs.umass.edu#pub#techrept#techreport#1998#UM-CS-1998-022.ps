URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1998/UM-CS-1998-022.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/98-022.html
Root-URL: 
Email: fnaumovic; avrunin; clarkeg@cs.umass.edu  
Title: Data Flow Analysis for Checking Properties of Concurrent Java Programs  
Author: Gleb Naumovich, George S. Avrunin, and Lori A. Clarke 
Address: Amherst, MA 01003-6410  
Affiliation: Laboratory for Advanced Software Engineering Research Department of Computer Science University of Massachusetts at Amherst  
Abstract: In this paper we show how the FLAVERS data flow analysis technique, originally formulated for programs with the rendezvous model of concurrency, can be applied to concurrent Java programs. The general approach of FLAVERS is based on modeling a concurrent program as a flow graph and using a data flow analysis algorithm over this graph to check statically if a property holds on all executions of the program. The accuracy of this analysis can be improved by supplying additional information, represented as finite state automata, to the data flow analysis algorithm. In this paper we present a straightforward approach for modeling Java programs that uses the accuracy improving mechanism to represent the possible communications among threads in Java programs, instead of representing them directly in the flow graph model. We also discuss a number of error-prone thread communication patterns that can arise in Java and describe how FLAVERS can be used to check for the presence of these. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Shing Chi Cheung and Jeff Kramer. </author> <title> Tractable dataflow analysis for distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(8):579593, </volume> <month> August </month> <year> 1994. </year>
Reference-contexts: As an alternative to reachability approaches, data flow analyses for concurrent software have been formulated with low-order polynomial execution time and storage bounds. Most of these have been defined to check application-independent properties (e.g. <ref> [1, 8, 12] </ref>).
Reference: [2] <author> James C. Corbett. </author> <title> Constructing compact models of concurrent Java programs. </title> <booktitle> In ACM SIGSOFT Proceedings of the 1998 International Symposium on Software Testing and Analysis, </booktitle> <pages> pages 110, </pages> <year> 1998. </year>
Reference-contexts: These models are different from the Java model, which supports monitors and a mixture of low-level thread synchronization primitives. There has been some recent work concerned with modeling Java programs. Corbett <ref> [2] </ref> describes a technique for constructing compact finite state models for Java. This approach relies on a data flow algorithm for constructing an approximation of the run-time structure of the program heap that is then used to reduce the size of the concurrency model. <p> Alias resolution, including dealing with method (and thread object) polymor-phism, is also an important issue. For the purposes of this paper we assume that alias resolution has been conservatively performed, using techniques such as <ref> [2, 5, 11] </ref>. The monitor-based model of communications between threads is significantly different from the communication mechanisms used by other popular concurrent languages, such as the rendezvous model of Ada 83 and CSP or the message sending model of Promela.
Reference: [3] <author> Claudio Demartini and Riccardo Sisto. </author> <title> Static analysis of Java multithreaded and distributed applications. </title> <booktitle> To appear in Proceedings of the International Symposium on Software Engineering for Parallel and Distributed Systems, </booktitle> <month> April </month> <year> 1998. </year>
Reference-contexts: This alias resolution approach could also be used to reduce the size of our flow graph program model. In this paper, however, we have not focused on the derivation of the program model. Demartini and Sisto <ref> [3] </ref> describe two models of Java programs. The first method models Java programs with Petri nets and the second models Java programs with Promela code. Both these models are intended to be used for reach-ability analysis.
Reference: [4] <author> Matthew Dwyer and Lori Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <booktitle> In ACM SIGSOFT'94 Software Engineering Notes, Proceedings of the Second ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 6275, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: FLAVERS (FLow Analysis for VERification of Systems) uses data flow analysis techniques to verify user-specified properties of software systems <ref> [4] </ref>. The attractiveness of this approach is in its low-order polynomial complexity bounds and its ability to improve the precision of the analysis by incrementally improving the accuracy of the program model. <p> For example, the use of a variable var that occurs in thread t could be labeled (use var; t; fl). 2 Also, some of the constraints modeling thread interactions can be incorporated into the thread automata feasibility constraints (called task au tomata in <ref> [4] </ref>). 4 (waiting; t; o) (notified-entry; t; o) (wait; t; o) (wait; t; o) For the purposes of our analysis, additional modeling is required for wait () method calls and synchronized blocks.
Reference: [5] <author> William Landi and Barbara Ryder. </author> <title> Pointer-induced aliasing: A problem taxonomy. </title> <booktitle> In Conference Record of the 18th Annual ACM Symposium on Principles of Programming Languages (POPL '91), </booktitle> <pages> pages 93103, </pages> <address> Orlando, FL, USA, </address> <month> January </month> <year> 1991. </year> <note> ACM Press. </note>
Reference-contexts: Alias resolution, including dealing with method (and thread object) polymor-phism, is also an important issue. For the purposes of this paper we assume that alias resolution has been conservatively performed, using techniques such as <ref> [2, 5, 11] </ref>. The monitor-based model of communications between threads is significantly different from the communication mechanisms used by other popular concurrent languages, such as the rendezvous model of Ada 83 and CSP or the message sending model of Promela.
Reference: [6] <author> Doug Lea. </author> <title> Concurrent Programming in Java. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1997. </year>
Reference-contexts: At present we are working on extending the approach to handle executions that may not terminate. 5.4 No Unnecessary Notifications Execution of notification methods, especially notifyAll (), is expensive <ref> [6] </ref>. Thus, notifications issued when no threads are waiting are wasteful. In addition, they also may indicate suspicious logic (e.g. where the programmer assumes erroneously that some threads may be waiting).
Reference: [7] <author> Thomas J. Marlowe and Barbara G. Ryder. </author> <title> Properties of data flow frameworks. </title> <journal> Acta Informatica, </journal> <volume> 28(2):121 163, </volume> <year> 1990. </year>
Reference-contexts: Once the solution of this data flow problem converges to a join over all paths solution <ref> [7] </ref>, we need to look only at the final node of the TFG to determine whether the property holds.
Reference: [8] <author> Stephen P. Masticola and Barbara G. Ryder. </author> <title> Static infinite wait anomaly detection in polynomial time. </title> <editor> In 11 David A. Padua, editor, </editor> <booktitle> Proceedings of the 1990 In--ternational Conference on Parallel Processing. </booktitle> <volume> Volume 2: Software, </volume> <pages> pages 7887, </pages> <address> Urbana-Champaign, IL, </address> <month> August </month> <year> 1990. </year> <institution> Pennsylvania State University Press. </institution>
Reference-contexts: As an alternative to reachability approaches, data flow analyses for concurrent software have been formulated with low-order polynomial execution time and storage bounds. Most of these have been defined to check application-independent properties (e.g. <ref> [1, 8, 12] </ref>).
Reference: [9] <author> Gleb Naumovich and George S. Avrunin. </author> <title> A conservative data flow algorithm for detecting all pairs of statements that may happen in parallel. </title> <type> Technical Report 98-23, </type> <institution> University of Massachusetts, Amherst, </institution> <month> April </month> <year> 1998. </year>
Reference-contexts: In addition, may immediately precede (MIP) edges are added between nodes in separate CFGs to represent possible interleavings of the actions associated with these nodes. The set of such edges can be computed efficiently <ref> [9] </ref>. The set of all events associated with a model of the program is the alphabet of the TFG. The language of the TFG is the set of event sequences that occur on paths from the initial node to the final node. <p> The CFGs for individual threads are combined into a TFG by using only the MIP edges, without communication nodes used by FLAVERS/Ada. We have developed a conservative algorithm for computing this information that is similar to our algorithm for Ada <ref> [9] </ref>. Note that even without representing thread communications explicitly in our Java graph model, this model conservatively overapproximates all possible executions of a program. shaded regions include nodes in the monitor of the program, solid edges represent control flow within individual threads and dashed edges are MIP edges.
Reference: [10] <author> Gleb Naumovich, Lori A. Clarke, and Leon J. Oster-weil. </author> <title> Comparing implementation strategies for composite data flow analysis problems. </title> <booktitle> To appear in proceedings of SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools and Engineering, </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: In practice, we use an efficient approach where the full product automaton is not actually created <ref> [10] </ref>. The containment problem on the property automaton is replaced with the containment problem on the product automaton.
Reference: [11] <author> John Plevyak and Andrew A. Chien. </author> <title> Precise concrete type inference for object-oriented languages. </title> <booktitle> In ACM SIGPLAN Proceedings of the 1994 Conference on Object-Oriented Programming, </booktitle> <pages> pages 324340, </pages> <year> 1994. </year>
Reference-contexts: Alias resolution, including dealing with method (and thread object) polymor-phism, is also an important issue. For the purposes of this paper we assume that alias resolution has been conservatively performed, using techniques such as <ref> [2, 5, 11] </ref>. The monitor-based model of communications between threads is significantly different from the communication mechanisms used by other popular concurrent languages, such as the rendezvous model of Ada 83 and CSP or the message sending model of Promela.
Reference: [12] <author> John H. Reif and Scott A. Smolka. </author> <title> Data flow analysis of distributed communicating processes. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 19(1):130, </volume> <month> Febru-ary </month> <year> 1990. </year>
Reference-contexts: As an alternative to reachability approaches, data flow analyses for concurrent software have been formulated with low-order polynomial execution time and storage bounds. Most of these have been defined to check application-independent properties (e.g. <ref> [1, 8, 12] </ref>).
Reference: [13] <author> Richard N. Taylor and L. J. Osterweil. </author> <title> Anomaly detection in concurrent software by static data flow analysis. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 6(3):265278, </volume> <month> May </month> <year> 1980. </year> <month> 12 </month>
Reference-contexts: Well-known examples are deadlocks and livelocks, when all or some of the threads in the program are stalled, and concurrent def-use faults <ref> [13] </ref>. Most of other concurrency faults identified in the static analysis literature are application-specific. This low number of general concurrency faults is explained by the fact that most static analysis approaches deal with high-level rendezvous or message-sending concurrency models. Java provides a number of specialized, often low-level, thread communication mechanisms.
References-found: 13

