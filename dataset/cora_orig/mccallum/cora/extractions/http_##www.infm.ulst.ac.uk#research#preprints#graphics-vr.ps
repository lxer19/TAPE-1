URL: http://www.infm.ulst.ac.uk/research/preprints/graphics-vr.ps
Refering-URL: http://www.infm.ulst.ac.uk/research/preprints.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: On the Computational Requirements of Virtual Reality Systems 1  
Author: Frank Devai 
Affiliation: School of Computing Mathematics, University of Ulster  
Abstract: The computational requirements of high-quality, real-time rendering exceeds the limits of generally available computing power. However illumination effects, except shadows, are less noticeable on moving pictures. Shadows can be produced with the same techniques used for visibility computations, therefore the basic requirements of real-time rendering are transformations, pre-selection of the part of the scene to be displayed and visibility computations. Transformations scale well, ie, their time requirement grows linearly with the input size. Pre-selection, if implemented by the traditional way of polygon clipping, has a growing rate of N log N in the worst case, where N is the total number of edges in the scene. Visibility computations, exhibiting a quadratic growing rate, are the bottleneck from a theoretical point of view. Three approaches are discussed to speed up visibility computations: (i) reducing the expected running time to O(N log N ) (ii) using approximation algorithms with O(N K) worst-case time, where K is the linear resolution of the image, and (iii) applying parallel techniques leading to logarithmic time in the worst-case. Though the growing rate of the time requirement of pre-selection is significantly slower than that of visibility, it is demonstrated that pre-selection has to deal with a significantly higher amount of data than visibility computations, as the average clipping volume is 1/27 of the volume of the model.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aho, A. V., Hopcroft, J. E. and Ullman, J. D. </author> <title> Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass. </address> <year> 1975. </year>
Reference-contexts: Therefore, the total number of edges of G is at most 5N . 2 The linearly ordered set T can be realised by a balanced tree <ref> [1, 2] </ref> such that the leaf nodes of the tree are labelled by line equations, and are also threaded by a doubly linked list. Then the operations insert and delete can be implemented in O (log N ) time, while above and below in constant time. <p> A binary z-tree for N line segments and K pixels can be built in O (N log K) time, and takes O (K) space in the worst case [23]. The visibility of the scan line can be obtained by a preorder traversal <ref> [1] </ref> of the z-tree. Let V be initially the root node of the tree, and let F be a background segment which is farther from the viewpoint u than any other segment in the scan plane.
Reference: [2] <author> Aho, A. V., Hopcroft, J. E. and Ullman, J. D. </author> <title> Data Structures and Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass. </address> <year> 1983. </year>
Reference-contexts: Therefore, the total number of edges of G is at most 5N . 2 The linearly ordered set T can be realised by a balanced tree <ref> [1, 2] </ref> such that the leaf nodes of the tree are labelled by line equations, and are also threaded by a doubly linked list. Then the operations insert and delete can be implemented in O (log N ) time, while above and below in constant time. <p> While traversing the regions of G, one has to account at most one insertion and at most one deletion for each crossing of an arc of G. Both an insertion and a deletion can be done in O (log N ) time <ref> [2, 52, 75] </ref> and the number of arcs is O (N + k), therefore step (2), and also the whole algorithm, can be implemented in O ((N + k) log N ) time.
Reference: [3] <author> Atallah, M. J., Cole R., Goodrich M. T. </author> <title> Cascading divide-and-conquer | a technique for designing parallel algorithms. </title> <note> SIAM Journal on Computing 18,3 (1989) 499-532. </note>
Reference-contexts: If the output for the exact solution is required in a sorted order, it is easy to provide an (n log n) lower bound by demonstrating that sorting is reducible to the planar visibility problem <ref> [3] </ref>. However, this is the time requirement for sorting the output, which is not inherently required. <p> Another algorithm, based on a divide-and conquer approach and called the merge method also achieves the optimal O (n log n) worst-case time <ref> [3] </ref>. Early scan-line algorithms [8, 87] take fi (n 2 ) time in the worst case [19], and attempt to exploit coherence [32, 65] which is no longer possible in a parallel environment, where adjacent scan lines may be processed by different processors. <p> Both the priority-queue [19] and the merge 22 z u x ,j ( ' x i i <ref> [3] </ref> methods take fi (n log n) time in the worst case, ie, these methods are best possible in terms of worst-case time, but use sorting, and merging of visible sets of line segments, therefore less appropriate for hardware implementation. <p> Asymptotic analysis, however, cannot 26 method time space z-buffer [32, 65] fi (nr) fi (n + r) Watkins [32, 65] fi (n 2 ) fi (n) priority-queue [19] fi (n log n) fi (n) merge <ref> [3] </ref> fi (n log n) fi (n) z-tree [23] fi (n log r) fi (n + r) Warnock fi (n log r) fi (n log r) recursive subdivision fi (n log r) fi (n log r) random fi (n 2 ) fi (n 2 ) trapezoid fi (n 2 ) fi
Reference: [4] <author> Balch, D. C., Tichenor, J. M. </author> <title> Telemedicine expanding the scope of health-care information. </title> <journal> Journal of the American Medical Informatics Association 4,1 (1997) 1-5. </journal>
Reference-contexts: Lag is critical when trying to achieve immersion [86]. In spite of the shortcomings of contemporary VR systems, a wide range of application areas are reported in the literature: flight [71] and driving [5] simulation, scientific visualisation [9], medicine <ref> [4, 44] </ref>, walk-through and fly-through of complex environments [28, 48, 88, 89], lighting-design [28] and even performance analysis of parallel computer systems [70]. Cobb et al [14] examined the feasibility of VR as a tool for the UK manufacturing industry.
Reference: [5] <author> Bayarri, S., Fernandez, M., Perez, M. </author> <title> Virtual reality for driving simulation. </title> <journal> Communications of the ACM 39,5 (1996) 72-76. </journal>
Reference-contexts: Lag is critical when trying to achieve immersion [86]. In spite of the shortcomings of contemporary VR systems, a wide range of application areas are reported in the literature: flight [71] and driving <ref> [5] </ref> simulation, scientific visualisation [9], medicine [4, 44], walk-through and fly-through of complex environments [28, 48, 88, 89], lighting-design [28] and even performance analysis of parallel computer systems [70]. Cobb et al [14] examined the feasibility of VR as a tool for the UK manufacturing industry.
Reference: [6] <author> Ben-Or, M. </author> <title> Lower bounds for algebraic computation trees. </title> <booktitle> Proc. 15th ACM Annual Symp. on Theory of Computing (Apr. </booktitle> <year> 1983) </year> <month> 80-86. 29 </month>
Reference-contexts: Then if any interval in L inP has a length less than ", return a Yes, otherwise a No answer for the "-closeness problem. The "-closeness problem takes (N log N ) time in the worst case, assuming the algebraic tree model of computation <ref> [6] </ref>. Let T A (N ) be the running time of algorithm A. <p> It is relatively straightforward to establish the complexity of the interval-union problem under a more general model of computation, called the algebraic tree <ref> [6] </ref> by demonstrating that any algorithm that can find the union of N intervals can also decide the element distinctness problem. The element distinctness problem is stated as follows [69].
Reference: [7] <author> Bentley, J. L., Ottmann, T. </author> <title> Algorithms for reporting and counting geometric intersections. </title> <journal> IEEE Trans. Comput. </journal> <note> C-28 (Sep. </note> <year> 1979) </year> <month> 643-647. </month>
Reference-contexts: The polygon corresponding to the minimum element of H will be visible within the currently visited region. Step (1) can be implemented in O ((N + k) log N ) time <ref> [7, 10, 64] </ref>. While traversing the regions of G, one has to account at most one insertion and at most one deletion for each crossing of an arc of G.
Reference: [8] <author> Bouknight, W. J. </author> <title> A procedure for generation of three-dimensional half-toned computer graphics presentations. </title> <journal> Comm. ACM 13,9 (Sep. </journal> <year> 1970) </year> <month> 527-536. </month>
Reference-contexts: Another algorithm, based on a divide-and conquer approach and called the merge method also achieves the optimal O (n log n) worst-case time [3]. Early scan-line algorithms <ref> [8, 87] </ref> take fi (n 2 ) time in the worst case [19], and attempt to exploit coherence [32, 65] which is no longer possible in a parallel environment, where adjacent scan lines may be processed by different processors.
Reference: [9] <author> Bryson, S. </author> <title> Virtual reality in scientific visualization. </title> <journal> Communications of the ACM 39,5 (1996) 62-71. </journal>
Reference-contexts: Lag is critical when trying to achieve immersion [86]. In spite of the shortcomings of contemporary VR systems, a wide range of application areas are reported in the literature: flight [71] and driving [5] simulation, scientific visualisation <ref> [9] </ref>, medicine [4, 44], walk-through and fly-through of complex environments [28, 48, 88, 89], lighting-design [28] and even performance analysis of parallel computer systems [70]. Cobb et al [14] examined the feasibility of VR as a tool for the UK manufacturing industry. <p> Slater and Usoh [76] propose an alternative viewing pipeline simulating peripheral vision in immersive virtual environments. Peripheral vision offers important cues for direction of gaze and movement. Relatively few papers <ref> [9, 47] </ref> deal with the design and computational requirements of VR systems. Development has traditionally been extensive in computer graphics: bigger memories and faster processors are becoming available due to increasingly faster electronic components. However, there are two inherent difficulties with this way of development.
Reference: [10] <author> Chazelle, B., Edelsbrunner H. </author> <title> An optimal algorithm for intersecting line segments in the plane. </title> <journal> Journal of the Association for Computing Machinery 39,1 (Jan. </journal> <year> 1992) </year> <month> 1-54. </month>
Reference-contexts: The polygon corresponding to the minimum element of H will be visible within the currently visited region. Step (1) can be implemented in O ((N + k) log N ) time <ref> [7, 10, 64] </ref>. While traversing the regions of G, one has to account at most one insertion and at most one deletion for each crossing of an arc of G.
Reference: [11] <author> Clarkson, K. L., Shor, P. W. </author> <title> Applications of random sampling in computational geometry II. </title> <booktitle> Discrete and Computational Geometry 4,1 1989, </booktitle> <pages> 387-421. </pages>
Reference-contexts: The average running time can be significantly better for some of the algorithms, and indeed, expected-time analyses of probabilistic algorithms attracted much attention recently <ref> [11, 12, 13, 62, 63] </ref>.
Reference: [12] <author> Clarkson, K. L. </author> <title> Randomized geometric algorithms. Computers and Euclidean Geometry 1992. </title>
Reference-contexts: The average running time can be significantly better for some of the algorithms, and indeed, expected-time analyses of probabilistic algorithms attracted much attention recently <ref> [11, 12, 13, 62, 63] </ref>.
Reference: [13] <author> Clarkson, K. L., Cole, R., Tarjan, R. E. </author> <title> Randomized parallel algorithms for trapezoidal diagrams. </title> <journal> Int. J. Comp. Geom. and Applications 1992, </journal> <pages> 117-133. </pages>
Reference-contexts: The average running time can be significantly better for some of the algorithms, and indeed, expected-time analyses of probabilistic algorithms attracted much attention recently <ref> [11, 12, 13, 62, 63] </ref>.
Reference: [14] <author> Cobb, S. V. G., Dcruz, M. D., Wilson, J. R. </author> <title> Integrated manufacture | a role for virtual-reality. </title> <journal> International Journal of Industrial Ergonomics 16,4-6 (1995) 411-425. </journal>
Reference-contexts: Cobb et al <ref> [14] </ref> examined the feasibility of VR as a tool for the UK manufacturing industry.
Reference: [15] <author> Cole, R. </author> <title> Parallel merge sort. </title> <journal> SIAM J. Computing 17,4 (Aug. </journal> <year> 1988) </year> <month> 770-785. </month>
Reference-contexts: The parallel hidden-line algorithm proposed earlier [22] uses a parallel sorting algorithm as a preprocessing step, and parallel sorting seems to be a promising starting point also for the interval-union problem. We can use an optimal EREW parallel sorting algorithm proposed by Cole <ref> [15] </ref>. Unfortunately, the hidden-line problem is significantly more difficult than sorting, and the earlier parallel hidden-line algorithm [22] relies heavily on concurrent-read operations. In section 5.1 we introduce the problem of union of point sets. <p> of the real line can be computed in O (log N ) time in the worst case by using N processors, assuming the EREW PRAM model of computation. 19 Proof : Step (1) can be implemented in O (log N ) time by using N processors under the EREW model <ref> [15] </ref>. Step (3) and therefore step (6) take O (log N ) time and N= log N processors assuming the EREW model [54]. Steps (2), (4) and (5) take constant time and N processors.
Reference: [16] <author> Cook, S., Dwork, C. </author> <title> Bounds on the time for parallel RAMs to compute simple functions. </title> <booktitle> Proc. 14th ACM Symp. on Theory of Computing, </booktitle> <address> San Francisco, California, </address> <month> (May, </month> <year> 1982) </year> <month> 231-233. </month>
Reference-contexts: Using N 2 processors, the algorithm can be executed for N edges within the same time under the EREW model. It follows from the definition of visibility that finding the maximum of N integers is constant-time reducible to the hidden line problem by using N processors. Cook and Dwork <ref> [16] </ref> have given an (log N ) lower bound for finding the maximum of N integers allowing infinitely many processors of a CREW PRAM model.
Reference: [17] <author> Coppen, D., Hawes, D., Slater, M., Davison, A. </author> <title> Distributed frame buffer for rapid dynamic changes to 3D scenes. Computers & Graphics 19,2 (1995) 247-250. [18] de Berg, M. Ray shooting, depth orders and hidden-surface removal. </title> <booktitle> Lecture Notes in Computer Science 703, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1993, </year> <pages> 201 pp. </pages>
Reference-contexts: On the hardware level graphics accelerators [50, 51], logic-enhanced memories [36, 51, 60], texture mapping [51] and scaleable architectures [27, 51, 60] are the new developments. Coppen et al <ref> [17] </ref> describe a distributed frame buffer architecture, designed to achieve fast display updates in response to dynamic transformations of graphical objects. As a matter of fact, developing scaleable architectures are basically the same concept as reducing the growing rate of algorithms.
Reference: [19] <author> Devai, F. </author> <title> Complexity of two-dimensional visibility computations. </title> <booktitle> Proc. 3rd European Conference on CAD/CAM and Computer Graphics, </booktitle> <address> Paris, France, </address> <month> Feb. </month> <year> 1984, </year> <journal> MICAD'84 Vol. </journal> <volume> 3, </volume> <pages> 827-841. </pages>
Reference-contexts: Schaufler and Sturzlinger [73] propose a three-dimensional image cache. Another group of new techniques are hierarchical or level-of-detail algorithms and object simplification [43, 47, 72, 80, 81]. VR applications also increased the practical significance of research on reducing the growing rate of visibility algorithms <ref> [19, 20, 21, 18, 58, 59] </ref> both in the worst case and on the average. <p> The binary-partition-tree method [62] can solve the visibility problem in O (n log n) expected time after some preprocessing. The priority-queue method, proposed earlier by the author <ref> [19] </ref>, solves the problem in O (n log n) worst-case time without the need for preprocessing by using a plane-sweep method and maintaining a priority queue of line segments. <p> Another algorithm, based on a divide-and conquer approach and called the merge method also achieves the optimal O (n log n) worst-case time [3]. Early scan-line algorithms [8, 87] take fi (n 2 ) time in the worst case <ref> [19] </ref>, and attempt to exploit coherence [32, 65] which is no longer possible in a parallel environment, where adjacent scan lines may be processed by different processors. Both the priority-queue [19] and the merge 22 z u x ,j ( ' x i i [3] methods take fi (n log n) <p> Early scan-line algorithms [8, 87] take fi (n 2 ) time in the worst case <ref> [19] </ref>, and attempt to exploit coherence [32, 65] which is no longer possible in a parallel environment, where adjacent scan lines may be processed by different processors. Both the priority-queue [19] and the merge 22 z u x ,j ( ' x i i [3] methods take fi (n log n) time in the worst case, ie, these methods are best possible in terms of worst-case time, but use sorting, and merging of visible sets of line segments, therefore less appropriate <p> Asymptotic analysis, however, cannot 26 method time space z-buffer [32, 65] fi (nr) fi (n + r) Watkins [32, 65] fi (n 2 ) fi (n) priority-queue <ref> [19] </ref> fi (n log n) fi (n) merge [3] fi (n log n) fi (n) z-tree [23] fi (n log r) fi (n + r) Warnock fi (n log r) fi (n log r) recursive subdivision fi (n log r) fi (n log r) random fi (n 2 ) fi (n <p> Constant factors can be determined from time measurements in the actual machine environment where the algorithms are to be used. Kremer-Patard [53] used manually generated input to compare some algorithms including the priority-queue method <ref> [19] </ref>. Another possibility is to extract the input data from real three-dimensional models. Considering the number of possible algorithms together with their variants, the number of time measurements required for conclusive results would be too high, and this method would be too expensive and time consuming.
Reference: [20] <author> Devai, F. </author> <title> Quadratic bounds for hidden-line elimination. </title> <booktitle> Proc. Second Annual ACM Symposium on Computational Geometry, </booktitle> <address> Yorktown Heights, New York, USA, </address> <month> June 2-4, </month> <year> 1986, </year> <pages> 269-275. </pages>
Reference-contexts: Schaufler and Sturzlinger [73] propose a three-dimensional image cache. Another group of new techniques are hierarchical or level-of-detail algorithms and object simplification [43, 47, 72, 80, 81]. VR applications also increased the practical significance of research on reducing the growing rate of visibility algorithms <ref> [19, 20, 21, 18, 58, 59] </ref> both in the worst case and on the average. <p> VR applications also increased the practical significance of research on reducing the growing rate of visibility algorithms [19, 20, 21, 18, 58, 59] both in the worst case and on the average. Though the concept output-sensitive visibility algorithms has been raised as early as the 1986 Computational Geometry conference <ref> [20, 66] </ref> Sudarsky and Gotsman [77] recently reported the application of output-sensitive visibility algorithms to dynamic scenes in VR. On the hardware level graphics accelerators [50, 51], logic-enhanced memories [36, 51, 60], texture mapping [51] and scaleable architectures [27, 51, 60] are the new developments. <p> and horizontal rectangles can force any hidden-line or hidden-surface algorithm to take at least quadratic time in the worst case. (This result is wrongly attributed to Fiume [30] by Foley et al [32, 33].) The quadratic lower bound can be demonstrated even if the input is only one simple polyhedron <ref> [20] </ref>. A constant running time, ie, a running time independent of the size of the input is a nonsense, which is impossible to achieve even with parallel processing. <p> Though it has been demonstrated that fi (N 2 ) 13 worst-case time can actually be attained both for the hidden-line <ref> [20] </ref> and for the hidden-surface problem [59] it is not easy to reduce below fi (N 2 log N ) for any practical algorithm. Our worst-case lower bound is based on the fact that there can be (N 2 ) intersection points. <p> hidden-line algorithm is optimal in a stronger sense, ie, its running time cannot be further improved, an interesting question arises: would N 2 = log N processors be sufficient to maintain O (log N ) time? The proof of the O (N 2 ) sequential complexity of the hidden-line problem <ref> [20] </ref> is based on an optimal algorithm for the arrangement of N lines in the plane. Recently Goodrich [39] proposed an optimal parallel algorithm for constructing line arrangements. Combining Goodrich's result with the techniques presented here and in [20] the question can be answered affirmatively. <p> of the O (N 2 ) sequential complexity of the hidden-line problem <ref> [20] </ref> is based on an optimal algorithm for the arrangement of N lines in the plane. Recently Goodrich [39] proposed an optimal parallel algorithm for constructing line arrangements. Combining Goodrich's result with the techniques presented here and in [20] the question can be answered affirmatively. The resulting algorithm, however, is significantly more complicated than the one presented here. The theoretical significance of the above results is the demonstration that the exact hidden-line problem is amenable to parallelization.
Reference: [21] <author> Devai, F. </author> <title> An intersection-sensitive hidden-surface algorithm. </title> <booktitle> Proc. </booktitle> <editor> Eurographics'87, Marechal, G. (Ed.) </editor> <address> Amsterdam, the Netherlands (Aug. 24-28, </address> <year> 1987) </year> <month> 495-502. </month>
Reference-contexts: Schaufler and Sturzlinger [73] propose a three-dimensional image cache. Another group of new techniques are hierarchical or level-of-detail algorithms and object simplification [43, 47, 72, 80, 81]. VR applications also increased the practical significance of research on reducing the growing rate of visibility algorithms <ref> [19, 20, 21, 18, 58, 59] </ref> both in the worst case and on the average. <p> Indeed, the algorithm given below takes O ((N + k) log N ) time, where k, k &lt; 0 &lt; N (N 1)=2, is the total number of intersection points. The following observations are used <ref> [21] </ref>. If all polygons are projected into the viewing plane , the edges of the polygons induce a planar subdivision G of . To avoid confusion, the vertices, edges and faces of G will be referred to as nodes, arcs and regions respectively.
Reference: [22] <author> Devai, F. </author> <title> An O(log N ) parallel time exact hidden-line algorithm. </title> <editor> In: Kuijk, A. A. M., Strasser, W. </editor> <booktitle> (Eds) Advances in Graphics Hardware II, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1988, </year> <pages> 65-73. </pages>
Reference-contexts: While it is well known that approximation methods such as the z-buffer, and ray tracing algorithms are relatively easy to implement on parallel computers, the parallel complexity of the exact hidden-line problem has been established only recently <ref> [22, 25] </ref>. Though these results are based on a theoretical model of parallel computation, the proposed algorithms can also be executed on real parallel machines in O (log d N ) time, where 3 d is a small positive constant depending on the particular machine. <p> It has been demonstrated that the exact hidden-line problem can be solved in fi (log N ) time in the worst case with N 2 processors, and that the fi (log N ) time cannot be further improved in the CREW PRAM model, even if arbitrarily many processors are available <ref> [22] </ref>. We prove the same result for the EREW model [25]. The EREW model is the variant of PRAM closest to real machines. First we propose a parallel algorithm for determining the union of a set of intervals, and then we use this algorithm to develop a parallel hidden-line algorithm. <p> First we propose a parallel algorithm for determining the union of a set of intervals, and then we use this algorithm to develop a parallel hidden-line algorithm. No parallel algorithm is known in the literature for the interval-union problem, though it has been demonstrated <ref> [22] </ref> that the hidden-line problem can be solved in fi (log N ) time with N 2 processors under the CREW model. The parallel hidden-line algorithm proposed earlier [22] uses a parallel sorting algorithm as a preprocessing step, and parallel sorting seems to be a promising starting point also for the <p> No parallel algorithm is known in the literature for the interval-union problem, though it has been demonstrated <ref> [22] </ref> that the hidden-line problem can be solved in fi (log N ) time with N 2 processors under the CREW model. The parallel hidden-line algorithm proposed earlier [22] uses a parallel sorting algorithm as a preprocessing step, and parallel sorting seems to be a promising starting point also for the interval-union problem. We can use an optimal EREW parallel sorting algorithm proposed by Cole [15]. <p> We can use an optimal EREW parallel sorting algorithm proposed by Cole [15]. Unfortunately, the hidden-line problem is significantly more difficult than sorting, and the earlier parallel hidden-line algorithm <ref> [22] </ref> relies heavily on concurrent-read operations. In section 5.1 we introduce the problem of union of point sets.
Reference: [23] <author> Devai, F. </author> <title> Approximation algorithms for high-resolution display. </title> <booktitle> Proc. PIXIM'88, 1st International Conference on Computer Graphics in Paris, </booktitle> <editor> Peroche, B. (Ed) France, </editor> <month> Oct. </month> <pages> 24-28, </pages> <year> 1988, </year> <pages> 121-130. </pages>
Reference-contexts: A binary z-tree for N line segments and K pixels can be built in O (N log K) time, and takes O (K) space in the worst case <ref> [23] </ref>. The visibility of the scan line can be obtained by a preorder traversal [1] of the z-tree. Let V be initially the root node of the tree, and let F be a background segment which is farther from the viewpoint u than any other segment in the scan plane. <p> Therefore, the scan line variant of the z-tree method takes O (N log K + K) time in the worst case. A three-dimensional generalisation of the z-tree method generates a hierarchical data structure in O (N K) time that can be displayed in O (K 2 ) time <ref> [23] </ref>. 16 5 Parallel complexity Distinguishing exact and approximation methods is also important when considering parallel solutions to the visibility problem. Most parallel approaches recommended until recently are based on the z-buffer [36, 61] or ray-tracing [49, 68] methods that classify as approximation algorithms. <p> The slightly more sophisticated z-tree method <ref> [23] </ref> reduces the space requirement to fi (n+r) while retaining the fi (n log r) worst-case time bound. Now let us return to the analysis of the planar Warnock method. First we observe that both methods make the same window subdivisions. <p> Asymptotic analysis, however, cannot 26 method time space z-buffer [32, 65] fi (nr) fi (n + r) Watkins [32, 65] fi (n 2 ) fi (n) priority-queue [19] fi (n log n) fi (n) merge [3] fi (n log n) fi (n) z-tree <ref> [23] </ref> fi (n log r) fi (n + r) Warnock fi (n log r) fi (n log r) recursive subdivision fi (n log r) fi (n log r) random fi (n 2 ) fi (n 2 ) trapezoid fi (n 2 ) fi (n 2 ) Table 2: Worst-case time and
Reference: [24] <author> Devai, F. </author> <title> Computational Geometry and Image Synthesis. </title> <booktitle> Lecture notes for Course 2, PIXIM'89, 2nd International Conference on Computer Graphics in Paris, </booktitle> <address> France, </address> <month> Sept. </month> <pages> 25-29, </pages> <year> 1989, </year> <pages> 88 pp. </pages>
Reference-contexts: Clipping can be reduced to the problem of determining the intersection of a line segment with a set of polygons that can be solved in O (N log N ) time in the worst case <ref> [24] </ref>. In section 2.2 we will demonstrate that clipping can also be done in linear time if preprocessing is allowed. <p> Warnock developed an algorithm that uses the observation that pixels within large areas of the image are coherent in the sense that they represent a single polygon [65, 32]. However, it has been demonstrated <ref> [24] </ref> that Warnock's algorithm also takes fi (K 2 N ) time in the worst case. Greene et al [41] describe a heuristic method similar to Warnock's algorithm, and report that a hierarchical approach can be faster in practice than the ordinary z-buffer algorithm.
Reference: [25] <author> Devai, F. </author> <title> An optimal parallel algorithm for the visualisation of solid models. In: Applications of Supercomputers in Engineering III, </title> <publisher> Elsevier Applied Science, </publisher> <address> London, </address> <year> 1993, </year> <pages> 199-210. </pages>
Reference-contexts: While it is well known that approximation methods such as the z-buffer, and ray tracing algorithms are relatively easy to implement on parallel computers, the parallel complexity of the exact hidden-line problem has been established only recently <ref> [22, 25] </ref>. Though these results are based on a theoretical model of parallel computation, the proposed algorithms can also be executed on real parallel machines in O (log d N ) time, where 3 d is a small positive constant depending on the particular machine. <p> We prove the same result for the EREW model <ref> [25] </ref>. The EREW model is the variant of PRAM closest to real machines. First we propose a parallel algorithm for determining the union of a set of intervals, and then we use this algorithm to develop a parallel hidden-line algorithm.
Reference: [26] <author> Devai, F. </author> <title> On the complexity of some geometric intersection problems. </title> <note> Journal of Computing and Information 1,1 (May 1995) 333-352. </note>
Reference-contexts: In this section we will demonstrate that it can also be done in linear time if some preprocessing is allowed <ref> [26] </ref>. The intersection of an arbitrary polygon with any face of the clipping volume can be obtained by determining the intersection of a line segment and a polygon.
Reference: [27] <author> Devai, F. </author> <title> Scan-line methods for parallel rendering. </title> <note> In: </note> <author> Chen, M., Townsend, P., Vince J. A. </author> <title> (Eds) High-Performance Computing for Computer Graphics and Visualisation. </title> <publisher> Springer Verlag, </publisher> <address> London, </address> <year> 1996, </year> <pages> 88-98. </pages>
Reference-contexts: On the hardware level graphics accelerators [50, 51], logic-enhanced memories [36, 51, 60], texture mapping [51] and scaleable architectures <ref> [27, 51, 60] </ref> are the new developments. Coppen et al [17] describe a distributed frame buffer architecture, designed to achieve fast display updates in response to dynamic transformations of graphical objects. <p> A more practical approach with the technology available in the foreseeable future is to assign a processor to each row of picture elements of a raster-scan image, in order to compute the image of that particular row <ref> [27] </ref>. Then the dominant computational problem is the determination of the visibility of a planar set of line segments. In section 6 distributed-memory parallel algorithms are considered. <p> A practical approach with the technology available in the foreseeable future is to assign a processor to each row of picture elements of a raster-scan image, in order to compute the image of that particular row <ref> [27] </ref>. Then the dominant computational problem is the determination of the visibility of a planar set of line segments.
Reference: [28] <author> Dobashi, Y., Kaneda, K., Nakatani, H., Yamashita, H., Nishita, T. </author> <title> A quick rendering method using basis functions for interactive lighting-design. </title> <journal> Computer Graphics Forum 14,3 (1995) c229. </journal>
Reference-contexts: Lag is critical when trying to achieve immersion [86]. In spite of the shortcomings of contemporary VR systems, a wide range of application areas are reported in the literature: flight [71] and driving [5] simulation, scientific visualisation [9], medicine [4, 44], walk-through and fly-through of complex environments <ref> [28, 48, 88, 89] </ref>, lighting-design [28] and even performance analysis of parallel computer systems [70]. Cobb et al [14] examined the feasibility of VR as a tool for the UK manufacturing industry. <p> In spite of the shortcomings of contemporary VR systems, a wide range of application areas are reported in the literature: flight [71] and driving [5] simulation, scientific visualisation [9], medicine [4, 44], walk-through and fly-through of complex environments [28, 48, 88, 89], lighting-design <ref> [28] </ref> and even performance analysis of parallel computer systems [70]. Cobb et al [14] examined the feasibility of VR as a tool for the UK manufacturing industry.
Reference: [29] <author> Firebaugh, M. W. </author> <title> Computer Graphics. Tools for Visualization. Wm. </title> <address> C. </address> <publisher> Brown Publishers, Oxford, </publisher> <address> UK, </address> <year> 1993, </year> <pages> 547 pp. </pages>
Reference-contexts: Indeed, this theoretical background cannot even predict or explain the performance of the most widely used hidden-surface technique, the z-buffer algorithm. The 2 running time of the z-buffer algorithm is often claimed to be a linear function of the input size, or even constant <ref> [29, 31, 32, 33, 65, 85] </ref>.
Reference: [30] <author> Fiume, E. L. </author> <title> The Mathematical Structure of Raster Graphics. </title> <publisher> Academic Press, </publisher> <address> San Diego, </address> <year> 1989. </year>
Reference-contexts: On the other hand, Schmitt [74] demonstrated how vertical and horizontal rectangles can force any hidden-line or hidden-surface algorithm to take at least quadratic time in the worst case. (This result is wrongly attributed to Fiume <ref> [30] </ref> by Foley et al [32, 33].) The quadratic lower bound can be demonstrated even if the input is only one simple polyhedron [20].
Reference: [31] <author> Foley, J. D., van Dam, A. </author> <title> Fundamentals of Interactive Computer Graphics. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1982. </year> <pages> 664 pp. </pages>
Reference-contexts: Indeed, this theoretical background cannot even predict or explain the performance of the most widely used hidden-surface technique, the z-buffer algorithm. The 2 running time of the z-buffer algorithm is often claimed to be a linear function of the input size, or even constant <ref> [29, 31, 32, 33, 65, 85] </ref>.
Reference: [32] <author> Foley, J. D., van Dam, A., Feiner, S. K., Hughes, J. F. </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice. </booktitle> <publisher> (Second Edition) Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1990. </year> <pages> 1174 pp. </pages>
Reference-contexts: Indeed, this theoretical background cannot even predict or explain the performance of the most widely used hidden-surface technique, the z-buffer algorithm. The 2 running time of the z-buffer algorithm is often claimed to be a linear function of the input size, or even constant <ref> [29, 31, 32, 33, 65, 85] </ref>. <p> On the other hand, Schmitt [74] demonstrated how vertical and horizontal rectangles can force any hidden-line or hidden-surface algorithm to take at least quadratic time in the worst case. (This result is wrongly attributed to Fiume [30] by Foley et al <ref> [32, 33] </ref>.) The quadratic lower bound can be demonstrated even if the input is only one simple polyhedron [20]. A constant running time, ie, a running time independent of the size of the input is a nonsense, which is impossible to achieve even with parallel processing. <p> Note that no assumption on the distribution of the input data was made, the only requirement is that the expected number of edge intersections is O (N ). 4 Approximation algorithms A widely used classification of visibility algorithms distinguishes two main classes: object-space and image-space algorithms <ref> [32, 33, 65, 79] </ref>. <p> Object-space algorithms are supposed to make calculations on the three-dimensional scene, while image-space algorithms on the two-dimensional image. (Foley et al <ref> [32] </ref> use a slightly different terminology: image- and object-precision algorithms, actually with the same meaning.) Image-space algorithms are 14 also supposed to exploit the finite resolution of the image, while object-space algorithms are assumed to be independent of the display device. This classification, however, is inappropriate in some respects. <p> Warnock developed an algorithm that uses the observation that pixels within large areas of the image are coherent in the sense that they represent a single polygon <ref> [65, 32] </ref>. However, it has been demonstrated [24] that Warnock's algorithm also takes fi (K 2 N ) time in the worst case. <p> Recall that in computer graphics the (x; z) Cartesian coordinate system and u = (0; 1) are 21 assumed, the visible image is projected into the x-axis, and the algorithms for the solution of the problem are referred to as scan-line algorithms <ref> [32, 65] </ref>. An early algorithm, which takes fi (n 2 ) time in the worst case, was given by Watkins [32, 65]. In practice the z-buffer algorithm | an approximation method | is often used, where the image is divided into r equal picture elements. <p> u = (0; 1) are 21 assumed, the visible image is projected into the x-axis, and the algorithms for the solution of the problem are referred to as scan-line algorithms <ref> [32, 65] </ref>. An early algorithm, which takes fi (n 2 ) time in the worst case, was given by Watkins [32, 65]. In practice the z-buffer algorithm | an approximation method | is often used, where the image is divided into r equal picture elements. The visibility of each picture element is approximated by the visibility of a sample point, usually taken at the middle of the pixel. <p> Another algorithm, based on a divide-and conquer approach and called the merge method also achieves the optimal O (n log n) worst-case time [3]. Early scan-line algorithms [8, 87] take fi (n 2 ) time in the worst case [19], and attempt to exploit coherence <ref> [32, 65] </ref> which is no longer possible in a parallel environment, where adjacent scan lines may be processed by different processors. <p> First two hierarchical methods based on subdivision techniques, then two simple probabilistic algorithms are proposed. 6.2 Hierarchical methods A scan-line algorithm can be developed by using the ideas proposed by Warnock for determining the visibility of a set of polygons in three-dimensional space <ref> [32, 65] </ref>. An interval of the x-axis containing the image of the input set will be called the window. Warnock's basic idea is to attempt to display the image if it is simple, otherwise subdivide the window until the image is simple enough. <p> The average running time can be significantly better for some of the algorithms, and indeed, expected-time analyses of probabilistic algorithms attracted much attention recently [11, 12, 13, 62, 63]. Asymptotic analysis, however, cannot 26 method time space z-buffer <ref> [32, 65] </ref> fi (nr) fi (n + r) Watkins [32, 65] fi (n 2 ) fi (n) priority-queue [19] fi (n log n) fi (n) merge [3] fi (n log n) fi (n) z-tree [23] fi (n log r) fi (n + r) Warnock fi (n log r) fi (n log <p> The average running time can be significantly better for some of the algorithms, and indeed, expected-time analyses of probabilistic algorithms attracted much attention recently [11, 12, 13, 62, 63]. Asymptotic analysis, however, cannot 26 method time space z-buffer <ref> [32, 65] </ref> fi (nr) fi (n + r) Watkins [32, 65] fi (n 2 ) fi (n) priority-queue [19] fi (n log n) fi (n) merge [3] fi (n log n) fi (n) z-tree [23] fi (n log r) fi (n + r) Warnock fi (n log r) fi (n log r) recursive subdivision fi (n log r) fi (n
Reference: [33] <author> Foley, J. D. et al. </author> <title> Introduction to Computer Graphics. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1994, </year> <pages> 557 pp </pages>
Reference-contexts: Indeed, this theoretical background cannot even predict or explain the performance of the most widely used hidden-surface technique, the z-buffer algorithm. The 2 running time of the z-buffer algorithm is often claimed to be a linear function of the input size, or even constant <ref> [29, 31, 32, 33, 65, 85] </ref>. <p> On the other hand, Schmitt [74] demonstrated how vertical and horizontal rectangles can force any hidden-line or hidden-surface algorithm to take at least quadratic time in the worst case. (This result is wrongly attributed to Fiume [30] by Foley et al <ref> [32, 33] </ref>.) The quadratic lower bound can be demonstrated even if the input is only one simple polyhedron [20]. A constant running time, ie, a running time independent of the size of the input is a nonsense, which is impossible to achieve even with parallel processing. <p> Note that no assumption on the distribution of the input data was made, the only requirement is that the expected number of edge intersections is O (N ). 4 Approximation algorithms A widely used classification of visibility algorithms distinguishes two main classes: object-space and image-space algorithms <ref> [32, 33, 65, 79] </ref>.
Reference: [34] <author> Franklin, W. R. </author> <title> A linear time exact hidden surface algorithm. </title> <booktitle> Computer Graphics 14,3 (1980) 117-123. </booktitle>
Reference-contexts: Most of the algorithms proposed in the literature <ref> [34, 37, 45, 46, 57] </ref> divide edges into line segments at the intersection points, then test each line segment for visibility against each polygon.
Reference: [35] <author> Fredman, M. L., Weide, B. </author> <title> On the complexity of computing the measure of [[a i ; b i ]. Comm. </title> <note> ACM 21,7 (July 1978) 540-544. </note>
Reference-contexts: Then the interval-union problem, as a special case of the problem of the union of point sets, can be formulated as follows: Given a list of 2N real numbers representing the endpoints of N intervals, compute the union of these intervals. Fredman and Weide <ref> [35] </ref> have established the complexity of a similar problem, ie, the measure of the union of a set of intervals, under the linear decision tree model of computation.
Reference: [36] <author> Fuchs, H. et al. </author> <title> Pixel-planes 5: A heterogeneous multiprocessor graphics system using processor enhanced memories. </title> <booktitle> Proc. Siggraph 89, </booktitle> <pages> 79-88. </pages>
Reference-contexts: Though the concept output-sensitive visibility algorithms has been raised as early as the 1986 Computational Geometry conference [20, 66] Sudarsky and Gotsman [77] recently reported the application of output-sensitive visibility algorithms to dynamic scenes in VR. On the hardware level graphics accelerators [50, 51], logic-enhanced memories <ref> [36, 51, 60] </ref>, texture mapping [51] and scaleable architectures [27, 51, 60] are the new developments. Coppen et al [17] describe a distributed frame buffer architecture, designed to achieve fast display updates in response to dynamic transformations of graphical objects. <p> Most parallel approaches recommended until recently are based on the z-buffer <ref> [36, 61] </ref> or ray-tracing [49, 68] methods that classify as approximation algorithms. With these methods usually a processor is assigned to each pixel. In general, by using approximation methods the visibility problem can be divided conveniently among as many processors as are available.
Reference: [37] <author> Galimberti, R. Montanari, U. </author> <title> An algorithm for hidden-line elimination. </title> <journal> Comm. ACM 12,4 (Apr. </journal> <year> 1969) </year> <month> 206-211. </month>
Reference-contexts: Most of the algorithms proposed in the literature <ref> [34, 37, 45, 46, 57] </ref> divide edges into line segments at the intersection points, then test each line segment for visibility against each polygon.
Reference: [38] <author> Goodrich, M. T. </author> <title> A polygonal approach to hidden-line and hidden-surface elimination. CVGIP: Graphical Models and Image Processing 54,1 (Jan. </title> <year> 1992) </year> <month> 1-12. </month>
Reference-contexts: Assuming just as many pixels as edges, ie, K 2 = N , would suggest that accepting an approximation does not pay: exact algorithms, eg, Goodrich's algorithm <ref> [38] </ref>, are asymptotically faster. Perhaps using a hierarchical approach that can compare more than one pixel at a time to each polygon would result in a faster algorithm.
Reference: [39] <author> Goodrich, M. T. </author> <title> Constructing arrangements optimally in parallel. </title> <note> Discrete & Computational Geometry 9,4 (1993) 371-385. </note>
Reference-contexts: Recently Goodrich <ref> [39] </ref> proposed an optimal parallel algorithm for constructing line arrangements. Combining Goodrich's result with the techniques presented here and in [20] the question can be answered affirmatively. The resulting algorithm, however, is significantly more complicated than the one presented here.
Reference: [40] <author> Greenberg, D. P. </author> <title> Global Illumination: The Radiosity Approach. </title> <booktitle> Lecture notes for Course 14, PIXIM'89, 2nd International Conference on Computer Graphics in Paris, </booktitle> <address> France, </address> <month> Sept. </month> <pages> 25-29, </pages> <year> 1989, </year> <pages> 56 pp. </pages>
Reference-contexts: Visibility computations can also be used for shadow calculations: the parts of the scene are in shadow which are not visible from a given light source. In a global illumination model, such as the radiosity method <ref> [40] </ref> all light interactions in the scene can be determined in advance in a view-independent way. Theoretically this would require the determination of the visibility of the scene from every point of the scene. In practice an approximation is sufficient.
Reference: [41] <author> Greene, N., Kass, M., Miller, G. </author> <title> Hierarchical z-buffer visibility. </title> <booktitle> Proc. Siggraph 93, </booktitle> <address> Anaheim, California, </address> <month> August </month> <year> 1993, </year> <pages> 231-238. </pages>
Reference-contexts: The visibility algorithms traditionally classified as image-space algorithms are actually approximation algorithms in most of the cases. The dominant visibility algorithms in use nowadays are z-buffer scan-line algorithms and ray casting <ref> [41] </ref>. It easy to see that the z-buffer and the ray casting methods take fi (K 2 N ) time in the worst case. <p> However, it has been demonstrated [24] that Warnock's algorithm also takes fi (K 2 N ) time in the worst case. Greene et al <ref> [41] </ref> describe a heuristic method similar to Warnock's algorithm, and report that a hierarchical approach can be faster in practice than the ordinary z-buffer algorithm.
Reference: [42] <author> Gupta, U. I., Lee, D. T., Leung, J. Y.-T. </author> <title> An optimal solution for the channel-assignment problem. </title> <journal> IEEE Trans. Comput. </journal> <month> C-28,11 </month> <year> (1979) </year> <month> 807-810. </month>
Reference-contexts: Practical scenes are more dense. The reader is encouraged to look at Figure 10 before reading any further, and have a guess how the set of line segments was generated. The technique we propose is based on a channel-assignment algorithm <ref> [42] </ref> and can be used to generate x-coordinates of the line segments from arbitrary probability distributions. First the x-coordinates of the left and right endpoints of the line segments are generated, which determine an interval for each line segment.
Reference: [43] <author> He, T. S., Hong, L. C., Kaufman, A., Varshney, A., Wang, S. </author> <title> Voxel based object simplification. </title> <booktitle> Proc. </booktitle> <month> Visualization'95 </month> <year> (1995) </year> <month> 296-303. </month>
Reference-contexts: Only objects in the potentially visible set of cells are actually submitted to the hidden object removal algorithm. Schaufler and Sturzlinger [73] propose a three-dimensional image cache. Another group of new techniques are hierarchical or level-of-detail algorithms and object simplification <ref> [43, 47, 72, 80, 81] </ref>. VR applications also increased the practical significance of research on reducing the growing rate of visibility algorithms [19, 20, 21, 18, 58, 59] both in the worst case and on the average.
Reference: [44] <author> Higgins, G. A., Meglan, D. A., Raju, R., Merril, J. R., Merril, G. L. Teleos(TM): </author> <title> Development of a software toolkit for authoring virtual medical environments. Presence | Teleoperators and Virtual Environments 6,2 (1997) 241-252. </title>
Reference-contexts: Lag is critical when trying to achieve immersion [86]. In spite of the shortcomings of contemporary VR systems, a wide range of application areas are reported in the literature: flight [71] and driving [5] simulation, scientific visualisation [9], medicine <ref> [4, 44] </ref>, walk-through and fly-through of complex environments [28, 48, 88, 89], lighting-design [28] and even performance analysis of parallel computer systems [70]. Cobb et al [14] examined the feasibility of VR as a tool for the UK manufacturing industry.
Reference: [45] <author> Hornung, C. </author> <title> An approach to a calculation-minimized hidden line algorithm. </title> <institution> Comput. & Graphics 6,3 (1982) 121-126. </institution>
Reference-contexts: Most of the algorithms proposed in the literature <ref> [34, 37, 45, 46, 57] </ref> divide edges into line segments at the intersection points, then test each line segment for visibility against each polygon.
Reference: [46] <author> Hornung, C. </author> <title> A method for solving the visibility problem. </title> <journal> IEEE Comput. Graphics & Appl. </journal> <month> 4,7 (July </month> <year> 1984) </year> <month> 26-33. </month>
Reference-contexts: Most of the algorithms proposed in the literature <ref> [34, 37, 45, 46, 57] </ref> divide edges into line segments at the intersection points, then test each line segment for visibility against each polygon.
Reference: [47] <author> Hubbold, R., Murta, A. West, A. Howard, T. </author> <title> Design issues for virtual reality systems. </title> <editor> In: Gobel, M. </editor> <title> (Ed) Virtual Environments '95, </title> <publisher> Springer Verlag, Wien, </publisher> <year> 1995, </year> <pages> 224-235. </pages>
Reference-contexts: 1 Introduction Virtual reality (VR) is a new human-computer interface paradigm to create the effect of a three-dimensional environment in which the user directly interacts with virtual objects. An immersive virtual environment allows human participants to engage their perceptual skills in solving problems <ref> [47, 83] </ref>. Immersive systems require special equipment, eg, a head-mounted display. Desktop, or non-immersive systems use a normal visual display unit that displays the image of the environment. The user interacts with input devices, such as a data glove or a three-dimensional mouse. <p> With frame rates less than 20 frames/sec scenes appear as a series of separate frames, and even frame rates between 20 an 60 frames sec may produce ghosting effects, ie, multiple images of the same object <ref> [47] </ref> Another impediment is lag, the delay between performing an action and seeing the result of that action. Lag is critical when trying to achieve immersion [86]. <p> Only objects in the potentially visible set of cells are actually submitted to the hidden object removal algorithm. Schaufler and Sturzlinger [73] propose a three-dimensional image cache. Another group of new techniques are hierarchical or level-of-detail algorithms and object simplification <ref> [43, 47, 72, 80, 81] </ref>. VR applications also increased the practical significance of research on reducing the growing rate of visibility algorithms [19, 20, 21, 18, 58, 59] both in the worst case and on the average. <p> Slater and Usoh [76] propose an alternative viewing pipeline simulating peripheral vision in immersive virtual environments. Peripheral vision offers important cues for direction of gaze and movement. Relatively few papers <ref> [9, 47] </ref> deal with the design and computational requirements of VR systems. Development has traditionally been extensive in computer graphics: bigger memories and faster processors are becoming available due to increasingly faster electronic components. However, there are two inherent difficulties with this way of development. <p> Finally in section 8 the practical significance of the proposed theoretical background is evaluated, and directions for further work are recommended. 2 Rendering three-dimensional scenes For the description of three-dimensional objects polygon-mesh models are most widely used <ref> [47, 72, 84] </ref>. These models provide an exact description for objects modelled by polyhedra, and an approximation for objects with curved surfaces. A polygon-mesh model is a collection of simple polygons possibly with holes, such that the polygons can intersect only at their edges.
Reference: [48] <author> Jalili, R., Kirchner, P. D., Montoya, J., Duncan, S., Genevriez, L., Lipscomb, J. S., Wolfe, R. H., Codella, C. F. </author> <title> A visit to the Dresden Frauenkirche. Presence | Teleoperators and Virtual Environments 5,1 (1995) 87-94. </title>
Reference-contexts: Lag is critical when trying to achieve immersion [86]. In spite of the shortcomings of contemporary VR systems, a wide range of application areas are reported in the literature: flight [71] and driving [5] simulation, scientific visualisation [9], medicine [4, 44], walk-through and fly-through of complex environments <ref> [28, 48, 88, 89] </ref>, lighting-design [28] and even performance analysis of parallel computer systems [70]. Cobb et al [14] examined the feasibility of VR as a tool for the UK manufacturing industry. <p> During the reconstruction of the church a model was created from the original building plans. A software package developed at the IBM T. J. Watson Research Center was used to view and walk through the model using both immersive and non-immersive technologies <ref> [48] </ref>. Another potentially spectacular application area is telesensation, a sort of a three-dimensional photography, when a scene from a remote location, eg, from nature or from a museum, is transmitted to a viewer.
Reference: [49] <author> Kedem, G., Ellis, J. L. </author> <booktitle> The raycasting machine. Proc. 1984 Int. Conf. on Computer Design, </booktitle> <month> October </month> <year> 1984, </year> <pages> 533-538. </pages>
Reference-contexts: Most parallel approaches recommended until recently are based on the z-buffer [36, 61] or ray-tracing <ref> [49, 68] </ref> methods that classify as approximation algorithms. With these methods usually a processor is assigned to each pixel. In general, by using approximation methods the visibility problem can be divided conveniently among as many processors as are available.
Reference: [50] <author> Knittel, G. </author> <title> A scalable architecture for volume rendering. </title> <journal> Computers & Graphics 19,5 (1995) 653-665. </journal>
Reference-contexts: Though the concept output-sensitive visibility algorithms has been raised as early as the 1986 Computational Geometry conference [20, 66] Sudarsky and Gotsman [77] recently reported the application of output-sensitive visibility algorithms to dynamic scenes in VR. On the hardware level graphics accelerators <ref> [50, 51] </ref>, logic-enhanced memories [36, 51, 60], texture mapping [51] and scaleable architectures [27, 51, 60] are the new developments. Coppen et al [17] describe a distributed frame buffer architecture, designed to achieve fast display updates in response to dynamic transformations of graphical objects.
Reference: [51] <author> Knittel, G., Schilling, A., Strasser, W. Grammy: </author> <title> High performance graphics using graphics memories. </title> <note> In: </note> <author> Chen, M., Townsend, P., Vince J. A. </author> <title> (Eds) High-Performance Computing for Computer Graphics and Visualisation. </title> <publisher> Springer Verlag, </publisher> <address> London, </address> <year> 1996, </year> <pages> 33-48. </pages>
Reference-contexts: Though the concept output-sensitive visibility algorithms has been raised as early as the 1986 Computational Geometry conference [20, 66] Sudarsky and Gotsman [77] recently reported the application of output-sensitive visibility algorithms to dynamic scenes in VR. On the hardware level graphics accelerators <ref> [50, 51] </ref>, logic-enhanced memories [36, 51, 60], texture mapping [51] and scaleable architectures [27, 51, 60] are the new developments. Coppen et al [17] describe a distributed frame buffer architecture, designed to achieve fast display updates in response to dynamic transformations of graphical objects. <p> Though the concept output-sensitive visibility algorithms has been raised as early as the 1986 Computational Geometry conference [20, 66] Sudarsky and Gotsman [77] recently reported the application of output-sensitive visibility algorithms to dynamic scenes in VR. On the hardware level graphics accelerators [50, 51], logic-enhanced memories <ref> [36, 51, 60] </ref>, texture mapping [51] and scaleable architectures [27, 51, 60] are the new developments. Coppen et al [17] describe a distributed frame buffer architecture, designed to achieve fast display updates in response to dynamic transformations of graphical objects. <p> On the hardware level graphics accelerators [50, 51], logic-enhanced memories [36, 51, 60], texture mapping <ref> [51] </ref> and scaleable architectures [27, 51, 60] are the new developments. Coppen et al [17] describe a distributed frame buffer architecture, designed to achieve fast display updates in response to dynamic transformations of graphical objects. <p> On the hardware level graphics accelerators [50, 51], logic-enhanced memories [36, 51, 60], texture mapping [51] and scaleable architectures <ref> [27, 51, 60] </ref> are the new developments. Coppen et al [17] describe a distributed frame buffer architecture, designed to achieve fast display updates in response to dynamic transformations of graphical objects. <p> Then the algorithm simply subdivides the projection of each input line segments into pixels, and updates the appropriate elements of the z-buffer in fi (nr) time in the worst case. The z-buffer algorithm is easy to implement in hardware <ref> [60, 51] </ref>, and the speed of that system is difficult to surpass if there are few overlapping surfaces in the scene. However, in virtual-reality applications the depth of the scene increases; there are multiple overlapping surfaces, and the speed of the z-buffer algorithm quickly deteriorates.
Reference: [52] <author> Knuth, D. E. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol. </volume> <month> 3: </month> <title> Sorting and Searching. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1973. </year>
Reference-contexts: While traversing the regions of G, one has to account at most one insertion and at most one deletion for each crossing of an arc of G. Both an insertion and a deletion can be done in O (log N ) time <ref> [2, 52, 75] </ref> and the number of arcs is O (N + k), therefore step (2), and also the whole algorithm, can be implemented in O ((N + k) log N ) time.
Reference: [53] <author> Kremer-Patard, G. </author> <title> Evaluation d'algorithmes de calcul de la visibilite d'un ensemble de segments du plan. </title> <institution> Revue de CFAO et d'Infographie 3,3 (1988) 39-57. </institution>
Reference-contexts: Constant factors can be determined from time measurements in the actual machine environment where the algorithms are to be used. Kremer-Patard <ref> [53] </ref> used manually generated input to compare some algorithms including the priority-queue method [19]. Another possibility is to extract the input data from real three-dimensional models.
Reference: [54] <author> Kruskal, C. P., Rudolph, L., Snir, M. </author> <title> Efficient parallel algorithms for graph problems. </title> <note> Algorithmica 5 (1990) 43-64. </note>
Reference-contexts: Then overlapped endpoints are simply removed from the list. We apply an efficient technique proposed by Kruskal et al <ref> [54] </ref>. <p> Step (3) and therefore step (6) take O (log N ) time and N= log N processors assuming the EREW model <ref> [54] </ref>. Steps (2), (4) and (5) take constant time and N processors. There are no memory conflicts in step (2), and we can avoid memory conflicts by examining and, if necessary, removing first the odd elements of D in step (4), then the even elements in step (5).
Reference: [55] <author> Laszlo, M. J. </author> <title> Computational Geometry and Computer Graphics in C++. </title> <publisher> Prentice Hall, </publisher> <address> Upper Saddle River, USA, </address> <year> 1996, </year> <pages> 266 pp. </pages>
Reference: [56] <author> Loftin, R. B., Kenney, P. J. </author> <title> Training the Hubble Space Telescope flight team. </title> <journal> IEEE Comput. Graphics & Appl. </journal> <month> 15,5 </month> <year> (1995) </year> <month> 31-37. </month>
Reference-contexts: A preparation and the crew training for a repair and maintenance mission became a major NASA project. More than 100 members of the ground-support flight team were trained in immersive virtual environments, and the repair mission was successfully completed in December 1993 <ref> [56] </ref>. The Dresden Frauenkirche was destroyed when the city was bombed by the Allied forces in 1945. During the reconstruction of the church a model was created from the original building plans. A software package developed at the IBM T. J.
Reference: [57] <author> Loutrel, P. P. </author> <title> A solution to the hidden-line problem for computer drawn polyhedra. </title> <journal> IEEE Trans. Comp. </journal> <month> C-19,3 (Mar. </month> <year> 1970) </year> <month> 205-213. </month>
Reference-contexts: Most of the algorithms proposed in the literature <ref> [34, 37, 45, 46, 57] </ref> divide edges into line segments at the intersection points, then test each line segment for visibility against each polygon.
Reference: [58] <author> Marton, G. </author> <title> Investigation of the Average Complexity of Ray-Tracing Algorithms. </title> <type> Ph.D Thesis, </type> <institution> Budapest, </institution> <note> 1995 (In Hungarian). 32 </note>
Reference-contexts: Schaufler and Sturzlinger [73] propose a three-dimensional image cache. Another group of new techniques are hierarchical or level-of-detail algorithms and object simplification [43, 47, 72, 80, 81]. VR applications also increased the practical significance of research on reducing the growing rate of visibility algorithms <ref> [19, 20, 21, 18, 58, 59] </ref> both in the worst case and on the average.
Reference: [59] <author> McKenna, M. </author> <title> Worst-case optimal hidden-surface removal. </title> <journal> ACM Transactions on Graphics 6,1 (Jan. </journal> <year> 1987) </year> <month> 19-28. </month>
Reference-contexts: Schaufler and Sturzlinger [73] propose a three-dimensional image cache. Another group of new techniques are hierarchical or level-of-detail algorithms and object simplification [43, 47, 72, 80, 81]. VR applications also increased the practical significance of research on reducing the growing rate of visibility algorithms <ref> [19, 20, 21, 18, 58, 59] </ref> both in the worst case and on the average. <p> Though it has been demonstrated that fi (N 2 ) 13 worst-case time can actually be attained both for the hidden-line [20] and for the hidden-surface problem <ref> [59] </ref> it is not easy to reduce below fi (N 2 log N ) for any practical algorithm. Our worst-case lower bound is based on the fact that there can be (N 2 ) intersection points.
Reference: [60] <author> Molnar, S., Eyles, J., and Poulton, J. PixelFlow: </author> <title> High-speed rendering using image composition. </title> <booktitle> Computer Graphics 26,2 (Proc. Siggraph 92, </booktitle> <month> July </month> <year> 1992) </year> <month> 231-240. </month>
Reference-contexts: Though the concept output-sensitive visibility algorithms has been raised as early as the 1986 Computational Geometry conference [20, 66] Sudarsky and Gotsman [77] recently reported the application of output-sensitive visibility algorithms to dynamic scenes in VR. On the hardware level graphics accelerators [50, 51], logic-enhanced memories <ref> [36, 51, 60] </ref>, texture mapping [51] and scaleable architectures [27, 51, 60] are the new developments. Coppen et al [17] describe a distributed frame buffer architecture, designed to achieve fast display updates in response to dynamic transformations of graphical objects. <p> On the hardware level graphics accelerators [50, 51], logic-enhanced memories [36, 51, 60], texture mapping [51] and scaleable architectures <ref> [27, 51, 60] </ref> are the new developments. Coppen et al [17] describe a distributed frame buffer architecture, designed to achieve fast display updates in response to dynamic transformations of graphical objects. <p> Then the algorithm simply subdivides the projection of each input line segments into pixels, and updates the appropriate elements of the z-buffer in fi (nr) time in the worst case. The z-buffer algorithm is easy to implement in hardware <ref> [60, 51] </ref>, and the speed of that system is difficult to surpass if there are few overlapping surfaces in the scene. However, in virtual-reality applications the depth of the scene increases; there are multiple overlapping surfaces, and the speed of the z-buffer algorithm quickly deteriorates.
Reference: [61] <author> Molnar, S., Cox, M., Ellsworth, D., Fuchs, H. </author> <title> A sorting classification of parallel rendering. </title> <journal> IEEE Comput. Graphics & Appl. </journal> <month> 14,4 </month> <year> (1994) </year> <month> 23-32. </month>
Reference-contexts: Most parallel approaches recommended until recently are based on the z-buffer <ref> [36, 61] </ref> or ray-tracing [49, 68] methods that classify as approximation algorithms. With these methods usually a processor is assigned to each pixel. In general, by using approximation methods the visibility problem can be divided conveniently among as many processors as are available.
Reference: [62] <author> Motwani, R., Raghavan, P. </author> <title> Randomized Algorithms. </title> <publisher> Cambridge University Press, </publisher> <address> Cam-bridge, UK, </address> <year> 1995, </year> <pages> 476 pp. </pages>
Reference-contexts: It follows that (n log n) is a lower bound also for the planar visibility problem in any computational model where (n log n) is a lower bound for the element distinctness problem. The binary-partition-tree method <ref> [62] </ref> can solve the visibility problem in O (n log n) expected time after some preprocessing. <p> The average running time can be significantly better for some of the algorithms, and indeed, expected-time analyses of probabilistic algorithms attracted much attention recently <ref> [11, 12, 13, 62, 63] </ref>.
Reference: [63] <author> Mulmuley, K. </author> <title> An efficient algorithm for hidden surface removal 2. </title> <journal> J. </journal> <note> Computer and System Sciences 49,3 (1994) 427-453. </note>
Reference-contexts: The average running time can be significantly better for some of the algorithms, and indeed, expected-time analyses of probabilistic algorithms attracted much attention recently <ref> [11, 12, 13, 62, 63] </ref>.
Reference: [64] <author> Myers, E. W. </author> <title> An O(E log E + I) expected time algorithm for the planar segment intersection problem. </title> <journal> SIAM J. Comput. </journal> <month> 14,3 (Aug. </month> <year> 1985) </year> <month> 625-637. </month>
Reference-contexts: The polygon corresponding to the minimum element of H will be visible within the currently visited region. Step (1) can be implemented in O ((N + k) log N ) time <ref> [7, 10, 64] </ref>. While traversing the regions of G, one has to account at most one insertion and at most one deletion for each crossing of an arc of G.
Reference: [65] <author> Newman, W. M., Sproull, R. F. </author> <title> Principles of Interactive Computer Graphics. </title> <publisher> (Second Edition) McGraw-Hill Kogakusha Ltd, </publisher> <address> Tokyo, Japan, </address> <year> 1979, </year> <pages> 541 pp. </pages>
Reference-contexts: Indeed, this theoretical background cannot even predict or explain the performance of the most widely used hidden-surface technique, the z-buffer algorithm. The 2 running time of the z-buffer algorithm is often claimed to be a linear function of the input size, or even constant <ref> [29, 31, 32, 33, 65, 85] </ref>. <p> Note that no assumption on the distribution of the input data was made, the only requirement is that the expected number of edge intersections is O (N ). 4 Approximation algorithms A widely used classification of visibility algorithms distinguishes two main classes: object-space and image-space algorithms <ref> [32, 33, 65, 79] </ref>. <p> Warnock developed an algorithm that uses the observation that pixels within large areas of the image are coherent in the sense that they represent a single polygon <ref> [65, 32] </ref>. However, it has been demonstrated [24] that Warnock's algorithm also takes fi (K 2 N ) time in the worst case. <p> Recall that in computer graphics the (x; z) Cartesian coordinate system and u = (0; 1) are 21 assumed, the visible image is projected into the x-axis, and the algorithms for the solution of the problem are referred to as scan-line algorithms <ref> [32, 65] </ref>. An early algorithm, which takes fi (n 2 ) time in the worst case, was given by Watkins [32, 65]. In practice the z-buffer algorithm | an approximation method | is often used, where the image is divided into r equal picture elements. <p> u = (0; 1) are 21 assumed, the visible image is projected into the x-axis, and the algorithms for the solution of the problem are referred to as scan-line algorithms <ref> [32, 65] </ref>. An early algorithm, which takes fi (n 2 ) time in the worst case, was given by Watkins [32, 65]. In practice the z-buffer algorithm | an approximation method | is often used, where the image is divided into r equal picture elements. The visibility of each picture element is approximated by the visibility of a sample point, usually taken at the middle of the pixel. <p> Another algorithm, based on a divide-and conquer approach and called the merge method also achieves the optimal O (n log n) worst-case time [3]. Early scan-line algorithms [8, 87] take fi (n 2 ) time in the worst case [19], and attempt to exploit coherence <ref> [32, 65] </ref> which is no longer possible in a parallel environment, where adjacent scan lines may be processed by different processors. <p> First two hierarchical methods based on subdivision techniques, then two simple probabilistic algorithms are proposed. 6.2 Hierarchical methods A scan-line algorithm can be developed by using the ideas proposed by Warnock for determining the visibility of a set of polygons in three-dimensional space <ref> [32, 65] </ref>. An interval of the x-axis containing the image of the input set will be called the window. Warnock's basic idea is to attempt to display the image if it is simple, otherwise subdivide the window until the image is simple enough. <p> The average running time can be significantly better for some of the algorithms, and indeed, expected-time analyses of probabilistic algorithms attracted much attention recently [11, 12, 13, 62, 63]. Asymptotic analysis, however, cannot 26 method time space z-buffer <ref> [32, 65] </ref> fi (nr) fi (n + r) Watkins [32, 65] fi (n 2 ) fi (n) priority-queue [19] fi (n log n) fi (n) merge [3] fi (n log n) fi (n) z-tree [23] fi (n log r) fi (n + r) Warnock fi (n log r) fi (n log <p> The average running time can be significantly better for some of the algorithms, and indeed, expected-time analyses of probabilistic algorithms attracted much attention recently [11, 12, 13, 62, 63]. Asymptotic analysis, however, cannot 26 method time space z-buffer <ref> [32, 65] </ref> fi (nr) fi (n + r) Watkins [32, 65] fi (n 2 ) fi (n) priority-queue [19] fi (n log n) fi (n) merge [3] fi (n log n) fi (n) z-tree [23] fi (n log r) fi (n + r) Warnock fi (n log r) fi (n log r) recursive subdivision fi (n log r) fi (n
Reference: [66] <author> O'Rourke, J. </author> <title> The computational geometry column. </title> <booktitle> Computer Graphics 20,5 (1986) 232-234. </booktitle>
Reference-contexts: VR applications also increased the practical significance of research on reducing the growing rate of visibility algorithms [19, 20, 21, 18, 58, 59] both in the worst case and on the average. Though the concept output-sensitive visibility algorithms has been raised as early as the 1986 Computational Geometry conference <ref> [20, 66] </ref> Sudarsky and Gotsman [77] recently reported the application of output-sensitive visibility algorithms to dynamic scenes in VR. On the hardware level graphics accelerators [50, 51], logic-enhanced memories [36, 51, 60], texture mapping [51] and scaleable architectures [27, 51, 60] are the new developments.
Reference: [67] <author> O'Rourke, J. </author> <title> Computational Geometry in C. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1994, </year> <pages> 368 pp. </pages>
Reference: [68] <author> Pili, P. </author> <title> A parallel raycast algorithm of CSG models on CM2. </title> <journal> International J. Modern Physics C-physics & Computers 4,1 (1993) 29-40. </journal>
Reference-contexts: Most parallel approaches recommended until recently are based on the z-buffer [36, 61] or ray-tracing <ref> [49, 68] </ref> methods that classify as approximation algorithms. With these methods usually a processor is assigned to each pixel. In general, by using approximation methods the visibility problem can be divided conveniently among as many processors as are available.
Reference: [69] <author> Preparata, F. P., Shamos, M. I. </author> <title> Computational Geometry. An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985, </year> <pages> 390 pp. </pages>
Reference-contexts: whole algorithm O (m log m + mn + n log n) time. 12 An (m log m + n log n) lower bound follows from Lemma 1, and an (mn) bound from the fact that the intersection of a simple m-gon with a simple n-gon may have mn vertices <ref> [69] </ref>. 2 Note that P " Q may be disconnected, and therefore not necessarily an ordinary polygon. Once A inQ and B inP has been determined, P [ Q, P Q and Q P can also be determined by traversing edges in O (mn) additional time. <p> For an improvement it should be noted that any visibility algorithm has to determine the union of fi (N ) hidden intervals on fi (N ) edges in the worst case. Since (N log N ) is a lower bound for determining the union of N intervals <ref> [69] </ref>, it appears that the best one can hope to achieve is a fi (N 2 log N ) worst-case time. <p> The element distinctness problem is stated as follows <ref> [69] </ref>. Given N real numbers, x 1 ; x 2 ; :::; x N , decide if all are different (ie, there are no i and j, 1 i; j N , such that i 6= j and x i = x j ). <p> Let us suppose that given an input x 1 ; x 2 ; :::; x n for the element distinctness problem <ref> [69] </ref>, and we are allowed to use any algorithm for determining the visibility of a planar set of line segments. Let u = (a; b) be the observer's position with arbitrary a and b &lt; 0. <p> as follows: If the number of visible segments returned by the visibility algorithm is exactly n, the input numbers x 1 ; x 2 ; :::; x n were distinct, otherwise not. (n log n) is a lower bound for the element distinctness problem, eg, in the algebraic tree model <ref> [69] </ref>. It follows that (n log n) is a lower bound also for the planar visibility problem in any computational model where (n log n) is a lower bound for the element distinctness problem. <p> Hence any line segment t could be represented by less than 2 log 2 r standard intervals of a segment tree <ref> [69] </ref>, though with the subdivision method t is represented by at most that many copies of itself. From here it follows that an upper bound on the worst-case time is O (n log r).
Reference: [70] <author> Reed, D. A, Shields, K. A, Scullin, W. H, Tavera, L. F, Elford, C. L. </author> <title> Virtual-reality and parallel systems performance analysis. </title> <note> IEEE Computer 28,11 (1995) 57-67. </note>
Reference-contexts: of the shortcomings of contemporary VR systems, a wide range of application areas are reported in the literature: flight [71] and driving [5] simulation, scientific visualisation [9], medicine [4, 44], walk-through and fly-through of complex environments [28, 48, 88, 89], lighting-design [28] and even performance analysis of parallel computer systems <ref> [70] </ref>. Cobb et al [14] examined the feasibility of VR as a tool for the UK manufacturing industry.
Reference: [71] <author> Rimmek, K. </author> <title> Flight simulation, an advanced application of virtual-reality. </title> <note> IFIP Transactions A | Computer Science and Technology 53 (1994) 171-176. </note>
Reference-contexts: Lag is critical when trying to achieve immersion [86]. In spite of the shortcomings of contemporary VR systems, a wide range of application areas are reported in the literature: flight <ref> [71] </ref> and driving [5] simulation, scientific visualisation [9], medicine [4, 44], walk-through and fly-through of complex environments [28, 48, 88, 89], lighting-design [28] and even performance analysis of parallel computer systems [70]. Cobb et al [14] examined the feasibility of VR as a tool for the UK manufacturing industry.
Reference: [72] <author> Schaufler, G., Sturzlinger, W. </author> <title> Generating multiple levels of detail from polygonal geometry models. </title> <editor> In: Gobel, M. </editor> <title> (Ed) Virtual Environments '95, </title> <publisher> Springer Verlag, Wien, </publisher> <year> 1995, </year> <pages> 33-41. </pages>
Reference-contexts: Only objects in the potentially visible set of cells are actually submitted to the hidden object removal algorithm. Schaufler and Sturzlinger [73] propose a three-dimensional image cache. Another group of new techniques are hierarchical or level-of-detail algorithms and object simplification <ref> [43, 47, 72, 80, 81] </ref>. VR applications also increased the practical significance of research on reducing the growing rate of visibility algorithms [19, 20, 21, 18, 58, 59] both in the worst case and on the average. <p> Finally in section 8 the practical significance of the proposed theoretical background is evaluated, and directions for further work are recommended. 2 Rendering three-dimensional scenes For the description of three-dimensional objects polygon-mesh models are most widely used <ref> [47, 72, 84] </ref>. These models provide an exact description for objects modelled by polyhedra, and an approximation for objects with curved surfaces. A polygon-mesh model is a collection of simple polygons possibly with holes, such that the polygons can intersect only at their edges.
Reference: [73] <author> Schaufler, G., Sturzlinger, W. </author> <title> A 3-dimensional image cache for virtual-reality Computer Graphics Forum 15,3 (1996) c227. </title>
Reference-contexts: Yagel and Ray [88] report on such a culling mechanism based on regular space subdivision. Only objects in the potentially visible set of cells are actually submitted to the hidden object removal algorithm. Schaufler and Sturzlinger <ref> [73] </ref> propose a three-dimensional image cache. Another group of new techniques are hierarchical or level-of-detail algorithms and object simplification [43, 47, 72, 80, 81].
Reference: [74] <author> Schmitt, A. </author> <title> Time and space bounds for hidden line and hidden surface algorithms. </title> <booktitle> Proc. </booktitle> <address> Eurographics'81, Darmstadt, Germany, </address> <month> (Sep. </month> <year> 1981) </year> <month> 43-56. </month>
Reference-contexts: The 2 running time of the z-buffer algorithm is often claimed to be a linear function of the input size, or even constant [29, 31, 32, 33, 65, 85]. On the other hand, Schmitt <ref> [74] </ref> demonstrated how vertical and horizontal rectangles can force any hidden-line or hidden-surface algorithm to take at least quadratic time in the worst case. (This result is wrongly attributed to Fiume [30] by Foley et al [32, 33].) The quadratic lower bound can be demonstrated even if the input is only
Reference: [75] <author> Sedgewick, R. </author> <title> Algorithms in C++. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1992, </year> <pages> 658 pp. </pages>
Reference-contexts: While traversing the regions of G, one has to account at most one insertion and at most one deletion for each crossing of an arc of G. Both an insertion and a deletion can be done in O (log N ) time <ref> [2, 52, 75] </ref> and the number of arcs is O (N + k), therefore step (2), and also the whole algorithm, can be implemented in O ((N + k) log N ) time.
Reference: [76] <author> Slater, M., Usoh, M. </author> <title> Simulating peripheral vision in immersive virtual environments. </title> <journal> Computers & Graphics 17,6 (1993) 643-653. </journal>
Reference-contexts: Coppen et al [17] describe a distributed frame buffer architecture, designed to achieve fast display updates in response to dynamic transformations of graphical objects. As a matter of fact, developing scaleable architectures are basically the same concept as reducing the growing rate of algorithms. Slater and Usoh <ref> [76] </ref> propose an alternative viewing pipeline simulating peripheral vision in immersive virtual environments. Peripheral vision offers important cues for direction of gaze and movement. Relatively few papers [9, 47] deal with the design and computational requirements of VR systems.
Reference: [77] <author> Sudarsky, O., Gotsman, C. </author> <title> Output-sensitive visibility algorithms for dynamic scenes with applications to virtual-reality. </title> <journal> Computer Graphics Forum 15,3 (1996) c249-c258. </journal> <volume> 33 </volume>
Reference-contexts: Though the concept output-sensitive visibility algorithms has been raised as early as the 1986 Computational Geometry conference [20, 66] Sudarsky and Gotsman <ref> [77] </ref> recently reported the application of output-sensitive visibility algorithms to dynamic scenes in VR. On the hardware level graphics accelerators [50, 51], logic-enhanced memories [36, 51, 60], texture mapping [51] and scaleable architectures [27, 51, 60] are the new developments.
Reference: [78] <author> Sutcliffe, A. G. </author> <title> Human-Computer Interface Design. </title> <publisher> Macmillan Press Ltd, </publisher> <year> 1988, </year> <note> Second edition 1955, 326 pp. </note>
Reference-contexts: Cobb et al [14] examined the feasibility of VR as a tool for the UK manufacturing industry. Education and training is another area with vast potential: students can fly through landscapes for a geography lesson, or travel down blood vessels in an anatomy class <ref> [78] </ref>. 1 State-of-the-Art Report, Eurographics'97 1 Spectacular applications are a training model for the repair mission of the Hubble Space Telescope and the reconstruction of the Dresden Frauenkirche. Shortly after NASA launched the Hubble Space Telescope in 1990, astronomers discovered flaws in its optical system. <p> Finally the system should provide the illusion that objects nearer to the observer may hide objects farther from the observer. This functionality is provided by visibility computations. There is evidence that the human visual system recognises solids by extracting edges in an image <ref> [78] </ref>. Indeed, line-drawing images often used for visualisation of solids in CAD systems, in addition to shaded, realistic images. Therefore two types of visibility problems are distinguished.
Reference: [79] <author> Sutherland, I. E., Sproull, R. F., Schumaker, R. A. </author> <title> A characterization of ten hidden-surface algorithms. </title> <journal> Computing Surveys 6,1 (March 1974) 1-55. </journal>
Reference-contexts: The false assumption of the constant running time of the z-buffer algorithm is the result of a gross misunderstanding of some speculations made more than 20 years ago by Sutherland et al <ref> [79] </ref>. As the underestimated | and not experimentally obtained | timing results were tabulated, authors of textbooks took them as experimental data. <p> Note that no assumption on the distribution of the input data was made, the only requirement is that the expected number of edge intersections is O (N ). 4 Approximation algorithms A widely used classification of visibility algorithms distinguishes two main classes: object-space and image-space algorithms <ref> [32, 33, 65, 79] </ref>.
Reference: [80] <author> Teller, S. J., Sequin, C. H. </author> <title> Visibility preprocessing for interactive walktroughs. </title> <booktitle> Proc. Siggraph 91, </booktitle> <year> 1991, </year> <pages> 61-69. </pages>
Reference-contexts: Only objects in the potentially visible set of cells are actually submitted to the hidden object removal algorithm. Schaufler and Sturzlinger [73] propose a three-dimensional image cache. Another group of new techniques are hierarchical or level-of-detail algorithms and object simplification <ref> [43, 47, 72, 80, 81] </ref>. VR applications also increased the practical significance of research on reducing the growing rate of visibility algorithms [19, 20, 21, 18, 58, 59] both in the worst case and on the average.
Reference: [81] <author> Teller, S. J., Hanrahan, P. </author> <title> Global visibility algorithms for illumination computations. </title> <booktitle> Proc. Siggraph 93, </booktitle> <address> Anaheim, California, </address> <year> 1993, </year> <pages> 239-246. </pages>
Reference-contexts: Only objects in the potentially visible set of cells are actually submitted to the hidden object removal algorithm. Schaufler and Sturzlinger [73] propose a three-dimensional image cache. Another group of new techniques are hierarchical or level-of-detail algorithms and object simplification <ref> [43, 47, 72, 80, 81] </ref>. VR applications also increased the practical significance of research on reducing the growing rate of visibility algorithms [19, 20, 21, 18, 58, 59] both in the worst case and on the average.
Reference: [82] <author> Terashima, N. </author> <title> Telesensation | distributed interactive virtual reality | overview and prospects. </title> <journal> IFIP Transactions A | Computer Science and Technology 51, </journal> <year> (1994) </year> <month> 49-59. </month>
Reference-contexts: Then the scene is re-generated at the viewer's location, who can enter the scene, walk around there, and touch the objects found there <ref> [82] </ref>. Though VR is based on traditional computer-graphics technology, some new techniques developed specifically for VR also emerged recently. One of these techniques is object preselection or culling, when simple mechanisms are used to reject most of the objects.
Reference: [83] <author> Usoh, M., Slater, M. </author> <title> An exploration of immersive virtual environments. </title> <address> Endeavour 19,1 (1995) 34-38. </address>
Reference-contexts: 1 Introduction Virtual reality (VR) is a new human-computer interface paradigm to create the effect of a three-dimensional environment in which the user directly interacts with virtual objects. An immersive virtual environment allows human participants to engage their perceptual skills in solving problems <ref> [47, 83] </ref>. Immersive systems require special equipment, eg, a head-mounted display. Desktop, or non-immersive systems use a normal visual display unit that displays the image of the environment. The user interacts with input devices, such as a data glove or a three-dimensional mouse.
Reference: [84] <author> Watt, A. </author> <title> Fundamentals of Three-Dimensional Computer Graphics. </title> <publisher> Addison-Wesley, </publisher> <address> Wok-ingham, UK, </address> <year> 1989. </year>
Reference-contexts: Finally in section 8 the practical significance of the proposed theoretical background is evaluated, and directions for further work are recommended. 2 Rendering three-dimensional scenes For the description of three-dimensional objects polygon-mesh models are most widely used <ref> [47, 72, 84] </ref>. These models provide an exact description for objects modelled by polyhedra, and an approximation for objects with curved surfaces. A polygon-mesh model is a collection of simple polygons possibly with holes, such that the polygons can intersect only at their edges.
Reference: [85] <author> Watt, A., Watt, M. </author> <title> Advanced Animation and Rendering Techniques. Theory and Practice. </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England, </address> <year> 1992, </year> <pages> 455 pp. </pages>
Reference-contexts: Indeed, this theoretical background cannot even predict or explain the performance of the most widely used hidden-surface technique, the z-buffer algorithm. The 2 running time of the z-buffer algorithm is often claimed to be a linear function of the input size, or even constant <ref> [29, 31, 32, 33, 65, 85] </ref>.
Reference: [86] <author> Wloka, M. M. </author> <title> Lag in multiprocessor virtual-reality. Presence | Teleoperators and Virtual Environments 4,1 (1995) 50-63. </title>
Reference-contexts: Lag is critical when trying to achieve immersion <ref> [86] </ref>.
Reference: [87] <author> Wylie, C., Romney, G. W., Evans, D. C., Erdahl, A. C. </author> <title> Halftone perspective drawings by computer. </title> <booktitle> Proc. Fall Joint Computer Conference 1967, </booktitle> <publisher> Thompson Books, </publisher> <address> Washington DC, </address> <year> 1967, </year> <pages> 49-58. </pages>
Reference-contexts: Another algorithm, based on a divide-and conquer approach and called the merge method also achieves the optimal O (n log n) worst-case time [3]. Early scan-line algorithms <ref> [8, 87] </ref> take fi (n 2 ) time in the worst case [19], and attempt to exploit coherence [32, 65] which is no longer possible in a parallel environment, where adjacent scan lines may be processed by different processors.
Reference: [88] <author> Yagel, R., Ray, W. </author> <title> Visibility computation for efficient walkthrough of complex environments. Presence | Teleoperators and Virtual Environments 5,1 (1995) 45-60. </title>
Reference-contexts: Lag is critical when trying to achieve immersion [86]. In spite of the shortcomings of contemporary VR systems, a wide range of application areas are reported in the literature: flight [71] and driving [5] simulation, scientific visualisation [9], medicine [4, 44], walk-through and fly-through of complex environments <ref> [28, 48, 88, 89] </ref>, lighting-design [28] and even performance analysis of parallel computer systems [70]. Cobb et al [14] examined the feasibility of VR as a tool for the UK manufacturing industry. <p> As a result, only a very small portion of the model has to go through the time-consuming process of visibility computations. Actually the concept is well known in computer graphics as clipping, but considering the huge amount of input data, some preprocessing is justified. Yagel and Ray <ref> [88] </ref> report on such a culling mechanism based on regular space subdivision. Only objects in the potentially visible set of cells are actually submitted to the hidden object removal algorithm. Schaufler and Sturzlinger [73] propose a three-dimensional image cache.
Reference: [89] <author> Zobel, R. W. </author> <title> The representation of experience in architectural design. Presence | Teleoperators and Virtual Environments 4,3 (1995) 254-266. </title> <type> 34 </type>
Reference-contexts: Lag is critical when trying to achieve immersion [86]. In spite of the shortcomings of contemporary VR systems, a wide range of application areas are reported in the literature: flight [71] and driving [5] simulation, scientific visualisation [9], medicine [4, 44], walk-through and fly-through of complex environments <ref> [28, 48, 88, 89] </ref>, lighting-design [28] and even performance analysis of parallel computer systems [70]. Cobb et al [14] examined the feasibility of VR as a tool for the UK manufacturing industry.
References-found: 88

