URL: http://www.cs.umd.edu/~tseng/cmsc732/papers/suif-pointer.ps.Z
Refering-URL: http://www.cs.umd.edu/~tseng/cmsc732/papers.html
Root-URL: 
Email: fbwilson,lamg@cs.stanford.edu  
Title: Efficient Context-Sensitive Pointer Analysis for C Programs  
Author: Robert P. Wilson and Monica S. Lam 
Web: http://suif.stanford.edu  
Address: CA 94305  
Affiliation: Computer Systems Laboratory Stanford University,  
Abstract: This paper proposes an efficient technique for context-sensitive pointer analysis that is applicable to real C programs. For efficiency, we summarize the effects of procedures using partial transfer functions. A partial transfer function (PTF) describes the behavior of a procedure assuming that certain alias relationships hold when it is called. We can reuse a PTF in many calling contexts as long as the aliases among the inputs to the procedure are the same. Our empirical results demonstrate that this technique is successfula single PTF per procedure is usually sufficient to obtain completely context-sensitive results. Because many C programs use features such as type casts and pointer arithmetic to circumvent the high-level type system, our algorithm is based on a low-level representation of memory locations that safely handles all the features of C. We have implemented our algorithm in the SUIF compiler system and we show that it runs efficiently for a set of C benchmarks. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of Pointers and Structures. </title> <booktitle> In Proceedings of the ACM SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Specifically, we never evaluate a node until one of its immediate predecessors has been evaluated, and we never evaluate an assignment until its destination locations are known <ref> [1] </ref>. We take advantage of the extended parameters to increase the opportunities for strong updates. A strong update is only possible if the destination of an assignment is a single location set representing a unique location. <p> Pointers typically have only a few possible values, so we record the possibilities using linked lists rather than bit vectors. Since the points-to functions usually do not change very much between two adjacent program points, we also incorporate the sparse representation described by Chase et al. <ref> [1] </ref>. This scheme only records the points-to values that change at each node. Because of the sparse points-to function representation, looking up the values of a pointer requires searching back for the most recent assignment to that location. <p> Since we only search for assignments in the dominating nodes, each meet node must contain SSA -functions [3] to identify the values to be assigned in it. We insert these - functions dynamically as new locations are assigned <ref> [1] </ref>. The pseudo-code for handling a meet node is shown in Figure 9. <p> Values assigned to one location set must be observed by references to overlapping locations. Thus, when a pointer is dereferenced, we 2 Instead of building skeleton trees <ref> [1] </ref>, we just keep lists of assignments sorted according to a bottom-up traversal of the dominator tree. <p> Although k-limiting can sometimes provide more information, our algorithm is not intended to distinguish the elements of recursive data structures. That problem has been addressed by a number of others <ref> [1, 4, 8, 9, 13] </ref>. Using symbolic names to represent the values of pointers passed into a procedure was first suggested by Landi and Ryder [12]. They use non-visible variables to represent storage outside the scope of a procedure. Emami et al. use invisible variables for the same purpose.
Reference: [2] <author> J.-D. Choi, M. Burke, and P. Carini. </author> <title> Efficient Flow-Sensitive Interprocedural Computation of Pointer-Induced Aliases and Side Effects. </title> <booktitle> In Proceedings of the 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: That is, values can propagate from one call site, through the callee procedure, and back to a different call site. Some algorithms attempt to avoid unrealizable paths by tagging the pointer information with abstractions of the calling contexts <ref> [2, 12] </ref>. However, these algorithms still inappropriately combine some information from different contexts. Emami et al. have proposed a context-sensitive algorithm that completely reanalyzes a procedure for each of its calling contexts [6]. <p> The minimal context information is simply the statement that creates the block. Including the call graph edges along which the new blocks are returned, eliminating duplicate edges in recursive cycles, can provide better precision for some programs <ref> [2] </ref>. While this scheme is a good starting point, we have found that for some programs it produces far more heap blocks than we would like. <p> Our analysis is based on a points-to representation similar to the one described by Emami et al. [6]. Other work has used alias pairs. Choi et al. show how alias pairs can be compactly represented using a transitive reduction strategy <ref> [2] </ref>. In that compact form, the alias pairs are not much different than a points-to representation. There are some differences in precision between using full alias pairs and points-to functions, but neither is clearly superior [14].
Reference: [3] <author> R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck. </author> <title> An Efficient Method of Computing Static Single Assignment Form. </title> <booktitle> In Proceedings of the 16th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 25-35, </pages> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: This may add new extended parameters in the PTFs on the call stack. Since we only search for assignments in the dominating nodes, each meet node must contain SSA -functions <ref> [3] </ref> to identify the values to be assigned in it. We insert these - functions dynamically as new locations are assigned [1]. The pseudo-code for handling a meet node is shown in Figure 9.
Reference: [4] <author> A. Deutsch. </author> <title> Interprocedural May-Alias Analysis for Pointers: Beyond k-limiting. </title> <booktitle> In Proceedings of the ACM SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Although k-limiting can sometimes provide more information, our algorithm is not intended to distinguish the elements of recursive data structures. That problem has been addressed by a number of others <ref> [1, 4, 8, 9, 13] </ref>. Using symbolic names to represent the values of pointers passed into a procedure was first suggested by Landi and Ryder [12]. They use non-visible variables to represent storage outside the scope of a procedure. Emami et al. use invisible variables for the same purpose.
Reference: [5] <author> M. Emami. </author> <title> A Practical Interprocedural Alias Analysis for an Optimizing/Parallelizing C Compiler. </title> <type> Master's thesis, </type> <institution> School of Computer Science, McGill University, </institution> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: Fortunately, our location sets solve this problem nicely. We simply allow the location set offsets to be negative, as shown in Figure 7. Emami solves this problem by always creating parameters for structures before any other parameters <ref> [5] </ref>, but that cannot work here because we create the parameters as they are referenced. 3.3 Points-to Functions Both the domains and ranges of the points-to functions are expressed in terms of location sets.
Reference: [6] <author> M. Emami, R. Ghiya, and L. J. Hendren. </author> <title> Context-Sensitive Interprocedural Points-to Analysis in the Presence of Function Pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: However, these algorithms still inappropriately combine some information from different contexts. Emami et al. have proposed a context-sensitive algorithm that completely reanalyzes a procedure for each of its calling contexts <ref> [6] </ref>. This not only prevents values from propagating along unrealizable paths, but also guarantees that the analysis of a procedure in one calling context is completely independent of all the other contexts. <p> An extended parameter represents the locations reached through an input pointer at the beginning of a procedure. Every object is represented by at most one extended parameter. This is similar to the invisible variables defined by Emami et al. <ref> [6] </ref>. For procedure f in Figure 1, we use the extended parameter 1 p to represent the location initially pointed to by p; 1 p represents x0 for the call at S1 and z0 for the call at S2. <p> Within the pointer analysis itself, that information can enable strong updates, where assignments overwrite the previous contents of their destinations. Others have kept track of possible and definite points-to values separately <ref> [6] </ref>, but that is unnecessary for our purposes. We only need that information at the point where a pointer is dereferenced. Since we assume that the input is legal, a location being dereferenced must contain a valid pointer. <p> Most of the previous work has made simplifying assumptions that rule out things such as pointer arithmetic, type casting, union types, out-of-bounds array references, and variable argument lists. Our analysis is based on a points-to representation similar to the one described by Emami et al. <ref> [6] </ref>. Other work has used alias pairs. Choi et al. show how alias pairs can be compactly represented using a transitive reduction strategy [2]. In that compact form, the alias pairs are not much different than a points-to representation.
Reference: [7] <author> M. W. Hall, S. P. Amarasinghe, B. R. Murphy, and M. S. Lam. </author> <title> Interprocedural Analysis for Parallelization: Preliminary Results. </title> <type> Technical Report CSL-TR-95-665, </type> <institution> Computer Systems Lab, Stanford University, Stanford, </institution> <address> CA 94305-4055, </address> <month> Apr. </month> <year> 1995. </year>
Reference-contexts: Reanalyzing for every calling context is only practical for small programs. For larger programs, the exponential cost quickly becomes prohibitive. Interval analysis, which has been successfully used to analyze side effects for scalar and array variables in Fortran programs <ref> [7, 10] </ref>, is an approach that combines context sensitivity and efficiency. This technique summarizes the effects of a procedure by a transfer function.
Reference: [8] <author> W. L. Harrison III. </author> <title> The Interprocedural Analysis and Automatic Parallelization of Scheme Programs. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2(3) </volume> <pages> 176-396, </pages> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Although k-limiting can sometimes provide more information, our algorithm is not intended to distinguish the elements of recursive data structures. That problem has been addressed by a number of others <ref> [1, 4, 8, 9, 13] </ref>. Using symbolic names to represent the values of pointers passed into a procedure was first suggested by Landi and Ryder [12]. They use non-visible variables to represent storage outside the scope of a procedure. Emami et al. use invisible variables for the same purpose.
Reference: [9] <author> L. J. Hendren and A. Nicolau. </author> <title> Parallelizing Programs with Recursive Data Structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Although k-limiting can sometimes provide more information, our algorithm is not intended to distinguish the elements of recursive data structures. That problem has been addressed by a number of others <ref> [1, 4, 8, 9, 13] </ref>. Using symbolic names to represent the values of pointers passed into a procedure was first suggested by Landi and Ryder [12]. They use non-visible variables to represent storage outside the scope of a procedure. Emami et al. use invisible variables for the same purpose.
Reference: [10] <author> F. Irigoin, P. Jouvelot, and R. Triolet. </author> <title> Semantical In-terprocedural Parallelization: An Overview of the PIPS Project. </title> <booktitle> In Proceedings of the 1991 ACM International Conference on Supercomputing, </booktitle> <pages> pages 244-251, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Reanalyzing for every calling context is only practical for small programs. For larger programs, the exponential cost quickly becomes prohibitive. Interval analysis, which has been successfully used to analyze side effects for scalar and array variables in Fortran programs <ref> [7, 10] </ref>, is an approach that combines context sensitivity and efficiency. This technique summarizes the effects of a procedure by a transfer function.
Reference: [11] <author> N. Jones and S. Muchnick. </author> <title> Flow Analysis and Optimization of Lisp-like Structures. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 102-131. </pages> <publisher> Prentice Hall, </publisher> <year> 1979. </year>
Reference-contexts: Our scheme for naming heap objects is taken directly from Choi et al. Most other work has used k-limiting, where some arbitrary limit is imposed on the length of pointer chains in recursive data structures <ref> [11] </ref>. Although k-limiting can sometimes provide more information, our algorithm is not intended to distinguish the elements of recursive data structures. That problem has been addressed by a number of others [1, 4, 8, 9, 13].
Reference: [12] <author> W. Landi and B. G. Ryder. </author> <title> A Safe Approximate Algorithm for Interprocedural Pointer Aliasing. </title> <booktitle> In Proceedings of the ACM SIGPLAN'92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: That is, values can propagate from one call site, through the callee procedure, and back to a different call site. Some algorithms attempt to avoid unrealizable paths by tagging the pointer information with abstractions of the calling contexts <ref> [2, 12] </ref>. However, these algorithms still inappropriately combine some information from different contexts. Emami et al. have proposed a context-sensitive algorithm that completely reanalyzes a procedure for each of its calling contexts [6]. <p> That problem has been addressed by a number of others [1, 4, 8, 9, 13]. Using symbolic names to represent the values of pointers passed into a procedure was first suggested by Landi and Ryder <ref> [12] </ref>. They use non-visible variables to represent storage outside the scope of a procedure. Emami et al. use invisible variables for the same purpose. <p> We have also analyzed some Unix utilities, grep and diff, and a number of the benchmarks used by Landi and Ryder <ref> [12] </ref>. Proce- Analysis Avg.
Reference: [13] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting Conflicts Between Structure Accesses. </title> <booktitle> In Proceedings of the ACM SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Although k-limiting can sometimes provide more information, our algorithm is not intended to distinguish the elements of recursive data structures. That problem has been addressed by a number of others <ref> [1, 4, 8, 9, 13] </ref>. Using symbolic names to represent the values of pointers passed into a procedure was first suggested by Landi and Ryder [12]. They use non-visible variables to represent storage outside the scope of a procedure. Emami et al. use invisible variables for the same purpose.
Reference: [14] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. D. Choi, M. G. Burke, and P. Carini. </author> <title> Pointer-Induced Aliasing: </title>
Reference-contexts: In that compact form, the alias pairs are not much different than a points-to representation. There are some differences in precision between using full alias pairs and points-to functions, but neither is clearly superior <ref> [14] </ref>. We have found that 9 the points-to function is a compact representation that works well for analyzing C programs. Our scheme for naming heap objects is taken directly from Choi et al.
References-found: 14

