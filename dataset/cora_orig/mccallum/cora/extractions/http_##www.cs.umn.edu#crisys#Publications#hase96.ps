URL: http://www.cs.umn.edu/crisys/Publications/hase96.ps
Refering-URL: http://www.cs.umn.edu/crisys/pubs.htm
Root-URL: http://www.cs.umn.edu
Email: heimdahl@cs.umn.edu  czerny@cps.msu.edu  
Title: Using PVS to Analyze Hierarchical State-Based Requirements for Completeness and Consistency  
Author: Mats P.E. Heimdahl Barbara J. Czerny 
Address: Minneapolis, MN 55455  A-714 Wells Hall  East Lansing, MI 48824  
Affiliation: University of Minnesota, Institute of Technology Department of Computer Science, 4-192 EE/CS Bldg.  Department of Computer Science,  Michigan State University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Although our approach has been largely successful, there are some drawbacks with the current implementation that must be addressed. Our prototype implementation uses Binary Decision Diagrams (BDDs) <ref> [1] </ref> to perform the analysis. Unfortunately, since BDDs treat predicates and functions as uninterpreted and thus fail to capture their semantics, the use of BDDs can lead to large numbers of spurious (false) error reports. <p> Nevertheless, some limitations with the approach have surfaced. Most importantly, the accuracy of the algorithms we use to and and or large Boolean formulas needs improvement. Currently, we are using Binary Decision Diagrams (BDDs) <ref> [1] </ref> to manipulate the formulas. The approach provides excellent performance in terms of execution time. Unfortunately, the accuracy of the BDD approach is, in some cases, inadequate. When analyzing the most complex parts of the TCAS requirements, the number of spurious (false) error reports can be a problem. <p> An example of indirection is shown in Figure 3, where the guarding condition refers to the macro Potential-Threat-Range-Test shown in Figure 4. Consequently, a large table typically uses 30 to 50 predicates spread over 8-10 macros. As previously mentioned, our prototype tool uses Binary Decision Diagrams (BDDs) <ref> [1] </ref> to represent and manipulate the guarding conditions. BDDs are directed acyclic graphs that represent Boolean formulas in a canonical form. Algorithms for manipulating BDDs, for example, anding and oring Boolean formulas, are efficient and provide good average performance.
Reference: [2] <author> M. Chechik and J. Gannon. </author> <title> Automatic verification of requirements implementations. </title> <booktitle> In Proceedings of the 1994 International Symposium on Software Testing and Analysis, </booktitle> <pages> pages 1-14, </pages> <year> 1994. </year>
Reference-contexts: Other approaches to static requirements analysis, such as the approach used to analyze SCR style requirements for consistency [11], have similar problems. To overcome these problems, most approaches to static analysis enforce restrictions on the modeling language to facilitate accurate analysis, such as restricting variables to Boolean <ref> [2, 3, 11] </ref>. In our work we want to avoid enforcing confining restrictions on our modeling language.
Reference: [3] <author> M. Chechik and J. Gannon. </author> <title> Automatic analysis of consistency between implementations and requirements: A case study. </title> <booktitle> In Proceedings of the Tenth Annual Conference on Computer Assurance, </booktitle> <pages> pages 123-131, </pages> <year> 1995. </year>
Reference-contexts: Other approaches to static requirements analysis, such as the approach used to analyze SCR style requirements for consistency [11], have similar problems. To overcome these problems, most approaches to static analysis enforce restrictions on the modeling language to facilitate accurate analysis, such as restricting variables to Boolean <ref> [2, 3, 11] </ref>. In our work we want to avoid enforcing confining restrictions on our modeling language.
Reference: [4] <author> J. Crow, S. Owre, J. Rushby, et al. </author> <title> A tutorial introduction to PVS. </title> <booktitle> In WIFT 95: Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <year> 1995. </year>
Reference-contexts: We are currently investigating how the Prototype Verification System (PVS) and its theorem proving component can help us increase the accuracy of our analysis. PVS is a verification system that provides an interactive environment for writing formal specifications and checking formal proofs <ref> [4] </ref>. The results of the investigation have been largely positive. <p> - Ground_Level ()) &gt; 1200 : F ; (Own_Tracked_Alt () - Ground_Level ()) &lt;= 1200 : F ; state Inhibited 4 Using PVS For Completeness and Consistency Analysis The Prototype Verification System (PVS) is a verification system that provides an interactive environment for the development and analysis of formal specifications <ref> [4, 15, 16] </ref>. PVS consists of a specification language, a parser, a type-checker, an interactive theorem prover, and various browsing tools. PVS has been used to model and reason about many different systems, for example, clock synchronization [18, 20] and the AAMP5 Microprocessor [14].
Reference: [5] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: This paper discusses the problems with spurious error reports and describes our experiences using the Prototype Verification System to increase the accuracy of our analysis results. Languages based on hierarchical finite state machines, for example, Statecharts <ref> [5, 6, 7] </ref> and the Requirements State Machine Language (RSML) [13], are powerful modeling languages suitable for specification of embedded software [8]. Embedded software is software that is part of a larger system and usually provides at least partial control over the system in which it is embedded. <p> The language is based on hierarchical finite state machines and is in many ways similar to Statecharts by David Harel; for example, RSML supports parallelism, hierarchies, and guarded transitions borrowed from Statecharts (Figure 1) <ref> [5, 8] </ref>. One of the main design goals of RSML was readability and understandability by non computer professionals such as, in our case, pilots, air frame manufacturers, and FAA representatives. During the TCAS project, we discovered that the guarding conditions required to accurately capture the requirements were often complex.
Reference: [6] <author> D. Harel. </author> <title> On visual formalisms. </title> <journal> Communications of the ACM, </journal> <volume> 31(5) </volume> <pages> 514-530, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: This paper discusses the problems with spurious error reports and describes our experiences using the Prototype Verification System to increase the accuracy of our analysis results. Languages based on hierarchical finite state machines, for example, Statecharts <ref> [5, 6, 7] </ref> and the Requirements State Machine Language (RSML) [13], are powerful modeling languages suitable for specification of embedded software [8]. Embedded software is software that is part of a larger system and usually provides at least partial control over the system in which it is embedded.
Reference: [7] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtull-Trauring, and M. Trakhtenbrot. Statemate: </author> <title> A working environment for the development of complex reactive systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4), </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: This paper discusses the problems with spurious error reports and describes our experiences using the Prototype Verification System to increase the accuracy of our analysis results. Languages based on hierarchical finite state machines, for example, Statecharts <ref> [5, 6, 7] </ref> and the Requirements State Machine Language (RSML) [13], are powerful modeling languages suitable for specification of embedded software [8]. Embedded software is software that is part of a larger system and usually provides at least partial control over the system in which it is embedded.
Reference: [8] <author> D. Harel and A. Pnueli. </author> <title> On the development of reactive systems. </title> <editor> In K.R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 477-498. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Languages based on hierarchical finite state machines, for example, Statecharts [5, 6, 7] and the Requirements State Machine Language (RSML) [13], are powerful modeling languages suitable for specification of embedded software <ref> [8] </ref>. Embedded software is software that is part of a larger system and usually provides at least partial control over the system in which it is embedded. <p> This type of software is often reactive in that it must react or respond to environmental conditions as reflected in the inputs arriving at the software boundary <ref> [8] </ref>. A robust system will detect and respond appropriately to violations of assumptions about the system environment (such as unexpected inputs). Therefore, in a robust system the software behavior must be completely specified with respect to its input domain. <p> The language is based on hierarchical finite state machines and is in many ways similar to Statecharts by David Harel; for example, RSML supports parallelism, hierarchies, and guarded transitions borrowed from Statecharts (Figure 1) <ref> [5, 8] </ref>. One of the main design goals of RSML was readability and understandability by non computer professionals such as, in our case, pilots, air frame manufacturers, and FAA representatives. During the TCAS project, we discovered that the guarding conditions required to accurately capture the requirements were often complex.
Reference: [9] <author> M. P.E. Heimdahl and N.G. Leveson. </author> <title> Completeness and Consistency Analysis of State-Based Requirements. </title> <booktitle> In Proceedings of the 17th International Conference on Software Engineering, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: Previously, we have defined procedures for analyzing hierarchical state-based requirements specifications for two properties: (1) completeness with respect to a set of criteria related to robustness (a response is specified for every possible input and input sequence) and (2) consistency (the specification is free from conflicting requirements and undesired nondeterminism) <ref> [9, 10] </ref>. We implemented the analysis procedures in a prototype tool and evaluated their effectiveness and efficiency on a large real world requirements specification expressed in an hierarchical state-based language called RSML (Requirements State Machine Language).
Reference: [10] <author> M. P.E. Heimdahl and N.G. Leveson. </author> <title> Completeness and Consistency Analysis of State-Based Requirements. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> TSE-22(6):363-377, </volume> <month> June </month> <year> 1996. </year>
Reference-contexts: Previously, we have defined procedures for analyzing hierarchical state-based requirements specifications for two properties: (1) completeness with respect to a set of criteria related to robustness (a response is specified for every possible input and input sequence) and (2) consistency (the specification is free from conflicting requirements and undesired nondeterminism) <ref> [9, 10] </ref>. We implemented the analysis procedures in a prototype tool and evaluated their effectiveness and efficiency on a large real world requirements specification expressed in an hierarchical state-based language called RSML (Requirements State Machine Language). <p> In state-based languages such as Statecharts and RSML, the transitions between states are guarded by conditions; the guarding condition must be true before the transition can be taken. Completeness and consistency in a state-based model implies the following <ref> [10] </ref>: 1. Every state must have a deterministic behavior (transition) defined for every possible input event, 2. The logical or of the guarding conditions on every transition out of any state must form a tautology; for any condition, there is always a transition that can be taken, and 3. <p> Manually verifying that a specification is complete and consistent is a time-consuming and error-prone process. Therefore, we formalized and implemented the analysis procedures in a prototype tool <ref> [10] </ref>. A detailed description of the tool can be found in Section 3. <p> Therefore, TCAS II provides a challenging testbed for experimental application of formal methods and automated analysis to a real system. The initial results from the analysis effort were encouraging <ref> [10] </ref> and scaled well to a large requirements specification. Nevertheless, some limitations with the approach have surfaced. Most importantly, the accuracy of the algorithms we use to and and or large Boolean formulas needs improvement. Currently, we are using Binary Decision Diagrams (BDDs) [1] to manipulate the formulas. <p> A macro is simply a named and/or table defined elsewhere in the document. A detailed description of the full notation can be found in [13]. Formal Semantics and Analysis Criteria. To facilitate automated analysis, the formal semantics of RSML has been defined as a composition of simple mathematical functions <ref> [10] </ref>. The individual transitions in the state machine are viewed as functions mapping one system state to the next. The structure of the state machine and the event propagation mechanism are then used to compose these functions into a statement about the behavior of the complete state machine. <p> If a set of simple compositional rules are satisfied, it is guaranteed that the machine behaves as a mathematical function, and, by definition, is complete (a behavior has been defined for all possible inputs and input sequences) and consistent (no conflicting requirements exist). The interested reader is referred to <ref> [10] </ref> for a formal description of the semantics and the compositional rules. <p> Clearly, the most costly part of the analysis is to and and or large guarding conditions together to check for contradictions and tautologies respectively. 3 The Current Approach The analysis procedures have been implemented in a prototype tool <ref> [10] </ref>. The tool parses a textual version of RSML, builds an internal representation of the state machine appropriate for analysis, and performs completeness and consistency analysis. <p> Consequently, spurious error reports may be generated. 3.1 Spurious Error Reports During initial experiments with our first prototype tool, spurious error reports were not a serious problem <ref> [10] </ref>. All spurious errors could be traced either to (1) a lack of type checking capability or (2) the inability of the tool to adequately include information about the structure of the state machine in the analysis. <p> First, we have demonstrated that static completeness and consistency analysis of a complex requirements specification is both feasible and effective <ref> [10] </ref>. Even if our BDD approach currently suffers from some limitations, we have been able to identify problems in a document that has undergone extensive manual reviews.
Reference: [11] <author> C. L. Heitmeyer, B. L. Labaw, and D. Kiskis. </author> <title> Consistency checking of SCR-style requirements specifications. </title> <booktitle> In Proceedings of the International Symposium on Requirements Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: The problem with spurious error reports is not unique to our analysis approach. Other approaches to static requirements analysis, such as the approach used to analyze SCR style requirements for consistency <ref> [11] </ref>, have similar problems. To overcome these problems, most approaches to static analysis enforce restrictions on the modeling language to facilitate accurate analysis, such as restricting variables to Boolean [2, 3, 11]. In our work we want to avoid enforcing confining restrictions on our modeling language. <p> Other approaches to static requirements analysis, such as the approach used to analyze SCR style requirements for consistency [11], have similar problems. To overcome these problems, most approaches to static analysis enforce restrictions on the modeling language to facilitate accurate analysis, such as restricting variables to Boolean <ref> [2, 3, 11] </ref>. In our work we want to avoid enforcing confining restrictions on our modeling language.
Reference: [12] <author> N. G. Leveson, M. Heimdahl, H. Hildreth, and J. Reese. </author> <title> TCAS II Requirements Specification. </title>
Reference-contexts: To demonstrate that our automated approach is feasible and that it is applicable to realistic systems, we applied the analysis to the requirements for a large commercial avionics system called TCAS II (Traffic alert and Collision Avoidance System II) <ref> [12] </ref>. TCAS II is an airborne, collision-avoidance system required on all commercial aircraft carrying more than 30 passengers through U.S. airspace.
Reference: [13] <author> N. G. Leveson, M. P.E. Heimdahl, H. Hildreth, and J. D. Reese. </author> <title> Requirements specification for process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9), </volume> <month> September </month> <year> 1994. </year>
Reference-contexts: This paper discusses the problems with spurious error reports and describes our experiences using the Prototype Verification System to increase the accuracy of our analysis results. Languages based on hierarchical finite state machines, for example, Statecharts [5, 6, 7] and the Requirements State Machine Language (RSML) <ref> [13] </ref>, are powerful modeling languages suitable for specification of embedded software [8]. Embedded software is software that is part of a larger system and usually provides at least partial control over the system in which it is embedded. <p> In our work we want to avoid enforcing confining restrictions on our modeling language. RSML was successfully used to model a complex avionics system <ref> [13] </ref>, and our experience from that effort convinced us that enforcing restrictions, such as the restrictions mentioned above, will limit the usability of the modeling language to a point where it will not be used by practitioners. <p> A macro is simply a named and/or table defined elsewhere in the document. A detailed description of the full notation can be found in <ref> [13] </ref>. Formal Semantics and Analysis Criteria. To facilitate automated analysis, the formal semantics of RSML has been defined as a composition of simple mathematical functions [10]. The individual transitions in the state machine are viewed as functions mapping one system state to the next. <p> Limiting the input and output variables to enumerated types and disallowing arithmetic expressions in the predicates would eliminate all of our problems with spurious errors. Unfortunately, it would also make RSML unsuitable as a modeling language for embedded control systems, the domain for which the language was originally developed <ref> [13] </ref>. Instead, we are attempting to solve the problem by using more powerful analysis methods. The next section describes our experiences using PVS to and and or the complex guarding conditions used in the TCAS II requirements specification.
Reference: [14] <author> S.P. Miller and M. Srivas. </author> <title> Formal verification of the AAMP5 microprocessor. </title> <booktitle> In Proceedings of the International Workshop on Industrial Strength Formal Techniques, </booktitle> <pages> pages 2-17, </pages> <year> 1995. </year>
Reference-contexts: PVS consists of a specification language, a parser, a type-checker, an interactive theorem prover, and various browsing tools. PVS has been used to model and reason about many different systems, for example, clock synchronization [18, 20] and the AAMP5 Microprocessor <ref> [14] </ref>. PVS contains a large library (called a prelude file) that contains many built-in theories that can be used during the proof process.
Reference: [15] <author> S. Owre, N. Shankar, and J.M.Rushby. </author> <title> The PVS Specification Language. </title> <institution> Computer Science Laboratory; SRI International, </institution> <address> Menlo Park, CA 94025, </address> <note> beta release edition, </note> <month> April </month> <year> 1993. </year>
Reference-contexts: - Ground_Level ()) &gt; 1200 : F ; (Own_Tracked_Alt () - Ground_Level ()) &lt;= 1200 : F ; state Inhibited 4 Using PVS For Completeness and Consistency Analysis The Prototype Verification System (PVS) is a verification system that provides an interactive environment for the development and analysis of formal specifications <ref> [4, 15, 16] </ref>. PVS consists of a specification language, a parser, a type-checker, an interactive theorem prover, and various browsing tools. PVS has been used to model and reason about many different systems, for example, clock synchronization [18, 20] and the AAMP5 Microprocessor [14].
Reference: [16] <author> S. Owre, N. Shankar, and J.M.Rushby. </author> <title> User Guide for the PVS Specification and Verification System. </title> <institution> Computer Science Laboratory; SRI International, </institution> <address> Menlo Park, CA 94025, </address> <note> beta release edition, </note> <month> March </month> <year> 1993. </year>
Reference-contexts: - Ground_Level ()) &gt; 1200 : F ; (Own_Tracked_Alt () - Ground_Level ()) &lt;= 1200 : F ; state Inhibited 4 Using PVS For Completeness and Consistency Analysis The Prototype Verification System (PVS) is a verification system that provides an interactive environment for the development and analysis of formal specifications <ref> [4, 15, 16] </ref>. PVS consists of a specification language, a parser, a type-checker, an interactive theorem prover, and various browsing tools. PVS has been used to model and reason about many different systems, for example, clock synchronization [18, 20] and the AAMP5 Microprocessor [14].
Reference: [17] <author> J. Rushby. </author> <title> Formal specification and verification for critical systems: Tools, achievements, and prospects. </title> <booktitle> In Electric Power Research Institute (EPRI) Workshop on Methodologies for Cost-Effective, Reliable Software Verification and Validation, </booktitle> <pages> pages 9-1 to 9-14, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: In particular, for our purposes, the decision procedures are extremely useful. Rushby notes that "it is enormously tedious to perform verifications involving even modest quantities of arithmetic in systems such as HOL that lack decision procedures" <ref> [17] </ref>. Although the decision procedures mainly deal with linear arithmetic, they can also help with some simple nonlinear reasoning, but the decision procedures are not complete for this case [19].
Reference: [18] <author> J. Rushby and F. von Henke. </author> <title> Formal verification of algorithms for critical systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(1) </volume> <pages> 13-23, </pages> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: PVS consists of a specification language, a parser, a type-checker, an interactive theorem prover, and various browsing tools. PVS has been used to model and reason about many different systems, for example, clock synchronization <ref> [18, 20] </ref> and the AAMP5 Microprocessor [14]. PVS contains a large library (called a prelude file) that contains many built-in theories that can be used during the proof process.
Reference: [19] <author> J. M. Rushby, </author> <year> 1995. </year> <type> Personal communication. </type>
Reference-contexts: In addition, PVS contains decision procedures for equality and linear inequality that are complete for linear arithmetic (multiplication by literal constants) on the reals <ref> [19, 21] </ref>. These features make PVS a promising tool that could potentially help solve the types of problems we outlined in the previous section. <p> Although the decision procedures mainly deal with linear arithmetic, they can also help with some simple nonlinear reasoning, but the decision procedures are not complete for this case <ref> [19] </ref>. Some of the predicates in the TCAS II requirements specification contain nonlinear arithmetic; this may be one of the reasons the largest test cases would not terminate since non-linear expressions limit the power of the decision procedures. We are currently investigating ways around this problem.
Reference: [20] <author> N. Shankar. </author> <title> Mechanical verification of a schematic protocol for byzantine fault-tolerant clock synchronization. </title> <type> Technical Report SRI-CSL-91-04, </type> <institution> SRI International, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: PVS consists of a specification language, a parser, a type-checker, an interactive theorem prover, and various browsing tools. PVS has been used to model and reason about many different systems, for example, clock synchronization <ref> [18, 20] </ref> and the AAMP5 Microprocessor [14]. PVS contains a large library (called a prelude file) that contains many built-in theories that can be used during the proof process.
Reference: [21] <author> N. Shankar, S. Owre, and J.M.Rushby. </author> <title> The PVS Proof Checker: A Reference Manual. </title> <institution> Computer Science Laboratory; SRI International, </institution> <address> Menlo Park, CA 94025, </address> <note> beta release edition, </note> <month> March </month> <year> 1993. </year> <month> 11 </month>
Reference-contexts: In addition, PVS contains decision procedures for equality and linear inequality that are complete for linear arithmetic (multiplication by literal constants) on the reals <ref> [19, 21] </ref>. These features make PVS a promising tool that could potentially help solve the types of problems we outlined in the previous section.
References-found: 21

