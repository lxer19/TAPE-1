URL: http://www.cs.concordia.ca/~faculty/gregb/home/PS/rood.ps.gz
Refering-URL: http://www.cs.concordia.ca/~faculty/gregb/home/paper.html
Root-URL: http://www.cs.concordia.ca
Email: fgregb,li,onog@cs.concordia.ca  
Title: Reusable Object-Oriented Design  
Author: G. Butler L. Li I.A. Tjandra 
Address: Montreal Quebec H3G 1M8 Canada  
Affiliation: Centre Interuniversitaire en Calcul Mathematique Algebrique Department of Computer Science Concordia University  
Abstract: Software design is a difficult creative task learnt from long experience. Reusable object-oriented design aims to describe and classify designs and design fragments so that designers may learn from other peoples' experience. Thus, it provides leverage for the design process. This paper surveys the field, discussing software architectures, application frameworks, design patterns, and the design of class libraries. The field is young with many open problems that still need to be researched. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Abowd, R. Allen, D. Garlan, </author> <title> Using style to give meaning to software architecture, </title> <booktitle> Proceedings of SIGSOFT'93: Foundations of Software Engineering, ACM Software Engineering Notes 18, </booktitle> <month> 3 (December </month> <year> 1993) </year> <month> 9-20. </month>
Reference-contexts: Another approach to utilising architectural styles is to encode a description of the components and constraints of an architecture into an software development environment. Thus the environment forces the designer to conform to the specified style. Garlan et al <ref> [1, 30] </ref> describe an architecture in terms of its components, connectors, configurations, ports, and roles. <p> As a consequence there is only a small body of work on how to formally specify design artifacts <ref> [1, 20, 23, 24, 36, 37, 59] </ref>. There is scope for further work in this area. * Experimental validation of claims that certain documentation or specification styles do improve understanding in practice is required. All aspects of research into software development need a firm experimental foundation.
Reference: [2] <author> C. Alexander, </author> <title> A Timeless Way of Building, </title> <publisher> Oxford University Press, </publisher> <year> 1979. </year>
Reference-contexts: So the pattern expresses the relationship among the elements in a problem, and describes the context: it lets the designer focus on the abstract level (building block) when thinking about the solution rather than focusing on the low concrete level (bricks) <ref> [2, 52] </ref>. The pattern mechanism also describes quality, impact and alternatives. "Design patterns identify, name, and abstract common themes in object-oriented design. They preserve design information by capturing the intent behind a design. <p> The first step to develop a pattern is a process of discovery [21, p.94]. "Beyond its elements, each building [or town] is defined by certain patterns of relationships among the elements.... These relationships are not extra, but necessary to the elements.... The elements themselves are patterns of relationships." <ref> [2, 21] </ref> "And finally, the things which seem like elements dissolve, and leave a fabric of relationships behind, 16 Design Pattern Name and Classification The name should convey the pattern's essence succinctly. A good name is vital, as it will become part of the design vocabulary. <p> Related Patterns What design patterns have closely related intent? What are the important differences? With which other patterns should this one be used? 17 which is the stuff that actually repeats itself, and gives the structure to a building or a town." <ref> [2, 21] </ref> To find a pattern among some low-level elements, such as classes and objects, means to find the relationships among them in a context. A pattern results from the experience of being an elaborator several times.
Reference: [3] <institution> Apple Computer, </institution> <note> Macapp 2.0 General Reference Manual, </note> <year> 1990. </year>
Reference-contexts: Once the selected configuration is compiled, a new instance of the application is ready for use. Early examples of application frameworks were for graphical user interfaces (GUI), including MacApp <ref> [3] </ref>, and Interviews [54]. There is now an abundance of GUI frameworks that have been used successfully on many platforms ranging from Dos to Unix, such as MacApp for MacIntosh, Owl-Windows for Dos/Windows, and Motif for Unix.
Reference: [4] <author> G. Arango and R. Prieto-Diaz, </author> <title> Domain analysis: Concepts and research directions, in Domain Analysis: Acquisition of Reusable Information for Software Construction, </title> <editor> R. Prieto-Diaz and G. Arango (eds), </editor> <publisher> Computer Society Press Tutorial, </publisher> <month> May </month> <year> 1989. </year>
Reference-contexts: developing software systems is identified, captured, and organized with the purpose of making it reusable when creating new systems." [74] The domain is analyzed from the user's and customer's perspective (as in normal systems analysis), and also analyzed from the developer's perspective to discover common software components, interfaces, and architectures <ref> [4, 74] </ref>. The sources of domain knowledge are the technical literature of the domain, requirements documents for current application software, surveys of customer needs, the architecture and components of existing systems, and domain experts.
Reference: [5] <author> D.S. Batory and S.W. O'Malley, </author> <title> The design and implementation of hierarchical software systems with reusable components, </title> <journal> ACM Trans. on Software Engineering and Methodology 1, </journal> <month> 4 </month> <year> (1992) </year> <month> 355-398. </month>
Reference-contexts: Don Batory <ref> [5] </ref> has developed the Genesis framework for relational database systems, where a database is a composition of functional layers (or realms), and the framework consists of the realms, their type constraints as functions, and the alternative implementations. <p> Batory and O'Malley <ref> [5] </ref> introduce tthe GenVoca approach to designing and implementing hierarchical software systems with reuse based on the object-oriented paradigm. It aims at developing a domain-independent model of hierarchical software system design and implementation based on interchangeable software components and large-scale reuse.
Reference: [6] <author> K. Beck, </author> <title> Patterns and software development, </title> <journal> Dr Dobbs Journal 19, </journal> <month> 2 </month> <year> (1993) </year> <month> 18-23. </month>
Reference-contexts: Eight design patterns are illustrated in the case study. 5.3 Other Information Patterns are a way of developing and packaging reusable software components <ref> [6] </ref>. Abstractors, who create reusable pieces, and elaborators, who massage those pieces to fit the needs of a user, are introduced as two sets of players in the world of software development.
Reference: [7] <author> Kent Beck and Ralph Johnson, </author> <title> Patterns generate architectures, </title> <publisher> ECOOP'94. </publisher>
Reference-contexts: Design processes may be modelled [63] as an exploration of issues, the arguments for and against a position on an issue, and the design steps taken because a position has been adopted. Beck and Johnson <ref> [7] </ref> use this approach to describe an architecture by the issues encountered and the design patterns chosen to address each issue. <p> Make sure that the information to implement them is present. 3.2 Other Information Design patterns can be used to describe an architecture and document the rationale for its development <ref> [7] </ref>. Architectural styles can be used to tailor proof techniques or provide a framework for modular proofs. <p> Knowing what varies, one can access related design patterns [29, Table 1.2, p.30]. It is then a matter of understanding the abstraction of the design pattern and matching components of the actual design to the abstract participants of the pattern. Beck and Johnson <ref> [7] </ref> illustrate the use of design patterns in developing the design for HotDraw, a framework for drawing editors. This is actual a re-documentation of an existing design [41], but it very clearly shows the nature of issue-based design.
Reference: [8] <author> Roger P. Beck, Satish R. Desai, Doris R. Ryan, Ronald W. Tower, Dennis Q. Vroom, Linda Mayer Wood, </author> <title> Architecture for large-scale reuse, </title> <journal> AT&T Technical Journal 71, </journal> <month> 6 </month> <year> (1992) </year> <month> 34-45. </month>
Reference-contexts: such as ET++, an editor toolkit [77] which has recently been used in MET++ which is a framework for multimedia applications; RTL framework [43] for code optimization in compilers; Choices for object-oriented operating systems [19]; BEE++ for analyzing and monitoring distributed programs [17]; and others for network management and telecommunications <ref> [8] </ref>, and financial engineering [10]. Don Batory [5] has developed the Genesis framework for relational database systems, where a database is a composition of functional layers (or realms), and the framework consists of the realms, their type constraints as functions, and the alternative implementations.
Reference: [9] <author> Ted J. Biggerstaff and Alan J. Perlis, </author> <title> Software Reusability, </title> <journal> volume I|Concepts and Models; volume II|Applications and Experience; ACM Press/Addison-Wesley, </journal> <year> 1989. </year>
Reference-contexts: Hence, lowering the effort and costs of maintenance and understanding are the primary means to increased productivity. Software reuse <ref> [9, 27, 67, 64] </ref> amortizes the cost of developing a component across many projects and supports better quality of products through more effort in inspections and testing. <p> is familiar with the basics of the object-oriented paradigm [45] and software engineering [32]. 2.1 Reuse Reuse applies not only to source-code fragments, but to all the intermediate products generated during software development, including requirements, documents, system specifications, and design: indeed any information that the developer needs to create software <ref> [9, 27, 67, 64] </ref>. The reuse of domain-independent software components for an organization usually involves features common to all application systems. These include common data structures, graphical user interfaces, interfaces to databases, and networks.
Reference: [10] <author> A. Birrer and T. Eggenschwiler, </author> <title> Frameworks in the financial engineering domain: An experience report, ECOOP'93 | Object-Oriented Programming, O.M. </title> <editor> Nierstrasz (ed.), </editor> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993, </year> <month> pp.21-35. </month>
Reference-contexts: editor toolkit [77] which has recently been used in MET++ which is a framework for multimedia applications; RTL framework [43] for code optimization in compilers; Choices for object-oriented operating systems [19]; BEE++ for analyzing and monitoring distributed programs [17]; and others for network management and telecommunications [8], and financial engineering <ref> [10] </ref>. Don Batory [5] has developed the Genesis framework for relational database systems, where a database is a composition of functional layers (or realms), and the framework consists of the realms, their type constraints as functions, and the alternative implementations.
Reference: [11] <author> Blandine Bongard, Bjorn Gronquist, Danielle Ribot, </author> <title> Impact of reuse on organizations, </title> <booktitle> Proc. </booktitle> <address> Reuse'93, Lucca, Italy, </address> <month> 24-26 Mar. </month> <note> 1993 (IEEE CS Press) </note>
Reference-contexts: The description of the solution may use a script language, such as a fourth-generation language (4GL) for relational databases, or a visual metaphor as in graphical user interface builders. 2.1.1 Scope of Reuse Three different scopes of reuse have been identified <ref> [11] </ref>: General reuse is independent of the domain of application. It almost entirely reuses components such as common data structures and graphical user interfaces, that are found in most applications. Reuse within an application domain restricts its focus to a single domain, such as insurance, or missile guidance.
Reference: [12] <author> Grady Booch, </author> <title> Software Components with Ada | Structures, Tools, and Subsystems, </title> <address> Benjamin/Cummings, Menlo Park, CA, </address> <year> 1987, </year> <pages> (xx)+635 pages. </pages>
Reference-contexts: Class libraries for common data structures are specific to the domain of data structures, and are the result of a long history of studying abstract data types and collection classes. The development of the Booch Components, first in Ada <ref> [12] </ref> then in C++ [14, 15], clearly uses a domain analysis. Utility class libraries for persistence, threads, and distributed computing follow a set of conventions, as do classes for I/O files and streams.
Reference: [13] <author> Grady Booch, </author> <title> Object-Oriented Design with Applications, </title> <booktitle> 2nd edition, </booktitle> <address> Benjamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: That is, software design produces a mechanism to perform the task, and that mechanism is later realised in a programming language. There are many methodologies for designing software <ref> [13, 18, 26, 39, 40, 44, 66, 76, 80, 81] </ref>. They chiefly address designing a system from scratch rather than design with reuse. Design is an example of a "wicked problem" [18, pp.19-21]. <p> There are generally multiple views of a system. Each view focuses on a single aspect of the system in an attempt to reduce complexity. Object-oriented design methodologies, for example, commonly use the following viewpoints or perspectives <ref> [13, 18, 66] </ref>: structural viewpoints of the static aspects of a system, which may include the organization of subsystems and modules at the architectural level; functional viewpoints which seek to describe what the system does in terms of its tasks; behavioral viewpoints describing the dynamic or causal nature of events and <p> The interaction diagrams <ref> [13] </ref> is applied to illustrate sequences of requests and collaborations between objects. Participants Describe the classes and/or objects participating in the design pattern and their responsibilities. Collaborations Describe how the participants collaborate to carry out their responsibilities.
Reference: [14] <author> Grady Booch and Michael Vilot, </author> <title> The design of the C++ Booch components, </title> <journal> ECOOP/OOPSLA 90, ACM SIGPLAN Notices 25, </journal> <month> 10 </month> <year> (1990) </year> <month> 1-11. </month>
Reference-contexts: Class libraries for common data structures are specific to the domain of data structures, and are the result of a long history of studying abstract data types and collection classes. The development of the Booch Components, first in Ada [12] then in C++ <ref> [14, 15] </ref>, clearly uses a domain analysis. Utility class libraries for persistence, threads, and distributed computing follow a set of conventions, as do classes for I/O files and streams.
Reference: [15] <author> Grady Booch and Michael Vilot, </author> <title> Simplifying the Booch components, </title> <note> The C++ Report (June 1993) pp.41-52. </note>
Reference-contexts: Class libraries for common data structures are specific to the domain of data structures, and are the result of a long history of studying abstract data types and collection classes. The development of the Booch Components, first in Ada [12] then in C++ <ref> [14, 15] </ref>, clearly uses a domain analysis. Utility class libraries for persistence, threads, and distributed computing follow a set of conventions, as do classes for I/O files and streams.
Reference: [16] <author> Christine L. Braun, </author> <title> Reuse, in Encyclopedia of Software Engineering, </title> <editor> John Marciniak (ed.), </editor> <publisher> John Wiley and Sons, </publisher> <year> 1994, </year> <pages> pp. 1055-1069. </pages>
Reference-contexts: Successful introduction of reuse requires an organization's software development process to be defined, that is, level 3 of the Capability Maturity Model scale [38]. In such cases, the conclusions from industrial reuse efforts <ref> [16, 50, 71] </ref> are typified by Hewlett-Packard's experience [53] of a 2-4 times return-on-investment from reuse. This is due to improved quality (up to 51% reduction in defects), improved productivity (up to 57% increase), and a 42% reduction in time-to-market. <p> A generic architecture is developed for this product family, so that there is a well-defined role for each component. The architecture, and its realization, is variously called a reference architecture, a domain specific software architecture (DSSA), or an application framework <ref> [16, 79] </ref>. The role of a component within the framework may also form part of the domain taxonomy and be used in classification and retrieval. For mature architectures and product families, one can build an application generator [22].
Reference: [17] <author> B. Bruegge, T. Gottschalk, B. Luo, </author> <title> A framework for dynamic program analyzers, </title> <publisher> OOPSLA'93, pp.65-82. </publisher>
Reference-contexts: exist for a broad range of application domains such as ET++, an editor toolkit [77] which has recently been used in MET++ which is a framework for multimedia applications; RTL framework [43] for code optimization in compilers; Choices for object-oriented operating systems [19]; BEE++ for analyzing and monitoring distributed programs <ref> [17] </ref>; and others for network management and telecommunications [8], and financial engineering [10].
Reference: [18] <author> David Budgen, </author> <title> Software Design, </title> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Systematic reuse of existing software components to construct new systems has been successfully practiced by organizations since at least 1979 [50, 51]. Software design is a difficult creative task learnt from long experience <ref> [18] </ref>. Reusable object-oriented design aims to describe and classify designs and design fragments so that designers may learn from other peoples' experience. Thus, it provides leverage for the design process. This paper surveys the field, discussing software architectures, application frameworks, design patterns, and the design of class libraries. <p> That is, software design produces a mechanism to perform the task, and that mechanism is later realised in a programming language. There are many methodologies for designing software <ref> [13, 18, 26, 39, 40, 44, 66, 76, 80, 81] </ref>. They chiefly address designing a system from scratch rather than design with reuse. Design is an example of a "wicked problem" [18, pp.19-21]. <p> There are many methodologies for designing software [13, 18, 26, 39, 40, 44, 66, 76, 80, 81]. They chiefly address designing a system from scratch rather than design with reuse. Design is an example of a "wicked problem" <ref> [18, pp.19-21] </ref>. <p> Not all domains lend themselves to reuse. For example, in a domain where difficult real-time constraints are very important, these performance considerations may always demand monolithic applications. Hence there is no possibility of separating out reusable components. 2.3 Design Design <ref> [18] </ref> is the activity to produce a description of how to perform a task in such a way that it satisfies the customers' requirements and also satisfies any constraints imposed by the environment in which the system is to be used. <p> Design methodologies <ref> [18, 26, 44] </ref> typically have three principal components: * a representation of the design using one or more notations; * a process for developing or transforming the representation; and * a set of heuristics maybe guiding the order of steps, or the selection of issues that are to be addressed. <p> The architectural design describes the main subsystems and modules, their responsibilities, the division of control, and the interface or protocol of each module. The detailed design describes the internal mechanism of each module. Design is an example of a "wicked problem" <ref> [18, p.19-21] </ref>. Often, when pursuing the resolution of an issue, the designer discovers other related issues of which the designer was not aware. The problem becomes more complicated as you approach a solution. Thus, the requirements for a system may not be fully understood until the design is complete. <p> The representation or model of the design forms the basis of communication, analysis, and documentation. A model and the views of a model are described using notations. Budgen <ref> [18] </ref> classifies design notations into three categories: diagrammatic notations based on a visual graphical representation; 5 textual notations written in pseudocode or natural language; and mathematical notations based on logic, algebra, set theory, or other mathematical notations. There are generally multiple views of a system. <p> There are generally multiple views of a system. Each view focuses on a single aspect of the system in an attempt to reduce complexity. Object-oriented design methodologies, for example, commonly use the following viewpoints or perspectives <ref> [13, 18, 66] </ref>: structural viewpoints of the static aspects of a system, which may include the organization of subsystems and modules at the architectural level; functional viewpoints which seek to describe what the system does in terms of its tasks; behavioral viewpoints describing the dynamic or causal nature of events and <p> For example, a developer might use nested modules to describe the structural view of a system; hierarchical data flow diagrams to describe functionality; statecharts, which provide nesting, abstraction, and decomposition, to model behavior; and a class inheritance hierarchy to model data <ref> [18] </ref>. Each viewpoint should be derived from a consistent underlying model. Harel [35] is optimistic that developers can exercise greater intellectual control over complexity by using models throughout the development process. Harel is a supporter of multiple models, which have both a visual representation and a solid semantic foundation.
Reference: [19] <author> Roy H. Campbell, Nayeem Islam, David Raila, Peter Madany, </author> <title> Designing and implementing Choices: An object-oriented system in C++, </title> <journal> Communications ACM 36, </journal> <month> 9 (September </month> <year> 1993) </year> <month> 117-126. </month>
Reference-contexts: Frameworks now exist for a broad range of application domains such as ET++, an editor toolkit [77] which has recently been used in MET++ which is a framework for multimedia applications; RTL framework [43] for code optimization in compilers; Choices for object-oriented operating systems <ref> [19] </ref>; BEE++ for analyzing and monitoring distributed programs [17]; and others for network management and telecommunications [8], and financial engineering [10].
Reference: [20] <author> Yoonsik Cheon and Gary Leavens, </author> <title> A quick overview of Larch/C++, </title> <type> Technical Report 93-18, </type> <institution> Dept of Computer Science, Iowa State University, </institution> <month> June </month> <year> 1993, </year> <pages> 34 pages. </pages>
Reference-contexts: Traditional techniques for modules, such as the Larch family of interface languages [34], can be used for describing class interfaces and extended to include the obligations on subclasses <ref> [20] </ref>. The Eiffel language [57] supports design-by-contract through the declaration of assertions, preconditions, and postconditions. Contracts [36, 37] are a high-level (abstract) construct for explicitly specifying behavioral composition, the obligations on participating objects, and interactions among groups of objects. <p> As a consequence there is only a small body of work on how to formally specify design artifacts <ref> [1, 20, 23, 24, 36, 37, 59] </ref>. There is scope for further work in this area. * Experimental validation of claims that certain documentation or specification styles do improve understanding in practice is required. All aspects of research into software development need a firm experimental foundation.
Reference: [21] <author> P. Coad, </author> <title> Patterns (Workshop), OOPSLA'92, </title> <type> OOPS Messenger 4, </type> <month> 2 (October </month> <year> 1993) </year> <month> 93-96. </month>
Reference-contexts: The implementation of the system can then be accomplished by reusing the corresponding components. The language P++ [69] supports the GenVoca approach. 14 5 Design Patterns A pattern is a solution to a problem in a context <ref> [21, p.93] </ref>. A pattern is an abstract model of the problem and its solution. <p> A Multicurrency Library, as an example, is described to illustrate how patterns can be used as "a way for abstractors to communicate their intent.". The first step to develop a pattern is a process of discovery <ref> [21, p.94] </ref>. "Beyond its elements, each building [or town] is defined by certain patterns of relationships among the elements.... These relationships are not extra, but necessary to the elements.... <p> The first step to develop a pattern is a process of discovery [21, p.94]. "Beyond its elements, each building [or town] is defined by certain patterns of relationships among the elements.... These relationships are not extra, but necessary to the elements.... The elements themselves are patterns of relationships." <ref> [2, 21] </ref> "And finally, the things which seem like elements dissolve, and leave a fabric of relationships behind, 16 Design Pattern Name and Classification The name should convey the pattern's essence succinctly. A good name is vital, as it will become part of the design vocabulary. <p> Related Patterns What design patterns have closely related intent? What are the important differences? With which other patterns should this one be used? 17 which is the stuff that actually repeats itself, and gives the structure to a building or a town." <ref> [2, 21] </ref> To find a pattern among some low-level elements, such as classes and objects, means to find the relationships among them in a context. A pattern results from the experience of being an elaborator several times.
Reference: [22] <author> J. Craig Cleaveland, </author> <title> Building application generators, </title> <note> IEEE Software 5 (July 1988) 25-33. </note>
Reference-contexts: The role of a component within the framework may also form part of the domain taxonomy and be used in classification and retrieval. For mature architectures and product families, one can build an application generator <ref> [22] </ref>. This is reuse by generation, where the components or system are generated automatically from a description of the desired solution. The description of the solution may use a script language, such as a fourth-generation language (4GL) for relational databases, or a visual metaphor as in graphical user interface builders. <p> These sub-contracts can simply be included in a large contract. The invariant clauses of a contract with sub-contracts are formed from the union of the corresponding statements from the sub-contracts. 4.3 Application Generators For mature architectures and product families, one can build an application generator <ref> [22] </ref>. This is reuse by generation, where the components or system are generated automatically from a description of the desired solution.
Reference: [23] <author> M. Cline and D. Lea, </author> <title> The behavior of C++ classes, </title> <booktitle> Proc. of the Symposium on Object-oriented Programming Emphasizing Practical Applications, </booktitle> <address> Marist College, </address> <year> 1990. </year>
Reference-contexts: As a consequence there is only a small body of work on how to formally specify design artifacts <ref> [1, 20, 23, 24, 36, 37, 59] </ref>. There is scope for further work in this area. * Experimental validation of claims that certain documentation or specification styles do improve understanding in practice is required. All aspects of research into software development need a firm experimental foundation.
Reference: [24] <author> W.R. Cook, </author> <title> Interfaces and specifications for the Smalltalk-80 collection classes, </title> <journal> OOPSLA'92, ACM SIGPLAN Notices 27, </journal> <month> 10 (October </month> <year> 1992) </year> <month> 1-15. </month>
Reference-contexts: As a consequence there is only a small body of work on how to formally specify design artifacts <ref> [1, 20, 23, 24, 36, 37, 59] </ref>. There is scope for further work in this area. * Experimental validation of claims that certain documentation or specification styles do improve understanding in practice is required. All aspects of research into software development need a firm experimental foundation.
Reference: [25] <author> L. Peter Deutsch, </author> <booktitle> Reusability in the Smalltalk-80 programming system, </booktitle> <pages> (pp. 72-76, </pages> <booktitle> ITT Proceedings of the Workshop on Reusability in Programming 1983) in Tutorial: Software Reusability, </booktitle> <editor> Peter Freeman (ed.), </editor> <publisher> IEEE Computer Society Press, </publisher> <year> 1987, </year> <month> pp.91-95. </month>
Reference-contexts: The framework consists of the abstract classes, the operations they implement, and the expectations placed on the concrete subclasses" <ref> [25, p.92] </ref> "A framework is an abstract design for a particular kind of application, and usually consists of a number of classes.
Reference: [26] <author> R.G. Fichman and C.F. Kemerer, </author> <title> Object-oriented and conventional analysis and design methodologies, </title> <booktitle> IEEE Computer 25, </booktitle> <month> 20 </month> <year> (1992) </year> <month> 22-39. </month>
Reference-contexts: That is, software design produces a mechanism to perform the task, and that mechanism is later realised in a programming language. There are many methodologies for designing software <ref> [13, 18, 26, 39, 40, 44, 66, 76, 80, 81] </ref>. They chiefly address designing a system from scratch rather than design with reuse. Design is an example of a "wicked problem" [18, pp.19-21]. <p> Design methodologies <ref> [18, 26, 44] </ref> typically have three principal components: * a representation of the design using one or more notations; * a process for developing or transforming the representation; and * a set of heuristics maybe guiding the order of steps, or the selection of issues that are to be addressed.
Reference: [27] <author> W.B. Frakes and S. Isoda, </author> <title> Success factors of systematic reuse, </title> <note> IEEE Software 11 (September 1994) 15-19. </note>
Reference-contexts: Hence, lowering the effort and costs of maintenance and understanding are the primary means to increased productivity. Software reuse <ref> [9, 27, 67, 64] </ref> amortizes the cost of developing a component across many projects and supports better quality of products through more effort in inspections and testing. <p> is familiar with the basics of the object-oriented paradigm [45] and software engineering [32]. 2.1 Reuse Reuse applies not only to source-code fragments, but to all the intermediate products generated during software development, including requirements, documents, system specifications, and design: indeed any information that the developer needs to create software <ref> [9, 27, 67, 64] </ref>. The reuse of domain-independent software components for an organization usually involves features common to all application systems. These include common data structures, graphical user interfaces, interfaces to databases, and networks. <p> Reuse within an organization has been profitable at each of the three scopes. Reuse is most successful when it is systematic and focuses on a narrow, well-understood application domain, or on a product family <ref> [27, 33] </ref>. 2.2 Domain Analysis Reuse which is specific to an application domain relies on an analysis of the domain to discover the common aspects of application systems for this domain, and to also discover the range of variability found in the domain.
Reference: [28] <author> Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, </author> <title> Design patterns: Abstraction and reuse of object-oriented design, </title> <editor> ECOOP'93, O.M. Nierstrasz (ed.), </editor> <booktitle> Lecture Notes in Computer Science 707, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993, </year> <pages> 406-431. </pages>
Reference-contexts: The pattern mechanism also describes quality, impact and alternatives. "Design patterns identify, name, and abstract common themes in object-oriented design. They preserve design information by capturing the intent behind a design. They identify classes, instances, their roles, collaborations, and the distribution of responsibilities." <ref> [28, p.407] </ref> "Design patterns are descriptions of communicating objects and classes that are customized to solve a general design problem in a particular context" [29, p.3]. Design patterns capture design experience at the micro-architecture level, by specifying the relationship between classes and objects involved in a particular design problem.
Reference: [29] <author> Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software, </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: They preserve design information by capturing the intent behind a design. They identify classes, instances, their roles, collaborations, and the distribution of responsibilities." [28, p.407] "Design patterns are descriptions of communicating objects and classes that are customized to solve a general design problem in a particular context" <ref> [29, p.3] </ref>. Design patterns capture design experience at the micro-architecture level, by specifying the relationship between classes and objects involved in a particular design problem. By documenting, cataloging and classifying this experience, design patterns allow it to be reused. <p> Since design patterns only record proven resuable design techniques, they offer improved reusability and reliability for developers of new systems. Furthermore, design patterns can improve the documentation and maintenance of existing systems through the reuse of the explicit specification of class and object interactions and their underlying intent <ref> [29] </ref>. So design patterns constitute a reusable base of experience for building reusable software. Design patterns tend to be independent of the application domain since they are smaller and less specialized than frameworks and architectures. <p> Typically this information is provided in a template, though some aspects of Contracts [36] for documenting frameworks actually document patterns: the connection is elaborated in work of Lajoie [47, 48]. The "standard" way to document a design pattern is the template <ref> [29, p.6] </ref> shown in Figure 3. A template provides a consistent format for documentation which makes design patterns easier to learn, compare and use. Design patterns vary in their granularity and level of abstraction, as well as in what they actually do. <p> A template provides a consistent format for documentation which makes design patterns easier to learn, compare and use. Design patterns vary in their granularity and level of abstraction, as well as in what they actually do. Design patterns are classified by two criteria <ref> [29, Table 1.1, p.10] </ref>: purpose which can be creational, structural, or behavioral; and scope which can be class, object or compound. <p> Generally these are issues of providing flexibility so that some aspect of the design can change easily. Knowing what varies, one can access related design patterns <ref> [29, Table 1.2, p.30] </ref>. It is then a matter of understanding the abstraction of the design pattern and matching components of the actual design to the abstract participants of the pattern. <p> Beck and Johnson [7] illustrate the use of design patterns in developing the design for HotDraw, a framework for drawing editors. This is actual a re-documentation of an existing design [41], but it very clearly shows the nature of issue-based design. In <ref> [29, pp.33-77] </ref>, a case study is presented in the design of a "What-You-See-Is-What-You-Get" document editor called Lexi. <p> The spiral approach of patterns [41] tailors the timing and volume of information that a reuser of a framework is presented with. The documentation templates for design patterns <ref> [29] </ref> ensures that each item of necessary information is provided, and that examples of use are also included. Documentation of architectures and class libraries is still in need of good styles and standards. * Formal specification and description of design artifacts claim to provide improved precision, conciseness, and reasoning.
Reference: [30] <author> D. Garlan, R. Allen, J. Ockerbloom, </author> <title> Exploiting style in architectural design environments, </title> <booktitle> Proceedings of SIGSOFT'94: Foundations of Software Engineering, ACM Software Engineering Notes 19, </booktitle> <month> 5 (December </month> <year> 1994) </year> <month> 175-188. </month>
Reference-contexts: This may help designers to appreciate the breadth of choices and trade-offs, and may guide the discovery or invention of new artifacts. It may also assist the development of design notations and languages, which could be incorporated in development environments specific to individual architectural styles <ref> [30] </ref>. The book on OMT [66] also contains very useful sections describing architectures and their use in system design. <p> Another approach to utilising architectural styles is to encode a description of the components and constraints of an architecture into an software development environment. Thus the environment forces the designer to conform to the specified style. Garlan et al <ref> [1, 30] </ref> describe an architecture in terms of its components, connectors, configurations, ports, and roles.
Reference: [31] <author> David Garlan and Mary Shaw. </author> <title> An Introduction to Software Architecture. </title> <booktitle> Advances in Software Engineering and Knowledge Engineering, </booktitle> <volume> Volume 1, </volume> <publisher> World Scientific Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: This is the software architecture level of design." <ref> [31] </ref> One important aspect of this area is compiling a catalogue of existing software architectures. The primary reference is the work of Mary Shaw and her colleagues [31]. Their list of architectural styles follows. * Pipe-and-Filters architectures, like that supported by the Unix shell, connect filters in a linear fashion. <p> This is the software architecture level of design." <ref> [31] </ref> One important aspect of this area is compiling a catalogue of existing software architectures. The primary reference is the work of Mary Shaw and her colleagues [31]. Their list of architectural styles follows. * Pipe-and-Filters architectures, like that supported by the Unix shell, connect filters in a linear fashion.
Reference: [32] <author> C. Ghezzi, M. Jazayeri, and D. Mandrioli, </author> <title> Fundamentals of Software Engineering, </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: no way to converge to a good design, one postulates a tentative design and by analysing its merits and deficiencies may refine it to a complete working design. 1 Parnas' writings [60, 61, 62] have lead to the consensus that "design for change" is an overarching principle for software design <ref> [32, p.65] </ref>, and that information hiding is an essential step to achieving design for change. The object-oriented paradigm stresses information hiding through the use of private state variables for objects and loose coupling through message passing [45], so it is well-suited to design for change. <p> In particular, we briefly provide background on reuse, domain analysis, and design. We assume the reader is familiar with the basics of the object-oriented paradigm [45] and software engineering <ref> [32] </ref>. 2.1 Reuse Reuse applies not only to source-code fragments, but to all the intermediate products generated during software development, including requirements, documents, system specifications, and design: indeed any information that the developer needs to create software [9, 27, 67, 64]. <p> Beck and Johnson [7] use this approach to describe an architecture by the issues encountered and the design patterns chosen to address each issue. Parnas' writings [60, 61, 62] have lead to the consensus that "design for change" is an overarching principle for software design <ref> [32, p.65] </ref>, and that information hiding is an essential step to achieving design for change. The object-oriented paradigm stresses information hiding through the use of private state variables for objects and loose coupling through message passing [45], so it is well-suited to design for change.
Reference: [33] <author> M.L. Griss, </author> <title> Software reuse: From library to factory, </title> <journal> IBM Systems Journal 32, </journal> <month> 4 </month> <year> (1993) </year> <month> 548-566. </month>
Reference-contexts: Every designer can benefit from a knowledge of software architectures and design patterns, and from familiarity with class libraries for domain-independent components such as data structures and user interfaces. However, more systematic reuse of domain-dependent design artifacts brings more benefits. Systematic reuse <ref> [33] </ref> requires a change in the whole software process, from requirements analysis to maintenance, and impacts the whole organization and the way it does business. Costing, funding of projects, and terms of contracts with customers and subcontractors are all impacted. <p> Reuse within an organization has been profitable at each of the three scopes. Reuse is most successful when it is systematic and focuses on a narrow, well-understood application domain, or on a product family <ref> [27, 33] </ref>. 2.2 Domain Analysis Reuse which is specific to an application domain relies on an analysis of the domain to discover the common aspects of application systems for this domain, and to also discover the range of variability found in the domain.
Reference: [34] <author> John V. Guttag and Jim J. Horning, </author> <title> with S.J. Garland, </title> <editor> K.D. Jones, A. Modet, and J.M. </editor> <title> Wing, Larch: Languages and Tools for Formal Specification, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: Traditional techniques for modules, such as the Larch family of interface languages <ref> [34] </ref>, can be used for describing class interfaces and extended to include the obligations on subclasses [20]. The Eiffel language [57] supports design-by-contract through the declaration of assertions, preconditions, and postconditions.
Reference: [35] <author> David Harel, </author> <title> Biting the silver bullet: Toward a brighter future for system development, </title> <booktitle> IEEE Computer 25, </booktitle> <month> 1 (January </month> <year> 1992) </year> <month> 8-20. </month>
Reference-contexts: Each viewpoint should be derived from a consistent underlying model. Harel <ref> [35] </ref> is optimistic that developers can exercise greater intellectual control over complexity by using models throughout the development process. Harel is a supporter of multiple models, which have both a visual representation and a solid semantic foundation.
Reference: [36] <author> R. Helm, I.M. Holland, and D. Gangopadhyay, </author> <title> Contracts: specifying behavioral compositions in object-oriented systems, </title> <journal> ACM SIGPLAN Notices 25 (1990) 169-180. </journal>
Reference-contexts: this in C++) Rule 13: Reduce implicit parameter passing The components of design patterns (described in the next section) also provide a goal or target for the re-structuring of classes, and may assist in determining some roles of the abstractions identified. 4.2 Describing Frameworks Only a small amount of work <ref> [36, 37, 41] </ref> has been done on documenting, specifying, and reasoning about frameworks. The frameworks under consideration are chosen from toolkits for user interfaces and drawing programs. Only the Contracts paper [36] considers verifying correctness, but the authors offer no evidence of actual reuse which has benefited from their contracts. <p> The frameworks under consideration are chosen from toolkits for user interfaces and drawing programs. Only the Contracts paper <ref> [36] </ref> considers verifying correctness, but the authors offer no evidence of actual reuse which has benefited from their contracts. On the other hand, patterns [41] have been an important aspect of much actual reuse. <p> Traditional techniques for modules, such as the Larch family of interface languages [34], can be used for describing class interfaces and extended to include the obligations on subclasses [20]. The Eiffel language [57] supports design-by-contract through the declaration of assertions, preconditions, and postconditions. Contracts <ref> [36, 37] </ref> are a high-level (abstract) construct for explicitly specifying behavioral composition, the obligations on participating objects, and interactions among groups of objects. <p> Typically this information is provided in a template, though some aspects of Contracts <ref> [36] </ref> for documenting frameworks actually document patterns: the connection is elaborated in work of Lajoie [47, 48]. The "standard" way to document a design pattern is the template [29, p.6] shown in Figure 3. <p> As a consequence there is only a small body of work on how to formally specify design artifacts <ref> [1, 20, 23, 24, 36, 37, 59] </ref>. There is scope for further work in this area. * Experimental validation of claims that certain documentation or specification styles do improve understanding in practice is required. All aspects of research into software development need a firm experimental foundation.
Reference: [37] <author> Ian M. Holland, </author> <title> Specifying reusable components with contracts, </title> <booktitle> ECOOP'92, Lecture Notes in Computer Science 615, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992, </year> <month> pp.287-308. </month>
Reference-contexts: this in C++) Rule 13: Reduce implicit parameter passing The components of design patterns (described in the next section) also provide a goal or target for the re-structuring of classes, and may assist in determining some roles of the abstractions identified. 4.2 Describing Frameworks Only a small amount of work <ref> [36, 37, 41] </ref> has been done on documenting, specifying, and reasoning about frameworks. The frameworks under consideration are chosen from toolkits for user interfaces and drawing programs. Only the Contracts paper [36] considers verifying correctness, but the authors offer no evidence of actual reuse which has benefited from their contracts. <p> Traditional techniques for modules, such as the Larch family of interface languages [34], can be used for describing class interfaces and extended to include the obligations on subclasses [20]. The Eiffel language [57] supports design-by-contract through the declaration of assertions, preconditions, and postconditions. Contracts <ref> [36, 37] </ref> are a high-level (abstract) construct for explicitly specifying behavioral composition, the obligations on participating objects, and interactions among groups of objects. <p> As a consequence there is only a small body of work on how to formally specify design artifacts <ref> [1, 20, 23, 24, 36, 37, 59] </ref>. There is scope for further work in this area. * Experimental validation of claims that certain documentation or specification styles do improve understanding in practice is required. All aspects of research into software development need a firm experimental foundation.
Reference: [38] <author> Watts Humphrey, </author> <title> Managing the Software Process, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Successful introduction of reuse requires an organization's software development process to be defined, that is, level 3 of the Capability Maturity Model scale <ref> [38] </ref>. In such cases, the conclusions from industrial reuse efforts [16, 50, 71] are typified by Hewlett-Packard's experience [53] of a 2-4 times return-on-investment from reuse. This is due to improved quality (up to 51% reduction in defects), improved productivity (up to 57% increase), and a 42% reduction in time-to-market.
Reference: [39] <author> Michael A. Jackson, </author> <title> Principles of Program Design, </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: That is, software design produces a mechanism to perform the task, and that mechanism is later realised in a programming language. There are many methodologies for designing software <ref> [13, 18, 26, 39, 40, 44, 66, 76, 80, 81] </ref>. They chiefly address designing a system from scratch rather than design with reuse. Design is an example of a "wicked problem" [18, pp.19-21].
Reference: [40] <author> Michael A. Jackson, </author> <title> System Development, </title> <publisher> Prentice-Hall, </publisher> <year> 1983. </year> <month> 23 </month>
Reference-contexts: That is, software design produces a mechanism to perform the task, and that mechanism is later realised in a programming language. There are many methodologies for designing software <ref> [13, 18, 26, 39, 40, 44, 66, 76, 80, 81] </ref>. They chiefly address designing a system from scratch rather than design with reuse. Design is an example of a "wicked problem" [18, pp.19-21].
Reference: [41] <author> R.E. Johnson, </author> <title> Documenting frameworks using patterns, </title> <journal> ACM SIGPLAN Notices 27 (1992) 63-76. </journal>
Reference-contexts: Application frameworks and class libraries are concrete; software architectures are abstract; design patterns are abstract, but they are often accompanied by examples which realise the design pattern in a specific application. We should be careful to distinguish design patterns, which are micro-architectures, from patterns <ref> [41] </ref>, which document how to reuse or apply a design. A discussion of the different uses of the word "pattern" is provided in [75]. <p> this in C++) Rule 13: Reduce implicit parameter passing The components of design patterns (described in the next section) also provide a goal or target for the re-structuring of classes, and may assist in determining some roles of the abstractions identified. 4.2 Describing Frameworks Only a small amount of work <ref> [36, 37, 41] </ref> has been done on documenting, specifying, and reasoning about frameworks. The frameworks under consideration are chosen from toolkits for user interfaces and drawing programs. Only the Contracts paper [36] considers verifying correctness, but the authors offer no evidence of actual reuse which has benefited from their contracts. <p> The frameworks under consideration are chosen from toolkits for user interfaces and drawing programs. Only the Contracts paper [36] considers verifying correctness, but the authors offer no evidence of actual reuse which has benefited from their contracts. On the other hand, patterns <ref> [41] </ref> have been an important aspect of much actual reuse. There the emphasis is on documentation rather than specification, and certainly there is no concern for verification of correctness. <p> It discusses which classes to subclass, and which methods to override, and whether combinations of classes and methods need to be specialized in unison to maintain a protocol of collaboration amongst the classes. It is prescriptive. Johnson <ref> [41] </ref> introduced an informal pattern language that can be used for documenting a framework in a natural language. <p> Beck and Johnson [7] illustrate the use of design patterns in developing the design for HotDraw, a framework for drawing editors. This is actual a re-documentation of an existing design <ref> [41] </ref>, but it very clearly shows the nature of issue-based design. In [29, pp.33-77], a case study is presented in the design of a "What-You-See-Is-What-You-Get" document editor called Lexi. <p> The spiral approach of patterns <ref> [41] </ref> tailors the timing and volume of information that a reuser of a framework is presented with. The documentation templates for design patterns [29] ensures that each item of necessary information is provided, and that examples of use are also included.
Reference: [42] <author> R.E. Johnson and B. Foote, </author> <title> Designing reusable classes, </title> <note> Journal of Object-Oriented Programming 1 (1988) 22-35. </note>
Reference-contexts: These classes can be taken from a class library, or can be application-specific." <ref> [42, p.25] </ref> A framework is usually designed by experts in a particular domain and it is used by non-experts. It allows the user to reuse abstract designs, and pre-fabricated components in order to develop a system in the domain. A user may also customize existing components by subclassing. <p> By addressing the issues raised, the framework evolves, gaining flexibility, coverage of domain concepts, and clarity of the concepts and the dimensions along which they vary. The major steps in developing an application framework can be summarized as follows <ref> [42, 72] </ref>: 1. Identify and analyze the application domain and identify the framework. If the application domain is large, it should be decomposed into a set of possible frameworks that can be used to build a solution. Analyze existing software solutions to identify their commonalities and the differences. 2. <p> When analyzing existing applications to determine reusable components and abstractions, one might re-structure the classes in order to separate what is common across applications from what is unique to one application. Johnson and Foote <ref> [42] </ref> provide a set of rules to this end: designing reusable classes. <p> the solution may use a script language, such as a fourth-generation language (4GL) for relational databases, or a visual metaphor as in graphical user interface builders. "toolkit is a collection of high level tools that allow a user to interact with an application framework to configure and construct new applications." <ref> [42, p.26] </ref> a compiler generator. 13 4.4 Other Information Section 3.2 on software architectures is also relevant to application frameworks. Batory and O'Malley [5] introduce tthe GenVoca approach to designing and implementing hierarchical software systems with reuse based on the object-oriented paradigm. <p> A pattern is problem-oriented, not solution-oriented, so the developer is looking for the issues or tensions that the pattern resolves. 18 6 Class Libraries There have been many class libraries developed, and their design has been extensively documented in the literature <ref> [42, 46, 56, 58, 70] </ref>, so this section will be brief. Object-oriented class libraries embody * the design of interfaces, * the design of a class hierarchy, and * the design of policies or conventions, such as those on reporting errors in calls to library classes. <p> The most effective libraries are domain-specific and often complement an application framework by providing a choice of concrete classes to instantiate the abstract classes in the framework <ref> [42, p.25] </ref>. <p> The rules of Johnson and Foote <ref> [42] </ref> provide some guidance as to the evolution of a reusable class for a library, and Meyer [58] illustrates clarity of concepts, the precise style of Eiffel interface contracts, and just how few arguments the methods in a reusable class should have.
Reference: [43] <author> R.E. Johnson, C. McConnell, J.M. </author> <title> Lake, The RTL system: A framework for code optimization, Code Generation | Concepts, Tools, techniques, </title> <editor> R. Giegerich and S.L. Graham (eds), </editor> <publisher> Springer-Verlag, </publisher> <address> London, </address> <year> 1991, </year> <month> pp.255-274. </month>
Reference-contexts: Frameworks now exist for a broad range of application domains such as ET++, an editor toolkit [77] which has recently been used in MET++ which is a framework for multimedia applications; RTL framework <ref> [43] </ref> for code optimization in compilers; Choices for object-oriented operating systems [19]; BEE++ for analyzing and monitoring distributed programs [17]; and others for network management and telecommunications [8], and financial engineering [10].
Reference: [44] <author> C.B. Jones, </author> <title> Systematic Software Development using VDM, </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: That is, software design produces a mechanism to perform the task, and that mechanism is later realised in a programming language. There are many methodologies for designing software <ref> [13, 18, 26, 39, 40, 44, 66, 76, 80, 81] </ref>. They chiefly address designing a system from scratch rather than design with reuse. Design is an example of a "wicked problem" [18, pp.19-21]. <p> Design methodologies <ref> [18, 26, 44] </ref> typically have three principal components: * a representation of the design using one or more notations; * a process for developing or transforming the representation; and * a set of heuristics maybe guiding the order of steps, or the selection of issues that are to be addressed.
Reference: [45] <author> Tim Korson and John D. McGregor, </author> <title> Understanding object-oriented: A unifying paradigm, </title> <journal> Communications of the ACM 33, </journal> <month> 9 (September </month> <year> 1990) </year> <month> 40-60. </month>
Reference-contexts: The object-oriented paradigm stresses information hiding through the use of private state variables for objects and loose coupling through message passing <ref> [45] </ref>, so it is well-suited to design for change. Meyer [55] makes the argument that object-oriented design is better for reuse than functional design. <p> In particular, we briefly provide background on reuse, domain analysis, and design. We assume the reader is familiar with the basics of the object-oriented paradigm <ref> [45] </ref> and software engineering [32]. 2.1 Reuse Reuse applies not only to source-code fragments, but to all the intermediate products generated during software development, including requirements, documents, system specifications, and design: indeed any information that the developer needs to create software [9, 27, 67, 64]. <p> The object-oriented paradigm stresses information hiding through the use of private state variables for objects and loose coupling through message passing <ref> [45] </ref>, so it is well-suited to design for change. The representation or model of the design forms the basis of communication, analysis, and documentation. A model and the views of a model are described using notations.
Reference: [46] <author> Tim Korson and John D. McGregor, </author> <title> Technical criteria for the specification and evaluation of object-oriented libraries, </title> <journal> Software Engineering Journal (March 1992) 85-94. </journal>
Reference-contexts: A pattern is problem-oriented, not solution-oriented, so the developer is looking for the issues or tensions that the pattern resolves. 18 6 Class Libraries There have been many class libraries developed, and their design has been extensively documented in the literature <ref> [42, 46, 56, 58, 70] </ref>, so this section will be brief. Object-oriented class libraries embody * the design of interfaces, * the design of a class hierarchy, and * the design of policies or conventions, such as those on reporting errors in calls to library classes. <p> The most effective libraries are domain-specific and often complement an application framework by providing a choice of concrete classes to instantiate the abstract classes in the framework [42, p.25]. Korson and McGregor <ref> [46] </ref> list the following necessary attributes of a reusable object-oriented class library: complete general model for each concept covered by the library; consistent definitions and naming throughout the library; easy-to-learn because of the organization of the documentation, design, and implementation; easy-to-use because the necessary classes are easy to find, understand, and
Reference: [47] <author> Richard Lajoie, </author> <title> Using, Reusing and Describing Object-Oriented Frameworks, </title> <type> Master Thesis, </type> <institution> McGill University, Montreal, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Typically this information is provided in a template, though some aspects of Contracts [36] for documenting frameworks actually document patterns: the connection is elaborated in work of Lajoie <ref> [47, 48] </ref>. The "standard" way to document a design pattern is the template [29, p.6] shown in Figure 3. A template provides a consistent format for documentation which makes design patterns easier to learn, compare and use.
Reference: [48] <author> Richard Lajoie and Rudolf K. Keller, </author> <title> Design and reuse in object-oriented frameworks: Patterns, contracts, and motifs in concert, </title> <booktitle> Colloquium on Object-Orientation in Databases and Software Engineering, 62nd Congress of ACFAS, </booktitle> <address> Montreal, </address> <month> May 16-17, </month> <year> 1994. </year>
Reference-contexts: Typically this information is provided in a template, though some aspects of Contracts [36] for documenting frameworks actually document patterns: the connection is elaborated in work of Lajoie <ref> [47, 48] </ref>. The "standard" way to document a design pattern is the template [29, p.6] shown in Figure 3. A template provides a consistent format for documentation which makes design patterns easier to learn, compare and use.
Reference: [49] <author> Simon S. Lam and A. Udaya Shankar, </author> <title> A theory of interfaces and modules I | Composition theorem, </title> <journal> IEEE Trans. Software Eng. </journal> <volume> 20, </volume> <month> 1 ( january </month> <year> 1994) </year> <month> 55-71. </month>
Reference-contexts: Architectural styles can be used to tailor proof techniques or provide a framework for modular proofs. Layered architectures can be reasoned about using modular proofs for each layer and then relying on the composition theorem of Lam and Shankar <ref> [49] </ref> to show that the system as a whole has the desired properties. The equivalence of two architectures may be proven [59] modulo the equivalence of their components, thus providing assurance about a system re-structuring or about a refinement from an abstract architecture to a concrete implementation of that architecture.
Reference: [50] <author> R.G. Lanergan and C.A. Grasso, </author> <title> Software engineering with reusable designs and code, </title> <journal> IEEE Trans. SE, </journal> <volume> SE-10, </volume> <month> 5 (September </month> <year> 1984) </year> <month> 498-501. </month>
Reference-contexts: Reuse applies not only to source-code fragments, but to all the intermediate products generated during software development, including requirements, documents, system specifications, and designs. Systematic reuse of existing software components to construct new systems has been successfully practiced by organizations since at least 1979 <ref> [50, 51] </ref>. Software design is a difficult creative task learnt from long experience [18]. Reusable object-oriented design aims to describe and classify designs and design fragments so that designers may learn from other peoples' experience. Thus, it provides leverage for the design process. <p> Successful introduction of reuse requires an organization's software development process to be defined, that is, level 3 of the Capability Maturity Model scale [38]. In such cases, the conclusions from industrial reuse efforts <ref> [16, 50, 71] </ref> are typified by Hewlett-Packard's experience [53] of a 2-4 times return-on-investment from reuse. This is due to improved quality (up to 51% reduction in defects), improved productivity (up to 57% increase), and a 42% reduction in time-to-market.
Reference: [51] <author> R.G. Lanergan and B.A. Poynton, </author> <title> Reusable code: The application development technique of the future, </title> <booktitle> Proceedings of the IBM SHARE/GUIDE Software Symposium, IBM, </booktitle> <address> Monterey, CA, </address> <month> October </month> <year> 1979, </year> <pages> 127-136. </pages>
Reference-contexts: Reuse applies not only to source-code fragments, but to all the intermediate products generated during software development, including requirements, documents, system specifications, and designs. Systematic reuse of existing software components to construct new systems has been successfully practiced by organizations since at least 1979 <ref> [50, 51] </ref>. Software design is a difficult creative task learnt from long experience [18]. Reusable object-oriented design aims to describe and classify designs and design fragments so that designers may learn from other peoples' experience. Thus, it provides leverage for the design process.
Reference: [52] <author> D. Lea, Christopher Alexander: </author> <title> An introduction for object-oriented designers, </title> <booktitle> Software Engineering Notes 19, </booktitle> <month> 1 (January </month> <year> 1994) </year> <month> 39-46. </month>
Reference-contexts: So the pattern expresses the relationship among the elements in a problem, and describes the context: it lets the designer focus on the abstract level (building block) when thinking about the solution rather than focusing on the low concrete level (bricks) <ref> [2, 52] </ref>. The pattern mechanism also describes quality, impact and alternatives. "Design patterns identify, name, and abstract common themes in object-oriented design. They preserve design information by capturing the intent behind a design. <p> This allows a designer to work at a more abstract level and to reduce system complexity. Each design pattern identifies a design problem, constraints, solution to that problem and other alternatives, meanwhile it encapsulates a well-defined problem/solution <ref> [52, p.42] </ref> as a building block for constructing more complex designs. Design patterns help reduce the required learning time for a library when the library uses the common vocabulary of roles in a design pattern.
Reference: [53] <author> Wayne C. Lim, </author> <title> Effects of reuse on quality, </title> <institution> productivity, and economics, </institution> <note> IEEE Software 11 (Septem-ber 1994) 23-30. </note>
Reference-contexts: Successful introduction of reuse requires an organization's software development process to be defined, that is, level 3 of the Capability Maturity Model scale [38]. In such cases, the conclusions from industrial reuse efforts [16, 50, 71] are typified by Hewlett-Packard's experience <ref> [53] </ref> of a 2-4 times return-on-investment from reuse. This is due to improved quality (up to 51% reduction in defects), improved productivity (up to 57% increase), and a 42% reduction in time-to-market.
Reference: [54] <author> M.A. Linton, J.M. Vlissides, P.R. Calder, </author> <title> Composing user interfaces with Interviews, </title> <booktitle> IEEE Computer 22, </booktitle> <month> 2 (February </month> <year> 1989) </year> <month> 8-22. </month>
Reference-contexts: Once the selected configuration is compiled, a new instance of the application is ready for use. Early examples of application frameworks were for graphical user interfaces (GUI), including MacApp [3], and Interviews <ref> [54] </ref>. There is now an abundance of GUI frameworks that have been used successfully on many platforms ranging from Dos to Unix, such as MacApp for MacIntosh, Owl-Windows for Dos/Windows, and Motif for Unix.
Reference: [55] <author> Bertrand Meyer, </author> <title> Reusability: The case for object-oriented design, </title> <booktitle> IEEE Software 4, </booktitle> <month> 2 (March </month> <year> 1987) </year> <month> 50-64. </month>
Reference-contexts: The object-oriented paradigm stresses information hiding through the use of private state variables for objects and loose coupling through message passing [45], so it is well-suited to design for change. Meyer <ref> [55] </ref> makes the argument that object-oriented design is better for reuse than functional design. He uses small examples to illustrate the argument that by focussing on data rather than process there are more reusable components: the objects are common across applications whereas functionality is not commonly reused.
Reference: [56] <author> Bertrand Meyer, </author> <title> Lessons from the design of the Eiffel libraries, </title> <type> CACM 33, </type> <month> 3 </month> <year> (1991) </year> <month> 68-84. </month>
Reference-contexts: A pattern is problem-oriented, not solution-oriented, so the developer is looking for the issues or tensions that the pattern resolves. 18 6 Class Libraries There have been many class libraries developed, and their design has been extensively documented in the literature <ref> [42, 46, 56, 58, 70] </ref>, so this section will be brief. Object-oriented class libraries embody * the design of interfaces, * the design of a class hierarchy, and * the design of policies or conventions, such as those on reporting errors in calls to library classes.
Reference: [57] <author> Bertrand Meyer, </author> <title> Applying Design by Contract, </title> <journal> IEEE Computer, </journal> <volume> 25(10), </volume> <month> October </month> <year> 1992, </year> <pages> 40-51. </pages>
Reference-contexts: Traditional techniques for modules, such as the Larch family of interface languages [34], can be used for describing class interfaces and extended to include the obligations on subclasses [20]. The Eiffel language <ref> [57] </ref> supports design-by-contract through the declaration of assertions, preconditions, and postconditions. Contracts [36, 37] are a high-level (abstract) construct for explicitly specifying behavioral composition, the obligations on participating objects, and interactions among groups of objects.
Reference: [58] <author> Bertrand Meyer, </author> <title> Reusable Software: The Base Object-Oriented Component Libraries, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1994. </year>
Reference-contexts: A pattern is problem-oriented, not solution-oriented, so the developer is looking for the issues or tensions that the pattern resolves. 18 6 Class Libraries There have been many class libraries developed, and their design has been extensively documented in the literature <ref> [42, 46, 56, 58, 70] </ref>, so this section will be brief. Object-oriented class libraries embody * the design of interfaces, * the design of a class hierarchy, and * the design of policies or conventions, such as those on reporting errors in calls to library classes. <p> The rules of Johnson and Foote [42] provide some guidance as to the evolution of a reusable class for a library, and Meyer <ref> [58] </ref> illustrates clarity of concepts, the precise style of Eiffel interface contracts, and just how few arguments the methods in a reusable class should have.
Reference: [59] <author> Mark Moriconi and Xiaolei Qian, </author> <title> Correctness and composition of software architectures, </title> <booktitle> Proceedings of SIGSOFT'94: Foundations of Software Engineering, ACM Software Engineering Notes 19, </booktitle> <month> 5 (December </month> <year> 1994) </year> <month> 164-174. </month>
Reference-contexts: Layered architectures can be reasoned about using modular proofs for each layer and then relying on the composition theorem of Lam and Shankar [49] to show that the system as a whole has the desired properties. The equivalence of two architectures may be proven <ref> [59] </ref> modulo the equivalence of their components, thus providing assurance about a system re-structuring or about a refinement from an abstract architecture to a concrete implementation of that architecture. Moriconi and Qian [59] illustrate their theory by proving the equivalence between a pipe-and-filter architecture for a compiler and one which uses <p> The equivalence of two architectures may be proven <ref> [59] </ref> modulo the equivalence of their components, thus providing assurance about a system re-structuring or about a refinement from an abstract architecture to a concrete implementation of that architecture. Moriconi and Qian [59] illustrate their theory by proving the equivalence between a pipe-and-filter architecture for a compiler and one which uses an abstract data type for the parse tree. 9 4 Application Frameworks For a given application domain, the process of domain analysis can draw from existing software applications to identify common architectural <p> As a consequence there is only a small body of work on how to formally specify design artifacts <ref> [1, 20, 23, 24, 36, 37, 59] </ref>. There is scope for further work in this area. * Experimental validation of claims that certain documentation or specification styles do improve understanding in practice is required. All aspects of research into software development need a firm experimental foundation.
Reference: [60] <author> D.L. Parnas, </author> <title> On the criteria to be used in decomposing systems into modules, </title> <journal> Communications of the ACM 15, </journal> <volume> 12 (1972) 1053-1058. </volume> <pages> 24 </pages>
Reference-contexts: is no right answer to the problem, just a vague distinction between good and bad designs; and there is no way to converge to a good design, one postulates a tentative design and by analysing its merits and deficiencies may refine it to a complete working design. 1 Parnas' writings <ref> [60, 61, 62] </ref> have lead to the consensus that "design for change" is an overarching principle for software design [32, p.65], and that information hiding is an essential step to achieving design for change. <p> Beck and Johnson [7] use this approach to describe an architecture by the issues encountered and the design patterns chosen to address each issue. Parnas' writings <ref> [60, 61, 62] </ref> have lead to the consensus that "design for change" is an overarching principle for software design [32, p.65], and that information hiding is an essential step to achieving design for change.
Reference: [61] <author> D.L. Parnas, </author> <title> Designing software for ease of extension and contraction, </title> <journal> IEEE Trans. Software Eng. </journal> <volume> SE-5, </volume> <month> 2 </month> <year> (1979) </year> <month> 128-137. </month>
Reference-contexts: is no right answer to the problem, just a vague distinction between good and bad designs; and there is no way to converge to a good design, one postulates a tentative design and by analysing its merits and deficiencies may refine it to a complete working design. 1 Parnas' writings <ref> [60, 61, 62] </ref> have lead to the consensus that "design for change" is an overarching principle for software design [32, p.65], and that information hiding is an essential step to achieving design for change. <p> Beck and Johnson [7] use this approach to describe an architecture by the issues encountered and the design patterns chosen to address each issue. Parnas' writings <ref> [60, 61, 62] </ref> have lead to the consensus that "design for change" is an overarching principle for software design [32, p.65], and that information hiding is an essential step to achieving design for change.
Reference: [62] <author> D.L. </author> <title> Parnas and P.C. Clements, A rational design process: How and why to fake it, </title> <journal> IEEE Trans. Software Eng. </journal> <volume> SE-12, </volume> <month> 2 </month> <year> (1986) </year> <month> 251-257. </month>
Reference-contexts: is no right answer to the problem, just a vague distinction between good and bad designs; and there is no way to converge to a good design, one postulates a tentative design and by analysing its merits and deficiencies may refine it to a complete working design. 1 Parnas' writings <ref> [60, 61, 62] </ref> have lead to the consensus that "design for change" is an overarching principle for software design [32, p.65], and that information hiding is an essential step to achieving design for change. <p> Beck and Johnson [7] use this approach to describe an architecture by the issues encountered and the design patterns chosen to address each issue. Parnas' writings <ref> [60, 61, 62] </ref> have lead to the consensus that "design for change" is an overarching principle for software design [32, p.65], and that information hiding is an essential step to achieving design for change.
Reference: [63] <author> C. Potts and G. Bruns, </author> <title> Recording the reasons for design decisions, </title> <booktitle> Proceedings of the 10th International Conference on Software Engineering, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1988, </year> <pages> pp. 418-427. </pages>
Reference-contexts: The problem becomes more complicated as you approach a solution. Thus, the requirements for a system may not be fully understood until the design is complete. Design processes may be modelled <ref> [63] </ref> as an exploration of issues, the arguments for and against a position on an issue, and the design steps taken because a position has been adopted.
Reference: [64] <author> Jeff Poulin and Will Tracz, WISR'93: </author> <booktitle> 6th annual workshop on software reuse | Summary and workshop group reports, ACM SIGSOFT Software Engineering Notes 19, </booktitle> <month> 1 (January </month> <year> 1994) </year> <month> 55-71. </month>
Reference-contexts: Hence, lowering the effort and costs of maintenance and understanding are the primary means to increased productivity. Software reuse <ref> [9, 27, 67, 64] </ref> amortizes the cost of developing a component across many projects and supports better quality of products through more effort in inspections and testing. <p> is familiar with the basics of the object-oriented paradigm [45] and software engineering [32]. 2.1 Reuse Reuse applies not only to source-code fragments, but to all the intermediate products generated during software development, including requirements, documents, system specifications, and design: indeed any information that the developer needs to create software <ref> [9, 27, 67, 64] </ref>. The reuse of domain-independent software components for an organization usually involves features common to all application systems. These include common data structures, graphical user interfaces, interfaces to databases, and networks.
Reference: [65] <author> R. Prieto-D iaz and J.M. Neighbors, </author> <title> Module interconnection languages, </title> <journal> J. Systems and Software 6, </journal> <month> 4 </month> <year> (1987) </year> <month> 307-334. </month>
Reference-contexts: There is a strong relationship between the study of software architectures and the study of programming at the architectural level that is pursued in megaprogramming [78] and the design of module interconnection languages <ref> [65] </ref>. 3.1 Reusing Software Architectures Rumbaugh et al [66] provide a methodology for applying an architecture that is based on * characterising the kinds of systems to which the architecture is applicable; * presenting important design principles which must be observed when applying the architecture; and * providing a sequence of
Reference: [66] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, W. Lorenson, </author> <title> Object-Oriented Modelling and Design, </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: That is, software design produces a mechanism to perform the task, and that mechanism is later realised in a programming language. There are many methodologies for designing software <ref> [13, 18, 26, 39, 40, 44, 66, 76, 80, 81] </ref>. They chiefly address designing a system from scratch rather than design with reuse. Design is an example of a "wicked problem" [18, pp.19-21]. <p> There are generally multiple views of a system. Each view focuses on a single aspect of the system in an attempt to reduce complexity. Object-oriented design methodologies, for example, commonly use the following viewpoints or perspectives <ref> [13, 18, 66] </ref>: structural viewpoints of the static aspects of a system, which may include the organization of subsystems and modules at the architectural level; functional viewpoints which seek to describe what the system does in terms of its tasks; behavioral viewpoints describing the dynamic or causal nature of events and <p> It may also assist the development of design notations and languages, which could be incorporated in development environments specific to individual architectural styles [30]. The book on OMT <ref> [66] </ref> also contains very useful sections describing architectures and their use in system design. <p> There is a strong relationship between the study of software architectures and the study of programming at the architectural level that is pursued in megaprogramming [78] and the design of module interconnection languages [65]. 3.1 Reusing Software Architectures Rumbaugh et al <ref> [66] </ref> provide a methodology for applying an architecture that is based on * characterising the kinds of systems to which the architecture is applicable; * presenting important design principles which must be observed when applying the architecture; and * providing a sequence of detailed steps to follow when developing a design <p> From such a descripption, their system, Aesop, can generate a development environment that is tailored to the given architectural style. 3.1.1 Example: Interactive Interface Architecture This section summarises the methodological information of Rumbaugh et al <ref> [66, section 9.10.3] </ref> for applying the interactive interface architectural style. Characterisation An interactive system is dominated by the interactions with external agents, such as users, sensors, and IO devices, over which it has no control. <p> Applicability What are the situations in which the design pattern can be applied? What are examples of poor designs that the pattern can address? How can one recognize these situations? Structure A graphical representation of the classes in the pattern using a notation based on the Object Modeling Technique (OMT) <ref> [66] </ref>. The interaction diagrams [13] is applied to illustrate sequences of requests and collaborations between objects. Participants Describe the classes and/or objects participating in the design pattern and their responsibilities. Collaborations Describe how the participants collaborate to carry out their responsibilities.
Reference: [67] <author> Wilhelm Schafer, Ruben Prieto-d iaz, Masao Matsumoto, </author> <title> Software Reusability, </title> <publisher> Ellis Horwood, </publisher> <year> 1993. </year>
Reference-contexts: Hence, lowering the effort and costs of maintenance and understanding are the primary means to increased productivity. Software reuse <ref> [9, 27, 67, 64] </ref> amortizes the cost of developing a component across many projects and supports better quality of products through more effort in inspections and testing. <p> is familiar with the basics of the object-oriented paradigm [45] and software engineering [32]. 2.1 Reuse Reuse applies not only to source-code fragments, but to all the intermediate products generated during software development, including requirements, documents, system specifications, and design: indeed any information that the developer needs to create software <ref> [9, 27, 67, 64] </ref>. The reuse of domain-independent software components for an organization usually involves features common to all application systems. These include common data structures, graphical user interfaces, interfaces to databases, and networks.
Reference: [68] <author> G. Sindre, E.-A. Karlsson, T. Staalhane, </author> <title> A method for software reuse through large component libraries, </title> <booktitle> Proceedings ICCI'93, </booktitle> <editor> Osman Abou-Rabia, Carl K. Chang, Waldemar W. Koczkodaj (editors), </editor> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1993, </year> <pages> pp. 464-468. </pages>
Reference-contexts: The quality factors of a component which affect reusability are the general ones of reliability, testability, and maintainability, and some which are more reuse specific quality factors: flexibility, portability, understandability, and confidence <ref> [68] </ref>. Confidence differs from reliability in that confidence is an estimate of the probability of error in unforeseen contexts, while reliability estimates the probability of error in a fixed context.
Reference: [69] <author> V. Singhal and D. Batory, </author> <title> P++: A language for large-scale reusable software components, </title> <institution> Department of Computer Science, University of Texas at Austin, </institution> <year> 1993. </year>
Reference-contexts: The interface of a component has additional information, such as source and object files. When designing a large system in a particular application domain, realms can be used as reusable design artifacts. The implementation of the system can then be accomplished by reusing the corresponding components. The language P++ <ref> [69] </ref> supports the GenVoca approach. 14 5 Design Patterns A pattern is a solution to a problem in a context [21, p.93]. A pattern is an abstract model of the problem and its solution.
Reference: [70] <author> Bjarne Stroustrup, </author> <title> The C++ Programming Language, </title> <publisher> 2nd edition Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: A pattern is problem-oriented, not solution-oriented, so the developer is looking for the issues or tensions that the pattern resolves. 18 6 Class Libraries There have been many class libraries developed, and their design has been extensively documented in the literature <ref> [42, 46, 56, 58, 70] </ref>, so this section will be brief. Object-oriented class libraries embody * the design of interfaces, * the design of a class hierarchy, and * the design of policies or conventions, such as those on reporting errors in calls to library classes.
Reference: [71] <author> M.E. Swanson and S.K. Curry, </author> <title> Implementing an asset management program at GTE Data Services, </title> <booktitle> Information and Management 16 (1989). </booktitle>
Reference-contexts: Successful introduction of reuse requires an organization's software development process to be defined, that is, level 3 of the Capability Maturity Model scale [38]. In such cases, the conclusions from industrial reuse efforts <ref> [16, 50, 71] </ref> are typified by Hewlett-Packard's experience [53] of a 2-4 times return-on-investment from reuse. This is due to improved quality (up to 51% reduction in defects), improved productivity (up to 57% increase), and a 42% reduction in time-to-market.
Reference: [72] <author> Taligent, Inc., </author> <title> Building object-oriented frameworks, A Taligent White Paper, </title> <year> 1994. </year>
Reference-contexts: By addressing the issues raised, the framework evolves, gaining flexibility, coverage of domain concepts, and clarity of the concepts and the dimensions along which they vary. The major steps in developing an application framework can be summarized as follows <ref> [42, 72] </ref>: 1. Identify and analyze the application domain and identify the framework. If the application domain is large, it should be decomposed into a set of possible frameworks that can be used to build a solution. Analyze existing software solutions to identify their commonalities and the differences. 2.
Reference: [73] <author> W. Tracz, </author> <title> The three cons of software reuse, </title> <booktitle> Proceedings of the Fourth Annual Workshop on Reuse, </booktitle> <address> Syracuse, NY, </address> <year> 1991. </year>
Reference-contexts: Tracz's 3C Model <ref> [73] </ref> of reusable software components indicates that at least the following information must be stored about each component, and used in its classification: concept, the abstraction captured in a component; content, the implementation of that abstraction; and context, the environment in which component is designed to operate.
Reference: [74] <author> W. Tracz, </author> <title> Domain analysis working group report, </title> <booktitle> First International Workshop on Software Reusability, </booktitle> <address> Dortmund, Germany, </address> <month> July 3-5, </month> <year> 1991. </year>
Reference-contexts: Domain analysis is "a process by which information used in developing software systems is identified, captured, and organized with the purpose of making it reusable when creating new systems." <ref> [74] </ref> The domain is analyzed from the user's and customer's perspective (as in normal systems analysis), and also analyzed from the developer's perspective to discover common software components, interfaces, and architectures [4, 74]. <p> developing software systems is identified, captured, and organized with the purpose of making it reusable when creating new systems." [74] The domain is analyzed from the user's and customer's perspective (as in normal systems analysis), and also analyzed from the developer's perspective to discover common software components, interfaces, and architectures <ref> [4, 74] </ref>. The sources of domain knowledge are the technical literature of the domain, requirements documents for current application software, surveys of customer needs, the architecture and components of existing systems, and domain experts.
Reference: [75] <author> Panu Viljamaa, </author> <title> The patterns busines: Impressions from PLoP-94, </title> <journal> ACM Software Eng. </journal> <note> Notes 20, 1 (January 1995) 74-78. </note>
Reference-contexts: We should be careful to distinguish design patterns, which are micro-architectures, from patterns [41], which document how to reuse or apply a design. A discussion of the different uses of the word "pattern" is provided in <ref> [75] </ref>. Every designer can benefit from a knowledge of software architectures and design patterns, and from familiarity with class libraries for domain-independent components such as data structures and user interfaces. However, more systematic reuse of domain-dependent design artifacts brings more benefits. <p> These are early days for design patterns, and much work is being done on ways of documenting and classifying patterns <ref> [75] </ref>. 5.2 Reusing Design Patterns Design patterns support issue-based design by providing a range of solutions for certain issues that commonly arise in object-oriented design. Generally these are issues of providing flexibility so that some aspect of the design can change easily.
Reference: [76] <author> J.D. Warnier, </author> <title> Logical Construction of Programs, </title> <publisher> Van Nostrand, </publisher> <year> 1980. </year>
Reference-contexts: That is, software design produces a mechanism to perform the task, and that mechanism is later realised in a programming language. There are many methodologies for designing software <ref> [13, 18, 26, 39, 40, 44, 66, 76, 80, 81] </ref>. They chiefly address designing a system from scratch rather than design with reuse. Design is an example of a "wicked problem" [18, pp.19-21].
Reference: [77] <author> A. Weinand, E. Gamma, R. Marty, </author> <title> Design and implementation of ET++, a seamless object-oriented application framework, Structured Programming 10, </title> <month> 2 </month> <year> (1989) </year> <month> 63-87. </month>
Reference-contexts: There is now an abundance of GUI frameworks that have been used successfully on many platforms ranging from Dos to Unix, such as MacApp for MacIntosh, Owl-Windows for Dos/Windows, and Motif for Unix. Frameworks now exist for a broad range of application domains such as ET++, an editor toolkit <ref> [77] </ref> which has recently been used in MET++ which is a framework for multimedia applications; RTL framework [43] for code optimization in compilers; Choices for object-oriented operating systems [19]; BEE++ for analyzing and monitoring distributed programs [17]; and others for network management and telecommunications [8], and financial engineering [10].
Reference: [78] <author> G. Wiederhold, P.Wegner, S. Ceri, </author> <title> Towards megaprogramming, </title> <note> CACM 35 (1992) 89-99. </note>
Reference-contexts: There is a strong relationship between the study of software architectures and the study of programming at the architectural level that is pursued in megaprogramming <ref> [78] </ref> and the design of module interconnection languages [65]. 3.1 Reusing Software Architectures Rumbaugh et al [66] provide a methodology for applying an architecture that is based on * characterising the kinds of systems to which the architecture is applicable; * presenting important design principles which must be observed when applying
Reference: [79] <author> Rebecca Wirfs-Brock and Ralph Johnson, </author> <booktitle> Surveying current research in object-oriented design, </booktitle> <volume> CACM 33, </volume> <month> 9 (September </month> <year> 1990) </year> <month> 104-124. </month>
Reference-contexts: A generic architecture is developed for this product family, so that there is a well-defined role for each component. The architecture, and its realization, is variously called a reference architecture, a domain specific software architecture (DSSA), or an application framework <ref> [16, 79] </ref>. The role of a component within the framework may also form part of the domain taxonomy and be used in classification and retrieval. For mature architectures and product families, one can build an application generator [22].
Reference: [80] <author> Niklaus Wirth, </author> <title> Program development by stepwise refinement, </title> <journal> Communications of the ACM 14, </journal> <month> 4 </month> <year> (1971) </year> <month> 221-227. </month>
Reference-contexts: That is, software design produces a mechanism to perform the task, and that mechanism is later realised in a programming language. There are many methodologies for designing software <ref> [13, 18, 26, 39, 40, 44, 66, 76, 80, 81] </ref>. They chiefly address designing a system from scratch rather than design with reuse. Design is an example of a "wicked problem" [18, pp.19-21].
Reference: [81] <author> E. Yourdon and L.L. Constantine, </author> <title> Structured Design, </title> <publisher> Prentice-Hall, </publisher> <year> 1979. </year> <month> 25 </month>
Reference-contexts: That is, software design produces a mechanism to perform the task, and that mechanism is later realised in a programming language. There are many methodologies for designing software <ref> [13, 18, 26, 39, 40, 44, 66, 76, 80, 81] </ref>. They chiefly address designing a system from scratch rather than design with reuse. Design is an example of a "wicked problem" [18, pp.19-21].
References-found: 81

