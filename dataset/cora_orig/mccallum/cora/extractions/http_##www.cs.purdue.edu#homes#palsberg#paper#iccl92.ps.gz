URL: http://www.cs.purdue.edu/homes/palsberg/paper/iccl92.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: palsberg@daimi.aau.dk  
Title: An Automatically Generated and Provably Correct Compiler for a Subset of Ada  
Author: Jens Palsberg 
Note: In Proc. ICCL'92, Fourth IEEE International Conference on Computer Languages, pages 117-126.  
Address: Ny Munkegade, DK-8000 Aarhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Abstract: We describe the automatic generation of a provably correct compiler for a non-trivial subset of Ada. The compiler is generated from an action semantic description; it emits absolute code for an abstract RISC machine language that currently is assembled into code for the SPARC and the HP Precision Architecture. The generated code is an order of magnitude better than what is produced by compilers generated by the classical systems of Mosses, Paulson, and Wand. The use of action semantics makes the processable language specification easy to read and pleasant to work with. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Harald Abelson, Gerald Jay Sussman, and Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: In practice, a session with Cantor looks as follows on the screen: cantor syntax semantics compiler compiler program code code input output The compiler generator cantor is written in Perl [43], and the generated compilers are written in Scheme <ref> [1] </ref>. Examples of a syntax and a semantics are given in appendix B; it is the L A T E X source of the appendix that is processed by 6 cantor.
Reference: [2] <author> Rudolf Berghammer, Herbert Ehler, and Hans Zierer. </author> <title> Towards an algebraic specification of code generation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 11 </volume> <pages> 45-63, </pages> <year> 1988. </year>
Reference-contexts: Work on compiler correctness does not seem to be of much help because it usually focuses on denotational semantics [13, 15, 41, 36, 27], algebraic variations hereof <ref> [3, 16, 42, 2, 18] </ref>, structural operational semantics [6], or natural semantics [4]. We are aware of only one compiler generator that has been proved correct: the one obtained by self-application of the partial evaluator mix, see the paper by Gomard and Jones [7].
Reference: [3] <author> Rod M. Burstall and Peter J. Landin. </author> <title> Programs and their proofs: an algebraic approach. </title> <editor> In B. Meltzer and D. Mitchie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> Vol. 4, </volume> <pages> pages 17-43. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year>
Reference-contexts: Work on compiler correctness does not seem to be of much help because it usually focuses on denotational semantics [13, 15, 41, 36, 27], algebraic variations hereof <ref> [3, 16, 42, 2, 18] </ref>, structural operational semantics [6], or natural semantics [4]. We are aware of only one compiler generator that has been proved correct: the one obtained by self-application of the partial evaluator mix, see the paper by Gomard and Jones [7].
Reference: [4] <author> Joelle Despeyroux. </author> <title> Proof of translation in natural semantics. </title> <booktitle> In LICS'86, First Symposium on Logic in Computer Science, </booktitle> <pages> pages 193-205, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Work on compiler correctness does not seem to be of much help because it usually focuses on denotational semantics [13, 15, 41, 36, 27], algebraic variations hereof [3, 16, 42, 2, 18], structural operational semantics [6], or natural semantics <ref> [4] </ref>. We are aware of only one compiler generator that has been proved correct: the one obtained by self-application of the partial evaluator mix, see the paper by Gomard and Jones [7]. Unfortunately, the generated compilers emit code for the lambda calculus, thus leaving considerable compilation to be done. <p> Our approach to correctness can be summarized as follows: 1. Give a natural semantics to both action notation and the abstract RISC machine language. 2. Make the compiling of action notation simple; and 3. Use a variation of Despeyroux's proof technique <ref> [4] </ref>. All specifications are given using unified algebras, an algebraic specification framework developed by Mosses [23, 21, 22]. This includes the semantics of action notation (13 pages), the semantics of the machine language (6 pages), the compiler (36 pages), and various auxiliary notation (14 pages).
Reference: [5] <author> Jean D. Ichbiah et al. </author> <title> Reference Manual for the Ada Programming Language. </title> <type> US DoD, </type> <month> July </month> <year> 1982. </year>
Reference-contexts: We have designed, implemented, and proved the correctness of a compiler generator, called Cantor, that accepts action semantic descriptions of programming languages. The considered subset of action notation, see appendix A, is powerful enough to allow the specification of a non-trivial subset of Ada <ref> [5] </ref>, called Mini-Ada, see appendix B. The generated compilers emit absolute code for an abstract RISC [40] machine language, which easily can be compiled into code for existing RISC processors. Currently, implementations exist for the SPARC [14] and the HP Precision Architecture [28].
Reference: [6] <author> Anders Gammelgaard and Flemming Nielson. </author> <title> Verification of the level 0 compiling specification. </title> <type> Technical report, </type> <institution> Department of Computer Science, Aarhus University, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Work on compiler correctness does not seem to be of much help because it usually focuses on denotational semantics [13, 15, 41, 36, 27], algebraic variations hereof [3, 16, 42, 2, 18], structural operational semantics <ref> [6] </ref>, or natural semantics [4]. We are aware of only one compiler generator that has been proved correct: the one obtained by self-application of the partial evaluator mix, see the paper by Gomard and Jones [7].
Reference: [7] <author> Carsten K. Gomard and Neil D. Jones. </author> <title> A partial evaluator for the untyped lambda-calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1) </volume> <pages> 21-69, </pages> <year> 1991. </year>
Reference-contexts: We are aware of only one compiler generator that has been proved correct: the one obtained by self-application of the partial evaluator mix, see the paper by Gomard and Jones <ref> [7] </ref>. Unfortunately, the generated compilers emit code for the lambda calculus, thus leaving considerable compilation to be done. It remains to be seen if this approach will lead to the generation of compilers for conventional machine architectures. A summary of the examination is given in figure 2.
Reference: [8] <author> Jeffrey J. Joyce. </author> <title> Totally verified systems: Linking verified software to verified hardware. In Proc. Hardware Specification, Verification and Synthesis: </title> <booktitle> Mathmat-ical Aspects, </booktitle> <pages> pages 177-201, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: This implies that code will not be overwritten, and that data will not be "exe cuted". Furthermore, we do not model delay slots. These idealizations simplify the correctness proof considerably, but they may be removed in future work, using the technique of Joyce <ref> [9, 8] </ref>. though with a little more difficulty. 3.3 Compiling Action Notation The compiler from action notation to Pseudo SPARC machine code proceeds in two passes: 1. Type analysis and calculation of code size; and 2. Code generation. For each pass there is a function defined for every syntactic category. <p> Putting further sophistication into the compiler will add significantly to these page counts. We feel that the size alone of the specifications calls for automatic proof checking. Recent attempts to automatically check a compiler correctness proof are reported by Young [46] and Joyce <ref> [9, 8] </ref>.
Reference: [9] <author> Jeffrey J. Joyce. </author> <title> A verified compiler for a verified microprocessor. </title> <type> Technical report, </type> <institution> University of Cambridge, Computer Laboratory, </institution> <address> England, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: This implies that code will not be overwritten, and that data will not be "exe cuted". Furthermore, we do not model delay slots. These idealizations simplify the correctness proof considerably, but they may be removed in future work, using the technique of Joyce <ref> [9, 8] </ref>. though with a little more difficulty. 3.3 Compiling Action Notation The compiler from action notation to Pseudo SPARC machine code proceeds in two passes: 1. Type analysis and calculation of code size; and 2. Code generation. For each pass there is a function defined for every syntactic category. <p> Putting further sophistication into the compiler will add significantly to these page counts. We feel that the size alone of the specifications calls for automatic proof checking. Recent attempts to automatically check a compiler correctness proof are reported by Young [46] and Joyce <ref> [9, 8] </ref>.
Reference: [10] <author> Richard Kelsey and Paul Hudak. </author> <title> Realistic compilation by program transformation. </title> <booktitle> In Sixteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 281-292, </pages> <year> 1989. </year>
Reference-contexts: A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller [38, 39], the compiler generator of Kelsey and Hudak <ref> [10] </ref>, and the Mess system of Pleban and Lee [33, 12, 35, 11]. These approaches are based on rather ad hoc specification languages, and, like the classical systems, they lack correctness proofs. The CAT system is aimed at generating compilers for Pascal, C, Basic, Fortran, and Cobol.
Reference: [11] <author> Peter Lee. </author> <title> Realistic Compiler Generation. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: This is somewhat far from the goal of generating realistic compilers, but is still an 2 improvement compared to the classical systems of Mosses, Paulson, and Wand where a slow-down of three orders of magnitude has been reported <ref> [11] </ref>. Action semantics was designed to allow accessible and maintainable descriptions of realistic programming languages. Our experiments with Cantor confirm that action semantic descriptions are easy to work with in practice. Future work on Cantor will attempt to improve speed without sacrificing provable correctness. <p> The target programs produced by the classical systems have been reported to run at least three orders of magnitude slower than corresponding target programs produced by handwritten compilers <ref> [11] </ref>. None of these systems have been proved correct. <p> A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller [38, 39], the compiler generator of Kelsey and Hudak [10], and the Mess system of Pleban and Lee <ref> [33, 12, 35, 11] </ref>. These approaches are based on rather ad hoc specification languages, and, like the classical systems, they lack correctness proofs. The CAT system is aimed at generating compilers for Pascal, C, Basic, Fortran, and Cobol.
Reference: [12] <author> Peter Lee and Uwe F. Pleban. </author> <title> A realistic compiler generator based on high-level semantics. </title> <booktitle> In Fourteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 284-295, </pages> <year> 1987. </year>
Reference-contexts: A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller [38, 39], the compiler generator of Kelsey and Hudak [10], and the Mess system of Pleban and Lee <ref> [33, 12, 35, 11] </ref>. These approaches are based on rather ad hoc specification languages, and, like the classical systems, they lack correctness proofs. The CAT system is aimed at generating compilers for Pascal, C, Basic, Fortran, and Cobol.
Reference: [13] <author> John McCarthy and James Painter. </author> <title> Correctness of a compiler for arithmetic expressions. </title> <booktitle> In Proc. Symposium in Applied Mathematics of the American Math-matical Society, </booktitle> <pages> pages 33-41, </pages> <month> April </month> <year> 1966. </year>
Reference-contexts: Work on compiler correctness does not seem to be of much help because it usually focuses on denotational semantics <ref> [13, 15, 41, 36, 27] </ref>, algebraic variations hereof [3, 16, 42, 2, 18], structural operational semantics [6], or natural semantics [4].
Reference: [14] <author> Sun Microsystems. </author> <title> A RISC tutorial. </title> <type> Technical Report 800-1795-10, </type> <institution> revision A, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: The generated compilers emit absolute code for an abstract RISC [40] machine language, which easily can be compiled into code for existing RISC processors. Currently, implementations exist for the SPARC <ref> [14] </ref> and the HP Precision Architecture [28]. The development of Cantor was guided by the following principles: * Correctness is more important than efficiency; and * Specification and proof must be completed before implementation begins.
Reference: [15] <author> Robert E. Milne and Christopher Strachey. </author> <title> A Theory of Programming Language Semantics. </title> <publisher> Chapman and Hall, </publisher> <year> 1976. </year> <month> 28 </month>
Reference-contexts: Work on compiler correctness does not seem to be of much help because it usually focuses on denotational semantics <ref> [13, 15, 41, 36, 27] </ref>, algebraic variations hereof [3, 16, 42, 2, 18], structural operational semantics [6], or natural semantics [4].
Reference: [16] <author> Francis Lockwood Morris. </author> <title> Advice on structuring compilers and proving them correct. </title> <booktitle> In Symposium on Principles of Programming Languages, </booktitle> <pages> pages 144-152, </pages> <year> 1973. </year>
Reference-contexts: Work on compiler correctness does not seem to be of much help because it usually focuses on denotational semantics [13, 15, 41, 36, 27], algebraic variations hereof <ref> [3, 16, 42, 2, 18] </ref>, structural operational semantics [6], or natural semantics [4]. We are aware of only one compiler generator that has been proved correct: the one obtained by self-application of the partial evaluator mix, see the paper by Gomard and Jones [7].
Reference: [17] <author> Peter D. Mosses. </author> <title> SIS|semantics implementation system. </title> <type> Technical Report Daimi MD-30, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1979. </year> <title> Out of print. </title>
Reference-contexts: This approach is usually called semantics-directed compiler generation. The traditional approach to compiler generation is based on denotational semantics [37]. Examples of existing compiler generators based on this idea include Mosses' Semantics Implementation System (SIS) <ref> [17] </ref>, Paulson's Semantics Processor (PSP) [31, 32], and Wand's Semantic Prototyping System (SPS) [44]. Denotational semantics has achieved much popularity as a vehicle for theoretical studies, but it is also recognized to be neither flexible nor readable, see for example the discussions by Mosses [19], and Pleban and Lee [34].
Reference: [18] <author> Peter D. Mosses. </author> <title> A constructive approach to compiler correctness. </title> <booktitle> In Proc. Seventh Colloquium of Automata, Languages, and Programming, </booktitle> <pages> pages 449-469, </pages> <month> July </month> <year> 1980. </year>
Reference-contexts: Work on compiler correctness does not seem to be of much help because it usually focuses on denotational semantics [13, 15, 41, 36, 27], algebraic variations hereof <ref> [3, 16, 42, 2, 18] </ref>, structural operational semantics [6], or natural semantics [4]. We are aware of only one compiler generator that has been proved correct: the one obtained by self-application of the partial evaluator mix, see the paper by Gomard and Jones [7].
Reference: [19] <author> Peter D. Mosses. </author> <booktitle> Abstract semantic algebras! In Proc. IFIP TC2 Working Conference on Formal Description of Programming Concepts II (Garmisch-Partenkirchen, </booktitle> <year> 1982), </year> <pages> pages 45-70. </pages> <publisher> North-Holland, </publisher> <year> 1983. </year>
Reference-contexts: Denotational semantics has achieved much popularity as a vehicle for theoretical studies, but it is also recognized to be neither flexible nor readable, see for example the discussions by Mosses <ref> [19] </ref>, and Pleban and Lee [34]. The target programs produced by the classical systems have been reported to run at least three orders of magnitude slower than corresponding target programs produced by handwritten compilers [11]. None of these systems have been proved correct. <p> Action semantics is a framework for formal semantics of programming languages, developed by Mosses <ref> [19, 20, 21, 24, 25] </ref> and Watt [26, 45]. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in 5 using semantic entities called actions, rather than higher-order functions.
Reference: [20] <author> Peter D. Mosses. </author> <title> A basic abstract semantic algebra. </title> <booktitle> In Proc. Int. Symp. on Semantics of Data Types (Sophia-Antipolis), </booktitle> <pages> pages 87-107. </pages> <publisher> Springer-Verlag (LNCS 173), </publisher> <year> 1984. </year>
Reference-contexts: Action semantics is a framework for formal semantics of programming languages, developed by Mosses <ref> [19, 20, 21, 24, 25] </ref> and Watt [26, 45]. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in 5 using semantic entities called actions, rather than higher-order functions.
Reference: [21] <author> Peter D. Mosses. </author> <title> Unified algebras and action semantics. </title> <booktitle> In Proc. STACS'89, </booktitle> <pages> pages 17-35. </pages> <publisher> Springer-Verlag (LNCS 349), </publisher> <year> 1989. </year>
Reference-contexts: Action semantics is a framework for formal semantics of programming languages, developed by Mosses <ref> [19, 20, 21, 24, 25] </ref> and Watt [26, 45]. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in 5 using semantic entities called actions, rather than higher-order functions. <p> Give a natural semantics to both action notation and the abstract RISC machine language. 2. Make the compiling of action notation simple; and 3. Use a variation of Despeyroux's proof technique [4]. All specifications are given using unified algebras, an algebraic specification framework developed by Mosses <ref> [23, 21, 22] </ref>. This includes the semantics of action notation (13 pages), the semantics of the machine language (6 pages), the compiler (36 pages), and various auxiliary notation (14 pages). The correctness statement, including various lemmas but without proofs, takes 28 pages.
Reference: [22] <author> Peter D. Mosses. </author> <title> Unified algebras and institutions. </title> <booktitle> In LICS'89, Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 304-312, </pages> <year> 1989. </year>
Reference-contexts: Give a natural semantics to both action notation and the abstract RISC machine language. 2. Make the compiling of action notation simple; and 3. Use a variation of Despeyroux's proof technique [4]. All specifications are given using unified algebras, an algebraic specification framework developed by Mosses <ref> [23, 21, 22] </ref>. This includes the semantics of action notation (13 pages), the semantics of the machine language (6 pages), the compiler (36 pages), and various auxiliary notation (14 pages). The correctness statement, including various lemmas but without proofs, takes 28 pages.
Reference: [23] <author> Peter D. Mosses. </author> <title> Unified algebras and modules. </title> <booktitle> In Sixteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 329-343, </pages> <year> 1989. </year>
Reference-contexts: Give a natural semantics to both action notation and the abstract RISC machine language. 2. Make the compiling of action notation simple; and 3. Use a variation of Despeyroux's proof technique [4]. All specifications are given using unified algebras, an algebraic specification framework developed by Mosses <ref> [23, 21, 22] </ref>. This includes the semantics of action notation (13 pages), the semantics of the machine language (6 pages), the compiler (36 pages), and various auxiliary notation (14 pages). The correctness statement, including various lemmas but without proofs, takes 28 pages.
Reference: [24] <author> Peter D. Mosses. </author> <title> An introduction to action semantics. </title> <type> Technical Report DAIMI PB-370, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1991. </year> <booktitle> Lecture Notes for the Marktoberdorf'91 Summer School, to be published in the Proceedings of the Summer School by Springer-Verlag (Series F). </booktitle>
Reference-contexts: Action semantics is a framework for formal semantics of programming languages, developed by Mosses <ref> [19, 20, 21, 24, 25] </ref> and Watt [26, 45]. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in 5 using semantic entities called actions, rather than higher-order functions.
Reference: [25] <author> Peter D. Mosses. </author> <title> Action Semantics. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year> <note> Number 26 Tracts in Theoretical Computer Science. </note>
Reference-contexts: Action semantics is a framework for formal semantics of programming languages, developed by Mosses <ref> [19, 20, 21, 24, 25] </ref> and Watt [26, 45]. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in 5 using semantic entities called actions, rather than higher-order functions. <p> It differs from denotational semantics, however, in 5 using semantic entities called actions, rather than higher-order functions. We have designed a subset of action notation which is amenable to compilation and which we have given a natural semantics, by a systematic transformation of its structural operational semantics <ref> [25] </ref>. The syntax of this subset is given in appendix A together with a brief overview of some the principles behind action semantics. <p> Note that the select construct in Mini-Ada can be used as a "case"-statement, and that also the input-output statements (read and write) are non-standard Ada. The Mini-Ada specification is a subset of one given by Mosses in his book <ref> [25] </ref>. (Readers who are unfamiliar with action semantics are not expected to understand the details in appendix B, despite the suggestiveness of the symbols used. See [25] for a full presentation of action semantics.) In the following, we first give an overview of the structure of Cantor and the generated Mini-Ada <p> The Mini-Ada specification is a subset of one given by Mosses in his book <ref> [25] </ref>. (Readers who are unfamiliar with action semantics are not expected to understand the details in appendix B, despite the suggestiveness of the symbols used. See [25] for a full presentation of action semantics.) In the following, we first give an overview of the structure of Cantor and the generated Mini-Ada compiler.
Reference: [26] <author> Peter D. Mosses and David A. Watt. </author> <title> The use of action semantics. </title> <booktitle> In Proc. IFIP TC2 Working Conference on Formal Description of Programming Concepts III (Gl. </booktitle> <address> Averns, </address> <year> 1986), </year> <pages> pages 135-163. </pages> <publisher> North-Holland, </publisher> <year> 1987. </year>
Reference-contexts: Action semantics is a framework for formal semantics of programming languages, developed by Mosses [19, 20, 21, 24, 25] and Watt <ref> [26, 45] </ref>. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in 5 using semantic entities called actions, rather than higher-order functions.
Reference: [27] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> Two-level semantics and code generation. </title> <journal> Theoretical Computer Science, </journal> <volume> 56 </volume> <pages> 59-133, </pages> <year> 1988. </year>
Reference-contexts: Work on compiler correctness does not seem to be of much help because it usually focuses on denotational semantics <ref> [13, 15, 41, 36, 27] </ref>, algebraic variations hereof [3, 16, 42, 2, 18], structural operational semantics [6], or natural semantics [4].
Reference: [28] <author> Hewlett Packard. </author> <title> Precision architecture and instruction. </title> <type> Technical Report 09740-90014, </type> <month> June </month> <year> 1987. </year>
Reference-contexts: The generated compilers emit absolute code for an abstract RISC [40] machine language, which easily can be compiled into code for existing RISC processors. Currently, implementations exist for the SPARC [14] and the HP Precision Architecture <ref> [28] </ref>. The development of Cantor was guided by the following principles: * Correctness is more important than efficiency; and * Specification and proof must be completed before implementation begins.
Reference: [29] <author> Jens Palsberg. </author> <title> Provably Correct Compiler Generation. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1992. </year>
Reference-contexts: Finally, in section 4 we compare the performance of the generated Mini-Ada compiler with the standard C compilers on the SPARC and the HP Precision Architecture. This paper summarizes the author's forthcoming PhD thesis <ref> [29] </ref>, except the correctness proof.
Reference: [30] <author> Jens Palsberg. </author> <title> A provably correct compiler generator. </title> <booktitle> In Proc. ESOP'92, Euro-pean Symposium on Programming, </booktitle> <pages> pages 418-434. </pages> <publisher> Springer-Verlag (LNCS 582), Rennes, </publisher> <address> France, </address> <month> February </month> <year> 1992. </year> <month> 29 </month>
Reference-contexts: Finally, in section 4 we compare the performance of the generated Mini-Ada compiler with the standard C compilers on the SPARC and the HP Precision Architecture. This paper summarizes the author's forthcoming PhD thesis [29], except the correctness proof. For an overview of our approach to correctness, see <ref> [30] </ref>. 2 Previous Work We will examine each of the previous approaches to compiler generation by focusing on: * The accessibility and maintainability of the involved specifications; * The quality of the generated compilers; and * Whether correctness has been proved.
Reference: [31] <author> Lawrence Paulson. </author> <title> A semantics-directed compiler generator. </title> <booktitle> In Ninth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 224-233, </pages> <year> 1982. </year>
Reference-contexts: This approach is usually called semantics-directed compiler generation. The traditional approach to compiler generation is based on denotational semantics [37]. Examples of existing compiler generators based on this idea include Mosses' Semantics Implementation System (SIS) [17], Paulson's Semantics Processor (PSP) <ref> [31, 32] </ref>, and Wand's Semantic Prototyping System (SPS) [44]. Denotational semantics has achieved much popularity as a vehicle for theoretical studies, but it is also recognized to be neither flexible nor readable, see for example the discussions by Mosses [19], and Pleban and Lee [34].
Reference: [32] <author> Uwe F. Pleban. </author> <title> Compiler prototyping using formal semantics. </title> <booktitle> In Proc. ACM SIG-PLAN'84 Symposium on Compiler Construction, </booktitle> <pages> pages 94-105. </pages> <booktitle> Sigplan Notices, </booktitle> <year> 1984. </year>
Reference-contexts: These criteria decide whether a system could be useful in a langauge designer's workbench. Common to all of the approaches are that they choose a specific target language <ref> [32] </ref>. Ideally, the task is then to write and prove the correctness of a compiler for the involved specification language. Such a compiler can then be composed with a language definition to yield a correct compiler for the language, see figure 1. This approach is usually called semantics-directed compiler generation. <p> This approach is usually called semantics-directed compiler generation. The traditional approach to compiler generation is based on denotational semantics [37]. Examples of existing compiler generators based on this idea include Mosses' Semantics Implementation System (SIS) [17], Paulson's Semantics Processor (PSP) <ref> [31, 32] </ref>, and Wand's Semantic Prototyping System (SPS) [44]. Denotational semantics has achieved much popularity as a vehicle for theoretical studies, but it is also recognized to be neither flexible nor readable, see for example the discussions by Mosses [19], and Pleban and Lee [34].
Reference: [33] <author> Uwe F. Pleban and Peter Lee. </author> <title> On the use of LISP in implementing denotational semantics. </title> <booktitle> In Proc. ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 233-248, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller [38, 39], the compiler generator of Kelsey and Hudak [10], and the Mess system of Pleban and Lee <ref> [33, 12, 35, 11] </ref>. These approaches are based on rather ad hoc specification languages, and, like the classical systems, they lack correctness proofs. The CAT system is aimed at generating compilers for Pascal, C, Basic, Fortran, and Cobol.
Reference: [34] <author> Uwe F. Pleban and Peter Lee. </author> <title> High-level semantics, an integrated approach to programming language semantics and the specification of implementations. </title> <booktitle> In Proc. Mathmatical Foundations of Programming Language Semantics, </booktitle> <pages> pages 550-571, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: Denotational semantics has achieved much popularity as a vehicle for theoretical studies, but it is also recognized to be neither flexible nor readable, see for example the discussions by Mosses [19], and Pleban and Lee <ref> [34] </ref>. The target programs produced by the classical systems have been reported to run at least three orders of magnitude slower than corresponding target programs produced by handwritten compilers [11]. None of these systems have been proved correct.
Reference: [35] <author> Uwe F. Pleban and Peter Lee. </author> <title> An automatically generated, realistic compiler for an imperative programming language. </title> <booktitle> In Proc. SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 222-232, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller [38, 39], the compiler generator of Kelsey and Hudak [10], and the Mess system of Pleban and Lee <ref> [33, 12, 35, 11] </ref>. These approaches are based on rather ad hoc specification languages, and, like the classical systems, they lack correctness proofs. The CAT system is aimed at generating compilers for Pascal, C, Basic, Fortran, and Cobol.
Reference: [36] <author> Wolfgang Polak. </author> <title> Compiler Specification and Verification. </title> <publisher> Springer-Verlag (LNCS 213), </publisher> <year> 1981. </year>
Reference-contexts: Work on compiler correctness does not seem to be of much help because it usually focuses on denotational semantics <ref> [13, 15, 41, 36, 27] </ref>, algebraic variations hereof [3, 16, 42, 2, 18], structural operational semantics [6], or natural semantics [4].
Reference: [37] <author> David A. Schmidt. </author> <title> Denotational Semantics. </title> <publisher> Allyn and Bacon, </publisher> <year> 1986. </year>
Reference-contexts: Such a compiler can then be composed with a language definition to yield a correct compiler for the language, see figure 1. This approach is usually called semantics-directed compiler generation. The traditional approach to compiler generation is based on denotational semantics <ref> [37] </ref>. Examples of existing compiler generators based on this idea include Mosses' Semantics Implementation System (SIS) [17], Paulson's Semantics Processor (PSP) [31, 32], and Wand's Semantic Prototyping System (SPS) [44].
Reference: [38] <author> Uwe Schmidt and Reinhard Voller. </author> <title> A multi-language compiler system with automatically generated codegenerators. </title> <booktitle> In Proc. ACM SIGPLAN'84 Symposium on Compiler Construction. Sigplan Notices, </booktitle> <year> 1984. </year>
Reference-contexts: A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller <ref> [38, 39] </ref>, the compiler generator of Kelsey and Hudak [10], and the Mess system of Pleban and Lee [33, 12, 35, 11]. These approaches are based on rather ad hoc specification languages, and, like the classical systems, they lack correctness proofs.
Reference: [39] <author> Uwe Schmidt and Reinhard Voller. </author> <title> Experience with VDM in Norsk Data. </title> <booktitle> In VDM'87. VDM|A Formal Method at Work, </booktitle> <pages> pages 49-62. </pages> <publisher> Springer-Verlag (LNCS 252), </publisher> <month> March </month> <year> 1987. </year>
Reference-contexts: A number of compiler generators have been built that produce compilers of a quality that compare well with commercially available compilers. Major examples are the CAT system of Schmidt and Voller <ref> [38, 39] </ref>, the compiler generator of Kelsey and Hudak [10], and the Mess system of Pleban and Lee [33, 12, 35, 11]. These approaches are based on rather ad hoc specification languages, and, like the classical systems, they lack correctness proofs.
Reference: [40] <author> William Stallings. </author> <title> Reduced Instruction Set Computers. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1986. </year>
Reference-contexts: The considered subset of action notation, see appendix A, is powerful enough to allow the specification of a non-trivial subset of Ada [5], called Mini-Ada, see appendix B. The generated compilers emit absolute code for an abstract RISC <ref> [40] </ref> machine language, which easily can be compiled into code for existing RISC processors. Currently, implementations exist for the SPARC [14] and the HP Precision Architecture [28].
Reference: [41] <author> Joseph E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: Work on compiler correctness does not seem to be of much help because it usually focuses on denotational semantics <ref> [13, 15, 41, 36, 27] </ref>, algebraic variations hereof [3, 16, 42, 2, 18], structural operational semantics [6], or natural semantics [4].
Reference: [42] <author> James W. Thatcher, Eric G. Wagner, and Jesse B. Wright. </author> <title> More on advice on structuring compilers and proving them correct. </title> <journal> Theoretical Computer Science, </journal> <volume> 15 </volume> <pages> 223-249, </pages> <year> 1981. </year>
Reference-contexts: Work on compiler correctness does not seem to be of much help because it usually focuses on denotational semantics [13, 15, 41, 36, 27], algebraic variations hereof <ref> [3, 16, 42, 2, 18] </ref>, structural operational semantics [6], or natural semantics [4]. We are aware of only one compiler generator that has been proved correct: the one obtained by self-application of the partial evaluator mix, see the paper by Gomard and Jones [7].
Reference: [43] <author> Larry Wall and Randal L. Schwartz. </author> <title> Programming Perl. </title> <address> O'Reilly, </address> <year> 1991. </year>
Reference-contexts: In practice, a session with Cantor looks as follows on the screen: cantor syntax semantics compiler compiler program code code input output The compiler generator cantor is written in Perl <ref> [43] </ref>, and the generated compilers are written in Scheme [1]. Examples of a syntax and a semantics are given in appendix B; it is the L A T E X source of the appendix that is processed by 6 cantor.
Reference: [44] <author> Mitchell Wand. </author> <title> A semantic prototyping system. </title> <booktitle> In Proc. ACM SIGPLAN'84 Symposium on Compiler Construction, </booktitle> <pages> pages 213-221. </pages> <booktitle> Sigplan Notices, </booktitle> <year> 1984. </year>
Reference-contexts: This approach is usually called semantics-directed compiler generation. The traditional approach to compiler generation is based on denotational semantics [37]. Examples of existing compiler generators based on this idea include Mosses' Semantics Implementation System (SIS) [17], Paulson's Semantics Processor (PSP) [31, 32], and Wand's Semantic Prototyping System (SPS) <ref> [44] </ref>. Denotational semantics has achieved much popularity as a vehicle for theoretical studies, but it is also recognized to be neither flexible nor readable, see for example the discussions by Mosses [19], and Pleban and Lee [34].
Reference: [45] <author> David A. Watt. </author> <title> Programming Language Syntax and Semantics. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Action semantics is a framework for formal semantics of programming languages, developed by Mosses [19, 20, 21, 24, 25] and Watt <ref> [26, 45] </ref>. It is intended to allow useful semantic descriptions of realistic programming languages, and it is compositional, like denotational semantics. It differs from denotational semantics, however, in 5 using semantic entities called actions, rather than higher-order functions.
Reference: [46] <author> William D. Young. </author> <title> A mechanically verified code generator. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 493-518, </pages> <year> 1989. </year> <month> 31 </month>
Reference-contexts: Putting further sophistication into the compiler will add significantly to these page counts. We feel that the size alone of the specifications calls for automatic proof checking. Recent attempts to automatically check a compiler correctness proof are reported by Young <ref> [46] </ref> and Joyce [9, 8].
References-found: 46

