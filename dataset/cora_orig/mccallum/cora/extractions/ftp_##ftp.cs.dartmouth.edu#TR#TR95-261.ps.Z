URL: ftp://ftp.cs.dartmouth.edu/TR/TR95-261.ps.Z
Refering-URL: http://www.cs.dartmouth.edu/reports/abstracts/TR95-261/
Root-URL: http://www.cs.dartmouth.edu
Title: Ph.D. Thesis Proposal: Transportable Agents  
Author: Robert S. Gray Dr. George Cybenko, Thayer Dr. David Kotz, Dr. Daniela Rus, 
Degree: Dr. Robert Sproull,  
Note: Thesis committee  
Date: 19 May 1995  
Address: 6211 Sudikoff Laboratory Hanover, New Hampshire 03755  College  
Affiliation: Department of Computer Science Dartmouth College  School of Engineering, Dartmouth College  Department of Computer Science, Dartmouth College  Department of Computer Science, Dartmouth  Sun Microsystems  
Abstract: One of the paradigms that has been suggested for allowing efficient access to remote resources is transportable agents. A transportable agent is a named program that can migrate from machine to machine in a heterogeneous network. The program chooses when and where to migrate. It can suspend its execution at an arbitrary point, transport to another machine and resume execution on the new machine. Transportable agents have several advantages over the traditional client/server model. Transportable agents consume less network bandwidth and do not require a connection between communicating machines - this is attractive in all networks and particularly attractive in wireless networks. Transportable agents are a convenient paradigm for distributed computing since they hide the communication channels but not the location of the computation. Transportable agents allow clients and servers to program each other. However transportable agents pose numerous challenges such as security, privacy and efficiency. Existing transportable agent systems do not meet all of these challenges. In addition there has been no formal characterization of the performance of transportable agents. This thesis addresses these weakness. The thesis has two parts - (1) formally characterize the performance of transportable agents through mathematical analysis and network simulation and (2) implement a complete transportable agent system. 
Abstract-found: 1
Intro-found: 1
Reference: [BN84] <author> A. D. Birrell and B. J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: Message passing is powerful and flexible but requires the programmer to handle low-level details keeping track of which response goes with which request, converting data between client and server formats, determining the address of the server and handling communication and system errors [SS94]. Remote procedure call (RPC) <ref> [BN84] </ref> was designed to relieve the programmer of these details. RPC allows a program on the client to invoke a procedure on the server using the standard procedure call mechanism. The most common implementation which is the implementation of [BN84] uses stub procedures [SS94]. <p> Remote procedure call (RPC) <ref> [BN84] </ref> was designed to relieve the programmer of these details. RPC allows a program on the client to invoke a procedure on the server using the standard procedure call mechanism. The most common implementation which is the implementation of [BN84] uses stub procedures [SS94]. A client that makes a remote procedure call is actually calling a local stub. This client stub puts the procedure name and parameters into a message and sends the message to the remote machine.
Reference: [BR93] <author> Nathaniel Borenstein and Marshall T. Rose. </author> <title> Mime extensions for mail-enabled applications: </title> <institution> application/Safe-Tcl and mulitpart/enabled-mail. Bellcore Memo, Bellcore, </institution> <year> 1993. </year> <note> This memo is a working draft and should not be cited in published work. 32 </note>
Reference-contexts: Postscript programs are often sent to remote printers and displays. Scripting systems such as Apple Script allow scripts to be sent from one application to another [Joh93]. MIME/Safe-Tcl allows Tcl scripts to be embedded in e-mail messages. These scripts are executed automatically when the message is received or viewed <ref> [BR93] </ref>. The IBM Intelligent Communications Network TM uses Intelligent Objects T M . These objects can contain procedures and can be sent from an application on one site to an application on another. The recipient can execute the embedded procedures [Rei94].
Reference: [Car94] <author> Luca Cardelli. Obliq: </author> <title> A language with distributed scope. Digital White Paper, </title> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1994. </year> <note> This white paper is available at http://www.research.digital.com/SRC/Obliq/Obliq.html. </note>
Reference-contexts: Until an identification scheme is developed and the migration feature is implemented, Jodler will be just an object-oriented extension to Tcl with rudimentary security features. 12 Obliq is similar to Jodler except that it has a fully realized and more elegant implementation <ref> [Car94] </ref>. Obliq is an interpreted, lexically scoped and object-oriented. An Obliq object is a collection of named fields which contain methods, aliases and values. A value can be a network reference. Obliq objects are technically immobile and tied to a specific site.
Reference: [Coe94] <author> Michael D. Coen. SodaBot: </author> <title> A software agent environment and construction system. </title> <editor> In Yannis Labrou and Tim Finin, editors, </editor> <booktitle> Proceedings of the CIKM Workshop on Intelligent Information Agents, Third International Conference on Information and Knowledge Management (CIKM 94), </booktitle> <address> Gaithersburg, Maryland, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: The rest are application-specific and ill-suited to general computation. These schemes are not included in the comparison of existing transportable agent systems. SodaBot an agent environment and construction system was developed to facilitate the creation of personal assistant agents <ref> [Coe94] </ref>. The system provides a high-level scripting language, a basic software agent (BSA) that controls the execution of all agents associated with a particular user and a graphical interface to the BSA. <p> Users can change the access rights for each agent running on their BSA and can visually inspect agents for security threats. SodaBot supports limited migration in that the components of an agent application are automatically distributed to the appropriate network sites when the application is first used <ref> [Coe94] </ref>. However this is far removed from true migration. SodaBot is not included in the comparison of existing transportable agent systems. Jodler is an object-oriented extension to the Tool Command Language (Tcl) [Ott94]. which object in Jodler consists of named slots which can contain either functions or values.
Reference: [Fal87] <author> Joseph R. Falcone. </author> <title> A programmable interface language for heterogeneous systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(4) </volume> <pages> 330-351, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: To address these two problems, researchers have turned to remote evaluation in which a subprogram is sent from the client to the server. The subprogram executes on the server and returns its result to the client. Falcone <ref> [Fal87] </ref> describes a system in which clients and servers program each other using the Network Command Language (NCL). NCL is a variant of Lisp. Each server provides a library of NCL functions. A client that requires a service sends an NCL expression to the appropriate server.
Reference: [Fon93] <author> Leonard N. Foner. </author> <title> What's an agent anyway: A sociological case study. Agents Memo 93-01, Agents Group, </title> <publisher> MIT Media Lab, </publisher> <year> 1993. </year>
Reference-contexts: Applications are often described as agent-based solely to draw attention or increase sales. For example No Hands Software describes its Magnet T M program as the "first intelligent agent for the Macintosh" even though it is essentially a file-finder <ref> [Fon93] </ref>. This inappropriate use of the term makes it difficult to separate hype from actual research. However there appear to be five legitimate contexts in which the term "agent" is used artificial intelligence, personal assistants, distributed information retrieval, software engineering and interoperation and transportable agents.
Reference: [GG88] <author> D. K. Gifford and N. Glasser. </author> <title> Remote pipes and procedures for efficient distributed communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(3) </volume> <pages> 258-283, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Most extensions to traditional RPC allow concurrent invocation of the same procedure on multiple servers or make RPC asynchronous [SS94]. These variations are more flexible but make programming more difficult. Other disadvantages of traditional RPC were described in <ref> [GG88] </ref>. It is difficult to send incremental results from the server to the client; implementations are commonly optimized for short results rather than bulk data transfer; and there is no way to pass a procedure or more precisely a reference to a procedure to the server. <p> This last limitation obviates any protocol that requires the server to invoke a client-specified procedure on the client machine. <ref> [GG88] </ref> addresses these problems by allowing procedure references to be passed as arguments and by introducing the pipe abstraction. A pipe is a connection between the client and the remote procedure that exists for the duration of the remote procedure call.
Reference: [GK94] <author> Michael R. Genesereth and Steven P. Ketchpel. </author> <title> Software agents. </title> <journal> Communications of the ACM, </journal> <volume> 37(7) </volume> <pages> 48-53, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Applications are sent scripts that guide the application through the desired task. These applications are said to be scriptable or programmable. Notable examples of the script-based approach include Tcl, Telescript, Apple Script, Hewlett-Packard's NewWave environment and the Autonomous Knowledge Agents (AKA) project <ref> [GK94, Joh93] </ref>. The Tk extension to Tcl provides the send command which is used to send Tcl scripts from one application to another. Telescript allows agents to send scripts to each other once the agents have established a direct connection. Apple Script and NewWave provide similar scripting functionality. <p> Agents communicate with the resource using the procedures in the Tcl interface rather than the resource's native communication language. This makes agents much easier to write. In addition the Tcl interface can remain constant across different architectures which makes agents much easier to port. 2.4.2 Declarative Genesereth <ref> [GK94] </ref> points out several disadvantages of the procedural approach. Writing procedures might require information about the recipient that is not available to the sender; procedures only compute in one direction; and procedures are difficult to merge. Genesereth argues for a declarative approach in which agents exchange declarative statements. <p> These declarative statements are written in the Agent Communication Language (ACL). ACL has three components a vocabulary, an inner language called the Knowledge Interchange Format (KIF) and an outer language called the Knowledge Query and Manipulation Language (KQML) <ref> [GK94] </ref>. The vocabulary is a dictionary of words specific to the application area. Each word has an English definition and a set of formal annotations written in KIF. KIF is a prefix version of first order predicate calculus which can express data, relationships among the data and procedures or scripts. <p> An example of directory assistance is the X.500 protocol; distributed object managers include CORBA, DSOM, OLE and OpenDoc; automatic brokers include ToolTalk and the Publish and Subscribe Service on the Macintosh <ref> [GK94] </ref>. The federated approach is distinguished by the amount of processing done in the facilitator [GK94]. Each facilitator performs backward inference rather than simple pattern matching. 2.4.3 Procedural versus declarative It is unclear whether the procedural or declarative approach is better. <p> An example of directory assistance is the X.500 protocol; distributed object managers include CORBA, DSOM, OLE and OpenDoc; automatic brokers include ToolTalk and the Publish and Subscribe Service on the Macintosh <ref> [GK94] </ref>. The federated approach is distinguished by the amount of processing done in the facilitator [GK94]. Each facilitator performs backward inference rather than simple pattern matching. 2.4.3 Procedural versus declarative It is unclear whether the procedural or declarative approach is better. The procedural approach is suggested when the sender is requesting a task that the recipient does not know how to perform in its entirety. <p> This approach involves less communication overhead but the source code of the application must be available. The third approach is to rewrite the application which is the most time-consuming but allows optimization for an agent environment <ref> [GK94] </ref>. We seek to support both procedure libraries and agent encapsulation. Agent encapsulation means that an agent must be able to directly access any resource at the site. However only the agents that encapsulate the resources will actually be allowed to do so. 4. security.
Reference: [GSS94] <author> Michael Genesereth, Narinder Singh, and Mustafa Syed. </author> <title> A distributed and anonymous knowledge sharing approach to software interoperation. </title> <editor> In Yannis Labrou and Tim Finin, editors, </editor> <booktitle> Proceedings of the CIKM Workshop on Intelligent Information Agents, Third International Conference on Information and Knowledge Management (CIKM 94), </booktitle> <address> Gaithersburg, Maryland, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: KQML offers more efficient communication than KIF alone. Agents that use KQML can communicate with each other directly. However this places the burden of in-teroperation squarely on the programmer. Instead Genesereth proposes a federated architecture in which facilitators handle interoperation <ref> [GSS94] </ref>. Essentially each agent is assigned a facilitator. An agent communicates only with its facilitator but facilitators communicate with each other. Each agent posts its capabilities and application-specific facts to its facilitator. Capabilities are a description of the services that the agent provides. Capabilities and facts are expressed in KIF.
Reference: [Haf95] <author> Katie Hafner. </author> <title> Have your agent call my agent. </title> <journal> Newsweek, </journal> <volume> 75(9), </volume> <month> February 27 </month> <year> 1995. </year>
Reference-contexts: an agent is an intelligent software servant that either (1) relieves the user of routine, burdensome tasks such as appointment scheduling and e-mail disposition or (2) filters the overwhelming volume of electronic information so that the user sees only the information that is relevant to her current interests and needs <ref> [Haf95, Rog95] </ref>. This definition due to its broadness and its ability to capture the imagination has made "agent" a buzzword within both the academic and commercial worlds. Applications are often described as agent-based solely to draw attention or increase sales.
Reference: [jav94] <institution> The Java language: A white paper. Sun Microsystems White Paper, Sun Microsystems, </institution> <year> 1994. </year>
Reference-contexts: The Java TM programming environment takes both approaches. A high-level Java program is compiled into bytecodes. The bytecodes can be interpreted or translated into machine code. Interpreted bytecodes are much faster than Tcl. Bytecodes converted to machine code are nearly as fast as native C <ref> [jav94] </ref>. Alternatively several groups are working on faster Tcl interpreters [Sah94] and Tcl compilers [SBD94]. These groups have achieved notable success even though Tcl was never meant to be compiled. There are other reasonable choices for an agent language.
Reference: [Joh93] <author> Raymond W. Johnson. </author> <title> Autonomous knowledge agents: How agents use the tool command language. </title> <booktitle> In Proceedings of the 1993 Tcl Workshop, </booktitle> <year> 1993. </year>
Reference-contexts: Applications are sent scripts that guide the application through the desired task. These applications are said to be scriptable or programmable. Notable examples of the script-based approach include Tcl, Telescript, Apple Script, Hewlett-Packard's NewWave environment and the Autonomous Knowledge Agents (AKA) project <ref> [GK94, Joh93] </ref>. The Tk extension to Tcl provides the send command which is used to send Tcl scripts from one application to another. Telescript allows agents to send scripts to each other once the agents have established a direct connection. Apple Script and NewWave provide similar scripting functionality. <p> There are several schemes that fall between remote evaluation and transportable agents. Postscript programs are often sent to remote printers and displays. Scripting systems such as Apple Script allow scripts to be sent from one application to another <ref> [Joh93] </ref>. MIME/Safe-Tcl allows Tcl scripts to be embedded in e-mail messages. These scripts are executed automatically when the message is received or viewed [BR93]. The IBM Intelligent Communications Network TM uses Intelligent Objects T M .
Reference: [JvRS95] <author> Dag Johansen, Robbert van Renesse, and Fred B. Scheidner. </author> <title> Operating system support for mobile agents. </title> <booktitle> In Proceedings of the 5th IEEE Workshop on Hot Topics in Operating Systems, </booktitle> <year> 1995. </year>
Reference-contexts: Mobile computing is characterized by low bandwidth, high latency and periods of disconnection from the network. Transportable agents are a convenient paradigm for distributed computing. First, the communication channels are hidden from the programmer but the location of the computation is not <ref> [JvRS95] </ref>. The agent specifies when and where to migrate and the system handles the transmission. <p> Clients and servers can program each other which greatly extends the functionality that application and server developers can provide to their customers. In addition an application can dynamically distribute its server components when it starts execution <ref> [JvRS95] </ref>. Applications that have been suggested for transportable agents include distributed information retrieval, network management, active e-mail, active documents, controlling remote devices, workflow and electronic shopping [Ous95, Whi94]. <p> The second security feature of the Obliq language itself is that objects can prevent other objects from cloning and modifying them. Higher-level security measures are not addressed. TACOMA (Tromst and COrnell Moving Agents) is a mobile agent system that uses Tcl/Horus. <ref> [JvRS95] </ref>. Tcl/Horus is a version of the Tcl scripting language which uses Horus to provide group communication and fault-tolerance. TACOMA agents are written in Tcl. Each agent has a briefcase of folders. Folders contain Tcl data and procedures. <p> Important features of the TACOMA system include rear guards, electronic cash and brokers. Rear guard agents handle machine failures. A rear guard is left behind whenever an agent migrates to a new machine. The rear guard restarts the agent if the agent suddenly "vanishes" <ref> [JvRS95] </ref>. Electronic cash is used to pay for services and is intended as a security measure. Runaway agents are impossible since an agent can not continue once its finances are exhausted. TACOMA relies on the underlying UNIX system for additional security. Broker agents provide directory and scheduling services. <p> Instead it is desirable to perform as much automatic recovery as possible. TACOMA leaves a rear guard agent behind whenever an agent migrates to a new network site <ref> [JvRS95] </ref>. The rear guard is responsible for restarting the agent if the agent disappears. The rear guard scheme quickly becomes complex since an agent that migrates several times will lead to chains or cycles of rear guards. <p> Such learning involves indirect observation of the user and other agents as well as direct feedback. 4. planning and inference Some agents must plan how to accomplish their task. 5. finances. Transportable agents may need to pay for certain services. TACOMA <ref> [JvRS95] </ref> uses a trusted money server that assigns a large random integer to each piece of electronic cash. When an agent transfers electronic cash to another agent, the recipient verifies that the cash has not been spent by contacting the authentication server.
Reference: [KK94] <author> Keith Kotay and David Kotz. </author> <title> Transportable agents. </title> <editor> In Yannis Labrou and Tim Finin, editors, </editor> <booktitle> Proceedings of the CIKM Workshop on Intelligent Information Agents, Third International Conference on Information and Knowledge Management (CIKM 94), </booktitle> <address> Gaithersburg, Maryland, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: The router carries data relevant to the task along with it and performs arbitrarily complex processing when deciding which step to perform next. Kotay and Kotz <ref> [KK94] </ref> describe a prototype system that was implemented as a starting point for future research. Transportable agents are written in a simple scripting language that includes most of the features of AWK as well as "traditional imperative language features" such as if-then and while [KK94]. <p> Kotay and Kotz <ref> [KK94] </ref> describe a prototype system that was implemented as a starting point for future research. Transportable agents are written in a simple scripting language that includes most of the features of AWK as well as "traditional imperative language features" such as if-then and while [KK94]. An agent migrates with the moveto command. The moveto command captures the internal state of the agent and transports this state to a new machine. The agent continues execution on the new machine from the statement after the moveto. <p> The authors suggest six areas for future work an interagent communication mechanism, replacement of the custom scripting language with a standard scripting language such as Tcl, an agent reproduction mechanism, improved security, improved error handling and navigation issues such as accessing replicated resources and searching for relevant resources <ref> [KK94] </ref>. Telescript is a General Magic product that is being used in AT&T's new PersonaLink network. It is one of the most robust transportable agent systems although it is a commercial product and unfortunately is not available to researchers. Each network site is divided into one or more virtual places.
Reference: [Mae94] <editor> Pattie Maes. </editor> <title> Agents that reduce work and information overload. </title> <journal> Communications of the ACM, </journal> <volume> 37(7) </volume> <pages> 48-53, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: These agents are distinguished from traditional utilities by (1) their use of machine learning so that they can adapt to user habits and preferences <ref> [Mae94] </ref> or (2) their use of automated reasoning so that they can make complex inferences about the work environment [Rie94]. <p> Maes presents a series of four agents that start with a minimum amount of domain knowledge and learn how to perform the task by observing and interacting with the user and other agents <ref> [Mae94] </ref>. This approach addresses the difficult problems of competence and trust. The agent is competent to perform the task for a specific user because it has learned to mimic user decisions.
Reference: [Neg95] <author> Nicholas Negroponte. Being digital. Alfred A. Knopf, </author> <year> 1995. </year>
Reference-contexts: The job of this assistant can be viewed as creating a personalized newspaper or news broadcast for the user. The third personal assistant is perhaps the most ambitious and most entertaining. We seek to implement part of Nicholas Negroponte's digital house <ref> [Neg95] </ref> in which smart appliances communicate with each other in order to accomplish a task for the owner.
Reference: [OPL94] <author> Tim Oates, M. V. Nagendra Prasad, and Victor Lesser. </author> <title> Networked information retrieval as distributed problem solving. </title> <editor> In Yannis Labrou and Tim Finin, editors, </editor> <booktitle> Proceedings of the CIKM Workshop on Intelligent Information Agents, Third International Conference on Information and Knowledge Management (CIKM 94), </booktitle> <address> Gaithersburg, Maryland, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: The example in the paper uses a combination of Internet resources to resolve underspecified e-mail addresses when sending messages. Vesser has written a succession of papers that develop a model for distributed searching. The most recent is <ref> [OPL94] </ref> which recasts the model in terms of agents. In the model a search involving multiple distributed resources is performed by a collection of cooperating agents. There is one agent for each resource.
Reference: [ora94] <author> Oracle Mobile Agents. </author> <title> Oracle Press Release, Oracle, </title> <year> 1994. </year>
Reference-contexts: It is far from complete. the user representative when the user is disconnected from the network or when the user does not want to receive intermediate data due to low transmission rates and high latencies <ref> [ora94] </ref>. Some of these schemes do not support arbitrary distribution and migration. The rest are application-specific and ill-suited to general computation. These schemes are not included in the comparison of existing transportable agent systems.
Reference: [Ott94] <author> Max Ott. </author> <title> Jodler a scripting language for the infobahn. </title> <booktitle> In Proceedings of the 1994 Tcl Workshop, </booktitle> <year> 1994. </year>
Reference-contexts: However this is far removed from true migration. SodaBot is not included in the comparison of existing transportable agent systems. Jodler is an object-oriented extension to the Tool Command Language (Tcl) <ref> [Ott94] </ref>. which object in Jodler consists of named slots which can contain either functions or values. A value can be a reference to another object. The transfer primitive moves an object to a new network location. A member function executes at the location of its object.
Reference: [Ous94] <author> John K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley Professional Computing Series. Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1994. </year> <month> 33 </month>
Reference-contexts: John Ousterhout at the University of California at Berkeley in 1987 and has enjoyed enormous popularity since then. Tcl has several advantages as a transportable agent language <ref> [Ous94] </ref>. Tcl is interpreted. This makes Tcl scripts highly portable and simplifies the implementation of security precautions. Tcl can be embedded in other applications due to its dual existence as a stand-alone interpreter and a function library.
Reference: [Ous95] <author> John K. Ousterhout. </author> <title> Scripts and agents: The new software high ground. </title> <booktitle> Invited Talk at 1995 Winter USENIX Conference, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: In addition an application can dynamically distribute its server components when it starts execution [JvRS95]. Applications that have been suggested for transportable agents include distributed information retrieval, network management, active e-mail, active documents, controlling remote devices, workflow and electronic shopping <ref> [Ous95, Whi94] </ref>. Any application in which it makes sense to move the program to the remote data or resource is a candidate for the transportable agent paradigm. The limiting factors are technical. For example there must be sufficient security precautions so that malicious agents can not damage a resource. <p> Finally Tcl is freely available to researchers unlike the commercial language Telescript. Several existing systems use Tcl as the agent language as noted in related work. However Tcl has several disadvantages. Tcl is inefficient compared to other interpreted languages such as Perl <ref> [Ous95] </ref>. Tcl is not object-oriented and provides no code modularization except for procedures. This makes it difficult to write large scripts. Fortunately several groups are working on more efficient Tcl interpreters [Sah94] and on Tcl compilers [SBD94].
Reference: [Rei94] <author> Andy Reinhardt. </author> <title> The network with smarts. </title> <journal> Byte, </journal> <pages> pages 51-64, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The most notable is General Magic's Telescript T M [Whi94] which is being used in AT&T's new PersonaLink T M network <ref> [Rei94] </ref>. The recent interest in transportable agents has been fueled by the growing inadequacy of the traditional client/server model for distributed applications. In the traditional client/server model the server provides a fixed set of operations. <p> The IBM Intelligent Communications Network TM uses Intelligent Objects T M . These objects can contain procedures and can be sent from an application on one site to an application on another. The recipient can execute the embedded procedures <ref> [Rei94] </ref>. Oracle Mobile Agents is meant for mobile computing and associates an agent with each mobile user. However the agent is not transportable. <p> Agents that attempt to violate the conditions of their permits are terminated immediately [Whi94]. The current applications of Telescript are electronic shopping (where each place is the electronic representative of a sales organization), active e-mail (where each place is a mailbox or router) and certain network management tasks <ref> [Rei94] </ref>. 2.5.4 Distributed systems Transportable agents can spread across a network and cooperate to perform a task. These cooperating agents behave like a distributed system. Therefore many of the services that will be necessary or convenient in agent applications have been addressed in distributed systems research. <p> For example the AT&T PersonaLink network is currently organized around a centralized AT&T server that is implicitly trusted. Therefore the server can submit an agent to a service on behalf of an anonymous user. The service sends billing information to the server which forwards it to the actual user <ref> [Rei94] </ref>. Privacy becomes much more difficult and perhaps impossible if there is no trusted third party. Fortunately high-privacy applications are often low-security while high-security applications are often low-privacy - e.g. browsing an online store catalog versus accessing classified military information. This should greatly extend the range of potential solutions. <p> TACOMA's electronic cash has the important security benefit of preventing runaway agents. An agent can not continue onces its finances are exhausted. PersonaLink is a commercial network that is centered around billing <ref> [Rei94] </ref>. However the exact billing mechanism is unknown. 6. negotiation Transportable agents may need to negotiate with one or more other agents in order to settle on a satisfactory price for the service. 7. Resource description, organization and discovery. These issues arise in information retrieval applications.
Reference: [Rie94] <author> Doug Riecken. M: </author> <title> An architecture of distributed agents. </title> <journal> Communications of the ACM, </journal> <volume> 37(7) </volume> <pages> 48-53, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: These agents are distinguished from traditional utilities by (1) their use of machine learning so that they can adapt to user habits and preferences [Mae94] or (2) their use of automated reasoning so that they can make complex inferences about the work environment <ref> [Rie94] </ref>. Maes presents a series of four agents that start with a minimum amount of domain knowledge and learn how to perform the task by observing and interacting with the user and other agents [Mae94]. This approach addresses the difficult problems of competence and trust. <p> The other three agents share the same basic design. Riecken has developed a more complex system called M that is designed to automatically group the doc 6 uments that are presented during the course of a virtual multimedia conference <ref> [Rie94] </ref>. The heart of the system is five inference engines functional, structural, causal, spatial and temporal that attempt to infer relationships among documents based on the actions that the users apply to the documents.
Reference: [RN95] <author> Stuart Russell and Peter Norvig. </author> <title> Artificial intelligence: A modern approach. </title> <booktitle> Prentice-Hall Series on Artificial Intelligence. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1995. </year>
Reference-contexts: Finally we describe the precursors to transportable agents and existing transportable agent systems. 2.1 Artificial intelligence Here an agent is an entity that perceives its environment with sensors and acts on its environment with effectors <ref> [RN95] </ref>. Such an agent can be either hardware with physical sensors and effectors or software with simulated sensors and effectors.
Reference: [Rog95] <author> Adams Rogers. </author> <title> Is there a case for viruses? Newsweek, </title> <type> 75(9), </type> <month> February 27 </month> <year> 1995. </year>
Reference-contexts: an agent is an intelligent software servant that either (1) relieves the user of routine, burdensome tasks such as appointment scheduling and e-mail disposition or (2) filters the overwhelming volume of electronic information so that the user sees only the information that is relevant to her current interests and needs <ref> [Haf95, Rog95] </ref>. This definition due to its broadness and its ability to capture the imagination has made "agent" a buzzword within both the academic and commercial worlds. Applications are often described as agent-based solely to draw attention or increase sales.
Reference: [Sah94] <author> Adam Sah. </author> <title> TC: An efficient implementation of the Tcl language. </title> <type> Master's thesis, </type> <institution> University of California at Berkeley, </institution> <month> May </month> <year> 1994. </year> <note> Available as technical report UCB-CSD-94-812. </note>
Reference-contexts: A high-level Java program is compiled into bytecodes. The bytecodes can be interpreted or translated into machine code. Interpreted bytecodes are much faster than Tcl. Bytecodes converted to machine code are nearly as fast as native C [jav94]. Alternatively several groups are working on faster Tcl interpreters <ref> [Sah94] </ref> and Tcl compilers [SBD94]. These groups have achieved notable success even though Tcl was never meant to be compiled. There are other reasonable choices for an agent language. The tradeoff is that security mechanisms become more complicated as the agent gets closer to the bare hardware. <p> However Tcl has several disadvantages. Tcl is inefficient compared to other interpreted languages such as Perl [Ous95]. Tcl is not object-oriented and provides no code modularization except for procedures. This makes it difficult to write large scripts. Fortunately several groups are working on more efficient Tcl interpreters <ref> [Sah94] </ref> and on Tcl compilers [SBD94]. In addition the lack of object-oriented features has not been an issue with the Tcl agents developed so far since these agents have been small even though they perform significant processing at the remote site.
Reference: [SBD94] <author> Adam Sah, Jon Blow, and Brian Dennis. </author> <title> An introduction to the Rush language. </title> <booktitle> In Proceedings of the 1994 Tcl Workshop, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Efficiently executing the agent code can be done no where but the system level. Existing systems use interpreted languages for security and portability. However the interpretative overhead is severe. For example Tcl runs ten thousand times slower than native C <ref> [SBD94] </ref>. The clear solution is to either compile agents into a low level representation that can be interpreted much faster or to compile agents into actual machine code. The Java TM programming environment takes both approaches. A high-level Java program is compiled into bytecodes. <p> The bytecodes can be interpreted or translated into machine code. Interpreted bytecodes are much faster than Tcl. Bytecodes converted to machine code are nearly as fast as native C [jav94]. Alternatively several groups are working on faster Tcl interpreters [Sah94] and Tcl compilers <ref> [SBD94] </ref>. These groups have achieved notable success even though Tcl was never meant to be compiled. There are other reasonable choices for an agent language. The tradeoff is that security mechanisms become more complicated as the agent gets closer to the bare hardware. <p> Tcl is inefficient compared to other interpreted languages such as Perl [Ous95]. Tcl is not object-oriented and provides no code modularization except for procedures. This makes it difficult to write large scripts. Fortunately several groups are working on more efficient Tcl interpreters [Sah94] and on Tcl compilers <ref> [SBD94] </ref>. In addition the lack of object-oriented features has not been an issue with the Tcl agents developed so far since these agents have been small even though they perform significant processing at the remote site. However it will become an issue as script size increases.
Reference: [SG90] <author> J. Stamos and D. Gifford. </author> <title> Remote evaluation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 537-565, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Remote evaluation (REV) is similar to NCL in that a procedure can be sent to a remote server for evaluation <ref> [SG90] </ref>. However REV can be used with any language. It uses client and server stubs in much the same way as RPC. All that is needed for a new language is stub generators and linking facilities so that the procedure can invoke the procedures provided at the server. <p> Stamos and Gifford identify four security considerations authentication, availability, secrecy and integrity. Authentication and availability consist of checking the identity of the client and preventing malicious denial of service. These can be handled with well known techniques <ref> [SG90] </ref>. Secrecy and integrity consist of preventing unauthorized access to and destruction of server information. These are more difficult. Stamos and Gifford present three solutions separate address spaces for each procedure, careful interpretation in a single address space and digital signatures with a single address space.
Reference: [Spr95] <author> Robert Sproull. </author> <title> Sun Microsystems, personal communication with the author, </title> <month> May </month> <year> 1995. </year>
Reference-contexts: The programmer wrote a single program which the compiler divided into interactive and computation-intensive pieces. The interactive piece was executed at the graphics terminal while the computation-intensive piece was executed on the mainframe. The two pieces were tied together with stubs as in RPC <ref> [Spr95] </ref>. The critical problem with RPC is that the client is limited to the operations provided at the server. <p> In other words we need to model the typical machine access pattern or the typical resource usage pattern. Modeling of typical access patterns has been one of the most difficult aspects of machine and network simulation <ref> [Spr95] </ref>. If the model is too general, model results will not agree with actual performance. If the model is tuned to particular applications, model results will agree with actual performance only for a particular mix of applications.
Reference: [SS94] <author> Mukesh Singhal and Niranjan G. Shivaratri. </author> <title> Advanced concepts in operating systems: Distributed, database and multiprocessor operating systems. </title> <publisher> McGraw-Hill Series in Computer Science. McGraw-Hill, </publisher> <address> New York, </address> <year> 1994. </year>
Reference-contexts: Message passing is powerful and flexible but requires the programmer to handle low-level details keeping track of which response goes with which request, converting data between client and server formats, determining the address of the server and handling communication and system errors <ref> [SS94] </ref>. Remote procedure call (RPC) [BN84] was designed to relieve the programmer of these details. RPC allows a program on the client to invoke a procedure on the server using the standard procedure call mechanism. The most common implementation which is the implementation of [BN84] uses stub procedures [SS94]. <p> system errors <ref> [SS94] </ref>. Remote procedure call (RPC) [BN84] was designed to relieve the programmer of these details. RPC allows a program on the client to invoke a procedure on the server using the standard procedure call mechanism. The most common implementation which is the implementation of [BN84] uses stub procedures [SS94]. A client that makes a remote procedure call is actually calling a local stub. This client stub puts the procedure name and parameters into a message and sends the message to the remote machine. <p> The client stub returns the result to the client. The original RPC mechanism blocked the client until the server returned the result. Most extensions to traditional RPC allow concurrent invocation of the same procedure on multiple servers or make RPC asynchronous <ref> [SS94] </ref>. These variations are more flexible but make programming more difficult. Other disadvantages of traditional RPC were described in [GG88]. <p> These cooperating agents behave like a distributed system. Therefore many of the services that will be necessary or convenient in agent applications have been addressed in distributed systems research. These services include synchronization, mutual exclusion, deadlock detection, agreement, shared memory, scheduling, transactions, crash recovery, fault tolerance and reliable broadcast <ref> [SS94] </ref>. These services must be available to transportable agents. However it is unreasonable to provide all of these services at the system level. Such a system would be unwieldy and inefficient. Instead most of these services should be provided with other agents. <p> The first issue is the level of the communication primitives. Low-level primitives such as send and receive are flexible but impose a significant burden on the programmer <ref> [SS94] </ref>. High-level primitives are restrictive but easier to use. The existing transportable agent systems provide either implicit communication or high-level primitives such as meet. For example communication in Obliq requires nothing more than the invocation of a member function. The member function can belong to a local or remote object.
Reference: [Sto94] <author> A. D. Stoyenko. SUPRA-RPC: </author> <title> SUbprogram PaRAmeters in Remote Procedure Calls. </title> <journal> Software-Practice and Experience, </journal> <volume> 24(1) </volume> <pages> 27-49, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: The developers of REV and NCL were primarily concerned with moving computation to a remote machine and imposed this limitation to simplify implementation. SURPRA-RPC (SUbprogram PaRAmeters in Remote Procedure Calls) on the other hand seeks to allow normal procedure call semantics for both local and remote calls <ref> [Sto94] </ref>. Essentially SUPRA-RPC extends traditional RPC with additional stubs that are invoked whenever a procedure references an out-of-scope variable or function. The server makes a callback to the client in order to handle the out-of-scope reference.
Reference: [Voo91] <author> Ellen M. Voorhees. </author> <title> Using computerized routers to control product flow. </title> <booktitle> In Proceedings of the Twenty-Fourth Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 275-282. </pages> <publisher> IEEE, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: However there is no corresponding fault-tolerant implementation for heterogeneous machines. There apparently is a mechanism for detecting malicious routers but this mechanism is not specified. In addition the current status of the router research is unclear. However intelligent routers have been used in a wafer routing application <ref> [Voo91] </ref> and have been suggested for a range of workflow applications [WVF89] in which certain people or machines must perform certain steps of a task. <p> The agent guides the tool through the appropriate steps for the current part, records the results and handles exceptional conditions. This application is an extended version of the wafer routing application in 26 <ref> [Voo91] </ref>. The third application is software development. Here an agent guides a software package and its components through the software life cycle.
Reference: [Whi94] <author> James E. White. </author> <title> Telescript technology: The foundation for the electronic marketplace. General Magic White Paper, General Magic, </title> <year> 1994. </year>
Reference-contexts: Although the idea of a program that can move from machine to machine under its own control is not new [WVF89], it is only in the last two years that production-quality systems have been implemented. The most notable is General Magic's Telescript T M <ref> [Whi94] </ref> which is being used in AT&T's new PersonaLink T M network [Rei94]. The recent interest in transportable agents has been fueled by the growing inadequacy of the traditional client/server model for distributed applications. In the traditional client/server model the server provides a fixed set of operations. <p> Agents that do more work avoid more intermediate messages and conserve more network bandwidth. The performance advantage is greatest in low bandwidth and high latency networks <ref> [Whi94] </ref>. Modern client/server models such as remote evaluation and SUPRA-RPC address the same problem by sending subprograms to the server for evaluation. However these subprograms are anonymous entities. There is no convenient way for two subprograms to communicate with each other which makes it difficult to share partial results. <p> Transportable agents do not require a connection between the local and remote sites and do not require state information at both sites. This makes transportable agents more fault-tolerant [WVF89] and in combination with their low use of network bandwidth, makes them ideally suited to mobile computing <ref> [Whi94] </ref>. Mobile computing is characterized by low bandwidth, high latency and periods of disconnection from the network. Transportable agents are a convenient paradigm for distributed computing. First, the communication channels are hidden from the programmer but the location of the computation is not [JvRS95]. <p> In addition an application can dynamically distribute its server components when it starts execution [JvRS95]. Applications that have been suggested for transportable agents include distributed information retrieval, network management, active e-mail, active documents, controlling remote devices, workflow and electronic shopping <ref> [Ous95, Whi94] </ref>. Any application in which it makes sense to move the program to the remote data or resource is a candidate for the transportable agent paradigm. The limiting factors are technical. For example there must be sufficient security precautions so that malicious agents can not damage a resource. <p> For example a permit could specify a maximum agent lifetime or a maximum fiscal budget. Agents that attempt to violate the conditions of their permits are terminated immediately <ref> [Whi94] </ref>. <p> Telescript provides the most complete security. All Telescript agents have permits and credentials. Credentials are used to continuously authenticate the identity of an agent's owner while permits limit the scope of an agent's actions and resource usage <ref> [Whi94] </ref>. The Telescript security mechanisms appear to be sufficient. We seek to confirm their sufficiency and either copy or redesign as appropriate. The second and more subtle security issue is that an agent must be protected from a malicious machine or resource. <p> The rear guard scheme quickly becomes complex since an agent that migrates several times will lead to chains or cycles of rear guards. Telescript takes an alternative approach and continuously backs up the internal state of an executing agent to nonvolatile store <ref> [Whi94] </ref>. All agents can be restored from the nonvolatile store if the site crashes. An issue that does not seem to be considered in the TACOMA or Telescript implementation is that there might be other agents that depend on one of the agents on the crashed machine.
Reference: [WVF89] <author> C. Daniel Wolfson, Ellen M. Voorhees, and Maura M. Flatley. </author> <title> Intelligent routers. </title> <booktitle> In Proceedings of the Ninth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 371-376. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1989. </year> <month> 34 </month>
Reference-contexts: The program chooses when and where to migrate. It can suspend its execution at an arbitrary point, transport to another machine and resume execution on the new machine. Although the idea of a program that can move from machine to machine under its own control is not new <ref> [WVF89] </ref>, it is only in the last two years that production-quality systems have been implemented. The most notable is General Magic's Telescript T M [Whi94] which is being used in AT&T's new PersonaLink T M network [Rei94]. <p> Most transportable agent systems support direct communication between agents and avoid this extra communication overhead when 4 exchanging partial results. Transportable agents do not require a connection between the local and remote sites and do not require state information at both sites. This makes transportable agents more fault-tolerant <ref> [WVF89] </ref> and in combination with their low use of network bandwidth, makes them ideally suited to mobile computing [Whi94]. Mobile computing is characterized by low bandwidth, high latency and periods of disconnection from the network. Transportable agents are a convenient paradigm for distributed computing. <p> Runaway agents are impossible since an agent can not continue once its finances are exhausted. TACOMA relies on the underlying UNIX system for additional security. Broker agents provide directory and scheduling services. Intelligent routers support true migration - i.e. the migration of executing scripts <ref> [WVF89] </ref>. An intelligent router is a software analogy for the run card that travels with a manufacturing lot. A run card specifies the steps that need to be taken in order to correctly manufacture the final product as well as the results of previous steps. <p> Routers written in MP2 can communicate with each other, spawn child routers and catch exceptions. MP1 is simpler and does not provide these facilities. A version of the router system that runs on homogeneous machines uses ISIS to detect and recover from node failures and other faults <ref> [WVF89] </ref>. However there is no corresponding fault-tolerant implementation for heterogeneous machines. There apparently is a mechanism for detecting malicious routers but this mechanism is not specified. In addition the current status of the router research is unclear. <p> There apparently is a mechanism for detecting malicious routers but this mechanism is not specified. In addition the current status of the router research is unclear. However intelligent routers have been used in a wafer routing application [Voo91] and have been suggested for a range of workflow applications <ref> [WVF89] </ref> in which certain people or machines must perform certain steps of a task. Intelligent routers are a natural mechanism for workflow applications since they can physically move from machine and machine and person to person as each step in the task 13 is completed. <p> Such a toolkit can be used directly in an application or can be used as the basis for an application-specific toolkit. Third it has been suggested that it should be possible to modify an agent while the agent is executing. <ref> [WVF89] </ref>. It is unclear whether the ability to modify an agent is useful in the general case. However it is certainly useful in network management and workflow applications. Workflow applications require that certain people or machines perform certain steps of the task.
References-found: 34

