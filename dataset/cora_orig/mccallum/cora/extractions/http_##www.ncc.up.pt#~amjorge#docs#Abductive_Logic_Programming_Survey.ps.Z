URL: http://www.ncc.up.pt/~amjorge/docs/Abductive_Logic_Programming_Survey.ps.Z
Refering-URL: http://www.ncc.up.pt/~amjorge/Personal_Repository.html
Root-URL: 
Email: antonis@saturn.cca.ucy.cy  frak,ftg@doc.ic.ac.uk  
Title: Abductive Logic Programming  
Author: A.C. Kakas R.A. Kowalski, F. Toni 
Address: 75 Kallipoleos Street, Nicosia P.O. Box 537, Cyprus.  London SW7 2BZ, UK.  
Affiliation: Department of Computer Science, University of Cyprus,  Department of Computing, Imperial College of Science, Technology and Medicine, 180 Queen's Gate,  
Abstract: This paper is a survey and critical overview of recent work on the extension of Logic Programming to perform Abductive Reasoning (Abductive Logic Programming). We outline the general framework of Abduction and its applications to Knowledge Assimilation and Default Reasoning; and we introduce an argumentation-theoretic approach to the use of abduction as an interpretation for Negation as Failure. We also analyse the links between Abduction and the extension of Logic Programming obtained by adding a form of explicit negation. Finally we discuss the relation between Abduction and Truth Maintenance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Akama, S., </author> <title> Answer set semantics and constructive logic with strong negation. </title> <note> Technical Report (1992) </note>
Reference-contexts: For this reason we use the term "explicit negation" instead. A similar notion has been investigated by Pearce and Wagner [93], who develop an extension of Horn programs by means of Nelson's strong negation. They also suggest the possibility of combining strong negation with NAF. Akama <ref> [1] </ref> argues that the semantics of this combination of strong negation with NAF is equivalent to the answer set semantics for extended logic programs developed by Gelfond and Lifschitz.
Reference: [2] <author> Allemand, D., Tanner, M., Bylander, T., Josephson, J., </author> <title> On the computational complexity of hypothesis assembly. </title> <booktitle> Proc. 10th International Joint Conference on Artificial Intelligence, </booktitle> <address> Milan (1987) 1112-1117 </address>
Reference-contexts: There are other formalisations of abduction. We mention them for completeness, but in the sequel we will concentrate on the logic-based view previously described. * Allemand et al. <ref> [2] </ref> and Reggia [111] present a mathematical char-acterisation, where abduction is defined over sets of observations and hypotheses, in terms of coverings and parsimony. * Levesque [83] gives an account of abduction at the "knowledge level".
Reference: [3] <author> Apt, K.R., Bezem, M., </author> <title> Acyclic programs. </title> <booktitle> Proc. 7th International Conference on Logic Programming, </booktitle> <address> Jerusalem (1990) 579-597 </address>
Reference-contexts: In contrast, all natural representations of the problem in Theorist give incorrect results. As Eshghi and Kowalski [32], Evans [34] and Apt and Bezem <ref> [3] </ref> observe, the Yale shooting problem has the form of a logic program, and interpreting negation in the problem as negation as failure yields only the correct result. This is the case for both the semantics and the proof theory of logic programming.
Reference: [4] <author> Barbuti, R., Mancarella, P., Pedreschi, D., Turini, F., </author> <title> A transformational approach to negation in logic programming. </title> <note> Journal of Logic Programming 8 (1990) 201-228 </note>
Reference-contexts: Because NAF is a special case of abduction, the problem of constructive negation in logic programming <ref> [4, 8, 130] </ref> is a special case of abduction with non-variable-free hypotheses. We have argued that the implementation of abduction needs to be considered within a broader framework of implementing knowledge assimilation (KA).
Reference: [5] <author> Brewka, G., </author> <title> Preferred subtheories: an extended logical framework for default reasoning. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1043-1048 </address>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [5, 9, 39, 52, 102, 106, 128] </ref>. Cox and Pietrzykowski [15] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not be explainable in terms of other explanations.
Reference: [6] <author> Bry, F., </author> <title> Intensional updates: abduction via deduction. </title> <booktitle> Proc. 7th International Conference on Logic Programming, </booktitle> <address> Jerusalem (1990) 561-575 </address>
Reference-contexts: An application that does not necessarily have a direct causal interpretation is knowledge assimilation [67, 72, 80, 89]. The assimilation of a new datum can be performed by adding to the theory new hypotheses that are explanations for the datum. Database view updates <ref> [6, 64] </ref> are an important special case of knowledge assimilation. Update requests are interpreted as observations to be explained. The explanations of the observations are transactions that satisfy the update request. We will discuss knowledge assimilation in greater detail in section 2.
Reference: [7] <author> Casamayor, J., Decker, H., </author> <title> Some proof procedures for computational first-order theories, with an abductive flavour to them. </title> <booktitle> Proc. 1st Compulog-Net Workshop on Logic Programming in Artificial Intelligence, </booktitle> <institution> Imperial College, </institution> <address> London (1992) </address>
Reference-contexts: Their extension modifies the integrity checking method of [76] and deals with arbitrary integrity constraints expressed in the form of denials. 27 Casamayor and Decker <ref> [7] </ref> also develop an abductive proof procedure for NAF. Their proposal combines features of the Eshghi-Kowalski procedure with ancestor resolution.
Reference: [8] <author> Chan, D., </author> <title> Constructive negation based on the completed database. </title> <booktitle> Proc. 5th International Conference and Symposium on Logic Programming, </booktitle> <address> Washington, Seattle (1988) 111-125 </address>
Reference-contexts: Because NAF is a special case of abduction, the problem of constructive negation in logic programming <ref> [4, 8, 130] </ref> is a special case of abduction with non-variable-free hypotheses. We have argued that the implementation of abduction needs to be considered within a broader framework of implementing knowledge assimilation (KA).
Reference: [9] <author> Charniak, E., McDermott, D., </author> <title> Introduction to artificial intelligence. </title> <publisher> (Addison-Wesley, </publisher> <address> Menlo Park, Ca,1985) </address>
Reference-contexts: Abduction is widely used in common-sense reasoning, for instance in diagnosis, to reason from effect to cause <ref> [9, 101] </ref>. We consider here an example drawn from [94]. <p> They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [5, 9, 39, 52, 102, 106, 128] </ref>. Cox and Pietrzykowski [15] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not be explainable in terms of other explanations. <p> Abduction can be used to perform high level vision [15]. The hypotheses are the objects to be recognised, and the observations are partial descriptions of objects. Abduction can be used in natural language understanding to interpret ambiguous sentences <ref> [9, 40, 53, 127] </ref>. The abductive explanations correspond to the various possible interpretations of such sentences. In planning problems, plans can be viewed as explanations of the given goal state to be reached [30, 125].
Reference: [10] <author> Chen, W., Warren, </author> <title> D.S., Abductive logic programming. </title> <type> Technical Report Dept. </type> <institution> of Comp. Science, State Univ. of New York at Stony Brook (1989) </institution>
Reference-contexts: Abduction can be computed in logic programming by extending SLD and SLDNF <ref> [10, 32, 33, 64, 67] </ref>. Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. <p> Semantics and proof procedures for ALP have been proposed by Eshghi and Kowalski [32], Kakas and Mancarella [63] and Chen and Warren <ref> [10] </ref>. Chen and Warren extend the perfect model semantics of Przymusinski [109] to include abducibles and integrity constraints over abducibles. <p> The abductive proof procedure needs to be extended and improved in various ways. One such extension is the generation of non-variable-free hypotheses, containing variables. This problem, which has been studied in part in <ref> [10] </ref>, [30] and [103], and also by [18] with respect to the completion semantics, involves the treatment of the equality predicate as a further abducible.
Reference: [11] <author> Clark,K.L., </author> <title> Negation as failure. Logic and Data Bases, </title> <editor> Gallaire and Minker eds., </editor> <publisher> Plenum, </publisher> <address> New York(1978) 293-322 </address>
Reference-contexts: Resolution-based techniques for computing abduction have also been developed by Demolombe and Fari~nas del Cerro [17] and Gaifman and Shapiro [41]. Abduction can also be applied to logic programming. A general logic program is a set of Horn clauses extended by negation as failure <ref> [11] </ref>, i.e. clauses of the form: A L 1 ; : : : ; L n where each L i is either an atom A i or its negation ~ A i 2 , A is an atom and each variable occurring in the clause is implicitly universally quantified. <p> to indicate both the set of abducible predicates and the set of all their variable-free instances. 7 These definitions have been proposed in the case where the theory is a logic program P by Kowalski and Sadri [76] and Lloyd and Topor [84] respectively, where KB is the Clark completion <ref> [11] </ref> of P . Another view of integrity constraints [60, 63, 74, 116, 117] regards these as epistemic or metalevel statements about the content of the database. In this case the integrity constraints are understood as statements at a different level from those in the knowledge base. <p> Default reasoning can also be performed with the use of negation as failure (NAF) <ref> [11] </ref> in general logic programs. NAF provides a natural and powerful mechanism for performing non-monotonic and default reasoning. As we have already mentioned, it provides a simple solution to the Yale shooting problem. <p> An alternative approach is presented by Console, Dupre and Torasso [13]. Here clauses of programs are interpreted as if-halves of if-and-only-if definitions that are obtained from the completion of the program <ref> [11] </ref> restricted to non-abducible predicates. Forward reasoning with the only-if-halves of these definitions, starting from the observation to be explained, generates abduc-tive hypotheses deductively. <p> Console, Dupre and Torasso extend this approach to deal with non-propositional abductive logic programs. In this more general case an equality theory, identical to the one presented in <ref> [11] </ref>, is needed; and in the definition of explanation formula, the notion of F being more specific than F 0 requires that F ! F 0 be a logical consequence of such an equality theory and that F 0 ! F not be a consequence of the equality theory.
Reference: [12] <author> Console, L., Dupre, D., Torasso, P. </author> <title> A Theory for diagnosis for incomplete causal models. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1311-1317 </address>
Reference-contexts: Abduction can be used to generate causal explanations for fault diagnosis (see for example <ref> [12, 108] </ref>). In medical diagnosis, for example, the candidate hypotheses are the possible causes (diseases), and the observations are the symptoms to be explained [105, 111]. Abduction can also be used for 8 model-based diagnosis [31, 115].
Reference: [13] <author> Console, L., Dupre, D., Torasso, P. </author> <title> On the relationship between abduction and deduction. </title> <note> Journal of Logic and Computation 2(5) (1991) 661-690 </note>
Reference-contexts: An alternative approach is presented by Console, Dupre and Torasso <ref> [13] </ref>. Here clauses of programs are interpreted as if-halves of if-and-only-if definitions that are obtained from the completion of the program [11] restricted to non-abducible predicates. Forward reasoning with the only-if-halves of these definitions, starting from the observation to be explained, generates abduc-tive hypotheses deductively.
Reference: [14] <author> Console, L., Saitta, L., </author> <title> Abduction, induction and inverse resolution. </title> <booktitle> Proc. 1st Compulog-Net Workshop on Logic Programming in Artificial Intelligence, </booktitle> <institution> Imperial College, </institution> <address> London (1992) </address>
Reference-contexts: In fact, these two conditions (1) and (2) alone are too weak to capture Peirce's notion. In particular, additional restrictions on are needed to distinguish abductive explanations from inductive generalisations <ref> [14] </ref>. Moreover, we also need to restrict so that it conveys some reason why the observations hold, e.g. we do not want to explain one effect in terms of another effect, but only in terms of some cause.
Reference: [15] <author> Cox, P. T., Pietrzykowski, T., </author> <title> Causes for events: their computation and applications. </title> <booktitle> Proc. 8th International Conference on Automated Deduction, CADE '86 (1992) 608-621 </booktitle>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations [5, 9, 39, 52, 102, 106, 128]. Cox and Pietrzykowski <ref> [15] </ref> identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not be explainable in terms of other explanations. For example, in example 1.1 the explanation grass-is-wet for the observation shoes-are-wet is not basic, whereas the alternative explanations rained-last-night sprinkler-was-on are. <p> Various authors have suggested the use of top-down, goal-oriented computation, based on the use of deduction to drive the generation of abductive hypotheses. Cox and Pietrzykowski <ref> [15] </ref> construct hypotheses from the "dead ends" of linear resolution proofs. Finger and Genesereth [36] generate "deductive solutions to design problems" using the "residue" left behind in resolution proofs. Poole, Goebel and Aleliunas [107] also use linear resolution to generate hypotheses. In contrast, the ATMS [71] computes abductive explanations bottom-up. <p> Abduction can be used to perform high level vision <ref> [15] </ref>. The hypotheses are the objects to be recognised, and the observations are partial descriptions of objects. Abduction can be used in natural language understanding to interpret ambiguous sentences [9, 40, 53, 127]. The abductive explanations correspond to the various possible interpretations of such sentences.
Reference: [16] <author> Decker, H., </author> <title> Integrity enforcement on deductive databases. </title> <booktitle> Proc. EDS '86, </booktitle> <address> Charleston, SC (1986) 271-285 </address>
Reference-contexts: For each such semantics, we have a specification of the integrity checking problem. Although the different views of integrity satisfaction are conceptually very different, the integrity checking procedures based upon these views are not very different in practice (e.g. <ref> [16, 76, 84] </ref>). They are mainly concerned with avoiding the inefficiency which arises if all the integrity constraints are retested after each update.
Reference: [17] <author> Demolombe, R., Fari~nas del Cerro, L., </author> <title> An inference rule for hypotheses generation. </title> <booktitle> Proc. 12th International Joint Conference on Artificial Intelligence, </booktitle> <address> Sidney (1991) 152-157 </address>
Reference-contexts: The ATMS can be regarded as a form of hyper-resolution, augmented with subsumption, for propositional logic programs [118]. Lamma and Mello [81] have developed an extension of the ATMS for the non-propositional case. Resolution-based techniques for computing abduction have also been developed by Demolombe and Fari~nas del Cerro <ref> [17] </ref> and Gaifman and Shapiro [41]. Abduction can also be applied to logic programming.
Reference: [18] <author> Denecker, M., De Schreye, D., </author> <title> Temporal reasoning with abductive event calculus. </title> <booktitle> Proc. 1st Compulog-Net Workshop on Logic Programming in Artificial Intelligence, </booktitle> <institution> Imperial College, </institution> <address> London (1992) </address>
Reference-contexts: The abductive proof procedure needs to be extended and improved in various ways. One such extension is the generation of non-variable-free hypotheses, containing variables. This problem, which has been studied in part in [10], [30] and [103], and also by <ref> [18] </ref> with respect to the completion semantics, involves the treatment of the equality predicate as a further abducible. Because NAF is a special case of abduction, the problem of constructive negation in logic programming [4, 8, 130] is a special case of abduction with non-variable-free hypotheses.
Reference: [19] <author> Denecker, M., De Schreye, D., </author> <title> On the duality of abduction and model generation. </title> <booktitle> Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1992) 650-657 </address>
Reference-contexts: As a consequence, the explanation formula is unique up to equivalence in the equality theory, and the proof procedure is more complex than for the propositional case, because it needs to generate consequences of the equality theory. Denecker and De Schreye <ref> [19] </ref> compare the search spaces for reasoning backward using the if-halves of definitions with those for reasoning forward using the only-if-halves for logic programs without NAF.
Reference: [20] <author> Doyle, J., </author> <title> A truth maintenance system. </title> <booktitle> Artificial Intelligence 12 (1979) 231-272 </booktitle>
Reference-contexts: The method is a bottom-up computation based upon the TMS procedure of <ref> [20] </ref>. Although the computation is not goal-directed, goals (or queries) can be represented as denials and be treated as integrity constraints. <p> The semantics of a TM system can accordingly be understood in terms of the semantics of the corresponding propositional logic program with abducibles and integrity constraints. The two most popular systems are the justification-based TM system (JTMS) of Doyle <ref> [20] </ref> and the assumption-based TM system (ATMS) of deKleer [71]. 6.1 Justification-based truth maintenance A justification in a JTMS can be written in the form p p 1 ; : : : ; p n ; ~ p n+1 ; : : : ; ~ p m ; expressing that p
Reference: [21] <author> Doyle, J., </author> <title> Rational belief revision. </title> <booktitle> Proc. 2nd International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> Cam-bridge, Mass. </address> <year> (1991) </year> <month> 163-174 </month>
Reference-contexts: Both of these updates satisfy the integrity constraints. However, only the first update satisfies the integrity constraints if we are given the further update insert mother (Joan; Bob): The general problem of belief revision has been studied formally in <ref> [42, 91, 92, 21] </ref>. <p> We have seen that the process of belief revision also needs to be considered within a KA context. In particular, it could be useful to investigate relationships between the belief revision frameworks of <ref> [21, 42, 91, 92] </ref> and various integrity constraint checking and restoration procedures. The extension of logic programming to include integrity constraints is useful both for abductive logic programming and for deductive databases applications.
Reference: [22] <author> Dung, </author> <title> P.M., Negation as hypothesis: an abductive foundation for logic programming Proc. </title> <booktitle> 8th International Conference on Logic Programming, </booktitle> <address> Paris (1991) 3-17 67 </address>
Reference-contexts: They relax this requirement and consider partial or three-valued stable models instead. In the context of the abductive semantics of NAF this is an argument against the disjunctive integrity constraints. An abductive semantics of NAF without disjunctive integrity constraints has been proposed by Dung <ref> [22] </ref>. The abductive proof procedure is sound with respect to this improved semantics. Satoh and Iwayama [122], on the other hand, show how to extend the abductive proof procedure of [33] to deal correctly with the stable model semantics. <p> Finally, we note that, in order to capture the semantics more closely for programs such as p p where ~ p holds, we can define a non-effective extension of the proof procedure, that allows infinite failure in the consistency phases. 4.3 An argumentation-theoretic interpretation Dung <ref> [22] </ref> replaces the disjunctive integrity constraints by a weaker requirement that the set of negative hypotheses be maximal. Unfortunately, simply replacing the disjunctive integrity constraints by maximality does not work, as shown in the following example. <p> Thus a preferred extension can be thought of as a maximal consistent set of hypotheses that contains its own defence against all attacks. In <ref> [22] </ref> a consistent set of hypotheses (not necessarily maximal) satisfying the property of containing its own defence against all attacks is said to be acceptable (to P fl ). <p> We have seen, in particular, that an implementation which is incorrect under one semantics (e.g. [33]) can be correct under another (e.g. <ref> [22] </ref>). We have also introduced an argumentation-theoretic interpretation for the semantics of abduction applied to NAF, and we have seen that this intepretation can help to understand the relationships between different semantics. Despite the recent advances in the semantics of NAF there is still room for improvement.
Reference: [23] <author> Dung, P.M., Ruamviboonsuk, P., </author> <title> Well-founded reasoning with clas-sical negation. </title> <booktitle> Proc. 1st International Workshop on Logic Programming and Nonmonotonic Reasoning, </booktitle> <editor> Nerode, Marek and Subrahma-nian eds., </editor> <address> Washington DC (1991) 120-135 </address>
Reference-contexts: In the example above we can restore consistency by rejecting the NAF assumption ~ bird (T om) even though bird (T om) does not hold. We then get the consistent set fbat (T om); f ly (T om)g. This problem has been studied in <ref> [23] </ref> and [97]. Both of these studies are primarily concerned with the related problem of inconsistency of the well-founded semantics when applied to extended logic programs [110]. To deal with the problem of inconsistency in extended logic programs, Dung [23] applies the preferred extension semantics to a new abductive framework derived <p> This problem has been studied in <ref> [23] </ref> and [97]. Both of these studies are primarily concerned with the related problem of inconsistency of the well-founded semantics when applied to extended logic programs [110]. To deal with the problem of inconsistency in extended logic programs, Dung [23] applies the preferred extension semantics to a new abductive framework derived from an extended logic program. An extended logic program P is first transformed into an ordinary general logic program P 0 by renaming explicitly negated literals : p (t) by positive literals p 0 (t). <p> In fact Pereira, Aparicio and Alferes have also used this method to study counterfactual reasoning [99]. Both methods, <ref> [23] </ref> and [97], can deal only with inconsistencies that can be attributed to NAF hypotheses, as shown by the following example.
Reference: [24] <author> Dung, </author> <title> P.M., An abductive foundation for non-monotonic truth maintenance. </title> <booktitle> Proc. 1st World Conference on Fundamentals of Artificial Intelligence, Paris, </booktitle> <editor> de Glas ed. </editor> <year> (1991) </year>
Reference-contexts: The JTMS can also be understood in terms of abduction using the abduc-tive approach to the semantics of NAF, as shown in <ref> [24, 48, 65] </ref>. This has the advantage that the nogoods of the JTMS can be interpreted as integrity constraints of the abductive framework.
Reference: [25] <author> Dung, </author> <title> P.M., Acyclic disjunctive logic programs with abductive procedure as proof procedure. </title> <booktitle> Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1992) 555-561 </address>
Reference-contexts: Their extension modifies the integrity checking method of [76] and deals with arbitrary integrity constraints expressed in the form of denials. 27 Casamayor and Decker [7] also develop an abductive proof procedure for NAF. Their proposal combines features of the Eshghi-Kowalski procedure with ancestor resolution. Dung <ref> [25] </ref> shows that in certain cases disjunctions such as p _ q can be represented by clauses of the form p ~ q and for these cases the Eshghi-Kowalski procedure is adequate.
Reference: [26] <author> Dung, </author> <title> P.M., An abductive procedure for disjunctive logic programming. </title> <institution> Technical Report Asian Institute of Technology (1992) </institution>
Reference-contexts: For the more general case in which this representation is not adequate and disjunction needs to be represented explicitly, Dung <ref> [26] </ref> extends the Eshghi-Kowalski procedure by using resolution-based techniques similar to those employed in [36].
Reference: [27] <author> Dung, </author> <title> P.M., </title> <type> Personal Communication (1992) </type>
Reference-contexts: An "argumentation-theoretic" interpretation for the semantics of NAF in logic programming has also been developed by Geffner [44]. However, his interpretation is only an approximation to the definition of acceptability given above and is equivalent to the well-founded semantics <ref> [27] </ref>. A similar approximation to the notion of acceptability has also been proposed by 31 Simari and Loui [126], who define an argumentation-theoretic framework for default reasoning in general.
Reference: [28] <author> Dung, P.M., Kakas, A.C., Mancarella, P., </author> <title> Negation as failure revisited. </title> <note> Technical Report (1992) </note>
Reference-contexts: Thus the well-founded semantics is 29 minimalist and sceptical, whereas the preferred extension semantics is max--imalist and credulous. A fixpoint construction of the preferred extension semantics is given in <ref> [28] </ref>. Kakas and Mancarella [69, 70] propose a modification of the preferred extension semantics. Their proposal can be illustrated by the following example. Example 4.6 In the abductive framework corresponding to the program p ~ q consider the set of hypotheses = fp fl g. <p> Despite the recent advances in the semantics of NAF there is still room for improvement. One possibility is to explore further the direction set in <ref> [28] </ref> and [70] which characterises the acceptability of a set of hypotheses recursively in terms of the non-acceptability of all attacks against . Another is to identify an appropriate concept of maximal consistency, perhaps along the lines of the retractability semantics suggested in [77].
Reference: [29] <author> Elkan, C., </author> <title> A rational reconstruction of non-monotonic truth maintenance systems. </title> <booktitle> Artificial Intelligence 43 (1990) 219-234 </booktitle>
Reference-contexts: Several authors have observed that the JTMS can be given a semantics corresponding to the semantics of logic programs, by interpreting justifications as propositional logic program clauses, and interpreting ~ p i as NAF of p i . The papers <ref> [29, 48, 65, 100] </ref>, in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. <p> The papers [29, 48, 65, 100], in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. Several authors <ref> [29, 38, 65, 112] </ref>, exploiting the interpretation of stable models as autoepistemic expansions [45], have shown a correspondence between well-founded labellings and stable expansions of the set of justifications viewed as autoepistemic theories.
Reference: [30] <author> Eshghi, K., </author> <title> Abductive planning with event calculus. </title> <booktitle> Proc. 5th International Conference and Symposium on Logic Programming, </booktitle> <address> Washing-ton, Seattle (1988) 562-579 </address>
Reference-contexts: Abduction can be used in natural language understanding to interpret ambiguous sentences [9, 40, 53, 127]. The abductive explanations correspond to the various possible interpretations of such sentences. In planning problems, plans can be viewed as explanations of the given goal state to be reached <ref> [30, 125] </ref>. These applications of abduction can all be understood as generating hypotheses which are causes for observations which are effects. An application that does not necessarily have a direct causal interpretation is knowledge assimilation [67, 72, 80, 89]. <p> T 1 &lt; T 2 ; initiates (E; P ); persists (T 1 ; P; T 2 ): 10 New information about the predicate holds-at can be assimilated by adding an explanation in terms of some event that generates this property together with an appropriate assumption that the property persists <ref> [30, 62, 125] </ref>. This has the additional effect that the new KB will imply that the property holds until it is terminated in the future [125]. This way of assimilating new information can also be used to resolve conflicts between the current KB and the new information [62, 125]. <p> The abductive proof procedure needs to be extended and improved in various ways. One such extension is the generation of non-variable-free hypotheses, containing variables. This problem, which has been studied in part in [10], <ref> [30] </ref> and [103], and also by [18] with respect to the completion semantics, involves the treatment of the equality predicate as a further abducible.
Reference: [31] <author> Eshghi, K., </author> <title> Diagnoses as stable models. </title> <booktitle> Proc. 1st International Workshop on Principles of Diagnosis, </booktitle> <address> Menlo Park, Ca (1990) </address>
Reference-contexts: Abduction can be used to generate causal explanations for fault diagnosis (see for example [12, 108]). In medical diagnosis, for example, the candidate hypotheses are the possible causes (diseases), and the observations are the symptoms to be explained [105, 111]. Abduction can also be used for 8 model-based diagnosis <ref> [31, 115] </ref>. In this case the theory describes the "nor-mal" behaviour of the system, and the task is to find a set of hypotheses of the form "some component A is not normal" that explains why the be-haviour of the system is not normal.
Reference: [32] <author> Eshghi, K., Kowalski, R.A., </author> <title> Abduction through deduction. </title> <institution> Technical Report Department of Computing, Imperial College, </institution> <address> London (1988) </address>
Reference-contexts: Abduction can be computed in logic programming by extending SLD and SLDNF <ref> [10, 32, 33, 64, 67] </ref>. Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. <p> Default reasoning concerns the use of general rules to derive information in the absence of contradictions. In the application of abduction to default reasoning, conclusions are viewed as observations to be explained by means of assumptions which hold by default unless a contradiction can be shown <ref> [32, 104] </ref>. As Poole [104] argues, the use of abduction avoids the need to develop a non-classical, non-monotonic logic for default reasoning. In section 3 we will further discuss the use of abduction for default reasoning in greater detail. <p> In contrast, all natural representations of the problem in Theorist give incorrect results. As Eshghi and Kowalski <ref> [32] </ref>, Evans [34] and Apt and Bezem [3] observe, the Yale shooting problem has the form of a logic program, and interpreting negation in the problem as negation as failure yields only the correct result. This is the case for both the semantics and the proof theory of logic programming. <p> This is the case for both the semantics and the proof theory of logic programming. Moreover, <ref> [32] </ref> and [62] show how to retain the correct result when negation as failure is interpreted as a form of abduction. <p> This interpretation was presented in <ref> [32] </ref> and [33], where negative literals are interpreted as abductive hypotheses that can be assumed to hold provided that, together with the program, they satisfy a canonical set of integrity constraints. <p> Semantics and proof procedures for ALP have been proposed by Eshghi and Kowalski <ref> [32] </ref>, Kakas and Mancarella [63] and Chen and Warren [10]. Chen and Warren extend the perfect model semantics of Przymusinski [109] to include abducibles and integrity constraints over abducibles.
Reference: [33] <author> Eshghi, K., Kowalski, R.A., </author> <title> Abduction compared with negation by failure. </title> <booktitle> Proc. 6th International Conference on Logic Programming, </booktitle> <month> Lis-bon </month> <year> (1989) </year> <month> 234-255 </month>
Reference-contexts: Abduction can be computed in logic programming by extending SLD and SLDNF <ref> [10, 32, 33, 64, 67] </ref>. Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. <p> In [76] this assumption is exploited by reasoning forward from the updates. This idea is exploited for the purpose of checking the satisfaction of abductive hypotheses in <ref> [33, 66, 67] </ref>. Although this procedure was originally formulated for the consistency view of constraint satisfaction, it has proved equally appropriate for the semantics of integrity constraints in abductive logic programming. 1.3 Applications In this section we briefly describe some of the applications of abduction in AI. <p> This interpretation was presented in [32] and <ref> [33] </ref>, where negative literals are interpreted as abductive hypotheses that can be assumed to hold provided that, together with the program, they satisfy a canonical set of integrity constraints. <p> we define the meaning of the integrity constraints I fl as follows: An extension P fl [ (which is a Horn theory) of P fl satisfies I fl if and only if for every variable-free atom t, P fl [ 6j= t ^ t fl ; and Eshghi and Kowalski <ref> [33] </ref> show that there is a one to one correspondence between stable models [45] of P and abductive extensions of P fl . <p> The Theorist framework of [104, 107] provides such an implementation of abduction by means of a resolution based proof procedure. In their study of NAF through abduction Eshghi and Kowalski <ref> [33] </ref> have defined an abductive proof procedure for NAF in logic programming. We will describe this procedure in some detail as it also serves as the basis for computing abductive explanations more generally within logic programming with other abducibles and integrity constraints (see section 5). <p> In general, whenever a hypothesis is tested for integrity, we can add the hypothesis to either at the beginning or 26 at the end of the consistency phase. When this addition is done at the beginning (as originally defined in <ref> [33] </ref>) this extra information can be used in any subordinate abductive phase. In this example, the hypothesis p fl is used in the subordinate abductive proof of q to justify the failure of q fl and consequently to render p fl acceptable. <p> So, as Eshghi and Kowalski <ref> [33] </ref> show by means of this example, the abduc-tive proof procedure is not always sound with respect to the above abductive semantics of NAF. It is possible, however, to argue that it is the semantics and not the proof procedure that is at fault. <p> An abductive semantics of NAF without disjunctive integrity constraints has been proposed by Dung [22]. The abductive proof procedure is sound with respect to this improved semantics. Satoh and Iwayama [122], on the other hand, show how to extend the abductive proof procedure of <ref> [33] </ref> to deal correctly with the stable model semantics. Their extension modifies the integrity checking method of [76] and deals with arbitrary integrity constraints expressed in the form of denials. 27 Casamayor and Decker [7] also develop an abductive proof procedure for NAF. <p> This property of the proof procedure and its relationship with the semantics needs to be investigated further. 5.2 Abductive proof procedure for ALP In [64, 65, 66], proof procedures are given to compute abductive explanations in ALP. These extend the abductive proof procedure for NAF <ref> [33] </ref> described in section 4.2, retaining the basic structure which interleaves an abductive phase that generates and collects abductive hypotheses with a 36 2 = fq fl ; rg r q p consistency phase that incrementally checks these hypotheses for integrity. <p> We have seen the importance of clarifying the semantics of abduction and of defining a semantics that helps to unify abduction, NAF, and default reasoning within a common framework. We have seen, in particular, that an implementation which is incorrect under one semantics (e.g. <ref> [33] </ref>) can be correct under another (e.g. [22]). We have also introduced an argumentation-theoretic interpretation for the semantics of abduction applied to NAF, and we have seen that this intepretation can help to understand the relationships between different semantics.
Reference: [34] <author> Evans, </author> <title> C.A., Negation as failure as an approach to the Hanks and McDermott problem. </title> <booktitle> Proc. 2nd International Symposium on Artificial intelligence, Monterrey, </booktitle> <address> Mexico (1989) 68 </address>
Reference-contexts: In contrast, all natural representations of the problem in Theorist give incorrect results. As Eshghi and Kowalski [32], Evans <ref> [34] </ref> and Apt and Bezem [3] observe, the Yale shooting problem has the form of a logic program, and interpreting negation in the problem as negation as failure yields only the correct result. This is the case for both the semantics and the proof theory of logic programming.
Reference: [35] <author> Evans, </author> <title> C.A., Kakas, A.C., </title> <booktitle> Hypothetico-deductive reasoning. Proc. In--ternational Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1992) 546-554 </address>
Reference-contexts: For example Sattar and Goebel [123] use "crucial literals" to discriminate between two mutually incompatible explanations. When the crucial literals are tested, one of the explanations is rejected. More generally Evans and Kakas <ref> [35] </ref> use the notion of corroboration to select explanations. An explanation fails to be corroborated if some of its logical consequences are not observed.
Reference: [36] <author> Finger, J.J., Genesereth, </author> <title> M.R., RESIDUE: a deductive approach to design synthesis. </title> <type> Technical Report no. </type> <institution> CS-85-1035, Stanford University (1985) </institution>
Reference-contexts: Various authors have suggested the use of top-down, goal-oriented computation, based on the use of deduction to drive the generation of abductive hypotheses. Cox and Pietrzykowski [15] construct hypotheses from the "dead ends" of linear resolution proofs. Finger and Genesereth <ref> [36] </ref> generate "deductive solutions to design problems" using the "residue" left behind in resolution proofs. Poole, Goebel and Aleliunas [107] also use linear resolution to generate hypotheses. In contrast, the ATMS [71] computes abductive explanations bottom-up. <p> For the more general case in which this representation is not adequate and disjunction needs to be represented explicitly, Dung [26] extends the Eshghi-Kowalski procedure by using resolution-based techniques similar to those employed in <ref> [36] </ref>.
Reference: [37] <author> Fujita, M., Hasegawa, R., </author> <title> A model generation theorem prover in KL1 using a ramified-stack algorithm. </title> <booktitle> Proc. 8th International Conference on Logic Programming, </booktitle> <address> Paris (1991) 535-548 </address>
Reference-contexts: a 0 q 14 A description of this work can also be found in [51]. 56 where a 0 is a new atom that stands for the complement of a, as expressed by the integrity constraint : (a ^ a 0 ): (7) A model generator (like SATCHMO or MGTP <ref> [37] </ref>) can then be applied to compute all the minimal models that satisfy the integrity constraints (7). 6 Abduction and Truth Maintenance In this section we will consider the relationship between truth maintenance (TM) and abduction. TM systems have historically been presented from a procedural point of view.
Reference: [38] <author> Fujiwara, Y., Honiden, S., </author> <title> Relating the TMS to Autoepistemic Logic. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1199-1205 </address>
Reference-contexts: The papers [29, 48, 65, 100], in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. Several authors <ref> [29, 38, 65, 112] </ref>, exploiting the interpretation of stable models as autoepistemic expansions [45], have shown a correspondence between well-founded labellings and stable expansions of the set of justifications viewed as autoepistemic theories.
Reference: [39] <author> Gabbay, </author> <title> D.M., Abduction in labelled deductive systems. A conceptual abstract. </title> <booktitle> Proc. of the European Conference on Symbolic and Quantitative Approaches for uncertainty '91, </booktitle> <volume> LNCS 548, </volume> <editor> eds. R. Kruse and P. </editor> <publisher> Siegel (1991) Springer Verlag, </publisher> <pages> 3-12 </pages>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [5, 9, 39, 52, 102, 106, 128] </ref>. Cox and Pietrzykowski [15] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not be explainable in terms of other explanations.
Reference: [40] <author> Gabbay, </author> <title> D.M., Kempson, R.M., Labelled abduction and relevance reasoning. Workshop on Non-Standard Queries and Non-Standard Answers, </title> <address> Toulose, France (1991) </address>
Reference-contexts: Abduction can be used to perform high level vision [15]. The hypotheses are the objects to be recognised, and the observations are partial descriptions of objects. Abduction can be used in natural language understanding to interpret ambiguous sentences <ref> [9, 40, 53, 127] </ref>. The abductive explanations correspond to the various possible interpretations of such sentences. In planning problems, plans can be viewed as explanations of the given goal state to be reached [30, 125].
Reference: [41] <author> Gaifman, H., Shapiro, E., </author> <title> Proof theory and semantics of logic programming. </title> <booktitle> Proc. LICS'89, </booktitle> <publisher> IEEE Computer Society Press (1989) 50-62 </publisher>
Reference-contexts: Lamma and Mello [81] have developed an extension of the ATMS for the non-propositional case. Resolution-based techniques for computing abduction have also been developed by Demolombe and Fari~nas del Cerro [17] and Gaifman and Shapiro <ref> [41] </ref>. Abduction can also be applied to logic programming.
Reference: [42] <author> Gardenfors, P., </author> <title> Knowledge in flux: modeling the dynamics of epistemic states. </title> <publisher> (MIT Press, </publisher> <address> Cambridge, Ma,1988) </address>
Reference-contexts: Both of these updates satisfy the integrity constraints. However, only the first update satisfies the integrity constraints if we are given the further update insert mother (Joan; Bob): The general problem of belief revision has been studied formally in <ref> [42, 91, 92, 21] </ref>. <p> We have seen that the process of belief revision also needs to be considered within a KA context. In particular, it could be useful to investigate relationships between the belief revision frameworks of <ref> [21, 42, 91, 92] </ref> and various integrity constraint checking and restoration procedures. The extension of logic programming to include integrity constraints is useful both for abductive logic programming and for deductive databases applications.
Reference: [43] <author> Geffner, H., </author> <title> Casual theories for non-monotonic reasoning. </title> <booktitle> Proc. AAAI '90 (1990) </booktitle>
Reference-contexts: Example 5.10 It is not possible to restore consistency by removing NAF hypotheses given the program: p However, Inoue [55, 56] suggests a general method for restoring consistency, which is applicable to this case. This method (see also section 5.8) is based on <ref> [43] </ref> and [104] and consists in isolating inconsistencies by finding maximally consistent subprograms. In this approach a knowledge system is represented by a pair (P; H), where: 47 1. P and H are both extended logic programs, 2. P represents a set of facts, 3. <p> A more direct approach to the problem of treating positive and negative predicates symmetrically in default reasoning is presented by Inoue [55, 56] following the methods of <ref> [43] </ref> and [104] (see section 5.6 for a discussion). This work is another interesting application of the notion of maximal consistency to extend logic programming for default reasoning.
Reference: [44] <author> Geffner, H., </author> <title> Beyond negation as failure. </title> <booktitle> Proc. 2nd International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> Cambridge, Mass. </address> <year> (1991) </year> <month> 218-229 </month>
Reference-contexts: Thus, the stable theories are those which are maximally acceptable to ;, where acceptability is defined by this approximation to the recursive definition. An "argumentation-theoretic" interpretation for the semantics of NAF in logic programming has also been developed by Geffner <ref> [44] </ref>. However, his interpretation is only an approximation to the definition of acceptability given above and is equivalent to the well-founded semantics [27].
Reference: [45] <author> Gelfond, M., Lifschitz, V., </author> <title> The Stable model semantics for logic programs. </title> <booktitle> Proc. 5th International Conference and Symposium on Logic Programming, </booktitle> <address> Washington, Seattle (1988) 1070-1080 69 </address>
Reference-contexts: extension P fl [ (which is a Horn theory) of P fl satisfies I fl if and only if for every variable-free atom t, P fl [ 6j= t ^ t fl ; and Eshghi and Kowalski [33] show that there is a one to one correspondence between stable models <ref> [45] </ref> of P and abductive extensions of P fl . <p> The papers [29, 48, 65, 100], in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. Several authors [29, 38, 65, 112], exploiting the interpretation of stable models as autoepistemic expansions <ref> [45] </ref>, have shown a correspondence between well-founded labellings and stable expansions of the set of justifications viewed as autoepistemic theories. The JTMS can also be understood in terms of abduction using the abduc-tive approach to the semantics of NAF, as shown in [24, 48, 65].
Reference: [46] <author> Gelfond, M., Lifschitz, V., </author> <title> Logic programs with classical negation. </title> <booktitle> Proc. 7th International Conference on Logic Programming, </booktitle> <address> Jerusalem (1990) 579-597 </address>
Reference-contexts: extend logic programs to allow explicit negation in the conclusions of clauses. (As we shall see later, in sections 5.7 and 5.8, this is related to the use of integrity constraints expressed in the form of denials.) In this section we will discuss the extension proposed by Gelfond and Lifschitz <ref> [46] </ref>. This extension is based on the stable model semantics, and can be understood, therefore, in terms of abduction, as we have already seen. <p> This negation denoted by ":" is called "classical negation" in <ref> [46] </ref>. However, as we will see below, because the contrapositives of extended clauses do not hold, the term "classical negation" is inappropriate. For this reason we use the term "explicit negation" instead. <p> The corresponding answer sets of P contain explicit negative literals : p (t) wherever the stable models contain p 0 (t). In <ref> [46] </ref> the answer sets are defined directly on the extended program by modifying the definition of the stable model semantics.
Reference: [47] <author> Goebel, R., Furukawa, K., Poole, D., </author> <title> Using definite clauses and integrity constraints as the basis for a theory formation approach to diagnostic reasoning. </title> <booktitle> Proc. 3rd International Conference on Logic Programming, London (1986) Springer Verlag Lecture Notes in Computer Science 225, </booktitle> <pages> 211-222 </pages>
Reference-contexts: it is possible to reason with it by regarding it as a knowledge system of the form (;; P ): For example 5.10 this will give two alternative semantics, fpg or f:pg. 5.7 Abduction as retractability An alternative way of viewing abduction, which emphasises the defeasibility of abducibles, is retractability <ref> [47] </ref>. Instead of regarding abducibles as atoms to be consistently added to a theory, they can be considered as assertions in the theory to be retracted in the presence of contradictions until consistency (or integrity) is restored (c.f. section 5.6).
Reference: [48] <author> Giordano, L., Martelli, A., </author> <title> Generalized stable model semantics, truth maintenance and conflict resolution. </title> <booktitle> Proc. 7th International Conference on Logic Programming, </booktitle> <address> Jerusalem (1990) 427-411 </address>
Reference-contexts: Several authors have observed that the JTMS can be given a semantics corresponding to the semantics of logic programs, by interpreting justifications as propositional logic program clauses, and interpreting ~ p i as NAF of p i . The papers <ref> [29, 48, 65, 100] </ref>, in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. <p> The JTMS can also be understood in terms of abduction using the abduc-tive approach to the semantics of NAF, as shown in <ref> [24, 48, 65] </ref>. This has the advantage that the nogoods of the JTMS can be interpreted as integrity constraints of the abductive framework.
Reference: [49] <author> Hanks, S., McDermott, D., </author> <title> Default reasoning, non-monotonic logics, and the frame problem. </title> <booktitle> Proc. 8th AAAI '86, </booktitle> <address> Philadelphia (1986) 328-333 </address>
Reference-contexts: But, more importantly, there are still other examples where the Theorist approach arguably gives the wrong result. The most important of these is the now notorious Yale shooting problem of <ref> [49, 50] </ref>.
Reference: [50] <author> Hanks, S., McDermott, D., </author> <title> Non-monotonic logics and temporal projection. </title> <booktitle> Artificial Intelligence 33 (1987) </booktitle>
Reference-contexts: But, more importantly, there are still other examples where the Theorist approach arguably gives the wrong result. The most important of these is the now notorious Yale shooting problem of <ref> [49, 50] </ref>.
Reference: [51] <author> Hasegawa, R., Fujita, M., </author> <title> Parallel theorem provers and their applications. </title> <booktitle> Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1992) 132-154 </address>
Reference-contexts: Inoue et al. translate each abductive logic program rule of the form p q; a where a is abducible, into a rule of a disjunctive logic program (p ^ a) _ a 0 q 14 A description of this work can also be found in <ref> [51] </ref>. 56 where a 0 is a new atom that stands for the complement of a, as expressed by the integrity constraint : (a ^ a 0 ): (7) A model generator (like SATCHMO or MGTP [37]) can then be applied to compute all the minimal models that satisfy the integrity
Reference: [52] <author> Hobbs, J.R., Stickel, M., Appelt, D., Martin, P., </author> <title> Interpretation as abduction. </title> <type> Technical Report 499, </type> <institution> Artificial Intelligence Center, Computing and Engineering Sciences Division, </institution> <address> Menlo Park, Ca (1990) </address>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [5, 9, 39, 52, 102, 106, 128] </ref>. Cox and Pietrzykowski [15] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not be explainable in terms of other explanations.
Reference: [53] <author> Hobbs, J.R., </author> <title> An integrated abductive framework for discourse interpretation. </title> <booktitle> Proc. AAAI Symposium on Automated Abduction, </booktitle> <address> Stanford (1990) 10-12 </address>
Reference-contexts: Abduction can be used to perform high level vision [15]. The hypotheses are the objects to be recognised, and the observations are partial descriptions of objects. Abduction can be used in natural language understanding to interpret ambiguous sentences <ref> [9, 40, 53, 127] </ref>. The abductive explanations correspond to the various possible interpretations of such sentences. In planning problems, plans can be viewed as explanations of the given goal state to be reached [30, 125].
Reference: [54] <author> Inoue, K., </author> <title> An abductive procedure for the CMS/ATMS. </title> <booktitle> Proc. Eu-ropean Conference on Artificial Intelligence, ECAI '90 International Workshop on Truth Maintenance, Stockholm, Springer Verlag Lecture notes in Computer Science (1990) </booktitle>
Reference-contexts: This abductive interpretation of ATMS has been developed further by Inoue <ref> [54] </ref>, who gives 60 an abductive proof procedure for the ATMS.
Reference: [55] <author> Inoue, K., </author> <title> Hypothetical reasoning in logic programs. </title> <type> Technical Report ICOT 607, </type> <address> Tokyo (1991) 70 </address>
Reference-contexts: Both methods, [23] and [97], can deal only with inconsistencies that can be attributed to NAF hypotheses, as shown by the following example. Example 5.10 It is not possible to restore consistency by removing NAF hypotheses given the program: p However, Inoue <ref> [55, 56] </ref> suggests a general method for restoring consistency, which is applicable to this case. This method (see also section 5.8) is based on [43] and [104] and consists in isolating inconsistencies by finding maximally consistent subprograms. <p> A more direct approach to the problem of treating positive and negative predicates symmetrically in default reasoning is presented by Inoue <ref> [55, 56] </ref> following the methods of [43] and [104] (see section 5.6 for a discussion). This work is another interesting application of the notion of maximal consistency to extend logic programming for default reasoning. <p> However it is worth noting that any other semantics of extended logic programs could also be used. For example Inoue <ref> [55, 56] </ref> uses an extension of the answer set semantics (see section 5.6), but for a slightly different transformation.
Reference: [56] <author> Inoue, K., </author> <title> Extended logic programs with default assumptions. </title> <booktitle> Proc. 8th International Conference on Logic Programming, </booktitle> <address> Paris (1991) 490-504 </address>
Reference-contexts: Similar methods for transforming abductive assumptions into NAF assumptions are employed by Inoue <ref> [56] </ref> and Pereira, Aparicio and Alferes [96]. <p> Both methods, [23] and [97], can deal only with inconsistencies that can be attributed to NAF hypotheses, as shown by the following example. Example 5.10 It is not possible to restore consistency by removing NAF hypotheses given the program: p However, Inoue <ref> [55, 56] </ref> suggests a general method for restoring consistency, which is applicable to this case. This method (see also section 5.8) is based on [43] and [104] and consists in isolating inconsistencies by finding maximally consistent subprograms. <p> A more direct approach to the problem of treating positive and negative predicates symmetrically in default reasoning is presented by Inoue <ref> [55, 56] </ref> following the methods of [43] and [104] (see section 5.6 for a discussion). This work is another interesting application of the notion of maximal consistency to extend logic programming for default reasoning. <p> However it is worth noting that any other semantics of extended logic programs could also be used. For example Inoue <ref> [55, 56] </ref> uses an extension of the answer set semantics (see section 5.6), but for a slightly different transformation.
Reference: [57] <author> Inoue, K., Koshimura, M., Hasegawa, R., </author> <title> Embedding negation as failure into a model generation theorem prover. </title> <booktitle> Proc. 11th International Conference on Automated Deduction, CADE '92, </booktitle> <address> Saratoga Springs, NY (1992) </address>
Reference-contexts: A different deductive framework for abduction is presented in [58] 14 . This method is related to a similar method for NAF presented in <ref> [57] </ref>.
Reference: [58] <author> Inoue, K., Ohta, Y., Hasegawa, R., Nakashima, M., </author> <title> Hypothetical reasoning systems on the MGTP. </title> <type> Technical Report ICOT, </type> <note> Tokyo (in Japanese) (1992) </note>
Reference-contexts: A discussion of the general phenomenon that reasoning with the if-halves of definitions can often simulate reasoning with the only-if-halves, and vice versa can be found in [75]. A different deductive framework for abduction is presented in <ref> [58] </ref> 14 . This method is related to a similar method for NAF presented in [57].
Reference: [59] <author> Junker, U., </author> <title> A correct non-monotonic ATMS. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1049-1054 </address>
Reference-contexts: Other non-monotonic extensions of ATMS have been developed in <ref> [59, 119] </ref>. It should be noted that one difference between ATMS and ALP is the requirement in ATMS that only minimal sets of assumptions be recorded. This minimality of assumptions is essential for the computational efficiency of the ATMS.
Reference: [60] <author> Kakas, A. C., </author> <title> Deductive databases as theories of belief. Technical Report Logic Programming Group, </title> <institution> Imperial College, </institution> <address> London (1991) </address>
Reference-contexts: Another view of integrity constraints <ref> [60, 63, 74, 116, 117] </ref> regards these as epistemic or metalevel statements about the content of the database. In this case the integrity constraints are understood as statements at a different level from those in the knowledge base.
Reference: [61] <author> Kakas, </author> <title> A.C., On the evolution of databases. Technical Report Logic Programming Group, </title> <institution> Imperial College, </institution> <address> London (1991) </address>
Reference-contexts: He proposes instead the notion of "economic rationality", in which the revised sets of beliefs are optimal, but not necessarily unique, with respect to a set of preference criteria on the possible beliefs states. This notion has been used to study the evolution of databases by means of updates <ref> [61] </ref>. It should also be noted that the use of abduction to perform belief revision in the view update case also allows results which are not unique, as illustrated in example 2.2. KA and belief revision are also related to truth maintenance systems.
Reference: [62] <author> Kakas, A. C., Mancarella, P., </author> <title> Anomalous models and abduction. </title> <booktitle> Proc. 2nd International Symposium on Artificial intelligence, Monterrey, </booktitle> <address> Mexico (1989) </address>
Reference-contexts: T 1 &lt; T 2 ; initiates (E; P ); persists (T 1 ; P; T 2 ): 10 New information about the predicate holds-at can be assimilated by adding an explanation in terms of some event that generates this property together with an appropriate assumption that the property persists <ref> [30, 62, 125] </ref>. This has the additional effect that the new KB will imply that the property holds until it is terminated in the future [125]. This way of assimilating new information can also be used to resolve conflicts between the current KB and the new information [62, 125]. <p> This has the additional effect that the new KB will imply that the property holds until it is terminated in the future [125]. This way of assimilating new information can also be used to resolve conflicts between the current KB and the new information <ref> [62, 125] </ref>. Suppose for example that the current KB contains the fact (expressed informally) "Mary has book1 at time t 0 " and that the persistence axiom predicts that "Mary has book1 at time t 1 " where t 0 &lt; t 1 . <p> This is the case for both the semantics and the proof theory of logic programming. Moreover, [32] and <ref> [62] </ref> show how to retain the correct result when negation as failure is interpreted as a form of abduction. On the other hand, the Theorist framework does overcome the problem that some default theories do not have extensions and hence cannot be given any meaning within Reiter's default logic.
Reference: [63] <author> Kakas, A. C., Mancarella, P., </author> <title> Generalized Stable Models: a Semantics for Abduction. </title> <booktitle> Proc. 9th European Conference on Artificial Intelligence, ECAI '90, </booktitle> <month> Stockolm </month> <year> (1990) </year> <month> 385-391 </month>
Reference-contexts: Another view of integrity constraints <ref> [60, 63, 74, 116, 117] </ref> regards these as epistemic or metalevel statements about the content of the database. In this case the integrity constraints are understood as statements at a different level from those in the knowledge base. <p> Semantics and proof procedures for ALP have been proposed by Eshghi and Kowalski [32], Kakas and Mancarella <ref> [63] </ref> and Chen and Warren [10]. Chen and Warren extend the perfect model semantics of Przymusinski [109] to include abducibles and integrity constraints over abducibles. Here we shall concentrate on the proposal of Kakas and Mancarella, which extends the stable model semantics. 5.1 Generalised stable model semantics Kakas and Mancarella [63] <p> <ref> [63] </ref> and Chen and Warren [10]. Chen and Warren extend the perfect model semantics of Przymusinski [109] to include abducibles and integrity constraints over abducibles. Here we shall concentrate on the proposal of Kakas and Mancarella, which extends the stable model semantics. 5.1 Generalised stable model semantics Kakas and Mancarella [63] develop a semantics for ALP by generalising the stable model semantics for logic programming. Let hP; A; Ii be an abductive framework, where P is a general logic program, and let be a subset of A.
Reference: [64] <author> Kakas, A. C., Mancarella, P., </author> <title> Database updates through abduction. </title> <booktitle> Proc. 16th International Conference on Very Large Databases, </booktitle> <address> VLDB'90, Brisbane, Australia (1990) </address>
Reference-contexts: Abduction can be computed in logic programming by extending SLD and SLDNF <ref> [10, 32, 33, 64, 67] </ref>. Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. <p> An application that does not necessarily have a direct causal interpretation is knowledge assimilation [67, 72, 80, 89]. The assimilation of a new datum can be performed by adding to the theory new hypotheses that are explanations for the datum. Database view updates <ref> [6, 64] </ref> are an important special case of knowledge assimilation. Update requests are interpreted as observations to be explained. The explanations of the observations are transactions that satisfy the update request. We will discuss knowledge assimilation in greater detail in section 2. <p> The task of translating the update request on the view predicates to an equivalent update on the extensional part (as in case (4) of KA) is achieved by finding an abductive explanation for the update in terms of variable-free instances of extensional predicates <ref> [64] </ref>. Any violation of integrity is dealt with by changing the extensional part of the database. <p> Another important difference is the distinction that the abductive proof procedure for NAF makes between the abductive and consistency phases. This allows a natural extension of the procedure to a more general framework where we have other hypotheses and integrity constraints in addition to those for NAF <ref> [64, 65, 66] </ref> (see section 5.2). To see how the abductive proof procedure extends SLDNF, consider the 25 2 s p fl q fl q following program. Example 4.3 s q p ~ q The query s has no SLDNF refutation. <p> In this sense, it tends to maximise the generation of hypotheses. This property of the proof procedure and its relationship with the semantics needs to be investigated further. 5.2 Abductive proof procedure for ALP In <ref> [64, 65, 66] </ref>, proof procedures are given to compute abductive explanations in ALP.
Reference: [65] <author> Kakas, A. C., Mancarella, P., </author> <title> On the relation of truth maintenance and abduction. </title> <booktitle> Proc. of the 1st Pacific Rim International Conference on Artificial Intelligence, </booktitle> <address> PRICAI'90, Nagoya, Japan (1990) </address>
Reference-contexts: Another important difference is the distinction that the abductive proof procedure for NAF makes between the abductive and consistency phases. This allows a natural extension of the procedure to a more general framework where we have other hypotheses and integrity constraints in addition to those for NAF <ref> [64, 65, 66] </ref> (see section 5.2). To see how the abductive proof procedure extends SLDNF, consider the 25 2 s p fl q fl q following program. Example 4.3 s q p ~ q The query s has no SLDNF refutation. <p> In this sense, it tends to maximise the generation of hypotheses. This property of the proof procedure and its relationship with the semantics needs to be investigated further. 5.2 Abductive proof procedure for ALP In <ref> [64, 65, 66] </ref>, proof procedures are given to compute abductive explanations in ALP. <p> In this case the abductive proof procedure needs only a minor extension <ref> [65, 66] </ref>: when a new hypothesis is added to , the proof procedure resolves the hypothesis against any integrity constraint containing that hypothesis, and then reasons backward from the resolvent. To illustrate this extension consider the following example. <p> Several authors have observed that the JTMS can be given a semantics corresponding to the semantics of logic programs, by interpreting justifications as propositional logic program clauses, and interpreting ~ p i as NAF of p i . The papers <ref> [29, 48, 65, 100] </ref>, in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. <p> The papers [29, 48, 65, 100], in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. Several authors <ref> [29, 38, 65, 112] </ref>, exploiting the interpretation of stable models as autoepistemic expansions [45], have shown a correspondence between well-founded labellings and stable expansions of the set of justifications viewed as autoepistemic theories. <p> The JTMS can also be understood in terms of abduction using the abduc-tive approach to the semantics of NAF, as shown in <ref> [24, 48, 65] </ref>. This has the advantage that the nogoods of the JTMS can be interpreted as integrity constraints of the abductive framework. <p> Ignoring the propositional nature of a TM system, ALP can be regarded as a hybrid of JTMS and ATMS, combining the non-monotonic negative assumptions of JTMS and the positive assumptions of ATMS, and allowing both positive and negative conditions in both justifications and nogoods <ref> [65] </ref>. Other non-monotonic extensions of ATMS have been developed in [59, 119]. It should be noted that one difference between ATMS and ALP is the requirement in ATMS that only minimal sets of assumptions be recorded. This minimality of assumptions is essential for the computational efficiency of the ATMS.
Reference: [66] <author> Kakas, A. C., Mancarella, P., </author> <title> Abductive logic programming. </title> <booktitle> Proc. NACLP '90, Workshop on Non-Monotonic Reasoning and Logic Programming, </booktitle> <address> Austin, Texas (1990) 71 </address>
Reference-contexts: In [76] this assumption is exploited by reasoning forward from the updates. This idea is exploited for the purpose of checking the satisfaction of abductive hypotheses in <ref> [33, 66, 67] </ref>. Although this procedure was originally formulated for the consistency view of constraint satisfaction, it has proved equally appropriate for the semantics of integrity constraints in abductive logic programming. 1.3 Applications In this section we briefly describe some of the applications of abduction in AI. <p> Another important difference is the distinction that the abductive proof procedure for NAF makes between the abductive and consistency phases. This allows a natural extension of the procedure to a more general framework where we have other hypotheses and integrity constraints in addition to those for NAF <ref> [64, 65, 66] </ref> (see section 5.2). To see how the abductive proof procedure extends SLDNF, consider the 25 2 s p fl q fl q following program. Example 4.3 s q p ~ q The query s has no SLDNF refutation. <p> In this sense, it tends to maximise the generation of hypotheses. This property of the proof procedure and its relationship with the semantics needs to be investigated further. 5.2 Abductive proof procedure for ALP In <ref> [64, 65, 66] </ref>, proof procedures are given to compute abductive explanations in ALP. <p> In this case the abductive proof procedure needs only a minor extension <ref> [65, 66] </ref>: when a new hypothesis is added to , the proof procedure resolves the hypothesis against any integrity constraint containing that hypothesis, and then reasons backward from the resolvent. To illustrate this extension consider the following example.
Reference: [67] <author> Kakas, A. C., Mancarella, P., </author> <title> Knowledge assimilation and abduction. </title> <booktitle> Proc. European Conference on Artificial Intelligence, ECAI '90 International Workshop on Truth Maintenance, Stockholm, Springer Verlag Lecture notes in Computer Science (1990) </booktitle>
Reference-contexts: Abduction can be computed in logic programming by extending SLD and SLDNF <ref> [10, 32, 33, 64, 67] </ref>. Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. <p> In [76] this assumption is exploited by reasoning forward from the updates. This idea is exploited for the purpose of checking the satisfaction of abductive hypotheses in <ref> [33, 66, 67] </ref>. Although this procedure was originally formulated for the consistency view of constraint satisfaction, it has proved equally appropriate for the semantics of integrity constraints in abductive logic programming. 1.3 Applications In this section we briefly describe some of the applications of abduction in AI. <p> These applications of abduction can all be understood as generating hypotheses which are causes for observations which are effects. An application that does not necessarily have a direct causal interpretation is knowledge assimilation <ref> [67, 72, 80, 89] </ref>. The assimilation of a new datum can be performed by adding to the theory new hypotheses that are explanations for the datum. Database view updates [6, 64] are an important special case of knowledge assimilation. Update requests are interpreted as observations to be explained. <p> The new information is independent from the current KB. The new KB is obtained by adding the new information to the current KB. In case (4) the KB can, alternatively, be augmented by an explanation for the new datum <ref> [67, 72, 80] </ref>. In [80] the authors have developed a system for knowledge assimilation (KA) based on this use of abduction. They have identified the basic issues associated with such a system and proposed solutions for some of these. <p> In this way the ab-ductive proof procedure generalises SLDNF significantly. Furthermore, the abductive explanation produced by the procedure can be recorded and used in any subsequent revision of the beliefs held by the program, in a similar fashion to truth maintenance systems <ref> [67] </ref>. In fact, this abductive treatment of NAF allows us to identify a close connection between logic programming and truth maintenance systems in general (see section 6). Another important difference is the distinction that the abductive proof procedure for NAF makes between the abductive and consistency phases.
Reference: [68] <author> Kakas, A. C., Mancarella, P., </author> <title> Preferred extensions are partial stable models. </title> <note> to appear in Journal of Logic Programming </note>
Reference-contexts: The preferred extension semantics provides a unifying framework for various approaches to the semantics of negation in logic programming. Kakas and Mancarella <ref> [68] </ref> show that it is equivalent to Sacca and Zaniolo's partial stable model semantics [120]. Like the partial stable model semantics, it includes the stable model semantics as a special case.
Reference: [69] <author> Kakas, A. C., Mancarella, P., </author> <title> Negation as stable hypotheses. </title> <booktitle> Proc. 1st International Workshop on Logic Programming and Nonmonotonic Reasoning, </booktitle> <editor> Nerode, Marek and Subrahmanian eds., </editor> <address> Washington DC (1991) </address>
Reference-contexts: Thus the well-founded semantics is 29 minimalist and sceptical, whereas the preferred extension semantics is max--imalist and credulous. A fixpoint construction of the preferred extension semantics is given in [28]. Kakas and Mancarella <ref> [69, 70] </ref> propose a modification of the preferred extension semantics. Their proposal can be illustrated by the following example. Example 4.6 In the abductive framework corresponding to the program p ~ q consider the set of hypotheses = fp fl g.
Reference: [70] <author> Kakas, A. C., Mancarella, P., </author> <title> Stable theories for logic programs. </title> <booktitle> Proc. </booktitle> <address> ISLP '91, San Diego (1991) [71] deKleer, </address> <note> J., An assumption-based TMS. Artificial Intelligence 32 (1986) </note>
Reference-contexts: Thus the well-founded semantics is 29 minimalist and sceptical, whereas the preferred extension semantics is max--imalist and credulous. A fixpoint construction of the preferred extension semantics is given in [28]. Kakas and Mancarella <ref> [69, 70] </ref> propose a modification of the preferred extension semantics. Their proposal can be illustrated by the following example. Example 4.6 In the abductive framework corresponding to the program p ~ q consider the set of hypotheses = fp fl g. <p> Like the original definition of preferred extension, the definition of stable set of hypotheses was not originally formulated in terms of attack, but is equivalent to the one presented above. Kakas and Mancarella <ref> [70] </ref> argue that the notion of defeating an attack needs to be liberalised further. They illustrate their argument with the following example. 30 Example 4.7 Consider the program P s ~ p q ~ r Here the only attack against the hypothesis s fl is E = fp fl g. <p> Despite the recent advances in the semantics of NAF there is still room for improvement. One possibility is to explore further the direction set in [28] and <ref> [70] </ref> which characterises the acceptability of a set of hypotheses recursively in terms of the non-acceptability of all attacks against . Another is to identify an appropriate concept of maximal consistency, perhaps along the lines of the retractability semantics suggested in [77]. The two possibilities need not be mutually exclusive.
Reference: [72] <author> Kowalski, R.A., </author> <title> Logic for problem solving. </title> ( <publisher> Elsevier, </publisher> <address> New York,1979) </address>
Reference-contexts: These applications of abduction can all be understood as generating hypotheses which are causes for observations which are effects. An application that does not necessarily have a direct causal interpretation is knowledge assimilation <ref> [67, 72, 80, 89] </ref>. The assimilation of a new datum can be performed by adding to the theory new hypotheses that are explanations for the datum. Database view updates [6, 64] are an important special case of knowledge assimilation. Update requests are interpreted as observations to be explained. <p> There are four possible deductive relationships between the current knowledge base (KB), the knowledge, and the new KB which arises as a result <ref> [72] </ref>. 1. The new information is already deducible from the current KB. The new KB, as a result, is identical with the current one. 2. The current KB = KB 1 [ KB 2 can be decomposed into two parts. <p> The new information is independent from the current KB. The new KB is obtained by adding the new information to the current KB. In case (4) the KB can, alternatively, be augmented by an explanation for the new datum <ref> [67, 72, 80] </ref>. In [80] the authors have developed a system for knowledge assimilation (KA) based on this use of abduction. They have identified the basic issues associated with such a system and proposed solutions for some of these. <p> Any violation of integrity detected in case (3) can be remedied in several ways <ref> [72] </ref>. The new input can be retracted as in conventional databases. Alternatively the new input can be upheld and some other assumptions can be withdrawn. This is the case with view updates.
Reference: [73] <author> Kowalski, R.A., </author> <title> Belief revision without constraints. </title> <booktitle> Computational Intelligence 3(3), </booktitle> <year> (1987) </year>
Reference: [74] <author> Kowalski, R.A., </author> <title> Problem and promises of computational logic. </title> <booktitle> Proc. Symposium on Computational Logic, </booktitle> <editor> Lloyd ed., </editor> <booktitle> Springer Verlag Lecture Notes in Computer Science (1990) </booktitle>
Reference-contexts: Another view of integrity constraints <ref> [60, 63, 74, 116, 117] </ref> regards these as epistemic or metalevel statements about the content of the database. In this case the integrity constraints are understood as statements at a different level from those in the knowledge base.
Reference: [75] <editor> Kowalski, R.A., </editor> <booktitle> Logic programming in artificial intelligence. Proc. 12th International Joint Conference on Artificial Intelligence, </booktitle> <address> Sidney (1991) 596-603 </address>
Reference-contexts: A discussion of the general phenomenon that reasoning with the if-halves of definitions can often simulate reasoning with the only-if-halves, and vice versa can be found in <ref> [75] </ref>. A different deductive framework for abduction is presented in [58] 14 . This method is related to a similar method for NAF presented in [57].
Reference: [76] <author> Kowalski, R.A., Sadri, F., </author> <title> An application of general purpose theorem-proving to database integrity. Foundations of Deductive Databases and Logic Programming, </title> <editor> Minker ed., </editor> <publisher> Morgan Kaufmann Publishers, </publisher> <address> Palo Alto (1987) 313-362 </address>
Reference-contexts: in the rest of this paper we will use the same symbol A to indicate both the set of abducible predicates and the set of all their variable-free instances. 7 These definitions have been proposed in the case where the theory is a logic program P by Kowalski and Sadri <ref> [76] </ref> and Lloyd and Topor [84] respectively, where KB is the Clark completion [11] of P . Another view of integrity constraints [60, 63, 74, 116, 117] regards these as epistemic or metalevel statements about the content of the database. <p> For each such semantics, we have a specification of the integrity checking problem. Although the different views of integrity satisfaction are conceptually very different, the integrity checking procedures based upon these views are not very different in practice (e.g. <ref> [16, 76, 84] </ref>). They are mainly concerned with avoiding the inefficiency which arises if all the integrity constraints are retested after each update. <p> A common idea of all these procedures is to render integrity checking more efficient by exploiting the assumption that the database before the update satisfies the integrity constraints, and therefore if integrity constraints are violated after the update, this violation should depend upon the update itself. In <ref> [76] </ref> this assumption is exploited by reasoning forward from the updates. This idea is exploited for the purpose of checking the satisfaction of abductive hypotheses in [33, 66, 67]. <p> The abductive proof procedure is sound with respect to this improved semantics. Satoh and Iwayama [122], on the other hand, show how to extend the abductive proof procedure of [33] to deal correctly with the stable model semantics. Their extension modifies the integrity checking method of <ref> [76] </ref> and deals with arbitrary integrity constraints expressed in the form of denials. 27 Casamayor and Decker [7] also develop an abductive proof procedure for NAF. Their proposal combines features of the Eshghi-Kowalski procedure with ancestor resolution.
Reference: [77] <author> Kowalski, R.A., Sadri, F., </author> <title> Knowledge representation without integrity constraints. </title> <institution> Technical Report Department of Computing, Imperial College, </institution> <address> London (1988) </address>
Reference-contexts: Hence by adding the hypothesis r to the explanation we can ensure that q fl is acceptable. 37 An important feature of the abductive proof procedures is that they avoid performing a full general-purpose integrity check (such as the forward reasoning procedure of <ref> [77] </ref>). In the case of a negative hypothesis, q fl for example, a general-purpose forward reasoning integrity check would have to use rules in the program such as p q fl to derive p. <p> Instead of regarding abducibles as atoms to be consistently added to a theory, they can be considered as assertions in the theory to be retracted in the presence of contradictions until consistency (or integrity) is restored (c.f. section 5.6). One approach to this understanding of abduction is presented in <ref> [77] </ref>. Here, Kowalski and Sadri present a transformation from a general logic program P with integrity constraints I, together with some indication of how to restore consistency, to a new general logic program P 0 without integrity constraints. <p> Another is to identify an appropriate concept of maximal consistency, perhaps along the lines of the retractability semantics suggested in <ref> [77] </ref>. The two possibilities need not be mutually exclusive. The former, recursive specification would be closer to an implementation than the latter. But the two specifications might otherwise be equivalent. The use of abduction for NAF is a special case.
Reference: [78] <author> Kowalski, R.A., Sadri, F., </author> <title> Logic programs with exception. </title> <booktitle> Proc. 7th International Conference on Logic Programming, </booktitle> <address> Jerusalem (1990) 598-613 </address>
Reference-contexts: Moreover the proof of equivalence is based on a tedious comparison of search spaces for the two programs. This problem was solved in a subsequent paper <ref> [78] </ref> by re-expressing integrity constraints as extended clauses where the retractable atoms are expressed as explicitly negated conclusions. <p> Kowalski and Sadri <ref> [78] </ref> also present a new transformation, which preserves the new semantics, and is a more elegant form of the original transformation.
Reference: [79] <author> Kowalski, R.A., Sergot, M., </author> <title> A logic-based calculus of events. </title> <booktitle> New Generation Computing 4 (1986) 67-95 </booktitle>
Reference-contexts: In other cases the addition of an explanation as a way of assimilating new data is forced by the particular way in which the knowledge is represented in the theory. Consider for example a problem of temporal reasoning formulated in the Event Calculus <ref> [79] </ref>.
Reference: [80] <author> Kunifuji, S., Tsurumaki, K., Furukawa, K., </author> <title> Consideration of a hypothesis-based reasoning system. </title> <journal> Journal of Japanese Society for Artificial Intelligence 1(2) (1986) 228-237 </journal>
Reference-contexts: These applications of abduction can all be understood as generating hypotheses which are causes for observations which are effects. An application that does not necessarily have a direct causal interpretation is knowledge assimilation <ref> [67, 72, 80, 89] </ref>. The assimilation of a new datum can be performed by adding to the theory new hypotheses that are explanations for the datum. Database view updates [6, 64] are an important special case of knowledge assimilation. Update requests are interpreted as observations to be explained. <p> The new information is independent from the current KB. The new KB is obtained by adding the new information to the current KB. In case (4) the KB can, alternatively, be augmented by an explanation for the new datum <ref> [67, 72, 80] </ref>. In [80] the authors have developed a system for knowledge assimilation (KA) based on this use of abduction. They have identified the basic issues associated with such a system and proposed solutions for some of these. <p> The new information is independent from the current KB. The new KB is obtained by adding the new information to the current KB. In case (4) the KB can, alternatively, be augmented by an explanation for the new datum [67, 72, 80]. In <ref> [80] </ref> the authors have developed a system for knowledge assimilation (KA) based on this use of abduction. They have identified the basic issues associated with such a system and proposed solutions for some of these.
Reference: [81] <author> Lamma, E., Mello, P., </author> <title> An assumption-based truth maintenance system dealing with non ground justifications. </title> <booktitle> Proc. 1st Compulog-Net Workshop on Logic Programming in Artificial Intelligence, </booktitle> <institution> Imperial College, </institution> <address> London (1992) </address>
Reference-contexts: Poole, Goebel and Aleliunas [107] also use linear resolution to generate hypotheses. In contrast, the ATMS [71] computes abductive explanations bottom-up. The ATMS can be regarded as a form of hyper-resolution, augmented with subsumption, for propositional logic programs [118]. Lamma and Mello <ref> [81] </ref> have developed an extension of the ATMS for the non-propositional case. Resolution-based techniques for computing abduction have also been developed by Demolombe and Fari~nas del Cerro [17] and Gaifman and Shapiro [41]. Abduction can also be applied to logic programming. <p> The extension of the ATMS to the non-propositional case requires a new notion of minimality of sets of assumptions. Minimality as subset inclusion is not sufficient, but needs to be replaced by a notion of minimal consequence from sets of not necessarily variable-free assumptions <ref> [81] </ref>. Ignoring the propositional nature of a TM system, ALP can be regarded as a hybrid of JTMS and ATMS, combining the non-monotonic negative assumptions of JTMS and the positive assumptions of ATMS, and allowing both positive and negative conditions in both justifications and nogoods [65].
Reference: [82] <author> Lever, J. M., </author> <title> Combining induction with resolution in logic programming. </title> <type> PhD Thesis, </type> <institution> Department of Computing, Imperial College, </institution> <month> Lon-don </month> <year> (1991) </year>
Reference-contexts: Integrity constraints are useful to avoid unintended updates to a database or knowledge base. They can also be used to represent desired properties of a program <ref> [82] </ref>. The concept of integrity constraints first arose in the field of databases and to a lesser extent in the field of AI knowledge representation. The basic idea is that only certain knowledge base states are considered acceptable, and an integrity constraint is meant to enforce these legal states.
Reference: [83] <author> Levesque, H.J., </author> <title> A knowledge-level account of abduction. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1061-1067 </address>
Reference-contexts: We mention them for completeness, but in the sequel we will concentrate on the logic-based view previously described. * Allemand et al. [2] and Reggia [111] present a mathematical char-acterisation, where abduction is defined over sets of observations and hypotheses, in terms of coverings and parsimony. * Levesque <ref> [83] </ref> gives an account of abduction at the "knowledge level". He characterises abduction in terms of a (modal) logic of beliefs, and shows how the logic-based approach to abduction can be understood in terms of a particular kind of belief.
Reference: [84] <author> Lloyd, J. W., Topor, R.W., </author> <title> A basis for deductive database system. </title> <note> Journal of Logic Programming 2 (1985) 93-109 </note>
Reference-contexts: paper we will use the same symbol A to indicate both the set of abducible predicates and the set of all their variable-free instances. 7 These definitions have been proposed in the case where the theory is a logic program P by Kowalski and Sadri [76] and Lloyd and Topor <ref> [84] </ref> respectively, where KB is the Clark completion [11] of P . Another view of integrity constraints [60, 63, 74, 116, 117] regards these as epistemic or metalevel statements about the content of the database. <p> For each such semantics, we have a specification of the integrity checking problem. Although the different views of integrity satisfaction are conceptually very different, the integrity checking procedures based upon these views are not very different in practice (e.g. <ref> [16, 76, 84] </ref>). They are mainly concerned with avoiding the inefficiency which arises if all the integrity constraints are retested after each update.
Reference: [85] <author> Makinson, D., </author> <title> General theory of cumulative inference. </title> <booktitle> Proc. 2nd International Workshop on Monmonotonic reasoning, Springer Verlag Lecture Notes in Computer Science 346 (1989) </booktitle>
Reference-contexts: He presents a number of examples where the two formulations differ and argues that Reiter's default logic gives counterintuitive results. In fact, many of these example can be dealt with correctly in certain extensions of default logic, such as Cumulative Default Logic <ref> [85] </ref>, and it is possible to dispute some of the other examples. But, more importantly, there are still other examples where the Theorist approach arguably gives the wrong result. The most important of these is the now notorious Yale shooting problem of [49, 50].
Reference: [86] <author> Manthey, R., Bry, F., </author> <title> SATCHMO: a theorem prover implemented in Prolog. </title> <booktitle> Proc. 9th International Conference on Automated Deduction, CADE '88, </booktitle> <address> Argonne, Illinois (1988) 415-434 </address>
Reference-contexts: They show a structural equivalence between the search spaces for SLD-resolution extended with abduction and the search spaces for model generation with SATCHMO <ref> [86] </ref> augmented with term rewriting to simulate unification. A discussion of the general phenomenon that reasoning with the if-halves of definitions can often simulate reasoning with the only-if-halves, and vice versa can be found in [75]. A different deductive framework for abduction is presented in [58] 14 .
Reference: [87] <author> Marek, W., Truszczynski, M., </author> <title> Stable semantics for logic programs and default theories. </title> <booktitle> Proc. </booktitle> <month> NACLP '89 </month> <year> (1989) </year> <month> 243-256 </month>
Reference: [88] <author> Minker, J., </author> <title> On indefinite databases and the closed world assumption. </title> <booktitle> Proc. 6th International Conference on Automated Deduction, CADE '82, </booktitle> <address> New York, </address> <note> Springer Verlag Lecture Notes in Computer Science 138 (1982) 292-308 </note>
Reference-contexts: Example 5.1 Consider the program P p a used to separate extensional and intensional predicates in deductive databases <ref> [88] </ref>.
Reference: [89] <author> Miyaki, T., Kunifuji, S., Kitakami, H., Furukawa, K., Takeuchi, A., Yokota, H., </author> <title> A knowledge assimilation method for logic databases. </title> <booktitle> International Symposium on Logic Programming, </booktitle> <address> Atlantic City, NJ (1984) 118-125 </address>
Reference-contexts: These applications of abduction can all be understood as generating hypotheses which are causes for observations which are effects. An application that does not necessarily have a direct causal interpretation is knowledge assimilation <ref> [67, 72, 80, 89] </ref>. The assimilation of a new datum can be performed by adding to the theory new hypotheses that are explanations for the datum. Database view updates [6, 64] are an important special case of knowledge assimilation. Update requests are interpreted as observations to be explained.
Reference: [90] <author> Morris, P. H., </author> <title> The anomalous extension problem in default reasoning. </title> <booktitle> Artificial Intelligence 35 (1988) 383-399 </booktitle>
Reference-contexts: The most important of these is the now notorious Yale shooting problem of [49, 50]. This can be reduced to the propositional logic program alive-af ter-load-wait-shoot alive-af ter-load-wait, ~ abnormal-alive-shoot loaded-af ter-load-wait loaded-af ter-load, ~ abnormal-loaded-wait abnormal-alive-shoot loaded-af ter-load-wait alive-af ter-load-wait loaded-af ter-load; As argued in <ref> [90] </ref>, these clauses can be simplified further: First, the facts alive-af ter-load-wait and loaded-af ter-load can be eliminated by resolving them against the corresponding conditions of the first two clauses, giving alive-af ter-load-wait-shoot ~ abnormal-alive-shoot loaded-af ter-load-wait ~ abnormal-loaded-wait abnormal-alive-shoot loaded-af ter-load-wait Then the atom loaded-af ter-load-wait can be resolved away <p> The second extension is intuitively incorrect under the intended interpretation. Hanks and Mc Dermott showed that many other approaches to default reasoning give similarly incorrect results. However, Morris <ref> [90] </ref> showed that the default theory which has no facts but contains the two non-normal defaults : M ~ q : M ~ r yields only one extension, containing q, which is the correct result. In contrast, all natural representations of the problem in Theorist give incorrect results. <p> In the JTMS changing an assumption is done by changing an OUT label to IN. Suppose, for example, that we are given the justifications p ~ q q ~ r corresponding to the propositional form of the Yale shooting problem. As Morris <ref> [90] </ref> observes, these correctly determine that q is labelled IN and that r and p are labelled OUT. If the JTMS is subsequently informed that p is true, then dependency-directed backtracking will install a justification for r, changing its label from OUT to IN.
Reference: [91] <author> Nebel, B., </author> <title> A knowledge level analysis of belief revision. </title> <booktitle> Proc. 1st International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> Toronto (1989) 301-311 </address>
Reference-contexts: Both of these updates satisfy the integrity constraints. However, only the first update satisfies the integrity constraints if we are given the further update insert mother (Joan; Bob): The general problem of belief revision has been studied formally in <ref> [42, 91, 92, 21] </ref>. <p> We have seen that the process of belief revision also needs to be considered within a KA context. In particular, it could be useful to investigate relationships between the belief revision frameworks of <ref> [21, 42, 91, 92] </ref> and various integrity constraint checking and restoration procedures. The extension of logic programming to include integrity constraints is useful both for abductive logic programming and for deductive databases applications.
Reference: [92] <author> Nebel, B., </author> <title> Belief revision and default reasoning: syntax-based approaches. </title> <booktitle> Proc. 2nd International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> Cambridge, Mass. </address> <year> (1991) </year> <month> 417-428 </month>
Reference-contexts: Both of these updates satisfy the integrity constraints. However, only the first update satisfies the integrity constraints if we are given the further update insert mother (Joan; Bob): The general problem of belief revision has been studied formally in <ref> [42, 91, 92, 21] </ref>. <p> We have seen that the process of belief revision also needs to be considered within a KA context. In particular, it could be useful to investigate relationships between the belief revision frameworks of <ref> [21, 42, 91, 92] </ref> and various integrity constraint checking and restoration procedures. The extension of logic programming to include integrity constraints is useful both for abductive logic programming and for deductive databases applications.
Reference: [93] <author> Pearce, D., Wagner, G., </author> <title> Logic programming with strong negation. </title> <booktitle> Proc. Workshop on Extensions of Logic Programming, Springer Verlag Lecture Notes in Computer Science (1991) </booktitle>
Reference-contexts: However, as we will see below, because the contrapositives of extended clauses do not hold, the term "classical negation" is inappropriate. For this reason we use the term "explicit negation" instead. A similar notion has been investigated by Pearce and Wagner <ref> [93] </ref>, who develop an extension of Horn programs by means of Nelson's strong negation. They also suggest the possibility of combining strong negation with NAF.
Reference: [94] <author> Pearl, J., </author> <title> Embracing causality in formal reasoning. </title> <booktitle> Proc. AAAI '87, </booktitle> <address> Washington, Seattle (1987) 360-373 </address>
Reference-contexts: Abduction is widely used in common-sense reasoning, for instance in diagnosis, to reason from effect to cause [9, 101]. We consider here an example drawn from <ref> [94] </ref>.
Reference: [95] <author> Peirce, C.S., </author> <title> Collected papers of Charles Sanders Peirce. </title> <booktitle> Vol.2, </booktitle> <pages> 1931-1958, </pages> <editor> Hartshorn et al. eds., </editor> <publisher> Harvard University Press </publisher>
Reference-contexts: We also introduce a novel argumentation-theoretic interpretation of abduction applied to negation as failure. The philosopher Pierce first introduced the notion of abduction. In <ref> [95] </ref> he identified three distinguished forms of reasoning. Deduction, an analytic process based on the application of general rules to particular cases, with the inference of a result. Induction, synthetic reasoning which infers the rule from the case and the result.
Reference: [96] <author> Pereira, L.M., Aparicio, J.N., Alferes, J.J., </author> <title> Non-monotonic reasoning with well-founded semantics. </title> <booktitle> Proc. 8th International Conference on Logic Programming, </booktitle> <address> Paris (1991) </address>
Reference-contexts: However, as we have already remarked in the case of the semantics of explicit negation, the transformational semantics, which is effectively employed by Satoh and Iwayama, has the advantage that any semantics can be used for the resulting transformed program (e.g. as in <ref> [96] </ref>, see below). Example 5.7 Consider the abductive framework hP; A; Ii of example 5.1. <p> Similar methods for transforming abductive assumptions into NAF assumptions are employed by Inoue [56] and Pereira, Aparicio and Alferes <ref> [96] </ref>. <p> Pereira, Aparicio and Alferes [98] have also developed proof procedures for this semantics. These procedures can be used as abductive proof procedures for ALP. As mentioned above, Pereira, Aparicio and Alferes <ref> [96] </ref> understand the transformed programs in terms of (three-valued) extended stable models. The extended stable model semantics has the advantage that it gives a semantics to every logic program and it does not force abducibles to be either believed or disbelieved. <p> of abductive reasoning, generalising appropriately the preferred extension, stable theory and acceptability semantics of NAF. 5.9 A methodology for default reasoning with explicit nega tion Compared with other authors, who primarily focus on extending or modifying the semantics of logic programming to deal with default reasoning, Pereira, Aparicio and Alferes <ref> [96] </ref> develop a methodology for performing 53 default reasoning with extended logic programs. Defaults of the form "nor-mally if q then p" are represented by an extended clause p q; ~ : nameqp; ~ : p (3) where the condition nameqp is a name given to the default. <p> default represented by (6) over the more general default (4), we add the additional clause : birds-f ly (x) penguin (x); ~ : penguins-don 0 t-f ly (x): Then to express that superpenguins fly, we can add the rule: :penguins-don 0 t-f ly (x) superpenguin (x): Pereira, Aparicio and Alferes <ref> [96] </ref> use the well-founded semantics extended with explicit negation to give a semantics for this methodology for default reasoning. However it is worth noting that any other semantics of extended logic programs could also be used.
Reference: [97] <author> Pereira, L.M., Aparicio, J.N., Alferes, J.J., </author> <title> Contradiction removal within well-founded semantics. </title> <booktitle> Proc. 1st International Workshop on Logic Programming and Nonmonotonic Reasoning, </booktitle> <editor> Nerode, Marek and Subrahmanian eds., </editor> <address> Washington DC (1991) </address>
Reference-contexts: In the example above we can restore consistency by rejecting the NAF assumption ~ bird (T om) even though bird (T om) does not hold. We then get the consistent set fbat (T om); f ly (T om)g. This problem has been studied in [23] and <ref> [97] </ref>. Both of these studies are primarily concerned with the related problem of inconsistency of the well-founded semantics when applied to extended logic programs [110]. <p> The new integrity constraints in I fl have the effect of removing a NAF hypothesis when it leads to a contradiction. Pereira, Aparicio and Alferes <ref> [97] </ref> employ a similar approach in the context of Przymuszynski's extended stable models [110]. It consists in identifying explicitly all the possible sets of NAF hypotheses which lead to an inconsistency and then restoring consistency by removing at least one hypothesis from each such set. <p> In fact Pereira, Aparicio and Alferes have also used this method to study counterfactual reasoning [99]. Both methods, [23] and <ref> [97] </ref>, can deal only with inconsistencies that can be attributed to NAF hypotheses, as shown by the following example.
Reference: [98] <author> Pereira, L.M., Aparicio, J.N., Alferes, J.J., </author> <title> Derivation procedures for extended stable models. </title> <booktitle> Proc. 12th International Joint Conference on Artificial Intelligence, </booktitle> <address> Sidney (1991) 863-868 </address>
Reference-contexts: The well-founded semantics can be thought of as representing a minimal incomplete view of the world and the extended stable model semantics as representing different ways of extending this view by abducing negative hypotheses. Pereira, Aparicio and Alferes <ref> [98] </ref> have also developed proof procedures for this semantics. These procedures can be used as abductive proof procedures for ALP. As mentioned above, Pereira, Aparicio and Alferes [96] understand the transformed programs in terms of (three-valued) extended stable models.
Reference: [99] <author> Pereira, L.M., Aparicio, J.N., Alferes, J.J., </author> <title> Counterfactual reasoning based on revising assumptions. </title> <booktitle> Proc. </booktitle> <address> ISLP '91, San Diego (1991) </address>
Reference-contexts: In fact Pereira, Aparicio and Alferes have also used this method to study counterfactual reasoning <ref> [99] </ref>. Both methods, [23] and [97], can deal only with inconsistencies that can be attributed to NAF hypotheses, as shown by the following example.
Reference: [100] <author> Pimentel, S. G., Cuadrado, J. L., </author> <title> A truth maintenance system based on stable models. </title> <booktitle> Proc. </booktitle> <month> NACLP '89 </month> <year> (1989) </year>
Reference-contexts: Several authors have observed that the JTMS can be given a semantics corresponding to the semantics of logic programs, by interpreting justifications as propositional logic program clauses, and interpreting ~ p i as NAF of p i . The papers <ref> [29, 48, 65, 100] </ref>, in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program.
Reference: [101] <author> Pople, H. E. Jr., </author> <booktitle> On the mechanization of abductive logic. Proc. 3rd International Joint Conference on Artificial Intelligence, </booktitle> <year> (1973) </year> <month> 147-152 </month>
Reference-contexts: Abduction is widely used in common-sense reasoning, for instance in diagnosis, to reason from effect to cause <ref> [9, 101] </ref>. We consider here an example drawn from [94].
Reference: [102] <author> Poole, D., </author> <title> On the comparison of theories: preferring the most specific explanation. </title> <booktitle> Proc. 9th International Joint Conference on Artificial Intelligence, </booktitle> <address> Los Angeles, Ca (1985) 144-147 </address>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [5, 9, 39, 52, 102, 106, 128] </ref>. Cox and Pietrzykowski [15] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not be explainable in terms of other explanations. <p> A similar approximation to the notion of acceptability has also been proposed by 31 Simari and Loui [126], who define an argumentation-theoretic framework for default reasoning in general. They combine a notion of acceptability with Poole's notion of "most specific" explanation <ref> [102] </ref>, to deal with hierarchies of defaults. 4.4 The abductive proof procedure revisited As mentioned above, the incorrectness (with respect to the stable model semantics) of the abductive proof procedure can be remedied by adopting the preferred extension, stable theory or acceptability semantics.
Reference: [103] <author> Poole, D., </author> <title> Variables in hypotheses. </title> <booktitle> Proc. 10th International Joint Conference on Artificial Intelligence, </booktitle> <address> Milan (1987) 905-908 </address>
Reference-contexts: The abductive proof procedure needs to be extended and improved in various ways. One such extension is the generation of non-variable-free hypotheses, containing variables. This problem, which has been studied in part in [10], [30] and <ref> [103] </ref>, and also by [18] with respect to the completion semantics, involves the treatment of the equality predicate as a further abducible. Because NAF is a special case of abduction, the problem of constructive negation in logic programming [4, 8, 130] is a special case of abduction with non-variable-free hypotheses.
Reference: [104] <author> Poole, D., </author> <title> A logical framework for default reasoning. </title> <booktitle> Artificial Intelligence 36 (1988) 27-47 </booktitle>
Reference-contexts: restrict the number of candidate explanations: * Once we restrict the hypotheses to belong to a specified set of sentences, we can further restrict, without loss of generality, the hypothe 3 ses to atoms (that "name" these sentences) which are predicates ex- plicitly indicated as abducible, as shown by Poole <ref> [104] </ref>. * In section 1.2 we will discuss the use of integrity constraints to reduce the number of possible explanations. * Additional information can help to discriminate between different explanations, by rendering some of them more appropriate or plausible than others. <p> Default reasoning concerns the use of general rules to derive information in the absence of contradictions. In the application of abduction to default reasoning, conclusions are viewed as observations to be explained by means of assumptions which hold by default unless a contradiction can be shown <ref> [32, 104] </ref>. As Poole [104] argues, the use of abduction avoids the need to develop a non-classical, non-monotonic logic for default reasoning. In section 3 we will further discuss the use of abduction for default reasoning in greater detail. <p> In the application of abduction to default reasoning, conclusions are viewed as observations to be explained by means of assumptions which hold by default unless a contradiction can be shown [32, 104]. As Poole <ref> [104] </ref> argues, the use of abduction avoids the need to develop a non-classical, non-monotonic logic for default reasoning. In section 3 we will further discuss the use of abduction for default reasoning in greater detail. <p> Default rules provide a way of extending an underlying incomplete theory. Different applications of the defaults can yield different extensions. As already mentioned in section 1, Poole et al. [107] and Poole <ref> [104] </ref> proposes an alternative formalisation of default reasoning in terms of abduction. <p> The new theory F [ should be consistent. This process of theory formation is a form of abduction, where variable-free instances of defaults in D are the candidate abducibles. Poole (theorem 5.1 in <ref> [104] </ref>) shows that the semantics of the theory formation framework hF ; Di is equivalent to that of an abductive framework hF 0 ; A; ;i (see section 1.2) where the default formulae are all atomic. <p> Any such method will be very useful in practice in view of the many diverse applications of abductive reasoning, including default reasoning. The Theorist framework of <ref> [104, 107] </ref> provides such an implementation of abduction by means of a resolution based proof procedure. In their study of NAF through abduction Eshghi and Kowalski [33] have defined an abductive proof procedure for NAF in logic programming. <p> Example 5.10 It is not possible to restore consistency by removing NAF hypotheses given the program: p However, Inoue [55, 56] suggests a general method for restoring consistency, which is applicable to this case. This method (see also section 5.8) is based on [43] and <ref> [104] </ref> and consists in isolating inconsistencies by finding maximally consistent subprograms. In this approach a knowledge system is represented by a pair (P; H), where: 47 1. P and H are both extended logic programs, 2. P represents a set of facts, 3. H represents a set of assumptions. <p> In this approach a knowledge system is represented by a pair (P; H), where: 47 1. P and H are both extended logic programs, 2. P represents a set of facts, 3. H represents a set of assumptions. The semantics is given using abduction as in <ref> [104] </ref> (see section 3) in terms of theory extensions P [ of P , with H maximal with respect to set inclusion, such that P [ has a consistent answer set. <p> A more direct approach to the problem of treating positive and negative predicates symmetrically in default reasoning is presented by Inoue [55, 56] following the methods of [43] and <ref> [104] </ref> (see section 5.6 for a discussion). This work is another interesting application of the notion of maximal consistency to extend logic programming for default reasoning. As a possible direction for future work, it would be desiderable to reconcile the different approaches of Inoue and of Kowalski and Sadri.
Reference: [105] <author> Poole, D., </author> <title> Representing knowledge for logic-based diagnosis. </title> <booktitle> Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1988) 1282-1290 </address>
Reference-contexts: Abduction can be used to generate causal explanations for fault diagnosis (see for example [12, 108]). In medical diagnosis, for example, the candidate hypotheses are the possible causes (diseases), and the observations are the symptoms to be explained <ref> [105, 111] </ref>. Abduction can also be used for 8 model-based diagnosis [31, 115].
Reference: [106] <author> Poole, D., </author> <title> Logic programming, abduction and probability. </title> <booktitle> Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1992) 530-538 </address>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [5, 9, 39, 52, 102, 106, 128] </ref>. Cox and Pietrzykowski [15] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not be explainable in terms of other explanations.
Reference: [107] <author> Poole, D., Goebel, R.G., Aleliunas, </author> <title> Theorist: a logical reasoning system for default and diagnosis. The Knowledge Fronteer: Essays in the Representation of Knowledge, </title> <editor> Cercone and McCalla eds, </editor> <booktitle> Springer Verlag Lecture Notes in Computer Science (1987) 331-352 </booktitle>
Reference-contexts: Cox and Pietrzykowski [15] construct hypotheses from the "dead ends" of linear resolution proofs. Finger and Genesereth [36] generate "deductive solutions to design problems" using the "residue" left behind in resolution proofs. Poole, Goebel and Aleliunas <ref> [107] </ref> also use linear resolution to generate hypotheses. In contrast, the ATMS [71] computes abductive explanations bottom-up. The ATMS can be regarded as a form of hyper-resolution, augmented with subsumption, for propositional logic programs [118]. Lamma and Mello [81] have developed an extension of the ATMS for the non-propositional case. <p> Default rules provide a way of extending an underlying incomplete theory. Different applications of the defaults can yield different extensions. As already mentioned in section 1, Poole et al. <ref> [107] </ref> and Poole [104] proposes an alternative formalisation of default reasoning in terms of abduction. <p> Any such method will be very useful in practice in view of the many diverse applications of abductive reasoning, including default reasoning. The Theorist framework of <ref> [104, 107] </ref> provides such an implementation of abduction by means of a resolution based proof procedure. In their study of NAF through abduction Eshghi and Kowalski [33] have defined an abductive proof procedure for NAF in logic programming.
Reference: [108] <author> Preist, C., Eshghi, K., </author> <title> Consistency-based and abductive diagnoses as generalised stable models. </title> <booktitle> Proc. International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo (1992) 514-521 </address>
Reference-contexts: Abduction can be used to generate causal explanations for fault diagnosis (see for example <ref> [12, 108] </ref>). In medical diagnosis, for example, the candidate hypotheses are the possible causes (diseases), and the observations are the symptoms to be explained [105, 111]. Abduction can also be used for 8 model-based diagnosis [31, 115].
Reference: [109] <author> Przymusinski, </author> <title> T.C., On the declarative and procedural semantics of logic programs. </title> <note> Journal of Automated Reasoning 5 (1989) 167-205 </note>
Reference-contexts: Semantics and proof procedures for ALP have been proposed by Eshghi and Kowalski [32], Kakas and Mancarella [63] and Chen and Warren [10]. Chen and Warren extend the perfect model semantics of Przymusinski <ref> [109] </ref> to include abducibles and integrity constraints over abducibles. Here we shall concentrate on the proposal of Kakas and Mancarella, which extends the stable model semantics. 5.1 Generalised stable model semantics Kakas and Mancarella [63] develop a semantics for ALP by generalising the stable model semantics for logic programming.
Reference: [110] <author> Przymusinski, </author> <title> T.C., Extended stable semantics for normal and disjunctive programs. </title> <booktitle> Proc. 7th International Conference on Logic Programming, </booktitle> <address> Jerusalem (1990) 459-477 </address>
Reference-contexts: It is possible, however, to argue that it is the semantics and not the proof procedure that is at fault. Indeed, Sacca and Zaniolo [120], Przymusinski <ref> [110] </ref> and others have argued that the totality requirement of stable models is too strong. They relax this requirement and consider partial or three-valued stable models instead. In the context of the abductive semantics of NAF this is an argument against the disjunctive integrity constraints. <p> Notice that, although Gelfond and Lifschitz define the answer set semantics directly without transforming the program and then applying the stable model semantics, the transformation can also be used with any other semantics for the resulting transformed program. Thus Przymusinski <ref> [110] </ref> for example applies the well-founded semantics to extended logic programs. Similarly any other semantics can also be applied. This is one of the main advantages of transformational semantics in general. <p> Inoue and Pereira, Aparicio and Alferes assign different semantics to the resulting program. Whereas Inoue applies the answer set semantics, Pereira, Aparicio and Alferes apply the well-founded semantics and the extended stable model semantics of <ref> [110] </ref>. The well-founded semantics can be thought of as representing a minimal incomplete view of the world and the extended stable model semantics as representing different ways of extending this view by abducing negative hypotheses. Pereira, Aparicio and Alferes [98] have also developed proof procedures for this semantics. <p> We then get the consistent set fbat (T om); f ly (T om)g. This problem has been studied in [23] and [97]. Both of these studies are primarily concerned with the related problem of inconsistency of the well-founded semantics when applied to extended logic programs <ref> [110] </ref>. To deal with the problem of inconsistency in extended logic programs, Dung [23] applies the preferred extension semantics to a new abductive framework derived from an extended logic program. <p> The new integrity constraints in I fl have the effect of removing a NAF hypothesis when it leads to a contradiction. Pereira, Aparicio and Alferes [97] employ a similar approach in the context of Przymuszynski's extended stable models <ref> [110] </ref>. It consists in identifying explicitly all the possible sets of NAF hypotheses which lead to an inconsistency and then restoring consistency by removing at least one hypothesis from each such set.
Reference: [111] <author> Reggia, J., </author> <title> Diagnostic experts systems based on a set-covering model. </title> <journal> International Journal of Man-Machine Studies 19(5) (1983) 437-460 </journal>
Reference-contexts: There are other formalisations of abduction. We mention them for completeness, but in the sequel we will concentrate on the logic-based view previously described. * Allemand et al. [2] and Reggia <ref> [111] </ref> present a mathematical char-acterisation, where abduction is defined over sets of observations and hypotheses, in terms of coverings and parsimony. * Levesque [83] gives an account of abduction at the "knowledge level". <p> Abduction can be used to generate causal explanations for fault diagnosis (see for example [12, 108]). In medical diagnosis, for example, the candidate hypotheses are the possible causes (diseases), and the observations are the symptoms to be explained <ref> [105, 111] </ref>. Abduction can also be used for 8 model-based diagnosis [31, 115].
Reference: [112] <author> Reinfrank, M., Dessler, O., </author> <title> On the relation between truth maintenance and non-monotonic logics. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1206-1212 </address>
Reference-contexts: The papers [29, 48, 65, 100], in particular, show that a well-founded labelling for a JTMS corresponds to a stable model of the corresponding logic program. Several authors <ref> [29, 38, 65, 112] </ref>, exploiting the interpretation of stable models as autoepistemic expansions [45], have shown a correspondence between well-founded labellings and stable expansions of the set of justifications viewed as autoepistemic theories.
Reference: [113] <author> Reiter, R., </author> <title> On closed world data bases. Logic and Databases, </title> <editor> Gallaire and Minker eds., </editor> <publisher> Plenum, </publisher> <address> New York(1978) 55-76 75 </address>
Reference-contexts: The relationships between ALP and truth maintenance will be discussed in section 6. 41 5.3 Stable model semantics extended with explicit negation In general logic programs, negative information is inferred by means of NAF. This is appropriate when the closed world assumption <ref> [113] </ref>, that the program gives a complete definition of the positive instances of a predicate, can safely be applied. It is not appropriate when the definition of a predicate is incomplete and therefore "open", as in the case of abducible predicates.
Reference: [114] <author> Reiter, R., </author> <title> A Logic for default reasoning. </title> <booktitle> Artificial Intelligence 13 (1980) 81-132 </booktitle>
Reference-contexts: sense reasoning, the rule that penguins do not fly has priority over the rule that birds fly, and consequently this new conclusion that Tweety does not fly causes the original conclusion to be withdrawn. 13 One of the most important formalisations of default reasoning is the Default Logic of Reiter <ref> [114] </ref>. Reiter separates beliefs into two kinds, ordinary sentences used to express "facts" and default rules of inference used to express general rules.
Reference: [115] <author> Reiter, R., </author> <title> A theory of diagnosis from first principle. </title> <booktitle> Artificial Intelligence 32 (1987) </booktitle>
Reference-contexts: Abduction can be used to generate causal explanations for fault diagnosis (see for example [12, 108]). In medical diagnosis, for example, the candidate hypotheses are the possible causes (diseases), and the observations are the symptoms to be explained [105, 111]. Abduction can also be used for 8 model-based diagnosis <ref> [31, 115] </ref>. In this case the theory describes the "nor-mal" behaviour of the system, and the task is to find a set of hypotheses of the form "some component A is not normal" that explains why the be-haviour of the system is not normal.
Reference: [116] <author> Reiter, R., </author> <title> On integrity constraints. </title> <booktitle> Proc. 2nd Conference on Theoretical Aspects of Reasoning about Knowledge, </booktitle> <editor> Moshe Y. Vardi ed., </editor> <address> Pacific Grove, California (1988) </address>
Reference-contexts: Another view of integrity constraints <ref> [60, 63, 74, 116, 117] </ref> regards these as epistemic or metalevel statements about the content of the database. In this case the integrity constraints are understood as statements at a different level from those in the knowledge base.
Reference: [117] <author> Reiter, R., </author> <title> On asking what a database knows. </title> <booktitle> Proc. Symposium on Computational Logic, </booktitle> <editor> Lloyd ed., </editor> <booktitle> Springer Verlag Lecture Notes in Computer Science (1990) </booktitle>
Reference-contexts: Another view of integrity constraints <ref> [60, 63, 74, 116, 117] </ref> regards these as epistemic or metalevel statements about the content of the database. In this case the integrity constraints are understood as statements at a different level from those in the knowledge base.
Reference: [118] <author> Reiter, R., deKleer, J., </author> <title> Foundations of assumption-based truth maintenance systems: preliminary report. </title> <booktitle> Proc. AAAI '87, </booktitle> <address> Washington, Seattle (1987) 183-188 </address>
Reference-contexts: Poole, Goebel and Aleliunas [107] also use linear resolution to generate hypotheses. In contrast, the ATMS [71] computes abductive explanations bottom-up. The ATMS can be regarded as a form of hyper-resolution, augmented with subsumption, for propositional logic programs <ref> [118] </ref>. Lamma and Mello [81] have developed an extension of the ATMS for the non-propositional case. Resolution-based techniques for computing abduction have also been developed by Demolombe and Fari~nas del Cerro [17] and Gaifman and Shapiro [41]. Abduction can also be applied to logic programming. <p> The dependence r a; b; c; d is not recorded because it is subsumed by the dependence r a; b; c: Reiter and deKleer <ref> [118] </ref> show that, given a set of justifications, nogoods, and candidate assumptions, the ATMS can be understood as computing minimal and consistent abductive explanations in the propositional case (where assumptions are interpreted as abductive hypotheses).
Reference: [119] <author> Rodi, W.L., Pimentel, S.G., </author> <title> A non-monotonic ATMS using stable bases. </title> <booktitle> Proc. 2nd International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> Cambridge, Mass. </address> <year> (1991) </year>
Reference-contexts: Other non-monotonic extensions of ATMS have been developed in <ref> [59, 119] </ref>. It should be noted that one difference between ATMS and ALP is the requirement in ATMS that only minimal sets of assumptions be recorded. This minimality of assumptions is essential for the computational efficiency of the ATMS.
Reference: [120] <author> Sacca, D., Zaniolo, C., </author> <title> Stable models and non determinism for logic programs with negation Proc. </title> <booktitle> ACM SIGMOD-SIGACT Symposium on Principles of Database Systems (1990) 205-217 </booktitle>
Reference-contexts: It is possible, however, to argue that it is the semantics and not the proof procedure that is at fault. Indeed, Sacca and Zaniolo <ref> [120] </ref>, Przymusinski [110] and others have argued that the totality requirement of stable models is too strong. They relax this requirement and consider partial or three-valued stable models instead. In the context of the abductive semantics of NAF this is an argument against the disjunctive integrity constraints. <p> The preferred extension semantics provides a unifying framework for various approaches to the semantics of negation in logic programming. Kakas and Mancarella [68] show that it is equivalent to Sacca and Zaniolo's partial stable model semantics <ref> [120] </ref>. Like the partial stable model semantics, it includes the stable model semantics as a special case. Dung also shows that the well-founded model [129] is the least complete extension that can be constructed bottom-up from the empty set of negative hypotheses, by adding incrementally all acceptable hypotheses.
Reference: [121] <author> Satoh, K., Iwayama, N., </author> <title> Computing abduction using the TMS. </title> <booktitle> Proc. 8th International Conference on Logic Programming, </booktitle> <address> Paris (1991) 505-518 </address>
Reference-contexts: An important problem for the practical use of extended programs is how to distinguish whether a negative condition is to be interpreted as explicit negation or as NAF. We will discuss this problem in section 7. 5.4 Simulation of abduction through NAF Satoh and Iwayama <ref> [121] </ref> show that an abductive logic program can be transformed into a logic program without abducibles but where the integrity constraints remain. Although they do not employ explicit negation, the 43 transformation implicitly simulates explicit negation by the introduction of new predicates. <p> Any semantics can be used for the transformed program (including even a transformational one, e.g. replacing explicitly negated atoms : p (t) by a new atom p 0 (t)). 5.5 Computation of abduction through TMS Satoh and Iwayama <ref> [121] </ref> present a method for computing generalised stable models for logic programs with integrity constraints represented as denials. The method is a bottom-up computation based upon the TMS procedure of [20]. <p> P has two stable models M 1 = fp; qg and M 2 = frg, but only M 2 satisfies I. The proof procedure of <ref> [121] </ref> deterministically computes only the intended model M 2 , without also computing and rejecting M 1 . 5.6 Restoring consistency of answer sets The answer sets of an extended program are not always consistent. <p> This has the advantage that the nogoods of the JTMS can be interpreted as integrity constraints of the abductive framework. The correspondence between abduction and the JTMS is reinforced by <ref> [121] </ref>, who give a proof procedure to compute generalised stable models using the JTMS (see section 5.5). 6.2 Assumption-based truth maintenance Justifications in ATMS have the more restricted Horn clause form p p 1 ; : : : ; p n : However, whereas the JTMS maintains only one implicit context
Reference: [122] <author> Satoh, K., Iwayama, N., </author> <title> A correct top-down proof procedure for a general logic program with integrity constraints. </title> <booktitle> Proc. 3rd International Workshop on Extensions of Logic Programming (1992) 19-34 </booktitle>
Reference-contexts: In the context of the abductive semantics of NAF this is an argument against the disjunctive integrity constraints. An abductive semantics of NAF without disjunctive integrity constraints has been proposed by Dung [22]. The abductive proof procedure is sound with respect to this improved semantics. Satoh and Iwayama <ref> [122] </ref>, on the other hand, show how to extend the abductive proof procedure of [33] to deal correctly with the stable model semantics.
Reference: [123] <author> Sattar, A., Goebel, R., </author> <title> Using crucial literals to select better theories. </title> <type> Technical Report Dept. </type> <institution> of Computer Science, University of Alberta, </institution> <address> Canada (1989) </address>
Reference-contexts: For example Sattar and Goebel <ref> [123] </ref> use "crucial literals" to discriminate between two mutually incompatible explanations. When the crucial literals are tested, one of the explanations is rejected. More generally Evans and Kakas [35] use the notion of corroboration to select explanations.
Reference: [124] <author> Sergot,M., </author> <title> A query-the-user facility for logic programming. Integrated Interactive Computer Systems, </title> <editor> Degano and Sandwell eds., </editor> <publisher> North Hol-land Press (1983) 27-41 76 </publisher>
Reference-contexts: When the crucial literals are tested, one of the explanations is rejected. More generally Evans and Kakas [35] use the notion of corroboration to select explanations. An explanation fails to be corroborated if some of its logical consequences are not observed. A related technique is presented by Sergot in <ref> [124] </ref>, where information is obtained from the user during the process of query evaluation. * Moreover various (domain specific) criteria of preference can be specified. They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations [5, 9, 39, 52, 102, 106, 128]. <p> Instead of failing in a proof when a selected subgoal fails to unify with the head of any rule, the subgoal can be viewed as a hypothesis. This is similar to viewing abducibles as "askable" conditions which are treated as qualifications to answers to queries <ref> [124] </ref>. In the same way that it is useful to distinguish a subset of all predicates as "ask-able", it is useful to distinguish certain predicates as abducible. In fact, it is generally convenient to choose, as abducible predicates, ones which are not conclusions of any clause.
Reference: [125] <author> Shanahan, M., </author> <title> Prediction is deduction but explanation is abduction. </title> <booktitle> Proc. 11th International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Mi (1989) 1055-1060 </address>
Reference-contexts: Abduction can be used in natural language understanding to interpret ambiguous sentences [9, 40, 53, 127]. The abductive explanations correspond to the various possible interpretations of such sentences. In planning problems, plans can be viewed as explanations of the given goal state to be reached <ref> [30, 125] </ref>. These applications of abduction can all be understood as generating hypotheses which are causes for observations which are effects. An application that does not necessarily have a direct causal interpretation is knowledge assimilation [67, 72, 80, 89]. <p> T 1 &lt; T 2 ; initiates (E; P ); persists (T 1 ; P; T 2 ): 10 New information about the predicate holds-at can be assimilated by adding an explanation in terms of some event that generates this property together with an appropriate assumption that the property persists <ref> [30, 62, 125] </ref>. This has the additional effect that the new KB will imply that the property holds until it is terminated in the future [125]. This way of assimilating new information can also be used to resolve conflicts between the current KB and the new information [62, 125]. <p> This has the additional effect that the new KB will imply that the property holds until it is terminated in the future <ref> [125] </ref>. This way of assimilating new information can also be used to resolve conflicts between the current KB and the new information [62, 125]. <p> This has the additional effect that the new KB will imply that the property holds until it is terminated in the future [125]. This way of assimilating new information can also be used to resolve conflicts between the current KB and the new information <ref> [62, 125] </ref>. Suppose for example that the current KB contains the fact (expressed informally) "Mary has book1 at time t 0 " and that the persistence axiom predicts that "Mary has book1 at time t 1 " where t 0 &lt; t 1 .
Reference: [126] <author> Simari, G.R., Loui, </author> <title> R.P, A mathematical treatment of defeasible reasoning and its implementation. </title> <booktitle> Artificial Intelligence 53 (1992) 125-157 </booktitle>
Reference-contexts: However, his interpretation is only an approximation to the definition of acceptability given above and is equivalent to the well-founded semantics [27]. A similar approximation to the notion of acceptability has also been proposed by 31 Simari and Loui <ref> [126] </ref>, who define an argumentation-theoretic framework for default reasoning in general.
Reference: [127] <author> Stickel, </author> <title> M.E., A prolog-like inference system for computing minimum-cost abductive explanations in natural-language interpretation. </title> <booktitle> Proc. International Computer Science Conference (Artificial Intelligence: Theory and Applications), </booktitle> <editor> Honk Kong, Lassez and Chin eds. </editor> <year> (1988) </year> <month> 343-350 </month>
Reference-contexts: Abduction can be used to perform high level vision [15]. The hypotheses are the objects to be recognised, and the observations are partial descriptions of objects. Abduction can be used in natural language understanding to interpret ambiguous sentences <ref> [9, 40, 53, 127] </ref>. The abductive explanations correspond to the various possible interpretations of such sentences. In planning problems, plans can be viewed as explanations of the given goal state to be reached [30, 125].
Reference: [128] <author> Stickel, </author> <title> M.E., Rationale and methods for abductive reasoning in natural language interpretation. </title> <booktitle> Proc. International Scientific Symposium on Natural Language and Logic, Hamburg, Germany, Springer Verlag Lecture Notes in Artificial Intelligence (1989) 233-252 </booktitle>
Reference-contexts: They impose a (partial) order on the sets of hypotheses which leads to the discrimination of explanations <ref> [5, 9, 39, 52, 102, 106, 128] </ref>. Cox and Pietrzykowski [15] identify other desirable properties of abductive explanations. For instance, an explanation should be basic, i.e. should not be explainable in terms of other explanations.
Reference: [129] <author> Van Gelder, A., Ross, K.A., Schlipf, J.S., </author> <title> Unfounded sets and the well-founded semantics for general logic programs. </title> <booktitle> Proc. ACM SIGMOD-SIGACT, Symposium on Principles of Database Systems (1988) </booktitle>
Reference-contexts: The same abductive proof procedure, but where each new hypothesis is added to only at the successful completion of its consistency phase, provides a sound proof procedure for the well-founded semantics <ref> [129] </ref>. Example 4.4 Consider the query p with respect to the abductive framework corresponding to the following program r ~ r p ~ q The abductive proof procedure succeeds with the explanation fq fl g, but the only set of hypotheses which satisfies the integrity constraints is fp fl g. <p> Kakas and Mancarella [68] show that it is equivalent to Sacca and Zaniolo's partial stable model semantics [120]. Like the partial stable model semantics, it includes the stable model semantics as a special case. Dung also shows that the well-founded model <ref> [129] </ref> is the least complete extension that can be constructed bottom-up from the empty set of negative hypotheses, by adding incrementally all acceptable hypotheses. Thus the well-founded semantics is 29 minimalist and sceptical, whereas the preferred extension semantics is max--imalist and credulous.
Reference: [130] <author> Wallace, M., </author> <title> Negation by constraints: a sound and efficient implementation of negation in deductive databases. </title> <booktitle> Proc. 4th Symposium on Logic Programming, </booktitle> <address> San Francisco (1987) 77 </address>
Reference-contexts: Because NAF is a special case of abduction, the problem of constructive negation in logic programming <ref> [4, 8, 130] </ref> is a special case of abduction with non-variable-free hypotheses. We have argued that the implementation of abduction needs to be considered within a broader framework of implementing knowledge assimilation (KA).
References-found: 129

