URL: http://hellgate.cs.nyu.edu:8888/~leunga/src/elf/project/strict+bta/project.ps
Refering-URL: http://hellgate.cs.nyu.edu:8888/~leunga/src/elf/project/strict+bta/
Root-URL: http://www.cs.nyu.edu
Email: leunga@valis.cs.nyu.edu  
Title: Type based program analysis with Elf  
Author: Allen Leung 
Date: December 20, 1995  
Affiliation: Courant Institute of Mathematical Sciences  
Abstract: Elf is a logic programming language with higher order data structures based on Martin-Lof's constructive type theory. In a series of examples we'll demonstrate the use of Elf in the context of type inference based program analysis of a simple functional language. First, a typing system for the language is defined and implemented. We then present the normal order and applicative order operational semantics of this language. Finally, simplified versions of Kuo and Mishra's subtype system for strictness analysis and Gomard et al's subtype system for binding time analysis are implemented.
Abstract-found: 1
Intro-found: 1
Reference: [Bar84] <author> H. P. Barendregt. </author> <title> The Lambda Calculus. Its Syntax and Semantics. </title> <publisher> Elsevier Science Publishing Company, Inc., </publisher> <year> 1984. </year>
Reference-contexts: that this is not derivable from the usual structural rule on !.) The second rule states that given a term M , if M N diverges for every term N then M also itself diverges (see rule (bot).) These axioms can be proven using properties of the untyped lambda calculus <ref> [Bar84] </ref>, whose proofs will be omitted here due to the author's laziness. Typing of constants It is necessary to assign types to the constants of REC. The strictness type of z is of course &gt;, since it is already in normal form.
Reference: [Bis95] <author> Sandip K. Biswas. </author> <title> Higher-order functors with transparent signatures. </title> <booktitle> In Conference Record of POPL '95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 154-163, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: A natural generalization of the ML style module system is to allow higher-order functors and signatures. This is can be modeled in the dependent type framework naturally since types are inherently higher ordered. Descriptions of these systems are found in many places, of which <ref> [Ler95, Bis95] </ref> are some of the latest references. 6.2 Other materials on Elf A formalization of the state transition logic of Elf is found in [Pfe89], in which the notion of proof search is made precise. More examples of Elf is found in the Elf distribution.
Reference: [Ell90] <author> Conal M. Elliott. </author> <title> Extensions and Applications of Higher-Order Unification. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: More examples of Elf is found in the Elf distribution. A tutorial of Elf is also available in [MP91]. Introduction to the LF framework can be found in [HHP93] and [Pfe91]. The higher order unification problem on dependent types is described in Elliott's thesis <ref> [Ell90] </ref>. Finally, the Elf homepage at http://www.cs.cmu.edu/~fp/elf.html contains many additional resources on Elf and LF.
Reference: [GLT89] <author> Jean-Yves Girard, Yves Lafont, and Paul Taylor. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year> <month> 30 </month>
Reference-contexts: A type judgement of the form ` e : P can be viewed in the following manner: e is a proof for the predicate P . This idea of types as propositions <ref> [GLT89, Tho91] </ref> is already implicit in various applications of types in computer science. For example, we when we say e : T in program type checking we mean informally that the program e satisfies the properties of T .
Reference: [HHP93] <author> Rober Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: More examples of Elf is found in the Elf distribution. A tutorial of Elf is also available in [MP91]. Introduction to the LF framework can be found in <ref> [HHP93] </ref> and [Pfe91]. The higher order unification problem on dependent types is described in Elliott's thesis [Ell90]. Finally, the Elf homepage at http://www.cs.cmu.edu/~fp/elf.html contains many additional resources on Elf and LF.
Reference: [JGS93] <author> Neil D. Jones, Carsten K. Gomard, and Peter Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentical Hall, </publisher> <year> 1993. </year>
Reference-contexts: Traditional compiler optimization such as constant propagation, value numbering, loop invariant hoisting, dead code elimination, inlining, etc can all be seen as a variant of the partial evaluation technique. 4.1 Subtyping theory Gomard et al <ref> [JGS93] </ref> describes a subtyping system that can be used to perform this analysis.
Reference: [KM87] <author> Tsung-Min Kuo and Prateek Mishra. </author> <title> On strictness and its analysis. </title> <booktitle> In Conference Record of the Fourteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 144-155, </pages> <address> Munich, Ger-many, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: Lazy evaluation usually involve the process of constructing closures (in an environment-based implementation) or application nodes (in a graph reduction-based implementation). Since we know that these closures or application nodes will eventually evaluated in a strict application, we can avoid this construction cost. The work of Kuo and Mishra <ref> [KM87] </ref> uses a type system to perform this analysis.
Reference: [Ler95] <author> Xavier Leroy. </author> <title> Applicative functors and fully transparent higher-order modules. </title> <booktitle> In Conference Record of POPL '95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 142-153, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: A natural generalization of the ML style module system is to allow higher-order functors and signatures. This is can be modeled in the dependent type framework naturally since types are inherently higher ordered. Descriptions of these systems are found in many places, of which <ref> [Ler95, Bis95] </ref> are some of the latest references. 6.2 Other materials on Elf A formalization of the state transition logic of Elf is found in [Pfe89], in which the notion of proof search is made precise. More examples of Elf is found in the Elf distribution.
Reference: [LM91] <author> Allen Leung and Prateek Mishra. </author> <title> Reasoning about simple and exhaustive demand in higher-order lazy languages. </title> <booktitle> In ACM Transactions on Functional Programming and Computer Architecture, </booktitle> <year> 1991. </year>
Reference-contexts: We have provided an informal introduction to the paradigm of types as propositions and explain how types can be used as a (higher order) logic programming language. Strictness analysis with type inference has been generalized to deal with non-flat datatypes in <ref> [LM91] </ref>. Newer improvement to the type system and completion algorithms of Gomard et al. for binding time analysis can be found in [?]. 29 6.1 Applications of dependent types Dependent types have been studied in details in Martin-Lof's type theory [NPS90].
Reference: [Mac86] <author> David MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In Conference Record of the Thirdteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 277-286, </pages> <address> St. Pe-tersburg Beach, Florida, </address> <month> January </month> <year> 1986. </year>
Reference-contexts: It has also found applications in the semantics of module systems <ref> [Mac86] </ref>. In particular, types in a programming language can be modeled as objects while the signature of module can be modeled as a type family indexed by these program type objects.
Reference: [Men79] <author> Elliott Mendelson. </author> <title> Introduction to Mathematical Logic. Wadsworth Advanced books & Software, </title> <year> 1979. </year>
Reference-contexts: For example, the judgement ` (x:x)z : nat can be simplified into ` z : nat using a single fi reduction. Consider the Hilbert style logical axiom schemas <ref> [Men79] </ref>: A ) B ) A We have the following "proofs" of these axioms in type theory: 2 x:y:x : A ! B ! A Notice that the two lambda terms are simply the combinators K and S! (The other logical axiom schema (:B ) :A) ) (:B ) A) )
Reference: [MP91] <author> Sipro Michaylov and Frank Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <booktitle> In Proceedings of the Second International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 299-344, </pages> <year> 1991. </year>
Reference-contexts: More examples of Elf is found in the Elf distribution. A tutorial of Elf is also available in <ref> [MP91] </ref>. Introduction to the LF framework can be found in [HHP93] and [Pfe91]. The higher order unification problem on dependent types is described in Elliott's thesis [Ell90]. Finally, the Elf homepage at http://www.cs.cmu.edu/~fp/elf.html contains many additional resources on Elf and LF.
Reference: [NPS90] <author> Bengt Nordstrom, Kent Petersson, and Jan M. Smith. </author> <title> Programming in Martin-Lof's type theory: an introduction. </title> <publisher> Oxford University Press, </publisher> <year> 1990. </year>
Reference-contexts: Newer improvement to the type system and completion algorithms of Gomard et al. for binding time analysis can be found in [?]. 29 6.1 Applications of dependent types Dependent types have been studied in details in Martin-Lof's type theory <ref> [NPS90] </ref>. It has also found applications in the semantics of module systems [Mac86]. In particular, types in a programming language can be modeled as objects while the signature of module can be modeled as a type family indexed by these program type objects.
Reference: [Pfe89] <author> Frank Pfenning. </author> <title> Elf: A language for logic definition and verified meta-programming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 313-322. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Elf <ref> [Pfe89] </ref> is a logic programming language with higher order data structures based on Martin-Lof's type theory. In this report we'll demonstrate the use of Elf in the context of type inference based program analysis of a simple functional language which we'll called REC. <p> Descriptions of these systems are found in many places, of which [Ler95, Bis95] are some of the latest references. 6.2 Other materials on Elf A formalization of the state transition logic of Elf is found in <ref> [Pfe89] </ref>, in which the notion of proof search is made precise. More examples of Elf is found in the Elf distribution. A tutorial of Elf is also available in [MP91]. Introduction to the LF framework can be found in [HHP93] and [Pfe91].
Reference: [Pfe91] <author> Frank Pfenning. </author> <booktitle> Logic programming in the LF logical framework, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: More examples of Elf is found in the Elf distribution. A tutorial of Elf is also available in [MP91]. Introduction to the LF framework can be found in [HHP93] and <ref> [Pfe91] </ref>. The higher order unification problem on dependent types is described in Elliott's thesis [Ell90]. Finally, the Elf homepage at http://www.cs.cmu.edu/~fp/elf.html contains many additional resources on Elf and LF.
Reference: [Tho91] <author> Simon Thompson. </author> <title> Type Theory and Functional Programming. </title> <address> Addison-Welsey, </address> <year> 1991. </year>
Reference-contexts: A type judgement of the form ` e : P can be viewed in the following manner: e is a proof for the predicate P . This idea of types as propositions <ref> [GLT89, Tho91] </ref> is already implicit in various applications of types in computer science. For example, we when we say e : T in program type checking we mean informally that the program e satisfies the properties of T .
Reference: [Win93] <editor> Glynn Winskel. </editor> <booktitle> The Formal Semantics of Programming Languages: </booktitle>
References-found: 17

