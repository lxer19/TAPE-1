URL: http://www.cs.utexas.edu/users/vlr/papers/minspan.ps
Refering-URL: http://www.cs.utexas.edu/users/vlr/pub.html
Root-URL: 
Title: Computing Minimal Spanning Subgraphs in Linear Time  
Author: Xiaofeng Han Pierre Kelsen Vijaya Ramachandran Robert Tarjan 
Affiliation: Department of Computer Science, Princeton University,  Department of Computer Science, University of British Columbia,  Department of Computer Sciences, University of Texas,  Department of Computer Sciences, University of Texas,  
Address: West Oak Street, Baskingridge, NJ  Princeton, NJ 08544.  Vancouver, B.C. CANADA V6N 1Z4.  Austin, TX 78712  Austin, TX 78712;  
Note: In SIAM JOURNAL ON COMPUTING, 1995. Copyright SIAM  Current affiliation: Zyga Corporation, 28  07920. Research done while he was a graduate student at the  Research done while he was a graduate student at the  and supported in part by NSF grant CCR-89-10707.  supported in part by NSF grant CCR-89-10707.  
Abstract: Let P be a property of undirected graphs. We consider the following problem: given a graph G that has property P , find a minimal spanning subgraph of G with property P . We describe general algorithms for this problem and prove their correctness under fairly weak assumptions about P . We establish that the worst-case running time of these algorithms is fi(m+n log n) for 2-edge-connectivity and biconnectivity where n and m denote the number of vertices and edges, respectively, in the input graph. By refining the basic algorithms we obtain the first linear time algorithms for computing a minimal 2-edge-connected spanning subgraph and for computing a minimal biconnected spanning subgraph. We also devise general algorithms for computing a minimal spanning subgraph in directed graphs. These algorithms allow us to simplify an earlier algorithm of Gibbons, Karp, Ramachan-dran, Soroker and Tarjan for computing a minimal strongly connected spanning subgraph. We also provide the first tight analysis of the latter algorithm, showing that its worst-case time complexity is fi(m + n log n). x Department of Computer Science, Princeton University, Princeton, NJ 08544 and NEC Research Institute, 4 Independence Way, Princeton, NJ 08540. Research at Princeton University partially supported by the National Science Foundation, Grant No. CCR-8920505, the Office of Naval Research, Contract No. N00014-91-J-1463, and by DIMACS (Center for Discrete Mathematics and Theoretical Computer Science), a National Science Foundation Science and Technology Center, Grant No. NSF-STC88-09648. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, J.E. Hopcroft AND J.D. Ullman, </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference: [2] <author> J.A. Bondy and U.S.R. Murty, </author> <title> Graph Theory with Applications, </title> <publisher> North-Holland, </publisher> <year> 1976. </year>
Reference-contexts: sequential model of computation that we assume in this paper is the RAM ([1]) with a word length of O (log n) bits where n is the length of the input (or the number of vertices in the input graph). 2 Definitions We introduce graph terminology similar to that of <ref> [2] </ref>.
Reference: [3] <author> F. Chung AND R.L. Graham, </author> <title> Private communication, </title> <note> 1977; cited in [7]. </note>
Reference: [4] <author> R. Cole AND U. Vishkin, </author> <title> Approximate and exact parallel scheduling with applications to list, tree, and graph problems, </title> <booktitle> Proc. 27th Ann. IEEE Symp. on Foundations of Comp. Sci., </booktitle> <year> 1986, </year> <month> pp.478-491. </month>
Reference: [5] <author> E. Dahlhaus, M. Karpinski AND P. Kelsen, </author> <title> An efficient parallel algorithm for finding a maximal independent set in a hypergraph of dimension 3, </title> <journal> Inf. Proc. Letters, </journal> <volume> vol. 42, </volume> <pages> pp. 309-313, </pages> <year> 1992. </year>
Reference-contexts: Efficient (deterministic) parallel algorithms for finding a maximal independent set in an independence system are known for the special case where the size of a minimal dependent set is 2 or 3 ([16], [9], <ref> [5] </ref>). For the problems that are of interest to us minimal dependent sets may have nonconstant size and hence a different approach is needed for obtaining fast parallel algorithms.
Reference: [6] <author> J. Edmonds, Edge-disjoint branchings, </author> <title> in "Combinatorial Algorithms", </title> <publisher> pp.91-96, Algorithmic Press, </publisher> <address> New York, </address> <year> 1973. </year>
Reference: [7] <author> M.R. Garey AND D.S. Johnson, </author> <title> Computers and Intractability: a Guide to the Theory of NP-Completeness, </title> <publisher> Freeman, </publisher> <address> San Francisco, CA, </address> <year> 1979. </year>
Reference-contexts: We are interested in the sequential and parallel complexity of this problem. The corresponding problem of finding a minimum spanning subgraph having a given property has been widely studied. We mention two results: Chung and Graham ([3], <ref> [7] </ref>) proved that the problems of finding a minimum k-vertex-connected or k-edge-connected spanning subgraph are N P -hard for any fixed k 2. For the more relaxed problem of finding sparse but not necessarily minimal k-edge-connected and k-vertex-connected spanning subgraphs, linear time algorithms are known ([18]).
Reference: [8] <author> P. Gibbons, R.M. Karp, V. Ramachandran, D. Soroker, AND R. Tarjan, </author> <title> Transitive compaction in parallel via branchings, </title> <journal> J. Algorithms, </journal> <volume> vol. 12, </volume> <year> 1991, </year> <pages> pp. 110-125. </pages>
Reference-contexts: For the problems that are of interest to us minimal dependent sets may have nonconstant size and hence a different approach is needed for obtaining fast parallel algorithms. The minimal spanning subgraph problem has been studied earlier for the property of strong connectivity (transitive compaction problem <ref> [8] </ref>) and for 2-edge-connectivity and biconnectivity 1 ([13]). For these problems algorithms are given in ([8], [13]) that run in O (m + n log n) sequential time and can be implemented as NC algorithms; here n and m represent the number of vertices and edges in the input graph. <p> We also describe general algorithms for computing a minimal spanning subgraph in directed graphs with respect to any monotone property that implies strong connectivity. For the special case of strong connectivity, we are able to simplify the algorithm of <ref> [8] </ref> for computing a minimal strongly connected spanning subgraph. We also provide the first tight analysis of the latter algorithm, showing that its worst-case running time is fi (m + n log n). This answers a question posed in [8]. This paper is organized as follows. <p> of strong connectivity, we are able to simplify the algorithm of <ref> [8] </ref> for computing a minimal strongly connected spanning subgraph. We also provide the first tight analysis of the latter algorithm, showing that its worst-case running time is fi (m + n log n). This answers a question posed in [8]. This paper is organized as follows. The next section defines the terms from graph theory used in this paper. In section 3 we describe and analyze general algorithms for computing minimal spanning subgraphs in undirected graphs. <p> In section 6 we develop and analyze general algorithms for computing minimal spanning subgraphs in directed graphs. In that section we also analyze an algorithm of <ref> [8] </ref> for computing a minimal strongly connected spanning subgraph and we provide a simplified algorithm for the problem. <p> By observation 1 the resulting subgraph is a minimal spanning P -subgraph of G. The following algorithm is a generalization of algorithms given in [13] and <ref> [8] </ref> (for finding a minimal 2-edge-connected, a minimal biconnected, and a minimal strongly connected spanning subgraph of a graph) to graph properties satisfying C1 and C2. <p> For the special case of strong connectivity we obtain an algorithm that computes a minimal strongly connected spanning subgraph in time O (m+n log n). This algorithm is simpler (both in the sequential and parallel implementation) than an earlier algorithm of <ref> [8] </ref> for this problem because it avoids the explicit computation of redundant edges. We prove that our algorithms require fi (m + n log n) time in the worst case for strong connectivity. <p> We prove that our algorithms require fi (m + n log n) time in the worst case for strong connectivity. By adapting the analysis we also get a fi (m + n log n) tight bound on the worst-case running time of an algorithm of <ref> [8] </ref> for finding a minimal strongly connected spanning subgraph. This answers an open question of [8]. 6.1 High-Level Algorithm Let G be a directed graph. A forward branching ([8]) rooted at a vertex x is a spanning subgraph of G whose underlying graph is a tree and in which x has <p> By adapting the analysis we also get a fi (m + n log n) tight bound on the worst-case running time of an algorithm of <ref> [8] </ref> for finding a minimal strongly connected spanning subgraph. This answers an open question of [8]. 6.1 High-Level Algorithm Let G be a directed graph. A forward branching ([8]) rooted at a vertex x is a spanning subgraph of G whose underlying graph is a tree and in which x has in-degree zero and all other vertices have in-degree one. <p> Hence jR i+1 j 1 2 jR i j. 2 6.2 Computing a Minimal Strongly Connected Spanning Subgraph In this subsection we adapt algorithm 7 to strong connectivity. Before we do this we review the algorithm of <ref> [8] </ref> for computing a minimal strongly connected spanning subgraph (called transitive compaction in [8]). The following definitions from [8] will be needed. Let G be a directed graph and x 2 V (G). <p> Before we do this we review the algorithm of <ref> [8] </ref> for computing a minimal strongly connected spanning subgraph (called transitive compaction in [8]). The following definitions from [8] will be needed. Let G be a directed graph and x 2 V (G). <p> Before we do this we review the algorithm of <ref> [8] </ref> for computing a minimal strongly connected spanning subgraph (called transitive compaction in [8]). The following definitions from [8] will be needed. Let G be a directed graph and x 2 V (G). An inverse branching rooted at x is a spanning subgraph of G whose underlying graph is a tree and in which x has out-degree zero and all other vertices have out-degree one. <p> Let H be a subgraph of G. An H-philic (H-phobic) branching in G is one that has the greatest (smallest) number of edges in common with H over all branchings (rooted at x) in G. In <ref> [8] </ref> the following algorithm is given for finding a minimal strongly connected spanning subgraph in a strongly connected digraph. Algorithm 8 Computing a minimal strongly connected spanning subgraph H of G. Input Strongly connected digraph G. <p> One iteration of the while-loop of algorithm 8 can be performed in linear time (see <ref> [8] </ref> for details). Algorithm 8 is a special case of algorithm 6 in the following sense: first, F (computed in step 2.2) is an optimal branching in H; second, F [ I = F [ (I F ) and I F is a minimal augmentation for F in H. <p> Thus, theorem 16 (or a similar result of <ref> [8] </ref>) implies that algorithm 8 runs in O (m + n log n) time. We now adapt algorithm 7 for strong connectivity so that it runs in O (m + n log n) time as well. <p> A spanning tree T H with a maximum number of edges of S is an S-philic forward branching. It can be computed in linear time using Edmonds' minimum weight branching algorithm as explained in <ref> [8] </ref>. To compute a minimal augmentation A for T H , we compute a T H -philic inverse branching I and set A = E (I) E (T H ). This can again be done in linear time using Edmonds' minimum weight branching algorithm ([8]). <p> This implementation of algorithm 7 is simpler than algorithm 8 since it does not require the redundant edges to be computed at each step (this is a fairly involved procedure). These simplifications are even more apparent in the parallel implementation of algorithm 8. Indeed, most of <ref> [8] </ref> is concerned with developing a fairly involved parallel algorithm for computing the redundant edges. Algorithm 7 can be parallelized just as algorithm 8. It does not require redundant edges to be computed (resulting in a much simpler implementation) while achieving the same parallel complexity. As pointed out in [8] it <p> of <ref> [8] </ref> is concerned with developing a fairly involved parallel algorithm for computing the redundant edges. Algorithm 7 can be parallelized just as algorithm 8. It does not require redundant edges to be computed (resulting in a much simpler implementation) while achieving the same parallel complexity. As pointed out in [8] it is conceivable that algorithm 8 terminates in a constant number of iterations of the while-loop, resulting in a linear worst-case running time. It would then be asymptotically faster than algorithm 7 which always runs in time fi (m + n log n). <p> In the remainder of this section we shall rule out this possibility by showing that algorithm 8 requires fi (m + n log n) time in the worst case, thus answering a question of <ref> [8] </ref>. Because algorithm 8 is a special case of algorithm 6 this will imply a similar result for the worst-case time complexity of algorithm 6 (for strong connectivity). <p> Since each iteration of algorithm 8 requires time (n), we infer that algorithm 8 requires (m + n log n) time in the worst case. This bound is tight because it is shown in <ref> [8] </ref> that the algorithm terminates in time O (m + n log n). 2 We now turn our attention to algorithm 6.
Reference: [9] <author> M. Goldberg AND T. Spencer, </author> <title> A new parallel algorithm for the maximal independent set problem, </title> <journal> SIAM J. Computing, </journal> <volume> vol. 18, </volume> <year> 1989, </year> <month> pp.419-427. </month>
Reference-contexts: Efficient (deterministic) parallel algorithms for finding a maximal independent set in an independence system are known for the special case where the size of a minimal dependent set is 2 or 3 ([16], <ref> [9] </ref>, [5]). For the problems that are of interest to us minimal dependent sets may have nonconstant size and hence a different approach is needed for obtaining fast parallel algorithms.
Reference: [10] <author> X. Han, </author> <title> An algorithmic approach to extremal graph problems, </title> <type> Ph.D. Thesis, </type> <month> June </month> <year> 1991, </year> <institution> Department of Computer Sciences, Princeton University, Princeton, NJ. </institution>
Reference-contexts: Algorithm 1 was first described in [14] while algorithms 2 and 3 are generalizations of algorithms for finding a minimal 2-edge-connected and a minimal biconnected spanning subgraph given in <ref> [10] </ref>. A graph property P is a Boolean-valued function on graphs. If P (G) is true for some graph G, we say that G has property P or G is a P -graph. A P-subgraph of G is a subgraph of G that has property P .
Reference: [11] <author> R.M. Karp and V. Ramachandran, </author> <title> Parallel algorithms for shared-memory machines, </title> <editor> in J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, Vol. A, </booktitle> <pages> pp. 869-941, </pages> <publisher> MIT Press/Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: In the next section we describe how to modify algorithm 3 so that it runs in linear time for 2-edge-connectivity and biconnectivity. We obtain a result similar to theorem 6 for the parallel complexity of computing a minimal spanning P -subgraph. (For a definition of the PRAM model see <ref> [11] </ref>.) Theorem 8 Assume that P satisfies C1 and C2 and also implies 2-edge-connectivity.
Reference: [12] <author> R.M. Karp, E. Upfal, AND A. Wigderson, </author> <title> The complexity of parallel search, </title> <journal> J.C.S.S., </journal> <volume> vol. 36, </volume> <year> 1988, </year> <month> pp.225-253. </month>
Reference: [13] <author> P. Kelsen AND V. Ramachandran, </author> <title> On finding minimal 2-connected subgraphs, Journal of Algorithms, </title> <booktitle> to appear; extended abstract in Proceedings of the Second ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <address> San Francisco, </address> <year> 1991, </year> <pages> pp. 178-187. </pages>
Reference-contexts: The minimal spanning subgraph problem has been studied earlier for the property of strong connectivity (transitive compaction problem [8]) and for 2-edge-connectivity and biconnectivity 1 (<ref> [13] </ref>). For these problems algorithms are given in ([8], [13]) that run in O (m + n log n) sequential time and can be implemented as NC algorithms; here n and m represent the number of vertices and edges in the input graph. <p> We analyze the worst-case complexity of these algorithms. We show that the algorithms for 2-edge-connectivity and biconnectivity require (log n) iterations in the worst-case; this implies that the worst-case time of these algorithms is fi (m + n log n), thus settling open questions posed in <ref> [13] </ref>. We describe refinements of the basic algorithms for 2-edge-connectivity and biconnectivity and obtain the first linear time algorithms for these properties. <p> By observation 1 the resulting subgraph is a minimal spanning P -subgraph of G. The following algorithm is a generalization of algorithms given in <ref> [13] </ref> and [8] (for finding a minimal 2-edge-connected, a minimal biconnected, and a minimal strongly connected spanning subgraph of a graph) to graph properties satisfying C1 and C2. <p> Thus each iteration of the while-loop requires time O (t (m; n)). By the previous result algorithm 3 terminates after O (log n) iterations of the while-loop. The claim follows. 2 In <ref> [13] </ref> linear time algorithms for computing a minimal augmentation for 2-edge-connectivity and biconnectivity are described. By theorem 6 algorithm 3 computes a minimal 2-edge-connected and a minimal biconnected spanning subgraph in time O ((m + n) log n). In fact the following stronger bound applies. <p> For biconnectivity a result of Plummer ([19]) states that every minimal biconnected graph (i.e., biconnected graph with no redundant edges) has O (n) edges. Thus jAj = O (n) for biconnectivity as well. 2 Algorithms for the same problems achieving similar time bounds are presented in <ref> [13] </ref>. Those algorithms are more complicated than algorithm 3 because they require redundant edges to be computed explicitly (a fairly involved procedure using ideas from triconnectivity testing). In section 4 we shall prove that the bound given in the last theorem is tight. <p> The minimal augmentation step can be done in polylogarithmic time on a linear number of processors as shown in <ref> [13] </ref> for biconnectivity and 2-edge-connectivity. 4 Linear Time Algorithms In this section we adapt algorithm 3 to compute minimal spanning subgraphs for 2-edge-connectivity and biconnectivity in linear time. The linear time bound is achieved by combining the linear time minimal augmentation procedures given in [13] with a method for reducing the <p> number of processors as shown in <ref> [13] </ref> for biconnectivity and 2-edge-connectivity. 4 Linear Time Algorithms In this section we adapt algorithm 3 to compute minimal spanning subgraphs for 2-edge-connectivity and biconnectivity in linear time. The linear time bound is achieved by combining the linear time minimal augmentation procedures given in [13] with a method for reducing the size of the current graph while preserving its 2-edge-connectivity (biconnectivity) structure. 4.1 Finding a Minimal 2-Edge-Connected Spanning Subgraph We start with a description of two graph operations that preserve the 2-edge-connectivity structure. <p> In step 2.0 we replace H by a sparse 2-edge-connected subgraph to speed up subsequent steps; this also simplifies the analysis of algorithm 3. A linear time algorithm for computing a minimal augmentation for 2-edge-connectivity (step 2.2) is given in <ref> [13] </ref>. We finally note that the intermediate graphs need not be simple even if the input graph G is simple. Algorithm 4 Computing a minimal 2-edge-connected spanning subgraph of G. Input 2-edge-connected graph G. <p> We compute an optimal tree T H and S-critical edges in linear time and space as described in the proof of theorem 6. We compute a minimal augmentation in linear time and space using the algorithm of <ref> [13] </ref>. To compute the S-critical edges, we determine the connected components of (V (H); S). Finally, the complexity of computing a full contraction is dominated by the complexity of computing 2-edge-connected components ([22]), i.e., it can be done in linear time and space. <p> In summary one iteration of algorithm 4 can be performed in linear time and space. The claim follows with corollary 3. 2 15 Note: An efficient N C algorithm for this problem is given in <ref> [13] </ref>. <p> The following algorithm is a variation of algorithm 3 in which we replace H by its full contraction at the end of each iteration of the while-loop. It is shown in <ref> [13] </ref> that the minimal augmentation step (step 2.2) can be done in linear time. We note that the intermediate graph H will always be simple assuming that the input graph G is simple (the usual assumption for biconnected graphs). 19 Algorithm 5 Computing a minimal biconnected spanning subgraph of G. <p> We compute an optimal tree T H and S-critical edges in linear time and space as described in the proof of theorem 6. We compute a minimal augmentation in linear time and space using the algorithm of <ref> [13] </ref>. Finally, the complexity of computing a full contraction is dominated by the complexity of computing blocks, i.e., it can be done in linear time and space ([22]). In summary one iteration of algorithm 5 can be performed in linear time and space. <p> The claim follows with corollary 6. 2 As was the case for 2-edge-connectivity the last result yields an improvement by a fi (log n) factor in the work of an efficient NC algorithm described in <ref> [13] </ref> for computing a minimal biconnected spanning subgraph. 22 5 Worst-Case Analysis In this section we prove that algorithm 3 requires fi (m + n log n) in the worst case for 2-edge-connectivity and biconnectivity. <p> Since each iteration of these algorithms takes (n) time they require (m + n log n) time in the worst case. By corollary 7 the same bound applies to algorithm 3. Because of theorem 7 this bound is tight for algorithm 3. In <ref> [13] </ref> it is shown that redundant edges can be determined for 2-edge-connectivity and biconnectivity in linear time by modifying the linear-time triconnectivity algorithm of [21]. Thus the bound is tight for algorithm 1 as well.
Reference: [14] <author> P. Kelsen AND V. Ramachandran, </author> <title> The complexity of finding minimal spanning subgraphs, </title> <type> Tech. Report TR-91-17, </type> <institution> 1991, Department of Computer Sciences, University of Texas, Austin, </institution> <address> TX 78712. </address>
Reference-contexts: A trivial ear is an ear containing a single edge. 3 Finding a Minimal Spanning Subgraph in Undirected Graphs In this section we describe three closely related algorithms for finding a minimal spanning subgraph of a graph for various properties of undirected graphs. Algorithm 1 was first described in <ref> [14] </ref> while algorithms 2 and 3 are generalizations of algorithms for finding a minimal 2-edge-connected and a minimal biconnected spanning subgraph given in [10]. A graph property P is a Boolean-valued function on graphs. <p> The results in this paper suggest that it may be possible to achieve linear time by combining the basic algorithms with various contraction operations (this approach has worked for 38 2-edge-connectivity and biconnectivity). Unfortunately we proved in <ref> [14] </ref> (using a fairly involved construction) that this approach will not improve the worst-case running time if we only collapse cycles and contract chains. A new approach seems necessary. 39
Reference: [15] <author> J.M. Lewis AND M. Yannakakis, </author> <title> The node-deletion problem for hereditary properties is N P - complete, </title> <editor> J. C. S. S., </editor> <volume> vol. 20, </volume> <year> 1980, </year> <month> pp.219-230. </month>
Reference-contexts: For the more relaxed problem of finding sparse but not necessarily minimal k-edge-connected and k-vertex-connected spanning subgraphs, linear time algorithms are known ([18]). Yannakakis ([24]; see also <ref> [15] </ref>) showed that the related problem of deleting a minimum set of edges so that the resulting graph has a given property is N P -hard for several graph properties (e.g., planar, outerplanar, transitive digraph).
Reference: [16] <author> M. Luby, </author> <title> A simple parallel algorithm for the maximal independent set problem, </title> <journal> SIAM J. Computing, </journal> <volume> vol. 15, </volume> <year> 1986, </year> <pages> pp. 1036-1053. </pages>
Reference: [17] <author> G. Miller AND J.H. Reif, </author> <title> Parallel tree contraction and its applications, </title> <booktitle> Proc. 26th Ann. Symp. on Foundations of Comp. </booktitle> <institution> Sci., pp.478-489, </institution> <year> 1985. </year>
Reference: [18] <author> H. Nagamochi AND T. Ibaraki, </author> <title> Linear time algorithms for finding a sparse k-connected spanning subgraph of a k-connected graph, </title> <journal> Algorithmica, </journal> <volume> vol. 7, </volume> <year> 1992, </year> <pages> pp. 583-596. </pages>
Reference: [19] <author> M. D. Plummer, </author> <title> On minimal blocks, </title> <journal> Trans. Amer. Math. Soc., </journal> <volume> vol. 134, </volume> <year> 1968, </year> <month> pp.85-94. </month>
Reference: [20] <author> V. Ramachandran, </author> <title> Fast parallel algorithms for reducible flow graphs, Concurrent Computations: Algorithms, Architecture and Technology, S.K. </title> <editor> Tewksbury, B.W. Dickinson and S.C. Schwartz, ed., </editor> <publisher> Plenum press, </publisher> <address> New York, NY, </address> <year> 1988, </year> <title> pp.117-138; see also Fast and processor-efficient parallel algorithms for reducible flow graphs, </title> <type> Tech. Report ACT-103, </type> <month> November </month> <year> 1988, </year> <institution> Coordinated Science Laboratory, University of Illinois, Urbana, Illinois, </institution> <address> IL 61801. </address>
Reference-contexts: Because various computations on trees can be performed efficiently, both sequentially ([22]) and in parallel ([17], <ref> [20] </ref>), this algorithm provides a useful paradigm for the sequential and parallel determination of minimal spanning subgraphs with respect to connectivity properties. We analyze the worst-case complexity of these algorithms.
Reference: [21] <author> V. Ramachandran, </author> <title> Parallel open ear decomposition with applications to graph biconnectivity and triconnectivity, in Synthesis of Parallel Algorithms, </title> <editor> J. Reif, ed., </editor> <publisher> Morgan-Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: Proof. Consider one iteration of the while-loop. We compute an ear decomposition in linear time and space using the algorithm of <ref> [21] </ref>. We compute an optimal tree T H and S-critical edges in linear time and space as described in the proof of theorem 6. We compute a minimal augmentation in linear time and space using the algorithm of [13]. <p> Proof. Consider one iteration of the while-loop. We compute an open ear decomposition in linear time and space using the algorithm of <ref> [21] </ref>. We compute an optimal tree T H and S-critical edges in linear time and space as described in the proof of theorem 6. We compute a minimal augmentation in linear time and space using the algorithm of [13]. <p> By corollary 7 the same bound applies to algorithm 3. Because of theorem 7 this bound is tight for algorithm 3. In [13] it is shown that redundant edges can be determined for 2-edge-connectivity and biconnectivity in linear time by modifying the linear-time triconnectivity algorithm of <ref> [21] </ref>. Thus the bound is tight for algorithm 1 as well.
Reference: [22] <author> R. Tarjan, </author> <title> Depth first search and linear graph algorithms, </title> <journal> SIAM J. Computing, </journal> <volume> vol. 1, </volume> <year> 1972, </year> <month> pp.146-160. </month>
Reference: [23] <author> W. Tutte, </author> <title> Graph theory, </title> <publisher> Addison-Wesley, </publisher> <year> 1984. </year>
Reference: [24] <author> M. Yannakakis, </author> <title> Node- and edge-deletion NP-complete problems, </title> <booktitle> Proc. 10th Ann. ACM Symp. on Theory of Computing, </booktitle> <address> New York, </address> <year> 1978, </year> <pages> pp. 253-264. 41 </pages>
References-found: 24

