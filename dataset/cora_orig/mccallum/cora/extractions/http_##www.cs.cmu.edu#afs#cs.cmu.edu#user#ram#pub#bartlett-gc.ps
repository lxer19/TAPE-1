URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/user/ram/pub/bartlett-gc.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/user/ram/pub/
Root-URL: 
Title: Compacting Garbage Collection with Ambiguous Roots  
Author: Joel F. Bartlett 
Address: 100 Hamilton Avenue Palo Alto, California 94301 USA  
Affiliation: Western Research Laboratory  
Note: Copyright 1988, Digital Equipment Corporation d i g i t a l  
Date: February, 1988  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> David H. Bartley, John C. Jensen. </author> <title> The Implementation of PC Scheme. </title> <booktitle> In 1986 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 86-93. </pages> <month> August, </month> <year> 1986. </year>
Reference-contexts: One way of creating continuations is to copy the program state found in the registers and the stack to a heap allocated data structure <ref> [1] </ref>. When the continuation is invoked, the saved stack and register contents are restored. While this has the disadvantage of having to copy data, the format of the stack and the use of the registers need not be known.
Reference: [2] <author> D. G. Bobrow. </author> <title> Managing Reentrant Structures Using Reference Counts. </title> <journal> ACM Transactions on Programming Languages and Systems 2(3) </journal> <pages> 269-273, </pages> <month> July, </month> <year> 1980. </year>
Reference-contexts: While Cedar initially used a method similar to Interlisp's, a new collector was designed because the implementers felt that the Interlisp collector had too high an execution cost, and was too complex. Even though they were aware of proposals for managing reference counts in circular structures <ref> [2] </ref>, they chose to implement a conventional trace-and-sweep (also known as mark-and-sweep) collector to reclaim inaccessible circular structures as it was simple and it was unclear how frequent circular structures were.
Reference: [3] <author> Jacques Cohen. </author> <title> Garbage Collection of Linked Data Structures. </title> <journal> ACM Computing Surveys 13(3) </journal> <pages> 341-367, </pages> <month> September, </month> <year> 1981. </year>
Reference-contexts: Many of the modern garbage collectors [10] recover space by copying accessible objects into some "new space". Two of the attractive properties of a copying collector are that it results in memory compaction and it can have a running time proportional to the amount of accessible storage <ref> [3] </ref>. However, such schemes place a large burden on the underlying system as not only must all objects be visible, but all pointers to the objects must be found and changed. In addition, a mechanism must be provided to update any values which have been derived from pointers. <p> With the overview of earlier and concurrent work completed, our attention will now turn to the new algorithms. 1.2. An Overview of Stop-and-Copy Garbage Collection The "mostly-copying" collector is best understood by showing how it is an evolution of the classical "stop-and-copy collector" <ref> [3] </ref>. In discussing the algorithms, we will restrict ourselves to the allocation of fixed-length cells containing two pointers, i.e. a Lisp cons cell. Each pointer in the cell will assumed to be either a pointer or NULL. <p> This is because the VAX employs a "caller save" protocol to retain register values across procedure calls, so no valid pointers are ever in the registers during storage allocation. 5. Comparison with the Classical Algorithm The new algorithm is similar to the classical algorithm in its resource demands <ref> [3] </ref>. It requires slightly more storage in the form of the space, link, type, and promoted fields associated with each page. It would not be unreasonable to store these in two 32-bit integers. Given a page size of 512 bytes, this requires less than 2% additional storage.
Reference: [4] <author> John DeTreville, </author> <title> Digitial Systems Research Center. </title> <type> Private communication, </type> <month> February 12, </month> <year> 1988. </year>
Reference-contexts: While it seems to pose no constraints on the client programs, it does not compact the heap. Also, one of the reviewers of this paper indicated that he was exploring the use of ideas similar to those expressed here in a concurrent collector <ref> [4] </ref>. With the overview of earlier and concurrent work completed, our attention will now turn to the new algorithms. 1.2. An Overview of Stop-and-Copy Garbage Collection The "mostly-copying" collector is best understood by showing how it is an evolution of the classical "stop-and-copy collector" [3].
Reference: [5] <author> L. Peter Deutsch, Daniel G. Bobrow. </author> <title> An Efficient, Incremental, Automatic Collector. </title> <journal> Communications of the ACM 19(9) </journal> <pages> 522-526, </pages> <month> September, </month> <year> 1976. </year>
Reference-contexts: Second, a mechanism must be provided to maintain these reference counts. This can be done explicitly by the programmer, or implicitly by the compiler. Finally, this method cannot recover circular structures. Significant improvements were made to this basic method, and a collector using reference counts was used for Interlisp <ref> [5] </ref>. In this collector, reference count maintenance is reduced because references which are on the stack are not counted. When space is being recovered, the stack contents are used as "hints" to retain items even though their reference counts were zero.
Reference: [6] <author> Richard P. Gabriel. </author> <title> Performance and Evaluation of Lisp Systems. </title> <publisher> The MIT Press, </publisher> <year> 1985, </year> <pages> pages 116-135. </pages>
Reference-contexts: Each of these collectors was then used to run two sample programs with varying page sizes. The sample programs were the Titan Scheme compiler and repeated executions of the Boyer benchmark <ref> [6] </ref>. The page size was varied from 128 to 4096 bytes. The effectiveness of each collector was measured by observing the number of times that garbage collection took place and the amount of storage that was retained after each collection.
Reference: [7] <author> Brian W. Kernighan, Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall Inc., </publisher> <year> 1978. </year>
Reference-contexts: In discussing the algorithms, we will restrict ourselves to the allocation of fixed-length cells containing two pointers, i.e. a Lisp cons cell. Each pointer in the cell will assumed to be either a pointer or NULL. The C <ref> [7] </ref> declaration for the cell is: typedef struct cons_cell - struct cons_cell *car; struct cons_cell *cdr; - *CP, CONS_CELL; The stop-and-copy algorithm manages a heap which is implemented using a contiguous block of storage. The algorithm divides the storage into two equal semispaces: "old space" and "new space".
Reference: [8] <author> Brian W. Kernighan, Rob Pike. </author> <title> The UNIX Programming Environment. </title> <publisher> Prentice-Hall Inc., </publisher> <year> 1984, </year> <pages> pages 227. </pages>
Reference-contexts: A continuation is a procedure which returns the program to some previous state of the computation. It can provide a more powerful control mechanism than the Common Lisp CATCH/THROW [13] or the C setjmp/longjmp <ref> [8] </ref>, as it is more general than an "upexit" and may be repeatedly invoked. One way of creating continuations is to copy the program state found in the registers and the stack to a heap allocated data structure [1].
Reference: [9] <author> Donald E. Knuth. </author> <booktitle> The Art of Computer Programming. Volume 1.Fundamental Algorithms. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1968, </year> <pages> pages 406-422. </pages>
Reference-contexts: Using the pointers in this "root set", all accessible objects can then be located. The correct management of the locations containing these roots has been a serious concern for as long as garbage collected storage has existed <ref> [9] </ref>. While symbolic programming languages such as Lisp hide the mechanics of correct pointer management from the user, they still are a concern of the language implementer. Many of the modern garbage collectors [10] recover space by copying accessible objects into some "new space". <p> A sample collector for use with C programs is provided in the Appendix. 1.1. Comparison with Existing Work One scheme that does not need any roots to recover space is reference counting. In the classical method <ref> [9] </ref>, each object contains a count of the number of references to it that exist. When a new reference is created, the count is incremented, and when a reference is deleted, the count is decremented. An object is explicitly freed when the reference count on the object becomes zero. <p> If a set of objects is available which include root pointers to all accessible storage, a mark-and-sweep collector <ref> [9] </ref> can be constructed. Each object which might be a root is treated in a conservative manner [12]. That is, objects that might be valid pointers are treated as pointers for purposes of storage retention.
Reference: [10] <author> Timothy J. McEntee. </author> <title> Overview of Garbage Collection in Symbolic Computing. </title> <booktitle> LISP Pointers 1(3) </booktitle> <pages> 8-16, </pages> <address> August-September, </address> <year> 1987. </year> <note> 3 [11] Jonathan Rees, </note> <editor> William Clinger (Editors). </editor> <title> Revised Report on the Algorithmic Language Scheme. </title> <journal> SIGPLAN Notices </journal> 21(12):37-79, December, 1986. 
Reference-contexts: While symbolic programming languages such as Lisp hide the mechanics of correct pointer management from the user, they still are a concern of the language implementer. Many of the modern garbage collectors <ref> [10] </ref> recover space by copying accessible objects into some "new space". Two of the attractive properties of a copying collector are that it results in memory compaction and it can have a running time proportional to the amount of accessible storage [3]. <p> The pointers are expected to be at the start of the object. The function will return a pointer to the data structure with its pointer cells initialized to NULL. For example, an instance of the structure: struct symbol - struct *symbol next; char name <ref> [10] </ref>; - could be allocated by: sp = (symbol*)gcalloc ( sizeof ( symbol ), 1 ); When the garbage collector is invoked, it will search the processor's registers, the stack, and the global pointers for "hints" as to what storage is still accessible.
Reference: [12] <author> Paul Rovner. </author> <title> On Adding Garbage Collection and Runtime Types to a Strongly-Typed, Statically-Checked, Concurrent Language. </title> <type> Technical Report CSL-84-7, </type> <institution> Xerox Palo Alto Research Center, </institution> <month> July, </month> <year> 1985. </year>
Reference-contexts: The collector they used is similar to the classical stop-and-copy collector and it requires a known set of roots in order to compact the heap. A later reference count based storage system was done for Cedar <ref> [12] </ref>. While Cedar initially used a method similar to Interlisp's, a new collector was designed because the implementers felt that the Interlisp collector had too high an execution cost, and was too complex. <p> If a set of objects is available which include root pointers to all accessible storage, a mark-and-sweep collector [9] can be constructed. Each object which might be a root is treated in a conservative manner <ref> [12] </ref>. That is, objects that might be valid pointers are treated as pointers for purposes of storage retention. As this type of collector will never move any objects, the only cost of guessing wrong is retaining extra data.
Reference: [13] <author> Guy L. Steele Jr. </author> <title> Common LISP: The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: A continuation is a procedure which returns the program to some previous state of the computation. It can provide a more powerful control mechanism than the Common Lisp CATCH/THROW <ref> [13] </ref> or the C setjmp/longjmp [8], as it is more general than an "upexit" and may be repeatedly invoked. One way of creating continuations is to copy the program state found in the registers and the stack to a heap allocated data structure [1].
Reference: [14] <author> David W. Wall. </author> <title> Global Register Allocation at Link Time. </title> <journal> SIGPLAN Notices 21(7) </journal> <pages> 264-275, </pages> <month> July, </month> <year> 1986. </year> <booktitle> SIGPLAN'86 Symposium on Compiler Construction. </booktitle>
Reference-contexts: When the Mahler code is compiled, extensive machine dependent optimization is done. This includes allocation of frequently used local storage to registers, global register allocation <ref> [14] </ref>, and code reordering to overlap execution with the arithmetic coprocessor, fill branch slots, and avoid pipeline stalls.
Reference: [15] <author> David W. Wall, Michael L. Powell. </author> <title> The Mahler Experience: Using an Intermediate Language as the Machine Description. </title> <booktitle> In Second International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS II), </booktitle> <pages> pages 100-104. </pages> <month> October, </month> <year> 1987. </year>
Reference-contexts: There, derived pointers are a problem and some protocol must be provided to keep them updated. Other environments present more serious problems in finding roots. If a Lisp system uses an intermediate language <ref> [15] </ref> as its target language, then it may have very little control over the actual code generated. <p> Putting Mostly-Copying Collection to Work The "mostly-copying" collection algorithm was developed to provide garbage collection for a Scheme implementation for the Titan, a high performance experimental workstation developed at WRL. The "official" definition for the machine is not the processor's instruction set, but the the Mahler intermediate language <ref> [15] </ref> which is the object code produced by all compilers. When the Mahler code is compiled, extensive machine dependent optimization is done.

References-found: 14

