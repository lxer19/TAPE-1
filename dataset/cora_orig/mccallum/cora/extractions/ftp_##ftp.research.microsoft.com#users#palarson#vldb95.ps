URL: ftp://ftp.research.microsoft.com/users/palarson/vldb95.ps
Refering-URL: http://www.research.microsoft.com/~palarson/publications.htm
Root-URL: http://www.research.microsoft.com
Email: fpwyan,palarsong@bluebox.uwaterloo.ca  
Title: Eager Aggregation and Lazy Aggregation  
Author: Weipeng P. Yan Per -Ake Larson 
Address: Waterloo, Waterloo, Ontario, Canada N2L 3G1  
Affiliation: Department of Computer Science, University of  
Abstract: Efficient processing of aggregation queries is essential for decision support applications. This paper describes a class of query transformations, called eager aggregation and lazy aggregation, that allows a query optimizer to move group-by operations up and down the query tree. Eager aggregation partially pushes a group-by past a join. After a group-by is partially pushed down, we still need to perform the original group-by in the upper query block. Eager aggregation reduces the number of input rows to the join and thus may result in a better overall plan. The reverse transformation, lazy aggregation, pulls a group-by above a join and combines two group-by operations into one. This transformation is typically of interest when an aggregation query references a grouped view (a view containing a group-by). Experimental results show that the technique is very beneficial for queries in the TPC-D benchmark. 
Abstract-found: 1
Intro-found: 1
Reference: [CS94] <author> S. Chaudhuri and K. Shim. </author> <title> Including group-by in query optimization. </title> <booktitle> In Proc. VLDB Conf., </booktitle> <pages> pages 354-366, </pages> <address> Santiago, Chile, </address> <month> Sep. </month> <year> 1994. </year>
Reference-contexts: Chaudhuri and Shim <ref> [CS94] </ref> also independently discovered eager group-by and eager count. Their simple coalescing grouping and generalized coalescing grouping correspond to our eager group-by and eager count transformation, respectively.
Reference: [GHQ95] <author> A. Gupta, V. Harinarayan, and D. Quass. </author> <title> Aggregate-query processing in data warehousing environments. </title> <booktitle> In Proc. VLDB Conf., </booktitle> <year> 1995. </year>
Reference-contexts: They also proposed an algorithm to integrate group-by push down, eager group-by and eager count into a greedy join enumeration algorithm which produces left deep trees in a cost based optimizer. However, they did not discuss lazy aggregation transformation in the paper. Gupta, Harinarayan and Quass <ref> [GHQ95] </ref> generalized group-by push down in another fashion. They showed that it is possible to perform early duplicate removal before a join when there is no aggregation in the original query. The access plan must maintain a count of the number of duplicates being removed.
Reference: [ISO92] <author> ISO. </author> <title> Information Technology Database languages - SQL. Reference number ISO/IEC 9075:1992(E), </title> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Note that subqueries are allowed. The grouping columns mentioned in the GROUP BY clause may contain columns from R d and R u , denoted by GA d and GA u , respectively. According to SQL2 <ref> [ISO92] </ref>, the selection columns in the SELECT clause must be a subset of the grouping columns. We denote the selection columns as SGA d and SGA u , subsets of GA d and GA u , respectively. <p> SQL2 <ref> [ISO92] </ref> represents missing information by a special value NULL. It adopts a three-valued logic in evaluating a conditional expression. We define functional dependencies using strict SQL2 semantics taking into account the effect of NULLs in SQL2.
Reference: [Loh88] <author> G. M. Lohman. </author> <title> Grammar-like functional rules for representing query optimization alternatives. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> pages 18-27, </pages> <address> Chicago, Illinois, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: The standard technique for determinating join order in a cost-based optimizer is dynamic programming in a bottom up (e.g., Starburst <ref> [Loh88] </ref>) fashion. During the dynamic programming process, plans for table accesses, two-table joins, three-table joins and joins involving more tables are constructed and kept until the final query plan is obtained.
Reference: [PHH92] <author> H. Pirahesh, J. M. Hellerstein, and W. Hasan. </author> <title> Extensible/rule based query rewrite optimization in starburst. </title> <booktitle> In Proc. SIGMOD Conf., </booktitle> <pages> pages 39-48, </pages> <address> San Diego, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: This technique is well known and is used in existing database systems. For example, the Starburst optimizer always transforms a query with a HAVING into one without at the beginning of the query rewrite phase <ref> [PHH92] </ref>. After the HAVING is eliminated, we can perform eager aggregation transformation on the view created. Now consider lazy aggregation.
Reference: [Raa95] <author> F. Raab, </author> <title> editor. TPC Benchmark(tm) D (Decision Support), Working Draft 9.1. Transaction Processing Performance Council, </title> <address> San Jose CA, 95112-6311, USA, </address> <month> February </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Aggregation is widely used in decision support systems. All queries in the TPC-D <ref> [Raa95] </ref> benchmark contain aggregation. Efficient processing of aggregation queries is essential for performance in decision support applications and large scale applications. <p> We call the technique of performing aggregation before join eager aggregation, and delaying aggregation until after join lazy aggregation. Lazy group-by is its reverse transformation. The following examples illustrate the basic idea of eager group-by and lazy group-by. The examples are based on a subset of the TPC-D database <ref> [Raa95] </ref>. The tables are defined in Appendix A. Example 1 : Find the total loss of revenue on orders handled by each clerk due to parts being returned by customers. Output clerk and loss of revenue. <p> A The TPC-D Database TPC-D is a decision support benchmark proposed by the the Transaction Processing Performance Council (TPC). It is a suite of business oriented queries to be executed against a database that allows continuous access as well as concurrent updates <ref> [Raa95] </ref>. The size of the database is scalable adjusted by a scale factor. The scale factor for a 100MB database is 0.1. The size of the database we used through out this paper is 100MB. Figure 4 shows the subset of the TPC-D database we used in this paper.
Reference: [Yan94] <author> W. P. Yan. </author> <title> Query optimization techniques for aggregation queries. Research Proposal, </title> <institution> University of Waterloo, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: With Reduced Elapsed Time (Compared With Original Formulation) Query Transformation Reduction in Elapsed time 5 EG on L/O and C 90.23% 8 EG on L/P/S 47.69% 14 EG on L 6.73% 17 DC then PU 29.09% 13 Related Work We proposed the idea of eager aggregation and lazy aggregation in <ref> [Yan94] </ref>. Chaudhuri and Shim [CS94] also independently discovered eager group-by and eager count. Their simple coalescing grouping and generalized coalescing grouping correspond to our eager group-by and eager count transformation, respectively.
Reference: [Yan95] <author> W. P. Yan. </author> <title> Rewrite optimization of SQL queries containing GROUP-BY. </title> <type> PhD thesis, </type> <institution> Department of Comp. Sci., University of Waterloo, </institution> <month> Sep. </month> <year> 1995. </year>
Reference-contexts: These examples show that both directions (eager group-by and lazy group-by) should be considered in query optimization. There may be several ways of performing eager group-by when there are more than two tables in the FROM clause <ref> [Yan95] </ref>. introduced in this paper. Eager count transformation performs eager aggregation on tables not containing aggregation columns, as shown in Figure 2 (d). It first counts the number of rows in each group in the early aggregation, then performs the join, and finally aggregates the original aggregation columns. <p> This is also true for all other corollaries in this paper. For a formal description of the transformation and proof, please refer to <ref> [Yan95] </ref>. 6 Eager Group-by and Lazy Group-by In the Main Theorem, if we let GA d contain all the aggregation columns, that is, all aggregation columns belong to R d tables, then we obtain the following corollary. <p> We call the transformation double group-by push down. Its reverse transformation, which pull up group-by's from two lower query blocks, is called double group-by pull up. Please refer to <ref> [Yan95] </ref> for the proof. A simple way to ensure that the conditions of the corollary hold is to use GA + d and GA + N GA u . Then, if (GA u ; GA d ) functionally determines the join columns, we can apply the Corollary. <p> Due to space limitation, we cannot provide the conditions here. Please refer to <ref> [Yan95] </ref> for detailed conditions and proofs. <p> Lazy aggregation is especially useful when the join is highly selective. The algorithm to find all valid lazy aggregation transformation for a given query is to iterate through each available transformation and output the rewritten forms. Please refer to <ref> [Yan95] </ref> for a detailed description for the algorithm. 10.3 Implementation We need to find a way to efficiently integrate eager/lazy aggregation and group-by push down/pull up into existing optimizers.
Reference: [YL94] <author> W. P. Yan and Per -Ake Larson. </author> <title> Performing group-by before join. </title> <booktitle> In Proc. IEEE ICDE, </booktitle> <pages> pages 89-100, </pages> <address> Houston, Texas, </address> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. Proceedings of the 21st VLDB Conference Zurich, Swizerland, 1995 We proposed a new query optimization technique, group-by push down and group-by pull up, which interchanges the order of group-by and joins <ref> [YL94, YL95] </ref>. Group-by push down is to push group-by past a join. Its major benefit is that the group-by may reduce the number of input rows of the join. Group-by pull up is to delay the processing of group-by until after a join. <p> Figure 1 (b) shows an alternative way where group-by is performed before join. Note that group-by and join commutation cannot always be done. The necessary and sufficient condition is provided in <ref> [YL94, YL95] </ref>. The technique to only partially push down a group-by past a join can be extended. For some queries containing joins and group-by, we can perform group-by on some of the tables, then the join, and finally another group-by. <p> When NULLs do not occur in the the columns involved in a functional dependency, our definition of functional dependency is the same as the traditional functional dependency. The detailed definitions are included in <ref> [YL94] </ref>. Due to space limitation, they are not included here. Let A and B be two sets of columns, A function ally determines B is denoted by A!B. 4.1 An Algebra for Representing SQL Queries Specifying operations using standard SQL is tedious.
Reference: [YL95] <author> W. P. Yan and Per -Ake Larson. </author> <title> Interchanging the order of grouping and join. </title> <type> Technical Report CS 95-09, </type> <institution> University of Waterloo, </institution> <month> Feb. </month> <year> 1995. </year> <month> 13 </month>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. Proceedings of the 21st VLDB Conference Zurich, Swizerland, 1995 We proposed a new query optimization technique, group-by push down and group-by pull up, which interchanges the order of group-by and joins <ref> [YL94, YL95] </ref>. Group-by push down is to push group-by past a join. Its major benefit is that the group-by may reduce the number of input rows of the join. Group-by pull up is to delay the processing of group-by until after a join. <p> Figure 1 (b) shows an alternative way where group-by is performed before join. Note that group-by and join commutation cannot always be done. The necessary and sufficient condition is provided in <ref> [YL94, YL95] </ref>. The technique to only partially push down a group-by past a join can be extended. For some queries containing joins and group-by, we can perform group-by on some of the tables, then the join, and finally another group-by. <p> However, it is possible to perform lazy aggregation when the HAVING clause of a query contains aggregation. We formally proved our theorem for the conditions of group-by push down transformation for queries containing a HAVING clause in <ref> [YL95] </ref>. The process to prove conditions of eager aggregation for queries with a HAVING clause is completely analog to our previous effort.
References-found: 10

