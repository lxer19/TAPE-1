URL: http://www.research.microsoft.com/~conal/papers/padl99.ps
Refering-URL: http://www.research.microsoft.com/~conal/papers/
Root-URL: http://www.research.microsoft.com
Title: From functional animation to sprite-based display  
Author: Conal Elliott 
Web: http://research.microsoft.com/~conal  
Affiliation: Microsoft Research  
Abstract: Functional animation encourages a highly modular programming style, by supplying a set of arbitrarily composable functions for building up animations. In contrast, libraries for sprite-based display impose rigid structure, in order to allow acceleration by hardware and low level software. This paper presents a method to bridge the gap between functional specification and stateful, sprite-based presentation of animation. The method's correctness is proved informally by derivation from a simple non-effective specification, exploiting algebraic properties of the animation data types that are made explicit in the functional approach. We have implemented this method in the Fran system, which is freely available. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Kavi Arya. </author> <title> A functional animation starter-kit. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(1) </volume> <pages> 1-18, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: 1 Introduction The functional approach to animation offers considerable flexibility and modularity <ref> [1, 7] </ref>. Animations are first-class values|elements of a data type consisting of a set of constants and combining operators. The data type allows great flexibility in composing these basic building blocks into either directly useful or attractive animations, or new building blocks, parameterized as desired.
Reference: 2. <author> Conal Elliott. </author> <title> A brief introduction to ActiveVRML. </title> <type> Technical Report MSR-TR-96-05, </type> <institution> Microsoft Research, </institution> <year> 1996. </year> <note> http://research.microsoft.com/scripts/- pubDB/pubsasp.asp?RecordID=38. </note>
Reference-contexts: In addition to time- and space-transformation, Fran's animation algebra supports cropping, conditionals and reactivity, each requiring special care for conversion to sprite normal form. Fran grew out of an earlier design called ActiveVRML <ref> [2] </ref>, which was a ML-like language extended with reactive behaviors and multimedia.
Reference: 3. <author> Conal Elliott. </author> <title> Modeling interactive 3D and multimedia animation with an embedded language. </title> <booktitle> In The Conference on Domain-Specific Languages, </booktitle> <pages> pages 285-296, </pages> <address> Santa Barbara, California, </address> <month> October </month> <year> 1997. </year> <note> USENIX. WWW version at http://- research.microsoft.com/~conal/papers/dsl97/dsl97.html. </note>
Reference-contexts: As such, it bridges the gap between the high level flexibility desired for specification of animations and the low level regularity imposed by the presentation library. This algorithm is used in the implementation of Fran ("Functional Reactive Animation") <ref> [7, 3, 4] </ref>, which is written in Haskell [9, 8] and runs in conjunction with a fast "temporal sprite engine," implemented in C++ for use with Fran and running in a separate thread. <p> Abstract interface to the ImageB type is a Haskell library. This "embedding" approach, discussed in detail elsewhere <ref> [3] </ref>, has allowed considerable leverage from the design and implementation of the host language Haskell. Fran is freely available, including the sprite engine, in full source code at http://research.microsoft.com/~conal/fran 2 Animation data types Fran's animation data types have been described elsewhere (e.g., [7], and for reference [11]).
Reference: 4. <author> Conal Elliott. </author> <title> Composing reactive animations. </title> <journal> Dr. Dobb's Journal, </journal> <month> July </month> <year> 1998. </year> <note> Extended version with animations at http://research.microsoft.com/~conal/- fran/ftutorial.htm,tutorialArticle.zipg. </note>
Reference-contexts: As such, it bridges the gap between the high level flexibility desired for specification of animations and the low level regularity imposed by the presentation library. This algorithm is used in the implementation of Fran ("Functional Reactive Animation") <ref> [7, 3, 4] </ref>, which is written in Haskell [9, 8] and runs in conjunction with a fast "temporal sprite engine," implemented in C++ for use with Fran and running in a separate thread.
Reference: 5. <author> Conal Elliott. </author> <title> From functional animation to sprite-based display (extended version). </title> <type> Technical Report MSR-TR-98-28, </type> <institution> Microsoft Research, </institution> <year> 1998. </year> <note> http://- research.microsoft.com/scripts/pubDB/pubsasp.asp?RecordID=190. </note>
Reference-contexts: We will rely on many simple algebraic properties of our data types. Below we derive the ImageB-to-[SpriteTree] conversion for a small representative set of ImageB constructors. See <ref> [5] </ref> for a full treatment. 4.1 Solid images Solid images are unaffected by transformations, and are of a default color, as expressed by the following properties: xfB *% SolidImage == SolidImage SolidImage `timeTransform` tt == SolidImage withColor defaultColor SolidImage == SolidImage These facts simplify the specification of spritify: treesIm (spritify above
Reference: 6. <author> Conal Elliott. </author> <title> Functional implementations of continuous modeled animation. </title> <booktitle> In Proceedings of PLILP/ALP '98, </booktitle> <year> 1998. </year> <note> http://research.microsoft.- com/~conal/papers/plilpalp98/short.ps. Extended version, MSR-TR-98-25, http://research.microsoft.com/scripts/pubDB/pubsasp.asp?RecordID=164. </note>
Reference-contexts: *% EmptyImage = EmptyImage xf *% SolidImage = SolidImage xf *% im = TransformI xf im Although a programmer would not be likely to transform empty or solid images explicitly, such compositions arise at runtime due to modular programming style, as well as some of the reactivity optimizations discussed in <ref> [6] </ref>. The constructors CondI, UntilI, and TimeTransI are used to define the overloaded functions condB, untilB, and timeTransform that apply to sound, 3D geometry, and all behaviors, as well as to image animations. <p> A monochrome sprite is allocated in the sprite engine, chaining to the sprite trees given as "above". The time stream ts is used to sample the cropping rectangle and color, using ats (which is memoized as described in <ref> [6] </ref>). The resulting sample values are used to interactively update the sprite attributes, as long as the request channel requestV says to continue.
Reference: 7. <author> Conal Elliott and Paul Hudak. </author> <title> Functional reactive animation. </title> <booktitle> In Proceedings of the 1997 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 263-273, </pages> <address> Amsterdam, The Netherlands, </address> <month> 9-11 June </month> <year> 1997. </year> <note> http://research.- microsoft.com/~conal/papers/icfp97.ps. </note>
Reference-contexts: 1 Introduction The functional approach to animation offers considerable flexibility and modularity <ref> [1, 7] </ref>. Animations are first-class values|elements of a data type consisting of a set of constants and combining operators. The data type allows great flexibility in composing these basic building blocks into either directly useful or attractive animations, or new building blocks, parameterized as desired. <p> As such, it bridges the gap between the high level flexibility desired for specification of animations and the low level regularity imposed by the presentation library. This algorithm is used in the implementation of Fran ("Functional Reactive Animation") <ref> [7, 3, 4] </ref>, which is written in Haskell [9, 8] and runs in conjunction with a fast "temporal sprite engine," implemented in C++ for use with Fran and running in a separate thread. <p> This "embedding" approach, discussed in detail elsewhere [3], has allowed considerable leverage from the design and implementation of the host language Haskell. Fran is freely available, including the sprite engine, in full source code at http://research.microsoft.com/~conal/fran 2 Animation data types Fran's animation data types have been described elsewhere (e.g., <ref> [7] </ref>, and for reference [11]). The animation-level types other than animated images, sounds, and 3D geometry come from applying the Behavior type constructor to these static types, and lifting operations on the static types to operations on behaviors. Behaviors are functions of continuous time.
Reference: 8. <author> Paul Hudak and Joseph Fasel. </author> <title> A gentle introduction to Haskell. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year> <note> See http://haskell.org/tutorial/index.html for latest version. </note>
Reference-contexts: As such, it bridges the gap between the high level flexibility desired for specification of animations and the low level regularity imposed by the presentation library. This algorithm is used in the implementation of Fran ("Functional Reactive Animation") [7, 3, 4], which is written in Haskell <ref> [9, 8] </ref> and runs in conjunction with a fast "temporal sprite engine," implemented in C++ for use with Fran and running in a separate thread. The sprite engine, constructed for use with Fran and described in this paper, manages a list of sprites.
Reference: 9. <editor> Paul Hudak, Simon L. Peyton Jones, and (editors) Philip Wadler. </editor> <title> Report on the programming language Haskell, A non-strict purely functional language (Version 1.2). </title> <journal> SIGPLAN Notices, </journal> <month> Mar, </month> <year> 1992. </year> <note> See http://haskell.org/report/index.html for latest version. </note>
Reference-contexts: As such, it bridges the gap between the high level flexibility desired for specification of animations and the low level regularity imposed by the presentation library. This algorithm is used in the implementation of Fran ("Functional Reactive Animation") [7, 3, 4], which is written in Haskell <ref> [9, 8] </ref> and runs in conjunction with a fast "temporal sprite engine," implemented in C++ for use with Fran and running in a separate thread. The sprite engine, constructed for use with Fran and described in this paper, manages a list of sprites.
Reference: 10. <author> Simon Peyton Jones, Andrew Gordon, and Sigbjorn Finne. </author> <title> Concurrent Haskell. </title> <booktitle> In Conference Record of POPL '96: The 23 rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 295-308, </pages> <address> St. Petersburg Beach, Florida, </address> <month> 21-24 January </month> <year> 1996. </year>
Reference-contexts: The actual implementation of spritify creates the mutable sprite trees with initial values for position, scale, pitch, etc., and then iteratively updates these attributes, while the sprite engine runs concurrently. For simplicity of implementation, every active sprite is managed by its own Haskell thread, using the Concurrent Haskell primitives <ref> [10] </ref>. Each such thread is fueled by a request channel, with each request saying either to continue or to quit, and puts status messages into a response channel. Each sprite thread iteratively samples the appropriate behaviors (slightly into the future) and invokes an update method on the sprite object.
Reference: 11. <author> John Peterson, Conal Elliott, and Gary Shu Ling. </author> <note> Fran user's manual, Revised February, 1998. http://research.microsoft.com/~conal/Fran/UsersMan.htm. </note>
Reference-contexts: Fran is freely available, including the sprite engine, in full source code at http://research.microsoft.com/~conal/fran 2 Animation data types Fran's animation data types have been described elsewhere (e.g., [7], and for reference <ref> [11] </ref>). The animation-level types other than animated images, sounds, and 3D geometry come from applying the Behavior type constructor to these static types, and lifting operations on the static types to operations on behaviors. Behaviors are functions of continuous time.
References-found: 11

