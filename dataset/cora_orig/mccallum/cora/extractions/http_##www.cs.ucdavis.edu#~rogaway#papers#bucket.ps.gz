URL: http://www.cs.ucdavis.edu/~rogaway/papers/bucket.ps.gz
Refering-URL: http://www.cs.ucdavis.edu/~rogaway/papers/
Root-URL: http://www.cs.ucdavis.edu
Title: Bucket Hashing and its Application to Fast Message Authentication  
Author: Phillip Rogaway 
Keyword: Key words: Cryptography, Hashing, Message authentication codes, Universal Hashing.  
Note: Earlier version appears in Advances in Cryptology CRYPTO '95. This is the full paper.  
Address: Davis, CA 95616.  
Affiliation: Department of Computer Science, University of California,  
Email: e-mail: rogaway@cs.ucdavis.edu  
Date: July 18, 1997  
Abstract: We introduce a new technique for constructing a family of universal hash functions. At its center is a simple metaphor: to hash a string x, cast each of its words into a small number of buckets; xor the contents of each bucket; then collect up all the buckets' contents. Used in the context of Wegman-Carter authentication, this style of hash function provides a fast approach for software message authentication. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Alon, O. Goldreich, J. H-astad and R. Peralta, </author> <title> Simple constructions of almost k-wise independent random variables, </title> <booktitle> 31st Annual Symposium on Foundations of Computer Science, IEEE Computer Society, </booktitle> <year> 1990, </year> <pages> pp. 544-553. </pages>
Reference-contexts: Now notice that we can treat any H 2 B [w; n; N ] as a hash function h = H from B <ref> [1; n; N ] </ref>, and conversely, because the description of a bucket hash hash function (a sequence of triples of indices) is insensitive to the word length w. <p> We will use B as shorthand for B <ref> [1; n; N ] </ref>. Exploiting linearity. For 0 t n, let 1 t = 1 t 0 nt and let 0 = 0 N . <p> In other words, a random h = h 1 : : : h n 2 C <ref> [1; n; N ] </ref> is a sequence of random triples, h i = fh i1 ; h i2 ; h i3 g, where h i1 ; h i2 ; h i3 2 f1; : : :; N g are distinct.
Reference: [2] <author> R. Arnold and D. Coppersmith, </author> <title> An alternative to perfect hashing, IBM RC 10332 (1984). </title>
Reference-contexts: Zobrist [33] gives a hashing technique which predates [10] and essentially coincides with one method from [10]. Arnold and Coppersmith <ref> [2] </ref> give an interesting hashing technique which allows one to map a set of keys k i into a set of corresponding values v i using a table only slightly bigger than P i v i . The proof of our main technical result is somewhat reminiscent of their analysis. <p> If n &lt; 4 then * = 0. Proof : First observe that, for h 2 B, computing h (x) amounts to computing a product Ax over GF <ref> [2] </ref> of an N fi n matrix A and a column vector x. In fact, selecting a random hash function h 2 B corresponds to picking a random binary n fi N matrix A which has three ones in each column and no two identical columns.
Reference: [3] <author> M. Bellare, R. Canetti and H. Krawczyk, </author> <title> Keying hash functions for message authentication, </title> <booktitle> Advances in Cryptology - CRYPTO '96, Lecture Notes in Computer Science, </booktitle> <volume> vol. 1109, </volume> <publisher> Springer-Verlag, </publisher> <year> 1996, </year> <pages> pp. 1-15. </pages>
Reference-contexts: Two approaches to message authentication. The fastest software MACs in common use today are exemplified by MAC k (x) = h (k k x k k), with h a (software-efficient) cryptographic hash function, such as h =MD5 [22]. Such methods are described in [30]. The algorithm HMAC <ref> [3] </ref> 1 represents the most refined algorithm in this direction.
Reference: [4] <author> M. Bellare, O. Goldreich and S. Goldwasser, </author> <title> Incremental cryptography: the case of hashing and signing, </title> <booktitle> Advances in Cryptology - CRYPTO '94, Lecture Notes in Computer Science, </booktitle> <volume> vol. 839, </volume> <publisher> Springer-Verlag, </publisher> <year> 1994, </year> <pages> pp. 216-233. </pages>
Reference-contexts: In particular, bucket hashing is parallelizable, since each word of the hash is just the xor of certain words of the message. Bucket hashing is incremental in the sense of <ref> [4] </ref> with respect to both append and substitute operations. Finally, the only processor instructions a bucket hash needs are word-aligned load, store, and xor; thus a bucket hash MAC is essentially endian-indifferent.
Reference: [5] <author> M. Bellare, J. Kilian and P. Rogaway, </author> <title> The security of cipher block chaining, </title> <booktitle> Advances in Cryptology - CRYPTO '94, Lecture Notes in Computer Science, </booktitle> <volume> vol. 839, </volume> <publisher> Springer-Verlag, </publisher> <year> 1994, </year> <pages> pp. 341-358. </pages>
Reference-contexts: Thus we view work like ours as making statements about unconditionally-secure authentication which give rise to corresponding statements and concrete schemes in the complexity-theoretic tradition. To make this translation we regard a finite pseudorandom function (PRF) as the most appropriate tool. Bellare, Kilian and Rogaway <ref> [5] </ref> were the first to formalize such objects, investigate their usage in the construction of efficient MACs, and suggest them as a desirable starting point for practical, provably-good constructions.
Reference: [6] <author> J. Bierbrauer, T. Johansson, G. Kabatianskii and B. Smeets, </author> <title> On families of hash functions via geometric codes and concatenation, </title> <booktitle> Advances in Cryptology - CRYPTO '93, Lecture Notes in Computer Science, </booktitle> <volume> vol. 773, </volume> <publisher> Springer-Verlag, </publisher> <year> 1994, </year> <pages> pp. 331-342. </pages>
Reference-contexts: Stinson does this in [27], and also gives general results on the construction of universal hash functions. We exploit some of these ideas. Subsequent improvements (rooted in coding theory) came from Bierbrauer, Johansson, Kabatianskii and Smeets <ref> [6] </ref>, and Gemmell and Naor [12]. The above work concentrates on unconditionally-secure authentication. Brassard [9] first connects the Wegman-Carter approach to the complexity-theoretic case. The complexity-theoretic notion for a secure MAC is a straightforward adaptation of the definition of a digital signature due to Goldwasser, Micali and Rivest [14]. <p> on a typical 32-bit RISC machine (an SGI with a 150 MHz IP22 processor, 16 KByte data cache, 16 KBytes instruction cache) the most straightforward Method-1/sm implementation ran at 340 Mb/s to hash 1024 words to 140, while a Method-2/sm implementation of a bucket hash family based on the C <ref> [10; 6] </ref> graph (see Section 7) ran at 1160 Mb/s to hash 909 words to 182. Follow-on work will give detailed experimental results. Rough comparisons. <p> Though (d; g)-cages are rather large (for even g they have at least (2 (d 1) g=2 2)=(d 2) nodes) some (d; g)-cages may give rise to useful hash families. For example, assume d 1 is a prime power. Let C <ref> [d; 6] </ref> be the (d; 6)-cage. This is the the point-line incidence graph of the projective plane of order d 1. Bucket hashing with C [10; 6] may be a good way to hash 909 words down to 182 words. Open questions. <p> For example, assume d 1 is a prime power. Let C [d; 6] be the (d; 6)-cage. This is the the point-line incidence graph of the projective plane of order d 1. Bucket hashing with C <ref> [10; 6] </ref> may be a good way to hash 909 words down to 182 words. Open questions. The generalized notion of bucket hashing amounts to saying that hashing is achieved for each bit position 1 : : : w by matrix multiplication with a sparse Boolean matrix H.
Reference: [7] <author> A. Bosselaers, R. Govaerts and J. Vandewalle, </author> <title> Fast hashing on the Pentium, </title> <booktitle> Advances in Cryptology - CRYPTO 96, Lecture Notes in Computer Science, </booktitle> <volume> vol. 1109, </volume> <publisher> Springer-Verlag, </publisher> <year> 1996, </year> <pages> pp. 298-312. </pages>
Reference-contexts: For one thing, the output of bucket hashing is too long to use directly; it will need to be composed with an additional layer of hashing. All the same, one can compare the instruction count mentioned above to that of MD5, which uses 36 instructions per 32-bit word <ref> [7] </ref>, and see that there is potential for substantial efficiency gains even if the true cost of using bucket hashing substantially exceeds 6 instructions/word. A bucket hash MAC has advantages in addition to speed. <p> Rough comparisons. Shoup estimates a cost of about 24 instructions/word (6 instructions per byte) for computing a hash function h 2 K, where K is described in Section 2 [24]. Bosselaers, Govaerts and Vandewalle have implemented MD5 at a cost of 36 instructions/word on a Pentium <ref> [7] </ref> (they obtain a good degree of overlapping instruction-issue, too). In recent work, Halevi and Krawczyk estimate a cost of about 7.5 instructions per word (assuming architectural support for multiplying two 32-bit words to yield a 64-bit product) for their MMH technique [15].
Reference: [8] <author> J. Bondy and U. Murty, </author> <title> Graph theory with Applications, </title> <publisher> North Holland, </publisher> <year> 1976. </year>
Reference-contexts: One possible choice of graphs in this regard are the (d; g)-cages (see <ref> [8] </ref>). A (d; g)-cage is a smallest d-regular graph whose shortest cycle has g edges. These graphs have been explicitly constructed for various values of (d; g).
Reference: [9] <author> G. Brassard, </author> <title> On computationally secure authentication tags requiring short secret shared keys, </title> <booktitle> Advances in Cryptology - CRYPTO '82, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1983, </year> <pages> pp. 79-86. </pages>
Reference-contexts: We exploit some of these ideas. Subsequent improvements (rooted in coding theory) came from Bierbrauer, Johansson, Kabatianskii and Smeets [6], and Gemmell and Naor [12]. The above work concentrates on unconditionally-secure authentication. Brassard <ref> [9] </ref> first connects the Wegman-Carter approach to the complexity-theoretic case. The complexity-theoretic notion for a secure MAC is a straightforward adaptation of the definition of a digital signature due to Goldwasser, Micali and Rivest [14].
Reference: [10] <author> L. Carter and M. Wegman, </author> <title> Universal hash functions, </title> <journal> J. of Computer and System Sciences 18, </journal> <year> 1979, </year> <pages> pp. 143-154. </pages>
Reference-contexts: As it turns out, to make a good MAC it is enough to construct something weaker than a strongly universal 2 family. Carter and Wegman <ref> [10] </ref> also introduced the notion of an almost universal 2 family, H. This must satisfy the weaker condition that Pr h2H [h (x) = h (x 0 )] is small for all x 6= x 0 . <p> Previous work. The general theory of unconditional authentication was developed by Simmons; see [26] for a survey. As we have already explained, the universal-hash-and-then-encrypt paradigm is due to Wegman and Carter [32]. The idea springs from their highly influential <ref> [10] </ref>. In Wegman-Carter authentication the size of the hash family corresponds to the number of bits of shared key|one reason to find smaller families of universal hash functions than those of [10, 32]. Stinson does this in [27], and also gives general results on the construction of universal hash functions. <p> The idea springs from their highly influential [10]. In Wegman-Carter authentication the size of the hash family corresponds to the number of bits of shared key|one reason to find smaller families of universal hash functions than those of <ref> [10, 32] </ref>. Stinson does this in [27], and also gives general results on the construction of universal hash functions. We exploit some of these ideas. Subsequent improvements (rooted in coding theory) came from Bierbrauer, Johansson, Kabatianskii and Smeets [6], and Gemmell and Naor [12]. <p> Finite PRFs are a refinement of the PRF notion of Goldreich, Goldwasser and Micali [13] to take account of the fixed lengths of inputs and outputs in the efficient primitives of cryptographic practice. Zobrist [33] gives a hashing technique which predates <ref> [10] </ref> and essentially coincides with one method from [10]. Arnold and Coppersmith [2] give an interesting hashing technique which allows one to map a set of keys k i into a set of corresponding values v i using a table only slightly bigger than P i v i . <p> Finite PRFs are a refinement of the PRF notion of Goldreich, Goldwasser and Micali [13] to take account of the fixed lengths of inputs and outputs in the efficient primitives of cryptographic practice. Zobrist [33] gives a hashing technique which predates <ref> [10] </ref> and essentially coincides with one method from [10]. Arnold and Coppersmith [2] give an interesting hashing technique which allows one to map a set of keys k i into a set of corresponding values v i using a table only slightly bigger than P i v i . <p> Johansson investigates how to reduce the size of the key for bucket hashing, which, in the current paper, is quite enormous [16]. 2 Preliminaries This section provides background drawn from Carter and Wegman <ref> [10, 32] </ref>, Stinson [27], and Krawczyk [18]. Proofs are omitted. A family of hash functions is a finite multiset H of string-valued functions, each h 2 H having the same nonempty domain A f0; 1g fl and range B f0; 1g b , for some constant b. <p> Proofs are omitted. A family of hash functions is a finite multiset H of string-valued functions, each h 2 H having the same nonempty domain A f0; 1g fl and range B f0; 1g b , for some constant b. Definition 1 <ref> [10] </ref> A family of hash functions H = fh : A ! f0; 1g b g is *-almost universal 2 , written *-AU 2 , if for all distinct x; x 0 2 A, Pr h2H h (x) = h (x 0 ) *. <p> Still, for sufficiently long messages, it will be faster to use the bucket hashing technique from the following section. We comment that there are many other well-known techniques for universal hashing, such as the linear congruential hash (modulo a prime) <ref> [10] </ref>, the shift register hash [31], or the Toeplitz matrix hash [18]. <p> on a typical 32-bit RISC machine (an SGI with a 150 MHz IP22 processor, 16 KByte data cache, 16 KBytes instruction cache) the most straightforward Method-1/sm implementation ran at 340 Mb/s to hash 1024 words to 140, while a Method-2/sm implementation of a bucket hash family based on the C <ref> [10; 6] </ref> graph (see Section 7) ran at 1160 Mb/s to hash 909 words to 182. Follow-on work will give detailed experimental results. Rough comparisons. <p> For example, assume d 1 is a prime power. Let C [d; 6] be the (d; 6)-cage. This is the the point-line incidence graph of the projective plane of order d 1. Bucket hashing with C <ref> [10; 6] </ref> may be a good way to hash 909 words down to 182 words. Open questions. The generalized notion of bucket hashing amounts to saying that hashing is achieved for each bit position 1 : : : w by matrix multiplication with a sparse Boolean matrix H.
Reference: [11] <author> Y. Desmedt, </author> <title> Unconditionally secure authentication schemes and practical and theoretical consequences, </title> <booktitle> Advances in Cryptology - CRYPTO '85, Lecture Notes in Computer Science, </booktitle> <volume> vol. 218, </volume> <publisher> Springer-Verlag, </publisher> <year> 1985, </year> <pages> pp. 42-45. </pages>
Reference: [12] <author> P. Gemmell and M. Naor, </author> <title> Codes for interactive authentication, </title> <booktitle> Advances in Cryptology - CRYPTO '93, Lecture Notes in Computer Science, </booktitle> <volume> vol. 773, </volume> <publisher> Springer-Verlag, </publisher> <year> 1994, </year> <pages> pp. 355-367. </pages>
Reference-contexts: Stinson does this in [27], and also gives general results on the construction of universal hash functions. We exploit some of these ideas. Subsequent improvements (rooted in coding theory) came from Bierbrauer, Johansson, Kabatianskii and Smeets [6], and Gemmell and Naor <ref> [12] </ref>. The above work concentrates on unconditionally-secure authentication. Brassard [9] first connects the Wegman-Carter approach to the complexity-theoretic case. The complexity-theoretic notion for a secure MAC is a straightforward adaptation of the definition of a digital signature due to Goldwasser, Micali and Rivest [14].
Reference: [13] <author> O. Goldreich, S. Goldwasser and S. Micali, </author> <title> How to construct random functions, </title> <journal> Journal of the ACM, </journal> <volume> Vol. 33, No. 4, </volume> <year> 1986, </year> <pages> pp. 210-217. </pages>
Reference-contexts: Bellare, Kilian and Rogaway [5] were the first to formalize such objects, investigate their usage in the construction of efficient MACs, and suggest them as a desirable starting point for practical, provably-good constructions. Finite PRFs are a refinement of the PRF notion of Goldreich, Goldwasser and Micali <ref> [13] </ref> to take account of the fixed lengths of inputs and outputs in the efficient primitives of cryptographic practice. Zobrist [33] gives a hashing technique which predates [10] and essentially coincides with one method from [10].
Reference: [14] <author> S. Goldwasser, S. Micali and R. Rivest, </author> <title> A digital signature scheme secure against adaptive chosen-message attacks, </title> <journal> SIAM Journal of Computing, </journal> <volume> vol. 17, no. </volume> <month> 2 (April </month> <year> 1988), </year> <pages> pp. 281-308. </pages>
Reference-contexts: The above work concentrates on unconditionally-secure authentication. Brassard [9] first connects the Wegman-Carter approach to the complexity-theoretic case. The complexity-theoretic notion for a secure MAC is a straightforward adaptation of the definition of a digital signature due to Goldwasser, Micali and Rivest <ref> [14] </ref>. Their notion of an adaptive chosen message attack is equally at home for defining an unconditionally-secure MAC. Thus we view work like ours as making statements about unconditionally-secure authentication which give rise to corresponding statements and concrete schemes in the complexity-theoretic tradition.
Reference: [15] <author> S. Halevi and H. Krawczyk, MMH: </author> <title> Message authentication in software in the Gbit/second rates, </title> <booktitle> Proceedings of the 4th Workshop on Fast Software Encryption, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: The techniques are also fast enough to be gainfully employed all by themselves. Halevi and Krawczyk describe a family of hash functions, MMH, which achieves extremely impressive software speeds on some modern platforms <ref> [15] </ref>. To achieve such performance one needs 3 the underlying hardware to be able to quickly multiply two 32-bit integers to form a 64-bit product. <p> In recent work, Halevi and Krawczyk estimate a cost of about 7.5 instructions per word (assuming architectural support for multiplying two 32-bit words to yield a 64-bit product) for their MMH technique <ref> [15] </ref>. We emphasize that trying to compare such numbers hides many significant factors, including length of hash output (worst for bucket hashing), table sizes and caching issues, and the degree of available parallelism.
Reference: [16] <author> T. Johansson, </author> <title> Bucket hashing with small key size, </title> <booktitle> Advances in Cryptology - EURO-CRYPT '97, Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: To achieve such performance one needs 3 the underlying hardware to be able to quickly multiply two 32-bit integers to form a 64-bit product. Johansson investigates how to reduce the size of the key for bucket hashing, which, in the current paper, is quite enormous <ref> [16] </ref>. 2 Preliminaries This section provides background drawn from Carter and Wegman [10, 32], Stinson [27], and Krawczyk [18]. Proofs are omitted. <p> One approach is to find a version of bucket hashing that uses a small key (ie., a short description for h). This way the underlying pseudorandom generator (if present) is less taxed. This approach has been investigated by <ref> [16] </ref>, who achieves a major reduction in the size of the description the h.
Reference: [17] <author> T. Johansson, G. Kabatianskii and B. Smeets, </author> <title> On the relation between A-codes and codes correcting independent errors. </title> <booktitle> Advances in Cryptology - EUROCRYPT '93, Lecture Notes in Computer Science, </booktitle> <volume> vol. 765, </volume> <publisher> Springer-Verlag, </publisher> <year> 1994, </year> <pages> pp. 1-11. </pages>
Reference: [18] <author> H. Krawczyk, </author> <title> LFSR-based hashing and authentication, </title> <booktitle> Advances in Cryptology - CRYPTO '94, Lecture Notes in Computer Science, </booktitle> <volume> vol. 839, </volume> <publisher> Springer-Verlag, </publisher> <year> 1994, </year> <pages> pp. 129-139. </pages>
Reference-contexts: The proof of our main technical result is somewhat reminiscent of their analysis. Lai, Rueppel and Woolven [20], Taylor [28], and Krawczyk <ref> [18] </ref> have all been interested in computationally efficient MACs. The last two works basically follow the Wegman-Carter paradigm. In particular, Krawczyk obtains efficient message authentication codes from hash families which resemble traditional cyclic redundancy codes (CRCs), and matrix multiplication using Toeplitz matrices. <p> Johansson investigates how to reduce the size of the key for bucket hashing, which, in the current paper, is quite enormous [16]. 2 Preliminaries This section provides background drawn from Carter and Wegman [10, 32], Stinson [27], and Krawczyk <ref> [18] </ref>. Proofs are omitted. A family of hash functions is a finite multiset H of string-valued functions, each h 2 H having the same nonempty domain A f0; 1g fl and range B f0; 1g b , for some constant b. <p> Then H 2 ffi H 1 = fh : A ! Cg is (* 1 + * 2 )-AXU 2 . We end this section with a sample construction for a software-efficient AXU 2 hash family, this one due to Krawczyk <ref> [18] </ref>. Let n; ` 1 be numbers and let m 2 f0; 1g n` be the string we wish to hash. <p> To hash m using h we compute the degree ` 1 (or less) polynomial m (x) x ` mod h (x). Viewing the coefficients of this polynomial as a string of length ` gives us the hash function h evaluated at M . Theorem 6 <ref> [18] </ref> K [n; `] is n`+` 2 `1 -AXU 2 . The efficiency with which hash functions h 2 K can be computed has been studied by Shoup [24] (who also looked at related hash families). <p> We comment that there are many other well-known techniques for universal hashing, such as the linear congruential hash (modulo a prime) [10], the shift register hash [31], or the Toeplitz matrix hash <ref> [18] </ref>. <p> The following theorem says that it is impossible (regardless of time, number of queries, or amount of MACed text) to forge with probability exceeding the collision probability. Proposition 13 <ref> [32, 18] </ref> Let H be *-AXU 2 and suppose adversary E forges in the scheme WC [H] with probability ffi. Then ffi *. Wegman-Carter with a finite PRF.
Reference: [19] <author> M. Luby and C. Rackoff, </author> <title> How to construct pseudorandom permutations from pseudorandom functions," </title> <journal> SIAM J. Comput, </journal> <volume> vol. 17, no. </volume> <month> 2 (April </month> <year> 1988). </year>
Reference: [20] <author> X. Lai, R. Rueppel and J. Woollven, </author> <title> A fast cryptographic checksum algorithm based on stream ciphers, </title> <booktitle> Advances in Cryptology, Proceedings of AUSCRYPT 92, Lecture Notes in Computer Science, </booktitle> <volume> vol. 718, </volume> <publisher> Springer-Verlag, </publisher> <year> 1992, </year> <pages> pp. 339-348. 19 </pages>
Reference-contexts: The proof of our main technical result is somewhat reminiscent of their analysis. Lai, Rueppel and Woolven <ref> [20] </ref>, Taylor [28], and Krawczyk [18] have all been interested in computationally efficient MACs. The last two works basically follow the Wegman-Carter paradigm. In particular, Krawczyk obtains efficient message authentication codes from hash families which resemble traditional cyclic redundancy codes (CRCs), and matrix multiplication using Toeplitz matrices.
Reference: [21] <author> P. Pearson, </author> <title> Fast hashing of variable-length text strings, </title> <journal> Communications of the ACM, </journal> <volume> vol. 33, no. 6 (1990), </volume> <pages> pp. 677-680. </pages>
Reference: [22] <author> R. Rivest, </author> <title> The MD5 message digest algorithm, </title> <institution> IETF RFC-1321, </institution> <year> 1992. </year>
Reference-contexts: This paper provides one such technique. Two approaches to message authentication. The fastest software MACs in common use today are exemplified by MAC k (x) = h (k k x k k), with h a (software-efficient) cryptographic hash function, such as h =MD5 <ref> [22] </ref>. Such methods are described in [30]. The algorithm HMAC [3] 1 represents the most refined algorithm in this direction.
Reference: [23] <author> P. Rogaway, </author> <title> Bucket hashing and its application to fast message authentication, </title> <booktitle> Advances in Cryptology - CRYPTO '95, Lecture Notes in Computer Science, </booktitle> <volume> vol. 963, </volume> <publisher> Springer-Verlag, </publisher> <year> 1995, </year> <pages> pp. 313-328. </pages>
Reference-contexts: Though originally intended for hardware, these techniques are fast in software, too. We recall Krawczyk's CRC-like hash in Section 2. An earlier version of this paper appeared as <ref> [23] </ref>. Subsequent work. Shoup [24] has carried out implementations and analysis of hash function families akin to polynomial evaluation. Such hash functions make good candidates for "second level hashing" when a speed-optimized hash function is applied to a long string.
Reference: [24] <author> V. Shoup, </author> <title> On fast and provably secure message authentication based on universal hashing, </title> <booktitle> Advances in Cryptology - CRYPTO '96, Lecture Notes in Computer Science, </booktitle> <volume> vol. 1109, </volume> <publisher> Springer-Verlag, </publisher> <year> 1996, </year> <pages> pp. 74-85. </pages>
Reference-contexts: Though originally intended for hardware, these techniques are fast in software, too. We recall Krawczyk's CRC-like hash in Section 2. An earlier version of this paper appeared as [23]. Subsequent work. Shoup <ref> [24] </ref> has carried out implementations and analysis of hash function families akin to polynomial evaluation. Such hash functions make good candidates for "second level hashing" when a speed-optimized hash function is applied to a long string. The techniques are also fast enough to be gainfully employed all by themselves. <p> Theorem 6 [18] K [n; `] is n`+` 2 `1 -AXU 2 . The efficiency with which hash functions h 2 K can be computed has been studied by Shoup <ref> [24] </ref> (who also looked at related hash families). These functions are fast to compute| about 6 instructions/byte on a 32-bit machine, assuming ` = 64, and ignoring the time to "preprocess" the function h. <p> Follow-on work will give detailed experimental results. Rough comparisons. Shoup estimates a cost of about 24 instructions/word (6 instructions per byte) for computing a hash function h 2 K, where K is described in Section 2 <ref> [24] </ref>. Bosselaers, Govaerts and Vandewalle have implemented MD5 at a cost of 36 instructions/word on a Pentium [7] (they obtain a good degree of overlapping instruction-issue, too).
Reference: [25] <author> A. </author> <title> Siegel On universal classes of fast high performance hash functions, their time-space tradeoff, and their applications, </title> <booktitle> 30th Annual Symposium on Foundations of Computer Science, IEEE Computer Society, </booktitle> <year> 1989, </year> <pages> pp. 20-25. </pages>
Reference: [26] <author> G. Simmons, </author> <title> A survey of information authentication, </title> <booktitle> in Contemporary Cryptography, The Science of Information Integrity, </booktitle> <editor> G. Simmons, editor, </editor> <publisher> IEEE Press, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Moreover, this provable security is achieved under extremely "tight" reductions, so that an adversary who can successfully break the MAC can break the underlying cryptographic primitive (the pseudorandom function F ) with essentially identical efficiency. Previous work. The general theory of unconditional authentication was developed by Simmons; see <ref> [26] </ref> for a survey. As we have already explained, the universal-hash-and-then-encrypt paradigm is due to Wegman and Carter [32]. The idea springs from their highly influential [10].
Reference: [27] <author> D. Stinson, </author> <title> Universal hashing and authentication codes, Designs, </title> <journal> Codes and Cryptography, </journal> <volume> vol. 4 (1994), </volume> <pages> pp. 369-380. </pages>
Reference-contexts: Carter and Wegman [10] also introduced the notion of an almost universal 2 family, H. This must satisfy the weaker condition that Pr h2H [h (x) = h (x 0 )] is small for all x 6= x 0 . As observed by Stinson <ref> [27] </ref>, an almost universal 2 family can easily be turned into an almost strongly universal 2 family by composing the almost universal 2 family with an almost strongly universal 2 one. <p> The idea springs from their highly influential [10]. In Wegman-Carter authentication the size of the hash family corresponds to the number of bits of shared key|one reason to find smaller families of universal hash functions than those of [10, 32]. Stinson does this in <ref> [27] </ref>, and also gives general results on the construction of universal hash functions. We exploit some of these ideas. Subsequent improvements (rooted in coding theory) came from Bierbrauer, Johansson, Kabatianskii and Smeets [6], and Gemmell and Naor [12]. The above work concentrates on unconditionally-secure authentication. <p> Johansson investigates how to reduce the size of the key for bucket hashing, which, in the current paper, is quite enormous [16]. 2 Preliminaries This section provides background drawn from Carter and Wegman [10, 32], Stinson <ref> [27] </ref>, and Krawczyk [18]. Proofs are omitted. A family of hash functions is a finite multiset H of string-valued functions, each h 2 H having the same nonempty domain A f0; 1g fl and range B f0; 1g b , for some constant b. <p> Proposition 2 <ref> [27] </ref> If H is *-AU 2 then H m is *-AU 2 . Sometimes one needs a way to make the collision probability smaller. <p> Proposition 4 <ref> [27] </ref> If H 1 is * 1 AU 2 and H 2 is * 2 AU 2 then H 2 ffi H 1 is (* 1 + * 2 )-AU 2 . <p> If B = f0; 1g b for some small b, and elements of H 2 are fast to compute on this domain, we have effectively "promoted" H 1 from being AU 2 to AXU 2 at little cost. 4 Proposition 5 <ref> [27] </ref> Suppose H 1 = fh : A ! Bg is * 1 AU 2 , and H 2 = fh : B ! Cg is * 2 -AXU 2 .
Reference: [28] <author> R. Taylor, </author> <title> An integrity check value algorithm for stream ciphers, </title> <booktitle> Advances in Cryptology - CRYPTO `93, Lecture Notes in Computer Science, </booktitle> <volume> vol. 773, </volume> <publisher> Springer-Verlag, </publisher> <year> 1994, </year> <pages> 40-48. </pages>
Reference-contexts: The proof of our main technical result is somewhat reminiscent of their analysis. Lai, Rueppel and Woolven [20], Taylor <ref> [28] </ref>, and Krawczyk [18] have all been interested in computationally efficient MACs. The last two works basically follow the Wegman-Carter paradigm. In particular, Krawczyk obtains efficient message authentication codes from hash families which resemble traditional cyclic redundancy codes (CRCs), and matrix multiplication using Toeplitz matrices.
Reference: [29] <author> J. </author> <title> Touch, Performance analysis of MD5, </title> <booktitle> Proc. Sigcomm '95, ACM, </booktitle> <year> 1995, </year> <pages> pp. 77-86. </pages>
Reference: [30] <author> G. Tsudik, </author> <title> Message authentication with one-way hash functions, </title> <booktitle> Proceedings of Infocom 92, </booktitle> <publisher> IEEE Press, </publisher> <year> 1992. </year>
Reference-contexts: This paper provides one such technique. Two approaches to message authentication. The fastest software MACs in common use today are exemplified by MAC k (x) = h (k k x k k), with h a (software-efficient) cryptographic hash function, such as h =MD5 [22]. Such methods are described in <ref> [30] </ref>. The algorithm HMAC [3] 1 represents the most refined algorithm in this direction.
Reference: [31] <author> U. Vazirani, </author> <title> Efficiency considerations in using semi-random sources, </title> <booktitle> Proceedings of the Nineteenth Annual ACM Symposium on Theory of Computing, </booktitle> <publisher> ACM Press, </publisher> <year> 1987, </year> <pages> pp. 160-168. </pages>
Reference-contexts: Still, for sufficiently long messages, it will be faster to use the bucket hashing technique from the following section. We comment that there are many other well-known techniques for universal hashing, such as the linear congruential hash (modulo a prime) [10], the shift register hash <ref> [31] </ref>, or the Toeplitz matrix hash [18].
Reference: [32] <author> M. Wegman and L. Carter, </author> <title> New hash functions and their use in authentication and set equality, </title> <journal> J. of Computer and System Sciences, </journal> <volume> vol. 22, </volume> <year> 1981, </year> <pages> pp. 265-279. </pages>
Reference-contexts: But it is well-known that this reasoning is specious: in particular, Wegman and Carter <ref> [32] </ref> showed back in 1981 that we do not have to "cryptographically" transform the entire string x. <p> Previous work. The general theory of unconditional authentication was developed by Simmons; see [26] for a survey. As we have already explained, the universal-hash-and-then-encrypt paradigm is due to Wegman and Carter <ref> [32] </ref>. The idea springs from their highly influential [10]. In Wegman-Carter authentication the size of the hash family corresponds to the number of bits of shared key|one reason to find smaller families of universal hash functions than those of [10, 32]. <p> The idea springs from their highly influential [10]. In Wegman-Carter authentication the size of the hash family corresponds to the number of bits of shared key|one reason to find smaller families of universal hash functions than those of <ref> [10, 32] </ref>. Stinson does this in [27], and also gives general results on the construction of universal hash functions. We exploit some of these ideas. Subsequent improvements (rooted in coding theory) came from Bierbrauer, Johansson, Kabatianskii and Smeets [6], and Gemmell and Naor [12]. <p> Johansson investigates how to reduce the size of the key for bucket hashing, which, in the current paper, is quite enormous [16]. 2 Preliminaries This section provides background drawn from Carter and Wegman <ref> [10, 32] </ref>, Stinson [27], and Krawczyk [18]. Proofs are omitted. A family of hash functions is a finite multiset H of string-valued functions, each h 2 H having the same nonempty domain A f0; 1g fl and range B f0; 1g b , for some constant b. <p> We will be hashing from domain D = f0; 1g wn to range R = f0; 1g wN . As a typical example, take w = 32, n = 1024, and N = 140. If we want to be explicit, such a family would be denoted B <ref> [32; 1024; 140] </ref>. For the scheme we describe to make sense we require that N Each hash function h 2 B is specified by a length-n list of cardinality-3 subsets of f1; : : :; N g. We denote this list by h = h 1 h n . <p> The following theorem says that it is impossible (regardless of time, number of queries, or amount of MACed text) to forge with probability exceeding the collision probability. Proposition 13 <ref> [32, 18] </ref> Let H be *-AXU 2 and suppose adversary E forges in the scheme WC [H] with probability ffi. Then ffi *. Wegman-Carter with a finite PRF. <p> Here is a way for the Signer to MAC a string X whose length is at most 1024 words. Assume an even number of words. The Signer and Verifier share as a MAC key (i) a random element h 1 2 B <ref> [32; 1024; 140] </ref>, (ii) a random element h 2 2 K [71; 64], and a (iii) a random string a 2 f0; 1g . We use the construction of Proposition 5 (slightly modified to account for length-variability).
Reference: [33] <author> A. Zobrist, </author> <title> A new hashing method with applications for game playing, </title> <institution> University of Wisconsin, Dept. of Computer Science, </institution> <note> TR #88 (April 1970). </note>
Reference-contexts: Finite PRFs are a refinement of the PRF notion of Goldreich, Goldwasser and Micali [13] to take account of the fixed lengths of inputs and outputs in the efficient primitives of cryptographic practice. Zobrist <ref> [33] </ref> gives a hashing technique which predates [10] and essentially coincides with one method from [10].
References-found: 33

