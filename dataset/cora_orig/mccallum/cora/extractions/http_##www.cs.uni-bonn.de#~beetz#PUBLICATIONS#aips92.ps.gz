URL: http://www.cs.uni-bonn.de/~beetz/PUBLICATIONS/aips92.ps.gz
Refering-URL: http://www.cs.uni-bonn.de/~beetz/publications.html
Root-URL: http://cs.uni-bonn.de
Email: beetz@cs.yale.edu, mcdermott@cs.yale.edu  
Title: Declarative Goals in Reactive Plans  
Author: Michael Beetz and Drew McDermott 
Address: P.O. Box 2158, Yale Station New Haven, CT 06520  
Affiliation: Yale University, Department of Computer Science  
Abstract: Classical planning started with goals and produced plans. To do something similar in a reactive framework, it is necessary to treat the achievement or maintenance of a goal as specifying a default behavior, while at the same time being able to deploy tools to generate more complex plans. These tools rely on representing the relations between goals and plan patterns that achieve them. An important component of the representation is a set of fast, local methods for making probabilistic estimations of the quality of proposed plans, including their robustness, completeness, and efficiency. 
Abstract-found: 1
Intro-found: 1
Reference: [BD89] <author> M. Boddy and T. Dean. </author> <title> Solving time-dependent planning problems. </title> <booktitle> In Proc. of the 11 th IJCAI, </booktitle> <pages> pages 979-984, </pages> <address> Detroit, MI, </address> <year> 1989. </year>
Reference-contexts: The robot planner has to treat planning time as a limited resource; i.e., it has to return plans for any allocation of computation time and has to reason about whether the expected gains from further planning will outweigh the costs of spending more planning time <ref> [DB88, BD89] </ref>. Finally, the planner has to be able to synthesize plans that implement any problem-solving behavior necessary to solve complex tasks in its environment|not just sequences of primitive robot actions [McD91c]. Various systems address different problems in the generation and revision of reactive plans.
Reference: [BP86] <author> M. Broy and P. Pepper. </author> <title> Program development as a formal activity. </title> <editor> In C. Rich and R. C. Waters, editors, </editor> <booktitle> Artificial Intelligence and Software Engineering, </booktitle> <pages> pages 123-131. </pages> <year> 1986. </year>
Reference-contexts: We could then use such a theory to generate transformation rules that would preserve the meaning of a plan while improving its efficiency <ref> [BP86] </ref>. A transformation rule is said to be correct if, for all cases for which its applicability condition holds, a plan matching its input schema is semantically equivalent to the one matching its output schema. Unfortunately, correct transformation rules are of little practical use for robot planning.
Reference: [Bro86] <author> R. A. Brooks. </author> <title> A robust layered control system for a mobile robot. </title> <journal> IEEE Journal of Robotics and Automation, </journal> <volume> 2(1) </volume> <pages> 285-348, </pages> <year> 1986. </year>
Reference-contexts: Finally, the planner has to be able to synthesize plans that implement any problem-solving behavior necessary to solve complex tasks in its environment|not just sequences of primitive robot actions [McD91c]. Various systems address different problems in the generation and revision of reactive plans. Representative approaches are the subsumption architecture <ref> [Bro86] </ref>, situated automata [Ros85, RP86], gapps [Kae88], the Entropy Reduction Engine (ere) [Dru89, DB90], and the Procedural Reasoning System (prs) [GL87, RG91]. In the subsumption architecture [Bro86, Bro91] and situated automata [Ros85] approach, sensor data are mapped into decisions about which actions to enable and disable. <p> Various systems address different problems in the generation and revision of reactive plans. Representative approaches are the subsumption architecture [Bro86], situated automata [Ros85, RP86], gapps [Kae88], the Entropy Reduction Engine (ere) [Dru89, DB90], and the Procedural Reasoning System (prs) [GL87, RG91]. In the subsumption architecture <ref> [Bro86, Bro91] </ref> and situated automata [Ros85] approach, sensor data are mapped into decisions about which actions to enable and disable. The state information stored in these ap 8 proaches is minimal and as a consequence all possible situations have to be associated with appropriate actions.
Reference: [Bro91] <author> R. A. Brooks. </author> <title> Intelligence without representation. </title> <journal> Artificial Intelligence, </journal> <volume> 47 </volume> <pages> 139-159, </pages> <year> 1991. </year>
Reference-contexts: Various systems address different problems in the generation and revision of reactive plans. Representative approaches are the subsumption architecture [Bro86], situated automata [Ros85, RP86], gapps [Kae88], the Entropy Reduction Engine (ere) [Dru89, DB90], and the Procedural Reasoning System (prs) [GL87, RG91]. In the subsumption architecture <ref> [Bro86, Bro91] </ref> and situated automata [Ros85] approach, sensor data are mapped into decisions about which actions to enable and disable. The state information stored in these ap 8 proaches is minimal and as a consequence all possible situations have to be associated with appropriate actions.
Reference: [Cha87] <author> D. Chapman. </author> <title> Planning for conjunctive goals. </title> <journal> Artificial Intelligence, </journal> <volume> 32 </volume> <pages> 333-377, </pages> <year> 1987. </year>
Reference-contexts: A plan is typically found by proposing an operator to solve part of the goal, then embedding that operator in a plan for the rest of the goal [McD91b]. Unfortunately, the choice of operators and embeddings is not obvious, so we quickly get an intractable search problem <ref> [Cha87] </ref>. The best approach we see to reactive goal decomposition is to assume that for every goal G there is a default plan for the job (achieve G). If there is no time to think, this is the plan that gets executed.
Reference: [DB88] <author> T. Dean and M. Boddy. </author> <title> An analysis of time-dependent planning. </title> <booktitle> In Proc. of AAAI-88, </booktitle> <pages> pages 49-54, </pages> <address> St. Paul, MN, </address> <year> 1988. </year>
Reference-contexts: The task of the scheduler is to divide the available time resources so that the biggest gains in terms of plan quality can be expected <ref> [DB88] </ref>. Scheduling is often necessary because transformations that produce better plans require more computation time. Currently, the scheduling functions have to be provided by the programmer. <p> The use of decision-theoretic methods for choosing between alternative tasks is discussed in [HH90]. Since plan hypotheses are generated based on heuristics they have to be tested (by projection) before being passed to the plan interpreter. HTRs provide useful plans soon and may continue to improve them <ref> [DB88] </ref>. HTRs may also have application conditions that are not strong enough to guarantee the maintenance of semantic equivalences of plans. The plan resulting from a transformation might be related to the original plan in several ways. <p> The robot planner has to treat planning time as a limited resource; i.e., it has to return plans for any allocation of computation time and has to reason about whether the expected gains from further planning will outweigh the costs of spending more planning time <ref> [DB88, BD89] </ref>. Finally, the planner has to be able to synthesize plans that implement any problem-solving behavior necessary to solve complex tasks in its environment|not just sequences of primitive robot actions [McD91c]. Various systems address different problems in the generation and revision of reactive plans.
Reference: [DB90] <author> M. Drummond and J. Bresina. </author> <title> Anytime synthetic projection: Maximizing the probability of goal satisfaction. </title> <booktitle> In Proc. of AAAI-90, </booktitle> <pages> pages 138-144, </pages> <address> Boston, MA, </address> <year> 1990. </year>
Reference-contexts: The robustness of a rpl expression as the product of its stability and correctness. The robustness of a plan can be increased by constructing alternative courses of actions such that the plan interpreter can choose between them at runtime, depending on the situations the robot finds itself in <ref> [DB90] </ref>. Reasoning about disjunctive plans, however, is often very expensive in terms of computational resources. Therefore, the planner should focus on relatively few alternatives and generate others only when necessary, i.e., when none of the alternative ways incorporated in its current plan succeeds. <p> Various systems address different problems in the generation and revision of reactive plans. Representative approaches are the subsumption architecture [Bro86], situated automata [Ros85, RP86], gapps [Kae88], the Entropy Reduction Engine (ere) <ref> [Dru89, DB90] </ref>, and the Procedural Reasoning System (prs) [GL87, RG91]. In the subsumption architecture [Bro86, Bro91] and situated automata [Ros85] approach, sensor data are mapped into decisions about which actions to enable and disable. <p> explicit representations allow xfrm to revise and specialize reactive plans if the robot acquires more information about the environment or if it changes its preferences, for instance, when it changes from a slow and robust execution mode to a fast and less reliable one. ere contains a synthetic projection algorithm <ref> [DB90] </ref>.
Reference: [Dru89] <author> M. Drummond. </author> <title> Situated control rules. </title> <editor> In R. J. Brachman, H. J. Levesque, and R. Re-iter, editors, </editor> <booktitle> KR'89: Proc. of the First International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 103-113. </pages> <publisher> Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1989. </year>
Reference-contexts: Various systems address different problems in the generation and revision of reactive plans. Representative approaches are the subsumption architecture [Bro86], situated automata [Ros85, RP86], gapps [Kae88], the Entropy Reduction Engine (ere) <ref> [Dru89, DB90] </ref>, and the Procedural Reasoning System (prs) [GL87, RG91]. In the subsumption architecture [Bro86, Bro91] and situated automata [Ros85] approach, sensor data are mapped into decisions about which actions to enable and disable.
Reference: [Fir87] <author> J. Firby. </author> <title> An investigation into reactive planning in complex domains. </title> <booktitle> In Proc. of AAAI-87, </booktitle> <pages> pages 202-206, </pages> <address> Seattle, WA, </address> <year> 1987. </year>
Reference-contexts: Under such time pressure, it is unlikely that it will be possible to generate complex reactive plans from first principles. Instead, most plans will be made up of large canned segments retrieved from a library, pasted together, and debugged <ref> [Fir87, McD90, SD87] </ref>.
Reference: [GL87] <author> M. P. Georgeff and A. L. Lansky. </author> <title> Reactive reasoning and planning. </title> <booktitle> In Proc. of AAAI-87, </booktitle> <pages> pages 677-682, </pages> <address> Seattle, WA, </address> <year> 1987. </year>
Reference-contexts: Various systems address different problems in the generation and revision of reactive plans. Representative approaches are the subsumption architecture [Bro86], situated automata [Ros85, RP86], gapps [Kae88], the Entropy Reduction Engine (ere) [Dru89, DB90], and the Procedural Reasoning System (prs) <ref> [GL87, RG91] </ref>. In the subsumption architecture [Bro86, Bro91] and situated automata [Ros85] approach, sensor data are mapped into decisions about which actions to enable and disable. <p> In contrast, xfrm computes plans that are represented in rpl, a more complex plan representation language. As in gapps, toplevel tasks in ere cannot be revised at execution time. prs <ref> [GL87] </ref> decides on actions and their order based on a database of current beliefs, a set of goals (desires), a set of intentions (goals the planner is committed to) and a set of plans specifying how to achieve goals and how to react to the environment.
Reference: [Han90] <author> S. Hanks. </author> <title> Projecting Plans for Uncertain Worlds. </title> <type> Technical report 756, </type> <institution> Yale University, Department of Computer Science, </institution> <year> 1990. </year>
Reference-contexts: First, it has to deal explicitly with the uncertainty that arises from the unpredictability of, and the incomplete information regarding, the environment in which the robot is operating <ref> [Han90] </ref>. It has to change the set of tasks it currently pursues according to user requests, information acquired, and given preference criteria.
Reference: [HH90] <author> P. Haddawy and S. Hanks. </author> <title> Issues in decision-theoretic planning: Symbolic goals and utilities. </title> <editor> In K. Sycara, editor, </editor> <booktitle> Proceedings of the Workshop on Innovative Approaches to Planning, Scheduling and Control, </booktitle> <pages> pages 48-58, </pages> <year> 1990. </year>
Reference-contexts: HTRs allow a planning system to generate plan hypotheses efficiently using heuristic and associational reasoning. Candidate plans are flexibly generated based on given preferences (e.g., a preference for efficiency over robustness), and expectations about the environment. The use of decision-theoretic methods for choosing between alternative tasks is discussed in <ref> [HH90] </ref>. Since plan hypotheses are generated based on heuristics they have to be tested (by projection) before being passed to the plan interpreter. HTRs provide useful plans soon and may continue to improve them [DB88]. <p> We have restricted ourselves to these aspects, because so far these are the ones that can be checked by the plan simulator. A thorough discussion of more expressive utility models for plans, including resources other than time, partial goal satisfaction, etc., can be found in <ref> [HH90] </ref>.
Reference: [Kae88] <author> L. P. Kaelbling. </author> <title> Goals as parallel program specifications. </title> <booktitle> In Proc. of AAAI-88, </booktitle> <pages> pages 60-65, </pages> <address> St. Paul, MN, </address> <year> 1988. </year>
Reference-contexts: Various systems address different problems in the generation and revision of reactive plans. Representative approaches are the subsumption architecture [Bro86], situated automata [Ros85, RP86], gapps <ref> [Kae88] </ref>, the Entropy Reduction Engine (ere) [Dru89, DB90], and the Procedural Reasoning System (prs) [GL87, RG91]. In the subsumption architecture [Bro86, Bro91] and situated automata [Ros85] approach, sensor data are mapped into decisions about which actions to enable and disable. <p> While these approaches are characterized by fast response time to environmental events they are unable to deal with multiple and varying goals in a sophisticated manner. gapps <ref> [Kae88] </ref> allows for the specification of reactive plans in terms of declarative tasks. Given declarative tasks (goals) of the form do (?a), achieve (?g), or maintain (?p), and a set of goal reduction rules, the system compiles the tasks into a synchronous digital circuit that achieves the tasks.
Reference: [MA91] <author> N. Martins and J. Allen. </author> <title> A language for planning with statistics. </title> <editor> In B. D'Ambrosio, P. Smets, and P. Bonissone, editors, </editor> <booktitle> Proc. of the 7 th Conference on Uncertainty in Artificial Intelligence, </booktitle> <pages> pages 220-227, </pages> <address> San Ma-teo, CA, 1991. </address> <publisher> Kaufmann. </publisher>
Reference-contexts: A thorough discussion of more expressive utility models for plans, including resources other than time, partial goal satisfaction, etc., can be found in [HH90]. The problem of making decisions based on weak evidence arises in the evaluation of plans by sampling simulations. <ref> [MA91] </ref> discusses an approach in which these problems can be represented and solved. 5 Conclusion In this paper we have described a representation scheme and the basic planning algorithms for handling declarative goals in a reactive planner.
Reference: [McD90] <author> D. McDermott. </author> <title> Planning reactive behavior: A progress report. </title> <editor> In K. Sycara, editor, </editor> <title> Innovative Approaches to Planning, </title> <journal> Scheduling and Control, </journal> <pages> pages 450-458, </pages> <address> San Mateo, CA, 1990. </address> <publisher> Kaufmann. </publisher>
Reference-contexts: Under such time pressure, it is unlikely that it will be possible to generate complex reactive plans from first principles. Instead, most plans will be made up of large canned segments retrieved from a library, pasted together, and debugged <ref> [Fir87, McD90, SD87] </ref>. <p> When there is more time, the planner can look for better plans. Methods for improving plans are represented as transformation rules and indexed by the patterns of plans they apply to. At the heart of our planner (called xfrm) <ref> [McD90] </ref> is a global technique for plan generation based on a projector and a transformer. The projector is used to predict what will happen when the current overall plan is executed. The outcome of a projector is a timeline and a set of "bugs". <p> In the third solution, descriptors for all the blue blocks in the kitchen are computed in advance and then for each of these descriptors the achievement task is executed. The perceive expression returns an effective designator for each blue block in the kitchen. A designator <ref> [McD90] </ref> is a data structure which carries the information necessary to resense and manipulate a perceived object. In particular, the designators contain the location of the objects. Thus the robot knows that it has to go into the the kitchen to get the blue blocks it is supposed to deliver.
Reference: [McD91a] <author> D. McDermott. </author> <title> A reactive plan language. </title> <type> Technical report 864, </type> <institution> Yale University, Department of Computer Science, </institution> <year> 1991. </year>
Reference-contexts: The plan is actually a program that can control the behavior of the agent completely without further intervention by the planner. These plans are written in rpl (Reactive Plan Language). Space does not allow a complete description of rpl (but see <ref> [McD91a] </ref>).
Reference: [McD91b] <author> D. McDermott. </author> <title> Regression planning. </title> <journal> International Journal of Intelligent Systems, </journal> <volume> 6 </volume> <pages> 357-416, </pages> <year> 1991. </year>
Reference-contexts: An operator is relevant to a goal if it adds propositions involving the predicates mentioned in the goal. A plan is typically found by proposing an operator to solve part of the goal, then embedding that operator in a plan for the rest of the goal <ref> [McD91b] </ref>. Unfortunately, the choice of operators and embeddings is not obvious, so we quickly get an intractable search problem [Cha87]. The best approach we see to reactive goal decomposition is to assume that for every goal G there is a default plan for the job (achieve G).
Reference: [McD91c] <author> D. McDermott. </author> <title> Robot planning. </title> <type> Technical report 861, </type> <institution> Yale University, Department of Computer Science, </institution> <year> 1991. </year>
Reference-contexts: Finally, the planner has to be able to synthesize plans that implement any problem-solving behavior necessary to solve complex tasks in its environment|not just sequences of primitive robot actions <ref> [McD91c] </ref>. Various systems address different problems in the generation and revision of reactive plans. Representative approaches are the subsumption architecture [Bro86], situated automata [Ros85, RP86], gapps [Kae88], the Entropy Reduction Engine (ere) [Dru89, DB90], and the Procedural Reasoning System (prs) [GL87, RG91].
Reference: [RG91] <author> A. S. Rao and M. P. Georgeff. </author> <title> Modeling rational agents within a BDI-architecture. </title> <editor> In J. Allen, R. Fikes, and E. Sandewall, editors, </editor> <booktitle> Principles of Knowledge Representation and Reasoning: Proc. of the Second International Conference (KR'91), </booktitle> <pages> pages 473-484. </pages> <publisher> Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1991. </year>
Reference-contexts: Various systems address different problems in the generation and revision of reactive plans. Representative approaches are the subsumption architecture [Bro86], situated automata [Ros85, RP86], gapps [Kae88], the Entropy Reduction Engine (ere) [Dru89, DB90], and the Procedural Reasoning System (prs) <ref> [GL87, RG91] </ref>. In the subsumption architecture [Bro86, Bro91] and situated automata [Ros85] approach, sensor data are mapped into decisions about which actions to enable and disable.
Reference: [Ros85] <author> S. J. Rosenschein. </author> <title> Formal theories of knowledge in AI and robotics. </title> <journal> New Generation Computing, </journal> <volume> 3 </volume> <pages> 345-357, </pages> <year> 1985. </year>
Reference-contexts: Various systems address different problems in the generation and revision of reactive plans. Representative approaches are the subsumption architecture [Bro86], situated automata <ref> [Ros85, RP86] </ref>, gapps [Kae88], the Entropy Reduction Engine (ere) [Dru89, DB90], and the Procedural Reasoning System (prs) [GL87, RG91]. In the subsumption architecture [Bro86, Bro91] and situated automata [Ros85] approach, sensor data are mapped into decisions about which actions to enable and disable. <p> Representative approaches are the subsumption architecture [Bro86], situated automata [Ros85, RP86], gapps [Kae88], the Entropy Reduction Engine (ere) [Dru89, DB90], and the Procedural Reasoning System (prs) [GL87, RG91]. In the subsumption architecture [Bro86, Bro91] and situated automata <ref> [Ros85] </ref> approach, sensor data are mapped into decisions about which actions to enable and disable. The state information stored in these ap 8 proaches is minimal and as a consequence all possible situations have to be associated with appropriate actions.
Reference: [RP86] <author> S. J. Rosenschein and L. </author> <title> Pack Kaelbling. The synthesis of digital machines with provable epistemic properties. </title> <booktitle> In Proc. of the 1986 Conference on Theoretical Aspects of Reasoning about Knowledge, </booktitle> <pages> pages 83-98, </pages> <address> Monterey, CA, </address> <year> 1986. </year>
Reference-contexts: Various systems address different problems in the generation and revision of reactive plans. Representative approaches are the subsumption architecture [Bro86], situated automata <ref> [Ros85, RP86] </ref>, gapps [Kae88], the Entropy Reduction Engine (ere) [Dru89, DB90], and the Procedural Reasoning System (prs) [GL87, RG91]. In the subsumption architecture [Bro86, Bro91] and situated automata [Ros85] approach, sensor data are mapped into decisions about which actions to enable and disable.
Reference: [SD87] <author> R. Simmons and R. Davis. </author> <title> Generate, test and debug: Combining associational rules and causal models. </title> <booktitle> In Proc. of the 10 th IJCAI, </booktitle> <pages> pages 1071-1078, </pages> <address> Milan, Italy, </address> <year> 1987. </year>
Reference-contexts: Under such time pressure, it is unlikely that it will be possible to generate complex reactive plans from first principles. Instead, most plans will be made up of large canned segments retrieved from a library, pasted together, and debugged <ref> [Fir87, McD90, SD87] </ref>. <p> The rpl construct description for achieving that an object will be in a certain room is shown in figure 5 and the corresponding default rule in figure 6. 3 Planning Algorithm The planning system is designed according to the Generate-Test-Debug (GTD) control strategy <ref> [SD87] </ref> and consists of a plan hypothesizer, a plan tester, and a plan debugger. The plan hy-pothesizer proposes plans that are promising under heuristic evaluation.
Reference: [Sim88] <author> R. Simmons. </author> <title> A theory of debugging plans and interpretations. </title> <booktitle> In Proc. of AAAI-88, </booktitle> <pages> pages 94-99, </pages> <address> St. Paul, MN, </address> <year> 1988. </year> <month> 10 </month>
Reference-contexts: ?cond ?taskend) (maintains ?pred ?goal-exp) (thnot (contains ?pred ?y))) 3.3 Debugging Plan Hypotheses The plan debugger gets a set of projections of the current plan hypothesis as its input and produces a debugged plan by running the transformation rules in the debug slots of the relevant rpl construct descriptions (see <ref> [Sim88] </ref> for a theory of plan debugging). The debugged version of the plan is passed to the plan tester for further testing. The test-debug cycle terminates when the plan tester module cannot find any more bugs in the hypothesis. Figure 9 shows a debug rule for the achieve-for-all construct.
References-found: 23

