URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/monadic-parsers.ps
Refering-URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/
Root-URL: 
Title: Monadic Parser Combinators  
Author: Graham Hutton Erik Meijer 
Affiliation: University of Nottingham  University of Utrecht  
Abstract: Appears as technical report NOTTCS-TR-96-4, Department of Computer Science, University of Nottingham, 1996 Abstract In functional programming, a popular approach to building recursive descent parsers is to model parsers as functions, and to define higher-order functions (or combinators) that implement grammar constructions such as sequencing, choice, and repetition. Such parsers form an instance of a monad, an algebraic structure from mathematics that has proved useful for addressing a number of computational problems. The purpose of this article is to provide a step-by-step tutorial on the monadic approach to building functional parsers, and to explain some of the benefits that result from exploiting monads. No prior knowledge of parser combinators or of monads is assumed. Indeed, this article can also be viewed as a first introduction to the use of monads in programming. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Aho, A., Sethi, R., & Ullman, J. </author> <year> (1986). </year> <title> Compilers | principles, techniques and tools. </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: For this reason, and for simplicity, in this article we only use the comprehension notation. It would be an easy task, however, to translate our definitions into the do notation. 4 Combinators for repetition Parser generators such as Lex and Yacc <ref> (Aho et al., 1986) </ref> for producing parsers written in C, and Ratatosk (Mogensen, 1993) and Happy (Gill & Marlow, 1995) for producing parsers written in Haskell, typically offer a fixed set of combinators for describing grammars. <p> The definition of first using pattern matching does not suffer from this problem. 6 Handling lexical issues Traditionally, a string to be parsed is not supplied directly to a parser, but is first passed through a lexical analysis phase (or lexer) that breaks the string into a sequence of tokens <ref> (Aho et al., 1986) </ref>. Lexical analysis is a convenient place to remove white-space (spaces, newlines, and tabs) and comments from the input string, and to distinguish between identifiers and keywords. Since lexers are just simple parsers, they can be built using parser combinators, as discussed by Hutton (1992).
Reference: <author> Burge, W.H. </author> <year> (1975). </year> <title> Recursive programming techniques. </title> <publisher> Addison-Wesley. </publisher> <address> Fokker, Jeroen. </address> <year> 1995 </year> <month> (May). </month> <title> Functional parsers. </title> <booktitle> Lecture notes of the Baastad Spring school on functional programming. </booktitle>
Reference-contexts: 1 Introduction In functional programming, a popular approach to building recursive descent parsers is to model parsers as functions, and to define higher-order functions (or combina-tors) that implement grammar constructions such as sequencing, choice, and repetition. The basic idea dates back to at least Burge's book on recursive programming techniques <ref> (Burge, 1975) </ref>, and has been popularised in functional programming by Wadler (1985), Hutton (1992), Fokker (1995), and others. Combinators provide a quick and easy method of building functional parsers.
Reference: <author> Gill, Andy, & Marlow, Simon. </author> <year> 1995 </year> <month> (Jan.). </month> <title> Happy: the parser generator for Haskell. </title> <institution> University of Glasgow. </institution>
Reference-contexts: Combinators provide a quick and easy method of building functional parsers. Moreover, the method has the advantage over functional parser generators such as Ratatosk (Mogensen, 1993) and Happy <ref> (Gill & Marlow, 1995) </ref> that one has the full power of a functional language available to define new combinators for special applications (Landin, 1966). <p> It would be an easy task, however, to translate our definitions into the do notation. 4 Combinators for repetition Parser generators such as Lex and Yacc (Aho et al., 1986) for producing parsers written in C, and Ratatosk (Mogensen, 1993) and Happy <ref> (Gill & Marlow, 1995) </ref> for producing parsers written in Haskell, typically offer a fixed set of combinators for describing grammars.
Reference: <author> Hughes, John. </author> <year> (1989). </year> <title> Why functional programming matters. </title> <journal> The computer journal, </journal> <volume> 32(2), </volume> <pages> 98-107. </pages>
Reference-contexts: In other words, many is not as lazy as we would expect. But does this really matter? Yes, because it is common in functional programming to rely on laziness to avoid the creation of large intermediate structures <ref> (Hughes, 1989) </ref>.
Reference: <author> Hutton, Graham. </author> <year> (1992). </year> <title> Higher-order functions for parsing. </title> <journal> Journal of functional programming, </journal> <note> 2(3), 323-343. </note> <author> 38 Graham Hutton and Erik Meijer Jones, Mark P. </author> <year> (1994). </year> <note> Gofer 2.30a release notes. Unpublished manuscript. </note>
Reference-contexts: One could go further (as in <ref> (Hutton, 1992) </ref>, for example) and abstract upon the type String of tokens, but we do not have need for this generalisation here. 2.2 Primitive parsers The three primitive parsers defined in this section are the building blocks of com-binator parsing.
Reference: <author> Jones, Mark P. </author> <year> (1995a). </year> <title> Functional programming beyond the Hindley/Milner type system. </title> <booktitle> Proc. lecture notes of the Baastad spring school on functional programming. </booktitle>
Reference-contexts: In this section we define a number of other monads related to the parser monad, leading up to a modular reformulation of the parser monad in terms of two simpler monads <ref> (Jones, 1995a) </ref>. The immediate benefit is that, as Monadic Parser Combinators 25 we shall see, the basic parser combinators no longer need to be defined explicitly.
Reference: <author> Jones, Mark P. </author> <year> (1995b). </year> <title> The Gofer distribution. </title> <note> Available from the University of Not-tingham: http://www.cs.nott.ac.uk/Department/Staff/mpj/. </note>
Reference-contexts: Some prior exposure to functional programming would be helpful in reading this article, but special features of Gofer <ref> (Jones, 1995b) </ref> | our implementation language | are explained as they are used. Any other lazy functional language that supports (multi-parameter) constructor classes and the use of monad comprehension notation would do equally well. No prior knowledge of parser combinators or monads is assumed.
Reference: <author> Jones, Mark P. </author> <year> (1995c). </year> <title> A system of constructor classes: overloading and implicit higher-order polymorphism. </title> <journal> Journal of functional programming, </journal> <volume> 5(1), </volume> <pages> 1-35. </pages>
Reference-contexts: Under this overloading mechanism, the appropriate monad for each use of a name is calculated automatically during type inference. Overloading in Gofer is accomplished by the use of classes <ref> (Jones, 1995c) </ref>. <p> allowing them to be expressed in the following, more appealing form: [ f x1 x2 ... xn | x1 &lt;- p1 Monadic Parser Combinators 11 , x2 &lt;- p2 , xn &lt;- pn ] In fact, this notation is not specific to parsers, but can be used with any monad <ref> (Jones, 1995c) </ref>. The reader might notice the similarity to the list comprehension notation supported by many functional languages. It was Wadler (1990) who first observed that the comprehension notation is not particular to lists, but makes sense for an arbitrary monad.
Reference: <author> Jones, Simon Peyton, & Launchbury, John. </author> <year> (1994). </year> <title> State in Haskell. </title> <institution> University of Glasgow. </institution>
Reference-contexts: Thinking pictorially in terms of boxes and wires is a useful aid to becoming familiar with these two operations <ref> (Jones & Launchbury, 1994) </ref>. The state-transformer monad State s does not have a zero and a plus. However, as we shall see in the next section, the parameterised state-transformer monad over a given based monad m does have a zero and a plus, provided that m does.
Reference: <author> Landin, Peter. </author> <year> (1966). </year> <title> The next 700 programming languages. </title> <journal> Communications of the ACM, </journal> <volume> 9(3). </volume>
Reference-contexts: Moreover, the method has the advantage over functional parser generators such as Ratatosk (Mogensen, 1993) and Happy (Gill & Marlow, 1995) that one has the full power of a functional language available to define new combinators for special applications <ref> (Landin, 1966) </ref>. It was realised early on (Wadler, 1990) that parsers form an instance of a monad, an algebraic structure from mathematics that has proved useful for addressing a number of computational problems (Moggi, 1989; Wadler, 1990; Wadler, 1992a; Wadler, 1992b).
Reference: <author> Mogensen, Torben. </author> <year> (1993). </year> <title> Ratatosk: a parser generator and scanner generator for Gofer. </title> <institution> University of Copenhagen (DIKU). </institution>
Reference-contexts: Combinators provide a quick and easy method of building functional parsers. Moreover, the method has the advantage over functional parser generators such as Ratatosk <ref> (Mogensen, 1993) </ref> and Happy (Gill & Marlow, 1995) that one has the full power of a functional language available to define new combinators for special applications (Landin, 1966). <p> It would be an easy task, however, to translate our definitions into the do notation. 4 Combinators for repetition Parser generators such as Lex and Yacc (Aho et al., 1986) for producing parsers written in C, and Ratatosk <ref> (Mogensen, 1993) </ref> and Happy (Gill & Marlow, 1995) for producing parsers written in Haskell, typically offer a fixed set of combinators for describing grammars.
Reference: <author> Moggi, Eugenio. </author> <year> (1989). </year> <title> Computation lambda-calculus and monads. </title> <note> Proc. IEEE symposium on logic in computer science. A extended version of the paper is available as a technical report from the University of Edinburgh. Rojemo, Niklas. </note> <year> (1995). </year> <title> Garbage collection and memory efficiency in lazy functional languages. </title> <type> Ph.D. thesis, </type> <institution> Chalmers University of Technology. </institution>
Reference: <author> Spivey, Mike. </author> <year> (1990). </year> <title> A functional theory of exceptions. </title> <booktitle> Science of computer programming, </booktitle> <volume> 14, </volume> <pages> 25-42. </pages>
Reference-contexts: Since failure can be viewed as a simple kind of exception, Maybe is sometimes called the exception monad in the literature <ref> (Spivey, 1990) </ref>. 7.2 The non-determinism monad A natural generalisation of Maybe is the list type constructor [].
Reference: <author> Wadler, Philip. </author> <year> (1985). </year> <title> How to replace failure by a list of successes. </title> <booktitle> Proc. conference on functional programming and computer architecture. </booktitle> <publisher> Springer-Verlag. </publisher>
Reference: <author> Wadler, Philip. </author> <year> (1990). </year> <title> Comprehending monads. </title> <booktitle> Proc. ACM conference on Lisp and functional programming. </booktitle>
Reference-contexts: Moreover, the method has the advantage over functional parser generators such as Ratatosk (Mogensen, 1993) and Happy (Gill & Marlow, 1995) that one has the full power of a functional language available to define new combinators for special applications (Landin, 1966). It was realised early on <ref> (Wadler, 1990) </ref> that parsers form an instance of a monad, an algebraic structure from mathematics that has proved useful for addressing a number of computational problems (Moggi, 1989; Wadler, 1990; Wadler, 1992a; Wadler, 1992b).
Reference: <author> Wadler, Philip. </author> <year> (1992a). </year> <title> The essence of functional programming. </title> <booktitle> Proc. principles of programming languages. </booktitle>
Reference-contexts: (for example, limiting parsers to producing at most one result), new combinators for the modified monad of parsers are also defined automatically. 7.1 The exception monad Before starting to define other monads, it is useful to first focus briefly on the intuition behind the use of monads in functional programming <ref> (Wadler, 1992a) </ref>. The basic idea behind monads is to distinguish the values that a computation can produce from the computation itself.
Reference: <author> Wadler, Philip. </author> <year> (1992b). </year> <title> Monads for functional programming. </title> <editor> Broy, Manfred (ed), </editor> <booktitle> Proc. Marktoberdorf Summer school on program design calculi. </booktitle> <publisher> Springer-Verlag. </publisher>
References-found: 17

