URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/papers/rlf92.ps.gz
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/papers/
Root-URL: 
Email: Internet: fp@cs.cmu.edu  
Title: Intersection Types for a Logical Framework  
Author: Frank Pfenning 
Date: December 1992  
Address: Pittsburgh, Pennsylvania 15213-3891  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: We propose a refinement of the type theory underlying the LF logical framework by a form of subtypes and intersection types. This refinement preserves desirable features of LF, such as decidability of type-checking, and at the same time considerably simplifies the representations of many deductive systems.
Abstract-found: 1
Intro-found: 1
Reference: [CDCV81] <author> Mario Coppo, Maria Dezani-Ciancaglini, and B. Venneri. </author> <title> Functional character of solvable terms. </title> <journal> Zeitschrift fur mathematische Logic und Grundlagen der Mathematik, </journal> <volume> 27 </volume> <pages> 45-58, </pages> <year> 1981. </year>
Reference-contexts: Similar systems of simple subtypes have been used in programming languages, in particular in connection with record types and object-oriented programming, but such systems are not expressive enough for our purposes. More promising are enhancements of simple subtypes with intersection types <ref> [CDCV81] </ref>, which have been applied to programming languages [Rey91] and recently also in type theory [Hay91]. General decidability of type-checking or inference in such calculi is problematic, but under certain restrictions type checking is decidable and principal types exist [Rey88, FP91, CG92].
Reference: [CG92] <author> M. Coppo and P. Giannini. </author> <title> A complete type inference algorithm for simple intersection types. </title> <editor> In J.-C. Raoult, editor, </editor> <booktitle> 17th Colloquium on Trees in Algebra and Programming, Rennes, France, </booktitle> <pages> pages 102-123, </pages> <address> Berlin, </address> <month> February </month> <year> 1992. </year> <note> Springer-Verlag LNCS 581. </note>
Reference-contexts: More promising are enhancements of simple subtypes with intersection types [CDCV81], which have been applied to programming languages [Rey91] and recently also in type theory [Hay91]. General decidability of type-checking or inference in such calculi is problematic, but under certain restrictions type checking is decidable and principal types exist <ref> [Rey88, FP91, CG92] </ref>. In this paper we tie together ideas from these threads of research and propose a refinement of the LF type theory by a version of bounded intersection types, or refinement types, as we call them.
Reference: [Fel89] <author> Amy Felty. </author> <title> Specifying and Implementing Theorem Provers in a Higher-Order Logic Programming Language. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <month> July </month> <year> 1989. </year> <note> Available as Technical Report MS-CIS-89-53. </note>
Reference-contexts: Natural Deductions in Normal Form. The next example illustrates that we often want to make subtype distinctions at the level of deductions and not only at the level of syntax. We follow the usual representation of natural deduction in LF [HHP93] and Felty's trick to enforce normal forms <ref> [Fel89] </ref>. We restrict ourselves to the purely implicational fragment. x . . . I x A B A B The deduction in the premise of the implication introduction rule discharges the hypothesis A labelled x and is represented as a function from deductions of A to deductions of B.
Reference: [FP91] <author> Tim Freeman and Frank Pfenning. </author> <title> Refinement types for ML. </title> <booktitle> In Proceedings of the SIGPLAN '91 Symposium on Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pages 268-277. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: More promising are enhancements of simple subtypes with intersection types [CDCV81], which have been applied to programming languages [Rey91] and recently also in type theory [Hay91]. General decidability of type-checking or inference in such calculi is problematic, but under certain restrictions type checking is decidable and principal types exist <ref> [Rey88, FP91, CG92] </ref>. In this paper we tie together ideas from these threads of research and propose a refinement of the LF type theory by a version of bounded intersection types, or refinement types, as we call them. <p> We show that it has a decidable type-checking problem and is thus useful as a logical framework. We have not yet implemented this system, but experience with a related implementation of refinement types for ML <ref> [FP91] </ref> and the current Elf term reconstruction algorithm leads us to believe that type-checking will be practical. The system we propose is relevant not only to LF and its Elf implementation, but could be directly applied to Prolog [MNPS91] or Isabelle [PN90] with similar benefits. <p> The type-checking algorithm which arises out of the proof of Theorem 6 works by bottom-up synthesis and is not practical. However, a top-down type-checking algorithm as in the implementation of refinement types for ML <ref> [FP91] </ref> promises to be of acceptable efficiency, especially since our language lacks recursion at the level of terms. We would also like to consider relaxing some of the restrictions currently in place to enforce orthogonality of conversion and subsorting.
Reference: [Geu92] <author> Herman Geuvers. </author> <title> The Church-Rosser property for fi-reduction in typed -calculi. </title> <editor> In A. Scedrov, editor, </editor> <booktitle> Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 453-460, </pages> <address> Santa Cruz, California, June 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Lemma 3 The judgment U V is decidable on valid terms and every valid term U has a unique equivalent canonical form. Proof sketch: The corresponding judgment on LF is decidable on valid LF terms (see, for example, <ref> [Geu92] </ref>). Equivalence on types and kinds is structural and therefore trivially decidable, except for conversions among the embedded objects.
Reference: [Hay91] <author> Susumu Hayashi. </author> <title> Singleton, union and intersection types for program extraction. </title> <editor> In T. Ito and A. R. Meyer, editors, </editor> <booktitle> Proceedings of the International Conference on Theoretical Aspects of Software, </booktitle> <pages> pages 701-730, </pages> <address> Sendai, Japan, </address> <month> September </month> <year> 1991. </year> <note> Springer-Verlag LNCS 526. </note>
Reference-contexts: More promising are enhancements of simple subtypes with intersection types [CDCV81], which have been applied to programming languages [Rey91] and recently also in type theory <ref> [Hay91] </ref>. General decidability of type-checking or inference in such calculi is problematic, but under certain restrictions type checking is decidable and principal types exist [Rey88, FP91, CG92].
Reference: [HHP93] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Over the past two years we have carried out extensive experiments in the application of the LF Logical Framework <ref> [HHP93] </ref> to represent and implement deductive systems and their metatheory. Such systems arise naturally in the study of logic and the theory of programming languages. <p> Natural Deductions in Normal Form. The next example illustrates that we often want to make subtype distinctions at the level of deductions and not only at the level of syntax. We follow the usual representation of natural deduction in LF <ref> [HHP93] </ref> and Felty's trick to enforce normal forms [Fel89]. We restrict ourselves to the purely implicational fragment. x . . . <p> Furthermore, every valid term U has a minimal type or kind. Proof sketch: Using the forgetful interpretation and the soundness and completeness of the algorithmic version of LF in <ref> [HHP93] </ref> we can show that each derivation can be transformed into one which eagerly applies normalization on types, but otherwise requires no type conversion.
Reference: [HP92] <author> John Hannan and Frank Pfenning. </author> <title> Compiler verification in LF. </title> <editor> In Andre Scedrov, editor, </editor> <booktitle> Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 407-418, </pages> <address> Santa Cruz, California, </address> <month> June </month> <year> 1992. </year> <title> IEEE Computer Society Press. Intersection Types for LF 12 </title>
Reference-contexts: For example, we have formalized the operational semantics and type system of Mini-ML and implemented a proof of type preservation [MP91] and the correctness of a compiler to a variant of the Categorical Abstract Machine <ref> [HP92] </ref>. LF is based on a predicative type theory with dependent types.
Reference: [Koh91] <author> Michael Kohlhase. </author> <title> Order-sorted type theory I: Unification. </title> <type> SEKI Report SR-91-18, </type> <institution> Universitat des Saarlandes, Saarbrucken, Germany, </institution> <year> 1991. </year>
Reference-contexts: However, it is not clear how to generalize these calculi to 1 Intersection Types for LF 2 logics or type theories with higher-order functions, although recently some interesting work in this direction has begun <ref> [Koh91, Koh92, NQ92] </ref>. Similar systems of simple subtypes have been used in programming languages, in particular in connection with record types and object-oriented programming, but such systems are not expressive enough for our purposes.
Reference: [Koh92] <author> Michael Kohlhase. </author> <title> Unification in order-sorted type theory. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Proceedings of the International Conference on Logic Programming and Automated Reasoning, </booktitle> <pages> pages 421-432, </pages> <address> St. Petersburg, Russia, July 1992. </address> <publisher> Springer-Verlag LNAI 624. </publisher>
Reference-contexts: However, it is not clear how to generalize these calculi to 1 Intersection Types for LF 2 logics or type theories with higher-order functions, although recently some interesting work in this direction has begun <ref> [Koh91, Koh92, NQ92] </ref>. Similar systems of simple subtypes have been used in programming languages, in particular in connection with record types and object-oriented programming, but such systems are not expressive enough for our purposes.
Reference: [MNPS91] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: The system we propose is relevant not only to LF and its Elf implementation, but could be directly applied to Prolog <ref> [MNPS91] </ref> or Isabelle [PN90] with similar benefits. In future work, we plan to consider the operational aspects of this type theory so that it can be fully embedded into the current Elf implementation. <p> Space only permits a rather sketchy discussion of these examples; the interested reader may find additional explanation in the indicated references. Hereditary Harrop Formulas. Here we consider, as an object logic, the language of hereditary Harrop formulas <ref> [MNPS91] </ref>, a fragment of logic suitable as a basis for a logic programming language. For the sake of brevity we restrict ourselves to the propositional formulas.
Reference: [MP91] <author> Spiro Michaylov and Frank Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <editor> In L.-H. Eriksson, L. Hallnas, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 299-344, </pages> <address> Stockholm, Sweden, </address> <month> January </month> <year> 1991. </year> <note> Springer-Verlag LNAI 596. </note>
Reference-contexts: Such systems arise naturally in the study of logic and the theory of programming languages. For example, we have formalized the operational semantics and type system of Mini-ML and implemented a proof of type preservation <ref> [MP91] </ref> and the correctness of a compiler to a variant of the Categorical Abstract Machine [HP92]. LF is based on a predicative type theory with dependent types.
Reference: [NQ92] <author> Tobias Nipkow and Zhenyu Qian. </author> <title> Reduction and unification in lambda calculi with subtypes. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 66-78, </pages> <address> Saratoga Springs, New York, June 1992. </address> <publisher> Springer-Verlag LNAI 607. </publisher>
Reference-contexts: However, it is not clear how to generalize these calculi to 1 Intersection Types for LF 2 logics or type theories with higher-order functions, although recently some interesting work in this direction has begun <ref> [Koh91, Koh92, NQ92] </ref>. Similar systems of simple subtypes have been used in programming languages, in particular in connection with record types and object-oriented programming, but such systems are not expressive enough for our purposes.
Reference: [Pfe91a] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: It has proved to be an excellent language for such formalization efforts, since it allows direct representation of deductions as objects and judgments as types and supports common concepts such as variable binding, substitution, and generic and hypothetical judgments. The logic programming language Elf <ref> [Pfe91a] </ref> implements LF and gives it an operational interpretation so that LF signatures can be executed as logic programs. It also provides sophisticated term reconstruction, which is important for realistic applications. Despite its expressive power, certain weaknesses of LF emerged during these experiments. <p> In future work, we plan to consider the operational aspects of this type theory so that it can be fully embedded into the current Elf implementation. This includes unification, or rather, solving of constraints in the style described in <ref> [Pfe91a, Pfe91b] </ref>, type reconstruction, and search. Based on experience from first-order logic programming we conjecture that subtyping constraints can lead to improved operational behavior of many programs. 2 Two Motivating Examples In this section we give two prototypical examples which motivate our extension of the LF type theory.
Reference: [Pfe91b] <author> Frank Pfenning. </author> <title> Unification and anti-unification in the Calculus of Constructions. </title> <booktitle> In Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 74-85, </pages> <address> Amsterdam, The Nether-lands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: In future work, we plan to consider the operational aspects of this type theory so that it can be fully embedded into the current Elf implementation. This includes unification, or rather, solving of constraints in the style described in <ref> [Pfe91a, Pfe91b] </ref>, type reconstruction, and search. Based on experience from first-order logic programming we conjecture that subtyping constraints can lead to improved operational behavior of many programs. 2 Two Motivating Examples In this section we give two prototypical examples which motivate our extension of the LF type theory.
Reference: [Pie91] <author> Benjamin C. Pierce. </author> <title> Programming with Intersection Types and Bounded Polymorphism. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> December </month> <year> 1991. </year> <note> Available as Technical Report CMU-CS-91-205. </note>
Reference-contexts: Proof sketch: By an interpretation into the subtyping problem for Forsythe, for which a decid-ability proof has been given by Reynolds [personal communication, 1991]. The proof can be found in <ref> [Pie91] </ref> in a slightly different form. Each atomic type of the form a M 1 . . . M n is interpreted as a simple type a M 1 . . . M n which inherits its subsorting property from a.
Reference: [PN90] <author> Lawrence C. Paulson and Tobias Nipkow. </author> <title> Isabelle tutorial and user's manual. </title> <type> Technical Report 189, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: The system we propose is relevant not only to LF and its Elf implementation, but could be directly applied to Prolog [MNPS91] or Isabelle <ref> [PN90] </ref> with similar benefits. In future work, we plan to consider the operational aspects of this type theory so that it can be fully embedded into the current Elf implementation. This includes unification, or rather, solving of constraints in the style described in [Pfe91a, Pfe91b], type reconstruction, and search.
Reference: [Rey88] <author> John C. Reynolds. </author> <title> Preliminary design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-88-159, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: More promising are enhancements of simple subtypes with intersection types [CDCV81], which have been applied to programming languages [Rey91] and recently also in type theory [Hay91]. General decidability of type-checking or inference in such calculi is problematic, but under certain restrictions type checking is decidable and principal types exist <ref> [Rey88, FP91, CG92] </ref>. In this paper we tie together ideas from these threads of research and propose a refinement of the LF type theory by a version of bounded intersection types, or refinement types, as we call them.
Reference: [Rey91] <author> John C. Reynolds. </author> <title> The coherence of languages with intersection types. </title> <editor> In T. Ito and A. R. Meyer, editors, </editor> <booktitle> International Conference on Theoretical Aspects of Computer Software, </booktitle> <pages> pages 675-700, </pages> <address> Sendai, Japan, </address> <month> September </month> <year> 1991. </year> <note> Springer-Verlag LNCS 526. </note>
Reference-contexts: Similar systems of simple subtypes have been used in programming languages, in particular in connection with record types and object-oriented programming, but such systems are not expressive enough for our purposes. More promising are enhancements of simple subtypes with intersection types [CDCV81], which have been applied to programming languages <ref> [Rey91] </ref> and recently also in type theory [Hay91]. General decidability of type-checking or inference in such calculi is problematic, but under certain restrictions type checking is decidable and principal types exist [Rey88, FP91, CG92].
Reference: [Smo89] <author> G. Smolka. </author> <title> Logic Programming over Polymorphically Order-Sorted Types. </title> <type> Dissertation, </type> <institution> Univer-sitat Kaiserslautern, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Looking elsewhere, we find an extensive body of work on order-sorted first-order calculi and their use in logic programming and automated theorem proving (see, for example, <ref> [Smo89, SS89] </ref>). However, it is not clear how to generalize these calculi to 1 Intersection Types for LF 2 logics or type theories with higher-order functions, although recently some interesting work in this direction has begun [Koh91, Koh92, NQ92].
Reference: [SS88] <author> Anne Salvesen and Jan M. Smith. </author> <title> The strength of the subset type in Martin-Lof's type theory. </title> <booktitle> In Third Annual Symposium on Logic in Computer Science, </booktitle> <address> Edinburgh, Scotland, </address> <pages> pages 384-391. </pages> <publisher> IEEE, </publisher> <month> July </month> <year> 1988. </year>
Reference-contexts: In practice, however, this becomes a significant burden and one has the feeling that the framework should support simple reasoning about subtypes. An obvious candidate for an extension of the type system are subset types as they are used for example in Martin-Lof type theory <ref> [SS88] </ref>. In a logical framework, however, they are problematic, because they lead to an undecidable type-checking problem. The methodology of LF reduces proof checking in the object language to type checking in the meta-language (the LF type theory), and thus decidability is paramount.
Reference: [SS89] <author> Manfred Schmidt-Schau. </author> <title> Computational Aspects of an Order-Sorted Logic with Term Declarations. </title> <publisher> Springer-Verlag LNAI 395, </publisher> <year> 1989. </year>
Reference-contexts: Looking elsewhere, we find an extensive body of work on order-sorted first-order calculi and their use in logic programming and automated theorem proving (see, for example, <ref> [Smo89, SS89] </ref>). However, it is not clear how to generalize these calculi to 1 Intersection Types for LF 2 logics or type theories with higher-order functions, although recently some interesting work in this direction has begun [Koh91, Koh92, NQ92].
References-found: 22

