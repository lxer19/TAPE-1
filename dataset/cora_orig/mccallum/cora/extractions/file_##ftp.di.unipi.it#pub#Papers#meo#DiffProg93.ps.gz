URL: file://ftp.di.unipi.it/pub/Papers/meo/DiffProg93.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: fmichele@blues,bossi@pdmat1g.unipd.it  fgabbri,levi,meog@di.unipi.it  
Title: Differential Logic Programming  
Author: A. Bossi M. Bugliesi M. Gabbrielli G. Levi M. C. Meo 
Address: Via Belzoni 7, 35131 Padova, Italy  Corso Italia 40, 56100 Pisa, Italy  
Affiliation: Dipartimento di Matematica P&A Universita di Padova  Dipartimento di Informatica Universita di Pisa,  
Abstract: In this paper we define a compositional semantics for a generalized composition operator on logic programs. Static and dynamic inheritance as well as composition by union of clauses can all be obtained by specializing the general operator. The semantics is based on the notion of differential programs, logic programs annotated with declarations that establish the programs' external interfaces. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt and D. Pedreschi. </author> <title> Proving Termination of General Prolog Programs. </title> <editor> In T. Ito and A.R. Meyer, editors, </editor> <booktitle> Proc. of Int. Conf. on Theoretical Aspects of Computer Software, volume 526 of Lecture Notes in Computer Science, </booktitle> <pages> pages 265-289, </pages> <address> Sendai, Japan, </address> <year> 1991. </year>
Reference-contexts: Finally, we assume the reader familiar with the standard notions of logic programming reported in [20] and <ref> [1] </ref>. The definition of &lt; -composition is based on the following notion of renaming. Definition 2.2 (renaming) Let and , , be two sets of predicate symbols.
Reference: [2] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Contributions to the Semantics of Open Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 570-580, </pages> <year> 1992. </year>
Reference-contexts: fails both in the hierarchy HP and in the cor responding program HP / . 3 A semantics compositional wrt / The approach we follow towards a compositional semantics for the composition operator &lt; is based on an extension of the semantics for open logic programs defined in [3] and <ref> [2] </ref>. The extension had been motivated by the fact that the standard approach to the semantics of logic programming provides an elegant way of defining the meaning of programs but lacks an important compositionality property. <p> If we want a semantics expressed within program syntax, compositionality with respect to union of programs can be equivalently achieved by choosing sets of clauses as the semantic objects used to interpret our programs. This idea is at the basis of the open semantics proposed in [3] and <ref> [2] </ref> and similarly of the semantics de 364 fined in [12]. Roughly, the open semantics S (P ) of a program P , is given by the set of resultants [21] obtained from goals of the form p ( ~ X) in P .
Reference: [3] <editor> A. Bossi and M. Menegus. Una Semantica Com-posizionale per Programmi Logici Aperti. In P. Asirelli, editor, </editor> <booktitle> Proc. Sixth Italian Conference on Logic Programming, </booktitle> <pages> pages 95-109, </pages> <year> 1991. </year>
Reference-contexts: then G fails both in the hierarchy HP and in the cor responding program HP / . 3 A semantics compositional wrt / The approach we follow towards a compositional semantics for the composition operator &lt; is based on an extension of the semantics for open logic programs defined in <ref> [3] </ref> and [2]. The extension had been motivated by the fact that the standard approach to the semantics of logic programming provides an elegant way of defining the meaning of programs but lacks an important compositionality property. <p> If we want a semantics expressed within program syntax, compositionality with respect to union of programs can be equivalently achieved by choosing sets of clauses as the semantic objects used to interpret our programs. This idea is at the basis of the open semantics proposed in <ref> [3] </ref> and [2] and similarly of the semantics de 364 fined in [12]. Roughly, the open semantics S (P ) of a program P , is given by the set of resultants [21] obtained from goals of the form p ( ~ X) in P .
Reference: [4] <author> A. Brogi, E. Lamma, and P. Mello. </author> <title> Structuring Logic Programs: A Unifying Framework and its Declarative and Operational Semantics. </title> <type> Technical Report 4/1, </type> <institution> Progetto Finalizzato C.N.R. Sis-temi Informatici e Calcolo Parallelo, </institution> <year> 1990. </year>
Reference-contexts: Thus, there is no support for the implicit interaction between different components which is entailed by the composition mechanisms we have considered in this paper. An extensive study on the semantics of various forms of composition mechanisms for logic programming has also been developed in <ref> [4] </ref>. In that paper, inheritance systems are viewed as a special case of more general forms of composition mechanisms which are derived as extensions or variations of Contextual Logic Programming. The approach is rather different than the one presented in this paper, in at least two respects. <p> The approach is rather different than the one presented in this paper, in at least two respects. The first is our use of extended interpretations as opposed to the use of standard Herbrand interpretations in <ref> [4] </ref>. The second is that the definition of inheritance assumed in that paper is based only on the idea of extension rather than overriding between inherited definitions. This assumption is crucial for the framework presented in [4] to prove the existence of a fixpoint for the immediate consequence operator they define. <p> use of extended interpretations as opposed to the use of standard Herbrand interpretations in <ref> [4] </ref>. The second is that the definition of inheritance assumed in that paper is based only on the idea of extension rather than overriding between inherited definitions. This assumption is crucial for the framework presented in [4] to prove the existence of a fixpoint for the immediate consequence operator they define. The same assumption provides also the basis for the compositional approach developed by the same authors in a related and more recent paper [5].
Reference: [5] <author> A. Brogi, E. Lamma, and P. Mello. </author> <title> Objects in a Logic Programming Framework. </title> <booktitle> In Second Rus-sian Conference on Logic Programming, </booktitle> <year> 1991. </year>
Reference-contexts: Internal predicates are thus thought of as encapsulated within the components and hence their definition not is exported by the hierarchies. The evaluation rules are given below in Natural Deduction style extending those reported in <ref> [5] </ref>. <p> This assumption is crucial for the framework presented in [4] to prove the existence of a fixpoint for the immediate consequence operator they define. The same assumption provides also the basis for the compositional approach developed by the same authors in a related and more recent paper <ref> [5] </ref>. Monteiro and Porto's approach to the declarative semantics of Contextual Logic Programming, [24], is also related to our characterization of inheritance. One major difference is in the language.
Reference: [6] <author> M. Bugliesi. </author> <title> A Declarative View of Inheritance in Logic Programming. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. Joint Int'l Conf. and Symposium on Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: Then the compositional properties of our semantics ensure that the meaning of the resulting hierarchy can be determined from the meaning of the components. A compositional semantics of inheritance is also given in <ref> [6] </ref>, but different semantic objects (the least Herbrand model and the immediate-consequence operator respectively) are required to coexist there, in order to capture the meaning of static and dynamic inheritance.
Reference: [7] <author> W. Cook and J. Palsberg. </author> <title> A Denotational Semantics of Inheritance and its Correctness. </title> <booktitle> In Proceedings of OOPSLA'89, </booktitle> <pages> pages 433-443. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Inheritance. Our view of inheritance conforms with the one nowadays widely accepted in the Object-Oriented community. An intuitive justification for such interpretation is contained in <ref> [7] </ref>. Inheritance is viewed as a mechanism for differential programming, i.e. a mechanism for constructing new program components by specifying how they differ from the existing ones. Differential programming is achieved by using filters to modify the external behaviour of exist-ing components. <p> This is achieved through the interpretation illustrated in figure 2. - self self WhoAreYou cs-student student "aCsStudent" a mechanism for deriving modified versions of recursive structures. This characterization constitutes the main motivation to Cook's approach in <ref> [7] </ref>.
Reference: [8] <author> F. Denis and J.-P. Delahaye. </author> <title> Unfolding, Procedural and Fixpoint Semantics of Logic Programs. </title> <editor> In C. Choffrut and M. Jantzen, editors, </editor> <booktitle> STACS 91, volume 480 of Lecture Notes in Computer Science, </booktitle> <pages> pages 511-522. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: (a):-frg2q (x). 3.1 Unfolding semantics and equiva lence results The equivalence between the operational semantics of an isa hierarchy HP and the fixpoint semantics of the corresponding HP / can be proved in a concise and el egant way by introducing the intermediate notion of unfolding semantics U (P ) <ref> [18, 19, 8] </ref>. The unfolding semantics is obtained as the limit of the top-down unfolding process. Definition 3.11 Let P be a h; ; fii-program. <p> )) fl jvar (G) = # jvar (G) The proof of the above result can be carried out by using a straightforward inductive argoment, since U (P ) is based on a top-down definition which mimics a parallel SLD derivation (the proof is essentially the same of those given in <ref> [19, 8] </ref> for the case of standard programs).
Reference: [9] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A new Declarative Semantics for Logic Languages. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 993-1005. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: Obviously the minimal-model semantics is also non-compositional with respect to more complex operators like our inheritance mechanisms. The same argument applies to also other semantics, such as those reported in <ref> [9] </ref> and [10], which are defined on sets of (possibly non ground) atoms. As a matter of fact, in order for a semantics to be compositional, it is crucial that its definition embeds a mapping from sets of atoms to sets of atoms.
Reference: [10] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: Obviously the minimal-model semantics is also non-compositional with respect to more complex operators like our inheritance mechanisms. The same argument applies to also other semantics, such as those reported in [9] and <ref> [10] </ref>, which are defined on sets of (possibly non ground) atoms. As a matter of fact, in order for a semantics to be compositional, it is crucial that its definition embeds a mapping from sets of atoms to sets of atoms.
Reference: [11] <author> M. Gabbrielli and G. Levi. </author> <title> On the Semantics of Logic Programs. </title> <editor> In J. Leach Albert, B. Monien, and M. Rodriguez-Artalejo, editors, </editor> <booktitle> Automata, Languages and Programming, 18th International Colloquium, volume 510 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-19. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year> <month> 369 </month>
Reference-contexts: The approach is based on the notion of differential programs, logic programs annotated in order to make their external interfaces explicit. The semantic characterization is defined following the general approach described in <ref> [11] </ref>. In that paper, the idea is to accommodate in the programs' interpretations more syntactic objects in order to achieve an accurate declarative characterization of the programs' operational behaviour.
Reference: [12] <author> H. Gaifman and E. Shapiro. </author> <title> Fully Abstract Com--positional Semantics for Logic Programs. </title> <booktitle> In Proc. of ACM Conf. on Principle of Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: This idea is at the basis of the open semantics proposed in [3] and [2] and similarly of the semantics de 364 fined in <ref> [12] </ref>. Roughly, the open semantics S (P ) of a program P , is given by the set of resultants [21] obtained from goals of the form p ( ~ X) in P .
Reference: [13] <author> L. Giordano and A. Martelli. </author> <title> A Modal Reconstruction of Blocks and Modules in Logic Programming. </title> <editor> In V. Saraswat and K. Ueda, editors, </editor> <booktitle> Proc. 1991 Int'l Symposium on Logic Programming, </booktitle> <pages> pages 239-253, </pages> <year> 1991. </year>
Reference-contexts: Implication goals as structuring tools are also used in [14] following a more static approach. Indeed, the language defined in [14] has static scope rules for clause definitions. A semantics based on modal logic for such a language is proprosed in <ref> [13] </ref>. A modular extension to logic programming was also proposed in [28], based on the theory of modularity developed by the Standard ML module system.
Reference: [14] <author> L. Giordano, A. Martelli, and F. Rossi. </author> <title> Local definitions with static scope rules in Logic Languages. </title> <booktitle> In Proc. of the FGCS Int. Conf., </booktitle> <year> 1988. </year>
Reference-contexts: Implication goals as structuring tools are also used in <ref> [14] </ref> following a more static approach. Indeed, the language defined in [14] has static scope rules for clause definitions. A semantics based on modal logic for such a language is proprosed in [13]. <p> Implication goals as structuring tools are also used in <ref> [14] </ref> following a more static approach. Indeed, the language defined in [14] has static scope rules for clause definitions. A semantics based on modal logic for such a language is proprosed in [13]. A modular extension to logic programming was also proposed in [28], based on the theory of modularity developed by the Standard ML module system.
Reference: [15] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: This characterization constitutes the main motivation to Cook's approach in [7]. In an independent study [27], Reddy adopts a similar approach and develops an incremental study of different forms of inheritance where the interpretation given by figure 2 is classified as dynamic inheritance ala Smalltalk <ref> [15] </ref> as opposed to the static mechanism exhibited by languages like Simula-67 and depicted in figure 1. The approach we take in this paper follows Reddy's classification. Compositionality.
Reference: [16] <author> R. Kowalsky. </author> <title> Logic for Problem S. </title> <publisher> Elsevier North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: 1 Introduction The power of Horn clause logic as a programming language was pointed out for the first time in <ref> [16] </ref> and since then it has gained the interest of a still growing research community. The most appealing features of logic programming as a programming language are to be found both in the elegance of its semantic characterization and in the declarativity of its computational model.
Reference: [17] <author> J.-L. Lassez and M. J. Maher. </author> <title> Closures and Fairness in the Semantics of Programming Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 29 </volume> <pages> 167-184, </pages> <year> 1984. </year>
Reference-contexts: As a matter of fact, in order for a semantics to be compositional, it is crucial that its definition embeds a mapping from sets of atoms to sets of atoms. This is the case for the semantics based on the closure operator of <ref> [17] </ref> and on the T P operator ([22]). If we want a semantics expressed within program syntax, compositionality with respect to union of programs can be equivalently achieved by choosing sets of clauses as the semantic objects used to interpret our programs.
Reference: [18] <author> G. Levi. </author> <title> Models, Unfolding Rules and Fixpoint Semantics. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1649-1665. </pages> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1988. </year>
Reference-contexts: (a):-frg2q (x). 3.1 Unfolding semantics and equiva lence results The equivalence between the operational semantics of an isa hierarchy HP and the fixpoint semantics of the corresponding HP / can be proved in a concise and el egant way by introducing the intermediate notion of unfolding semantics U (P ) <ref> [18, 19, 8] </ref>. The unfolding semantics is obtained as the limit of the top-down unfolding process. Definition 3.11 Let P be a h; ; fii-program.
Reference: [19] <author> G. Levi and P. Mancarella. </author> <title> The Unfolding Semantics of Logic Programs. </title> <type> Technical Report TR-13/88, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1988. </year>
Reference-contexts: (a):-frg2q (x). 3.1 Unfolding semantics and equiva lence results The equivalence between the operational semantics of an isa hierarchy HP and the fixpoint semantics of the corresponding HP / can be proved in a concise and el egant way by introducing the intermediate notion of unfolding semantics U (P ) <ref> [18, 19, 8] </ref>. The unfolding semantics is obtained as the limit of the top-down unfolding process. Definition 3.11 Let P be a h; ; fii-program. <p> )) fl jvar (G) = # jvar (G) The proof of the above result can be carried out by using a straightforward inductive argoment, since U (P ) is based on a top-down definition which mimics a parallel SLD derivation (the proof is essentially the same of those given in <ref> [19, 8] </ref> for the case of standard programs).
Reference: [20] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: We also denote with ~ B a conjunction of atoms, with ~ X tuple of variables and and with # jV the restriction of the substitution # to the set of variables V . Finally, we assume the reader familiar with the standard notions of logic programming reported in <ref> [20] </ref> and [1]. The definition of &lt; -composition is based on the following notion of renaming. Definition 2.2 (renaming) Let and , , be two sets of predicate symbols.
Reference: [21] <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial Evaluation in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 217-242, </pages> <year> 1991. </year>
Reference-contexts: This idea is at the basis of the open semantics proposed in [3] and [2] and similarly of the semantics de 364 fined in [12]. Roughly, the open semantics S (P ) of a program P , is given by the set of resultants <ref> [21] </ref> obtained from goals of the form p ( ~ X) in P .
Reference: [22] <author> P. Mancarella and D. Pedreschi. </author> <title> An Algebra of Logic Programs. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1006-1023. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference: [23] <author> D. Miller. </author> <title> A Logical Analysis of Modules in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 6(2) </volume> <pages> 79-108, </pages> <year> 1989. </year>
Reference-contexts: Then [[HP 1 / ]] ) 4 Related Work The use of the deduction theorem to provide a logical foundation to the theory of modular logic programming was the main motivation behind Miller's seminal paper on this subject <ref> [23] </ref>. His idea was to extend the expressive power of positive horn clauses by allowing implications to occur in the bodies of clauses and by interpreting them as follows.
Reference: [24] <author> L. Monteiro and A. Porto. </author> <title> Contextual logic programming. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Proc. Sixth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 284-302. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: The same assumption provides also the basis for the compositional approach developed by the same authors in a related and more recent paper [5]. Monteiro and Porto's approach to the declarative semantics of Contextual Logic Programming, <ref> [24] </ref>, is also related to our characterization of inheritance. One major difference is in the language. In fact, Contextual Logic Programming (CxLP) has essentially the same semantic connotation as static inheritance, with 368 the difference that CxLP's mechanism for unit com-position is inherently dynamic.
Reference: [25] <author> L. Monteiro and A. Porto. </author> <title> A Transformational View of Inheritance in Logic Programming. </title> <booktitle> In Proc. 7th Int. Conf. on Logic Programming, </booktitle> <year> 1990. </year>
Reference-contexts: In effect, CxLP's context extension, by providing a mechanism for dynamically specifying (and modifying) a unit's hierarchical links with its ancestors, captures a more general notion which is known as delegation [30]. In a related paper <ref> [25] </ref> they take a more direct approach to the study of inheritance systems. The notion of inheritance they consider in (the bulk of) that paper is essentially the same we have assumed here. The semantic problem is instead approached from a completely different perspective. Their view is strictly transformational.
Reference: [26] <author> L. Monteiro and A. Porto. </author> <title> Syntactic and Semantic Inheritance in Logic Programming. </title> <editor> In J. Dar-lington and R. Dietrich, editors, </editor> <booktitle> Proc. PHOENIX Seminar and Workshop on Declarative Programming, </booktitle> <year> 1991. </year>
Reference-contexts: A declarative interpretation is then derived indirectly on the account of the well-known equivalence between the operational and declarative semantics in logic programming. A refined result is described in <ref> [26] </ref> where they introduce a direct declarative characterization for a composite language which combines the static and dynamic interpretations of inheritance as well as the overriding and extension modes between inherited definition we have considered in this paper. <p> There is a fundamental difference from the approach we have presented here: the semantic construction of <ref> [26] </ref> applies to complete hierarchies and it is given under the assumption that the components of the hierarchy are known in advance. As such, the issue of compositionality is not even taken into account.
Reference: [27] <author> U. Reddy. </author> <title> Objects as Closures: Abstarct Semantics of Object Oriented Languages. </title> <booktitle> In Proc. of the Int. Conf. on Lisp and Functional Programming, </booktitle> <pages> pages 289-297. </pages> <publisher> ACM, </publisher> <year> 1988. </year>
Reference-contexts: This is achieved through the interpretation illustrated in figure 2. - self self WhoAreYou cs-student student "aCsStudent" a mechanism for deriving modified versions of recursive structures. This characterization constitutes the main motivation to Cook's approach in [7]. In an independent study <ref> [27] </ref>, Reddy adopts a similar approach and develops an incremental study of different forms of inheritance where the interpretation given by figure 2 is classified as dynamic inheritance ala Smalltalk [15] as opposed to the static mechanism exhibited by languages like Simula-67 and depicted in figure 1.
Reference: [28] <author> D. T. Sannella and L. A. Wallen. </author> <title> A Calculus for the Construction of Modular Polog Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 6(12) </volume> <pages> 144-177, </pages> <year> 1992. </year>
Reference-contexts: Indeed, the language defined in [14] has static scope rules for clause definitions. A semantics based on modal logic for such a language is proprosed in [13]. A modular extension to logic programming was also proposed in <ref> [28] </ref>, based on the theory of modularity developed by the Standard ML module system. Abstraction and the ability to define structured components are also at the basis of that approach but cross-references between predicate definitions in different modules are achieved only through the explicit use of qualified names.
Reference: [29] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference: [30] <author> P. Wegner. </author> <title> Dimensions of Object-Based Language Design. </title> <booktitle> In Proc. of the OOPSLA '87, </booktitle> <year> 1987. </year>
Reference-contexts: In effect, CxLP's context extension, by providing a mechanism for dynamically specifying (and modifying) a unit's hierarchical links with its ancestors, captures a more general notion which is known as delegation <ref> [30] </ref>. In a related paper [25] they take a more direct approach to the study of inheritance systems. The notion of inheritance they consider in (the bulk of) that paper is essentially the same we have assumed here. The semantic problem is instead approached from a completely different perspective.
Reference: [31] <author> C. Zaniolo. </author> <title> Deductive Databases Theory meets Practice. </title> <booktitle> In Proc. 2nd Int. Conf. on Extended Database Technology, </booktitle> <year> 1990. </year> <month> 370 </month>
Reference-contexts: The most appealing features of logic programming as a programming language are to be found both in the elegance of its semantic characterization and in the declarativity of its computational model. As best summarized by Zaniolo in <ref> [31] </ref>, the rule based reasoning of logic, combined with adequate tools for efficiently storing and retrieving large amounts of information could provide a realistic basis for the development of efficient knowledge base systems.
References-found: 31

