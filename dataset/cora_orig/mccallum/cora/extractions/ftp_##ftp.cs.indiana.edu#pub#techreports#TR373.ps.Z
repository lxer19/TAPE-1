URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR373.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Author: Zheng Zhu and Steven D. Johnson 
Keyword: Automatic Synthesis of Sequential  
Date: february 1993  
Affiliation: indiana university  Synchronizations  
Abstract: computer science department technical report no. 373 To appear in the procedings of the 1993 IFIP Conference on Hardware Description Languages and their Applications (CHDL '93 ), Ottawa, Canada, April, 1993. Also published as University of British Columbia Computer Science Department Technical Report TR 93-3. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Borriello, G. </author> <title> Specification and synthesis of interface logic. In High-Level VLSI Synthesis, </title> <editor> R. Camposano and W. Wolf, Eds. </editor> <publisher> Kluwer Acdemic Publishers, </publisher> <year> 1991, </year> <journal> ch. </journal> <volume> 7, </volume> <pages> pp. 153-176. </pages>
Reference-contexts: Those include CIRCAL [6] by Milne, HOP [2] by Gopalakrishnan and that reported in [9] by Subrah-manyam. In recent years, more and more researchers have focused on hardware timing related issues and have achieved substantial progress. Borriello <ref> [1] </ref> proposed a method of specifying and automatically synthesizing hardware interfaces. Milne [5] investigated the issues related to hardware timing description and verification. Wolf and Takach [11, 10] used finite state machines to specify hardware and used control transformations to explore design spaces. <p> Wolf and Takach [11, 10] used finite state machines to specify hardware and used control transformations to explore design spaces. Majority of the work in this area focus on verification aspects of sequential system designs. There are only limited works (e.g. <ref> [1] </ref>) which addressed formal and practical aspects in derivation of sequential systems. The work reported in this paper aims at providing a language for sequential behaviors and an automatic generation of synchronizations when sequential compositions are performed.
Reference: [2] <author> Gopalakrishnan, G. C., Fujimoto, F. M., Akella, V., and Mani, N. S. HOP: </author> <title> A process model for synchronous hardware; semantics and experiments in process composition. Integration, </title> <booktitle> the VLSI journal 8 (1989), </booktitle> <pages> 209-247. </pages>
Reference-contexts: In [7], Milner extended CCS to model synchrony. Hardware design oriented formalisms, often based on formalisms such CSP and CCS, have been developed in the last decade to address hardware design related issues. Those include CIRCAL [6] by Milne, HOP <ref> [2] </ref> by Gopalakrishnan and that reported in [9] by Subrah-manyam. In recent years, more and more researchers have focused on hardware timing related issues and have achieved substantial progress. Borriello [1] proposed a method of specifying and automatically synthesizing hardware interfaces.
Reference: [3] <author> Hoare, C. A. R. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: We also briefly describe an algorithm which converts a specification of synchronization to a description in our language. Various languages for describing, verifying and synthesizing sequential behaviors of hardwares have been proposed. Well known formalisms for concurrent systems include CSP <ref> [3] </ref> by Hoare and CCS [8] by Milner. In [7], Milner extended CCS to model synchrony. Hardware design oriented formalisms, often based on formalisms such CSP and CCS, have been developed in the last decade to address hardware design related issues.
Reference: [4] <author> Manna, Z. </author> <title> Mathematical Theory of Computation. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1974. </year>
Reference: [5] <author> Milne, G. </author> <title> Timing constraints, formalizing their description and verification. </title> <booktitle> In Proceedings of the IFIP WG 10.2 9th International Symposium on Computer Hardware Description Languages and Their Applications (1989), </booktitle> <editor> J. Darringer and F. Ramming, Eds., </editor> <publisher> North Holland. </publisher>
Reference-contexts: Those include CIRCAL [6] by Milne, HOP [2] by Gopalakrishnan and that reported in [9] by Subrah-manyam. In recent years, more and more researchers have focused on hardware timing related issues and have achieved substantial progress. Borriello [1] proposed a method of specifying and automatically synthesizing hardware interfaces. Milne <ref> [5] </ref> investigated the issues related to hardware timing description and verification. Wolf and Takach [11, 10] used finite state machines to specify hardware and used control transformations to explore design spaces. Majority of the work in this area focus on verification aspects of sequential system designs.
Reference: [6] <author> Milne, G. J. </author> <title> CIRCAL and the representation of communication concurrency and time. </title> <journal> ACM Transactions on Programming Languages and Systems 7, </journal> <month> 2 </month> <year> (1985). </year>
Reference-contexts: In [7], Milner extended CCS to model synchrony. Hardware design oriented formalisms, often based on formalisms such CSP and CCS, have been developed in the last decade to address hardware design related issues. Those include CIRCAL <ref> [6] </ref> by Milne, HOP [2] by Gopalakrishnan and that reported in [9] by Subrah-manyam. In recent years, more and more researchers have focused on hardware timing related issues and have achieved substantial progress. Borriello [1] proposed a method of specifying and automatically synthesizing hardware interfaces.
Reference: [7] <author> Milner, R. </author> <title> Calculi for synchrony and asynchrony. </title> <booktitle> Theoretical Computer Science 25 (1983), </booktitle> <pages> 267-310. </pages>
Reference-contexts: We also briefly describe an algorithm which converts a specification of synchronization to a description in our language. Various languages for describing, verifying and synthesizing sequential behaviors of hardwares have been proposed. Well known formalisms for concurrent systems include CSP [3] by Hoare and CCS [8] by Milner. In <ref> [7] </ref>, Milner extended CCS to model synchrony. Hardware design oriented formalisms, often based on formalisms such CSP and CCS, have been developed in the last decade to address hardware design related issues. Those include CIRCAL [6] by Milne, HOP [2] by Gopalakrishnan and that reported in [9] by Subrah-manyam.
Reference: [8] <author> Milner, R. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: We also briefly describe an algorithm which converts a specification of synchronization to a description in our language. Various languages for describing, verifying and synthesizing sequential behaviors of hardwares have been proposed. Well known formalisms for concurrent systems include CSP [3] by Hoare and CCS <ref> [8] </ref> by Milner. In [7], Milner extended CCS to model synchrony. Hardware design oriented formalisms, often based on formalisms such CSP and CCS, have been developed in the last decade to address hardware design related issues.
Reference: [9] <author> Subrahmanyam, P. A. </author> <title> What's in a timing discipline?: Considerations in the specification and synthesis of systems with interacting asynchronous and synchronous components. </title> <booktitle> In Lecture Notes in Computer Science (1989), </booktitle> <editor> M. Leeser and G. Brown, Eds., </editor> <publisher> Cornell University, Springer-Verlag. </publisher>
Reference-contexts: In [7], Milner extended CCS to model synchrony. Hardware design oriented formalisms, often based on formalisms such CSP and CCS, have been developed in the last decade to address hardware design related issues. Those include CIRCAL [6] by Milne, HOP [2] by Gopalakrishnan and that reported in <ref> [9] </ref> by Subrah-manyam. In recent years, more and more researchers have focused on hardware timing related issues and have achieved substantial progress. Borriello [1] proposed a method of specifying and automatically synthesizing hardware interfaces. Milne [5] investigated the issues related to hardware timing description and verification.
Reference: [10] <author> Takach, A., and Wolf, W. </author> <title> Behavior FSMs for high-level synthesis and verification. </title> <type> Tech. Rep. </type> <institution> CE-W91-13, Dept of EE, Priceton University, </institution> <year> 1991. </year>
Reference-contexts: In recent years, more and more researchers have focused on hardware timing related issues and have achieved substantial progress. Borriello [1] proposed a method of specifying and automatically synthesizing hardware interfaces. Milne [5] investigated the issues related to hardware timing description and verification. Wolf and Takach <ref> [11, 10] </ref> used finite state machines to specify hardware and used control transformations to explore design spaces. Majority of the work in this area focus on verification aspects of sequential system designs. There are only limited works (e.g. [1]) which addressed formal and practical aspects in derivation of sequential systems.
Reference: [11] <author> Wolf, W., and Takach, A. </author> <title> Architectural optimization methods for control--dominated machines. In High-Level VLSI Synthesis, </title> <editor> R. Camposano and W. Wolf, Eds. </editor> <publisher> Kluwer Acdemic Publishers, </publisher> <year> 1991, </year> <pages> pp. 231-254. </pages>
Reference-contexts: In recent years, more and more researchers have focused on hardware timing related issues and have achieved substantial progress. Borriello [1] proposed a method of specifying and automatically synthesizing hardware interfaces. Milne [5] investigated the issues related to hardware timing description and verification. Wolf and Takach <ref> [11, 10] </ref> used finite state machines to specify hardware and used control transformations to explore design spaces. Majority of the work in this area focus on verification aspects of sequential system designs. There are only limited works (e.g. [1]) which addressed formal and practical aspects in derivation of sequential systems.
Reference: [12] <author> Zhu, Z. </author> <title> Structured Hardware Design Transformations. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Indiana University, USA, </institution> <year> 1992. </year>
Reference-contexts: In this section, we briefly present its syntax and the semantics of the language. Instead of presenting every detail of the language, we shall convey concepts through examples. More detailed and formal description of the language can be found in <ref> [12] </ref>. 2.1 Timing Expressions and Timing Functions Let T a set of terms 1 , and #, ? be two special symbols. <p> Self-reference is analogous to the race condition in circuit designs, or interlock in theories of concurrent systems. An algorithm for detecting self-references is described in <ref> [12] </ref>. A timing function that does not have self-reference during its evaluation in every given environment is called self-reference free. Throughout this paper, we assume that every timing function is self-reference free. The next definition simulates state transitions of an automaton. Definition 2.4. <p> Define tt (e) =t (e)(p). The (infinite) semantics of timing functions is an extension of the finite interpretation. We only give an informal description here. A detailed account can be found in <ref> [12] </ref>. The (infinite) semantics of a timing function is a function which, given an environment and a set of input sequences, returns sequences of data outputs. <p> (7) is equivalent to the following timing relation: 8 &gt; &gt; &gt; : (p 2 ; [p 1 = 0 ! 0]) (p 4 ; [p 2 = 0 ! #] 1) &gt; &gt; &gt; = (8) Furthermore, we can prove that the relation (8) is equivalent to the following <ref> [12] </ref>: 8 &gt; : (p 3 ; [p 1 = 0 ! #] 1) 9 &gt; ; It is obvious that this timing relation does not contain any self-reference. Another possibility is that the self-reference is a result of contradiction in original inequalities or an over-constraint during solving inequalities. <p> into a single one: (p; [s r = 0 ! 0] 0 [r = 0 ! 0] 1) It can be proven that (10) is equivalent to the function ( (r; [s r = 0 ! #] # [s m = 0 ! 0] [d = 0 ! 0]) In <ref> [12] </ref>, we proved the following fact of the algorithm: given a system of inequalities I, the algorithm terminates on I and returns three possible values: 1. f;g. ; is an empty function which is regarded as an "unconstrained" timing function. This means that every inequality in I holds on itself.
References-found: 12

