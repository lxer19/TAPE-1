URL: http://www.cs.man.ac.uk/~kung-kiu/pub/lopstr96.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: kung-kiu@cs.man.ac.uk  ornaghi@dsi.unimi.it  
Phone: 2  
Title: Forms of Logic Specifications: A Preliminary Study  
Author: Kung-Kiu Lau and Mario Ornaghi 
Address: Manchester, Manchester M13 9PL, United Kingdom  Milano, Via Comelico 39/41, Milano, Italy  
Affiliation: 1 Department of Computer Science University of  Dipartimento di Scienze dell'Informazione Universita' degli studi di  
Abstract: There is no universal agreement on exactly what form a specification should take, what part it should play in synthesis, and what its precise relationship with the specified program should be. In logic programming, the role of specification is all the more unclear since logic programs are often used as executable specifications. In this paper we take the view that specifications should be set in the context of the problem domain, which we call a framework . We conduct a preliminary study of two useful forms of logic specifications: if-and-only-if and partial specifications. First we set up a three-tier formalism for synthesis, the top-tier being a framework. Then within this formalism we define these two forms of specifications, and discuss their roles in synthesis. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J.L. Bates and R.L. Constable. </author> <title> Proofs as programs. </title> <journal> ACM TOPLAS 7(1) </journal> <pages> 113-136, </pages> <year> 1985. </year>
Reference-contexts: In general, constructive synthesis follows the `proofs as programs' approach (e.g. <ref> [1, 20] </ref>). 11 A specification consists of an input-output theorem of the form 8x9y . r (x; y) (18) From a proof of this theorem, a program to compute r can be extracted.
Reference: 2. <author> A. Bundy, A. Smaill and G. Wiggins. </author> <title> The synthesis of logic programs from inductive proofs. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proc. Esprit Symposium on Computational Logic, </booktitle> <pages> pages 135-149, </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: In logic programming, the connection between deductive and constructive synthesis is particularly close. For example, in the constructive synthesis method of <ref> [2] </ref>, the input-output relation r (x; y) in (18) is itself an iff specification. In [15, 7], program extraction is performed by proving goals of the form 8x9y . q (x; y) r (x) (19) using an extended Prolog execution mechanism.
Reference: 3. <author> C.C. Chang and H.J. Keisler. </author> <title> Model Theory. </title> <publisher> North-Holland, </publisher> <year> 1973. </year>
Reference: 4. <author> K.L. Clark. </author> <title> Predicate Logic as a Computational Formalism. </title> <type> Tech. Rep. 79/59, </type> <institution> Imperial College, </institution> <year> 1979. </year>
Reference-contexts: For example, in [9, 5, 12], frameworks are not used, and iff specifications are used in a proof-theoretic way to derive logic programs, and/or to prove them correct. Nevertheless, there are similarities between our specifications and some of their verification conditions. For example, Clark <ref> [4, Section 4] </ref> (see also [13, p.158]) uses the following correctness sentence: 8x; y .
Reference: 5. <author> K.L. Clark. </author> <title> The Synthesis and Verification of Logic Programs. </title> <type> Tech. Rep. 81/36, </type> <institution> Imperial College, </institution> <year> 1981. </year>
Reference-contexts: Iff specifications are the most widely used form of specifications in logic program synthesis, e.g. <ref> [9, 5, 12, 17, 18] </ref>. In these papers, 8 various techniques are described for systematically deriving standard logic programs ([9, 5, 12, 8 More details of these, and related papers, can be found in [6]. 17]) or constraint logic programs ([18]). <p> In these papers, 8 various techniques are described for systematically deriving standard logic programs ([9, 5, 12, 8 More details of these, and related papers, can be found in [6]. 17]) or constraint logic programs ([18]). However, it should be noted that in e.g. <ref> [9, 5, 12] </ref>, there is no (explicit) use of frameworks, or of model-theoretic semantics of iff specifications as described here, but they do make use of recursive iff specifications. Iff specifications provide a starting point for program synthesis. <p> Our use of frameworks distinguishes our approach to specifications from related work in deductive synthesis. Moreover, we use a model-theoretic approach whereas others predominantly adopt a proof-theoretic approach. For example, in <ref> [9, 5, 12] </ref>, frameworks are not used, and iff specifications are used in a proof-theoretic way to derive logic programs, and/or to prove them correct. Nevertheless, there are similarities between our specifications and some of their verification conditions.
Reference: 6. <author> Y. Deville and K.K. Lau. </author> <title> Logic program synthesis. </title> <journal> J. Logic Programming 19,20:321-350, </journal> <note> 1994. Special issue: Ten years of logic programming. </note>
Reference-contexts: Iff specifications are the most widely used form of specifications in logic program synthesis, e.g. [9, 5, 12, 17, 18]. In these papers, 8 various techniques are described for systematically deriving standard logic programs ([9, 5, 12, 8 More details of these, and related papers, can be found in <ref> [6] </ref>. 17]) or constraint logic programs ([18]). However, it should be noted that in e.g. [9, 5, 12], there is no (explicit) use of frameworks, or of model-theoretic semantics of iff specifications as described here, but they do make use of recursive iff specifications. <p> The model-theoretic semantics discussed here is used in [19] to define the model-theoretic relationship between frameworks, specifications and programs, in a three-tier formalism for logic program synthesis. The kinds of specifications presented here are intended for deductive synthesis, and not for constructive synthesis (see <ref> [6] </ref> for a survey of different approaches to logic program synthesis). Our use of frameworks distinguishes our approach to specifications from related work in deductive synthesis. Moreover, we use a model-theoretic approach whereas others predominantly adopt a proof-theoretic approach.
Reference: 7. <author> L. </author> <title> Fribourg. Extracting logic programs from proofs that use extended Prolog execution and induction. </title> <editor> In D.H.D. Warren and P. Szeredi, editors, </editor> <booktitle> Proc. 7 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 685-699, </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In logic programming, the connection between deductive and constructive synthesis is particularly close. For example, in the constructive synthesis method of [2], the input-output relation r (x; y) in (18) is itself an iff specification. In <ref> [15, 7] </ref>, program extraction is performed by proving goals of the form 8x9y . q (x; y) r (x) (19) using an extended Prolog execution mechanism. Here, r (x) can be regarded as an input, and q (x; y) as an output.
Reference: 8. <author> J. Goguen and J. Meseguer. </author> <title> Unifying functional, object-oriented and relational programming with logical semantics. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference: 9. <author> A. Hansson and S.- A. </author> <title> Tarnlund. A natural programming calculus. </title> <booktitle> In Proc. </booktitle> <pages> IJCAI 79 , pages 348-355, </pages> <year> 1979. </year>
Reference-contexts: Iff specifications are the most widely used form of specifications in logic program synthesis, e.g. <ref> [9, 5, 12, 17, 18] </ref>. In these papers, 8 various techniques are described for systematically deriving standard logic programs ([9, 5, 12, 8 More details of these, and related papers, can be found in [6]. 17]) or constraint logic programs ([18]). <p> In these papers, 8 various techniques are described for systematically deriving standard logic programs ([9, 5, 12, 8 More details of these, and related papers, can be found in [6]. 17]) or constraint logic programs ([18]). However, it should be noted that in e.g. <ref> [9, 5, 12] </ref>, there is no (explicit) use of frameworks, or of model-theoretic semantics of iff specifications as described here, but they do make use of recursive iff specifications. Iff specifications provide a starting point for program synthesis. <p> Our use of frameworks distinguishes our approach to specifications from related work in deductive synthesis. Moreover, we use a model-theoretic approach whereas others predominantly adopt a proof-theoretic approach. For example, in <ref> [9, 5, 12] </ref>, frameworks are not used, and iff specifications are used in a proof-theoretic way to derive logic programs, and/or to prove them correct. Nevertheless, there are similarities between our specifications and some of their verification conditions.
Reference: 10. <author> P.M. Hill and J.W. Lloyd. </author> <title> The Godel Programming Language. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The existence of an isoinitial model is not always guaranteed though. Indeed, we distinguish between two kinds of frameworks: 3 That is a model where each element (of the domain) can be represented by a ground term. 4 Or in typed logic programming languages such as Godel <ref> [10] </ref>. Closed Frameworks. A closed framework F is a theory that has an isoinitial model. This means that the axioms completely characterise the intended meaning (namely the interpretation in the isoinitial model) of the sort, function and relation symbols of the signature.
Reference: 11. <author> W. Hodges. </author> <title> Logical features of Horn clauses. In D.M. </title> <editor> Gabbay, C.J. Hogger, and J.A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <volume> Vol 1, </volume> <pages> pages 449-503, </pages> <publisher> Oxford University Press, </publisher> <year> 1993. </year>
Reference: 12. <author> C.J. </author> <title> Hogger. Derivation of logic programs. </title> <editor> J. </editor> <booktitle> ACM , 28(2) </booktitle> <pages> 372-392, </pages> <month> April </month> <year> 1981. </year>
Reference-contexts: Iff specifications are the most widely used form of specifications in logic program synthesis, e.g. <ref> [9, 5, 12, 17, 18] </ref>. In these papers, 8 various techniques are described for systematically deriving standard logic programs ([9, 5, 12, 8 More details of these, and related papers, can be found in [6]. 17]) or constraint logic programs ([18]). <p> In these papers, 8 various techniques are described for systematically deriving standard logic programs ([9, 5, 12, 8 More details of these, and related papers, can be found in [6]. 17]) or constraint logic programs ([18]). However, it should be noted that in e.g. <ref> [9, 5, 12] </ref>, there is no (explicit) use of frameworks, or of model-theoretic semantics of iff specifications as described here, but they do make use of recursive iff specifications. Iff specifications provide a starting point for program synthesis. <p> Our use of frameworks distinguishes our approach to specifications from related work in deductive synthesis. Moreover, we use a model-theoretic approach whereas others predominantly adopt a proof-theoretic approach. For example, in <ref> [9, 5, 12] </ref>, frameworks are not used, and iff specifications are used in a proof-theoretic way to derive logic programs, and/or to prove them correct. Nevertheless, there are similarities between our specifications and some of their verification conditions.
Reference: 13. <author> C.J. </author> <title> Hogger. Introduction to Logic Programming. </title> <publisher> Academic Press, </publisher> <year> 1984. </year>
Reference-contexts: For example, in [9, 5, 12], frameworks are not used, and iff specifications are used in a proof-theoretic way to derive logic programs, and/or to prove them correct. Nevertheless, there are similarities between our specifications and some of their verification conditions. For example, Clark [4, Section 4] (see also <ref> [13, p.158] </ref>) uses the following correctness sentence: 8x; y .
Reference: 14. <author> C.B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Prentice Hall, </publisher> <address> 2nd edition, </address> <year> 1990. </year>
Reference-contexts: Roughly speaking, the relation r (x; y) is defined if and when IC (x) holds, and in this case r (x; y) is defined to be R (x; y) and OC (y) will also hold. If we follow the pre-post-condition style of program specification (e.g. <ref> [14, 23] </ref>), then a conditional specification defines a program P to compute r (x; y) in such a way that whenever IC (x) is satisfied, P satisfies OC (y) ^ R (x; y). <p> Conditional specifications are widely used in so-called formal methods, e.g. VDM <ref> [14] </ref> and Z [23], in the form of pre- and post-conditions for specifying the effects of operations on the current computational state. However, these methods use such specifications in a purely proof-theoretic way.
Reference: 15. <author> T. Kanamori and H. Seki. </author> <title> Verification of Prolog programs using an extension of execution. </title> <editor> In E. Shapiro, editor, </editor> <booktitle> Proc. 3 rd Int. Conf. on Logic Programming, Lecture Notes in Computer Science 225, </booktitle> <pages> pages 475-489, </pages> <year> 1986. </year>
Reference-contexts: In logic programming, the connection between deductive and constructive synthesis is particularly close. For example, in the constructive synthesis method of [2], the input-output relation r (x; y) in (18) is itself an iff specification. In <ref> [15, 7] </ref>, program extraction is performed by proving goals of the form 8x9y . q (x; y) r (x) (19) using an extended Prolog execution mechanism. Here, r (x) can be regarded as an input, and q (x; y) as an output.
Reference: 16. <author> K.K. Lau and M. Ornaghi. </author> <title> On specification frameworks and deductive synthesis of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. LOPSTR 94 and META 94 , Lecture Notes in Computer Science 883, </booktitle> <pages> pages 104-121, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: A useful criterion for adequacy is the existence of a program P for computing the specified relation, such that P existentially terminates and the completion of P can be proved in the framework F , enriched by the iff specifications of the predicates in P (see <ref> [16] </ref>). In other words, program synthesis can actually be used to expand F with adequate iff specifications. Expansions of frameworks by new function symbols are equally important: Definition 3.
Reference: 17. <author> K.K. Lau, M. Ornaghi and S.- A. </author> <title> Tarnlund. The halting problem for deductive synthesis of logic programs. </title> <editor> In P. van Hentenryck, editor, </editor> <booktitle> Proc. 11 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 665-683, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Indeed logic programs are often used as executable specifications, for instance in rapid prototyping. In our work in deductive synthesis of logic programs (see e.g. <ref> [17, 18] </ref>), we maintain a strict distinction between specifications and programs. We take the view that program synthesis should take place in a three-tier formalism (with model-theoretic semantics). At the bottom level, we have programs, for computing (specified) relations. <p> Iff specifications are the most widely used form of specifications in logic program synthesis, e.g. <ref> [9, 5, 12, 17, 18] </ref>. In these papers, 8 various techniques are described for systematically deriving standard logic programs ([9, 5, 12, 8 More details of these, and related papers, can be found in [6]. 17]) or constraint logic programs ([18]).
Reference: 18. <author> K.K. Lau and M. Ornaghi. </author> <title> A formal approach to deductive synthesis of constraint logic programs. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proc. 1995 Int. Logic Programming Symp., </booktitle> <pages> pages 543-557, </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Indeed logic programs are often used as executable specifications, for instance in rapid prototyping. In our work in deductive synthesis of logic programs (see e.g. <ref> [17, 18] </ref>), we maintain a strict distinction between specifications and programs. We take the view that program synthesis should take place in a three-tier formalism (with model-theoretic semantics). At the bottom level, we have programs, for computing (specified) relations. <p> Iff specifications are the most widely used form of specifications in logic program synthesis, e.g. <ref> [9, 5, 12, 17, 18] </ref>. In these papers, 8 various techniques are described for systematically deriving standard logic programs ([9, 5, 12, 8 More details of these, and related papers, can be found in [6]. 17]) or constraint logic programs ([18]).
Reference: 19. <author> K.K. Lau and M. Ornaghi. </author> <title> The relationship between logic programs and specifications | the subset example revisited. </title> <note> To appear in J. Logic Programming. </note>
Reference-contexts: Open frameworks are very useful in that they allow us to introduce parameters, and to deal with incomplete information that can be supplied via parameters (see <ref> [19] </ref>). For simplicity, in this paper we will consider only specifications within closed frameworks. Such frameworks can be constructed incrementally, starting from a simple framework with an obvious isoinitial model, e.g. the term model generated by the constructor symbols (see e.g. [19]). Example 2. <p> incomplete information that can be supplied via parameters (see <ref> [19] </ref>). For simplicity, in this paper we will consider only specifications within closed frameworks. Such frameworks can be constructed incrementally, starting from a simple framework with an obvious isoinitial model, e.g. the term model generated by the constructor symbols (see e.g. [19]). Example 2. <p> Hence the program (16) is a correct implementation of S. 6 Discussion and Concluding Remarks We have presented a model-theoretic view of frameworks and specifications. The model-theoretic semantics discussed here is used in <ref> [19] </ref> to define the model-theoretic relationship between frameworks, specifications and programs, in a three-tier formalism for logic program synthesis. The kinds of specifications presented here are intended for deductive synthesis, and not for constructive synthesis (see [6] for a survey of different approaches to logic program synthesis).
Reference: 20. <author> Z. Manna and R. Waldinger. </author> <title> Fundamentals of deductive program synthesis. </title> <journal> IEEE Trans. on Soft. Eng. </journal> <volume> 18(8) </volume> <pages> 53-79, </pages> <year> 1992. </year>
Reference-contexts: In general, constructive synthesis follows the `proofs as programs' approach (e.g. <ref> [1, 20] </ref>). 11 A specification consists of an input-output theorem of the form 8x9y . r (x; y) (18) From a proof of this theorem, a program to compute r can be extracted.
Reference: 21. <author> P. Miglioli, U. Moscato and M. Ornaghi. </author> <title> Abstract parametric classes and abstract data types defined by classical and constructive logical methods. </title> <journal> J. Symb. Comp. </journal> <volume> 18 </volume> <pages> 41-81, </pages> <year> 1994. </year>
Reference: 22. <author> R.A. O'Keefe. </author> <title> What does subset mean? ALP Newsletter 8(3):10, </title> <month> August </month> <year> 1995. </year>
Reference-contexts: For example, consider the following Prolog program (in <ref> [22] </ref>) for subset : member (X, [X|_]). member (X, [_|Xs]) :- member (X, Xs). subset ([], _). subset ([X|Xs], Ys) :- member (X, Ys), subset (Xs, Ys). (1) As a program, the meaning of (1) is of course completely defined, for example, by the usual minimum model semantics. <p> For this reason, the intended meaning S of a program P used as an executable specification, needs to be specified separately. For instance, S for (1) might be the following informal specification (also in <ref> [22] </ref>): "subset (X, Y) is to be true if: X and Y are two lists of integers and the set X represents is a subset of the set that Y represents." (2) Now, (2) uses the abstract data types of finite sets, lists, and integers, but it does not contain such
Reference: 23. <institution> J.M. Spivey. Understanding Z . Cambridge University Press, </institution> <year> 1988. </year>
Reference-contexts: Roughly speaking, the relation r (x; y) is defined if and when IC (x) holds, and in this case r (x; y) is defined to be R (x; y) and OC (y) will also hold. If we follow the pre-post-condition style of program specification (e.g. <ref> [14, 23] </ref>), then a conditional specification defines a program P to compute r (x; y) in such a way that whenever IC (x) is satisfied, P satisfies OC (y) ^ R (x; y). <p> Conditional specifications are widely used in so-called formal methods, e.g. VDM [14] and Z <ref> [23] </ref>, in the form of pre- and post-conditions for specifying the effects of operations on the current computational state. However, these methods use such specifications in a purely proof-theoretic way.
Reference: 24. <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Note that the syntax of a framework is similar to that used in algebraic abstract data types (e.g. <ref> [24] </ref>). 4 However, algebraic abstract data types are usually defined by equational or Horn axioms, whereas frameworks are defined by full first-order axioms. Therefore, an algebraic abstract data type is an initial model of its specification, whereas a framework has an isoinitial model.
References-found: 24

