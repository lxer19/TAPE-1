URL: ftp://ftp.gmd.de/gmd/concorde/gabriel.tc2.ps.gz
Refering-URL: http://www.first.gmd.de/concorde/publications.html
Root-URL: 
Email: E-Mail: gabriel@karlsruhe.gmd.dbp.de  
Title: Program Transformation Expressed in the  
Author: DEVA Meta-Calculus Robert Gabriel 
Address: 7500 Karlsruhe 1, Germany.  
Affiliation: GMD Forschungsstelle an der Universitat Karlsruhe (German National Research Center for Computer Science), Vincenz-Prienitz-Strae 1,  
Abstract: This paper contributes to the field of formal program development. It exemplifies the use of the meta-calculus DEVA. DEVA has been designed to be a uniform logical framework for expressing, e.g., theories, proofs and formal methods. The paper focusses on the well-known schema ParenthesesMovement for the optimization of linearly recursive functions. The proof of the correctness of the schema and the necessary theories are given in DEVA. The whole formalization was verified with the DEVA support environment. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F.L. Bauer and H. Wossner. </author> <title> Algorithmic Language and Program Development. </title> <publisher> Springer Verlag, </publisher> <year> 1982. </year>
Reference-contexts: The choice of this example has several advantages. First, as the schema is well-known, the reader can concentrate on the formalization itself. It will turn out that it is very close to the presentation in standard text books <ref> [1] </ref> with the additional advantage that it can be checked by machine. <p> It allows the transformation of a linearly recursive function into its equivalent tail recursive form. The latter may, e.g., then be transformed into a while loop. More detailed descriptions can be found in <ref> [1] </ref>. A function f is linearly recursive, iff 1. its defining equation obeys the structure f (x) = if cond (x) then f (newval (x)) expr (x) else stopval (x), and 2. f is not called in the functions newval, expr and stopval .
Reference: [2] <author> O. Bittel, R. Gabriel, M. Weber, and W. Zimmermann. Vorlesungsskriptum zu Kalkule zur Programmentwicklung. </author> <title> GMD Forschungsstelle an der Universitat Karls-ruhe, </title> <year> 1990. </year>
Reference-contexts: Hence, the rules are denoted Apply ! = and Apply = . The rules for symmetry, transitivity, folding and unfolding can be derived from the two axioms for reflexivity and substitutivity. For reasons of space, the derivations are omitted in this paper. In the full formalization <ref> [2] </ref> these laws were derived, because it is advisible to use as few axioms as possible, in order to be able to check their consistency. 5 ; part equality := [[ () = () : [a ? sort ` [a; a ` prop]] ; refl = : [a ? sort ; <p> In addition, it was shown how the schema can be applied to a concrete example. Besides the factorial function, the schema has also been used to optimize the reverse function in the same easy way <ref> [2] </ref>. The only thing required in addition to the work presented is a formalization of the theory of polymorphic lists and the appropriate function definitions. Future work will deal with the extension of the formalization with respect to termination orderings. Other transformation schemata will be considered.
Reference: [3] <author> N.G. de Bruijn. </author> <title> A survey of the project AUTOMATH. Essays in combinatory logic, lambda calculus and formalism, </title> <publisher> Academic Press, </publisher> <pages> pages 589-606, </pages> <year> 1980. </year>
Reference-contexts: Detailed descriptions of DEVA can be found in [11, 12, 10]. Technically, DEVA is a typed -calculus with generalized -structured types. It is based on the Nederpelt calculus [9] developed in the project AUTOMATH <ref> [3] </ref> enriched by 2 f (x : a) : a = if cond (x ) then f (newval (x )) expr (x ) else stopval (x ) ? Associativity of f (x : a) : a = if cond (x ) then h (newval (x ); expr (x )) else stopval
Reference: [4] <author> R. Gabriel. </author> <title> The automatic generation of graphical user-interfaces. In System design: </title> <booktitle> concepts, methods and tools, </booktitle> <pages> pages 330-339. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> April </month> <year> 1988. </year>
Reference-contexts: DEVA is supported by a prototype environment which enables the checking of correctness of DEVA developments [5]. For reasons of clarity, DEVA has a two dimensional notation which is supported by a graphical user interface <ref> [4, 5] </ref>. 'naturals', which contains a formalization of Peano's axioms. Contexts are the syntactic means for breaking down DEVA developments into logical units. Contexts can be reused with the import-construct: An 'import' makes visible the contents of a context. Contexts are made up of a sequence of declarations or definitions.
Reference: [5] <author> R. Gabriel. </author> <title> ESPRIT project ToolUse. Final report of the DEVA support task: Retrospective and manuals. Arbeitspapiere der GMD, no. </title> <type> 425, </type> <institution> Gesellschaft fur Mathematik und Datenverarbeitung, </institution> <year> 1990. </year>
Reference-contexts: DEVA is supported by a prototype environment which enables the checking of correctness of DEVA developments <ref> [5] </ref>. For reasons of clarity, DEVA has a two dimensional notation which is supported by a graphical user interface [4, 5]. 'naturals', which contains a formalization of Peano's axioms. Contexts are the syntactic means for breaking down DEVA developments into logical units. <p> DEVA is supported by a prototype environment which enables the checking of correctness of DEVA developments [5]. For reasons of clarity, DEVA has a two dimensional notation which is supported by a graphical user interface <ref> [4, 5] </ref>. 'naturals', which contains a formalization of Peano's axioms. Contexts are the syntactic means for breaking down DEVA developments into logical units. Contexts can be reused with the import-construct: An 'import' makes visible the contents of a context. Contexts are made up of a sequence of declarations or definitions.
Reference: [6] <author> R. Gabriel and S. Jahnichen. ToolUse: </author> <title> a uniform approach to formal program development. </title> <journal> Technique et Science Informatiques, </journal> <volume> 9(2) </volume> <pages> 166-174, </pages> <year> 1990. </year>
Reference-contexts: Even more challenging, and very important for the development of provably correct software, is the combination of different development methods. Such considerations have led to the development of the DEVA meta-calculus. DEVA [10] was developed in the framework of the ESPRIT project ToolUse <ref> [6] </ref>. DEVA is intended to be a uniform logical framework for expressing, e.g., theories, proofs and formal methods in the same way as a programming language is for various kinds of software. A comparison of DEVA with similar approaches can be found in [12].
Reference: [7] <author> C. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction In the last decade, academia has dedicated much effort to the development of new specification languages, program development methods and correctness preserving program transformation techniques. Some of the methods and specification languages have started to be used in industry. Examples are the methods Z and VDM <ref> [13, 7] </ref>. These different theories, methods and techniques often lack machine support for instance, for proving conditions that have to be met during the application of a method. Even more challenging, and very important for the development of provably correct software, is the combination of different development methods.
Reference: [8] <author> C. Lafontaine. </author> <title> Formalization of the VDM reification in the DEVA meta calculus. The human-leucocyte-antigen case study. </title> <booktitle> In Programming Concepts and Methods, </booktitle> <pages> pages 333-368. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: It is part of an ongoing research effort to investigate the formalization of development methods and program developments in the DEVA meta-calculus. In the framework of these investigations, DEVA has been used to express, e.g., the Bird-Meertens-Formalism 1 [11] and VDM reification <ref> [8] </ref>. This paper focusses on the program transformation schema ParenthesesMovement for the optimization of linearly recursive functions. The proof of the correctness of the schema and the necessary theories are given in DEVA. The choice of this example has several advantages.
Reference: [9] <author> R.P. </author> <title> Nederpelt. An approach to theorem proving on the basis of a typed lambda calculus. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 87 </volume> <pages> 181-190, </pages> <year> 1980. </year>
Reference-contexts: Some of the DEVA language constructs necessary for the understanding of this paper will be described when explaining the formalization. Detailed descriptions of DEVA can be found in [11, 12, 10]. Technically, DEVA is a typed -calculus with generalized -structured types. It is based on the Nederpelt calculus <ref> [9] </ref> developed in the project AUTOMATH [3] enriched by 2 f (x : a) : a = if cond (x ) then f (newval (x )) expr (x ) else stopval (x ) ? Associativity of f (x : a) : a = if cond (x ) then h (newval (x
Reference: [10] <author> M. Sintzoff, Ph. de Groote, M. Weber, and Jacques Cazin. </author> <title> Definition 1.1 of the generic development language DEVA. </title> <type> Technical report, </type> <institution> Universite Catholique de Louvain, Belgium, Digital Equipment Corporation 1989. </institution>
Reference-contexts: Even more challenging, and very important for the development of provably correct software, is the combination of different development methods. Such considerations have led to the development of the DEVA meta-calculus. DEVA <ref> [10] </ref> was developed in the framework of the ESPRIT project ToolUse [6]. DEVA is intended to be a uniform logical framework for expressing, e.g., theories, proofs and formal methods in the same way as a programming language is for various kinds of software. <p> Some of the DEVA language constructs necessary for the understanding of this paper will be described when explaining the formalization. Detailed descriptions of DEVA can be found in <ref> [11, 12, 10] </ref>. Technically, DEVA is a typed -calculus with generalized -structured types.
Reference: [11] <author> M. Weber. </author> <title> Formalization of the Bird-Meertens algorithmic calculus in the DEVA meta calculus. </title> <booktitle> In Programming Concepts and Methods, </booktitle> <pages> pages 201-232. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: It is part of an ongoing research effort to investigate the formalization of development methods and program developments in the DEVA meta-calculus. In the framework of these investigations, DEVA has been used to express, e.g., the Bird-Meertens-Formalism 1 <ref> [11] </ref> and VDM reification [8]. This paper focusses on the program transformation schema ParenthesesMovement for the optimization of linearly recursive functions. The proof of the correctness of the schema and the necessary theories are given in DEVA. The choice of this example has several advantages. <p> Some of the DEVA language constructs necessary for the understanding of this paper will be described when explaining the formalization. Detailed descriptions of DEVA can be found in <ref> [11, 12, 10] </ref>. Technically, DEVA is a typed -calculus with generalized -structured types.
Reference: [12] <author> M. Weber. </author> <title> A Meta-Calculus for Formal System Development. </title> <type> PhD thesis, </type> <institution> University of Karlsruhe, </institution> <year> 1990. </year>
Reference-contexts: DEVA is intended to be a uniform logical framework for expressing, e.g., theories, proofs and formal methods in the same way as a programming language is for various kinds of software. A comparison of DEVA with similar approaches can be found in <ref> [12] </ref>. The work presented here shows how program transformation techniques can be expressed in DEVA. It is part of an ongoing research effort to investigate the formalization of development methods and program developments in the DEVA meta-calculus. <p> Some of the DEVA language constructs necessary for the understanding of this paper will be described when explaining the formalization. Detailed descriptions of DEVA can be found in <ref> [11, 12, 10] </ref>. Technically, DEVA is a typed -calculus with generalized -structured types.
Reference: [13] <author> J.P. Woodcock. </author> <title> Using Z. </title> <type> Technical report, </type> <institution> Programming Research Group, Oxford University Computing Laboratory, </institution> <year> 1988. </year> <month> 19 </month>
Reference-contexts: 1 Introduction In the last decade, academia has dedicated much effort to the development of new specification languages, program development methods and correctness preserving program transformation techniques. Some of the methods and specification languages have started to be used in industry. Examples are the methods Z and VDM <ref> [13, 7] </ref>. These different theories, methods and techniques often lack machine support for instance, for proving conditions that have to be met during the application of a method. Even more challenging, and very important for the development of provably correct software, is the combination of different development methods.
References-found: 13

