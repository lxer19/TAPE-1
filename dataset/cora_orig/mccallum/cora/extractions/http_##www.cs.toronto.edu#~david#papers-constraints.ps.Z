URL: http://www.cs.toronto.edu/~david/papers-constraints.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: 
Email: david@cs.toronto.edu  
Title: Memoing Evaluation for Constraint Extensions of Datalog  
Author: DAVID TOMAN Editor: Raghu Ramakrishnan and Peter Stuckey 
Keyword: Datalog, constraint class, top-down evaluation, memoing evaluation of logic programs, SLG.  
Affiliation: Department of Computer Science, University of Toronto  
Date: 2, 337-359 (1997)  
Note: Constraints: An International Journal,  c 1997 Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.  
Abstract: This paper proposes an efficient method for evaluation of deductive queries over constraint databases. The method is based on a combination of the top-down resolution with memoing and the closed form bottom-up evaluation. In this way the top-down evaluation is guaranteed to terminate for all queries for which the bottom-up evaluation terminates. The main advantage of the proposed method is the direct use of the information present in partially instantiated queries without the need for rewriting of the original program. The evaluation algorithm automatically propagates the necessary constraints during the computation. In addition, the top-down evaluation potentially allows the use of compilation techniques, developed for compilers of logic programming languages, which can make the query evaluation very efficient. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Abiteboul, S., Hull, R., and Vianu, V. </author> <year> (1995). </year> <title> Foundations of Databases. </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: Example 4 (Common Constraint Classes) Standard Datalog can be defined using the class of constraints generated from the set fx = a : a 2 Ag where A is the set of all constants in the Datalog program (the active domain <ref> (Abiteboul et al., 1995) </ref>). Allowing general equality may cause problems to the standard evaluation strategies (rules may not be range-restricted). However, in our case we simply generate the appropriate class of constraints from the set fx = a : a 2 Ag [ fx = yg.
Reference: <author> Bancilhon, F., Maier, D., Sagiv, Y., and Ullman, J. </author> <year> (1986). </year> <title> Magic Sets and Other Strange Ways to Implement Logic Programs. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-16. </pages>
Reference-contexts: However, these strategies fail to take into account the information contained in a partially instantiated query: they are not goal-oriented. There are two major approaches to solving this problem in the case of standard (ground) Datalog: 1. Rewrite the original program using the Magic Templates (MT) transformation tech nique <ref> (Bancilhon et al., 1986, Ramakrishnan, 1991) </ref> and subsequently evaluate the transformed program bottom-up, or 2. Adopt a variant of a top-down evaluation strategy (Clocksin and Mellish, 1987) based on the resolution principle (Lloyd, 1987). In this paper we consider mainly the top-down, resolution-based methods.
Reference: <author> Chen, W. and Warren, D. S. </author> <year> (1993). </year> <title> Query evaluation under the well-founded semantics. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 168-179. </pages>
Reference-contexts: Note also that breadth-first traversal of a SLD-tree does not guarantee termination in general. The drawback is caused by occurrences of infinite paths in SLD search trees. This has been observed in several papers, e.g., <ref> (Chen and Warren, 1993, Tamaki and Sato, 1986) </ref> and an alternative to SLD-resolution was proposed (under various names). The main idea lies in remembering answers for already resolved subgoals. This approach guarantees 344 D. TOMAN termination in the case of function-free logic programs (Swift and Warren, 1994b). <p> Top-down evaluation for Datalog C In the last section the bottom-up evaluation of Datalog C was defined in terms of elementary operations over a given constraint class. This section shows how a top-down query evaluation procedure (SLG-resolution <ref> (Chen and Warren, 1993) </ref>) can be refined using the same operations to handle constraint queries. This approach allows us to build an efficient top-down evaluation procedure for every class of constraints that has a closed form bottom-up evaluation procedure.
Reference: <author> Clocksin, W. F. and Mellish, C. S. </author> <year> (1987). </year> <title> Programming in Prolog. </title> <publisher> Springer, </publisher> <address> Berlin, 3 edition. </address>
Reference-contexts: Rewrite the original program using the Magic Templates (MT) transformation tech nique (Bancilhon et al., 1986, Ramakrishnan, 1991) and subsequently evaluate the transformed program bottom-up, or 2. Adopt a variant of a top-down evaluation strategy <ref> (Clocksin and Mellish, 1987) </ref> based on the resolution principle (Lloyd, 1987). In this paper we consider mainly the top-down, resolution-based methods. However, the MT optimization for constraint deductive query languages is also be introduced for comparison purposes. <p> strategy <ref> (Clocksin and Mellish, 1987) </ref> based on the resolution principle (Lloyd, 1987). In this paper we consider mainly the top-down, resolution-based methods. However, the MT optimization for constraint deductive query languages is also be introduced for comparison purposes. It is well known that the standard top-down strategies, e.g., the SLD-resolution (Clocksin and Mellish, 1987), despite their efficiency, have a major drawback as query evaluation procedures: they lead to nonterminating computations even in the situations, where the bottom-up algorithms are guaranteed to terminate. Note also that breadth-first traversal of a SLD-tree does not guarantee termination in general.
Reference: <author> Freire, J., Swift, T., and Warren, D. S. </author> <year> (1996). </year> <title> Beyond depth-first: Improving tabled logic programs through alternative schedulingstrategies. In ProgrammingLanguages: Implementations, Logics, and Programs, </title> <booktitle> volume 1140 of Lecture Notes in Computer Science, </booktitle> <pages> pages 234-258. </pages>
Reference-contexts: However, the termination guarantees are often sacrificed (Ullman, 1989) in order to improve the expressiveness and efficiency; an exception is (Swift and Warren, 1994b) where no constraints are allowed. On the other hand these methods can take full advantage of compilation techniques developed for other logic programming languages, e.g., <ref> (Freire et al., 1996, Swift and Warren, 1994a, Warren, 1983) </ref>. This greatly improves the practical efficiency of query evaluation in the case of Datalog (Swift and Warren, 1994b). We show that similar results can be achieved for constraint extensions of Datalog. <p> TOMAN of the underlying RDBMS directly). We propose the top-down evaluation procedure to be used as a front-end built on top of a standard relational DBMS. Similar approach was proposed in <ref> (Freire et al., 1996, Freire et al., 1997) </ref> for the XSB deductive system. The proposed techniques can be directly applied in the constraint setting. 4. Negation.
Reference: <author> Freire, J., Swift, T., and Warren, D. S. </author> <year> (1997). </year> <title> Taking i/o seriously: Resolution reconsidered for disk. </title> <booktitle> In International Conference on Logic Programming. </booktitle>
Reference-contexts: In addition, recent work on scheduling of operations in tabling systems <ref> (Freire et al., 1997) </ref> shows modifications to the tabling strategy that make it efficient even if external storage is involved. The scheduling strategies are orthogonal to the extensions introduced for handling constraints and thus can be immediately applied to our proposal. 6.1.
Reference: <author> Gao, H. and Warren, D. S. </author> <year> (1993). </year> <title> A powerful evaluation strategy for CLP programs. </title> <booktitle> In PPCP'93, First International Workshop on Principles and Practice of Constraint Programming, </booktitle> <pages> pages 90-97. </pages>
Reference-contexts: The efficiency achieved by this method is better than the efficiency of comparable bottom-up methods including program rewriting techniques (e.g., Magic Set Transformation). * The top-down evaluation strategy allows a direct use of the results obtained in the area of compilation techniques for logic programming languages <ref> (Gao and Warren, 1993, Swift and Warren, 1994a, Warren, 1983) </ref>. Handling the constraints as first-class data allows us to use these techniques for query evaluation in constraint databases. <p> However, the propagation of constraints at the time of goal resolution is reduced. The soundness and completeness properties are preserved by Lemma 20. The termination is guaranteed similarly to Theorem 23. In <ref> (Gao and Warren, 1993) </ref> the following version of such a modification was considered: Action/Node Children Conditions Query projection body (G; B 1 ; : : : ; B k ; C) ! goal (G; B 1 ; true; B 2 ; : : : ; B k ; C) none In <p> This dramatically increases the expressive power of the query language while preserving termination and efficiency. MEMOING EVALUATION FOR CONSTRAINT EXTENSIONS OF DATALOG 357 2. The other direction is pursued in the area of (general) Logic Programming: In <ref> (Gao and Warren, 1993, Johnson, 1993, Lim and Stuckey, 1990) </ref> top-down evaluation for constraint logic programs is proposed. However, in all cases, general constraint solving procedures are used. Thus, these methods are not directly useful for query evaluation in constraint databases: termination of queries cannot be guaranteed. <p> However, in all cases, general constraint solving procedures are used. Thus, these methods are not directly useful for query evaluation in constraint databases: termination of queries cannot be guaranteed. The closest to our work is <ref> (Gao and Warren, 1993) </ref>. However, the method proposed there allows propagation of constants only (i.e., constraints of the form x = a); the constraint part of the query is essentially computed bottom-up. Our approach allows full propagation of all possible constraints during the whole evaluation process. 6.2.
Reference: <author> Jaffar, J. and Maher, M. </author> <year> (1994). </year> <title> Constraint logic programming: A survey. </title> <journal> Journal of Logic Programming, </journal> 19(20) 503-581. 
Reference-contexts: Constraint Memoing integrates the constraints as first-class data into the evaluation procedure. This approach is different from most CLP systems, where constraints are handled by a separate constraint solver <ref> (Jaffar and Maher, 1994) </ref>. We propose much tighter integration of constraints into the query evaluation: they are handled very similarly to standard ground tuples (or terms in the CLP systems). <p> F V (C) denotes the set of free variables in C. This definition is similar to the definition of Constraint Domain <ref> (Jaffar and Maher, 1994) </ref>. However, C contains only satisfiable constraints. The elements of C are used as a finite representation of the (possibly infinite) relations stored in a constraint database.
Reference: <author> Johnson, M. </author> <year> (1993). </year> <title> Memoization in constraint logic programming. </title> <booktitle> In PPCP'93, First International Workshop on Principles and Practice of Constraint Programming, </booktitle> <pages> pages 130-138. </pages>
Reference-contexts: This dramatically increases the expressive power of the query language while preserving termination and efficiency. MEMOING EVALUATION FOR CONSTRAINT EXTENSIONS OF DATALOG 357 2. The other direction is pursued in the area of (general) Logic Programming: In <ref> (Gao and Warren, 1993, Johnson, 1993, Lim and Stuckey, 1990) </ref> top-down evaluation for constraint logic programs is proposed. However, in all cases, general constraint solving procedures are used. Thus, these methods are not directly useful for query evaluation in constraint databases: termination of queries cannot be guaranteed.
Reference: <author> Kanellakis, P., Kuper, G., and Revesz, P. </author> <year> (1995). </year> <title> Constraint Query Languages. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 51(1) </volume> <pages> 26-52. </pages>
Reference-contexts: 1. Introduction We propose a new method for evaluating deductive queries over constraint databases <ref> (Kanellakis et al., 1995) </ref>. The evaluation of queries over such databases is different from the one used in standard database systems. The constraints are used as the actual representation of data stored in the database rather than mere restrictions of the contents of otherwise ground relations. <p> However, neither of them seems to address all three of the requirements. The first approach is based on a fixpoint, bottom-up evaluation of the rules. Here the first condition is usually met, e.g., for Datalog (Ullman, 1989), Datalog with dense order constraints <ref> (Kanellakis et al., 1995) </ref>, Datalog with integer constraints (Revesz, 1993, Toman et al., 1994), and sets (Srivastava et al., 1994). However, the evaluation process is not goal-oriented and thus the evaluation of partially instantiated queries is fairly inefficient. <p> This is achieved by defining several constraint operations over the representation of the constraints that are used by the query evaluation algorithm (cf. Definition 2). Moreover, the same operations are also needed for the bottom-up evaluation <ref> (Kanellakis et al., 1995) </ref> and thus we can reuse results obtained in (Kanellakis et al., 1995, Revesz, 1993, Srivastava et al., 1994, Toman et al., 1994). * Termination. Constraint Memoing guarantees termination of queries for all classes of constraints that have a terminating closed-form bottom-up evaluation procedure. <p> In (Toman et al., 1994) a closed form bottom-up evaluation procedure for C ;&lt;Z = C &lt;Z [ C Z was developed including the constraint operations from Definition 2. The dense order constraints over Q can be incorporated by a slight modification of constraint operations defined in <ref> (Kanellakis et al., 1995) </ref>. All the above constraint classes are constraint-compact. <p> However, there are also constraint classes where all the constraint operations are defined, but which are not constraint-compact, e.g., the class generated from the set fx + c &lt; y : c 2 Zg (gap-order constraints with possibly negative size of the gap (Revesz, 1993)) or the linear arithmetic constraints <ref> (Kanellakis et al., 1995) </ref>. Definition 5 (Datalog C Program) Let C be a class of constraints. A atom is a predicate symbol with distinct variables as its arguments.
Reference: <author> Kanellakis, P., Ramaswamy, S., Vengroff, D., and Vitter, J. </author> <year> (1993). </year> <title> Indexing for Data Models with Constraints and Classes. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 233-243. </pages>
Reference-contexts: Storage and access methods. To achieve an efficient implementation of constraint databases, new storage management techniques have to be developed: access methods suitable for fast retrieval of the stored information, efficient updates of generalized relations, indexing techniques <ref> (Kanellakis et al., 1993) </ref>, etc. 6. Benchmarks. The performance of various implementations of Logic Programming languages (e.g., Prolog) is often judged by the performance on a standard benchmarks (e.g., nrev). We propose to develop similar benchmarks for query evaluation methods in constraint databases.
Reference: <author> Kemp, D., Ramamohanarao, K., and Somogyi, Z. </author> <year> (1990). </year> <title> Right-, left-, and multi-linear transformations that maintain context information. </title> <booktitle> In International Conference on Very Large Data Bases, </booktitle> <pages> pages 380-391. </pages> <note> MEMOING EVALUATION FOR CONSTRAINT EXTENSIONS OF DATALOG 359 Kemp, </note> <author> D. B. and Stuckey, P. J. </author> <year> (1993). </year> <title> Analysis based constraint query optimization. </title> <editor> In Warren, D. S., editor, </editor> <booktitle> International Conference on Logic Programming, </booktitle> <pages> pages 666-682. </pages>
Reference-contexts: The other important consequence of using adornments is the possibility to reduce the arity of literals in the bodies of clauses. This leads to more efficient bottom-up evaluation: reduction of arity by one may cause linear speedup <ref> (Kemp et al., 1990) </ref>. 3. The adornment partially factors the search space and allows to propagate only the needed restrictions. In the SLG C case the first use of adornments is not needed (similarly to the bottom-up procedure for constraints: Algorithm 9).
Reference: <author> Lim, P. and Stuckey, P. </author> <year> (1990). </year> <title> Meta programming as constraint programming. </title> <booktitle> In North American Conference on Logic Programming, </booktitle> <pages> pages 416-430. </pages>
Reference: <author> Lloyd, J. </author> <year> (1987). </year> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, 2nd edition. </publisher>
Reference-contexts: Rewrite the original program using the Magic Templates (MT) transformation tech nique (Bancilhon et al., 1986, Ramakrishnan, 1991) and subsequently evaluate the transformed program bottom-up, or 2. Adopt a variant of a top-down evaluation strategy (Clocksin and Mellish, 1987) based on the resolution principle <ref> (Lloyd, 1987) </ref>. In this paper we consider mainly the top-down, resolution-based methods. However, the MT optimization for constraint deductive query languages is also be introduced for comparison purposes. <p> We assume that the SLG-trees are ordered left-to-right in the order they were created. The choice of selection strategy does not affect the soundness/completeness of the algorithm <ref> (Lloyd, 1987) </ref>. However, the selection strategy may influence the efficiency of the system (cf. Section 6).
Reference: <author> Maher, M. </author> <year> (1993). </year> <title> A logic programming view of clp. </title> <booktitle> In International Conference on Logic Programming, </booktitle> <pages> pages 737-753. </pages>
Reference-contexts: However, the use of the weaker definition may require much more expensive subsumption checks (Srivastava, 1993). The two definitions are equivalent for constraint classes that satisfy the single subsumption property <ref> (Maher, 1993) </ref>. Example 4 (Common Constraint Classes) Standard Datalog can be defined using the class of constraints generated from the set fx = a : a 2 Ag where A is the set of all constants in the Datalog program (the active domain (Abiteboul et al., 1995)).
Reference: <author> Ramakrishnan, R. </author> <year> (1991). </year> <title> Magic Templates: A Spellbinding Approach to Logic Programs. </title> <journal> Journal of Logic Programming, </journal> 11(3&4):189-216. 
Reference-contexts: In the presented form the Query projection rule implements the left-to-right selection rule (common to most of the LP systems). However, any other goal selection strategy can be implemented here, e.g., selection based on specific SIPSSideways Information Passing Style <ref> (Ramakrishnan, 1991) </ref>. The main difference between SLG and SLG C is in two additional rules: the Query Projection and the Answer Projection. <p> This transformation completely eliminates the need for non tabled resolution steps. 3. Program transformation similar to supplementary magic <ref> (Ramakrishnan, 1991) </ref>. The previous folding transformation may introduce unnecessary recomputation of conjunctions of goals. This can be avoided by a technique that folds common parts of bodies of the clauses and creates separate clauses. <p> Again, for simplicity, only the left-to-right SIPS is used. This corresponds to the selection rule used in Constraint Memoing. In both cases, different selection rules may improve the efficiency of query evaluation <ref> (Ramakrishnan, 1991) </ref>. However, in the case on MT, the SIPS is fixed during the program transformation phase and there are technical difficulties with combining different SIPS in one program. <p> In the case of SLG C evaluation, the selection rule can be adjusted during the evaluation process dynamically while preserving correctness of the answers. The Magic Templates transformation is often preceded by an adornment transformation <ref> (Ramakrishnan, 1991) </ref>. The adornment phase is designed to partition the search space according to (the statically derivable) information about free and bound arguments of the literals. The purpose of this transformation is threefold: 1. <p> Analysis of binding patterns. Similarly to the MT transformation, the queries can be analyzed to determine the flow of information in clause bodies <ref> (Ramakrishnan, 1991) </ref>. This is a considerably more complicated task in the presence of constraints: it is no longer sufficient to focus on single variables; the relationships between groups of variables have to be taken into consideration (as noted in Section 4).
Reference: <author> Ramakrishnan, R. and Srivastava, D. </author> <year> (1993). </year> <title> Pushing Constraint Selections. </title> <journal> Journal of Logic Programming, </journal> 16(3&4):361-414. 
Reference: <author> Revesz, P. </author> <year> (1993). </year> <title> A Closed-Form Evaluation for Datalog Queries with Integer (Gap)-Order Constraints. </title> <journal> Theoretical Computer Science, </journal> <volume> 116 </volume> <pages> 117-149. </pages>
Reference-contexts: The first approach is based on a fixpoint, bottom-up evaluation of the rules. Here the first condition is usually met, e.g., for Datalog (Ullman, 1989), Datalog with dense order constraints (Kanellakis et al., 1995), Datalog with integer constraints <ref> (Revesz, 1993, Toman et al., 1994) </ref>, and sets (Srivastava et al., 1994). However, the evaluation process is not goal-oriented and thus the evaluation of partially instantiated queries is fairly inefficient. Application of standard program transformation techniques, e.g., the Magic Rewriting, does not completely solve the problem (cf. <p> The evaluation remains otherwise unchanged as we use more general evaluation mechanism. Incorporation of more interesting constraints, e.g., constraints over integers (Z) is also easy: the gap-order constraints <ref> (Revesz, 1993) </ref> are generated from the set C &lt;Z = fx &lt; u : u 2 Ag [fu &lt; x : u 2 Ag [fx+c &lt; y : c 2 Z + g. Similarly the periodicity constraints are generated from C Z = fx k c : c 2 Ag. <p> However, there are also constraint classes where all the constraint operations are defined, but which are not constraint-compact, e.g., the class generated from the set fx + c &lt; y : c 2 Zg (gap-order constraints with possibly negative size of the gap <ref> (Revesz, 1993) </ref>) or the linear arithmetic constraints (Kanellakis et al., 1995). Definition 5 (Datalog C Program) Let C be a class of constraints. A atom is a predicate symbol with distinct variables as its arguments. <p> Algorithm 9 was shown to be sound and complete for Datalog (Ullman, 1989), Datalog &lt;Q , and Datalog &lt;;Z <ref> (Revesz, 1993, Toman et al., 1994) </ref>. A simple generalization of the proofs in (Toman et al., 1994) shows soundness and completeness of Algorithm 9 for a general class C: Notation 10 Let S C. Then kSk is the set of valuations such that j= C for some C 2 S. <p> The soundness and completeness proof is based on the reduction to the fixpoint computation on ground instances. However, to prove termination of the query evaluation algorithms (in both the bottom-up and top-down cases) a finite encoding of a potentially infinite result of the evaluation is needed <ref> (Revesz, 1993, Toman et al., 1994) </ref>: Theorem 23 (Termination) Let C be a constraint-compact class. Then the SLG C evaluation terminates for all queries (G; C; P ). Proof: Let C be a constraint-compact class of constraints. Then: 1.
Reference: <author> Revesz, P. Z. </author> <year> (1995). </year> <title> Safe Stratified Datalog with Integer Order Programs. </title> <booktitle> In International Conference on Constraint Programming, volume 1000 of Lecture Notes in Computer Science, </booktitle> <pages> pages 154-169. </pages>
Reference-contexts: This condition is easy to satisfy in the case of finite domain constraints. For infinite constraint classes we sometimes need to restrict the class of allowed Datalog C programs to those, where termination can be guaranteed <ref> (Revesz, 1995) </ref>. (Toman, 1997) presents an extension of Constraint Memoing to Datalog C programs with negation under the well founded semantics. However, the constraint class is required to be both constraint compact and closed under complementation. 5. Storage and access methods.
Reference: <author> Sagonas, K. F., Swift, T., and Warren, D. S. </author> <year> (1994). </year> <title> XSB as an efficient deductive database engine. </title> <editor> In Snodgrass, R. T. and Winslett, M., editors, </editor> <booktitle> ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 442-453. </pages>
Reference-contexts: This step is quite subtle if termination of queries is to be preserved. In contrast to bottom-up methods, it is also possible to extend the query language to classes of constraints, where termination is not guaranteed. Even in those cases the algorithm reduces the possibility of non-termination <ref> (Sagonas et al., 1994) </ref>. * The use of a top-down method allows a fully goal-oriented query evaluation: the information present in partially instantiated queries is used to prune the search space of queries.
Reference: <author> Srivastava, D. </author> <year> (1993). </year> <title> Subsumption and Indexing in Constraint Query Languages with Linear Arithmetic Constraints. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 8 </volume> <pages> 315-343. </pages>
Reference-contexts: In general, the above condition could be weakened to require only that every infinite set of constraints contains a finite cover (where every constraint is covered by possibly several elements of the cover). However, the use of the weaker definition may require much more expensive subsumption checks <ref> (Srivastava, 1993) </ref>. The two definitions are equivalent for constraint classes that satisfy the single subsumption property (Maher, 1993).
Reference: <author> Srivastava, D., Ramakrishnan, R., and Revesz, P. </author> <year> (1994). </year> <title> Constraint Objects. </title> <editor> In Borning, A., editor, PPCP'94, </editor> <booktitle> Second International Workshop on Principles and Practice of Constraint Programming, volume 874 of Lecture Notes in Computer Science, </booktitle> <pages> pages 181-192. </pages>
Reference-contexts: The first approach is based on a fixpoint, bottom-up evaluation of the rules. Here the first condition is usually met, e.g., for Datalog (Ullman, 1989), Datalog with dense order constraints (Kanellakis et al., 1995), Datalog with integer constraints (Revesz, 1993, Toman et al., 1994), and sets <ref> (Srivastava et al., 1994) </ref>. However, the evaluation process is not goal-oriented and thus the evaluation of partially instantiated queries is fairly inefficient. Application of standard program transformation techniques, e.g., the Magic Rewriting, does not completely solve the problem (cf.
Reference: <author> Stuckey, P. J. and Sudarshan, S. </author> <year> (1994). </year> <title> Compiling query constraints. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 56-67. </pages>
Reference: <author> Swift, T. and Warren, D. S. </author> <year> (1994a). </year> <title> An abstract machine for SLG resolution: definite programs. </title> <booktitle> In Logic Programming Proceedings of the 1994 International Symposium, </booktitle> <pages> pages 633-652. </pages>
Reference-contexts: Thus we can expect very efficient Constraint Memoing-based query evaluation engines for constraint extensions of Datalog whose performance will be comparable to the top-down engines for ground Datalog <ref> (Swift and Warren, 1994a, Swift and Warren, 1994b) </ref>. 6. Conclusion We have proposed a practical approach to query evaluation for generalized constraint databases.
Reference: <author> Swift, T. and Warren, D. S. </author> <year> (1994b). </year> <title> Analysis of SLG-WAM evaluation of definite programs. </title> <booktitle> In Logic Programming Proceedings of the 1994 International Symposium, </booktitle> <pages> pages 219-235. </pages>
Reference-contexts: TOMAN The second approach is based on a top-down, resolution-based method. Here the second and third conditions are usually met. However, the termination guarantees are often sacrificed (Ullman, 1989) in order to improve the expressiveness and efficiency; an exception is <ref> (Swift and Warren, 1994b) </ref> where no constraints are allowed. On the other hand these methods can take full advantage of compilation techniques developed for other logic programming languages, e.g., (Freire et al., 1996, Swift and Warren, 1994a, Warren, 1983). <p> On the other hand these methods can take full advantage of compilation techniques developed for other logic programming languages, e.g., (Freire et al., 1996, Swift and Warren, 1994a, Warren, 1983). This greatly improves the practical efficiency of query evaluation in the case of Datalog <ref> (Swift and Warren, 1994b) </ref>. We show that similar results can be achieved for constraint extensions of Datalog. In this paper we try to combine the advantages of the above two approaches. <p> The main idea lies in remembering answers for already resolved subgoals. This approach guarantees 344 D. TOMAN termination in the case of function-free logic programs <ref> (Swift and Warren, 1994b) </ref>. We extend this method to constraint deductive queries while preserving the termination and complexity bounds of the bottom-up evaluation algorithms. 3. <p> Note the essential use of constraint projection which allows to determine the relevant constraint for every atom. The SLG-resolution can handle negation using additional rules <ref> (Swift and Warren, 1994b, Toman, 1997) </ref>. However, our proposal currently allows only positive programs. Adding negation is briefly discussed in Section 6.
Reference: <author> Tamaki, S. and Sato, T. </author> <year> (1986). </year> <title> OLD Resolution with Tabulation. </title> <booktitle> In International Conference on Logic Programming, </booktitle> <pages> pages 84-98. </pages>
Reference: <author> Toman, D. </author> <year> (1995). </year> <title> Top-Down Beats Bottom-Up for Constraint Based Extensions of Datalog. </title> <booktitle> In International Logic Programming Symposium, </booktitle> <pages> pages 189-203. </pages>
Reference-contexts: Application of standard program transformation techniques, e.g., the Magic Rewriting, does not completely solve the problem (cf. Section 4). * A preliminary report on this work appeared in Proc. 1995 ILPS, Portland, OR, <ref> (Toman, 1995) </ref>. 338 D. TOMAN The second approach is based on a top-down, resolution-based method. Here the second and third conditions are usually met.
Reference: <author> Toman, D. </author> <year> (1997). </year> <title> Computing the Well-founded Semantics for Constraint Extensions of Datalog : . In Constraint Databases and Applications, </title> <booktitle> volume 1191 of Lecture Notes in Computer Science, </booktitle> <pages> pages 64-79. </pages>
Reference-contexts: This condition is easy to satisfy in the case of finite domain constraints. For infinite constraint classes we sometimes need to restrict the class of allowed Datalog C programs to those, where termination can be guaranteed (Revesz, 1995). <ref> (Toman, 1997) </ref> presents an extension of Constraint Memoing to Datalog C programs with negation under the well founded semantics. However, the constraint class is required to be both constraint compact and closed under complementation. 5. Storage and access methods.
Reference: <author> Toman, D., Chomicki, J., and Rogers, D. </author> <year> (1994). </year> <title> Datalog with Integer Periodicity Constraints. </title> <booktitle> In International Logic Programming Symposium, </booktitle> <pages> pages 189-203. </pages>
Reference-contexts: However, while in the case of ground tuples the projection returns always only one tuple (constraint), in the case of more general constraints the constraint projection may return a set containing more than one constraint representing a disjunction <ref> (Toman et al., 1994, Williams, 1976) </ref>. <p> However, while in the case of ground tuples the projection returns always only one tuple (constraint), in the case of more general constraints the constraint projection may return a set containing more than one constraint representing a disjunction (Toman et al., 1994, Williams, 1976). Example: In <ref> (Toman et al., 1994) </ref> we considered the following example: Assume that we want to eliminate quantifier 9y from the constraint: (9y)(x + c 1 &lt; y ^ y + c 2 &lt; z ^ y k d) Clearly we cannot replace it simply by x + c 1 + c 2 <p> Similarly the periodicity constraints are generated from C Z = fx k c : c 2 Ag. In <ref> (Toman et al., 1994) </ref> a closed form bottom-up evaluation procedure for C ;&lt;Z = C &lt;Z [ C Z was developed including the constraint operations from Definition 2. The dense order constraints over Q can be incorporated by a slight modification of constraint operations defined in (Kanellakis et al., 1995). <p> Algorithm 9 was shown to be sound and complete for Datalog (Ullman, 1989), Datalog &lt;Q , and Datalog &lt;;Z (Revesz, 1993, Toman et al., 1994). A simple generalization of the proofs in <ref> (Toman et al., 1994) </ref> shows soundness and completeness of Algorithm 9 for a general class C: Notation 10 Let S C. Then kSk is the set of valuations such that j= C for some C 2 S.
Reference: <author> Ullman, J. </author> <year> (1989). </year> <title> Principles of Database and Knowledge-Base Systems, volume 2. </title> <publisher> Computer Science Press. </publisher>
Reference-contexts: However, neither of them seems to address all three of the requirements. The first approach is based on a fixpoint, bottom-up evaluation of the rules. Here the first condition is usually met, e.g., for Datalog <ref> (Ullman, 1989) </ref>, Datalog with dense order constraints (Kanellakis et al., 1995), Datalog with integer constraints (Revesz, 1993, Toman et al., 1994), and sets (Srivastava et al., 1994). However, the evaluation process is not goal-oriented and thus the evaluation of partially instantiated queries is fairly inefficient. <p> Section 4). * A preliminary report on this work appeared in Proc. 1995 ILPS, Portland, OR, (Toman, 1995). 338 D. TOMAN The second approach is based on a top-down, resolution-based method. Here the second and third conditions are usually met. However, the termination guarantees are often sacrificed <ref> (Ullman, 1989) </ref> in order to improve the expressiveness and efficiency; an exception is (Swift and Warren, 1994b) where no constraints are allowed. <p> Handling the constraints as first-class data allows us to use these techniques for query evaluation in constraint databases. In <ref> (Ullman, 1989) </ref> the bottom-up approach (equipped with a query transformation phase) is shown to be no worse than the top-down approach for restricted classes of Datalog MEMOING EVALUATION FOR CONSTRAINT EXTENSIONS OF DATALOG 339 programs over ground relations. <p> A query is partially instantiated if the constraint C is nontrivial (i.e., C 6= true). 342 D. TOMAN 2.1. Closed-form Bottom-up Evaluation The usual approach to query evaluation for Datalog C is a variation on the bottom-up evaluation algorithm <ref> (Ullman, 1989) </ref>. In its simplest form a bottom-up evaluation algorithm is defined as follows: Definition 7 (Interpretation) Let R (x 1 ; : : : ; x k ) be an atom and C 2 C a constraint such that F V (C) F V (R). <p> I := ; repeat J; I := I; TP C (I) while J 6= I return fC ^ D : (G; D) 2 Ig This arrangement also shows how other TP-based evaluation procedures can be utilized for constraint query evaluation, e.g., the semi-naive bottom-up evaluation <ref> (Ullman, 1989) </ref>. Algorithm 9 was shown to be sound and complete for Datalog (Ullman, 1989), Datalog &lt;Q , and Datalog &lt;;Z (Revesz, 1993, Toman et al., 1994). <p> TP C (I) while J 6= I return fC ^ D : (G; D) 2 Ig This arrangement also shows how other TP-based evaluation procedures can be utilized for constraint query evaluation, e.g., the semi-naive bottom-up evaluation <ref> (Ullman, 1989) </ref>. Algorithm 9 was shown to be sound and complete for Datalog (Ullman, 1989), Datalog &lt;Q , and Datalog &lt;;Z (Revesz, 1993, Toman et al., 1994). A simple generalization of the proofs in (Toman et al., 1994) shows soundness and completeness of Algorithm 9 for a general class C: Notation 10 Let S C. <p> All the constraint classes in Example 4 have a closed-form terminating bottom-up evaluation procedure (based on Definitions 8 and 9). 2.2. Goal-oriented Evaluation Strategies There are several standard improvements to the naive bottom-up evaluation algorithm, e.g., the semi-naive algorithm <ref> (Ullman, 1989) </ref>. However, these strategies fail to take into account the information contained in a partially instantiated query: they are not goal-oriented. There are two major approaches to solving this problem in the case of standard (ground) Datalog: 1. <p> Implementation We have implemented experimental versions of the following deductive query evaluation algorithms: 1. the Naive Bottom-up: a straightforward implementation of Algorithm 9, 2. the Semi-naive Bottom-up: a modification of Algorithm 9 <ref> (Ullman, 1989) </ref>, 3. the Semi-naive Bottom-up with MT C , and 4. the Constraint Memoing algorithm SLG C . The implementation of each of the evaluation algorithms is parametrized on the underlying class of constraints. For each constraint class we provide elementary operations on the constraint representation (cf.
Reference: <author> Warren, D. H. D. </author> <year> (1983). </year> <title> An Abstract PROLOG Instruction Set. </title> <type> Technical Report 309, </type> <institution> Artificial Intelligence Center, Computer Science and Technology Division, SRI International, </institution> <address> Menlo Park, CA. </address>
Reference-contexts: Also, the constraints specify complex relations between the individual variables, which is not possible in the standard approach. Development of such a representation enables building of very efficient query evaluation engines based on partial evaluation of the atomic constraints in a given class, similarly to the WAM abstract code <ref> (Warren, 1983) </ref>. 2. Analysis of binding patterns. Similarly to the MT transformation, the queries can be analyzed to determine the flow of information in clause bodies (Ramakrishnan, 1991).
Reference: <author> Williams, H. </author> <year> (1976). </year> <title> Fourier-Motzkin Elimination Extension to Integer Programming Problems. </title> <journal> Journal of Combinatorial Theory A, </journal> <volume> 21 </volume> <pages> 118-123. </pages>
References-found: 32

