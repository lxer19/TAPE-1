URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/papers/elp96.ps.gz
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/papers/
Root-URL: 
Email: e-mail: filianojfpg@cs.cmu.edu  e-mail: hodas@cs.hmc.edu  
Phone: 2  
Title: Efficient Resource Management  
Author: Cervesato Joshua S. Hodas and Frank Pfenning 
Affiliation: Computer Science Department, Harvey Mudd College  
Address: Pittsburgh, PA 15213-3891, USA  Claremont, CA 91711, USA  
Note: Iliano  
Abstract: This paper will appear in the proceedings of the 1996 International Workshop on Extensions of Logic Programming, Leipzig, Germany, March 28-30 1996. for Linear Logic Proof Search Abstract. The design of linear logic programming languages and theorem provers opens a number of new implementation challenges not present in more traditional logic languages such as Horn clauses (Prolog) and hereditary Harrop formulas (Prolog). Among these, the problem of efficiently managing the linear context when solving a goal is of crucial importance for the use of these systems in non-trivial applications. This paper studies this problem in the case of Lolli [6] (though its results have application to other systems). We first give a proof-theoretic presentation of the operational semantics of this language as a resolution calculus. We then present a series of resource management systems designed to eliminate the non-determinism in the distribution of linear formulas that undermines the efficiency of a direct implementation of this system.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> Linear Objects: Logical Processes with Built-in Inheritance. </title> <booktitle> New Generation Computing 9 </booktitle> <pages> 3-4, </pages> <year> 1991. </year>
Reference-contexts: In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category. Consequently, several logic programming languages based on linear logic have been designed in the last five years <ref> [1, 3, 6, 10] </ref>. Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. <p> every proof in L can be transformed into an equivalent proof that consults the program only when the goal formula is atomic (thus proofs are goal-directed [11]), and at that point selects and operates upon a single program formula in order to proceed with the derivation (thus proofs are focused <ref> [1] </ref>). Proofs with both properties are called uniform. Hodas and Miller capture this behavior in the system L 0 which eliminates the left-hand rules of the logic in favor of a single rule for backchaining . In Fig. 1 we present a new resolution system, called R, for LHHF.
Reference: 2. <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-101, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Linear logic <ref> [2] </ref> views logical assumptions as consumable resources. This allows elegant and concise formalizations of a number of problems which are difficult to represent in traditional logics. In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category.
Reference: 3. <author> James Harland and David Pym. </author> <title> The uniform proof-theoretic foundation of linear logic programming. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <address> San Diego, California, </address> <month> October </month> <year> 1991, </year> <editor> V. Saraswat and K. Ueda, </editor> <booktitle> eds., </booktitle> <pages> pp. 304-318. </pages>
Reference-contexts: In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category. Consequently, several logic programming languages based on linear logic have been designed in the last five years <ref> [1, 3, 6, 10] </ref>. Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. <p> Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. However, to our knowledge, usable implementations have thus far been released only for Lolli [6] and Lygon <ref> [3] </ref>. Linear logic programming languages offer the implementor new challenges not present in more traditional logic languages such as Prolog or Prolog. Among these, the efficient management of the linear formulas contained in the context is of crucial importance for the use of these languages in non-trivial applications. <p> However, our results have already been applied to a prototype implementation of a programming language based on Miller's specification logic Forum [10], and should apply equally well to implementations of other linear logic programming languages such as Lygon <ref> [3] </ref>. It is also possible to adapt these techniques to the development of theorem provers for linear logic. We do not provide proofs of the soundness and completeness theorems that relate the systems presented here. <p> Hodas and Polakow have extended the system RM 3 to Miller's specification logic Forum [10] and have based a prototype implementation on it. These techniques should extend just as easily to implementations of Lygon <ref> [3, 4] </ref> and other linear languages. Finally, since Forum is complete for all of classical linear logic, they are also clearly applicable to the design of theorem provers.
Reference: 4. <author> James Harland and Michael Winikoff. </author> <title> Deterministic resource management for the linear logic programming language Lygon. </title> <type> Technical Report TR 94/23, </type> <institution> Melbourne University, Department of Computer Science, </institution> <year> 1994. </year>
Reference-contexts: To our knowledge, the only other authors who have been concerned with the issue of efficiency in context management for linear logic programming languages are the designers of Lygon. In a recent publication <ref> [4] </ref>, they build on the work of Hodas and Miller and independently develop a system with the characteristics of Hodas' efficient handling of &gt;. <p> Hodas and Polakow have extended the system RM 3 to Miller's specification logic Forum [10] and have based a prototype implementation on it. These techniques should extend just as easily to implementations of Lygon <ref> [3, 4] </ref> and other linear languages. Finally, since Forum is complete for all of classical linear logic, they are also clearly applicable to the design of theorem provers.
Reference: 5. <author> Joshua S. Hodas, </author> <title> Logic Programming in Intuitionistic Linear Logic: Theory, Design, and Implementation, </title> <type> Ph.D. </type> <institution> Dissertation from University of Pennsylvania, Department of Computer and Information Science, </institution> <month> May </month> <year> 1994. </year> <note> Available electronically at http://www.cs.hmc.edu/~hodas/papers/. </note>
Reference-contexts: We do not treat other sources of non-determinism, which can be handled according to standard techniques in a logic programming framework, or that we might want to keep open in a theorem prover. We will focus our attention on the language Lolli <ref> [5, 6] </ref>, that we used to test the techniques described below. However, our results have already been applied to a prototype implementation of a programming language based on Miller's specification logic Forum [10], and should apply equally well to implementations of other linear logic programming languages such as Lygon [3]. <p> We do not provide proofs of the soundness and completeness theorems that relate the systems presented here. We believe these results are simple enough to be reconstructed by the reader, who is referred to Hodas' dissertation <ref> [5] </ref> for proofs relevant to the first two systems. 2 Resolution for Linear Hereditary Harrop Formulas The programming language Lolli [5, 6] is based on the fragment of linear logic freely generated by the operators &gt;, &, ffi, and 8. <p> We believe these results are simple enough to be reconstructed by the reader, who is referred to Hodas' dissertation [5] for proofs relevant to the first two systems. 2 Resolution for Linear Hereditary Harrop Formulas The programming language Lolli <ref> [5, 6] </ref> is based on the fragment of linear logic freely generated by the operators &gt;, &, ffi, and 8. The connective is called intuitionistic implication and is defined as A B !A ffi B. <p> Hodas and Miller initially underestimated the importance of this issue [6]. However the subsequent development of sample applications to accompany the first public release of Lolli showed this problem to be critical in practice. The solution we describe is adapted from Hodas' dissertation <ref> [5] </ref>, and was incorporated into that implementation.
Reference: 6. <author> Joshua S. Hodas and Dale Miller. </author> <title> Logic Programming in a Fragment of Linear Logic. </title> <journal> Journal of Information and Computation, </journal> <volume> 110(2) </volume> <pages> 327-365, </pages> <year> 1994. </year>
Reference-contexts: In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category. Consequently, several logic programming languages based on linear logic have been designed in the last five years <ref> [1, 3, 6, 10] </ref>. Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. <p> Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. However, to our knowledge, usable implementations have thus far been released only for Lolli <ref> [6] </ref> and Lygon [3]. Linear logic programming languages offer the implementor new challenges not present in more traditional logic languages such as Prolog or Prolog. <p> We do not treat other sources of non-determinism, which can be handled according to standard techniques in a logic programming framework, or that we might want to keep open in a theorem prover. We will focus our attention on the language Lolli <ref> [5, 6] </ref>, that we used to test the techniques described below. However, our results have already been applied to a prototype implementation of a programming language based on Miller's specification logic Forum [10], and should apply equally well to implementations of other linear logic programming languages such as Lygon [3]. <p> We believe these results are simple enough to be reconstructed by the reader, who is referred to Hodas' dissertation [5] for proofs relevant to the first two systems. 2 Resolution for Linear Hereditary Harrop Formulas The programming language Lolli <ref> [5, 6] </ref> is based on the fragment of linear logic freely generated by the operators &gt;, &, ffi, and 8. The connective is called intuitionistic implication and is defined as A B !A ffi B. <p> Hodas and Miller discuss a proof system, L, for LHHF based on sequents of this form <ref> [6] </ref>. They also prove the soundness and completeness of L with respect to the usual rules for linear logic restricted to the language of LHHF . <p> The rules in the bottom section of Fig. 1 describe how to reduce non-atomic goal formulas. They stem from the right introduction rules of linear logic, and are essentially identical to the right rules for L 0 <ref> [6] </ref>. R differs from L 0 in the treatment of atomic goal formulas. In order to solve these goals, Hodas and Miller rely on the function k k, which converts a formula in the program to a (possibly infinite) set of clauses, each defining a single ground atom. <p> Assume that contains n formulas. Then there are 2 n possible splits. In the worst case, finding a workable split (or determining that none exists) will require trying them all. This problem was given a deterministic solution by Hodas and Miller in <ref> [6] </ref> in what they called the I/O model of execution for Lolli. We will instead use the name resource management system and refer to this deduction system as RM 1 . <p> In their original paper, Hodas and Miller write this judgment IfGgO, with G being the goal formula, and I and O being the input and the output contexts respectively <ref> [6] </ref>. The main difference with respect to our judgment is that in their presentation I and O are lists of items that can be either program formulas or the special constant del. This is very close to their original Prolog implementation of LHHF. <p> If it contains n formulas, we are left with 2 n possible output contexts O that might be passed to the remaining computation. Hodas and Miller initially underestimated the importance of this issue <ref> [6] </ref>. However the subsequent development of sample applications to accompany the first public release of Lolli showed this problem to be critical in practice. The solution we describe is adapted from Hodas' dissertation [5], and was incorporated into that implementation. <p> The declarative nature of the rules makes these same ideas applicable to implementations based on other programming paradigms. In particular, the original Prolog prototype for Lolli <ref> [6] </ref> can be easily adapted to take advantage of these observations. 6 Conclusions and Related Work The issue of efficient context management has proved to be crucial for the use of linear logic programming languages in non-trivial applications.
Reference: 7. <author> Keehang Kwon. </author> <title> Towards a Verified Abstract Machine for a Logic Programming Language with a Notion of Scope. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Duke University, </institution> <month> December </month> <year> 1994. </year> <note> Available as Technical Report CS-1994-36. </note>
Reference-contexts: Our analysis was motivated primarily the goal of building an efficient interpreter, but should also be applicable to the design of compilers which, of course, will ultimately be necessary for the execution of large programs. We expect that compilation techniques developed for Prolog [8] and Prolog <ref> [7, 12] </ref> may be combined with our methods. The results described in the paper can be applied to other programming languages based on linear logic. Hodas and Polakow have extended the system RM 3 to Miller's specification logic Forum [10] and have based a prototype implementation on it.
Reference: 8. <author> Timothy G. Lindholm and Richard A. O'Keefe. </author> <title> Efficient Implementation of a Defensible Semantics for Dynamic Prolog Code. </title> <booktitle> Proceedings of the Fourth International Conference on Logic Programming, J.L. Lassez, </booktitle> <publisher> ed., </publisher> <pages> pp 21-39, </pages> <publisher> MIT Press 1987. </publisher>
Reference-contexts: Our analysis was motivated primarily the goal of building an efficient interpreter, but should also be applicable to the design of compilers which, of course, will ultimately be necessary for the execution of large programs. We expect that compilation techniques developed for Prolog <ref> [8] </ref> and Prolog [7, 12] may be combined with our methods. The results described in the paper can be applied to other programming languages based on linear logic.
Reference: 9. <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <editor> In P. Schroder-Heister editor, </editor> <booktitle> Proceedings of the International Workshop on Proof-Theoretical Extensions of Logic Programming, </booktitle> <pages> pages 253-281, </pages> <address> Tubingen, Germany, 1989, </address> <publisher> Springer-Verlag LNAI 475. </publisher>
Reference-contexts: This issue is particularly simple in Prolog: The only predicates that can modify the program are the extra-logicals assert and retract, which have global effect. In languages admitting implications in goals, Prolog <ref> [9] </ref> and Elf [13] for example, the use of scoped assumptions causes the program to grow and contract like a stack. The matter is more complicated in the case of linear logic due to the strict rules placed on the use and reuse of assumptions.
Reference: 10. <author> Dale Miller. </author> <title> A Multiple-Conclusion Meta-Logic. </title> <booktitle> Proceedings of the 1994 Symposium on Logics in Computer Science, </booktitle> <editor> S. Abramsky, </editor> <publisher> ed., </publisher> <pages> pp. 272-281. </pages>
Reference-contexts: In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category. Consequently, several logic programming languages based on linear logic have been designed in the last five years <ref> [1, 3, 6, 10] </ref>. Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. <p> We will focus our attention on the language Lolli [5, 6], that we used to test the techniques described below. However, our results have already been applied to a prototype implementation of a programming language based on Miller's specification logic Forum <ref> [10] </ref>, and should apply equally well to implementations of other linear logic programming languages such as Lygon [3]. It is also possible to adapt these techniques to the development of theorem provers for linear logic. <p> The results described in the paper can be applied to other programming languages based on linear logic. Hodas and Polakow have extended the system RM 3 to Miller's specification logic Forum <ref> [10] </ref> and have based a prototype implementation on it. These techniques should extend just as easily to implementations of Lygon [3, 4] and other linear languages. Finally, since Forum is complete for all of classical linear logic, they are also clearly applicable to the design of theorem provers.
Reference: 11. <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming, </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: Similarly, the variable x does not appear free in a in rule 8 d . 3 tional properties to be considered an abstract logic programming language <ref> [11] </ref>. In particular, every proof in L can be transformed into an equivalent proof that consults the program only when the goal formula is atomic (thus proofs are goal-directed [11]), and at that point selects and operates upon a single program formula in order to proceed with the derivation (thus proofs <p> not appear free in a in rule 8 d . 3 tional properties to be considered an abstract logic programming language <ref> [11] </ref>. In particular, every proof in L can be transformed into an equivalent proof that consults the program only when the goal formula is atomic (thus proofs are goal-directed [11]), and at that point selects and operates upon a single program formula in order to proceed with the derivation (thus proofs are focused [1]). Proofs with both properties are called uniform.
Reference: 12. <author> Gopalan Nadathur, Bharat Jayaraman, and Keehang Kwon. </author> <title> Scoping constructs in logic programming: Implementation problems and their solution. </title> <type> Technical Report CS-1994-35, </type> <institution> Department of Computer Science, Duke University, </institution> <month> October </month> <year> 1994. </year> <note> To appear in Journal of Logic Programming. </note>
Reference-contexts: Our analysis was motivated primarily the goal of building an efficient interpreter, but should also be applicable to the design of compilers which, of course, will ultimately be necessary for the execution of large programs. We expect that compilation techniques developed for Prolog [8] and Prolog <ref> [7, 12] </ref> may be combined with our methods. The results described in the paper can be applied to other programming languages based on linear logic. Hodas and Polakow have extended the system RM 3 to Miller's specification logic Forum [10] and have based a prototype implementation on it.
Reference: 13. <author> Frank Pfenning. </author> <title> Elf: A meta-language for deductive systems. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 811-815, </pages> <address> Nancy, France, </address> <month> June </month> <year> 1994. </year> <note> Springer-Verlag LNAI 814. System abstract. 15 </note>
Reference-contexts: This issue is particularly simple in Prolog: The only predicates that can modify the program are the extra-logicals assert and retract, which have global effect. In languages admitting implications in goals, Prolog [9] and Elf <ref> [13] </ref> for example, the use of scoped assumptions causes the program to grow and contract like a stack. The matter is more complicated in the case of linear logic due to the strict rules placed on the use and reuse of assumptions.
References-found: 13

