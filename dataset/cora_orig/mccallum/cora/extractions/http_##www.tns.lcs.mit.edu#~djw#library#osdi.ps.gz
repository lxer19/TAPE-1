URL: http://www.tns.lcs.mit.edu/~djw/library/osdi.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/
Root-URL: 
Email: fnecula,petelg@cs.cmu.edu  
Title: Safe Kernel Extensions Without Run-Time Checking  
Author: George C. Necula Peter Lee 
Date: October 28-31, 1996.  
Note: Submitted to the Second Symposium on Operating Systems Design and Implementation (OSDI '96), Seattle, Washington,  
Address: Pittsburgh, Pennsylvania 15213-3891  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: This paper describes a mechanism by which an opera-ting-system kernel can determine with certainty that it is safe to execute a binary supplied by an untrusted source. The kernel first defines a safety policy and makes it public. Then, using this policy, an application can provide binaries in a special form called self-certified code, or simply SCC. Each SCC binary contains, in addition to the native code, a safety certificate that attests to the code's safety properties. The kernel can easily validate a certificate without using cryptography and without consulting any external trusted entities. If the validation succeeds, the code is guaranteed to respect the safety policy without relying on run-time checks. The main practical difficulty of SCC is in generating the certificates. In order to gain some preliminary experience with this, we have written several network packet filters in hand-tuned DEC Alpha assembly language, and then generated SCC binaries for them using a special prototype assembler. The SCC binaries can be executed with no run-time overhead, beyond a one-time cost of 1 to 4 milliseconds for validating the enclosed certificates. The net result is that our packet filters are formally guaranteed to be safe and are faster than packet filters created using Berkeley Packet Filters, Software Fault Isolation, or safe languages such as Modula-3. This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software," ARPA Order No. C533, issued by ESC/ENS under Contract No. F19628-95-C-0050. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Advanced Research Projects Agency or the U.S. Government. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bershad, B., Savage, S., Pardyak, P., Sirer, E. G., Becker, D., Fiuczynski, M., Chambers, C., and Eggers, S. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Symposium on Operating System Principles (De-cember 1995), </booktitle> <pages> pp. 267-284. </pages>
Reference-contexts: This methodology could be used to do off-line SFI. Certificate sizes and validation times are very similar to those for plain SCC packets. Another approach to safe code is to use a type-safe programming language. This approach is taken by the SPIN <ref> [1] </ref> operating system, and the language used is Modula-3 [15]. SPIN allows applications to install extensions in the kernel but only if they are written in the safe subset of Modula-3.
Reference: [2] <author> Constable, R. L., Allen, S. F., Bromley, H. M., Cleaveland, W. R., Cremer, J. F., </author> <title> 3 This is essentially the same as having a compiler translate the types as well as the code, so that the target program will have types that can be checked. In fact, this approach to compiling is taken by the SML/TIL compiler [19]. </title> <note> 13 Harper, </note> <author> R. W., Howe, D. J., Knoblock, T. B., Mendler, N. P., Panangaden, P., Sasaki, J. T., and Smith, S. F. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference: [3] <author> Dijkstra, E. W. </author> <title> Guarded commands, nondeter minancy and formal derivation of programs. </title> <booktitle> Communications of the ACM 18 (1975), </booktitle> <pages> 453-457. </pages>
Reference-contexts: Still, it would be much better to use more sophisticated theorem-proving technology. One of the simplifications in the packet filters is to restrict programs so that they do not contain loops. Although the general framework presented in this paper is easily extended to accommodate loops <ref> [3] </ref>, this introduces a number of complications. One experiment we conducted involves an IP-header checksum routine, which is hand-coded in 39 DEC Alpha instructions. The core loop contains 8 instructions, and is optimized by computing the 16-bit IP checksum using 64-bit additions followed by a folding operation.
Reference: [4] <author> Dijkstra, E. W. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference: [5] <author> Engler, D. R., Wallach, D., and Kaashoek, M. F. </author> <title> Efficient, safe, application-specific message processing. </title> <type> Technical Memorandum MIT/LCS/TM533, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: It is possible, of course, to eliminate the need for interpretation. For example, we could replace the packet-filter interpreter with a compiler. This approach is taken by several researchers <ref> [5, 8] </ref>. The problem here is the start-up cost and complexity of compilation, especially if serious optimizations are performed. Another approach to safe code execution is Software Fault Isolation (SFI) [20]. SFI is an inexpensive method for parsing binaries and inserting run-time checks for every memory operation.
Reference: [6] <author> Harper, R., Honsell, F., and Plotkin, G. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery 40, </journal> <month> 1 (Jan. </month> <year> 1993), </year> <pages> 143-184. </pages>
Reference: [7] <author> Hoare, C. A. R. </author> <title> An axiomatic basis for com puter programming. </title> <booktitle> Communications of the ACM 12 (1969), </booktitle> <pages> 567-580. </pages>
Reference: [8] <author> Lee, P., and Leone, M. </author> <title> Optimizing ML with run-time code generation. </title> <booktitle> In PLDI'96 Conference on Programming Language Design and Implementation (May 1996). </booktitle>
Reference-contexts: It is possible, of course, to eliminate the need for interpretation. For example, we could replace the packet-filter interpreter with a compiler. This approach is taken by several researchers <ref> [5, 8] </ref>. The problem here is the start-up cost and complexity of compilation, especially if serious optimizations are performed. Another approach to safe code execution is Software Fault Isolation (SFI) [20]. SFI is an inexpensive method for parsing binaries and inserting run-time checks for every memory operation.
Reference: [9] <author> Martin-L of, P. </author> <title> A theory of types. </title> <type> Technical Re port 71-3, </type> <institution> Department of Mathematics, University of Stockholm, </institution> <year> 1971. </year>
Reference: [10] <author> McCanne, S. </author> <title> The Berkeley Packet Fil ter man page. </title> <note> BPF distribution available at ftp://ftp.ee.lbl.gov. </note>
Reference: [11] <author> McCanne, S., and Jacobson, V. </author> <title> The BSD packet filter: A new architecture for user-level packet capture. </title> <booktitle> In The Winter 1993 USENIX Conference (January 1993), USENIX Association, </booktitle> <pages> pp. 259-269. </pages>
Reference-contexts: The standard way to ensure safe execution of packet filters is to interpret the filter and perform extensive run-time checks. This approach is best exemplified by the BSD Packet Filter architecture <ref> [11] </ref>, commonly referred to as BPF. In the BPF approach the filter is encoded in a restricted accumulator-based language. According to the BPF semantics, a filter that attempts to read outside the packet or the scratch memory, or to write outside the scratch memory, is terminated and the packet rejected.
Reference: [12] <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: In the formal definition of SML <ref> [12] </ref>, a formal theorem guarantees the safety of any type-correct SML program, for a rigorously defined notion of safety.
Reference: [13] <author> Mogul, J. C., Rashid, R. F., and Accetta, M. J. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In ACM Symposium on Operating Systems Principles (November 1987), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 39-51. </pages> <note> An updated version is available as DEC WRL Research Report 87/2. </note>
Reference-contexts: introduction in <ref> [13] </ref>, packet filters have been used successfully in network monitoring and diagnosis. In the SCC approach the packet filter is an SCC binary whose native code component is invoked by the kernel on each incoming network packet. Kernel safety is ensured by validating the safety certificate.
Reference: [14] <author> Necula, G. C., and Lee, P. </author> <title> Self-certified code. </title> <type> Technical report, </type> <institution> Computer Science Department, Carnegie Mellon University, </institution> <year> 1996. </year> <note> In preparation. </note>
Reference-contexts: a few optimizations that we incorporated in our packet filters: * The number of memory operations is minimized by using the DEC Alpha 64-bit load followed by byte extraction. * The TCP port number can be found at packet off set (<ref> [14] </ref> 8 & 15) fl 4 + 16, where [14] 8 denotes the byte at offset 14. If loading 64 bits at a time on a low-endian machine, the formula becomes ((([8] 64 48) & 255) & 15) fl 4 + 16.
Reference: [15] <author> Nelson, G. </author> <title> Systems Programming with MODULA-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Certificate sizes and validation times are very similar to those for plain SCC packets. Another approach to safe code is to use a type-safe programming language. This approach is taken by the SPIN [1] operating system, and the language used is Modula-3 <ref> [15] </ref>. SPIN allows applications to install extensions in the kernel but only if they are written in the safe subset of Modula-3. The extensions are compiled by a trusted compiler and the resulting executable code is then believed to be safe (at least according to the Modula-3 model of safety). <p> In the formal definition of SML [12], a formal theorem guarantees the safety of any type-correct SML program, for a rigorously defined notion of safety. There are, of course, many other type-safe programming languages, for example Modula-3 <ref> [15] </ref> and Java [17], but the use of mathematical formalism sets SML apart from the these languages, and as a practical matter this rigor provides the basic conceptual and technical foundations that we need to create checkable certificates.
Reference: [16] <author> Sites, R. L. </author> <title> Alpha Architecture Reference Man ual. </title> <publisher> Digital Press, </publisher> <year> 1992. </year>
Reference: [17] <author> Sun Microsystems. </author> <title> The Java language specifi cation. </title> <note> Available as ftp://ftp.javasoft.com/docs/javaspec.ps.zip, </note> <year> 1995. </year>
Reference-contexts: In the formal definition of SML [12], a formal theorem guarantees the safety of any type-correct SML program, for a rigorously defined notion of safety. There are, of course, many other type-safe programming languages, for example Modula-3 [15] and Java <ref> [17] </ref>, but the use of mathematical formalism sets SML apart from the these languages, and as a practical matter this rigor provides the basic conceptual and technical foundations that we need to create checkable certificates.
Reference: [18] <author> Sun Microsystems. </author> <title> The Java Virtual Machine specification. </title> <note> Available as ftp://ftp.javasoft.com/docs/vmspec.ps.zip, </note> <year> 1995. </year>
Reference-contexts: On average, SCC packet filters are five times faster than the Modula-3 packet filters. We should mention here one more approach to safe code execution, although we do not have an actual quantitative comparison. The Java Virtual Machine <ref> [18] </ref> is one proposed solution to safe interaction of distributed, untrusted agents. Mobile code is encoded in the Java Virtual Machine Language (also referred to as Java Byte-code), which is basically a safe low-level imperative language. Safety is achieved through a combination of static typechecking and run-time checking.
Reference: [19] <author> Tarditi, D., Morrisett, J. G., Cheng, P., Stone, C., Harper, R., and Lee, P. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In PLDI'96 Conference on Programming Language Design and Implementation (May 1996). </booktitle>
Reference: [20] <author> Wahbe, R., Lucco, S., Anderson, T. E., and Graham, S. L. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In 14th ACM Symposium on Operating Systems Principles (December 1993), ACM, </booktitle> <pages> pp. 203-216. 14 </pages>
Reference-contexts: For example, we could replace the packet-filter interpreter with a compiler. This approach is taken by several researchers [5, 8]. The problem here is the start-up cost and complexity of compilation, especially if serious optimizations are performed. Another approach to safe code execution is Software Fault Isolation (SFI) <ref> [20] </ref>. SFI is an inexpensive method for parsing binaries and inserting run-time checks for every memory operation. There are many flavors of SFI depending on the desired level of memory safety. <p> If, on the other hand, the untrusted code interacts frequently with the code consumer or other untrusted components residing in different protection domains and the read operations must be checked also, the overhead of the run-time checks can amount to 20% <ref> [20] </ref>. A more serious disadvantage of SFI is that it can only ensure memory safety.
References-found: 20

