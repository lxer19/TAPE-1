URL: ftp://ftp.eecs.umich.edu/groups/gasm/pvm.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: boerger@di.unipi.it  glaesser@uni-paderborn.de  
Title: Modelling and Analysis of Distributed and Reactive Systems using Evolving Algebras  
Author: Egon Borger Uwe Glasser 
Date: July 19, 1995  
Address: 56125 Pisa, Italy  33098 Paderborn, Germany  
Affiliation: Dipartimento di Informatica Universita di Pisa  Heinz Nixdorf Institut Universitat-GH Paderborn  
Abstract: This is a tutorial introduction into the evolving algebra approach to design and verification of complex computing systems. It is written to be used by the working computer scientist. We explain the salient features of the methodology by showing how one can develop from scratch an easily understandable and transparent evolving algebra model for PVM, the widespread virtual architecture for heterogeneous distributed computing.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ch. Beierle and E. Borger. </author> <title> A WAM extension for type-constraint logic programming: Specification and correctness proof. </title> <type> Research report IWBS 200, </type> <institution> IBM Germany Science Center, </institution> <address> Heidelberg, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: a result the abstract PROLOG model of [15] and its refinement to the WAM model of [16] could easily be extended to constraint logic programming languages with or without types where unifiability appears as a particular case of constraints (see the formal evolving algebra definitions of PROLOG III [18], Protos-L <ref> [1] </ref>, and CLP (R) [17]).
Reference: [2] <author> Ch. Beierle, E. Borger, I. D - urd -anovic U. Glasser, and E. Riccobene. </author> <title> An evolving algebra solution to the steam-boiler control specification problem. Seminar on Methods for Specification and Semantics (Dagstuhl, </title> <month> June </month> <year> 1995), </year> <type> Report, </type> <year> 1995. </year> <month> 24 </month>
Reference-contexts: For an interesting although small example of such a system see the evolving algebra specification of the steam-boiler control which has been refined leading from the ground model to a running C ++ program (see <ref> [2] </ref>). A more involved example is constituted by the problem of faithfully defining the standard for a programming language, i.e. in an easy to understand but precise and complete way.
Reference: [3] <author> E. Borger. </author> <title> Logic Programming: The Evolving Algebra Approach. </title> <editor> In B. Pehrson and I. Simon (Eds.) </editor> <booktitle> IFIP 13th World Computer Congress 1994, Volume I: </booktitle> <address> Technology/Foundations, </address> <publisher> Elsevier, Amsterdam, </publisher> <pages> 391-395. </pages>
Reference-contexts: from TID kill process (pid (task (Tid ))) else forward kill msghTid i to pvmd (Tid ) 22 kill msghi if event (pvmd) = kill msghTid i from pvmd 0 then delete Tid from TID kill process (pid (task (Tid ))) 4 Appropriate Ground Models As has been observed in <ref> [3, 21] </ref> evolving algebras fit in a special way when it comes to link a non-formal system description S (requirements specification) to a formal model S 0 which has to be recognized as faithful formalization of S.
Reference: [4] <author> E. Borger. </author> <title> Annotated bibliography on evolving algebras. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Introduction In 1988 Yuri Gurevich has discovered the notion of evolving algebra in an attempt to sharpen Turing's thesis by complexity theoretic considerations (see [22]). Through numerous case studies (see <ref> [4] </ref> for an annotated list which is complete up to 1994) it has become clear since then that using the notion of evolving algebras one can develop a powerful and elegant specification methodology which has a huge yet unexplored potential for industrial applications.
Reference: [5] <author> E. Borger and G. Del Castillo. </author> <title> A formal method for provably correct composition of a real-life processor out of basic components (The APE100 reverse engineering project). </title> <booktitle> In Proc. of the First IEEE International Conference on Engineering of Complex Computer Systems (ICECCS'95). </booktitle>
Reference-contexts: This freedom explains the success of the simple and transparent evolving algebra models for the semantics and the implementation of numerous complex programming languages like Prolog [15, 16], C [24], VHDL [11], Occam [9, 8], for protocols [12, 27], architectures <ref> [6, 5, 13] </ref>, real-time algorithms [25, 26], etc. The importance of the freedom of abstraction which is offered through the notion of evolving algebra is also confirmed by a common experience in the design of algorithms. <p> Nothing prevents us from restricting this notion to specific and even syntactic concepts of compositionality where the need arises; an example where it turned out to be useful to stick to a simple automaton-theoretic concept of composition of evolving algebras through sequencing, juxtaposition, and feedback can be found in <ref> [5] </ref>. 3 Locality for Dynamics It is typical for large systems that their overall dynamical behaviour is determined by the dynamic behaviour of their components, i.e. by local changes.
Reference: [6] <author> Egon Borger, Giuseppe Del Castillo, Paola Glavan, and Dean Rosenzweig. </author> <title> Towards a mathematical specification of the APE100 architecture: The APESE model. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> Proc. of the IFIP 13th World Computer Congress 1994, Volume I: Technology and Foundations, </booktitle> <pages> pages 396-401. </pages> <publisher> Elsevier Science Publishers B. V., </publisher> <year> 1994. </year>
Reference-contexts: This freedom explains the success of the simple and transparent evolving algebra models for the semantics and the implementation of numerous complex programming languages like Prolog [15, 16], C [24], VHDL [11], Occam [9, 8], for protocols [12, 27], architectures <ref> [6, 5, 13] </ref>, real-time algorithms [25, 26], etc. The importance of the freedom of abstraction which is offered through the notion of evolving algebra is also confirmed by a common experience in the design of algorithms.
Reference: [7] <author> E. Borger and B. Demoen. </author> <title> A framework to specify database update views for Prolog. </title> <editor> In M. J. Maluszynski, editor, PLILP'91. </editor> <booktitle> Third International Symposium on Programming Languages Implementation and Logic Programming, volume 528 of Lecture Notes in Computer Science, </booktitle> <pages> pages 147-158. </pages> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: If we want to model also Prolog's program modification features then procdef becomes an internal dynamic function (see <ref> [7, 14] </ref>). Note that during the refinement process by which the Prolog model of [15] is linked in a provably correct way to the WAM implementation model in [16] the function procdef receives an explicit definition.
Reference: [8] <author> E. Borger and I. D - urd -anovic. </author> <title> Correctness of compiling Occam to Trans-puter code. </title> <note> 1995 (submitted). </note>
Reference-contexts: This freedom explains the success of the simple and transparent evolving algebra models for the semantics and the implementation of numerous complex programming languages like Prolog [15, 16], C [24], VHDL [11], Occam <ref> [9, 8] </ref>, for protocols [12, 27], architectures [6, 5, 13], real-time algorithms [25, 26], etc. The importance of the freedom of abstraction which is offered through the notion of evolving algebra is also confirmed by a common experience in the design of algorithms. <p> In both cases the recursive definitions replace rather complex algorithmic characterizations in the VHDL'93 language reference manual [28]. * In the abstract evolving algebra models of Occam (see [9]) which are the starting point for the correctness proof of a compilation scheme into Transputer instructions in <ref> [8] </ref> we have taken great advantage of the usual flowchart layout of programs; we define it by external functions which in the later refinement steps are replaced by recursive definitions of the compiling function.
Reference: [9] <author> E. Borger, I. D - urd -anovic, and D. Rosenzweig. </author> <title> Occam: Specification and compiler correctness. part i: The primary model. </title> <editor> In E.-R. Olderog, editor, </editor> <booktitle> Proc. of PROCOMET'94 (IFIP Working Conference on Programming Concepts, Methods and Calculi), </booktitle> <pages> pages 489-508. </pages> <publisher> North-Holland, </publisher> <year> 1994. </year>
Reference-contexts: This freedom explains the success of the simple and transparent evolving algebra models for the semantics and the implementation of numerous complex programming languages like Prolog [15, 16], C [24], VHDL [11], Occam <ref> [9, 8] </ref>, for protocols [12, 27], architectures [6, 5, 13], real-time algorithms [25, 26], etc. The importance of the freedom of abstraction which is offered through the notion of evolving algebra is also confirmed by a common experience in the design of algorithms. <p> In both cases the recursive definitions replace rather complex algorithmic characterizations in the VHDL'93 language reference manual [28]. * In the abstract evolving algebra models of Occam (see <ref> [9] </ref>) which are the starting point for the correctness proof of a compilation scheme into Transputer instructions in [8] we have taken great advantage of the usual flowchart layout of programs; we define it by external functions which in the later refinement steps are replaced by recursive definitions of the compiling
Reference: [10] <author> E. Borger and U.Glasser. </author> <title> A formal specification of the PVM architecture. </title> <editor> In B. Pehrson and I. Simon (Eds.) </editor> <booktitle> IFIP 13th World Computer Congress 1994, Volume I: </booktitle> <address> Technology/Foundations, </address> <publisher> Elsevier, Amsterdam, </publisher> <pages> 402-409. </pages>
Reference-contexts: For the the PVM features that have been discussed here, the differences in the functional behaviour of these two types of pvmds are irrelevant. 6 Conclusions Continuing the work started in <ref> [10] </ref> we have defined a formal model for PVM from scratch. The goal was to illustrate some outstanding merits of the evolving algebra methodology to design and analysis of complex computer systems.
Reference: [11] <author> E. Borger, U. Glasser, and W. Mueller. </author> <title> Formal definition of an abstract VHDL'93 simulator by EA-machines. </title> <editor> In C. Delgado Kloos and Peter T. Breuer, editors, </editor> <booktitle> Semantics of VHDL, volume 307 of The Kluwer International Series in Engineering and Computer Science. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference-contexts: This freedom explains the success of the simple and transparent evolving algebra models for the semantics and the implementation of numerous complex programming languages like Prolog [15, 16], C [24], VHDL <ref> [11] </ref>, Occam [9, 8], for protocols [12, 27], architectures [6, 5, 13], real-time algorithms [25, 26], etc. The importance of the freedom of abstraction which is offered through the notion of evolving algebra is also confirmed by a common experience in the design of algorithms. <p> A more involved example is constituted by the problem of faithfully defining the standard for a programming language, i.e. in an easy to understand but precise and complete way. For the ISO Prolog Standard published in 1995 and the IEEE VHDL'93 Standard evolving algebra ground models appear in <ref> [15, 11] </ref>. 5 Distributed Evolving Algebras In this section we resume the preceding discussion by the definition of distributed evolving algebras, taken from [23] to which we refer for details.
Reference: [12] <author> E. Borger, Y. Gurevich, and D. Rosenzweig. </author> <title> The bakery algorithm: Yet another specification and verification. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: This freedom explains the success of the simple and transparent evolving algebra models for the semantics and the implementation of numerous complex programming languages like Prolog [15, 16], C [24], VHDL [11], Occam [9, 8], for protocols <ref> [12, 27] </ref>, architectures [6, 5, 13], real-time algorithms [25, 26], etc. The importance of the freedom of abstraction which is offered through the notion of evolving algebra is also confirmed by a common experience in the design of algorithms. <p> by leaving the evaluation and compilation of expressions and the implementation of values abstract, realized by appropriately restricted external functions. * In the more theoretical example constituted by Lamport's mutual exclusion protocol, known as bakery algorithm, a tremendous simplification of the correctness proofs in the literature has been achieved in <ref> [12] </ref> by introducing two external functions, namely Ticket and Go, on which three natural conditions and an induction principle are imposed which imply the correctness of the protocol.
Reference: [13] <author> E. Borger and S. Mazzanti. </author> <title> A correctness proof for pipelining in RISC architectures. </title> <type> Manuscript, </type> <year> 1995. </year> <month> 25 </month>
Reference-contexts: This freedom explains the success of the simple and transparent evolving algebra models for the semantics and the implementation of numerous complex programming languages like Prolog [15, 16], C [24], VHDL [11], Occam [9, 8], for protocols [12, 27], architectures <ref> [6, 5, 13] </ref>, real-time algorithms [25, 26], etc. The importance of the freedom of abstraction which is offered through the notion of evolving algebra is also confirmed by a common experience in the design of algorithms.
Reference: [14] <author> E. Borger and D. Rosenzweig. </author> <title> An analysis of Prolog database views and their uniform implementation. </title> <type> Research report CSE-TR-89-91, </type> <institution> EECS, University of Michigan, </institution> <address> Ann Arbor MI, </address> <year> 1991. </year>
Reference-contexts: If we want to model also Prolog's program modification features then procdef becomes an internal dynamic function (see <ref> [7, 14] </ref>). Note that during the refinement process by which the Prolog model of [15] is linked in a provably correct way to the WAM implementation model in [16] the function procdef receives an explicit definition.
Reference: [15] <author> E. Borger and D. Rosenzweig. </author> <title> A mathematical definition of full Prolog. </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1995. </year>
Reference-contexts: A priori no restriction is imposed on the abstraction level where one might want to place an evolving algebra description of a system. This freedom explains the success of the simple and transparent evolving algebra models for the semantics and the implementation of numerous complex programming languages like Prolog <ref> [15, 16] </ref>, C [24], VHDL [11], Occam [9, 8], for protocols [12, 27], architectures [6, 5, 13], real-time algorithms [25, 26], etc. The importance of the freedom of abstraction which is offered through the notion of evolving algebra is also confirmed by a common experience in the design of algorithms. <p> The power of abstraction which is offered through the introduction of external functions does not depend on their being dynamic. Consider as example the formal definition given in <ref> [15] </ref> for the programming language Prolog as seen by the programmer. The four simple rules which define the full behaviour of Prolog for user-defined predicates make crucial use of two external functions procdef and unify. <p> If we want to model also Prolog's program modification features then procdef becomes an internal dynamic function (see [7, 14]). Note that during the refinement process by which the Prolog model of <ref> [15] </ref> is linked in a provably correct way to the WAM implementation model in [16] the function procdef receives an explicit definition. The function unify is supposed in [15] to provide for each pair of literals either a unifying substitution or the information that there is no such unification. <p> Note that during the refinement process by which the Prolog model of <ref> [15] </ref> is linked in a provably correct way to the WAM implementation model in [16] the function procdef receives an explicit definition. The function unify is supposed in [15] to provide for each pair of literals either a unifying substitution or the information that there is no such unification. This function describes the abstract behaviour of unification without being bound to any concrete unification algorithm. <p> This function describes the abstract behaviour of unification without being bound to any concrete unification algorithm. It also hides from the programmer the details about the representation of termes which appear in the refined WAM models of [16]. As a result the abstract PROLOG model of <ref> [15] </ref> and its refinement to the WAM model of [16] could easily be extended to constraint logic programming languages with or without types where unifiability appears as a particular case of constraints (see the formal evolving algebra definitions of PROLOG III [18], Protos-L [1], and CLP (R) [17]). <p> Other examples of external functions which contributed in a crucial way to the simplicity of the models under consideration are the following: * the static find-catcher function defined in <ref> [15] </ref> leads to a concise formal ization of the error-handling predicates catch and throw of Prolog. * In the evolving algebra model for the IEEE VHDL Standard we have obtained a simple and uniform rule set for signal assignments by intro 12 ducing for the inertial delay an external static function <p> A more involved example is constituted by the problem of faithfully defining the standard for a programming language, i.e. in an easy to understand but precise and complete way. For the ISO Prolog Standard published in 1995 and the IEEE VHDL'93 Standard evolving algebra ground models appear in <ref> [15, 11] </ref>. 5 Distributed Evolving Algebras In this section we resume the preceding discussion by the definition of distributed evolving algebras, taken from [23] to which we refer for details.
Reference: [16] <author> E. Borger and D. Rosenzweig. </author> <title> The WAM definition and compiler correctness. </title> <editor> In L. C. Beierle and L. Plumer, editors, </editor> <booktitle> Logic Programming: Formal Methods and Practical Applications, Series in Computer Science and Artificial Intelligence. </booktitle> <publisher> Elsevier Science B.V./North-Holland, </publisher> <year> 1995. </year>
Reference-contexts: A priori no restriction is imposed on the abstraction level where one might want to place an evolving algebra description of a system. This freedom explains the success of the simple and transparent evolving algebra models for the semantics and the implementation of numerous complex programming languages like Prolog <ref> [15, 16] </ref>, C [24], VHDL [11], Occam [9, 8], for protocols [12, 27], architectures [6, 5, 13], real-time algorithms [25, 26], etc. The importance of the freedom of abstraction which is offered through the notion of evolving algebra is also confirmed by a common experience in the design of algorithms. <p> If we want to model also Prolog's program modification features then procdef becomes an internal dynamic function (see [7, 14]). Note that during the refinement process by which the Prolog model of [15] is linked in a provably correct way to the WAM implementation model in <ref> [16] </ref> the function procdef receives an explicit definition. The function unify is supposed in [15] to provide for each pair of literals either a unifying substitution or the information that there is no such unification. <p> This function describes the abstract behaviour of unification without being bound to any concrete unification algorithm. It also hides from the programmer the details about the representation of termes which appear in the refined WAM models of <ref> [16] </ref>. As a result the abstract PROLOG model of [15] and its refinement to the WAM model of [16] could easily be extended to constraint logic programming languages with or without types where unifiability appears as a particular case of constraints (see the formal evolving algebra definitions of PROLOG III [18], <p> It also hides from the programmer the details about the representation of termes which appear in the refined WAM models of <ref> [16] </ref>. As a result the abstract PROLOG model of [15] and its refinement to the WAM model of [16] could easily be extended to constraint logic programming languages with or without types where unifiability appears as a particular case of constraints (see the formal evolving algebra definitions of PROLOG III [18], Protos-L [1], and CLP (R) [17]).
Reference: [17] <author> E. Borger and R. Salamone. </author> <title> CLAM specification for provably correct compilation of CLP(R) programs. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: PROLOG model of [15] and its refinement to the WAM model of [16] could easily be extended to constraint logic programming languages with or without types where unifiability appears as a particular case of constraints (see the formal evolving algebra definitions of PROLOG III [18], Protos-L [1], and CLP (R) <ref> [17] </ref>).
Reference: [18] <author> E. Borger and P. Schmitt. </author> <title> A formal operational semantics for languages of type Prolog III. </title> <editor> In E. Borger, H. Kleine Buning, M. M. Richter, and W. Schonfeld, editors, CSL'90, </editor> <booktitle> 4th Workshop on Computer Science Logic, volume 533 of Lecture Notes in Computer Science, </booktitle> <pages> pages 67-79. </pages> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: As a result the abstract PROLOG model of [15] and its refinement to the WAM model of [16] could easily be extended to constraint logic programming languages with or without types where unifiability appears as a particular case of constraints (see the formal evolving algebra definitions of PROLOG III <ref> [18] </ref>, Protos-L [1], and CLP (R) [17]).
Reference: [19] <author> A. Geist, A. Beguelin, J. Dongarra, W. Jiang, B. Manchek, and V. Sun-deram. </author> <title> PVM 3 User's Guide and Reference Manual. </title> <type> Technical Report ORNL/TM-12187, </type> <institution> Oak Ridge National Laboratory, Oak Ridge, Tennessee 37831, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: These sets can be completely abstract|this is the case if no restriction 1 More precisely, we specify the C-interface of the virtual machine of PVM 3, the current version of PVM <ref> [19] </ref>. 2 is imposed on the corresponding category of objects. <p> The architecture of each host machine is indicated by a function arch : HOST ! ARCH where ARCH is the set of possible architectures to be used with PVM 3 as listed in <ref> [19] </ref>. An important feature which distinguishes the universe HOST from ARCH is that the latter is static|i.e. it does not change|whereas the former is dynamic. <p> BUFID ! ENCODING = fPvmDataDefault; PvmDataRaw; PvmDataInPlaceg, associated to send buffers, specifies the method used for packing messages: PvmDataDefault refers to External Data Representation (XDR); PvmDataRaw to the original data format; PvmDataInPlace means that the data items have to be copied directly out of the user's memory (for details cf. <ref> [19] </ref>). Two injective functions sendbuf and recvbuf from TASK into BUFID yield the current send and receive buffers of tasks. <p> On completion of this operation try to spawn returns, to the calling pvmd, the resulting list of pids, one for each successfully created process required to spawn a new task, by generating an ext spawn report event. 6 This feature is not yet implemented, cf. <ref> [19] </ref>. 19 pvm spawn () if event (pvmd) = spawn (F ile; Args; F lag; Where ; Ntask ) from Task thenif hostselect (F lag; Where ; Ntask ; pvmd) = hlocal; remotei & local = hpvmd; n 0 i & remote = hpvmd 1 ; n 1 i; : :
Reference: [20] <author> A. Geist, A. Beguelin, J. Dongarra, W. Jiang, B. Manchek, and V. Sun-deram. </author> <title> PVM: Parallel Virtual Machine A Users Guide and Tutorial for Network Parallel Computing. </title> <publisher> MIT Press, </publisher> <year> 1994. </year> <note> to appear. </note>
Reference-contexts: We provide an abstract formal specification of central components of PVM, the widespread virtual architecture for heterogeneous distributed computing <ref> [20, 32] </ref>. We start from scratch without presupposing any knowledge of PVM; fl In BRICS TR (BRICS-NS-95-4), University of Aarhus, July 1995. Preliminary versions of this paper have been presented by U. Glasser at the PVM Users' Group Meeting, Oak Ridge, TN, May, 1994 and by E.
Reference: [21] <author> U. Glasser. </author> <title> Systems Level Specification and Modelling of Reactive Systems: Concepts, Methods, </title> <booktitle> and Tools. In Proc. of the Fifth International Conference on Computer Aided Systems Technology (EUROCAST'95), </booktitle> <address> Innsbruck, Austria, </address> <month> May, </month> <year> 1995. </year>
Reference-contexts: from TID kill process (pid (task (Tid ))) else forward kill msghTid i to pvmd (Tid ) 22 kill msghi if event (pvmd) = kill msghTid i from pvmd 0 then delete Tid from TID kill process (pid (task (Tid ))) 4 Appropriate Ground Models As has been observed in <ref> [3, 21] </ref> evolving algebras fit in a special way when it comes to link a non-formal system description S (requirements specification) to a formal model S 0 which has to be recognized as faithful formalization of S.
Reference: [22] <author> Y. Gurevich. </author> <title> Logic and the challenge of computer science. </title> <editor> In E. Borger, editor, </editor> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <pages> pages 1-57. </pages> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: Introduction In 1988 Yuri Gurevich has discovered the notion of evolving algebra in an attempt to sharpen Turing's thesis by complexity theoretic considerations (see <ref> [22] </ref>). Through numerous case studies (see [4] for an annotated list which is complete up to 1994) it has become clear since then that using the notion of evolving algebras one can develop a powerful and elegant specification methodology which has a huge yet unexplored potential for industrial applications.
Reference: [23] <author> Yuri Gurevich. </author> <title> Evolving Algebra 1993: Lipari Guide. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: It is for the benefit of the practitioner that we are going to introduce here the notion of evolving algebra by a non-toy example from real-life; for a precise mathematical foundation we refer the interested reader to <ref> [23] </ref>. <p> In accordance with usual practice the execution of updates in evolving algebras can be conditioned by so-called guards, giving rise to so-called transition rules (also called guarded multi-update instruction in <ref> [23] </ref>) of the following form: if Cond then Updates Cond is an arbitrary boolean valued expression (first-order logic formula) and U pdates a set of updates. <p> with algebras. 6 An evolving algebra can (in a first approximation) be defined as a finite set of transition rules if Cond then Updates where Updates consists of finitely many function updates (and domain extensions or deletions of elements; these two update forms can be reduced to function updates, see <ref> [23] </ref>). The effect of a transition rule R when applied to an algebra A is to produce another algebra A 0 which differs from A by the new values for those functions at those arguments where the values are updated by the rule R. <p> For the ISO Prolog Standard published in 1995 and the IEEE VHDL'93 Standard evolving algebra ground models appear in [15, 11]. 5 Distributed Evolving Algebras In this section we resume the preceding discussion by the definition of distributed evolving algebras, taken from <ref> [23] </ref> to which we refer for details. A distributed evolving algebra A comes as a finite set of sequential evolving algebra programs, called modules, together with a finite set of concurrently operating agents executing these modules, and a collection of initial states of A. <p> A rigorous semantical definition of the notion of runs of distributed evolving algebras is given in <ref> [23] </ref>. The Distributed PVM Algebra In our PVM model the agents are represented by the concurrently operating PVM daemons as identified through the function pvmd (taking the role of Self). The set of pvmds increases or decreases depending on the dynamically changing configuration of the virtual machine. <p> The goal was to illustrate some outstanding merits of the evolving algebra methodology to design and analysis of complex computer systems. This text has been written for the practitioner; we advice the theoretically inclined to study <ref> [23] </ref> where Gurevich provides a rigorous mathematical foundation of the semantics of evolving algebras.
Reference: [24] <author> Y. Gurevich and J. Huggins. </author> <title> The semantics of the C programming language. </title> <editor> In E. Borger, H. Kleine Buning, G. Jager, S. Martini, and M. M. Richter, editors, </editor> <booktitle> Computer Science Logic, volume 702 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 26 </month>
Reference-contexts: This freedom explains the success of the simple and transparent evolving algebra models for the semantics and the implementation of numerous complex programming languages like Prolog [15, 16], C <ref> [24] </ref>, VHDL [11], Occam [9, 8], for protocols [12, 27], architectures [6, 5, 13], real-time algorithms [25, 26], etc. The importance of the freedom of abstraction which is offered through the notion of evolving algebra is also confirmed by a common experience in the design of algorithms.
Reference: [25] <author> Y. Gurevich, J. Huggins, and R. Mani. </author> <title> The Generalized Railroad Crossing Problem: An Evolving Algebra Based Solution. </title> <institution> EECS Department, University of Michigan-Ann Arbor, </institution> <type> CSE Technical Report, </type> <institution> CSE-TR-230-95, </institution> <year> 1995. </year>
Reference-contexts: This freedom explains the success of the simple and transparent evolving algebra models for the semantics and the implementation of numerous complex programming languages like Prolog [15, 16], C [24], VHDL [11], Occam [9, 8], for protocols [12, 27], architectures [6, 5, 13], real-time algorithms <ref> [25, 26] </ref>, etc. The importance of the freedom of abstraction which is offered through the notion of evolving algebra is also confirmed by a common experience in the design of algorithms.
Reference: [26] <author> Y. Gurevich and R. Mani. </author> <title> Group Membership Protocol: Specification and Verification. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: This freedom explains the success of the simple and transparent evolving algebra models for the semantics and the implementation of numerous complex programming languages like Prolog [15, 16], C [24], VHDL [11], Occam [9, 8], for protocols [12, 27], architectures [6, 5, 13], real-time algorithms <ref> [25, 26] </ref>, etc. The importance of the freedom of abstraction which is offered through the notion of evolving algebra is also confirmed by a common experience in the design of algorithms.
Reference: [27] <author> Jim Huggins. </author> <title> Kermit: Specification and verification. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: This freedom explains the success of the simple and transparent evolving algebra models for the semantics and the implementation of numerous complex programming languages like Prolog [15, 16], C [24], VHDL [11], Occam [9, 8], for protocols <ref> [12, 27] </ref>, architectures [6, 5, 13], real-time algorithms [25, 26], etc. The importance of the freedom of abstraction which is offered through the notion of evolving algebra is also confirmed by a common experience in the design of algorithms.
Reference: [28] <institution> The Institute of Electrical and Electronics Engineering. IEEE Standard VHDL Language Reference Manual|IEEE Std 1076-1993, </institution> <address> New York, NY, USA, </address> <year> 1994. </year> <note> [29] . M. </note> <editor> Marcotty and H.F. Ledgard. </editor> <booktitle> The World of Programming Languages. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: In both cases the recursive definitions replace rather complex algorithmic characterizations in the VHDL'93 language reference manual <ref> [28] </ref>. * In the abstract evolving algebra models of Occam (see [9]) which are the starting point for the correctness proof of a compilation scheme into Transputer instructions in [8] we have taken great advantage of the usual flowchart layout of programs; we define it by external functions which in the
Reference: [30] <author> Peter D. Mosses. </author> <title> Action Semantics. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: For data structures the algebraic specification approach (see [33]) shows a way to deal with abstract data types; for actions the action semantics approach (see <ref> [30] </ref>) proposes a scheme for constructing complex operations out of basic components. Evolving algebras offer the possibility to choose both, the data and the basic actions, at any level of abstraction and independently of each other.
Reference: [31] <author> David L. Parnas. </author> <title> Information distribution aspects of design methodology. </title> <editor> In C. V. Freiman, editor, </editor> <booktitle> Proc. of IFIP Congress 1971, Volume 1: Foundations and Systems, </booktitle> <pages> pages 339-344. </pages> <publisher> North-Holland, </publisher> <year> 1972. </year>
Reference-contexts: Parnas in <ref> [31] </ref>, addresses the modular structuring of systems and can be summerized as follows: "A module achieves program simplification by providing an abstrac tion. That is, its function can be understood through its interface definition without any need to understand the internal details." [29].
Reference: [32] <author> V.S. Sunderam, G.A. Geist, J. Dongarra, and R. Manchek. </author> <title> The PVM Concurrent Computing System: Evolution, Experiences, and Trends. </title> <journal> Parallel Computing, </journal> <volume> 20(4) </volume> <pages> 531-545, </pages> <year> 1994. </year>
Reference-contexts: We provide an abstract formal specification of central components of PVM, the widespread virtual architecture for heterogeneous distributed computing <ref> [20, 32] </ref>. We start from scratch without presupposing any knowledge of PVM; fl In BRICS TR (BRICS-NS-95-4), University of Aarhus, July 1995. Preliminary versions of this paper have been presented by U. Glasser at the PVM Users' Group Meeting, Oak Ridge, TN, May, 1994 and by E.
Reference: [33] <author> Martin Wirsing. </author> <title> Algebraic Specifications. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science B, </booktitle> <pages> pages 675-788, </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: For data structures the algebraic specification approach (see <ref> [33] </ref>) shows a way to deal with abstract data types; for actions the action semantics approach (see [30]) proposes a scheme for constructing complex operations out of basic components.
Reference: [34] <author> Niklaus Wirth. </author> <title> Algorithms & Data Structures. </title> <publisher> Prentice-Hall, </publisher> <year> 1975. </year> <month> 27 </month>
Reference-contexts: Wirth: "... Data in the first instance represent abstractions of real phenomena and are preferably formulated as abstract structures not necessarily realized in common programming languages." (see <ref> [34] </ref>, page 10) Furthermore, the reciprocal dependency of algorithms and data structures makes it important for the designer not to be hindered by inappropriate re strictions of the framework; to say it again with Wirth's words: 7 "It is clear that decisions about structuring data cannot be made without knowledge of <p> In short, the subjects of program composition and data structures are inseparably interwined." (see <ref> [34] </ref>, page 9) The framework of evolving algebras offers the freedom the designer needs to `tailor' his models to the given level of abstraction. 2 Information Hiding and Interfaces The basic idea of information hiding, as introduced by D.
References-found: 33

