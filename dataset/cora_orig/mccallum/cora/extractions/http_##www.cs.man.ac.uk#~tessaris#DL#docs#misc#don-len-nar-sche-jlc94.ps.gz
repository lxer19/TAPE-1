URL: http://www.cs.man.ac.uk/~tessaris/DL/docs/misc/don-len-nar-sche-jlc94.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~tessaris/DL/papers.html
Root-URL: http://www.cs.man.ac.uk
Email: e-mail: fdonini,lenzerini,nardi,aschaerfg@assi.ing.uniroma1.it  
Title: Deduction in Concept Languages: From Subsumption to Instance Checking  
Author: Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, Andrea Schaerf 
Note: To appear in Journal of Logic and Computation  
Address: Via Salaria 113, 00198 Roma, Italia  
Affiliation: Dipartimento di Informatica e Sistemistica Universita di Roma "La Sapienza"  
Abstract: It is a common opinion that subsumption is the central reasoning task in frame-based knowledge representation languages (or concept languages). Intuitively, a concept C subsumes another concept D if the set of objects represented by C is a superset of the one represented by D. When individual objects are taken into account, the basic deductive task for retrieving information from a knowledge base is instance checking, that amounts to checking whether the knowledge base implies that an individual is an instance of a given concept. In this paper, we address the question of whether instance checking can be solved by means of subsumption algorithms. We do so by considering several languages where subsumption belongs to different complexity classes. For such languages we present methods for the instance checking problem, provide a complexity analysis of this problem, and compare it with the subsumption problem. The main result of the paper is that instance checking is not always easily reducible to sub-sumption. In particular, there are cases where it is strictly harder than subsumption. This impacts on the design of reasoning algorithms for knowledge representation systems based on concept languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Franz Baader and Bernhard Hollunder. </author> <title> A terminological knowledge representation system with complete inference algorithm. </title> <booktitle> In Proc. of the Workshop on Processing Declarative Knowledge, PDK-91, Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 67-86. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In <ref> [1, 6] </ref>, several computational properties of the calculus are discussed. Here, we report, without proof, one basic properties that will be used in the subsequent sections. Proposition 3.1 Let S be a constraint system. The following problems can be solved in polynomial time with respect to jSj: 1. <p> Finally, the classes p p p k of the polynomial hierarchy are defined by p p p p k , k+1 = co k+1 p k . In <ref> [1, 5, 6, 11, 24] </ref>, several results on the computational complexity of concept satisfiability, subsumption, knowledge base satisfiability and instance checking in concept languages are presented. In order to make this paper self-contained, we summarize the main results in Figure 1. <p> In addition, in the language including 14 concept subsumption knowledge base instance checking satisfiability satisfiability AL P P P P ALN P P ALE coNP NP [5] [5] ALR coNP NP [6] [6] ALU NP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE [24] [24] <ref> [1] </ref> [1] both constructs (ALC) concept satisfiability is PSPACE-complete. Let us elaborate more on these complexity results. The first observation refers to coNP-completeness of concept satisfiability in ALE. <p> In addition, in the language including 14 concept subsumption knowledge base instance checking satisfiability satisfiability AL P P P P ALN P P ALE coNP NP [5] [5] ALR coNP NP [6] [6] ALU NP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE [24] [24] <ref> [1] </ref> [1] both constructs (ALC) concept satisfiability is PSPACE-complete. Let us elaborate more on these complexity results. The first observation refers to coNP-completeness of concept satisfiability in ALE. <p> A constraint system S is said to be a pre-completion of S if it is obtained from S by the application of the ! 8 , ! u , and ! t -rules, and none of these rules is applicable to S (see <ref> [1] </ref>). Note that any pre-completion S of S contains no variables, and, moreover, all the individuals in S are also in S . Moreover, when is expressed in a language without disjunction, there is only one pre-completion of S . <p> The notions of pre-completion and C Sjb are useful for characterizing the satisfiability of a knowledge base, as shown in the following proposition, whose proof can be easily derived from the results in <ref> [1] </ref>. Proposition 4.2 Let L be any of the concept languages defined in Section 2. An L-knowledge base is satisfiable if and only if there is a clash-free pre-completion S of S such that for each individual b in , C Sjb is satisfiable. <p> The algorithm systematically searches a precompletion S of S such that for each individual b, the satisfiability checking of C Sjb (done with the PSPACE algorithm) returns true. Notice that the results on KS AL and KS ALC have been reported elsewhere in the literature (see [12] and <ref> [1] </ref>, respectively). 5 Instance Checking In this section we investigate on the computational complexity of IN L , where L is any of the concept languages defined in Section 2. <p> AL P P P P P ALN P P P P P NP-hard ALE coNP NP coNP coNP-hard PSPACE [5] [5] in 2 ALR coNP NP coNP NP NP [6] [6] ALU NP coNP NP coNP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE PSPACE [24] [24] <ref> [1] </ref> [1] [1] is not directly reducible to SU ALC as for ALU , i.e. Proposition 5.13 does not hold for ALC. This is easily derivable from the fact that ALE is a sublanguage of ALC. <p> AL P P P P P ALN P P P P P NP-hard ALE coNP NP coNP coNP-hard PSPACE [5] [5] in 2 ALR coNP NP coNP NP NP [6] [6] ALU NP coNP NP coNP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE PSPACE [24] [24] <ref> [1] </ref> [1] [1] is not directly reducible to SU ALC as for ALU , i.e. Proposition 5.13 does not hold for ALC. This is easily derivable from the fact that ALE is a sublanguage of ALC. <p> AL P P P P P ALN P P P P P NP-hard ALE coNP NP coNP coNP-hard PSPACE [5] [5] in 2 ALR coNP NP coNP NP NP [6] [6] ALU NP coNP NP coNP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE PSPACE [24] [24] <ref> [1] </ref> [1] [1] is not directly reducible to SU ALC as for ALU , i.e. Proposition 5.13 does not hold for ALC. This is easily derivable from the fact that ALE is a sublanguage of ALC.
Reference: [2] <author> John L. Bell and Moshe Machover. </author> <title> A Course in Mathematical Logic. </title> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: Subsumption and instance checking are therefore particular deduction problems over such fragment. Our study is carried on within the framework of a reasoning technique based constraint systems, which can be regarded as a refinement of the deduction method of tableaux for first-order logic (see <ref> [2] </ref>). In particular, we extend the technique used in [6, 7, 24] to the treatment of individuals. The main outcome of our analysis is that there are cases where instance checking is strictly harder than subsumption. <p> soning In this section we first describe a calculus for realizing the reasoning services mentioned in Section 2, and then discuss on several aspects related to the computational complexity of such services. 3.1 The calculus The technique we present is a refinement of the tableaux calculus for first order logic <ref> [2] </ref>, and is employed in [5, 6, 10, 24] both for the design of algorithms for concept satisfiability and subsumption, and for studying their computational properties.
Reference: [3] <author> Ronald J. Brachman and Hector J. Levesque. </author> <booktitle> The tractability of sub-sumption in frame-based description languages. In Proc. of the 4th Nat. Conf. on Artificial Intelligence AAAI-84, </booktitle> <pages> pages 34-37, </pages> <year> 1984. </year>
Reference-contexts: Existential role quantification is sometimes unqualified and written 9CHILD, in which case it denotes the set of individuals with a child. The basic language that we consider (called F L , see <ref> [3] </ref>) includes concept conjunction, universal role quantification and unqualified existential role quantification. More powerful languages are then defined by adding other constructs to this basic language. The hierarchical structure of concepts is determined by the subsumption relation, which is interpreted as set containment. <p> It is a common opinion that subsumption checking is the central reasoning task in concept languages (see for example [14, 16]). This has motivated a large body of research on the problem of subsumption checking in different concept languages as in <ref> [3, 6, 10, 17, 23, 24] </ref>. 1 The definition of knowledge bases by means of concept languages is done by specifying a set of assertions stating either that an individual is an instance of a concept expression, written C (a), or that two individuals are instances of a role, written R
Reference: [4] <author> Martin Buchheit, Francesco M. Donini, and Andrea Schaerf. </author> <title> Decidable reasoning in terminological knowledge representation systems. </title> <booktitle> In Proc. of the 13th Int. Joint Conf. on Artificial Intelligence IJCAI-93, </booktitle> <pages> pages 704-709, </pages> <address> Chambery, France, 1993. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Let be a knowledge base expressed in one of the concept languages introduced in Section 2. Since the ! t -rule and the ! -rule are nondeterministic, more than one complete constraint system (called completion) can be obtained from S . It follows from the results in <ref> [4] </ref> that there is no infinite chain of completion steps issuing from S , and, moreover, is satisfiable if and only if there is at least one completion of S that does not contain any clash.
Reference: [5] <author> Francesco M. Donini, Bernhard Hollunder, Maurizio Lenzerini, Alberto Marchetti Spaccamela, Daniele Nardi, and Werner Nutt. </author> <title> The complexity of existential quantification in concept languages. </title> <journal> Artificial Intelligence, </journal> <volume> 2-3:309-327, </volume> <year> 1992. </year>
Reference-contexts: first describe a calculus for realizing the reasoning services mentioned in Section 2, and then discuss on several aspects related to the computational complexity of such services. 3.1 The calculus The technique we present is a refinement of the tableaux calculus for first order logic [2], and is employed in <ref> [5, 6, 10, 24] </ref> both for the design of algorithms for concept satisfiability and subsumption, and for studying their computational properties. In this work, since we are interested in knowledge base satisfiability and instance checking, we extend the calculus to the treatment of individuals (as proposed in [9]). <p> Finally, the classes p p p k of the polynomial hierarchy are defined by p p p p k , k+1 = co k+1 p k . In <ref> [1, 5, 6, 11, 24] </ref>, several results on the computational complexity of concept satisfiability, subsumption, knowledge base satisfiability and instance checking in concept languages are presented. In order to make this paper self-contained, we summarize the main results in Figure 1. <p> In addition, in the language including 14 concept subsumption knowledge base instance checking satisfiability satisfiability AL P P P P ALN P P ALE coNP NP <ref> [5] </ref> [5] ALR coNP NP [6] [6] ALU NP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE [24] [24] [1] [1] both constructs (ALC) concept satisfiability is PSPACE-complete. Let us elaborate more on these complexity results. The first observation refers to coNP-completeness of concept satisfiability in ALE. <p> In addition, in the language including 14 concept subsumption knowledge base instance checking satisfiability satisfiability AL P P P P ALN P P ALE coNP NP <ref> [5] </ref> [5] ALR coNP NP [6] [6] ALU NP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE [24] [24] [1] [1] both constructs (ALC) concept satisfiability is PSPACE-complete. Let us elaborate more on these complexity results. The first observation refers to coNP-completeness of concept satisfiability in ALE. <p> Let us elaborate more on these complexity results. The first observation refers to coNP-completeness of concept satisfiability in ALE. We provide here an intuitive motivation for the fact that the problem is in coNP, while we refer the reader to <ref> [5] </ref> for a detailed discussion on the coNP-hardness. Let us consider the complement of concept satisfiability. The results in [24] show that in order to check the unsatisfiability of an ALE -concept C, one can focus on particular sets of constraints called traces. <p> Even though KS ALC and SU ALC are in the same complexity class, KS ALC 39 concept subsumption knowledge base inst. checking inst. checking satisfiability satisfiability KB compl. combined compl. AL P P P P P ALN P P P P P NP-hard ALE coNP NP coNP coNP-hard PSPACE <ref> [5] </ref> [5] in 2 ALR coNP NP coNP NP NP [6] [6] ALU NP coNP NP coNP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE PSPACE [24] [24] [1] [1] [1] is not directly reducible to SU ALC as for ALU , i.e. Proposition 5.13 does not hold for ALC. <p> AL P P P P P ALN P P P P P NP-hard ALE coNP NP coNP coNP-hard PSPACE <ref> [5] </ref> [5] in 2 ALR coNP NP coNP NP NP [6] [6] ALU NP coNP NP coNP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE PSPACE [24] [24] [1] [1] [1] is not directly reducible to SU ALC as for ALU , i.e. Proposition 5.13 does not hold for ALC.
Reference: [6] <author> Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, and Werner Nutt. </author> <title> The complexity of concept languages. </title> <editor> In James Allen, Richard Fikes, and Erik Sandewall, editors, </editor> <booktitle> Proc. of the 2nd Int. Conf. on Principles of Knowledge Representation and Reasoning KR-91, </booktitle> <pages> pages 151-162. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: It is a common opinion that subsumption checking is the central reasoning task in concept languages (see for example [14, 16]). This has motivated a large body of research on the problem of subsumption checking in different concept languages as in <ref> [3, 6, 10, 17, 23, 24] </ref>. 1 The definition of knowledge bases by means of concept languages is done by specifying a set of assertions stating either that an individual is an instance of a concept expression, written C (a), or that two individuals are instances of a role, written R <p> Our study is carried on within the framework of a reasoning technique based constraint systems, which can be regarded as a refinement of the deduction method of tableaux for first-order logic (see [2]). In particular, we extend the technique used in <ref> [6, 7, 24] </ref> to the treatment of individuals. The main outcome of our analysis is that there are cases where instance checking is strictly harder than subsumption. <p> first describe a calculus for realizing the reasoning services mentioned in Section 2, and then discuss on several aspects related to the computational complexity of such services. 3.1 The calculus The technique we present is a refinement of the tableaux calculus for first order logic [2], and is employed in <ref> [5, 6, 10, 24] </ref> both for the design of algorithms for concept satisfiability and subsumption, and for studying their computational properties. In this work, since we are interested in knowledge base satisfiability and instance checking, we extend the calculus to the treatment of individuals (as proposed in [9]). <p> In <ref> [1, 6] </ref>, several computational properties of the calculus are discussed. Here, we report, without proof, one basic properties that will be used in the subsequent sections. Proposition 3.1 Let S be a constraint system. The following problems can be solved in polynomial time with respect to jSj: 1. <p> Finally, the classes p p p k of the polynomial hierarchy are defined by p p p p k , k+1 = co k+1 p k . In <ref> [1, 5, 6, 11, 24] </ref>, several results on the computational complexity of concept satisfiability, subsumption, knowledge base satisfiability and instance checking in concept languages are presented. In order to make this paper self-contained, we summarize the main results in Figure 1. <p> In addition, in the language including 14 concept subsumption knowledge base instance checking satisfiability satisfiability AL P P P P ALN P P ALE coNP NP [5] [5] ALR coNP NP <ref> [6] </ref> [6] ALU NP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE [24] [24] [1] [1] both constructs (ALC) concept satisfiability is PSPACE-complete. Let us elaborate more on these complexity results. The first observation refers to coNP-completeness of concept satisfiability in ALE. <p> In addition, in the language including 14 concept subsumption knowledge base instance checking satisfiability satisfiability AL P P P P ALN P P ALE coNP NP [5] [5] ALR coNP NP <ref> [6] </ref> [6] ALU NP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE [24] [24] [1] [1] both constructs (ALC) concept satisfiability is PSPACE-complete. Let us elaborate more on these complexity results. The first observation refers to coNP-completeness of concept satisfiability in ALE. <p> In addition, in the language including 14 concept subsumption knowledge base instance checking satisfiability satisfiability AL P P P P ALN P P ALE coNP NP [5] [5] ALR coNP NP <ref> [6] </ref> [6] ALU NP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE [24] [24] [1] [1] both constructs (ALC) concept satisfiability is PSPACE-complete. Let us elaborate more on these complexity results. The first observation refers to coNP-completeness of concept satisfiability in ALE. <p> In addition, in the language including 14 concept subsumption knowledge base instance checking satisfiability satisfiability AL P P P P ALN P P ALE coNP NP [5] [5] ALR coNP NP <ref> [6] </ref> [6] ALU NP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE [24] [24] [1] [1] both constructs (ALC) concept satisfiability is PSPACE-complete. Let us elaborate more on these complexity results. The first observation refers to coNP-completeness of concept satisfiability in ALE. <p> We can conclude that T is a nondeterministic polynomial time Turing machine, which implies that concept unsatisfiability in ALE is in NP, and concept satisfiability is in coNP. The same considerations hold for subsumption in ALE , and for both satisfiability and subsumption in ALR, as shown in <ref> [6] </ref>. Let us now discuss the complexity result about ALU . We refer, in particular, to checking whether an ALU -concept C is satisfiable. <p> The nondeterminism is clearly due to the ! t -rule. It is shown in <ref> [6] </ref> that both computing one completion of fx: Cg and checking whether it is clash-free can be done in polynomial time. It is also shown that the complement of subsumption can be computed by a nondeterministic Turing machine 16 in polynomial time. <p> Notice that the NP-hardness of SU ALR , and therefore the NP-hardness of IN ALR , follows from NP-hardness of SU ALE , since, when checking concept satisfiability, qualified existential quantification can be simulated in ALR using role conjunction (see <ref> [6] </ref>). <p> AL P P P P P ALN P P P P P NP-hard ALE coNP NP coNP coNP-hard PSPACE [5] [5] in 2 ALR coNP NP coNP NP NP <ref> [6] </ref> [6] ALU NP coNP NP coNP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE PSPACE [24] [24] [1] [1] [1] is not directly reducible to SU ALC as for ALU , i.e. Proposition 5.13 does not hold for ALC. <p> AL P P P P P ALN P P P P P NP-hard ALE coNP NP coNP coNP-hard PSPACE [5] [5] in 2 ALR coNP NP coNP NP NP <ref> [6] </ref> [6] ALU NP coNP NP coNP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE PSPACE [24] [24] [1] [1] [1] is not directly reducible to SU ALC as for ALU , i.e. Proposition 5.13 does not hold for ALC. <p> AL P P P P P ALN P P P P P NP-hard ALE coNP NP coNP coNP-hard PSPACE [5] [5] in 2 ALR coNP NP coNP NP NP <ref> [6] </ref> [6] ALU NP coNP NP coNP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE PSPACE [24] [24] [1] [1] [1] is not directly reducible to SU ALC as for ALU , i.e. Proposition 5.13 does not hold for ALC. This is easily derivable from the fact that ALE is a sublanguage of ALC. <p> AL P P P P P ALN P P P P P NP-hard ALE coNP NP coNP coNP-hard PSPACE [5] [5] in 2 ALR coNP NP coNP NP NP <ref> [6] </ref> [6] ALU NP coNP NP coNP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE PSPACE [24] [24] [1] [1] [1] is not directly reducible to SU ALC as for ALU , i.e. Proposition 5.13 does not hold for ALC. This is easily derivable from the fact that ALE is a sublanguage of ALC. <p> For other languages where subsumption is NP-complete, such as ALR, the source of complexity singled out for ALE does not arise. In fact, although ALR can simulate qualified existential quantification in the assertions (see <ref> [6] </ref>), qualified existential quantification cannot be expressed in the query concept, neither explicitly nor implicitly. It follows that instance checking in ALR is NP-complete, exactly like subsump tion. 4. With regard to other languages, instance checking is again in the same complexity class as subsumption.
Reference: [7] <author> Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, and Werner Nutt. </author> <title> Tractable concept languages. </title> <booktitle> In Proc. of the 12th Int. Joint Conf. on Artificial Intelligence IJCAI-91, </booktitle> <pages> pages 458-463, </pages> <address> Sidney, </address> <year> 1991. </year>
Reference-contexts: Our study is carried on within the framework of a reasoning technique based constraint systems, which can be regarded as a refinement of the deduction method of tableaux for first-order logic (see [2]). In particular, we extend the technique used in <ref> [6, 7, 24] </ref> to the treatment of individuals. The main outcome of our analysis is that there are cases where instance checking is strictly harder than subsumption.
Reference: [8] <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability|A guide to NP-completeness. W.H. </title> <publisher> Freeman and Company, </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference-contexts: Deciding which rules are applicable to S; 2. Computing the constraint system resulting from applying a rule to S; 3. Checking whether S is clash-free. 13 3.2 Computational complexity We use standard notions from complexity theory (see <ref> [8, 19] </ref>). The class NP contains the problems that can be solved by a nondeterministic Turing machine in polynomial time. The class coNP comprises all problems that are the complement of a problem in NP. <p> It is well known that deciding the validity of quantified boolean formulae is a PSPACE-complete problem <ref> [8, page 172] </ref>. In [24] it is proven that QBF can be reduced to the satisfiability of an ALC-concept of the form C u C 1 0 where C and C i 0 are defined as follows.
Reference: [9] <author> Bernhard Hollunder. </author> <title> Hybrid inferences in KL-ONE-based knowledge representation systems. </title> <booktitle> In Proc. of the German Workshop on Artificial Intelligence, </booktitle> <pages> pages 38-47. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: In this work, since we are interested in knowledge base satisfiability and instance checking, we extend the calculus to the treatment of individuals (as proposed in <ref> [9] </ref>). The calculus operates on constraints consisting of individuals, variables, concepts and roles. Concepts are assumed to be in a particular form, called simple, which is the analogous of the negation normal form for formulae.
Reference: [10] <author> Bernhard Hollunder, Werner Nutt, and Manfred Schmidt-Schau. </author> <title> Sub-sumption algorithms for concept description languages. </title> <booktitle> In Proc. of the 9th European Conf. on Artificial Intelligence ECAI-90, </booktitle> <pages> pages 348-353, </pages> <address> London, 1990. </address> <publisher> Pitman. </publisher>
Reference-contexts: It is a common opinion that subsumption checking is the central reasoning task in concept languages (see for example [14, 16]). This has motivated a large body of research on the problem of subsumption checking in different concept languages as in <ref> [3, 6, 10, 17, 23, 24] </ref>. 1 The definition of knowledge bases by means of concept languages is done by specifying a set of assertions stating either that an individual is an instance of a concept expression, written C (a), or that two individuals are instances of a role, written R <p> first describe a calculus for realizing the reasoning services mentioned in Section 2, and then discuss on several aspects related to the computational complexity of such services. 3.1 The calculus The technique we present is a refinement of the tableaux calculus for first order logic [2], and is employed in <ref> [5, 6, 10, 24] </ref> both for the design of algorithms for concept satisfiability and subsumption, and for studying their computational properties. In this work, since we are interested in knowledge base satisfiability and instance checking, we extend the calculus to the treatment of individuals (as proposed in [9]).
Reference: [11] <author> Maurizio Lenzerini and Andrea Schaerf. </author> <title> Concept languages as query languages. </title> <booktitle> In Proc. of the 9th Nat. Conf. on Artificial Intelligence AAAI-91, </booktitle> <pages> pages 471-476, </pages> <year> 1991. </year>
Reference-contexts: Finally, the classes p p p k of the polynomial hierarchy are defined by p p p p k , k+1 = co k+1 p k . In <ref> [1, 5, 6, 11, 24] </ref>, several results on the computational complexity of concept satisfiability, subsumption, knowledge base satisfiability and instance checking in concept languages are presented. In order to make this paper self-contained, we summarize the main results in Figure 1. <p> In other words, in order to get intractability it is sufficient to enrich only the query language with qualified existential quantification, keeping a tractable language for expressing the knowledge base. It follows that, as noted in [12], the polynomial algorithm presented in <ref> [11] </ref> for querying AL-knowledge bases with ALE , is incomplete. This unexpected result about ALE shows that instance checking in this language suffers from a new source of complexity, which does not show up when checking subsumption between ALE -concepts.
Reference: [12] <author> Maurizio Lenzerini and Andrea Schaerf. </author> <title> Querying concept-based knowledge bases. </title> <booktitle> In Proc. of the Workshop on Processing Declarative Knowledge, PDK-91, Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 107-123. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The algorithm systematically searches a precompletion S of S such that for each individual b, the satisfiability checking of C Sjb (done with the PSPACE algorithm) returns true. Notice that the results on KS AL and KS ALC have been reported elsewhere in the literature (see <ref> [12] </ref> and [1], respectively). 5 Instance Checking In this section we investigate on the computational complexity of IN L , where L is any of the concept languages defined in Section 2. <p> Notice that the tractability of IN AL is proven in <ref> [12] </ref> using a different technique. <p> In other words, in order to get intractability it is sufficient to enrich only the query language with qualified existential quantification, keeping a tractable language for expressing the knowledge base. It follows that, as noted in <ref> [12] </ref>, the polynomial algorithm presented in [11] for querying AL-knowledge bases with ALE , is incomplete. This unexpected result about ALE shows that instance checking in this language suffers from a new source of complexity, which does not show up when checking subsumption between ALE -concepts. <p> We answer negatively to the above question by showing that instance checking in ALR can be done in NP with respect to combined complexity. The fact that qualified existential quantification cannot be expressed in ALR-query concepts, is confirmed in <ref> [12] </ref>, where it is shown that query answering using ALR as query language to an AL-knowledge base can be done in polynomial time (whereas it is coNP-hard when the query language is ALE ). Notice that only one pre-completion can be obtained from an ALR-knowledge base . <p> In other words, when is expressed in AL, instance checking using ALU is still coNP-hard with respect to query complexity (as proved in <ref> [12] </ref>), but is polynomial with respect to knowledge base complexity. 5.4 Languages with PSPACE-complete Subsumption (ALC) In this section we deal with the language ALC, where, by means of the complement of concepts, both qualified existential quantification and disjunction can be expressed.
Reference: [13] <author> Hector J. Levesque. </author> <title> Logic and the complexity of reasoning. </title> <journal> Journal of Philosophical Logic, </journal> <volume> 17 </volume> <pages> 355-389, </pages> <year> 1988. </year>
Reference-contexts: This explains why IN AL and IN ALN do not suffer from this computational problem. Let us illustrate the new form of complexity by 30 means of an example. The example we present is taken from <ref> [13, Sec. 10] </ref> and shows how certain logic puzzles can be expressed through an ALE query. Example 5.7 There are five blocks in a stack, where the second from the top is green, and the fourth is not green. <p> As pointed out in <ref> [13] </ref>, the answer is not immediately obvious. If one thinks about it, though, one realizes that the answer is YES. In order to discover this, one needs to reason by case analysis.
Reference: [14] <author> Hector J. Levesque and Ron J. Brachman. </author> <title> Expressiveness and tractability in knowledge representation and reasoning. </title> <journal> Computational Intelligence, </journal> <volume> 3 </volume> <pages> 78-93, </pages> <year> 1987. </year>
Reference-contexts: Later, concept languages (also called terminological languages, or description logics) have been introduced with the aim of providing a simple and well-established first-order semantics to capture the meaning of the most popular features of the structured representations of knowledge (see for example <ref> [14, 16] </ref>). In concept languages, concepts are used to represent classes as sets of individuals, and roles are binary relations used to specify their properties or attributes. <p> For example, the concept Parentu8CHILD.Male is subsumed by Parent, since it specifies an additional property of parents. It is a common opinion that subsumption checking is the central reasoning task in concept languages (see for example <ref> [14, 16] </ref>).
Reference: [15] <author> Robert MacGregor. </author> <title> Inside the LOOM description classifier. </title> <journal> SIGART Bulletin, </journal> <volume> 2(3) </volume> <pages> 88-92, </pages> <year> 1991. </year> <month> 44 </month>
Reference-contexts: In fact, a careful analysis of the relationship between subsumption and instance checking is lacking, although most of the existing systems (e.g. Loom <ref> [15] </ref>, Classic [20], Back [21]) provide implementations of reasoning services based on subsumption algorithms.
Reference: [16] <author> Bernhard Nebel. </author> <title> Reasoning and Revision in Hybrid Representation Sys--tems. </title> <booktitle> Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Later, concept languages (also called terminological languages, or description logics) have been introduced with the aim of providing a simple and well-established first-order semantics to capture the meaning of the most popular features of the structured representations of knowledge (see for example <ref> [14, 16] </ref>). In concept languages, concepts are used to represent classes as sets of individuals, and roles are binary relations used to specify their properties or attributes. <p> For example, the concept Parentu8CHILD.Male is subsumed by Parent, since it specifies an additional property of parents. It is a common opinion that subsumption checking is the central reasoning task in concept languages (see for example <ref> [14, 16] </ref>). <p> The central question we address in this paper is whether instance checking can be easily reduced to subsumption. The basic idea underlying most of the approaches developed so far (see <ref> [16] </ref>), is the following: in order to check whether j= D (a), first extract from the knowledge base all the information concerning the individual a, and then reason on the concept expression C a containing all the knowledge about a, thus reducing instance checking to a subsumption test between C a <p> Concept satisfiability and subsumption characterize reasoning on concept expressions, and have been deeply analyzed in the literature, often relying on the assumption that more sophisticated reasoning services could be based on them (see for example <ref> [16] </ref>). Knowledge base satisfiability and instance checking characterize reasoning when individuals come into play: the former is used for verifying whether the information contained in a knowledge base is 8 coherent; the latter is used for checking whether an individual is an instance of a concept within a knowledge base. <p> Indeed, observe that the only task that the algorithm performs besides subsumption is to compute the pre-completion of S and the concept (C ja u RC ja ), which is a minimal requirement for instance checking (see <ref> [16] </ref>). From all the above observations, we can conclude that IN AL can be really solved by relying on the algorithm for subsumption. Unfortunately, not all polynomial languages exhibit this property.
Reference: [17] <author> Bernhard Nebel. </author> <title> Terminological reasoning is inherently intractable. </title> <journal> Artificial Intelligence, </journal> <volume> 43 </volume> <pages> 235-249, </pages> <year> 1990. </year>
Reference-contexts: It is a common opinion that subsumption checking is the central reasoning task in concept languages (see for example [14, 16]). This has motivated a large body of research on the problem of subsumption checking in different concept languages as in <ref> [3, 6, 10, 17, 23, 24] </ref>. 1 The definition of knowledge bases by means of concept languages is done by specifying a set of assertions stating either that an individual is an instance of a concept expression, written C (a), or that two individuals are instances of a role, written R <p> It is well known that any reasoning process over knowledge bases comprising an acyclic terminology can be reduced to a reasoning process over a knowledge base with an empty terminology, in particular by substituting in the assertions every concept name with the corresponding definition (see 7 <ref> [17] </ref> for a discussion on this topic). For this reason, in our analysis we do not take into account terminologies and, therefore, we conceive a knowledge base as just a set of L-assertions.
Reference: [18] <author> Bernhard Nebel. </author> <title> Terminological cycles: Semantics and computational properties. </title> <editor> In John F. Sowa, editor, </editor> <booktitle> Principles of Semantic Networks, </booktitle> <pages> pages 331-361. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: However, almost all implemented systems assume that such definitions are acyclic, i.e. in the definition of concept C no (direct or indirect) reference to C itself may occur (see <ref> [18] </ref> for a discussion on the semantics of terminological cycles).
Reference: [19] <author> Christos H. Papadimitriou and Kenneth Steiglitz. </author> <title> Combinatorial Optimization: Algorithms and Complexity. </title> <publisher> Prentice-Hall, </publisher> <year> 1982. </year>
Reference-contexts: Deciding which rules are applicable to S; 2. Computing the constraint system resulting from applying a rule to S; 3. Checking whether S is clash-free. 13 3.2 Computational complexity We use standard notions from complexity theory (see <ref> [8, 19] </ref>). The class NP contains the problems that can be solved by a nondeterministic Turing machine in polynomial time. The class coNP comprises all problems that are the complement of a problem in NP.
Reference: [20] <author> Peter F. Patel-Schneider, D. L. McGuiness, Ronald J. Brachman, Lori Alperin Resnick, and A. Borgida. </author> <title> The CLASSIC knowledge represen-tatin system: Guiding principles and implementation rational. </title> <journal> SIGART Bulletin, </journal> <volume> 2(3) </volume> <pages> 108-113, </pages> <year> 1991. </year>
Reference-contexts: In fact, a careful analysis of the relationship between subsumption and instance checking is lacking, although most of the existing systems (e.g. Loom [15], Classic <ref> [20] </ref>, Back [21]) provide implementations of reasoning services based on subsumption algorithms.
Reference: [21] <author> C. Peltason. </author> <title> The BACK system an overview. </title> <journal> SIGART Bulletin, </journal> <volume> 2(3) </volume> <pages> 114-119, </pages> <year> 1991. </year>
Reference-contexts: In fact, a careful analysis of the relationship between subsumption and instance checking is lacking, although most of the existing systems (e.g. Loom [15], Classic [20], Back <ref> [21] </ref>) provide implementations of reasoning services based on subsumption algorithms.
Reference: [22] <author> Andrea Schaerf. </author> <title> On the complexity of the instance checking problem in concept languages with existential quantification. </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 2 </volume> <pages> 265-278, </pages> <year> 1993. </year> <note> An abridged version appeared in Proc. of ISMIS-93. </note>
Reference-contexts: Furthermore, we call 2+2-SAT the problem of checking whether a 2+2-CNF formula is satisfiable. In <ref> [22] </ref>, 2+2-SAT is proved to be NP-complete. <p> The correctness of the reduction is proven in <ref> [22] </ref>. We report here only the resulting lemma. 29 Lemma 5.5 A 2+2-CNF formula F is unsatisfiable if and only if F j= D (f). Proposition 5.6 IN ALE is coNP-hard with respect to knowledge base complexity. Proof. <p> Since the above reduction makes use of atomic complements, it may seem that coNP-hardness arises from the interaction between qualified existential quantification and atomic complements. However, it is shown in <ref> [22] </ref> that if we replace A and :A in F with 9R and 8R.B, respectively, (where R is a new role and B is a new atomic concept), we obtain a new reduction for which Lemma 5.5 still holds. It follows that instance checking in F LE (i.e. <p> At this point, one may ask which is the upper bound of IN ALE . In <ref> [22] </ref> it is shown that IN ALE can be solved by an algorithm that has nondeterministic polynomial knowledge base complexity, and uses an NP oracle. The number of calls to such an oracle is linear with respect to the number of 31 individuals in the knowledge base.
Reference: [23] <author> Manfred Schmidt-Schau. </author> <title> Subsumption in KL-ONE is undecidable. </title> <editor> In Ron J. Brachman, Hector J. Levesque, and Ray Reiter, editors, </editor> <booktitle> Proc. of the 1st Int. Conf. on Principles of Knowledge Representation and Reasoning KR-89, </booktitle> <pages> pages 421-431. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1989. </year>
Reference-contexts: It is a common opinion that subsumption checking is the central reasoning task in concept languages (see for example [14, 16]). This has motivated a large body of research on the problem of subsumption checking in different concept languages as in <ref> [3, 6, 10, 17, 23, 24] </ref>. 1 The definition of knowledge bases by means of concept languages is done by specifying a set of assertions stating either that an individual is an instance of a concept expression, written C (a), or that two individuals are instances of a role, written R
Reference: [24] <author> Manfred Schmidt-Schau and Gert Smolka. </author> <title> Attributive concept descriptions with complements. </title> <journal> Artificial Intelligence, </journal> <volume> 48(1) </volume> <pages> 1-26, </pages> <year> 1991. </year>
Reference-contexts: It is a common opinion that subsumption checking is the central reasoning task in concept languages (see for example [14, 16]). This has motivated a large body of research on the problem of subsumption checking in different concept languages as in <ref> [3, 6, 10, 17, 23, 24] </ref>. 1 The definition of knowledge bases by means of concept languages is done by specifying a set of assertions stating either that an individual is an instance of a concept expression, written C (a), or that two individuals are instances of a role, written R <p> Our study is carried on within the framework of a reasoning technique based constraint systems, which can be regarded as a refinement of the deduction method of tableaux for first-order logic (see [2]). In particular, we extend the technique used in <ref> [6, 7, 24] </ref> to the treatment of individuals. The main outcome of our analysis is that there are cases where instance checking is strictly harder than subsumption. <p> first describe a calculus for realizing the reasoning services mentioned in Section 2, and then discuss on several aspects related to the computational complexity of such services. 3.1 The calculus The technique we present is a refinement of the tableaux calculus for first order logic [2], and is employed in <ref> [5, 6, 10, 24] </ref> both for the design of algorithms for concept satisfiability and subsumption, and for studying their computational properties. In this work, since we are interested in knowledge base satisfiability and instance checking, we extend the calculus to the treatment of individuals (as proposed in [9]). <p> Finally, the classes p p p k of the polynomial hierarchy are defined by p p p p k , k+1 = co k+1 p k . In <ref> [1, 5, 6, 11, 24] </ref>, several results on the computational complexity of concept satisfiability, subsumption, knowledge base satisfiability and instance checking in concept languages are presented. In order to make this paper self-contained, we summarize the main results in Figure 1. <p> In addition, in the language including 14 concept subsumption knowledge base instance checking satisfiability satisfiability AL P P P P ALN P P ALE coNP NP [5] [5] ALR coNP NP [6] [6] ALU NP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE <ref> [24] </ref> [24] [1] [1] both constructs (ALC) concept satisfiability is PSPACE-complete. Let us elaborate more on these complexity results. The first observation refers to coNP-completeness of concept satisfiability in ALE. <p> In addition, in the language including 14 concept subsumption knowledge base instance checking satisfiability satisfiability AL P P P P ALN P P ALE coNP NP [5] [5] ALR coNP NP [6] [6] ALU NP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE <ref> [24] </ref> [24] [1] [1] both constructs (ALC) concept satisfiability is PSPACE-complete. Let us elaborate more on these complexity results. The first observation refers to coNP-completeness of concept satisfiability in ALE. <p> We provide here an intuitive motivation for the fact that the problem is in coNP, while we refer the reader to [5] for a detailed discussion on the coNP-hardness. Let us consider the complement of concept satisfiability. The results in <ref> [24] </ref> show that in order to check the unsatisfiability of an ALE -concept C, one can focus on particular sets of constraints called traces. <p> It is well known that deciding the validity of quantified boolean formulae is a PSPACE-complete problem [8, page 172]. In <ref> [24] </ref> it is proven that QBF can be reduced to the satisfiability of an ALC-concept of the form C u C 1 0 where C and C i 0 are defined as follows. <p> Proposition 5.9, together with the reduction of QBF to the satisfiability of C u C 1 0 u u C n 0 given in <ref> [24] </ref>, ensures us that IN ALE is PSPACE-hard. Since IN ALE is a special case of the PSPACE-complete problem IN ALC (see Subsection 5.4), it follows that IN ALE is also in PSPACE. <p> Therefore both sources of complexity discussed in Section 3 are present in this language. As shown in <ref> [24] </ref>, concept satisfiability and subsumption in ALC are PSPACE-complete problems. Differently from the languages considered so far, in ALC instance checking easily reduces to knowledge base satisfiability. In fact, since ALC admits general complements, j= D (a) if and only if the ALC-knowledge base [ f:D (a)g is unsatisfiable. <p> AL P P P P P ALN P P P P P NP-hard ALE coNP NP coNP coNP-hard PSPACE [5] [5] in 2 ALR coNP NP coNP NP NP [6] [6] ALU NP coNP NP coNP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE PSPACE <ref> [24] </ref> [24] [1] [1] [1] is not directly reducible to SU ALC as for ALU , i.e. Proposition 5.13 does not hold for ALC. This is easily derivable from the fact that ALE is a sublanguage of ALC. <p> AL P P P P P ALN P P P P P NP-hard ALE coNP NP coNP coNP-hard PSPACE [5] [5] in 2 ALR coNP NP coNP NP NP [6] [6] ALU NP coNP NP coNP coNP [6] [6] ALC PSPACE PSPACE PSPACE PSPACE PSPACE <ref> [24] </ref> [24] [1] [1] [1] is not directly reducible to SU ALC as for ALU , i.e. Proposition 5.13 does not hold for ALC. This is easily derivable from the fact that ALE is a sublanguage of ALC.
Reference: [25] <author> Fabrizio Sebastiani and Umberto Straccia. </author> <title> A computationally tractable terminological logic. </title> <booktitle> In Proc. of the 3rd Scandinavian Conf. on Artificial Intelligence SCAI-91, </booktitle> <pages> pages 307-315, </pages> <year> 1991. </year>
Reference: [26] <author> M. Vardi. </author> <title> Querying logical databases. </title> <journal> Journal of Computer and System Science, </journal> <volume> 33 </volume> <pages> 142-160, </pages> <year> 1986. </year> <month> 45 </month>
Reference-contexts: The same situation arises in databases <ref> [26] </ref>, where, in order to evaluate the computational complexity of query answering for various query languages, three different measures are used, namely, data complexity (the complexity with respect to the size of the database), query complexity, and combined complexity.
References-found: 26

