URL: http://www.cs.wustl.edu/~pjain/Service-Configurator.ps
Refering-URL: http://www.cs.wustl.edu/~pjain/publications.html
Root-URL: 
Email: pjain@cs.wustl.edu and schmidt@cs.wustl.edu  
Phone: (314) 935-7538 1  
Title: Service Configurator A Pattern for Dynamic Configuration and Reconfiguration of Communication Services  
Author: Prashant Jain and Douglas C. Schmidt 
Address: St. Louis, MO 63130,  
Affiliation: Department of Computer Science Washington University  
Abstract: This paper has been submitted to the Pattern Languages of Programming Design 3 book. Abstract This paper describes the Service Configurator pattern, which decouples the implementation of communication services from their configuration. This pattern increases the flexibility and extensibility of communication services by enabling their configuration and reconfiguration at any point in time without affecting other services. The Service Configurator pattern is widely used in system and application programming environments including UNIX, Windows NT, and Java Applets. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> in Proceedings of the 2 nd Conference on Object-Oriented Technologies and Systems, </booktitle> <institution> (Toronto, Canada), USENIX, </institution> <month> June </month> <year> 1996. </year>
Reference: [2] <author> R. Gusella and S. Zatti, </author> <title> The Accuracy of the Clock Synchronization Achieved by TEMPO in Berkeley UNIX 4.3BSD, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 15, </volume> <pages> pp. 847-853, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: 1, the architecture of the distributed time service contains the following components: * A Time Server answers queries about the time made by Clerks. * A Clerk queries one or more Time Servers to determine the correct time, calculates the approximate correct time using one of several distributed time algorithms <ref> [2, 3] </ref>, and updates its own local system time. * A Client uses the global time information maintained by a Clerk to provide consistency with the notion of time used by clients on other hosts. 3.2 Common Traps and Pitfalls One way to implement the distributed time service is to hard-code
Reference: [3] <author> F. Cristian, </author> <title> Probabilistic Clock Synchronization, </title> <journal> Distributed Computing, </journal> <volume> vol. 3, </volume> <pages> pp. 146-158, </pages> <year> 1989. </year>
Reference-contexts: 1, the architecture of the distributed time service contains the following components: * A Time Server answers queries about the time made by Clerks. * A Clerk queries one or more Time Servers to determine the correct time, calculates the approximate correct time using one of several distributed time algorithms <ref> [2, 3] </ref>, and updates its own local system time. * A Client uses the global time information maintained by a Clerk to provide consistency with the notion of time used by clients on other hosts. 3.2 Common Traps and Pitfalls One way to implement the distributed time service is to hard-code
Reference: [4] <author> D. C. Schmidt and T. Suda, </author> <title> An Object-Oriented Framework for Dynamically Configuring Extensible Distributed Communication Systems, </title> <journal> IEE/BCS Distributed Systems Engineering Journal (Special Issue on Configurable Distributed Systems), </journal> <volume> vol. 2, </volume> <pages> pp. 280-293, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: However, terminating the process to change the Clerk code would terminate the Time Server as well. This disruption in service may not be acceptable for highly available distributed systems (such as telecommunication switches or call centers <ref> [4] </ref>). * System performance may not scale up efficiently: Associating a process for each service ties up OS resources (such as I/O descriptors, virtual memory, and process table slots). This can be wasteful if services are frequently idle. <p> There are two basic ways to define the service control interface. One is to have each service inherit from a common base class. This is the approach used by the ACE Service Configurator framework <ref> [4] </ref>. <p> The C++ code in this section implements the Time Server and the Clerk classes. 5 Both classes inherit from Service, allowing them to be dynamically configured into an application. In addition, the approach uses a configuration mechanism based on explicit dynamic linking <ref> [4] </ref> and a configuration file (svc.conf) to dynamically configure the Clerk and Server portions of the distributed time service. <p> In addition to outlining the services, the code shown below includes the main driver function, which is the generic entry point into any Service Configurator-based application. The implementation runs on both UNIX and Win32 platforms using ACE <ref> [4] </ref>, which can be obtained via the WWW at www.cs.wustl.edu/~schmidt/ACE.html. 9.1 The Time Server Class The Time Server uses the Acceptor pattern to accept connections from one or more Clerks. The Acceptor pattern creates handlers for every connection from Clerks that want to receive requests for time updates.
Reference: [5] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Initializing Communication Services, </title> <booktitle> in Proceedings of the 1 st European Pattern Languages of Programming Conference, </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: Each subclass represents a concrete Service that has specific functionality in the distributed time service. The Time Server service is responsible for receiving and processing requests for time updates from Clerks. The Clerk service is a Connector <ref> [5] </ref> factory that (1) creates a new connection for every server, (2) dynamically allocates a new handler to send time update requests to a connected server, (3) receives the replies from all the servers through the handlers, and (4) updates the local system time based on an average of all Time <p> The example focuses on the configuration-related aspects of the distributed time service described in Section 3. In addition, this example illustrates the use of other patterns (such as the Reactor pattern [8] and the Acceptor and Connector patterns <ref> [5] </ref>) that are commonly used to develop communication services and ORBs. In the example below, the Concrete Service class in the OMT class diagram shown in Figure 3 is represented by the Time Server class, as well as the Clerk class. <p> These frameworks contain a master Acceptor <ref> [5] </ref> process that reactively monitors the set of ports associated with the services. When a client connection occurs on a monitored port, the Acceptor process accepts the connection and demultiplexes the request to the appropriate pre-registered service handler.
Reference: [6] <author> R. Gingell, M. Lee, X. Dang, and M. Weeks, </author> <title> Shared Libraries in SunOS, </title> <booktitle> in Proceedingsof the Summer 1987 USENIX Technical Conference, </booktitle> <address> (Phoenix, Arizona), </address> <year> 1987. </year>
Reference-contexts: For instance, the Service Configurator first initializes the service and then loads it into the Service Repository. This may be undesirable or an unnecessary overhead in time-critical applications. In addition, the use of dynamic linking often adds extra indirection to invoke functions and access global variables <ref> [6] </ref>. 8 Implementation The Service Configurator pattern has been implemented in many ways, ranging from OS device drivers, Internet super-servers, and Java applets. This section explains the steps and alternatives involved when implementing the pattern.
Reference: [7] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: </address> <publisher> Mi-crosoft Press, </publisher> <year> 1993. </year>
Reference-contexts: Another way to control communication services involves programming each Service to respond to a specific set of messages. This makes it possible to integrate the Service Configurator into non-OO programming languages (such as C). The Windows NT Service Control Manager (SCM) <ref> [7] </ref> uses this scheme. Each Window NT host has a master SCM process that automatically initiates and manages system services by passing them various control messages (such as PAUSE, RESUME, and TERMINATE). <p> exemplifies the flexibility offered by the Service Configurator pattern. 10 Known Uses The Service Configurator pattern is widely used in operating system and application programming environments including UNIX, Windows NT, ACE, and Java Applets: * Modern operating system device drivers: Modern operating systems (such as Solaris [10] and Windows NT <ref> [7] </ref>) provide support for dynamically configurable kernel-level device drivers. These drivers can be linked into and unlinked out of the system dynamically via init/fini/info hooks. <p> This handler performs the service (either reactively or in an active object) and returns any results to the client. * The Windows NT Service Control Manager (SCM): Unlike inetd and listen, the Windows NT Service Control Manager (SCM) <ref> [7] </ref> is not a port monitor. That is, it does not provide built-in support for listening to a set of I/O ports and dispatching server processes on-demand when client requests arrive.
Reference: [8] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Moreover, processes are often the wrong execution mechanism for many short-lived communication tasks (such as asking a Time Server for the current time or resolving a host address request in the Domain Name Service). In these cases, a multi-threaded Active Object [9] or a single-threaded Reactive <ref> [8] </ref> event loop may be more efficient. 3.3 Solution Often, a more convenient and flexible way to implement distributed services is to use the Service Configurator pattern. <p> centralized configuration mechanism simplifies the installation and administration of the services in an application by consolidating service attributes and initialization parameters in a single location. * Determine the service execution mechanism: A service that has been dynamically configured by a Service Configura-tor can be executed using various combinations of Reactive <ref> [8] </ref> and Active Object [9] schemes. <p> The example focuses on the configuration-related aspects of the distributed time service described in Section 3. In addition, this example illustrates the use of other patterns (such as the Reactor pattern <ref> [8] </ref> and the Acceptor and Connector patterns [5]) that are commonly used to develop communication services and ORBs. In the example below, the Concrete Service class in the OMT class diagram shown in Figure 3 is represented by the Time Server class, as well as the Clerk class. <p> A method in a Java Applet can access the thread it is running under using Thread.currentThread (), and then issue control messages to it such as suspend, resume, and stop. 11 Related Patterns A Service Configurator often makes use of the Reactor <ref> [8] </ref> pattern to perform event demultiplexing and dispatching on behalf of configured services. Likewise, dynamically configured services that execute for a long periods of time often use the Active Object pattern [14]. Administrative interfaces (such as configuration files or GUIs) to a Service Configurator-based system provide a Facade [15].
Reference: [9] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> (Reading, MA), </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Moreover, processes are often the wrong execution mechanism for many short-lived communication tasks (such as asking a Time Server for the current time or resolving a host address request in the Domain Name Service). In these cases, a multi-threaded Active Object <ref> [9] </ref> or a single-threaded Reactive [8] event loop may be more efficient. 3.3 Solution Often, a more convenient and flexible way to implement distributed services is to use the Service Configurator pattern. <p> the installation and administration of the services in an application by consolidating service attributes and initialization parameters in a single location. * Determine the service execution mechanism: A service that has been dynamically configured by a Service Configura-tor can be executed using various combinations of Reactive [8] and Active Object <ref> [9] </ref> schemes.
Reference: [10] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin-giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: reconfigure service implementations further exemplifies the flexibility offered by the Service Configurator pattern. 10 Known Uses The Service Configurator pattern is widely used in operating system and application programming environments including UNIX, Windows NT, ACE, and Java Applets: * Modern operating system device drivers: Modern operating systems (such as Solaris <ref> [10] </ref> and Windows NT [7]) provide support for dynamically configurable kernel-level device drivers. These drivers can be linked into and unlinked out of the system dynamically via init/fini/info hooks.
Reference: [11] <author> W. R. Stevens, </author> <title> UNIX Network Programming. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Two widely available network daemon management frameworks are inetd <ref> [11] </ref> and listen [12].
Reference: [12] <author> S. Rago, </author> <title> UNIX System V Network Programming. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Two widely available network daemon management frameworks are inetd [11] and listen <ref> [12] </ref>. Both frameworks consult configuration files that specify service names (such as the standard Internet services ftp, telnet, daytime, and echo), (2) port numbers to listen on for clients to connect with these services, and (3) an executable file to invoke and perform the service when a client connects.
Reference: [13] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: Each installed service is individually responsible for configuring itself and monitoring any communication endpoints (which may be more general than I/O ports, e.g., named pipes or shared memory). * The ADAPTIVE Communication Environment (ACE) framework: The ACE framework <ref> [13] </ref> provides a set of C++ mechanisms for configuring and controlling communication services dynamically. The ACE Service Configurator extends the mechanisms provided by 8 inetd, listen, and SCM to automatically support dynamic linking and unlinking of communication services.
Reference: [14] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, </title> <booktitle> in Proceed ings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-7, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Likewise, dynamically configured services that execute for a long periods of time often use the Active Object pattern <ref> [14] </ref>. Administrative interfaces (such as configuration files or GUIs) to a Service Configurator-based system provide a Facade [15]. This Facade simplifies the management and control of applications that are executing within the Service Configurator. The virtual methods provided by the Service base class are callback hooks [16].
Reference: [15] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Likewise, dynamically configured services that execute for a long periods of time often use the Active Object pattern [14]. Administrative interfaces (such as configuration files or GUIs) to a Service Configurator-based system provide a Facade <ref> [15] </ref>. This Facade simplifies the management and control of applications that are executing within the Service Configurator. The virtual methods provided by the Service base class are callback hooks [16]. These hooks are used by the Service Configurator to initiate, suspend, resume, and terminate services. <p> These hooks are used by the Service Configurator to initiate, suspend, resume, and terminate services. A Service (such as the Clerk class created by the make Clerk function in Section 9) may be created using a Factory Method <ref> [15] </ref>. This allows an application to decide which type of Service subclass to create. The Manager Pattern [17] manages a collection of objects by assuming responsibility for creating and deleting these objects. In addition, it provides an interface to allow client access to the objects it manages.
Reference: [16] <author> S. Berczuk, </author> <title> A Pattern for Separating Assembly and Processing, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Administrative interfaces (such as configuration files or GUIs) to a Service Configurator-based system provide a Facade [15]. This Facade simplifies the management and control of applications that are executing within the Service Configurator. The virtual methods provided by the Service base class are callback hooks <ref> [16] </ref>. These hooks are used by the Service Configurator to initiate, suspend, resume, and terminate services. A Service (such as the Clerk class created by the make Clerk function in Section 9) may be created using a Factory Method [15].
Reference: [17] <author> P. Sommerland and F. Buschmann, </author> <title> Manager, </title> <booktitle> in Proceedings of the 3 rd Pattern Languages of Programming Conference, </booktitle> <month> September </month> <year> 1996. </year> <month> 9 </month>
Reference-contexts: A Service (such as the Clerk class created by the make Clerk function in Section 9) may be created using a Factory Method [15]. This allows an application to decide which type of Service subclass to create. The Manager Pattern <ref> [17] </ref> manages a collection of objects by assuming responsibility for creating and deleting these objects. In addition, it provides an interface to allow client access to the objects it manages.
References-found: 17

