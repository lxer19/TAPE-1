URL: ftp://ftp.cs.washington.edu/pub/constraints/papers/hclp-iclp-89.ps.Z
Refering-URL: http://www.cs.washington.edu/research/constraints/hclp/hclp-iclp-89.html
Root-URL: 
Email: internet: borning@cs.washington.edu, mjm@ibm.com, amy@cs.washington.edu, molly@cs.washington.edu  
Title: Constraint Hierarchies and Logic Programming  
Author: Alan Borningy, Michael Maherz, Amy Martindaley, and Molly Wilsony 
Address: P.O. Box 704 Seattle, WA 98195 Yorktown Heights, NY 10598  
Affiliation: yComputer Science Dept, FR-35 zIBM T.J. Watson Research Ctr. University of Washington  
Abstract: Constraint Logic Programming (CLP) is a general scheme for extending logic programming to include constraints. It is parameterized by D, the domain of the constraints. However, CLP(D) languages, as well as most other constraint systems, only allow the programmer to specify constraints that must hold. In many applications, such as interactive graphics, page layout, and decision support, one needs to express preferences as well as strict requirements. If we wish to make full use of the constraint paradigm, we need ways to represent these defaults and preferences declaratively, as constraints, rather than encoding them in the procedural parts of the language. We describe a scheme for extending CLP(D) to include both required and preferential constraints, with an arbitrary number of strengths of preference. We present some of the theory of such languages, and an algorithm for executing them. To test our ideas, we have implemented an interpreter for an instance of this language scheme with D equal to the reals. We describe our interpreter, and outline some examples of using this language. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alan Borning, Robert Duisberg, Bjorn Freeman-Benson, Axel Kramer, and Michael Woolf. </author> <title> Constraint Hierarchies. </title> <booktitle> In Proceedings of the 1987 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 48-60. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1987. </year>
Reference-contexts: Early versions of ThingLab implemented these defaults in an ad hoc fashion as part of the constraint satisfaction algorithm. Later, to allow such defaults and preferences to be specified explicitly and declaratively, we devised a theory of constraint hierarchies <ref> [1] </ref>, which allows a user to specify not only constraints that must hold, but also weaker constraints at an arbitrary number of strengths. The constraint hierarchy scheme is parameterized by a comparator C that allows us to compare different possible solutions to the hierarchy and select the best ones. <p> The constraint hierarchy scheme is parameterized by a comparator C that allows us to compare different possible solutions to the hierarchy and select the best ones. We have also implemented several algorithms for satisfying such hierarchies within ThingLab <ref> [1, 6] </ref>. Defaults and preferences arise naturally when trying to use constraint logic programming for interactive graphics, as well as for other 2 applications, for example, decision support systems.
Reference: [2] <author> Alan Borning, Michael Maher, Amy Martindale, and Molly Wil-son. </author> <title> Constraint Hierarchies and Logic Programming. </title> <type> Technical Report 88-11-10, </type> <institution> Computer Science Department, University of Wash-ington, </institution> <month> November </month> <year> 1988. </year> <month> 15 </month>
Reference-contexts: However, since we have the full power of logic programming available to configure a network of constraints dynamically, we can do considerably more. For example, in <ref> [2] </ref> we describe a user interface example in which we use a recursive rule to set up constraints between each node of a tree and a view of that node on the display. 5 HCLP Theory 5.1 Definitions In this section we develop some of the theory of HCLP (D; C). <p> A complete description is given in <ref> [2] </ref>. In addition, we have written a proof of correctness for the algorithm, which we plan to publish separately [12]. The algorithm works for any constraint domain D, but is specific to the locally-predicate-better comparator. The algorithm has two phases.
Reference: [3] <author> Alan H. Borning. </author> <title> The Programming Language Aspects of ThingLab, A Constraint-Oriented Simulation Laboratory. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(4) </volume> <pages> 353-387, </pages> <month> October </month> <year> 1981. </year>
Reference-contexts: If we wish to make full use of the constraint paradigm, we need ways to represent these defaults and preferences declaratively, as constraints, rather than encoding them in the procedural parts of the language. Consider an interactive graphics example from our own work on ThingLab <ref> [3] </ref>. Suppose we have a line with a point constrained to lie at its midpoint. If we pick up one end of the line with the mouse and move it about, the constraint will ensure that the midpoint relation remains satisfied. <p> In a similar manner, we can (without any hard thinking required) translate all of the ThingLab examples given in <ref> [3] </ref> into HCLP. For the more complex examples, the HCLP code becomes tediously long. However (as with ThingLab), we envision such code being written automatically by the interactive graphics application, rather than by a 8 person.
Reference: [4] <author> Alain Colmerauer. </author> <title> An Introduction to Prolog III. </title> <type> Draft, </type> <institution> Groupe Intelligence Artificielle, Universite Aix-Marseille II, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: In place of unification (which can be viewed as testing the satisfiability of equations over the Herbrand universe), constraints are accumulated and tested for sat-isfiability over D, using techniques appropriate to the domain. Several 1 such languages have now been implemented, including Prolog III <ref> [4] </ref>, CLP (R) [7, 9] and CHIP [5]. The formal semantics of such languages differ mainly in the choice of underlying domain and constraints, as was shown formally in [8].
Reference: [5] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Bertheir. </author> <title> The Constraint Logic Programming Language CHIP. </title> <type> Draft, </type> <institution> European Computer-Industry Research Center, Mu-nich, West Germany. </institution>
Reference-contexts: Several 1 such languages have now been implemented, including Prolog III [4], CLP (R) [7, 9] and CHIP <ref> [5] </ref>. The formal semantics of such languages differ mainly in the choice of underlying domain and constraints, as was shown formally in [8].
Reference: [6] <author> Bjorn Freeman-Benson and John Maloney. </author> <title> The DeltaBlue Algorithm: An Incremental Constraint Hierarchy Solver. </title> <booktitle> In Proceedings of the Eighth Annual IEEE Phoenix Conference on Computers and Communications, </booktitle> <address> Scottsdale, Arizona, </address> <month> March </month> <year> 1989. </year> <note> IEEE. To appear. </note>
Reference-contexts: The constraint hierarchy scheme is parameterized by a comparator C that allows us to compare different possible solutions to the hierarchy and select the best ones. We have also implemented several algorithms for satisfying such hierarchies within ThingLab <ref> [1, 6] </ref>. Defaults and preferences arise naturally when trying to use constraint logic programming for interactive graphics, as well as for other 2 applications, for example, decision support systems.
Reference: [7] <author> N. Heintze, J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(&lt;) Programmer's Manual. </title> <type> Technical report, </type> <institution> Computer Science Dept, Monash University, </institution> <year> 1987. </year>
Reference-contexts: In place of unification (which can be viewed as testing the satisfiability of equations over the Herbrand universe), constraints are accumulated and tested for sat-isfiability over D, using techniques appropriate to the domain. Several 1 such languages have now been implemented, including Prolog III [4], CLP (R) <ref> [7, 9] </ref> and CHIP [5]. The formal semantics of such languages differ mainly in the choice of underlying domain and constraints, as was shown formally in [8].
Reference: [8] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proceedings of the 14th ACM Principles of Programming Languages Conference, </booktitle> <address> Munich, </address> <month> January </month> <year> 1987. </year> <note> ACM. </note>
Reference-contexts: 1 Introduction Recently there has been considerable research on extending logic programming to include constraints. This extension significantly increases the expressiveness of such languages. Constraint Logic Programming <ref> [8] </ref> is a general scheme for such extensions, and is parameterized by D, the domain of the constraints. The language that arises from a fixed set of constraints over D can be denoted by CLP (D). <p> Several 1 such languages have now been implemented, including Prolog III [4], CLP (R) [7, 9] and CHIP [5]. The formal semantics of such languages differ mainly in the choice of underlying domain and constraints, as was shown formally in <ref> [8] </ref>. It was also shown that for every language that can be obtained from the CLP scheme for solution-compact domains D, numerous desirable properties of the declarative and operational semantics hold|properties that had been considered characteristic of logic programming. In particular, CLP languages have coincident logical, fixedpoint, and operational semantics. <p> Although many of these results are analogs of results for CLP, some analogs do not hold for HCLP, for reasons discussed below. Due to space limitations some definitions have been omitted. For undefined notation or terminology see <ref> [8] </ref>. We write P j= D Q if Q holds in every model of P that has the same universe as D and assigns the same meaning to function symbols and constraint predicate symbols as D. We use (9) to denote existential closure.
Reference: [9] <author> J. Jaffar and S. Michaylov. </author> <title> Methodology and Implementation of a CLP System. </title> <booktitle> In Proceedings of the 4th International Conference on Logic Programming, </booktitle> <year> 1987. </year>
Reference-contexts: In place of unification (which can be viewed as testing the satisfiability of equations over the Herbrand universe), constraints are accumulated and tested for sat-isfiability over D, using techniques appropriate to the domain. Several 1 such languages have now been implemented, including Prolog III [4], CLP (R) <ref> [7, 9] </ref> and CHIP [5]. The formal semantics of such languages differ mainly in the choice of underlying domain and constraints, as was shown formally in [8].
Reference: [10] <author> William Leler. </author> <title> Constraint Programming Languages. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: In particular, CLP languages have coincident logical, fixedpoint, and operational semantics. Independent of logic programming, constraints have proven useful for a variety of applications, including geometric layout, physical simulations, user interface design, document formatting, algorithm animation, and design and analysis of mechanical devices and electrical circuits. (See <ref> [10] </ref> for a survey.) Many such applications require some notion of defaults and preferences. If we wish to make full use of the constraint paradigm, we need ways to represent these defaults and preferences declaratively, as constraints, rather than encoding them in the procedural parts of the language.
Reference: [11] <author> Katta G. Murty. </author> <title> Linear Programming. </title> <publisher> Wiley, </publisher> <year> 1983. </year>
Reference-contexts: The locally-better comparator is derived from the concept of a vector minimum (or pareto-optimal point, or nondominated feasible solution) in multiobjective linear program ming problems <ref> [11] </ref>. Finally, the standard linear programming problem of minimizing an objective function subject to a set of linear inequality conditions can be easily expressed as a constraint hierarchy.
Reference: [12] <author> Molly Wilson. </author> <title> A Proof of Correctness of an Algorithm for Executing Constraint Hierarchy Logic Programs. </title> <note> To be submitted for publication, 1989. 16 </note>
Reference-contexts: A complete description is given in [2]. In addition, we have written a proof of correctness for the algorithm, which we plan to publish separately <ref> [12] </ref>. The algorithm works for any constraint domain D, but is specific to the locally-predicate-better comparator. The algorithm has two phases. In the first phase, the algorithm attempts to reduce a goal using only predicates and required constraints, while building up a hierarchy of non-required constraints.
References-found: 12

