URL: ftp://ftp.cs.caltech.edu/tr/cs-tr-93-21.ps.Z
Refering-URL: ftp://ftp.cs.caltech.edu/tr/INDEX.html
Root-URL: http://www.cs.caltech.edu
Title: A Verified Integration of Imperative Parallel Programming Paradigms in an Object-Oriented Language  
Author: Paul Sivilotti 
Degree: Thesis by  In Partial Fulfillment of the Requirements for the Degree of Master of Science  
Date: 1993 (submitted 30 June 1993)  
Address: Pasadena, California  CS-TR-93-21  
Affiliation: California Institute of Technology  Caltech  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Selim G. Akl, </author> <title> The Design and Analysis of Parallel Algorithms, </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference: [2] <author> Gregory R. Andrews, </author> <title> Concurrent Programming: </title> <booktitle> Principles and Practice, </booktitle> <address> Benjamin-Cummings, </address> <year> 1991. </year>
Reference-contexts: Semaphores were introduced in [7] and are further discussed in [9], [14], and <ref> [2, Chapter 4] </ref>. 2.2 Specification Since the P () operation is not atomic, we distinguish between the initiation and the termination of this operation. <p> We choose here to allow the signaling process to continue executing inside the monitor. This signaling discipline is known as "signal and continue". Monitors were introduced in [9] and [8]. They are described in detail in <ref> [2] </ref> and [4], including extensions such as other possible signaling disciplines, extended primitives, and priority waiting. 3.2 Specification A monitor guarantees mutual exclusion implicitly by allowing only one of its member functions to be executing at a time. <p> The proof rules introduced in Hoare's classic paper [9] allow a valid implementation of wait to be "exit the monitor and suspend forever". Other collections of proof rules ([11] and <ref> [2] </ref>) have similar flaws, allowing spurious suspensions. It is a general observation that the specification of a monitor implies the proof rules, but not the converse. When a monitor is defined by its implementation using semaphores, the entire specification, including progress properties, is certainly captured with the specification of semaphores. <p> If there is no message to be removed, this operation suspends until there is such a message. Processes that receive messages are called consumers. The channel can be used by arbitrary and varying numbers of producers and consumers. Asynchronous channels are discussed in <ref> [2] </ref> and [5]. 4.2 Specification Since the blockingReceive () operation can suspend, it is not atomic, and we distinguish between the initiation and the termination of this operation.
Reference: [3] <author> Stephen F. Barker, </author> <title> The Elements of Logic, </title> <publisher> McGraw-Hill, </publisher> <year> 1989. </year>
Reference: [4] <editor> Lubomir Bic and Alan C. Shaw, </editor> <booktitle> The Logical Design of Operating Systems, </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: of iterations void Philosopher (Semaphore &left, Semaphore &right) f for (int i=0; i&lt;N; i++) f left.P (); right.P (); eat (); left.V (); right.V (); think (); g main () f Semaphore fork [5] = f1,1,1,1,1g; par f parfor (int i=0; i3; i++) Philosopher (fork [i],fork [i+1]); Philosopher (fork [0],fork <ref> [4] </ref>); g Discussion Arrays of semaphores can be declared and each semaphore initialized with its own value. In this case, fork is an array of 5 semaphores, each of which is initialized with the value 1. One must be careful when passing semaphores to functions. <p> We choose here to allow the signaling process to continue executing inside the monitor. This signaling discipline is known as "signal and continue". Monitors were introduced in [9] and [8]. They are described in detail in [2] and <ref> [4] </ref>, including extensions such as other possible signaling disciplines, extended primitives, and priority waiting. 3.2 Specification A monitor guarantees mutual exclusion implicitly by allowing only one of its member functions to be executing at a time.
Reference: [5] <author> K. Mani Chandy and Jayadev Misra, </author> <title> Parallel Program Design: A Foundation, </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: A fork cannot be simultaneously held by two people. #define N 20 //number of iterations void Philosopher (Semaphore &left, Semaphore &right) f for (int i=0; i&lt;N; i++) f left.P (); right.P (); eat (); left.V (); right.V (); think (); g main () f Semaphore fork <ref> [5] </ref> = f1,1,1,1,1g; par f parfor (int i=0; i3; i++) Philosopher (fork [i],fork [i+1]); Philosopher (fork [0],fork [4]); g Discussion Arrays of semaphores can be declared and each semaphore initialized with its own value. <p> Philosophers cycle between thinking and eating. In order to eat, a philosopher needs both the fork to his left and the fork to his right. A fork cannot be simultaneously held by two people. 31 class DiningRoom : private Monitor f private: int forks <ref> [5] </ref>; Condition forks available [5]; public: DiningRoom (void) f parfor (int i=0; i4; i++) forks [i] = 2; g void start eating (int i) f enter (); if (forks [i] 6= 2) wait (forks available [i]); forks [(i+4)%5] -= 1; forks [(i+1)%5] -= 1; leave (); g void stop eating (int <p> Philosophers cycle between thinking and eating. In order to eat, a philosopher needs both the fork to his left and the fork to his right. A fork cannot be simultaneously held by two people. 31 class DiningRoom : private Monitor f private: int forks <ref> [5] </ref>; Condition forks available [5]; public: DiningRoom (void) f parfor (int i=0; i4; i++) forks [i] = 2; g void start eating (int i) f enter (); if (forks [i] 6= 2) wait (forks available [i]); forks [(i+4)%5] -= 1; forks [(i+1)%5] -= 1; leave (); g void stop eating (int i) f enter (); <p> If there is no message to be removed, this operation suspends until there is such a message. Processes that receive messages are called consumers. The channel can be used by arbitrary and varying numbers of producers and consumers. Asynchronous channels are discussed in [2] and <ref> [5] </ref>. 4.2 Specification Since the blockingReceive () operation can suspend, it is not atomic, and we distinguish between the initiation and the termination of this operation.
Reference: [6] <author> K. Mani Chandy and Stephen Taylor, </author> <title> An Introduction to Parallel Programming, </title> <publisher> Jones and Bartlett Publishers, </publisher> <year> 1992. </year>
Reference-contexts: j++) Cell (to right [i][j-1], to left [i][j+1], to below [i-1][j], to above [i+1][j], to left [i][j], to right [i][j], to above [i][j], to below [i][j],0); g /flparfl/ g /flparforfl/ g Discussion A mesh of processes communicating via channels can also be set up by recursion, as is done in <ref> [6, Section 8.2] </ref>. This avoids the declaration 62 of a global array of channels. An iterative approach was chosen here for the sake of clarity of code and to illustrate the integration of channels and arrays. Also note that the channels are passed as reference parameters.
Reference: [7] <author> Edsgar W. Dijkstra, </author> <title> Cooperating sequential processes, </title> <institution> Mathematics Dept., Technological University, Eindhoven, </institution> <address> The Netherlands, </address> <year> 1965. </year>
Reference-contexts: If, on the other hand, the value of the semaphore is 0 (and therefore a decrement would violate the invariant that the value be non-negative), then the P () operation suspends until the decrement may be safely performed. Semaphores were introduced in <ref> [7] </ref> and are further discussed in [9], [14], and [2, Chapter 4]. 2.2 Specification Since the P () operation is not atomic, we distinguish between the initiation and the termination of this operation.
Reference: [8] <author> Per Brinch Hansen, </author> <title> Operating System Principles, </title> <publisher> Prentice-Hall, </publisher> <year> 1973. </year>
Reference-contexts: We choose here to allow the signaling process to continue executing inside the monitor. This signaling discipline is known as "signal and continue". Monitors were introduced in [9] and <ref> [8] </ref>. They are described in detail in [2] and [4], including extensions such as other possible signaling disciplines, extended primitives, and priority waiting. 3.2 Specification A monitor guarantees mutual exclusion implicitly by allowing only one of its member functions to be executing at a time.
Reference: [9] <author> Hoare, </author> <title> C.A.R., Monitors: an operating system structuring concept, </title> <journal> Comm. ACM 17, </journal> <volume> 10 (October), </volume> <pages> 549-557, </pages> <year> 1974. </year> <title> Corrigendum, </title> <journal> Comm. ACM 18, </journal> <volume> 2 (February), 95, </volume> <year> 1975. </year>
Reference-contexts: If, on the other hand, the value of the semaphore is 0 (and therefore a decrement would violate the invariant that the value be non-negative), then the P () operation suspends until the decrement may be safely performed. Semaphores were introduced in [7] and are further discussed in <ref> [9] </ref>, [14], and [2, Chapter 4]. 2.2 Specification Since the P () operation is not atomic, we distinguish between the initiation and the termination of this operation. <p> We choose here to allow the signaling process to continue executing inside the monitor. This signaling discipline is known as "signal and continue". Monitors were introduced in <ref> [9] </ref> and [8]. They are described in detail in [2] and [4], including extensions such as other possible signaling disciplines, extended primitives, and priority waiting. 3.2 Specification A monitor guarantees mutual exclusion implicitly by allowing only one of its member functions to be executing at a time. <p> For our purposes, the former is insuffi-cient and the latter unsatisfying. A collection of axiomatic proof rules is not sufficient because they often neglect to enforce any kind of progress condition. The proof rules introduced in Hoare's classic paper <ref> [9] </ref> allow a valid implementation of wait to be "exit the monitor and suspend forever". Other collections of proof rules ([11] and [2]) have similar flaws, allowing spurious suspensions. It is a general observation that the specification of a monitor implies the proof rules, but not the converse.
Reference: [10] <author> John E. Hopcroft and Jeffrey D. Ullman, </author> <title> Introduction to Automata Theory, Languages, and Computation, </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference: [11] <author> Howard, J.H., </author> <title> Proving Monitors, </title> <journal> Comm. ACM 19, </journal> <volume> 5 (May), </volume> <pages> 273-279, </pages> <year> 1976. </year>
Reference: [12] <author> Carl Kesselman and K. Mani Chandy, </author> <title> CC ++ : A Declarative Concur--rent Object Oriented Programming Language, </title> <institution> CS-TR-92-01, California Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: Also, the CC ++ operators &lt;< void and &gt;> void are invoked for the message since it is a parameter in the RPC. For a more complete discussion of these CC ++ constructs, see [15] and <ref> [12] </ref>. 5.3.3 Local Copy of Messages The purpose of the transport layer is to make the cost of the physical transfer of data to a remote (non-local) address space as transparent to the sending process as possible.
Reference: [13] <author> Harry R. Lewis, Christos H. Papadimitriou, C.H., </author> <title> Elements of the Theory of Computation, </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference: [14] <author> Martin, A.J., </author> <title> An Axiomatic Definition of Synchronization Primitives, </title> <journal> Acta Informatica 16, </journal> <volume> p219-235, </volume> <year> 1981. </year>
Reference-contexts: If, on the other hand, the value of the semaphore is 0 (and therefore a decrement would violate the invariant that the value be non-negative), then the P () operation suspends until the decrement may be safely performed. Semaphores were introduced in [7] and are further discussed in [9], <ref> [14] </ref>, and [2, Chapter 4]. 2.2 Specification Since the P () operation is not atomic, we distinguish between the initiation and the termination of this operation.
Reference: [15] <author> Adam Rifkin, </author> <title> A CC ++ Primer for C Programmers, </title> <institution> CS-TR-93-14, Cal-ifornia Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: Also, the CC ++ operators &lt;< void and &gt;> void are invoked for the message since it is a parameter in the RPC. For a more complete discussion of these CC ++ constructs, see <ref> [15] </ref> and [12]. 5.3.3 Local Copy of Messages The purpose of the transport layer is to make the cost of the physical transfer of data to a remote (non-local) address space as transparent to the sending process as possible.
Reference: [16] <institution> The Hypercube Project Programmer's Manual, JPL D-3220, </institution> <month> October 30, </month> <year> 1989. </year>
References-found: 16

