URL: ftp://theory.cs.uni-bonn.de/pub/reports/cs-reports/1995/85132-cs.ps.gz
Refering-URL: http://cs.uni-bonn.de/info5/publications/CS-1995-en.html
Root-URL: http://cs.uni-bonn.de
Email: Email:marek@cs.uni-bonn.de  Email:wojtekp@mimuw.edu.pl  Email:rytter@mimuw.edu.pl  
Phone: 56/142-1.  
Title: The Fully Compressed String Matching for Lempel-Ziv Encoding  
Author: Marek Karpinski Wojciech Plandowski Wojciech Rytter 
Note: This research was partially supported by DFG Grant KA 673/4-1, and by the ESPRIT BR Grant 7097 and ECUS 030.  Partially supported by the KBN Grant.  Supported partially by the DFG Grant Bo  
Address: Bonn, 53117 Bonn.  02-097 Warszawa.  02-097 Warszawa.  
Affiliation: Dept. of Computer Science, University of  Institute of Informatics, Warsaw University,  Institute of Informatics, Warsaw University,  
Abstract: The growing importance of massively stored information requires new approaches to efficient algorithms on texts represented in a compressed form. We consider here the string-matching problem in the compressed setting. This problem has been already investigated in [2], [3], [1]. A rather theoretical type of compression was considered in [8]. In this paper we consider a practically important compression algorithm of Lempel and Ziv (LZ algorithm, in short). Denote by LZ(w) the compressed version of a given string w using the LZ algorithm. The Fully Compressed Matching Problem is that of deciding if the pattern P occurs in a text T , given only LZ(P ) and LZ(T ), without decompressing the pattern and the text. The first occurrence is reported, if there is any. Let m and n denote the sizes of LZ(P ) and LZ(T ), and M , N be the sizes of uncompressed strings P and T , respectively. In this paper we design the first polynomial time (with respect to n and m) algorithm for the Fully Compressed Matching Problem. Note that in generall N , M are exponential with respect to n and m, and any algorithm which explicitely decompresses the pattern P or the text T would work in exponential time! In particular the algorithm given in [5] works in this situation in exponential time with respect to m (in this algorithm the uncompressed pattern is a part of the input). The situations when both objects participating in the string-matching are compressed (we deal with compressed patterns) are also practically important, for example in genetics and molecular biology (where uncompressed patterns are extremely long) or when we search for one compressed file in another compressed file. We introduce a new technique of succinct representations for long string periods and overlaps. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.Amir, G. Benson and M. Farach, </author> <title> Let sleeping files lie: pattern-matching in Z-compressed files, </title> <booktitle> in SODA'94. </booktitle>
Reference-contexts: Compression is a kind of succinct representation. The complexity of succinctly represented graphs was already investigated in many papers. However in the algorithmics of textual problems only recently the problems related to compressed objects were investigated ([2], [3], <ref> [1] </ref> and [8]). The compressed matching problem was investigated in [5], where the Lempel-Ziv (LZ) compression was considered. The LZ compression (see [14]) gives a very natural way of representing a string. <p> Assume that is an underlying alphabet and let w be a string over . The factorization of w is given by a decomposition: w = c 1 f 1 c 2 : : : f k c k+1 , where c 1 = w <ref> [1] </ref> and for each 1 i k c i 2 and f i is the longest prefix of f i c i+1 : : : f k c k+1 which appears in c 1 f 1 c 2 : : : f i1 c i . <p> After identifying each subword f i with its corresponding interval we obtain the LZ encoding of the string. Hence LZ (aababbabbababbabb#) = a <ref> [1; 1] </ref>b [1; 2]b [4; 6]a [2; 10]#. 1.2 Composition systems We introduce some useful abstraction of the LZ encoding. The composition systems (introduced here) are variations of straight line programs and context-free grammars. Introduce the set VAR (S) of variables of a composition system S. <p> After identifying each subword f i with its corresponding interval we obtain the LZ encoding of the string. Hence LZ (aababbabbababbabb#) = a [1; 1]b <ref> [1; 2] </ref>b [4; 6]a [2; 10]#. 1.2 Composition systems We introduce some useful abstraction of the LZ encoding. The composition systems (introduced here) are variations of straight line programs and context-free grammars. Introduce the set VAR (S) of variables of a composition system S. <p> The first mismatch can be computed using an equality-test algorithm from Theorem 2.3. 9 ALGORITHM SECOND PHASE ; for k = 1 to n do if the rule for X k is X k = a then if P = a then report occurrence and STOP else compute PREF <ref> [1; k] </ref>, SUFF [1; k] else fX k = X i [s] X [t] pref := Cut (PREF [jval (X i )j; i]; s); suf f := Cut (SUFF [1; j]; t); pos := Solution (jP j; pref; suf f ); if pos 6= 0 then report an occurrence and STOP <p> mismatch can be computed using an equality-test algorithm from Theorem 2.3. 9 ALGORITHM SECOND PHASE ; for k = 1 to n do if the rule for X k is X k = a then if P = a then report occurrence and STOP else compute PREF <ref> [1; k] </ref>, SUFF [1; k] else fX k = X i [s] X [t] pref := Cut (PREF [jval (X i )j; i]; s); suf f := Cut (SUFF [1; j]; t); pos := Solution (jP j; pref; suf f ); if pos 6= 0 then report an occurrence and STOP else for each <p> for X k is X k = a then if P = a then report occurrence and STOP else compute PREF [1; k], SUFF [1; k] else fX k = X i [s] X [t] pref := Cut (PREF [jval (X i )j; i]; s); suf f := Cut (SUFF <ref> [1; j] </ref>; t); pos := Solution (jP j; pref; suf f ); if pos 6= 0 then report an occurrence and STOP else for each finger b in F IN GERS (X k ) do if b &gt; s then U := PrefExt (pref; val (X k )[s + 1::b]) [
Reference: [2] <author> A.Amir, G. Benson, </author> <title> Efficient two dimensional compressed matching, </title> <booktitle> Proc. of the 2nd IEEE Data Compression Conference 279-288 (1992) </booktitle>
Reference-contexts: After identifying each subword f i with its corresponding interval we obtain the LZ encoding of the string. Hence LZ (aababbabbababbabb#) = a [1; 1]b <ref> [1; 2] </ref>b [4; 6]a [2; 10]#. 1.2 Composition systems We introduce some useful abstraction of the LZ encoding. The composition systems (introduced here) are variations of straight line programs and context-free grammars. Introduce the set VAR (S) of variables of a composition system S. <p> After identifying each subword f i with its corresponding interval we obtain the LZ encoding of the string. Hence LZ (aababbabbababbabb#) = a [1; 1]b [1; 2]b [4; 6]a <ref> [2; 10] </ref>#. 1.2 Composition systems We introduce some useful abstraction of the LZ encoding. The composition systems (introduced here) are variations of straight line programs and context-free grammars. Introduce the set VAR (S) of variables of a composition system S. <p> The value of the last variable of the composition system S ( denoted val (S)) is the value of S. Example Consider the following composition system S: A = a; B = b; C = A B; D = B C; E = C D; F = D <ref> [2] </ref> E [4] ; G = E F . We have here val (S) = val (G) = abbabababba. We say that the systems S 1 , S 2 are equivalent iff val (S 1 ) = val (S 2 ).
Reference: [3] <author> A.Amir, G. Benson and M. Farach, </author> <title> Optimal two-dimensional compressed matching, </title> <booktitle> in ICALP'94 </booktitle>
Reference-contexts: Compression is a kind of succinct representation. The complexity of succinctly represented graphs was already investigated in many papers. However in the algorithmics of textual problems only recently the problems related to compressed objects were investigated ([2], <ref> [3] </ref>, [1] and [8]). The compressed matching problem was investigated in [5], where the Lempel-Ziv (LZ) compression was considered. The LZ compression (see [14]) gives a very natural way of representing a string.
Reference: [4] <author> M. Crochemore and W. Rytter, </author> <title> Text Algorithms, </title> <publisher> Oxford University Press, </publisher> <address> New York (1994). </address>
Reference-contexts: After identifying each subword f i with its corresponding interval we obtain the LZ encoding of the string. Hence LZ (aababbabbababbabb#) = a [1; 1]b [1; 2]b <ref> [4; 6] </ref>a [2; 10]#. 1.2 Composition systems We introduce some useful abstraction of the LZ encoding. The composition systems (introduced here) are variations of straight line programs and context-free grammars. Introduce the set VAR (S) of variables of a composition system S. <p> Example Consider the following composition system S: A = a; B = b; C = A B; D = B C; E = C D; F = D [2] E <ref> [4] </ref> ; G = E F . We have here val (S) = val (G) = abbabababba. We say that the systems S 1 , S 2 are equivalent iff val (S 1 ) = val (S 2 ).
Reference: [5] <author> M. Farach and M. </author> <title> Thorup, String matching in Lempel-Ziv compressed strings, </title> <note> to appear in STOC'95. </note>
Reference-contexts: Compression is a kind of succinct representation. The complexity of succinctly represented graphs was already investigated in many papers. However in the algorithmics of textual problems only recently the problems related to compressed objects were investigated ([2], [3], [1] and [8]). The compressed matching problem was investigated in <ref> [5] </ref>, where the Lempel-Ziv (LZ) compression was considered. The LZ compression (see [14]) gives a very natural way of representing a string. <p> Question: does P [i::j] = T [i 0 ::j 0 ] ? If "no" then find the first mismatch. 1.1 The Lempel-Ziv compression. There is a large number of possible variations of the LZ algorithm. We consider the same version as in <ref> [5] </ref> (this is called LZ1 in [5]). Intuitively, LZ algorithm compresses the text because it is able to discover some repeated subwords. We consider the version of LZ algorithm without self-referencing. Our algorithms can be extended to the general self-referential case. <p> Question: does P [i::j] = T [i 0 ::j 0 ] ? If "no" then find the first mismatch. 1.1 The Lempel-Ziv compression. There is a large number of possible variations of the LZ algorithm. We consider the same version as in <ref> [5] </ref> (this is called LZ1 in [5]). Intuitively, LZ algorithm compresses the text because it is able to discover some repeated subwords. We consider the version of LZ algorithm without self-referencing. Our algorithms can be extended to the general self-referential case. Assume that is an underlying alphabet and let w be a string over . <p> In the first phase of the algorithm in each word val (X k ) at most 2n positions are being distinguished. They are called fingers and are denoted by F IN GERS (X k ). They correspond to informers in <ref> [5] </ref>. The positions in F IN GERS (X k ) are those predecessors of end-positions of variables that are in the word val (X k ).
Reference: [6] <author> M.R. Garey and D.S. Johnson, </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. W.H. </title> <publisher> Freeman (1979). </publisher>
Reference-contexts: After identifying each subword f i with its corresponding interval we obtain the LZ encoding of the string. Hence LZ (aababbabbababbabb#) = a [1; 1]b [1; 2]b <ref> [4; 6] </ref>a [2; 10]#. 1.2 Composition systems We introduce some useful abstraction of the LZ encoding. The composition systems (introduced here) are variations of straight line programs and context-free grammars. Introduce the set VAR (S) of variables of a composition system S.
Reference: [7] <author> R.M. Karp and M. Rabin, </author> <title> Efficient randomized pattern matching algorithms, </title> <journal> IBM Journal of Research and Dev. </journal> <volume> 31, </volume> <month> pp.249-260 </month> <year> (1987). </year>
Reference: [8] <author> M. Karpinski, W. Rytter and A. Shinohara, </author> <title> Pattern-matching for strings with short description, to appear in Combinatorial Pattern Matching, </title> <year> 1995 </year>
Reference-contexts: Compression is a kind of succinct representation. The complexity of succinctly represented graphs was already investigated in many papers. However in the algorithmics of textual problems only recently the problems related to compressed objects were investigated ([2], [3], [1] and <ref> [8] </ref>). The compressed matching problem was investigated in [5], where the Lempel-Ziv (LZ) compression was considered. The LZ compression (see [14]) gives a very natural way of representing a string. <p> We say that a set of positive integers from [1 : : :N ] is succinct w.r.t. N iff it can be decomposed in at most blog 2 (N )c + 1 linear sets. The following lemma was shown in <ref> [8] </ref>. Lemma 1.3 (succinct sets lemma) The set Periods (w) is succinct w.r.t. jwj. Denote ArithProg (i; p; k) = fi; i + p; i + 2p; : : : ; i + kpg, so it is an arithmetic progression of length k + 1. <p> Then the representation of PrefExt (S; val (W) can be computed in polynomial time. Proof. The proof is similar to the proof of Lemma 7 in <ref> [8] </ref>. Assume the sequence t 0 ; t 1 ; : : : ; t s is decreasing. Denote p = t 0 t 1 . Since S is linear p = t i t i+1 for 1 i s.
Reference: [9] <author> D. Knuth, </author> <title> The Art of Computing, Vol. II: Seminumerical Algorithms. Second edition. </title> <publisher> Addison-Wesley (1981). </publisher> <pages> 11 </pages>
Reference: [10] <author> A. Lempel and J.Ziv, </author> <title> On the complexity of finite sequences, </title> <journal> IEEE Trans. on Inf. Theory 22, </journal> <month> 75-81 </month> <year> (1976) </year>
Reference-contexts: After identifying each subword f i with its corresponding interval we obtain the LZ encoding of the string. Hence LZ (aababbabbababbabb#) = a [1; 1]b [1; 2]b [4; 6]a <ref> [2; 10] </ref>#. 1.2 Composition systems We introduce some useful abstraction of the LZ encoding. The composition systems (introduced here) are variations of straight line programs and context-free grammars. Introduce the set VAR (S) of variables of a composition system S.
Reference: [11] <author> M. </author> <title> Lothaire, Combinatorics on Words. </title> <publisher> Addison-Wesley (1993). </publisher>
Reference: [12] <author> W. Plandowski, </author> <title> Testing equivalence of morphisms on context-free languages, </title> <booktitle> ESA'94, Lecture Notes in Computer Science 855, </booktitle> <publisher> Springer-Verlag, </publisher> <month> 460-470 </month> <year> (1994). </year>
Reference-contexts: The value of this operation is a set of one or two items: ff is split into "smaller" items. The operation satisfies: fffg j SP LIT (ff). The operation SP LIT can be defined formally in a similar way as in <ref> [12] </ref>. We describe only how overlap items are split, other types of items are split similarly. Assume A; B 2 V AR (S 1 ) [ V AR (S 2 ). <p> The global structure of the algorithm is: Initially: = fff 0 g invariant1: j fff 0 g. invariant2: jj is polynomial. Finally: consists only of atomic items. Assume is a set of overlap items. We use the operation Compact (). Essentially this operation works similarly as in <ref> [12] </ref>. The operation removes from some number of overlap item and possibly inserts other overlap items (related to the same variables as removed items). Assume that for each atomic item ff SP LIT (ff) = fffg.
Reference: [13] <author> J.Storer, </author> <title> Data compression: methods and theory, </title> <publisher> Computer Science Press, </publisher> <address> Rockville, Maryland, </address> <year> 1988 </year>
Reference: [14] <author> J.Ziv and A.Lempel, </author> <title> A universal algorithm for sequential data compression, </title> <journal> IEEE Trans. on Inf. Theory 17, </journal> <pages> 8-19, </pages> <year> 1984 </year> <month> 12 </month>
Reference-contexts: However in the algorithmics of textual problems only recently the problems related to compressed objects were investigated ([2], [3], [1] and [8]). The compressed matching problem was investigated in [5], where the Lempel-Ziv (LZ) compression was considered. The LZ compression (see <ref> [14] </ref>) gives a very natural way of representing a string. In this paper we consider the Fully Compressed Matching Problem: Instance: a compressed pattern LZ (P ) and a compressed text LZ (T ) Question: does P occurs in T ? If "yes" then report the first occurrence.
References-found: 14

