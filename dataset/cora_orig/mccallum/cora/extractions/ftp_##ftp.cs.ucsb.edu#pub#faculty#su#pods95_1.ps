URL: ftp://ftp.cs.ucsb.edu/pub/faculty/su/pods95_1.ps
Refering-URL: ftp://ftp.cs.ucsb.edu/pub/faculty/su/pods95_1.html
Root-URL: http://www.cs.ucsb.edu
Title: Dense-Order Constraint Databases (Extended Abstract)  
Author: Stephane Grumbach Jianwen Su flfl 
Address: Santa Barbara  
Affiliation: University of Toronto and INRIA  University of California at  
Abstract: We consider infinite databases which admit a finite representation in terms of dense-order constraints. We study the complexity and the expressive power of various query languages over dense order constraint databases, allowing order, addition, recursion, or nested sets. We provide in particular an exact characterization of the class of dense order queries computable in PTIME (data complexity). We also prove that region and graph connectivity queries are not definable with linear constraints. We then investigate complex object models for constraint databases. Complex objects are fundamental to deal with pointsets as first-class citizens. We introduce an active domain semantics, and show that in terms of complexity and expressive power, the characterizations of the calculus for constraint complex objects are similar to the case of the classical complex object calculus. 
Abstract-found: 1
Intro-found: 1
Reference: [AB87] <author> S. Abiteboul and C. Beeri. </author> <title> On the power of languages for the manipulation of complex objects. </title> <booktitle> In Proc. Int. Workshop on Theory and Applications of Nested Relations and Complex Objects (extended abstract), </booktitle> <address> Darmstadt, </address> <year> 1987. </year> <note> INRIA research report 846. </note>
Reference-contexts: On the other hand, a great amount of research has been done on hierarchical database structures, in particular, those constructed using the tuple and set constructs such as the nested or non first normal form relations (e.g., [JS82, FT83, RKS88]), and the complex objects (e.g., <ref> [AB87, HS91, GV91] </ref>). Query languages for complex objects have been extensively studied, and their complexity is now well understood. Complex objects provide a modeling power which is fundamental in the context of constraint databases. <p> We next consider a logic-based query language for constraint complex object databases. Syntactically, the query language is defined over the language L c in a way very similar to the classical complex object calculus presented in <ref> [AB87, HS91, GV91] </ref> and with the following extension. "Set terms" may be composed in the following manner: if ' is a formula with free variables in fx 1 ; : : : ; x n g, then f (x 1 ; : : : ; x n ) j 'g is <p> The construction of Q is similar to that presented in the proof of similar results for the classical complex object calculus with invention [HS91, HS93]. 2 In this paper, we propose a semantics for C-CALC which is analogous to the active domain semantics for the classical complex object calculus <ref> [AB87, HS91, GV91] </ref>. In particular, under this semantics, the range of each set variable consists of a finite number of c-objects. The number and also the actual c-objects depend on the input database. <p> Theorem 5.2 PTIME C-CALC 1 PSPACE. Proof: (Sketch) The upper bound result is obtained similarly to the classical complex object case [HS91] but focusing on maximal covers. To see the lower bound, it is sufficient to observe that one can simulate fixpoint computation with one level of set nesting <ref> [AB87] </ref>. 2 Let H i (i 0) be families of functions from N to N such that H 0 = f p j p is a polynomial g and H i = f 2 f j f 2 H i1 g for i 1.
Reference: [ACGK94] <author> F. Afrati, S. Cosmadakis, S. Grum-bach, and G. Kuper. </author> <title> Expressiveness of linear vs. polynomial constraints in database query languages. </title> <booktitle> In Proc. Workshop on the Principles and Practice of Constraint Programming, </booktitle> <year> 1994. </year>
Reference-contexts: There are many challenging problems from both practical and theoretical points of view. In recent years, there has been a growing interest in constraint-based databases and query languages (e.g., <ref> [KKR90, Rev93, Kup93, BJM93, KG94, ACGK94, GS94, PVV94, GST95] </ref>). Constraint database models extend the traditional relational databases [Cod70] to potentially infinite collections of data items under the assumption that the databases admit finite representations. <p> Examples which are not queries include convex hull, Voronoi diagram, etc. For these latter examples from computational geometry, dense order constraints are not very appropriate. Instead, linear constraints are necessary. The expressive power of first-order in the case of linear constraint databases has been studied in <ref> [ACGK94, GST95] </ref>. The "data complexity" of queries is defined as usual based on computational devices and "standard encodings" of the input and output. We first introduce the standard encoding of a database, which is obtained by encoding the quantifier-free formula representing it.
Reference: [AV89] <author> S. Abiteboul and V. Vianu. </author> <title> Fixpoint extensions of first-order logic and datalog like languages. </title> <booktitle> In Proc. 4th Symp. on Logic in Computer Science, </booktitle> <pages> pages 71-79, </pages> <year> 1989. </year>
Reference-contexts: Addition or Recursion In this section, we consider the following query languages: * FO | first-order with dense-order constraints, * FO + | FO with linear constraints (with a built-in addition, +), and * Datalog : | inflationary Datalog with negation with dense-order constraints (or similarly infla tionary fixpoint logic <ref> [AV89, GS86] </ref>). We shall focus on their expressive power and complexity. The language FO over dense-order constraints is essentially first-order logic over the language f=; g [ . Datalog with (dense-order) constraints is defined as follows.
Reference: [BJM93] <author> A. Brodsky, J. Jaffar, and M. J. Maher. </author> <title> Towards practical constraint databases. </title> <booktitle> In Proc. Int. Conf. on Very Large Data Bases, </booktitle> <pages> pages 567-580, </pages> <year> 1993. </year>
Reference-contexts: There are many challenging problems from both practical and theoretical points of view. In recent years, there has been a growing interest in constraint-based databases and query languages (e.g., <ref> [KKR90, Rev93, Kup93, BJM93, KG94, ACGK94, GS94, PVV94, GST95] </ref>). Constraint database models extend the traditional relational databases [Cod70] to potentially infinite collections of data items under the assumption that the databases admit finite representations.
Reference: [BK95] <author> A. Brodsky and Y. Kornatzky. </author> <title> The L yri C language: Querying constraint objects. </title> <booktitle> In Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <year> 1995. </year>
Reference-contexts: In practical examples, there are properties naturally associated to pointsets and not to individual points (e.g., rainfall, population, etc. in geographical databases). The need for hierarchically structured or aggregation constraints has already been observed <ref> [KG94, Kup93, SRR94, SRS94, Rev95, BK95] </ref>. We develop a complex object model for constraint databases. Intuitively, "complex constraint objects" are composed from finitely representable sets by the tuple and set constructs. A logic based query language C-CALC is also proposed which uses the "active domain" semantics.
Reference: [CH80] <author> A. K. Chandra and D. Harel. </author> <title> Computable queries for relational data bases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-78, </pages> <year> 1980. </year>
Reference-contexts: In this paper, we restrict our attention to databases which admit a finite representation with dense order constraints over the rational numbers Q = (Q; ). We generalize the classical definition of relational queries <ref> [CH80] </ref> to "dense order" databases and consider queries closed under automorphisms of Q. We study the complexity and the expressive power of query languages for such databases. As shown in [GS94], this topic has been only hardly investigated, and there is a serious lack of proof techniques. <p> q (a 1 ; b 1 ) q t (a 4 ; b 4 ) q (a 5 ; b 5 ) (a 6 ; b 6 ) q q (a 7 ; b 7 ) 3 Queries The notion of a database query was introduced by Chandra and Harel <ref> [CH80] </ref> as a mapping Q from (finite) structures over a given signature to (finite) relations of a fixed arity n, which is partial recursive and satisfies the following consistency criterion: if two structures, A and B, over are isomorphic under an isomorphism , then Q (A) and Q (B) are also <p> It is easy to see that automorphisms of Q preserve the finite representability of structures, that is, if A is a finitely representable expansion of Q, and is an automorphism 1 of Q, then (A) is also finitely representable. This allows us to extend naturally the definition of <ref> [CH80] </ref> to finitely representable databases (where the recursiveness is with respect to the finite representation of the relations). Definition 3.1 A boolean query K is a partial recursive collection of finitely representable database instances over closed under automorphisms of Q. The definition of non boolean queries is then classical. <p> In other words, it was shown that: PTIME relational input/output Inflationary Datalog : PTIME dense-order input/output = PTIME In our result, PTIME denotes a set of queries over dense-order constraint databases, and not over relational databases as defined in <ref> [CH80] </ref>. Proof of Theorem 4.4 (Sketch). The inclusion of inflationary Datalog : in PTIME has been shown in [KKR90]. We only prove the converse inclusion.
Reference: [CK73] <author> C.C. Chang and H.J. Keisler. </author> <title> Model Theory, </title> <booktitle> volume 73 of Studies in Logic. </booktitle> <publisher> North-Holland, </publisher> <year> 1973. </year>
Reference-contexts: It is easy to see that under the restriction to finitely representable databases, first-order sentences and boolean inflationary Datalog : programs define boolean queries. The theory of dense order without endpoints is decidable and admits quantifier elimination procedures <ref> [CK73] </ref>. It has been shown in [GS94], that it is a sufficient and necessary condition for first-order logic to define a query language. The data complexity of queries in first-order logic and in Datalog : has been studied in [KKR90, KG94].
Reference: [Cod70] <author> E.F. Codd. </author> <title> A relational model of data for large shared data banks. </title> <journal> Communications of ACM, </journal> <volume> 13:6:377-387, </volume> <year> 1970. </year>
Reference-contexts: There are many challenging problems from both practical and theoretical points of view. In recent years, there has been a growing interest in constraint-based databases and query languages (e.g., [KKR90, Rev93, Kup93, BJM93, KG94, ACGK94, GS94, PVV94, GST95]). Constraint database models extend the traditional relational databases <ref> [Cod70] </ref> to potentially infinite collections of data items under the assumption that the databases admit finite representations. As introduced in the seminal paper by Kanellakis, Kuper and Revesz [KKR90], the basic idea is to generalize the relations by allowing generalized tuples as conjunctions of constraints. <p> A generalized tuple is a finite representation of a potentially infinite set of tuples over ratio-nals. A k-ary finitely representable relation (or generalized relation in [KKR90]) is then a finite set of k-ary generalized tuples. In this framework, a tuple (a; b) in the classical relational data model <ref> [Cod70] </ref> is an abbreviation for the formula (constraint) "(x = a ^ y = b)" represented using only the equality symbol "=" and constants.
Reference: [Col75] <author> G. E. Collins. </author> <title> Quantifier elimination for real closed fields by cylindric decompositions. </title> <booktitle> In Proc. 2nd GI Conf. Automata Theory and FOrmal Languages, volume 35 of Lecture Notes in Computer Science, </booktitle> <pages> pages 134-83. </pages> <publisher> Springer-Verlag, </publisher> <year> 1975. </year>
Reference-contexts: When restricted to flat input schemas and (second order) set variables ranging over relations, our semantics is in the spirit of quantifying over "cells" <ref> [Col75, KY85] </ref>. In the remainder of the section, we consider the expressive power and complexity of the language C-CALC. We focus here only on queries over dense-order constraint databases ("flat" complex constraint databases).
Reference: [Dri82] <author> L. Van den Dries. </author> <title> Remarks on Tarski's problem concerning (r; +; fi; exp). </title> <booktitle> In Logic Colloquium, </booktitle> <publisher> North-Holland, </publisher> <address> 1982. </address> <publisher> Elsevier. </publisher>
Reference-contexts: A naive semantics is to allow set variables to range over arbitrary sets. In this case, addition, multiplication, and exponentiation are easily definable. However, it is known that, with the presence of addition, multiplication, and exponentiation, the theory doesn't admit a quantifier elimination procedure <ref> [Dri82] </ref>. An improvement to the naive approach would be to restrict the range of set variables to only finitely representable sets. For example, a set variable x of type f [Q]g would range over all possible finite sets of rational intervals.
Reference: [FSS84] <author> M. Furst, J. B. Saxe, and M. Sipser. </author> <title> Parity, circuits, and the polynomial-time hierarchy. </title> <journal> Math. Syst. Theory, </journal> <volume> 17 </volume> <pages> 13-27, </pages> <year> 1984. </year>
Reference-contexts: We prove that numerous classical queries including various forms of connectivity are not expressible in FO + . We consider (i) classical graph queries, and (ii) spatial queries. For graph queries, the inputs are finite relations over integer values (defined with equality constraints). It was shown in <ref> [FSS84] </ref> that parity and connectivity of a finite graph are not in AC 0 . It follows easily that: Theorem 4.2 The graph connectivity and parity queries are not linear (not in FO + ). For spatial queries, we consider queries over infinite relations.
Reference: [FT83] <author> P.C. Fischer and S.J. Thomas. </author> <title> Operators for non-first-normal-form relations. </title> <booktitle> In Proc. IEEE Computer Software Applications Conference, </booktitle> <pages> pages 464-475, </pages> <year> 1983. </year>
Reference-contexts: On the other hand, a great amount of research has been done on hierarchical database structures, in particular, those constructed using the tuple and set constructs such as the nested or non first normal form relations (e.g., <ref> [JS82, FT83, RKS88] </ref>), and the complex objects (e.g., [AB87, HS91, GV91]). Query languages for complex objects have been extensively studied, and their complexity is now well understood. Complex objects provide a modeling power which is fundamental in the context of constraint databases.
Reference: [GJ79] <author> M. Garey and D. Johnson. </author> <title> Computers and Intractability A Guide to the theory of NP-Completeness. </title> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: Theorem 5.3 For each i 0, H i -TIME C-CALC i+1 H i -SPACE. Following from the above theorem and the space (time) hierarchy results <ref> [GJ79] </ref>, the family of languages C-CALC i (i 0) forms a non collapsing hierarchy. In particular, this gives a separation of C-CALC i+2 from C-CALC i for each i 0.
Reference: [GS86] <author> Y. Gurevich and S. Shelah. </author> <title> Fixed-point extensions of first-order logic. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 32 </volume> <pages> 265-280, </pages> <year> 1986. </year>
Reference-contexts: Addition or Recursion In this section, we consider the following query languages: * FO | first-order with dense-order constraints, * FO + | FO with linear constraints (with a built-in addition, +), and * Datalog : | inflationary Datalog with negation with dense-order constraints (or similarly infla tionary fixpoint logic <ref> [AV89, GS86] </ref>). We shall focus on their expressive power and complexity. The language FO over dense-order constraints is essentially first-order logic over the language f=; g [ . Datalog with (dense-order) constraints is defined as follows.
Reference: [GS94] <author> S. Grumbach and J. Su. </author> <title> Finitely representable databases (extended abstract). </title> <booktitle> In Proc. 13th ACM Symp. on Principles of Database Systems, </booktitle> <year> 1994. </year>
Reference-contexts: There are many challenging problems from both practical and theoretical points of view. In recent years, there has been a growing interest in constraint-based databases and query languages (e.g., <ref> [KKR90, Rev93, Kup93, BJM93, KG94, ACGK94, GS94, PVV94, GST95] </ref>). Constraint database models extend the traditional relational databases [Cod70] to potentially infinite collections of data items under the assumption that the databases admit finite representations. <p> We generalize the classical definition of relational queries [CH80] to "dense order" databases and consider queries closed under automorphisms of Q. We study the complexity and the expressive power of query languages for such databases. As shown in <ref> [GS94] </ref>, this topic has been only hardly investigated, and there is a serious lack of proof techniques. <p> In Section 5, the hierarchical constraint database model is introduced, with its query language, along with complexity and expressive power results. Section 6 concludes the paper. 2 Dense Order Databases Finitely representable databases over dense-order constraints were first studied in [KKR90], and further investigated in particular in <ref> [KG94, GS94, GST95] </ref>. In the following, we recall the definitions and illustrate them with motivating examples. We consider a countable first-order language L with equality (=) and order (). <p> It is easy to see that under the restriction to finitely representable databases, first-order sentences and boolean inflationary Datalog : programs define boolean queries. The theory of dense order without endpoints is decidable and admits quantifier elimination procedures [CK73]. It has been shown in <ref> [GS94] </ref>, that it is a sufficient and necessary condition for first-order logic to define a query language. The data complexity of queries in first-order logic and in Datalog : has been studied in [KKR90, KG94].
Reference: [GST95] <author> S. Grumbach, J. Su, and C. Tollu. </author> <title> Linear constraint databases. </title> <booktitle> In Proc. </booktitle> <address> LCC, </address> <year> 1995. </year> <note> To appear in LNCS Spring-Verlag volume. </note>
Reference-contexts: There are many challenging problems from both practical and theoretical points of view. In recent years, there has been a growing interest in constraint-based databases and query languages (e.g., <ref> [KKR90, Rev93, Kup93, BJM93, KG94, ACGK94, GS94, PVV94, GST95] </ref>). Constraint database models extend the traditional relational databases [Cod70] to potentially infinite collections of data items under the assumption that the databases admit finite representations. <p> We first consider their complexity, and show in particular that: (i) FO + has AC 0 data complexity when restricted to input databases defined with integers only <ref> [GST95] </ref>; and (ii) Datalog : expresses exactly all PTIME constraint queries. FO and Datalog : express mappings that are closed under automorphisms of Q (queries). It is not the case of FO + in general. We therefore restrict our attention to the queries definable in FO + . <p> In Section 5, the hierarchical constraint database model is introduced, with its query language, along with complexity and expressive power results. Section 6 concludes the paper. 2 Dense Order Databases Finitely representable databases over dense-order constraints were first studied in [KKR90], and further investigated in particular in <ref> [KG94, GS94, GST95] </ref>. In the following, we recall the definitions and illustrate them with motivating examples. We consider a countable first-order language L with equality (=) and order (). <p> Examples which are not queries include convex hull, Voronoi diagram, etc. For these latter examples from computational geometry, dense order constraints are not very appropriate. Instead, linear constraints are necessary. The expressive power of first-order in the case of linear constraint databases has been studied in <ref> [ACGK94, GST95] </ref>. The "data complexity" of queries is defined as usual based on computational devices and "standard encodings" of the input and output. We first introduce the standard encoding of a database, which is obtained by encoding the quantifier-free formula representing it. <p> Nevertheless, the expressive power of these languages has not been seriously investigated. It is still open if numerous well known queries are first-order definable over finitely representable databases. The next result <ref> [GST95] </ref> shows that FO + queries can be evaluated in AC 0 over dense-order constraint databases defined using only integers in the constraints. <p> The restriction is harmless since dense-order databases are homeomorphic (transformation on the axis) to databases representable with only integers, and the representation over integers only can be used in practice to avoid the encoding of rationals. 5 Theorem 4.1 <ref> [GST95] </ref> FO + has uniform AC 0 data complexity over inputs defined with integers.
Reference: [GV91] <author> S. Grumbach and V. Vianu. </author> <title> Tractable query languages for complex object databases. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 315-327, </pages> <year> 1991. </year>
Reference-contexts: On the other hand, a great amount of research has been done on hierarchical database structures, in particular, those constructed using the tuple and set constructs such as the nested or non first normal form relations (e.g., [JS82, FT83, RKS88]), and the complex objects (e.g., <ref> [AB87, HS91, GV91] </ref>). Query languages for complex objects have been extensively studied, and their complexity is now well understood. Complex objects provide a modeling power which is fundamental in the context of constraint databases. <p> A logic based query language C-CALC is also proposed which uses the "active domain" semantics. In particular, the language allows quantifying over sets. We study the complexity and expressive power of the new language and show that essentially the results <ref> [HS91, GV91] </ref> for query languages of classical complex objects carry over to the context of constraint databases. For example, when restricted to flat input and output, C-CALC expresses exactly all constraint queries having hyper-exponential time (space) complexity; the hierarchy based on "set-height" does not collapse. <p> We next consider a logic-based query language for constraint complex object databases. Syntactically, the query language is defined over the language L c in a way very similar to the classical complex object calculus presented in <ref> [AB87, HS91, GV91] </ref> and with the following extension. "Set terms" may be composed in the following manner: if ' is a formula with free variables in fx 1 ; : : : ; x n g, then f (x 1 ; : : : ; x n ) j 'g is <p> The construction of Q is similar to that presented in the proof of similar results for the classical complex object calculus with invention [HS91, HS93]. 2 In this paper, we propose a semantics for C-CALC which is analogous to the active domain semantics for the classical complex object calculus <ref> [AB87, HS91, GV91] </ref>. In particular, under this semantics, the range of each set variable consists of a finite number of c-objects. The number and also the actual c-objects depend on the input database. <p> In the remainder of the section, we consider the expressive power and complexity of the language C-CALC. We focus here only on queries over dense-order constraint databases ("flat" complex constraint databases). We show that the results on classical complex object languages <ref> [HS91, GV91] </ref> 9 carry over to the complex constraint database framework. (Proofs are provided in the full paper.) We first define the set-height [HS91] of a type to be the maximal number of set constructs in a path from the root to a leaf in a syntax tree of the type. <p> Let E be the set of constraint queries having hyper-exponential time (space) complexity. Corollary 5.5 C-CALC = E = ([ i H i )-TIME = ([ i H i )-SPACE. We can also extend C-CALC with fixpoint and while constructs similarly to <ref> [KKR90, GV91] </ref>. The following can be shown: Theorem 5.6 For each i0, C-CALC i +fixpoint = H i -TIME and C-CALC i +while = H i -SPACE. Before we end the section, we briefly discuss another approach to incorporating sets into constraint databases. <p> This approach, called "range restriction", uses syntactic conditions on formulas to ensure that set values assigned to set variables are only from the input database. The range restriction rules are defined similar to that for classical complex objects in <ref> [GV91] </ref>. For example, one rule states that if R (x 1 ; : : : ; x n ) is an atomic formula, then x 1 ; : : : ; x n are range restricted. Due to space limitation, we do not list the conditions here.
Reference: [HH93] <author> T. Hirst and D. Harel. </author> <title> Completeness results of recursive data bases. </title> <booktitle> In Proc. 12th ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 244-252, </pages> <year> 1993. </year>
Reference-contexts: There have been very few theoretical results on infinite databases. General results on the completeness of query languages for infinite recursive databases were reported by Hirst and Harel in <ref> [HH93] </ref>, where it is shown in particular that quantifier free first-order logic is complete on the class of all recursive databases. In [KKR90, KG94], the data complexity of both the relational calculus and inflationary Datalog with negation is studied.
Reference: [HS91] <author> R. Hull and J. Su. </author> <title> On the expressive power of database queries with intermediate types. </title> <journal> 11 Journal of Computer and System Sciences, </journal> <volume> 43(1) </volume> <pages> 219-267, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: On the other hand, a great amount of research has been done on hierarchical database structures, in particular, those constructed using the tuple and set constructs such as the nested or non first normal form relations (e.g., [JS82, FT83, RKS88]), and the complex objects (e.g., <ref> [AB87, HS91, GV91] </ref>). Query languages for complex objects have been extensively studied, and their complexity is now well understood. Complex objects provide a modeling power which is fundamental in the context of constraint databases. <p> A logic based query language C-CALC is also proposed which uses the "active domain" semantics. In particular, the language allows quantifying over sets. We study the complexity and expressive power of the new language and show that essentially the results <ref> [HS91, GV91] </ref> for query languages of classical complex objects carry over to the context of constraint databases. For example, when restricted to flat input and output, C-CALC expresses exactly all constraint queries having hyper-exponential time (space) complexity; the hierarchy based on "set-height" does not collapse. <p> We next consider a logic-based query language for constraint complex object databases. Syntactically, the query language is defined over the language L c in a way very similar to the classical complex object calculus presented in <ref> [AB87, HS91, GV91] </ref> and with the following extension. "Set terms" may be composed in the following manner: if ' is a formula with free variables in fx 1 ; : : : ; x n g, then f (x 1 ; : : : ; x n ) j 'g is <p> The construction of Q is similar to that presented in the proof of similar results for the classical complex object calculus with invention <ref> [HS91, HS93] </ref>. 2 In this paper, we propose a semantics for C-CALC which is analogous to the active domain semantics for the classical complex object calculus [AB87, HS91, GV91]. In particular, under this semantics, the range of each set variable consists of a finite number of c-objects. <p> The construction of Q is similar to that presented in the proof of similar results for the classical complex object calculus with invention [HS91, HS93]. 2 In this paper, we propose a semantics for C-CALC which is analogous to the active domain semantics for the classical complex object calculus <ref> [AB87, HS91, GV91] </ref>. In particular, under this semantics, the range of each set variable consists of a finite number of c-objects. The number and also the actual c-objects depend on the input database. <p> In the remainder of the section, we consider the expressive power and complexity of the language C-CALC. We focus here only on queries over dense-order constraint databases ("flat" complex constraint databases). We show that the results on classical complex object languages <ref> [HS91, GV91] </ref> 9 carry over to the complex constraint database framework. (Proofs are provided in the full paper.) We first define the set-height [HS91] of a type to be the maximal number of set constructs in a path from the root to a leaf in a syntax tree of the type. <p> We focus here only on queries over dense-order constraint databases ("flat" complex constraint databases). We show that the results on classical complex object languages [HS91, GV91] 9 carry over to the complex constraint database framework. (Proofs are provided in the full paper.) We first define the set-height <ref> [HS91] </ref> of a type to be the maximal number of set constructs in a path from the root to a leaf in a syntax tree of the type. Similar to [HS91], let C-CALC i be the set of all C-CALC queries Q whose input and output are flat and the set-height <p> carry over to the complex constraint database framework. (Proofs are provided in the full paper.) We first define the set-height <ref> [HS91] </ref> of a type to be the maximal number of set constructs in a path from the root to a leaf in a syntax tree of the type. Similar to [HS91], let C-CALC i be the set of all C-CALC queries Q whose input and output are flat and the set-height of each type used in Q is smaller or equal to i. Intuitively, queries in C-CALC i can use variables of type at most i levels of nested sets. <p> C-CALC 0 is FO. The following result characterizes the expressive power of C-CALC 1 . Theorem 5.2 PTIME C-CALC 1 PSPACE. Proof: (Sketch) The upper bound result is obtained similarly to the classical complex object case <ref> [HS91] </ref> but focusing on maximal covers. <p> In particular, this gives a separation of C-CALC i+2 from C-CALC i for each i 0. It is known that for the similar hierarchy for classical complex objects each level of nested sets yield strictly more expressive power <ref> [HS91] </ref>. Using a reduction to the classical case, this above separation can be further improved: Theorem 5.4 For each i 0, C-CALC i C-CALC i+1 . Let E be the set of constraint queries having hyper-exponential time (space) complexity.
Reference: [HS93] <author> R. Hull and J. Su. </author> <title> Algebraic and calculus query languages for recursively typed complex objects. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 47(1) </volume> <pages> 121-56, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: The construction of Q is similar to that presented in the proof of similar results for the classical complex object calculus with invention <ref> [HS91, HS93] </ref>. 2 In this paper, we propose a semantics for C-CALC which is analogous to the active domain semantics for the classical complex object calculus [AB87, HS91, GV91]. In particular, under this semantics, the range of each set variable consists of a finite number of c-objects.
Reference: [Imm86] <author> N. Immerman. </author> <title> Relational queries computable in polynomial time. </title> <journal> Inf. and Control, </journal> <volume> 68 </volume> <pages> 86-104, </pages> <year> 1986. </year>
Reference-contexts: The rest of the proof involves techniques which have been used already in the literature, following the results of <ref> [Var82, Imm86] </ref>. Note that in I and its relational representation, the constants are rational numbers. These rational constants occurring in the relational representation of the input or in the query itself, are encoded into consecutive integers by respecting their order. Zero is zero.
Reference: [JS82] <author> B. Jaeschke and H.J. Schek. </author> <title> Remarks on the algebra of non first normal form relations. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <year> 1982. </year>
Reference-contexts: On the other hand, a great amount of research has been done on hierarchical database structures, in particular, those constructed using the tuple and set constructs such as the nested or non first normal form relations (e.g., <ref> [JS82, FT83, RKS88] </ref>), and the complex objects (e.g., [AB87, HS91, GV91]). Query languages for complex objects have been extensively studied, and their complexity is now well understood. Complex objects provide a modeling power which is fundamental in the context of constraint databases.
Reference: [KG94] <author> P. C. Kanellakis and D. Q. Goldin. </author> <title> Constraint programming and database query languages. </title> <booktitle> In Proc. 2nd Conference on Theoretical Aspects of Computer Software (TACS), </booktitle> <month> April </month> <year> 1994. </year> <note> (To appear in LNCS Spring-Verlag volume). </note>
Reference-contexts: There are many challenging problems from both practical and theoretical points of view. In recent years, there has been a growing interest in constraint-based databases and query languages (e.g., <ref> [KKR90, Rev93, Kup93, BJM93, KG94, ACGK94, GS94, PVV94, GST95] </ref>). Constraint database models extend the traditional relational databases [Cod70] to potentially infinite collections of data items under the assumption that the databases admit finite representations. <p> General results on the completeness of query languages for infinite recursive databases were reported by Hirst and Harel in [HH93], where it is shown in particular that quantifier free first-order logic is complete on the class of all recursive databases. In <ref> [KKR90, KG94] </ref>, the data complexity of both the relational calculus and inflationary Datalog with negation is studied. It was shown that over dense-order constraint databases, the relational calculus has AC 0 data 1 complexity and inflationary Datalog with negation has PTIME data complexity. <p> In practical examples, there are properties naturally associated to pointsets and not to individual points (e.g., rainfall, population, etc. in geographical databases). The need for hierarchically structured or aggregation constraints has already been observed <ref> [KG94, Kup93, SRR94, SRS94, Rev95, BK95] </ref>. We develop a complex object model for constraint databases. Intuitively, "complex constraint objects" are composed from finitely representable sets by the tuple and set constructs. A logic based query language C-CALC is also proposed which uses the "active domain" semantics. <p> In Section 5, the hierarchical constraint database model is introduced, with its query language, along with complexity and expressive power results. Section 6 concludes the paper. 2 Dense Order Databases Finitely representable databases over dense-order constraints were first studied in [KKR90], and further investigated in particular in <ref> [KG94, GS94, GST95] </ref>. In the following, we recall the definitions and illustrate them with motivating examples. We consider a countable first-order language L with equality (=) and order (). <p> It is important to note that these particular shaped objects can be represented by four constants along with a flag indicating the shape (and boundary conditions). This lead to efficient encoding of dense-order constraint databases. An alternative encoding was proposed in <ref> [KG94] </ref>. 3 r (a 0 ; b 0 ) q (a 1 ; b 1 ) q t (a 4 ; b 4 ) q (a 5 ; b 5 ) (a 6 ; b 6 ) q q (a 7 ; b 7 ) 3 Queries The notion of a <p> It has been shown in [GS94], that it is a sufficient and necessary condition for first-order logic to define a query language. The data complexity of queries in first-order logic and in Datalog : has been studied in <ref> [KKR90, KG94] </ref>. FO queries are computable in AC 0 data complexity, FO + queries in NC, and Datalog : queries in PTIME. Nevertheless, the expressive power of these languages has not been seriously investigated. It is still open if numerous well known queries are first-order definable over finitely representable databases. <p> It is clear that this is expressible in Datalog : . The following main result of this section completely characterizes the expressive power of inflationary Datalog : . Theorem 4.4 Inflationary Datalog : = PTIME. Remark: A similar statement can be found in [KKR90] and also in <ref> [KG94] </ref>, but its meaning is different. What was proved there was that "inflationary Datalog : can express any relational database query computable in PTIME" ([KKR90] Theorem 3.15), i.e., PTIME queries from finite relational databases to finite relations.
Reference: [KKR90] <author> P. Kanellakis, G Kuper, and P. Revesz. </author> <title> Constraint query languages. </title> <booktitle> In Proc. 9th ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 299-313, </pages> <address> Nashville, </address> <year> 1990. </year>
Reference-contexts: There are many challenging problems from both practical and theoretical points of view. In recent years, there has been a growing interest in constraint-based databases and query languages (e.g., <ref> [KKR90, Rev93, Kup93, BJM93, KG94, ACGK94, GS94, PVV94, GST95] </ref>). Constraint database models extend the traditional relational databases [Cod70] to potentially infinite collections of data items under the assumption that the databases admit finite representations. <p> Constraint database models extend the traditional relational databases [Cod70] to potentially infinite collections of data items under the assumption that the databases admit finite representations. As introduced in the seminal paper by Kanellakis, Kuper and Revesz <ref> [KKR90] </ref>, the basic idea is to generalize the relations by allowing generalized tuples as conjunctions of constraints. For instance, x y ^x 0 defines a binary generalized tuple. A generalized, or "finitely representable", relation is then a finite set of such tuples. <p> In the rational plane, it results in an infinite set of points, or tuples of atomic values, over Q k . The relational calculus over finitely representable relations constitutes a constraint query language which admits a declarative semantics and an efficient bottom-up evaluation in closed form <ref> [KKR90] </ref>. There have been very few theoretical results on infinite databases. <p> General results on the completeness of query languages for infinite recursive databases were reported by Hirst and Harel in [HH93], where it is shown in particular that quantifier free first-order logic is complete on the class of all recursive databases. In <ref> [KKR90, KG94] </ref>, the data complexity of both the relational calculus and inflationary Datalog with negation is studied. It was shown that over dense-order constraint databases, the relational calculus has AC 0 data 1 complexity and inflationary Datalog with negation has PTIME data complexity. <p> In Section 5, the hierarchical constraint database model is introduced, with its query language, along with complexity and expressive power results. Section 6 concludes the paper. 2 Dense Order Databases Finitely representable databases over dense-order constraints were first studied in <ref> [KKR90] </ref>, and further investigated in particular in [KG94, GS94, GST95]. In the following, we recall the definitions and illustrate them with motivating examples. We consider a countable first-order language L with equality (=) and order (). <p> Throughout the whole paper, we consider the structure Q = (Q; ) of the set of rational numbers along with its dense order. Unless stated otherwise, 2 constraints are given in terms of equations or inequalities over the rationals. Kanellakis, Kuper, and Revesz <ref> [KKR90] </ref> introduced the concept of a k-ary generalized tuple, which is a constraint expressed as a conjunction of atomic formulas in L over k variables. For instance, (x y ^ x 0 ^ y 10) is a binary generalized tuple representing a triangle. <p> For instance, (x y ^ x 0 ^ y 10) is a binary generalized tuple representing a triangle. A generalized tuple is a finite representation of a potentially infinite set of tuples over ratio-nals. A k-ary finitely representable relation (or generalized relation in <ref> [KKR90] </ref>) is then a finite set of k-ary generalized tuples. In this framework, a tuple (a; b) in the classical relational data model [Cod70] is an abbreviation for the formula (constraint) "(x = a ^ y = b)" represented using only the equality symbol "=" and constants. <p> For Datalog : , negations are allowed in the bodies of rules. The inflationary semantics is computed by adding after each iteration the set of facts just derived to the set previously obtained. It has been shown in <ref> [KKR90] </ref> that both FO and Datalog : can be evaluated bottom-up and in closed form, i.e., instances are mapped to instances. FO + also allows the addition operator, +, with the intended semantics. It follows from results in [Tar51], that FO + can be evaluated bottom-up. <p> It has been shown in [GS94], that it is a sufficient and necessary condition for first-order logic to define a query language. The data complexity of queries in first-order logic and in Datalog : has been studied in <ref> [KKR90, KG94] </ref>. FO queries are computable in AC 0 data complexity, FO + queries in NC, and Datalog : queries in PTIME. Nevertheless, the expressive power of these languages has not been seriously investigated. It is still open if numerous well known queries are first-order definable over finitely representable databases. <p> It is clear that this is expressible in Datalog : . The following main result of this section completely characterizes the expressive power of inflationary Datalog : . Theorem 4.4 Inflationary Datalog : = PTIME. Remark: A similar statement can be found in <ref> [KKR90] </ref> and also in [KG94], but its meaning is different. What was proved there was that "inflationary Datalog : can express any relational database query computable in PTIME" ([KKR90] Theorem 3.15), i.e., PTIME queries from finite relational databases to finite relations. <p> Proof of Theorem 4.4 (Sketch). The inclusion of inflationary Datalog : in PTIME has been shown in <ref> [KKR90] </ref>. We only prove the converse inclusion. For the sake of simplicity, we detail the proof in the case of a binary query over a database schema containing a single relation of arity 2. In other words, we work in a space of dimension 2. <p> Let E be the set of constraint queries having hyper-exponential time (space) complexity. Corollary 5.5 C-CALC = E = ([ i H i )-TIME = ([ i H i )-SPACE. We can also extend C-CALC with fixpoint and while constructs similarly to <ref> [KKR90, GV91] </ref>. The following can be shown: Theorem 5.6 For each i0, C-CALC i +fixpoint = H i -TIME and C-CALC i +while = H i -SPACE. Before we end the section, we briefly discuss another approach to incorporating sets into constraint databases.
Reference: [Kup93] <author> G. M. Kuper. </author> <title> Aggregation in constraint databases. </title> <booktitle> In Proc. Workshop on the Principles and Practice of Constraint Programming, </booktitle> <pages> pages 176-183, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: There are many challenging problems from both practical and theoretical points of view. In recent years, there has been a growing interest in constraint-based databases and query languages (e.g., <ref> [KKR90, Rev93, Kup93, BJM93, KG94, ACGK94, GS94, PVV94, GST95] </ref>). Constraint database models extend the traditional relational databases [Cod70] to potentially infinite collections of data items under the assumption that the databases admit finite representations. <p> In practical examples, there are properties naturally associated to pointsets and not to individual points (e.g., rainfall, population, etc. in geographical databases). The need for hierarchically structured or aggregation constraints has already been observed <ref> [KG94, Kup93, SRR94, SRS94, Rev95, BK95] </ref>. We develop a complex object model for constraint databases. Intuitively, "complex constraint objects" are composed from finitely representable sets by the tuple and set constructs. A logic based query language C-CALC is also proposed which uses the "active domain" semantics.
Reference: [KY85] <author> D. Kozen and C. Yap. </author> <title> Algebraic cell decomposition in np. </title> <booktitle> In Proc IEEE Foundations of Computer Science, </booktitle> <pages> pages 515-521, </pages> <year> 1985. </year>
Reference-contexts: When restricted to flat input schemas and (second order) set variables ranging over relations, our semantics is in the spirit of quantifying over "cells" <ref> [Col75, KY85] </ref>. In the remainder of the section, we consider the expressive power and complexity of the language C-CALC. We focus here only on queries over dense-order constraint databases ("flat" complex constraint databases).
Reference: [PVV94] <author> J. Paredaens, J. Van den Bussche, and D. Van Gucht. </author> <title> Towards a theory of spatial database queries. </title> <booktitle> In Proc. 13th ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 279-88, </pages> <year> 1994. </year>
Reference-contexts: There are many challenging problems from both practical and theoretical points of view. In recent years, there has been a growing interest in constraint-based databases and query languages (e.g., <ref> [KKR90, Rev93, Kup93, BJM93, KG94, ACGK94, GS94, PVV94, GST95] </ref>). Constraint database models extend the traditional relational databases [Cod70] to potentially infinite collections of data items under the assumption that the databases admit finite representations. <p> Definition 3.1 A boolean query K is a partial recursive collection of finitely representable database instances over closed under automorphisms of Q. The definition of non boolean queries is then classical. In <ref> [PVV94] </ref>, different notions of queries were introduced. They are based on consistency criteria related to the geometry in which the database is to be interpreted. We next see that our definition of a query corresponds naturally to a topological concept. Consider the usual topology on the set Q of rationals.
Reference: [Rev93] <author> P. Z. Revesz. </author> <title> A closed form for datalog queries with integer (gap)-order constraints. </title> <journal> Theoretical Computer Science, </journal> <volume> 116(1) </volume> <pages> 117-149, </pages> <year> 1993. </year>
Reference-contexts: There are many challenging problems from both practical and theoretical points of view. In recent years, there has been a growing interest in constraint-based databases and query languages (e.g., <ref> [KKR90, Rev93, Kup93, BJM93, KG94, ACGK94, GS94, PVV94, GST95] </ref>). Constraint database models extend the traditional relational databases [Cod70] to potentially infinite collections of data items under the assumption that the databases admit finite representations. <p> Some of the results do not hold in other contexts. In particular, Theorem 4.4 doesn't carry over to the case of discrete orders. It has been shown in <ref> [Rev93] </ref> that stratified Datalog : can express any Turing computable function. Nevertheless, we conjecture that query languages capturing PTIME queries over other classes of constraints can be obtained with bounded fixpoint. The results presented in this paper have consequences beyond the scope of dense-order constraint databases.
Reference: [Rev95] <author> P. Z. Revesz. </author> <title> Datalog queries of set constraint databases. </title> <booktitle> In Proc. Int. Conf. on Database Theory, </booktitle> <year> 1995. </year>
Reference-contexts: In practical examples, there are properties naturally associated to pointsets and not to individual points (e.g., rainfall, population, etc. in geographical databases). The need for hierarchically structured or aggregation constraints has already been observed <ref> [KG94, Kup93, SRR94, SRS94, Rev95, BK95] </ref>. We develop a complex object model for constraint databases. Intuitively, "complex constraint objects" are composed from finitely representable sets by the tuple and set constructs. A logic based query language C-CALC is also proposed which uses the "active domain" semantics.
Reference: [RKS88] <author> M.A. Roth, H.F. Korth, and A. Silber-schatz. </author> <title> Extended algebra and calculus for nested relational databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(4) </volume> <pages> 389-417, </pages> <year> 1988. </year>
Reference-contexts: On the other hand, a great amount of research has been done on hierarchical database structures, in particular, those constructed using the tuple and set constructs such as the nested or non first normal form relations (e.g., <ref> [JS82, FT83, RKS88] </ref>), and the complex objects (e.g., [AB87, HS91, GV91]). Query languages for complex objects have been extensively studied, and their complexity is now well understood. Complex objects provide a modeling power which is fundamental in the context of constraint databases.
Reference: [SRR94] <author> D. Srivastava, R. Ramakrishnan, and P. Z. Revesz. </author> <title> Constraint objects. </title> <booktitle> In Proc. Workshop on the Principles and Practice of Constraint Programming, </booktitle> <year> 1994. </year>
Reference-contexts: In practical examples, there are properties naturally associated to pointsets and not to individual points (e.g., rainfall, population, etc. in geographical databases). The need for hierarchically structured or aggregation constraints has already been observed <ref> [KG94, Kup93, SRR94, SRS94, Rev95, BK95] </ref>. We develop a complex object model for constraint databases. Intuitively, "complex constraint objects" are composed from finitely representable sets by the tuple and set constructs. A logic based query language C-CALC is also proposed which uses the "active domain" semantics.
Reference: [SRS94] <author> D. Srivastava, K. A. Ross, and P. J. Stuckey. </author> <title> Foundations of aggregation constraints. </title> <booktitle> In Proc. Workshop on the Principles and Practice of Constraint Programming, </booktitle> <year> 1994. </year>
Reference-contexts: In practical examples, there are properties naturally associated to pointsets and not to individual points (e.g., rainfall, population, etc. in geographical databases). The need for hierarchically structured or aggregation constraints has already been observed <ref> [KG94, Kup93, SRR94, SRS94, Rev95, BK95] </ref>. We develop a complex object model for constraint databases. Intuitively, "complex constraint objects" are composed from finitely representable sets by the tuple and set constructs. A logic based query language C-CALC is also proposed which uses the "active domain" semantics.
Reference: [Tar51] <author> A. Tarski. </author> <title> A Decision Method for Elementary Algebra and Geometry. </title> <publisher> University of Cal-ifornia Press, </publisher> <address> Berkeley, California, </address> <year> 1951. </year>
Reference-contexts: It has been shown in [KKR90] that both FO and Datalog : can be evaluated bottom-up and in closed form, i.e., instances are mapped to instances. FO + also allows the addition operator, +, with the intended semantics. It follows from results in <ref> [Tar51] </ref>, that FO + can be evaluated bottom-up. Remark: We restrict our attention to queries (in the sense of Definition 3.1) over dense order databases. In the following, FO + denotes the set of queries definable with +.
Reference: [Var82] <author> M. Vardi. </author> <title> Relational queries computable in polynomial time. </title> <booktitle> In Proc. 14th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 137-146, </pages> <year> 1982. </year> <month> 12 </month>
Reference-contexts: The rest of the proof involves techniques which have been used already in the literature, following the results of <ref> [Var82, Imm86] </ref>. Note that in I and its relational representation, the constants are rational numbers. These rational constants occurring in the relational representation of the input or in the query itself, are encoded into consecutive integers by respecting their order. Zero is zero.
References-found: 34

