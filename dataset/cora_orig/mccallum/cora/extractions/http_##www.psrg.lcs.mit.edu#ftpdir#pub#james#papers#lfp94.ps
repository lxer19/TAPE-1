URL: http://www.psrg.lcs.mit.edu/ftpdir/pub/james/papers/lfp94.ps
Refering-URL: http://www.psrg.lcs.mit.edu/~james/whoami.html
Root-URL: 
Title: Concurrent Replicating Garbage Collection  
Author: James O'Toole and Scott Nettles 
Abstract: We have implemented a concurrent copying garbage collector that uses replicating garbage collection. In our design, the client can continuously access the heap during garbage collection. No low-level synchronization between the client and the garbage collector is required on individual object operations. The garbage collector replicates live heap objects and periodically synchronizes with the client to obtain the client's current root set and mutation log. An experimental implementation using the Standard ML of New Jersey system on a shared-memory multiprocessor demonstrates excellent pause time performance and moderate execution time speedups. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time Concurrent Garbage Collection on Stock Multiprocessors. </title> <booktitle> In SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 11-20, </pages> <year> 1988. </year>
Reference-contexts: Essentially all of these collectors require the client to access the to-space version of an object during collections. The technique of Ellis, Li, and Appel <ref> [1] </ref> enforces this restriction by using virtual memory protection to force clients to use only to-space objects. Our technique does not require any unusual operating system or hardware support and it imposes smaller demands on the client than software versions of Bakers algorithm.
Reference: [2] <author> H. G. Baker. </author> <title> List Processing in Real Time on a Serial Computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <year> 1978. </year>
Reference-contexts: We expect to be able to measure the trapping and synchronization costs in the current implementation. These and other measurements might answer the policy questions raised in Sections 3.3 and 3.4. 5 Related Work There is a long history of incremental and concurrent copying collectors dating back to Baker <ref> [2] </ref>. Essentially all of these collectors require the client to access the to-space version of an object during collections. The technique of Ellis, Li, and Appel [1] enforces this restriction by using virtual memory protection to force clients to use only to-space objects.
Reference: [3] <author> Hans-Juergen Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly Parallel Garbage Collection. </title> <booktitle> In SIG-PLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 157-164, </pages> <year> 1991. </year>
Reference-contexts: Brooks' technique [4], later implemented by North and Reppy [13], requires the client to follow a forwarding pointer that leads to the relocated object. This eliminated a test in favor of extra space and an indirection. Work by Boehm, Demers and Shenker <ref> [3] </ref> on a concurrent mark-and-sweep collector uses mutation logging to track changes made by the client. The mutation log is implemented by periodically sampling the dirty page bits maintained by the virtual memory system. The authors observed the possibility of using a from-space invariant for a copying collector.
Reference: [4] <author> Rodney A. Brooks. </author> <title> Trading Data Space for Reduced Time and Code Space in Real-Time Garbage Collection. </title> <booktitle> In SIGPLAN Symposium on LISP and Functional Programming, </booktitle> <year> 1984. </year>
Reference-contexts: The idea of a separate forwarding pointer word first appeared in the context of to-space methods. Brooks' technique <ref> [4] </ref>, later implemented by North and Reppy [13], requires the client to follow a forwarding pointer that leads to the relocated object. This eliminated a test in favor of extra space and an indirection.
Reference: [5] <author> E. Dijkstra, L. Lamport, A. Martin, C. Scholten, and E. Steffens. </author> <title> On-the-fly Garbage Collection:An Exercise in Cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: The collector copies live immutable objects into a shared heap. To avoid inconsistent mutable values, all mutable objects are allocated in the shared heap. The shared heap is collected by a concurrent mark-and-sweep algorithm based on Dijkstra <ref> [5] </ref>. When a mutation causes an immutable object to become reachable from the shared heap, then it is immediately copied into the shared heap. The use of replicat-ing collection allows the original owner of immutable objects to continue to access the private copy.
Reference: [6] <author> D. Doligez and G. Gonthier. </author> <title> Portable Unobtrusive Garbage Collector for Multiprocessor Systems. </title> <booktitle> In Proceedings of the 1994 ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: In their collector each thread can perform its minor collection independently of every other thread and in general no global synchronization is needed between the clients and the collector. Doligez and Gonthier further characterize how a multiprocessor garbage collector can be more unobtrusive <ref> [6] </ref>. We believe this is an important advantage and are attempting to understand how to achieve it in our system. Huelsbergen and Larus's collector uses an invariant that requires the client to use the to-space version of a mutable object if it exists.
Reference: [7] <author> D. Doligez and X. Leroy. </author> <title> A Concurrent Generational Garbage Collector for a Multi-Threaded Implementation of ML. </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 113-123, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The authors observed the possibility of using a from-space invariant for a copying collector. Two recent collectors for ML are quite closely related to ours and employ variations of the replication idea. Doligez and Leroy <ref> [7] </ref> implemented a concurrent collector that uses a mixed strategy to provide collection for a multithreaded version of CAML. Huelsbergen and Larus [8] implemented a concurrent collector for SML/NJ that uses replicating collection.
Reference: [8] <author> Lorenz Huelsbergen and James R. Larus. </author> <title> A Concurrent Copying Garbage Collector for Languages that Distinguish (Im)mutable Data. </title> <booktitle> In Proceedings of the 1993 ACM Symposiym on Principles and Practice of Parallel Programming, </booktitle> <year> 1993. </year>
Reference-contexts: Two recent collectors for ML are quite closely related to ours and employ variations of the replication idea. Doligez and Leroy [7] implemented a concurrent collector that uses a mixed strategy to provide collection for a multithreaded version of CAML. Huelsbergen and Larus <ref> [8] </ref> implemented a concurrent collector for SML/NJ that uses replicating collection. Both of these collectors depend heavily on the fact that ML implementations can distinguish mutable from immutable data. Our technique does not depend on this feature of ML and is therefore more generally applicable.
Reference: [9] <author> J. Gregory Morrisett and Andrew Tolmach. </author> <title> Procs and Locks: A Portable Multiprocessing Platform for Standard ML of New Jersey. </title> <booktitle> In Proceedings of the 1993 ACM Symposiym on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 198-207, </pages> <year> 1993. </year>
Reference-contexts: In a generational collector the root set may include the set of cross-generational pointers that point from older objects to newer objects. 3 Implementation Our concurrent replicating collector is based on a version of Standard ML of New Jersey (SML/NJ) that has been extended to support multiprocessors <ref> [9] </ref>. The collector uses a separate thread for garbage collection work. Scanning and replication work are done concurrently, but the current prototype processes mutation log entries only while the client is paused. <p> Also, our collector uses a Unix signal mechanism taken from the SML/NJ MP system by Morrisett and Tolmach <ref> [9] </ref> to interrupt the client when it has established the completion condition. Our implementation also requires the client to asynchronously pause the collector. This is now implemented by having the collector poll periodically to detect a synchronization request from the client. <p> We have heard from Tolmach that the speedups achieved on the benchmarks in his work with Morrisett <ref> [9] </ref> may have been limited because the garbage collector was stop-and-copy and single-threaded. It is possible that those speedups would be closer to linear using a concurrent collector. We are also interested in investigating performance questions about the collector that are not answered by this paper.
Reference: [10] <author> Scott M. Nettles and James W. O'Toole. </author> <title> Real-Time Replication Garbage Collection. </title> <booktitle> In SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 217-226. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: Incremental collection addresses the problem of pause times by allowing the collector and application to proceed in tandem. We have previously demonstrated that replicating garbage collection can be used to build incremental collectors that limit these pauses sufficiently to allow applications such as mouse tracking to use GC <ref> [10] </ref>. In this work we show how the same technique can be used to build collectors that are concurrent. Because most of the collection work can be done concurrently we are able to demonstrate both much shorter pauses and speedups compared to our previous work. <p> The SML/NJ collector uses a log called the storelist to track such mutations. We modified the SML/NJ compiler and all appropriate runtime system operations so that all mutations are recorded in the storelist. In previous work <ref> [10] </ref>, we measured the runtime cost of the additional logging to be 0-5% of total execution time for the benchmarks described in this paper. No logging is required for allocation operations because newly allocated objects cannot yet have been copied by the garbage collector. <p> As shown in Figure 3, the client operation that reads the header word was modified to follow the forwarding word. Our previous results showed that the runtime cost to the client due to this change was not significant <ref> [10] </ref>. However, in the presence of concurrency, this change creates a potential read-write conflict between the collector and the client. <p> Even in this benchmark, the fully concurrent configuration shows more elapsed time in the minor collector than the stop-and-copy configuration does. We believe that the increased fraction of elapsed time in the minor collector is caused by high synchronization costs and the log processing work. Earlier measurements <ref> [10] </ref> of these benchmarks indicate that the log processing costs are small, but they do explain some of the increase in minor gc time observed here. <p> We hope to implement their invariant along with some of the others we have described elsewhere [11] and obtain a direct comparison. The work described in this paper extends our previous work on incremental and real-time collection <ref> [10, 11] </ref> by supporting concurrency among multiple clients and the garbage collector. We use this concurrent collector together with a transaction manager for a persistent heap in which the mutation log also serves as the transaction log [14].
Reference: [11] <author> Scott M. Nettles, James W. O'Toole, David Pierce, and Nicholas Haines. </author> <title> Replication-Based Incremental Copying Collection. </title> <booktitle> In Proceedings of the SIGPLAN International Workshop on Memory Management, </booktitle> <pages> pages 357-364. </pages> <publisher> ACM, Springer-Verlag, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: This also makes it difficult to assess the overhead of their technique. Less importantly, their implementation does not merge forwarding pointers with header words and thus has a substantial space penalty. We hope to implement their invariant along with some of the others we have described elsewhere <ref> [11] </ref> and obtain a direct comparison. The work described in this paper extends our previous work on incremental and real-time collection [10, 11] by supporting concurrency among multiple clients and the garbage collector. <p> We hope to implement their invariant along with some of the others we have described elsewhere [11] and obtain a direct comparison. The work described in this paper extends our previous work on incremental and real-time collection <ref> [10, 11] </ref> by supporting concurrency among multiple clients and the garbage collector. We use this concurrent collector together with a transaction manager for a persistent heap in which the mutation log also serves as the transaction log [14].
Reference: [12] <author> S.M. Nettles and J.M. Wing. </author> <title> Persistance + Undoability = Transactions. </title> <booktitle> In Proceedings of the 25th Hawaii International Conference on System Sciences, </booktitle> <volume> volume 2, </volume> <pages> pages 832-843. </pages> <publisher> IEEE, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: Mutation logging works best when mutations are infrequent or can be recorded without client cooperation. Mutation logging is also attractive whenever a log is already required for other reasons, such as in generational collectors, distributed applications, and transactional storage systems <ref> [12, 14] </ref>. 2.3 The Collector Invariant The invariant maintained by the collector is that the client can only access from-space objects and that all to-space replicas are up-to-date with respect to their original from-space objects unless a corresponding mutation is described in the mutation log. 2.4 The Completion Condition While the
Reference: [13] <author> S. C. North and J.H. Reppy. </author> <title> Concurrent Garbage Collection on Stock Hardware. </title> <editor> In Gilles Kahn, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture (LNCS 274), </booktitle> <pages> pages 113-133. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: The idea of a separate forwarding pointer word first appeared in the context of to-space methods. Brooks' technique [4], later implemented by North and Reppy <ref> [13] </ref>, requires the client to follow a forwarding pointer that leads to the relocated object. This eliminated a test in favor of extra space and an indirection. Work by Boehm, Demers and Shenker [3] on a concurrent mark-and-sweep collector uses mutation logging to track changes made by the client.
Reference: [14] <author> James O'Toole, Scott Nettles, and David Gifford. </author> <title> Concurrent Compacting Garbage Collection of a Persistent Heap. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles. ACM, SIGOPS, </booktitle> <month> Decem-ber </month> <year> 1993. </year>
Reference-contexts: Mutation logging works best when mutations are infrequent or can be recorded without client cooperation. Mutation logging is also attractive whenever a log is already required for other reasons, such as in generational collectors, distributed applications, and transactional storage systems <ref> [12, 14] </ref>. 2.3 The Collector Invariant The invariant maintained by the collector is that the client can only access from-space objects and that all to-space replicas are up-to-date with respect to their original from-space objects unless a corresponding mutation is described in the mutation log. 2.4 The Completion Condition While the <p> We use this concurrent collector together with a transaction manager for a persistent heap in which the mutation log also serves as the transaction log <ref> [14] </ref>. In that work [14] we used replicating garbage collection to demonstrate the first implementation of a concurrent compacting garbage collector for a persistent heap. We showed how to provide good performance for a transactional heap but discussed the concurrent garbage collection algorithm only at a high level. <p> We use this concurrent collector together with a transaction manager for a persistent heap in which the mutation log also serves as the transaction log <ref> [14] </ref>. In that work [14] we used replicating garbage collection to demonstrate the first implementation of a concurrent compacting garbage collector for a persistent heap. We showed how to provide good performance for a transactional heap but discussed the concurrent garbage collection algorithm only at a high level.
Reference: [15] <author> Paul R. Wilson. </author> <title> Uniprocessor Garbage Collection Techniques. </title> <booktitle> In Proceedings of the 1992 SIGPLAN International Workshop on Memory Management, </booktitle> <pages> pages 1-42. </pages> <publisher> ACM, Springer-Verlag, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: Finally, we discuss possible improvements to the implementation and suggest areas for further work. We assume that the reader is familiar with the basics of copying and generational garbage collection. The survey by Wilson <ref> [15] </ref> should be useful to readers unfamiliar with the area. 2 Concurrent Replicating GC Concurrent garbage collectors permit the client to execute while the garbage collection is in progress.
Reference: [16] <author> Benjamin Zorn. </author> <title> The measured cost of conservative garbage collection. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 23(7) </volume> <pages> 733-756, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Recent studies by Zorn <ref> [16] </ref> of applications that make heavy use of dynamic storage suggest that in fact explicit storage management may be as costly as GC. However, many garbage collectors stop the application during collection, creating pauses that are unacceptable to many applications that might otherwise utilize GC.
References-found: 16

