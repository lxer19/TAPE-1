URL: http://www.cs.cornell.edu/Info/People/kreitz/PS-files/90-revue.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/kreitz/Abstracts/90-revue.html
Root-URL: 
Title: Towards a formal Theory of Program Construction  
Author: Christoph Kreitz 
Address: Alexanderstr. 10, D-6100 Darmstadt  
Affiliation: FG Intellektik FB Informatik, Technische Hochschule Darmstadt  
Date: 4(3):53-79, November 1990  
Note: Revue d' intelligence artificielle,  
Abstract: A unified framework for formal reasoning about programs and deductive mechanisms involved in programming is developed. Within it principal approaches to program synthesis are formally investigated. We will show that a high degree of abstraction opens a way to combine their strengths, simplifies formal proofs, and leads to clearer insights into the meta-mathematics of program construction. All definitions and theorems are presented completely formal which allows to straightforwardly implement them with a proof system for the underlying calculus and derive verified implementations of programming methods from them. 
Abstract-found: 1
Intro-found: 1
Reference: [And86] <author> P. Andrews. </author> <title> An Introduction to mathematical logic and Type Theory: To Truth through Proof. </title> <publisher> Academic Press, </publisher> <year> 1986. </year>
Reference: [Bas89] <author> D. Basin. </author> <title> Building theories in NuPRL. </title> <editor> In A. R. Meyer and M. A. Taitslin, editors, </editor> <booktitle> Logic at Botik 89, </booktitle> <pages> pages 12-25. </pages> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: It allows a user to write meta-programs guiding the application of refinement rules. Such tactics act as derived inference rules whose correctness is guaranteed by the fact that they have to make use of primitive inference rules to actually modify a proof. Experiments with NuPRL reported in <ref> [CAB + 86, How86, Kre86, Cle87, How88a, Bas89] </ref> show that together with the expressive power of Type Theory these components strongly support a flexible high level "implementation" of mathematical theories. 3 Methodology and notation As said before the formal theory of program construction shall provide a unified framework for reasoning about <p> Formal definitions introduce new notions. In formal theorems important properties are stated and verified. During the past years, a number of domain theories have been implemented with NuPRL. We refer the reader to [CAB + 86, How86, Kre86, Cle87, How88a] and particularly to <ref> [Bas89] </ref> for accounts of how mathematical knowledge should be represented and reasoned about. Here we will present some elements of a theory about finite sets over ordered types which we will use in Section 4.3.
Reference: [BC85] <author> J. L. Bates and R. L. Constable. </author> <title> Proofs as programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 113-136, </pages> <year> 1985. </year>
Reference-contexts: Directing the formal theory towards the development of verified program synthesizers, i.e. towards representing deductive mechanisms for programming, proving them correct and creating a verified implementation, distinguishes our approach from those focusing on "low level" calculi <ref> [ML82, BC85, CH88, PM89, Coq89, Gal90] </ref>, on metareasoning within a such a calculus [CK86, Kno87, How88b] or on implementing a deductive mechanism by representing it in some calculus [Pau87, HRS90, Web90]. <p> We selected Intuitionistic Type Theory as general formalism to underly our formal framework. Reasons for that are discussed in the following section where we also introduce syntax and features of the NuPRL proof development system for Type Theory <ref> [BC85, CAB + 86] </ref>. Section 3 explains the methodology we will follow. In Section 4 then the frame for reasoning about the object level of programming will be presented and illustrated by an exemplified formalization of strategies of the LOPS system [Bib80, BH84]. <p> As formulation to underly our theory we selected the one of NuPRL <ref> [BC85, CAB + 86] </ref>, a descendent of Martin-L of's Type Theory [ML82], because an interactive environment for developing completely formal theories in NuPRL is already available. <p> Consequently, algorithms can be specified in form of mathematical propositions impli-citely asserting their existence. The computational content of such a proposition is a program guaranteed to meet the specification and can be extracted from its proof. This so-called proofs-as-programs paradigm <ref> [BC85] </ref> is of particular importance for embedding our framework into NuPRL. Unlike most other type theoretical calculi NuPRL's proof calculus supports a top-down development of this algorithm. <p> We will later see how this influences the approaches to solve it. 5.2 Principal approaches to program synthesis Essentially there are two different ideologies to approach program synthesis: * The so-called theorem proving or AE approaches <ref> [MW80, BC85, Fra85, CH88, Gal90] </ref> arose from the idea that constructing a program and proving it logically correct should be done at the same time. <p> The advantage of this direction is its solid theoretical foundation. A lot of research has been done in developing appropriate logical calculi (see e.g. <ref> [ML82, BC85, CH88, PM89, Coq89, Gal90] </ref>) and algorithms extracting (efficient) programs from proofs within these [Hay86, CH88, PM89]. 2 However, AE approaches suffer from the fact that, if general theorem proving strategies like resolution are used, the method a program is constructed appears to be quite unnatural.
Reference: [BD77] <author> R. M. Burstall and J. Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> Journal of the ACM, </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <year> 1977. </year> <month> 77 </month>
Reference-contexts: Furthermore, there is only little practical experience in constructing AE proofs for a larger class of programming problems. * In transformation based approaches (see e.g. <ref> [BD77, MW79, Bib80, Hog81, BH84, Der85, SL89, SL90] </ref>) a specification is treated as if it were already some kind of logic program, though an inefficient one.
Reference: [BH84] <author> W. Bibel and K. M. H ornig. </author> <title> LOPS a system based on a strategical approach to program synthesis. </title> <editor> In A.W. Biermann, G. Guiho, and Y. Kodratoff, editors, </editor> <booktitle> Automatic program construction techniques, </booktitle> <pages> pages 69-89. </pages> <publisher> MacMillan, </publisher> <year> 1984. </year>
Reference-contexts: Section 3 explains the methodology we will follow. In Section 4 then the frame for reasoning about the object level of programming will be presented and illustrated by an exemplified formalization of strategies of the LOPS system <ref> [Bib80, BH84] </ref>. We will show that even a straightforward formalization already gives some new insights about the deductive method. Since, however, in such a direct approach general principles are covered up by individual notations we go for a higher degree of abstraction in Section 5. <p> As running example we chose key strategies of the LOPS (LOgic Program Synthesis) system <ref> [Bib80, BH84, Fro85, NFK89] </ref> which may be briefly summarized as follows: Starting with a specification given as a first-order formula of the form 8i 9y ( IC (i) ) OC (i,y) ) where i and y represent input and output variable, IC some input condition, and OC the relation between input <p> Furthermore, there is only little practical experience in constructing AE proofs for a larger class of programming problems. * In transformation based approaches (see e.g. <ref> [BD77, MW79, Bib80, Hog81, BH84, Der85, SL89, SL90] </ref>) a specification is treated as if it were already some kind of logic program, though an inefficient one. <p> Many parts need to be worked out in further detail. In particular, all components involved in the programming process must be formalized to prove general correlations between them. Embedding already existing approaches to program synthesis (like LOPS <ref> [Bib80, BH84] </ref> or KIDS [SL89, SL90]) into our framework is another path to be followed. Behind the KIDS system, for instance, there is already a theory which proves its program construction methods correct on some mathematical level.
Reference: [Bib80] <author> W. Bibel. </author> <title> Syntax-directed, semantics-supported program synthesis. </title> <journal> Artificial Intelligence, </journal> <volume> 14(3) </volume> <pages> 243-261, </pages> <month> October </month> <year> 1980. </year>
Reference-contexts: Section 3 explains the methodology we will follow. In Section 4 then the frame for reasoning about the object level of programming will be presented and illustrated by an exemplified formalization of strategies of the LOPS system <ref> [Bib80, BH84] </ref>. We will show that even a straightforward formalization already gives some new insights about the deductive method. Since, however, in such a direct approach general principles are covered up by individual notations we go for a higher degree of abstraction in Section 5. <p> As running example we chose key strategies of the LOPS (LOgic Program Synthesis) system <ref> [Bib80, BH84, Fro85, NFK89] </ref> which may be briefly summarized as follows: Starting with a specification given as a first-order formula of the form 8i 9y ( IC (i) ) OC (i,y) ) where i and y represent input and output variable, IC some input condition, and OC the relation between input <p> All LOPS strategies are designed to leave open some choices which could be made by a programmed heuristic or an assisting user. Our formalization of LOPS strategies follows the original description of <ref> [Bib80] </ref>. Besides illustrating of the principles of our formal theory it will give us some new insights into the true nature of the LOPS approach and "mechanical" proofs for the correctness of the strategies involved. <p> This strategy, which <ref> [Bib80] </ref> calls GET-DNF, will also be represented as a theorem expressing a proof rule to be applied immediately after GUESS-DOMAIN. <p> We will therefore explain the operation of GET-REC by some small standard example using one of the most typical abstract recursion schemes and leave generalizations to the future. 65 Example: The maximum of a finite set: (c.f. <ref> [Bib80] </ref>) An algorithm calculating the maximum m of a finite set S over some arbitrary ordered type OUT shall be synthesized. According to Definition 4.4 the following specification has to be considered as top goal: top ` 8OUT:TYPES.8:ORDERINGS (OUT).8S:OUT Set.9m:OUT. <p> Example: The result of postprocessing is: top 1 1 1 g=max (S)_ (m=max (S n g) & gm & g6=m _ S=fgg ) m2S n g & S n gm & gm & g6=m) 4.3.3 Further strategies In <ref> [Bib80] </ref> other strategies which we did not make use of have been introduced: GET-EP tries to make a predicate evaluable by replacing ineffective components. If there is more than one output variable, GET-RNV tries to reduce their number, GET-SOC separates the output conditions, CHVAR chooses an output variable for guessing. <p> Thus the alternative S=fgg will not lead to a solution in the failure case. The contradiction is dropped adding S6=fgg as control information to the other alternative. After folding the definition of &lt; the final result is: top 1 1 1 1 67 <ref> [Bib80] </ref> proposes to construct a program by an algorithmic reading of the for-mula. This means making use of the (meta-)knowledge that a solution of the final formula is also one for the original one and transforming the (exclusive) disjunction into a case analysis according to the decidable predicates mentioned. <p> Many of them use an additional precondition IC on the input to exclude singular cases like division by zero (see e.g. <ref> [MW80, Bib80, SL89] </ref>). Obviously, the domains IN and OU T should be first-order types and IC; IOR must be first-order formulae over the appropriate types. <p> Furthermore, there is only little practical experience in constructing AE proofs for a larger class of programming problems. * In transformation based approaches (see e.g. <ref> [BD77, MW79, Bib80, Hog81, BH84, Der85, SL89, SL90] </ref>) a specification is treated as if it were already some kind of logic program, though an inefficient one. <p> It is a transformation controlled by a set of parameters: the type of the new variable g, its domain condition and the "tautology" predicate. Note that for this the position of predicates and quantifiers had to be changed resulting in a form equivalent to the one given in <ref> [Bib80] </ref>. Guess (A,dc,t)(sp) &lt;IN,OUT,IC,8g:A.dc (i,g)) IOR (i,y)&(t (g,y)_:t (g,y))&gt; where sp=&lt;IN,OUT,IC,IOR&gt; The following theorem which may be considerd a reformulation of Theorem 4.6 gives clearer insights into the deductive behaviour the GUESS transformation. <p> Many parts need to be worked out in further detail. In particular, all components involved in the programming process must be formalized to prove general correlations between them. Embedding already existing approaches to program synthesis (like LOPS <ref> [Bib80, BH84] </ref> or KIDS [SL89, SL90]) into our framework is another path to be followed. Behind the KIDS system, for instance, there is already a theory which proves its program construction methods correct on some mathematical level.
Reference: [Bru80] <author> N. G. De Bruijn. </author> <title> A survey of the project AUTOMATH. </title> <editor> In J.P. Sedlin and J.R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference: [CAB + 86] <author> R. L. Constable et. al. </author> <title> Implementing Mathematics with the NuPRL proof development system. </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: We selected Intuitionistic Type Theory as general formalism to underly our formal framework. Reasons for that are discussed in the following section where we also introduce syntax and features of the NuPRL proof development system for Type Theory <ref> [BC85, CAB + 86] </ref>. Section 3 explains the methodology we will follow. In Section 4 then the frame for reasoning about the object level of programming will be presented and illustrated by an exemplified formalization of strategies of the LOPS system [Bib80, BH84]. <p> As formulation to underly our theory we selected the one of NuPRL <ref> [BC85, CAB + 86] </ref>, a descendent of Martin-L of's Type Theory [ML82], because an interactive environment for developing completely formal theories in NuPRL is already available. <p> The propositions-as-types correspondence thus gives a constructive predicate logic with sorts for free. Syntax and some details of NuPRL's Type Theory are listed in Figure 1. For a full presentation we refer the reader to <ref> [CAB + 86] </ref> (chapter 8). 57 NuPRL statements are expressed in the form of sequents. <p> It allows a user to write meta-programs guiding the application of refinement rules. Such tactics act as derived inference rules whose correctness is guaranteed by the fact that they have to make use of primitive inference rules to actually modify a proof. Experiments with NuPRL reported in <ref> [CAB + 86, How86, Kre86, Cle87, How88a, Bas89] </ref> show that together with the expressive power of Type Theory these components strongly support a flexible high level "implementation" of mathematical theories. 3 Methodology and notation As said before the formal theory of program construction shall provide a unified framework for reasoning about <p> Formal definitions introduce new notions. In formal theorems important properties are stated and verified. During the past years, a number of domain theories have been implemented with NuPRL. We refer the reader to <ref> [CAB + 86, How86, Kre86, Cle87, How88a] </ref> and particularly to [Bas89] for accounts of how mathematical knowledge should be represented and reasoned about. Here we will present some elements of a theory about finite sets over ordered types which we will use in Section 4.3.
Reference: [CH88] <author> T. Coquand and G. Huet. </author> <title> The calculus of constructions. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 95-120, </pages> <year> 1988. </year>
Reference-contexts: A theoretical foundation for them does not exist so far. In our opinion this is due to a lack of abstraction when formalizing deductive mechanisms for program development. Lots of general deductive calculi (see e.g. <ref> [ML82, CH88, Gal90] </ref>) are known to be powerful enough that all kinds of programs can be derived within them. But for treating the problem these must be considered to be at the same level as assembler languages for writing programs. <p> Directing the formal theory towards the development of verified program synthesizers, i.e. towards representing deductive mechanisms for programming, proving them correct and creating a verified implementation, distinguishes our approach from those focusing on "low level" calculi <ref> [ML82, BC85, CH88, PM89, Coq89, Gal90] </ref>, on metareasoning within a such a calculus [CK86, Kno87, How88b] or on implementing a deductive mechanism by representing it in some calculus [Pau87, HRS90, Web90]. <p> We will later see how this influences the approaches to solve it. 5.2 Principal approaches to program synthesis Essentially there are two different ideologies to approach program synthesis: * The so-called theorem proving or AE approaches <ref> [MW80, BC85, Fra85, CH88, Gal90] </ref> arose from the idea that constructing a program and proving it logically correct should be done at the same time. <p> The advantage of this direction is its solid theoretical foundation. A lot of research has been done in developing appropriate logical calculi (see e.g. <ref> [ML82, BC85, CH88, PM89, Coq89, Gal90] </ref>) and algorithms extracting (efficient) programs from proofs within these [Hay86, CH88, PM89]. 2 However, AE approaches suffer from the fact that, if general theorem proving strategies like resolution are used, the method a program is constructed appears to be quite unnatural. <p> The advantage of this direction is its solid theoretical foundation. A lot of research has been done in developing appropriate logical calculi (see e.g. [ML82, BC85, CH88, PM89, Coq89, Gal90]) and algorithms extracting (efficient) programs from proofs within these <ref> [Hay86, CH88, PM89] </ref>. 2 However, AE approaches suffer from the fact that, if general theorem proving strategies like resolution are used, the method a program is constructed appears to be quite unnatural.
Reference: [Chu40] <author> A. Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference: [CK86] <author> R. L. Constable and T.B. Knoblock. </author> <title> Formalized metareasoning in Type Theory. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <year> 1986. </year>
Reference-contexts: Directing the formal theory towards the development of verified program synthesizers, i.e. towards representing deductive mechanisms for programming, proving them correct and creating a verified implementation, distinguishes our approach from those focusing on "low level" calculi [ML82, BC85, CH88, PM89, Coq89, Gal90], on metareasoning within a such a calculus <ref> [CK86, Kno87, How88b] </ref> or on implementing a deductive mechanism by representing it in some calculus [Pau87, HRS90, Web90]. To avoid creating a new logic and get distracted from our original goal we will select one of the already established general deductive calculi to underly our theory. <p> We would have to make use of the meta-level of Type Theory, i.e. ML-programs, to do so. Of course, one might give an exhaustive extensional definition using NuPRL's recursive types [CM85, Men87] and apply methods developed for partial reflection and formal metamathematics in NuPRL <ref> [CK86, Kno87, How88b] </ref> but this would create a big overhead. It will turn out that for investigating program construction methods we can do without this syntactic information which would rather burden us with superfluous details and does not give any additional insights.
Reference: [Cle87] <author> W. R. Cleaveland. </author> <title> Type-theoretic models of concurrency. </title> <type> Report TR 87-837, </type> <institution> Cornell University. Department of Computer Science, </institution> <year> 1987. </year>
Reference-contexts: It allows a user to write meta-programs guiding the application of refinement rules. Such tactics act as derived inference rules whose correctness is guaranteed by the fact that they have to make use of primitive inference rules to actually modify a proof. Experiments with NuPRL reported in <ref> [CAB + 86, How86, Kre86, Cle87, How88a, Bas89] </ref> show that together with the expressive power of Type Theory these components strongly support a flexible high level "implementation" of mathematical theories. 3 Methodology and notation As said before the formal theory of program construction shall provide a unified framework for reasoning about <p> Formal definitions introduce new notions. In formal theorems important properties are stated and verified. During the past years, a number of domain theories have been implemented with NuPRL. We refer the reader to <ref> [CAB + 86, How86, Kre86, Cle87, How88a] </ref> and particularly to [Bas89] for accounts of how mathematical knowledge should be represented and reasoned about. Here we will present some elements of a theory about finite sets over ordered types which we will use in Section 4.3.
Reference: [CM85] <author> R. L. Constable and P. Mendler. </author> <title> Recursive definitions in Type Theory. </title> <booktitle> In Logics of Programs Conference, </booktitle> <pages> pages 61-78. </pages> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: We would have to make use of the meta-level of Type Theory, i.e. ML-programs, to do so. Of course, one might give an exhaustive extensional definition using NuPRL's recursive types <ref> [CM85, Men87] </ref> and apply methods developed for partial reflection and formal metamathematics in NuPRL [CK86, Kno87, How88b] but this would create a big overhead.
Reference: [Coq89] <author> T. Coquand. </author> <title> Metamathematical investigations of a calculus of constructions. </title> <type> Report 1088, </type> <institution> Institut National de Recherche en Informatique et en Automa-tique, </institution> <year> 1989. </year>
Reference-contexts: Directing the formal theory towards the development of verified program synthesizers, i.e. towards representing deductive mechanisms for programming, proving them correct and creating a verified implementation, distinguishes our approach from those focusing on "low level" calculi <ref> [ML82, BC85, CH88, PM89, Coq89, Gal90] </ref>, on metareasoning within a such a calculus [CK86, Kno87, How88b] or on implementing a deductive mechanism by representing it in some calculus [Pau87, HRS90, Web90]. <p> The advantage of this direction is its solid theoretical foundation. A lot of research has been done in developing appropriate logical calculi (see e.g. <ref> [ML82, BC85, CH88, PM89, Coq89, Gal90] </ref>) and algorithms extracting (efficient) programs from proofs within these [Hay86, CH88, PM89]. 2 However, AE approaches suffer from the fact that, if general theorem proving strategies like resolution are used, the method a program is constructed appears to be quite unnatural.
Reference: [Der85] <author> N. Dershowitz. </author> <title> Synthesis by completion. </title> <booktitle> In IJCAI 85, </booktitle> <pages> pages 208-214, </pages> <year> 1985. </year>
Reference-contexts: Furthermore, there is only little practical experience in constructing AE proofs for a larger class of programming problems. * In transformation based approaches (see e.g. <ref> [BD77, MW79, Bib80, Hog81, BH84, Der85, SL89, SL90] </ref>) a specification is treated as if it were already some kind of logic program, though an inefficient one.
Reference: [Dij76] <author> E. W. Dijkstra. </author> <title> A discipline of Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1976. </year>
Reference-contexts: 1 Introduction Since the upcoming of the so-called software crisis efforts have been put into the production of better software. Methodologists <ref> [Gri81, Dij76] </ref> have developed a science of programming to solve the problem that products of the software production business seldomly meet the original intentions of the clients and are very difficult to maintain and modify.
Reference: [Fra85] <author> M. Franova. </author> <title> A methodology for automatic programming based on the constructive matching strategy. </title> <booktitle> In EUROCAL 85, </booktitle> <pages> pages 568-570. </pages> <publisher> Springer, </publisher> <year> 1985. </year>
Reference-contexts: We will later see how this influences the approaches to solve it. 5.2 Principal approaches to program synthesis Essentially there are two different ideologies to approach program synthesis: * The so-called theorem proving or AE approaches <ref> [MW80, BC85, Fra85, CH88, Gal90] </ref> arose from the idea that constructing a program and proving it logically correct should be done at the same time.
Reference: [Fro85] <author> B. </author> <title> Fronh ofer. The LOPS-approach: Towards new syntheses of algorithms. </title> <editor> In H. Trost and J. Retti, editors, </editor> <volume> OGAI 85, </volume> <pages> pages 164-172. </pages> <publisher> Springer, </publisher> <year> 1985. </year>
Reference-contexts: As running example we chose key strategies of the LOPS (LOgic Program Synthesis) system <ref> [Bib80, BH84, Fro85, NFK89] </ref> which may be briefly summarized as follows: Starting with a specification given as a first-order formula of the form 8i 9y ( IC (i) ) OC (i,y) ) where i and y represent input and output variable, IC some input condition, and OC the relation between input
Reference: [Gal90] <author> D. </author> <title> Galmiche. Constructive system for automatic program synthesis. </title> <journal> Theoretical Computer Science, </journal> <volume> 71 </volume> <pages> 227-239, </pages> <year> 1990. </year>
Reference-contexts: A theoretical foundation for them does not exist so far. In our opinion this is due to a lack of abstraction when formalizing deductive mechanisms for program development. Lots of general deductive calculi (see e.g. <ref> [ML82, CH88, Gal90] </ref>) are known to be powerful enough that all kinds of programs can be derived within them. But for treating the problem these must be considered to be at the same level as assembler languages for writing programs. <p> Directing the formal theory towards the development of verified program synthesizers, i.e. towards representing deductive mechanisms for programming, proving them correct and creating a verified implementation, distinguishes our approach from those focusing on "low level" calculi <ref> [ML82, BC85, CH88, PM89, Coq89, Gal90] </ref>, on metareasoning within a such a calculus [CK86, Kno87, How88b] or on implementing a deductive mechanism by representing it in some calculus [Pau87, HRS90, Web90]. <p> We will later see how this influences the approaches to solve it. 5.2 Principal approaches to program synthesis Essentially there are two different ideologies to approach program synthesis: * The so-called theorem proving or AE approaches <ref> [MW80, BC85, Fra85, CH88, Gal90] </ref> arose from the idea that constructing a program and proving it logically correct should be done at the same time. <p> The advantage of this direction is its solid theoretical foundation. A lot of research has been done in developing appropriate logical calculi (see e.g. <ref> [ML82, BC85, CH88, PM89, Coq89, Gal90] </ref>) and algorithms extracting (efficient) programs from proofs within these [Hay86, CH88, PM89]. 2 However, AE approaches suffer from the fact that, if general theorem proving strategies like resolution are used, the method a program is constructed appears to be quite unnatural.
Reference: [GMW79] <author> M. J. Gordon, R. Milner, and C. Wadsworth. </author> <title> Edinburgh LCF: A mechanized Logic of Computation. </title> <publisher> Springer Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Besides a highly 58 visual proof-editor for interactive development of proofs and extraction of their computational contents a definition mechanism allows to abstract from low-level type theoretical expressions and enhance readability of mechanical proofs. In addition to that a high-level programming language ML, originally developed for Edinburgh's LCF System <ref> [GMW79] </ref>, serves as the meta-language of NuPRL. It allows a user to write meta-programs guiding the application of refinement rules. Such tactics act as derived inference rules whose correctness is guaranteed by the fact that they have to make use of primitive inference rules to actually modify a proof.
Reference: [Gri81] <editor> D. Gries. </editor> <booktitle> The science of programming. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1981. </year>
Reference-contexts: 1 Introduction Since the upcoming of the so-called software crisis efforts have been put into the production of better software. Methodologists <ref> [Gri81, Dij76] </ref> have developed a science of programming to solve the problem that products of the software production business seldomly meet the original intentions of the clients and are very difficult to maintain and modify.
Reference: [Hay86] <author> S. Hayashi. PX: </author> <title> a system extracting programs from proofs. </title> <booktitle> In IFIP Conference on Formal Description of Programming Concepts, </booktitle> <pages> pages 399-424, </pages> <year> 1986. </year>
Reference-contexts: The advantage of this direction is its solid theoretical foundation. A lot of research has been done in developing appropriate logical calculi (see e.g. [ML82, BC85, CH88, PM89, Coq89, Gal90]) and algorithms extracting (efficient) programs from proofs within these <ref> [Hay86, CH88, PM89] </ref>. 2 However, AE approaches suffer from the fact that, if general theorem proving strategies like resolution are used, the method a program is constructed appears to be quite unnatural.
Reference: [Hog81] <author> C. J. </author> <title> Hogger. Derivation of logic programs. </title> <journal> Journal of the ACM, </journal> <volume> 28(2) </volume> <pages> 372-392, </pages> <year> 1981. </year>
Reference-contexts: Furthermore, there is only little practical experience in constructing AE proofs for a larger class of programming problems. * In transformation based approaches (see e.g. <ref> [BD77, MW79, Bib80, Hog81, BH84, Der85, SL89, SL90] </ref>) a specification is treated as if it were already some kind of logic program, though an inefficient one.
Reference: [How86] <author> D. Howe. </author> <title> Implementing number theory: An experiment with NuPRL. </title> <booktitle> In CADE 8, </booktitle> <pages> pages 404-415. </pages> <publisher> Springer, </publisher> <year> 1986. </year>
Reference-contexts: It allows a user to write meta-programs guiding the application of refinement rules. Such tactics act as derived inference rules whose correctness is guaranteed by the fact that they have to make use of primitive inference rules to actually modify a proof. Experiments with NuPRL reported in <ref> [CAB + 86, How86, Kre86, Cle87, How88a, Bas89] </ref> show that together with the expressive power of Type Theory these components strongly support a flexible high level "implementation" of mathematical theories. 3 Methodology and notation As said before the formal theory of program construction shall provide a unified framework for reasoning about <p> Formal definitions introduce new notions. In formal theorems important properties are stated and verified. During the past years, a number of domain theories have been implemented with NuPRL. We refer the reader to <ref> [CAB + 86, How86, Kre86, Cle87, How88a] </ref> and particularly to [Bas89] for accounts of how mathematical knowledge should be represented and reasoned about. Here we will present some elements of a theory about finite sets over ordered types which we will use in Section 4.3.
Reference: [How88a] <author> D. Howe. </author> <title> Automating reasoning in an implementation of constructive Type Theory. </title> <type> Report TR 88-925, </type> <institution> Cornell University. Department of Computer Science, </institution> <year> 1988. </year>
Reference-contexts: It allows a user to write meta-programs guiding the application of refinement rules. Such tactics act as derived inference rules whose correctness is guaranteed by the fact that they have to make use of primitive inference rules to actually modify a proof. Experiments with NuPRL reported in <ref> [CAB + 86, How86, Kre86, Cle87, How88a, Bas89] </ref> show that together with the expressive power of Type Theory these components strongly support a flexible high level "implementation" of mathematical theories. 3 Methodology and notation As said before the formal theory of program construction shall provide a unified framework for reasoning about <p> Formal definitions introduce new notions. In formal theorems important properties are stated and verified. During the past years, a number of domain theories have been implemented with NuPRL. We refer the reader to <ref> [CAB + 86, How86, Kre86, Cle87, How88a] </ref> and particularly to [Bas89] for accounts of how mathematical knowledge should be represented and reasoned about. Here we will present some elements of a theory about finite sets over ordered types which we will use in Section 4.3.
Reference: [How88b] <author> D. Howe. </author> <title> Computational metatheory in NuPRL. </title> <booktitle> In CADE 9, </booktitle> <pages> pages 238-257, </pages> <year> 1988. </year>
Reference-contexts: Directing the formal theory towards the development of verified program synthesizers, i.e. towards representing deductive mechanisms for programming, proving them correct and creating a verified implementation, distinguishes our approach from those focusing on "low level" calculi [ML82, BC85, CH88, PM89, Coq89, Gal90], on metareasoning within a such a calculus <ref> [CK86, Kno87, How88b] </ref> or on implementing a deductive mechanism by representing it in some calculus [Pau87, HRS90, Web90]. To avoid creating a new logic and get distracted from our original goal we will select one of the already established general deductive calculi to underly our theory. <p> We would have to make use of the meta-level of Type Theory, i.e. ML-programs, to do so. Of course, one might give an exhaustive extensional definition using NuPRL's recursive types [CM85, Men87] and apply methods developed for partial reflection and formal metamathematics in NuPRL <ref> [CK86, Kno87, How88b] </ref> but this would create a big overhead. It will turn out that for investigating program construction methods we can do without this syntactic information which would rather burden us with superfluous details and does not give any additional insights.
Reference: [HRS90] <author> M. Heisel, W. Reif, and W. Stephan. </author> <title> Tactical theorem proving in program verification. </title> <editor> In M. Stickel, editor, </editor> <booktitle> CADE 10, </booktitle> <pages> pages 117-131, </pages> <year> 1990. </year> <month> 78 </month>
Reference-contexts: deductive mechanisms for programming, proving them correct and creating a verified implementation, distinguishes our approach from those focusing on "low level" calculi [ML82, BC85, CH88, PM89, Coq89, Gal90], on metareasoning within a such a calculus [CK86, Kno87, How88b] or on implementing a deductive mechanism by representing it in some calculus <ref> [Pau87, HRS90, Web90] </ref>. To avoid creating a new logic and get distracted from our original goal we will select one of the already established general deductive calculi to underly our theory.
Reference: [Kno87] <author> T. B. Knoblock. </author> <title> Metamathematical extensibility in Type Theory. </title> <type> Report TR 87-892, </type> <institution> Cornell University. Department of Computer Science, </institution> <year> 1987. </year>
Reference-contexts: Directing the formal theory towards the development of verified program synthesizers, i.e. towards representing deductive mechanisms for programming, proving them correct and creating a verified implementation, distinguishes our approach from those focusing on "low level" calculi [ML82, BC85, CH88, PM89, Coq89, Gal90], on metareasoning within a such a calculus <ref> [CK86, Kno87, How88b] </ref> or on implementing a deductive mechanism by representing it in some calculus [Pau87, HRS90, Web90]. To avoid creating a new logic and get distracted from our original goal we will select one of the already established general deductive calculi to underly our theory. <p> We would have to make use of the meta-level of Type Theory, i.e. ML-programs, to do so. Of course, one might give an exhaustive extensional definition using NuPRL's recursive types [CM85, Men87] and apply methods developed for partial reflection and formal metamathematics in NuPRL <ref> [CK86, Kno87, How88b] </ref> but this would create a big overhead. It will turn out that for investigating program construction methods we can do without this syntactic information which would rather burden us with superfluous details and does not give any additional insights.
Reference: [Kre86] <author> C. </author> <title> Kreitz. Constructive automata theory implemented with the NuPRL proof development system. </title> <type> Report TR 86-779, </type> <institution> Cornell University. Department of Computer Science, </institution> <year> 1986. </year>
Reference-contexts: It allows a user to write meta-programs guiding the application of refinement rules. Such tactics act as derived inference rules whose correctness is guaranteed by the fact that they have to make use of primitive inference rules to actually modify a proof. Experiments with NuPRL reported in <ref> [CAB + 86, How86, Kre86, Cle87, How88a, Bas89] </ref> show that together with the expressive power of Type Theory these components strongly support a flexible high level "implementation" of mathematical theories. 3 Methodology and notation As said before the formal theory of program construction shall provide a unified framework for reasoning about <p> Formal definitions introduce new notions. In formal theorems important properties are stated and verified. During the past years, a number of domain theories have been implemented with NuPRL. We refer the reader to <ref> [CAB + 86, How86, Kre86, Cle87, How88a] </ref> and particularly to [Bas89] for accounts of how mathematical knowledge should be represented and reasoned about. Here we will present some elements of a theory about finite sets over ordered types which we will use in Section 4.3.
Reference: [Men87] <author> P. Mendler. </author> <title> Inductive definition in Type Theory. </title> <type> Report TR 87-870, </type> <institution> Cornell University. Department of Computer Science, </institution> <year> 1987. </year>
Reference-contexts: We would have to make use of the meta-level of Type Theory, i.e. ML-programs, to do so. Of course, one might give an exhaustive extensional definition using NuPRL's recursive types <ref> [CM85, Men87] </ref> and apply methods developed for partial reflection and formal metamathematics in NuPRL [CK86, Kno87, How88b] but this would create a big overhead.
Reference: [ML82] <author> P. </author> <title> Martin-L of. </title> <booktitle> Constructive mathematics and computer programming. In 6th International Congress for Logic, Methodology and Philosophy of Science, </booktitle> <year> 1979, </year> <pages> pages 153-175, </pages> <publisher> North-Holland, </publisher> <year> 1982. </year>
Reference-contexts: A theoretical foundation for them does not exist so far. In our opinion this is due to a lack of abstraction when formalizing deductive mechanisms for program development. Lots of general deductive calculi (see e.g. <ref> [ML82, CH88, Gal90] </ref>) are known to be powerful enough that all kinds of programs can be derived within them. But for treating the problem these must be considered to be at the same level as assembler languages for writing programs. <p> Directing the formal theory towards the development of verified program synthesizers, i.e. towards representing deductive mechanisms for programming, proving them correct and creating a verified implementation, distinguishes our approach from those focusing on "low level" calculi <ref> [ML82, BC85, CH88, PM89, Coq89, Gal90] </ref>, on metareasoning within a such a calculus [CK86, Kno87, How88b] or on implementing a deductive mechanism by representing it in some calculus [Pau87, HRS90, Web90]. <p> Thus type symbols even provide important syntactic clues which are not available in untyped theories. Furthermore, the whole conceptual apparatus of programming mirrors that of intuitionistic mathematics (c.f. <ref> [ML82] </ref> p.155) and can be immediately embedded as well. <p> As formulation to underly our theory we selected the one of NuPRL [BC85, CAB + 86], a descendent of Martin-L of's Type Theory <ref> [ML82] </ref>, because an interactive environment for developing completely formal theories in NuPRL is already available. <p> Thus a program essentially is a function from input- to output space, a view supported by <ref> [ML82, SL89] </ref> and constructive mathematicians. <p> The advantage of this direction is its solid theoretical foundation. A lot of research has been done in developing appropriate logical calculi (see e.g. <ref> [ML82, BC85, CH88, PM89, Coq89, Gal90] </ref>) and algorithms extracting (efficient) programs from proofs within these [Hay86, CH88, PM89]. 2 However, AE approaches suffer from the fact that, if general theorem proving strategies like resolution are used, the method a program is constructed appears to be quite unnatural.
Reference: [MW79] <author> Z. Manna and R. Waldinger. </author> <title> Synthesis: Dreams ) programs. </title> <journal> IEEE Transactions of Software Engineering, </journal> <volume> SE-5(4):294-328, </volume> <year> 1979. </year>
Reference-contexts: Furthermore, there is only little practical experience in constructing AE proofs for a larger class of programming problems. * In transformation based approaches (see e.g. <ref> [BD77, MW79, Bib80, Hog81, BH84, Der85, SL89, SL90] </ref>) a specification is treated as if it were already some kind of logic program, though an inefficient one.
Reference: [MW80] <author> Z. Manna and R. Waldinger. </author> <title> A deductive approach to program synthesis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(1) </volume> <pages> 90-121, </pages> <year> 1980. </year>
Reference-contexts: Many of them use an additional precondition IC on the input to exclude singular cases like division by zero (see e.g. <ref> [MW80, Bib80, SL89] </ref>). Obviously, the domains IN and OU T should be first-order types and IC; IOR must be first-order formulae over the appropriate types. <p> We will later see how this influences the approaches to solve it. 5.2 Principal approaches to program synthesis Essentially there are two different ideologies to approach program synthesis: * The so-called theorem proving or AE approaches <ref> [MW80, BC85, Fra85, CH88, Gal90] </ref> arose from the idea that constructing a program and proving it logically correct should be done at the same time.
Reference: [NFK89] <author> G. Neugebauer, B. Fronh ofer, and C. </author> <title> Kreitz. XPRTS an implementation tool for program synthesis. </title> <editor> In D. Metzing, editor, </editor> <volume> GWAI 89, </volume> <pages> pages 348-357. </pages> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: After a while many program synthesizers tend to get quite bulky and improved versions again have to be build from scratch (c.f. experiences reported in <ref> [NFK89] </ref>). Often there are even doubts about the faithfulness of the implementation and it is not clear if or why they are correct. <p> As running example we chose key strategies of the LOPS (LOgic Program Synthesis) system <ref> [Bib80, BH84, Fro85, NFK89] </ref> which may be briefly summarized as follows: Starting with a specification given as a first-order formula of the form 8i 9y ( IC (i) ) OC (i,y) ) where i and y represent input and output variable, IC some input condition, and OC the relation between input <p> From a practical point of view LOPS is simply a shortcut in this chain of reasoning and it is only natural that later implementations of LOPS <ref> [NFK89] </ref> chose to abandon the framework of 89-quantified formulae in favour of a representation fitting the LOPS approach better. We will demonstrate this by running the maximum example in the correct framework. The control decisions now are explicitely mentioned.
Reference: [Pau87] <author> L. Paulson. </author> <title> The representation of logics in higher-order logic. </title> <type> Technical Report 113, </type> <institution> University of Cambridge. Computer Laboratory, </institution> <year> 1987. </year>
Reference-contexts: deductive mechanisms for programming, proving them correct and creating a verified implementation, distinguishes our approach from those focusing on "low level" calculi [ML82, BC85, CH88, PM89, Coq89, Gal90], on metareasoning within a such a calculus [CK86, Kno87, How88b] or on implementing a deductive mechanism by representing it in some calculus <ref> [Pau87, HRS90, Web90] </ref>. To avoid creating a new logic and get distracted from our original goal we will select one of the already established general deductive calculi to underly our theory. <p> However, it lacks uniformity and formality and cannot say anything about the actual implementation. Such gaps could be filled by formal investigations. The principles discussed here are not restricted to the area of program construction. They can, as research on representing various logics in higher-order logic <ref> [Pau87] </ref> indicates, be generalized to reasoning about other deductive mechanisms as well. Acknowledgements We thank Robert Constable and the NuPRL group of Cornell University for helpful discussions when preparing the beginnings of this theory, particularly for hints on self-reflection mechanisms and practical limitations of implementing Type Theory.
Reference: [PM89] <author> C. Paulin-Mohring. </author> <title> Extracting F ! 's programs from proofs in the Calculus of Constructions. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 89-104, </pages> <year> 1989. </year>
Reference-contexts: Directing the formal theory towards the development of verified program synthesizers, i.e. towards representing deductive mechanisms for programming, proving them correct and creating a verified implementation, distinguishes our approach from those focusing on "low level" calculi <ref> [ML82, BC85, CH88, PM89, Coq89, Gal90] </ref>, on metareasoning within a such a calculus [CK86, Kno87, How88b] or on implementing a deductive mechanism by representing it in some calculus [Pau87, HRS90, Web90]. <p> The advantage of this direction is its solid theoretical foundation. A lot of research has been done in developing appropriate logical calculi (see e.g. <ref> [ML82, BC85, CH88, PM89, Coq89, Gal90] </ref>) and algorithms extracting (efficient) programs from proofs within these [Hay86, CH88, PM89]. 2 However, AE approaches suffer from the fact that, if general theorem proving strategies like resolution are used, the method a program is constructed appears to be quite unnatural. <p> The advantage of this direction is its solid theoretical foundation. A lot of research has been done in developing appropriate logical calculi (see e.g. [ML82, BC85, CH88, PM89, Coq89, Gal90]) and algorithms extracting (efficient) programs from proofs within these <ref> [Hay86, CH88, PM89] </ref>. 2 However, AE approaches suffer from the fact that, if general theorem proving strategies like resolution are used, the method a program is constructed appears to be quite unnatural.
Reference: [SL89] <author> D. R. Smith and M. R. Lowry. </author> <title> Algorithm design and design tactics. </title> <booktitle> In International Conference on the Mathematics of Program Construction, </booktitle> <pages> pages 379-398. </pages> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Many of them use an additional precondition IC on the input to exclude singular cases like division by zero (see e.g. <ref> [MW80, Bib80, SL89] </ref>). Obviously, the domains IN and OU T should be first-order types and IC; IOR must be first-order formulae over the appropriate types. <p> Thus a program essentially is a function from input- to output space, a view supported by <ref> [ML82, SL89] </ref> and constructive mathematicians. <p> and building a synthesizer means to construct a program fulfilling it (by showing its solvability): SYNTHESIZABLE (pc) 9synth:SPECIFICATIONS-&gt;PROGRAMS. 8sp:SPECIFICATIONS. pc (sp)) FULFILS (sp,synth (sp)) One may object that these definitions do not include partial functions or mul-tivalued ones which typically express the behaviour of logic programs or those used in <ref> [SL89] </ref>. Such an objection could be answered by referring to the possibility of choosing the powerset P (OU T ) of the output space as the real output domain. <p> Furthermore, there is only little practical experience in constructing AE proofs for a larger class of programming problems. * In transformation based approaches (see e.g. <ref> [BD77, MW79, Bib80, Hog81, BH84, Der85, SL89, SL90] </ref>) a specification is treated as if it were already some kind of logic program, though an inefficient one. <p> To show that such a program can be constructed means to prove the following: 9p:M-PROGRAMS.8x:IN (p). IC (x) ) body (p)(x)=fy:OUT (p)|IOR (x,y)g 73 This form which is nearly the same as the one of <ref> [SL89] </ref> is absolutely identical to our M-SOLVABLE (&lt;IN,OUT,IC,IOR&gt;) predicate, the synthesis problem for mul-tivalued functions, and allows controlling the effects of transforming IOR (x; y) by theorems of some abstract algorithm theory. <p> Many parts need to be worked out in further detail. In particular, all components involved in the programming process must be formalized to prove general correlations between them. Embedding already existing approaches to program synthesis (like LOPS [Bib80, BH84] or KIDS <ref> [SL89, SL90] </ref>) into our framework is another path to be followed. Behind the KIDS system, for instance, there is already a theory which proves its program construction methods correct on some mathematical level. However, it lacks uniformity and formality and cannot say anything about the actual implementation.
Reference: [SL90] <author> D. R. Smith and M. R. Lowry. </author> <title> KIDS a knowledge-based software development system. </title> <editor> In M. R. Lowry and R. McCartney, editors, </editor> <booktitle> Automating Software Design, </booktitle> <address> Menlo Park, </address> <year> 1990. </year>
Reference-contexts: Many formal approaches for the automated synthesis of programs have been developed and implemented during the last years (see e.g. [BD77, MW79, MW80, Bib80, Hog81, BH84, Der85, BC85, Fra85, CH88, NFK89, PM89, SL89, SL90, Gal90]). The KIDS system <ref> [SL90] </ref>, most mature of the realized ones, is even be lieved close to the point where it can be used for routine programming. Current implementations of program synthesis systems, however, more or less underly the same problems as conventional software. <p> Furthermore, there is only little practical experience in constructing AE proofs for a larger class of programming problems. * In transformation based approaches (see e.g. <ref> [BD77, MW79, Bib80, Hog81, BH84, Der85, SL89, SL90] </ref>) a specification is treated as if it were already some kind of logic program, though an inefficient one. <p> Practical aspects and efficiency considerations have been the driving force of these approaches. Therefore the practical results of already existing systems like KIDS <ref> [SL90] </ref> are much better than those of AE based ones. In more recent approaches also strong theoretical foundations have been incorporated (see e.g. [SL90] where domain knowledge and program construction methods have been investigated). <p> Practical aspects and efficiency considerations have been the driving force of these approaches. Therefore the practical results of already existing systems like KIDS <ref> [SL90] </ref> are much better than those of AE based ones. In more recent approaches also strong theoretical foundations have been incorporated (see e.g. [SL90] where domain knowledge and program construction methods have been investigated). Since, however, the degree of formalization is way below that of the AE approaches it is not clear how the implementations reflect the theoretical foundations. <p> Many parts need to be worked out in further detail. In particular, all components involved in the programming process must be formalized to prove general correlations between them. Embedding already existing approaches to program synthesis (like LOPS [Bib80, BH84] or KIDS <ref> [SL89, SL90] </ref>) into our framework is another path to be followed. Behind the KIDS system, for instance, there is already a theory which proves its program construction methods correct on some mathematical level. However, it lacks uniformity and formality and cannot say anything about the actual implementation.
Reference: [Smi84] <author> J. Smith. </author> <title> An interpretation of Martin-L of's Type Theory in a type-free theory of propositions. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 49(3) </volume> <pages> 730-753, </pages> <year> 1984. </year>
Reference: [Web90] <author> M. Weber. </author> <title> Formalization of the Bird-Meertens algorithmic calculus in the DEVA meta-calculus. </title> <booktitle> In IFIP Working Conference on Programming Concepts and Methods, </booktitle> <year> 1990. </year> <month> 79 </month>
Reference-contexts: deductive mechanisms for programming, proving them correct and creating a verified implementation, distinguishes our approach from those focusing on "low level" calculi [ML82, BC85, CH88, PM89, Coq89, Gal90], on metareasoning within a such a calculus [CK86, Kno87, How88b] or on implementing a deductive mechanism by representing it in some calculus <ref> [Pau87, HRS90, Web90] </ref>. To avoid creating a new logic and get distracted from our original goal we will select one of the already established general deductive calculi to underly our theory.
References-found: 40

