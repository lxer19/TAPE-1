URL: http://www.cs.ucsd.edu/~calder/pfdc/papers/pfdc-kistler.ps.Z
Refering-URL: http://www.cs.ucsd.edu/~calder/pfdc/program.html
Root-URL: http://www.cs.ucsd.edu
Title: Computing the Similarity of Profiling Data Heuristics for Guiding Adaptive Compilation  
Author: Thomas Kistler and Michael Franz 
Address: Irvine, CA 92697-3425  
Affiliation: Department of Information and Computer Science University of California at Irvine  
Abstract: We present a technique to measure and detect changes in the behavioral patterns of applications. In a continually dynamically optimizing system, such information is useful not only to decide which program parts to optimize, but also which previously optimized program parts to re-optimize. This leads to a system that is better tailored towards users' needs than statically optimized systems.
Abstract-found: 1
Intro-found: 1
Reference: [DS84] <author> P. Deutsch and A. Schiffman. </author> <title> "Efficient Implementation of the Smalltalk-80 System". </title> <booktitle> In Proceedings of the 11th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pp 297-302, </pages> <month> January </month> <year> 1984. </year> <note> Kistler and Franz 6 </note>
Reference-contexts: Once the counter becomes negative, the block is optimized and finalized|no backtracking and no "deoptimization" is allowed. Unfortunately, this results in a less adaptive system that cannot react to changes in the behavior of application programs. The Smalltalk-80 system <ref> [DS84] </ref> uses no counters at all, but rather translates and optimizes the intermediate code into native code when a procedure is about Kistler and Franz 5 to be executed for the first time. The generated code image is then cached for subsequent invocations.
Reference: [Fra97] <author> M. Franz. </author> <title> "Run-Time Code Generation as a Central System Service". </title> <booktitle> In The Sixth Workshop on Hot Topics in Operating Systems (HotOS-VI), </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pp 112-117, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: Similar to Digital FX!32, however, the system optimizes applications after execution and hence lacks adaptability as well. In contrast to all of the above work, we are currently developing a system that not only dynamically optimizes programs but also continuously monitors the system's behavior using the above-described function <ref> [Kis96, Fra97] </ref>. In case of substantial changes in the user's behavior, applications are dynamically re-optimized in the background which leads to a much more responsive and adaptive system. 5 Acknowledgement Part of this work is funded by the National Science Foundation under grant CCR-97014000.
Reference: [Han74] <author> G. Hansen. </author> <title> Adaptive Systems for the Dynamic Run-Time Optimization of Programs. </title> <type> Ph.D. Dissertation, </type> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <year> 1974. </year>
Reference-contexts: Hence, program reoptimization can be performed on a finer level of granularity. As an example, as soon as the similarity measure for a single procedure changes, the procedure can exclusively be optimized and replaced on-the-fly. 4 Related Work Pioneering research in dynamic program optimization was done by Hansen <ref> [Han74] </ref> who first described a fully automated system for incremental code optimization. In this system, all optimizations are performed on basic blocks/segments. In order to decide when to optimize and what to optimize, a counter is inserted into each basic block.
Reference: [HH97] <author> R. Hookway and M. Herdeg. </author> <title> DIGITAL FX!32: Combining Emulation and Binary Translation. </title> <journal> In Digital Technical Journal 9(1) </journal> <pages> 3-12, </pages> <year> 1997. </year>
Reference-contexts: Although the Self-93 system performs dynamic optimization, it does not perform dynamic re-optimization. Once a certain optimization has been performed, the counters are removed and no further enhancements are possible. The system therefore also lacks adaptability. Digital FX!32 <ref> [HH97] </ref> is a binary translation mechanism that enables the execution of Intel x86 applications on Alpha microprocessors. An Intel x86 program is first emulated on the target machine to gather profiling data.
Reference: [HU96] <author> U. Holzle, D. Ungar. </author> <title> "Reconciling Responsiveness with Performance in Pure Object-Oriented Languages". </title> <booktitle> In ACM Transactions on Programming Languages and Systems 18(4), </booktitle> <pages> pp 355-400, </pages> <year> 1996. </year>
Reference-contexts: One of the key issues of dynamic optimization is to determine when to optimize and what to optimize. Optimizing too aggressively does not pay back the time invested in code optimization and optimizing too little does not sufficiently improve runtime performance <ref> [HU96] </ref>. In most systems, deciding what and when to optimize is based on counters that measure the execution frequency of code entities (e.g., basic blocks or procedures). As soon as a counter overflows, the corresponding code entity is optimized and the profiling code is removed. <p> Also, the adaptability of the system highly depends on how often cached code images are discarded| which, in the described system, is only the case when the system runs out of memory. The Self-93 system <ref> [HU96] </ref> uses a similar technique to Hansen's system and uses invocation counts to trigger optimizations. However, in contrast to Hansen's system, invocation counts decay exponentially over time in order not to prioritize long-running slow tasks. Although the Self-93 system performs dynamic optimization, it does not perform dynamic re-optimization.
Reference: [Kis96] <author> T. Kistler. </author> <title> "Dynamic Runtime Optimization". </title> <booktitle> In Proceedings of the Joint Modular Languages Conference, JMLC'97, </booktitle> <pages> pp 53-66. </pages> <note> Published as Springer Lecture Notes in Computer Science No. 1204, </note> <month> March </month> <year> 1997. </year> <note> Also published as Technical Report No. 96-54, </note> <institution> Department of Information and Computer Science, University of California, Irvine, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: In such a situation, previously performed optimizations might deteriorate the overall system performance as code optimizations have been tailored towards earlier behavioral patterns. In this case, the application should periodically be re-optimized and reshaped towards the system's new demands <ref> [Kis96] </ref>. Hence, a good algorithm for making optimization decisions not only has to be able to pinpoint the most frequently executed program parts, but also has to be capable of detecting changes in the application's behavior for triggering re-optimizations. <p> Similar to Digital FX!32, however, the system optimizes applications after execution and hence lacks adaptability as well. In contrast to all of the above work, we are currently developing a system that not only dynamically optimizes programs but also continuously monitors the system's behavior using the above-described function <ref> [Kis96, Fra97] </ref>. In case of substantial changes in the user's behavior, applications are dynamically re-optimized in the background which leads to a much more responsive and adaptive system. 5 Acknowledgement Part of this work is funded by the National Science Foundation under grant CCR-97014000.
Reference: [ZWG+97] <author> X. Zhang, Z. Wang, N. Gloy, J. Chen, and M. Smith. </author> <title> "System Support for Automatic Profiling and Optimization". </title> <booktitle> In Proceedings of the 16th ACM Symposium of Operating Systems Principles, </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: Since the translation service and the application never run concurrently, programs can only be optimized towards the average system behavior and cannot adapt to specific user-session patterns. In addition to simple block counts, the Morph <ref> [ZWG+97] </ref> system from Har-vard University also uses profiling data collected "on-line" to direct optimizations toward the most popular parts of the program. Similar to Digital FX!32, however, the system optimizes applications after execution and hence lacks adaptability as well.
References-found: 7

