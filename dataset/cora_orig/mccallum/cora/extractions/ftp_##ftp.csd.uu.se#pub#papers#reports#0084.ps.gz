URL: ftp://ftp.csd.uu.se/pub/papers/reports/0084.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: e-mail: bjornc@csd.uu.se  e-mail: matsc@sics.se  e-mail: Daniel.Diaz@inria.fr  
Title: Entailment of Finite Domain Constraints  
Author: Bjorn Carlson Mats Carlsson Daniel Diaz 
Note: This work was sponsored by ESPRIT Project 7195 (ACCLAIM), and has been performed in close cooperation with the Programming Systems group at SICS and Philippe Codognet at INRIA-Rocquencourt. Also published in Proceedings of the Eleventh International Conference on Logic Programming, MIT Press, 1994.  
Address: Box 311 751 05 Uppsala  Box 1263, S-164 28 KISTA, Sweden  78153 Le Chesnay, France  
Affiliation: Computing Science Department, Uppsala University  Swedish Institute of Computer Science  INRIA-Rocquencourt Domaine de Voluceau  
Abstract: UPMAIL Technical Report No. 84 1 September, 1994 ISSN 1100-0686 Abstract Using a glass-box theory of finite domain constraints, FD, we show how the entailment of user-defined constraints can be expressed by anti-monotone FD constraints. We also provide an algorithm for checking the entailment and consistency of FD constraints. FD is shown to be expressive enough to allow the definition of arithmetical constraints, as well as non-trivial symbolic constraints, that are normally built in to CLP systems. In particular, we use conditional FD constraints, which exploit entailment checking, to define symbolic constraints. Thus, we claim that a glass-box system such as FD is expressive enough to capture the essence of finite domain constraint programming. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Carlson, S. Janson and S. Haridi. </author> <note> Programming in AKL(FD). Forthcoming SICS Research Report, 1994. 14 </note>
Reference-contexts: Constraints that are builtins of a black-box solver, are instead defined by programming primitives of the glass-box <ref> [5, 13, 4, 1] </ref>. Combinators of a glass-box system typically include conjunction, implication and disjunction. <p> Furthermore, the implementation of a glass-box system lifts the complexity from the emulator level to the compiler level, as well as making available traditional compiler optimization techniques. The net result being that the implementations of glass-box systems can be made highly efficient <ref> [3, 13, 1] </ref>. 1 In this paper we study how to use the glass-box system FD [12] to define non-trivial finite domain constraints and to check their entailment. We show that by using conditional reasoning, based on entailment, complex symbolic constraints can be defined in FD. <p> The unary constraints of FD can be used as the target language for compilers of arbitrary finite domain constraints [2], and in fact FD subsumes basically all existing finite domain constraint systems with preserved and sometimes improved efficiency <ref> [1, 3, 4] </ref>. 2.1 The theory FD is based on domain constraints X 2 I, where I is a set of integers described by a finite union of intervals. The set I is the set of possible values of X, and X is said to be constrained to I. <p> ! E i = V * I in dom (B 1 ) : : dom (B k ), where * E i 6= V ! B i = 0, and However, note that this version of element/3 does not exploit the full pruning possible from the denotation of the constraint <ref> [1] </ref>. 3 Entailment Conditions In this section we characterize the entailment of FD constraints by sufficient truth conditions. 3.1 Entailment of indexicals The aim of this section is to show how to generate logical conditions to detect entailment and inconsistency of indexicals. <p> In all other cases the computation records (suspends) the constraint so that when the store is updated the constraint can be rechecked when necessary <ref> [1, 3] </ref>. If c is monotone, X 2 (X S " r S ) is added to the store. Example 9. Again we use disequality as an example. <p> Only when Y is determined the constraint will be decided entailed (see Section 4.3). This scheme has been implemented in the AKL-system, developed at SICS [7], and preliminary results indicate an efficiency comparable with clp (FD), cc (FD), and CHIP <ref> [1] </ref>. 4.2 Generating entailment checking indexicals In this section we show how to use the entailment detection in Section 4 for checking the entailment conditions of Section 3.1. <p> We adapt Table 2 and Table 3 to generate anti-monotone indexicals instead of conditions, and thus we can use the decision table (Table 4) for checking the conditions <ref> [1] </ref>.
Reference: [2] <author> B. Carlson and M. Carlsson. </author> <title> Compiling Linear Integer Constraints. </title> <type> Forthcoming SICS Research Report, </type> <year> 1994. </year>
Reference-contexts: The unary constraints of FD are thought of as propagation rules, i.e. rules for describing node and arc consistency propagation. The unary constraints of FD can be used as the target language for compilers of arbitrary finite domain constraints <ref> [2] </ref>, and in fact FD subsumes basically all existing finite domain constraint systems with preserved and sometimes improved efficiency [1, 3, 4]. 2.1 The theory FD is based on domain constraints X 2 I, where I is a set of integers described by a finite union of intervals.
Reference: [3] <author> D. Diaz and P. Codognet. </author> <title> A Minimal Extension of the WAM for clp(FD). </title> <booktitle> In Proceedings of the 10th International Conference on Logic Programming, </booktitle> <year> 1993. </year>
Reference-contexts: Furthermore, the implementation of a glass-box system lifts the complexity from the emulator level to the compiler level, as well as making available traditional compiler optimization techniques. The net result being that the implementations of glass-box systems can be made highly efficient <ref> [3, 13, 1] </ref>. 1 In this paper we study how to use the glass-box system FD [12] to define non-trivial finite domain constraints and to check their entailment. We show that by using conditional reasoning, based on entailment, complex symbolic constraints can be defined in FD. <p> The unary constraints of FD can be used as the target language for compilers of arbitrary finite domain constraints [2], and in fact FD subsumes basically all existing finite domain constraint systems with preserved and sometimes improved efficiency <ref> [1, 3, 4] </ref>. 2.1 The theory FD is based on domain constraints X 2 I, where I is a set of integers described by a finite union of intervals. The set I is the set of possible values of X, and X is said to be constrained to I. <p> In all other cases the computation records (suspends) the constraint so that when the store is updated the constraint can be rechecked when necessary <ref> [1, 3] </ref>. If c is monotone, X 2 (X S " r S ) is added to the store. Example 9. Again we use disequality as an example.
Reference: [4] <author> D. Diaz and P. Codognet. </author> <title> Compiling Constraint in clp(FD). </title> <type> Technical report, </type> <institution> INRIA-Rocquencourt, </institution> <year> 1993. </year>
Reference-contexts: Constraints that are builtins of a black-box solver, are instead defined by programming primitives of the glass-box <ref> [5, 13, 4, 1] </ref>. Combinators of a glass-box system typically include conjunction, implication and disjunction. <p> The unary constraints of FD can be used as the target language for compilers of arbitrary finite domain constraints [2], and in fact FD subsumes basically all existing finite domain constraint systems with preserved and sometimes improved efficiency <ref> [1, 3, 4] </ref>. 2.1 The theory FD is based on domain constraints X 2 I, where I is a set of integers described by a finite union of intervals. The set I is the set of possible values of X, and X is said to be constrained to I. <p> Obviously, the constraint propagation obtained with this constraint is stronger than the propagation of the formulation using freeze. In <ref> [4] </ref> it is shown that the speedup with respect to the CHIP definition grows with n.
Reference: [5] <author> M. Dincbas, P. van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. </author> <title> The Constraint Logic Programming Language CHIP. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <year> 1988. </year>
Reference-contexts: Constraints that are builtins of a black-box solver, are instead defined by programming primitives of the glass-box <ref> [5, 13, 4, 1] </ref>. Combinators of a glass-box system typically include conjunction, implication and disjunction.
Reference: [6] <author> M. Dincbas, P. van Hentenryck, and H. Simonis. </author> <title> Constraint Satisfaction using constraint logic programming. </title> <booktitle> In Artifical Intelligence, </booktitle> <volume> vol 58, </volume> <pages> 113-159, </pages> <year> 1992. </year>
Reference-contexts: The domain approximation performs stronger propagation than the interval approximation, but the interval version is more efficient to compute. For a careful examination of domain and interval approximations of constraints see elsewhere <ref> [6, 13, 14] </ref>. Note that operationally the constraint propagation implemented by the FD constraints may be weaker than what can be performed by a constraint solver for the n-ary constraint. Example 2.
Reference: [7] <author> S. Janson and S. Haridi. </author> <title> Programming paradigms of the Andorra Kernel Language. </title> <booktitle> In Logic Programming: Proceedings of the 1991 International Symposium, </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Only when Y is determined the constraint will be decided entailed (see Section 4.3). This scheme has been implemented in the AKL-system, developed at SICS <ref> [7] </ref>, and preliminary results indicate an efficiency comparable with clp (FD), cc (FD), and CHIP [1]. 4.2 Generating entailment checking indexicals In this section we show how to use the entailment detection in Section 4 for checking the entailment conditions of Section 3.1.
Reference: [8] <author> M. J. Maher. </author> <title> Logic semantics for a class of committed choice programs. </title> <booktitle> In Logic Programming: Proceedings of the Fourth International Conference, </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: We show that by using conditional reasoning, based on entailment, complex symbolic constraints can be defined in FD. Entailment has previously been recognized as the key to how concurrent and constraint programming can be merged <ref> [8, 10] </ref>, but hence it serves an important function even within a constraint logic programming framework. By exploiting the monotonicity of FD constraints we show that entailment checking can be done purely in terms of anti-monotone FD constraints.
Reference: [9] <editor> W.J. Older and F. Benhamou. </editor> <booktitle> Programming in CLP(BNR). In Position Papers of the First Workshop, </booktitle> <address> PPCP, Newport, Rhode Island, </address> <year> 1993. </year>
Reference-contexts: The original formulation [11] used a freeze on each X i . However, owing to entailment detection it is possible to simply encode the following relation <ref> [9] </ref>: n X (j) i where (j) i is 1 if X i = j and 0 if X i 6= j.
Reference: [10] <author> V. A. Saraswat. </author> <title> Concurrent Constraint Programming, </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: We show that by using conditional reasoning, based on entailment, complex symbolic constraints can be defined in FD. Entailment has previously been recognized as the key to how concurrent and constraint programming can be merged <ref> [8, 10] </ref>, but hence it serves an important function even within a constraint logic programming framework. By exploiting the monotonicity of FD constraints we show that entailment checking can be done purely in terms of anti-monotone FD constraints.
Reference: [11] <author> P. van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Example 4. The magic series problem <ref> [11] </ref> consists in finding a sequence of numbers fX 0 ; : : : ; X n g such that i occurs X i times in the sequence. The original formulation [11] used a freeze on each X i . <p> Example 4. The magic series problem <ref> [11] </ref> consists in finding a sequence of numbers fX 0 ; : : : ; X n g such that i occurs X i times in the sequence. The original formulation [11] used a freeze on each X i . However, owing to entailment detection it is possible to simply encode the following relation [9]: n X (j) i where (j) i is 1 if X i = j and 0 if X i 6= j.
Reference: [12] <author> P. van Hentenryck, V. Saraswat, and Y. Deville. </author> <title> Constraint processing in cc(FD). </title> <type> Unpublished manuscript, </type> <institution> Computer Science Department, Brown University, </institution> <year> 1991. </year>
Reference-contexts: The net result being that the implementations of glass-box systems can be made highly efficient [3, 13, 1]. 1 In this paper we study how to use the glass-box system FD <ref> [12] </ref> to define non-trivial finite domain constraints and to check their entailment. We show that by using conditional reasoning, based on entailment, complex symbolic constraints can be defined in FD. <p> A short summary concludes the paper (Section 5). 2 FD: A Theory of Finite Domain Constraints The constraint system FD <ref> [12] </ref> is a general purpose constraint framework for solving discrete constraint satisfaction problems in a concurrent constraint setting. <p> The expression r is called a range (defined by R in Figure 1), which denotes a partial function from stores to finite unions of intervals over the integers. We will refer to X in r as an indexical in the following <ref> [12] </ref>. The partial function r is evaluated in a store S as follows.
Reference: [13] <author> P. van Hentenryck, V. Saraswat, and Y. Deville. </author> <title> Constraint Logic Programming over Finite Domains: the Design, Implementation, and Applications of cc(FD). </title> <type> Technical report, </type> <institution> Computer Science Department, Brown University, </institution> <year> 1992. </year>
Reference-contexts: Constraints that are builtins of a black-box solver, are instead defined by programming primitives of the glass-box <ref> [5, 13, 4, 1] </ref>. Combinators of a glass-box system typically include conjunction, implication and disjunction. <p> Furthermore, the implementation of a glass-box system lifts the complexity from the emulator level to the compiler level, as well as making available traditional compiler optimization techniques. The net result being that the implementations of glass-box systems can be made highly efficient <ref> [3, 13, 1] </ref>. 1 In this paper we study how to use the glass-box system FD [12] to define non-trivial finite domain constraints and to check their entailment. We show that by using conditional reasoning, based on entailment, complex symbolic constraints can be defined in FD. <p> The domain approximation performs stronger propagation than the interval approximation, but the interval version is more efficient to compute. For a careful examination of domain and interval approximations of constraints see elsewhere <ref> [6, 13, 14] </ref>. Note that operationally the constraint propagation implemented by the FD constraints may be weaker than what can be performed by a constraint solver for the n-ary constraint. Example 2.
Reference: [14] <author> P. van Hentenryck and Y. Deville. </author> <title> Operational Semantics of Constraint Logic Programming over Finite Domains. </title> <booktitle> In Proceedings of the 3rd Int. Symposium on Programming Language Implementation and Logic Programming, </booktitle> <year> 1991. </year> <month> 15 </month>
Reference-contexts: The domain approximation performs stronger propagation than the interval approximation, but the interval version is more efficient to compute. For a careful examination of domain and interval approximations of constraints see elsewhere <ref> [6, 13, 14] </ref>. Note that operationally the constraint propagation implemented by the FD constraints may be weaker than what can be performed by a constraint solver for the n-ary constraint. Example 2.
References-found: 14

