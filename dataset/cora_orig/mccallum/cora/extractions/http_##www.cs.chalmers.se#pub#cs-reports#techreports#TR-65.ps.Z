URL: http://www.cs.chalmers.se/pub/cs-reports/techreports/TR-65.ps.Z
Refering-URL: http://www.cs.chalmers.se/pub/cs-reports/techreports/
Root-URL: 
Title: Programming Methodology Group  Retrieving Library Identifiers via Equational Matching of Types  
Author: Mikael Rittri 
Date: 65 May 1992  
Affiliation: Chalmers University of Technology and University of Goteborg  
Pubnum: Report  
Abstract-found: 0
Intro-found: 1
Reference: [AJ89] <author> L. Augustsson and T. Johnsson. </author> <title> The Chalmers Lazy-ML compiler. </title> <journal> The Computer Journal, </journal> <volume> 32(2), </volume> <year> 1989. </year>
Reference-contexts: The implementation follows the description in Section 4 closely. The major difference is that the disjunction matching systems are never generated explicitly; the representation used is more like AND-OR-trees. My search system is implemented in Standard ML [Rea89], but for my tests, I have used the Lazy ML <ref> [AJ89] </ref> library. The test library contains 185 identifiers, but I preprocessed it to reduce the number of attempted matches. First, library types that are -instances of each other share a single entry. This gave a table of only 103 entries.
Reference: [BDCL90] <author> K. B. Bruce, R. Di Cosmo, and G. Longo. </author> <title> Provable isomorphisms of types. </title> <institution> Research report LIENS-90-14, Ecole Normale Superieure, Paris, </institution> <year> 1990. </year> <note> To appear in Mathematical Structures in Computer Science, 2(2). </note>
Reference-contexts: The sound- and completeness result was stated and proved explicitly for Cartesian closed categories in [Sol83], without reference to Martin. See also <ref> [LADC89, BDCL90, MS90] </ref>. The distributivity axiom and the axioms on 1 may not have as great practical importance as the original three, but they seem worth including to get clean semantics.
Reference: [Bur86] <author> H.-J. Burckert. </author> <title> Some relationships between unification, restricted uni fication, and matching. </title> <editor> In J. H. Siekmann, editor, </editor> <booktitle> 8th Int. Conf. on Automated Deduction, Oxford, U.K., 1986. Volume 230 of Lecture Notes in Comput. </booktitle> <publisher> Sci., Springer-Verlag. </publisher>
Reference-contexts: E-unification can become much harder when free function symbols are allowed. In fact, Burckert and Schmidt-Schau have given an equational theory in which unification is trivially decidable when only interpreted symbols are allowed, but becomes undecidable when a single free constant is allowed <ref> [Bur86] </ref>. Note that the variables in the subject of a matching problem are never instantiated, and therefore behave like free constants.
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In 9th ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1982. </year>
Reference-contexts: The words free and bound are derived from the modern view of polymorphic types, as given in <ref> [DM82] </ref>. In that view, type variables may be bound by quantifiers, so polymorphic types are not just first order terms.
Reference: [FH86] <author> F. Fages and G. Huet. </author> <title> Complete sets of unifiers and matchers in equa tional theories. </title> <journal> Theoretical Comput. Sci., </journal> <volume> 43 </volume> <pages> 189-200, </pages> <year> 1986. </year>
Reference-contexts: It is an open question whether such unifiability is decidable; some partial results have been obtained in [NPS89], see Section 6. 2 Unification/Matching in Equational Theories Unification theory is a young discipline, and notation and definitions vary between different authors. I have picked my notation from several sources, mostly <ref> [HO80, FH86, Tid86, Kir86, Sie89] </ref>. When the definitions vary, which they do only in details, I have picked one that seemed appropriate, though I stay close to [FH86]. This section is sparse in motivations and is not intended as an introduction to the subject. <p> I have picked my notation from several sources, mostly [HO80, FH86, Tid86, Kir86, Sie89]. When the definitions vary, which they do only in details, I have picked one that seemed appropriate, though I stay close to <ref> [FH86] </ref>. This section is sparse in motivations and is not intended as an introduction to the subject. <p> This nice property is lost if we unify in arbitrary equational theories. Often, we have to be satisfied with a set of unifiers, such that at least one of them is more general than an arbitrary unifier. The following definition is taken from <ref> [FH86] </ref>. Let s and t be terms, and let W be a set of variables such that W "(V (s)[V (t)) = ;. <p> Let p and s be terms and let W be a set of variables such that W " V (s) = ;. A set of substitutions is a complete set of E-matchers of p to s away from W <ref> [FH86] </ref> if 1. for all 2 , D () V (p) and I () " W = ; (purity), 2. M E hp; si (correctness), 3. for all t 2 M E hp; si, there is a 2 such that E t [V (p)] (completeness).
Reference: [Gur90] <author> R. Gurevic. </author> <title> Equational theory of positive numbers with exponentiation is not finitely axiomatizable. </title> <journal> Ann. of Pure and Appl. Logic, </journal> <volume> 49(1) </volume> <pages> 1-30, </pages> <year> 1990. </year>
Reference-contexts: It is then reasonable to 1 If addition is also included, the question whether the usual axioms are equationally complete for arithmetic is known as Tarski's high school algebra problem. A. J. Wilkie found a counter-example [Wil81], and R. Gurevic showed recently that no finite axiomatization suffices <ref> [Gur90] </ref>. 3 interpret a query A as asking for all identifiers e in the library for which e : A holds. These are, in fact, the identifiers whose most general types are at least as general as A.
Reference: [Han87] <author> P. Hancock. </author> <title> A type-checker. Chapter 9 of S. </title> <editor> L. Peyton Jones, </editor> <booktitle> The Imple mentation of Functional Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Proof. Follows from the definition of t B b. Given a term b 2 T fi , we can now find a most -general term among the terms t 2 T ff for which t B b. Inspired by <ref> [Han87, Sec. 9.6] </ref>, we will use two functions Take and Split to get hold of "new" variables. The function Take takes a natural number n and an infinite set Y of variables, and returns n distinct variables of Y .
Reference: [Her68] <author> J. </author> <title> Herbrand. Recherches sur la theorie de la demonstration, </title> <type> (thesis, </type> <institution> Univ. de Paris, </institution> <year> 1930). </year> <editor> In Ecrits logiques de Jacques Herbrand. PUF, </editor> <address> Paris, </address> <year> 1968. </year>
Reference-contexts: An E-unification problem is a pair of terms hs; ti for which we seek the set of all their E-unifiers, U E hs; ti. When E = ;, and s and t are ;-unifiable, one can always find a single ;-unifier which is more general than all other ;-unifiers <ref> [Her68, Rob65] </ref>. Such a most general unifier can then represent the set of all unifiers. This nice property is lost if we unify in arbitrary equational theories.
Reference: [HO80] <author> G. Huet and D. C. Oppen. </author> <title> Equations and rewrite rules: A survey. </title> <editor> In R. Book, editor, </editor> <title> Formal Languages: Perspectives and Open Problems. </title> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: It is an open question whether such unifiability is decidable; some partial results have been obtained in [NPS89], see Section 6. 2 Unification/Matching in Equational Theories Unification theory is a young discipline, and notation and definitions vary between different authors. I have picked my notation from several sources, mostly <ref> [HO80, FH86, Tid86, Kir86, Sie89] </ref>. When the definitions vary, which they do only in details, I have picked one that seemed appropriate, though I stay close to [FH86]. This section is sparse in motivations and is not intended as an introduction to the subject.
Reference: [Hul79] <author> J. M. Hullot. </author> <title> Associative commutative pattern matching. </title> <booktitle> In Sixth Int. Joint Conf. on Artificial Intelligence, </booktitle> <address> Tokyo, </address> <year> 1979. </year>
Reference-contexts: x ] y = y ] x; x ] (y ] z) = (x ] y) ] z; 0 ] x = x where `]' is a new binary function symbol, and `0' is a new constant. 11 The base matchers can be found as before, but by using ACU-matching <ref> [Hul79, Sti81] </ref> rather than AU-matching. However, the commutativity means that for a given base matcher, there may be alternative ways to obtain a set of smaller matching problems. <p> In summary, then, there are four important parts of the -matching algorithm. 1. The definition and properties of bases of terms and substitutions. 2. How to find base matchers by ACU-matching. (This will not be described in this paper, though, since the methods of <ref> [Hul79] </ref> or [Sti81] suffice.) 3. How to find a most -general substitution with a given base. We will define a function `Mg' that does this. This function needs a supply Y of fresh variables, so we will provide it as an extra argument. 4. <p> Repeat the analogous procedure for s, getting the irreducible product s 1;# fi fis n;# . By Lemma 4, t 1;# fi fit m;# = AC s 1;# fi fis n;# Then, by the equivalence lemma II.1 of <ref> [Hul79] </ref>, m = n and there is a permutation on f1; : : : ; mg, such that t i;# = AC s (i);# whenever 1 i m: Consider an arbitrary i.
Reference: [Kir86] <editor> C. Kirchner. </editor> <booktitle> Computing unification algorithms. In Symp. on Logic in Computer Science, </booktitle> <address> Cambridge, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: It is an open question whether such unifiability is decidable; some partial results have been obtained in [NPS89], see Section 6. 2 Unification/Matching in Equational Theories Unification theory is a young discipline, and notation and definitions vary between different authors. I have picked my notation from several sources, mostly <ref> [HO80, FH86, Tid86, Kir86, Sie89] </ref>. When the definitions vary, which they do only in details, I have picked one that seemed appropriate, though I stay close to [FH86]. This section is sparse in motivations and is not intended as an introduction to the subject. <p> The set U E (S) of E-unifiers of such a system S consists of those substitutions that unifies all of the pairs, that is, U E (S) = hs;ti2S An E-unification disjunction system <ref> [Kir86] </ref> is a set of E-unification systems. The set U E (D) of E-unifiers of a disjunction system D consist of those that unify 2 Thus, the symbol can be read as "less specific than", following the tradition in unification theory.
Reference: [LADC89] <author> G. Longo, A. Asperti, and R. Di Cosmo. </author> <title> Coherence and valid isomor phism in closed categories. </title> <editor> In D. H. Pitt et al., editors, </editor> <booktitle> Category Theory and Computer Science, Manchester, U.K., 1989. Volume 389 of Lecture Notes in Comput. </booktitle> <publisher> Sci., Springer-Verlag. </publisher>
Reference-contexts: This paper describes an algorithm and an implementation based on similar work by Bernard Lang [Lan78]. Although my own motivation is library search, others have suggested applications for program transformation [NPS89] and type-checking up to equivalence <ref> [LADC89] </ref>. In this introduction, I will first summarize the reasons to use an equivalence relation during library search, and then I will explain why more general types should be found. In Section 2, I review the basics of unification theory. <p> The sound- and completeness result was stated and proved explicitly for Cartesian closed categories in [Sol83], without reference to Martin. See also <ref> [LADC89, BDCL90, MS90] </ref>. The distributivity axiom and the axioms on 1 may not have as great practical importance as the original three, but they seem worth including to get clean semantics.
Reference: [Lan78] <author> B. Lang. </author> <title> Matching with multiplication and exponentiation, </title> <month> May </month> <year> 1978. </year> <title> Author's current address: </title> <institution> INRIA, Domaine de Voluceau, Rocquencourt, </institution> <address> B.P. 105, F-78153 Le Chesnay Cedex, France. E-mail: lang@inria.fr </address>
Reference-contexts: To combine the two ideas, we need to do pattern matching modulo the equivalence relation. This paper describes an algorithm and an implementation based on similar work by Bernard Lang <ref> [Lan78] </ref>. Although my own motivation is library search, others have suggested applications for program transformation [NPS89] and type-checking up to equivalence [LADC89]. <p> E-matcher will also be an E-matcher. 3 Comparison with Previous Work Bernard Lang at INRIA, France, has given a matching algorithm for a theory very similar to ; the only difference is that fi is not commutative, so one has to add the axiom x fi 1 = x explicitly <ref> [Lan78] </ref>. I will modify his algorithm to handle commutativity, too. In Section 3.1, I describe Lang's algorithm, and in Section 3.2, I will show how my problem is different from Lang's and give an overview of my algorithm. <p> with 0 j ff i , we have that t i;j = t i;j;# = AC s (i);j;# = s (i);j , and since = AC = , it follows that t i;j = s (i);j , and we are finished. 4.2 Bases of Terms and Substitutions In analogy with <ref> [Lan78] </ref>, we define a base of a term in T ff . Intuitively, a base of term t is the bag of the symbols H (q i ) in a regular form of t (as written in definition 2). <p> X " D (!), we have by definition that Mg (!; Y )j X = fx 1 7! Mg (!(x 1 ); Y 1 ); : : : ; x m 7! Mg (!(x m ); Y m )g 5 Note that Mg (!; Y ) corresponds to !;W in <ref> [Lan78] </ref>, provided that Y is the complement of W . 20 where the Y i 's are subsets of Y and pairwise disjoint. <p> If we only care about matchability, we can of course interrupt the generation of top level matchers as soon as one is found. We will, like <ref> [Lan78] </ref>, assume that V (s) = ;. Except for the main procedure, the algorithm consists of three mutually recursive procedures for pairs, systems, and disjunction systems, respectively. We give the whole algorithm first, then a proof of correctness.
Reference: [Mar72] <author> C. F. Martin. </author> <title> Axiomatic bases for equational theories of natural numbers. </title> <journal> Notices of the Am. Math. Soc., </journal> <note> 19(7):A-778-779, Abstract 698-E1, </note> <year> 1972. </year>
Reference: [Mar73] <author> C. F. Martin. </author> <title> Equational Theories of Natural Numbers and Transfinite Ordinals. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <address> CA 94720, USA, </address> <year> 1973. </year> <note> The relevant results appear also in [Mar72]. </note>
Reference-contexts: Charles Martin has shown <ref> [Mar73] </ref> that they are also complete for this arithmetic interpretation, when expressions are built only from 1, fi, ) and variables. 1 The corresponding completeness result for Cartesian closed categories is a direct corollary, since the positive numbers form one such category.
Reference: [Mil78] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> J. of Com put. and System Sci., </journal> <volume> 17(3) </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Section 6 describes some related work. To understand the application, the reader should be familiar with functional programming (see e.g. [Rea89]) and the usual Hindley-Milner type system <ref> [Mil78, Rea89] </ref>. The main points are that we see types as first order terms, as in [Mil78], and that though a function (or any value) may have many types, one of them can be instantiated to all the others. <p> Section 6 describes some related work. To understand the application, the reader should be familiar with functional programming (see e.g. [Rea89]) and the usual Hindley-Milner type system [Mil78, Rea89]. The main points are that we see types as first order terms, as in <ref> [Mil78] </ref>, and that though a function (or any value) may have many types, one of them can be instantiated to all the others. <p> Theoretically, we could look up the semantics of polymorphic types. According to <ref> [Mil78] </ref>, the notation e : A, where A is a type, means that e can be assigned any ground (i.e. variable-free) type that is an instance of A. <p> The words free and bound are derived from the modern view of polymorphic types, as given in [DM82]. In that view, type variables may be bound by quantifiers, so polymorphic types are not just first order terms. Already in <ref> [Mil78] </ref>, a distinction was made between "generic" and "non-generic" variables, but the difference was not noted in the syntax for types, and as a result, the algorithm for type derivation became harder to understand. <p> The set U E (D) of E-unifiers of a disjunction system D consist of those that unify 2 Thus, the symbol can be read as "less specific than", following the tradition in unification theory. Alas, people who write about polymorphic types <ref> [Mil78, RT89] </ref> use the opposite convention and take or similar symbols to mean "less general than". 8 at least one of its component systems, that is, U E (D) = S2D The notion of complete sets of unifiers is extended in the natural way to unification systems and unification disjunction systems.
Reference: [MS90] <author> L. Meertens and A. Siebes. </author> <title> Universal type isomorphisms in Cartesian closed categories | preliminary version, 1990. </title> <publisher> Centrum voor Wiskunde en Informatica, </publisher> <address> Amsterdam, the Netherlands. E-mail: </address> <publisher> lambert@cwi.nl and arno@cwi.nl </publisher>
Reference-contexts: The sound- and completeness result was stated and proved explicitly for Cartesian closed categories in [Sol83], without reference to Martin. See also <ref> [LADC89, BDCL90, MS90] </ref>. The distributivity axiom and the axioms on 1 may not have as great practical importance as the original three, but they seem worth including to get clean semantics.
Reference: [Nip90] <author> T. Nipkow. </author> <title> A critical pair lemma for higher-order rewrite systems and its application to fl . In G. </title> <editor> Huet and G. Plotkin, editors, </editor> <booktitle> First Annual Workshop on Logical Frameworks, Antibes, </booktitle> <address> France, </address> <year> 1990, </year> <pages> pages 361-376. </pages>
Reference-contexts: An implementation of a search system, which retrieves identifiers whose types are isomorphic to a given query, is described in [Rit89]. <ref> [Nip90] </ref> presents a language in which expressions of isomorphic types are identified, except that the commutativity of fi is not used. 1.2 Retrieving More General Types There are both theoretical and practical reasons to accept identifiers whose types are more general than the query.
Reference: [NPS89] <author> P. Narendran, F. Pfenning, and R. Statman. </author> <title> On the unification problem for Cartesian closed categories, 1989. Addresses: </title> <type> P. </type> <institution> Naren-dran, State Univ. of New York at Albany, USA. F. Pfenning 29 and R. Statman, Carnegie Mellon Univ., Pittsburgh, USA. E-mail: dran@cssun.albany.edu , fp@cs.cmu.edu , statman@c.cs.cmu.edu </institution>
Reference-contexts: To combine the two ideas, we need to do pattern matching modulo the equivalence relation. This paper describes an algorithm and an implementation based on similar work by Bernard Lang [Lan78]. Although my own motivation is library search, others have suggested applications for program transformation <ref> [NPS89] </ref> and type-checking up to equivalence [LADC89]. In this introduction, I will first summarize the reasons to use an equivalence relation during library search, and then I will explain why more general types should be found. In Section 2, I review the basics of unification theory. <p> To handle free type variables, we would need to unify modulo isomorphism, which means to test whether there is a substitution of types for type variables that makes two given types isomorphic. It is an open question whether such unifiability is decidable; some partial results have been obtained in <ref> [NPS89] </ref>, see Section 6. 2 Unification/Matching in Equational Theories Unification theory is a young discipline, and notation and definitions vary between different authors. I have picked my notation from several sources, mostly [HO80, FH86, Tid86, Kir86, Sie89]. <p> So when we have found a base matcher, the remaining work is to solve a disjunction system, rather than an ordinary system, which means that -matching is slower than L-matching. In fact, -matching is NP-complete <ref> [NPS89] </ref>, but practical experience shows that it is feasible for library search, see Section 5. Example 4. A user seeks the function foldr of Example 2, but does not realize that the operator can be asymmetrical. <p> Thus, it should be worthwhile to look for some heuristics for ordering subproblems. 6 Unification in (Subsets of ) Lang's technique with bases and exponents of terms is probably a good framework for -unification as well as -matching; the problem is to get termination. -unification has been studied in <ref> [NPS89] </ref>, where it is reported as an open question whether such unifiability is decidable, but it is shown (among other things) that * -unifiability is at least as hard as the reachability problem for Petri Nets. * Let 0 be the equational theory presented by the axioms for except distribu tivity. <p> The results in <ref> [NPS89] </ref> are only stated for unification in the presence of free constants. It does not follow immediately that an algorithm for 0 -unification can be extended to free function symbols of any arity, but the techniques in [SS89] might apply. The method in [NPS89] also yields an algorithm that finds finite <p> The results in <ref> [NPS89] </ref> are only stated for unification in the presence of free constants. It does not follow immediately that an algorithm for 0 -unification can be extended to free function symbols of any arity, but the techniques in [SS89] might apply. The method in [NPS89] also yields an algorithm that finds finite complete sets of unifiers in the equational theory presented by just AC and currying. <p> An implementation of a library search system shows that satisfactory speed can be achieved. I see two ways to continue. * The current implementation can be made faster and user-friendlier. * One should investigate whether an algorithm for 0 -unification, as outlined in <ref> [NPS89] </ref>, can be made efficient enough for library search. Such an algorithm could handle free type variables in queries, as sketched in Section 1.3.
Reference: [PB85] <author> P. W. Purdom, Jr. and C. A. Brown. </author> <title> Fast many-to-one matching algo rithms. </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Rewriting Techniques and Applications, Dijon, France, 1985. Volume 202 of Lecture Notes in Comput. </booktitle> <publisher> Sci., Springer-Verlag. </publisher>
Reference-contexts: This gave 12 subtables, and it reduced the number of entries that must be checked to a maximum of 61 and a minimum of 16, depending on the query. (Related ideas can be found in <ref> [PB85] </ref>, where a technique for many-to-one ;- or AC-matching is given.) Some examples of library search are given in Table 1. As can be seen, some unwanted functions are usually retrieved, but not so many as to swamp the interesting findings.
Reference: [PS81] <author> G. E. Peterson and M. E. Stickel. </author> <title> Complete sets of reductions for some equational theories. </title> <journal> J. of the Assoc. for Comput. Mach., </journal> <volume> 28(2) </volume> <pages> 233-264, </pages> <month> April </month> <year> 1981. </year>
Reference-contexts: We want to show both that every term has a regular form, and that regular forms are unique up to rearrangements of factors. These statements are given as Theorems 3 and 5 below. To deal with them, we use the techniques of Peterson and Stickel <ref> [PS81] </ref>, who provide means to rewrite modulo an associative-commutative theory. We single out the associative and commutative axioms of into a subtheory AC, and direct the other axioms into a rewriting system R. <p> R;AC = (= AC ffi . R ffi = AC ) (cf. <ref> [PS81, p. 244] </ref>). We say that a term t is irreducible, if there is no term s such that t . R;AC s. To show that . R;AC is well-founded, i.e. that there are no infinite sequences t 0 . R;AC t 1 . R;AC t 2 . <p> R;AC ) fl t # , and s (. R;AC ) fl s # , where t # and s # are irreducible, then t # = AC s # . In Peterson's and Stickel's terminology <ref> [PS81] </ref>, the lemma states that R is AC-complete. To prove it, one can use their theorem 9.3, which says that it is enough to show that R is AC-compatible, and that for every critical pair for R and AC, the components of the pair reduces to AC-equal terms. <p> To prove it, one can use their theorem 9.3, which says that it is enough to show that R is AC-compatible, and that for every critical pair for R and AC, the components of the pair reduces to AC-equal terms. Compatibility is a somewhat technical property <ref> [PS81, def. 9.1] </ref>, but Peterson and Stickel provide a simple method to add extra rewrite rules to a rewrite system, to make it AC-compatible [op. cit., theorem 10.5]. By using this method, we find that R e = R [ (y fi (1fix) . y fix) is AC-compatible.
Reference: [Rea89] <author> C. Reade. </author> <title> Elements of Functional Programming. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Section 5 describes my implementation of a library search system and gives some examples of use; most of this section can be understood without reading Sections 2-4. Section 6 describes some related work. To understand the application, the reader should be familiar with functional programming (see e.g. <ref> [Rea89] </ref>) and the usual Hindley-Milner type system [Mil78, Rea89]. The main points are that we see types as first order terms, as in [Mil78], and that though a function (or any value) may have many types, one of them can be instantiated to all the others. <p> Section 6 describes some related work. To understand the application, the reader should be familiar with functional programming (see e.g. [Rea89]) and the usual Hindley-Milner type system <ref> [Mil78, Rea89] </ref>. The main points are that we see types as first order terms, as in [Mil78], and that though a function (or any value) may have many types, one of them can be instantiated to all the others. <p> A description of how to build parsers with operators like h&i can be found in <ref> [Rea89, Sec. 6.6] </ref>, where the type given for h&i is the most specific one above. (I have simplified the h&i of [Rea89] a little by ignoring how to handle a failure to parse, but this does not change the main idea.) 1.3 Should We Retrieve Unifiable Types? Colin Runciman and Ian <p> A description of how to build parsers with operators like h&i can be found in [Rea89, Sec. 6.6], where the type given for h&i is the most specific one above. (I have simplified the h&i of <ref> [Rea89] </ref> a little by ignoring how to handle a failure to parse, but this does not change the main idea.) 1.3 Should We Retrieve Unifiable Types? Colin Runciman and Ian Toyn at the University of York have argued [RT89] that identifiers whose types are unifiable with the query should be retrieved. <p> The implementation follows the description in Section 4 closely. The major difference is that the disjunction matching systems are never generated explicitly; the representation used is more like AND-OR-trees. My search system is implemented in Standard ML <ref> [Rea89] </ref>, but for my tests, I have used the Lazy ML [AJ89] library. The test library contains 185 identifiers, but I preprocessed it to reduce the number of attempted matches. First, library types that are -instances of each other share a single entry.
Reference: [Rit89] <author> M. Rittri. </author> <title> Using types as search keys in function libraries. </title> <journal> J. of Func tional Programming, </journal> <volume> 1(1) </volume> <pages> 71-89, </pages> <year> 1991. </year> <note> Earlier version in Funct. </note> <institution> Prog. Lang. and Comput. Arch., </institution> <address> London, </address> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction In an earlier paper <ref> [Rit89] </ref>, I have argued that types are good search keys in functional program libraries, if one identifies types by a particular equivalence relation. I argue in this paper that one may also want to retrieve identifiers of more general types than the query type. <p> To state some kind of completeness result, we need clear semantics for the equivalence relation. In <ref> [Rit89] </ref>, I proposed that types should be seen as equal whenever bijections between them (like curry/uncurry) exist in typed fi-calculus with surjective pairing. <p> An implementation of a search system, which retrieves identifiers whose types are isomorphic to a given query, is described in <ref> [Rit89] </ref>. [Nip90] presents a language in which expressions of isomorphic types are identified, except that the commutativity of fi is not used. 1.2 Retrieving More General Types There are both theoretical and practical reasons to accept identifiers whose types are more general than the query. <p> The authors' motivation is that query types can (or should) be derived automatically from contexts of use, specification laws, etc., which can give queries that are more general than the type of the sought function. 5 In <ref> [Rit89] </ref>, it was proposed that two kinds of type variables should be allowed in queries. One kind, bound ones, may not be instantiated and express that the sought function must have a polymorphic type. <p> Therefore, cMpair always terminates with a finite complete set of matchers. 24 5 Practical Experience of Library Search In 1988, I implemented a search system that retrieved library identifiers of types -equal to a given query <ref> [Rit89] </ref>. The speed of the system was satisfactory, but the examples in Section 1.2 convinced me that -equality was not always enough in a programming language with polymorphic types. I have now implemented a search system that retrieves library identifiers of types more -general than a given query.
Reference: [Rob65] <author> J. A. Robinson. </author> <title> A machine oriented logic based on the resolution prin ciple. </title> <journal> J. of the Assoc. for Comput. Mach., </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: An E-unification problem is a pair of terms hs; ti for which we seek the set of all their E-unifiers, U E hs; ti. When E = ;, and s and t are ;-unifiable, one can always find a single ;-unifier which is more general than all other ;-unifiers <ref> [Her68, Rob65] </ref>. Such a most general unifier can then represent the set of all unifiers. This nice property is lost if we unify in arbitrary equational theories.
Reference: [RT89] <author> C. Runciman and I. Toyn. </author> <title> Retrieving reusable software components by polymorphic type. </title> <journal> J. of Functional Programming, </journal> <volume> 1(2) </volume> <pages> 191-211, </pages> <year> 1991. </year> <note> Earlier version in Funct. </note> <institution> Prog. Lang. and Comput. Arch., </institution> <address> London, </address> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: is the most specific one above. (I have simplified the h&i of [Rea89] a little by ignoring how to handle a failure to parse, but this does not change the main idea.) 1.3 Should We Retrieve Unifiable Types? Colin Runciman and Ian Toyn at the University of York have argued <ref> [RT89] </ref> that identifiers whose types are unifiable with the query should be retrieved. <p> The set U E (D) of E-unifiers of a disjunction system D consist of those that unify 2 Thus, the symbol can be read as "less specific than", following the tradition in unification theory. Alas, people who write about polymorphic types <ref> [Mil78, RT89] </ref> use the opposite convention and take or similar symbols to mean "less general than". 8 at least one of its component systems, that is, U E (D) = S2D The notion of complete sets of unifiers is extended in the natural way to unification systems and unification disjunction systems.
Reference: [Sie89] <author> J. H. Siekmann. </author> <title> Unification theory. </title> <journal> J. of Symbolic Computation, </journal> <volume> 7:207 274, </volume> <year> 1989. </year>
Reference-contexts: It is an open question whether such unifiability is decidable; some partial results have been obtained in [NPS89], see Section 6. 2 Unification/Matching in Equational Theories Unification theory is a young discipline, and notation and definitions vary between different authors. I have picked my notation from several sources, mostly <ref> [HO80, FH86, Tid86, Kir86, Sie89] </ref>. When the definitions vary, which they do only in details, I have picked one that seemed appropriate, though I stay close to [FH86]. This section is sparse in motivations and is not intended as an introduction to the subject. <p> This section is sparse in motivations and is not intended as an introduction to the subject. I have found the introductory parts of [Tid86] readable for a beginner, and <ref> [Sie89] </ref> is a survey article that contains an extensive bibliography. 6 Let F be a set of function symbols, and let V be a countably infinite set of variables. We assume that F " V = ;.
Reference: [Sol83] <author> S. V. Solov'ev. </author> <title> The category of finite sets and Cartesian closed categories. </title> <journal> J. of Soviet Math., </journal> <volume> 22(3) </volume> <pages> 1387-1400, </pages> <year> 1983. </year> <note> This is an AMS translation of the Russian original in Zapiski Nauchnykh Seminarov Leningradskogo Otdeleniya Matematicheskogo Instituta im. </note> <editor> V. A. Steklova AN SSSR, </editor> <volume> Vol. 105, </volume> <year> 1981, </year> <pages> pp. 174-194. </pages>
Reference-contexts: The sound- and completeness result was stated and proved explicitly for Cartesian closed categories in <ref> [Sol83] </ref>, without reference to Martin. See also [LADC89, BDCL90, MS90]. The distributivity axiom and the axioms on 1 may not have as great practical importance as the original three, but they seem worth including to get clean semantics.
Reference: [SS89] <author> M. Schmidt-Schau. </author> <title> Unification in a combination of arbitrary disjoint equational theories. </title> <journal> J. of Symbolic Computation, </journal> <volume> 8 </volume> <pages> 51-99, </pages> <year> 1989. </year>
Reference-contexts: The results in [NPS89] are only stated for unification in the presence of free constants. It does not follow immediately that an algorithm for 0 -unification can be extended to free function symbols of any arity, but the techniques in <ref> [SS89] </ref> might apply. The method in [NPS89] also yields an algorithm that finds finite complete sets of unifiers in the equational theory presented by just AC and currying.
Reference: [Sti81] <author> M. E. Stickel. </author> <title> A unification algorithm for associative-commutative func tions. </title> <journal> J. of the Assoc. for Comput. Mach., </journal> <volume> 28(3) </volume> <pages> 423-434, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: x ] y = y ] x; x ] (y ] z) = (x ] y) ] z; 0 ] x = x where `]' is a new binary function symbol, and `0' is a new constant. 11 The base matchers can be found as before, but by using ACU-matching <ref> [Hul79, Sti81] </ref> rather than AU-matching. However, the commutativity means that for a given base matcher, there may be alternative ways to obtain a set of smaller matching problems. <p> In summary, then, there are four important parts of the -matching algorithm. 1. The definition and properties of bases of terms and substitutions. 2. How to find base matchers by ACU-matching. (This will not be described in this paper, though, since the methods of [Hul79] or <ref> [Sti81] </ref> suffice.) 3. How to find a most -general substitution with a given base. We will define a function `Mg' that does this. This function needs a supply Y of fresh variables, so we will provide it as an extra argument. 4. <p> Choose a base b p of p and a base b s of s. 2. Let be a finite complete set of ACU-matchers of b p to b s away from V , such a set can be found by the method of <ref> [Sti81] </ref>. 3. Let Y 1 ; Y 2 = Split (2; Y ). 4. Let = fMg (!; Y 1 ) j ! 2 g, and for each 2 , let 0 = cMd (Dh (p); si; Y 2 ). 5.
Reference: [Tid86] <author> E. Tiden. </author> <title> First-Order Unification in Combinations of Equational The ories. </title> <type> PhD thesis, </type> <institution> Dept. of Num. Anal. and Comput. Sci., The Royal Inst. of Tech., Stockholm, Sweden, </institution> <year> 1986. </year>
Reference-contexts: It is an open question whether such unifiability is decidable; some partial results have been obtained in [NPS89], see Section 6. 2 Unification/Matching in Equational Theories Unification theory is a young discipline, and notation and definitions vary between different authors. I have picked my notation from several sources, mostly <ref> [HO80, FH86, Tid86, Kir86, Sie89] </ref>. When the definitions vary, which they do only in details, I have picked one that seemed appropriate, though I stay close to [FH86]. This section is sparse in motivations and is not intended as an introduction to the subject. <p> When the definitions vary, which they do only in details, I have picked one that seemed appropriate, though I stay close to [FH86]. This section is sparse in motivations and is not intended as an introduction to the subject. I have found the introductory parts of <ref> [Tid86] </ref> readable for a beginner, and [Sie89] is a survey article that contains an extensive bibliography. 6 Let F be a set of function symbols, and let V be a countably infinite set of variables. We assume that F " V = ;. <p> The (partial) correctness of cMp can be shown from the one of cMd and from Theorems 16 and 18. It is obvious that the functions cMpair and cMd preserve correctness, and the technique used in cMs is the usual one to solve unification or matching systems, see e.g. <ref> [Tid86, Appendix A, Lemma 4.4 and Figure 2] </ref>. The termination of our algorithm can be shown by using a well-founded relation on subjects. <p> Such an algorithm can be extended to free function symbols, since the theory is regular (each axiom has the same set of variables on its left and right hand side) and collapse-free (no axiom equates a variable with a non-variable term), see e.g. <ref> [Tid86] </ref>. 7 Summary and Conclusion I have argued that when function libraries are searched by means of type, one would like to retrieve functions of types at least as general as the query, modulo canonical 27 CCC-isomorphism.
Reference: [Tur85] <author> D. A. Turner. Miranda: </author> <title> A non-strict functional language with polymor phic types. </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, Nancy, France, 1985. Volume 201 of Lecture Notes in Comput. Sci., </booktitle> <pages> pages 1-16, </pages> <publisher> Springer-Verlag. </publisher> <pages> 30 </pages>
Reference-contexts: For example the type deduced by the system for foldr is (x ) y ) y) ) y ) List (x) ) y; which reveals that the operator supplied to foldr can be unsymmetrical, which is something that most people miss when they are shown its definition." <ref> [Tur85, p. 5] </ref> Example 3. Let a parsing function take a list of lexical tokens. If an initial segment of the list can be parsed as a value a, then the parsing function returns a and the rest of the list.
Reference: [Wil81] <author> A. J. Wilkie. </author> <title> On exponentiation | a solution to Tarski's high school al gebra problem, 1981. Author's current address: </title> <journal> Mathematical Institute, </journal> <pages> 24-29, </pages> <address> St. Giles, Oxford OX1 3LB, U.K. </address> <month> 31 </month>
Reference-contexts: It is then reasonable to 1 If addition is also included, the question whether the usual axioms are equationally complete for arithmetic is known as Tarski's high school algebra problem. A. J. Wilkie found a counter-example <ref> [Wil81] </ref>, and R. Gurevic showed recently that no finite axiomatization suffices [Gur90]. 3 interpret a query A as asking for all identifiers e in the library for which e : A holds. These are, in fact, the identifiers whose most general types are at least as general as A.
References-found: 32

