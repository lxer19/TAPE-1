URL: http://www.ai.mit.edu/people/dam/jacm1.ps
Refering-URL: http://www.ai.mit.edu/people/dam/jacm1.html
Root-URL: 
Email: DAM@ai.mit.edu  
Title: Taxonomic Syntax for First Order Inference  
Author: DAVID MCALLESTER and ROBERT GIVAN 
Keyword: Categories and Subject Descriptors: F.4.1 [Mathematical Logic and Formal Languages]: Mathematical logic computational logic, mechanical theorem proving; I.2.3 [Artificial Intelligence]: Deduction and Theorem Proving deduction General Terms: Deduction, Algorithms Additional Keywords and Phrases: Proof Theory, Machine Inference, Theorem Proving, Automated Reasoning, Polynomial Time Algorithms, Inference Rules, Proof Systems, Mechanical Verification.  
Note: This research was supported in part by National Science Foundation Grant IRI-8819624 and in part by the Advanced Research Projects Agency of the Department of Defense under Office of Naval Research contract N00014-85-K-0124 and N00014-89-J-3202. Author's Address:  
Address: Cambridge Massachusetts  545 Technology Square, Cambridge Mass, 02139,  
Affiliation: Massachusetts Institute of Technology,  MIT Artificial Intelligence Laboratory,  
Abstract: We identify a new polynomial time decidable fragment of first order logic and present a general method for using polynomial time inference procedures in knowledge representation systems. Our results indicate that a non-standard "taxonomic" syntax is essential in constructing natural and powerful polynomial time inference procedures. The central role of taxonomic syntax in our polynomial time inference procedures provides technical support for the often expressed intuition that knowledge is better represented in terms of taxonomic relationships than classical first order formulas. To use our procedures in a knowledge representation system we define a "Socratic proof system" which is complete for first order inference and which can be used as a semi-automated interface to a first order knowledge base. This paper appeared in JACM, vol. 40, no. 2, April 1993. A postscript electronic source for this paper can be found in ftp.ai.mit.edu:/pub/dam/jacm1.ps. A bibtex reference can be found in internet file ftp.ai.mit.edu:/pub/dam/dam.bib. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> John Bell and Moshe Machover. </author> <title> A Course in Mathematical Logic. </title> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: This proof is based on a standard Herbrand construction analogous to similar well known constructions for other first order inference systems <ref> [1] </ref>. Consider a set of formulas and a particular formula such that j= , i.e., every model of is a model of . We must show that in this case there exists a Socratic derivation of the sequent ` .
Reference: [2] <author> R. S. Boyer Bledsoe, W. W. and W. H. Henneman. </author> <title> Computer proofs of limit theorems. </title> <journal> Artificial Intelligence, </journal> <volume> 3 </volume> <pages> 27-60, </pages> <year> 1972. </year>
Reference-contexts: One way of constructing a Socratic system is to simply place a limit on the amount of time allotted for theorem proving in checking individual steps. This has been done for systems based on resolution theorem proving <ref> [2] </ref>. However, many researchers are uncomfortable with the 2 lack of any natural characterization of exactly when an individual step in these Socratic proofs is acceptable. Term rewriting systems form another class of Socratic systems with a more natural definition of an acceptable proof step.
Reference: [3] <author> Robert S. Boyer and J Struther Moore. </author> <title> A Computational Logic. </title> <booktitle> ACM Monograph Series. </booktitle> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: Term rewriting systems form another class of Socratic systems with a more natural definition of an acceptable proof step. There currently exists a variety of man-machine interactive systems that use term rewriting combined with various methods of performing mathematical induction <ref> [3] </ref>, [10], [11]. The theorem proving mechanisms employed in these systems are incomplete and often terminate with failure.
Reference: [4] <author> Ronald Brachman and James Schmolze. </author> <title> An overview of the kl-one knowledge representation system. </title> <journal> Computational Intelligence, </journal> <volume> 9(2) </volume> <pages> 171-216, </pages> <year> 1985. </year>
Reference-contexts: Non-standard tractable fragments of logic have been identified in the context of a certain family of knowledge representation languages called frame description languages, or FDLs <ref> [4] </ref> [16]. Although an FDL is a nonstandard syntax, one can still identify atomic formulas, literals, Boolean combinations and quantified formulas. Earlier work on FDLs has focused primarily on the problem of determining the validity of individual atomic formulas. <p> A third is recursive definitions. Recursive definitions are perhaps best modeled using the -calculus [18]. 2 In classical syntax, the only valid atomic formulas are equations of the form t = t. 4 <ref> [4] </ref>. If a given query is expressed as a formula in the tractable fragment of logic, then a polynomial decision procedure can be used to determine if the query formula follows from the tractable component of the data base. <p> Our taxonomic syntax for first order logic is related to a large family of knowledge representation languages known as frame description languages (FDLs) <ref> [4] </ref>, [16], [21], [7].
Reference: [5] <author> J. M. Crawford and Benjamin Kuipers. </author> <title> Towards a theory of access-limited logic for knowledge representation. </title> <booktitle> In First International Conference on Principles of Knowledge PUBLISHER = Morgan Kaufmann Publishers, Representation and Reasoning, </booktitle> <pages> pages 67-78, </pages> <year> 1989. </year>
Reference-contexts: Unfortunately, many potential applications of automated reasoning have suffered from its apparent computational intractability. The most successful automated reasoning systems have been based on man-machine interaction. Following <ref> [5] </ref>, we formalize man-machine interactive systems as Socratic proof systems. A formal Socratic proof is a series of steps, analogous to the questions used in the Socratic method of teaching, but where a mechanical procedure is used to determine the "acceptability" of individual steps.
Reference: [6] <author> Martin Davis. </author> <title> Obvious logical inferences. </title> <booktitle> In Proceedings of AAAI-81, </booktitle> <pages> pages 530-531. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1981. </year>
Reference-contexts: Some authors have proposed decision procedures that require more than polynomial time, such as the decision procedure for propositional dynamic logic, or the decision procedure for ground predicate calculus [20], <ref> [6] </ref>. Others have emphasized polynomial time procedures [17]. Polynomial time procedures are clearly desirable if one wants the acceptability of Socratic proofs to be quickly checkable. Some research on polynomial time inference procedures has emphasized computationally tractable fragments of first order logic.
Reference: [7] <author> Francesco Donini, Maurizio Lenzerini, Daniele Nardi, and Werner Nutt. </author> <title> The complexity of concept languages. </title> <booktitle> In Proceedings of KR91, </booktitle> <pages> pages 151-162. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Our taxonomic syntax for first order logic is related to a large family of knowledge representation languages known as frame description languages (FDLs) [4], [16], [21], <ref> [7] </ref>. <p> There is no simple relationship between the expressive power of quantifier-free taxonomic syntax as defined here and the FDLs that have been discussed in the literature. For example, the class expression 8R:C as defined in <ref> [7] </ref> cannot be expressed in the quantifier-free fragment of our taxonomic syntax. Conversely, the class expression R (C W ) of our taxonomic syntax cannot be expressed in any of the languages discussed in [7]. <p> For example, the class expression 8R:C as defined in <ref> [7] </ref> cannot be expressed in the quantifier-free fragment of our taxonomic syntax. Conversely, the class expression R (C W ) of our taxonomic syntax cannot be expressed in any of the languages discussed in [7]. For a given FDL one can define at least three decision problems of increasing difficulty which we will call the atomic formula validity problem, the atomic formula entailment problem, and the literal conjunction satisfi-ability problem.
Reference: [8] <author> Peter J. Downey, Ravi Sethi, and Robert E. Tarjan. </author> <title> Variations on the common subexpression problem. </title> <journal> JACM, </journal> <volume> 27(4) </volume> <pages> 758-771, </pages> <month> October </month> <year> 1980. </year>
Reference-contexts: The difficult part of this satisfiability problem is computing all substitutional consequences of equality. A polynomial time decision procedure based on congruence closure was first given by Kozen [13]. Kozen's congruence closure procedure was followed by a series of applications and more efficient implementations [17] <ref> [8] </ref>. It is also possible to combine the decision procedure for Horn clauses with the decision procedure for ground literals resulting in an efficient procedure for deciding the satisfiability of a set of 3 ground Horn clauses in first order logic with equality. <p> The significance of this extension lies in the significantly greater expressive power of taxonomic ground literals. The decision procedure for the classical ground literal satisfiability problem is based on congruence closure for reasoning about equality [13], <ref> [8] </ref>, [17]. Our decision procedure for taxonomic syntax can be viewed as a (non-trivial) adaptation of congruence closure. The congruence closure procedure can be viewed as an implementation of the four basic inference rules for equality | reflexivity, transitivity, symmetry, and substitutivity (congruence).
Reference: [9] <author> William Downing and Jean H. Gallier. </author> <title> Linear time algorithms for testing the satisfiability of propositional horn formulae. </title> <journal> Journal of Logic Programming, </journal> <volume> 1(3) </volume> <pages> 267-284, </pages> <year> 1984. </year> <month> 56 </month>
Reference-contexts: Some research on polynomial time inference procedures has emphasized computationally tractable fragments of first order logic. For example, it is not difficult to give a linear time procedure for determining the satisfiability of a set of propositional Horn clauses <ref> [9] </ref>. A more complex example involves deciding the satisfiability of a set of ground literals in first order logic with equality. The difficult part of this satisfiability problem is computing all substitutional consequences of equality. A polynomial time decision procedure based on congruence closure was first given by Kozen [13].
Reference: [10] <author> G. Sivikamur Kapur, D. and H. Zhang. Rrl: </author> <title> A rewrite rule laboratory. </title> <booktitle> In 8th CADE. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Term rewriting systems form another class of Socratic systems with a more natural definition of an acceptable proof step. There currently exists a variety of man-machine interactive systems that use term rewriting combined with various methods of performing mathematical induction [3], <ref> [10] </ref>, [11]. The theorem proving mechanisms employed in these systems are incomplete and often terminate with failure.
Reference: [11] <author> Jussi Ketonen. </author> <title> Ekl a mathematically oriented proof checker. </title> <booktitle> In 7th CADE, </booktitle> <pages> pages 65-79. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Term rewriting systems form another class of Socratic systems with a more natural definition of an acceptable proof step. There currently exists a variety of man-machine interactive systems that use term rewriting combined with various methods of performing mathematical induction [3], [10], <ref> [11] </ref>. The theorem proving mechanisms employed in these systems are incomplete and often terminate with failure.
Reference: [12] <author> Kurt Konolidge. </author> <title> A Deduction Model of Belief. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1986. </year>
Reference-contexts: The first involves heuristic or probabilistic knowledge, also known as defaults and nonmonotonicity [19]. The second is "intensional" propositions such as the proposition P in the sentence "John believes that P" <ref> [12] </ref>. A third is recursive definitions. Recursive definitions are perhaps best modeled using the -calculus [18]. 2 In classical syntax, the only valid atomic formulas are equations of the form t = t. 4 [4].
Reference: [13] <author> Dexter C. Kozen. </author> <title> Complexity of finitely presented algebras. </title> <booktitle> In Proceedings of the Ninth Annual ACM Symposium on the Theory of Computu-tation, </booktitle> <pages> pages 164-177, </pages> <year> 1977. </year>
Reference-contexts: A more complex example involves deciding the satisfiability of a set of ground literals in first order logic with equality. The difficult part of this satisfiability problem is computing all substitutional consequences of equality. A polynomial time decision procedure based on congruence closure was first given by Kozen <ref> [13] </ref>. Kozen's congruence closure procedure was followed by a series of applications and more efficient implementations [17] [8]. <p> The significance of this extension lies in the significantly greater expressive power of taxonomic ground literals. The decision procedure for the classical ground literal satisfiability problem is based on congruence closure for reasoning about equality <ref> [13] </ref>, [8], [17]. Our decision procedure for taxonomic syntax can be viewed as a (non-trivial) adaptation of congruence closure. The congruence closure procedure can be viewed as an implementation of the four basic inference rules for equality | reflexivity, transitivity, symmetry, and substitutivity (congruence).
Reference: [14] <author> D. McAllester. </author> <title> Automatic recognition of tractability in inference relations. </title> <type> Memo 1215, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> February </month> <year> 1990. </year> <note> To appear in JACM. </note>
Reference-contexts: In research reported elsewhere we have constructed an automated procedure for verifying the tractability of a large class of rule sets <ref> [14] </ref>. The large case analysis necessary to establish the tractability of rules 1 through 31 has been machine verified. 8 Conclusion Automated reasoning is a classical problem of artificial intelligence. <p> It is also possible to construct a mechanical procedure that can determine in a large number of cases whether or not a given rule set is local. Such a procedure is described in <ref> [14] </ref>. It is straightforward to verify that when the extension ff is an application term then only inference rules that can derive new label formulas are rules 1 through 19.
Reference: [15] <author> David A. McAllester. Ontic: </author> <title> A Knowledge Representation System for Mathematics. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: More powerful decision procedures lead to shorter Socratic proofs. For the Socratic proof described here there is no need for a distinction between a tractable and an intractable language. The Socratic proof system defined in this paper is similar to the one used in the Ontic system <ref> [15] </ref>. Ontic provides Socratic completeness relative to Zermelo-Fraenkel set theory, i.e., any formula provable in set theory can be given a Socratic proof in that system. Ontic has been used to verify the Stone Representation Theorem of lattice theory starting with only the axioms of set theory. <p> Rule 30 allows any formula to be derived from F. In practice the inference process can be terminated whenever one can derive F. Rules 20 through 30 are incomplete for Boolean inference. Rules 20 through 29 characterize a limited form of Boolean inference known as Boolean constraint propagation <ref> [15] </ref>. These rules can also be viewed as a characterization of propositional unit resolution. Intuitively, each rule expresses a local relationship between a Boolean formula and its immediate subformulas. The incompleteness of rules 20 through 30 for Boolean inference results from an inability to perform case analysis. <p> For a fixed level of quantifer nesting the cost remains polynomial in the number of focus objects | the order of the polynomial being determined by the level of quantifier nesting. A more detailed discussion of sets of focus terms can be found in <ref> [15] </ref>. 26 (S1) [ fg ` ` [ fg ` (S3) ` (x) (S4) ` :Is (x; C) (S5) [ fIs (x 1 ; C); Is (x 2 ; C)g ` Is (x 1 ; x 2 ) ` fDet (C)g (S6) [ fIs (x; C); Is (x; W )g ` <p> The Socratic proof system described here is similar to the one used in the Ontic system described in <ref> [15] </ref>. The Ontic system provides Socratic completeness relative to Zermelo-Fraenkel set theory, i.e., any formula provable in set theory can (in principle) be given a Socratic proof in the Ontic system.
Reference: [16] <author> Bernhard Nebel. </author> <title> Terminological reasoning is inherently intractable. </title> <journal> Artificial Intelligence, </journal> <volume> 43 </volume> <pages> 235-249, </pages> <year> 1990. </year>
Reference-contexts: Non-standard tractable fragments of logic have been identified in the context of a certain family of knowledge representation languages called frame description languages, or FDLs [4] <ref> [16] </ref>. Although an FDL is a nonstandard syntax, one can still identify atomic formulas, literals, Boolean combinations and quantified formulas. Earlier work on FDLs has focused primarily on the problem of determining the validity of individual atomic formulas. <p> Our taxonomic syntax for first order logic is related to a large family of knowledge representation languages known as frame description languages (FDLs) [4], <ref> [16] </ref>, [21], [7]. <p> This particular problem is known in the knowledge representation literature as the subsumption problem | the problem of determining whether one class subsumes another class. Several FDLs have been found in which the atomic formula validity problem (the subsumption problem) is non-trivial yet polynomial time decidable <ref> [16] </ref>. However, we do not know of any published polynomial decision procedures for the atomic formula entailment problem of an FDL. The literal conjunction satisfiability problem has been similarly ignored.
Reference: [17] <author> Greg Nelson and Derek Oppen. </author> <title> Fast decision procedures based on congruence closure. </title> <journal> JACM, </journal> <volume> 27(2) </volume> <pages> 356-364, </pages> <month> April </month> <year> 1980. </year>
Reference-contexts: Some authors have proposed decision procedures that require more than polynomial time, such as the decision procedure for propositional dynamic logic, or the decision procedure for ground predicate calculus [20], [6]. Others have emphasized polynomial time procedures <ref> [17] </ref>. Polynomial time procedures are clearly desirable if one wants the acceptability of Socratic proofs to be quickly checkable. Some research on polynomial time inference procedures has emphasized computationally tractable fragments of first order logic. <p> The difficult part of this satisfiability problem is computing all substitutional consequences of equality. A polynomial time decision procedure based on congruence closure was first given by Kozen [13]. Kozen's congruence closure procedure was followed by a series of applications and more efficient implementations <ref> [17] </ref> [8]. It is also possible to combine the decision procedure for Horn clauses with the decision procedure for ground literals resulting in an efficient procedure for deciding the satisfiability of a set of 3 ground Horn clauses in first order logic with equality. <p> The significance of this extension lies in the significantly greater expressive power of taxonomic ground literals. The decision procedure for the classical ground literal satisfiability problem is based on congruence closure for reasoning about equality [13], [8], <ref> [17] </ref>. Our decision procedure for taxonomic syntax can be viewed as a (non-trivial) adaptation of congruence closure. The congruence closure procedure can be viewed as an implementation of the four basic inference rules for equality | reflexivity, transitivity, symmetry, and substitutivity (congruence).
Reference: [18] <author> D. Park. </author> <title> Finiteness is -ineffable. </title> <journal> Theoretical Computer Science, </journal> <volume> 3(2) </volume> <pages> 173-181, </pages> <year> 1976. </year>
Reference-contexts: The first involves heuristic or probabilistic knowledge, also known as defaults and nonmonotonicity [19]. The second is "intensional" propositions such as the proposition P in the sentence "John believes that P" [12]. A third is recursive definitions. Recursive definitions are perhaps best modeled using the -calculus <ref> [18] </ref>. 2 In classical syntax, the only valid atomic formulas are equations of the form t = t. 4 [4].
Reference: [19] <author> Judea Pearl. </author> <title> Probilistic Reasoning in Intelligent Systems: Networks of Plausible Inference. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: The first involves heuristic or probabilistic knowledge, also known as defaults and nonmonotonicity <ref> [19] </ref>. The second is "intensional" propositions such as the proposition P in the sentence "John believes that P" [12]. A third is recursive definitions.
Reference: [20] <author> V. Pratt. </author> <title> On specifying verifiers. </title> <booktitle> In Proceedings of the 7th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1980. </year>
Reference-contexts: Some authors have proposed decision procedures that require more than polynomial time, such as the decision procedure for propositional dynamic logic, or the decision procedure for ground predicate calculus <ref> [20] </ref>, [6]. Others have emphasized polynomial time procedures [17]. Polynomial time procedures are clearly desirable if one wants the acceptability of Socratic proofs to be quickly checkable. Some research on polynomial time inference procedures has emphasized computationally tractable fragments of first order logic.
Reference: [21] <author> M. Schmidt-Schaub and G. Smalka. </author> <title> Attributive concept descriptions with complements. </title> <journal> Artificial Intelligence, </journal> <volume> 47, </volume> <year> 1991. </year>
Reference-contexts: Our taxonomic syntax for first order logic is related to a large family of knowledge representation languages known as frame description languages (FDLs) [4], [16], <ref> [21] </ref>, [7].
Reference: [22] <author> Christoph Walther. </author> <title> Many sorted unification. </title> <journal> JACM, </journal> <volume> 35(1), </volume> <year> 1988. </year> <month> 57 </month>
Reference-contexts: The one-language architecture is able to draw more conclusions than the corresponding two-language system. Polynomial time inference procedures have also been studied in the context of unification theory. Most relevant to the present paper is the study of many sorted unification <ref> [22] </ref>. Certain first order axioms about taxonomic relationships can be incorporated into the sort structure of many sorted logic and then handled in the unification step of a resolution theorem prover. <p> There are two principle differences between the use of sorts in unification and the use of taxonomic formulas described here. First, the sort structures that have been built into unification procedures are simpler 5 than the taxonomic formulas studied here. For example, in the unification algorithms presented in <ref> [22] </ref> the sorts are represented by symbols under a fixed partial order and complex class expressions are not considered. Second, like earlier work on FDLs, sorted unification also takes a two-language approach to the use of decision procedures.
References-found: 22

