URL: http://fas.sfu.ca/cs/people/GradStudents/pwfong/personal/Pub/modver.ps
Refering-URL: http://fas.sfu.ca/cs/people/GradStudents/pwfong/personal/Research/
Root-URL: 
Email: fpwfong,camerong@cs.sfu.ca  
Title: Proof Linking: An Architecture for Modular Verification of Dynamically-Linked Mobile Code  
Author: Philip W. L. Fong and Robert D. Cameron 
Address: B.C., Canada  
Affiliation: School of Computing Science Simon Fraser University,  
Abstract: Security flaws are routinely discovered in commercial implementations of mobile code systems such as the Java Virtual Machine (JVM). Typical architectures for such systems exhibit complex interdependencies between the loader, the verifier, and the linker, making them difficult to craft, validate, and maintain. This reveals a software engineering challenge that is common to all mobile code systems in which a static verification phase is introduced before dynamic linking. In such systems, one has to articulate how loading, verification, and linking interact with each other, and how the three processes should be organized to address various security issues. We propose a standard architecture for crafting mobile code verifiers, based on the concept of proof linking. This architecture modularizes the verification process and isolates the dependencies among the loader, verifier, and linker. We also formalize the process of proof linking and establish properties to which correct implementations must conform. As an example, we instantiate our architecture for the problem of Java bytecode verification and assess the correctness of this instantiation. Finally, we briefly discuss alternative mobile code verification architectures enabled by our mod-ularization. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Luca Cardelli. </author> <title> Program fragments, linking, and modularization. </title> <booktitle> In Proceedings of the 24th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year> <note> Also available at http://research.microsoft.com/research/cambridge/ luca/Papers/Linking.ps. </note>
Reference-contexts: In this context, we can characterize our architecture in the framework of Cardelli's theoretical treatment of type-safe linking <ref> [1] </ref>. In short, module verification in our system is comparable to Cardelli's intra-checking, while proof linking may be viewed as an incremental form of inter-checking. Our approach differs substantially in the treatment of typing environments. <p> In our work, consistency of type extension is achieved by the monotonicity condition. Cardelli <ref> [1] </ref> proposes a formal model for type-safe (static) linking in a simply-typed lambda calculus. In his model, program fragments to be linked to gether is called a linkset. Linking is modelled as a series of substitutions that preserve type safety invariants. <p> Our verify primitive is equivalent to his intra-checking, while our resolve primitive could be seen as an incremental version of his inter-checking. The correctness of his model is also dependent (though implicitly) on some specific ordering of substitution steps <ref> [1, Lemma 3-3 & Section 6] </ref>. Extension of this framework to incremental dynamic linking would be an interesting area for further work. One may argue that, by making the verifier module replaceable, we are simply transferring the point of attack to the proof linker.
Reference: [2] <author> Antonio Carzaniga, Gian Pietro Picco, and Giovanni Vigna. </author> <title> Designing Distributed Applications with Mobile Code Paradigms. </title> <booktitle> In ICSE '97, </booktitle> <year> 1997. </year>
Reference-contexts: 1 Introduction Recent years have witnessed a significant growth of interest in mobile code in the form of active contents (e.g. applets) or code-on-demand <ref> [2] </ref>. Java [8] has emerged as an industrial standard for crafting mobile code of the mentioned forms. One of the crucial language features behind this success is Java's claim of security.
Reference: [3] <author> D. Clark and D. Wilson. </author> <title> A comparison of commercial and military computer security policies. </title> <booktitle> In Proceedings of the IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 184-194, </pages> <year> 1987. </year>
Reference-contexts: Although the first application of our framework, Java bytecode verification, is mainly type checking, we are ex ploring the application of our framework to the verification of other security properties like confidentiality [5, 18] and integrity <ref> [3] </ref>. In the long run, we would like to formally characterize the kind of program properties that allow modular verification in the manner prescribed by this paper.
Reference: [4] <author> Drew Dean. </author> <title> The security of static typing with dynamic linking. </title> <booktitle> In Proceedings of the Fourth ACM Conference on Computer and Communication Security, </booktitle> <address> Zurich, Switzerland, </address> <year> 1997. </year> <note> Also available at http://www.CS.Princeton.EDU/sip/pub/ccs4.html. </note>
Reference-contexts: We apply the above to articulate the correctness of dynamic linking in an instantiation of Java bytecode verification. Moreover, our modularization leads naturally to several potential extensions of mobile code verification. Dean pioneered the study of type-safe dynamic linking <ref> [4] </ref>. In order to make sure that the reflection facilities of Java do not produce type confusion, he formalized an approximation to the linking behavior of Sun's implementation of the Java run-time environment. He then formulates a sufficient condition, called consistent extension (of type environment), for type-safe linking.
Reference: [5] <author> Dorothy E. Denning and Peter J. Denning. </author> <title> Certification of Programs for Secure Information Flow. </title> <journal> Communications of the ACM, </journal> <volume> 20(7) </volume> <pages> 504-513, </pages> <month> July </month> <year> 1977. </year>
Reference-contexts: Although the first application of our framework, Java bytecode verification, is mainly type checking, we are ex ploring the application of our framework to the verification of other security properties like confidentiality <ref> [5, 18] </ref> and integrity [3]. In the long run, we would like to formally characterize the kind of program properties that allow modular verification in the manner prescribed by this paper.
Reference: [6] <author> Premkumar T. Devanbu, Philip W. L. Fong, and Stuart G. Stubblebine. </author> <title> Techniques for trusted software engineering. </title> <booktitle> In Proceedings of the 20th International Conference on Software Engineering, </booktitle> <address> Kyoto, Japan, </address> <year> 1998. </year> <note> Available at http://www.research.att.com/~prem/icse98.ps. </note>
Reference-contexts: The above implementation is an infrastructure for the work in <ref> [6] </ref>. We are now investigating how to incorporate a proof linker into a Java-enabled web browser. 5 Rethinking Verification The modular verification model we propose here invites several natural extensions to mobile code verification. <p> Combining modular verification with key-management technologies, and by employing a physically secure coprocessor to perform verification, Devanbu, Fong, and Stubblebine <ref> [6] </ref> produce a distributed mobile code verification architecture that has various security-related and configuration-management-related benefits. In this way, our work renders verification a service that can be offered by any third-party verification service provider. Thirdly, modularization of verification provides interoperability among various verification protocols. <p> Since proof checking is usually easier than proof generation, this protocol introduces less link-time overhead than proof-on-demand. Also, since proof generation is now performed once and for all by the developer of the code, one can afford to consider difficult-to-prove safety properties. 3. Proof delegation <ref> [6] </ref>: Code is passed to a trusted program analyzer, which certifies the correctness of the code, and then digitally signs it. Upon arrival at the execution site, verification is replaced by signature checking. This protocol is potentially the most efficient when the safety properties can be mechanically established.
Reference: [7] <author> Edward Felten. </author> <note> Security Flaw in JDK 1.1.1 and Hot-Java 1.0. http://www.cs.princeton.edu/sip/, 1997. </note>
Reference-contexts: The verification algorithm is a very complex process including type checking and data-flow analysis. Due to the complexity of the verification algorithm, it is a nontrivial undertaking to produce an implementation that is correct. Because of this, various security breaches were discovered in several major implementations <ref> [7, 17] </ref>. Given that security is a critical concern for parties hosting mobile code, it becomes imperative to have a way of validating the bytecode verifier itself. The current implementation from Sun and other vendors make the validation of the bytecode verifier very difficult. 1. Interleaving logic.
Reference: [8] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Recent years have witnessed a significant growth of interest in mobile code in the form of active contents (e.g. applets) or code-on-demand [2]. Java <ref> [8] </ref> has emerged as an industrial standard for crafting mobile code of the mentioned forms. One of the crucial language features behind this success is Java's claim of security.
Reference: [9] <author> Stanley Letovsky and Elliot Soloway. </author> <title> Delocalized Plans and Program Comprehension. </title> <journal> IEEE Software, </journal> <pages> pages 41-49, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: Consequently, checks are spread all over the run-time system, and it is difficult to guarantee the completeness of the verification process. It has been well-known in program understanding literature that interleaving and delocalized program plans lead to programs that are difficult to comprehend <ref> [15, 9] </ref>. This so-called "scattershot security" [13] renders validation of the verifier extremely difficult. Not only this, interleaving and delocalization result in an overly tight coupling between the verifier and the rest of the Java run-time environment.
Reference: [10] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison Wesley, </publisher> <year> 1997. </year>
Reference-contexts: As some authors have pointed out, Java security is type safety [13]. As long as the strict type rules are not violated, a piece of mobile code is guaranteed to behave in a well-mannered way. To enforce type safety, a bytecode verifier <ref> [10] </ref> is invoked prior to the execution of untrusted code. The verifier makes sure that all type rules are honored in the code. The verification algorithm is a very complex process including type checking and data-flow analysis. <p> Monotonicity: The initial theory and the obligations are all definite Horn clauses. 3 In principle, we could have formulated the commitments and obligations related to the checking of resolution errors <ref> [10, chapter 5] </ref>. <p> Generating commitments and obligations. We have implemented a stand-alone Java bytecode verifier that generates the commitments and obligations in figure 4 and 5. In Sun's implementation of the verifier, merging of two classes Z 1 and Z 2 yields their most specific common superclass <ref> [10] </ref>. Computation of this superclass involves the recursive loading of all superclasses of Z 1 and Z 2 . Our implementation avoids recursive loading by representing the most specific common superclass algebraically as Z 1 u Z 2 .
Reference: [11] <author> Daryl McCullough. </author> <title> Specification for Multi-Level Security and a Hook-Up Property. </title> <booktitle> In Proceedings for the IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 161-166, </pages> <year> 1987. </year>
Reference-contexts: such interoperability. 6 Discussion and Related Work Neither dynamic linking nor modular verification is new: dynamic linking is common in operating systems like UNIX and Windows; the notion of local certifiability is well known in software engineering [19]; composability of security features was studied as early as in the 1980's <ref> [11, 12] </ref>. Our main contribution lies in the proposal of an infrastructure that permits mudular verification in the presence of dynamic linking. Eliminating interleaving and delocalization, the resulting verifier can be understood and validated independent of the rest of the run-time system.
Reference: [12] <author> Daryl McCullough. </author> <title> Noninterference and the Compos-ability of Security Properties. </title> <booktitle> In Proceedings of the IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 177-186, </pages> <year> 1988. </year>
Reference-contexts: such interoperability. 6 Discussion and Related Work Neither dynamic linking nor modular verification is new: dynamic linking is common in operating systems like UNIX and Windows; the notion of local certifiability is well known in software engineering [19]; composability of security features was studied as early as in the 1980's <ref> [11, 12] </ref>. Our main contribution lies in the proposal of an infrastructure that permits mudular verification in the presence of dynamic linking. Eliminating interleaving and delocalization, the resulting verifier can be understood and validated independent of the rest of the run-time system.
Reference: [13] <author> Gary Mcgraw and Edward W. Felten. </author> <title> Java Security: Hostile Applets, Holes, and Antidotes. </title> <publisher> John Wiley & Sons, Inc, </publisher> <year> 1997. </year> <month> 8 </month>
Reference-contexts: As a mobile code hosting environment (e.g. browser) brings in programs of untrusted origin, it is imperative to guarantee that the untrusted program does not exploit the hosting machine in any undesirable way. As some authors have pointed out, Java security is type safety <ref> [13] </ref>. As long as the strict type rules are not violated, a piece of mobile code is guaranteed to behave in a well-mannered way. To enforce type safety, a bytecode verifier [10] is invoked prior to the execution of untrusted code. <p> Consequently, checks are spread all over the run-time system, and it is difficult to guarantee the completeness of the verification process. It has been well-known in program understanding literature that interleaving and delocalized program plans lead to programs that are difficult to comprehend [15, 9]. This so-called "scattershot security" <ref> [13] </ref> renders validation of the verifier extremely difficult. Not only this, interleaving and delocalization result in an overly tight coupling between the verifier and the rest of the Java run-time environment. Whenever a flaw is found in the verifier, the entire run-time environment (e.g. a browser) has to be replaced.
Reference: [14] <author> George C. Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Pro--ceedings of the 24th ACM Symposium on Principles of Programming Languages (POPL'97), </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year> <note> Also available at http://www.cs.cmu.edu/~necula/popl97.ps.gz. </note>
Reference-contexts: Proof-on-demand: The existing implementations of Java bytecode verification exemplify this protocol. Verification is performed dynamically whenever a class-file is linked into the run-time environment. The protocol introduces link-time overhead, but it allows dynamically-generated code to be verified properly. 2. Proof-carrying code <ref> [14] </ref>: Verification is performed remotely. A correctness proof is attached to a code module when it is shipped. Upon arrival at the execution site, the correctness proof is checked before execution is granted. Since proof checking is usually easier than proof generation, this protocol introduces less link-time overhead than proof-on-demand.
Reference: [15] <author> Spencer Rugaber, Kurt Stirewalt, and Linda W. Wills. </author> <title> The Interleaving Problem in Program Understanding. </title> <booktitle> In 2nd Working Conference on Reverse Engineering, </booktitle> <pages> pages 166-175, </pages> <address> Toronto, Ontario, Canada, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: Consequently, checks are spread all over the run-time system, and it is difficult to guarantee the completeness of the verification process. It has been well-known in program understanding literature that interleaving and delocalized program plans lead to programs that are difficult to comprehend <ref> [15, 9] </ref>. This so-called "scattershot security" [13] renders validation of the verifier extremely difficult. Not only this, interleaving and delocalization result in an overly tight coupling between the verifier and the rest of the Java run-time environment.
Reference: [16] <institution> SRI International Computer Science Laboratory. </institution> <note> The PVS verification system. Available at http://www.csl.sri.com/pvs.html. </note>
Reference-contexts: He then formulates a sufficient condition, called consistent extension (of type environment), for type-safe linking. He established the correctness of his approximation using the PVS theorem prover <ref> [16] </ref>. While he focusses mainly on the articulartion of linking correctness in the presence of reflection facilities, we attempt to provide a modular architecture upon which one can dynamically link together results from static analysis of different compilation units.
Reference: [17] <author> The Kimera Team. </author> <title> Security Flaws in Java Implementations. </title> <note> http://kimera.cs.washington.edu/flaws/index.html, 1997. </note>
Reference-contexts: The verification algorithm is a very complex process including type checking and data-flow analysis. Due to the complexity of the verification algorithm, it is a nontrivial undertaking to produce an implementation that is correct. Because of this, various security breaches were discovered in several major implementations <ref> [7, 17] </ref>. Given that security is a critical concern for parties hosting mobile code, it becomes imperative to have a way of validating the bytecode verifier itself. The current implementation from Sun and other vendors make the validation of the bytecode verifier very difficult. 1. Interleaving logic.
Reference: [18] <author> Dennis Volpano and Geoffrey Smith. </author> <title> A type-based approach to program security. </title> <booktitle> In Proceedings of the Seventh International Joint Conference on the Theory and Practice of Software Development, volume 1214 of Lecture Notes in Computer Science, </booktitle> <pages> pages 607-621, </pages> <month> April </month> <year> 1997. </year> <note> Also available at http://www.cs.nps.navy.mil/research/languages/ papers/atsc/tapsoft97.ps.Z. </note>
Reference-contexts: Although the first application of our framework, Java bytecode verification, is mainly type checking, we are ex ploring the application of our framework to the verification of other security properties like confidentiality <ref> [5, 18] </ref> and integrity [3]. In the long run, we would like to formally characterize the kind of program properties that allow modular verification in the manner prescribed by this paper.
Reference: [19] <author> B. W. Weide and J. E. Hollingsworth. </author> <title> Scalability of Reuse Technology to Large Systems Requires Local Certifiability. </title> <booktitle> In Proceedings of the 5th Annual Workshop on Software Reuse, </booktitle> <year> 1992. </year> <month> 9 </month>
Reference-contexts: Proof linking provides an infrastructure for such interoperability. 6 Discussion and Related Work Neither dynamic linking nor modular verification is new: dynamic linking is common in operating systems like UNIX and Windows; the notion of local certifiability is well known in software engineering <ref> [19] </ref>; composability of security features was studied as early as in the 1980's [11, 12]. Our main contribution lies in the proposal of an infrastructure that permits mudular verification in the presence of dynamic linking.
References-found: 19

