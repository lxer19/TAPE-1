URL: http://www.cs.mu.oz.au/tr_db/mu_98_02.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Analysing Modes and Subtypes in Z Specifications  
Author: Michael Winikoff 
Address: Parkville, Victoria 3052 Australia  
Affiliation: Department of Computer Science The University of Melbourne  
Pubnum: Technical Report 98/2  
Abstract: Poor requirements are the cause of a large proportion of defects in released software. Requirements can be improved by using mathematical modelling techniques. These have a number of advantages and a single major disadvantage-it is difficult to demonstrate a formal specification to a client or user. One proposed solution to this problem is to automatically derive (executable) prototypes of a system from a formal specification by using analysis. This process is known as animation. In this report we focus on the analyses used in an animation tool for the specification language Z. Specifically, we look at mode and subtype analyses. More extensive motivation and discussion of other aspects of the tool can be found elsewhere. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. M. Brien and J. E. </author> <title> Nicholls. Z base standard. </title> <type> Technical Monograph PRG-107, </type> <institution> Oxford University Computing Laboratory, </institution> <address> Wolfson Building, Parks Road, Oxford, UK, </address> <month> November </month> <year> 1992. </year> <note> Accepted for standardization under ISO/IEC JTC1/SC22. </note>
Reference-contexts: We present the design of MUZAK and describe briefly what information we need in order to translate specifications to executable code and how the translation is performed. We then focus on how the information is determined. The complete details for two analyses are presented. MUZAK animates Z <ref> [1, 12] </ref> using Mercury [9-11]. The Z specification to be animated is translated to first order set theory (in Horn clause form) and then analysed. The results of the analysis are used to generate Mercury code.
Reference: [2] <author> Krasner H. Curtis, B. and Neil Iscoe. </author> <title> A field study of the software design process for large systems. </title> <journal> Communications of The ACM, </journal> <volume> 31(11) </volume> <pages> 1268-1287, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction A majority of defects in software can be traced back to poor requirements <ref> [2, 5, 8] </ref>. Two approaches to improving requirements are prototyping and mathematical modelling. Mathematical models have the advantage of being more abstract. This enables them to avoid design biases and makes them more suitable as a basis for subsequent system development.
Reference: [3] <author> Philip W. </author> <title> Dart. On derived dependencies and connected databases. </title> <journal> Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 163-188, </pages> <year> 1991. </year>
Reference-contexts: We avoid this by representing constraints as sets of clauses. We have the following collected definitions from <ref> [3, 4] </ref>: 28 C ::= true j false j C ^ C j C _ C j A clause ::= C ! A Where C can not contain A.
Reference: [4] <author> Philip W. Dart and Justin Zobel. </author> <title> Efficient run-time checking of typed logic programs. </title> <journal> Journal of Logic Programming, </journal> 14(1&2):31-69, 1992. 
Reference-contexts: We avoid this by representing constraints as sets of clauses. We have the following collected definitions from <ref> [3, 4] </ref>: 28 C ::= true j false j C ^ C j C _ C j A clause ::= C ! A Where C can not contain A.
Reference: [5] <author> Robyn R. Lutz. </author> <title> Targeting safet-related errors during software requirements analysis. </title> <booktitle> In Proceedings of SIGSOFT '93, Foundations of Software Engineering, </booktitle> <pages> pages 99-105, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction A majority of defects in software can be traced back to poor requirements <ref> [2, 5, 8] </ref>. Two approaches to improving requirements are prototyping and mathematical modelling. Mathematical models have the advantage of being more abstract. This enables them to avoid design biases and makes them more suitable as a basis for subsequent system development.
Reference: [6] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: i ) As the following properties show, these are safe approximations to the standard log ical connectives: F _ ^ F 0 , F ^ F 0 F ) F n g k Once we have transformed a general constraint into a set of clauses we can use standard results <ref> [6] </ref> to replace a general theorem prover with a top down resolution search a la Prolog without losing completeness. This is significantly more efficient. 4.5 Example We now consider applying the above algorithm to the previously presented informal example.
Reference: [7] <author> Lee Naish. </author> <title> A declarative view of modes. </title> <booktitle> In Proceedings of the 1996 Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 185-199. </pages> <publisher> MIT Press, </publisher> <month> Septem-ber </month> <year> 1996. </year>
Reference-contexts: freeg and fy 7! x; z 7! xg x is either fy 7! zg or fz 7! yg. 6 fF i g fF 1 g fF 2 g + xfFg f9 x * Fg x f: Fg fAg fA = A 0 gunify (A; A 0 ; ) A mode <ref> [7] </ref> is an abstraction of the operational semantics of a formula. A mode I ) O describes the effect of executing a formula on (abstracted) substitutions. In particular we use a simple abstraction which records the ground variables.
Reference: [8] <editor> Philip Sallis, Graham Tate, and Stephen McDonell. </editor> <booktitle> Software Engineering. </booktitle> <publisher> Addison Wesley Publishing Co., </publisher> <year> 1995. </year>
Reference-contexts: 1 Introduction A majority of defects in software can be traced back to poor requirements <ref> [2, 5, 8] </ref>. Two approaches to improving requirements are prototyping and mathematical modelling. Mathematical models have the advantage of being more abstract. This enables them to avoid design biases and makes them more suitable as a basis for subsequent system development.
Reference: [9] <author> Zoltan Somogyi, Fergus Henderson, and Thomas Conway. </author> <title> Mercury: an efficient purely declarative logic programming language. </title> <booktitle> In Proceedings of the Australian Computer Science Conference, </booktitle> <pages> pages 499-512, </pages> <month> February </month> <year> 1995. </year>
Reference: [10] <author> Zoltan Somogyi, Fergus Henderson, Thomas Conway, Andrew Bromage, Tyson Dowd, David Jeffery, Peter Ross, Peter Schachte, and Simon Taylor. </author> <title> Status of the Mercury system. </title> <booktitle> In Proceedings of the JICSLP'96 Workshop on Parallelism and Implementation Technology for (Constraint) Logic Programming Languages, </booktitle> <pages> pages 207-218, </pages> <year> 1996. </year>
Reference: [11] <author> Zoltan Somogyi, Fergus Henderson, Thomas Conway, and Richard O'Keefe. </author> <title> Logic programming for the real world. </title> <editor> In Donald A. Smith, editor, </editor> <booktitle> Proceedings of the ILPS'95 Postconference Workshop on Visions for the Future of Logic Programming, </booktitle> <pages> pages 83-94, </pages> <address> Portland, Oregon, </address> <year> 1995. </year>
Reference: [12] <author> J. M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> Prentice Hall International Series in Computer Science, 2nd edition, </booktitle> <year> 1992. </year> <month> 36 </month>
Reference-contexts: We present the design of MUZAK and describe briefly what information we need in order to translate specifications to executable code and how the translation is performed. We then focus on how the information is determined. The complete details for two analyses are presented. MUZAK animates Z <ref> [1, 12] </ref> using Mercury [9-11]. The Z specification to be animated is translated to first order set theory (in Horn clause form) and then analysed. The results of the analysis are used to generate Mercury code.
Reference: [13] <author> M. Winikoff, P. Dart, and E. Kazmierczak. </author> <title> Rapid prototyping using formal speci-fications. </title> <editor> In Chris McDonald, editor, </editor> <booktitle> Proceedings of the 21st Australasian Computer Science Conference, ACSC'98, </booktitle> <pages> pages 279-293. </pages> <publisher> Springer, </publisher> <month> February </month> <year> 1998. </year>
Reference-contexts: We then present in section 3 the mode analysis and in section 4 the subtype analysis. Section 5 gives a complete example. Motivation, results, and discussions of other aspects of MUZAK can be found in <ref> [13, 14] </ref> For up to date information on MUZAK and the pipedream project see: http://www.cs.mu.oz.au/winikoff/pipe 2 Overview Input to the analyses Before proceeding to discuss design issues we briefly describe the input to the analyses. The translation from Z to first order set theory is given in [14]. <p> In this section we briefly explain why we have chosen to perform analysis at all, and why these particular two analyses. Other questions such as Why use Z? and Why use Mercury? are addressed elsewhere <ref> [13] </ref>. Z Horn Clause + Sets Mercury Mode Analysis Subtype Analysis 2 Since expanding them out would increase the size of the formula 4 Why analyse? There is a gap between a set of logical formulae (in Horn clause form) and an executable logic program.
Reference: [14] <author> Michael Winikoff and Philip Dart. </author> <title> Translating Z to logic. </title> <type> Technical Report 97/14, </type> <institution> Department of Computer Science, Melbourne University, </institution> <year> 1997. </year> <month> 37 </month>
Reference-contexts: We then present in section 3 the mode analysis and in section 4 the subtype analysis. Section 5 gives a complete example. Motivation, results, and discussions of other aspects of MUZAK can be found in <ref> [13, 14] </ref> For up to date information on MUZAK and the pipedream project see: http://www.cs.mu.oz.au/winikoff/pipe 2 Overview Input to the analyses Before proceeding to discuss design issues we briefly describe the input to the analyses. The translation from Z to first order set theory is given in [14]. <p> The translation from Z to first order set theory is given in <ref> [14] </ref>. Note that the translation produces a set of Horn clauses.
References-found: 14

