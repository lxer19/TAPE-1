URL: http://choices.cs.uiuc.edu/Security/Papers/symp.ps
Refering-URL: http://choices.cs.uiuc.edu/Security/index.html
Root-URL: http://www.cs.uiuc.edu
Email: theron@eng.sun.com  sturman@cs.uiuc.edu  roy@cs.uiuc.edu  
Title: Security, Delegation, and Extensibility  
Author: Theron Tock Daniel Sturman Roy Campbell 
Date: November 4, 1994  
Abstract: We present the design of a customizable, object-oriented framework for secure communication. This framework provides authenticated message passing to existing distributed applications and services: through the use of inheritance, communication classes preserve interfaces while adding security. New applications or services specify communication requirements and the system ensures the correct protocols are used for communication. To demonstrate the extensibility of this framework approach, we present subframeworks for secret communication and the delegation of authority. We describe our implementation of this framework for Choices, an object-oriented operating system.
Abstract-found: 1
Intro-found: 1
Reference: [AR87] <author> David P. Anderson and P. Venkat Rangan. </author> <title> A Basis for Secure Communication in Large Distributed Systems. </title> <booktitle> In Proceedings of the Symposium on Security and Privacy, </booktitle> <pages> pages 167-172. </pages> <publisher> IEEE, </publisher> <year> 1987. </year>
Reference-contexts: Using message ports to provide authentication and secrecy is also not new <ref> [AR87] </ref>. Our system, however, extends this previous work by using inheritance to both simplify the design and to hide explicit knowledge about security from the applications. By designing a framework for secure communication, we may add and remove functionality from the system in terms of classes.
Reference: [CIM92] <author> Roy H. Campbell, Nayeem Islam, and Peter Madany. </author> <title> Choices, Frameworks and Refinement. </title> <journal> Computing Systems, </journal> <volume> 5(3) </volume> <pages> 217-257, </pages> <year> 1992. </year>
Reference-contexts: Third, existing applications may need to incorporate security and this conversion should be simple. We describe a solution that preserves existing primitives yet provides simple authentication in terms of a framework <ref> [CIM92] </ref>. A framework is an object-oriented system design specified as a collection of classes. By capturing the interactions of a system using abstract classes, the system can be implemented by selecting appropriate combinations of concrete subclasses. <p> An important structuring tool in Choices is the framework <ref> [CIM92] </ref> which we describe in more detail below. We then present the original communication framework of Choices that is the basis for our work. 2.1 Frameworks A framework is a collection of abstract classes that defines the design of the system through informal specification of class interactions.
Reference: [CIRM93] <author> Roy H. Campbell, Nayeem Islam, David Raila, and Peter Madany. </author> <title> Designing and Implementing Choices: An Object-Oriented System in C++. </title> <journal> Communications of the ACM, </journal> <volume> 36(9) </volume> <pages> 117-126, </pages> <year> 1993. </year>
Reference-contexts: We conclude with a comparison of our approach to other work and a discussion of the benefits of our design. 2 Background The work described in this paper is implemented as part of the object-oriented operating system Choices <ref> [CIRM93] </ref>, developed at the University of Illinois. An important structuring tool in Choices is the framework [CIM92] which we describe in more detail below. <p> For each request, the ContainerCreator constructs a container using appropriate concrete classes. Because of this indirection, the system can be reconfigured to provide message containers that offer better performance characteristics for a particular application while still satisfying the requested semantics <ref> [CIRM93] </ref>. In the same vein, the system can be reconfigured to enforce a level of secure communication in applications that are not designed for secure use. For example, a system administrator may wish to impose secret communication on all applications in the system.
Reference: [FS86] <author> Amos Fiat and Adi Shamir. </author> <title> How to Prove Yourself: Practical Solutions to Identification and Signature Problems. </title> <editor> In G. Goos and J. Hartmanis, editors, </editor> <booktitle> Lecture Notes in Computer Science 263, </booktitle> <pages> pages 186-194. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: This permits multiple implementations and delayed selection of a particular protocol until run-time. Our current implementation provides protocol objects implementing RSA public-key authentication [Lab92], Kerberos [SNS88, KN93], and Fiat-Shamir zero-knowledge proofs <ref> [FS86] </ref>. We discuss these implementations in more detail in Section 7. From an application's perspective, use of the authentication classes is identical to using the original communication framework. <p> Our asymmetric version of Needam-Schroeder uses the RSA public key library [Lab92] and our symmetric version is based on Kerberos [KN93]. The zero-knowledge protocol is an implementation of the work described in <ref> [FS86] </ref>. A separate AuthProtocol subclass exists for each of these three protocols. The three subclasses may be used interchangeably. The two Needham-Schroeder variants have fairly high overhead to exchange a session key securely, but individual message authentications are inexpensive.
Reference: [GM90] <author> Morrie Gasser and Ellen McDermott. </author> <title> An Architecture for Practical Delegation in a Distributed System. </title> <booktitle> In Proceedings of the Symposium on Security and Privacy, </booktitle> <pages> pages 20-30. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: Therefore, we did not implement a secret communication sub-framework for this protocol. The delegation protocol we use is similar to the passport scheme described in [Sol88]. Our scheme is independent of any specific authentication protocol. Unlike the delegation protocols in Kerberos [VAB91] and the Distributed System Security Architecture (DSSA) <ref> [GM90] </ref> which generate new delegation keys used by the underlying encryption primitives, the delegation protocol we describe here needs no specific information about the particular authentication protocol in use. The delegation protocol consists of a sequence of authenticated messages exchanged between the delegator and the service being delegated. <p> The Distributed System Security Architecture (DSSA) was initiated to solve authentication and authorization problems in large distributed systems. The available literature does not address application interface issues and the system is currently not available for evaluation. However the delegation scheme <ref> [GM90] </ref> does have limitations. Each delegation requires a new certificate, which are quite large and slow to generate. 9 Discussion The framework presented in this paper has been implemented in the Choices object-oriented operating system. Using the framework, secure communication may be easily incorporated into existing applications.
Reference: [IC92] <author> Nayeem Islam and Roy H. Campbell. </author> <title> Design Considerations for Shared Memory Multiprocessor Message Systems. </title> <journal> In IEEE Transactions on Parallel and Distributed Systems, </journal> <pages> pages 702-712, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: These abstract classes present interfaces for message fragmentation and reassembly, flow control, reliability, and message transport <ref> [IC92] </ref>. The application interface of the message-passing system, shown in Figure 1, is based on MsgPorts and MsgContainers. A MsgContainer is a receptacle for retrieving messages, and a MsgPort is a send-only channel to a specific container. Multiple ports may refer to a single container.
Reference: [KN93] <author> J. Kohl and C. Neuman. </author> <title> RFC 1510: The Kerberos Network Authentication Service (V5), </title> <month> September </month> <year> 1993. </year>
Reference-contexts: The AuthProtocol class is abstract and captures an authentication protocol's interactions with the other portions of the communication framework. This permits multiple implementations and delayed selection of a particular protocol until run-time. Our current implementation provides protocol objects implementing RSA public-key authentication [Lab92], Kerberos <ref> [SNS88, KN93] </ref>, and Fiat-Shamir zero-knowledge proofs [FS86]. We discuss these implementations in more detail in Section 7. From an application's perspective, use of the authentication classes is identical to using the original communication framework. <p> We have implemented three authentication protocols: one each for Needham-Schroeder key exchange using symmetric and asymmetric encryption, and one using Fiat-Shamir zero-knowledge proofs. Our asymmetric version of Needam-Schroeder uses the RSA public key library [Lab92] and our symmetric version is based on Kerberos <ref> [KN93] </ref>. The zero-knowledge protocol is an implementation of the work described in [FS86]. A separate AuthProtocol subclass exists for each of these three protocols. The three subclasses may be used interchangeably.
Reference: [Lab92] <author> RSA Laboratories. RSAREF: </author> <title> A Cryptographic Toolkit for Privacy-Enhanced Mail: Library Reference Manual. Distributed with RSAREF source code, </title> <month> March </month> <year> 1992. </year>
Reference-contexts: The AuthProtocol class is abstract and captures an authentication protocol's interactions with the other portions of the communication framework. This permits multiple implementations and delayed selection of a particular protocol until run-time. Our current implementation provides protocol objects implementing RSA public-key authentication <ref> [Lab92] </ref>, Kerberos [SNS88, KN93], and Fiat-Shamir zero-knowledge proofs [FS86]. We discuss these implementations in more detail in Section 7. From an application's perspective, use of the authentication classes is identical to using the original communication framework. <p> We show that this delegation protocol better supports mobile systems than current delegation schemes. We have implemented three authentication protocols: one each for Needham-Schroeder key exchange using symmetric and asymmetric encryption, and one using Fiat-Shamir zero-knowledge proofs. Our asymmetric version of Needam-Schroeder uses the RSA public key library <ref> [Lab92] </ref> and our symmetric version is based on Kerberos [KN93]. The zero-knowledge protocol is an implementation of the work described in [FS86]. A separate AuthProtocol subclass exists for each of these three protocols. The three subclasses may be used interchangeably.
Reference: [Ras86] <author> Richard Rashid. </author> <title> Threads of a New System. UNIX Review, </title> <year> 1986. </year>
Reference-contexts: The lack of bottlenecks in this delegation protocol, as well as the ability to delegate to a disconnected entity, are well suited to this environment. 10 8 Related Work The use of message ports for communication is not new, having been popularized by operating systems such as Mach <ref> [Ras86] </ref>. Using message ports to provide authentication and secrecy is also not new [AR87]. Our system, however, extends this previous work by using inheritance to both simplify the design and to hide explicit knowledge about security from the applications.
Reference: [SNS88] <author> Jennifer G. Steiner, Clifford Neuman, and Jeffrey I. Schiller. </author> <title> Kerberos: An Authentication Service for Open Network Systems. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 191-202, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: The AuthProtocol class is abstract and captures an authentication protocol's interactions with the other portions of the communication framework. This permits multiple implementations and delayed selection of a particular protocol until run-time. Our current implementation provides protocol objects implementing RSA public-key authentication [Lab92], Kerberos <ref> [SNS88, KN93] </ref>, and Fiat-Shamir zero-knowledge proofs [FS86]. We discuss these implementations in more detail in Section 7. From an application's perspective, use of the authentication classes is identical to using the original communication framework. <p> Amoeba uses capabilities extensively, allowing applications to pass rights to other applications [TvRvS + 90]. There are several limitations to this approach: authorizations are difficult to revoke, their distribution not easily controlled, and because there is no separate authentication mechanism the network must be physically secured. The Kerberos <ref> [SNS88] </ref> system provides both authentication and delegation. However, the application interface is overly complicated and difficult to use. Both Amoeba and Kerberos were designed to provide a specific set of functionality. Therefore, extending these systems to include concepts such as delegation has proven difficult.
Reference: [Sol88] <author> Karen R. Sollins. </author> <title> Cascaded Authentication. </title> <booktitle> In Proceedings of the Symposium on Security and Privacy, </booktitle> <pages> pages 156-163. </pages> <publisher> IEEE, </publisher> <year> 1988. </year>
Reference-contexts: However, zero-knowledge proofs do not support the exchange of secret information: all messages in the proof are clear-text messages. Therefore, we did not implement a secret communication sub-framework for this protocol. The delegation protocol we use is similar to the passport scheme described in <ref> [Sol88] </ref>. Our scheme is independent of any specific authentication protocol.
Reference: [TvRvS + 90] <author> Andrew S. Tanenbaum, Robbert van Renesse, Hans van Staveren, Gregory J. Sharp, Sape J. Mullender, Jack Jansen, and Guido van Rossum. </author> <title> Experiences with the Amoeba Distributed Operating System. </title> <journal> Communications of the ACM, </journal> <volume> 33(12), </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: Furthermore, our design is unique in its flexibility: adding delegation is a straightforward extension of our concepts. Delegation has received increased attention with the emergence of distributed systems. Amoeba uses capabilities extensively, allowing applications to pass rights to other applications <ref> [TvRvS + 90] </ref>. There are several limitations to this approach: authorizations are difficult to revoke, their distribution not easily controlled, and because there is no separate authentication mechanism the network must be physically secured. The Kerberos [SNS88] system provides both authentication and delegation.
Reference: [VAB91] <author> Vijay Varadharajan, Phillip Allen, and Stewart Black. </author> <title> An Analysis of the Proxy Problem in Distributed Systems. </title> <booktitle> In Proceedings of the Symposium on Security and Privacy, </booktitle> <pages> pages 255-275. </pages> <publisher> IEEE, </publisher> <year> 1991. </year> <month> 12 </month>
Reference-contexts: Therefore, we did not implement a secret communication sub-framework for this protocol. The delegation protocol we use is similar to the passport scheme described in [Sol88]. Our scheme is independent of any specific authentication protocol. Unlike the delegation protocols in Kerberos <ref> [VAB91] </ref> and the Distributed System Security Architecture (DSSA) [GM90] which generate new delegation keys used by the underlying encryption primitives, the delegation protocol we describe here needs no specific information about the particular authentication protocol in use.
References-found: 13

