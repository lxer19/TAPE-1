URL: http://www.daimi.aau.dk/~elascurn/purity.ps
Refering-URL: http://www.daimi.aau.dk/~elascurn/
Root-URL: http://www.daimi.aau.dk
Email: elascurn@daimi.aau.dk  
Title: A Java tmfl Bytecode Optimizer Using Side-effect Analysis  
Author: Lars R. Clausen 
Affiliation: Department of Computer Science Aarhus University  
Abstract: This paper describes Cream, an optimizer for Java byte-code using side-effect analysis to improve the optimizations. Dead code elimination and loop invariant removal is implemented and tested, as well as several variations of the side-effect analysis. The optimizer is tested on real-world applications such as itself and JavaSoft's Java compiler. Results show that the optimizations benefit a lot from the side-effect analysis. The best side-effect analysis gives five to ten times as many optimizations as without an analysis, and, in one case, makes a sped increase of 25 % possible.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: Using this information, many more optimizations of field accesses and method invocation become possible. In this paper, we describe a working implementation of Cream, an optimizer for Java bytecode, which performs dead-code elimination and loop-invariant removal using standard optimization techniques from <ref> [1] </ref>, as well as the side-effect analysis. It handles native code, exceptions and monitors, and optimizes large class collections successfully. In Section 2 we describe how we analyze Java byte-code. <p> This uses a standard analysis with kill- and gen-sets. The only difference is that stack variables are always considered killed when they are used. Cycle detection and dominance graph construction: Before doing loop invariant elimination, a cycle detector as in <ref> [1] </ref> is run, and a dominance graph is built. Dead code marking: The dead code marker considers all impure instructions, return instructions, and instructions that may alter the control flow, to be live.
Reference: [2] <author> John Banning. </author> <title> An efficient way to find side effects of procedure calls and aliases of variables. </title> <booktitle> POPL, </booktitle> <pages> pages 29-41, </pages> <year> 1979. </year>
Reference-contexts: There are several bytecode-to-C compilers [8] [10], which then use the C compiler for standard optimizations. While this gives many of the well-known optimizations, it does not take the special structure of an object-oriented language into account. Side-effect analysis was first thoroughly covered by Banning in <ref> [2] </ref>, and the methods improved upon by Kennedy and Cooper in [5]. These papers considered optimizing imperative languages, and thus did not consider classes and virtual functions. 6 Conclusions and future work We have defined and implemented an optimizer using inter-procedural side-effect analysis.
Reference: [3] <author> Doug Bell. </author> <title> Make Java fast: Optimize. </title> <journal> JavaWorld Magazine, </journal> <month> April </month> <year> 1996. </year>
Reference-contexts: Suns compiler has some inlining, though in versions before 1.1 it could break privacy of classes <ref> [3] </ref>. The only optimization they suggest is for the runtime system to calculate certain constants ahead of time. Cierniak and Li [4] have made a flexible compiler/optimizer using an intermediate representation.
Reference: [4] <author> Michael Cierniak and Wei Li. Briki: </author> <title> A flexible Java compiler. </title> <type> Technical Report TR 621, </type> <institution> University of Rochester, Computer Science Department, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Suns compiler has some inlining, though in versions before 1.1 it could break privacy of classes [3]. The only optimization they suggest is for the runtime system to calculate certain constants ahead of time. Cierniak and Li <ref> [4] </ref> have made a flexible compiler/optimizer using an intermediate representation. It is also able to optimize bytecode to bytecode, but their article does not mention any interprocedural analysis or actual results. This is the only optimizer we know of that are akin to Cream.
Reference: [5] <author> Keith D. Cooper and Ken Kennedy. </author> <title> Interprocedu-ral side-effect analysis in linear time. </title> <booktitle> PLDI, </booktitle> <pages> pages 57-66, </pages> <year> 1988. </year>
Reference-contexts: t t t t t t t t foo () bar () -x x x x x x x x x x GF qux () (write-only) ED The fastest way to find the real purity of the recursive methods is by finding the strongly connected components of the call graph <ref> [5] </ref> and treat them as one virtual node. Methods included in the same component will have the same purity, as they may at some time call any of the others. Finding the strongly-connected components has a well-known linear-time solution [11]. <p> While this gives many of the well-known optimizations, it does not take the special structure of an object-oriented language into account. Side-effect analysis was first thoroughly covered by Banning in [2], and the methods improved upon by Kennedy and Cooper in <ref> [5] </ref>. These papers considered optimizing imperative languages, and thus did not consider classes and virtual functions. 6 Conclusions and future work We have defined and implemented an optimizer using inter-procedural side-effect analysis.
Reference: [6] <author> Fritz Henglein. </author> <title> Breaking through the n 3 barrier: Faster object type inference. </title> <editor> In Benjamin Pierce, editor, </editor> <booktitle> Proc. 4th Int'l Workshop on Foundations of Object-Oriented Languages (FOOL), </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: Though this would not get rid of all virtual calls, it should still give a vast improvement. Type inference of this kind is well studied ([9], <ref> [6] </ref>), but outside the current scope of this project. Instead we have chosen the other, somewhat simpler solution, to make our analysis over all possible methods called.
Reference: [7] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <year> 1996. </year>
Reference-contexts: Section 3 describes the side-effect analysis and its effectiveness in our implementation, and Section 4 shows how it is used in Cream, and the resulting optimizations. Section 5 briefly describes related work, and Section 6 gives conclusions and future work. 2 Analyzing Java bytecode Java bytecode <ref> [7] </ref> is a simple, stack-based language with about 200 instructions, about 50 of which are special cases of other instructions. It is strongly typed, and contains information about the class structure.
Reference: [8] <author> G. Muller, B. Moura, F. Bellard, and C. Consel. Harissa: </author> <title> a flexible and efficient Java environment mixing bytecode and compiled code. </title> <note> To appear in Proceedings of COOTS'97, </note> <month> June </month> <year> 1997. </year>
Reference-contexts: It is also able to optimize bytecode to bytecode, but their article does not mention any interprocedural analysis or actual results. This is the only optimizer we know of that are akin to Cream. There are several bytecode-to-C compilers <ref> [8] </ref> [10], which then use the C compiler for standard optimizations. While this gives many of the well-known optimizations, it does not take the special structure of an object-oriented language into account. <p> Implementing common subexpression elimination would likely be worthwhile, as there are often long chains of fields accesses occuring more than once in a loop without being invariant. The results obtained here should be compared to what can be done using the Harissa bytecode-to-C translator <ref> [8] </ref>, both alone and together. Using an optimizing C compiler as backend gives local optimizations such as strength reduction and register allocation for free, and the large-scale optimizations suggested and partially in this paper will still be available. 7 Acknowledgements The optimizer is based on Clark Verbrugge's Coffi program [12].
Reference: [9] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference: [10] <author> Todd Proebsting, John Hartman, Gregg Townsend, Patrick Bridges, Tim Newsham, and Scott Wat-terson. Toba: </author> <title> A Java-to-C translator. </title> <type> Technical report, </type> <institution> University of Arizona, </institution> <year> 1997. </year>
Reference-contexts: It is also able to optimize bytecode to bytecode, but their article does not mention any interprocedural analysis or actual results. This is the only optimizer we know of that are akin to Cream. There are several bytecode-to-C compilers [8] <ref> [10] </ref>, which then use the C compiler for standard optimizations. While this gives many of the well-known optimizations, it does not take the special structure of an object-oriented language into account.
Reference: [11] <author> Robert Endre Tarjan. </author> <title> Fast algorithms for solving path problems. </title> <journal> Journal of the ACM, </journal> <volume> 28(3) </volume> <pages> 594-614, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: Methods included in the same component will have the same purity, as they may at some time call any of the others. Finding the strongly-connected components has a well-known linear-time solution <ref> [11] </ref>. By using these virtual nodes, we turn the call graph into a directed acyclic graph, where a simple depth-first traversal can be used to find the purities.
Reference: [12] <author> Clark Verbrugge. </author> <title> Using Coffi. </title> <type> Technical report, </type> <institution> McGill University, </institution> <month> October </month> <year> 1996. </year> <month> 9 </month>
Reference-contexts: Using an optimizing C compiler as backend gives local optimizations such as strength reduction and register allocation for free, and the large-scale optimizations suggested and partially in this paper will still be available. 7 Acknowledgements The optimizer is based on Clark Verbrugge's Coffi program <ref> [12] </ref>. Though some rewriting was necessary, it has turned out to be a good starting point for the program.
References-found: 12

