URL: http://st-www.cs.uiuc.edu/~hanmer/PLoP-97/Proceedings.ps/noble.ps
Refering-URL: http://st-www.cs.uiuc.edu/~hanmer/PLoP-97/Workshops.html
Root-URL: http://www.cs.uiuc.edu
Email: kjx@mri.mq.edu.au  
Author: James Noble 
Date: October 20, 1997  
Address: Sydney.  
Affiliation: MRI, School of MPCE, Macquarie University,  
Abstract: Arguments and Results Abstract If an object oriented program is a collection of communicating objects, then the objects' protocols define the languages the program speaks. Unfortunately, protocols are difficult to design in isolation, so many programs' protocols are not as well designed as they could be. This paper presents six patterns which describe how objects protocols can be designed or redesigned. By using these patterns, programs and designs can be made more simple, more general, and more easy to change.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ole Agesen, Lars Bak, Craig Chambers, Bay-Wei Chang, Urs Holzle, John Maloney, Randall B. Smith, David Ungar, and Mario Wolczko. </author> <title> The Self Programmer's Reference Manual. </title> <institution> Sun Microsystems and Stanford University, </institution> <address> 4.0 edition, </address> <year> 1995. </year>
Reference-contexts: The system's users could check the supporting logic to verify that the decisions were being made appropriately. The Self Programmer's Reference Manual describes how Result Objects can be used in Self to return multiple values from messages <ref> [1] </ref>. Result Objects are often used to provide error handling (resulting in Error Objects). Representing errors with Result Objects allows the errors to be queued as they occur, and displayed later to the user. These Result Objects can also provide textual descriptions of the errors, and appropriate help information.
Reference: [2] <author> Ken Auer and Kent Beck. </author> <title> Lazy optimization: Patterns for efficient smalltalk programming. </title> <booktitle> In Pattern Languages of Program Design, </booktitle> <volume> volume 2. </volume> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Design Patterns describes how ET++ uses Lazy Objects called virtual proxies to represent large images which may not need to be displayed [9]. Related Patterns Ken Auer and Kent Beck have described many similar patterns for optimising Smalltalk programs <ref> [2] </ref>. 13 Acknowledgements These patterns are revised versions of some patterns from the Found Objects pattern language [17], and were inspired by discussions on the patterns-discussion mailing list and the WikiWikiWeb. In particular, Kent Beck described Parameters Object [4] and suggested Result Object [3].
Reference: [3] <author> Kent Beck. </author> <title> Result object. </title> <address> http://c2.com/cgi/wiki?ResultObject. </address>
Reference-contexts: In particular, Kent Beck described Parameters Object [4] and suggested Result Object <ref> [3] </ref>. Patrick Logan noticed the similarity between these two patterns, David C. Laurence provided the Telecoms example for Result Object and Mike Koss described the use of Result Objects to handle errors. Authors and reviewers at the EuroPLOP'96 and PLOP'97 writers workshop provided many pertinent comments and suggestions.
Reference: [4] <author> Kent Beck. </author> <title> Parameters object. Email message sent to the patterns-digest list, </title> <month> March </month> <year> 1995. </year>
Reference-contexts: Smalltalk's Point and Rectangle objects can be seen as Arguments Objects which package up two or four integer arguments to describe points or rectangles <ref> [4] </ref>. Smalltalk also uses Message objects which record the arguments and name of a message which has caused an error [10]. 4 Related Patterns The following two patterns describe how Arguments Object can be applied in particular situations. <p> In particular, Kent Beck described Parameters Object <ref> [4] </ref> and suggested Result Object [3]. Patrick Logan noticed the similarity between these two patterns, David C. Laurence provided the Telecoms example for Result Object and Mike Koss described the use of Result Objects to handle errors.
Reference: [5] <author> Kent Beck. </author> <title> Smalltalk Best Practice Patterns. </title> <publisher> Prentice-Hall, </publisher> <year> 1996. </year>
Reference-contexts: If these patterns are applied injudiciously they will accelerate this process. 1 This is not limited solely to these patterns. Many other patterns have this effect, including those in Design Patterns [9] and Smalltalk Best Practice Patterns <ref> [5] </ref>, as do Parnas's criteria for program decomposition [19]. 2 Form The patterns are written in electric modified Portland form. Each begins with a question (in italics) describing a problem, followed by one paragraph describing the pattern's context, and a second describing the forces the pattern resolves.
Reference: [6] <author> Grady Booch. </author> <title> Object Oriented Analysis and Design with Applications. </title> <publisher> Benjamin Cummings, </publisher> <address> second edition, </address> <year> 1994. </year>
Reference-contexts: Curry [12]. The name Curried Object also suggests that this pattern is a little spicy and exotic, and probably not for the beginner. Known Uses Iterators are the most common kind of Curried Object, as they are used in many common languages and class libraries <ref> [9, 10, 6] </ref>. An iterator's server is a collection object, and the iterator maintains a slowly varying index into the collection. Many graphics systems use Curried Objects whose servers are views, as in the example above. For example, VisualWorks uses GraphicsContext objects [18] and Smalltalk/V uses Pen objects [15].
Reference: [7] <author> Brian Foote and Ralph E. Johnston. </author> <title> Reflective facilities in Smalltalk-80. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <year> 1989. </year>
Reference-contexts: A Future Object will also be more difficult to write than a 11 Result Object, although some languages are sufficiently flexible that a single generic Future Object can be written once and reused as necessary <ref> [7] </ref>. A Future Object cannot avoid the intrinsic problems imposed by concurrency: the program's performance will become less predictable, and harder to debug [16]. Also, this pattern should be applied only when the parallel computation is independent of the rest of the program. <p> Also, this pattern should be applied only when the parallel computation is independent of the rest of the program. Known Uses Future Objects are quite common in parallel and distributed computing. They were introduced in Multilisp [11] and have been used in Smalltalk <ref> [7] </ref> and Mushroom [13] amongst many other systems [16]. Related Patterns Future Object has been described briefly as part of the Active Object pattern [23].
Reference: [8] <author> Martin Fowler. </author> <title> Analysis Patterns. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: As well as simplifying client code, this also avoids the problems which would occur if the time was returned at one second before midnight, and the date one second afterwards. Martin Fowler discusses similar Result Objects called TimePoints <ref> [8] </ref>. An expert system used in Telecoms capacity planning used a Result Object to package the decisions it returned with the logic supporting the decisions. The system's users could check the supporting logic to verify that the decisions were being made appropriately.
Reference: [9] <author> Erich Gamma, Richard Helm, Ralph E. Johnson, and John Vlissides. </author> <title> Design Patterns. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: To quote Alan Perlis: In the long run every program becomes rococo | then rubble. [20]. If these patterns are applied injudiciously they will accelerate this process. 1 This is not limited solely to these patterns. Many other patterns have this effect, including those in Design Patterns <ref> [9] </ref> and Smalltalk Best Practice Patterns [5], as do Parnas's criteria for program decomposition [19]. 2 Form The patterns are written in electric modified Portland form. <p> This message should perform the essential function performed by the messages from the original protocol, and use the Selector Object argument to discriminate between the functions in detail (typically using multimethods or double dispatching <ref> [9] </ref>). Change the protocol's clients and servers to use the new protocol. In some cases, the Selector Object can be a very lightweight object, such as a symbol or enumeration, which is used only to determine the fine details of the function to be performed. <p> For example, VisualWorks uses symbols representing file access modes as arguments to messages to manage files [18]. Many OO graphics systems, again including VisualWorks, provide Geometric or Graphic objects which combine the Selector Object and Arguments Object (1) patterns. Related Patterns Lightweight Selector Objects can often be Flyweights <ref> [9] </ref>. 3 Curried Object How can you simplify an extremely complicated protocol? Over the course of a program, objects exchange messages, and the objects passed as arguments to these messages are usually different every time. <p> Curry [12]. The name Curried Object also suggests that this pattern is a little spicy and exotic, and probably not for the beginner. Known Uses Iterators are the most common kind of Curried Object, as they are used in many common languages and class libraries <ref> [9, 10, 6] </ref>. An iterator's server is a collection object, and the iterator maintains a slowly varying index into the collection. Many graphics systems use Curried Objects whose servers are views, as in the example above. For example, VisualWorks uses GraphicsContext objects [18] and Smalltalk/V uses Pen objects [15]. <p> Related Patterns Arguments Object (1) can provide a less radical alternative to Curried Object. The original server can act as an Abstract Factory <ref> [9] </ref> to create the Curried Object. A Curried Object can be similar to an object-level Adaptor [9], but where an adaptor allows an object to conform to an existing protocol, a Curried Object introduces a new, simpler protocol. <p> Related Patterns Arguments Object (1) can provide a less radical alternative to Curried Object. The original server can act as an Abstract Factory <ref> [9] </ref> to create the Curried Object. A Curried Object can be similar to an object-level Adaptor [9], but where an adaptor allows an object to conform to an existing protocol, a Curried Object introduces a new, simpler protocol. The Accumulator [25] pattern is a variant of Curried Object which simplifies the protocol used to create objects. <p> They were introduced in Multilisp [11] and have been used in Smalltalk [7] and Mushroom [13] amongst many other systems [16]. Related Patterns Future Object has been described briefly as part of the Active Object pattern [23]. A Future Object can be seen as a Proxy <ref> [9] </ref> for an object which hasn't been computed yet. 6 Lazy Object How can you answer a question that is easy to answer now, but that may never be asked? Some computations can best be performed immediately but the computation's result may never be needed. <p> The LOOM virtual memory system for Smalltalk used Lazy Objects called leaves to represent objects which were swapped out into secondary storage [14]. Design Patterns describes how ET++ uses Lazy Objects called virtual proxies to represent large images which may not need to be displayed <ref> [9] </ref>. Related Patterns Ken Auer and Kent Beck have described many similar patterns for optimising Smalltalk programs [2]. 13 Acknowledgements These patterns are revised versions of some patterns from the Found Objects pattern language [17], and were inspired by discussions on the patterns-discussion mailing list and the WikiWikiWeb.
Reference: [10] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Smalltalk's Point and Rectangle objects can be seen as Arguments Objects which package up two or four integer arguments to describe points or rectangles [4]. Smalltalk also uses Message objects which record the arguments and name of a message which has caused an error <ref> [10] </ref>. 4 Related Patterns The following two patterns describe how Arguments Object can be applied in particular situations. The number of message names in a protocol can be reduced by using a Selector Object (2). <p> Curry [12]. The name Curried Object also suggests that this pattern is a little spicy and exotic, and probably not for the beginner. Known Uses Iterators are the most common kind of Curried Object, as they are used in many common languages and class libraries <ref> [9, 10, 6] </ref>. An iterator's server is a collection object, and the iterator maintains a slowly varying index into the collection. Many graphics systems use Curried Objects whose servers are views, as in the example above. For example, VisualWorks uses GraphicsContext objects [18] and Smalltalk/V uses Pen objects [15].
Reference: [11] <author> Robert H. Halstead, Jr. </author> <title> Multilisp: A language for concurrent symbolic computation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(4) </volume> <pages> 501-538, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: Therefore: Make a Future Object which computes the answer in parallel. A Future Object is a Result Object (4) which computes an answer in a parallel thread, based on initial information supplied by the original server <ref> [11] </ref>. The Future Object should receive the computation's arguments from the server, and then cache any information which may change after the main computation resumes. The Future Object should handle the thread management | creating a new thread to perform the computation, and extracting the results when the thread completes. <p> Also, this pattern should be applied only when the parallel computation is independent of the rest of the program. Known Uses Future Objects are quite common in parallel and distributed computing. They were introduced in Multilisp <ref> [11] </ref> and have been used in Smalltalk [7] and Mushroom [13] amongst many other systems [16]. Related Patterns Future Object has been described briefly as part of the Active Object pattern [23].
Reference: [12] <author> Martin C. Henson. </author> <title> Elements of Functional Programming Languages. </title> <publisher> Blackwell Scientific, </publisher> <year> 1987. </year>
Reference-contexts: This pattern is called Curried Object because the underlying mechanism is partial function application, colloquially known as currying after the mathematician Haskell B. Curry <ref> [12] </ref>. The name Curried Object also suggests that this pattern is a little spicy and exotic, and probably not for the beginner. Known Uses Iterators are the most common kind of Curried Object, as they are used in many common languages and class libraries [9, 10, 6].
Reference: [13] <author> Trevor P. Hopkins and Mario Wolczko. </author> <title> Writing concurrent object-oriented programs using Smalltalk-80. </title> <journal> The Computer Journal, </journal> <volume> 32(4), </volume> <month> October </month> <year> 1989. </year>
Reference-contexts: Also, this pattern should be applied only when the parallel computation is independent of the rest of the program. Known Uses Future Objects are quite common in parallel and distributed computing. They were introduced in Multilisp [11] and have been used in Smalltalk [7] and Mushroom <ref> [13] </ref> amongst many other systems [16]. Related Patterns Future Object has been described briefly as part of the Active Object pattern [23]. <p> Known Uses The mushroom system implements a generic Lazy Object <ref> [13] </ref>. The LOOM virtual memory system for Smalltalk used Lazy Objects called leaves to represent objects which were swapped out into secondary storage [14]. Design Patterns describes how ET++ uses Lazy Objects called virtual proxies to represent large images which may not need to be displayed [9].
Reference: [14] <author> Ted Kaehler and Glenn Krasner. </author> <title> LOOM-large object-oriented memory for Smalltalk-80 systems. </title> <editor> In Glenn Krasner, editor, </editor> <title> Smalltalk-80: Bits of History, Words of Advice, chapter 14. </title> <publisher> aw, </publisher> <year> 1983. </year>
Reference-contexts: Known Uses The mushroom system implements a generic Lazy Object [13]. The LOOM virtual memory system for Smalltalk used Lazy Objects called leaves to represent objects which were swapped out into secondary storage <ref> [14] </ref>. Design Patterns describes how ET++ uses Lazy Objects called virtual proxies to represent large images which may not need to be displayed [9].
Reference: [15] <author> Wilf Lalonde. </author> <title> Discovering Smalltalk. </title> <address> Benjamin/Cummings, </address> <year> 1994. </year>
Reference-contexts: An iterator's server is a collection object, and the iterator maintains a slowly varying index into the collection. Many graphics systems use Curried Objects whose servers are views, as in the example above. For example, VisualWorks uses GraphicsContext objects [18] and Smalltalk/V uses Pen objects <ref> [15] </ref>. VisualWorks also includes MessageSend objects, a curried version of the Message Arguments Object (1). MessageSend inherits from Message, and adds an extra variable to store the message's receiver, allowing a message to sent without an explicit reference to the ultimate receiver object.
Reference: [16] <author> Doug Lea. </author> <title> Concurrent Programming in Java. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: A Future Object cannot avoid the intrinsic problems imposed by concurrency: the program's performance will become less predictable, and harder to debug <ref> [16] </ref>. Also, this pattern should be applied only when the parallel computation is independent of the rest of the program. Known Uses Future Objects are quite common in parallel and distributed computing. <p> Known Uses Future Objects are quite common in parallel and distributed computing. They were introduced in Multilisp [11] and have been used in Smalltalk [7] and Mushroom [13] amongst many other systems <ref> [16] </ref>. Related Patterns Future Object has been described briefly as part of the Active Object pattern [23].
Reference: [17] <author> James Noble. </author> <title> Found objects, </title> <note> 1996. Reviewed at EuroPLOP. </note>
Reference-contexts: Related Patterns Ken Auer and Kent Beck have described many similar patterns for optimising Smalltalk programs [2]. 13 Acknowledgements These patterns are revised versions of some patterns from the Found Objects pattern language <ref> [17] </ref>, and were inspired by discussions on the patterns-discussion mailing list and the WikiWikiWeb. In particular, Kent Beck described Parameters Object [4] and suggested Result Object [3]. Patrick Logan noticed the similarity between these two patterns, David C.
Reference: [18] <author> ParcPlace Systems. </author> <title> VisualWorks Smalltalk User's Guide, </title> <address> 2.0 edition, </address> <year> 1994. </year>
Reference-contexts: Known Uses Selector Objects are often used to build object oriented interfaces to existing file or graphics systems. For example, VisualWorks uses symbols representing file access modes as arguments to messages to manage files <ref> [18] </ref>. Many OO graphics systems, again including VisualWorks, provide Geometric or Graphic objects which combine the Selector Object and Arguments Object (1) patterns. <p> An iterator's server is a collection object, and the iterator maintains a slowly varying index into the collection. Many graphics systems use Curried Objects whose servers are views, as in the example above. For example, VisualWorks uses GraphicsContext objects <ref> [18] </ref> and Smalltalk/V uses Pen objects [15]. VisualWorks also includes MessageSend objects, a curried version of the Message Arguments Object (1). MessageSend inherits from Message, and adds an extra variable to store the message's receiver, allowing a message to sent without an explicit reference to the ultimate receiver object. <p> These Result Objects can also provide textual descriptions of the errors, and appropriate help information. For example, VisualWorks includes SystemError objects, Result Objects which package together return codes and identifying arguments from errors occurring outside the system <ref> [18] </ref>. 10 Related Patterns If the question can be answered in parallel, try Future Object (5).
Reference: [19] <author> David Lorge Parnas, Paul C. Clements, and David M. Weiss. </author> <title> The modular structure of complex systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(3), </volume> <month> March </month> <year> 1985. </year>
Reference-contexts: If these patterns are applied injudiciously they will accelerate this process. 1 This is not limited solely to these patterns. Many other patterns have this effect, including those in Design Patterns [9] and Smalltalk Best Practice Patterns [5], as do Parnas's criteria for program decomposition <ref> [19] </ref>. 2 Form The patterns are written in electric modified Portland form. Each begins with a question (in italics) describing a problem, followed by one paragraph describing the pattern's context, and a second describing the forces the pattern resolves.
Reference: [20] <author> Alan Perlis. </author> <title> Epigrams on programming. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 17(9), </volume> <month> September </month> <year> 1982. </year>
Reference-contexts: As a result, although objects may be easier to understand in isolation, the global design of the program may become confused. To quote Alan Perlis: In the long run every program becomes rococo | then rubble. <ref> [20] </ref>. If these patterns are applied injudiciously they will accelerate this process. 1 This is not limited solely to these patterns. <p> To quote Alan Perlis: If you have a procedure with 10 parameters, you probably missed some <ref> [20] </ref>. Therefore: Make an Arguments Object to capture the common parts of the protocol. In its simplest form, an Arguments Object should have one variable for each argument to be eliminated from the protocol, and the usual messages to access and update its variables.
Reference: [21] <author> Nat Pryce. </author> <title> Type-safe session. </title> <booktitle> In EuroPLOP'97 Proceedings, </booktitle> <year> 1997. </year>
Reference-contexts: The Accumulator [25] pattern is a variant of Curried Object which simplifies the protocol used to create objects. The Type-Safe Session pattern is a Curried Object which emphasises type safety <ref> [21] </ref>. Patterns about Results Many messages ask questions of the objects to which they are sent, and the results of these messages are the answers to these questions.
Reference: [22] <author> Robert W. Scheifler and Jim Gettys. </author> <title> The X Window System. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5(2), </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: Known Uses MacApp uses Event objects to package the arguments sent to widgets in response to user actions [24]. The X Window System's drawing operations use GraphicsContexts to package up a large number of arguments such as the font, colour, line width, and clip region <ref> [22] </ref>. Smalltalk's Point and Rectangle objects can be seen as Arguments Objects which package up two or four integer arguments to describe points or rectangles [4].
Reference: [23] <author> Douglas C. Schmidt and Charles D. Cranor. </author> <title> Active object: An object behavioral pattern for concurrent programming. </title> <booktitle> In Pattern Languages of Program Design, </booktitle> <volume> volume 2. </volume> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: Known Uses Future Objects are quite common in parallel and distributed computing. They were introduced in Multilisp [11] and have been used in Smalltalk [7] and Mushroom [13] amongst many other systems [16]. Related Patterns Future Object has been described briefly as part of the Active Object pattern <ref> [23] </ref>.
Reference: [24] <author> Kurt Schmucker. MacApp: </author> <title> an application framework. </title> <journal> Byte, </journal> <volume> 11(8), </volume> <year> 1986. </year>
Reference-contexts: As with all these patterns, this pattern introduces an additional object into the design, requiring modifications to the program and increasing runtime space and time costs. Known Uses MacApp uses Event objects to package the arguments sent to widgets in response to user actions <ref> [24] </ref>. The X Window System's drawing operations use GraphicsContexts to package up a large number of arguments such as the font, colour, line width, and clip region [22].
Reference: [25] <author> Phillip M. Yelland. </author> <title> Creating host compliance in a portable framework: A study in the use of existing design patterns. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <year> 1996. </year>
Reference-contexts: The original server can act as an Abstract Factory [9] to create the Curried Object. A Curried Object can be similar to an object-level Adaptor [9], but where an adaptor allows an object to conform to an existing protocol, a Curried Object introduces a new, simpler protocol. The Accumulator <ref> [25] </ref> pattern is a variant of Curried Object which simplifies the protocol used to create objects. The Type-Safe Session pattern is a Curried Object which emphasises type safety [21].
Reference: [26] <author> Walter Zimmer. </author> <title> Relationships between design patterns. In Pattern Languages of Program Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year> <month> 14 </month>
Reference-contexts: Figure 2 also illustrates two relationships between the patterns. One pattern can refine another pattern, meaning one pattern is a more specific version of the other. Alternatively, patterns can conflict, meaning that the patterns are mutually exclusive, each providing a different solution to a similar problem <ref> [26] </ref>. Forces Each of these patterns resolves a number of different forces, and some conflicting patterns resolve similar problems in different ways.
References-found: 26

