URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS93-02.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Bounded Timestamps in Process Networks  
Author: Ambuj K. Singh 
Date: June 30, 1992  
Address: Santa Barbara, California 93106  
Affiliation: Department of Computer Science University of California at Santa Barbara  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Birman, K., A. Schiper, and P. Stephenson, </author> <title> "Lightweight Causal and Atomic Group Broadcast", </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9:3, </volume> <pages> pp. 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Timestamps are a useful mechanism for understanding and analyzing the causality of distributed computation. They have been used to solve a wide class of problems including mutual exclusion [8], recovery [7], debugging [3, 4], and causal broadcasts <ref> [1] </ref>. A significant drawback of the existing implementation of timestamps is that they become potentially unbounded in size. As a result, algorithms based on timestamps must allow for unbounded messages or rely upon some techniques for global resetting of timestamps [1]. <p> exclusion [8], recovery [7], debugging [3, 4], and causal broadcasts <ref> [1] </ref>. A significant drawback of the existing implementation of timestamps is that they become potentially unbounded in size. As a result, algorithms based on timestamps must allow for unbounded messages or rely upon some techniques for global resetting of timestamps [1]. In this paper we investigate the reusability of timestamps and present a simple implementation of bounded timestamps. <p> The updating and the communication of timestamps is achieved by the following set of actions. * Upon occurrence of an event, process i advances its current timestamp cts by incrementing the field cts [i] modulo 2flsize1. If the set of current values is exhausted, i.e., cts [i] = window <ref> [1] </ref>, then the process is blocked until window [1] advances. * When process i sends a message to process j, it attaches its current timestamp cts, the most recent timestamp received from process j recent j , and a set of values old k for each k such that process j <p> If the set of current values is exhausted, i.e., cts [i] = window <ref> [1] </ref>, then the process is blocked until window [1] advances. * When process i sends a message to process j, it attaches its current timestamp cts, the most recent timestamp received from process j recent j , and a set of values old k for each k such that process j is the parent of process i in T
Reference: [2] <author> Chandy, K. M., and J. Misra, </author> <title> Parallel Program Design: A Foundation, </title> <address> Reading, Mas-sachusetts: </address> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Process i can reuse value m once all the processes in the network have become black. A number of mechanisms can be used for inferring whether a process has become black and for inferring whether all the processes in the network have become black <ref> [2] </ref>. We outline one such combination of mechanisms next. We construct a spanning tree with process i as the root.
Reference: [3] <author> Cooper, R., and K. Marzullo, </author> <title> "Consistent Detection of Global Predicates", </title> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <address> Santa Cruz, </address> <pages> pp. 163-173, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Timestamps are a useful mechanism for understanding and analyzing the causality of distributed computation. They have been used to solve a wide class of problems including mutual exclusion [8], recovery [7], debugging <ref> [3, 4] </ref>, and causal broadcasts [1]. A significant drawback of the existing implementation of timestamps is that they become potentially unbounded in size. As a result, algorithms based on timestamps must allow for unbounded messages or rely upon some techniques for global resetting of timestamps [1].
Reference: [4] <author> Fowler, J., and W. Zwaenepoel, </author> <title> "Causal Distributed Breakpoints", </title> <booktitle> Proceedings of the 10th International Conference on Distributed Systems, Paris, France, </booktitle> <pages> pp. 131 - 141, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Timestamps are a useful mechanism for understanding and analyzing the causality of distributed computation. They have been used to solve a wide class of problems including mutual exclusion [8], recovery [7], debugging <ref> [3, 4] </ref>, and causal broadcasts [1]. A significant drawback of the existing implementation of timestamps is that they become potentially unbounded in size. As a result, algorithms based on timestamps must allow for unbounded messages or rely upon some techniques for global resetting of timestamps [1].
Reference: [5] <author> Herlihy, M., </author> <title> "Wait-Free Implementations of Concurrent Objects," </title> <booktitle> Proceedings of the Sixth ACM Symposium on the Principles of Distributed Computing, </booktitle> <year> 1988, </year> <pages> pp. 276 - 290. </pages>
Reference-contexts: The problem is more difficult to solve in that setting on account of the constraints of wait-freedom <ref> [5] </ref>. The same constraint cannot be applied to message-passing networks as any communication necessarily involves waiting. 4 The number of active values that a process should allow for at any time depends upon the frequency of communication between neighbors, the height of the spanning trees, and the message transmission delay.
Reference: [6] <author> Israeli, A., and M. Li, </author> <title> "Bounded Time-stamps", </title> <booktitle> Proceedings of Twenty-eighth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pp. 371 - 382, </pages> <year> 1987. </year>
Reference-contexts: To clarify, we define a timestamping system similar to the sequential timestamp system defined by Israeli and Li <ref> [6] </ref>. As in there, we define a directed graph in which each node contains a value (a timestamp component corresponding to a process). A directed edge u ! v denotes that u is an older value than v. <p> i &gt; window [0] then window := (old i ; old i (size 1)), i.e., updates the set of values that can be used if some old values have disappeared from the network. 4 Discussion A number of authors have considered the question of bounded timestamps in shared variable systems <ref> [6] </ref>. The problem is more difficult to solve in that setting on account of the constraints of wait-freedom [5].
Reference: [7] <author> Johnson, D. B., and W. Zwaenepoel, </author> <title> "Recovery in Distributed Systems Using Optimistic Message Logging and Checkpointing", </title> <journal> Journal of Algorithms, </journal> <volume> 11:3, </volume> <pages> pp. 462-491, </pages> <month> Sep. </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Timestamps are a useful mechanism for understanding and analyzing the causality of distributed computation. They have been used to solve a wide class of problems including mutual exclusion [8], recovery <ref> [7] </ref>, debugging [3, 4], and causal broadcasts [1]. A significant drawback of the existing implementation of timestamps is that they become potentially unbounded in size. As a result, algorithms based on timestamps must allow for unbounded messages or rely upon some techniques for global resetting of timestamps [1].
Reference: [8] <author> Lamport, L., </author> <title> "Time, Clock, and the Ordering of Events in a Distributed System", </title> <journal> Communications of the ACM , 21:7, </journal> <month> July </month> <year> 1978, </year> <pages> pp. 558 - 565. 5 </pages>
Reference-contexts: 1 Introduction Timestamps are a useful mechanism for understanding and analyzing the causality of distributed computation. They have been used to solve a wide class of problems including mutual exclusion <ref> [8] </ref>, recovery [7], debugging [3, 4], and causal broadcasts [1]. A significant drawback of the existing implementation of timestamps is that they become potentially unbounded in size. As a result, algorithms based on timestamps must allow for unbounded messages or rely upon some techniques for global resetting of timestamps [1]. <p> As a result, algorithms based on timestamps must allow for unbounded messages or rely upon some techniques for global resetting of timestamps [1]. In this paper we investigate the reusability of timestamps and present a simple implementation of bounded timestamps. Recall the mechanism used for updating and communicating timestamps <ref> [8, 9] </ref>. * Initially the current timestamp of every process is initialized to 0. * Upon the occurrence of an event, a process advances its current timestamp. <p> The functions next and sup are implemented so that the causality of events corresponds to their timestamps. Thus, in the scalar timestamps mechanism of Lamport <ref> [8] </ref>, function next returns the next natural number and function sup is defined to be the maximum of naturals. In the vector timestamps mechanism [9], on the other hand, function next increments the process's component of the timestamp and function sup is defined to be element-wise maximum of vectors.
Reference: [9] <author> Mattern, F., </author> <title> "Virtual Time and Global States in Distributed Systems", in Parallel and Distributed Algorithms, </title> <editor> M. Cosnard et al. (eds.), </editor> <publisher> Elsevier/North Holland, </publisher> <pages> pp. 215-226, </pages> <year> 1989. </year>
Reference-contexts: As a result, algorithms based on timestamps must allow for unbounded messages or rely upon some techniques for global resetting of timestamps [1]. In this paper we investigate the reusability of timestamps and present a simple implementation of bounded timestamps. Recall the mechanism used for updating and communicating timestamps <ref> [8, 9] </ref>. * Initially the current timestamp of every process is initialized to 0. * Upon the occurrence of an event, a process advances its current timestamp. <p> The functions next and sup are implemented so that the causality of events corresponds to their timestamps. Thus, in the scalar timestamps mechanism of Lamport [8], function next returns the next natural number and function sup is defined to be the maximum of naturals. In the vector timestamps mechanism <ref> [9] </ref>, on the other hand, function next increments the process's component of the timestamp and function sup is defined to be element-wise maximum of vectors.
References-found: 9

