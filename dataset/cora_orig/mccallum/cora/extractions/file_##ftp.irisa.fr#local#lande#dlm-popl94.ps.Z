URL: file://ftp.irisa.fr/local/lande/dlm-popl94.ps.Z
Refering-URL: http://www.irisa.fr/lande/LeMetayer.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Deriving algorithms from type inference systems: Application to strictness analysis  
Author: Chris Hankin Daniel Le Metayer INRIA/IRISA 
Address: LONDON SW7 2BZ, UK  35042 RENNES CEDEX, FRANCE  
Affiliation: Department of Computing, Imperial College,  Campus de Beaulieu  
Abstract: The role of non-standard type inference in static program analysis has been much studied recently. Early work em-phasised the efficiency of type inference algorithms and paid little attention to the correctness of the inference system. Recently more powerful inference systems have been investigated but the connection with efficient inference algorithms has been obscured. The contribution of this paper is twofold: first we show how to transform a program logic into an algorithm and, second, we introduce the notion of lazy types and show how to derive an efficient algorithm for strictness analysis. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. van Bakel, </author> <title> Complete restrictions of the intersection type discipline, </title> <journal> Theoretical Computer Science, </journal> <volume> 102(1) </volume> <pages> 135-163, </pages> <year> 1992. </year>
Reference-contexts: Also an entailment relation is defined on types and the corresponding type inference system includes a weakening rule. This is enough to make type inference a non trivial task (let us notice however that such a system does not suffer the undecidability problem of more powerful intersection type systems <ref> [1, 2] </ref>: this is because we are working with the simply typed calculus). We first define a notion of most general type which is equivalent to the conjunction of all the types of an expression. <p> We define = as the equivalence induced by the ordering on types: = t , t and t 3 Most General Types We introduce a slightly restricted language of strictness formulae in Fig. 2; this language is closely related to van Bakel's strict types <ref> [1] </ref>. Basically strict types do not allow intersections on the right hand side of an arrow. <p> First we show that the weakening rule can be removed from ` T without changing the set of derivable types provided we add a form of weakening in the Var, Fix and Cond rules. A similar property has been proved for other type systems including a form of weakening <ref> [1, 21] </ref>. Then we use theorems 5.5 and 5.6 and proceed by induction on e to prove completeness. 6 The lazy types algorithm Applying the same techniques as in Section 4, we can derive an algorithm from the lazy type inference system. <p> x : 2 Taut ` G c : t Abs ` G x:e : ( ! ) ` G e 1 : ((; e 2 ) ! ) Fix n ^ i ! 1 ) ^ . . . ^ ( i=1 ` G fix (g:e) : k (k 2 <ref> [1; n] </ref>) Cond-1 ` G e 1 : f ` G cond (e 1 ; e 2 ; e 3 ) : Cond-2 ` G e 2 : ` G e 3 : ` G cond (e 1 ; e 2 ; e 3 ) : illustrating the treatment of recursion <p> We briefly review related work in these two areas before discussing further work. The techniques we have used in the first stage of our refinements (Sections 3 and 5) are related to previous work on restricting type systems (see for instance [21] for a type system with subtypes and <ref> [1] </ref> for a type system with conjunction types and subtypes), especially the transformations required to remove weakening. Our approach to the development of abstract machines from logics (Sections 4 and 6) is closely related to Hannan's and Miller's [11].
Reference: [2] <author> H. Barendregt, M. Coppo, M. Dezani-Ciancaglini, </author> <title> A filter lambda model and the completeness of type assignment, </title> <journal> Journal of Symbolic Logic, </journal> <volume> 48(4), </volume> <year> 1983. </year>
Reference-contexts: Also an entailment relation is defined on types and the corresponding type inference system includes a weakening rule. This is enough to make type inference a non trivial task (let us notice however that such a system does not suffer the undecidability problem of more powerful intersection type systems <ref> [1, 2] </ref>: this is because we are working with the simply typed calculus). We first define a notion of most general type which is equivalent to the conjunction of all the types of an expression.
Reference: [3] <author> P. N. Benton, </author> <title> Strictness logic and polymorphic invari-ance, </title> <booktitle> in Proceedings of the 2nd Int. Symposium on Logical Foundations of Computer Science, </booktitle> <publisher> LNCS 620, Springer Verlag, </publisher> <year> 1992. </year>
Reference: [4] <author> T.-R. Chuang and B. Goldberg, </author> <title> A syntactic approach to fixed point computation on finite domains, </title> <booktitle> in Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: The main technical contribution of the paper is the notion of lazy types and the corresponding type system and algorithm. This addresses an issue that has taxed the abstract interpretation community greatly. The papers <ref> [4, 5, 7, 8, 9, 13, 16, 18] </ref> all tackle the same issue. The basic problem is that the choice to abstract functions by functions is a disastrous one for the efficiency of the analysis. <p> The basic problem is that the choice to abstract functions by functions is a disastrous one for the efficiency of the analysis. We can classify the various proposals to circumvent the problem into two categories: (1) some of them <ref> [4, 8, 13, 16] </ref> strive for a better representation of abstract functions to improve their computation without losing completeness (with respect to the system of Section 2) while (2) others [6, 7, 9, 18] trade a cheaper implementation of the fixed point against a loss of accuracy.
Reference: [5] <author> C. Clack and S. L. Peyton Jones, </author> <title> Strictness Analysis </title> - 
Reference-contexts: The correctness is shown with respect to the brute force algorithm by a routine inductive argument. 4.3 The frontiers machine Considering first-order functions, the machine of the last subsection effectively computes a truth-table representation of the function. Clack and Peyton Jones <ref> [5] </ref> proposed an alternative representation of first-order functions: rather than representing a function by its truth table, one could just record the maximal argument values at which the result was 0 this gives a compact representation from which the truth table could be reconstructed. <p> The main technical contribution of the paper is the notion of lazy types and the corresponding type system and algorithm. This addresses an issue that has taxed the abstract interpretation community greatly. The papers <ref> [4, 5, 7, 8, 9, 13, 16, 18] </ref> all tackle the same issue. The basic problem is that the choice to abstract functions by functions is a disastrous one for the efficiency of the analysis.
References-found: 5

