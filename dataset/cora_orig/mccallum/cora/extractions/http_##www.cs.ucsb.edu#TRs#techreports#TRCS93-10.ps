URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS93-10.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Semantics-based Time Warp Protocols  
Author: Hong Va Leong Divyakant Agrawal 
Keyword: message semantics, commutativity, distributed discrete event simulation, time warp, rollback  
Address: Santa Barbara, CA 93106  
Affiliation: Department of Computer Science University of California  
Abstract: The time warp mechanism is one of the useful paradigms to carry out a distributed discrete event simulation, where the synchronization of events can be determined a priori when the program is being executed. The forward computation performed optimistically has to be rolled back when an out-of-order synchronization message is received. This excessive amount of rollback seriously jeopardizes the performance of a time warp mechanism. Semantics of the synchronization messages being sent in a time warp execution can be exploited to reduce the amount of rollback. In particular, the commutativity and dependency properties of messages can be used to avoid certain types of rollback. For example, two commutative messages can be processed in any order and the resultant computation remains valid. In this paper, the semantics on the messages are defined and the protocols for handling such kinds of messages in the time warp mechanism and several optimizations are presented. fl An abridged version of this paper appears in the Proceedings of the 7th International Workshop on Distributed Algorithms as Using Message Semantics to Reduce Rollback in the Time Warp Mechanism. y This research is supported by the National Science Foundation under grant number IRI-9117094. 
Abstract-found: 1
Intro-found: 1
Reference: [ABHN91] <author> Mustaque Ahamad, James E. Burns, Phillip W. Hutto, and Gil Neiger. </author> <title> Causal memory. </title> <type> Technical report, </type> <institution> Georgia Institute of Technology, College of Computing, Atlanta, GA30332-2593, </institution> <year> 1991. </year>
Reference-contexts: 1 Introduction Synchronization of parallel programs in a message passing system is an important research topic that crosses several disciplines in computer science: distributed computing, computer architectures, and programming languages. Several synchronization mechanisms and models have been proposed to simplify the design of parallel or concurrent programs <ref> [CM88, BJKS88, LH89, BND89, ABHN91] </ref>. In general, the main source of complexity in synchronizing parallel programs is due to the nondeterministic nature of interactions among processes in the parallel programs.
Reference: [BJKS88] <author> K.P. Birman, T.A. Joseph, K. Kane, and F. Schmuck. </author> <title> ISIS a distributed programming environment user's guide and reference manual. </title> <type> Technical report, </type> <institution> Cornell University, Department of Computer Science, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Synchronization of parallel programs in a message passing system is an important research topic that crosses several disciplines in computer science: distributed computing, computer architectures, and programming languages. Several synchronization mechanisms and models have been proposed to simplify the design of parallel or concurrent programs <ref> [CM88, BJKS88, LH89, BND89, ABHN91] </ref>. In general, the main source of complexity in synchronizing parallel programs is due to the nondeterministic nature of interactions among processes in the parallel programs.
Reference: [BL92] <author> R.L. Bagrodia and W.T. Liao. </author> <title> Transparent optimizations of overheads in optimistic simulations. </title> <booktitle> In Proceedings of the 1992 Winter Simulation Conference, </booktitle> <pages> pages 637-645, </pages> <year> 1992. </year>
Reference-contexts: Sokol, Stucky and Hwang [SSH89] have proposed the Moving Time Window system which employs the notions of non-side-effecting and side-effecting messages (corresponding to the read and write operations). The arrivals of out-of-order non-side-effecting messages do not necessitate a rollback, since they do not change the object-state. Bagrodia and Liao <ref> [BL92] </ref> introduced "associative" messages that can be used with TWM. Their notion of association is commutative in nature and an associative sequence of messages guarantees the same final state and the same set of output messages whenever it is permuted, but detecting the sequence is extremely difficult, if not impossible.
Reference: [BND89] <author> Amotz Bar-Noy and Danny Dolev. </author> <title> Shared memory vs message passing in an asynchronous distributed environment. </title> <booktitle> In Proceedings of the 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 307-318. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Synchronization of parallel programs in a message passing system is an important research topic that crosses several disciplines in computer science: distributed computing, computer architectures, and programming languages. Several synchronization mechanisms and models have been proposed to simplify the design of parallel or concurrent programs <ref> [CM88, BJKS88, LH89, BND89, ABHN91] </ref>. In general, the main source of complexity in synchronizing parallel programs is due to the nondeterministic nature of interactions among processes in the parallel programs.
Reference: [CM79] <author> K.M. Chandy and J. Misra. </author> <title> Distributed simulation: A case study in design and verification of distributed programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(9) </volume> <pages> 440-452, </pages> <month> Sept </month> <year> 1979. </year>
Reference-contexts: The Time Warp Mechanism (TWM) [Jef85] is an implementation of virtual time in a message passing environment, in which the processes of a parallel program are synchronized using partial rollback instead of the conventional method of blocking <ref> [CM79] </ref>. The TWM synchronizes a set of processes corresponding to a parallel program or a distributed simulation over a message passing system. Each process has a logical clock that is used to maintain the virtual time at that process.
Reference: [CM88] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Synchronization of parallel programs in a message passing system is an important research topic that crosses several disciplines in computer science: distributed computing, computer architectures, and programming languages. Several synchronization mechanisms and models have been proposed to simplify the design of parallel or concurrent programs <ref> [CM88, BJKS88, LH89, BND89, ABHN91] </ref>. In general, the main source of complexity in synchronizing parallel programs is due to the nondeterministic nature of interactions among processes in the parallel programs.
Reference: [DR90] <author> P.M. Dickens and P.F. Reynold. </author> <title> SRADS with local rollback. </title> <booktitle> In Proceedings of the SCS Multiconference on Distributed Simulation, </booktitle> <pages> pages 161-164, </pages> <month> Jan </month> <year> 1990. </year>
Reference-contexts: Several optimizations have been suggested to address the problem of rollback in the TWM such as limiting the forward progress of the computation as in the Moving Time Windows scheme [SSH89] or by limiting the propagation of messages <ref> [DR90, Ste91] </ref>. Another popular technique is called lazy cancellation of output messages [Gaf88]. In lazy cancellation, output messages are not annihilated as soon as a process rolls back. Instead, these messages are cancelled lazily (if necessary 1 ) during the forward re-execution of the process.
Reference: [Fuj90] <author> R. Fujimoto. </author> <title> Parallel distributed discrete event simulation. </title> <journal> Communications of the ACM, </journal> <volume> 33(10) </volume> <pages> 30-53, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The non-determinism is inherent in such environments due to the asynchrony of message passing systems and due to the uncertainty of the relative speeds of process execution in parallel programs. For a class of parallel programs corresponding to distributed discrete event simulation <ref> [Mis86, Fuj90] </ref>, the synchronization complexity can be greatly reduced by eliminating non-determinism of execution order. <p> However, it is still advantageous to develop optimizations, that can be used to minimize rollback in the TWM, resulting in better performance. Rollback cost is not high in practical systems, but the cost of wasted forward computation due to rollback is extremely high <ref> [Fuj90] </ref>. It is therefore important to reduce rollback distance and limit the effect of a rollback.
Reference: [Gaf88] <author> A. Gafni. </author> <title> Rollback mechanisms for optimistic distributed simulation systems. </title> <booktitle> In Proceedings of the SCS Multiconference on Distributed Simulation, </booktitle> <pages> pages 61-67, </pages> <month> July </month> <year> 1988. </year> <month> 20 </month>
Reference-contexts: Another popular technique is called lazy cancellation of output messages <ref> [Gaf88] </ref>. In lazy cancellation, output messages are not annihilated as soon as a process rolls back. Instead, these messages are cancelled lazily (if necessary 1 ) during the forward re-execution of the process. Furthermore, the technique of lazy re-evaluation has also been proposed [Wes88].
Reference: [HW91] <author> M. P. Herlihy and W. E. Weihl. </author> <title> Hybrid Concurrency Control for Abstract Data Types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43(1) </volume> <pages> 25-61, </pages> <month> August </month> <year> 1991. </year> <booktitle> Special issue on the 7th Annual ACM SIGACT-SIGMOD Symposium on the Principles of Database Systems, </booktitle> <month> March 21-23, </month> <year> 1988. </year>
Reference-contexts: In particular, we demonstrate how the type-specific properties such as commutativ-ity [Kor83, SS84, Wei89] and invalidated-by <ref> [HW91] </ref> relations on operations on a set object can be used to reduce rollback in the system. A set object supports three types of operations: insert, delete, and member. Two insert operations commute, since the ordering of elements in a set is irrelevant. <p> An example is the notion of commutativity between two operations. In particular, we are using the right-backward commute relation [Wei89] and the invalidated-by relation <ref> [HW91] </ref>. Definition 1 An operation q is said to right commute backward with another operation p whenever for all sequences h, if h p q is valid then h q p is valid and equivalent to h p q.
Reference: [Jef85] <author> David Jefferson. </author> <title> Virtual time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(3) </volume> <pages> 404-425, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: In particular, since events in a distributed discrete event simulation are determined a priori, the ordering constraints of events can be enforced internally instead of relying on the real time execution of the parallel program to determine the ordering of events. Jefferson <ref> [Jef85] </ref> proposed the notion of virtual time for synchronizing processes in distributed discrete event simulation. Unlike real time, virtual time is not a monotonically increasing, single-valued function, but rather it allows different portions of a computation to advance and retract their own relative times, dynamically preserving the precedence constraints. <p> Unlike real time, virtual time is not a monotonically increasing, single-valued function, but rather it allows different portions of a computation to advance and retract their own relative times, dynamically preserving the precedence constraints. The Time Warp Mechanism (TWM) <ref> [Jef85] </ref> is an implementation of virtual time in a message passing environment, in which the processes of a parallel program are synchronized using partial rollback instead of the conventional method of blocking [CM79]. <p> This rollback is accomplished by restoring an older state of the process and by withdrawing (annihilating) all output messages that were sent after the rollbacked virtual time. The annihilation of output messages may result in the rollback of other processes. Jefferson <ref> [Jef85] </ref> has shown that despite such rollbacks, there exists a nondecreasing systemwide virtual time called global virtual time, such that no process will rollback below the current global virtual time. 1 One of the main drawbacks of the TWM is the phenomenon of cascading rollback, i.e., rollback at a process causing <p> Thus, although the SV T of the response of ins (x)@4 is set to 4, the correct response as well as the correct state fx; yg is generated by executing ins (x)@4 after virtual time 14 instead of at the intended virtual time 4. 2 See <ref> [Jef85] </ref> for a discussion of regular (positive) and anti (negative) messages, which are analogous to the concept of matter and anti-matter in particle physics. 4 Next, we give an example to illustrate that commutativity of operation is not always applicable to avoid rollback.
Reference: [Kor83] <author> H. F. Korth. </author> <title> Locking primitives in a database system. </title> <journal> Journal of the ACM, </journal> <volume> 30(1) </volume> <pages> 55-79, </pages> <month> Jan </month> <year> 1983. </year>
Reference-contexts: As a result, messages destined to these objects can be interpreted as operation invocations whereas messages sent out from these objects can be interpreted as operation responses. The type-specific properties, e.g., the commutativity relation <ref> [Kor83, SS84, Wei89] </ref> among operations, of the objects in the TWM can now be used to alleviate the rollback problem. Informally, we say that two operations commute if the resultant state is independent of the order of execution of the two operations. <p> We conclude the paper with a brief discussion of our results. 2 Motivation In this section, we use an example of a time warp execution that consists of a process implementing a set object. In particular, we demonstrate how the type-specific properties such as commutativ-ity <ref> [Kor83, SS84, Wei89] </ref> and invalidated-by [HW91] relations on operations on a set object can be used to reduce rollback in the system. A set object supports three types of operations: insert, delete, and member. Two insert operations commute, since the ordering of elements in a set is irrelevant.
Reference: [LA93] <author> H.V. Leong and D. Agrawal. </author> <title> Using message semantics to reduce rollback in optimistic message logging recovery schemes. </title> <type> Technical report, </type> <institution> University of California at Santa Barbara, Department of Computer Science, Santa Barbara, CA93106, </institution> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: We are currently investigating other synchronization problems in message passing systems that can benefit from the approach of exploiting the semantics of messages. For example, the perfor 19 mance of crash recovery and checkpointing can be improved <ref> [LA93] </ref> and the ordering constraints in broadcast and multicast protocols can be relaxed, when we take into account the semantics of messages. Acknowledgement We would like to express our gratitude to Jonathan R. Agre for technical supports on discrete event simulation and time warp mechanism.
Reference: [Lam78] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference: [LH89] <author> Kai Li and Paul Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> Nov </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Synchronization of parallel programs in a message passing system is an important research topic that crosses several disciplines in computer science: distributed computing, computer architectures, and programming languages. Several synchronization mechanisms and models have been proposed to simplify the design of parallel or concurrent programs <ref> [CM88, BJKS88, LH89, BND89, ABHN91] </ref>. In general, the main source of complexity in synchronizing parallel programs is due to the nondeterministic nature of interactions among processes in the parallel programs.
Reference: [Mis86] <author> J. Misra. </author> <title> Distributed discrete-event simulation. </title> <journal> ACM Computing Surveys, </journal> <volume> 18(1) </volume> <pages> 39-65, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: The non-determinism is inherent in such environments due to the asynchrony of message passing systems and due to the uncertainty of the relative speeds of process execution in parallel programs. For a class of parallel programs corresponding to distributed discrete event simulation <ref> [Mis86, Fuj90] </ref>, the synchronization complexity can be greatly reduced by eliminating non-determinism of execution order.
Reference: [SS84] <author> P.M. Schwarz and A.Z. Spector. </author> <title> Synchronizing shared abstract types. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 223-250, </pages> <month> Aug </month> <year> 1984. </year>
Reference-contexts: As a result, messages destined to these objects can be interpreted as operation invocations whereas messages sent out from these objects can be interpreted as operation responses. The type-specific properties, e.g., the commutativity relation <ref> [Kor83, SS84, Wei89] </ref> among operations, of the objects in the TWM can now be used to alleviate the rollback problem. Informally, we say that two operations commute if the resultant state is independent of the order of execution of the two operations. <p> We conclude the paper with a brief discussion of our results. 2 Motivation In this section, we use an example of a time warp execution that consists of a process implementing a set object. In particular, we demonstrate how the type-specific properties such as commutativ-ity <ref> [Kor83, SS84, Wei89] </ref> and invalidated-by [HW91] relations on operations on a set object can be used to reduce rollback in the system. A set object supports three types of operations: insert, delete, and member. Two insert operations commute, since the ordering of elements in a set is irrelevant.
Reference: [SSH89] <author> L. Sokol, B. Stucky, and V. Hwang. MTW: </author> <title> A control mechanism for parallel discrete simulation. </title> <booktitle> In Proceedings of the 1989 International Conference on Parallel Processing, volume III, </booktitle> <pages> pages 250-254. </pages> <publisher> IEEE, </publisher> <year> 1989. </year>
Reference-contexts: It is therefore important to reduce rollback distance and limit the effect of a rollback. Several optimizations have been suggested to address the problem of rollback in the TWM such as limiting the forward progress of the computation as in the Moving Time Windows scheme <ref> [SSH89] </ref> or by limiting the propagation of messages [DR90, Ste91]. Another popular technique is called lazy cancellation of output messages [Gaf88]. In lazy cancellation, output messages are not annihilated as soon as a process rolls back. <p> The hope is that at a certain point in the forward re-execution, the new process state will become identical to the prior (incorrect) state rendering annihilation of all subsequent output messages as well as the re-execution of previously processed input messages unnecessary. Sokol, Stucky and Hwang <ref> [SSH89] </ref> have proposed the Moving Time Window system which employs the notions of non-side-effecting and side-effecting messages (corresponding to the read and write operations). The arrivals of out-of-order non-side-effecting messages do not necessitate a rollback, since they do not change the object-state.
Reference: [Ste91] <author> J.S. Steinman. SPEEDES: </author> <title> Synchronous parallel environment for emulation and discrete event simulation. </title> <booktitle> In Proceedings of the SCS Multiconference on Distributed Simulation, </booktitle> <pages> pages 95-103, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: Several optimizations have been suggested to address the problem of rollback in the TWM such as limiting the forward progress of the computation as in the Moving Time Windows scheme [SSH89] or by limiting the propagation of messages <ref> [DR90, Ste91] </ref>. Another popular technique is called lazy cancellation of output messages [Gaf88]. In lazy cancellation, output messages are not annihilated as soon as a process rolls back. Instead, these messages are cancelled lazily (if necessary 1 ) during the forward re-execution of the process.
Reference: [Wei89] <author> William E. Weihl. </author> <title> The impact of recovery on concurrency control. </title> <booktitle> In Proceedings of the 8th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 259-269. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: As a result, messages destined to these objects can be interpreted as operation invocations whereas messages sent out from these objects can be interpreted as operation responses. The type-specific properties, e.g., the commutativity relation <ref> [Kor83, SS84, Wei89] </ref> among operations, of the objects in the TWM can now be used to alleviate the rollback problem. Informally, we say that two operations commute if the resultant state is independent of the order of execution of the two operations. <p> We conclude the paper with a brief discussion of our results. 2 Motivation In this section, we use an example of a time warp execution that consists of a process implementing a set object. In particular, we demonstrate how the type-specific properties such as commutativ-ity <ref> [Kor83, SS84, Wei89] </ref> and invalidated-by [HW91] relations on operations on a set object can be used to reduce rollback in the system. A set object supports three types of operations: insert, delete, and member. Two insert operations commute, since the ordering of elements in a set is irrelevant. <p> The semantics of two operations can be captured by the effect on the object when these two operations are executed by the object in different orders. An example is the notion of commutativity between two operations. In particular, we are using the right-backward commute relation <ref> [Wei89] </ref> and the invalidated-by relation [HW91]. Definition 1 An operation q is said to right commute backward with another operation p whenever for all sequences h, if h p q is valid then h q p is valid and equivalent to h p q. <p> response if new state is equivalent to the old one then return /* early termination: ff 4 */ endfor endif end 5 Integrating Right Backward Commutativity with Forward Commutativity When operation responses are taken into account, our protocol can be improved through the intro duction of the forward commute relation <ref> [Wei89] </ref>. By combinating the forward commute relation with the right-backward commute relation, the amount of rollback can further be reduced. We first 11 give a formal definition of forward commutativity.
Reference: [Wes88] <author> D. West. </author> <title> Optimizing time warp: Lazy rollback and lazy re-evaluation. </title> <type> Master's thesis, </type> <institution> University of Calgary, Department of Computer Science, </institution> <month> Jan </month> <year> 1988. </year> <month> 21 </month>
Reference-contexts: In lazy cancellation, output messages are not annihilated as soon as a process rolls back. Instead, these messages are cancelled lazily (if necessary 1 ) during the forward re-execution of the process. Furthermore, the technique of lazy re-evaluation has also been proposed <ref> [Wes88] </ref>. The hope is that at a certain point in the forward re-execution, the new process state will become identical to the prior (incorrect) state rendering annihilation of all subsequent output messages as well as the re-execution of previously processed input messages unnecessary.
References-found: 21

