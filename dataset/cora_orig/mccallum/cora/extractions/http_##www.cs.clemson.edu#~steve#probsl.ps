URL: http://www.cs.clemson.edu/~steve/probsl.ps
Refering-URL: http://www.cs.clemson.edu/~steve/resint.html
Root-URL: http://www.cs.clemson.edu
Author: D. E. STEVENSON 
Note: Given this framework, the questions asked in the title may finally be answered in the conclusion.  
Abstract: WHAT IS COMPUTATIONAL KNOWLEDGE AND HOW DO WE ACQUIRE IT? Abstract. The goal of foundational thinking in computer science is to understand the methods and practices of working programmers; we might even be able to improve upon those practices. The investigation outlined here applies the methods of constructive mathematics a la A. N. Kolmogoroff, L. E. J. Brouwer and Errett Bishop to contemporary computer science. The major approach is to use Kolmogoroff's interpretation of the predicate calculus. This investigation includes an attempt to merge contemporary thoughts on computability and computing semantics with the language of mental constructions proposed by Brouwer. This necessarily forces us to ask about the psychology of language. I present a definition of algorithms that links language, constructive mathematics, and logic. Using the concept of an abstract family of algorithms (Hennie) and principles of constructivity, a definition of problem solving. The constructive requirements for an algorithm are developed and presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Michael J. Beeson. </author> <title> Foundations of Constructive Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Elements of Constructionistic Computing The task now is the top-down development of the elements of constructive computing. Late 20th Century views of constructionism/intuitionism are succinctly present in <ref> [1, 2] </ref> and the papers of Martin-Lof. A very brief overview of those principles is developed here. A set is seen as a container that holds elements that fit a particular definition. That definition may not admit anything so that a constructive set must be shown to be inhabited.
Reference: [2] <author> Errett Bishop and Douglas Bridges. </author> <title> Constructive Analysis. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: This has deep consequences in practical computer science. 5. Principles of Constructivity 5.1. Received Principles. To set forth a consistent set of principles for constructive programming, there are certain concepts that I inherit from other aspects of constructivity. A succinct list of rules gleaned from Bishop's writings <ref> [2, 3, 5, 6, 4, 7] </ref> are shown in Figure 6 and expanded below: 1. Objects. Objects in programming are figments of the imagination of humans but representations stored in a computer. The first view is from Brouwer and the second from the reality of computers. 2. Existence. <p> Elements of Constructionistic Computing The task now is the top-down development of the elements of constructive computing. Late 20th Century views of constructionism/intuitionism are succinctly present in <ref> [1, 2] </ref> and the papers of Martin-Lof. A very brief overview of those principles is developed here. A set is seen as a container that holds elements that fit a particular definition. That definition may not admit anything so that a constructive set must be shown to be inhabited.
Reference: [3] <author> Errett A. Bishop. </author> <title> Foundations of Constructive Analysis. </title> <publisher> McGraw-Hill, </publisher> <year> 1967. </year> <title> WHAT IS COMPUTATIONAL KNOWLEDGE AND HOW DO WE ACQUIRE IT? 19 </title>
Reference-contexts: This has deep consequences in practical computer science. 5. Principles of Constructivity 5.1. Received Principles. To set forth a consistent set of principles for constructive programming, there are certain concepts that I inherit from other aspects of constructivity. A succinct list of rules gleaned from Bishop's writings <ref> [2, 3, 5, 6, 4, 7] </ref> are shown in Figure 6 and expanded below: 1. Objects. Objects in programming are figments of the imagination of humans but representations stored in a computer. The first view is from Brouwer and the second from the reality of computers. 2. Existence.
Reference: [4] <author> Errett A. Bishop. </author> <title> Mathematics as a numerical language. </title> <editor> In A. Kino, J. Myhill, and R. E. Vesley, editors, </editor> <booktitle> Intuitionism and Proof Theory, </booktitle> <pages> pages 53-71. </pages> <publisher> North Holland, </publisher> <year> 1967. </year>
Reference-contexts: This has deep consequences in practical computer science. 5. Principles of Constructivity 5.1. Received Principles. To set forth a consistent set of principles for constructive programming, there are certain concepts that I inherit from other aspects of constructivity. A succinct list of rules gleaned from Bishop's writings <ref> [2, 3, 5, 6, 4, 7] </ref> are shown in Figure 6 and expanded below: 1. Objects. Objects in programming are figments of the imagination of humans but representations stored in a computer. The first view is from Brouwer and the second from the reality of computers. 2. Existence.
Reference: [5] <author> Errett E. Bishop. </author> <title> The crisis in contemporary mathematics. </title> <journal> Historia Mathematica, </journal> <volume> 2 </volume> <pages> 507-517, </pages> <year> 1975. </year>
Reference-contexts: This has deep consequences in practical computer science. 5. Principles of Constructivity 5.1. Received Principles. To set forth a consistent set of principles for constructive programming, there are certain concepts that I inherit from other aspects of constructivity. A succinct list of rules gleaned from Bishop's writings <ref> [2, 3, 5, 6, 4, 7] </ref> are shown in Figure 6 and expanded below: 1. Objects. Objects in programming are figments of the imagination of humans but representations stored in a computer. The first view is from Brouwer and the second from the reality of computers. 2. Existence.
Reference: [6] <author> Errett E. Bishop. </author> <title> Schizophrenia in contemporary mathematics. </title> <journal> Contemporary Mathematics, </journal> <volume> 39 </volume> <pages> 1-32, </pages> <year> 1985. </year>
Reference-contexts: This has deep consequences in practical computer science. 5. Principles of Constructivity 5.1. Received Principles. To set forth a consistent set of principles for constructive programming, there are certain concepts that I inherit from other aspects of constructivity. A succinct list of rules gleaned from Bishop's writings <ref> [2, 3, 5, 6, 4, 7] </ref> are shown in Figure 6 and expanded below: 1. Objects. Objects in programming are figments of the imagination of humans but representations stored in a computer. The first view is from Brouwer and the second from the reality of computers. 2. Existence.
Reference: [7] <author> Errett J. Bishop and Douglas Bridges. </author> <title> Constructive Analysis. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: This has deep consequences in practical computer science. 5. Principles of Constructivity 5.1. Received Principles. To set forth a consistent set of principles for constructive programming, there are certain concepts that I inherit from other aspects of constructivity. A succinct list of rules gleaned from Bishop's writings <ref> [2, 3, 5, 6, 4, 7] </ref> are shown in Figure 6 and expanded below: 1. Objects. Objects in programming are figments of the imagination of humans but representations stored in a computer. The first view is from Brouwer and the second from the reality of computers. 2. Existence.
Reference: [8] <author> Noam Chomsky. </author> <title> Three models for the description of language. </title> <journal> IEEE Trans. on Information Theory, </journal> <volume> 2(3) </volume> <pages> 113-124, </pages> <year> 1956. </year>
Reference: [9] <author> R. L. Constable and et al. </author> <title> Implementing Mathematics with the NuPrl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: The thesis presented here is that algorithms have both state and witness data manipulations. Therefore, we must define the metalanguage rules so that both are presented: (1) the usual state machine and (2) a modified proof in the spirit of the static-dynamic principle. Using LCF [19] and NuPrl <ref> [9] </ref> as exemplars, the system could be seen as a mapping hA i ; i ; W i i = hA 0 ; 0 ; W 0 i where A are algorithms, are states, and W = hProof, Hypotheses, Tacticali.
Reference: [10] <author> S. Feferman. </author> <title> Constructive theories of functions and classes. </title> <editor> In M. Boffa, D. van Dalen, and K. McAloon, editors, </editor> <booktitle> Logic Colloquia 1978 Mons, number 97 in Stud. Logic Found Math., </booktitle> <pages> pages 159-224. </pages> <publisher> North Holland, </publisher> <year> 1979. </year>
Reference-contexts: Failure. All constructive theories explicitly acknowledge that something might fail to exist. Constructivity as a principle extends from a 20th Century philosophical principle called "verificationism". For the most part, I are uninterested in verificationism except in one major point: the focus on meaning. Feferman <ref> [10] </ref> develop two criteria for what theories should accomplish instead of the mechanics. <p> The central view of meaning is the theme of Waismann's 3 [27]: where the meaning of a construct is taken as its use. A more natural way to say this might be that meaning derives from use or effect. Considering Feferman <ref> [10] </ref> again, we can say M 1 An operation is an adequate formalization of an operator F if every feature of F is repre sented by . 2 His leadership was cut short by his death in 1936; killed by a student over his Jewish heritage. 3 Ranta [20] suggests Waismann
Reference: [11] <author> James H. </author> <title> Fetzer. Program verification: the very idea. </title> <journal> CACM, </journal> <volume> 31(9), </volume> <year> 1988. </year>
Reference: [12] <author> Stephen J. Gould. </author> <title> Full House. Random House?, </title> <year> 1995. </year>
Reference: [13] <author> Carl A. Gunter. </author> <title> Semantics of Programming Languages: Structures and techniques. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Failure of any hypothesis is failure for the program. 7. Semantics and the Case for Construction There are several ways to present semantics. The three most common | as the reader is well aware | are (1) operational, (2) axiomatic, and (3) denotational. See, for example, Gunter <ref> [13] </ref>. It is now common to used category-theoretic notation to describe denotational theories as we did in Equation (1). To provide a constructive basis for semantics, however, we return to the original concept of solves. Recall that I started out with a discussion of Kolmogoroff's concept.
Reference: [14] <author> Fred Hennie. </author> <title> Introduction to Computability. </title> <publisher> Addison-Wesley, </publisher> <year> 1977. </year>
Reference: [15] <author> S. C. Kleene. </author> <title> Introduction to Metamathematics. </title> <publisher> North Holland Publishing Company, </publisher> <year> 1971. </year> <note> Original 1952. </note>
Reference: [16] <author> A. Kolmogoroff. </author> <title> Zur Deutung der intuitionistischen Logik. </title> <journal> Mathmatische Zeitschrift, </journal> <volume> 33 </volume> <pages> 58-65, </pages> <year> 1932. </year>
Reference: [17] <author> Thomas S. Kuhn. </author> <title> The Structure of Scientific Revolutions. </title> <publisher> University of Chicago Press, </publisher> <address> Chicago, IL, 2 edition, </address> <year> 1970. </year>
Reference: [18] <author> John McCarthy. </author> <title> A basis for a mathematical theory of computation. </title> <booktitle> Computer Programming and Formal Systems, </booktitle> <pages> pages 33-70, </pages> <year> 1963. </year>
Reference-contexts: Early compilers didn't have the time or space to deal with other issues. But this is the 21st Century, not the 1960s. The usual model for programming is something based on the -calculus, going back to McCarty <ref> [18] </ref>. This model represents the "unwinding" version of the -calculus. Hence the meta-language rules have those operations, stacks, etc. The thesis presented here is that algorithms have both state and witness data manipulations.
Reference: [19] <author> Lawrence C. Paulson. </author> <title> Logic and computation : interactive proof with Cambridge LCF. </title> <publisher> Cambridge University Press, </publisher> <year> 1987. </year>
Reference-contexts: The thesis presented here is that algorithms have both state and witness data manipulations. Therefore, we must define the metalanguage rules so that both are presented: (1) the usual state machine and (2) a modified proof in the spirit of the static-dynamic principle. Using LCF <ref> [19] </ref> and NuPrl [9] as exemplars, the system could be seen as a mapping hA i ; i ; W i i = hA 0 ; 0 ; W 0 i where A are algorithms, are states, and W = hProof, Hypotheses, Tacticali.
Reference: [20] <author> Aarne Ranta. </author> <title> Type-Theoretical Grammar. </title> <publisher> Clarendon Press, </publisher> <year> 1994. </year>
Reference-contexts: Considering Feferman [10] again, we can say M 1 An operation is an adequate formalization of an operator F if every feature of F is repre sented by . 2 His leadership was cut short by his death in 1936; killed by a student over his Jewish heritage. 3 Ranta <ref> [20] </ref> suggests Waismann as a key to understanding analytic/linguistic philosophy 16 D. E.
Reference: [21] <author> W. </author> <title> Rudin. Real Analysis. </title> <publisher> Macmillan, </publisher> <year> 1968. </year>
Reference-contexts: Taking a cue from analysis <ref> [21, p. 42] </ref>, I call the set ^a a cover. 8.2. Sets. Since ^ A is constructive, there is a function that passes on membership in ^ A. To reduce notation, assume that ^ A is that function.
Reference: [22] <author> D. E. Stevenson. </author> <title> Science, computational science, and computer science: At a crossroads. </title> <journal> Comm. ACM, </journal> <volume> 37(12) </volume> <pages> 85-96, </pages> <year> 1994. </year>
Reference: [23] <author> D. E. Stevenson. </author> <title> Principles of constructive euclidean geometry. </title> <journal> Bulletin of the AMS, </journal> <note> Submitted. </note>
Reference-contexts: However, that is exactly what the programmer is faced with. With this in mind, the elements of constructive computing would describe how objects are formed and how the witness data guarantees that the constructed object is the desired object. There is an interesting tie-in with <ref> [23] </ref>. Diagrams have been portrayed by purists as unnecessary and should be eliminated. In [23] we give another interpretation: the diagrams are the blueprints of an object. The auxiliary lines, etc., of these diagrams are the means by which we hang the proof off the construction. <p> With this in mind, the elements of constructive computing would describe how objects are formed and how the witness data guarantees that the constructed object is the desired object. There is an interesting tie-in with <ref> [23] </ref>. Diagrams have been portrayed by purists as unnecessary and should be eliminated. In [23] we give another interpretation: the diagrams are the blueprints of an object. The auxiliary lines, etc., of these diagrams are the means by which we hang the proof off the construction. Similarly, rather than banish information from programs we should encourage the use of annotation. <p> The Vienna Circle was led Moritz Schlick 2 , a "retred" physicist. Schlick's stand was that the sciences and mathematics were not meaningless symbols but had to be coordinated with reality. (This is different than Brouwer, but a conclusion in <ref> [23] </ref>). In computing we are faced with an equivalent problem because a program is a model of some system. What we compute must match what the real system does. Validation, in the sense of model validation, determines whether or not the program's "system" and the system presented initially are connected.
Reference: [24] <author> Patrick Suppes. </author> <title> Introduction to Logic. </title> <publisher> Van Nostrand, </publisher> <year> 1971. </year>
Reference: [25] <author> A. S. </author> <title> Troelstra. </title> <booktitle> Principles of Intuitionism. Number 95 in Lecture Notes in Mathematics. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1969. </year>
Reference-contexts: Taking a cue from analysis [21, p. 42], I call the set ^a a cover. 8.2. Sets. Since ^ A is constructive, there is a function that passes on membership in ^ A. To reduce notation, assume that ^ A is that function. In <ref> [25] </ref>, the convention is that ^ A^a is true when ^a is an object in ^ A as in (ii) above. Actually, this convention seems to be handy about one-half the time; the other half ^ At a = ^a would be better.
Reference: [26] <author> A. M. </author> <title> Turing. On computable numbers, with an application to the "entscheidungsproglem". </title> <journal> Proc. London Math. Soc. </journal> <volume> Ser 2, 42 </volume> <pages> 230-265, </pages> <year> 1935. </year>
Reference: [27] <author> Friedrich Waismann. </author> <booktitle> The principles of linguistic philosophy. </booktitle> <publisher> Macmillan, </publisher> <year> 1965. </year>
Reference-contexts: Likewise, artificial intelligence systems, accounting systems, air traffic control systems, medical diagnostics, and fingerprint matching programs have a reality they have to validate to. Meaning, therefore, is the match of the computation and the evolution of the system. The central view of meaning is the theme of Waismann's 3 <ref> [27] </ref>: where the meaning of a construct is taken as its use. A more natural way to say this might be that meaning derives from use or effect.
Reference: [28] <author> Niklaus Wirth. </author> <title> Algorithms + data structures=programs. </title> <publisher> Prentice-Hall, </publisher> <address> 1976. 442 R. C. </address> <institution> Edwards Hall Department of Computer Science, Clemson University, </institution> <address> PO Box 341906, Clemson, SC 29634-1906 E-mail address: steve@cs.clemson.edu </address>
References-found: 28

