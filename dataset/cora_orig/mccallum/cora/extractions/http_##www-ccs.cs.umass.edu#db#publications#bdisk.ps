URL: http://www-ccs.cs.umass.edu/db/publications/bdisk.ps
Refering-URL: http://www-ccs.cs.umass.edu/rtdb/publications.html
Root-URL: 
Email: jai@cs.wisc.edu  anithrak@us.oracle.com  sivasank@cs.umass.edu  krithi@cs.umass.edu  
Title: Efficient Concurrency Control for Broadcast Environments  
Author: Jayavel Shanmugasundaram Arvind Nithrakashyap Rajendran Sivasankaran Krithi Ramamritham 
Note: Currently at the  Currently at Oracle Corporation, 500 Oracle Parkway 4op1385a,  
Address: Amherst, MA 01002  Wisconsin, Madison, WI 53706  Redwood Shores, CA 94065  
Affiliation: Department of Computer Science University of Massachusetts  Department of Computer Sciences, University of  
Abstract: A crucial limitation in environments where data is broadcast to clients is the low bandwidth available for clients to communicate with servers. Advanced applications in such environments do need concurrency control support. However, given the asymmetric communication capabilities and the needs of clients in mobile environments, traditional correctness requirements and mechanisms to achieve them are too restrictive, unnecessary, and impractical in such environments. Hence weaker alternatives that are sufficient and practical for such environments are needed. We propose a correctness criterion that allows read-only transactions to read current and consistent data "off the air", i.e., without contacting the server, say, to obtain locks. Update transactions, however, need to validate their updates at the server. Even though the proposed correctness criterion is weaker than serializability, it is shown that determining legality of histories with respect to this consistency requirement is NP-Complete. So, APPROX, a polynomial time algorithm, to efficiently detect (a subset of) legal histories is outlined. F-Matrix, a protocol to implement APPROX in broadcast disk environments, is then proposed. Our protocol requires additional control information to be broadcast with the data in order to ensure correctness and so a key issue is how to minimize the overhead entailed by this additional information. To this end, we propose R-Matrix, a simpler version of F-Matrix, to implement APPROX. Experimental results confirm the hypothesis that the weaker correctness criterion leads to substantially lower response times compared to using serializability, as exemplified by the concurrency control algorithm used in the Datacycle architecture. Furthermore, even though F-Matrix and R-Matrix show comparable performance in many situations, overall, F-Matrix leads to better response times and is also more scalable than R-Matrix and Datacycle. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Acharya, R. Alonso, M. Franklin, S. Zdonik, </author> <title> "Broadcast Disks: Data Management for Asymmetric Communications Environments," </title> <booktitle> Proceedings of the ACM SIGMOD Conference, </booktitle> <address> California, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Client caching in broadcast environments <ref> [1] </ref> is typically done to improve the client application performance by storing frequently accessed data items in the client cache. Thus, the client does not have to wait to read the data off the broadcast and can directly read it from the local cache. <p> Thus, the client does not have to wait to read the data off the broadcast and can directly read it from the local cache. Since the client cache is typically not large enough to hold all the items being broadcast, appropriate cache replacement policies are used <ref> [1] </ref>. In the presence of updates, however, the issue becomes more complex. This is because the data in the client caches may be "inconsistent" [3] with the data being broadcast due to updates at the server.
Reference: [2] <author> S. Acharya, M. Franklin and S. Zdonik, </author> <title> "Disseminating Updates on Broadcast Disks," </title> <booktitle> Proceedings of 22nd VLDB Conference, </booktitle> <address> Mumbai(Bombay), India, </address> <year> 1996. </year>
Reference-contexts: Given the limited amount of bandwidth available for clients to communicate with the broadcast server in such environments, achieving data consistency efficiently in such an environment is a challenging research issue. [12] and <ref> [2] </ref> are among the few papers motivated by similar considerations. Herman et. al. [12] discuss transactional support in the Datacycle architecture, which is also an asymmetric bandwidth environment. However, they use serializability as the correctness criterion, which we show is very expensive to achieve in such environments. In [2], the authors <p> [12] and <ref> [2] </ref> are among the few papers motivated by similar considerations. Herman et. al. [12] discuss transactional support in the Datacycle architecture, which is also an asymmetric bandwidth environment. However, they use serializability as the correctness criterion, which we show is very expensive to achieve in such environments. In [2], the authors discuss the tradeoffs between currency of data and performance issues when some of the broadcast data items are updated by processes running on the server. However, the updates do not have transactional semantics associated with them either at the server or at the clients. <p> This is because the data in the client caches may be "inconsistent" [3] with the data being broadcast due to updates at the server. Mechanisms to deal with this problem in the context of broadcast environments have been proposed <ref> [2] </ref>. The mechanisms described in [2] are for maintaining the consistency of data items read, on a per object basis. <p> This is because the data in the client caches may be "inconsistent" [3] with the data being broadcast due to updates at the server. Mechanisms to deal with this problem in the context of broadcast environments have been proposed <ref> [2] </ref>. The mechanisms described in [2] are for maintaining the consistency of data items read, on a per object basis.
Reference: [3] <author> R. Alonso, D. Barbara, H. Garcia-Molina, </author> <title> "Data Caching Issues in an Information Retrieval System," </title> <journal> ACM Transactions on Database Systems, </journal> <volume> vol. 15, no. 3, </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: Since the client cache is typically not large enough to hold all the items being broadcast, appropriate cache replacement policies are used [1]. In the presence of updates, however, the issue becomes more complex. This is because the data in the client caches may be "inconsistent" <ref> [3] </ref> with the data being broadcast due to updates at the server. Mechanisms to deal with this problem in the context of broadcast environments have been proposed [2]. The mechanisms described in [2] are for maintaining the consistency of data items read, on a per object basis.
Reference: [4] <author> R. Alonso, H. Korth, </author> <booktitle> "Database Systems Issues in Nomadic Computing," Proceedings of the ACM SIGMOD Conference, </booktitle> <address> Washington D.C, </address> <month> June </month> <year> 1993, </year> <pages> pp. 388-392. </pages>
Reference-contexts: In particular, we are concerned with the problem of providing readers with current and consistent data while ensuring the consistency of updates. Broadcast-based data dissemination is also likely to be a major mode of information transfer in mobile computing and wireless environments <ref> [4, 13, 26] </ref>. Many such systems have been proposed [20] and [16] and commercial systems such as Vitria [21] already implement broadcasting. <p> The problem of determining if a history satisfies the correctness criterion is NP-Complete. We hence propose a polynomial time approximation algorithm, AP-PROX, to efficiently determine legal histories. A mechanism to implement this algorithm in broadcast disk <ref> [4] </ref> environments, F-Matrix, is also described. We then propose, R-Matrix, a simpler (in terms of space, time and effectiveness in determining legal histories) version of F-Matrix.
Reference: [5] <author> P.A. Bernstein, V. Hadzilacos, N. Goodman, </author> <title> "Concurrency Control and Recovery in Database Systems," </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: The proofs of all the theorems can be found in the appendix. 8 Theorem 1 A scheduler can determine that a history H satisfies requirements 1 through 3 iff (a) H update is view serializable <ref> [25, 5, 18] </ref> and (b) for each read-only transaction t, the subhistory formed by the transactions in LIV E H (t) is also view serializable (ignoring the final database state). <p> Theorem 2 The problem of determining whether a history H is legal is NP-Complete. So, it is very unlikely that an efficient (practical) algorithm exists to determine all and only legal histories. However, because view serializability is NP-Complete, in practice, a stronger but polynomially checkable property, conflict serializability <ref> [5] </ref>, is enforced. The question that now arises is: What is the complexity of determining whether a history H is legal, given that H update is conflict serializable? We can show that this problem is also NP-Complete. <p> to maintain two versions of objects, one the latest committed version and the other the last written version 3 . 2 For a more precise definition of S H (t R ), see Appendix C 3 The maintenance of two versions of objects has some commonality with multiversion concurrency control <ref> [5] </ref>. Our concern here is about clients which maintain only a single version. 11 2. Using a concurrency control mechanism, ensures the conflict serializability of all transac-tions submitted to the server (some of these may originate at the clients and submitted for validation as described later).
Reference: [6] <author> P.M. Bober, M.J. Carey, </author> <title> "Multiversion Query Locking," </title> <booktitle> Proceedings of the VLDB Conference, </booktitle> <address> Vancouver, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Whereas we independently discovered the above correctness criterion when we began investigating appropriate correctness criteria for broadcast environments, our correctness criterion bears some similarities to those proposed in [15] and is similar to the "update consistency" correctness proposed in <ref> [6] </ref>. These correctness criteria, however, were proposed in the context of different system architectures and so the mechanisms proposed for implementing them did not take into account the nature of the broadcast medium ([15] and [6] propose locking based protocols which, as outlined before, are infeasible in broadcast environments). <p> to those proposed in [15] and is similar to the "update consistency" correctness proposed in <ref> [6] </ref>. These correctness criteria, however, were proposed in the context of different system architectures and so the mechanisms proposed for implementing them did not take into account the nature of the broadcast medium ([15] and [6] propose locking based protocols which, as outlined before, are infeasible in broadcast environments). Moreover, unlike our work, a formal characterization of the correctness criterion was not presented.
Reference: [7] <author> M.J. Carey, M.J. Franklin, M. Livny, E. Shekita, </author> <title> "Data Caching Tradeoffs in Client-Server DBMS Architectures,"Proceedings of the ACM SIGMOD Conference, </title> <address> Denver, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Finally, we syntactically characterize the set of histories satisfying this correctness criterion and study its relationship to other existing correctness criteria. 2.1 Inapplicability of Existing Client Server Concurrency Control Techniques There has been some work dealing with concurrency control in client server architectures <ref> [7, 22, 23, 9] </ref>. All of these techniques are based primarily on caching the data items read/written by client transactions.
Reference: [8] <author> T.H. Cormen, C.E. Leiserson, R.L. Rivest, </author> <title> "Introduction to Algorithms," </title> <publisher> McGraw-Hill Book Company, </publisher> <year> 1990. </year>
Reference: [9] <author> M.J. Franklin, </author> <title> "Caching and Memory Management in Client-Server Database Systems," </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Sciences, University of Wisconsin-Madison, </institution> <year> 1993. </year>
Reference-contexts: Finally, we syntactically characterize the set of histories satisfying this correctness criterion and study its relationship to other existing correctness criteria. 2.1 Inapplicability of Existing Client Server Concurrency Control Techniques There has been some work dealing with concurrency control in client server architectures <ref> [7, 22, 23, 9] </ref>. All of these techniques are based primarily on caching the data items read/written by client transactions.
Reference: [10] <author> M.R. Garey, D.S. Johnson, </author> <title> "Computers and Intractability: A Guide to the Theory of NP-Completeness," </title> <publisher> Freeman, </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference: [11] <author> S. Gukal, E. Omiecinski, U. Ramachandran, </author> <title> "Transient Versioning for Consistency and Con-currency in Client-Server Systems," </title> <booktitle> Proceedings of the Conference on Parallel and Distributed Information Systems (PDIS), </booktitle> <address> Florida, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: Also, precious client server bandwidth would be wasted for acquiring locks even for read-only transactions. There have been some multiversion concurrency control techniques proposed in the context of client server systems <ref> [11] </ref> that allow read-only transactions to read older versions of data. Apart from the fact that the currency requirement is not adequately met by using old version of data, the server has to keep track of the cache contents (slices) at the clients.
Reference: [12] <author> G. Herman, G. Gopal, K.C. Lee, A. Weinreb, </author> <title> "The Datacycle Architecture for Very High Throughput Database Systems," </title> <booktitle> Proceedings of the ACM SIGMOD Conference, </booktitle> <address> New York, </address> <year> 1987. </year>
Reference-contexts: Given the limited amount of bandwidth available for clients to communicate with the broadcast server in such environments, achieving data consistency efficiently in such an environment is a challenging research issue. <ref> [12] </ref> and [2] are among the few papers motivated by similar considerations. Herman et. al. [12] discuss transactional support in the Datacycle architecture, which is also an asymmetric bandwidth environment. However, they use serializability as the correctness criterion, which we show is very expensive to achieve in such environments. <p> Given the limited amount of bandwidth available for clients to communicate with the broadcast server in such environments, achieving data consistency efficiently in such an environment is a challenging research issue. <ref> [12] </ref> and [2] are among the few papers motivated by similar considerations. Herman et. al. [12] discuss transactional support in the Datacycle architecture, which is also an asymmetric bandwidth environment. However, they use serializability as the correctness criterion, which we show is very expensive to achieve in such environments. <p> This is unacceptable in broadcast environments, as detailed above. To the best of our knowledge, the Datacycle approach <ref> [12] </ref> is the only concurrency control technique proposed in the literature in the context of broadcast environments. We show that our approach has better performance than that of the Datacycle approach. <p> We propose a simpler algorithm that approximates APPROX but which is much more space efficient. We then qualitatively compare the algorithms with the existing Datacycle concurrency control algorithm <ref> [12] </ref>. Finally, we study how client caching can be incorporated into the proposed concurrency control mechanisms. The mechanisms proposed in this section handle both read-only and update transactions. Before we go into the specifics of the algorithm implementation, we first outline some relevant characteristics of broadcast disks. <p> In other words, a transaction can proceed to read an object only if no previously read value has been updated. This corresponds to the Datacycle approach for concurrency control <ref> [12] </ref> and ensures serializability. For the rest of this paper, we call this approach Datacycle. The Datacycle approach, however, does not fully realize the potential of the matrix reduction.
Reference: [13] <author> T. Imielinski and B. R. Badrinath, </author> <title> "Mobile wireless computing: challenges in data management," </title> <journal> Communications of the ACM, </journal> <volume> Vol. 37, No. 10, </volume> <month> October </month> <year> 1994, </year> <pages> pp. 18-28. </pages>
Reference-contexts: In particular, we are concerned with the problem of providing readers with current and consistent data while ensuring the consistency of updates. Broadcast-based data dissemination is also likely to be a major mode of information transfer in mobile computing and wireless environments <ref> [4, 13, 26] </ref>. Many such systems have been proposed [20] and [16] and commercial systems such as Vitria [21] already implement broadcasting.
Reference: [14] <author> S. Kumar, E. Kwang, D. Agrawal, "Caprera: </author> <title> An Activity Framework for Transaction Processing on Wide-Area Networks," </title> <booktitle> Proceedings of the VLDB Conference, </booktitle> <address> Athens, Greece, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: The server checks to see whether the update transaction can be committed using any of the concurrency control protocols outlined under server functionality. If so, the transaction is committed, else it is aborted. This method of handling update transactions is similar to the method proposed in <ref> [14] </ref>. * Abort: If the transaction has not performed any write operation, then the abort does nothing (other than stopping further execution of the transaction and discarding its writes).
Reference: [15] <author> H. Garcia-Molina and G. Wiederhold, </author> <title> "Read-Only Transactions in a Distributed Database," </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 7, No. 2, </volume> <month> June </month> <year> 1982, </year> <pages> pp. 209-234. </pages>
Reference-contexts: Whereas we independently discovered the above correctness criterion when we began investigating appropriate correctness criteria for broadcast environments, our correctness criterion bears some similarities to those proposed in <ref> [15] </ref> and is similar to the "update consistency" correctness proposed in [6]. These correctness criteria, however, were proposed in the context of different system architectures and so the mechanisms proposed for implementing them did not take into account the nature of the broadcast medium ([15] and [6] propose locking based protocols
Reference: [16] <author> B. Oki, M. Pfluegl, A. Siegel, D. Skeen, </author> <title> "The Information Bus An Architecture for Extensible Distributed Systems," </title> <booktitle> Proceedings of the SOSP Conference, </booktitle> <address> North Carolina, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Broadcast-based data dissemination is also likely to be a major mode of information transfer in mobile computing and wireless environments [4, 13, 26]. Many such systems have been proposed [20] and <ref> [16] </ref> and commercial systems such as Vitria [21] already implement broadcasting. As these systems continue to evolve, they will be used to run sophisticated applications, many of which will involve data whose consistency must be maintained in spite of updates, some of which may originate from mobile clients.
Reference: [17] <author> C.H. Papadimitriou, </author> <title> "The Serializability of Concurrent Database Updates," </title> <journal> Journal of the ACM, </journal> <volume> Vol. 26, No. 4, </volume> <month> October </month> <year> 1979, </year> <pages> pp. 631-653. </pages>
Reference: [18] <author> C. H. Papadimitriou, </author> <title> "The Theory of Database Concurrency Control," </title> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: The proofs of all the theorems can be found in the appendix. 8 Theorem 1 A scheduler can determine that a history H satisfies requirements 1 through 3 iff (a) H update is view serializable <ref> [25, 5, 18] </ref> and (b) for each read-only transaction t, the subhistory formed by the transactions in LIV E H (t) is also view serializable (ignoring the final database state).
Reference: [19] <author> J. Shanmugasundaram, A. Nithrakashyap, J. Padhye, R. Sivasankaran, M. Xiong, K. Ramam-ritham, </author> <title> "Transaction Processing in Broadcast Disk Environments," Advanced Transaction Models and Architectures, </title> <editor> S. Jajodia and L. Kerschnerg (eds.), </editor> <publisher> Kluwer Academic Publishers, </publisher> <year> 1997. </year>
Reference-contexts: Other applications of broadcasting, include stock trading, next generation road traffic management systems and automated industrial plants <ref> [19, 24] </ref>. Given the limited amount of bandwidth available for clients to communicate with the broadcast server in such environments, achieving data consistency efficiently in such an environment is a challenging research issue. [12] and [2] are among the few papers motivated by similar considerations. <p> The results confirm the hypothesis that a weaker consistency requirement leads to substantially better read response times. In an earlier work <ref> [19] </ref>, we had performed a preliminary study of correctness criteria appropriate for broadcast environments. This paper builds upon the earlier work by formulating a specific correctness criterion, providing a formal analysis of the correctness criterion, proposing concrete mechanisms to enforce the correctness criterion and evaluating these mechanisms.
Reference: [20] <author> S. Shekar, D. Liu, </author> <title> "Genesis and Advanced Traveler Information Systems (ATIS): </title> <booktitle> Killer Applications for Mobile Computing," MOBIDATA Workshop, </booktitle> <address> New Jersey, </address> <year> 1994. </year>
Reference-contexts: Broadcast-based data dissemination is also likely to be a major mode of information transfer in mobile computing and wireless environments [4, 13, 26]. Many such systems have been proposed <ref> [20] </ref> and [16] and commercial systems such as Vitria [21] already implement broadcasting. As these systems continue to evolve, they will be used to run sophisticated applications, many of which will involve data whose consistency must be maintained in spite of updates, some of which may originate from mobile clients.
Reference: [21] <institution> White Paper, Vitria Technology Inc. </institution> <note> (http://www.vitira.com). </note>
Reference-contexts: Broadcast-based data dissemination is also likely to be a major mode of information transfer in mobile computing and wireless environments [4, 13, 26]. Many such systems have been proposed [20] and [16] and commercial systems such as Vitria <ref> [21] </ref> already implement broadcasting. As these systems continue to evolve, they will be used to run sophisticated applications, many of which will involve data whose consistency must be maintained in spite of updates, some of which may originate from mobile clients.
Reference: [22] <author> W. Wang, L. Rowe, </author> <title> "Cache Consistency and Concurrency Control in a Client/Server DBMS Architecture," </title> <booktitle> Proceedings of the ACM SIGMOD Conference, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Finally, we syntactically characterize the set of histories satisfying this correctness criterion and study its relationship to other existing correctness criteria. 2.1 Inapplicability of Existing Client Server Concurrency Control Techniques There has been some work dealing with concurrency control in client server architectures <ref> [7, 22, 23, 9] </ref>. All of these techniques are based primarily on caching the data items read/written by client transactions.
Reference: [23] <author> W. Wilkinson, M.A. Nemat, </author> <title> "Maintaining Consistency of Client Cached Data," </title> <booktitle> Proceedings of the VLDB Conference, </booktitle> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Finally, we syntactically characterize the set of histories satisfying this correctness criterion and study its relationship to other existing correctness criteria. 2.1 Inapplicability of Existing Client Server Concurrency Control Techniques There has been some work dealing with concurrency control in client server architectures <ref> [7, 22, 23, 9] </ref>. All of these techniques are based primarily on caching the data items read/written by client transactions.
Reference: [24] <author> P. Xuan, S. Sen, O.J.Gonzalez-Gomez, J. Fernandez and K. Ramamritham, </author> <title> "Broadcast on Demand Efficient and Timely Dissemination of Data in Mobile Environments," </title> <booktitle> IEEE Real-Time Technology and Applications Symposium, </booktitle> <pages> pp. 38-48, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Other applications of broadcasting, include stock trading, next generation road traffic management systems and automated industrial plants <ref> [19, 24] </ref>. Given the limited amount of bandwidth available for clients to communicate with the broadcast server in such environments, achieving data consistency efficiently in such an environment is a challenging research issue. [12] and [2] are among the few papers motivated by similar considerations.
Reference: [25] <author> M. Yannakakis, </author> <title> "Serializability by Locking," </title> <journal> Journal of the ACM, </journal> <volume> Vol. 31, No. 2, </volume> <month> April </month> <year> 1984. </year>
Reference-contexts: The proofs of all the theorems can be found in the appendix. 8 Theorem 1 A scheduler can determine that a history H satisfies requirements 1 through 3 iff (a) H update is view serializable <ref> [25, 5, 18] </ref> and (b) for each read-only transaction t, the subhistory formed by the transactions in LIV E H (t) is also view serializable (ignoring the final database state).

References-found: 25

