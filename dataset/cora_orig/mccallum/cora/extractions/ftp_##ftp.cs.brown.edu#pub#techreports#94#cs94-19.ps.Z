URL: ftp://ftp.cs.brown.edu/pub/techreports/94/cs94-19.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-94-19.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. Mani Chandy and Leslie Lamport, </author> <title> ``Distributed Snapshots: Determining Global States of Distributed Systems,'' </title> <journal> ACM Trans on Comp Syst 3(1) pp. </journal> <month> 63-75 (Feb, </month> <year> 1985). </year>
Reference-contexts: This work is part of our larger effort on developing adaptive tracing strategies for debugging [3, 4]. 2. Motivation and related work Checkpointing and message logging have been used in many applications including parallel debugging [2, 8], fault-tolerant computing [7], and other areas <ref> [1] </ref>. Check-pointing supports incremental replay by saving each process' state periodically so that reexecution can start from a checkpoint instead of the execution's beginning. However, checkpointing alone is not enough.
Reference: [2] <author> Arthur P. Goldberg, Ajei Gopal, Andy Lowry, </author> <title> a nd Rob Strom, ``Restoring Consistent Global States of Distributed Computations,'' </title> <booktitle> ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <address> 144-154 Santa Cruz, CA, </address> <month> (May </month> <year> 1991). </year>
Reference-contexts: This work is part of our larger effort on developing adaptive tracing strategies for debugging [3, 4]. 2. Motivation and related work Checkpointing and message logging have been used in many applications including parallel debugging <ref> [2, 8] </ref>, fault-tolerant computing [7], and other areas [1]. Check-pointing supports incremental replay by saving each process' state periodically so that reexecution can start from a checkpoint instead of the execution's beginning. However, checkpointing alone is not enough. <p> The difficult aspect of supporting incremental replay is balancing these two choices. Below we outline several options for addressing this problem and discuss what approaches past work has taken. One simple approach proposed in the past is to log all the messages <ref> [2, 8] </ref>. However, the run-time overhead of this approach is prohibitive. On modern machines, executions of even moderate length can pass gigabytes of data in messages. Another approach at the other extreme recreated to replay S 1,3 .
Reference: [3] <author> Robert H.B. Netzer and Barton P. Miller, </author> <title> ``Optimal Tracing and Replay for Debugging Message-Passing Parallel Programs,'' </title> <booktitle> Supercomputing '92, </booktitle> <pages> pp. </pages> <address> 502-511 Minneapolis, MN, </address> <month> (November </month> <year> 1992). </year>
Reference-contexts: Experiments show that in practice it performs just as well as the first algorithm but without the overhead, usually logging 0. 1 - 5% of the messages. This work is part of our larger effort on developing adaptive tracing strategies for debugging <ref> [3, 4] </ref>. 2. Motivation and related work Checkpointing and message logging have been used in many applications including parallel debugging [2, 8], fault-tolerant computing [7], and other areas [1].
Reference: [4] <author> Robert H.B. Netzer and Jian Xu, </author> <title> ``Adaptive Message Logging for Incremental Program Replay,'' </title> <booktitle> IEEE Parallel and Distributed Technology, </booktitle> <month> (November </month> <year> 1993). </year> <note> Also appears in Supercomputing '93, </note> <institution> Portland, </institution> <month> OR (November </month> <year> 1993). </year>
Reference-contexts: This freedom allows us to decide at run-time which messages can be quickly recomputed (during the replay) by reexecuting the processes that sent them. In a previous paper we presented a heuristic to identify which messages can be quickly recomputed during replay and need not be logged <ref> [4] </ref>. The problem with this technique is that it can log more than necessary and cannot always keep the replay time bounded. In this paper we directly address the replay time problem and guarantee a replay bound. <p> Experiments show that in practice it performs just as well as the first algorithm but without the overhead, usually logging 0. 1 - 5% of the messages. This work is part of our larger effort on developing adaptive tracing strategies for debugging <ref> [3, 4] </ref>. 2. Motivation and related work Checkpointing and message logging have been used in many applications including parallel debugging [2, 8], fault-tolerant computing [7], and other areas [1]. <p> The iiiiiM relation shows where the unlogged messages are delivered: a iiiiiM b means that a sent a message that b received, and that the message was not logged (we write a iiiiiM b to denote the message). This definition differs slightly from that presented in our earlier work <ref> [4] </ref>. Messages that are logged can be retrieved from the log during replay, so they do not introduce replay dependences. edges represent the computation in between events (these edges are directed left to right but we omit the arrowheads), and their weights denote the cpu time required.
Reference: [5] <author> Robert H.B. Netzer and Mark H. Weaver, </author> <title> ``Optimal Tracing and Incremental Reexecution for Debugging Long-Running Programs,'' </title> <booktitle> ACM SIG-PLAN Conf. on Programming Language Design and Implementation, </booktitle> <address> Orlando, FL, </address> <month> (June </month> <year> 1994). </year>
Reference-contexts: It can adapt to the execution's message-passing patterns by selectively logging only those messages that cannot be quickly reproduced. Furthermore, it can also be used with other adaptive schemes (like incremental checkpointing) since each process is free to checkpoint at opportune moments <ref> [5] </ref>. In a previous paper we presented a method that adaptively logs messages to cut what we call domino dependences (chains of messages between two checkpoints of the same process see Figure 1 for an example)[4]. <p> These results suggest that our critical-path based technique bounded replay time with low message logging overhead. Because it does not depend on when checkpoints are taken (for reasonable checkpoint periods), it can be integrated with other adaptive schemes, such as incremental checkpointing <ref> [5] </ref> to further reduce the total overhead of supporting incremental replay. We simulated our algorithm from a message trace of a single execution of each program. Simulation allowed us to vary parameters and still analyze the same execution (different runs produce different executions since the programs are nondeterministic).
Reference: [6] <author> Y. M. Wang, P. Y. Chung, I. J. Lin, and W. K. Fuchs, </author> <title> ``Checkpoint Space Reclamation for Independent Checkpointing in Message-passing Systems,'' </title> <type> Tech. Rep. </type> <institution> CRHC-92-06, University of Illi-nois CSL., </institution> <year> (1992). </year>
Reference-contexts: However, this work does not solve the incremental replay problem for debugging. Recovering from faults requires only the ability to replay from the most recent checkpoint, and past work has focused on discarding old messages and checkpoints <ref> [6] </ref>. In contrast to recoveries, replays are requested often, and we must be able to quickly replay any part of the execution (old messages and checkpoints cannot be discarded). 3. Model First we outline a notation for representing program executions.
Reference: [7] <author> Y. M. Wang and W. K. Fuchs, </author> <title> ``Optimistic message logging for independent checkpointing in message-passing systems,'' </title> <booktitle> IEEE Symp. on Reliable Distributed Syst., </booktitle> <pages> pp. </pages> <month> 147-154 (Oct </month> <year> 1992). </year>
Reference-contexts: This work is part of our larger effort on developing adaptive tracing strategies for debugging [3, 4]. 2. Motivation and related work Checkpointing and message logging have been used in many applications including parallel debugging [2, 8], fault-tolerant computing <ref> [7] </ref>, and other areas [1]. Check-pointing supports incremental replay by saving each process' state periodically so that reexecution can start from a checkpoint instead of the execution's beginning. However, checkpointing alone is not enough.
Reference: [8] <author> Larry D. Wittie, </author> <title> ``Debugging Distributed C Programs by Real Time Replay,'' </title> <booktitle> SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <address> 57-67 Madison, WI, </address> <month> (May </month> <year> 1988). </year> <pages> 10 11 </pages>
Reference-contexts: This work is part of our larger effort on developing adaptive tracing strategies for debugging [3, 4]. 2. Motivation and related work Checkpointing and message logging have been used in many applications including parallel debugging <ref> [2, 8] </ref>, fault-tolerant computing [7], and other areas [1]. Check-pointing supports incremental replay by saving each process' state periodically so that reexecution can start from a checkpoint instead of the execution's beginning. However, checkpointing alone is not enough. <p> The difficult aspect of supporting incremental replay is balancing these two choices. Below we outline several options for addressing this problem and discuss what approaches past work has taken. One simple approach proposed in the past is to log all the messages <ref> [2, 8] </ref>. However, the run-time overhead of this approach is prohibitive. On modern machines, executions of even moderate length can pass gigabytes of data in messages. Another approach at the other extreme recreated to replay S 1,3 .
References-found: 8

