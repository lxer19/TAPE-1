URL: http://www.win.tue.nl/cs/tt/jaco/papers/mfsdb.ps.gz
Refering-URL: http://www.win.tue.nl/cs/tt/jaco/papers/
Root-URL: http://www.win.tue.nl
Email: jaco@win.tue.nl  hooman@cs.kun.nl  edejong@signaal.nl  
Title: Modular Formal Specification of Data and Behaviour in isolation, and the views of several components
Author: Jaco van de Pol Jozef Hooman Edwin de Jong 
Keyword: formal requirements specification, large scale embedded systems, modularity, multiple views, data and behaviour, states and events, linear temporal logic, PVS.  
Note: The proposed method is modular, because components can be specified and analysed  the conjunction.  
Address: P.O. Box 513, 5600 MB, Eindhoven, The Netherlands  P.O. Box 9010, 6500 GL, Nijmegen, The Netherlands  P.O. Box 42, 7550 GD, Hengelo, The Netherlands  
Affiliation: Dept. of Computing Science, Eindhoven University of Technology  Computing Science Institute, University of Nijmegen  Hollandse Signaalapparaten B.V.  
Abstract: We propose an approach to the formal modular specification of the requirements on large scale embedded systems. A mathematical framework supporting this approach is developed and implemented in the theorem prover PVS. The method is illustrated by formalising the requirements of a miniature embedded system. This specification is then analysed using the theorem prover, revealing some errors in the original specification. In this approach a specification consists of two views, describing the data and the allowed behaviour of a system. Abstract specifications are supported, because both requirements on data and on behaviour are stated in an assertional way. The data is specified by invariants on states of the system and behaviour is specified by temporal logic formulae on runs of the system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Barringer, R. Kuiper, and A. Pnueli. </author> <title> Now you may compose temporal logic specifications. </title> <booktitle> In ACM Symposium on Theory of Computing (STOC '84), </booktitle> <pages> pages 51-63. </pages> <publisher> ACM Press, </publisher> <year> 1984. </year>
Reference-contexts: Formalisms like CRL [4], and I/O-automata [9] have also a data description, but they remain control-oriented; only the visible actions of processes count. Moreover, specifications in these formalisms tend to be too operational for requirements engineering. Finally, formalisms based on temporal logic <ref> [10, 1] </ref>, and TLA [8], have a notion of state and state transitions, and behaviour can be specified by temporal assertions, but these formalisms lack a principle of hierarchically structured states, so they are not modular with respect to the data view. <p> In design, data and behaviour of components are refined, and structural components are combined by taking parallel composition. To allow refinement and composition, the model 18 has to be extended, with for instance stuttering steps [8], communication primitives and encapsulation. The work on compositionality, e.g. <ref> [1] </ref> may provide useful insights. Finally, this paper is not concerned with the design of concrete specification languages. Instead, we developed a mathematical framework. Eventually, a specification language is needed which is convenient and readable for engineers.
Reference: [2] <author> G. Booch. </author> <title> Object Oriented Analysis and Design with Applications. </title> <publisher> The Benjamin Cummings Publishing Co. Inc., </publisher> <year> 1991. </year>
Reference-contexts: In graphical languages, like UML [3] and STATEMATE [5], the emphasis is on express-ibility and scalability, rather than on the underlying mathematical framework. Comparing our approach with object-oriented analysis <ref> [2] </ref>, we see some similarities and differences. As in object orientation, we can specify components in isolation, and also have aggregates of components. These aggregates can form a hierarchy. Also multiple occurrences of the same component are allowed. However, our approach doesn't include object creation.
Reference: [3] <author> M. Fowler and K. Scott. </author> <title> UML Distilled: Applying the Standard Modeling Object Language. Object Technology Series. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: In graphical languages, like UML <ref> [3] </ref> and STATEMATE [5], the emphasis is on express-ibility and scalability, rather than on the underlying mathematical framework. Comparing our approach with object-oriented analysis [2], we see some similarities and differences. As in object orientation, we can specify components in isolation, and also have aggregates of components.
Reference: [4] <author> J.F. Groote and A. Ponse. </author> <title> The syntax and semantics of CRL. </title> <editor> In A. Ponse, C. Verhoef, and S.F.M. van Vlijmen, editors, </editor> <title> Algebra of Communicating Processes, </title> <booktitle> Utrecht 1994, Workshops in Computing, </booktitle> <pages> pages 26-62. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: Process algebras, on the other extreme, are completely control-oriented. The state is only implicitly present, as a kind of "program counter". Formalisms like CRL <ref> [4] </ref>, and I/O-automata [9] have also a data description, but they remain control-oriented; only the visible actions of processes count. Moreover, specifications in these formalisms tend to be too operational for requirements engineering.
Reference: [5] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, and A. Shtul-Trauring. </author> <title> STATEMATE; a working environment for the development of complex reactive systems. </title> <booktitle> In Proc. of the 10th Int. Conf. on Software Engineering, </booktitle> <pages> pages 396-406, </pages> <address> Singapore, 1988. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In graphical languages, like UML [3] and STATEMATE <ref> [5] </ref>, the emphasis is on express-ibility and scalability, rather than on the underlying mathematical framework. Comparing our approach with object-oriented analysis [2], we see some similarities and differences. As in object orientation, we can specify components in isolation, and also have aggregates of components. These aggregates can form a hierarchy.
Reference: [6] <author> C.B. Jones. </author> <title> Systematic Software Development using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> 2nd edition, </address> <year> 1990. </year>
Reference-contexts: The scheme calculus of Z [17], makes specifications modular with respect to the data view. Z specifications incorporate state invariants and transitions but no events. From a Z specification the interaction with the environment cannot be unambiguously inferred (this is also true of VDM <ref> [6] </ref>). This observation is not new: in Object-Z [14] an order on actions can be specified with temporal logic formulae; see also [7], where deontic logic is used to describe when certain actions are permitted or obliged. Process algebras, on the other extreme, are completely control-oriented.
Reference: [7] <author> S. Khosla and T. S. E. Maibaum. </author> <title> The prescription and description of state based systems. </title> <editor> In B. Banieqbal, H. Barringer, and A. Pnueli, editors, </editor> <booktitle> Temporal Logic in Specification, volume 398 of LNCS, </booktitle> <pages> pages 243-294. </pages> <publisher> Springer, </publisher> <year> 1987. </year>
Reference-contexts: From a Z specification the interaction with the environment cannot be unambiguously inferred (this is also true of VDM [6]). This observation is not new: in Object-Z [14] an order on actions can be specified with temporal logic formulae; see also <ref> [7] </ref>, where deontic logic is used to describe when certain actions are permitted or obliged. Process algebras, on the other extreme, are completely control-oriented. The state is only implicitly present, as a kind of "program counter".
Reference: [8] <author> L. Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <year> 1994. </year>
Reference-contexts: Atomic formulae: We have three atomic formulae, expressing the fact that a predicate on states, on events, or on state transitions holds at the start of the run. A predicate on state transitions is a binary relation on successive states (called an action in TLA <ref> [8] </ref>): Boolean operators: These are lifted to temporal logic by importing bool2pred of Figure 6 instantiated on runs. Modal operators: Modal operators can be defined analogously to their usual semantic definition. <p> Formalisms like CRL [4], and I/O-automata [9] have also a data description, but they remain control-oriented; only the visible actions of processes count. Moreover, specifications in these formalisms tend to be too operational for requirements engineering. Finally, formalisms based on temporal logic [10, 1], and TLA <ref> [8] </ref>, have a notion of state and state transitions, and behaviour can be specified by temporal assertions, but these formalisms lack a principle of hierarchically structured states, so they are not modular with respect to the data view. <p> Research on the smooth integration of requirements specification and design is needed. In design, data and behaviour of components are refined, and structural components are combined by taking parallel composition. To allow refinement and composition, the model 18 has to be extended, with for instance stuttering steps <ref> [8] </ref>, communication primitives and encapsulation. The work on compositionality, e.g. [1] may provide useful insights. Finally, this paper is not concerned with the design of concrete specification languages. Instead, we developed a mathematical framework. Eventually, a specification language is needed which is convenient and readable for engineers.
Reference: [9] <author> N.A. Lynch. </author> <title> I/O automata: A model for discrete event systems. </title> <booktitle> In Proc. of 22nd Conf. on Inf. Sciences and Systems, </booktitle> <pages> pages 29-38, </pages> <address> Princeton, NJ, USA, </address> <year> 1988. </year>
Reference-contexts: Process algebras, on the other extreme, are completely control-oriented. The state is only implicitly present, as a kind of "program counter". Formalisms like CRL [4], and I/O-automata <ref> [9] </ref> have also a data description, but they remain control-oriented; only the visible actions of processes count. Moreover, specifications in these formalisms tend to be too operational for requirements engineering.
Reference: [10] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems - Specification. </title> <publisher> Springer, </publisher> <year> 1992. </year> <month> 19 </month>
Reference-contexts: Formalisms like CRL [4], and I/O-automata [9] have also a data description, but they remain control-oriented; only the visible actions of processes count. Moreover, specifications in these formalisms tend to be too operational for requirements engineering. Finally, formalisms based on temporal logic <ref> [10, 1] </ref>, and TLA [8], have a notion of state and state transitions, and behaviour can be specified by temporal assertions, but these formalisms lack a principle of hierarchically structured states, so they are not modular with respect to the data view.
Reference: [11] <author> E.R. </author> <title> Olderog and C.A.R. Hoare. Specification-oriented semantics for communicating processes. </title> <journal> Acta Informatica, </journal> <volume> 23(1) </volume> <pages> 9-66, </pages> <year> 1986. </year>
Reference-contexts: In order to express more requirements on systems we will investigate other models of concurrency. Extensions with real-time will be considered, but we also consider ready traces, in order to express that certain input events should be enabled (cf. <ref> [11] </ref>). The analysis can then be extended by proving other interesting properties of a specification, for instance robustness, meaning that the specified system accepts all possible input. Research on the smooth integration of requirements specification and design is needed.
Reference: [12] <author> S. Owre, J.M. Rushby, N. Shankar, and F. Von Henke. </author> <title> Formal Verification of Fault-Tolerant Architectures: Prolegomena to the Design of PVS. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <year> 1995. </year>
Reference-contexts: It is required that its logic can express the mathematical framework that we develop in this paper as well as the specification of the requirements. We have implemented our ideas in PVS (Prototype Verification System) <ref> [12, 15] </ref>, which is based on typed higher-order classical logic. Problem statement. We look for a modular specification method in which it is possible to specify components independently, without knowledge of the complete system. The same component can then be used in different contexts. <p> These theories are generic in the sense that they can be used in each system specification without change. The second part consists of the actual requirements. For the running example this part is presented in Section 4. 3.1 Preliminary: the Theorem Prover PVS PVS (Prototype Verification System <ref> [12, 15] </ref>) is a specification language and a proof checker, based on typed higher-order classical logic, in which our mathematical framework can be easily expressed. Type checking reveals a lot of errors in a specification. When proving a theorem, PVS administrates the (sub)theorems still to be proved. <p> The boolean operators are written &, =&gt;, OR, NOT (conjunction, implication, disjunction and negation). We introduce some of the basic notations of PVS. For a full explanation we refer to <ref> [12] </ref>. Function types are written as in [nat,real-&gt;bool], which denotes the collection of relations between natural and real numbers. Functions can be written in lambda notation, as in LAMBDA (m:nat,z:real) : z*z=m, which has the type just mentioned. Quantifiers can be used, as in e.g. FORALL (m:nat): EXISTS (z:real): z*z=m.
Reference: [13] <author> J.C. van de Pol, J.J.M. Hooman, and E. de Jong. </author> <title> Formal requirements specification for command and control systems. </title> <booktitle> In Proc. of the Conf. on Engineering of Computer Based Systems, </booktitle> <pages> pages 37-44, </pages> <address> Jerusalem, 1998. </address> <publisher> IEEE. </publisher>
Reference-contexts: Formal analysis consists of proving theorems on the specification. We will discuss two different checks in the sequel. We also discuss the degree of automation in the proofs of the theorems in PVS. 5.1 Compatibility of State Transitions and Invariants The first check is taken from <ref> [13] </ref>. The specification contains invariants, and also a number of state transitions. The intended meaning is that state transitions should maintain the invariant. In particular, if the counter values are incremented, z must be recomputed due to the integrity constraint z = x:value y:value.
Reference: [14] <editor> G. Rose. Object-Z. In S. Stepney, R. Barden, and D. Cooper, editors, </editor> <title> Object Orientation in Z, </title> <booktitle> Workshops in Computing, </booktitle> <pages> pages 59-77. </pages> <publisher> Springer, </publisher> <year> 1992. </year>
Reference-contexts: Z specifications incorporate state invariants and transitions but no events. From a Z specification the interaction with the environment cannot be unambiguously inferred (this is also true of VDM [6]). This observation is not new: in Object-Z <ref> [14] </ref> an order on actions can be specified with temporal logic formulae; see also [7], where deontic logic is used to describe when certain actions are permitted or obliged. Process algebras, on the other extreme, are completely control-oriented. The state is only implicitly present, as a kind of "program counter".
Reference: [15] <author> S. Owre, S. Rajan, J.M. Rushby, N. Shankar, and M.K. Srivas. PVS: </author> <title> Combining specification, proof checking, and model checking. </title> <editor> In R. Alur and T.A. Henzinger, editors, </editor> <booktitle> Proc. of the 8th Int. Conf. on Computer Aided Verification, volume 1102 of LNCS, </booktitle> <pages> pages 411-414. </pages> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: It is required that its logic can express the mathematical framework that we develop in this paper as well as the specification of the requirements. We have implemented our ideas in PVS (Prototype Verification System) <ref> [12, 15] </ref>, which is based on typed higher-order classical logic. Problem statement. We look for a modular specification method in which it is possible to specify components independently, without knowledge of the complete system. The same component can then be used in different contexts. <p> These theories are generic in the sense that they can be used in each system specification without change. The second part consists of the actual requirements. For the running example this part is presented in Section 4. 3.1 Preliminary: the Theorem Prover PVS PVS (Prototype Verification System <ref> [12, 15] </ref>) is a specification language and a proof checker, based on typed higher-order classical logic, in which our mathematical framework can be easily expressed. Type checking reveals a lot of errors in a specification. When proving a theorem, PVS administrates the (sub)theorems still to be proved.
Reference: [16] <author> I. Sommerville and P. Sawyer. </author> <title> Requirements Engineering. </title> <publisher> Wiley, </publisher> <address> Chichester, </address> <year> 1997. </year>
Reference-contexts: Hence it is a difficult and error-prone task to build such systems. To have a solid basis for system development it is important to have an unambiguous and truthful description of the requirements on such systems. Requirements engineering. We refer to <ref> [16] </ref> for a general treatise on requirements engineering. The requirements specification is the starting point of the development of large systems. Errors in the specification propagate to all later phases in the development, until they are detected.
Reference: [17] <author> J.M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <publisher> Prentice Hall, </publisher> <address> 2nd edition, </address> <year> 1992. </year>
Reference-contexts: The generic framework can be reused for other specifications without change. The analysis concentrated on compatibility of invariants and state transitions and on validating and rejecting scenarios. Related Work. We briefly summarise some existing specification formalisms. The scheme calculus of Z <ref> [17] </ref>, makes specifications modular with respect to the data view. Z specifications incorporate state invariants and transitions but no events. From a Z specification the interaction with the environment cannot be unambiguously inferred (this is also true of VDM [6]).
Reference: [18] <author> P. Zave and M. Jackson. </author> <title> Where do operations come from? A multiparadigm specification technique. </title> <journal> IEEE Trans. on SE, </journal> <volume> 22(7) </volume> <pages> 508-528, </pages> <year> 1996. </year> <month> 20 </month>
Reference-contexts: Such a language might include restricted versions of class diagrams, finite automata, tabular representations or process expressions. Partial specifications must be mapped systematically into the common underlying mathematical framework, in order to obtain a sound multi-paradigm specification method (cf. <ref> [18] </ref>). Acknowledgements. We like to thank Roel Bloo and Dieter Hammer from the Technical University Eindhoven for critical comments on previous versions of this paper. We are also grateful to Martin Streng from Hollandse Signaalapparaten B.V. for discussions on the applicability of our method.
References-found: 18

