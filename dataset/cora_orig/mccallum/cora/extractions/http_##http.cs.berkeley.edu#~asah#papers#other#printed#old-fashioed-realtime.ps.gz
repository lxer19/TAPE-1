URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/old-fashioed-realtime.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/
Root-URL: http://www.cs.berkeley.edu
Title: 91 An Old-Fashioned Recipe for Real Time  
Author: Mart n Abadi and Leslie Lamport 
Date: October 12, 1992  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martn Abadi and Leslie Lamport. </author> <title> Composing specifications. </title> <editor> In J. W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Stepwise Refinement of Distributed Systems, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-41. </pages> <publisher> Springer-Verlag, </publisher> <month> May/June </month> <year> 1989. </year>
Reference-contexts: This rule is circular, because a component's specification requires only that it behave correctly if its environment does, and its environment consists of all the other components. Despite its circularity, the rule is sound for specifications written in a particular style <ref> [1, 15, 17] </ref>. By examining an apparently paradoxical example, we discover how real-time specifications of open systems can be written in this style. 2 Closed Systems We briefly review how to represent closed systems in TLA. <p> An open system interacts with an environment, where system steps are distinguished from environment steps. Sections 4.1 and 4.2 reformulate a number of concepts introduced in <ref> [1] </ref> that are needed for treating open systems in TLA. Some new results appear in Section 4.3. <p> Intuitively, 5 is -receptive iff every behavior in 5 can be achieved by an implementation that performs only steps the environment being able to perform any : step. The concept of receptiveness is due to Dill [8]. The generalization to -receptiveness is developed in <ref> [1] </ref>. 8 A safety property is -receptive iff it constrains at most . The generalization of machine closure to open systems is machine realizability. <p> Formally, .5; L/ is defined to be -machine realizable iff .5; L/ is machine closed and 5 ^ L is -receptive. For equal to true, machine realizability reduces to machine closure. 8 To translate from the semantic model of <ref> [1] </ref> into that of TLA, we let agents be pairs of states and identify an action with the set of all agents that are steps. <p> A TLA behavior s 1 ; s 2 ; : : : corresponds to the sequence s 1 ff 2 ff 3 ff 4 ! : : : , where ff i equals .s i1 ; s i /. With this translation, the definitions in <ref> [1] </ref> differ from the ones given here and in the appendix mainly by attributing the choice of initial state to the environment rather than to the system, requiring initial conditions to be assumptions about the environment rather than guarantees by the system. 24 4.2 The F Operator A common way of <p> This is sufficient for our purposes, since NZ is a liveness property. The generalization of Proposition 2 is omitted; it would be analogous to Proposition 10 of <ref> [1] </ref>. Proposition 4 is stated in terms of -invariance, which generalizes the ordinary concept of invariance. A predicate P is a -invariant of a formula 5 iff, in any behavior satisfying 5, no -step makes P false. <p> The proof that the composition of two specifications implements a third specification is based on the following result, which is a reformulation of Theorem 2 of <ref> [1] </ref> for safety properties. Theorem 3 If E, E 1 , E 2 ,, M 1 , and M 2 are safety properties and 1 and 2 are actions such that 1. E 1 does not constrain 1 and E 2 does not constrain 2 , 2. <p> What happened to the simplicity? 32 About half of the exposition is a review of concepts unrelated to real time. All the fundamental concepts described in Sections 2 and 4, including machine closure, machine realizability, and the F operator, have appeared before <ref> [1, 2] </ref>. These concepts are subtle, but they are important for understanding any concurrent system; they were not invented for real-time systems. We chose to formulate these concepts in TLA. Like any language, TLA seems complicated on first encounter. <p> Open systems made up for any lack of difficulty with closed systems. State-based approaches to open systems were a fairly recent development, and we had little experience with them. Studying real-time systems taught us a great deal, and led to a number of changes from the approach in <ref> [1] </ref>. For example, we now write specifications with F instead of ), and we put initial conditions in the system guarantee rather than in the environment assumption. Many alternative ways of writing real-time specifications seemed plausible; choosing one that works was surprisingly hard. <p> PROOF: This is proved in Proposition 9 of <ref> [1] </ref>. Lemma 2 .5; L/ is -machine realizable iff for every finite behavior t satisfying 5, there exists a -strategy f such that O . f; t / 5 ^ L. h1i1. ASSUME: 1. <p> v/ 4. 8 j 2 J P : 5 ) P T imer .T j ; A j ; 1 j ; v/ PROOF: J P and J V exist by assumption h0i.3b. h1i2. 5 t ) 2Inv, where Inv D 1.^ 8 j 2 J : T j 2 <ref> [now; 1] </ref> 3.^ 8 j 2 J : .Enabled hA j i v D Enabled .hA j i v ^ .now 0 D now// 4.^ 8k 2 I " J : t k T k 5.^ 8 j 2 J V : :Enabled hA j i v ) .T j D <p> ) VTimer.T j ; A j ; 1 j ; v/ 4. 8 j 2 J P : 5 ) P T imer .T j ; A j ; 1 j ; v/ h1i2. 5 t ) 2Inv, where Inv D 1.^ 8 j 2 J : T j 2 <ref> [now; 1] </ref> 3.^ 8 j 2 J : .Enabled hA j i v D Enabled .hA j i v ^ .now 0 D now// 4.^ 8k 2 I " J : t k T k 5.^ 8 j 2 J V : :Enabled hA j i v ) .T j D <p> Q.E.D. h6i3. CASE: T 2 <ref> [r C 1; 1] </ref> PROOF: Impossible by h6i1 and I 0 .1. h6i4. Q.E.D. PROOF: h6i2, h6i3, I .3.1, and case assumption h5i. h5i3. Q.E.D. PROOF: h5i1 and h5i2. h4i3. P ^ I ) Enabled hAi f PROOF: h2i1. h4i4. Q.E.D. PROOF: h4i1, h4i2, h4i3, and Lemma 3. h3i2. <p> I ^ I 0 ^ [N ] f ) . P 0 _ Q 0 / PROOF: Immediate, since P 0 D true. h3i2. ASSUME: P ^ I ^ I 0 ^ hN ^ Ai f PROVE: Q 0 h4i1. T 2 <ref> [r C 1; 1] </ref> PROOF: By I . h4i2. hNowTi now PROOF: By h4i1, I .2, and A. h4i3. Q.E.D. PROOF: h4i1, h4i2, and the definition of NowT. h3i3. P ^ I ) Enabled hAi f PROOF: h3i1. h3i4. Q.E.D. PROOF: h3i1, h3i2, h3i3, and Lemma 3. h2i6.
Reference: [2] <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: We begin our review of TLA with an example. Section 2.2 summarizes the formal definitions. A more leisurely exposition appears in [13], and most definitions in the current paper are repeated in a list in the appendix. Section 2.3 reviews the concepts of safety [4] and machine closure <ref> [2] </ref> (also known as feasibility [5]) and relates them to TLA, and Section 2.4 defines a useful class of history variables [2]. 2 - - ibit ival obit oval q: : : : last: Propositions and theorems are proved in the appendix. 2.1 The Lossy-Queue Example We introduce TLA with the <p> Section 2.3 reviews the concepts of safety [4] and machine closure <ref> [2] </ref> (also known as feasibility [5]) and relates them to TLA, and Section 2.4 defines a useful class of history variables [2]. 2 - - ibit ival obit oval q: : : : last: Propositions and theorems are proved in the appendix. 2.1 The Lossy-Queue Example We introduce TLA with the example of the lossy queue shown in Figure 1. <p> Machine closure for more general classes of properties can be proved with the following two propositions, which are proved in the appendix. To apply the first, one must prove that 9x : 5 is a safety property. By Proposition 2 of <ref> [2, page 265] </ref>, it suffices to prove that 5 has finite internal nondeterminism (fin), with x as its internal state component. Here, fin means roughly that there are only a finite number of sequences of values for x that can make a finite behavior satisfy 5. <p> In other words, conjoining Hist.h; f; g; v/ to 8 does not change the behavior of its variables, so it makes h a dummy variable for 8in fact, it is a special kind of history variable <ref> [2, page 270] </ref>. 3 More precisely, T ^ A will imply w 0 6D w, where T is the type-correctness invariant. 10 As an example, we add to the lossy queue's specification 8 Q a history variable hin that records the sequence of values transmitted on the input wire. <p> So far, we have been discussing nonZenoness of the internal specification, where both the timers and the system's internal variables are visible. Timers are defined by adding history-determined variables, so existentially quantifying over them preserves nonZenoness by Proposition 2. We expect most specifications to be fin <ref> [2, page 263] </ref>, so nonZenoness will also be preserved by existentially quantifying over the system's internal variables. <p> What happened to the simplicity? 32 About half of the exposition is a review of concepts unrelated to real time. All the fundamental concepts described in Sections 2 and 4, including machine closure, machine realizability, and the F operator, have appeared before <ref> [1, 2] </ref>. These concepts are subtle, but they are important for understanding any concurrent system; they were not invented for real-time systems. We chose to formulate these concepts in TLA. Like any language, TLA seems complicated on first encounter.
Reference: [3] <author> Martn Abadi and Gordon Plotkin. </author> <title> A logical view of composition. </title> <type> Research Report 86, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: E ) M / and, for every finite prefix of , if satisfies E then satisfies M . If E and M are safety properties, then E F M is as well. For safety properties, the operator F is the implication operator of an intuitionistic logic <ref> [3] </ref>. Most valid propositional formulas without negation remain valid when ) is replaced by F, if all the formulas that appear on the left of a F are safety properties. <p> M 1 constrains at most 1 and M 2 constrains at most 2 , then the following proof rule is valid: E ^ M 1 ^ M 2 ) E 1 ^ E 2 This theorem is essentially the same as Theorem 1 of <ref> [3] </ref>; the proof is omitted. 5 Real-Time Open Systems In Section 3, we saw how we can represent time by the variable now and introduce timing constraints with timers.
Reference: [4] <author> Bowen Alpern and Fred B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: We begin our review of TLA with an example. Section 2.2 summarizes the formal definitions. A more leisurely exposition appears in [13], and most definitions in the current paper are repeated in a list in the appendix. Section 2.3 reviews the concepts of safety <ref> [4] </ref> and machine closure [2] (also known as feasibility [5]) and relates them to TLA, and Section 2.4 defines a useful class of history variables [2]. 2 - - ibit ival obit oval q: : : : last: Propositions and theorems are proved in the appendix. 2.1 The Lossy-Queue Example We <p> Property SF v .EnQ/ asserts that if action EnQ is enabled infinitely often, then infinitely many EnQ steps must occur. It implies that if infinitely many inputs are sent, then the queue must receive infinitely many of them. The formula (2) implies the liveness property <ref> [4] </ref> that an infinite number of inputs produces an infinite number of outputs. This formula also implies the same safety properties as 8 Q . <p> We say that a finite behavior satisfies a property F iff it can be continued to an infinite behavior in F. A property F is a safety property <ref> [4] </ref> iff the following condition holds: F contains a behavior iff 8 it is satisfied by every finite prefix of the behavior. 1 Intuitively, a safety property asserts that something bad does not happen. Predicates and formulas of the form 2 [A] f are safety properties.
Reference: [5] <author> Krzysztof R. Apt, Nissim Francez, and Shmuel Katz. </author> <title> Appraising fairness in languages for distributed programming. </title> <journal> Distributed Computing, </journal> <volume> 2 </volume> <pages> 226-241, </pages> <year> 1988. </year>
Reference-contexts: Section 2.2 summarizes the formal definitions. A more leisurely exposition appears in [13], and most definitions in the current paper are repeated in a list in the appendix. Section 2.3 reviews the concepts of safety [4] and machine closure [2] (also known as feasibility <ref> [5] </ref>) and relates them to TLA, and Section 2.4 defines a useful class of history variables [2]. 2 - - ibit ival obit oval q: : : : last: Propositions and theorems are proved in the appendix. 2.1 The Lossy-Queue Example We introduce TLA with the example of the lossy queue
Reference: [6] <author> Arthur Bernstein and Paul K. Harter, Jr. </author> <title> Proving real time properties of programs with temporal logic. </title> <booktitle> In Proceedings of the Eighth Symposium on Operating Systems Principles, </booktitle> <pages> pages 1-11, </pages> <address> New York, </address> <year> 1981. </year> <journal> ACM. Operating Systems Review 15, </journal> <volume> 5. </volume>
Reference-contexts: The first application we have seen of a clearly off-the-shelf method to a real-time algorithm was in 1983 [16], but there were probably earlier ones. Indeed, the extension of an existing temporal logic to real-time programs by Bernstein and Harter in 1981 <ref> [6] </ref> can be viewed as an application of that logic. The old-fashioned methods handle real time by introducing a variable, which we call now, to represent time.
Reference: [7] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: Fortunately, no fundamental change to the old methods for specifying and reasoning about systems is needed for these new classes. It has long been known that the methods originally developed for shared-memory multiprocessing apply equally well to distributed systems <ref> [7, 11] </ref>. The first application we have seen of a clearly off-the-shelf method to a real-time algorithm was in 1983 [16], but there were probably earlier ones.
Reference: [8] <author> David L. Dill. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-Independent Circuits. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: The generalization to arbitrary properties of constraining at most is -receptiveness. Intuitively, 5 is -receptive iff every behavior in 5 can be achieved by an implementation that performs only steps the environment being able to perform any : step. The concept of receptiveness is due to Dill <ref> [8] </ref>. The generalization to -receptiveness is developed in [1]. 8 A safety property is -receptive iff it constrains at most . The generalization of machine closure to open systems is machine realizability.
Reference: [9] <author> Michael Fischer. Re: </author> <title> Where are you? E-mail message to Leslie Lamport. Arpanet message number 8506252257.AA07636@YALE-BULLDOG.YALE.ARPA (47 lines), </title> <address> June 25, 1985 18:56:29 EDT. </address>
Reference-contexts: This is the case for the timed queue. 3.4 An Example: Fischer's Protocol As another example of real-time closed systems, we treat a simplified version of a real-time mutual exclusion protocol proposed by Fischer <ref> [9] </ref>, [12, page 2]. The example was suggested by Schneider [18].
Reference: [10] <author> Cliff B. Jones. </author> <title> Specification and design of (parallel) programs. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of the IFIP 9th World Congress, </booktitle> <pages> pages 321-332. </pages> <publisher> IFIP, North-Holland, </publisher> <month> September </month> <year> 1983. </year>
Reference-contexts: by attributing the choice of initial state to the environment rather than to the system, requiring initial conditions to be assumptions about the environment rather than guarantees by the system. 24 4.2 The F Operator A common way of specifying an open system is in terms of assumptions and guarantees <ref> [10] </ref>, requiring the system to guarantee a property M if its environment satisfies an assumption E. An obvious formalization of such a specification is the property E ) M . However, this property contains behaviors in which the system violates M and then the environment later violates E.
Reference: [11] <author> Leslie Lamport. </author> <title> An assertional correctness proof of a distributed algorithm. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 2(3) </volume> <pages> 175-206, </pages> <month> December </month> <year> 1982. </year> <month> 61 </month>
Reference-contexts: Fortunately, no fundamental change to the old methods for specifying and reasoning about systems is needed for these new classes. It has long been known that the methods originally developed for shared-memory multiprocessing apply equally well to distributed systems <ref> [7, 11] </ref>. The first application we have seen of a clearly off-the-shelf method to a real-time algorithm was in 1983 [16], but there were probably earlier ones.
Reference: [12] <author> Leslie Lamport. </author> <title> A fast mutual exclusion algorithm. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(1) </volume> <pages> 1-11, </pages> <month> February </month> <year> 1987. </year>
Reference-contexts: This is the case for the timed queue. 3.4 An Example: Fischer's Protocol As another example of real-time closed systems, we treat a simplified version of a real-time mutual exclusion protocol proposed by Fischer [9], <ref> [12, page 2] </ref>. The example was suggested by Schneider [18].
Reference: [13] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <type> Research Report 79, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: The result can be a complicated program that is hard to understand and easy to get wrong. We take as our formalism TLA, the temporal logic of actions <ref> [13] </ref>. In TLA, programs and properties are represented as logical formulas. A real-time program can be written as the conjunction of its untimed version, expressed in a standard way as a TLA formula, and its timing assumptions, expressed in terms of a few standard parameterized formulas. <p> Open systems, in which the environment and system are separated, are discussed in Section 4. We begin our review of TLA with an example. Section 2.2 summarizes the formal definitions. A more leisurely exposition appears in <ref> [13] </ref>, and most definitions in the current paper are repeated in a list in the appendix. <p> Type correctness of 5 Q is asserted by the formula 5 Q ) 2T Q , which is easily proved <ref> [13] </ref>. Type correctness of 8 Q follows from 5 Q ) 2T Q by the usual rules for reasoning about quantifiers. <p> The approximate meaning of quantification over a flexible variable is that 9x : F is true for a behavior iff there is some sequence of values that can be assigned to x that makes F true. The precise definition appears in <ref> [13] </ref> and is recalled in the appendix. As usual, we write 9 x 1 ; : : : ; x n : F instead of 9 x 1 : : : : ; 9 x n : F. <p> Like any language, TLA seems complicated on first encounter. We believe that a true measure of simplicity of a formal language is the simplicity of its formal description. The complete syntax and formal semantics of TLA are given in about 1-1/2 pages of figures in <ref> [13] </ref>. We never claimed that specifying and reasoning about concurrent systems is easy. Verifying concurrent systems is difficult and error prone. Our assertions that one formula follows from another, made so casually in the exposition, must be backed up by detailed calculations. <p> The formal specification of Fischer's protocol in Figure 4, obtained by conjoining timing constraints to the untimed protocol, is as simple and direct as we could have hoped for. Moreover, the formal correctness proofs of this protocol and of the queue example, using the method of reasoning described in <ref> [13] </ref>, were straightforward. Perhaps the most profound discovery was the relation between nonZenoness and machine closure. Open systems made up for any lack of difficulty with closed systems. State-based approaches to open systems were a fairly recent development, and we had little experience with them. <p> P 0 _ Q 0 / 3. P ^ I ) Enabled hAi f . then WF f .A/ ^ 2I ^ 2 [N ] f ) . P ; Q/ PROOF: This is a simple generalization of rule WF1 of <ref> [13] </ref>; the proof of soundness is omitted. Lemma 4 For any actions A and B, state function f , variable x , predicate P, and property 5: 1. (a) . <p> i .now;v/ , Lemma 4.4 implies that the disjunction of subactions is a sub-action, and Lemma 4.3 implies that if D is a subaction, then P ^ D is also a subaction, for any predicate P. h1i5. 5 t ^ WF .now;v/ .C/ ) NZ PROOF: By the Lattice Rule <ref> [13] </ref>, it suffices to ASSUME: r 2 R PROVE: 5 t ^ WF .now;v/ .C/ ) . .now D r / ; .now 2 [r C 1; 1// / PROOF SKETCH: The standard method of proving that now D r leads to now 2 [r C 1; 1/ is to assume <p> Q.E.D. PROOF: h3i1, h4i1, and h1i2, since 5 t ) 2 [TimerAct] .now;v/ by assump tion h0i.3b. h3i3. Q.E.D. PROOF: Since U and V are finite by assumption h0i.0d, it follows from h3i2 and the Lattice Rule <ref> [13] </ref> that 5 t ^ 2.now 2 [r; r C 1// ^ WF .now;v/ .C/ implies 3.U D ;/.
Reference: [14] <author> Keith Marzullo, Fred B. Schneider, and Navin Budhiraja. </author> <title> Derivation of sequential, real-time process-control programs. </title> <editor> In Andr e M. van Tilborg and Gary M. Koob, editors, </editor> <booktitle> Foundations of Real-Time Computing: Formal Specifications and Methods, chapter 2, </booktitle> <pages> pages 39-54. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, Dordrecht, and London, </address> <year> 1991. </year>
Reference-contexts: The observation that continuous parameters other than time can be modeled by program variables has probably been known for years. However, the first published work we know of that uses this idea, by Marzullo, Schneider, and Budhiraja <ref> [14] </ref>, appeared only recently. 34 Appendix A Definitions A.1 States and Behaviors 6: The set of all states (assignments of values to variables). 6 fl : The set of finite behaviors (finite sequences of states). 6 1 : The set of behaviors (infinite sequences of states). : The empty sequence. j
Reference: [15] <author> Jayadev Misra and K. Mani Chandy. </author> <title> Proofs of networks of processes. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7(4):417-426, </volume> <month> July </month> <year> 1981. </year>
Reference-contexts: This rule is circular, because a component's specification requires only that it behave correctly if its environment does, and its environment consists of all the other components. Despite its circularity, the rule is sound for specifications written in a particular style <ref> [1, 15, 17] </ref>. By examining an apparently paradoxical example, we discover how real-time specifications of open systems can be written in this style. 2 Closed Systems We briefly review how to represent closed systems in TLA.
Reference: [16] <author> Peter G. Neumann and Leslie Lamport. </author> <title> Highly dependable distributed systems. </title> <type> Technical report, </type> <institution> SRI International, </institution> <month> June </month> <year> 1983. </year> <title> Contract Number DAEA18-81-G-0062, SRI Project 4180. </title>
Reference-contexts: It has long been known that the methods originally developed for shared-memory multiprocessing apply equally well to distributed systems [7, 11]. The first application we have seen of a clearly off-the-shelf method to a real-time algorithm was in 1983 <ref> [16] </ref>, but there were probably earlier ones. Indeed, the extension of an existing temporal logic to real-time programs by Bernstein and Harter in 1981 [6] can be viewed as an application of that logic.
Reference: [17] <author> Amir Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <editor> In Krzysztof R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, NATO ASI Series, </booktitle> <pages> pages 123-144. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1984. </year>
Reference-contexts: This rule is circular, because a component's specification requires only that it behave correctly if its environment does, and its environment consists of all the other components. Despite its circularity, the rule is sound for specifications written in a particular style <ref> [1, 15, 17] </ref>. By examining an apparently paradoxical example, we discover how real-time specifications of open systems can be written in this style. 2 Closed Systems We briefly review how to represent closed systems in TLA.

References-found: 17

