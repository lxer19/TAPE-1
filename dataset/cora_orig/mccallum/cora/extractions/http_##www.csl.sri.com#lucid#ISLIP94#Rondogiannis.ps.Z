URL: http://www.csl.sri.com/lucid/ISLIP94/Rondogiannis.ps.Z
Refering-URL: http://www.csl.sri.com/lucid/ISLIP94/electronic-proceedings.html
Root-URL: 
Email: e-mail: fprondo,wwadgeg@csr.uvic.ca  
Title: Transforming First-Order Functional Programs to Intensional Programs of Nullary Variables: Theoretical Foundations  
Author: P. Rondogiannis and W. W. Wadge 
Address: P.O. Box 3055, Victoria, B.C. CANADA V8W 3P6.  
Affiliation: Department of Computer Science University of Victoria  
Abstract: In this paper we present a revised formulation and a correctness proof of Yaghi's [Yag84] transformation algorithm from first-order extensional programs to intensional programs of nullary variables. The formal definition of the algorithm is a functional one, and its main difference from the one given in [Yag84] is that if two expressions in the source program are identical, then they are assigned identical intensional expressions during the translation. The correctness proof of the algorithm is established by showing that a function call in the extensional program has informally speaking the same meaning as the intensional expression that results from its translation.
Abstract-found: 1
Intro-found: 1
Reference: [AW76] <author> E. Ashcroft and W. Wadge. </author> <title> Lucid a formal system for writing and proving programs. </title> <journal> SIAM J. on Computing, </journal> <volume> 5(3) </volume> <pages> 336-354, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: He then proposed an algorithm for transforming first-order functional programs into programs of this language. Yaghi's work, apart from its theoretical significance, had practical implications as well: the resulting intensional programs can be interpreted in a very simple way. In fact, the Lucid functional-dataflow language <ref> [AW76, AW77, WA85, EAAJ91] </ref>, other Lucid-related systems [DW90b, DW90a], as well as standard functional languages [RW93, RW94b], have been successfully implemented based on this approach. However, there are two important aspects of the technique, that were not developed in [Yag84]: 1.
Reference: [AW77] <author> E. Ashcroft and W. Wadge. </author> <title> Lucid, a Nonprocedural Language with Iteration. </title> <journal> Communications of the ACM, </journal> <volume> 20(7) </volume> <pages> 519-526, </pages> <month> July </month> <year> 1977. </year>
Reference-contexts: He then proposed an algorithm for transforming first-order functional programs into programs of this language. Yaghi's work, apart from its theoretical significance, had practical implications as well: the resulting intensional programs can be interpreted in a very simple way. In fact, the Lucid functional-dataflow language <ref> [AW76, AW77, WA85, EAAJ91] </ref>, other Lucid-related systems [DW90b, DW90a], as well as standard functional languages [RW93, RW94b], have been successfully implemented based on this approach. However, there are two important aspects of the technique, that were not developed in [Yag84]: 1.
Reference: [DW90a] <author> W. Du and W. W. Wadge. </author> <title> The Eductive Implementation of a Three-dimensional Spreadsheet. </title> <journal> Software-Practice and Experience, </journal> 20(11) 1097-1114, November 1990. 
Reference-contexts: Yaghi's work, apart from its theoretical significance, had practical implications as well: the resulting intensional programs can be interpreted in a very simple way. In fact, the Lucid functional-dataflow language [AW76, AW77, WA85, EAAJ91], other Lucid-related systems <ref> [DW90b, DW90a] </ref>, as well as standard functional languages [RW93, RW94b], have been successfully implemented based on this approach. However, there are two important aspects of the technique, that were not developed in [Yag84]: 1. The transformation algorithm from extensional to intensional programs presented in [Yag84], is semi-formal and non-functional. 2.
Reference: [DW90b] <author> W. </author> <title> Du and W.W.Wadge. A 3D Spreadsheet Based on Intensional Logic. </title> <journal> IEEE Software, </journal> <pages> pages 78-89, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Yaghi's work, apart from its theoretical significance, had practical implications as well: the resulting intensional programs can be interpreted in a very simple way. In fact, the Lucid functional-dataflow language [AW76, AW77, WA85, EAAJ91], other Lucid-related systems <ref> [DW90b, DW90a] </ref>, as well as standard functional languages [RW93, RW94b], have been successfully implemented based on this approach. However, there are two important aspects of the technique, that were not developed in [Yag84]: 1. The transformation algorithm from extensional to intensional programs presented in [Yag84], is semi-formal and non-functional. 2.
Reference: [DWP81] <author> D. Dowty, R. Wall, and S. Peters. </author> <title> Introduction to Montague Semantics. </title> <publisher> Reidel Publishing Company, </publisher> <year> 1981. </year>
Reference-contexts: 1 Introduction The first work to establish a transformation algorithm from extensional to intensional programs, was A. Yaghi's Ph.D. dissertation [Yag84]. Motivated by Montague's intensional logic <ref> [Mon74, DWP81] </ref>, Yaghi first defined a simple intensional programming language, whose syntax only allowed nullary variable definitions. He then proposed an algorithm for transforming first-order functional programs into programs of this language.
Reference: [EAAJ91] <author> A. A. Faustini E. A. Ashcroft and R. Jagannathan. </author> <title> An Intensional Language for Parallel Applications Programming. </title> <editor> In B.K.Szymanski, editor, </editor> <booktitle> Parallel Functional Languages and Compilers, </booktitle> <pages> pages 11-49. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: He then proposed an algorithm for transforming first-order functional programs into programs of this language. Yaghi's work, apart from its theoretical significance, had practical implications as well: the resulting intensional programs can be interpreted in a very simple way. In fact, the Lucid functional-dataflow language <ref> [AW76, AW77, WA85, EAAJ91] </ref>, other Lucid-related systems [DW90b, DW90a], as well as standard functional languages [RW93, RW94b], have been successfully implemented based on this approach. However, there are two important aspects of the technique, that were not developed in [Yag84]: 1.
Reference: [Gun92] <author> C. Gunter. </author> <title> Semantics of Programming Languages. </title> <publisher> The MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: The correctness proof for the transformation is given in Section 5, and the paper concludes by discussing the main points of our work. In the following sections, we assume a basic familiarity with the work described in [Yag84], as well as an understanding of domain theory and denotational semantics <ref> [Sto77, Ten91, Gun92] </ref>. 2 Yaghi's Transformation Algorithm This section presents an outline of Yaghi's transformation algorithm. The source extensional language under consideration, is a first-order subset of ISWIM [Lan66], referred as Iwade in [Yag84].
Reference: [Lan66] <author> P. J. Landin. </author> <title> The Next 700 Programming Languages. </title> <journal> Communications of the ACM, </journal> <volume> 9(3) </volume> <pages> 157-166, </pages> <month> Mar. </month> <year> 1966. </year>
Reference-contexts: The source extensional language under consideration, is a first-order subset of ISWIM <ref> [Lan66] </ref>, referred as Iwade in [Yag84]. Intuitively, Iwade does not allow nested where clauses, and it requires that all variables in a program are distinct. The target intensional language is referred as DE in [Yag84], and it only allows nullary variable definitions.
Reference: [LP81] <author> H. Lewis and C. Papadimitriou. </author> <title> Elements of the Theory of Computation. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Therefore, we revise Yaghi's algorithm so as to operate in a "referentially transparent" way: identical function calls should be assigned identical intensional expressions. For this purpose, we will use a Godel numbering function. Let Exp be the set of expressions of programs of Iwade. Then: Theorem 3.1 <ref> [LP81, pages 242-243] </ref> There exists a one-to-one map de : Exp ! N . For every E 2 Exp, dEe is called the Godel number of E.
Reference: [Mon74] <author> R. </author> <title> Montague. </title> <booktitle> Formal Philosophy, Selected Papers of R. </booktitle> <publisher> Montague. Yale University Press, </publisher> <year> 1974. </year>
Reference-contexts: 1 Introduction The first work to establish a transformation algorithm from extensional to intensional programs, was A. Yaghi's Ph.D. dissertation [Yag84]. Motivated by Montague's intensional logic <ref> [Mon74, DWP81] </ref>, Yaghi first defined a simple intensional programming language, whose syntax only allowed nullary variable definitions. He then proposed an algorithm for transforming first-order functional programs into programs of this language.
Reference: [RW93] <author> P. Rondogiannis and W. Wadge. </author> <title> A Dataflow Implementation Technique for Lazy Typed Functional Languages. </title> <booktitle> In Proceedings of the Sixth International Symposium on Lucid and Intensional Programming, </booktitle> <pages> pages 23-42, </pages> <year> 1993. </year>
Reference-contexts: Yaghi's work, apart from its theoretical significance, had practical implications as well: the resulting intensional programs can be interpreted in a very simple way. In fact, the Lucid functional-dataflow language [AW76, AW77, WA85, EAAJ91], other Lucid-related systems [DW90b, DW90a], as well as standard functional languages <ref> [RW93, RW94b] </ref>, have been successfully implemented based on this approach. However, there are two important aspects of the technique, that were not developed in [Yag84]: 1. The transformation algorithm from extensional to intensional programs presented in [Yag84], is semi-formal and non-functional. 2.
Reference: [RW94a] <author> P. Rondogiannis and W. Wadge. </author> <title> Compiling Higher-Order Functions for Tagged-Dataflow. </title> <booktitle> In Proceedings of the IFIP/ACM International Conference on Parallel Architectures and Compilation Techniques. </booktitle> <publisher> North-Holland, </publisher> <month> August </month> <year> 1994. </year>
Reference-contexts: Moreover, the techniques illustrated in this paper can be extended to apply to more "demanding" intensional-ization procedures, such as for example the ones that have been suggested for higher-order functional programs <ref> [Wad91, RW94a] </ref>.
Reference: [RW94b] <author> P. Rondogiannis and W. Wadge. </author> <title> Higher-Order Dataflow and its Implementation on Stock Hardware. </title> <booktitle> In Proceedings of the ACM Symposium on Applied Computing, </booktitle> <pages> pages 431-435. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: Yaghi's work, apart from its theoretical significance, had practical implications as well: the resulting intensional programs can be interpreted in a very simple way. In fact, the Lucid functional-dataflow language [AW76, AW77, WA85, EAAJ91], other Lucid-related systems [DW90b, DW90a], as well as standard functional languages <ref> [RW93, RW94b] </ref>, have been successfully implemented based on this approach. However, there are two important aspects of the technique, that were not developed in [Yag84]: 1. The transformation algorithm from extensional to intensional programs presented in [Yag84], is semi-formal and non-functional. 2.
Reference: [Sto77] <author> J. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: The correctness proof for the transformation is given in Section 5, and the paper concludes by discussing the main points of our work. In the following sections, we assume a basic familiarity with the work described in [Yag84], as well as an understanding of domain theory and denotational semantics <ref> [Sto77, Ten91, Gun92] </ref>. 2 Yaghi's Transformation Algorithm This section presents an outline of Yaghi's transformation algorithm. The source extensional language under consideration, is a first-order subset of ISWIM [Lan66], referred as Iwade in [Yag84].
Reference: [Ten91] <author> R. Tennent. </author> <title> Semantics of Programming Languages. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: The correctness proof for the transformation is given in Section 5, and the paper concludes by discussing the main points of our work. In the following sections, we assume a basic familiarity with the work described in [Yag84], as well as an understanding of domain theory and denotational semantics <ref> [Sto77, Ten91, Gun92] </ref>. 2 Yaghi's Transformation Algorithm This section presents an outline of Yaghi's transformation algorithm. The source extensional language under consideration, is a first-order subset of ISWIM [Lan66], referred as Iwade in [Yag84]. <p> )(w); : : : ; [[E (E n )]](bu k+1 )(w)) Recalling that f (x 1 ; : : : ; x n ) : : = E (B f ) in T rans (P), and using the definition of bu k+1 in terms of u k (see for example <ref> [Ten91] </ref>), the above is equivalent to the following: [[E (B f )]](bu k )(dEe : w) v [[B f ]](u k+1 ) where k+1 (x j ) = [[E (E i )]](bu k+1 )(w), j = 1; : : :; n. <p> suffices to show that for every k 0, we have: call l 1 (bu k (f))(w) v u (f)([[call l 2 (f)]](bu k )(w)) u k (f)([[call l 2 (f)]](bu)(w)) v call l 1 (bu (f))(w) Using the technique for computing the least environment from its approximations (see for example <ref> [Ten91] </ref>), one can compute the values of bu k and u k for various values of k 2 N .
Reference: [WA85] <author> W. W. Wadge and E. A. Ashcroft. </author> <title> Lucid, the Dataflow Programming Language. </title> <publisher> Academic Press, </publisher> <year> 1985. </year>
Reference-contexts: He then proposed an algorithm for transforming first-order functional programs into programs of this language. Yaghi's work, apart from its theoretical significance, had practical implications as well: the resulting intensional programs can be interpreted in a very simple way. In fact, the Lucid functional-dataflow language <ref> [AW76, AW77, WA85, EAAJ91] </ref>, other Lucid-related systems [DW90b, DW90a], as well as standard functional languages [RW93, RW94b], have been successfully implemented based on this approach. However, there are two important aspects of the technique, that were not developed in [Yag84]: 1.
Reference: [Wad91] <author> W. W. Wadge. </author> <title> Higher-Order Lucid. </title> <booktitle> In Proceedings of the Fourth International Symposium on Lucid and Intensional Programming, </booktitle> <year> 1991. </year>
Reference-contexts: Moreover, the techniques illustrated in this paper can be extended to apply to more "demanding" intensional-ization procedures, such as for example the ones that have been suggested for higher-order functional programs <ref> [Wad91, RW94a] </ref>.
Reference: [Yag84] <author> A. A. Yaghi. </author> <title> The Intensional Implementation Technique for Functional Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Warwick, Coventry, UK, </institution> <year> 1984. </year>
Reference-contexts: 1 Introduction The first work to establish a transformation algorithm from extensional to intensional programs, was A. Yaghi's Ph.D. dissertation <ref> [Yag84] </ref>. Motivated by Montague's intensional logic [Mon74, DWP81], Yaghi first defined a simple intensional programming language, whose syntax only allowed nullary variable definitions. He then proposed an algorithm for transforming first-order functional programs into programs of this language. <p> In fact, the Lucid functional-dataflow language [AW76, AW77, WA85, EAAJ91], other Lucid-related systems [DW90b, DW90a], as well as standard functional languages [RW93, RW94b], have been successfully implemented based on this approach. However, there are two important aspects of the technique, that were not developed in <ref> [Yag84] </ref>: 1. The transformation algorithm from extensional to intensional programs presented in [Yag84], is semi-formal and non-functional. 2. A correctness proof of the transformation is not given in [Yag84], and has remained an open problem since then. <p> However, there are two important aspects of the technique, that were not developed in <ref> [Yag84] </ref>: 1. The transformation algorithm from extensional to intensional programs presented in [Yag84], is semi-formal and non-functional. 2. A correctness proof of the transformation is not given in [Yag84], and has remained an open problem since then. <p> However, there are two important aspects of the technique, that were not developed in <ref> [Yag84] </ref>: 1. The transformation algorithm from extensional to intensional programs presented in [Yag84], is semi-formal and non-functional. 2. A correctness proof of the transformation is not given in [Yag84], and has remained an open problem since then. It is the purpose of this paper to resolve the above two issues, establishing in this way a semantics preserving transformation from extensional to intensional programs. The rest of the paper is organized as follows: Section 2 outlines Yaghi's transformation algorithm. <p> The correctness proof for the transformation is given in Section 5, and the paper concludes by discussing the main points of our work. In the following sections, we assume a basic familiarity with the work described in <ref> [Yag84] </ref>, as well as an understanding of domain theory and denotational semantics [Sto77, Ten91, Gun92]. 2 Yaghi's Transformation Algorithm This section presents an outline of Yaghi's transformation algorithm. The source extensional language under consideration, is a first-order subset of ISWIM [Lan66], referred as Iwade in [Yag84]. <p> with the work described in <ref> [Yag84] </ref>, as well as an understanding of domain theory and denotational semantics [Sto77, Ten91, Gun92]. 2 Yaghi's Transformation Algorithm This section presents an outline of Yaghi's transformation algorithm. The source extensional language under consideration, is a first-order subset of ISWIM [Lan66], referred as Iwade in [Yag84]. Intuitively, Iwade does not allow nested where clauses, and it requires that all variables in a program are distinct. The target intensional language is referred as DE in [Yag84], and it only allows nullary variable definitions. <p> The source extensional language under consideration, is a first-order subset of ISWIM [Lan66], referred as Iwade in <ref> [Yag84] </ref>. Intuitively, Iwade does not allow nested where clauses, and it requires that all variables in a program are distinct. The target intensional language is referred as DE in [Yag84], and it only allows nullary variable definitions. Moreover, DE is enriched with a set of intensional operators, which play an important role in the translation process. For precise formal definitions of Iwade and DE, see [Yag84, page 3-3] and [Yag84, pages 2-38, 3-23] respectively. <p> The target intensional language is referred as DE in [Yag84], and it only allows nullary variable definitions. Moreover, DE is enriched with a set of intensional operators, which play an important role in the translation process. For precise formal definitions of Iwade and DE, see <ref> [Yag84, page 3-3] </ref> and [Yag84, pages 2-38, 3-23] respectively. The transformation algorithm, can be outlined as follows: 1. Let f be a function appearing in the source extensional program. <p> The target intensional language is referred as DE in [Yag84], and it only allows nullary variable definitions. Moreover, DE is enriched with a set of intensional operators, which play an important role in the translation process. For precise formal definitions of Iwade and DE, see [Yag84, page 3-3] and <ref> [Yag84, pages 2-38, 3-23] </ref> respectively. The transformation algorithm, can be outlined as follows: 1. Let f be a function appearing in the source extensional program. <p> applied: result : = call 1 (f) + call 2 (f) f = call 1 (g) g = y : = actuals (4; 5) y = actuals (x + 1) In the following we give a brief informal description of the semantics of DE programs (for a precise definition see <ref> [Yag84] </ref>). In general, the semantics of Iwade and DE programs are defined using standard techniques. Their only difference is that the underlying domain of the latter is a much richer one than the domain of the former. <p> Elements of (W ! D) are called intensions. Therefore, call and actuals are operators that take as arguments intensions. The corresponding semantic equations associated with these two operations, are <ref> [Yag84] </ref>: (call i (a))(w) = a (i : w) (actuals (a 1 ; : : : ; a n ))(i : w) = (a i )(w) where a; a 1 ; : : : ; a n 2 (W ! D), w 2 W , and : is the usual consing <p> Moreover, the semantic interpretation of constant symbols appearing in DE programs, is defined in a pointwise way in terms of the interpretation of the corresponding constants that appear in Iwade programs <ref> [Yag84] </ref>. 3 A Revised Formulation of Yaghi's Algorithm The main idea behind Yaghi's approach is that every function call in the source program will be translated into a unique intensional expression. <p> This means that even if two function calls in a program are syntactically identical, they will be given different translations, as the following example illustrates: Example 3.1 Consider the following first-order extensional program: result : f (x) = x + 1 The algorithm described in <ref> [Yag84] </ref> would translate the above program as follows: result : = call 1 (f) + call 2 (f) f = x + 1 : = actuals (10; 10) However, such a translation is not natural and proves quite difficult to formalize. <p> create a set of new definitions, one for every formal parameter of f : I = labels (f ; P) A f (P) = j=1 fx j = actuals (hE (i fi j)i i2I )g Notice that the actuals operator we adopt is more general than the one used in <ref> [Yag84] </ref>. In our case, actuals takes as argument a sequence of expressions indexed by a set I N . In Yaghi's case, the set I is always equal to f1; : : : ; ng, for some n 2 N . <p> Case S = c (S 1 ; : : : ; S n ). The interpretation function C 0 for constants in the intensional program, is defined in a pointwise way in terms of the interpretation function C for constants in the extensional program (see <ref> [Yag84, page 3-4] </ref>).
References-found: 18

