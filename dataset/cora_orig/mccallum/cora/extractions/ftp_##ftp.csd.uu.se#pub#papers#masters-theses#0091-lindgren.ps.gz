URL: ftp://ftp.csd.uu.se/pub/papers/masters-theses/0091-lindgren.ps.gz
Refering-URL: http://www.csd.uu.se/~andersl/
Root-URL: 
Title: Uppsala Master's Theses in  A Prototype of a Soft Type System for Erlang  
Author: Anders Lindgren Examiner: H-akan Millroth 
Address: Box 311 S-751 05 Uppsala Sweden  
Affiliation: Computing Science Department Uppsala University  
Date: April 24, 1996 ISSN 1100-1836  
Pubnum: Computing Science 91 Examensarbete DV2  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Alexander Aiken, Edward L. Wimmers, and T. K. Lakshman. </author> <title> Soft Typing with Conditional Types. </title> <booktitle> Proceedings of the 21st Annual Symposium on Principles of Programming, </booktitle> <pages> pages 163-173. </pages> <month> Jan </month> <year> 1994. </year>
Reference-contexts: a practical point of view this type of analysis is of great value: to automatically pinpoint a subtle type error might save several hours of hard work for a programmer. 1.2.1 The Type System The type system is based on the Soft Typing method presented by Aiken, Wim-mers and Lakshman <ref> [1] </ref>. The underlying idea is to represent the possible values CHAPTER 1. INTRODUCTION 3 of the objects in the program as sets. The sets are constrainted by equations representing the use of the variables. <p> RELATED WORK 5 2.2 Aiken, Wimmers, and Lakshman The work presented in this thesis is based on theories presented by Aiken, Wim-mers, and Lakshman <ref> [1] </ref>. In their paper they present a soft type system for a simple functional language. The type inference system is based on inclusion constraints between type expressions. The system consists of two phases: * Generation of inclusion constraints using deduction rules for every lan guage construction. * Solving the constraints. <p> Lists, used for storing variable number of terms. Lists are built up using the empty list [ ], and a cons pair [ x j y ], where x is the head and y the tail. The tail is normally another list. The expression <ref> [1, 2, 3] </ref> is an abbreviation for [1 | [2 | [3 | [ ]]]]. CHAPTER 3. ERLANG 8 Tuples, used for storing fixed number of terms, e.g. -1, 2, 4-. <p> We also discuss how useful information could be extracted from the constraint store. In this thesis we do not consider how the constraints are solved. The interested reader should refer to <ref> [1] </ref>. 5.1 The Result Should the attempt to solve the equation system lead to a contradiction, we know that the program we are analysing contains a type conflict. In this thesis, we do not consider the problem of finding the cause of the type conflict.
Reference: [2] <author> Alexander Aiken. Illyria Demo. </author> <note> http://http.cs.berkeley.edu/~aiken/Illyria-demo.html. May 1995. </note>
Reference-contexts: The type constraint generator phase of the system is written in Erlang. The type constraint solver used is written for the language Illyria by Alexander Aiken <ref> [2] </ref>. Chapter 2 Related Work 2.1 Type Inference and Soft Typing In some statically typed languages, for example ML [5], the programmer need not specify the types for all functions and variables. The compiler tries to infer the type from the information given. <p> Lists, used for storing variable number of terms. Lists are built up using the empty list [ ], and a cons pair [ x j y ], where x is the head and y the tail. The tail is normally another list. The expression <ref> [1, 2, 3] </ref> is an abbreviation for [1 | [2 | [3 | [ ]]]]. CHAPTER 3. ERLANG 8 Tuples, used for storing fixed number of terms, e.g. -1, 2, 4-. <p> The expressions are evaluated in left-to-right order. The value of the sequenced expression is the value of the last expression. Variables bound in one expression are available in the following expressions. CHAPTER 3. ERLANG 9 Examples of sequences are: X = 1, X + 1 X = <ref> [2, 3] </ref>, Y = [1 | X], [A, B, C] = Y, B The value of all three sequences are 2. 3.3.6 Guards A guard is a simple test used to direct the control flow. Guards could be part of function declaration and complex expressions such as case and receive. <p> Appendix A Usage This appendix describes how to use the type system presented in this thesis. A.1 Installation In order to use the prototype the following software must be installed: * Erlang. * a Common Lisp system. * The Illyria system <ref> [2] </ref>. * Our prototype, consisting of types and types config, two modules writ ten in Erlang. The Common Lisp system should be configured to start when the shell command lisp is executed. When started, the Common Lisp system should read and evaluate a lisp program from the standard input.
Reference: [3] <author> Joe Armstrong, Robert Virding, Claes Wikstrom, and Mike Williams. </author> <title> Concurrent Programming in Erlang. </title> <publisher> Prentice Hall, </publisher> <address> second edition, </address> <year> 1996. </year>
Reference-contexts: There exists two methods to check the type validity of a program written in a dynamically language. The work presented in this thesis is an example of an approximative analysis. The other method is empirical, i.e. testing, testing and testing. Erlang <ref> [3] </ref> and Common Lisp [7] are two examples of dynamically typed languages. 1.1.3 Untyped languages The last category are languages are untyped. Even though objects with different type exists, there is no way of checking if an object has a certain type. <p> Chapter 3 Erlang This chapter introduces the main features and constructions of the language Erlang <ref> [3] </ref>. 3.1 Background The language Erlang has been developed at the telecommunication company Ericsson. It was developed after a large survey, performed by Ellemtel Computer Science Laboratory, covering more than 20 languages at the beginning of the 1980:s. No language in the survey measured up to the requirements. <p> Lists, used for storing variable number of terms. Lists are built up using the empty list [ ], and a cons pair [ x j y ], where x is the head and y the tail. The tail is normally another list. The expression <ref> [1, 2, 3] </ref> is an abbreviation for [1 | [2 | [3 | [ ]]]]. CHAPTER 3. ERLANG 8 Tuples, used for storing fixed number of terms, e.g. -1, 2, 4-. <p> The expressions are evaluated in left-to-right order. The value of the sequenced expression is the value of the last expression. Variables bound in one expression are available in the following expressions. CHAPTER 3. ERLANG 9 Examples of sequences are: X = 1, X + 1 X = <ref> [2, 3] </ref>, Y = [1 | X], [A, B, C] = Y, B The value of all three sequences are 2. 3.3.6 Guards A guard is a simple test used to direct the control flow. Guards could be part of function declaration and complex expressions such as case and receive.
Reference: [4] <author> Robin Milner. </author> <title> A Theory of Type Polymorphism in Programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: The compiler tries to infer the type from the information given. A program is incorrect if the amount of information supplied is not enough to infer the type of all parts of the program. The ideas behind the inference mechanism was developed by Robin Milner <ref> [4] </ref>. By soft typing we mean a system where the type inference ideas has been applied to dynamically typed languages. In general, to infer the type of a program written in a dynamically typed language is an undecidable problem.
Reference: [5] <author> R. Milner, M. Tofte, and R. M. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: It is not possible to write a program which is incorrect in the sense that it will "go wrong"; it is not possible to apply objects of the wrong type to a operation. Examples of statically typed languages are Pascal [6] and ML <ref> [5] </ref>. 1 CHAPTER 1. INTRODUCTION 2 1.1.2 Dynamically typed languages In a dynamically typed language, objects have distinct types which are checked at run-time. Dynamically typed languages gives more freedom to the programmer, she can write a program mixing types anyway she like. <p> The type constraint generator phase of the system is written in Erlang. The type constraint solver used is written for the language Illyria by Alexander Aiken [2]. Chapter 2 Related Work 2.1 Type Inference and Soft Typing In some statically typed languages, for example ML <ref> [5] </ref>, the programmer need not specify the types for all functions and variables. The compiler tries to infer the type from the information given. A program is incorrect if the amount of information supplied is not enough to infer the type of all parts of the program.
Reference: [6] <author> Kathleen Jensen and Niklaus Wirth. </author> <title> Pascal User Manual and report, </title> <booktitle> Volume 18 of Lectures Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: It is not possible to write a program which is incorrect in the sense that it will "go wrong"; it is not possible to apply objects of the wrong type to a operation. Examples of statically typed languages are Pascal <ref> [6] </ref> and ML [5]. 1 CHAPTER 1. INTRODUCTION 2 1.1.2 Dynamically typed languages In a dynamically typed language, objects have distinct types which are checked at run-time. Dynamically typed languages gives more freedom to the programmer, she can write a program mixing types anyway she like.
Reference: [7] <author> Guy L. Steele JR. </author> <title> Common Lisp the Language. </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: There exists two methods to check the type validity of a program written in a dynamically language. The work presented in this thesis is an example of an approximative analysis. The other method is empirical, i.e. testing, testing and testing. Erlang [3] and Common Lisp <ref> [7] </ref> are two examples of dynamically typed languages. 1.1.3 Untyped languages The last category are languages are untyped. Even though objects with different type exists, there is no way of checking if an object has a certain type.
Reference: [8] <author> Philip Wadler and Simon Marlow. </author> <title> A Type Tool for Erlang. </title> <note> http://www.dcs.glasgow.ac.uk/~wadler/erltypes.html. Dec 1995. 43 </note>
Reference-contexts: As of this writing, nothing has been published about their results. The information presented here has been retrieved from a page on the World Wide Web <ref> [8] </ref>. Similar to this work, their system has been based on the theories of Aiken, Wimmers, and Lakshman. Unlike this work, it is possible for the programmer to specify the type of Erlang functions using a new -type declaration.
References-found: 8

