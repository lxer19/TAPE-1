URL: http://www.csl.sri.com/~gong/papers/sri-csl-tr94-14.ps.gz
Refering-URL: http://www.csl.sri.com/~gong/papers/sri-csl-tr94-14-abs.html
Root-URL: 
Email: (gong@csl.sri.com)  
Title: Fail-Stop Protocols: An Approach to Designing Secure Protocols  
Author: Li Gong 
Date: October 20, 1994  
Address: 333 Ravenswood Avenue Menlo Park, California 94025 U.S.A.  
Affiliation: SRI International Computer Science Laboratory  
Abstract: This paper presents a methodology to facilitate the design and analysis of secure cryptographic protocols. This work is based on a novel notion of a fail-stop protocol, which automatically halts in response to any active attack. This paper suggests types of protocols that are fail-stop, outlines some proof techniques for them, and uses examples to illustrate how the notion of a fail-stop protocol can make protocol design easier and can provide a more solid basis for some proposed protocol analysis methods. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, M. Burrows, C. Kaufman, and B. Lampson. </author> <title> Authentication and Delegation with Smart-cards. </title> <type> Technical Report 67, </type> <institution> DEC System Research Center, Palo Alto, California, </institution> <month> Oc-tober </month> <year> 1990. </year>
Reference-contexts: Checking whether a protocol conforms to Claim 2 (thus being fail-stop) is easy. For example, the Nessett protocol [24] and a few smart-card protocols <ref> [1] </ref> are fail-stop. Many published protocols are not fail-stop as we defined. One reason is that many designers try to be economical they would want to send plaintext messages whenever they think it safe to do so.
Reference: [2] <author> M. Abadi and R.M. Needham. </author> <title> Prudent Engineering Practice for Cryptographic Protocols. </title> <booktitle> In Proceedings of the IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 122-136, </pages> <address> Oakland, California, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: In particular, the message header provides sufficient redundancy so that any random modification of the message can be detected with an extremely high probability. Recently, Abadi and Needham collected a number of prudent engineering principles for designing authentication protocols <ref> [2] </ref>. The above specification of fail-stop protocols satisfies some of these principles. Fail-stop protocols using public-key systems can be similarly formulated. The only difference is in the encryption of the message. 2. Each message is signed by the sender's private key.
Reference: [3] <author> M. Abadi and M. Tuttle. </author> <title> A Semantics for a logic for Authentication (Extended Abstract). </title> <booktitle> In Proceedings of the ACM Symposium of Principles of Distributed Computing, </booktitle> <pages> pages 201-216, </pages> <month> January </month> <year> 1991. </year> <month> 12 </month>
Reference-contexts: In addition, like software testing, searching is computation 1 To relate this problem to the Turing machine halting problem, simply define a protocol that broadcasts all its secrets if the analyzer finds it secure and does nothing otherwise. 1 intensive. Methods based on modal logic <ref> [6, 3] </ref>, on the other hand, seem more conclusive in that their aim is to produce a proof of protocol security by deducing that certain protocol goals are achieved. However, such methods generally make a number of assumptions some of which cannot be justified by the methods themselves. <p> Consequently, the only difference between effects of passive attacks and active attacks is that the latter can cause early termination of a protocol execution. Thus, we need to analyze only the effect of passive attacks, and in particular, it is now much easier 2 Abadi and Tuttle <ref> [3] </ref> in their new semantics of the BAN logic [6] tried to relax this assumption by assuming instead that a secret can be leaked but whoever processes it (maybe illegally) will not misuse it.
Reference: [4] <author> A.D. Birrell. </author> <title> Secure Communications Using Remote Procedure Calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 1-14, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: 1 Background and Motivation In a distributed system, security depends heavily on the use of secure protocols such as authentication protocols (e.g., [21, 26]) and secure communication protocols (e.g., <ref> [4] </ref>). It is well known that such protocols can fail even if the underlying cryptosystems are sound and can have very subtle security flaws that are quite difficult to debug [6].
Reference: [5] <author> M. Burrows, M. Abadi, and R.M. Needham. </author> <title> A Logic for Authentication. </title> <type> Technical Report 39, </type> <institution> DEC System Research Center, Palo Alto, California, </institution> <month> February </month> <year> 1989. </year> <note> Revised version of Febru-ary 22, </note> <year> 1990. </year>
Reference-contexts: However, this kind of unguided (and rather ad hoc) "optimization" is easily one of the rich sources of security bugs. As Roger Needham remarked, one cannot foresee the consequences of being clever [20]. Nevertheless, examples have shown that guided optimizations can indeed identify and remove redundant data from messages <ref> [5] </ref>. Moreover, sometimes auxiliary data are sent in the clear. For example, the identity of the sender of an encrypted message is sent along when it helps the recipient to choose the correct key for decryption. <p> Suppose we allow the existence of such auxiliary data, more published protocols can be viewed as fail-stop. They include the Denning-Sacco protocol [9], the Needham-Schroeder Public-key protocol [21], the Demonstration Protocol and the Enhanced Kerberos Protocol [12], the Wide-mouthed-frog protocol and the CCITT X.509 protocol <ref> [5] </ref>, the Andrew Secure RPC [29], and the Private-key Certificate protocol [8]. <p> Even if we assume that the attacker is an insider, say A, we can still show that A cannot gain possession of B's private key. An analysis of this protocol using the BAN logic is contained in <ref> [5, p.33] </ref>. 3.3 Fail-Safe Protocols and Other Generalizations Some protocols are not fail-stop but can apparently be analyzed in the same way as fail-stop protocols. For example, when a message arrives whose freshness the recipient cannot decide, it is safe to let the recipient respond with a nonce.
Reference: [6] <author> M. Burrows, M. Abadi, and R.M. Needham. </author> <title> A Logic for Authentication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 18-36, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: It is well known that such protocols can fail even if the underlying cryptosystems are sound and can have very subtle security flaws that are quite difficult to debug <ref> [6] </ref>. <p> fact, the protocol security problem is undecidable in that, given any protocol analyzer, there are protocols whose security the analyzer cannot decide. 1 Recent years have seen notable efforts devoted to developing methods theories, logics, formal methods, and tools to facilitate the analysis of the security of cryptographic protocols (e.g., <ref> [11, 6, 17] </ref>). Although these results are significant, they are not yet satisfactory due to the following reasons. Methods based on searching, as the authors themselves pointed out [17], can find protocol design vulnerabilities to only those attacks that are explicitly modelled. <p> In addition, like software testing, searching is computation 1 To relate this problem to the Turing machine halting problem, simply define a protocol that broadcasts all its secrets if the analyzer finds it secure and does nothing otherwise. 1 intensive. Methods based on modal logic <ref> [6, 3] </ref>, on the other hand, seem more conclusive in that their aim is to produce a proof of protocol security by deducing that certain protocol goals are achieved. However, such methods generally make a number of assumptions some of which cannot be justified by the methods themselves. <p> Thus, we need to analyze only the effect of passive attacks, and in particular, it is now much easier 2 Abadi and Tuttle [3] in their new semantics of the BAN logic <ref> [6] </ref> tried to relax this assumption by assuming instead that a secret can be leaked but whoever processes it (maybe illegally) will not misuse it. <p> Here a freshness identifier can be a timestamp (if clocks are assumed to be securely and reliably synchronized) or a nonce issued by the intended recipient. When a freshness identifier takes on a more complicated form, the rules for reasoning about freshness <ref> [6, 13] </ref> can be used to determine if the identifier is fresh with regard to the recipient. Basically, if x is deemed fresh and y cannot be computed (in a computationally feasible way) by someone without the knowledge of x, then y is also deemed fresh [13]. <p> Beside such simple rules of optimization, the BAN logic is supposedly to be quite good at finding redundancies in messages <ref> [6] </ref>, so it can also be used to optimize a protocol. Note that such optimizations are guided by security analysis so that they do not weaken protocol security.
Reference: [7] <author> M. Burrows, M. Abadi, and R.M. Needham. </author> <title> Rejoinder to Nessett. </title> <journal> ACM Operating Systems Review, </journal> <volume> 24(2) </volume> <pages> 39-40, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: However, it is probably unfair to say that the logic of Burrows, Abadi, and Needham is flawed the logic's scope is explicitly defined not to cover the issue of secrecy <ref> [7] </ref>. None of the later extensions of this logic resolves this difficulty. An earlier work by Dolev and Yao [11] proved that protocols using public-key cryptosystems [10] and having certain very rigid structures can automatically satisfy the secrecy assumption.
Reference: [8] <author> D. Davis and R. Swick. </author> <title> Network Security via Private-Key Certificates. </title> <journal> ACM Operating Systems Review, </journal> <volume> 24(4) </volume> <pages> 64-67, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: They include the Denning-Sacco protocol [9], the Needham-Schroeder Public-key protocol [21], the Demonstration Protocol and the Enhanced Kerberos Protocol [12], the Wide-mouthed-frog protocol and the CCITT X.509 protocol [5], the Andrew Secure RPC [29], and the Private-key Certificate protocol <ref> [8] </ref>. The fact that there are many existing protocols that are fail-stop suggest that our formulations are not too limiting for practical applications. 2.2 Validating the Secrecy Assumption In BAN-like logics, a secrecy assumption is that a data item is known only to a set of parties.
Reference: [9] <author> D.E. Denning and G.M. Sacco. </author> <title> Timestamps in Key Distribution Protocols. </title> <journal> Communications of the ACM, </journal> <volume> 24(8) </volume> <pages> 533-536, </pages> <month> August </month> <year> 1981. </year>
Reference-contexts: This modification will thus cause the recipient to halt, so the protocol is still fail-stop. Suppose we allow the existence of such auxiliary data, more published protocols can be viewed as fail-stop. They include the Denning-Sacco protocol <ref> [9] </ref>, the Needham-Schroeder Public-key protocol [21], the Demonstration Protocol and the Enhanced Kerberos Protocol [12], the Wide-mouthed-frog protocol and the CCITT X.509 protocol [5], the Andrew Secure RPC [29], and the Private-key Certificate protocol [8].
Reference: [10] <author> W. Diffie and M.E. Hellman. </author> <title> New Directions in Cryptography. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> IT-22(6):644-65, </volume> <month> November </month> <year> 1976. </year>
Reference-contexts: None of the later extensions of this logic resolves this difficulty. An earlier work by Dolev and Yao [11] proved that protocols using public-key cryptosystems <ref> [10] </ref> and having certain very rigid structures can automatically satisfy the secrecy assumption. However, the restrictions on the protocols are so strict for instance, one can only append to a message - that the results are not widely applicable.
Reference: [11] <author> D. Dolev and A.C. Yao. </author> <title> On the Security of Public Key Protocols. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> IT-29(2):198-208, </volume> <month> March </month> <year> 1983. </year>
Reference-contexts: fact, the protocol security problem is undecidable in that, given any protocol analyzer, there are protocols whose security the analyzer cannot decide. 1 Recent years have seen notable efforts devoted to developing methods theories, logics, formal methods, and tools to facilitate the analysis of the security of cryptographic protocols (e.g., <ref> [11, 6, 17] </ref>). Although these results are significant, they are not yet satisfactory due to the following reasons. Methods based on searching, as the authors themselves pointed out [17], can find protocol design vulnerabilities to only those attacks that are explicitly modelled. <p> However, it is probably unfair to say that the logic of Burrows, Abadi, and Needham is flawed the logic's scope is explicitly defined not to cover the issue of secrecy [7]. None of the later extensions of this logic resolves this difficulty. An earlier work by Dolev and Yao <ref> [11] </ref> proved that protocols using public-key cryptosystems [10] and having certain very rigid structures can automatically satisfy the secrecy assumption. However, the restrictions on the protocols are so strict for instance, one can only append to a message - that the results are not widely applicable.
Reference: [12] <author> L. Gong, T.M.A. Lomas, R.M. Needham, and J.H. Saltzer. </author> <title> Protecting Poorly Chosen Secrets from Guessing Attacks. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 11(5) </volume> <pages> 648-656, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Suppose we allow the existence of such auxiliary data, more published protocols can be viewed as fail-stop. They include the Denning-Sacco protocol [9], the Needham-Schroeder Public-key protocol [21], the Demonstration Protocol and the Enhanced Kerberos Protocol <ref> [12] </ref>, the Wide-mouthed-frog protocol and the CCITT X.509 protocol [5], the Andrew Secure RPC [29], and the Private-key Certificate protocol [8]. <p> We can call such protocols fail-safe. Many existing protocols are fail-safe in nature, including the revised Needham-Schroeder protocol [22], the Otway-Rees protocol [27], the GLNS nonce protocol <ref> [12] </ref>, the Neuman-Stubblebine protocol [25], and the protocol for multiple authentication of Kehne et al. [16]. Some may argue that the rigid structural requirement in Claim 2 is still too limiting, and indeed it is possible that some such defined protocols may transmit unnecessary data.
Reference: [13] <author> L. Gong, R. Needham, and R. Yahalom. </author> <title> Reasoning about Belief in Cryptographic Protocols. </title> <booktitle> In Proceedings of the IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 234-248, </pages> <address> Oakland, California, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: They can also be dealt with by logics with more complicated constructs (e.g., <ref> [13] </ref>). <p> Such design errors, which can have serious security implications, have been found elsewhere by using BAN-like logics <ref> [13] </ref>. 2.1 Practical Fail-Stop Protocols A way to verify that a protocol is fail-stop is to show that the protocol conforms to one of the known specifications of fail-stop protocols. To build up such a "library" of protocol specifications, we first give one of the simplest specifications of fail-stop protocols. <p> Here a freshness identifier can be a timestamp (if clocks are assumed to be securely and reliably synchronized) or a nonce issued by the intended recipient. When a freshness identifier takes on a more complicated form, the rules for reasoning about freshness <ref> [6, 13] </ref> can be used to determine if the identifier is fresh with regard to the recipient. Basically, if x is deemed fresh and y cannot be computed (in a computationally feasible way) by someone without the knowledge of x, then y is also deemed fresh [13]. <p> Basically, if x is deemed fresh and y cannot be computed (in a computationally feasible way) by someone without the knowledge of x, then y is also deemed fresh <ref> [13] </ref>. To see that Claim 2 is valid, we note that a message's header uniquely identifies the position of the message (e.g., within which protocol execution and which message of this execution). It is not possible to use this message elsewhere without modifying the message. <p> the party already has in possession)? This question is related to that of the "state of knowledge" [19] in that we need to find out what information an attacker has gathered by recording the execution of a protocol. 4 The notion and rules of "possession" proposed in the GNY logic <ref> [13] </ref> can be applied directly for this purpose. <p> This advantage can be seen from another point of view. The logic of Gong, Needham, and Yahalom (GNY) <ref> [13] </ref> has a number of extensions to BAN so that most of the assumptions in BAN are handled explicitly in GNY. <p> To check this assumption, we assume that the attacker can record both messages and can have access to A's public key k a (which is generally known to the public). Now we can use the possession rules <ref> [13] </ref> as follows: poss (fn a ; k ab g k 0 a ) AND poss (k a ) poss ((n a ; k ab )) and then poss ((n a ; k ab )) poss (k ab ) In other words, an attacker can obtain k ab .
Reference: [14] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> London, </address> <year> 1985. </year>
Reference-contexts: Also, a protocol consisting of two fail-stop protocols running in parallel is fail-stop, even the two protocols share variables. Claim 3 The sequential and parallel composition of fail-stop protocols is also fail-stop. For such sequential or parallel protocol compositions <ref> [14] </ref>, the analysis of secrecy (see Section 2.2) is insensitive to the order of the interleaving messages.
Reference: [15] <author> C.B. Jones. </author> <title> The Search for Tractable Ways of Reasoning about Programs. </title> <type> Technical Report UMCS-92-4-4, </type> <institution> Department of Computer Science, University of Manchester, </institution> <address> England, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: From another angle, just as algorithms or programs should be designed for their correctness to be easily proven <ref> [15, 28] </ref>, security protocols should be designed so that their security can be proven with relative ease.
Reference: [16] <author> A. Kehne, J. Schonwalder, and H. Langendorfer. </author> <title> A Nonce-Based Protocol for Multiple Authentications. </title> <journal> ACM Operating Systems Review, </journal> <volume> 26(4) </volume> <pages> 84-89, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: We can call such protocols fail-safe. Many existing protocols are fail-safe in nature, including the revised Needham-Schroeder protocol [22], the Otway-Rees protocol [27], the GLNS nonce protocol [12], the Neuman-Stubblebine protocol [25], and the protocol for multiple authentication of Kehne et al. <ref> [16] </ref>. Some may argue that the rigid structural requirement in Claim 2 is still too limiting, and indeed it is possible that some such defined protocols may transmit unnecessary data. After we are satisfied that a protocol is secure, we can optimize the protocol while maintaining its security.
Reference: [17] <author> R.A. Kemmerer, C. Meadows, and J. Millen. </author> <title> Three Systems for Cryptographic Protocol Analysis. </title> <journal> Journal of Cryptology, </journal> <month> October </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: fact, the protocol security problem is undecidable in that, given any protocol analyzer, there are protocols whose security the analyzer cannot decide. 1 Recent years have seen notable efforts devoted to developing methods theories, logics, formal methods, and tools to facilitate the analysis of the security of cryptographic protocols (e.g., <ref> [11, 6, 17] </ref>). Although these results are significant, they are not yet satisfactory due to the following reasons. Methods based on searching, as the authors themselves pointed out [17], can find protocol design vulnerabilities to only those attacks that are explicitly modelled. <p> Although these results are significant, they are not yet satisfactory due to the following reasons. Methods based on searching, as the authors themselves pointed out <ref> [17] </ref>, can find protocol design vulnerabilities to only those attacks that are explicitly modelled. Thus, failure to find a vulnerability by such a method does not mean that the protocol is secure, but merely that certain lines of attack are less likely to succeed. <p> This is logically sound, but does not reflect what happens in the real world. 3 Some searching-based method, such as the NRL protocol analyzer <ref> [17] </ref>, are said to have the potential to provide some proving capability, but no general proof methodology is currently available. 2 to conclude whether the secrecy assumption can be violated.
Reference: [18] <author> L. Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year> <month> 13 </month>
Reference-contexts: A cryptographic protocol uses cryptographic mechanisms such as encryption and decryption algorithms to guarantee the integrity, the secrecy, the origin, the destination, the order, the timeliness, and ultimately the meaning of the messages. We assume that a protocol executes in steps or rounds. Using Lamport's definition of causality <ref> [18] </ref>, we can organize the messages of a protocol into an acyclic directed graph where each arc represents a message and each directed path represents a sequence of messages.
Reference: [19] <author> M. Merritt and P. Wolper. </author> <title> States of Knowledge in Cryptographic Protocols. </title> <type> Unpublished manuscript, </type> <year> 1985. </year> <note> An earlier version of this work appeared as R. </note> <author> DeMillo, N. Lynch, and M. Merritt. </author> <title> Cryptographic Protocols. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1982, </year> <pages> pages 383-400. </pages>
Reference-contexts: is to decide that, given that one can record all messages exchanged during a protocol execution, can any party learn a particular data item by manipulating the messages (together with those data items the party already has in possession)? This question is related to that of the "state of knowledge" <ref> [19] </ref> in that we need to find out what information an attacker has gathered by recording the execution of a protocol. 4 The notion and rules of "possession" proposed in the GNY logic [13] can be applied directly for this purpose.
Reference: [20] <author> R.M. Needham. </author> <title> Denial of Service. </title> <booktitle> In Proceedings of the 1st ACM Conference on Computer and Communications Security, </booktitle> <pages> pages 151-153, </pages> <address> Fairfax, Virginia, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: However, this kind of unguided (and rather ad hoc) "optimization" is easily one of the rich sources of security bugs. As Roger Needham remarked, one cannot foresee the consequences of being clever <ref> [20] </ref>. Nevertheless, examples have shown that guided optimizations can indeed identify and remove redundant data from messages [5]. Moreover, sometimes auxiliary data are sent in the clear.
Reference: [21] <author> R.M. Needham and M.D. Schroeder. </author> <title> Using Encryption for Authentication in Large Networks of Computers. </title> <journal> Communications of the ACM, </journal> <volume> 21(12) </volume> <pages> 993-999, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: 1 Background and Motivation In a distributed system, security depends heavily on the use of secure protocols such as authentication protocols (e.g., <ref> [21, 26] </ref>) and secure communication protocols (e.g., [4]). It is well known that such protocols can fail even if the underlying cryptosystems are sound and can have very subtle security flaws that are quite difficult to debug [6]. <p> This modification will thus cause the recipient to halt, so the protocol is still fail-stop. Suppose we allow the existence of such auxiliary data, more published protocols can be viewed as fail-stop. They include the Denning-Sacco protocol [9], the Needham-Schroeder Public-key protocol <ref> [21] </ref>, the Demonstration Protocol and the Enhanced Kerberos Protocol [12], the Wide-mouthed-frog protocol and the CCITT X.509 protocol [5], the Andrew Secure RPC [29], and the Private-key Certificate protocol [8]. <p> protocol, this procedure can be applied only to fail-stop protocols, because in protocols that are not fail-stop, active attacks can be successful so that secrets can be leaked in ways not detectable by this procedure. 3.2 Example 2: the Needham-Schroeder Public-Key Protocol Our second example is the Needham-Schroeder public-key protocol <ref> [21] </ref>, and it works as follows. 1. A ! S: A; B k 0 s 4. B ! S: B; A k 0 s 7.
Reference: [22] <author> R.M. Needham and M.D. Schroeder. </author> <title> Authentication Revisited. </title> <journal> ACM Operating Systems Review, </journal> <volume> 21(1):7, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: For example, when a message arrives whose freshness the recipient cannot decide, it is safe to let the recipient respond with a nonce. We can call such protocols fail-safe. Many existing protocols are fail-safe in nature, including the revised Needham-Schroeder protocol <ref> [22] </ref>, the Otway-Rees protocol [27], the GLNS nonce protocol [12], the Neuman-Stubblebine protocol [25], and the protocol for multiple authentication of Kehne et al. [16].
Reference: [23] <author> G. Neiger and S. Toueg. </author> <title> Automatically Increasing the Fault-Tolerance of Distributed Systems. </title> <type> Technical Report GIT-ICS-89/01, </type> <institution> Georgia Institute of Technology, Atlanta, Georgia, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: It will be very interesting to see how to define a hierarchy of attacker models and show how to convert a protocol for one model into another. This is analogous to the work on converting protocols between various fault models <ref> [23] </ref>. Acknowledgement Fred Schneider of Cornell University, in a private correspondence of March 20, 1992, gave me early encouragement to clarify and develop my initial ideas of fail-stop protocols.
Reference: [24] <author> D.M. Nessett. </author> <title> A Critique of the Burrows, Abadi, and Needham Logic. </title> <journal> ACM Operating Systems Review, </journal> <volume> 24(2) </volume> <pages> 35-38, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: complement the proof-based approach, but because of the unlimited ways in which an attack can take place, it is impossible to model all possible attacks (both smart and stupid attacks) that must include all types of attacks as well as all possible instances of these attacks. 3 Indeed, when Nessett <ref> [24] </ref> raised the difficulty with this assumption of secrecy, no satisfactory answer could be provided. However, it is probably unfair to say that the logic of Burrows, Abadi, and Needham is flawed the logic's scope is explicitly defined not to cover the issue of secrecy [7]. <p> Checking whether a protocol conforms to Claim 2 (thus being fail-stop) is easy. For example, the Nessett protocol <ref> [24] </ref> and a few smart-card protocols [1] are fail-stop. Many published protocols are not fail-stop as we defined. One reason is that many designers try to be economical they would want to send plaintext messages whenever they think it safe to do so. <p> We also outline some generalizations of fail-stop protocols, such as fail-safe protocols, which help to expand the scope of protocols that can be analyzed using our new approach. 3.1 Example 1: the Nessett Protocol Our first example is the Nessett protocol <ref> [24] </ref>, as follows. 1. A ! B: fn a ; k ab g 2. B ! A: fn b g k ab Table 4: Nessett protocol In message 1, A "distributes" a key k ab to be shared between A and B.
Reference: [25] <author> B.C. Neuman and S.G. Stubblebine. </author> <title> A Note on the Use of Timestamps as Nonces. </title> <journal> ACM Operating Systems Review, </journal> <volume> 27(2) </volume> <pages> 10-14, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: We can call such protocols fail-safe. Many existing protocols are fail-safe in nature, including the revised Needham-Schroeder protocol [22], the Otway-Rees protocol [27], the GLNS nonce protocol [12], the Neuman-Stubblebine protocol <ref> [25] </ref>, and the protocol for multiple authentication of Kehne et al. [16]. Some may argue that the rigid structural requirement in Claim 2 is still too limiting, and indeed it is possible that some such defined protocols may transmit unnecessary data.
Reference: [26] <author> B.C. Neuman and T. Ts'o. </author> <title> Kerberos: An Authentication Service for Computer Networks. </title> <journal> IEEE Communications, </journal> <volume> 32(9) </volume> <pages> 33-38, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: 1 Background and Motivation In a distributed system, security depends heavily on the use of secure protocols such as authentication protocols (e.g., <ref> [21, 26] </ref>) and secure communication protocols (e.g., [4]). It is well known that such protocols can fail even if the underlying cryptosystems are sound and can have very subtle security flaws that are quite difficult to debug [6].
Reference: [27] <author> D. Otway and O. Rees. </author> <title> Efficient and Timely Mutual Authentication. </title> <journal> ACM Operating Systems Review, </journal> <volume> 21(1) </volume> <pages> 8-10, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: For example, when a message arrives whose freshness the recipient cannot decide, it is safe to let the recipient respond with a nonce. We can call such protocols fail-safe. Many existing protocols are fail-safe in nature, including the revised Needham-Schroeder protocol [22], the Otway-Rees protocol <ref> [27] </ref>, the GLNS nonce protocol [12], the Neuman-Stubblebine protocol [25], and the protocol for multiple authentication of Kehne et al. [16]. Some may argue that the rigid structural requirement in Claim 2 is still too limiting, and indeed it is possible that some such defined protocols may transmit unnecessary data.
Reference: [28] <author> J. Rushby. </author> <title> Formal Methods and the Certification of Critical Systems. </title> <type> Technical Report SRI-CSL-93-07, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, California, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: From another angle, just as algorithms or programs should be designed for their correctness to be easily proven <ref> [15, 28] </ref>, security protocols should be designed so that their security can be proven with relative ease.
Reference: [29] <author> M. Satyanarayanan. </author> <title> Integrating Security in a Large Distributed System. </title> <journal> ACM Transactions on Computer System, </journal> <volume> 7(3) </volume> <pages> 247-280, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: They include the Denning-Sacco protocol [9], the Needham-Schroeder Public-key protocol [21], the Demonstration Protocol and the Enhanced Kerberos Protocol [12], the Wide-mouthed-frog protocol and the CCITT X.509 protocol [5], the Andrew Secure RPC <ref> [29] </ref>, and the Private-key Certificate protocol [8].
Reference: [30] <author> R.D. Schlichting and F.B. Schneider. </author> <title> Fail-Stop Processors: An Approach to Designing Fault-Tolerant Computing Systems. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 1(3) </volume> <pages> 222-238, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: Given the above observations, we propose a new approach to designing secure protocols that is centered on a notion of fail-stop protocols. This notion is partly inspired by the work on fail-stop processors by Schlichting and Schneider <ref> [30] </ref>. They proposed the concept of a fail-stop processor, which, when failing, stops completely before any effect is visible to the outside world. Schneider also showed how to construct a fail-stop processor using Byzantine agreement [31]. <p> Therefore, similarly, if a protocol is well designed so that its conformation to certain guidelines ensures that certain security properties are (automatically) satisfied, then its proof of security is likely to be easier and simpler. In particular, inspired by the work on fail-stop processors <ref> [30, 31] </ref>, we defined the notion of a fail-stop protocol and illustrated how the important secrecy assumption necessary for applying the BAN logic can be easily validated with the possession rules in the GNY logic for such a restricted class of protocols.
Reference: [31] <author> F.B. Schneider. </author> <title> Byzantine Generals in Action: Implementing Fail-Stop Processors. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 2(2) </volume> <pages> 145-154, </pages> <month> May </month> <year> 1984. </year> <month> 14 </month>
Reference-contexts: They proposed the concept of a fail-stop processor, which, when failing, stops completely before any effect is visible to the outside world. Schneider also showed how to construct a fail-stop processor using Byzantine agreement <ref> [31] </ref>. A desirable result of this fail-stop behavior is that it is much easier to reason about fault-tolerant systems built with fail-stop processors, compared with processors that may have omission or Byzantine failures. <p> Therefore, similarly, if a protocol is well designed so that its conformation to certain guidelines ensures that certain security properties are (automatically) satisfied, then its proof of security is likely to be easier and simpler. In particular, inspired by the work on fail-stop processors <ref> [30, 31] </ref>, we defined the notion of a fail-stop protocol and illustrated how the important secrecy assumption necessary for applying the BAN logic can be easily validated with the possession rules in the GNY logic for such a restricted class of protocols.
References-found: 31

