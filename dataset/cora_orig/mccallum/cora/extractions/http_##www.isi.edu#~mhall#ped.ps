URL: http://www.isi.edu/~mhall/ped.ps
Refering-URL: http://www.isi.edu/~mhall/mypapers.html
Root-URL: http://www.isi.edu
Title: Experiences Using the ParaScope Editor: an Interactive Parallel Programming Tool  
Author: Mary W. Hall Timothy J. Harvey Ken Kennedy Nathaniel M c Intosh Kathryn S. M c Kinley Jeffrey D. Oldham Michael H. Paleczny Gerald Roth 
Abstract: The ParaScope Editor is an interactive parallel programming tool that assists knowledgeable users in developing scientific Fortran programs. It displays the results of sophisticated program analyses, provides a set of powerful interactive transformations, and supports program editing. This paper summarizes experiences of scientific programmers and tool designers using the ParaScope Editor. We evaluate existing features and describe enhancements in three key areas: user interface, analysis, and transformation. Many existing features prove crucial to successful program parallelization. They include interprocedural array side-effect analysis and program and dependence view filtering. Desirable functionality includes improved program navigation based on performance estimation, incorporating user assertions in analysis and more guidance in selecting transformations. These results offer insights and application for the authors of a variety of programming tools and parallelizing compilers. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Allen, M. Burke, P. Charles, R. Cytron, and J. Ferrante. </author> <title> An overview of the PTRAN analysis system for multiprocessing. </title> <booktitle> In Proceedings of the First International Conference on Supercomputing. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Athens, Greece, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: Although a substantial amount of research has been devoted to automatic parallelization, such systems are not consistently successful <ref> [1, 9, 6, 30, 33] </ref>. When automatic systems fail, the ParaScope Editor (Ped) assists in parallelizing Fortran applications by combining programmer expertise with extensive analysis and program transformations [3, 27, 28].
Reference: [2] <author> J. R. Allen, D. Baumgartner, K. Kennedy, and A. Porter-field. </author> <title> PTOOL: A semi-automatic parallel programming assistant. </title> <booktitle> In Proceedings of the 1986 International Conference Page 10 on Parallel Processing, </booktitle> <address> St. Charles, IL, August 1986. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The contents of this paper are derived from the assistants' accounts and the discussions as well as talks by Stein and Fletcher on their experiences. 3 User Interface 3.1 Background The user interface communicates Ped's capabilities to programmers. Repeated evaluation of Ped [17] and its predecessor Ptool <ref> [2, 25] </ref> by compiler writers, application programmers and human interface experts has led to its current design. Although many of the features in the new Ped interface are found in the original [28], it improves upon the original by providing more consistent and powerful features.
Reference: [3] <author> V. Balasundaram, K. Kennedy, U. Kremer, K. S. M c Kinley, and J. Subhlok. </author> <title> The ParaScope Editor: An interactive parallel programming tool. </title> <booktitle> In Proceedings of Supercomputing '89, </booktitle> <address> Reno, NV, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: Although a substantial amount of research has been devoted to automatic parallelization, such systems are not consistently successful [1, 9, 6, 30, 33]. When automatic systems fail, the ParaScope Editor (Ped) assists in parallelizing Fortran applications by combining programmer expertise with extensive analysis and program transformations <ref> [3, 27, 28] </ref>. This paper reports on the utility of Ped as an interactive parallel programming tool in the ParaScope parallel programming environment [10]. Through user evaluation of Ped, we assess existing functionality and suggest enhancements.
Reference: [4] <author> J. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> In Conference Record of the Sixth Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <address> San Antonio, TX, </address> <month> January </month> <year> 1979. </year>
Reference-contexts: Interprocedu-ral constants are inherited from a procedure's callers and directly incorporated into its intraprocedural counterpart. Flow-insensitive side-effect analysis, including Mod and Ref analysis, describes the variables that may be accessed on some control flow path through the procedure <ref> [4] </ref>. Flow-sensitive side-effect analysis, such as Kill analysis, describes accesses that occur on every possible control flow path [7].
Reference: [5] <author> A.J. Bernstein. </author> <title> Analysis of programs for parallel processing. </title> <journal> IEEE Transactions on Electronic Computers, </journal> <volume> 15(5) </volume> <pages> 757-763, </pages> <month> October </month> <year> 1966. </year>
Reference-contexts: Program Analysis. Dependence analysis specifies a partial order of a program's statements that preserves its meaning <ref> [5, 15] </ref>. For safety, the compiler must assume a dependence exists if it cannot prove otherwise.
Reference: [6] <author> W. Blume and R. Eigenmann. </author> <title> Performance analysis of par-allelizing compilers on the Perfect Benchmarks programs. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 3(6) </volume> <pages> 643-656, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Although a substantial amount of research has been devoted to automatic parallelization, such systems are not consistently successful <ref> [1, 9, 6, 30, 33] </ref>. When automatic systems fail, the ParaScope Editor (Ped) assists in parallelizing Fortran applications by combining programmer expertise with extensive analysis and program transformations [3, 27, 28]. <p> In arc3d, an array is killed inside a procedure invoked in a loop, so interpro-cedural array kill analysis is required. To perform array privatization in slab2d, kill analysis must be combined with loop transformations. Because the need for array kill analysis has been discussed previously <ref> [6, 33] </ref>, we do not elaborate further here. Reductions. Five of the programs contain sum reductions which go unrecognized by Ped. For example, computing the sum of all the elements of an array. <p> Embedding and extraction are not currently implemented in Ped. 6 Related Work A few other papers report on the effectiveness of existing automatic parallelizing compilers on large applications <ref> [9, 6, 12, 13, 33] </ref> and of interactive tools [9]. Two of these suggest compiler-programmer interaction to achieve parallelization [9, 33]. Blume and Eigenmann explore the effectiveness of Kap [29] applied to Perfect benchmark programs on an 8-processor Alliant [6]. <p> Two of these suggest compiler-programmer interaction to achieve parallelization [9, 33]. Blume and Eigenmann explore the effectiveness of Kap [29] applied to Perfect benchmark programs on an 8-processor Alliant <ref> [6] </ref>. Half of the programs demonstrate little or no improvement following parallelization. Using the transformation algorithms in Kap, scalar expansion is the only transformation that consistently improved performance on several codes.
Reference: [7] <author> D. Callahan. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Program Language Design and Implementation, </booktitle> <address> Atlanta, GA, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: Flow-insensitive side-effect analysis, including Mod and Ref analysis, describes the variables that may be accessed on some control flow path through the procedure [4]. Flow-sensitive side-effect analysis, such as Kill analysis, describes accesses that occur on every possible control flow path <ref> [7] </ref>. Regular section analysis is also used to describe more precisely, when possible, the side-effects to portions of arrays [24]. 4.2 Evaluation Table 3 demonstrates the importance of existing analysis and the need for additional analysis for the programs described in Table 1. Dependence Analysis.
Reference: [8] <author> S. Carr. </author> <title> Memory-Hierarchy Management. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: In addition, more advanced symbolic analysis and exploiting user assertions in all analyses are essential to parallelize many programs. Transformations. Program transformations introduce, discover, and exploit parallelism without changing the meaning of the program. Ped provides users with the same source-to-source transformations and accompanying analysis employed by ParaScope's compilers <ref> [8, 22] </ref>, allowing users to apply transformations di Page 1 name description & contributor lines procedures spec77 weather simulation code 5600 67 Steve Poole, IBM Kingston & Lo Hsieh, IBM Palo Alto pneoss thermodynamics code 350 5 Mary Zosel, Lawrence Livermore National Laboratory nxsns quantum mechanics code 1400 11 John Engle,
Reference: [9] <author> D. Cheng and D. Pase. </author> <title> An evaluation of automatic and interactive parallel programming tools. </title> <booktitle> In Proceedings of Supercomputing '91, </booktitle> <address> Albuquerque, NM, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: Although a substantial amount of research has been devoted to automatic parallelization, such systems are not consistently successful <ref> [1, 9, 6, 30, 33] </ref>. When automatic systems fail, the ParaScope Editor (Ped) assists in parallelizing Fortran applications by combining programmer expertise with extensive analysis and program transformations [3, 27, 28]. <p> Embedding and extraction are not currently implemented in Ped. 6 Related Work A few other papers report on the effectiveness of existing automatic parallelizing compilers on large applications <ref> [9, 6, 12, 13, 33] </ref> and of interactive tools [9]. Two of these suggest compiler-programmer interaction to achieve parallelization [9, 33]. Blume and Eigenmann explore the effectiveness of Kap [29] applied to Perfect benchmark programs on an 8-processor Alliant [6]. <p> Embedding and extraction are not currently implemented in Ped. 6 Related Work A few other papers report on the effectiveness of existing automatic parallelizing compilers on large applications [9, 6, 12, 13, 33] and of interactive tools <ref> [9] </ref>. Two of these suggest compiler-programmer interaction to achieve parallelization [9, 33]. Blume and Eigenmann explore the effectiveness of Kap [29] applied to Perfect benchmark programs on an 8-processor Alliant [6]. Half of the programs demonstrate little or no improvement following parallelization. <p> Embedding and extraction are not currently implemented in Ped. 6 Related Work A few other papers report on the effectiveness of existing automatic parallelizing compilers on large applications [9, 6, 12, 13, 33] and of interactive tools [9]. Two of these suggest compiler-programmer interaction to achieve parallelization <ref> [9, 33] </ref>. Blume and Eigenmann explore the effectiveness of Kap [29] applied to Perfect benchmark programs on an 8-processor Alliant [6]. Half of the programs demonstrate little or no improvement following parallelization. <p> To aid the compiler in selecting appropriate loops to parallelize, they suggest user access to profiling information and assertion facilities that allow specifying ranges of symbolic variables. Cheng and Pase consider 25 programs running on an 8 processor Cray Y-MP, using Cray fpp, Kap/Cray and Forge to introduce parallelism <ref> [9] </ref>. Most of the parallel versions demonstrate a speedup of less than 2 over their vector counterparts. When using Forge, the only interactive tool, they offer two suggestions. First, the user should be given insight about what loops to parallelize, either through profiling or performance estimation.
Reference: [10] <author> K. Cooper, M. W. Hall, R. T. Hood, K. Kennedy, K. S. McKinley, J. M. Mellor-Crummey, L. Torczon, and S. K. Warren. </author> <title> The ParaScope parallel programming environment. </title> <journal> Proceedings of the IEEE, </journal> <note> To appear 1993. </note>
Reference-contexts: When automatic systems fail, the ParaScope Editor (Ped) assists in parallelizing Fortran applications by combining programmer expertise with extensive analysis and program transformations [3, 27, 28]. This paper reports on the utility of Ped as an interactive parallel programming tool in the ParaScope parallel programming environment <ref> [10] </ref>. Through user evaluation of Ped, we assess existing functionality and suggest enhancements. The critiques confirm the usefulness of tools like Ped and offer new insights for compiler writers and parallel programming tool designers in three key areas. User Interface.
Reference: [11] <author> K. Cooper, K. Kennedy, L. Torczon, A. Weingarten, and M. Wolcott. </author> <title> Editing and compiling whole programs. </title> <booktitle> In Proceedings of the Second ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> Palo Alto, CA, </address> <month> December </month> <year> 1986. </year>
Reference-contexts: To fully support dependence navigation, Ped must be able to display other procedures while iterating over all the endpoints corresponding to a dependence. Other. Another ParaScope tool, the Composition Editor, compares a procedure definition to calls invoking it, ensuring the parameter lists agree in number and type <ref> [11, 21] </ref>. These types of errors exist in production codes because most compilers do not perform cross-procedure comparisons. Several mismatched parameters between a procedure call and its declaration were detected and subsequently corrected using this analysis.
Reference: [12] <author> R. Eigenmann, J. Hoeflinger, G. Jaxon, Z. Li, and D. Padua. </author> <title> Restructuring Fortran programs for Cedar. </title> <booktitle> In Proceedings of the 1991 International Conference on Parallel Processing, </booktitle> <address> St. Charles, IL, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: Embedding and extraction are not currently implemented in Ped. 6 Related Work A few other papers report on the effectiveness of existing automatic parallelizing compilers on large applications <ref> [9, 6, 12, 13, 33] </ref> and of interactive tools [9]. Two of these suggest compiler-programmer interaction to achieve parallelization [9, 33]. Blume and Eigenmann explore the effectiveness of Kap [29] applied to Perfect benchmark programs on an 8-processor Alliant [6]. <p> The compiler often fails to parallelize important loops, such as loops containing procedure calls, and sometimes parallelizes loops with insufficient granularity. These failures are in part because the compiler does not perform interproce-dural analysis. Eigenmann et al. presents novel approaches for improving parallelization in four Perfect programs <ref> [12, 13] </ref>. These techniques include run-time dependence testing and aggressive use of synchronization to guard critical sections. Singh and Hennessy examine parallelization of three programs on an 8-processor Alliant [33]. They observe that certain programming styles interfere with compiler analysis.
Reference: [13] <author> R. Eigenmann, J. Hoeflinger, Z. Li, and D. Padua. </author> <title> Experience in the automatic parallelization of four Perfect benchmark programs. </title> <editor> In U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing, Fourth International Workshop, </booktitle> <address> Santa Clara, CA, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: Embedding and extraction are not currently implemented in Ped. 6 Related Work A few other papers report on the effectiveness of existing automatic parallelizing compilers on large applications <ref> [9, 6, 12, 13, 33] </ref> and of interactive tools [9]. Two of these suggest compiler-programmer interaction to achieve parallelization [9, 33]. Blume and Eigenmann explore the effectiveness of Kap [29] applied to Perfect benchmark programs on an 8-processor Alliant [6]. <p> The compiler often fails to parallelize important loops, such as loops containing procedure calls, and sometimes parallelizes loops with insufficient granularity. These failures are in part because the compiler does not perform interproce-dural analysis. Eigenmann et al. presents novel approaches for improving parallelization in four Perfect programs <ref> [12, 13] </ref>. These techniques include run-time dependence testing and aggressive use of synchronization to guard critical sections. Singh and Hennessy examine parallelization of three programs on an 8-processor Alliant [33]. They observe that certain programming styles interfere with compiler analysis.
Reference: [14] <author> D. C. Engelbart and W. K. </author> <title> English. A research center for augmenting human intellect. </title> <booktitle> In Proceedings of AFIPS 1968 Fall Joint Computer Conference, </booktitle> <address> San Francisco, CA, </address> <month> De-cember </month> <year> 1968. </year>
Reference-contexts: Progressive disclosure presents details incrementally as they become relevant [34]. View filtering emphasizes or conceals parts of the book as specified by a user <ref> [14] </ref>. Power steering automates repetitive or error-prone tasks, providing unobtrusive assistance while leaving the user in control. The layout of a Ped window is shown in Figure 1. The large area at the top is the source pane displaying the Fortran text.
Reference: [15] <author> J. Ferrante, K. Ottenstein, and J. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Program Analysis. Dependence analysis specifies a partial order of a program's statements that preserves its meaning <ref> [5, 15] </ref>. For safety, the compiler must assume a dependence exists if it cannot prove otherwise. <p> Ped detects data and control dependences. Data dependences are located by testing pairs of references in a loop. A hierarchical suite of tests is used, starting with inexpensive tests, to prove or disprove that a dependence exists [19]. Control dependences explicitly represent how control decisions affect statement execution <ref> [15] </ref>. Supporting Analysis. Scalar data-flow analysis, including def-use chains, constant propagation and symbolic analysis, provides additional information about the values and relationship of variables and can vastly improve the precision of dependence analysis [19, 20].
Reference: [16] <author> K. Fletcher. </author> <title> Experience with ParaScope at NASA Ames Research Center. Presentation during the ParaScope Editor Workshop, </title> <month> July </month> <year> 1991. </year>
Reference-contexts: Table 1 lists the workshop attendees with the programs they contributed. Additional evaluations result from two studies of parallel programming tools: one by Joseph Stein, a visiting scientist at Syracuse University [35], and another by Katherine Fletcher of Rice University and Doreen Cheng at Nasa Ames Research Center <ref> [16] </ref>. At the workshop, we divided the attendees into groups of one or two people and assigned a researcher familiar with Ped to assist each group. After a morning of introductory talks and a Ped demonstration, the user groups parallelized their application with Ped for the next two half days.
Reference: [17] <author> K. Fletcher, K. Kennedy, K. S. M c Kinley, and S. Warren. </author> <title> The ParaScope Editor: User interface goals. </title> <type> Technical Report TR90-113, </type> <institution> Dept. of Computer Science, Rice University, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: The critiques confirm the usefulness of tools like Ped and offer new insights for compiler writers and parallel programming tool designers in three key areas. User Interface. We describe a new user interface that was designed and implemented based on previous evaluations <ref> [17, 25] </ref>. This interface enhances the original [28], unifying improved navigation and viewing of the program, its dependences, and information about its variables. <p> The contents of this paper are derived from the assistants' accounts and the discussions as well as talks by Stein and Fletcher on their experiences. 3 User Interface 3.1 Background The user interface communicates Ped's capabilities to programmers. Repeated evaluation of Ped <ref> [17] </ref> and its predecessor Ptool [2, 25] by compiler writers, application programmers and human interface experts has led to its current design. Although many of the features in the new Ped interface are found in the original [28], it improves upon the original by providing more consistent and powerful features.
Reference: [18] <author> G. Goff. </author> <title> Practical techniques to augment dependence analysis in the presence of symbolic terms. </title> <type> Technical Report TR92-194, </type> <institution> Dept. of Computer Science, Rice University, </institution> <month> Oc-tober </month> <year> 1992. </year>
Reference-contexts: We are using a three-pronged approach to improving the precision of dependence information in the presence of symbolics: (1) sophisticated symbolic analysis; (2) partial evaluation, or compiling the program with all or part of an input data set <ref> [18] </ref>; and (3) incorporating user assertions to eliminate dependences (described from the user interface perspective in Section 3.3). The following program fragment from the routine fil-ter3d in arc3d demonstrates the type of advanced inter-procedural symbolic analysis that would improve program parallelization.
Reference: [19] <author> G. Goff, K. Kennedy, and C. Tseng. </author> <title> Practical dependence testing. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Program Language Design and Implementation, </booktitle> <address> Toronto, Canada, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Dependence analysis specifies a partial order of a program's statements that preserves its meaning [5, 15]. For safety, the compiler must assume a dependence exists if it cannot prove otherwise. In ParaScope, analysis of interprocedural and intrapro-cedural constants, symbolics and array sections improve the precision of its dependence analysis <ref> [19, 27] </ref>. (We assume the reader is familiar with these analyses.) Our evaluation confirms these are indispensable for discovering parallelism. In addition, more advanced symbolic analysis and exploiting user assertions in all analyses are essential to parallelize many programs. Transformations. <p> The dependence pane also permits an important form of editing known as dependence marking. The system marks each dependence as either proven, pending, accepted or rejected. If Ped proves a dependence exists with an exact dependence test <ref> [19] </ref>, the dependence is marked as proven; otherwise it is marked pending. Users may sharpen Ped's dependence analysis by marking a pending dependence as accepted or rejected . <p> Dependence Analysis. Ped detects data and control dependences. Data dependences are located by testing pairs of references in a loop. A hierarchical suite of tests is used, starting with inexpensive tests, to prove or disprove that a dependence exists <ref> [19] </ref>. Control dependences explicitly represent how control decisions affect statement execution [15]. Supporting Analysis. Scalar data-flow analysis, including def-use chains, constant propagation and symbolic analysis, provides additional information about the values and relationship of variables and can vastly improve the precision of dependence analysis [19, 20]. <p> Control dependences explicitly represent how control decisions affect statement execution [15]. Supporting Analysis. Scalar data-flow analysis, including def-use chains, constant propagation and symbolic analysis, provides additional information about the values and relationship of variables and can vastly improve the precision of dependence analysis <ref> [19, 20] </ref>. Def-use chains expose dependences among scalar variables as well as linking all accesses to each array for dependence testing. A critical contribution of scalar data-flow analysis is recognizing scalars that are killed, or redefined, on every iteration of a loop and may be made private, thus eliminating dependences.
Reference: [20] <author> M. Haghighat and C. Polychronopoulos. </author> <title> Symbolic dependence analysis for high-performance parallelizing compilers. </title> <booktitle> In Advances in Languages and Compilers for Parallel Computing, </booktitle> <address> Irvine, CA, August 1990. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Control dependences explicitly represent how control decisions affect statement execution [15]. Supporting Analysis. Scalar data-flow analysis, including def-use chains, constant propagation and symbolic analysis, provides additional information about the values and relationship of variables and can vastly improve the precision of dependence analysis <ref> [19, 20] </ref>. Def-use chains expose dependences among scalar variables as well as linking all accesses to each array for dependence testing. A critical contribution of scalar data-flow analysis is recognizing scalars that are killed, or redefined, on every iteration of a loop and may be made private, thus eliminating dependences. <p> Symbolic terms in subscript expressions are a key limiting factor in precise dependence analysis. One study found that over 50% of the array references in some numerical packages contained at least one unknown symbolic term <ref> [20] </ref>. The index arrays entry in Table 3 demonstrates that three programs contained index arrays in subscript expressions that prevented parallelization.
Reference: [21] <author> M. W. Hall. </author> <title> Managing Interprocedural Optimization. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: ParaScope now includes a static performance estimator used to predict the relative execution time of loops and subroutines in parallel programs [26]. Several users wanted a graphical representation of the call graph, rather than the current textual presentation <ref> [21] </ref>. A visual program representation provides a much needed "big picture" when working with a large or unfamiliar program. Short cuts to accessing other procedures via this representation were also requested. Dependence Navigation. In navigating dependences, the users requested a number of features subsumed by the current implementation. <p> To fully support dependence navigation, Ped must be able to display other procedures while iterating over all the endpoints corresponding to a dependence. Other. Another ParaScope tool, the Composition Editor, compares a procedure definition to calls invoking it, ensuring the parameter lists agree in number and type <ref> [11, 21] </ref>. These types of errors exist in production codes because most compilers do not perform cross-procedure comparisons. Several mismatched parameters between a procedure call and its declaration were detected and subsequently corrected using this analysis.
Reference: [22] <author> M. W. Hall, S. Hiranandani, K. Kennedy, and C. Tseng. </author> <title> Interprocedural compilation of Fortran D for MIMD distributed-memory machines. </title> <booktitle> In Proceedings of Supercomputing '92, </booktitle> <address> Minneapolis, MN, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: In addition, more advanced symbolic analysis and exploiting user assertions in all analyses are essential to parallelize many programs. Transformations. Program transformations introduce, discover, and exploit parallelism without changing the meaning of the program. Ped provides users with the same source-to-source transformations and accompanying analysis employed by ParaScope's compilers <ref> [8, 22] </ref>, allowing users to apply transformations di Page 1 name description & contributor lines procedures spec77 weather simulation code 5600 67 Steve Poole, IBM Kingston & Lo Hsieh, IBM Palo Alto pneoss thermodynamics code 350 5 Mary Zosel, Lawrence Livermore National Laboratory nxsns quantum mechanics code 1400 11 John Engle,
Reference: [23] <author> M. W. Hall, K. Kennedy, and K. S. M c Kinley. </author> <title> Interprocedu-ral transformations for parallel code generation. </title> <booktitle> In Proceedings of Supercomputing '91, </booktitle> <address> Albuquerque, NM, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: The procedures invoked in these loops however contain outer loops with many more iterations that may also safely execute in parallel. Page 9 A solution that combines the granularity of the outer loop with the parallelism of the inner loop is to perform loop interchange across the procedure boundary <ref> [23] </ref>. In some cases, loops in gloop contained multiple calls so the loops of the called procedures were first fused before applying interchange.
Reference: [24] <author> P. Havlak and K. Kennedy. </author> <title> An implementation of inter-procedural bounded regular section analysis. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 2(3) </volume> <pages> 350-360, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Flow-sensitive side-effect analysis, such as Kill analysis, describes accesses that occur on every possible control flow path [7]. Regular section analysis is also used to describe more precisely, when possible, the side-effects to portions of arrays <ref> [24] </ref>. 4.2 Evaluation Table 3 demonstrates the importance of existing analysis and the need for additional analysis for the programs described in Table 1. Dependence Analysis. The dependence entry in Table 3 indicates whether dependence analysis locates parallel loops in each program.
Reference: [25] <author> L. Henderson, R. Hiromoto, O. Lubeck, and M. Simmons. </author> <title> On the use of diagnostic dependency-analysistools in parallel programming: Experiences using PTOOL. </title> <journal> The Journal of Supercomputing, </journal> <volume> 4 </volume> <pages> 83-96, </pages> <year> 1990. </year>
Reference-contexts: The critiques confirm the usefulness of tools like Ped and offer new insights for compiler writers and parallel programming tool designers in three key areas. User Interface. We describe a new user interface that was designed and implemented based on previous evaluations <ref> [17, 25] </ref>. This interface enhances the original [28], unifying improved navigation and viewing of the program, its dependences, and information about its variables. <p> The contents of this paper are derived from the assistants' accounts and the discussions as well as talks by Stein and Fletcher on their experiences. 3 User Interface 3.1 Background The user interface communicates Ped's capabilities to programmers. Repeated evaluation of Ped [17] and its predecessor Ptool <ref> [2, 25] </ref> by compiler writers, application programmers and human interface experts has led to its current design. Although many of the features in the new Ped interface are found in the original [28], it improves upon the original by providing more consistent and powerful features. <p> In the program nxsns, interprocedural scalar Kill analysis reveals a scalar variable is killed in a procedure invoked inside a loop. Experience using Ptool, Ped's predecessor, suggests interprocedural scalar Kill analysis is also useful in eliminating spurious dependences <ref> [25] </ref>. Interprocedural Side-effect Analysis. The sections entry indicates that scalar side-effect analysis or regular section analysis reduces the number of dependences on a loop containing a procedure call in six of the programs. <p> The existence of an advanced interactive tool allowed us to go beyond the comments provided by the studies of automatic parallelizers to investigate the appropriate level for compiler and tool interaction. For instance, users deleted dependences in Ped, as suggested previously <ref> [25, 33] </ref>, but requested higher-level assertions and guidance.
Reference: [26] <author> K. Kennedy, N. McIntosh, and K. S. M c Kinley. </author> <title> Static performance estimation in a parallelizing compiler. </title> <type> Technical Report TR91-174, </type> <institution> Dept. of Computer Science, Rice University, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: ParaScope now includes a static performance estimator used to predict the relative execution time of loops and subroutines in parallel programs <ref> [26] </ref>. Several users wanted a graphical representation of the call graph, rather than the current textual presentation [21]. A visual program representation provides a much needed "big picture" when working with a large or unfamiliar program. Short cuts to accessing other procedures via this representation were also requested. Dependence Navigation.
Reference: [27] <author> K. Kennedy, K. S. M c Kinley, and C. Tseng. </author> <title> Analysis and transformation in the ParaScope Editor. </title> <booktitle> In Proceedings of the 1991 ACM International Conference on Supercomputing, </booktitle> <address> Cologne, Germany, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Although a substantial amount of research has been devoted to automatic parallelization, such systems are not consistently successful [1, 9, 6, 30, 33]. When automatic systems fail, the ParaScope Editor (Ped) assists in parallelizing Fortran applications by combining programmer expertise with extensive analysis and program transformations <ref> [3, 27, 28] </ref>. This paper reports on the utility of Ped as an interactive parallel programming tool in the ParaScope parallel programming environment [10]. Through user evaluation of Ped, we assess existing functionality and suggest enhancements. <p> Dependence analysis specifies a partial order of a program's statements that preserves its meaning [5, 15]. For safety, the compiler must assume a dependence exists if it cannot prove otherwise. In ParaScope, analysis of interprocedural and intrapro-cedural constants, symbolics and array sections improve the precision of its dependence analysis <ref> [19, 27] </ref>. (We assume the reader is familiar with these analyses.) Our evaluation confirms these are indispensable for discovering parallelism. In addition, more advanced symbolic analysis and exploiting user assertions in all analyses are essential to parallelize many programs. Transformations. <p> A loop that contains no loop-carried dependences may execute its iterations in parallel. Further, dependences are used to prove the safety of program transformations. This section briefly describes the dependence analysis and supporting analyses that are currently available in Ped <ref> [27] </ref>. Dependence Analysis. Ped detects data and control dependences. Data dependences are located by testing pairs of references in a loop. A hierarchical suite of tests is used, starting with inexpensive tests, to prove or disprove that a dependence exists [19]. <p> derive relational constraints on variables during dependence testing using a variant of integer programming, and these are presented to the user in their implementation. 5 Program Transformation 5.1 Background Ped supports a large set of transformations proven useful for introducing, discovering, and exploiting parallelism and for enhancing memory hierarchy use <ref> [27] </ref>. a power steering paradigm: the user specifies the transformations to be made, and the system provides advice and carries out the mechanical details. The system advises whether the transformation is applicable (is syntactically correct), safe (preserves the semantics of the program) and profitable (contributes to parallelization).
Reference: [28] <author> K. Kennedy, K. S. M c Kinley, and C. Tseng. </author> <title> Interactive parallel programming using the ParaScope Editor. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 2(3) </volume> <pages> 329-341, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Although a substantial amount of research has been devoted to automatic parallelization, such systems are not consistently successful [1, 9, 6, 30, 33]. When automatic systems fail, the ParaScope Editor (Ped) assists in parallelizing Fortran applications by combining programmer expertise with extensive analysis and program transformations <ref> [3, 27, 28] </ref>. This paper reports on the utility of Ped as an interactive parallel programming tool in the ParaScope parallel programming environment [10]. Through user evaluation of Ped, we assess existing functionality and suggest enhancements. <p> The critiques confirm the usefulness of tools like Ped and offer new insights for compiler writers and parallel programming tool designers in three key areas. User Interface. We describe a new user interface that was designed and implemented based on previous evaluations [17, 25]. This interface enhances the original <ref> [28] </ref>, unifying improved navigation and viewing of the program, its dependences, and information about its variables. Our evaluation confirms the appropriateness of the interface but exposes the need for new features such as navigation assistance based on performance estimation and a facility enabling users to assert information about variable values. <p> Repeated evaluation of Ped [17] and its predecessor Ptool [2, 25] by compiler writers, application programmers and human interface experts has led to its current design. Although many of the features in the new Ped interface are found in the original <ref> [28] </ref>, it improves upon the original by providing more consistent and powerful features. Ped employs three user interface techniques to manage and present the detailed information computed by the system: (1) a book metaphor with progressive disclosure, (2) user-controlled view filtering, and (3) power steering for complex actions.
Reference: [29] <author> Kuck & Associates, Inc. </author> <title> KAP User's Guide. </title> <address> Champaign, IL 61820, </address> <year> 1988. </year>
Reference-contexts: Two of these suggest compiler-programmer interaction to achieve parallelization [9, 33]. Blume and Eigenmann explore the effectiveness of Kap <ref> [29] </ref> applied to Perfect benchmark programs on an 8-processor Alliant [6]. Half of the programs demonstrate little or no improvement following parallelization. Using the transformation algorithms in Kap, scalar expansion is the only transformation that consistently improved performance on several codes.
Reference: [30] <author> K. S. McKinley. </author> <title> Automatic and Interactive Parallelization. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Although a substantial amount of research has been devoted to automatic parallelization, such systems are not consistently successful <ref> [1, 9, 6, 30, 33] </ref>. When automatic systems fail, the ParaScope Editor (Ped) assists in parallelizing Fortran applications by combining programmer expertise with extensive analysis and program transformations [3, 27, 28].
Reference: [31] <institution> Pacific-Sierra Research. </institution> <note> Forge User's Guide Version, version 7.01 edition, </note> <month> December </month> <year> 1990. </year>
Reference-contexts: User Interaction. Users were comfortable with selecting a loop and then evaluating its dependences and variable annotations. Specifically, one user commented that having all information available in one window annotating the source code was preferable to the functional-based approach of Forge <ref> [31] </ref>, which requires the programmer to bring up a series of windows to ac Page 4 cess the results of program analysis. To correct overly conservative analysis, users performed both dependence deletion and variable reclassification to reflect their perception of the true program state. <p> For this purpose, the users relied on external tools to profile their codes. They used the Unix utility gprof from Sun and Cray executions to derive procedure-level profiles. One user brought loop-level profiling available from Forge <ref> [31] </ref>, which shows the loop structure of a procedure, with the number of iterations executed and its percentage of execution time.
Reference: [32] <author> W. Pugh and D. Wonnacott. </author> <title> Eliminating false data dependences using the omega test. </title> <booktitle> In Proceedings of the SIG-PLAN '92 Conference on Program Language Design and Implementation, </booktitle> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: A similar approach is being pursued by Pugh and Wonnacott <ref> [32] </ref>.
Reference: [33] <author> J. Singh and J. Hennessy. </author> <title> An empirical investigation of the effectiveness of and limitations of automatic parallelization. </title> <booktitle> In Proceedings of the International Symposium on Shared Memory Multiprocessors, </booktitle> <address> Tokyo, Japan, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Although a substantial amount of research has been devoted to automatic parallelization, such systems are not consistently successful <ref> [1, 9, 6, 30, 33] </ref>. When automatic systems fail, the ParaScope Editor (Ped) assists in parallelizing Fortran applications by combining programmer expertise with extensive analysis and program transformations [3, 27, 28]. <p> In arc3d, an array is killed inside a procedure invoked in a loop, so interpro-cedural array kill analysis is required. To perform array privatization in slab2d, kill analysis must be combined with loop transformations. Because the need for array kill analysis has been discussed previously <ref> [6, 33] </ref>, we do not elaborate further here. Reductions. Five of the programs contain sum reductions which go unrecognized by Ped. For example, computing the sum of all the elements of an array. <p> Embedding and extraction are not currently implemented in Ped. 6 Related Work A few other papers report on the effectiveness of existing automatic parallelizing compilers on large applications <ref> [9, 6, 12, 13, 33] </ref> and of interactive tools [9]. Two of these suggest compiler-programmer interaction to achieve parallelization [9, 33]. Blume and Eigenmann explore the effectiveness of Kap [29] applied to Perfect benchmark programs on an 8-processor Alliant [6]. <p> Embedding and extraction are not currently implemented in Ped. 6 Related Work A few other papers report on the effectiveness of existing automatic parallelizing compilers on large applications [9, 6, 12, 13, 33] and of interactive tools [9]. Two of these suggest compiler-programmer interaction to achieve parallelization <ref> [9, 33] </ref>. Blume and Eigenmann explore the effectiveness of Kap [29] applied to Perfect benchmark programs on an 8-processor Alliant [6]. Half of the programs demonstrate little or no improvement following parallelization. <p> Eigenmann et al. presents novel approaches for improving parallelization in four Perfect programs [12, 13]. These techniques include run-time dependence testing and aggressive use of synchronization to guard critical sections. Singh and Hennessy examine parallelization of three programs on an 8-processor Alliant <ref> [33] </ref>. They observe that certain programming styles interfere with compiler analysis. These include linearized arrays and specialized use of the boundary elements in an array. <p> The existence of an advanced interactive tool allowed us to go beyond the comments provided by the studies of automatic parallelizers to investigate the appropriate level for compiler and tool interaction. For instance, users deleted dependences in Ped, as suggested previously <ref> [25, 33] </ref>, but requested higher-level assertions and guidance.
Reference: [34] <author> D. C. Smith, C. Irby, R. Kimball, B. Verplank, and E. Harslem. </author> <title> Designing the Star user interface. </title> <journal> BYTE, </journal> <volume> 7(4) </volume> <pages> 242-282, </pages> <month> April </month> <year> 1982. </year>
Reference-contexts: The book metaphor portrays a Fortran program as an electronic book with analysis results annotating the source, analogous to a book's marginal notes, footnotes, appendices, and indices [37]. Progressive disclosure presents details incrementally as they become relevant <ref> [34] </ref>. View filtering emphasizes or conceals parts of the book as specified by a user [14]. Power steering automates repetitive or error-prone tasks, providing unobtrusive assistance while leaving the user in control. The layout of a Ped window is shown in Figure 1.
Reference: [35] <author> J. Stein. </author> <title> On outer-loop parallelization of existing, real-life Fortran-77 programs. </title> <institution> Colloquium at Rice University, </institution> <month> July </month> <year> 1991. </year> <title> In collaboration with M. Paul and G.C. </title> <note> Fox. </note>
Reference-contexts: Table 1 lists the workshop attendees with the programs they contributed. Additional evaluations result from two studies of parallel programming tools: one by Joseph Stein, a visiting scientist at Syracuse University <ref> [35] </ref>, and another by Katherine Fletcher of Rice University and Doreen Cheng at Nasa Ames Research Center [16]. At the workshop, we divided the attendees into groups of one or two people and assigned a researcher familiar with Ped to assist each group.
Reference: [36] <author> R. C. Waters. </author> <title> Program editors should not abandon text oriented commands. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 17(7) </volume> <pages> 39-46, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: For example, source view filter predicates can test attributes of a line such as if it contains certain text or if it is a loop header. The source pane allows arbitrary editing of the program using mixed text and structure editing techniques <ref> [36] </ref>. The user has the full freedom to edit character by character or to use the power steering afforded by template-based structure editing. Incremental parsing occurs in response to edits, and the user is immediately informed of any syntactic or semantic errors. Dependence Information.
Reference: [37] <author> N. Yankelovitch, N. Meyrowitz, and A. van Dam. </author> <title> Reading and writing the electronic book. </title> <journal> IEEE Computer, </journal> <volume> 18(10) </volume> <pages> 15-29, </pages> <month> October </month> <year> 1985. </year> <pages> Page 11 </pages>
Reference-contexts: The book metaphor portrays a Fortran program as an electronic book with analysis results annotating the source, analogous to a book's marginal notes, footnotes, appendices, and indices <ref> [37] </ref>. Progressive disclosure presents details incrementally as they become relevant [34]. View filtering emphasizes or conceals parts of the book as specified by a user [14]. Power steering automates repetitive or error-prone tasks, providing unobtrusive assistance while leaving the user in control.
References-found: 37

