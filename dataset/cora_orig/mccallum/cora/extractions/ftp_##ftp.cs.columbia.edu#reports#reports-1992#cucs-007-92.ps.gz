URL: ftp://ftp.cs.columbia.edu/reports/reports-1992/cucs-007-92.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1992.html
Root-URL: http://www.cs.columbia.edu
Email: ftait,djdg@cs.columbia.edu  
Title: An Efficient Variable-Consistency Replicated File Service  
Author: Carl D. Tait and Dan Duchamp 
Address: New York, NY 10027  
Affiliation: Computer Science Department Columbia University  
Abstract: In a previous paper, we introduced a new method of file replica management designed to address the problems faced by mobile clients. Two goals shaped our design: minimizing synchronous operations, and letting clients determine the level of consistency desired. The previous paper was a high-level view of the most fundamental issues; here, we refine our previous ideas and flesh out the rest of the design. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Baker et al. </author> <title> Measurements of a Distributed File System. </title> <booktitle> In Proc. Thirteenth ACM Symp. on Operating System Principles, </booktitle> <pages> pages 198-212, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: While loose read () is allowed to return any convenient value, analysis of file-trace data presented in our previous paper indicates that a "best effort" implementation will almost always return the most up-to-date value. This conclusion is supported by the recent study by Baker et al. <ref> [1] </ref>, which found that only one third of one percent of open () calls read data that was written by another client less than 60 seconds previously.
Reference: [2] <author> M. Blaze and R. Alonso. </author> <title> Dynamic Hierarchical Caching in Large-Scale Distributed File Systems. </title> <booktitle> In Proc. Twelfth Intl. Conf. on Distributed Computing Systems, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Muntz and Honeyman [9] report that intermediate caches experience a surprisingly low hit rate: less than 19% when the client itself has a 20 megabyte cache. Blaze and Alonso <ref> [2] </ref> achieve better results by using a dynamic, hierarchical caching scheme. In their model, however, clients are assumed to have minimally-shared hierarchies such as home directories and temporary files stored on local disks, which is not an assumption we wish to make in our system.
Reference: [3] <author> H. Garcia-Molina. </author> <title> Elections in a Distributed Computing System. </title> <journal> IEEE Trans. Computers, </journal> <volume> C-31(1):48-59, </volume> <month> January </month> <year> 1982. </year>
Reference-contexts: When its requests go unanswered, the client asks the matchmaker for a new primary. By letting the client drive the process, and by recognizing that the new primary is not required to have 11 up-to-date versions of any files, we avoid the complexity of a traditional election scheme <ref> [3] </ref>. Furthermore, a primary can crash (or just drop out) at any time without causing updates to be lost.
Reference: [4] <author> D. K. Gifford. </author> <title> Weighted Voting for Replicated Data. </title> <booktitle> In Proc. Seventh ACM Symp. on Operating System Principles, </booktitle> <pages> pages 150-162, </pages> <month> December </month> <year> 1979. </year>
Reference-contexts: This condition is simply that of quorum consensus, wherein the read and write quorums must overlap <ref> [4] </ref>. Files are tagged with timestamps so that the copies at different replicas can be compared for recency. After reading T-N+1 copies, the primary compares the timestamps and gives the client the most recent copy of the file plus an indication of whether it has a CT.
Reference: [5] <author> C. G. Gray and D. R. Cheriton. Leases: </author> <title> An Efficient Fault-Tolerant Mechanism for Distributed File Cache Consistency. </title> <booktitle> In Proc. Twelfth ACM Symp. on Operating System Principles, </booktitle> <pages> pages 202-210, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: This is a comparatively infrequent operation, so scalability should not be adversely affected. We assume that secondary server mappings will rarely be changed, but we do provide a modification method based on Gray's idea of leases <ref> [5] </ref>. Mappings returned by map () are valid for only a limited period of time: relatively long (say, 10 to 30 minutes), but decidedly non-infinite. At the end of the lease period, map () must be called again to revalidate the mapping.
Reference: [6] <author> J. Ioannidis, D. Duchamp, and G. Q. Maguire, Jr. </author> <title> IP-based Protocols for Mobile Internetworking. </title> <booktitle> In Proc. SIGCOMM '91, </booktitle> <pages> pages 235-245, </pages> <month> September </month> <year> 1991. </year> <month> 15 </month>
Reference-contexts: The client need remember only its own address and the address of the mapping server at its home site. These addresses need to be retained in non-volatile storage. Previous work on mobile internetworking by Ioannidis et al. <ref> [6] </ref> has demonstrated the feasibility of such a scheme from a networking perspective.
Reference: [7] <author> T. Mann, A. Hisgen, and G. Swart. </author> <title> An Algorithm for Data Replication. </title> <type> Technical Report 46, </type> <institution> Digital Systems Research Center, </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: In a previous paper [14] we have argued that client mobility is a major new development that requires re-thinking file system design, and that existing approaches to replica management (e.g., <ref> [7, 13] </ref>) would not cope well with mobile clients. In that paper we proposed an alternative: a lazy "server-based" update scheme and a new service interface that allows applications to select strong or weak consistency semantics on each particular read call.
Reference: [8] <author> D. L. Mills. </author> <title> Network Time Protocol (Version 2) Specification and Implementation. Network Working Group RFC 1119, </title> <month> September </month> <year> 1989. </year>
Reference-contexts: A file cache of modest size is maintained by each client. 1 5. File service sites can synchronize their clocks. This assumption, once controversial, can now be satisfied by several clock synchronization protocols (e.g., <ref> [8] </ref>). We do not make any assumptions about client clocks. Flowing from these assumptions is our conclusion that three design goals are of paramount importance in handling mobile clients: we must minimize synchronous multi-server operations, ease the addition and deletion of server sites, and allow for incomplete replication at servers.
Reference: [9] <author> D. Muntz and P. Honeyman. </author> <title> Multi-level Caching in Distributed File Systems. </title> <type> Technical Report CITI TR 91-3, </type> <institution> University of Michigan, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: Muntz and Honeyman <ref> [9] </ref> report that intermediate caches experience a surprisingly low hit rate: less than 19% when the client itself has a 20 megabyte cache. Blaze and Alonso [2] achieve better results by using a dynamic, hierarchical caching scheme.
Reference: [10] <author> J. Ousterhout and F. Douglis. </author> <title> Beating the I/O Bottleneck: A Case for Log-Structured File Systems. </title> <journal> Operating Systems Review, </journal> <volume> 23(1) </volume> <pages> 11-28, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: This paper finishes our design. We make several assumptions about operating conditions: 1. Client movements cannot be constrained, although patterns of movement may exist. 2. Latency of remote operations degrades as the distance between hosts increases. 3. The presented load is what Ousterhout has called "engineering/office applications" <ref> [10] </ref>. In this model workload, sequential sharing is not uncommon, but simultaneous sharing (other than read-read) is rare. 4. A file cache of modest size is maintained by each client. 1 5. File service sites can synchronize their clocks.
Reference: [11] <author> J.-F. Paris. </author> <title> Voting with Witnesses: A Consistency Scheme for Replicated Files. </title> <booktitle> In Proc. Sixth Intl. Conf. on Distributed Computing Systems, </booktitle> <pages> pages 606-612, </pages> <year> 1986. </year>
Reference-contexts: Nonetheless, by using the scheme described above, we ensure that an initial strict read will find the most recent replica, assuming that a sufficient number of secondaries are available. A secondary that does not have a replica of the file in question acts as a kind of witness <ref> [11] </ref>: a server that may be counted as part of a quorum even though it contains no explicit information about a file. Reducing Initial Strict Reads.
Reference: [12] <author> M. Satyanarayanan et al. Coda: </author> <title> A Highly Available File System for a Distributed Workstation Environment. </title> <journal> IEEE Trans. Computers, </journal> <volume> 39(4) </volume> <pages> 447-459, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: They are simply hints used to improve the performance of strict reads. In other systems, tokens are prerequisites for performing operations; in our design, strict reads can take place without using currency tokens, though performance will be less than optimal. CTs are somewhat akin to callbacks in Coda <ref> [12] </ref>, though the pessimistic nature of CTs provides a stronger consistency guarantee: a CT will not be granted if any other client has even the potential to make a consistent update. 2.2 Client-Primary Attachment Client-to-primary assignments are made by a special module called the matchmaker, which is most conveniently implemented as <p> This person 2 Although version vectors are a more powerful conflict detection mechanism than timestamps, the added power would not provide a significant advantage in our system. Version vectors are useful for detecting conflicts in an optimistic system such as Coda <ref> [12] </ref>, which always returns the best value it can find. In contrast, our strict read () operation will not return any value unless a certain level of consistency can be assured, thereby preventing many potential conflicts from occurring.
Reference: [13] <author> A. Siegel, K. Birman, and K. Marzullo. Deceit: </author> <title> A Flexible Distributed File System. </title> <booktitle> In Proc. 1990 Summer USENIX Technical Conf., </booktitle> <pages> pages 51-62. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: In a previous paper [14] we have argued that client mobility is a major new development that requires re-thinking file system design, and that existing approaches to replica management (e.g., <ref> [7, 13] </ref>) would not cope well with mobile clients. In that paper we proposed an alternative: a lazy "server-based" update scheme and a new service interface that allows applications to select strong or weak consistency semantics on each particular read call. <p> For this case, we provide a synchronous, blocking forced write operation that causes an immediate pickup. Asynchronous update propagation has well-known benefits and dangers, and it has been used in the design of other replicated file systems (e.g., <ref> [13] </ref>). Our work is significantly different in two ways. First, by requiring that the client retain an update until a sufficient number of secondaries have the new value, we trade cache space for a low-latency, yet reliable write operation.
Reference: [14] <author> C. Tait and D. Duchamp. </author> <title> Service Interface and Replica Management Algorithm for Mobile File System Clients. </title> <booktitle> In Proc. First Intl. Conf. on Parallel and Distributed Information Systems, </booktitle> <pages> pages 190-197, </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1991. </year> <month> 16 </month>
Reference-contexts: 1 Introduction This work investigates how to design a replicated file system that will serve mobile clients well. The idea that file service clients might be mobile is a natural one, given the likely marriage between two exploding trends: portable computers and wireless networks. In a previous paper <ref> [14] </ref> we have argued that client mobility is a major new development that requires re-thinking file system design, and that existing approaches to replica management (e.g., [7, 13]) would not cope well with mobile clients.
References-found: 14

