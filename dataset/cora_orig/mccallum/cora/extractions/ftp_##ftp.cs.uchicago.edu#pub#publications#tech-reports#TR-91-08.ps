URL: ftp://ftp.cs.uchicago.edu/pub/publications/tech-reports/TR-91-08.ps
Refering-URL: http://cs-www.uchicago.edu/publications/tech-reports/
Root-URL: 
Title: Checking Computations in Polylogarithmic Time setup, a single reliable PC can monitor the operation of
Author: Laszlo Babai Lance Fortnow Leonid A. Levin Mario Szegedy 
Note: In this  
Address: Budapest  Chicago 6  Boston University 4  Chicago  
Affiliation: Univ. of Chicago 6 and Eotvos Univ.,  Dept. Comp. Sci. Univ. of  Dept. Comp. Sci.  Dept. Comp. Sci. Univ. of  
Abstract: Motivated by Manuel Blum's concept of instance checking, we consider new, very fast and generic mechanisms of checking computations. Our results exploit recent advances in interactive proof protocols [LFKN92], [Sha92], and especially the M IP = N EXP protocol from [BFL91]. We show that every nondeterministic computational task S(x; y), defined as a polynomial time relation between the instance x, representing the input and output combined, and the witness y can be modified to a task S 0 such that: (i) the same instances remain accepted; (ii) each instance/witness pair becomes checkable in polylogarithmic Monte Carlo time; and (iii) a witness satisfying S 0 can be computed in polynomial time from a witness satisfying S. Here the instance and the description of S have to be provided in error-correcting code (since the checker will not notice slight changes). A modification of the M IP proof was required to achieve polynomial time in (iii); the earlier technique yields N O(log log N) time only. This result becomes significant if software and hardware reliability are regarded as a considerable cost factor. The polylogarithmic checker is the only part of the system that needs to be trusted; it can be hard wired. (We use just one Checker for all problems!) The checker is tiny and so presumably can be optimized and checked off-line at a modest cost. In another interpretation, we show that in polynomial time, every formal mathematical proof can be transformed into a transparent proof, i.e. a proof verifiable in polylogarithmic Monte Carlo time, assuming the "theorem-candidate" is given in error-correcting code. In fact, for any " &gt; 0, we can transform any proof P in time kP k 1+" into a transparent proof, verifiable in Monte Carlo time (log kP k) O(1=") . As a by-product, we obtain a binary error correcting code with very efficient error-correction. The code transforms messages of length N into codewords of length N 1+" ; and for strings within 10% of a valid codeword, it allows to recover any bit of the unique codeword within that distance in polylogarithmic ((log N ) O(1=") ) time. 
Abstract-found: 1
Intro-found: 1
Reference: [AHK77] <author> K. Appel, W. Haken, and J. Koch. </author> <title> Every planar map is four colorable. Part II: Reducibility. </title> <journal> Illinois Journal of Mathematics, </journal> <volume> 21 </volume> <pages> 491-567, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction 1.1 Very long mathematical proofs An interesting foundational problem is posed by some mathematical proofs which are too large to be checked by a single human. The proof of the Four Color Theorem <ref> [AHK77] </ref>, considered controversial at the time, started with a Lemma that the Theorem follows if certain computation terminates. It was completed with the experimental fact that the computation did indeed terminate within two weeks on contemporary computers. The "Enormous Theorem" [Gor85] provides the classification of all finite simple groups.
Reference: [ALM + 92] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and hardness of approximation problems. </title> <booktitle> In Proceedings of the 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 14-23. </pages> <publisher> IEEE, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: In fact we get the stronger result that the proof has size n 1+* . Arora and Safra [AS92] and Arora, Lund, Motwani, Sudan and Szegedy <ref> [ALM + 92] </ref> build on this result to show that N P = [ c&gt;0 P CP (c log (n); c). 3 A Transparent Proof Based on MIP In this section we will informally show how to convert results on multiple prover interactive proof systems to weak results on transparent proofs.
Reference: [AS92] <author> S. Arora and S. Safra. </author> <title> Approximating clique is NP-complete. </title> <booktitle> In Proceedings of the 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 2-13. </pages> <publisher> IEEE, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: with high probability outputs "P does not compute a correct E (W )," unless (except for a small fraction of easily and uniquely recoverable errors) x; S are in error-correcting form and x is acceptable (i.e. (9W )S (x; W )). 2.4 Applications to Probabilistically Checkable Programs Arora and Safra <ref> [AS92] </ref> define a hierarchy of complexity classes PCP (for probabilistically checkable proofs), corresponding to the number of random and query bits required to verify a proof of membership in the language, as follows: A verifier M is a probabilistic polynomial-time Turing machine with random access to a string representing a membership <p> In fact we get the stronger result that the proof has size n 1+* . Arora and Safra <ref> [AS92] </ref> and Arora, Lund, Motwani, Sudan and Szegedy [ALM + 92] build on this result to show that N P = [ c&gt;0 P CP (c log (n); c). 3 A Transparent Proof Based on MIP In this section we will informally show how to convert results on multiple prover interactive
Reference: [BF90] <author> D. Beaver and J. Feigenbaum. </author> <title> Hiding instances in multioracle queries. </title> <booktitle> In Proceedings of the 7th Symposium on Theoretical Aspects of Computer Science, volume 415 of Lecture Notes in Computer Science, </booktitle> <pages> pages 37-48. </pages> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: Then f cannot vanish in more than a d=jIj fraction of I m . (The proof is by a simple induction on m.) An important property of low degree polynomials over not too small finite fields is that they are random self-reducible, as observed by Beaver-Feigenbaum <ref> [BF90] </ref> and Lipton [Lip91]. They show that an m-variate polynomial p : F m ! F of degree d can be recovered from an ff-approximation assuming ff 1=(2d) and jFj d+2. A.
Reference: [BF91] <author> L. Babai and L. Fortnow. Arithmetization: </author> <title> A new method in structural complexity theory. </title> <journal> Computational Complexity, </journal> <volume> 1(1) </volume> <pages> 41-66, </pages> <year> 1991. </year>
Reference-contexts: In recent consecutive extensions of the power of interactive proofs, complete languages in the corresponding classes were shown to admit Blum-Kannan instance checkers: P #P [LFKN92], P SP ACE [Sha92], EXP [BFL91]. (See <ref> [BF91] </ref> for more such classes.) The Checker of the present paper runs in polylogarithmic time and needs no interaction with the program to be checked. There is some conceptual price to pay for these advantages.
Reference: [BFL91] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Non-deterministic exponential time has two-prover interactive protocols. </title> <journal> Computational Complexity, </journal> <volume> 1(1) </volume> <pages> 3-40, </pages> <year> 1991. </year>
Reference-contexts: If the answer differs, reject. Repeat this process a polylogarithmic number of times. If no contradiction arises, accept (cf. [BGKW88], [FRS88], <ref> [BFL91] </ref>). We can give a helping hand to the Solver to enable his program to respond in something like real time to the Checker's questions, after some preprocessing. <p> In recent consecutive extensions of the power of interactive proofs, complete languages in the corresponding classes were shown to admit Blum-Kannan instance checkers: P #P [LFKN92], P SP ACE [Sha92], EXP <ref> [BFL91] </ref>. (See [BF91] for more such classes.) The Checker of the present paper runs in polylogarithmic time and needs no interaction with the program to be checked. There is some conceptual price to pay for these advantages. <p> Fortnow, Rompel and Sipser [FRS88] show that the languages accepted by multiple provers and [ k&gt;0 P CP (n k ; n k ) are equivalent. Thus Babai, Fortnow and Lund <ref> [BFL91] </ref> show that NEXP = [ k&gt;0 P CP (n k ; n k ). The results in this paper show that N P [ c&gt;0 P CP (c log n; log c n) since a careful analysis shows that we only need O (log n) coins in our protocol. <p> For every x 62 L and for all oracles O 0 , M O 0 accepts with probability &lt; 1 p (jxj) for all polynomials p and x sufficiently large. Babai, Fortnow and Lund <ref> [BFL91] </ref> show that every language in nondeterministic exponential time is accepted by a probabilistic oracle machine. They also show that every language in deterministic exponential time has such a machine where the oracle O can be computed in deterministic exponential time. <p> We will explain the structure of these graphs in Section 6. The set C of colors will be viewed as a subset of a field F. The transparent version will involve an extension of this string to a table of values of a multivariate polynomial over F. <ref> [BFL91] </ref> suggests to identify the domain V of A with f0; 1g n , and, regarding f0; 1g as a subset of F, extend A to a multilinear function over I n where I is a finite subset of F. However, in order for the [LFKN92]-type protocol of [BFL91] to work, <p> over F. <ref> [BFL91] </ref> suggests to identify the domain V of A with f0; 1g n , and, regarding f0; 1g as a subset of F, extend A to a multilinear function over I n where I is a finite subset of F. However, in order for the [LFKN92]-type protocol of [BFL91] to work, one requires I to have order (n 2 ), forcing the table of the multilinear function to have size n (n) = N (log log N) , where N = 2 n is the length of A. This would render the "transparent proof" slightly superpolynomial. <p> A function is ff-approximately h-smooth if it is an ff-approximation of an h-smooth function. 1-smooth polynomials are called multilinear. One of the key ingredients of the M IP = N EXP protocol in <ref> [BFL91] </ref> is a multilinear-ity/low degree test. Theorem 4.4 ([BFL91]) Let F be a field, h; m positive integers, and I a finite subset of F. <p> The algorithm queries hm O (1) values of f. For the proof, see <ref> [BFL91, Theorem 5.13 and Remark 5.15] </ref>. (Specific citations refer to the journal version.) A more efficient version of the algorithm was recently found by Szegedy (see [FGL + 91]). <p> We review the protocol which is a slight variation of the one used for an analogous purpose in <ref> [BFL91, Proposition 3.3] </ref>. The protocol builds on the technique of Lund, Karloff, Fortnow, and Nisan [LFKN92]. The protocol will work assuming the degree of f is d in each variable (f is d-smooth), and jIj 2dm. The protocol proceeds in rounds. There are m rounds. <p> It follows that unless one of the Consistency Tests fails, with probability 1 dm=jIj, the same error will have to occur in each round. But the error in the last round is discovered by the Final Test. 2 5.2 Simultaneous vanishing In <ref> [BFL91] </ref>, simultaneous vanishing of all values f (x); x 2 D was reduced to the statement P This trick works over subfields of the reals and will be used in the main procedure (Section 8). However, if we wish to avoid large-precision arithmetic, a different approach is required. <p> However, if we wish to avoid large-precision arithmetic, a different approach is required. We modify a procedure described in <ref> [BFL91, Section 7.1] </ref>. The situation is similar to Section 5.1, except that rather than verifying equation (4), we have to verify that f (u) = 0 for each u 2 H m . In this section we show how to reduce this problem to the result of Section 5.1.
Reference: [BGKW88] <author> M. Ben-Or, S. Goldwasser, J. Kilian, and A. Wigderson. </author> <title> Multi-prover interactive proofs: How to remove intractability assumptions. </title> <booktitle> In Proceedings of the 20th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 113-131. </pages> <publisher> ACM, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: If the answer differs, reject. Repeat this process a polylogarithmic number of times. If no contradiction arises, accept (cf. <ref> [BGKW88] </ref>, [FRS88], [BFL91]). We can give a helping hand to the Solver to enable his program to respond in something like real time to the Checker's questions, after some preprocessing.
Reference: [BGW88] <author> M. Ben-Or, S. Goldwasser, and A. Wigderson. </author> <title> Completeness theorems for non-cryptographic fault-tolerant distributed computation. </title> <booktitle> In Proceedings of the 20th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 1-10. </pages> <publisher> ACM, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: A. Wigderson has pointed out to us that the bound on ff can be improved to a constant, say 15%, using known error-correction techniques in the way used by Ben-Or, Goldwasser, and Wigderson <ref> [BGW88] </ref> in their "secret sharing with cheaters" protocol. We briefly review the technique and state the result. Proposition 4.3 Let p be an unknown polynomial of degree d in m variables over the finite field F. <p> If this is the case, the polynomial e' can be recovered from the values of '. Indeed, as observed in <ref> [BGW88, p. 5] </ref>, this is a case of correcting errors in a generalized Reed-Muller code, cf.[PW72, p. 283].
Reference: [BK89] <author> M. Blum and S. Kannan. </author> <title> Designing programs that check their work. </title> <booktitle> In Proceedings of the 21st ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 86-97. </pages> <publisher> ACM, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Blum and Kannan <ref> [BK89] </ref> define a program checker C P L for a language L and an instance x 2 f0; 1g fl as a probabilistic polynomial-time oracle Turing Machine, that, given a program P claiming to compute L and an input x, outputs with high probability: 1. "correct," if P correctly computes L
Reference: [FGL + 91] <author> U. Feige, S. Goldwasser, L. Lovasz, S. Safra, and M. Szegedy. </author> <title> Approximating clique is almost NP-complete. </title> <booktitle> In Proceedings of the 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 2-12. </pages> <publisher> IEEE, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: The algorithm queries hm O (1) values of f. For the proof, see [BFL91, Theorem 5.13 and Remark 5.15]. (Specific citations refer to the journal version.) A more efficient version of the algorithm was recently found by Szegedy (see <ref> [FGL + 91] </ref>). We shall now combine this result with the ideas of Beaver, Feigenbaum, Lipton, Ben-Or, Goldwasser, and Wigderson to upgrade the test, incorporating a strong self-correction feature which makes the test tolerant to errors of up to a substantial fraction of the domain.
Reference: [FRS88] <author> L. Fortnow, J. Rompel, and M. Sipser. </author> <title> On the power of multi-prover interactive protocols. </title> <booktitle> In Proceedings of the 3rd IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 156-161. </pages> <publisher> IEEE, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: If the answer differs, reject. Repeat this process a polylogarithmic number of times. If no contradiction arises, accept (cf. [BGKW88], <ref> [FRS88] </ref>, [BFL91]). We can give a helping hand to the Solver to enable his program to respond in something like real time to the Checker's questions, after some preprocessing. <p> If x 62 L, then for all proofs , the probability over random strings of length r (n) that M using proof accepts is bounded by 1=2. Fortnow, Rompel and Sipser <ref> [FRS88] </ref> show that the languages accepted by multiple provers and [ k&gt;0 P CP (n k ; n k ) are equivalent. Thus Babai, Fortnow and Lund [BFL91] show that NEXP = [ k&gt;0 P CP (n k ; n k ). <p> Instead of the standard defintion of multiple prover interactive proof systesm, we will use the following equivalent defintion due to Fortnow, Rompel and Sipser <ref> [FRS88] </ref>: Let M be a probabilistic polynomial time Turing machine with access to an oracle O.
Reference: [Gor85] <author> D. Gorenstein. </author> <title> The enormous theorem. </title> <journal> Scientific American, </journal> <volume> 253(6) </volume> <pages> 104-115, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: The proof of the Four Color Theorem [AHK77], considered controversial at the time, started with a Lemma that the Theorem follows if certain computation terminates. It was completed with the experimental fact that the computation did indeed terminate within two weeks on contemporary computers. The "Enormous Theorem" <ref> [Gor85] </ref> provides the classification of all finite simple groups. Its proof, spread over 15,000 pages in Gorenstein's estimate, consists of a large number of difficult lemmas.
Reference: [KU58] <author> A. Kolmogorov and V. Uspenski. </author> <title> On the definition of an algorithm. </title> <journal> Uspehi Mat. Nauk, </journal> <note> 13(4):3--28, 1958. Translation in [KU63]. </note>
Reference-contexts: Second, we intend to transform very long mathematical proofs into transparent form. Squaring the length of the proof of the Enormous Theorem would seem too much. Better accuracy is harder to achieve in machine-independent terms. One possibility is to accept the thesis of Kolmogorov and Uspenski <ref> [KU58] </ref> that the Pointer Machine model of computation proposed there (the original and cleaner version of RAM; see below) simulates, with constant factor time overhead, any other realistic model (including formal mathematical proofs). This thesis suggests the following solution.
Reference: [KU63] <author> A. Kolmogorov and V. Uspenski. </author> <title> On the definition of an algorithm. </title> <journal> American Mathematical Society Translations, </journal> <volume> 29 </volume> <pages> 217-245, </pages> <year> 1963. </year>
Reference: [LFKN92] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan. </author> <title> Algebraic methods for interactive proof systems. </title> <journal> Journal of the ACM, </journal> <volume> 39(4) </volume> <pages> 859-868, </pages> <year> 1992. </year>
Reference-contexts: In recent consecutive extensions of the power of interactive proofs, complete languages in the corresponding classes were shown to admit Blum-Kannan instance checkers: P #P <ref> [LFKN92] </ref>, P SP ACE [Sha92], EXP [BFL91]. (See [BF91] for more such classes.) The Checker of the present paper runs in polylogarithmic time and needs no interaction with the program to be checked. There is some conceptual price to pay for these advantages. <p> We review the protocol which is a slight variation of the one used for an analogous purpose in [BFL91, Proposition 3.3]. The protocol builds on the technique of Lund, Karloff, Fortnow, and Nisan <ref> [LFKN92] </ref>. The protocol will work assuming the degree of f is d in each variable (f is d-smooth), and jIj 2dm. The protocol proceeds in rounds. There are m rounds.
Reference: [Lip91] <author> R. Lipton. </author> <title> New directions in testing. </title> <editor> In J. Feigenbaum and M. Merritt, editors, </editor> <booktitle> Distributed Computing and Cryptography, volume 2 of DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <pages> pages 191 - 202. </pages> <publisher> American Mathematical Society, </publisher> <address> Providence, </address> <year> 1991. </year>
Reference-contexts: Then f cannot vanish in more than a d=jIj fraction of I m . (The proof is by a simple induction on m.) An important property of low degree polynomials over not too small finite fields is that they are random self-reducible, as observed by Beaver-Feigenbaum [BF90] and Lipton <ref> [Lip91] </ref>. They show that an m-variate polynomial p : F m ! F of degree d can be recovered from an ff-approximation assuming ff 1=(2d) and jFj d+2. A.
Reference: [MS77] <author> F. MacWilliams and N. Sloane. </author> <title> The Theory of Error-Correcting Codes. </title> <publisher> North-Holland, </publisher> <address> Ams-terdam, </address> <year> 1977. </year>
Reference-contexts: This justifies statement (b) (for tokens). (c) and (d) (for tokens) follow from Corollary 4.5. Now to switch to bits from tokens, we have to apply an encoding of the tokens themselves. Here we have a large degree of freedom; e.g. Justesen's codes will work (cf. <ref> [MS77, Chap.10.11] </ref>).
Reference: [PW72] <author> W. Peterson and W. Weldon, Jr. </author> <title> Error-correcting Codes. </title> <publisher> MIT Press, </publisher> <year> 1972. </year>
Reference: [Sch80a] <author> A. Schonhage. </author> <title> Storage modification machines. </title> <journal> SIAM Journal on Computing, </journal> <volume> 9(3) </volume> <pages> 490-508, </pages> <year> 1980. </year>
Reference-contexts: Pointer Machines are equivalent to RAM's within the accuracy relevant for us (polylog factors). We describe a slightly generalized version (to directed graphs) due to A. Schonhage <ref> [Sch80a] </ref>. This definition is not required for the technical details of the proofs but it may contribute to conceptual clarity. The memory configuration of a Pointer Machine (PM) is a directed graph with labeled edges. The set of labels (colors) is finite and predefined independently of the input.
Reference: [Sch80b] <author> J. Schwartz. </author> <title> Fast probabilistic algorithms for verification of polynomial identities. </title> <journal> Journal of the ACM, </journal> <volume> 27 </volume> <pages> 701-717, </pages> <year> 1980. </year>
Reference-contexts: An important feature of low degree polynomials is that they form an error-correcting code with large distance: two such polynomials can agree on a small fraction of their domain only, assuming the domain is not too small. This follows from a well known lemma of J. T. Schwartz <ref> [Sch80b] </ref> which we quote. Lemma 4.2 (J. T. Schwartz) Let I F be a finite subset of the field F. Let f : F m ! F be an m-variate polynomial of (combined) degree d 0.
Reference: [Sha92] <author> A. Shamir. </author> <title> IP = PSPACE. </title> <journal> Journal of the ACM, </journal> <volume> 39(4) </volume> <pages> 869-877, </pages> <year> 1992. </year>
Reference-contexts: In recent consecutive extensions of the power of interactive proofs, complete languages in the corresponding classes were shown to admit Blum-Kannan instance checkers: P #P [LFKN92], P SP ACE <ref> [Sha92] </ref>, EXP [BFL91]. (See [BF91] for more such classes.) The Checker of the present paper runs in polylogarithmic time and needs no interaction with the program to be checked. There is some conceptual price to pay for these advantages.
References-found: 21

