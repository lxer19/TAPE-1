URL: http://polaris.cs.uiuc.edu/reports/1227.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/tech_reports.html
Root-URL: http://www.cs.uiuc.edu
Email: (harrisonjammargue)@csrd.uiuc.edu  
Title: A Program's Eye View of Miprac  
Author: Williams Ludwell Harrison, III Zahira Ammarguellat 
Date: May 18, 1992  
Address: Urbana, Illinois, 61801  
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign  
Abstract: Miprac is a parallelizing C, Lisp and Fortran compiler. We present its workings by following a C program as it progresses through the modules of the compiler. Miprac makes use of a simple, operational intermediate form, called MIL. Dependence analysis and memory management are performed by a whole-program abstract interpretation of MIL. We present the intermediate form, and illustrate the analysis and transformation of the example program as it becomes a parallel object code for Cedar.
Abstract-found: 1
Intro-found: 1
Reference: [AH87] <author> S. Abramsky and C. Hankin. </author> <title> Abstract Interpretation of Declarative Languages, chapter An introduction to abstract interpretation, </title> <address> pages 9-31. </address> <publisher> Ellis Horwood Books in Computing Science. Halsted Press (John Wiley and Sons), </publisher> <year> 1987. </year>
Reference-contexts: The operator + means unsigned addition (field offsets are nonnegative). 3 Abstract Interpretation Miprac's interprocedural analysis is an abstract interpretation. Space does not permit a description of this technique. See <ref> [AH87] </ref> for an introduction to the topic, and [Har89] for a detailed development of an abstract interpretation like Miprac's. The details of Miprac's interprocedural analysis are explained in an upcoming monograph. For the purpose of this paper, let us conceive of it in the following, oversimplified way.
Reference: [Amm92] <author> Z. Ammarguellat. </author> <title> An algorithm for control-flow normalization and its complexity. </title> <journal> IEEE TOSE, </journal> <volume> 18(3) </volume> <pages> 237-251, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: To set the contents of k to 1 we write (write k 1). Following translation into MIL is a control-flow normalizer, the purpose of which is to simplify (structure) the intermediate form by eliminating go's and target's. The method is described in detail in <ref> [Amm92] </ref>. After this phase, loops are represented as tail-recursive procedures and the only transfers of control that remain in the program are call expressions. In Figure 3, procedure p is shown after normalization.
Reference: [Ban79] <author> J.P. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> In 6th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1979. </year>
Reference-contexts: In our opinion, dependence testing in the presense of pointers has three aspects. The first is a global assessment of the side-effects of procedures and expressions <ref> [Har89, Nei88, LD88, GJLS87, Ban79, Rey78] </ref>. This is necessary to restrict the visibility of effects upon data that lives for only part of a computation (and this is most data in the case of many Lisp, C and C++ programs).
Reference: [Bod] <author> Francois Bodin. </author> <title> Preliminary report: Data structure analysis in c programs. </title>
Reference-contexts: The third aspect is the dependence test itself, which must relate accesses which we suspect are dependent upon one another, to the structure (connectivity) of the objects they are accessing, and to the control-flow of the procedures in which the accesses take place <ref> [HPR89, HN90, Bod, LH88, Rey78] </ref>. <p> It turns out that there is a simple theorem that pertains to the procedure strings that label the edges of such a graph, that can be used to prove the absence of cycles and sharing in the data structure it summarizes. This is quite similar to results obtained in <ref> [LR91, HN90, CWZ90, Bod, JM82] </ref> (or straightforward extensions of those methods). Our approach has both advantages and disadvantages compared to those methods.
Reference: [CWZ90] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <year> 1990. </year>
Reference-contexts: The second aspect of dependence testing in the presense of pointers is to determine relationships between pointers (locations) and the objects they point to <ref> [LR91, HN90, CWZ90, LH88, Gua87, JM82] </ref>. This is typically an analysis of their connectivity by means of a graph that approximates their structure [CWZ90, JM82], or by enumeration of the possibly aliased paths in memory [HN90, Deu92, LR91, Gua87]. <p> The second aspect of dependence testing in the presense of pointers is to determine relationships between pointers (locations) and the objects they point to [LR91, HN90, CWZ90, LH88, Gua87, JM82]. This is typically an analysis of their connectivity by means of a graph that approximates their structure <ref> [CWZ90, JM82] </ref>, or by enumeration of the possibly aliased paths in memory [HN90, Deu92, LR91, Gua87]. We have chosen a store-based method that we will illustrate briefly below. <p> It turns out that there is a simple theorem that pertains to the procedure strings that label the edges of such a graph, that can be used to prove the absence of cycles and sharing in the data structure it summarizes. This is quite similar to results obtained in <ref> [LR91, HN90, CWZ90, Bod, JM82] </ref> (or straightforward extensions of those methods). Our approach has both advantages and disadvantages compared to those methods.
Reference: [Deu92] <author> Alain Deutsch. </author> <title> A storeless model of aliasing and its abstractions using finite representations of right-regular equivalence relations. </title> <booktitle> In Proceedings of the IEEE 1992 International Conference on Computer Languages. </booktitle> <publisher> IEEE Press, </publisher> <month> April </month> <year> 1992. </year>
Reference-contexts: This is typically an analysis of their connectivity by means of a graph that approximates their structure [CWZ90, JM82], or by enumeration of the possibly aliased paths in memory <ref> [HN90, Deu92, LR91, Gua87] </ref>. We have chosen a store-based method that we will illustrate briefly below. <p> On the other hand, it does not behave as well as the method of [HN90] when local modifications are made to a tree, especially if many control movements occur between construction of the tree and subsequent modification of its links. The method of <ref> [Deu92] </ref> is able to describe more complex relations among pointers than is possible with our framework, but is applied to a much simpler programming language than C (or MIL) in the cited paper.
Reference: [GJLS87] <author> D. K. Gifford, P. Jouvelot, J. M. Lucassen, and M. A. Sheldon. </author> <title> Fx-87 reference manual. </title> <type> Technical Report MIT/LCS/TR-407, </type> <institution> Mas-sachusetts Institute of Technology, </institution> <month> January </month> <year> 1987. </year>
Reference-contexts: In our opinion, dependence testing in the presense of pointers has three aspects. The first is a global assessment of the side-effects of procedures and expressions <ref> [Har89, Nei88, LD88, GJLS87, Ban79, Rey78] </ref>. This is necessary to restrict the visibility of effects upon data that lives for only part of a computation (and this is most data in the case of many Lisp, C and C++ programs). <p> An aggressive side-effect analysis greatly reduces the number of individual access that must be considered (by circumscribing the visibility of those accesses.) The propagation of side-effects is sometimes controlled by language restrictions [LH92], or by language extensions <ref> [GJLS87] </ref>, but when treating C and Lisp programs in their generality these solutions are not applicable. The second aspect of dependence testing in the presense of pointers is to determine relationships between pointers (locations) and the objects they point to [LR91, HN90, CWZ90, LH88, Gua87, JM82].
Reference: [Gua87] <author> Vincent Antony Guarna. </author> <title> Analysis of c programs for parallelization in the presence of pointers. </title> <type> Technical Report 695, </type> <institution> Center for Supercomputing Research and Development, University of Illinois at Urbana-Champaign, </institution> <year> 1987. </year>
Reference-contexts: The second aspect of dependence testing in the presense of pointers is to determine relationships between pointers (locations) and the objects they point to <ref> [LR91, HN90, CWZ90, LH88, Gua87, JM82] </ref>. This is typically an analysis of their connectivity by means of a graph that approximates their structure [CWZ90, JM82], or by enumeration of the possibly aliased paths in memory [HN90, Deu92, LR91, Gua87]. <p> This is typically an analysis of their connectivity by means of a graph that approximates their structure [CWZ90, JM82], or by enumeration of the possibly aliased paths in memory <ref> [HN90, Deu92, LR91, Gua87] </ref>. We have chosen a store-based method that we will illustrate briefly below.
Reference: [Har89] <author> W.L. Harrison III. </author> <title> The interprocedural analysis and automatic par-allelization of scheme programs. Lisp and Symbolic Computation: </title> <journal> an International Journal, </journal> 2(3/4):179-396, 1989. 
Reference-contexts: The operator + means unsigned addition (field offsets are nonnegative). 3 Abstract Interpretation Miprac's interprocedural analysis is an abstract interpretation. Space does not permit a description of this technique. See [AH87] for an introduction to the topic, and <ref> [Har89] </ref> for a detailed development of an abstract interpretation like Miprac's. The details of Miprac's interprocedural analysis are explained in an upcoming monograph. For the purpose of this paper, let us conceive of it in the following, oversimplified way. <p> The fundamental idea behind interprocedural analysis in Miprac is the time-dependent value. Before we can speak about a time-dependent value, we must have a notion of time. 4 Procedure Strings The basic metric of time in Miprac is the procedure string. These were introduced in <ref> [Har89] </ref>, but we will review (and amend) the definitions here. Imagine that as we execute a program, we accumulate a string that records all of the procedure calls and returns made from the beginning of the program. <p> None are reflexive. Similar domains are used in <ref> [Har89] </ref>, but no interesting domains of integers or truth-values are given there. 10 Time-Varying Integers 11 A Domain of Truth Looked at differently, Miprac considers each call expression of the program to define one dimension of a multidimensional iteration space. Conceptually, a count is associated with each call expression. <p> In our opinion, dependence testing in the presense of pointers has three aspects. The first is a global assessment of the side-effects of procedures and expressions <ref> [Har89, Nei88, LD88, GJLS87, Ban79, Rey78] </ref>. This is necessary to restrict the visibility of effects upon data that lives for only part of a computation (and this is most data in the case of many Lisp, C and C++ programs). <p> In the text below, we will write ^p by showing its graph (as a function) between brackets: ^p = [ff 7! d; fi 7! ujuu+]. When a procedure fl is mapped to *, it will simply be omitted from the brackets. (See <ref> [Har89] </ref> for a complete description of abstract procedure strings.) The value shown in Figure 9 is, as was the value in Figure 8, a location (an element of the domain L). <p> It seems to the analysis that it has made every possible movement with respect to procedure f. A number of interesting theorems relating procedure strings to side-effects and memory management were proven in <ref> [Har89] </ref>. <p> In this case, for example, neither g, h, call expression 127 nor call expression 96 have side-effects as a result of the accesses to $DYN-25 in f. We known this because the procedure string ^p in is, no net downward movements). A similar theorem was proven in <ref> [Har89] </ref> concerning the placement of objects in memory; it says that if p p b contains no term ff u then the object may be deallocated when ff is deactivated. <p> It localizes scalar variables according to interprocedural definitions and uses. Finally, it inserts two-way cobegin expressions to express concurrency. We are not advocating this as a method of parallelization; a more powerful suite of transformations, like those in [PW86] and <ref> [Har89] </ref> would be preferable, but the emphasis in Miprac is upon interprocedural analysis, and the construction of a complete compiler, from parsers to code generator. In this figure, the program listing is shown, but the only expressions displayed are procedure, call, and cobegin.
Reference: [Har91] <author> W.L. Harrison III. </author> <title> Generalized iteration space and the parallelization of symbolic programs. </title> <editor> In Ian Foster and Evan Tick, editors, </editor> <booktitle> Proceedings of the Workshop on Computation of Symbolic Languages for Parallel Computers. </booktitle> <institution> Argonne National Laboratory, </institution> <month> October </month> <year> 1991. </year> <title> ANL-91/34. 28 REFERENCES REFERENCES </title>
Reference-contexts: For example, it has been determined that i is a function of three active call expressions: 391, 514 and 523. (The counts associated with inactive call expressions are known to be zero, and therefore cannot contribute to the value of i.) This view is described in <ref> [Har91] </ref>. 6 A Domain of Truth As we saw above, Miprac attempts to interpret integers as functions of time, where time is measured by a procedure string. Let i 2 I, and let p 2 P be the current procedure string.
Reference: [HN90] <author> L. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <month> January </month> <year> 1990. </year>
Reference-contexts: The second aspect of dependence testing in the presense of pointers is to determine relationships between pointers (locations) and the objects they point to <ref> [LR91, HN90, CWZ90, LH88, Gua87, JM82] </ref>. This is typically an analysis of their connectivity by means of a graph that approximates their structure [CWZ90, JM82], or by enumeration of the possibly aliased paths in memory [HN90, Deu92, LR91, Gua87]. <p> This is typically an analysis of their connectivity by means of a graph that approximates their structure [CWZ90, JM82], or by enumeration of the possibly aliased paths in memory <ref> [HN90, Deu92, LR91, Gua87] </ref>. We have chosen a store-based method that we will illustrate briefly below. <p> The third aspect is the dependence test itself, which must relate accesses which we suspect are dependent upon one another, to the structure (connectivity) of the objects they are accessing, and to the control-flow of the procedures in which the accesses take place <ref> [HPR89, HN90, Bod, LH88, Rey78] </ref>. <p> It turns out that there is a simple theorem that pertains to the procedure strings that label the edges of such a graph, that can be used to prove the absence of cycles and sharing in the data structure it summarizes. This is quite similar to results obtained in <ref> [LR91, HN90, CWZ90, Bod, JM82] </ref> (or straightforward extensions of those methods). Our approach has both advantages and disadvantages compared to those methods. <p> It handles cyclic structures, back pointers, mutual recursion and mixed structure types naturally. On the other hand, it does not behave as well as the method of <ref> [HN90] </ref> when local modifications are made to a tree, especially if many control movements occur between construction of the tree and subsequent modification of its links.
Reference: [HPR89] <author> Susan Horowitz, Phil Pfeiffer, and Thomas Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the ACM SIGPLAN 1989 Symposium on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: The third aspect is the dependence test itself, which must relate accesses which we suspect are dependent upon one another, to the structure (connectivity) of the objects they are accessing, and to the control-flow of the procedures in which the accesses take place <ref> [HPR89, HN90, Bod, LH88, Rey78] </ref>.
Reference: [JM82] <author> N. D. Jones and S. S. Muchnick. </author> <title> A flexible approach to interproce-dural data flow analysis of programs with recursive data structures. </title> <booktitle> In Conference Record of the Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: The second aspect of dependence testing in the presense of pointers is to determine relationships between pointers (locations) and the objects they point to <ref> [LR91, HN90, CWZ90, LH88, Gua87, JM82] </ref>. This is typically an analysis of their connectivity by means of a graph that approximates their structure [CWZ90, JM82], or by enumeration of the possibly aliased paths in memory [HN90, Deu92, LR91, Gua87]. <p> The second aspect of dependence testing in the presense of pointers is to determine relationships between pointers (locations) and the objects they point to [LR91, HN90, CWZ90, LH88, Gua87, JM82]. This is typically an analysis of their connectivity by means of a graph that approximates their structure <ref> [CWZ90, JM82] </ref>, or by enumeration of the possibly aliased paths in memory [HN90, Deu92, LR91, Gua87]. We have chosen a store-based method that we will illustrate briefly below. <p> It turns out that there is a simple theorem that pertains to the procedure strings that label the edges of such a graph, that can be used to prove the absence of cycles and sharing in the data structure it summarizes. This is quite similar to results obtained in <ref> [LR91, HN90, CWZ90, Bod, JM82] </ref> (or straightforward extensions of those methods). Our approach has both advantages and disadvantages compared to those methods.
Reference: [KDLS87] <author> David Kuck, Edward Davidson, Duncan Lawrie, and Ahmed Sameh. </author> <title> Parallel supercomputing today and the cedar approach. </title> <editor> In J. J. Dongarra, editor, </editor> <booktitle> Experimental Parallel Computing Architectures, </booktitle> <pages> pages 1-20. </pages> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <address> New York, NY, </address> <year> 1987. </year>
Reference-contexts: 1 The Philosophy of Miprac Miprac is an experimental parallelizer for C, Lisp and Fortran. It accepts a sequential program, or a program with user-specified concurrency, in one of these languages, and produces a parallel object code for a shared-memory multiprocessor. At present the compiler is targeted to Cedar <ref> [KDLS87] </ref>, the 32-processor machine built at CSRD. Miprac makes use of a simple intermediate form called MIL.
Reference: [LD88] <author> J.M. Lucasses and D.K.Gifford. </author> <title> Polymorphic effect systems. </title> <booktitle> Proceedings 15th POPL, </booktitle> <pages> pages 47-57, </pages> <year> 1988. </year>
Reference-contexts: In our opinion, dependence testing in the presense of pointers has three aspects. The first is a global assessment of the side-effects of procedures and expressions <ref> [Har89, Nei88, LD88, GJLS87, Ban79, Rey78] </ref>. This is necessary to restrict the visibility of effects upon data that lives for only part of a computation (and this is most data in the case of many Lisp, C and C++ programs).
Reference: [LH88] <author> J.R. Larus and P.N. Hilfunger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the Sigplan'88 Conference on Programming Language Desing and Implementation, </booktitle> <pages> pages 21-34, </pages> <year> 1988. </year>
Reference-contexts: The second aspect of dependence testing in the presense of pointers is to determine relationships between pointers (locations) and the objects they point to <ref> [LR91, HN90, CWZ90, LH88, Gua87, JM82] </ref>. This is typically an analysis of their connectivity by means of a graph that approximates their structure [CWZ90, JM82], or by enumeration of the possibly aliased paths in memory [HN90, Deu92, LR91, Gua87]. <p> The third aspect is the dependence test itself, which must relate accesses which we suspect are dependent upon one another, to the structure (connectivity) of the objects they are accessing, and to the control-flow of the procedures in which the accesses take place <ref> [HPR89, HN90, Bod, LH88, Rey78] </ref>.
Reference: [LH92] <author> A. Nicolau L.J. Hendren, J. Hummel. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and transformations of imperative programs. </title> <booktitle> In ACM Sigplan Conference on Programming Language Design and Implementation, </booktitle> <year> 1992. </year>
Reference-contexts: If these subcompu-tations are procedure calls, this can be an enormous number of pairs of memory accesses. An aggressive side-effect analysis greatly reduces the number of individual access that must be considered (by circumscribing the visibility of those accesses.) The propagation of side-effects is sometimes controlled by language restrictions <ref> [LH92] </ref>, or by language extensions [GJLS87], but when treating C and Lisp programs in their generality these solutions are not applicable. <p> Its disadvantage is that it fails if either the creation or traversal of a data structure does not have simple, periodic structure. Annotated type declarations, like those in in <ref> [LH92] </ref>, can perhaps be used to restrict the procedure strings that label the pointers in Figure 12, so that they do not degrade under complex modification of the data structure; this would strengthen the method considerably. 11 The Parallelized Result In Miprac we have employed a very simple sequence of program
Reference: [LR91] <author> W. Landi and B.G. Ryder. </author> <title> A safe approximate algorithm for inter-procedural pointer aliasing. </title> <type> Technical Report LCSR-TR-168, </type> <institution> Laboratory for Computer Science Research, Rutgers University, </institution> <month> Septem-ber </month> <year> 1991. </year>
Reference-contexts: The second aspect of dependence testing in the presense of pointers is to determine relationships between pointers (locations) and the objects they point to <ref> [LR91, HN90, CWZ90, LH88, Gua87, JM82] </ref>. This is typically an analysis of their connectivity by means of a graph that approximates their structure [CWZ90, JM82], or by enumeration of the possibly aliased paths in memory [HN90, Deu92, LR91, Gua87]. <p> This is typically an analysis of their connectivity by means of a graph that approximates their structure [CWZ90, JM82], or by enumeration of the possibly aliased paths in memory <ref> [HN90, Deu92, LR91, Gua87] </ref>. We have chosen a store-based method that we will illustrate briefly below. <p> It turns out that there is a simple theorem that pertains to the procedure strings that label the edges of such a graph, that can be used to prove the absence of cycles and sharing in the data structure it summarizes. This is quite similar to results obtained in <ref> [LR91, HN90, CWZ90, Bod, JM82] </ref> (or straightforward extensions of those methods). Our approach has both advantages and disadvantages compared to those methods.
Reference: [Nei88] <author> A. Neirynck. </author> <title> Static Analysis of Aliasing and Side Effects in Higher-Order Languages. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> January </month> <year> 1988. </year>
Reference-contexts: In our opinion, dependence testing in the presense of pointers has three aspects. The first is a global assessment of the side-effects of procedures and expressions <ref> [Har89, Nei88, LD88, GJLS87, Ban79, Rey78] </ref>. This is necessary to restrict the visibility of effects upon data that lives for only part of a computation (and this is most data in the case of many Lisp, C and C++ programs).
Reference: [PGH + 89] <author> C.D. Polychronopoulos, M. Girkar, M.R. Haghighat, C.L. Lee, B. Le-ung, and D. Schouten. </author> <title> Parafrase-2: An environment for paralleliz-ing, partitioning, synchronizing, and scheduling programs on multiprocessors. </title> <booktitle> In Proceedings of the 1989 International Conference on Parallel Processing, </booktitle> <month> August </month> <year> 1989. </year> <title> 29 REFERENCES REFERENCES </title>
Reference-contexts: There is an interesting comparison to be made between Miprac and other compilers that accept several input languages. Our approach is closer to that of the GNU C compiler (gcc), which operates upon a machine-oriented register transfer language, than that of Parafrase-2 <ref> [PGH + 89] </ref>, which operates upon an abstract syntax tree of Fortran and C programs. MIL was designed to allow Miprac to treat programming language constructs that are difficult for other parallelizers to handle.
Reference: [PW86] <author> D.A. Padua and M. J. Wolfe. </author> <title> Advanced compiler optimizations for supercomputers. </title> <journal> Communications of the ACM, </journal> <volume> 29(12), </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: It localizes scalar variables according to interprocedural definitions and uses. Finally, it inserts two-way cobegin expressions to express concurrency. We are not advocating this as a method of parallelization; a more powerful suite of transformations, like those in <ref> [PW86] </ref> and [Har89] would be preferable, but the emphasis in Miprac is upon interprocedural analysis, and the construction of a complete compiler, from parsers to code generator. In this figure, the program listing is shown, but the only expressions displayed are procedure, call, and cobegin.
Reference: [Rey78] <author> J. C. Reynolds. </author> <title> Syntactic control of interference. </title> <booktitle> In 5th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1978. </year>
Reference-contexts: In our opinion, dependence testing in the presense of pointers has three aspects. The first is a global assessment of the side-effects of procedures and expressions <ref> [Har89, Nei88, LD88, GJLS87, Ban79, Rey78] </ref>. This is necessary to restrict the visibility of effects upon data that lives for only part of a computation (and this is most data in the case of many Lisp, C and C++ programs). <p> The third aspect is the dependence test itself, which must relate accesses which we suspect are dependent upon one another, to the structure (connectivity) of the objects they are accessing, and to the control-flow of the procedures in which the accesses take place <ref> [HPR89, HN90, Bod, LH88, Rey78] </ref>.
Reference: [Sch82] <author> R.B. Schnabel. </author> <title> Determining feasibility of a set of nonlinear inequality constraints. </title> <booktitle> In Mathematical Programming Study 16, </booktitle> <pages> pages 137-146. </pages> <publisher> North-Holland Publishing Company, </publisher> <year> 1982. </year> <month> 30 </month>
Reference-contexts: The various constraints that must hold in the case of a dependence form a system of inequalities whose feasibility is decided by linear or nonlinear programming. (It turns out that this particular dependence is broken by a nonlinear programming technique like that in <ref> [Sch82] </ref>.) 8 Pointers and Dependences: Some Opinions So far this paper has been concerned with integers and subscript expressions and iteration spaces, the stuff of conventional parallelization (of Fortran). However, in C, Lisp and Scheme programs we encounter dynamically allocated objects and pointers to them.
References-found: 23

