URL: http://www.cs.purdue.edu/Renaissance/LF-performance.ps
Refering-URL: http://www.cs.purdue.edu/Renaissance/
Root-URL: http://www.cs.purdue.edu
Email: fmuckel|russog@cs.purdue.edu  
Title: The Performance of a Distributed System Using Structural-Based Conformance Checking  
Author: Patrick A. Muckelbauer and Vincent F. Russo 
Address: West Lafayette, IN 47907  
Affiliation: Department of Computer Sciences Purdue University  
Abstract: This paper illustrates the design and implementation of an object-oriented distributed system framework in which the interactions between clients and servers are implemented as method invocations on objects in separate domains (autonomous collections of objects). While this approach has been adopted by a number of other efforts including OMG's CORBA, Microsoft's OLE-II, IBM's SOM/DSOM and Sun's Spring System, our work differs in a substantial way: the structure of interfaces is used for conformance checking rather than interface names (or hierarchies of names). This paper illustrates the design of our system and details the impact structural-based conformance has on the implementation and performance of a distributed object system.
Abstract-found: 1
Intro-found: 1
Reference: [AC93] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping Recursive Types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(4) </volume> <pages> 575-631, </pages> <year> 1993. </year>
Reference-contexts: Complete common subgraph elimination is possible by canonicalizing and minimizing type graphs. This is polynomial in time and can be done off-line <ref> [AC93, AHU74] </ref>. Canonicalization eliminates all remaining common subgraphs of the type graphs within a single domain (this only works on a per domain basis). <p> This implies that an algorithm implementing the conformance rules is undecidable (i.e., may fail to terminate for recursive types). However, a decidable algorithm for these conformance rules does exit and is described in Section 4. A detailed discussion of a similar structural-based conformance algorithm can also be found in <ref> [AC93] </ref>.
Reference: [AHU74] <author> Alfred Aho, John Hopcroft, and Jeffrey Ullman. </author> <title> The Design and Analysis of Computer Algorithms, </title> <booktitle> chapter 4, </booktitle> <pages> pages 157-162. </pages> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1974. </year>
Reference-contexts: Complete common subgraph elimination is possible by canonicalizing and minimizing type graphs. This is polynomial in time and can be done off-line <ref> [AC93, AHU74] </ref>. Canonicalization eliminates all remaining common subgraphs of the type graphs within a single domain (this only works on a per domain basis).
Reference: [Ber93] <author> Edward V. Berard. </author> <booktitle> Essays on Object-Oriented Software Engineering, </booktitle> <volume> volume 1. </volume> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Object-oriented programming increases program modularity and data abstraction by supporting encapsulation through narrow, rigidly defined and strongly enforced interfaces to objects <ref> [Ber93] </ref>. An object consists of an encapsulated state and a set of operations, or methods, that modify or access the state. The interface of an object is defined by the collection of all its methods.
Reference: [BR94] <author> Gerald Baumgartner and Vincent F. Russo. </author> <title> "Implementing Signatures for C++". </title> <booktitle> In Proceedings of the USENIX C ++ Conference, </booktitle> <year> 1994. </year>
Reference-contexts: A C ++ translator for Lingua Franca has been built which maps Lingua Franca type descriptions into C ++ types. C ++ was chosen due to its availability and our previous work on integrating the signature concept into the language <ref> [GR91, BR94] </ref>. A mapping to JAVA [GM95] is underway. The transport modules used to perform cross-domain messaging are modular and based upon the domain of the client and server. Communication protocols have been designed and built to support machine independent, cross-domain method invocations using shared memory and UDP/IP packet transport.
Reference: [Car85] <author> Luca Cardelli. </author> <title> Amber, </title> <booktitle> Combintors and Functional Programming Languages. In Proceedings of the 13th Summer School of the LITP, </booktitle> <address> Le Val D'Ajol, Vosges (France), </address> <month> May </month> <year> 1985. </year> <booktitle> Lecture notes in computer science, </booktitle> <volume> vol. 242, </volume> <month> Spring-Verlag. </month>
Reference-contexts: An alternate approach is to use the inheritance relationship established by an interface hierarchy to define conformance. For example, many object-oriented languages use subclassing to define subtyping. While structural subtyping has been used in several distributed and non-distributed program 3 ming languages such as Amber <ref> [Car85] </ref>, Emerald [JLHB87] and Obliq [Car94], such systems restrict the programmer to a single implementation language for building interoperating modules. The key contributing feature of our work is the extension of structural subtyping to multilingual, heterogeneous distributed systems.
Reference: [Car94] <author> Luca Cardelli. Obliq: </author> <title> A Lightweight Language for Network Objects. </title> <type> Technical report, </type> <note> DEC SRC, 1994. Available via anonymous ftp from gatekeeper.pa.dec.com as pub/DEC/Modula-3-contrib/Obliq.ps. </note>
Reference-contexts: For example, many object-oriented languages use subclassing to define subtyping. While structural subtyping has been used in several distributed and non-distributed program 3 ming languages such as Amber [Car85], Emerald [JLHB87] and Obliq <ref> [Car94] </ref>, such systems restrict the programmer to a single implementation language for building interoperating modules. The key contributing feature of our work is the extension of structural subtyping to multilingual, heterogeneous distributed systems.
Reference: [Coh91] <author> Norman Cohen. </author> <title> Type-Extension Type Tests Can Be Performed In Constant Time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 626-629, </pages> <year> 1991. </year>
Reference-contexts: The increased coupling in inheritance-based systems, however, leads to an increase in performance and allows them to be inherently more efficient than structural-based systems. In particular, 10 Assuming single inheritance, a complexity of O ( 1 ) for the algorithm is obtainable and is described in <ref> [Coh91] </ref>. 26 the runtime representation of types and the conformance algorithm for comparing them is less com-plex in inheritance-based systems. Consequently, we expect the cost of distributed conformance checking in most inheritance-based systems to be less than in structural-based systems.
Reference: [GJM91] <author> Carlo Ghezze, Mehdi Jazayeri, and Dino Mandrioli. </author> <title> Fundamentals of Software Engineering. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: For example, methods can be added to the interface of an object without breaking compatibility with its clients. This reduces interface dependencies and again lowers client/server coupling. While the modularity and encapsulation provided by the object-oriented model <ref> [GJM91] </ref> would seem to be ideal for distributed systems, object-oriented mechanisms are usually only accessible and enforced through programming language support. Relying on programming language support would severely limit the degree to which disjoint, unrelated components can interact in a multilingual, loosely coupled distributed system.
Reference: [GM95] <author> James Gosling and Henry McGilton. </author> <title> The JAVA Language Environment: A White Paper. </title> <type> Technical report, </type> <institution> Sun Microsystems, </institution> <year> 1995. </year> <note> Available from http://www.javasoft.com/whitePaper. </note>
Reference-contexts: A C ++ translator for Lingua Franca has been built which maps Lingua Franca type descriptions into C ++ types. C ++ was chosen due to its availability and our previous work on integrating the signature concept into the language [GR91, BR94]. A mapping to JAVA <ref> [GM95] </ref> is underway. The transport modules used to perform cross-domain messaging are modular and based upon the domain of the client and server. Communication protocols have been designed and built to support machine independent, cross-domain method invocations using shared memory and UDP/IP packet transport.
Reference: [GR91] <author> Elana D. Granston and Vincent F. Russo. </author> <title> "Signature-Based Polymorphism for C++". </title> <booktitle> In Proceedings of the USENIX C ++ Conference, </booktitle> <year> 1991. </year>
Reference-contexts: A C ++ translator for Lingua Franca has been built which maps Lingua Franca type descriptions into C ++ types. C ++ was chosen due to its availability and our previous work on integrating the signature concept into the language <ref> [GR91, BR94] </ref>. A mapping to JAVA [GM95] is underway. The transport modules used to perform cross-domain messaging are modular and based upon the domain of the client and server. Communication protocols have been designed and built to support machine independent, cross-domain method invocations using shared memory and UDP/IP packet transport.
Reference: [HPM93] <author> G. Hamilton, M. Powell, and J. Mitchell. Subcontract: </author> <title> A Flexible Base for Distributed Programming. </title> <booktitle> In Proceedings of the ACM Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: The generated language specific modules are used by programmers to implement server objects (usually by inheriting from automatically generated parent classes) and/or to generate typed references to remote objects via proxy objects [Sha86]. While this approach has been adopted by a number of other efforts including Sun's Spring System <ref> [HPM93] </ref>, OMG's CORBA [OMG91], IBM's SOM/DSOM [IBM93] and Microsoft's OLE-II [Mic94] our work differs in one substantial way: the structure of interfaces is used for conformance checking rather than interface names (or hierarchies of names).
Reference: [IBM93] <institution> IBM. </institution> <note> SOMobjects Developer Toolkit Users Guide Version 2.0, </note> <year> 1993. </year>
Reference-contexts: While this approach has been adopted by a number of other efforts including Sun's Spring System [HPM93], OMG's CORBA [OMG91], IBM's SOM/DSOM <ref> [IBM93] </ref> and Microsoft's OLE-II [Mic94] our work differs in one substantial way: the structure of interfaces is used for conformance checking rather than interface names (or hierarchies of names).
Reference: [JLHB87] <author> Eric Jul, Henry Levy, Norman Hutchinson, and Andrew Black. </author> <title> Fine-Grained Mobility in the Emerald System. </title> <booktitle> In Proceedings of the ACM Symposium on Operating System Principles, </booktitle> <pages> pages 62-74, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: An alternate approach is to use the inheritance relationship established by an interface hierarchy to define conformance. For example, many object-oriented languages use subclassing to define subtyping. While structural subtyping has been used in several distributed and non-distributed program 3 ming languages such as Amber [Car85], Emerald <ref> [JLHB87] </ref> and Obliq [Car94], such systems restrict the programmer to a single implementation language for building interoperating modules. The key contributing feature of our work is the extension of structural subtyping to multilingual, heterogeneous distributed systems.
Reference: [JR86] <author> Michael B. Jones and Richard F. Rashid. </author> <title> Mach and Matchmaker: Kernel and Language Support for Object-Oriented Distributed Systems. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 67-86, </pages> <year> 1986. </year> <month> 29 </month>
Reference-contexts: Relying on programming language support would severely limit the degree to which disjoint, unrelated components can interact in a multilingual, loosely coupled distributed system. We adopt the solution of using a high-level interface description language (IDL) <ref> [JR86] </ref> to address the language dependency problem. An IDL provides a mechanism for specifying an object's interface independent of any programming language. A translator maps these specifications into a target language's notion of objects and interfaces.
Reference: [MGH + 94] <author> James Mitchell, Jonathan Gibbons, Graham Hamilton, Peter Kessler, Yousef Khalidi, Panos Kougiouris, Peter Madany, Michael Nelson, Michael Powell, and Sanjay Radia. </author> <title> An Overview of the Spring System. </title> <booktitle> In Proceedings of Compcon Spring 1994, </booktitle> <month> February </month> <year> 1994. </year>
Reference-contexts: Consequently, the measured results should be consistent with the expected-case complexity of the conformance algorithm. The types used in the experiment are interface types taken from the Renaissance and Spring <ref> [MGH + 94] </ref> Systems. Spring is a CORBA-based object-oriented distributed system where conformance is based on names of interfaces an not structure [MGH + 94][OMG91]. The Spring System was used solely as a source for additional interface types that occur in actual systems. <p> The types used in the experiment are interface types taken from the Renaissance and Spring <ref> [MGH + 94] </ref> Systems. Spring is a CORBA-based object-oriented distributed system where conformance is based on names of interfaces an not structure [MGH + 94][OMG91]. The Spring System was used solely as a source for additional interface types that occur in actual systems. These types were re-written in Lingua Franca for experimentation purposes and no Spring code was used.
Reference: [Mic94] <author> Microsoft Corporation. </author> <title> OLE2 Programmer's Reference, volume 2. </title> <publisher> Microsoft Press, </publisher> <year> 1994. </year>
Reference-contexts: While this approach has been adopted by a number of other efforts including Sun's Spring System [HPM93], OMG's CORBA [OMG91], IBM's SOM/DSOM [IBM93] and Microsoft's OLE-II <ref> [Mic94] </ref> our work differs in one substantial way: the structure of interfaces is used for conformance checking rather than interface names (or hierarchies of names). We argue in [Muc96] that this choice is superior both theoretically and practically and leads to reduced coupling in object-oriented distributed systems.
Reference: [Muc96] <author> Patrick A. Muckelbauer. </author> <title> Structural Subtyping in a Distributed Object System. </title> <type> PhD thesis, </type> <institution> Department of Computer Sciences, Purdue University, </institution> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: We argue in <ref> [Muc96] </ref> that this choice is superior both theoretically and practically and leads to reduced coupling in object-oriented distributed systems. In this paper, we detail the design and implementation of our structural-based distributed object system. <p> The major tools used to support this are the Lingua Franca type system (described in <ref> [Muc96] </ref>) for describing types and a set of libraries to provide conformance checking and inter-domain method invocations between domains described with Lingua Franca programs. <p> In <ref> [Muc96] </ref> we argue that this leads to reduced coupling in distributed systems. 3.1.1 Simple Example The small code fragment detailed below is a sample Lingua Franca program that describes a set of interfaces for a simple file system. The program defines two interfaces: FileServer and File. <p> This, in turn, makes these systems more difficult to manage than structural-based systems <ref> [Muc96] </ref>. The increased coupling in inheritance-based systems, however, leads to an increase in performance and allows them to be inherently more efficient than structural-based systems. <p> In <ref> [Muc96] </ref> we argue that the choice of structural subtyping over inheritance subtyping is superior both theoretically and practically and leads to less coupled systems. Unfortunately, the decrease in coupling and it benefits are tempered by a potential decrease in system performance. <p> This paper helps illustrate why the decrease in performance is expected to be marginal and worth the gain in flexibility. 10.1 Current Status The design and specification of Lingua Franca is complete and is described in <ref> [Muc96] </ref>. A C ++ translator for Lingua Franca has been built which maps Lingua Franca type descriptions into C ++ types. C ++ was chosen due to its availability and our previous work on integrating the signature concept into the language [GR91, BR94]. A mapping to JAVA [GM95] is underway.
Reference: [OMG91] <author> OMG. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <year> 1991. </year>
Reference-contexts: The interface of an object is defined by the collection of all its methods. The only way to modify or access an object's state is to invoke a method in the object's interface. In distributed object-oriented systems <ref> [OMG91] </ref> clients access servers by invoking methods on objects in a server's domain via remote references. Domains are self-contained and usually implemented in a single programming language (or at least a single consistent object model). Domains are independent address spaces and can be executing on different machines. <p> While this approach has been adopted by a number of other efforts including Sun's Spring System [HPM93], OMG's CORBA <ref> [OMG91] </ref>, IBM's SOM/DSOM [IBM93] and Microsoft's OLE-II [Mic94] our work differs in one substantial way: the structure of interfaces is used for conformance checking rather than interface names (or hierarchies of names).
Reference: [Sha86] <author> Marc Shapiro. </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <booktitle> In Proceedings of the 6th. International Conference on Distributed Computer Systems, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: A translator maps these specifications into a target language's notion of objects and interfaces. The generated language specific modules are used by programmers to implement server objects (usually by inheriting from automatically generated parent classes) and/or to generate typed references to remote objects via proxy objects <ref> [Sha86] </ref>.
Reference: [Sun85] <author> Sun Microsystems. </author> <title> Networking on the SUN Workstation, </title> <booktitle> 1985. </booktitle> <pages> 30 </pages>
Reference-contexts: For example, in many simple remote procedure call (RPC) systems, types are numbers where each number represents a well defined and agreed upon set of procedures <ref> [Sun85] </ref>. Conformance checking is simply a matter of testing whether a server's exported number equals the number expected by a client. 2.1.1 Conformance Rules for a Distributed Object-Oriented System The conformance rules used by object-oriented programming languages are based on subtyping.
References-found: 20

