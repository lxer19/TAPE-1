URL: http://www.cis.ohio-state.edu/~neelam/papers/synch.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~neelam/papers/research.html
Root-URL: 
Email: e-mail: neelam@cis.ohio-state.edu  
Title: Covariance, Contravariance, and Synchronization Constraints  
Author: Neelam Soundarajan 
Address: Columbus, OH 43210 USA  
Affiliation: Computer and Information Science The Ohio State University  
Abstract: Object Orientation and concurrent progamming are a natural match. Objects correspond to processes in a concurrent program; a message from one object to another invoking a method of the latter, corresponds naturally to (message passing) interaction between processes in a concurrent program. Despite this close correspondence, progress in developing an OO approach to concurrency has been limited. One important problem has been the so-called inheritance anomaly which is concerned with how and how easily synchronization constraints specified in a base class may be modified in a derived class. Our concern in the current paper is more basic. We address the question of what types of modifications in the synchronization constraints inherited from the base class ought to be permitted to be made in the derived class. We identify the modifications that are reasonable, especially when the problem is viewed from the point of view of a client of the class. We point out that when viewed from this perspective, some of the current proposals for expressing synchronization constraints allow precisely the wrong types of modifications to be made in the derived classes. We also analyze the relation between this question and the problems that inheritance encounters already in the sequential case, such as the covariance versus contravariance conflict. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Aksit, J. Booch, W. Sterren, L. Bergmans, </author> <title> Real-time specification inheritance anomalies and real-time filters, </title> <booktitle> in Proceedings of ECOOP '94, </booktitle> <year> 1994. </year>
Reference: 2. <author> P. America, F. van Linden, </author> <title> A parallel OO language, </title> <booktitle> Proceedings of OOPSLA '90, </booktitle> <year> 1990. </year>
Reference: 3. <author> L. Cardelli, </author> <title> A semantics of multiple inheritance, </title> <journal> Inf. Comput., </journal> <volume> 76, </volume> <pages> 138-164, </pages> <year> 1988. </year>
Reference-contexts: It is because of such problems that authors like Cardelli <ref> [3] </ref> have required con-travariance: when we override the eq function defined in the base class by a new defintion in the derived class, we are not allowed to restrict the domain of the (explicit) arguments of the function.
Reference: 4. <author> G. Castagna, </author> <title> Covariance and contravariance, </title> <journal> ACM TOPLAS, </journal> <volume> 17, </volume> <pages> 431-447, </pages> <year> 1995. </year>
Reference-contexts: It will become the responsibility of the client program to avoid this problem. (Eiffel tries to provide some warnings on the basis of link-time analysis, when there is a possibility of such situations arising.) A very general analysis of the contravariant versus covariance conflict is given by Castagna <ref> [4] </ref>. His conclusion essentially is that covariance is ok on arguments on which we do dynamic dispatch, but on others we must use contravariance. This, of course, disagrees with Meyer's approach. Thus in the Point example, following the analysis in [4], we would have to define the eq function in ColoredPt <p> of the contravariant versus covariance conflict is given by Castagna <ref> [4] </ref>. His conclusion essentially is that covariance is ok on arguments on which we do dynamic dispatch, but on others we must use contravariance. This, of course, disagrees with Meyer's approach. Thus in the Point example, following the analysis in [4], we would have to define the eq function in ColoredPt to receive a second argument of type Point, not ColoredPt, since no dynamic dispatching is being done on this argument. <p> Indeed, for standard OO languages like C++, since dynamic dispatch is done only on the first argument, the analysis in <ref> [4] </ref> doesn't contribute anything new to what has been said in earlier papers requiring contravariance. There is one possible way to stay with covariance without running the risk of run-time errors.
Reference: 5. <author> C. Chambers, </author> <title> OO multi-methods in Cecil, </title> <booktitle> Proceedings of ECOOP '92. </booktitle>
Reference-contexts: In more complex systems, we would clearly need to be able to deal with conditions relating two or more objects, possibly instances of different classes. There has been some work in studying the question of multi-object coordination (see for example <ref> [5, 8] </ref>). Here again the question of what kinds of changes in these conditions ought to be allowed in derived classes needs to be analyzed. As may be expected, this will be a far more difficult question than the one we have considered.
Reference: 6. <author> M. Dodani, C. Tsai, </author> <title> ACTS: a type system for OOP, </title> <booktitle> Proceedings of ECOOP '92. </booktitle>
Reference-contexts: This approach seems to work at least for simple examples but we won't pursue the idea further in this paper. Another attempt at trying to retain covariance in a limited situation (but still avoiding run-time errors) is that of Dodani and Tsai <ref> [6] </ref>. Their idea was to allow covariance when inheriting from an abstract base class but not when inheriting from a concrete base class. The hope was that since the client cannot construct an instance of an abstract class, the problem would not arise.
Reference: 7. <author> S. Frolund, </author> <title> Inheritance of synchronization constraints, </title> <booktitle> Proceedings of ECOOP '92. </booktitle>
Reference-contexts: This is the problem that was dubbed the inheritance anomaly by Matsuoka and Yonezawa [14] who perfomed a thorough analysis of this problem. A natural solution to the problem, and this has been suggested by several authors such as Frolund <ref> [7] </ref>, would be to introduce notation that will allow us separate the synchronization constraints from the bodies of the operations. We will use one of these notations later in the paper. <p> We are interested not in how synchronization constraints ought to be modified in derived classes but what sorts of modifications are reasonable. As we will see in section 3, our analysis shows that while they go part way to solving the inheritance anomaly problem, approaches like that of <ref> [7] </ref> do not help with this question. Indeed they allow the wrong type of changes to be made in derived classes to synchronization constraints inherited from the base classes. It turns out that the problem we analyze bears considerable similarity to the problem of covariance versus contravariance in sequential OOP. <p> So in the next section we review that problem and the solutions that have been proposed. In the third section we consider synchronization issues and discuss the problem with synchronization constraints of the kind used by <ref> [7] </ref> and compare this problem with the co-variance / contravariance question. We then propose some possible solutions to the problem and analyze the implications. We do not propose any new liguistic constructs that will ensure that synchronization constraints are only modified in ways we deem appropriate. <p> We will see in the next section that the problem with synchronization constraints of the kind proposed in <ref> [7] </ref> is also semantic. 3 Redefining synchronization constraints, or When is a bounded buffer not one? Let us start with an example from Frolund [7]. Consider a standard bounded-buffer class of size MAX that provides the usual put and get operations. <p> We will see in the next section that the problem with synchronization constraints of the kind proposed in <ref> [7] </ref> is also semantic. 3 Redefining synchronization constraints, or When is a bounded buffer not one? Let us start with an example from Frolund [7]. Consider a standard bounded-buffer class of size MAX that provides the usual put and get operations. The synchronization constraints for this class expressed in the notation of [7] are: ( size MAX ) prevents put ( size 0 ) prevents get This ensures that the put operation is not executed <p> also semantic. 3 Redefining synchronization constraints, or When is a bounded buffer not one? Let us start with an example from Frolund <ref> [7] </ref>. Consider a standard bounded-buffer class of size MAX that provides the usual put and get operations. The synchronization constraints for this class expressed in the notation of [7] are: ( size MAX ) prevents put ( size 0 ) prevents get This ensures that the put operation is not executed when there is no space in the buffer and the get operation is not executed when the buffer is empty. <p> The corresponding synchronization constraint would be ( size 2flMAX ) prevents put But we cannot define bigger-buffer as a derived class of bounded-buffer in the formalism of <ref> [7] </ref> because the synchronization constraint of the latter class preventing the application of put if the buffer already has size elements would be inherited and would prevent the client of bigger-buffer from using the bigger-buffer object to store more than MAX elements. So in the formalism of [7] there would be <p> the formalism of <ref> [7] </ref> because the synchronization constraint of the latter class preventing the application of put if the buffer already has size elements would be inherited and would prevent the client of bigger-buffer from using the bigger-buffer object to store more than MAX elements. So in the formalism of [7] there would be no reasonable way to define bigger-buffer by inheriting from bounded-buffer. But clearly, any user program that works properly when using an instance of bounded-buffer class will work equally well if we were to substitute an instance of bigger-buffer. <p> In other words, an instance of bigger-buffer is-an instance of bounded-buffer, so the former class should be definable as a derived class of the latter. In fact, if we are allowed to strengthen synchronization constraints in the derived classes, as in systems like <ref> [7] </ref>, we will be able to define a class smaller-buffer as a derived class of bounded-buffer: ( size MAXffi2 ) prevents put This suggests that a smaller-buffer object is also a bounded-buffer object. <p> Before we proceed to look at possible solutions, we should mention that other proposals than <ref> [7] </ref> have the same problem. Consider, for instance, the system of Lopes and Lieberherr [12]. <p> The central argument of [12] is that an important source of difficulties in concurrent OOP, in particular of the inheritance anomaly, is that code that ensures the synchronization constraints is often mixed in with code for performing individual operations. While this argument is also the starting point of <ref> [7] </ref> and others, Lopes and Lieberherr propose a different solution: A class in [12] consists of a synchronization pattern and a behavioral block which essentially contains the bodies of the various methods without any synchronization code in them. ([12] also introduces a propogation pattern which doesn't need to concern us here.). <p> sequence of operations that satisfies the constraints of the base class must also satisfy the constraints of the derived class. 1 How do we ensure that this requirement is met? That depends partly on the notation that we adapt to specify the synchronization conditions: synchronization constraints of the kind in <ref> [7] </ref>, synchronization patterns as in [12], method sets as in [10], or as in [14] etc. In none of these cases though will the check be simple. <p> Frolund <ref> [7] </ref> argues that there is no need to guarantee that a client program that works correctly when it uses a base class object, will also work correctly if we replaced the base class object by a derived class object. But this guarantee, we feel, is a key requirement for inheritance. <p> But this guarantee, we feel, is a key requirement for inheritance. Without it mechanisms like dynamic dispatch will fail completely. If the argument in <ref> [7] </ref> were accepted, we would have to give 2 As an aside we note that [13] also require, in effect, that any new methods introduced in the derived classes be `explainable' in terms of applications of methods already defined in the base class.
Reference: 8. <author> S. Frolund, G. Aha, </author> <title> A language framework for multi-object coordination, </title> <booktitle> Proceedings of ECOOP '93. </booktitle>
Reference-contexts: In more complex systems, we would clearly need to be able to deal with conditions relating two or more objects, possibly instances of different classes. There has been some work in studying the question of multi-object coordination (see for example <ref> [5, 8] </ref>). Here again the question of what kinds of changes in these conditions ought to be allowed in derived classes needs to be analyzed. As may be expected, this will be a far more difficult question than the one we have considered.
Reference: 9. <author> W. Hursch, </author> <title> Should superclasses be abstract, </title> <booktitle> Proceedings of ECOOP '94. </booktitle>
Reference-contexts: In the final section we summarize the problem and our conclusions, and mention some questions that remain to be answered. 2 Covariance versus Contravariance Consider the following (classic) example taken from Hursch <ref> [9] </ref>. Suppose we have a class called Point to represent points on a 2-d plane. The instance variables of 3 the class are, of course, the x- and y-coordinates of the point. <p> Their idea was to allow covariance when inheriting from an abstract base class but not when inheriting from a concrete base class. The hope was that since the client cannot construct an instance of an abstract class, the problem would not arise. But as Hursch <ref> [9] </ref> shows 5 this doesn't always work. He constructs an example with an abstract Point class and two (concrete) derived classes ColoredPt and ThreeDPt and writes client code that results in calling the eq function of the ThreeDPt class with a second argument that is an instance of ColoredPt.
Reference: 10. <author> Y. Ishikawa, </author> <title> Communication mechanisms on autonomous objects, </title> <booktitle> Proceedings of OOPSLA '92. </booktitle>
Reference-contexts: class must also satisfy the constraints of the derived class. 1 How do we ensure that this requirement is met? That depends partly on the notation that we adapt to specify the synchronization conditions: synchronization constraints of the kind in [7], synchronization patterns as in [12], method sets as in <ref> [10] </ref>, or as in [14] etc. In none of these cases though will the check be simple.
Reference: 11. <author> D. Kafura, K. Lee, </author> <title> Inheritance in Actor based languages, </title> <booktitle> Proceedings of ECOOP '89. </booktitle>
Reference-contexts: Suppose, for instance, we use the idea of behavior abstractions of Kafura et al <ref> [11] </ref>. Then in the code of each method, such as get and put, we will find commands like `become empty', `become partial', etc. to denote the subsequent behavior of the buffer.
Reference: 12. <author> C. Lopes, K. Lieberherr, </author> <title> Abstracting process to function relations, </title> <booktitle> Proceedings of ECOOP '94. </booktitle>
Reference-contexts: Before we proceed to look at possible solutions, we should mention that other proposals than [7] have the same problem. Consider, for instance, the system of Lopes and Lieberherr <ref> [12] </ref>. The central argument of [12] is that an important source of difficulties in concurrent OOP, in particular of the inheritance anomaly, is that code that ensures the synchronization constraints is often mixed in with code for performing individual operations. <p> Before we proceed to look at possible solutions, we should mention that other proposals than [7] have the same problem. Consider, for instance, the system of Lopes and Lieberherr <ref> [12] </ref>. The central argument of [12] is that an important source of difficulties in concurrent OOP, in particular of the inheritance anomaly, is that code that ensures the synchronization constraints is often mixed in with code for performing individual operations. <p> While this argument is also the starting point of [7] and others, Lopes and Lieberherr propose a different solution: A class in <ref> [12] </ref> consists of a synchronization pattern and a behavioral block which essentially contains the bodies of the various methods without any synchronization code in them. ([12] also introduces a propogation pattern which doesn't need to concern us here.). <p> Thus these synchronization patterns are compile time entities; all that exists at at run-time is code for the methods of the various classes with synchronization code embedded. A derived class in <ref> [12] </ref> will inherit both the synchronization pattern and the behavior block of its parent class. We can then modify either or both of these as appropriate. <p> We can then modify either or both of these as appropriate. Again the compiler is responsible for compiling the derived class from the information inherited from the parent and the changes that have been made in defining the derived class. One problem with the approach of <ref> [12] </ref> is that their synchronization patterns tend to be quite complex, sometimes exceeding in size the code for all the methods of the class. More important for the problem we are considering is that [12] doesn't really impose any conditions on what changes may be made in the derived classes to <p> One problem with the approach of <ref> [12] </ref> is that their synchronization patterns tend to be quite complex, sometimes exceeding in size the code for all the methods of the class. More important for the problem we are considering is that [12] doesn't really impose any conditions on what changes may be made in the derived classes to the synchronization patterns inherited from the base class, so exactly the same problem we saw can be reproduced in this system. Let us now return to our buffer examples. <p> the constraints of the base class must also satisfy the constraints of the derived class. 1 How do we ensure that this requirement is met? That depends partly on the notation that we adapt to specify the synchronization conditions: synchronization constraints of the kind in [7], synchronization patterns as in <ref> [12] </ref>, method sets as in [10], or as in [14] etc. In none of these cases though will the check be simple.
Reference: 13. <author> B. Liskov, J. Wing, </author> <title> A new definition of the subtype relation, </title> <booktitle> Proceedings of ECOOP '93. </booktitle>
Reference-contexts: One important point has often been ignored in the debate over contra versus covariance. Even contravariance only ensures syntactic or type compatibility. As Liskov and Wing <ref> [13] </ref> point out, it does not ensure that if D is a derived class and B the base class, that objects of type D are conceptually actually objects of type B. <p> The methods defined in D could behave entirely differently from the methods that they override (while still obeying the contravariance restriction). To take care of this <ref> [13] </ref> proposes extending contravariance to include a semantic requirement. Essentially the pre-condition of the function defined in the base class would have to imply the pre-condition of the corresponding function in the derived class, and the post-condition of the latter would have to imply the post-condition of the former. <p> But this only takes care of error messages from the run-time system. To ensure that the behavior of the program is as expected by the client we must also, as Liskov and Wing <ref> [13] </ref> point out, worry about pre- and post-conditions of the methods redefined in the derived classes and show that these 10 are appropriately related to their counterparts in the base class. 2 In the concurrent case there is the added complication of synchronization conditions in the base class and what changes <p> This is exactly like the Liskov-Wing condition on pre-conditions of methods defined in derived classes and the pre-conditions of the corresponding methods in the base class. The former should not be more demanding than the latter. In general, in fact, both the requirements that <ref> [13] </ref> impose as well as the ones we have suggested are natural consequences of the basic relation between derived classes and base classes an instance of the derived class is-an instance of the base class and the user should be able to it treat as such. <p> But this guarantee, we feel, is a key requirement for inheritance. Without it mechanisms like dynamic dispatch will fail completely. If the argument in [7] were accepted, we would have to give 2 As an aside we note that <ref> [13] </ref> also require, in effect, that any new methods introduced in the derived classes be `explainable' in terms of applications of methods already defined in the base class. <p> In the concurrent case, if the same object can be used by another process concurrently then it is conceivable that the other process might indeed invoke one of these new methods. It may be interesting to see if the condition in <ref> [13] </ref> can be weakened in view of this. 11 free rein to the designer of the derived class to build arbitrary behaviors into the derived class objects. We feel such complete freedom would make it much harder for clients to use classes defined using inheritance.
Reference: 14. <author> S. Matsuoka, A. Yonezawa, </author> <title> Analysis of inheritance anomaly in concurrent OO languages, in Research directions in concurrent OO programming, </title> <editor> ed. Agha, Wegner, Yonezawa, </editor> <year> 1993. </year>
Reference-contexts: This is the problem that was dubbed the inheritance anomaly by Matsuoka and Yonezawa <ref> [14] </ref> who perfomed a thorough analysis of this problem. A natural solution to the problem, and this has been suggested by several authors such as Frolund [7], would be to introduce notation that will allow us separate the synchronization constraints from the bodies of the operations. <p> the constraints of the derived class. 1 How do we ensure that this requirement is met? That depends partly on the notation that we adapt to specify the synchronization conditions: synchronization constraints of the kind in [7], synchronization patterns as in [12], method sets as in [10], or as in <ref> [14] </ref> etc. In none of these cases though will the check be simple.
Reference: 15. <author> J. Meseguer, </author> <title> Solving the inheritance anomaly, </title> <booktitle> Proceedings of ECOOP '93. </booktitle>
Reference: 16. <author> B. Meyer, </author> <title> Object oriented software construction, </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Although some authors have criticized inheritance, others like Meyer <ref> [16] </ref> have presented persuasive arguments in its favor. One of the main reasons for the slow progress in bringing OO ideas to concurrent programming is the inheritance anomaly.
Reference: 17. <author> J. van den Bos, C. Laffra, </author> <title> PROCOL, </title> <journal> Acta Informatica, </journal> <volume> 28, </volume> <pages> 511-538, </pages> <year> 1991. </year> <month> 13 </month>
References-found: 17

