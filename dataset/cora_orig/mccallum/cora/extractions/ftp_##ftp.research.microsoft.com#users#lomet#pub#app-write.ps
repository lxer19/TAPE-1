URL: ftp://ftp.research.microsoft.com/users/lomet/pub/app-write.ps
Refering-URL: http://www.research.microsoft.com/users/lomet/
Root-URL: http://www.research.microsoft.com
Email: Email: lomet@microsoft.com  
Phone: Phone: (425)703-1853 Fax: (425)936-7329  
Title: Application Recovery Including Logical Write Operations  
Author: David Lomet 
Address: One Microsoft Way, Redmond, WA 98052  
Affiliation: Microsoft Research  
Abstract: This paper describes how a database system provides application recovery from system crashes at reduced logging cost by logging application writes as well as application reads as logical operations. A previous paper treated application reads by themselves. During recovery, a logical operation reads its input data values from objects of the database rather than from values written to the log. Hence, during normal operation, we avoid writing those values to the log, a substantial saving. This requires flushing cached objects in a specific order to ensure that input objects have the same values during recovery as when read originally. Treating both reads and writes as logical log operations can produce flush order cycles, previously requiring atomic flushing of all objects in a cycle. Our fundamental innovation is a new write graph (specifying flush order) that enables the cache manager to eliminate atomic flush sets by itself generating and logging write operations. We design a cache manager that handles the more complex flush ordering process. Finally, we optimize recovery by generalizing recovery LSNs to avoid the redo of operations whose effects are already in the recovered system. We exploit this to avoid re-execution of terminated applications when all their logical writes are installed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Gray, J. and Reuter, A. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann (1993) San Mateo, </publisher> <address> CA </address>
Reference-contexts: Even better, however, is to avoid doing anything to variables until they are exposed. For blind writes, this means doing nothing until we find the last such write to each variable. Indeed, media recovery has sometimes been performed using a log in which all earlier operations have been deleted <ref> [1] </ref>. This effectively treats all operations that write to unexposed variables as already installed, regardless of the results of the SI test. The traditional SI REDO test treats all variables as if they were exposed.
Reference: [2] <author> Lomet, D. </author> <title> Application Recovery Using Generalized Redo Recovery. </title> <booktitle> Int'l. Conf. on Data Engineering (Orlando, </booktitle> <address> FL) February, </address> <year> 1998. </year>
Reference-contexts: 1 Introduction Our purpose in this paper and its predecessor <ref> [2] </ref> is to enable applications to persist across system crashes, without the application needing to take steps to ensure its persistence. <p> Interactions with objects managed by the designated RM are logged very efficiently. Interactions with system elements external to the designated RM require that more information be logged, and hence are more costly. 1.1 The Basis in Recovery Theory Application recovery in <ref> [2] </ref> exploits the recovery framework of [3, 4], which specifies how to provide recovery when using complex log operations, not the usual page-oriented operations that write one page, and perhaps read it. <p> The installation graph orders operations more weakly than serializability. Indeed, installation order depends only on read-write conflicts and some write-write conflicts between operations. Here, as in <ref> [2] </ref>, we simplify 1 the installation graph by restricting log operations to update only single objects, dispensing with the notions of updates and redos. After a system crash, we must explain the system state in terms of which operations are installed, i.e. have their effects present in the stable state. <p> Atomically flushing all variables written by this node avoids the cyclic ordering difficulty but introduces substantial additional cost. 1.2 Application Recovery with Logical Reads In <ref> [2] </ref>, we described how to provide application recovery using logged operations and database style recovery. Application state is treated as a black box whose internal changes are not visible. Only in interactions with, e.g. an end user, a database, a file, or another process, is a state change exposed. <p> We illustrate the decomposition of an application's execution into loggable operations in Figure 1. Here we describe briefly the execute (Ex (A)) and read (R (A; O)) operations, together with the physical form of write (W P (O)). (For a description of the complete set of application operations, see <ref> [2] </ref>.) Ex (A) describes application A's state transition caused by its execution between adjacent interactions. Ex (A) reads from and writes to only A's state. <p> A write graph is required to be an acyclic graph so that the flush ordering can be realized. 2.2 Write Graph W and Its Problem W is computed in [3] as indicated in Figure 3. In <ref> [2] </ref> we showed how to dynamically compute W for the application operations described there. Consider again the example of Figure 2, where O and A need to be flushed atomically. Suppose this example were followed by a blind write W P (O). <p> Rather, updates can continue on the other variables while one of the variables is being logged for its W IP operation. 3 Cache Management Structures 3.1 Prior Environment We made two restrictions in <ref> [2] </ref> that simplified the structure of W. 1. For any operation Op, jwr (Op)j = 1. This avoids the first collapse in constructing W since wr (Op) intersects with the W r (n) of at most one node n of W . 2. <p> Then we introduce the changes that permit RW to cope with W L (A; O) operations and with nodes n with jvars (n)j &gt; 1. We wish to minimize the changes to the data structures defined in <ref> [2] </ref> to represent W, but some changes will be necessary. This earlier data structure is an enhancement to the traditional cache management page table that we call the object table. The object table is illustrated in Figure 4. <p> Many that may be named in log records will, in fact, be terminated or deleted, and hence their operations will be installed. 5 Summary Our goal has been to reduce the cost of providing application recovery. Our previous paper <ref> [2] </ref> showed how application read operations are handled as logical operations, greatly reducing the normal execution cost of logging reads. This paper has attacked the problem of reducing the cost of handling application write operations. Because of the subtleties of recovery, it has taken us over a range of subjects.
Reference: [3] <author> Lomet, D. and Tuttle, M. </author> <title> Redo recovery from system crashes. </title> <booktitle> Proc. Very Large Databases Conf.(Zurich, </booktitle> <address> Switzerland) Sept. </address> <year> 1995 </year>
Reference-contexts: Interactions with objects managed by the designated RM are logged very efficiently. Interactions with system elements external to the designated RM require that more information be logged, and hence are more costly. 1.1 The Basis in Recovery Theory Application recovery in [2] exploits the recovery framework of <ref> [3, 4] </ref>, which specifies how to provide recovery when using complex log operations, not the usual page-oriented operations that write one page, and perhaps read it. <p> There are many write graphs that are possible. For example, a single node write graph that atomically flushes all of the cache to disk is sufficient to ensure recovery (though it is rarely necessary). The write graph W of <ref> [3] </ref> is also sufficient, but often not necessary. All write graphs are computed from the subgraph of uninstalled operations of the installation graph. <p> Enforcing write graph order for flushing variables then enforces installation graph order on the operations. A write graph is required to be an acyclic graph so that the flush ordering can be realized. 2.2 Write Graph W and Its Problem W is computed in <ref> [3] </ref> as indicated in Figure 3. In [2] we showed how to dynamically compute W for the application operations described there. Consider again the example of Figure 2, where O and A need to be flushed atomically. Suppose this example were followed by a blind write W P (O). <p> Here the edge is a reverse write-read edge from the reader to the earlier writer. We continue until all operations have been processed. This replaces the transitive closure that built T and the first collapse in <ref> [3] </ref>. The second collapse can also be handled incrementally as operations are included in RW , producing an acyclic RW . A node n of RW is removed when ops (n) are installed. Removal of a node removes all its edges. <p> The installation graph imposes the precise requirement on operation installation order. From this we derive a write graph that the CM uses to order flushing and keep the system state recoverable. But the write graph W of <ref> [3] </ref> did not capture the installation requirements with sufficient precision to permit effective managing of object flushes. So we introduced a new and refined write graph RW to deal with this.
Reference: [4] <author> Lomet, D. and Tuttle, M. </author> <title> A Formal Treatment of Redo Recovery with Pragmatic Implications. </title> <institution> Cambridge Research Lab, Cambridge, </institution> <note> MA.(in preparation) </note>
Reference-contexts: Interactions with objects managed by the designated RM are logged very efficiently. Interactions with system elements external to the designated RM require that more information be logged, and hence are more costly. 1.1 The Basis in Recovery Theory Application recovery in [2] exploits the recovery framework of <ref> [3, 4] </ref>, which specifies how to provide recovery when using complex log operations, not the usual page-oriented operations that write one page, and perhaps read it.
Reference: [5] <author> Mohan, C., Haderle, D., Lindsay, B., Pirahesh, H., and Schwarz, P. </author> <title> ARIES: A transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. </title> <journal> ACM Trans. on Database Systems 17,1 (Mar. </journal> <year> 1992) </year> <month> 94-162. </month>
Reference-contexts: SI 's ARIES Definition A recovery SI (rSI ) for a variable (previously called a recovery LSN ), is an SI that indicates from what point in the log there may be updates which are, possibly, not yet in the nonvolatile storage version of the page (as defined in ARIES <ref> [5] </ref>). In ARIES, the SI s across all variables increase monotonically in update order, not just on a per variable basis.
Reference: [6] <author> Strom, R. and Yemini, S. </author> <title> Optimistic Recovery in Distributed Systems ACM Trans. </title> <booktitle> on Computer Systems 3,3 (Aug. </booktitle> <year> 1985) </year> <month> 204-226. </month>
Reference-contexts: This reduces overall cost and makes application outcomes after failures more predictable and understandable. Our work is focused on reducing the costs of the logging and checkpointing needed for application persistence. We primarily exploit application replay <ref> [6] </ref>. Application actions are logged during normal execution and are replayed as needed during recovery. This is less costly than the forced writing of application state to stable storage. Recovery itself becomes more costly now as parts of the applications are re-executed during recovery.
References-found: 6

