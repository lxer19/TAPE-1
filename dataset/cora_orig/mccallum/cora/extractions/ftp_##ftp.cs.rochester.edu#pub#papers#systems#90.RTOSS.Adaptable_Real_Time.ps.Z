URL: ftp://ftp.cs.rochester.edu/pub/papers/systems/90.RTOSS.Adaptable_Real_Time.ps.Z
Refering-URL: http://www.cs.rochester.edu/trs/systems-trs.html
Root-URL: 
Email: -leblanc,markatos-@cs.rochester.edu  
Phone: (716) 275-9491  
Title: Operating System Support for Adaptable Real-Time Systems  
Author: Thomas J. LeBlanc Evangelos P. Markatos 
Address: Rochester, New York 14627  
Affiliation: Computer Science Department University of Rochester  
Abstract: This paper outlines our plans for a real-time systems research program to support the long-term goal of developing intelligent robots. The distinguishing characteristic of our approach to real-time systems is an emphasis on system adaptability in a dynamic real-world environment. We achieve adaptability by allowing multiple real-time process models, with different known properties and timing constraints, to coexist within a single system and application. Using a hardware architecture in which a large-scale multiprocessor controls a behavioral system with vision and manipulation capabilities, we are constructing a prototype software environment that provides a predictable schedule for reflexive robot tasks and a flexible environment for implementing adaptive cognitive robot tasks. We will exploit multiple processors, user-level scheduling, and user-defined process and communication models in the construction of real-time robotics applications. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <institution> BBN Advanced Computers Inc., Inside the Butterfly Plus, </institution> <month> Oct </month> <year> 1987. </year>
Reference-contexts: The average user may be unwilling or unable to fully exploit these mechanisms; therefore, we plan to implement different policies in libraries that are linked to user programs and provide convenient high-level abstractions. Psyche is currently implemented on a 24-node BBN Butterfly Plus <ref> [1] </ref>. Our first robotics application, a balloon bouncing program called Juggler, successfully ran in November 1989. This application combines binocular camera input, a pipelined image processor, and a 6-degree-of-freedom robot arm (with a squash racquet attached) to bounce a balloon.
Reference: 2. <author> S. C. Cheng, J. A. Stankovic and K. Ramamritham, </author> <title> ``Scheduling Algorithms for Hard Real-Time Systems A Brief Survey,'' </title> <booktitle> IEEE Tutorial on Real-Time Systems, </booktitle> <year> 1988, </year> <pages> pp. 150-173. </pages>
Reference-contexts: In some cases predictions may not even be feasible, since they are often expensive to make (many real-time scheduling problems have been proven to be computationally intractable <ref> [2] </ref>) and may require information that is unavailable (for example, the computation time for a search algorithm may be unbounded) or difficult to gather (for example, the state of the external world).
Reference: 3. <author> H. Chetto and M. Chetto, </author> <title> ``Scheduling Periodic and Sporadic Tasks in a Real-Time System,'' </title> <journal> Information Processing Letters, </journal> <month> Feb </month> <year> 1989, </year> <pages> pp. 177-184. </pages>
Reference-contexts: These processes are scheduled using the earliest-deadline-first algorithm. We could model the aperiodic processes as periodic processes and use a rate-monotonic scheduler [13] or use the modified earliest deadline first scheduler proposed in <ref> [3] </ref>, which can guarantee a set of tasks at the expense of high worst-case time complexity. Rather than do so, we use cheap processors to separate the scheduling classes, simplify the scheduling algorithms, and avoid a global, pessimistic, worst-case analysis. The cognitive subsystem is a soft real-time system.
Reference: 4. <author> A. Gheith and K. Schwan, ``CHAOSart: </author> <title> Kernel Support for Atomic Transactions in Real-Time Applications,'' </title> <booktitle> Proc. 19th International Symp. on Fault-Tolerant Computing, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: Our emphasis is on situations where the dynamic scheduling approach employed in the Spring kernel may be infeasible or where other techniques could be fruitfully exploited, such as imprecise computations, criticality-based scheduling, and exception propagation. Our work also shares several ideas with the CHAOS-ARC operating system kernel <ref> [4, 5] </ref>. We both support hard and soft real-time constraints within a single program and allow the user to tailor scheduling policies to changing conditions. CHAOS-ARC presents a single unified computation model based on objects, invocations, and transactions, whereas we allow users to define their own process and communication models.
Reference: 5. <author> A. Gheith and K. Schwan, ``CHAOS-ARC: </author> <title> Kernel Support for Multi-Weight Objects, Invocations, and Atomicity in Real-Time Applications,'' </title> <institution> GIT-ICS-90/06, Georgia Institute of Technology, </institution> <month> Jan </month> <year> 1990. </year>
Reference-contexts: Our emphasis is on situations where the dynamic scheduling approach employed in the Spring kernel may be infeasible or where other techniques could be fruitfully exploited, such as imprecise computations, criticality-based scheduling, and exception propagation. Our work also shares several ideas with the CHAOS-ARC operating system kernel <ref> [4, 5] </ref>. We both support hard and soft real-time constraints within a single program and allow the user to tailor scheduling policies to changing conditions. CHAOS-ARC presents a single unified computation model based on objects, invocations, and transactions, whereas we allow users to define their own process and communication models.
Reference: 6. <author> K. D. Gordon, L. W. Dowdy, J. Baldo and K. J. Rappoport, </author> <title> ``Scheduling Aperiodic Tasks with Hard Deadlines in a Rate Monotonic Framework,'' </title> <booktitle> Proc. 6th IEEE Workshop on Real-time Operating Systems and Software, </booktitle> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1989, </year> <pages> pp. 1-5. </pages>
Reference-contexts: Rate monotonic scheduling assumes that processes are periodic, with known computation times, and that each process has a deadline equal to its period. This model can also support aperiodic processes with known computation times and deadlines, while still using a rate monotonic scheduler <ref> [6, 13] </ref>. The advantage of using a single process model is that all processes in the system inherit the proven properties of the scheduler, which may include on-line or off-line guarantees, and early warnings. There are several disadvantages, however.
Reference: 7. <author> E. D. Jensen, C. D. Locke and H. Tokuda, </author> <title> ``A Time-Driven Scheduling Model for Real--Time Operating Systems,'' </title> <booktitle> Proc. 6th Real-Time Systems Symp., </booktitle> <address> San Diego, CA, </address> <month> Dec </month> <year> 1985, </year> <pages> pp. 112-122. </pages>
Reference-contexts: For example, in the case where only process deadlines are known, earliest-deadline-first provides an optimal schedule for meeting the deadlines. When other information is available, such as the number of processes and their maximum computation time, periods, earliest starting times, functions that relate the payoff of completion with time <ref> [7] </ref>, the existence of imprecise computations [8], precedence relations, and synchronization and communication constraints, other scheduling algorithms can incorporate the information. The function of the scheduler may also vary from application to application. <p> The function of the scheduler may also vary from application to application. The scheduler may be required to meet all the deadlines, meet the deadlines of the most critical processes, meet those deadlines that optimize some cost function <ref> [7] </ref>, or give each process enough computation time, such that the approximation of the solution it computes is satisfactory (i.e., imprecise computations). This type of flexibility is especially important in the multiprocessor case, where optimal solutions are intractable and heuristic solutions need to be explored. 5.
Reference: 8. <author> K. J. Lin, S. Natarajan and J. W. S. Liu, </author> <title> ``Imprecise Results: Utilizing Partial Computations in Real-Time Systems,'' </title> <booktitle> Proc. 8th Real-Time Systems Symp., </booktitle> <year> 1987, </year> <pages> pp. 210-217. </pages>
Reference-contexts: When other information is available, such as the number of processes and their maximum computation time, periods, earliest starting times, functions that relate the payoff of completion with time [7], the existence of imprecise computations <ref> [8] </ref>, precedence relations, and synchronization and communication constraints, other scheduling algorithms can incorporate the information. The function of the scheduler may also vary from application to application.
Reference: 9. <author> C. L. Liu and J. W. Layland, </author> <title> ``Scheduling Algorithms for Multiprogramming in a Hard Real-Time Environment,'' </title> <journal> Journal of the ACM 20, </journal> <month> 1 (Jan </month> <year> 1973), </year> <pages> pp. 46-61. </pages>
Reference-contexts: This approach requires that each process provide the necessary attribute information, such as worst-case computation time or period, and that all processes have similar timing constraints, such as deadline or earliest-start-time constraints. Efforts to expand the utility of rate monotonic scheduling <ref> [9] </ref> fall into this category. Rate monotonic scheduling assumes that processes are periodic, with known computation times, and that each process has a deadline equal to its period. This model can also support aperiodic processes with known computation times and deadlines, while still using a rate monotonic scheduler [6, 13].
Reference: 10. <author> R. Rajkumar, L. Sha and J. P. Lehocsky, </author> <title> ``An Experimental Investigation of Synchronization Protocols,'' </title> <booktitle> Proc. 6th IEEE Workshop on Real-time Operating Systems and Software, </booktitle> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1989, </year> <pages> pp. 11-17. </pages>
Reference-contexts: The general problem of preserving timing constraints during communication has not been adequately addressed even when both processes involved have the same attributes and constraints, although solutions for specific cases (such as maintaining a consistent priority using a priority inversion protocol <ref> [10] </ref>) have been developed. The problem of meeting timing constraints across models is even more complex. We believe that the advantages of multiple models outweight the disadvantages, but progress on the problems listed above is required.
Reference: 11. <author> M. L. Scott, T. J. LeBlanc and B. D. Marsh, </author> <title> ``Design Rationale for Psyche, a General-Purpose Multiprocessor Operating System,'' </title> <booktitle> Proc. 1988 International Conference on Parallel Processing, </booktitle> <address> St. Charles, IL, </address> <month> Aug </month> <year> 1988, </year> <pages> pp. 255-262. </pages>
Reference-contexts: Using a hardware architecture in which a large-scale multiprocessor controls a behavioral system with vision and manipulation capabilities, we propose to build a software environment for real-time systems based on the Psyche multiprocessor operating system <ref> [11, 12] </ref>. The distinguishing characteristic of our approach is an emphasis on adaptability in a dynamic real-world environment.
Reference: 12. <author> M. L. Scott, T. J. LeBlanc and B. D. Marsh, </author> <title> ``Evolution of an Operating System for Large-Scale Shared-Memory Multiprocessors,'' </title> <type> TR 309, </type> <institution> Department of Computer Science, University of Rochester, </institution> <month> Mar </month> <year> 1989. </year>
Reference-contexts: Using a hardware architecture in which a large-scale multiprocessor controls a behavioral system with vision and manipulation capabilities, we propose to build a software environment for real-time systems based on the Psyche multiprocessor operating system <ref> [11, 12] </ref>. The distinguishing characteristic of our approach is an emphasis on adaptability in a dynamic real-world environment.
Reference: 13. <author> L. Sha, J. Lehoczky and R. Rajkumar, </author> <title> ``Solutions for Some Practical Problems in Prioritized Preemptive Scheduling,'' </title> <booktitle> Proc. 7th Real-Time Systems Symp., </booktitle> <address> New Orleans, LA, </address> <year> 1986, </year> <pages> pp. 181-191. </pages>
Reference-contexts: Rate monotonic scheduling assumes that processes are periodic, with known computation times, and that each process has a deadline equal to its period. This model can also support aperiodic processes with known computation times and deadlines, while still using a rate monotonic scheduler <ref> [6, 13] </ref>. The advantage of using a single process model is that all processes in the system inherit the proven properties of the scheduler, which may include on-line or off-line guarantees, and early warnings. There are several disadvantages, however. <p> On the other hand, processes that respond to interrupts from the human controller are aperiodic, with known computation times. These processes are scheduled using the earliest-deadline-first algorithm. We could model the aperiodic processes as periodic processes and use a rate-monotonic scheduler <ref> [13] </ref> or use the modified earliest deadline first scheduler proposed in [3], which can guarantee a set of tasks at the expense of high worst-case time complexity.
Reference: 14. <author> J. Stankovic and K. Ramamritham, </author> <title> ``The Design of the Spring Kernel,'' </title> <booktitle> Proc. 4th IEEE Workshop on Real-Time Operating Systems, </booktitle> <year> 1987, </year> <pages> pp. 19-23. </pages>
Reference-contexts: Rather than incorporate ad hoc solutions to specific problems, we plan to work with our AI colleagues to exploit their developments on general systems for planning and reasoning. Many of our assumptions are shared with the designers of the Spring kernel <ref> [14] </ref>, which has the goal of supporting predictable real-time AI applications. Spring uses predictable dynamic scheduling to add flexibility to systems that have historically been difficult to modify, unable to adapt to changing conditions, and based entirely on static schedules.
References-found: 14

