URL: http://www.cs.man.ac.uk/fmethods/people/visserw/spin98.ps.gz
Refering-URL: http://www.cs.man.ac.uk/fmethods/LaTeX/people/willem-visser.html
Root-URL: http://www.cs.man.ac.uk
Title: CTL Model Checking for SPIN  
Author: Willem Visser and Howard Barringer 
Affiliation: Department of Computer Science, Manchester University  
Abstract: fvisserw,howardg@cs.man.ac.uk Abstract. We describe an efficient CTL fl model checking algorithm based on alternating automata and games. A CTL fl formula, expressing a correctness property, is first translated to a hesitant alternating automaton and then composed with a Kripke structure representing the model to be checked, this resulting automaton is then checked for nonemptiness. We introduce the nonemptiness game that checks the nonemptiness of a hesitant alternating automata (HAA). In the same way that alternating automata generalises nondeterministic automata, we show that this game for checking the nonemptiness of HAA, generalises the nested depth-first algorithm used to check the nonemptiness of nondeterministic Buchi automata (used in SPIN).
Abstract-found: 1
Intro-found: 1
Reference: [Ber95] <author> O. Bernholtz. </author> <title> Model Checking for Branching Time Temporal Logics. </title> <type> PhD thesis, </type> <institution> The Technion, Haifa, Israel, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: For example, in [MSS88] WAA are used to explain the complexity of decision procedures for certain temporal logics. More recently, WAA were used to define linear time algorithms for model checking CTL <ref> [Ber95] </ref>. In [BVW94], Bernholtz et al. defined bounded alternation WAA, that also allow space efficient CTL model checking. In fact, it was shown that CTL model checking is in NLOGSPACE in the size of the Kripke structure. A weak alternating automaton is defined as follows. <p> Unfortunately WAA cannot be used for model checking CTL fl , since CTL fl can define languages that are not weakly definable. A stronger acceptance condition is required for automata corresponding to CTL fl formulas. In <ref> [Ber95] </ref> hesitant alternating tree automata (HAA) are defined that have a more restricted transition structure than WAA, but a more powerful acceptance condition. As with WAA, there exists a partial order between disjoint sets S i of S. <p> In [Vis98] it is shown that 1-HAA is the automata-theoretic counterpart of CTL, whereas HAA in general correspond to CTL fl formulas. 4.2 Translating CTL fl to HAA Here we will only discuss informally the translation of CTL fl formulas into HAA. The interested reader is referred to <ref> [Ber95] </ref> for a detailed analysis of this translation. <p> In the construction of the HAA for E the crucial point is the construction of a nondeterministic Buchi word automaton that accepts all the infinite words recognised by . A simple translation exists from this automaton to the HAA for E (see <ref> [Ber95] </ref>). Unfortunately, the Buchi word automaton is exponential in the size of the [VW94,GPVW95]. This results in the complete translation from a CTL fl formula into an HAA being exponential. <p> word automaton, even though this translation is known to be linear [MSS88]; this is because the reduction to a 1-letter nonemptiness problem, which we will see in the next section is crucial for efficient model checking, is impossible for alternating Buchi word automata, but valid for nondeterministic Buchi word automata <ref> [Ber95] </ref>. Example: Consider the CTL fl formula ' = AF Gp. Since it is of the form A we need to negate and complement the HAA for EGF :p. Note that we do not need to construct an HAA for the maximal formula (:p) since it is already a proposition. <p> If the language accepted by A K D;' is nonempty then ' holds for K, otherwise not. Thus, a nonemptiness check for HAA is required to check CTL fl properties in K. The general nonemptiness check for HAA cannot be done efficiently <ref> [Ber95] </ref>. Fortunately, taking the product with the Kripke structure K, results in a 1-letter HAA over words (i.e. an HAA with jj = 1 and D = f1g), for which a nonemptiness check can be done in linear time [Ber95]. Let us now define this product automaton. <p> The general nonemptiness check for HAA cannot be done efficiently <ref> [Ber95] </ref>. Fortunately, taking the product with the Kripke structure K, results in a 1-letter HAA over words (i.e. an HAA with jj = 1 and D = f1g), for which a nonemptiness check can be done in linear time [Ber95]. Let us now define this product automaton. <p> From section 4.2 (and in more detail <ref> [Ber95] </ref>) we know that the HAA obtained from formulas of the form E' only contain _-choices and those for A' only contain ^-choices.The nonemptiness games for linear time formulas can therefore be considered to be boring games for one of the two players, since either all the moves will be made <p> Furthermore, when Port makes all the moves the acceptance condition is (G; ;) and when Brandy makes all the moves it is (;; B) <ref> [Ber95] </ref>. Therefore from the winning conditions in the nonemptiness game given in Figure 5, if Port (Brandy) moves and G (B) is empty then any position on the current play that is revisited means a win for Brandy (Port).
Reference: [BVW94] <author> O. Bernholtz, M. Vardi, and P. Wolper. </author> <title> An Automata-Theoretic Approach to Branching-Time Model Checking. </title> <booktitle> In CAV '94: 6th International Conference on Computer Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <year> 1994. </year>
Reference-contexts: For example, in [MSS88] WAA are used to explain the complexity of decision procedures for certain temporal logics. More recently, WAA were used to define linear time algorithms for model checking CTL [Ber95]. In <ref> [BVW94] </ref>, Bernholtz et al. defined bounded alternation WAA, that also allow space efficient CTL model checking. In fact, it was shown that CTL model checking is in NLOGSPACE in the size of the Kripke structure. A weak alternating automaton is defined as follows.
Reference: [CE81] <author> E.M. Clarke and E.A. Emerson. </author> <title> Design and Synthesis of Synchronization Skeletons using Branching Time Temporal Logic. </title> <editor> In D. Kozen, editor, </editor> <booktitle> Proceedings of IBM Workshop on Logic of Programs, </booktitle> <pages> pages 52-71. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 131, </volume> <year> 1981. </year>
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: In section 8 we have some concluding remarks about the work presented here. 2 Syntax and Semantics of CTL fl CTL fl can express both linear and branching time properties, and is therefore more expressive than the linear time logic LTL [LP85] and the branching time logic CTL <ref> [CES86] </ref>. In fact, both these logics are sublogics of CTL fl . For technical convenience only positive CTL fl formulas will be used here, i.e. formulas with negations only applied to atomic propositions.
Reference: [CVWY92] <author> C. Courcoubetis, M. Vardi, P. Wolper, and M. Yannakakis. </author> <title> Memory-Efficient Algorithms for the Verification of Temporal Properties. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 1 </volume> <pages> 275-288, </pages> <year> 1992. </year> <title> 5 This requirement needs further investigation; we believe it might not be necessary, although it is in our prototype implementation. </title>
Reference-contexts: Courcoubetis et al. <ref> [CVWY92] </ref> show that during the nonemptiness check of a Buchi automaton the computation of SCCs can be avoided. Note that constructing SCCs is not very memory efficient since the states in the SCCs must be stored during the procedure. <p> VisitedStates is a data-structure, usually a hash table, that keeps track of all states already seen during the search. The algorithm works as follows: when the first search backtracks to an accepting state a second search is started to look for a cycle through this state. In <ref> [CVWY92] </ref> it was stated that the memory requirements of the nested depth-first search would be double that of a single depth-first search, but in [GH93] it is shown that only two bits need to be added to each state to separate the states stored in VisitedStates.
Reference: [EJ88] <author> E.A. Emerson and C.S. Jutla. </author> <title> Complexity of Tree Automata and Modal Logics of Programs. </title> <booktitle> In 29th annual IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1988. </year>
Reference-contexts: avoided by picking the other option in the _-choice and reach a trivial accepting state it follows that the run of the alternating automata is accepting and hence K; x j= AGEF p. 5 Nonemptiness Game Emerson and Jutla were the first to use game-theory in combination with temporal logic <ref> [EJ88] </ref>. They used infinite Borel games to show that satisfiability checking for CTL fl is in deterministic double exponential time. Stirling showed how Ehrenfeucht-Fraisse games can be used to capture the expressive power of the extremal fixed point operators of the -calculus [Sti96].
Reference: [GH93] <author> P. Godefroid and G.J. Holzmann. </author> <title> On the Verification of Temporal Properties. </title> <booktitle> In Participants Proceedings of the 13-th IFIP Symposium on Protocol Specification, Testing, and Verification, Liege, </booktitle> <address> Belgium, </address> <month> 25-28 May </month> <year> 1993. </year>
Reference-contexts: In [CVWY92] it was stated that the memory requirements of the nested depth-first search would be double that of a single depth-first search, but in <ref> [GH93] </ref> it is shown that only two bits need to be added to each state to separate the states stored in VisitedStates. <p> However, adding the CTL fl nonemptiness games would require some fundamental changes. Firstly, it is worth noting that whereas for the LTL games at most one new game will be required (from the result for the nested depth-first search <ref> [GH93] </ref>), in the CTL fl case many (nested) games might be required depending on the formula to be checked. <p> Also, in the CTL fl case we currently require that the results stores for the new games be deleted when the games terminate 5 , which is not necessary for the strictly LTL case (again from <ref> [GH93] </ref>). The biggest single change to SPIN would be to replace the never claim with a different notation to handle the positive boolean functions used with the HAA. Specifically to handle the case where we have ^ connectives.
Reference: [GPVW95] <author> R. Gerth, D. Peled, M. Vardi, and P. Wolper. </author> <title> Simple on-the-fly automatic verification of linear temporal logic. In Protocol Specification Testing and Verification, </title> <address> pages 3-18, Warsaw, Poland, 1995. </address> <publisher> Chapman & Hall. </publisher>
Reference-contexts: 0 ; f:pg) = M (q 1 ; f:pg) = q 1 M (q 0 ; fpg) = M (q 1 ; fpg) = q 0 with the accepting set fq 1 g and the initial state q 0 . (We implemented an optimised version of the algorithm given in <ref> [GPVW95] </ref> to create Buchi word automata from linear time formulas.) From this we construct the HAA for EGF :p: q ffi (q; f:pg; k) ffi (q; fpg; k) W k1 W k1 q 1 c=0 (c; q 1 ) c=0 (c; q 0 ) with acceptance condition (fq 1 g; fg)
Reference: [Hol91] <author> G.J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: Nested DFS Of all model checkers, SPIN <ref> [Hol91] </ref> is probably the most widely used: a recent estimation puts the number of installations at around 4000 [Hol97] with an even spread among commercial and academic usage.
Reference: [Hol97] <author> G. </author> <title> Holzmann. </title> <type> Invited Presentation, </type> <month> November </month> <year> 1997. </year> <title> Formal Methods Day, </title> <institution> Royal Holloway & Bedford NW College, University of London. </institution>
Reference-contexts: Nested DFS Of all model checkers, SPIN [Hol91] is probably the most widely used: a recent estimation puts the number of installations at around 4000 <ref> [Hol97] </ref> with an even spread among commercial and academic usage. Correctness properties in SPIN are specified by the so-called never claim, which is essentially a Buchi automaton expressing unacceptable behaviour (hence the name never claim).
Reference: [HPY96] <author> G.J. Holzmann, D. Peled, and M. Yannakakis. </author> <title> On Nested Depth First Search. </title> <editor> In Jean-Charles Gregoire, Gerard J. Holzmann, and Doron Peled, editors, </editor> <booktitle> Proceedings of the Second Workshop in the SPIN Verification System. </booktitle> <publisher> American Mathematical Society, </publisher> <address> DIMACS/39, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: This is the same rule that is used in the nested depth-first search used in the SPIN model checker <ref> [HPY96] </ref> (see also section 3.2). Here we have presented a justification for this rule in the setting of the nonemptiness game. 6.2 CTL Nonemptiness Games In [Vis98] it was shown that CTL formulas can be translated to 1-HAA (HAA with singleton S i sets).
Reference: [Lam80] <author> L. Lamport. </author> <title> Sometimes is sometimes "not never" | on the Temporal Logic of Programs. </title> <booktitle> Proceedings 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-185, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Temporal logics are popular property-description languages since they can describe event orderings without having to introduce time explicitly. There are two main kinds of temporal logics: linear and branching <ref> [Lam80] </ref>. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time has several possible futures.
Reference: [LP85] <author> Orna Lichtenstein and Amir Pnueli. </author> <title> Checking That Finite State Concurrent Programs Satisfy Their Linear Specification. </title> <booktitle> Proceedings 12th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: In section 8 we have some concluding remarks about the work presented here. 2 Syntax and Semantics of CTL fl CTL fl can express both linear and branching time properties, and is therefore more expressive than the linear time logic LTL <ref> [LP85] </ref> and the branching time logic CTL [CES86]. In fact, both these logics are sublogics of CTL fl . For technical convenience only positive CTL fl formulas will be used here, i.e. formulas with negations only applied to atomic propositions.
Reference: [MSS86] <author> D.E. Muller, A. Saoudi, and P.E. Schupp. </author> <title> Alternating Automata, the Weak Monadic Theory of the Tree and its Complexity. </title> <booktitle> In 13th International Colloquium on Automata, Languages and Programming, volume 226 of Lecture Notes in Computer Science, </booktitle> <year> 1986. </year>
Reference-contexts: Weak alternating automata (WAA), introduced by Muller et al. <ref> [MSS86] </ref>, was one of the first types of alternating automata to be used for reasoning about temporal logic. For example, in [MSS88] WAA are used to explain the complexity of decision procedures for certain temporal logics.
Reference: [MSS88] <author> D.E. Muller, A. Saoudi, and P.E. Schupp. </author> <title> Weak Alternating Automata give a Simple Explanation of why Temporal and Dynamic Logics are Decidable in Exponential Time. </title> <booktitle> In Third Symposium on Logic in Computer Science, </booktitle> <pages> pages 422-427, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Weak alternating automata (WAA), introduced by Muller et al. [MSS86], was one of the first types of alternating automata to be used for reasoning about temporal logic. For example, in <ref> [MSS88] </ref> WAA are used to explain the complexity of decision procedures for certain temporal logics. More recently, WAA were used to define linear time algorithms for model checking CTL [Ber95]. In [BVW94], Bernholtz et al. defined bounded alternation WAA, that also allow space efficient CTL model checking. <p> This results in the complete translation from a CTL fl formula into an HAA being exponential. Note that we do not translate the linear time formula into an alternating Buchi word automaton, even though this translation is known to be linear <ref> [MSS88] </ref>; this is because the reduction to a 1-letter nonemptiness problem, which we will see in the next section is crucial for efficient model checking, is impossible for alternating Buchi word automata, but valid for nondeterministic Buchi word automata [Ber95]. Example: Consider the CTL fl formula ' = AF Gp.
Reference: [QS82] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and Verification of Concurrent Systems in CESAR. </title> <booktitle> In International Symposium on Programming, volume 137 of Lecture Notes in Computer Science, </booktitle> <year> 1982. </year>
Reference: [Sti95] <author> C. Stirling. </author> <title> Local model checking games. </title> <booktitle> In CONCUR '95: 6th International Conference on Concurrency Theory, volume 962 of Lecture Notes in Computer Science, </booktitle> <year> 1995. </year>
Reference-contexts: Stirling showed how Ehrenfeucht-Fraisse games can be used to capture the expressive power of the extremal fixed point operators of the -calculus [Sti96]. To the best of our knowledge, Stirling was also the first to use two-player games for model checking <ref> [Sti95] </ref> when he reformulated the model checking problem for the -calculus as a two-player game. Here we show how the nonemptiness check for HAA can be formulated as a 2-player game. We refer to this game as the nonemptiness game.
Reference: [Sti96] <author> C. Stirling. </author> <title> Games and model mu-calculus. </title> <booktitle> In TACAS '96: 2nd International Workshop on Tools and Algorithms for the Construction and Analysis of Systems, volume 1055 of Lecture Notes in Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: They used infinite Borel games to show that satisfiability checking for CTL fl is in deterministic double exponential time. Stirling showed how Ehrenfeucht-Fraisse games can be used to capture the expressive power of the extremal fixed point operators of the -calculus <ref> [Sti96] </ref>. To the best of our knowledge, Stirling was also the first to use two-player games for model checking [Sti95] when he reformulated the model checking problem for the -calculus as a two-player game. Here we show how the nonemptiness check for HAA can be formulated as a 2-player game.
Reference: [Tar72] <author> Robert E. Tarjan. </author> <title> Depth-First Search and Linear Graph Algorithms. </title> <journal> Society for Industrial and Applied Mathematics, </journal> <volume> 1(2) </volume> <pages> 146-160, </pages> <year> 1972. </year>
Reference-contexts: It is easy to see that a linear time algorithm exists to find such an accepting state: decompose the state graph of the automaton into SCCs, which can be done in time linear in the size of the automaton <ref> [Tar72] </ref>; the automaton is nonempty iff an accepting state exists in any of the SCCs.
Reference: [VBF + 97] <author> W. Visser, H. Barringer, D. Fellows, G. Gough, and A. Williams. </author> <title> Efficient CTL fl Model Checking for the Analysis of Rainbow Designs. </title> <booktitle> Proceedings of CHARME '97, </booktitle> <address> Montreal, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: One of the features of this model checker is that it was designed with the view to easily facilitate changing the design formalism to be checked. Currently we check asynchronous hardware designs described in the Rainbow formalism <ref> [VBF + 97] </ref>. The next step would be to do PROMELA designs. 8 Concluding Remarks We showed that the automata approach that led to efficient LTL model checking algorithms can be generalised to full CTL fl . This is to the best of our knowledge the first such algorithm.
Reference: [Vis98] <author> W.C. Visser. </author> <title> Efficient CTL fl Model Checking using Games and Automata. </title> <type> PhD thesis, </type> <institution> Manchester University, </institution> <month> June </month> <year> 1998. </year>
Reference-contexts: Here we also define a subclass of HAA, called 1-HAA, for which every S i set contains only one state in the partial order. In <ref> [Vis98] </ref> it is shown that 1-HAA is the automata-theoretic counterpart of CTL, whereas HAA in general correspond to CTL fl formulas. 4.2 Translating CTL fl to HAA Here we will only discuss informally the translation of CTL fl formulas into HAA. <p> This is the same rule that is used in the nested depth-first search used in the SPIN model checker [HPY96] (see also section 3.2). Here we have presented a justification for this rule in the setting of the nonemptiness game. 6.2 CTL Nonemptiness Games In <ref> [Vis98] </ref> it was shown that CTL formulas can be translated to 1-HAA (HAA with singleton S i sets). Hence, unlike in the linear time case, the introduction of a results store cannot cause a position in G (B) to be labelled incorrectly as a win for the wrong player. <p> By adding a simple proviso to the rules for playing the nonemptiness game the rules in Table 1 is also sufficient to play nonemptiness game for full CTL fl . Here we will only give informal arguments for why this is the case, the interested reader is referred to <ref> [Vis98] </ref> where it is discussed in detail. First observe that a CTL fl formula can consists of a boolean combination of CTL and/or LTL formulas or nesting of such formulas. <p> Specifically to handle the case where we have ^ connectives. We have implemented a CTL fl model checker that works with HAA and the nonemptiness game approach <ref> [Vis98] </ref>. One of the features of this model checker is that it was designed with the view to easily facilitate changing the design formalism to be checked. Currently we check asynchronous hardware designs described in the Rainbow formalism [VBF + 97].
Reference: [VW86a] <author> M. Vardi and P. Wolper. </author> <title> Automata-theoretic Techniques for Modal Logics of Programs. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(5), </volume> <year> 1986. </year>
Reference-contexts: An interface for doing LTL model checking exists by translating a LTL formula to a never claim (Buchi automaton). 4 Automata-Theoretic CTL fl Model Checking The automata-theoretic counterpart for branching time temporal logic is automata over infinite trees <ref> [VW86a] </ref>. For branching time, unlike for linear time, satisfiability and model checking complexity do not coincide; model checking is typically much easier than checking sat-isfiability. Nondeterministic tree automata cannot compete with this gap, essentially since the translation from formulas to automata can incur an exponential blow-up in size.
Reference: [VW86b] <author> M.Y. Vardi and P. Wolper. </author> <title> An Automata Theoretic Approach to Automatic Program Verification. </title> <booktitle> In First Symposium on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <month> June </month> <year> 1986. </year>
Reference: [VW94] <author> M. Vardi and P. Wolper. </author> <title> Reasoning about Infinite Computations. </title> <journal> Information and Computation, </journal> <volume> 115(1), </volume> <year> 1994. </year>
Reference-contexts: The automaton A K has as its accepting set all the states in the automaton and therefore any run of the automaton is accepting. Thus, L (A K ) is the set of computations (possible behaviours) of K. In <ref> [VW94] </ref> it is proven that for an LTL formula a Buchi automaton A can be constructed such that L (A ) is the set of computations that satisfies formula with the number of states of L (A ) in O (2 O (j j) ). <p> Construct the product automaton A K;: = K fi A : . 3. If L (A K;: ) 6= ; report invalid else report valid. 3.2 Nonemptiness Checking A Buchi automaton accepts some word iff there exists an accepting state reachable from the initial state and from itself <ref> [VW94] </ref>.
Reference: [Wol89] <author> P. Wolper. </author> <title> On the Relation of Programs and Computations to Models of Temporal Logic. In Temporal Logic in Specification, </title> <booktitle> volume 398 of Lecture Notes in Computer Science, </booktitle> <year> 1989. </year>
Reference-contexts: For branching temporal logic, each Kripke structure corresponds to a single nondeterministic computation. Therefore, model checking is reduced to checking the membership of this computation in the language of the automaton describing the formula <ref> [Wol89] </ref>. This suggests the following automata-based model checking algorithm. Given a branching temporal formula ' and a Kripke structure K with degrees in D: 1. Construct the alternating automaton for the formula, A D;' . 2. Construct the product alternating automaton A K D;' = KfiA D;' .
References-found: 25

