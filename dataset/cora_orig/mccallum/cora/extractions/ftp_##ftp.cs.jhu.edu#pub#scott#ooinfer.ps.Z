URL: ftp://ftp.cs.jhu.edu/pub/scott/ooinfer.ps.Z
Refering-URL: http://www.cs.jhu.edu/labs/pll/home.html
Root-URL: http://www.cs.jhu.edu
Title: Type Inference for Recursively Constrained Types and its Application to OOP  
Author: Jonathan Eifrig Scott Smith Valery Trifonov 
Date: November 16, 1994  
Address: (DRAFT)  
Affiliation: The Johns Hopkins University  
Abstract-found: 0
Intro-found: 1
Reference: [AC94] <author> M. Abadi and L. Cardelli. </author> <title> A semantics of object types. </title> <booktitle> In Proceedings of the Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 332-341, </pages> <year> 1994. </year>
Reference-contexts: We take a translational approach because we find the factoring to help clarify ambiguities; however, there is also merit in studying languages where objects themselves are primitive <ref> [AC94] </ref>, and the concepts herein should eventually be recast as primitive object typings. I-Soop's type system contains both subtyping and polymorphic rc types. We infer shallow polymorphic rc types at let-expressions as in the Hind-ley/Milner algorithm [Mil78].
Reference: [Aik94] <author> A. Aiken. Illyria system. ftp://s2k-ftp.cs.berkeley.edu/pub/personal/aiken/, </author> <year> 1994. </year>
Reference-contexts: In particular their language is a functional language without records. The ideal model cannot model languages with state, so their approach would not extend to a language with state. Aiken has implemented the type inference algorithm <ref> [Aik94] </ref>, and this implemented system has an optimized inference algorithm and an implementation of extensible records. Encoding object-oriented features within a more basic language is one possible approach to how object-oriented programming should be done [Remy94].
Reference: [AW93] <author> A. Aiken and E. L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <year> 1993. </year>
Reference-contexts: Records are needed so record subtyping can be used to model object subtyping [CW85]. Without state, the critical state-holding property of objects is lost [ESTZ94]. Our approach to establishing the soundness of constrained type inference differs from other work in the literature. In other approaches (e.g. <ref> [AW93, Kae92, SY94, PS94] </ref>), a method is given that either produces a satisfying assignment to the constraints and thus establishes their consistency, or establishes that no such solution exists and the constraints are thus inconsistent. <p> Their system however has no polymorphism, and they take a code-expansion view of inheritance, requiring re-type-checking with each class extension. This lack of polymorphism has been partially addressed by Plevyak and Chien [PC94]. Our work is closest to that of Aiken and Wimmers <ref> [AW93] </ref>. They develop a type system with subtyping, union and intersection types, and a form of polymorphic type similar to polymorphic rc types. They prove soundness using the ideal model [MPS86]. <p> It is important to observe that consistency of constraints is implicitly enforced by each rule. Other presentations of constrained type systems <ref> [Mit84, AW93, Kae92] </ref> do not require local consistency, so the constraints in the rules have both a hypothetical and assertional component. They are hypothetical in that they may be inconsistent, and they are assertional in that they assert properties of the type if they are consistent. <p> Leaving the latter constraints out (as <ref> [AW93] </ref> do) results in a system unsound with respect to the standard call-by-value semantics of the let expression; C may contain constraints on type variables free in the environment, and their omission may lead to accepting programs which get stuck while evaluating the expression assigned to the bound variable.
Reference: [Bru93] <author> K. Bruce. </author> <title> Safe type checking in a statically-typed object-oriented programming language. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-298, </pages> <year> 1993. </year>
Reference-contexts: Indeed, t 2 -!zero:--!Bool by transitive closure also requires a record without zero to be a subtype of a record with zero, but this is by definition an inconsistent constraint. Compared to other work on rigorously sound class-based object languages, neither Bruce's TOOPLE or TOIL languages <ref> [Bru93, BvG93] </ref>, nor our Loop language [ESTZ95] allows the above program to type-check; in fact we know of no static type-system for object-oriented programming 14 that successfully type-checks this example.
Reference: [BvG93] <author> Kim B. Bruce and Robert van Gent. </author> <title> TOIL: A new type-safe object-oriented imperative language. </title> <type> Technical report, </type> <institution> Williams College, </institution> <year> 1993. </year>
Reference-contexts: Indeed, t 2 -!zero:--!Bool by transitive closure also requires a record without zero to be a subtype of a record with zero, but this is by definition an inconsistent constraint. Compared to other work on rigorously sound class-based object languages, neither Bruce's TOOPLE or TOIL languages <ref> [Bru93, BvG93] </ref>, nor our Loop language [ESTZ95] allows the above program to type-check; in fact we know of no static type-system for object-oriented programming 14 that successfully type-checks this example.
Reference: [Car84] <author> L. Cardelli. </author> <title> A semantics of multiple inheritance. In Semantics of Data Types, </title> <booktitle> volume 173 of Lecture notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Then these rules are shown equivalent in strength to the general form of rules, without recourse to a "principal types" property. 1.1 Related Work A number of type inference systems have been developed that bear on the type inference problem for OOP. Papers of Reynolds [Rey85], Cardelli <ref> [Car84] </ref>, and Mitchell [Mit84] are foundational papers in the field that develop the basic concepts of constraints and subtyping. Many papers have been written since; we focus on the more recent work the most relevant to ours.
Reference: [CCH + 89] <author> P. Canning, W. Cook, W. Hill, J. Mitchell, and W. Olthoff. </author> <title> F-bounded polymorphism for object-oriented programming. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: However, type inference has yet to achieve practical application to object-oriented programming languages. We strongly feel the core type features necessary to model object-oriented programming with type inference include a notion of subtyping [CW85], and a notion of "recursively constrained polymorphism," a generalization of F-bounded polymorphism <ref> [CHC90, CCH + 89] </ref>. Recursively constrained types are types of the form t n C, with " n " reading "where." C is a set of type constraints of the form t 1 t 2 , possibly containing free type variables. <p> Polymorphic rc types generalize the more well-known bounded types [CW85] 8t t: t 0 in several ways. First, they are recursive, so t could occur free in t ; this is not allowed in bounded types. Types with t occurring free in t are the so-called F-bounded types <ref> [CCH + 89] </ref>. Polymorphic rc types generalize F-bounded types by allowing more than one upper bound on a type variable, as well as allowing multiple lower-bound constraints t t.
Reference: [CHC90] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: However, type inference has yet to achieve practical application to object-oriented programming languages. We strongly feel the core type features necessary to model object-oriented programming with type inference include a notion of subtyping [CW85], and a notion of "recursively constrained polymorphism," a generalization of F-bounded polymorphism <ref> [CHC90, CCH + 89] </ref>. Recursively constrained types are types of the form t n C, with " n " reading "where." C is a set of type constraints of the form t 1 t 2 , possibly containing free type variables. <p> As we show, typing becomes considerably more difficult in the presence of binary methods <ref> [CHC90] </ref>. The ideal way to show applicability to OOP would be to define a complete OOP language, types, and inference algorithm; this is beyond the scope of this paper, however. Instead, we will show how a collection of simple macros allow OOP to be embedded into I-Soop. <p> Because num is of the same type as the type of objects of the class we are currently defining, expressing the type of the gcd method will require some self-referentiality. We first consider appropriate types for the inheritance-is-subtyping paradigm. This is known to have serious limitations <ref> [CHC90] </ref>, but is nonetheless frequently found in commercial OOP languages. In this paradigm we give GcdNum the type GcdNum : GcdType!GcdType; where GcdType = t: ( -!- val : Nat ref, gcd : t!t -) Note that is the usual recursive type constructor.
Reference: [CW85] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: However, type inference has yet to achieve practical application to object-oriented programming languages. We strongly feel the core type features necessary to model object-oriented programming with type inference include a notion of subtyping <ref> [CW85] </ref>, and a notion of "recursively constrained polymorphism," a generalization of F-bounded polymorphism [CHC90, CCH + 89]. <p> Polymorphic rc types are types 8t 1 ; : : : ; t n : t n C where constraints t 1 t 2 in C may contain type variables t 1 ; : : : t n free. Polymorphic rc types generalize the more well-known bounded types <ref> [CW85] </ref> 8t t: t 0 in several ways. First, they are recursive, so t could occur free in t ; this is not allowed in bounded types. Types with t occurring free in t are the so-called F-bounded types [CCH + 89]. <p> In addition the underlying language includes records and a notion of state, for with these features it is possible to obtain an effective encoding of object-oriented programming. Records are needed so record subtyping can be used to model object subtyping <ref> [CW85] </ref>. Without state, the critical state-holding property of objects is lost [ESTZ94]. Our approach to establishing the soundness of constrained type inference differs from other work in the literature.
Reference: [ESTZ93] <author> J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. </author> <title> A simple interpretation of OOP in a language with state. </title> <type> Technical Report YALEU/DCS/RR-968, </type> <institution> Yale University, </institution> <year> 1993. </year>
Reference-contexts: We thus opt for an encoding using a Y -combinator with an initial instance variable allocation phase. In a more complete treatment of this topic a limited form of memory-based fixed point such as the single-assignment reference (SAR) of <ref> [ESTZ93] </ref> could be used. We ignore the issue of information hiding in this presentation, though it is not difficult to incorporate.
Reference: [ESTZ94] <author> J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. </author> <title> Application of OOP type theory: State, decidability, integration. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <year> 1994. </year> <month> 15 </month>
Reference-contexts: Records are needed so record subtyping can be used to model object subtyping [CW85]. Without state, the critical state-holding property of objects is lost <ref> [ESTZ94] </ref>. Our approach to establishing the soundness of constrained type inference differs from other work in the literature.
Reference: [ESTZ95] <author> J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. </author> <title> An interpretation of typed OOP in a language with state. </title> <booktitle> Lisp and Symbolic Computation, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: First, it is difficult to take fixed points of records in a call-by-value language. Second, when taking a fixed point via a Y -combinator, the semantics entails re-evaluating the record with each recursive access, and thus erroneously re-initialize any instance variables. In previous work <ref> [ESTZ95] </ref> we avoided these problems by using a memory-based fixed point. Unfortunately this encoding will not work here as the use of reference 1 Also called implicit object coercion or object subsumption. 10 cells to form the fixed point will infer imperative polymorphic types for objects. <p> Compared to other work on rigorously sound class-based object languages, neither Bruce's TOOPLE or TOIL languages [Bru93, BvG93], nor our Loop language <ref> [ESTZ95] </ref> allows the above program to type-check; in fact we know of no static type-system for object-oriented programming 14 that successfully type-checks this example.
Reference: [Kae92] <author> S. Kaes. </author> <title> Type inference in the presence of overloading, subtyping and recursive types. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 193-204, </pages> <year> 1992. </year>
Reference-contexts: Records are needed so record subtyping can be used to model object subtyping [CW85]. Without state, the critical state-holding property of objects is lost [ESTZ94]. Our approach to establishing the soundness of constrained type inference differs from other work in the literature. In other approaches (e.g. <ref> [AW93, Kae92, SY94, PS94] </ref>), a method is given that either produces a satisfying assignment to the constraints and thus establishes their consistency, or establishes that no such solution exists and the constraints are thus inconsistent. <p> Papers of Reynolds [Rey85], Cardelli [Car84], and Mitchell [Mit84] are foundational papers in the field that develop the basic concepts of constraints and subtyping. Many papers have been written since; we focus on the more recent work the most relevant to ours. Kaes <ref> [Kae92] </ref> develops a type inference algorithm for a language containing polymorphic and recursive types and type constraints. This work incorporates subtyping constraints, recursive types, and polymorphism. Kaes writes so-called constrained types t jC in close analogy to our rc types t n C. <p> It is important to observe that consistency of constraints is implicitly enforced by each rule. Other presentations of constrained type systems <ref> [Mit84, AW93, Kae92] </ref> do not require local consistency, so the constraints in the rules have both a hypothetical and assertional component. They are hypothetical in that they may be inconsistent, and they are assertional in that they assert properties of the type if they are consistent.
Reference: [KPS92] <author> D. Kozen, J. Palsberg, and M. I. Schwartzbach. </author> <title> Efficient inference of partial types. </title> <booktitle> In Foundations of Computer Science, </booktitle> <year> 1992. </year>
Reference-contexts: Sekiguchi and Yonezawa [SY94] take an approach similar to Kaes but interpret as subtyping on record types, making it more directly applicable to object-oriented programming. Palsberg, Schwartzbach, et. al. have written a number of papers concerning type inference for objects <ref> [PS94, OPS92, PS92, KPS92] </ref>. The main feature of their work is they do not take the Hindley/Milner approach to type inference.
Reference: [KR94] <author> Samuel N. Kamin and Uday S. Reddy. </author> <title> Two semantic models of object-oriented languages. </title> <editor> In Carl A. Gunter and John C. Mitchell, editors, </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming, chapter 13, </booktitle> <pages> pages 464-495. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The basic idea of the representation is to interpret classes as functions on records s:- : : : - where s is the "self"; new then takes the fixed point of a class to produce an object, in the form of a record (see <ref> [KR94] </ref>). We cannot quite use this encoding. First, it is difficult to take fixed points of records in a call-by-value language. Second, when taking a fixed point via a Y -combinator, the semantics entails re-evaluating the record with each recursive access, and thus erroneously re-initialize any instance variables.
Reference: [Mil78] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: I-Soop's type system contains both subtyping and polymorphic rc types. We infer shallow polymorphic rc types at let-expressions as in the Hind-ley/Milner algorithm <ref> [Mil78] </ref>. In addition the underlying language includes records and a notion of state, for with these features it is possible to obtain an effective encoding of object-oriented programming. Records are needed so record subtyping can be used to model object subtyping [CW85].
Reference: [Mit84] <author> J. Mitchell. </author> <title> Coercion and type inference (summary). </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1984. </year>
Reference-contexts: Papers of Reynolds [Rey85], Cardelli [Car84], and Mitchell <ref> [Mit84] </ref> are foundational papers in the field that develop the basic concepts of constraints and subtyping. Many papers have been written since; we focus on the more recent work the most relevant to ours. <p> It is important to observe that consistency of constraints is implicitly enforced by each rule. Other presentations of constrained type systems <ref> [Mit84, AW93, Kae92] </ref> do not require local consistency, so the constraints in the rules have both a hypothetical and assertional component. They are hypothetical in that they may be inconsistent, and they are assertional in that they assert properties of the type if they are consistent.
Reference: [MPS86] <author> D. B. MacQueen, G. Plotkin, and R. Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> <volume> 71 </volume> <pages> 95-130, </pages> <year> 1986. </year>
Reference-contexts: Our work is closest to that of Aiken and Wimmers [AW93]. They develop a type system with subtyping, union and intersection types, and a form of polymorphic type similar to polymorphic rc types. They prove soundness using the ideal model <ref> [MPS86] </ref>. As with the previously mentioned researchers, they have an algorithm that produces a satisfying assignment to the top-level constraints to establish consistency of a constraint set. The satisfying assignment they produce is an ideal in the ideal model. We have no union, intersection, or negation types.
Reference: [OPS92] <author> N. Oxhtj, J. Palsberg, and M. I. Schwartzbach. </author> <title> Type inference with subtypes. </title> <booktitle> In ECOOP'92 European Conference on Object-Oriented Programming, volume 615 of Lecture notes in Computer Science, </booktitle> <pages> pages 329-349. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Sekiguchi and Yonezawa [SY94] take an approach similar to Kaes but interpret as subtyping on record types, making it more directly applicable to object-oriented programming. Palsberg, Schwartzbach, et. al. have written a number of papers concerning type inference for objects <ref> [PS94, OPS92, PS92, KPS92] </ref>. The main feature of their work is they do not take the Hindley/Milner approach to type inference.
Reference: [PC94] <author> J. Plevyak and A. Chien. </author> <title> Precise concrete type inference for object-oriented languages. </title> <booktitle> In Proceedings of the Ninth Annual ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 324-340, </pages> <year> 1994. </year>
Reference-contexts: Other advantages of their approach include asymptotically efficient inference algorithms, and named class types. Their system however has no polymorphism, and they take a code-expansion view of inheritance, requiring re-type-checking with each class extension. This lack of polymorphism has been partially addressed by Plevyak and Chien <ref> [PC94] </ref>. Our work is closest to that of Aiken and Wimmers [AW93]. They develop a type system with subtyping, union and intersection types, and a form of polymorphic type similar to polymorphic rc types. They prove soundness using the ideal model [MPS86].
Reference: [PS92] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference for partial types. </title> <journal> Information Processing Letters, </journal> <pages> pages 175-180, </pages> <year> 1992. </year>
Reference-contexts: Sekiguchi and Yonezawa [SY94] take an approach similar to Kaes but interpret as subtyping on record types, making it more directly applicable to object-oriented programming. Palsberg, Schwartzbach, et. al. have written a number of papers concerning type inference for objects <ref> [PS94, OPS92, PS92, KPS92] </ref>. The main feature of their work is they do not take the Hindley/Milner approach to type inference.
Reference: [PS94] <author> J. Palsberg and M. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> Wiley, </publisher> <year> 1994. </year>
Reference-contexts: Records are needed so record subtyping can be used to model object subtyping [CW85]. Without state, the critical state-holding property of objects is lost [ESTZ94]. Our approach to establishing the soundness of constrained type inference differs from other work in the literature. In other approaches (e.g. <ref> [AW93, Kae92, SY94, PS94] </ref>), a method is given that either produces a satisfying assignment to the constraints and thus establishes their consistency, or establishes that no such solution exists and the constraints are thus inconsistent. <p> Sekiguchi and Yonezawa [SY94] take an approach similar to Kaes but interpret as subtyping on record types, making it more directly applicable to object-oriented programming. Palsberg, Schwartzbach, et. al. have written a number of papers concerning type inference for objects <ref> [PS94, OPS92, PS92, KPS92] </ref>. The main feature of their work is they do not take the Hindley/Milner approach to type inference.
Reference: [Remy94] <author> Didier Remy. </author> <title> Programming objects with ML-ART: An extension to ML with abstract and record types. </title> <editor> In Masami Hagiya and John C. Mitchell, editors, </editor> <booktitle> International Symposium on Theoretical Aspects of Computer Software, </booktitle> <pages> pages 321-346, </pages> <address> Sendai, Japan, April 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Aiken has implemented the type inference algorithm [Aik94], and this implemented system has an optimized inference algorithm and an implementation of extensible records. Encoding object-oriented features within a more basic language is one possible approach to how object-oriented programming should be done <ref> [Remy94] </ref>. We could take a similar approach by programming in an object-oriented style via the encoding of objects in I-Soop that we give in Section 5. Remy gives a collection of extensions to ML that allow OOP to be encoded.
Reference: [Rey85] <author> J. C. Reynolds. </author> <title> Three approaches to type structure. </title> <booktitle> In TAPSOFT proceedings, volume 185 of Lecture notes in Computer Science, </booktitle> <pages> pages 97-138, </pages> <year> 1985. </year>
Reference-contexts: Then these rules are shown equivalent in strength to the general form of rules, without recourse to a "principal types" property. 1.1 Related Work A number of type inference systems have been developed that bear on the type inference problem for OOP. Papers of Reynolds <ref> [Rey85] </ref>, Cardelli [Car84], and Mitchell [Mit84] are foundational papers in the field that develop the basic concepts of constraints and subtyping. Many papers have been written since; we focus on the more recent work the most relevant to ours.
Reference: [SY94] <author> T. Sekiguchi and A. Yonezawa. </author> <title> A complete type inference system for subtyped recursive types. </title> <booktitle> In Proc. Theoretical Aspects of Computer Software, volume 789 of Lecture Notes in Computer Science, </booktitle> <pages> pages 667-686. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Records are needed so record subtyping can be used to model object subtyping [CW85]. Without state, the critical state-holding property of objects is lost [ESTZ94]. Our approach to establishing the soundness of constrained type inference differs from other work in the literature. In other approaches (e.g. <ref> [AW93, Kae92, SY94, PS94] </ref>), a method is given that either produces a satisfying assignment to the constraints and thus establishes their consistency, or establishes that no such solution exists and the constraints are thus inconsistent. <p> Kaes takes the standard approach to constraint consistency, by producing a solution to the constraints. He also intends to model overloading, not record subtyping (his system has no record types). Sekiguchi and Yonezawa <ref> [SY94] </ref> take an approach similar to Kaes but interpret as subtyping on record types, making it more directly applicable to object-oriented programming. Palsberg, Schwartzbach, et. al. have written a number of papers concerning type inference for objects [PS94, OPS92, PS92, KPS92].
Reference: [Tof90] <author> M. Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <year> 1990. </year>
Reference-contexts: We show this view is sound, without ever showing the "consistent" constraint systems have solutions. Instead we directly establish a subject-reduction property over a proof of typing with "consistent" rc types at each node <ref> [Tof90, WF91] </ref>. We believe the standard method of finding solutions to the constraint sets can be overly restrictive, for it forces one to have a rich enough type language or type model that can express the solutions as types or sets. <p> An expression is expansive if and only if it is not a value; following Tofte <ref> [Tof90] </ref> we form type schemes by making the sets of type variables we generalize over dependent on the expansiveness of the expression. <p> The typing rules for I-Soop are given in Figure 1. Most of the rules have obvious relation to those of standard systems with subtyping and records; as in Tofte's system <ref> [Tof90] </ref>, the typing of ref introduces imperative types. The main difference is the addition of constraints as part of types, the associated subsumption rule on these types, and the way consistent constraints accumulate from the leaves to the root of a typing proof. <p> The proof proceeds in the standard fashion: given a configuration and a proof of its typability, perform one step of computation and transform the original typing proof into a proof for the new configuration. The interaction between let-polymorphism and reference cells is known to cause significant difficulty <ref> [Tof90] </ref>; our approach to this problem derives from [WF91], avoiding Tofte's complex greatest fixed-point construction. The differences between our proof and that of [WF91] result from the constraint systems of rc types and polymorphic rc types.
Reference: [WF91] <author> A. Wright and M. Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Rice University Department of Computer Science, </institution> <year> 1991. </year> <note> To appear in Information and Computation. </note>
Reference-contexts: We show this view is sound, without ever showing the "consistent" constraint systems have solutions. Instead we directly establish a subject-reduction property over a proof of typing with "consistent" rc types at each node <ref> [Tof90, WF91] </ref>. We believe the standard method of finding solutions to the constraint sets can be overly restrictive, for it forces one to have a rich enough type language or type model that can express the solutions as types or sets. <p> The interaction between let-polymorphism and reference cells is known to cause significant difficulty [Tof90]; our approach to this problem derives from <ref> [WF91] </ref>, avoiding Tofte's complex greatest fixed-point construction. The differences between our proof and that of [WF91] result from the constraint systems of rc types and polymorphic rc types. <p> The interaction between let-polymorphism and reference cells is known to cause significant difficulty [Tof90]; our approach to this problem derives from <ref> [WF91] </ref>, avoiding Tofte's complex greatest fixed-point construction. The differences between our proof and that of [WF91] result from the constraint systems of rc types and polymorphic rc types. Each step of computation is accompanied by a proof transformation that pushes constraints present near the top of the proof tree towards the leaves.
References-found: 27

