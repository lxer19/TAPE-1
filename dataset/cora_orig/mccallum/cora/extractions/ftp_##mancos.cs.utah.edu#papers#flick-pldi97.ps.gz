URL: ftp://mancos.cs.utah.edu/papers/flick-pldi97.ps.gz
Refering-URL: ftp://mancos.cs.utah.edu/papers/flick-pldi97-abs.html
Root-URL: 
Email: flick@cs.utah.edu  
Title: Flick: A Flexible, Optimizing IDL Compiler  
Author: Eric Eide Kevin Frei Bryan Ford Jay Lepreau Gary Lindstrom 
Note: To appear in Proceedings of the ACM SIGPLAN '97 Conference on Programming Language Design and Implementation (PLDI), Las Vegas, NV, June 15-18, 1997.  
Web: http://www.cs.utah.edu/projects/flux/flick/  
Address: 3190 M.E.B., Salt Lake City, Utah 84112  
Affiliation: University of Utah, Department of Computer Science  
Abstract: An interface definition language (IDL) is a nontraditional language for describing interfaces between software components. IDL compilers generate stubs that provide separate communicating processes with the abstraction of local object invocation or procedure call. High-quality stub generation is essential for applications to benefit from component-based designs, whether the components reside on a single computer or on multiple networked hosts. Typical IDL compilers, however, do little code optimization, incorrectly assuming that interprocess communication is always the primary bottleneck. More generally, typical IDL compilers are rigid and limited to supporting only a single IDL, a fixed mapping onto a target language, and a narrow range of data encodings and transport mechanisms. Flick, our new IDL compiler, is based on the insight that IDLs are true languages amenable to modern compilation techniques. Flick exploits concepts from traditional programming language compilers to bring both flexibility and optimization to the domain of IDL compilation. Through the use of carefully chosen intermediate representations, Flick supports multiple IDLs, diverse data encodings, multiple transport mechanisms, and applies numerous optimizations to all of the code it generates. Our experiments show that Flick-generated stubs marshal data between 2 and 17 times faster than stubs produced by traditional IDL compilers, and on today's generic operating systems, increase end-to-end throughput by factors between 1.2 and 3.7. This research was supported in part by the Defense Advanced Research Projects Agency, monitored by the Department of the Army under contract number DABT63-94-C-0058, and Rome Laboratory, Air Force Material Command, USAF, under agreement number F30602-96-2-0269. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright annotation hereon. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> ACCETTA, M., BARON, R., BOLOSKY, W., GOLUB, D., RASHID, R., TEVANIAN, A., AND YOUNG, M. </author> <title> Mach: A new kernel foundation for UNIX development. </title> <booktitle> In Proc. of the Summer 1986 USENIX Conf. </booktitle> <month> (June </month> <year> 1986), </year> <pages> pp. 93-112. </pages>
Reference-contexts: Flick currently has front ends that parse the CORBA [18], ONC RPC [23], and MIG [20] IDLs. Flick compiles an interface specification in any of these languages through a series of intermediate representations to produce CORBA-, rpcgen-, or MIG-style C stubs communicating via TCP, UDP, Mach <ref> [1] </ref> messages, or Fluke [10] kernel IPC. Flick's compilation stages are implemented as individual components and it is easy for a system designer to mix and match components at IDL compilation time in order to create the high-performance communication stubs that he or she needs.
Reference: [2] <author> AUERBACH, J. S., AND RUSSELL, J. R. </author> <title> The Concert signature representation: IDL as an intermediate language. </title> <booktitle> In Proc. of the Workshop on Interface Definition Languages (Jan. </booktitle> <year> 1994), </year> <pages> pp. 1-12. </pages>
Reference-contexts: For Flick to do similarly, it would simply emit marshaling code as it traversed an AOI structure. ILU does support two IDLs its native, unique IDL and the CORBA IDL but only by translating the CORBA language into its own IDL. Like Flick, the Concert/C distributed programming system <ref> [2] </ref> quite fully develops the concept of flexible presentation. In Concert, the primary purpose of this separation is to handle the vagaries of RPC mapping to different target languages, striving for a minimal contract in order to achieve maximal interoperability between target languages.
Reference: [3] <author> BIRRELL, A. D., AND NELSON, B. J. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems 2, </journal> <month> 1 (Feb. </month> <year> 1984). </year>
Reference-contexts: The numbers in the example ONC RPC IDL program are chosen by the programmer to identify components of the interface. IDL compiler hide the details of communication and allow the client and server to interact through a procedural interface. Traditionally, stubs have implemented remote procedure calls (RPC) <ref> [3] </ref> or remote method invocations (RMI): the client and server are located in separate processes, and the stubs in each process communicate by exchanging messages through a transport medium such as TCP/IP. More recently, IDLs have become popular for defining high-level interfaces between program modules within a single process.
Reference: [4] <author> BODEN, N., COHEN, D., FELDERMAN, R., KU-LAWIK, A., SEITZ, C., SEIZOVIC, J., AND SU, W.- K. </author> <title> Myrinet A gigabit-per-second local-area network. </title> <booktitle> IEEE MICRO 15, </booktitle> <month> 1 (February </month> <year> 1995), </year> <pages> 29-36. </pages>
Reference-contexts: For the ONC RPC and CORBA IDL-based compilers, we measured the performance of generated stub functions communicating across three different networks: a 10Mbps Ethernet link, a 100Mbps Ethernet link, and a 640Mbps Myrinet link <ref> [4] </ref>. For MIG interfaces, we measured Mach IPC speeds between separate tasks running on a single host. 6 For each transport and compiler, we measured the costs of three different method invocations. The first method takes an input array of integers.
Reference: [5] <author> CLARK, D. D., AND TENNENHOUSE, D. L. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In Proc. of the SIGCOMM '90 Symp. </booktitle> <year> (1990), </year> <pages> pp. 200-208. </pages>
Reference-contexts: Today's IDL compilers still assume that the transport medium is inherently slow, and therefore, that optimization of the stubs will not yield significant speed increases. Modern network architectures, however, have moved the performance bottlenecks for distributed applications out of the operating system layers and into the applications themselves <ref> [5, 12, 13] </ref>. In this paper we show that in order to solve the problems inherent to existing IDL compilers, IDL compilation must evolve from an ad hoc process to a principled process incorporating techniques that are already well-established in the traditional programming language community. <p> In a seminal paper in the networking domain, Clark and Ten nenhouse <ref> [5] </ref> identified data representation conversion as a bottleneck to many communication protocols. They emphasized the importance of optimizing the presentation layer of a protocol stack and showed that it often dominates processing time.
Reference: [6] <author> DRUSCHEL, P., DAVIE, B. S., AND PETERSON, L. L. </author> <title> Experiences with a high-speed network adapter: A software perspective. </title> <booktitle> In Proc. of the SIGCOMM '94 Symp. </booktitle> <year> (1994), </year> <pages> pp. 2-13. </pages>
Reference-contexts: As operating system limitations are reduced by lighter-weight transports <ref> [6, 7] </ref>, Flick's ability to produce optimized marshal code will have an increasingly large impact. 10 highly specialized for optimizing Mach message communication, and is able only to support simple data types.
Reference: [7] <author> EICKEN, T. V., CULLER, D. E., GOLDSTEIN, S. C., AND SCHAUSER, K. E. </author> <title> Active messages: A mechanism for integrated communication and computation. </title> <booktitle> In Proc. of the 19th International Symp. on Computer Architecture (May 1992), </booktitle> <pages> pp. 256-266. </pages>
Reference-contexts: As operating system limitations are reduced by lighter-weight transports <ref> [6, 7] </ref>, Flick's ability to produce optimized marshal code will have an increasingly large impact. 10 highly specialized for optimizing Mach message communication, and is able only to support simple data types.
Reference: [8] <author> FORD, B., HIBLER, M., AND LEPREAU, J. </author> <title> Using annotated interface definitions to optimize RPC. </title> <booktitle> In Proc. of the 15th ACM Symp. on Operating Systems Principles (1995), </booktitle> <address> p. </address> <note> 232. Poster. 12 </note>
Reference-contexts: CORBA mapping rules, the Mail send function could be defined to take a separate message length argument: void Mail_send (Mail obj, char *msg, int len); This presentation of the Mail interface could enable optimizations because Mail send would no longer need to count the number of characters in the message <ref> [8, 9] </ref>. This change to the presentation would not affect the network contract between client and server; the messages exchanged between client and server would be unchanged. The addition of a separate len parameter changes only the calling conventions for the Mail send function. <p> In Concert, the primary purpose of this separation is to handle the vagaries of RPC mapping to different target languages, striving for a minimal contract in order to achieve maximal interoperability between target languages. However, this separation is not leveraged for optimizations. In earlier work <ref> [8, 9] </ref> we concentrated on leveraging Flick's explicit separation of presentation from interface in order to produce application-specialized stubs. We showed that programmer-supplied interface annotations that coerce the programmer's contract to applications' needs could provide up to an order of magnitude speedup in RPC performance.
Reference: [9] <author> FORD, B., HIBLER, M., AND LEPREAU, J. </author> <title> Using an-notated interface definitions to optimize RPC. </title> <type> Tech. Rep. </type> <institution> UUCS-95-014, University of Utah, </institution> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: CORBA mapping rules, the Mail send function could be defined to take a separate message length argument: void Mail_send (Mail obj, char *msg, int len); This presentation of the Mail interface could enable optimizations because Mail send would no longer need to count the number of characters in the message <ref> [8, 9] </ref>. This change to the presentation would not affect the network contract between client and server; the messages exchanged between client and server would be unchanged. The addition of a separate len parameter changes only the calling conventions for the Mail send function. <p> In Concert, the primary purpose of this separation is to handle the vagaries of RPC mapping to different target languages, striving for a minimal contract in order to achieve maximal interoperability between target languages. However, this separation is not leveraged for optimizations. In earlier work <ref> [8, 9] </ref> we concentrated on leveraging Flick's explicit separation of presentation from interface in order to produce application-specialized stubs. We showed that programmer-supplied interface annotations that coerce the programmer's contract to applications' needs could provide up to an order of magnitude speedup in RPC performance.
Reference: [10] <author> FORD, B., HIBLER, M., LEPREAU, J., TULLMANN, P., BACK, G., AND CLAWSON, S. </author> <title> Microkernels meet recursive virtual machines. </title> <booktitle> In Proc. of the Second Symp. on Operating Systems Design and Implementation (Seattle, </booktitle> <address> WA, Oct. 1996), </address> <publisher> USENIX Assoc., </publisher> <pages> pp. 137-151. </pages>
Reference-contexts: Flick compiles an interface specification in any of these languages through a series of intermediate representations to produce CORBA-, rpcgen-, or MIG-style C stubs communicating via TCP, UDP, Mach [1] messages, or Fluke <ref> [10] </ref> kernel IPC. Flick's compilation stages are implemented as individual components and it is easy for a system designer to mix and match components at IDL compilation time in order to create the high-performance communication stubs that he or she needs. <p> the CORBA IIOP (Internet Inter-ORB Protocol) [18] on top of TCP; the second sends ONC RPC messages [23, 24] over TCP or UDP; the third supports MIG-style typed messages sent between Mach 3 ports; and the fourth imple ments a special message format for the fast Fluke kernel IPC facility <ref> [10] </ref>. Although these four communication subsystems are all very different, Flick's back ends share a large library of code to optimize the marshaling and unmarshaling of data. This library operates on the MINT representations of the messages. <p> Specialized Transports Because Flick is a toolkit, it is straightforward to implement back ends that take advantage of special features of a particular transport system. For example, Flick's Mach 3 back end allows stubs to communicate out-of-band data [20] and Flick's Fluke <ref> [10] </ref> back end produces stubs that communicate data between clients and servers in machine registers. A Fluke client stub stores the first several words of the message in a particular set of registers; small messages fit completely within the register set.
Reference: [11] <author> GOKHALE, A. </author> <type> Personal communication, </type> <month> Mar. </month> <year> 1997. </year>
Reference-contexts: The authors optimized the interpreter and thereby increased throughput over an ATM network by factors of 1.8 to 5 for a range of data types. Their implementation achieved throughput comparable to that of commercial CORBA systems that utilize compiled stubs, including ORBeline <ref> [11] </ref>. However, since Flick-generated stubs typically greatly outperform stubs produced by ORBeline, Flick must also outperform the best current interpretive marshalers.
Reference: [12] <author> GOKHALE, A., AND SCHMIDT, D. C. </author> <title> Measuring the performance of communication middleware on high-speed networks. Computer Communication Review 26, </title> <address> 4 (Oct. </address> <year> 1996). </year>
Reference-contexts: Today's IDL compilers still assume that the transport medium is inherently slow, and therefore, that optimization of the stubs will not yield significant speed increases. Modern network architectures, however, have moved the performance bottlenecks for distributed applications out of the operating system layers and into the applications themselves <ref> [5, 12, 13] </ref>. In this paper we show that in order to solve the problems inherent to existing IDL compilers, IDL compilation must evolve from an ad hoc process to a principled process incorporating techniques that are already well-established in the traditional programming language community. <p> As expected, Flick-generated stubs process integer arrays more quickly than structure arrays because Flick performs its memcpy optimization only for arrays of atomic types. ORBeline stubs use scatter/gather I/O in order to transmit arrays of integers and thereby avoid conventional marshaling <ref> [12] </ref>; this is why data for ORBeline's performance over integer arrays are missing from Figure 3. <p> As measured by the widely available ttcp benchmark program, the maximum effective bandwidth of our 100Mbps Ethernet link is 70Mbps and the maximum bandwidth of our Myrinet link is just 84.5Mbps. These low measurements are due to the performance limitations imposed by the operating system's low-level protocol layers <ref> [12] </ref>. Through calculations based on these numbers and measured memory bandwidth, we have confirmed that the difference between ttcp throughput and the performance of Flick stubs is entirely due to the functional requirement to marshal and unmarshal message data which requires memory-to-memory copying and is thus limited by memory bandwidth. <p> They emphasized the importance of optimizing the presentation layer of a protocol stack and showed that it often dominates processing time. Recent work by Schmidt et al. <ref> [12, 21] </ref> has quantified this problem for rpcgen and two commercial CORBA implementations. On average, due to inefficiencies at the presentation and transport layers, compiler-generated stubs achieved only 16-80% of the throughput of hand-coded stubs.
Reference: [13] <author> GOKHALE, A., AND SCHMIDT, D. C. </author> <title> Optimizing the performance of the CORBA Internet Inter-ORB Protocol over ATM. </title> <type> Tech. Rep. </type> <institution> WUCS-97-09, Washington University Department of Computer Science, </institution> <address> St. Louis, MO, </address> <year> 1997. </year>
Reference-contexts: Today's IDL compilers still assume that the transport medium is inherently slow, and therefore, that optimization of the stubs will not yield significant speed increases. Modern network architectures, however, have moved the performance bottlenecks for distributed applications out of the operating system layers and into the applications themselves <ref> [5, 12, 13] </ref>. In this paper we show that in order to solve the problems inherent to existing IDL compilers, IDL compilation must evolve from an ad hoc process to a principled process incorporating techniques that are already well-established in the traditional programming language community. <p> By incorporating USC-style representations for all types, Flick could improve its existing copy optimizations as outlined in Section 3.2. Recently, Gokhale and Schmidt <ref> [13] </ref> addressed performance issues by optimizing SunSoft's reference implementation of IIOP [26]. The SunSoft IIOP implementation does not include an IDL compiler but instead relies on an interpreter to marshal and unmarshal data.
Reference: [14] <author> HOSCHKA, P., AND HUITEMA, C. </author> <title> Automatic generation of optimized code for marshalling routines. </title> <booktitle> In International Working Conference on Upper Layer Protocols, Architectures and Applications (Barcelona, </booktitle> <address> Spain, </address> <year> 1994), </year> <editor> M. Medina and N. Borenstein, Eds., </editor> <publisher> IFIP TC6/WG6.5, North-Holland, </publisher> <pages> pp. 131-146. </pages>
Reference-contexts: To address these and similar performance issues, several attempts have been made to improve the code generated by IDL compilers. Mach's MIG [20] compiler generates fast code but only by restricting the types that it can handle: essentially just scalars and arrays of scalars. Hoschka and Huitema <ref> [14] </ref> studied the tradeoffs between (large, fast) compiled stubs and (small, slow) interpreted stubs and suggested that an optimizing IDL compiler should use both techniques in order to balance the competing demands of throughput and stub code size.
Reference: [15] <author> JANSSEN, B., AND SPREITZER, M. </author> <title> ILU 2.0alpha8 Reference Manual. </title> <institution> Xerox Corporation, </institution> <month> May </month> <year> 1996. </year> <month> ftp://ftp.parc.xerox.com/pub/ilu/ilu.html. </month>
Reference-contexts: Although Flick's explicit representation for C language constructs is ordinary in comparison to the intermediate representations used by traditional language compilers, it is unique in comparison to traditional IDL compilers because most IDL compilers including rpcgen and ILU <ref> [15] </ref> maintain no explicit representations of the code that they produce. 2.2.3 PRES: The Message Presentation PRES, the third and final component of PRES C, defines the mapping between the message formats defined in MINT and the target language-specific, application-level formats defined in CAST. <p> Their implementation achieved throughput comparable to that of commercial CORBA systems that utilize compiled stubs, including ORBeline [11]. However, since Flick-generated stubs typically greatly outperform stubs produced by ORBeline, Flick must also outperform the best current interpretive marshalers. In the area of flexible IDL compilers, the Inter-Language Unification <ref> [15] </ref> (ILU) system from Xerox PARC emphasizes support for many target languages, supporting C, C++, Modula-3, Python, and Common Lisp. However, like most IDL compilers, ILU uses as its sole intermediate representation a simple AST directly derived from the IDL input file.
Reference: [16] <author> MCVOY, L., AND STAELIN, C. lmbench: </author> <title> Portable tools for performance analysis. </title> <booktitle> In Proc. of 1996 USENIX Conf. </booktitle> <month> (Jan. </month> <year> 1996). </year>
Reference-contexts: Our host for the MIG tests was a 100MHz Pentium with an 8K/8K (I/D 2/2 assoc) L1 cache, a 512K direct-mapped L2 cache, both write-back, and 16MB of DRAM, running CMU Mach 3. It had copy/read/write bandwidths of 36/62/82MBps. All memory bandwidth tests were performed using lmbench 1.1 <ref> [16] </ref>, and all throughput measurements were performed with the operating system socket queue size set to 64K. test compares equivalent marshaling functions and avoids any transport-related bottlenecks. The performance ratios are similar when the tests are performed on a little endian (Pentium) architecture.
Reference: [17] <author> NETBULA, </author> <note> LLC. PowerRPC, Version 1.0, 1996. http://www.netbula.com/products/powerrpc/. </note>
Reference-contexts: The different IDL compilers are summarized in Table 3. The first compiler, Sun's rpcgen, is in widespread use. PowerRPC <ref> [17] </ref> is a 5 A future version of Flick will produce iterative marshal and unmarshal code for tail-recursive data encodings in the marshal buffer. 8 new commercial compiler derived from rpcgen.
Reference: [18] <author> OBJECT MANAGEMENT GROUP. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.0 ed., </editor> <month> July </month> <year> 1995. </year>
Reference-contexts: An IDL specification declares one or more interfaces; each interface declares a set of operations that may be invoked on objects implementing the interface. The input and output behavior of each operation is given by the IDL specification. For example, the following CORBA <ref> [18] </ref> IDL program declares a simple interface to an electronic mail service: interface Mail - void send (in string msg); -; A largely equivalent mail system interface would be defined in the ONC RPC 1 [23] IDL by this program: program Mail - version MailVers - void send (string) = 1; <p> Flick, our Flexible IDL Compiler Kit, exploits this idea. Flick is designed as a toolkit of reusable components that may be specialized for particular IDLs, target language mappings, data encodings, and transport mechanisms. Flick currently has front ends that parse the CORBA <ref> [18] </ref>, ONC RPC [23], and MIG [20] IDLs. Flick compiles an interface specification in any of these languages through a series of intermediate representations to produce CORBA-, rpcgen-, or MIG-style C stubs communicating via TCP, UDP, Mach [1] messages, or Fluke [10] kernel IPC. <p> A single presentation generator can process AOI files that were derived from several different IDLs. 3 Flick currently has two presentation generators that read AOI files: one that implements the C mapping specified by CORBA <ref> [18] </ref> and a second that implements the C mapping defined by Sun Microsystems' rpcgen program [25]. Each of these presentation generators outputs its presentations in an intermediate representation called PRES C (Presentation in C). <p> Each of Flick's C back ends supports a different communication subsystem: the first implements the CORBA IIOP (Internet Inter-ORB Protocol) <ref> [18] </ref> on top of TCP; the second sends ONC RPC messages [23, 24] over TCP or UDP; the third supports MIG-style typed messages sent between Mach 3 ports; and the fourth imple ments a special message format for the fast Fluke kernel IPC facility [10].
Reference: [19] <author> O'MALLEY, S., PROEBSTING, T. A., AND MONTZ, A. B. </author> <title> USC: A universal stub compiler. </title> <booktitle> In Proceedings of the Conference on Communications Architectures, Protocols and Applications (SIGCOMM) (Lon-don, </booktitle> <address> UK, </address> <month> Aug. </month> <year> 1994), </year> <pages> pp. 295-306. </pages>
Reference-contexts: A more flexible copy optimizer that allows for byte swapping and word copying of other aggregate types similar to the optimizer in USC <ref> [19] </ref> will be implemented in a future version of Flick. Even when an object cannot be copied with memcpy, Flick performs an optimization to speed component-by-component copying. As part of the analysis performed for optimizing marshal buffer allocation described above, Flick identifies portions of the message that have fixed layouts. <p> However, their experimental results appear to apply only to the extraordinarily expensive type representations used in ASN.1, in which type encoding is dynamic even for fundamental scalar types such as integers. Of more relevance to commonly used representations is the Universal Stub Compiler (USC) work by O'Malley et al. <ref> [19] </ref>. USC does an excellent job of optimizing copying based on a user-provided specification of the byte-level representations of data types.
Reference: [20] <institution> OPEN SOFTWARE FOUNDATION AND CARNEGIE MELLON UNIVERSITY. </institution> <type> Mach 3 Server Writer's Guide. </type> <address> Cambridge, MA, </address> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: For performance critical applications, implementors resorted to hand-coded stubs tolerating the accompanying greater software engineering costs. Some IDL compilers such as MIG <ref> [20] </ref> struck a middle ground by providing a language with a restricted set of structured data types, blended with programmer control over implementation details. This compromise could be likened to that provided by a traditional compiler that permits embedded assembly language. <p> Flick, our Flexible IDL Compiler Kit, exploits this idea. Flick is designed as a toolkit of reusable components that may be specialized for particular IDLs, target language mappings, data encodings, and transport mechanisms. Flick currently has front ends that parse the CORBA [18], ONC RPC [23], and MIG <ref> [20] </ref> IDLs. Flick compiles an interface specification in any of these languages through a series of intermediate representations to produce CORBA-, rpcgen-, or MIG-style C stubs communicating via TCP, UDP, Mach [1] messages, or Fluke [10] kernel IPC. <p> Flick's MIG front end, however, is a special case. A MIG interface definition contains constructs that are applicable only to the C language and to the Mach message and IPC systems <ref> [20] </ref>. Therefore, as illustrated in Figure 1, Flick's MIG front end is conjoined with a special MIG presentation generator that understands these idioms. Flick's MIG components translate MIG interface descriptions directly into PRES C representations; this is different than Flick's CORBA and ONC RPC front ends, which produce AOI. <p> Specialized Transports Because Flick is a toolkit, it is straightforward to implement back ends that take advantage of special features of a particular transport system. For example, Flick's Mach 3 back end allows stubs to communicate out-of-band data <ref> [20] </ref> and Flick's Fluke [10] back end produces stubs that communicate data between clients and servers in machine registers. A Fluke client stub stores the first several words of the message in a particular set of registers; small messages fit completely within the register set. <p> On average, due to inefficiencies at the presentation and transport layers, compiler-generated stubs achieved only 16-80% of the throughput of hand-coded stubs. To address these and similar performance issues, several attempts have been made to improve the code generated by IDL compilers. Mach's MIG <ref> [20] </ref> compiler generates fast code but only by restricting the types that it can handle: essentially just scalars and arrays of scalars.
Reference: [21] <author> SCHMIDT, D. C., HARRISON, T., AND AL-SHAER, E. </author> <title> Object-oriented components for high-speed network programming. </title> <booktitle> In Proceedings of the First Conference on Object-Oriented Technologies and Systems (Mon-terey, </booktitle> <address> CA, June 1995), </address> <publisher> USENIX. </publisher>
Reference-contexts: They emphasized the importance of optimizing the presentation layer of a protocol stack and showed that it often dominates processing time. Recent work by Schmidt et al. <ref> [12, 21] </ref> has quantified this problem for rpcgen and two commercial CORBA implementations. On average, due to inefficiencies at the presentation and transport layers, compiler-generated stubs achieved only 16-80% of the throughput of hand-coded stubs.
Reference: [22] <author> SHAO, Z., AND APPEL, A. </author> <title> A type-based compiler for standard ML. </title> <booktitle> In Proc. ACM SIGPLAN Symp. on Programming Language Design and Implementation (June 1995), </booktitle> <pages> pp. 116-129. </pages>
Reference-contexts: Finally, several techniques used by Flick are similar or analogous to those in traditional compilers for general purpose programming languages. In addition, it appears that our work has many similarities to type-based representation analysis <ref> [22] </ref> directed to achieving more efficient unboxed data representations whenever possible, and to convert between such representations. 6 Conclusion This work exploits the fundamental and overdue recognition that interface definition languages are indeed programming languages, albeit specialized and non-traditional in their computational content.
Reference: [23] <author> SRINIVASAN, R. </author> <title> RPC: Remote procedure call protocol specification version 2. </title> <type> Tech. Rep. RFC 1831, </type> <institution> Sun Microsystems, Inc., </institution> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: For example, the following CORBA [18] IDL program declares a simple interface to an electronic mail service: interface Mail - void send (in string msg); -; A largely equivalent mail system interface would be defined in the ONC RPC 1 <ref> [23] </ref> IDL by this program: program Mail - version MailVers - void send (string) = 1; - = 1; As shown by these examples, an IDL program declares a set of functions or methods but does not describe the computations that those functions and methods perform. <p> Flick, our Flexible IDL Compiler Kit, exploits this idea. Flick is designed as a toolkit of reusable components that may be specialized for particular IDLs, target language mappings, data encodings, and transport mechanisms. Flick currently has front ends that parse the CORBA [18], ONC RPC <ref> [23] </ref>, and MIG [20] IDLs. Flick compiles an interface specification in any of these languages through a series of intermediate representations to produce CORBA-, rpcgen-, or MIG-style C stubs communicating via TCP, UDP, Mach [1] messages, or Fluke [10] kernel IPC. <p> Each of Flick's C back ends supports a different communication subsystem: the first implements the CORBA IIOP (Internet Inter-ORB Protocol) [18] on top of TCP; the second sends ONC RPC messages <ref> [23, 24] </ref> over TCP or UDP; the third supports MIG-style typed messages sent between Mach 3 ports; and the fourth imple ments a special message format for the fast Fluke kernel IPC facility [10].
Reference: [24] <author> SRINIVASAN, R. XDR: </author> <title> External data representation standard. </title> <type> Tech. Rep. RFC 1832, </type> <institution> Sun Microsystems, Inc., </institution> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: Each of Flick's C back ends supports a different communication subsystem: the first implements the CORBA IIOP (Internet Inter-ORB Protocol) [18] on top of TCP; the second sends ONC RPC messages <ref> [23, 24] </ref> over TCP or UDP; the third supports MIG-style typed messages sent between Mach 3 ports; and the fourth imple ments a special message format for the fast Fluke kernel IPC facility [10].
Reference: [25] <author> SUN MICROSYSTEMS, INC. </author> <title> ONC+ Developer's Guide, </title> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: Today, in almost every respect, IDL compilers lag behind traditional language compilers in terms of flexibility and optimization. IDL compilers such as Sun's rpcgen <ref> [25] </ref> are generally written from scratch and are implemented without incorporating modern compiler technologies such as multiple, flexible intermediate representations. <p> A single presentation generator can process AOI files that were derived from several different IDLs. 3 Flick currently has two presentation generators that read AOI files: one that implements the C mapping specified by CORBA [18] and a second that implements the C mapping defined by Sun Microsystems' rpcgen program <ref> [25] </ref>. Each of these presentation generators outputs its presentations in an intermediate representation called PRES C (Presentation in C).
Reference: [26] <institution> SUNSOFT, INC. SunSoft Inter-ORB Engine, Release 1.1, </institution> <month> June </month> <year> 1995. </year> <note> ftp://ftp.omg.org/pub/ interop/iiop.tar.Z. 13 </note>
Reference-contexts: By incorporating USC-style representations for all types, Flick could improve its existing copy optimizations as outlined in Section 3.2. Recently, Gokhale and Schmidt [13] addressed performance issues by optimizing SunSoft's reference implementation of IIOP <ref> [26] </ref>. The SunSoft IIOP implementation does not include an IDL compiler but instead relies on an interpreter to marshal and unmarshal data. The authors optimized the interpreter and thereby increased throughput over an ATM network by factors of 1.8 to 5 for a range of data types.
References-found: 26

