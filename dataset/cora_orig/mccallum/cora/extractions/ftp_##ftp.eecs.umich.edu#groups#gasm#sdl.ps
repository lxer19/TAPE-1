URL: ftp://ftp.eecs.umich.edu/groups/gasm/sdl.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: glaesser@uni-paderborn.de)  Rene.Karges@metronet.de)  
Title: Abstract State Machine Semantics of SDL  
Author: Uwe Glasser Rene Karges 
Address: Germany  Koln, Germany  
Affiliation: (Heinz Nixdorf Institut Universitat-GH Paderborn,  (metronet GmbH  
Abstract: Based on the ITU-T Recommendation Z.100 [27]|also known as SDL-92| we define a formal semantic model of the dynamic properties of Basic SDL in terms of an abstract SDL machine. More precisely, we use the concept of multi-agent real-time ASM [17] as a semantic platform on top of which we construct our mathematical description. The resulting interpretation model is not only mathematically precise but also reflects the common understanding of SDL in a direct and intuitive manner; it provides a concise and understandable representation of the complete dynamic semantics of Basic SDL. Moreover, the model can easily be extended and modified|a particularly important issue for an evolving technical standard. In this article, we consider all relevant aspects concerning the behavior of channels, processes and timers with respect to signal transfer operations and timer operations. The model we obtain is intended as a basis for formal documentation as well as for executable high-level SDL specifications. Key Words: SDL, Basic SDL, Semantic Foundations, Telecommunication Systems, Formal Documentation, Executable Specifications, Abstract State Machines Category: C.2.1, C.2.4, D.2.1, D.3.1, D.3.3, F.3.2 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Ch. Beierle, E. Borger, I. D - urd -anovic, U. Glasser, and E. Riccobene. </author> <title> Refining abstract machine specifications of the steam boiler control to well documented executable code. </title> <editor> In J.-R. Abrial, E. Borger, and H. Langmaack, editors, </editor> <title> Formal Methods for Industrial Applications: Specifying and Programming the Steam Boiler Control, </title> <booktitle> volume 1165 of LNCS (State-of-the-Art Survey), </booktitle> <pages> pages 52-78. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: of the underlying machine model constitutes a simple yet powerful formal basis to deal with concurrent and reactive behavior in a direct and intuitive way; the fact that ASM-based system models naturally enable operational interpretations is often considered as an advantage when dealing with complex technical systems (e.g., as in <ref> [1, 5, 4] </ref>) 1 We present here a formal semantic model of Basic SDL as defined in (Chap. 2 of) the ITU-T Recommendation Z.100 [27]|also referred to as SDL-92.
Reference: 2. <author> F. Belina, D. Hogrefe, and A. Sarma. </author> <title> SDL with Applications from Protocol Specification. </title> <publisher> Carl Hanser Verlag / Prentice Hall International, </publisher> <year> 1991. </year>
Reference-contexts: Journal of Universal Computer Science, vol. 3, no. 12 (1997), 1382-1414 submitted: 25/6/97, accepted: 26/11/97, appeared: 28/12/97 Springer Pub. Co. literature <ref> [25, 13, 2] </ref>) in a direct and intuitive manner.
Reference: 3. <author> J. A. Bergstra and C. A. Middleburg. </author> <title> Process Algebra Semantics of 'SDL. </title> <type> Technical Report UNU/IIST Report No. 68, </type> <institution> UNU/IIST, The United Nations University, </institution> <month> April </month> <year> 1996. </year>
Reference-contexts: In fact, there is a considerable variety of formal semantic models of SDL, which have been developed using various formal methods. Among the approaches which are mainly concerned with analysis and verification of SDL specifications are the following. In <ref> [3] </ref>, Bergstra and Middleburg define a process algebra semantics of a restricted version of SDL, which they call 'SDL. Broy [10], Holz and Sttlen [21] use the stream processing functions of FOCUS to model subsets of SDL.
Reference: 4. <author> E. Borger and U. Glasser. </author> <title> A formal specification of the PVM architecture. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> Proc. of the IFIP 13th World Computer Congress 1994, Volume I: Technology and Foundations, </booktitle> <pages> pages 402-409. </pages> <publisher> Elsevier Science Publishers B. V., </publisher> <year> 1994. </year> <note> 1412 Glaesser U., </note> <author> Karges R.: </author> <title> Abstract State Machine Semantics of SDL </title>
Reference-contexts: of the underlying machine model constitutes a simple yet powerful formal basis to deal with concurrent and reactive behavior in a direct and intuitive way; the fact that ASM-based system models naturally enable operational interpretations is often considered as an advantage when dealing with complex technical systems (e.g., as in <ref> [1, 5, 4] </ref>) 1 We present here a formal semantic model of Basic SDL as defined in (Chap. 2 of) the ITU-T Recommendation Z.100 [27]|also referred to as SDL-92.
Reference: 5. <author> E. Borger, U. Glasser, and W. Mueller. </author> <title> Formal definition of an abstract VHDL'93 simulator by EA-machines. </title> <editor> In C. Delgado Kloos and P.T. Breuer, editors, </editor> <booktitle> Semantics of VHDL, volume 307 of The Kluwer International Series in Engineering and Computer Science. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference-contexts: of the underlying machine model constitutes a simple yet powerful formal basis to deal with concurrent and reactive behavior in a direct and intuitive way; the fact that ASM-based system models naturally enable operational interpretations is often considered as an advantage when dealing with complex technical systems (e.g., as in <ref> [1, 5, 4] </ref>) 1 We present here a formal semantic model of Basic SDL as defined in (Chap. 2 of) the ITU-T Recommendation Z.100 [27]|also referred to as SDL-92. <p> Our formal definition provides a concise yet understandable model, which can easily be extended and modified|this flexibility is particularly important for an evolving technical standard. In that respect the work presented here is comparable to our semantic model of the hardware description language VHDL <ref> [6, 5] </ref>. Furthermore, the model we obtain provides an excellent basis for mechanizing SDL specifications, e.g. as required for machine supported analysis and transformation or the execution and animation of high-level SDL specifications. Formal Semantics of SDL. <p> The complete model (without the initial state definition) has about double the size of the one given here. An obvious way of extending the current model is to include the full structuring facilities of SDL. Based on our experience with VHDL <ref> [5] </ref>, which offers structuring concepts similar to block partitioning in SDL, we can state that this does not cause any real problems. It should also be mentioned that we have tools to run ASM models on real machines [12, 11].
Reference: 6. <author> E. Borger, U. Glasser, and W. Muller. </author> <title> The semantics of behavioral VHDL'92 descriptions. </title> <booktitle> In Proc. </booktitle> <address> of EURO-VHDL'94 (September 19-20, Grenoble), </address> <year> 1994. </year>
Reference-contexts: Our formal definition provides a concise yet understandable model, which can easily be extended and modified|this flexibility is particularly important for an evolving technical standard. In that respect the work presented here is comparable to our semantic model of the hardware description language VHDL <ref> [6, 5] </ref>. Furthermore, the model we obtain provides an excellent basis for mechanizing SDL specifications, e.g. as required for machine supported analysis and transformation or the execution and animation of high-level SDL specifications. Formal Semantics of SDL.
Reference: 7. <author> E. Borger and L. Mearelli. </author> <title> Integrating ASMs into the software development life cycle. </title> <journal> Journal of Universal Computer Science (J.UCS), </journal> <volume> 3(5) </volume> <pages> 603-665, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: Journal of Universal Computer Science, vol. 3, no. 12 <ref> (1997) </ref>, 1382-1414 submitted: 25/6/97, accepted: 26/11/97, appeared: 28/12/97 Springer Pub. Co. literature [25, 13, 2]) in a direct and intuitive manner. <p> Finally, there is a more subtle class of functions in addition to the ones described above. To model interactions between a system and its environment it 4 We use here the terminology introduced in <ref> [7] </ref>, which is essentially based on the classification scheme defined in [9] (though the naming is different). 1385Glaesser U., Karges R.: Abstract State Machine Semantics of SDL is sometimes required to have functions which are partly controlled and partly monitored at the same time (as will be exemplified in Sect. 3.1.3).
Reference: 8. <author> E. Borger, I. D - urd -anovic, and D. Rosenzweig. </author> <title> Occam: Specification and compiler correctness. part i: The primary model. </title> <editor> In E.-R. Olderog, editor, </editor> <booktitle> Proc. of PRO-COMET'94 (IFIP Working Conference on Programming Concepts, Methods and Calculi), </booktitle> <pages> pages 489-508. </pages> <publisher> North-Holland, </publisher> <year> 1994. </year>
Reference-contexts: set of signals to be saved in state S are given through corresponding functions inputset and saveset. 27 The idea of modeling control flow by means of flowcharts is of course not new; similar concepts have for instance been applied in ASM-based semantic models of various other languages (e.g., Occam <ref> [8] </ref> and C [16]). 1401Glaesser U., Karges R.: Abstract State Machine Semantics of SDL Finally, there are operations on flowcharts that allow to switch between the individual flowcharts within the collection of flowcharts associated with a process agent.
Reference: 9. <author> Egon Borger. </author> <title> Why use evolving algebras for hardware and software engineering? In Proc. </title> <booktitle> of SOFSEM'95, volume 1012 of LNCS, </booktitle> <pages> pages 236-271. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: For a rigorous mathematical definition of the semantic foundations of ASMs, we however refer to [19] and [20]. A comprehensive treatment of the methodological background on ASM-based modeling, validation and verification of complex systems can be found in <ref> [9] </ref>. 2.1 The Basic ASM Model An ASM A is defined by its program Prog consisting of a finite number of transition rules and its initial state S 0 . <p> Finally, there is a more subtle class of functions in addition to the ones described above. To model interactions between a system and its environment it 4 We use here the terminology introduced in [7], which is essentially based on the classification scheme defined in <ref> [9] </ref> (though the naming is different). 1385Glaesser U., Karges R.: Abstract State Machine Semantics of SDL is sometimes required to have functions which are partly controlled and partly monitored at the same time (as will be exemplified in Sect. 3.1.3). These are called interaction functions.
Reference: 10. <author> Manfred Broy. </author> <title> Towards a Formal Foundation of the Specification and Description Language SDL. </title> <journal> Formal Aspects of Computing 3, </journal> (3):21-57, 1991. 
Reference-contexts: Among the approaches which are mainly concerned with analysis and verification of SDL specifications are the following. In [3], Bergstra and Middleburg define a process algebra semantics of a restricted version of SDL, which they call 'SDL. Broy <ref> [10] </ref>, Holz and Sttlen [21] use the stream processing functions of FOCUS to model subsets of SDL. Fischer and Dimitrov propose extended Petri nets as a formal basis to verify SDL protocol specifications [14]. Rinderspacher employs a term-rewriting system based modeling concept [26].
Reference: 11. <author> G. Del Castillo, I. D - urd -anovic and U. Glasser. </author> <title> An evolving algebra abstract machine. </title> <editor> In H. Kleine Buning, editor, </editor> <booktitle> Computer Science Logic, volume 1092 of LNCS, </booktitle> <pages> pages 191-214. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Based on our experience with VHDL [5], which offers structuring concepts similar to block partitioning in SDL, we can state that this does not cause any real problems. It should also be mentioned that we have tools to run ASM models on real machines <ref> [12, 11] </ref>. Provided that the details which we left abstract in our SDL model (this mainly concerns interfaces to the external environment) are handled properly (e.g., by specifying them through user inputs, external processes etc.), we are able to produce an executable version of our SDL model.
Reference: 12. <author> Giuseppe Del Castillo. ASM-SL, </author> <title> a Specification Language based on Gurevich's Abstract State Machines: Introduction and Tutorial. </title> <note> Technical Report (to appear). </note>
Reference-contexts: Based on our experience with VHDL [5], which offers structuring concepts similar to block partitioning in SDL, we can state that this does not cause any real problems. It should also be mentioned that we have tools to run ASM models on real machines <ref> [12, 11] </ref>. Provided that the details which we left abstract in our SDL model (this mainly concerns interfaces to the external environment) are handled properly (e.g., by specifying them through user inputs, external processes etc.), we are able to produce an executable version of our SDL model.
Reference: 13. <author> O. Frgemand and A. Olsen. </author> <title> Introduction to SDL-92. </title> <journal> Computer Networks and ISDN Systems, </journal> (26):1143-1167, 1994. 
Reference-contexts: Journal of Universal Computer Science, vol. 3, no. 12 (1997), 1382-1414 submitted: 25/6/97, accepted: 26/11/97, appeared: 28/12/97 Springer Pub. Co. literature <ref> [25, 13, 2] </ref>) in a direct and intuitive manner.
Reference: 14. <author> J. Fischer and E. Dimitrov. </author> <title> Verification of SDL Protocol Specifications using Extended Petri Nets. </title> <booktitle> In Proc. of the Workshop on Petri Nets and Protocols of the 16th Intern. Conf. on Application and Theory of Petri Nets, </booktitle> <pages> pages 1-12. </pages> <address> Torino, Italy, </address> <year> 1995. </year>
Reference-contexts: Broy [10], Holz and Sttlen [21] use the stream processing functions of FOCUS to model subsets of SDL. Fischer and Dimitrov propose extended Petri nets as a formal basis to verify SDL protocol specifications <ref> [14] </ref>. Rinderspacher employs a term-rewriting system based modeling concept [26]. Some of these approaches consider only a relatively small subset of SDL ignoring certain essential features (e.g., dynamic process creation or basic structuring concepts).
Reference: 15. <author> J. Fischer, St. Lau, and A. Prinz. </author> <title> A Short Note About BSDL Semantic Issues for SDL. </title> <journal> SDL Newsletter, </journal> <volume> (18), </volume> <month> January </month> <year> 1995. </year>
Reference-contexts: An approach aiming at a more comprehensive semantic model of SDL is provided by Fischer, Lau and Prinz through their definition of BSDL (Base SDL) using Object-Z <ref> [15, 24] </ref>. This work is organized as follows. Section 2 briefly introduces the basic concepts and notions of Abstract State Machines, including the employed model of real time, as far as these are required here.
Reference: 16. <author> Y. Gurevich and J. Huggins. </author> <title> The semantics of the C programming language. </title> <editor> In E. Borger, H. Kleine Buning, G. Jager, S. Martini, and M. M. Richter, editors, </editor> <booktitle> Computer Science Logic, volume 702 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: to be saved in state S are given through corresponding functions inputset and saveset. 27 The idea of modeling control flow by means of flowcharts is of course not new; similar concepts have for instance been applied in ASM-based semantic models of various other languages (e.g., Occam [8] and C <ref> [16] </ref>). 1401Glaesser U., Karges R.: Abstract State Machine Semantics of SDL Finally, there are operations on flowcharts that allow to switch between the individual flowcharts within the collection of flowcharts associated with a process agent.
Reference: 17. <author> Y. Gurevich and J. Huggins. </author> <title> The railroad crossing problem: An experiment with instantaneous actions and immediate reactions. </title> <editor> In H. Kleine Buning, editor, </editor> <booktitle> Computer Science Logic, volume 1092 of LNCS, </booktitle> <pages> pages 266-290. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: To model the dynamic properties of SDL, including timing behavior, we apply the concept of real-time ASMs as defined by Gurevich and Huggins in <ref> [17] </ref>. Real-time ASMs impose additional constraints on the notion of run and thereby provide a restricted class of ASMs with agents performing instantaneous actions in continuous time. For the purpose considered here, it is important that agents fire their rules at the moment they are enabled. <p> Intuitively, that means that an agent fires a rule as soon as the enabling condition expressed by the guard of the rule becomes true. Strictly speaking, one has to be more careful about the precise meaning of `immediate' (as explained in <ref> [17] </ref>). Nevertheless, we can assume here that an agent which is enabled at time t to fire a certain rule actually fires the rule not later than t + * (for some infinitely small *). By adding further constraints on how basic functions evolve, the model in [17] is such that <p> (as explained in <ref> [17] </ref>). Nevertheless, we can assume here that an agent which is enabled at time t to fire a certain rule actually fires the rule not later than t + * (for some infinitely small *). By adding further constraints on how basic functions evolve, the model in [17] is such that internal updates (as performed by the agents) and external updates (as performed by the environment) do not interfere. 7 According to [25], time supervision in telecommunication systems is typically used for purposes such as the following: to control the release of limited resources, to control answers from
Reference: 18. <author> Yuri Gurevich. </author> <title> Evolving algebras a tutorial introduction. </title> <journal> Bulletin of the EATCS, </journal> (43):264-284, February 1991. 
Reference-contexts: 1 Introduction Abstract State Machines (ASMs)|formerly called Evolving Algebras <ref> [18, 19] </ref>| combine declarative concepts of first-order logic with the operational view of transition systems in a common framework for mathematical modeling of discrete dynamic systems.
Reference: 19. <author> Yuri Gurevich. </author> <title> Evolving Algebra 1993: Lipari Guide. </title> <editor> In E. Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 9-36. </pages> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: 1 Introduction Abstract State Machines (ASMs)|formerly called Evolving Algebras <ref> [18, 19] </ref>| combine declarative concepts of first-order logic with the operational view of transition systems in a common framework for mathematical modeling of discrete dynamic systems. <p> The particular focus is on the specific ASM model that will be employed for the construction of our SDL model. For a rigorous mathematical definition of the semantic foundations of ASMs, we however refer to <ref> [19] </ref> and [20]. <p> The construction of complex transition rules out of basic update instructions is inductively defined by means of ASM rule constructors. For brevity, we explain the meaning of ASM rules as employed in the abstract machine model of SDL (see Sect. 3) only informally and refer to <ref> [19] </ref> resp. [20] for a rigorous semantic definition. <p> The underlying semantic model ensures (by restricting the class of admissible runs of A) that the order in which the agents perform their operations is always such that no conflicts arise (for details see the definition of partially ordered runs in <ref> [19] </ref>). 5 Formally, the meaning of the notion of multi-agent ASM, as it is used here, is identical with the meaning of distributed ASM as defined in [19] (where the term distributed actually refers to the distribution of control rather than to the distribution of data). 6 Note that Mod allows <p> which the agents perform their operations is always such that no conflicts arise (for details see the definition of partially ordered runs in <ref> [19] </ref>). 5 Formally, the meaning of the notion of multi-agent ASM, as it is used here, is identical with the meaning of distributed ASM as defined in [19] (where the term distributed actually refers to the distribution of control rather than to the distribution of data). 6 Note that Mod allows to define (or to redefine) the behavior of agents dynamically; it is thereby possible to create new agents at run time.
Reference: 20. <author> Yuri Gurevich. </author> <title> ASM Guide 97. </title> <type> CSE Technical Report CSE-TR-336-97, </type> <institution> EECS Department, University of Michigan-Ann Arbor, </institution> <year> 1997. </year>
Reference-contexts: The particular focus is on the specific ASM model that will be employed for the construction of our SDL model. For a rigorous mathematical definition of the semantic foundations of ASMs, we however refer to [19] and <ref> [20] </ref>. <p> The construction of complex transition rules out of basic update instructions is inductively defined by means of ASM rule constructors. For brevity, we explain the meaning of ASM rules as employed in the abstract machine model of SDL (see Sect. 3) only informally and refer to [19] resp. <ref> [20] </ref> for a rigorous semantic definition. <p> The resulting description forms the Process Module of the abstract machine model. 24 Note that a choose-construct does not affect the ASM state if the underlying set is empty (i.e., in that case the subrule in the body of the choose-construct is simply ignored see <ref> [20] </ref>). 25 Here arises an interesting question, which is not completely answered by the definitions of Z.100: does the fact that the environment may continue to send signals to an SDL system even when no process instances are left mean that such a system still has a behavior? 26 See [22] <p> The intuitive meaning of this operation is obvious and requires actually no further explanation. (For a formal treatment of the semantics of the extend-construct see <ref> [20] </ref>.) 1404 Glaesser U., Karges R.: Abstract State Machine Semantics of SDL 2. the specified destination is a process instance which does not exsist; 3. the specified destination is a process instance set which is empty.
Reference: 21. <author> E. Holz and K. Sttlen. </author> <title> An Attempt to Embed a Restricted Version of SDL as a Target Language in Focus. </title> <editor> In St. Leue D. Hogrefe, editor, </editor> <booktitle> Proc. of Forte '94, </booktitle> <pages> pages 324-339. </pages> <publisher> Chapmann & Hall, </publisher> <year> 1994. </year>
Reference-contexts: Among the approaches which are mainly concerned with analysis and verification of SDL specifications are the following. In [3], Bergstra and Middleburg define a process algebra semantics of a restricted version of SDL, which they call 'SDL. Broy [10], Holz and Sttlen <ref> [21] </ref> use the stream processing functions of FOCUS to model subsets of SDL. Fischer and Dimitrov propose extended Petri nets as a formal basis to verify SDL protocol specifications [14]. Rinderspacher employs a term-rewriting system based modeling concept [26].
Reference: 22. <author> Rene Karges. </author> <title> Formale Semantik von SDL als abstraktes Zustandssystem. </title> <type> (Diploma thesis), </type> <institution> Fachbereich Mathematik-Informatik, Universitat-GH Paderborn, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: Instead, we introduce the employed encoding scheme abstractly by means of a mapping ` [[ ]] '. The basic idea is exemplified below (for a comprehensive treatment see also <ref> [22] </ref>). As a primitive example for the representation of syntactical objects consider the encoding of an SDL process definition. Assume that a process type named Server is to be defined. The initial number and the maximum number of process instances of type Server is 2 resp. 16. <p> [20]). 25 Here arises an interesting question, which is not completely answered by the definitions of Z.100: does the fact that the environment may continue to send signals to an SDL system even when no process instances are left mean that such a system still has a behavior? 26 See <ref> [22] </ref> for a thorough description of control flow related behavior. 1400 Glaesser U., Karges R.: Abstract State Machine Semantics of SDL 5.1 Modeling of Control Flow We model control flow through operations on transition diagrams, usually called flowcharts 27 . <p> For instance, in the encoding of a nextstate statement (terminating an SDL transition) a function stateloc yields the node and the flowchart to proceed with as illustrated in Fig. 7. As a primitive example of the interpretation scheme controlling the processing of flowcharts (as described in <ref> [22] </ref>) consider the following fragment for an output statement: case stmt (node (Self)) . . . output : OutputSignalInstance (args (node (Self))) node (Self) := next (node (Self)) . . . endcase where the rule OutputSignalInstance is defined in the Sect. 5.2 on signal output. 1402 Glaesser U., Karges R.: Abstract
Reference: 23. <author> P. W. Kutter and A. Pierantonio. </author> <title> Montages: Specifications of realistic programming languages. </title> <journal> Journal of Universal Computer Science, </journal> <volume> 3(5) </volume> <pages> 416-442, </pages> <year> 1997. </year>
Reference-contexts: Finally, there are existing ASM-based concepts and tools addressing modeling of static semantics <ref> [23] </ref>. Combining these approaches with our model will allow to produce a complete semantic model including all static and dynamic properties of SDL. Acknowledgements.
Reference: 24. <author> St. Lau and A. Prinz. BSDL: </author> <title> The Language Version 0.2. </title> <institution> Department of Computer Science, Humboldt University Berlin, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: An approach aiming at a more comprehensive semantic model of SDL is provided by Fischer, Lau and Prinz through their definition of BSDL (Base SDL) using Object-Z <ref> [15, 24] </ref>. This work is organized as follows. Section 2 briefly introduces the basic concepts and notions of Abstract State Machines, including the employed model of real time, as far as these are required here.
Reference: 25. <author> A. Olsen, O. Frgemand, B. Mtller-Pedersen, R. Reed, and J. R. W. Smith. </author> <title> Systems Engineering Using SDL-92. </title> <publisher> Elsevier Science B. V., </publisher> <year> 1994. </year> <editor> 1413Glaesser U., Karges R.: </editor> <title> Abstract State Machine Semantics of SDL </title>
Reference-contexts: Journal of Universal Computer Science, vol. 3, no. 12 (1997), 1382-1414 submitted: 25/6/97, accepted: 26/11/97, appeared: 28/12/97 Springer Pub. Co. literature <ref> [25, 13, 2] </ref>) in a direct and intuitive manner. <p> By adding further constraints on how basic functions evolve, the model in [17] is such that internal updates (as performed by the agents) and external updates (as performed by the environment) do not interfere. 7 According to <ref> [25] </ref>, time supervision in telecommunication systems is typically used for purposes such as the following: to control the release of limited resources, to control answers from unreliable resources, or to issue actions on a regular basis; whether the time constructs of SDL are sufficient for specific real-time requirements depends very much
Reference: 26. <author> Markus Rinderspacher. </author> <title> A Verification concept for SDL systems and its appli-cation to the Abracadabra Protocol. </title> <type> Interner Bericht 14/94, </type> <institution> Institut fur Logik, Komplexitat und Deduktionssysteme, Universitat Karlsruhe, </institution> <year> 1994. </year>
Reference-contexts: Broy [10], Holz and Sttlen [21] use the stream processing functions of FOCUS to model subsets of SDL. Fischer and Dimitrov propose extended Petri nets as a formal basis to verify SDL protocol specifications [14]. Rinderspacher employs a term-rewriting system based modeling concept <ref> [26] </ref>. Some of these approaches consider only a relatively small subset of SDL ignoring certain essential features (e.g., dynamic process creation or basic structuring concepts).
Reference: 27. <author> ITU-T Recommendation Z.100. </author> <title> Specification and Description Language (SDL). </title> <institution> International Telecommunication Union (ITU), Geneva, </institution> <note> 1994 + Addendum 1996. 1414 Glaesser U., </note> <author> Karges R.: </author> <title> Abstract State Machine Semantics of SDL </title>
Reference-contexts: Formal Semantics of SDL. Z.100 does already come together with a complete formal model of SDL based on a combination of Meta-IV and CSP (Annex F to <ref> [27] </ref>). However, the current situation is not really satisfying: "This annex constitutes a formal definition of SDL. <p> If any properties of an SDL concept defined in this document, contradicts the properties defined in Z.100 and the concept is consistently defined in Z.100, then the definition in Z.100 takes precedence and this formal definition requires correction." (Annex F1 to <ref> [27] </ref>, page 1) One reason why Z.100 does not rely on its own formal model is probably the fact that this model is hardly usable because of its size: the entire formal definition is more than 500 pages. <p> SDL provides four built-in operations on process identifiers: self, sender, offspring and parent (see Sect. 2.4.4 of <ref> [27] </ref>). We define analogous functions on PID, namely Self, sender, offspring and parent, each of which yields a corresponding PId value. <p> (if defined); offspring (p) identifies the process instance most recently created by p (if any); parent (p) yields the process instance that has created p. 15 13 The PId values of environment process instances must be distinguishable from any of the PId values within the system (see Sect. 1.3.2 of <ref> [27] </ref>). 14 The default meaning of the function Self in the multi-agent ASM model (see Sect. 2.2.1) actually coincides with the meaning of the SDL function self. 15 For all process instances present at system initialization, the predefined value of parent is null, and for all newly created process instances, the <p> model (see Sect. 2.2.1) actually coincides with the meaning of the SDL function self. 15 For all process instances present at system initialization, the predefined value of parent is null, and for all newly created process instances, the predefined value of sender and offspring is null (see Sect. 2.4.4 of <ref> [27] </ref>). 1390 Glaesser U., Karges R.: Abstract State Machine Semantics of SDL The relation between process instances and process types is defined through the following dynamic function procname : PID ! PROCESS: The use of formal parameters in the definition of processes allows to instantiate certain variables when creating process instances. <p> For instance, one can assume that time values increase monotonically. Concerning the behavior of channels, the following constraints are assumed (see Sect. 2.5.1 of <ref> [27] </ref>): (i) signal transfer via channels is reliable; (ii) the propagation of signals with respect to a given 17 There are no a priori given restrictions on the length (or size) of channel queues. 1393Glaesser U., Karges R.: Abstract State Machine Semantics of SDL channel is order-preserving; (iii) the time interval <p> Additionally, we assume that shorthand notations, e.g. as offered by the so-called additional concepts of Basic SDL (like RPC or continuous signal see Sect. 4 of <ref> [27] </ref>), have been eliminated by transforming them into equivalent primitive concepts. 1395Glaesser U., Karges R.: Abstract State Machine Semantics of SDL (where NAT denotes the domain of natural numbers). For brevity, the main part of the definition, as represented by the body of the process Server, is left out. <p> processes in the system environment is not explicitly addressed), we merely mention this path constructor for the sake of completeness and symmetry. 1397Glaesser U., Karges R.: Abstract State Machine Semantics of SDL obtains the so-called Reachability set 22 of a process instance set (see Sect. 6.4 of Annex F3 to <ref> [27] </ref>), which is required to define the signal output behavior (see Sect. 5.2). In general, a Reachability set may contain more than one communication path that is able to convey a certain signal to a specified destination. <p> For given arguments Pid, SName, ToArg, ViaArg the meaning of choose reachability is as 22 The computation of the Reachability sets is completely deterministic and can be carried out by means of a preprocessing step. Sect. 6.4 of Annex F3 to <ref> [27] </ref> describes an incremental construction procedure determining for each channel path and each signal route path of a system the corresponding Reachability set. <p> Basic SDL the situation is particularly simple because of the two-level hierarchy. 23 If an output statement does neither specify a receiver nor a communication path, any process instance of the system for which there exists a suitable communication path may actually receive the resulting signal (see Sect. 2.7.4 of <ref> [27] </ref>). 1398 Glaesser U., Karges R.: Abstract State Machine Semantics of SDL follows: choose reachability (Pid; SName; ToArg; ViaArg) = ( hp; ri; if 9 p 2 PATH 9 r 2 PROCESS [ fenvg : Reachable (p; r; Pid; SName; ToArg; ViaArg) hundef; undefi; otherwise; where Reachable represents a static predicate <p> Similarly, the nondeterministic choice does not necessarily yield a definite result 24 (since all instances of PName may already have terminated their execution). It is therefore to be checked prior to delivering SInst whether a valid receiver exists. Whenever no receiver exists, Z.100 assumes (see Sect. 2.7.4 of <ref> [27] </ref>) that the signal instance is discarded 25 . In our model there is however no need to discard SInst from SIGINST (what we could easily do) as it will not be referred to any further. <p> state additional constraints restricting the possible choices of receiver/path combinations. via all represents multicast and is actually an abbreviation used to send identical copies of a specified signal to all destinations 29 that can be reached (depending on the available paths) from a given process instance (see Sect. 2.7.4 of <ref> [27] </ref>); as such it can easily be transformed into a number of output statements in standard form as part of a preprocessing step and is therefore not further addressed here. <p> Recall that an output statement has no effect (i.e., does not generate a signal instance) in each of the following situations (see Sect. 2.7.4 of <ref> [27] </ref>): 1. a communication path able to convey a signal of the specified type to the matching destination does not exist; 29 In combination with the via all option an output statement must not specify any destination (neither a receiver process instance nor a process instance set). 30 To create a <p> In case of a spontaneous transition, sender refers to the process instance performing the spontaneous transition (see Sect. 2.6.6 of <ref> [27] </ref>). In addition to updating sender accordingly, the process agent switches to the node of his flowchart to proceed with, as identified through inputbranch (node (Self); none). <p> ASM agents representing timer instances are created dynamically at the moment a timer instance is referred to for the first time. In general, the first use of a timer may be a set operation as well as a reset operation (see Sect. 2.8 of <ref> [27] </ref>), set (T ime; TName (P arams)); reset (TName (P arams)); where T ime specifies a value of TIME, TName specifies a value of TIMER and P arams is an element from VALUE fl . <p> On receiving a timer signal the PId of the sender of that timer signal is defined to be the PId of the process instance that receives the timer signal (see Sect. 2.8 of <ref> [27] </ref>). In the definition of CreateTimerSignal below the value of owner (Self) (i.e., the PId of the owner process) thus identifies the sender of the timer signal s. <p> Furthermore, a timer may be set to a time value which is smaller or equal to the value of now having the effect that the timer expires immediately (see Sect. 2.8 of <ref> [27] </ref>). 1411Glaesser U., Karges R.: Abstract State Machine Semantics of SDL 7 Conclusions The mathematical modeling concept of multi-agent real-time ASM and the SDL view on asynchronously communicating systems clearly coincide with respect to essential properties of the underlying computation models.
References-found: 27

