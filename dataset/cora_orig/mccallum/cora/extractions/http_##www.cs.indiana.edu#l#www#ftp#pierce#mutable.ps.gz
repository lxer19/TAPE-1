URL: http://www.cs.indiana.edu/l/www/ftp/pierce/mutable.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/
Root-URL: http://www.cs.indiana.edu
Title: Mutable Objects  
Author: Benjamin C. Pierce 
Date: May 29, 1993  
Note: Working draft of  
Address: Edinburgh  
Affiliation: LFCS,  
Abstract: There are now several type-theoretic models for object-oriented languages based on higher-order polymorphic lambda-calculi [Bru92, Bru93, CCH + 89, CHC90, Mit90, PT93]. It has been claimed that these models can be extended straightforwardly to handle objects with mutable state. Following a suggestion of Didier Remy, we verify this claim for the model proposed in [PT93].
Abstract-found: 1
Intro-found: 1
Reference: [Bru92] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented language: Design, static typing and semantics. </title> <type> Technical Report CS-92-01, </type> <institution> Williams College, </institution> <month> January </month> <year> 1992. </year>
Reference: [Bru93] <author> Kim B. Bruce. </author> <title> Safe type checking in a statically typed object-oriented programming language. </title> <booktitle> In Proceedings of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference: [CCH + 89] <author> Peter Canning, William Cook, Walter Hill, Walter Olthoff, and John Mitchell. </author> <title> F-bounded quantification for object-oriented programming. </title> <booktitle> In Fourth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <month> September </month> <year> 1989. </year>
Reference: [CHC90] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year> <note> To appear in [GM93]. </note>
Reference-contexts: This deficiency, which seems to appear in most -calculus models of object-oriented programming, has also been pointed out by Wand [Wan89] and Cook, Hill, and Canning <ref> [CHC90] </ref>. Using the ordinary fixed point combinator at functional types that is found in call-by-value languages causes new to diverge in some cases.
Reference: [CM91] <author> Luca Cardelli and John Mitchell. </author> <title> Operations on records. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 1 </volume> <pages> 3-48, </pages> <year> 1991. </year> <note> To appear in [GM93]; also available as DEC Systems Research Center Research Report #48, </note> <month> August, </month> <year> 1989, </year> <booktitle> and in the proceedings of MFPS '89, </booktitle> <publisher> Springer LNCS volume 442. </publisher>
Reference-contexts: While this has the advantage of allowing the encoding of objects to be expressed in a more economical formal framework, it imposes a heavy burden in terms of readability and it does not correspond closely to real implementations. Again, well-known techniques involving extensible records <ref> [Wan87, Rem89, CM91, etc.] </ref> could be used here to obtain clearer | and perhaps more realistic | encodings.
Reference: [GM93] <author> Carl A. Gunter and John C. Mitchell. </author> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design. </title> <publisher> The MIT Press, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference: [Mit90] <author> John C. Mitchell. </author> <title> Toward a typed foundation for method specialization and inheritance. </title> <booktitle> In Proceedings of the 17th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-124, </pages> <month> January </month> <year> 1990. </year> <note> To appear in [GM93]. </note>
Reference: [PT93] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <note> 1993. To appear; a preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title "Object-Oriented Programming Without Recursive Types". </title>
Reference-contexts: 1 Overview <ref> [PT93] </ref> proposed a statically typed model of "functional-style" object-oriented programming, where an object responds to an updating message by returning a new, appropriately modified object. But, as others had noted in earlier papers, the extension to objects with mutable state was not completely straightforward. <p> references and a call-by-value evaluation strategy; this allows the type-correctness of the new encoding to be checked automatically, and gives us the chance to see some running examples. 1 2 A Call-By-Value Formulation of F ! This note develops a slightly modified version of the statically typed object model of <ref> [PT93] </ref> in which objects may behave either functionally | returning "updated copies of themselves" as the results of methods | or, as is more common in mainstream object-oriented languages, imperatively | destructively modifying their instance variables in response to update messages. <p> Since <ref> [PT93] </ref> treated the operational semantics of its F ! informally, there is no difficulty in substituting | again, informally | a call-by-value reduction order for the original call-by-name semantics. <p> type system remains identical to the call-by-name variant and that this kind of change in evaluation order and addition of mutable storage cells are reasonably well understood for numerous related calculi. 3 Development From now on, I will assume that the reader is familiar with the encoding of objects in <ref> [PT93] </ref>, to which I also defer for the definition of the F ! . Most readers will probably want to skim the technical development here or simply jump to the next section for some examples. The only important point to note is that the change is essentially trivial. <p> Most readers will probably want to skim the technical development here or simply jump to the next section for some examples. The only important point to note is that the change is essentially trivial. For concreteness, I use the same encoding of objects as <ref> [PT93] </ref>: # Object = Fun (M:*-&gt;*) Some (A) -|state:A, methods:M (A)|-; Object : (*-&gt;*)->* 2 However, nothing in what follows depends on the details of this encoding. An encoding in terms of recursive types and F-bounded quantification should work equally well. <p> A class is a data structure that can be either instantiated to form new objects or extended to form new classes. Its precise definition depends on the choice of the style of inheritance we want to use; here, I follow the definition given in Section 7 of <ref> [PT93] </ref>, in which the instance variables of a class definition are visible only to the methods defined by that class, and not to the methods of subclasses. # Class = # Fun (SelfM:*-&gt;*) # Some (SelfR) # -| localstate: Unit-&gt;SelfR, # buildM: ClassMethods SelfM SelfR|-; Class : (*-&gt;*)->* Our new version <p> describes the arguments that must be provided to the method building function: a "final representation" type containing all of the instance variables of the new object being constructed, an "extractor" that can be used to map back and forth between the final representation and the "local representation" type SelfR (c.f. <ref> [PT93] </ref> for details), and a vector of "self methods": # ClassMethods = # Fun (SelfM:*-&gt;*) # Fun (SelfR:*) # All (FinalR) # (Extractor FinalR SelfR) -&gt; # (Unit -&gt; SelfM (FinalR)) -&gt; # (SelfM (FinalR)); ClassMethods : (*-&gt;*)->*->* The "Unit-&gt;" in the type of the self method vector is the only <p> The extend function takes a class and a description of an incremental change to its state and behavior, and builds a new class. Except for two points where the type annotations must be modified (marked &lt;---), its definition remains identical to the one in <ref> [PT93] </ref>. # extend = # fun (SuperM: *-&gt;*) # fun (SelfM &lt; SuperM) # fun (SelfDeltaR) # fun (superClass: Class SuperM) # fun (deltastate: Unit-&gt;SelfDeltaR) # fun (build: All (FinalR) # (FinalR-&gt;SelfDeltaR) -&gt; # (FinalR-&gt;SelfDeltaR-&gt;FinalR) -&gt; # (SuperM (FinalR)) -&gt; # (Unit-&gt;SelfM (FinalR)) -&gt; % &lt;--- # (SelfM (FinalR))) # open <p> # copy: R-&gt;R # |-; PointM : *-&gt;* # CPointM = Fun (R:*) -| setX: R-&gt;Int->Unit, # getX: R-&gt;Int, # bump: R-&gt;Unit, # copy: R-&gt;R, # setC: R-&gt;Color->Unit, # getC: R-&gt;Color # |-; CPointM : *-&gt;* The implementations of the message-sending functions Point'setX, Point'bump, etc. are identical to those in <ref> [PT93] </ref>, so I elide them here. (The types of the imperative ones could be simplified a bit by removing the quantifier, but I leave it for consistency.) # Point'setX; &lt;val&gt; : All (M&lt;PointM) (Object M) -&gt; Int -&gt; Unit # Point'getX; &lt;val&gt; : All (M&lt;PointM) (Object M) -&gt; Int # Point'bump;
Reference: [Rem89] <author> Didier Remy. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> In Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, Austin, </booktitle> <pages> pages 242-249. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year> <note> To appear in [GM93]. </note>
Reference-contexts: While this has the advantage of allowing the encoding of objects to be expressed in a more economical formal framework, it imposes a heavy burden in terms of readability and it does not correspond closely to real implementations. Again, well-known techniques involving extensible records <ref> [Wan87, Rem89, CM91, etc.] </ref> could be used here to obtain clearer | and perhaps more realistic | encodings.
Reference: [Wan87] <author> Mitchell Wand. </author> <title> Complete type inference for simple objects. </title> <booktitle> In Proceedings of the IEEE Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: While this has the advantage of allowing the encoding of objects to be expressed in a more economical formal framework, it imposes a heavy burden in terms of readability and it does not correspond closely to real implementations. Again, well-known techniques involving extensible records <ref> [Wan87, Rem89, CM91, etc.] </ref> could be used here to obtain clearer | and perhaps more realistic | encodings.
Reference: [Wan89] <author> Mitchell Wand. </author> <title> Type inference for record concatenation and multiple inheritance. </title> <booktitle> In Fourth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 92-97, </pages> <address> Pacific Grove, CA, </address> <month> June </month> <year> 1989. </year> <month> 10 </month>
Reference-contexts: This deficiency, which seems to appear in most -calculus models of object-oriented programming, has also been pointed out by Wand <ref> [Wan89] </ref> and Cook, Hill, and Canning [CHC90]. Using the ordinary fixed point combinator at functional types that is found in call-by-value languages causes new to diverge in some cases.
References-found: 11

