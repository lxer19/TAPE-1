URL: http://www.cs.utexas.edu/users/lavender/papers/coop-isipcala93.ps
Refering-URL: http://www.cs.utexas.edu/users/lavender/papers/index.html
Root-URL: 
Title: Concurrent Object-Oriented Languages and the Inheritance Anomaly  
Author: Dennis G. Kafura and R. Greg Lavender 
Address: VA 24061, USA 2 MCC, 3500 W. Balcones Center Dr., Austin TX 78759, USA  
Affiliation: 1 Dept. of Computer Science, Virginia Tech, Blacksburg  
Abstract: A survey of concurrent object-oriented languages is presented. The survey is organized around three models: the Animation Model that describes a variety of relationships between threads and objects, an Interaction Model that classifies the possible semantics of invocations and returns between a client object and a server object, and a Synchronization Model that shows different ways in which concurrent invocations can be managed by a server. A number of representative languages are briefly presented. The problem of synchronization in concurrent object-oriented languages is considered in detail including a discussion of the inheritance anomaly. A synchronization mechanism, called a behavior set, is shown to avoid this anomaly in certain cases. The implementation of behavior sets in ACT++, an actor-based concurrent programming framework implemented in C++, is described. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> G. Agha. </author> <title> ACTORS: A Model of Concurrent Computation in Distributed Systems, </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: ACT++ is a class hierarchy developed in C++. This hierarchy provides the programmer with abstractions for concurrent programming based on the actor model of computation <ref> [1] </ref>. An application in the actor model is comprised of a number of actors, autonomous agents that execute concurrently and reactively in response to the arrival of messages. Message passing is one-way and asynchronous. <p> From this perspective, the behavior equations define the operations offered by an agent as well as a replacement behavior. The notion of replacement behavior is a fundamental aspect of the Actor model <ref> [1] </ref>. Hence, it seems appropriate to use behavior equations as a formal means for specifying and reasoning about the behavior of individual objects with actor-like semantics.
Reference: 2. <author> P. </author> <title> America. "Inheritance and subtyping in a parallel object-oriented language," </title> <booktitle> ECOOP'87 Conference Proceedings, </booktitle> <pages> pp. 234-242, </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Recent work on the problem has demonstrated that the anomaly occurs across a spectrum of concurrent object-oriented languages, regardless of the type of mechanism employed for specifying synchronization constraints <ref> [2, 7, 12] </ref>. A deeper issue is that the concurrent object-oriented research community does not yet have a good semantic model that relates the type features and the concurrency features of concurrent object-oriented languages. In the following, the inheritance-synchronization conflict is addressed in a formal way.
Reference: 3. <author> P. America. "POOL-T: </author> <title> A parallel object-oriented language," in Object-Oriented Con current Programming, </title> <editor> ed. A. Yonezawa, M. </editor> <booktitle> Tokoro, </booktitle> <pages> pp. 199-220, </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: Philosophically these languages in this family are designed to be small, compact, cohesive languages with well understood interactions among its features. In Pool-T <ref> [3] </ref> all entities are objects, all objects are sequential, and all objects communicate with each other via synchronous message passing. As is usually the 21 case with synchronous invocations, the receiver of a server's return value is known implicitly by the server.
Reference: 4. <author> B. Anderson. </author> <title> "Fine-grained parallelism in Ellie," </title> <journal> Journal of Object-Oriented Program ming, </journal> <volume> 5(3), </volume> <pages> pp. 55-61, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Messages that would cause the invocation of a locked method are held pending in the object's mail queue until the method is unlocked. This form of synchronization falls in the category of a guarded ports style of concrete, conditional interface. 3.7 Ellie A distinguishing aspect of the Ellie language <ref> [4] </ref> is the pervasive use of fine grain concurrency matched with a strategy for compile-time grain adaption. <p> Thus, the Interaction Model used in Ellie is synchronous and provides an explicit return mechanism through futures. Delegation is also provided in Ellie through a mechanism called "interface inclusion". The following example is provided in <ref> [4] </ref>: export local 1, (local 2), (local 3).(remote 1, remote 2) When given as the export interface of object X, the above declaration implies that the interface of X is taken to be the union of: 23 1. the locally defined name local 1, 2. the names that are accessible in
Reference: 5. <author> L. Bergmans, M. Aksit, K. Wakita, and A. Yonezawa. </author> <title> "An object-oriented model for extensible concurrent systems: the composition-filters approach," </title> <booktitle> in Trese Papers on OO Software Engineering, </booktitle> <institution> Department of Computer Science, University of Twente, Netherlands. </institution>
Reference-contexts: A process suspended on the wait method 24 would now find the method available in the interface and its invocation could then be initiated. 3.8 Sina The Sina language <ref> [5, 26] </ref> makes straightforward choices in its Animation and Interaction Models. Invocations in Sina are synchronous with an implicit return. In the Animation Model, all objects are uniformly active. The language, however, is somewhat ambivalent in its position on multiplicity. By default the Sina preprocessor generates only sequential objects.
Reference: 6. <author> B. Bershad and E. Lazowska and H. Levy. </author> <title> "Presto: A system for object-oriented par allel programming," </title> <journal> Software: Practice and Experience, </journal> <volume> 18(8), </volume> <pages> pp. 713-732, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Sina also allows synchronization counters to be included in the definition of filters. The standard object model defines a number of such counters including dispatched, completed and received that indicate how many messages are in each of these states. 3.9 Presto Presto <ref> [6] </ref> is a C++-based framework for parallel programming of shared memory multiprocessors. The goal of Presto is to provide low-level mechanisms for developers to create specialized, domain-specific abstractions. One kind of "developer" are those experimenting with various concurrent programming models that are more highly 25 Fig. 12.
Reference: 7. <author> J-P. Briot and Akinori Yonezawa. </author> <title> "Inheritance and synchronization in object-oriented concurrent programming," in ABCL: An Object-Oriented Concurrent System, </title> <editor> (ed. A. Yonezawa), </editor> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Recent work on the problem has demonstrated that the anomaly occurs across a spectrum of concurrent object-oriented languages, regardless of the type of mechanism employed for specifying synchronization constraints <ref> [2, 7, 12] </ref>. A deeper issue is that the concurrent object-oriented research community does not yet have a good semantic model that relates the type features and the concurrency features of concurrent object-oriented languages. In the following, the inheritance-synchronization conflict is addressed in a formal way.
Reference: 8. <author> D. Caromel. </author> <title> "Concurrency: An object-oriented approach," TOOLS-2 Conference Pro ceedings, </title> <editor> (eds. J. Bexivin, B. Meyer and J. M. </editor> <booktitle> Nerson), </booktitle> <pages> pp. 183-197, </pages> <year> 1990. </year>
Reference-contexts: Furthermore, the activation condition also insist that no Put methods are executing concurrently. The activation condition for the Get method requires that the buffer is not empty (i.e., that more Put invocations have completed than Get invocations). 3.11 Eiffel// The primary goal of Eiffel// <ref> [8] </ref>, a concurrent extension to the Eiffel language, is to achieve performance improvements with as few changes as possible to an application developed as a non-concurrent Eiffel system. This goal is similar to that of ESP, which retains the programming model of C++ but allows for transparent distributed execution.
Reference: 9. <author> M. A. Ellis and B. Stroustrup. </author> <title> The Annotated C++ Reference Manual, </title> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Fine-grained intra-object concurrency is not a feature of objects in the systems under consideration here. A specific interest is expressing and inheriting concurrent object behavior in ACT++ [13, 14, 18], a prototype object-oriented language based on the Actor model and C++ <ref> [9] </ref>. ACT++ is a collection of classes that implement the abstractions of the Actor model and integrates these abstractions with the encapsulation, inheritance, and strong-typing features of C++. The language falls in the non-orthogonal category of concurrent object-oriented languages [23], since there are both active and passive objects.
Reference: 10. <author> A. Grimshaw. </author> <title> "Easy-to-Use object-oriented parallel processing with Mentat," </title> <journal> IEEE Computer, </journal> <volume> 26(5), </volume> <pages> pp. 39-51, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The key to making this scheme work is that the invocations can be controlled by the receiving object and the invocation control can be modified via inheritance to yield a control that is specialized for the receiving object. Fig. 15. Synchronization in Eiffel// 3.12 Mentat Mentat <ref> [10] </ref> is both a language and run-time system. The Mentat Programming Language (MPL) is based on C++. The primary goal of Mentat is to allow the same application to be run across different parallel architectures with no changes in the application itself. <p> When the invoked method finally returns, via the "return to future" (rtf) primitive, a result value is delivered to all objects awaiting the value. An important measure of Mentat's success, and for other similar approaches as well, is the speed-up that can be obtained across different machine architectures. In <ref> [10] </ref> the following performance data is reported for Mentat. Two applications, matrix multiply and Gaussian elimination, were run on two different machine architectures, a network of eight Sun workstations and a 32-processor Intel iPSC/2.
Reference: 11. <author> M. Jackson. </author> <title> System Development, </title> <publisher> Prentice-Hall, </publisher> <year> 1983. </year>
Reference-contexts: A concurrent object-oriented language suppresses substantial detail about control flow management, specifically the invocation and scheduling of object executions. By contract, sequential languages force the developer to explicitly construct a, perhaps elaborate, invocation and scheduling 3 structure. For example, the last step in Jackson's JSD design method <ref> [11] </ref> is exactly to create a scheduler. Not only are these explicit control organizations difficult to construct but they are often fragile, incapable of being extended simply to accommodate simple extensions of functionality.
Reference: 12. <author> D. Kafura and K. H. Lee. </author> <title> "Inheritance in actor based concurrent object-oriented languages," </title> <booktitle> ECOOP'89 Conference Proceedings, </booktitle> <pages> pp. 131-145, </pages> <publisher> Cambridge University Press, </publisher> <year> 1989. </year> <month> 42 </month>
Reference-contexts: Recent work on the problem has demonstrated that the anomaly occurs across a spectrum of concurrent object-oriented languages, regardless of the type of mechanism employed for specifying synchronization constraints <ref> [2, 7, 12] </ref>. A deeper issue is that the concurrent object-oriented research community does not yet have a good semantic model that relates the type features and the concurrency features of concurrent object-oriented languages. In the following, the inheritance-synchronization conflict is addressed in a formal way.
Reference: 13. <author> D. Kafura and K. H. Lee. </author> <title> "ACT++: building a concurrent C++ with actors," </title> <journal> Journal of Object-Oriented Programing, </journal> <volume> 3(1), </volume> <pages> pp. 25-37, </pages> <month> May/June </month> <year> 1990. </year>
Reference-contexts: The actor become operation results in a replacement behavior with its own thread of 36 control. Fine-grained intra-object concurrency is not a feature of objects in the systems under consideration here. A specific interest is expressing and inheriting concurrent object behavior in ACT++ <ref> [13, 14, 18] </ref>, a prototype object-oriented language based on the Actor model and C++ [9]. ACT++ is a collection of classes that implement the abstractions of the Actor model and integrates these abstractions with the encapsulation, inheritance, and strong-typing features of C++.
Reference: 14. <author> D. Kafura, M. Mukherji, and G. Lavender. </author> <title> "ACT++ 2.0: A class library for concurrent programming in C++ using actors," </title> <journal> Journal of Object-Oriented Programing, </journal> <note> to appear 1993. </note>
Reference-contexts: The actor become operation results in a replacement behavior with its own thread of 36 control. Fine-grained intra-object concurrency is not a feature of objects in the systems under consideration here. A specific interest is expressing and inheriting concurrent object behavior in ACT++ <ref> [13, 14, 18] </ref>, a prototype object-oriented language based on the Actor model and C++ [9]. ACT++ is a collection of classes that implement the abstractions of the Actor model and integrates these abstractions with the encapsulation, inheritance, and strong-typing features of C++. <p> Interesting work in this area is [22], which also uses CCS as a starting point. We have not discussed the details of the run-time enforcement of behavior sets. ACT++ and behavior sets have been implemented on the Sequent Symmetry, a shared memory multiprocessor <ref> [14] </ref>. A subject of our current research is to determine the relationship between our implementation approach and others based on reflection.
Reference: 15. <author> S. Krakowiak, et al. </author> <title> "Design and implementation of an nbject-oriented, strongly typed language for distributed applications," </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> September/October, </volume> <pages> pp. 11-22, </pages> <year> 1990. </year>
Reference-contexts: Alternatively, a thread may be created only when an invocation has been accepted, rather than when the invocation is initiated. This later strategy is used in the ACT++ system. 3.10 Guide Guide <ref> [15] </ref> is a language developed for the programming of distributed applications that manipulate permanent data. The language and an operating system (also called Guide) were developed at the University of Grenoble.
Reference: 16. <author> C. Laffra. </author> <title> PROCOL: A Concurrent Object Language with Protocols, Delegation, Per sistence and Constraints, </title> <type> Ph.D. Dissertation, </type> <institution> Erasmus University, Rotterdam, </institution> <year> 1992. </year>
Reference-contexts: The put method opens the getDelay queue (as a get method is now possible) and possibly closes the putDelay method when the buffer is full (to prevent the buffer from overflowing). 3.4 Procol The Procol language <ref> [16, 27] </ref> incorporates a wide variety of interesting features including constraints and object persistence. The brief survey given here cannot do justice to the full scope of this language. 19 Fig. 9. Use of delay qeues in Hybrid Objects in Procol are sequential and homogeneous.
Reference: 17. <author> W. J. Leddy and K. S. Smith, </author> <title> "The design of the experimental system's kernel," Pro ceedings: </title> <booktitle> Hypercube and Concurrent Applications Conference, </booktitle> <address> Monterey, California, </address> <year> 1989. </year>
Reference-contexts: Second, passive objects may be created by declaring an object with no body. In this case a default body is supplied. The default body simply accepts messages in sequential order. 3.6 ESP The Extensible System Platform (ESP) <ref> [17] </ref> was develop at the Microelectronics and Computer Technology Corporation (MCC) as the software component of a research effort to develop flexible hardware and software components for building parallel systems.
Reference: 18. <author> K. H. Lee. </author> <title> Designing a Statically Typed Actor-Based Concurrent Object-Oriented Pro gramming Language, </title> <type> Ph.D. Dissertation, </type> <institution> Department of Computer Science, Virginia Tech, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: The actor become operation results in a replacement behavior with its own thread of 36 control. Fine-grained intra-object concurrency is not a feature of objects in the systems under consideration here. A specific interest is expressing and inheriting concurrent object behavior in ACT++ <ref> [13, 14, 18] </ref>, a prototype object-oriented language based on the Actor model and C++ [9]. ACT++ is a collection of classes that implement the abstractions of the Actor model and integrates these abstractions with the encapsulation, inheritance, and strong-typing features of C++.
Reference: 19. <author> S. Matsuoka, K. Wakita, and A. Yonezawa. </author> <title> "Analysis of the inheritance anomaly in concurrent object-oriented languages," </title> <booktitle> extended abstract presented at the ECOOP-OOPSLA'90 Workshop on Object-based Concurrency, </booktitle> <month> October, </month> <year> 1990. </year>
Reference-contexts: A problem called the 31 inheritance anomaly <ref> [19] </ref> arises when synchronization constraints are implemented within the methods of a class and an attempt is made to specialize methods through inheritance. In this section, concurrent object behavior is formalized using the equational notation of the CCS [20]. <p> The efficacy of this mechanism and its degree of interaction with the C++ inheritance mechanism has been examined by others and has been found to have serious limitations <ref> [19, 23] </ref>. The most serious limitation occurs because a behavior abstraction is not a first-class entity in the language and is thus subject to the effects of the inheritance anomaly.
Reference: 20. <author> R. Milner. </author> <title> Communication and Concurrency, </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: Thus, no invocation can occur when the server is in a state that is incompatible with the invocation. The term "behavioral" is used because this view of an object is similar to the notion of observable behavior used in CCS <ref> [20] </ref> and other similar theories of concurrency. Each projected interface is a subset of the maximal statically defined interface of the server. In this way the usual static type-checking rules can be applied. <p> A problem called the 31 inheritance anomaly [19] arises when synchronization constraints are implemented within the methods of a class and an attempt is made to specialize methods through inheritance. In this section, concurrent object behavior is formalized using the equational notation of the CCS <ref> [20] </ref>. The formalization facilitates a characterization of the fundamental cause of the inheritance anomaly, and leads to the definition of a set of conditions that are necessary for inheritance and synchronization constraints to coexist in concurrent object-oriented languages. <p> From this perspective, the behavior of an object is its observable behavior since all that is relevant is how the object appears to those clients that communicate with the object. This notion of observable behavior is motivated by a similar notion described in <ref> [20] </ref>; however, the machinery of CCS is used here in a superficial manner to characterize the behavior of individual objects, not systems of objects. In dealing with concurrent objects, the relationship between the state of an object and the subset of methods that define its observable behavior is critical. <p> The observable behavior of an object representing a bounded linear order is completely described by the following equations: A 0 = in (x 1 ):A 1 (x 1 ) def . . . def This set of behavior equations is similar to an example in <ref> [20] </ref>. The equations capture precisely the states that an object representing a bounded linear order may occupy during its lifetime. In the equations, only the prefix (.) and summation (+) combinators of CCS are required.
Reference: 21. <author> O. Nierstrasz. </author> <title> "Active objects in hybrid," </title> <booktitle> OOPSLA'87 Proceedings, </booktitle> <pages> pp. 243-253, </pages> <year> 1987. </year>
Reference-contexts: After such a get method has been executed the put method can be resumed to store the provided value in the buffer. 3.3 Hybrid The Hybrid language and run-time system <ref> [21] </ref> employs homogeneous active objects that use a monitor-style form of multiplicity. Recall that this allows an object to have at most one active thread at a time from among several threads that may execute within the object at different points in time.
Reference: 22. <author> O. Nierstrasz and M. Papathomas. </author> <title> "Towards a type theory for active objects," in Object Management, </title> <editor> (ed. D. </editor> <booktitle> Tsichritzis), </booktitle> <pages> pp. 295-304, </pages> <institution> Centre Universitaire D'Informatique, Universite De Geneva, </institution> <year> 1990. </year>
Reference-contexts: We suspect that type-theoretic semantics currently applied to object-oriented languages are incapable of addressing the temporal nature of a changing object interface as captured by the 41 behavior function. Interesting work in this area is <ref> [22] </ref>, which also uses CCS as a starting point. We have not discussed the details of the run-time enforcement of behavior sets. ACT++ and behavior sets have been implemented on the Sequent Symmetry, a shared memory multiprocessor [14].
Reference: 23. <author> M. Papathomas. </author> <title> "Concurrency issues in object-oriented languages," in Object Oriented Development, </title> <editor> (ed. D. </editor> <booktitle> Tsichritzis), </booktitle> <pages> pp. 207-245, </pages> <institution> Centre Universitaire D'Informatique, Universite De Geneva, </institution> <year> 1989. </year>
Reference-contexts: The remainder of this introductory section consider the first point. Subsequent sections consider each of the other points in order. This paper relies heavily on a previous survey by Wegner [29] and a taxonomy presented by Papathomas <ref> [23] </ref>. While differing in terminology and in some conclusions, the thorough work of Papathomas was an especially important information source for the survey undertaken here. As a final preparatory comment, the terms "language", "object-oriented" and "parallel" are given generous interpretations in this survey. <p> The various forms of multiplicity are considered further below. The first choice on the uniformity dimension, the homogeneous approach, offers a simple view of the relationship between threads and objects; only a single protocol of interaction among objects needs to be understood, implemented, optimized 6 and employed. Papathomas <ref> [23] </ref> argues that homogeneous objects are more easily reused as all objects inherently possess the ability to be used in a concurrent environment without any synchronizing actions being required of the client. In contrast, the clients must themselves provide the synchronization required to access passive objects. <p> ACT++ is a collection of classes that implement the abstractions of the Actor model and integrates these abstractions with the encapsulation, inheritance, and strong-typing features of C++. The language falls in the non-orthogonal category of concurrent object-oriented languages <ref> [23] </ref>, since there are both active and passive objects. Active objects are instances of any class derived from a special Actor class defined as part of the language run-time. Any instance of a class not derived from the Actor class is a passive object. <p> The efficacy of this mechanism and its degree of interaction with the C++ inheritance mechanism has been examined by others and has been found to have serious limitations <ref> [19, 23] </ref>. The most serious limitation occurs because a behavior abstraction is not a first-class entity in the language and is thus subject to the effects of the inheritance anomaly.
Reference: 24. <author> M. Papathomas. </author> <title> Language Design Rationale and Semantic Framework for Concurrent Object-Oriented Programming, </title> <type> Ph.D. Dissertation, </type> <institution> University of Geneva, </institution> <year> 1992. </year>
Reference-contexts: The framework of the Synchronization Model, shown in Fig. 6, closely parallels that of Papathomas <ref> [24] </ref>, though some terminology and organization has been changed. The Synchronization Model considers what, if any, controls are imposed over concurrent invocations impinging on a given object.
Reference: 25. <author> C. Tomlinson and V. Singh. </author> <title> "Inheritance and synchronization with enabled-sets," </title> <booktitle> OOPSLA'89 Conference Proceedings, ACM Sigplan Notices, </booktitle> <pages> pp. 103-112, </pages> <year> 1989. </year>
Reference-contexts: A construct called an "enabled set" improves on the notion of behavior abstraction by promoting the control of the visibility of an object's interface to a dynamic mechanism that can be manipulated within the language. Enabled sets were implemented in Rosette, an interpreted actor language with dynamic typing <ref> [25] </ref>. The flexibility offered by enabled sets is difficult to achieve in a statically typed language like ACT++. Behavior sets represent a compromise between the enabled sets and behavior abstraction.
Reference: 26. <author> A. Tripathi and M. Aksit. </author> <title> "Communication, scheduling and resource management in Sina," </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(4), </volume> <pages> pp. 24-37, </pages> <month> November/December </month> <year> 1988. </year>
Reference-contexts: A process suspended on the wait method 24 would now find the method available in the interface and its invocation could then be initiated. 3.8 Sina The Sina language <ref> [5, 26] </ref> makes straightforward choices in its Animation and Interaction Models. Invocations in Sina are synchronous with an implicit return. In the Animation Model, all objects are uniformly active. The language, however, is somewhat ambivalent in its position on multiplicity. By default the Sina preprocessor generates only sequential objects.
Reference: 27. <author> J. Van Den Bos and C. Laffra. </author> <title> "Procol: A parallel object language with protocols," </title> <journal> ACM Sigplan Notices, Proceedings OOPSLA'89, </journal> <volume> 24(10), </volume> <pages> pp. 95-102, </pages> <month> October, </month> <year> 1989. </year>
Reference-contexts: The put method opens the getDelay queue (as a get method is now possible) and possibly closes the putDelay method when the buffer is full (to prevent the buffer from overflowing). 3.4 Procol The Procol language <ref> [16, 27] </ref> incorporates a wide variety of interesting features including constraints and object persistence. The brief survey given here cannot do justice to the full scope of this language. 19 Fig. 9. Use of delay qeues in Hybrid Objects in Procol are sequential and homogeneous.
Reference: 28. <author> T. Watanabe and A. Yonezawa. </author> <title> "Reflection in an object-oriented concurrent lan guage," </title> <journal> ACM Sigplan Notices, </journal> <volume> 23(11), </volume> <pages> pp. 306-315, </pages> <year> 1988. </year>
Reference-contexts: A select statement allowed queued messages to be pattern matched against the alternatives of the select. One of the messages satisfying a pattern matching would be selected for execution. It should also be noted that a later variant, named ABCL/R <ref> [28] </ref>, use a reflective form of synchronization control. Two other minor observations about ABCL are the following. First, inheritance is not supported in the base language. Instead of form of task delegation is used, Second, messages may be sent in either normal mode or express mode.
Reference: 29. <author> P. Wegner. </author> <title> "Dimensions of object-based language design," </title> <booktitle> OOPSLA'87 Conference Proceedings, ACM Sigplan Notices, </booktitle> <pages> pp. 168-182, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: The remainder of this introductory section consider the first point. Subsequent sections consider each of the other points in order. This paper relies heavily on a previous survey by Wegner <ref> [29] </ref> and a taxonomy presented by Papathomas [23]. While differing in terminology and in some conclusions, the thorough work of Papathomas was an especially important information source for the survey undertaken here. As a final preparatory comment, the terms "language", "object-oriented" and "parallel" are given generous interpretations in this survey.
Reference: 30. <author> A. Yonezawa, E. Shibayama, T. Takada, and Y. Honda. </author> <title> "Modelling and programming in an object-oriented concurrent language ABCL/1," in Object-Oreinted Concurrent Programming, </title> <editor> ed. M. </editor> <booktitle> Tokoro, </booktitle> <pages> pp. 55-89, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year> <title> This article was processed using the L a T E X macro package with LLNCS style 43 </title>
Reference-contexts: A more complete description of this mechanism is given in Sect. 4. Fig. 7. A bounded buffer in ACT++ 3.2 ABCL ABCL is the name given to a family of languages. Only the features of ABCL/1 <ref> [30] </ref> are described here. Like ACT++, ABCL/1 is an actor-based language. All objects are homogeneous and each object may be described as serialized, meaning that its execution is sequential, or unserialized, meaning that it may be executed concurrently without restriction.
References-found: 30

