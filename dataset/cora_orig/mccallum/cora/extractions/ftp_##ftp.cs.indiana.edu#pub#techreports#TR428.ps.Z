URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR428.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Title: Processing Queries Containing Generalized Quantifiers  
Author: Sudhir Rao, Antonio Badia, and Dirk Van Gucht 
Affiliation: Indiana University  
Abstract: We considered the problem of processing queries that contain generalized quantifiers. We demonstrate that current relational systems are ill-equipped, both at the language and at the query processing level, to deal with such queries. We propose a boolean matrix approach which establishes the feasibility of building systems that can process queries with generalized quantifiers efficiently, and we provide insights into the intrinsic difficulties associated with processing such queries. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Baase, S., </author> <title> Computer Algorithms, </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: We now briefly describe the various multiplication algorithms implemented in GQ-BMM. * some: For the some generalized quantifier, we experimented with two algorithms, called Kronrod and Witness, respectively. Kronrod is an adaptation, to secondary memory, of Kronrod's well-known boolean matrix multiplication algorithm <ref> [1] </ref> 10 . Witness is an algorithm that uses certain witnessing techniques [15] 11 found in most join algorithms [16]. In particular, in the Witness algorithm, a fragment of a boolean matrix is, before the multiplication, first transformed into a list of sets, each set corresponding to a witness.
Reference: [2] <author> Badia, A., Gyssens, M. and D. Van Gucht. </author> <title> "Query languages with generalized quantifiers," in Applications of Logic Databases, edited by R. Ramakrishnan, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995, </year> <pages> pp. 235-258. </pages>
Reference-contexts: In two recent papers, Hsu and Parker [17] and, independently, Badia, Van Gucht, and Gyssens <ref> [2] </ref>, validated this argument by establishing a link between the phenomenon of sub-query syntax in query languages and the theory of generalized quantifiers as it was introduced by Barwise and Cooper [3] in linguistics. 2 Taking as established that generalized quantifiers are crucial in query languages, it becomes vital to demonstrate <p> In Section 3, we demonstrate that GQ-queries are inadequately supported in current relational database management systems. There are fl CS Department, Bloomington, IN 47405. E-mail: fsrao, abadia, vguchtg@cs.indiana.edu. 1 Several recent papers [7, 20] have pointed out that users commonly use these features. 2 The authors of <ref> [2] </ref> took this validation a step further and postulated the conjunctive formulation thesis. This thesis states that real-world queries can be formulated most naturally as a conjunction of first-order-predicate statements and generalized-quantifier statements over sub-queries. [2] also introduced a query language, called QLGQ, which was designed in accordance with this thesis. <p> [7, 20] have pointed out that users commonly use these features. 2 The authors of <ref> [2] </ref> took this validation a step further and postulated the conjunctive formulation thesis. This thesis states that real-world queries can be formulated most naturally as a conjunction of first-order-predicate statements and generalized-quantifier statements over sub-queries. [2] also introduced a query language, called QLGQ, which was designed in accordance with this thesis. (It is clear from Hsu and Parker's paper that SQL is designed in accordance with the conjunctive formulation thesis. <p> An answer to such a query is the set of patient-disease tuples which make the formula true. Formulas like these, with free variables and containing generalized quantifiers, will be called GQ-queries. In two recent papers, Hsu and Parker [17], and independently, Badia, Van Gucht and Gyssens <ref> [2] </ref> introduced query languages that naturally incorporate the ideas proposed by Barwise and Cooper. Hsu and Parker's language is a natural generalization of SQL. The language in [2], called QLGQ, is developed in the style of the domain relational calculus [8, 9]. <p> In two recent papers, Hsu and Parker [17], and independently, Badia, Van Gucht and Gyssens <ref> [2] </ref> introduced query languages that naturally incorporate the ideas proposed by Barwise and Cooper. Hsu and Parker's language is a natural generalization of SQL. The language in [2], called QLGQ, is developed in the style of the domain relational calculus [8, 9]. The GQ-queries given in Remark 2.2 are specified in QLGQ syntax. <p> The system needs to offer a better query language than SQL to enable natural GQ-query formulation. Languages such as reported in [17] and <ref> [2] </ref> should guide the design of such languages. 2. The system must, at the storage level, be able to deal with relations that have a matrix representation which can range in sparsity from very sparse to very dense.
Reference: [3] <author> Barwise, J. and Cooper, R., </author> <title> "Generalized quantifiers and natural language," </title> <journal> Linguistic and Philosophy, </journal> <volume> 4, </volume> <year> 1981, </year> <pages> pp. 159-219. </pages>
Reference-contexts: In two recent papers, Hsu and Parker [17] and, independently, Badia, Van Gucht, and Gyssens [2], validated this argument by establishing a link between the phenomenon of sub-query syntax in query languages and the theory of generalized quantifiers as it was introduced by Barwise and Cooper <ref> [3] </ref> in linguistics. 2 Taking as established that generalized quantifiers are crucial in query languages, it becomes vital to demonstrate that queries containing generalized quantifiers (GQ-queries) can be supported effectively. The present paper takes a step in this direction. <p> Building on Montague's work [21], Barwise and Cooper <ref> [3] </ref> advocated the adoption of generalized quantifiers in natural language formalization. We illustrate their insights through an example.
Reference: [4] <author> Brink, C., </author> <title> "Boolean Circulants, Groups, and Relation Algebras", </title> <journal> American Mathematical Monthly , 1992. </journal> <volume> 11 </volume>
Reference-contexts: Remark 4.2 It is worthwhile to mention that GQ-BMM supports, besides the various matrix multiplication operations, other standard operations on boolean matrices, i.e., complementation, transposition, and addition <ref> [4, 10] </ref>. In combination with the various matrix multiplication operations, these operations make GQ-BMM a system in which many complex queries can be processed. Due to space limitations, we can not go into more details regarding this aspect of our system.
Reference: [5] <author> Chamberlin, D., et.al., "SEQUEL/2: </author> <title> A unified approach to data definition, manipulation, </title> <journal> and control," IBM Journal of R&D, </journal> <volume> 20, 6, </volume> <year> 1976. </year>
Reference-contexts: The problem with SQL is that it stops short of taking full advantage of its inherently good design. In fact, original-SQL (SEQUEL/2) <ref> [5] </ref> was better than SQL in this regard.) 1 two essential problems: 1) SQL's syntax is too restricted to formulate GQ-queries, and 2) SQL queries that simulate GQ-queries are frequently ill-supported by existing relational query processor.
Reference: [6] <author> Cattell, R., ed, </author> <title> The Object Database Standard: ODMG-93 , Release 1.1, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Numerous existing query languages (SQL [25], OQL <ref> [6] </ref>, CORAL [24], RC/S [23] etc.) allow queries with embedded sub-queries as well as sub-query comparison statements. 1 It is often argued that these features enhance the declarativeness of the query language.
Reference: [7] <author> Chaudhuri, S. and Shim, K. </author> <title> "Including group-by in query optimization," </title> <booktitle> Proceedings of the Twentieth International Conference on Very Large Databases, </booktitle> <year> 1994, </year> <pages> pp. 354-366". </pages>
Reference-contexts: The paper is organized as follows. In Section 2, we provide an introduction to generalized quantifiers. In Section 3, we demonstrate that GQ-queries are inadequately supported in current relational database management systems. There are fl CS Department, Bloomington, IN 47405. E-mail: fsrao, abadia, vguchtg@cs.indiana.edu. 1 Several recent papers <ref> [7, 20] </ref> have pointed out that users commonly use these features. 2 The authors of [2] took this validation a step further and postulated the conjunctive formulation thesis.
Reference: [8] <author> Codd, E. F., </author> <title> "Further normalizations of the relational model," in Data Base Systems, </title> <editor> R. Rustin, Ed., </editor> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1972, </year> <pages> pp. 33-64. </pages>
Reference-contexts: Hsu and Parker's language is a natural generalization of SQL. The language in [2], called QLGQ, is developed in the style of the domain relational calculus <ref> [8, 9] </ref>. The GQ-queries given in Remark 2.2 are specified in QLGQ syntax. In Section 3, we will formulate queries such as these in Hsu and Parker's extended SQL. 3 Processing GQ-Queries in Relational Sys tems Hsu and Parker [17] discussed the syntactic limitations of SQL to express GQ-queries.
Reference: [9] <author> Codd, E. F., </author> <title> "Relational completeness of database sublanguages," in Data Base Systems, </title> <editor> R. Rustin, Ed., </editor> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1972, </year> <pages> pp. 65-98. </pages>
Reference-contexts: Hsu and Parker's language is a natural generalization of SQL. The language in [2], called QLGQ, is developed in the style of the domain relational calculus <ref> [8, 9] </ref>. The GQ-queries given in Remark 2.2 are specified in QLGQ syntax. In Section 3, we will formulate queries such as these in Hsu and Parker's extended SQL. 3 Processing GQ-Queries in Relational Sys tems Hsu and Parker [17] discussed the syntactic limitations of SQL to express GQ-queries.
Reference: [10] <author> Copilowish, Irving M., </author> <title> Matrix Development of the Calculus of Relations, </title> <journal> Journal of Symbolic Logic, Dec.,1948, </journal> <volume> Vol. 13, No. </volume> <pages> 4. </pages>
Reference-contexts: Remark 4.2 It is worthwhile to mention that GQ-BMM supports, besides the various matrix multiplication operations, other standard operations on boolean matrices, i.e., complementation, transposition, and addition <ref> [4, 10] </ref>. In combination with the various matrix multiplication operations, these operations make GQ-BMM a system in which many complex queries can be processed. Due to space limitations, we can not go into more details regarding this aspect of our system.
Reference: [11] <author> Date, C., </author> <title> An Introduction to Database Systems, Sixth Edition, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1994. </year>
Reference-contexts: We conclude by discussing these results and by pointing out strengths and weaknesses of GQ-BMM. 7 This strategy has been suggested on numerous occasions (see for example <ref> [11, 13] </ref>) and is also advo cated in Hsu and Parker [17]. 8 In contrast, in the case of the all query, one is fortunate because the count information necessary to solve the query is not of the order of the cartesian product but rather that of the join result. 5
Reference: [12] <author> Dawar, H. and Hella, L., </author> <title> "The expressive power of finitely many quantifiers,", </title> <booktitle> Proc. of the 9th IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pp. 20-29, </pages> <year> 1994. </year>
Reference: [13] <author> Dayal, U., </author> <title> "Of nests and trees: a unified approach to processing queries that contain nested subqueries, aggregates and quantifiers," </title> <booktitle> in VLDB 1987, </booktitle> <pages> pp. 197-208. </pages>
Reference-contexts: Using this formulation of the all-query, the performance of the commercial relational systems improves dramatically (see Figure 1). (Observe however the large discrepancy between the two commercial systems.) Unfortunately, reformulating the no-query and the not all-query via grouping and counting mechanisms (as advocated by Hsu and Parker [17], see also <ref> [13] </ref>) does not result in a similar speed-up. The reason for this is simple; both these queries contain a hidden complementation, which means, for all practical purposes, that a cartesian product needs to be attempted to account for the negation. <p> We conclude by discussing these results and by pointing out strengths and weaknesses of GQ-BMM. 7 This strategy has been suggested on numerous occasions (see for example <ref> [11, 13] </ref>) and is also advo cated in Hsu and Parker [17]. 8 In contrast, in the case of the all query, one is fortunate because the count information necessary to solve the query is not of the order of the cartesian product but rather that of the join result. 5
Reference: [14] <author> EXODUS, </author> <title> "Using the EXODUS Storage Manager V3.0", unpublished, included in the EXODUS Storage Manager Software Release, </title> <note> available via anonymous ftp from ftp.cs.wisconsin.edu. </note>
Reference-contexts: For example, 3 GQ-BMM is a boolean-matrix file system implemented on top of the EXODUS storage manager <ref> [14] </ref> 4 The body of literature on generalized quantifiers in mathematical logic|and, more recently, in finite model theory (e.g., [12])|is extensive. 5 The fourth sentence is technically not expressible in FO-logic. 2 "John's symptoms" = bs [patient-symptom (`John'; s)] "Hepatitis-A symptoms" = bs [disease-symptom (`Hepatitis-A'; s)] "Heart-disease symptoms" = bs [9d <p> A similar fact is true for the matrices P fi all D and P fi not all D. 4.2 Implementation To validate the above conceptualization, we implemented a system called GQ-BMM (Generalized Quantifier Processing as Boolean Matrix Multiplication) on top of the University of Wisconsin EXODUS storage manager <ref> [14] </ref> (Currently, GQ-BMM handles only binary relations.) We next describe the data structures and algorithms implemented in GQ-BMM. Data Structures In GQ-BMM, each (binary) relation is implemented as a boolean matrix. Assume that R is a relation over domains A and B, i.e., R A fi B.
Reference: [15] <author> Galil, Z. and Margalit, O., </author> <title> "Witnesses for Boolean Matrix Multiplication and for Transitive Closure", </title> <journal> Journal of Complexity, 1993, </journal> <volume> vol. 9, </volume> <month> pp.201-221. </month>
Reference-contexts: Kronrod is an adaptation, to secondary memory, of Kronrod's well-known boolean matrix multiplication algorithm [1] 10 . Witness is an algorithm that uses certain witnessing techniques <ref> [15] </ref> 11 found in most join algorithms [16]. In particular, in the Witness algorithm, a fragment of a boolean matrix is, before the multiplication, first transformed into a list of sets, each set corresponding to a witness.
Reference: [16] <author> Graefe, G., </author> <title> "Query evaluation techniques for large databases," </title> <journal> ACM computing Surveys, </journal> <volume> 25, 2, </volume> <year> 1993. </year>
Reference-contexts: are respectively P fi all Q (i; j) = z=1 P fi no Q (i; j) = : z=1 P fi notall Q (i; j) = : m ^ P (i; z) ! Q (z; j): 9 The idea of associating bit vectors to domain elements was advocated by Graefe <ref> [16] </ref> to efficiently support relational division. 7 pname symptom p 1 s 1 p 2 s 3 p 4 s 2 p 5 s 2 p 1 1 0 0 p 3 1 0 0 p 5 0 1 0 dname symptom d 1 s 2 d 2 s 1 d <p> Kronrod is an adaptation, to secondary memory, of Kronrod's well-known boolean matrix multiplication algorithm [1] 10 . Witness is an algorithm that uses certain witnessing techniques [15] 11 found in most join algorithms <ref> [16] </ref>. In particular, in the Witness algorithm, a fragment of a boolean matrix is, before the multiplication, first transformed into a list of sets, each set corresponding to a witness. The multiplication is then done via local cartesian products, again guided by the witnesses.
Reference: [17] <author> Hsu, P.Y. and Parker, </author> <title> D.S., "Improving SQL with Generalized Quantifiers", </title> <booktitle> Proceedings of the Tenth International Conference on Data Engineering, </booktitle> <year> 1995. </year>
Reference-contexts: 1 Introduction Numerous existing query languages (SQL [25], OQL [6], CORAL [24], RC/S [23] etc.) allow queries with embedded sub-queries as well as sub-query comparison statements. 1 It is often argued that these features enhance the declarativeness of the query language. In two recent papers, Hsu and Parker <ref> [17] </ref> and, independently, Badia, Van Gucht, and Gyssens [2], validated this argument by establishing a link between the phenomenon of sub-query syntax in query languages and the theory of generalized quantifiers as it was introduced by Barwise and Cooper [3] in linguistics. 2 Taking as established that generalized quantifiers are crucial <p> An answer to such a query is the set of patient-disease tuples which make the formula true. Formulas like these, with free variables and containing generalized quantifiers, will be called GQ-queries. In two recent papers, Hsu and Parker <ref> [17] </ref>, and independently, Badia, Van Gucht and Gyssens [2] introduced query languages that naturally incorporate the ideas proposed by Barwise and Cooper. Hsu and Parker's language is a natural generalization of SQL. The language in [2], called QLGQ, is developed in the style of the domain relational calculus [8, 9]. <p> The GQ-queries given in Remark 2.2 are specified in QLGQ syntax. In Section 3, we will formulate queries such as these in Hsu and Parker's extended SQL. 3 Processing GQ-Queries in Relational Sys tems Hsu and Parker <ref> [17] </ref> discussed the syntactic limitations of SQL to express GQ-queries. To overcome these limitations, they syntactically extended SQL and provided a translation mechanism from extended-SQL to conventional SQL (actually SQL2 [25]). In this section we consider this approach. <p> D.cnt = P.cnt Using this formulation of the all-query, the performance of the commercial relational systems improves dramatically (see Figure 1). (Observe however the large discrepancy between the two commercial systems.) Unfortunately, reformulating the no-query and the not all-query via grouping and counting mechanisms (as advocated by Hsu and Parker <ref> [17] </ref>, see also [13]) does not result in a similar speed-up. The reason for this is simple; both these queries contain a hidden complementation, which means, for all practical purposes, that a cartesian product needs to be attempted to account for the negation. <p> We conclude by discussing these results and by pointing out strengths and weaknesses of GQ-BMM. 7 This strategy has been suggested on numerous occasions (see for example [11, 13]) and is also advo cated in Hsu and Parker <ref> [17] </ref>. 8 In contrast, in the case of the all query, one is fortunate because the count information necessary to solve the query is not of the order of the cartesian product but rather that of the join result. 5 PS DS some Query Timings (seconds) Univ. <p> The system needs to offer a better query language than SQL to enable natural GQ-query formulation. Languages such as reported in <ref> [17] </ref> and [2] should guide the design of such languages. 2. The system must, at the storage level, be able to deal with relations that have a matrix representation which can range in sparsity from very sparse to very dense.
Reference: [18] <author> Keenan, E.L. and Stavi, J., </author> <title> "A semantic characterization of natural language determiners", </title> <journal> Linguistics and Philosophy, </journal> <volume> 9, </volume> <year> 1986, </year> <pages> pp. 253-326. </pages>
Reference-contexts: Remark 2.1 All the generalized quantifiers in the example sentences are binary . There are, however, natural unary, as well as higher arity, generalized quantifiers <ref> [18, 27] </ref>. A well-known example in the database community of a unary generalized quantifier is SQL's EXISTS. In SQL, EXISTS (S) is true if and only if the set S 6= ;. Remark 2.2 (GQ-queries) All the examples we have discussed so far are sentences (i.e., true-false formulas).
Reference: [19] <author> Lindstrom, P., </author> <title> "First order predicate logic with generalized quantifies," </title> <journal> Theoria, </journal> <volume> 32, </volume> <pages> pp. 186-195, </pages> <year> 1966. </year>
Reference-contexts: give a list of requirements for query languages and database systems that we believe are fundamental to adequate GQ-queries processing. 2 Generalized quantifiers Generalized quantifiers were introduced by mathematical logicians in the late 1950s who wanted to study logical properties of quantifiers that could not be expressed within first-order logic <ref> [19, 22] </ref>. 4 In the early 1980s, they became prominent in linguistics. Building on Montague's work [21], Barwise and Cooper [3] advocated the adoption of generalized quantifiers in natural language formalization. We illustrate their insights through an example.
Reference: [20] <author> Lu, H., Chan, H.C., and Wei, K.K., </author> <title> "A survey on usage of SQL," </title> <booktitle> SIGMOD Record , 22, </booktitle> <year> 1993, </year> <pages> pp. 60-65. </pages>
Reference-contexts: The paper is organized as follows. In Section 2, we provide an introduction to generalized quantifiers. In Section 3, we demonstrate that GQ-queries are inadequately supported in current relational database management systems. There are fl CS Department, Bloomington, IN 47405. E-mail: fsrao, abadia, vguchtg@cs.indiana.edu. 1 Several recent papers <ref> [7, 20] </ref> have pointed out that users commonly use these features. 2 The authors of [2] took this validation a step further and postulated the conjunctive formulation thesis.
Reference: [21] <author> Montague, R., </author> <title> Formal Philosophy: Selected Papers, </title> <editor> R. H. Thomason, Ed., </editor> <publisher> Yale University Press, </publisher> <address> New Haven, Conn., </address> <year> 1974. </year>
Reference-contexts: Building on Montague's work <ref> [21] </ref>, Barwise and Cooper [3] advocated the adoption of generalized quantifiers in natural language formalization. We illustrate their insights through an example.
Reference: [22] <author> Mostowski, A., </author> <title> "On a generalization of quantifiers," </title> <journal> Fundamenta Mathematica, </journal> <volume> 44, </volume> <year> 1957, </year> <pages> pp. 12-36. </pages>
Reference-contexts: give a list of requirements for query languages and database systems that we believe are fundamental to adequate GQ-queries processing. 2 Generalized quantifiers Generalized quantifiers were introduced by mathematical logicians in the late 1950s who wanted to study logical properties of quantifiers that could not be expressed within first-order logic <ref> [19, 22] </ref>. 4 In the early 1980s, they became prominent in linguistics. Building on Montague's work [21], Barwise and Cooper [3] advocated the adoption of generalized quantifiers in natural language formalization. We illustrate their insights through an example.
Reference: [23] <author> Ozsoyoglu, G. and Wang, H., </author> <title> "A relational calculus with set operators, its safety, and equivalent graphical languages," </title> <journal> IEEE Transactions on Software Engineering , 15, </journal> <year> 1989, </year> <pages> pp. 1038-1052. </pages>
Reference-contexts: 1 Introduction Numerous existing query languages (SQL [25], OQL [6], CORAL [24], RC/S <ref> [23] </ref> etc.) allow queries with embedded sub-queries as well as sub-query comparison statements. 1 It is often argued that these features enhance the declarativeness of the query language.
Reference: [24] <author> Ramakrishnan, R., Seshadri, P., Srivastava, D., and Sudarshan, S., </author> <title> "The CORAL User Manual: A Tutorial Introduction to CORAL," </title> <institution> Computer Science Department, University of Wisconsin-Madison, </institution> <note> available via anonymous ftp from ftp.cs.wisc.edu in the directory coral/doc. </note>
Reference-contexts: 1 Introduction Numerous existing query languages (SQL [25], OQL [6], CORAL <ref> [24] </ref>, RC/S [23] etc.) allow queries with embedded sub-queries as well as sub-query comparison statements. 1 It is often argued that these features enhance the declarativeness of the query language.
Reference: [25] <author> International Organization for Standardization (ISO), </author> <title> Database Language SQL. Document ISO/IEC 9075:1992. 12 [26] van Benthem, J., "Questions about quantifiers," </title> <journal> Journal of Symbolic Logic, </journal> <volume> 49, </volume> <year> 1984, </year> <pages> pp. 443-466. </pages>
Reference-contexts: 1 Introduction Numerous existing query languages (SQL <ref> [25] </ref>, OQL [6], CORAL [24], RC/S [23] etc.) allow queries with embedded sub-queries as well as sub-query comparison statements. 1 It is often argued that these features enhance the declarativeness of the query language. <p> To overcome these limitations, they syntactically extended SQL and provided a translation mechanism from extended-SQL to conventional SQL (actually SQL2 <ref> [25] </ref>). In this section we consider this approach. To focus the discussion, we will only consider GQ-queries containing the generalized quantifiers some, all, no, and not all.
Reference: [27] <author> Westerstahl, D., </author> <title> "Quantifiers in Formal and Natural Languages", in Handbook of Philosophical Logic, </title> <editor> D. Gabbay and F. Guenthner, eds., </editor> <volume> vol. </volume> <booktitle> IV, </booktitle> <address> D. </address> <publisher> Reidel Publishing Company, </publisher> <year> 1989, </year> <pages> pp. 1-131. </pages>
Reference-contexts: Remark 2.1 All the generalized quantifiers in the example sentences are binary . There are, however, natural unary, as well as higher arity, generalized quantifiers <ref> [18, 27] </ref>. A well-known example in the database community of a unary generalized quantifier is SQL's EXISTS. In SQL, EXISTS (S) is true if and only if the set S 6= ;. Remark 2.2 (GQ-queries) All the examples we have discussed so far are sentences (i.e., true-false formulas).
References-found: 26

