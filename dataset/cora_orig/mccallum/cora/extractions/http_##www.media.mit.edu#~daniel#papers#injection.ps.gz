URL: http://www.media.mit.edu/~daniel/papers/injection.ps.gz
Refering-URL: http://www.media.mit.edu/~daniel/research.html
Root-URL: http://www.media.mit.edu
Email: bieman@cs.colostate.edu  
Title: Using Fault Injection to Increase Software Test Coverage  
Author: James M. Bieman Daniel Dreilinger Lijun Lin 
Keyword: software testing, software test coverage, fault injection, error recovery, software reliability, Visual C-Patrol.  
Note: To appear in Proc. International Symposium on Software Reliability (ISSRE'96)  
Address: Fort Collins, Colorado 80523  
Affiliation: Computer Science Department Colorado State University  
Abstract: During testing, it is nearly impossible to run all statments or branches of a program. It is especially difficult to test the code used to respond to exceptional conditions. This untested code, often the error recovery code, will tend to be an error prone part of a system. We show that test coverage can be increased through an assertion violation technique for injecting software faults during execution. Using our prototype tool, Visual C-Patrol (VCP), we were able to substantially increase test branch coverage in four software systems studied. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Barton, E. Czeck, Z. Segall, and D. Siewiorek. </author> <title> Fault injection experiments using FIAT. (Fault Injection-based Automated Testing). </title> <journal> IEEE Trans. Computers, </journal> <volume> 39(4) </volume> <pages> 575-583, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Dynamic Fault Injection The dynamic or state changing forms of fault injection do not require multiple compilation. Dynamic fault injection is most commonly used to simulate hardware errors by modifying or injecting faults into memory bits and registers <ref> [15, 1, 4, 10] </ref>. The changed memory locations can contain both program instructions and data. A wide variety of faults can be emulated. However, dynamic fault injection has been commonly used to modeling hardware faults such as bus errors or incorrect CPU instructions. <p> Exhaustive hardware fault injections would be infeasible on a machine with an address space of several megabytes. 2. FIAT (`Fault Injection-based Automated Testing') uses fault injection to evaluate the dependability of fault tolerant software <ref> [1] </ref>. FIAT, implemented entirely in software, changes bits in both program text and data regions of machine memory to simulate hardware faults. 3. Chillarege and Bowen manually injected 70 overlay faults into a large commercial transaction processing system [4].
Reference: [2] <author> B. Beizer. </author> <title> Black-Box Testing. </title> <publisher> John Wiley & Sons, </publisher> <year> 1995. </year>
Reference-contexts: 1. Introduction Developing reliable and fault tolerant software is difficult and requires discipline both in specifying system functionality and in implementing systems correctly. Approaches for developing highly reliable software include the use of formal methods [11, 14, 9], and rigorous testing methods <ref> [2, 7, 13] </ref>. Testing cannot guarantee that software is correct [17], and verification requires enormous human effort and is subject to errors [6]. Automated support is necessary to help ensure software correctness and fault tolerance.
Reference: [3] <author> T. A. Budd. </author> <title> Mutation analysis: Ideas, examples, problems and prospects. </title> <editor> In B. Chandrasekaran and S. Radicchi, editors, </editor> <booktitle> Computer Program Testing, </booktitle> <pages> pages 129-134. </pages> <publisher> North-Holland, </publisher> <year> 1981. </year>
Reference-contexts: Automated support is necessary to help ensure software correctness and fault tolerance. Fault injection has been proposed for use in mutation testing primarily as a mechanism for evaluating the adequacy of test data <ref> [3, 8] </ref>. Mutation testing injects faults by modifying program text. As a result, the testing process can generate enormous numbers of mutant programs, and each program fl Research partially supported by the Colorado Advanced Software Institute (CASI) and Storage Technology Inc.
Reference: [4] <author> R. Chillarege and N. Bowen. </author> <title> Understanding large system failure a fault injection experiment. </title> <booktitle> In Proc. 19th Int. Symp. Fault-Tolerant Computing (FTCS-19), </booktitle> <pages> pages 356-363, </pages> <address> Chicago, IL, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Dynamic Fault Injection The dynamic or state changing forms of fault injection do not require multiple compilation. Dynamic fault injection is most commonly used to simulate hardware errors by modifying or injecting faults into memory bits and registers <ref> [15, 1, 4, 10] </ref>. The changed memory locations can contain both program instructions and data. A wide variety of faults can be emulated. However, dynamic fault injection has been commonly used to modeling hardware faults such as bus errors or incorrect CPU instructions. <p> FIAT, implemented entirely in software, changes bits in both program text and data regions of machine memory to simulate hardware faults. 3. Chillarege and Bowen manually injected 70 overlay faults into a large commercial transaction processing system <ref> [4] </ref>. Overlay faults occur when a program writes into an incorrect location due to a faulty destination operand. To decrease fault and error latency and increase the probability that a fault will cause an error, a large region of memory was corrupted with a single injection.
Reference: [5] <author> R. DeMillo, T. Li, and A. Mathur. </author> <title> Architecture of TAMER: a tool for dependability analysis of distributed fault-tolerant systems. </title> <type> Technical Report SERC-TR-158-P, </type> <institution> Software Engineering Research Center, Computer Science Dept., Purdue Univ., </institution> <year> 1994. </year>
Reference-contexts: Also, invalid program states in fault tolerant software should not propagate to the output. Thus, weak mutation testing may be difficult to apply to robust fault tolerant software. The TAMER fault injection tool mutates source code to test fault-tolerant system <ref> [5] </ref>. TAMER injects possible faults at module interfaces using a fault manager. The system is designed so that all mutants can be created using only one compilation, and iterates the execution of the mutants.
Reference: [6] <author> R. DeMillo, R. Lipton, and A. Perlis. </author> <title> Social processes and proofs of theorems and programs. </title> <journal> Communications of the ACM, </journal> <volume> 22(5) </volume> <pages> 803-820, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: Approaches for developing highly reliable software include the use of formal methods [11, 14, 9], and rigorous testing methods [2, 7, 13]. Testing cannot guarantee that software is correct [17], and verification requires enormous human effort and is subject to errors <ref> [6] </ref>. Automated support is necessary to help ensure software correctness and fault tolerance. Fault injection has been proposed for use in mutation testing primarily as a mechanism for evaluating the adequacy of test data [3, 8]. Mutation testing injects faults by modifying program text.
Reference: [7] <author> R. DeMillo, W. McCracken, R. Martin, and J. Passafiume. </author> <title> Software Testing and Evaluation. </title> <address> Benjamin/Cummings, Menlo Park, CA, </address> <year> 1987. </year>
Reference-contexts: 1. Introduction Developing reliable and fault tolerant software is difficult and requires discipline both in specifying system functionality and in implementing systems correctly. Approaches for developing highly reliable software include the use of formal methods [11, 14, 9], and rigorous testing methods <ref> [2, 7, 13] </ref>. Testing cannot guarantee that software is correct [17], and verification requires enormous human effort and is subject to errors [6]. Automated support is necessary to help ensure software correctness and fault tolerance.
Reference: [8] <author> R. A. DeMillo, D. S. Guindi, W. M. McCracken, A. J. Of-fut, and K. N. King. </author> <title> An extended overview of the mothra sofware testing environment. </title> <booktitle> Proc. ACM SIGSOFT/IEEE Second Workshop on Software Testing, Verification, and Analysis, </booktitle> <pages> pages 142-151, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Automated support is necessary to help ensure software correctness and fault tolerance. Fault injection has been proposed for use in mutation testing primarily as a mechanism for evaluating the adequacy of test data <ref> [3, 8] </ref>. Mutation testing injects faults by modifying program text. As a result, the testing process can generate enormous numbers of mutant programs, and each program fl Research partially supported by the Colorado Advanced Software Institute (CASI) and Storage Technology Inc. <p> The most common static fault injection is mutation testing. Much of the recent fault injection research is concerned with dynamic injection. 5.1. Static Fault InjectionMutation Testing Mutation testing involves testing modified or mutated program source text <ref> [8] </ref>. It is primarily applied to unit testingtesting which involves small individual modules of the program. A mutant program is created by making a small syntactic change, a mutation, to the original program. For example, a greater-than operator, &gt;, might be changed to greater-than-or-equal, &gt;=.
Reference: [9] <author> S. Garland, J. Guttag, and J. Horning. </author> <title> Debugging larch shared language specifications. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 16(9) </volume> <pages> 1044-1057, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: 1. Introduction Developing reliable and fault tolerant software is difficult and requires discipline both in specifying system functionality and in implementing systems correctly. Approaches for developing highly reliable software include the use of formal methods <ref> [11, 14, 9] </ref>, and rigorous testing methods [2, 7, 13]. Testing cannot guarantee that software is correct [17], and verification requires enormous human effort and is subject to errors [6]. Automated support is necessary to help ensure software correctness and fault tolerance.
Reference: [10] <author> J. Gerardin. </author> <title> The `def.injector' test instrument, assistance in the design of reliable and safe systems. </title> <booktitle> Computers in Industry, </booktitle> <volume> 11(4) </volume> <pages> 311-319, </pages> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: Dynamic Fault Injection The dynamic or state changing forms of fault injection do not require multiple compilation. Dynamic fault injection is most commonly used to simulate hardware errors by modifying or injecting faults into memory bits and registers <ref> [15, 1, 4, 10] </ref>. The changed memory locations can contain both program instructions and data. A wide variety of faults can be emulated. However, dynamic fault injection has been commonly used to modeling hardware faults such as bus errors or incorrect CPU instructions. <p> Testing only for hardware faults ignores potential software faults. Four dynamic fault injection case studies are relevant to our work: 1. The DEF.Injector (`Defined Errors Fast Injector') injects a set of hardware faults by toggling memory bits or bytes, changing bus addresses, and changing machine instructions <ref> [10] </ref>. It is a hardware device that is physically connected to specific target machines. Because of the dedicated hardware involved, intermittent faults are easily modeled. The DEF.Injector can achieve thorough coverage of all defined tests because the address space of the target machines is quite small (8-64K).
Reference: [11] <author> A. Hall. </author> <title> Seven myths of formal methods. </title> <journal> IEEE Software, </journal> <volume> 7(5) </volume> <pages> 11-19, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: 1. Introduction Developing reliable and fault tolerant software is difficult and requires discipline both in specifying system functionality and in implementing systems correctly. Approaches for developing highly reliable software include the use of formal methods <ref> [11, 14, 9] </ref>, and rigorous testing methods [2, 7, 13]. Testing cannot guarantee that software is correct [17], and verification requires enormous human effort and is subject to errors [6]. Automated support is necessary to help ensure software correctness and fault tolerance.
Reference: [12] <author> W. Howden. </author> <title> Weak mutation testing and completeness of test sets. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> SE-8(4):371-379, </volume> <month> July </month> <year> 1982. </year>
Reference-contexts: In one study of a 30-line triangle program, 951 mutants were automatically created [16]. Massive computational resources can be required to repeatedly recompile and run all of the mutations. Weak mutation testing is less rigorous but more efficient than strong mutation testing <ref> [12] </ref>. Using weak mutation testing, mutant and original program states are compared soon after the mutation is executed, rather than after entire programs are run. States can be compared soon after executing mutated expressions, statements, or basic blocks.
Reference: [13] <author> W. Howden. </author> <title> A functional approach to program testing and analysis. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> SE-12(10):997-1005, </volume> <month> October </month> <year> 1986. </year>
Reference-contexts: 1. Introduction Developing reliable and fault tolerant software is difficult and requires discipline both in specifying system functionality and in implementing systems correctly. Approaches for developing highly reliable software include the use of formal methods [11, 14, 9], and rigorous testing methods <ref> [2, 7, 13] </ref>. Testing cannot guarantee that software is correct [17], and verification requires enormous human effort and is subject to errors [6]. Automated support is necessary to help ensure software correctness and fault tolerance.
Reference: [14] <author> C. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> Prentice-Hall International, </booktitle> <address> London, </address> <year> 1986. </year>
Reference-contexts: 1. Introduction Developing reliable and fault tolerant software is difficult and requires discipline both in specifying system functionality and in implementing systems correctly. Approaches for developing highly reliable software include the use of formal methods <ref> [11, 14, 9] </ref>, and rigorous testing methods [2, 7, 13]. Testing cannot guarantee that software is correct [17], and verification requires enormous human effort and is subject to errors [6]. Automated support is necessary to help ensure software correctness and fault tolerance.
Reference: [15] <author> W.-L. Kao, R. Iyer, and D. Tang. </author> <title> Fine: a fault injection and monitoring environment for tracing the unix system behavior under faults. </title> <journal> IEEE Trans. Software Engineering, </journal> 19(11) 1105-1119, Nov. 1993. 
Reference-contexts: Dynamic Fault Injection The dynamic or state changing forms of fault injection do not require multiple compilation. Dynamic fault injection is most commonly used to simulate hardware errors by modifying or injecting faults into memory bits and registers <ref> [15, 1, 4, 10] </ref>. The changed memory locations can contain both program instructions and data. A wide variety of faults can be emulated. However, dynamic fault injection has been commonly used to modeling hardware faults such as bus errors or incorrect CPU instructions. <p> About 16% of 7 the faults immediately crashed the system; about 14% caused a partial loss of service; half of the faults did not cause failures. 4. FINE (`The Fault Injection and Monitoring Environment') was used to study fault propagation in UNIX operating system kernel <ref> [15] </ref>. This system modeled hardware faults including memory faults, CPU faults, bus faults, and I/O faults. Unlike the other studies, software faults were studied including initialization faults, assignment faults, condition check faults, and invalid function faults. Initialization faults can be detected by a compiler.
Reference: [16] <author> A. Offutt and S. Lee. </author> <title> An empirical evaluation of weak mutation. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 20(5) </volume> <pages> 337-345, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Mutation testing can require the creation of a vast number of mutant programs. A program with N variable references can have N 2 mutant versions. In one study of a 30-line triangle program, 951 mutants were automatically created <ref> [16] </ref>. Massive computational resources can be required to repeatedly recompile and run all of the mutations. Weak mutation testing is less rigorous but more efficient than strong mutation testing [12]. <p> States can be compared soon after executing mutated expressions, statements, or basic blocks. Weak mutation testing is much less expensive than strong mutation testing, while almost as effective <ref> [16] </ref>. Weak mutation testing does not solve the problem of identifying equivalent mutants. Also, invalid program states in fault tolerant software should not propagate to the output. Thus, weak mutation testing may be difficult to apply to robust fault tolerant software.
Reference: [17] <author> L. J. White. </author> <title> Basic mathematical definitions and results in testing. </title> <editor> In B. Chandrasekaran and S. Radicchi, editors, </editor> <booktitle> Computer Program Testing, </booktitle> <pages> pages 13-24. </pages> <publisher> North-Holland, </publisher> <year> 1981. </year>
Reference-contexts: Approaches for developing highly reliable software include the use of formal methods [11, 14, 9], and rigorous testing methods [2, 7, 13]. Testing cannot guarantee that software is correct <ref> [17] </ref>, and verification requires enormous human effort and is subject to errors [6]. Automated support is necessary to help ensure software correctness and fault tolerance. Fault injection has been proposed for use in mutation testing primarily as a mechanism for evaluating the adequacy of test data [3, 8].
Reference: [18] <author> H. Yin and J. Bieman. </author> <title> Improving software testability with assertion insertion. </title> <booktitle> In Proc. Int. Test Conf., </booktitle> <month> Oct. </month> <year> 1994. </year> <month> 9 </month>
Reference-contexts: A correct pre- or post-condition can be injected as code and checked at run time using a facility like C assert statements or C-Patrol insertion directives. 3. Implementing Assertion Violation Fault In jection To demonstrate the proposed fault injection method, we extended the C-Patrol assertion insertion system <ref> [18] </ref> to support fault injection and built a visual X Window System interface. 3.1. C-Patrol C-Patrol is a code insertion tool that can assist developers in the placement of software probes that are used in testing.
References-found: 18

