URL: http://www.cs.utexas.edu/users/less/compilers/tickC.ps
Refering-URL: http://www.cs.utexas.edu/users/less/compiler.html
Root-URL: 
Email: engler@lcs.mit.edu, whsieh@cs.washington.edu, kaashoek@lcs.mit.edu  
Title: `C: A Language for High-Level, Efficient, and Machine-Independent Dynamic Code Generation  
Author: Dawson R. Engler, Wilson C. Hsieh and M. Frans Kaashoek 
Keyword: dynamic code generation, C  
Address: Cambridge, MA 02139  
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: We describe `C (Tick C), a superset of ANSI C that allows flexible, high-level, efficient, and machine-independent specification of dynamically generated code. `C provides many of the performance benefits of pure partial evaluation, but in the context of a complex, statically typed, but widely used language. `C examples illustrate the ease of specifying dynamically generated code and how it can be put to use. Experiments with a prototype compiler show that `C enables excellent performance improvement (in some cases, more than an order of magnitude). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Auslander, M. Philipose, C. Chambers, S.J. Eggers, and B.N. Bershad. </author> <title> Fast, effective dynamic compilation. </title> <note> Submitted for publication, </note> <month> October </month> <year> 1995. </year>
Reference-contexts: Additionally, our language extensions and prototype implementation have been done in the context of ANSI C, a complex non-functional language. Several other projects address the higher-level issue of automatic compiler support for detecting runtime constants <ref> [1, 9] </ref>. They use programmer annotations to indicate some runtime constants; the compiler computes what variables are derived runtime constants. Keppel addressed some issues relevant to retargeting dynamic code generation in [20]. He developed a portable system for modifying instruction spaces on a variety of machines.
Reference: [2] <author> R. Bernstein. </author> <title> Multiplication by integer constants. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 16(7) </volume> <pages> 641-652, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Static compilation was done using gcc version 2.5.8. 5.1 Matrix Scaling Scaling a matrix by a runtime constant allows ample opportunity for speedup from the use of dynamic code generation. For instance, multiplication can be reduced in strength to shifts and adds <ref> [2] </ref>; division can be reduced in strength to multiplication, and then to shifts and adds [15]. Additionally, loop bounds can be encoded in branch checks as constants, which can alleviate register pressure. The `C code for expressing matrix scaling by a runtime constant is shown in Figure 3.
Reference: [3] <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. Fi-uczynski, D. Becker, S. Eggers, and C. Chambers. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: While this functionality can be simulated in the original `C language, the syntactic sugar of lambda can remove awkwardness in some situations. 7 Related Work Dynamic code generation has a long history. It has been used to increase the performance of operating systems <ref> [3, 12, 27, 28] </ref>, windowing operations [26], dynamically typed languages [6, 10, 17], simulators [30, 34] and matrix manipulations [13]. `C grew out of our previous work with DCG [13], an efficient, retargetable dynamic code generation system. `C offers several improvements over DCG, but retains DCG's portability and flexibility.
Reference: [4] <author> A.D. Birrell and B.J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: These operations are frequently performed to support remote procedure call <ref> [4] </ref>. By generating specialized code for the most active functions it is possible to gain substantial performance benefits [33]. The generation of marshaling code relies on `C's ability to specify arbitrary numbers of incoming parameters.
Reference: [5] <author> R.L. Burden and J.D. Faires. </author> <title> Numerical Methods. </title> <publisher> PWS-kent Publishing Company, </publisher> <address> Boston, MA, </address> <note> fourth edition, </note> <year> 1989. </year>
Reference-contexts: By using `C to compose cspecs instead of function pointers, library functions can be parameterized easily and efficiently, since cspecs can be integrated directly into `C code without extra function calls. The `C code for Newton's method <ref> [5] </ref> illustrates `C's advantages for parameterized functions. The function newton takes as arguments the allowed number of iterations, a tolerance, an initial estimate, and two pointers to functions that return cspecs to compute a function and its derivative.
Reference: [6] <author> C. Chambers and D. Ungar. </author> <title> Customization: Optimizing compiler technology for SELF, a dynamically-typed object-oriented programming language. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 146-160, </pages> <address> Port-land, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request Permissions from Publications Dept, ACM Inc., Fax +1 (212) 869-0481, or &lt;permissions@acm.org&gt;. example, interpreters can compile frequently used code and execute it directly <ref> [6] </ref>; this technique can improve performance by an order of magnitude, even compared to heavily tuned interpreters [12]. Unfortunately, current dynamic code generation systems are not satisfactory. <p> is approximately a factor of 2-3 slower than hand-optimized DCG code [13], because the prototype compiler emits naive DCG IR, and does not perform global optimizations. 5.2 Compiling Interpreter Interpreters can use dynamic code generation technology to improve performance by compiling and then directly executing frequently interpreted pieces of code <ref> [6, 10] </ref>. To show that `C can be used to do this easily and efficiently we present a recursive-descent compiling interpreter that accepts a subset of C, called Tiny C [13]. <p> It has been used to increase the performance of operating systems [3, 12, 27, 28], windowing operations [26], dynamically typed languages <ref> [6, 10, 17] </ref>, simulators [30, 34] and matrix manipulations [13]. `C grew out of our previous work with DCG [13], an efficient, retargetable dynamic code generation system. `C offers several improvements over DCG, but retains DCG's portability and flexibility.
Reference: [7] <author> D. D. Clark and D. L. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In ACM Communication Architectures, Protocols, and Applications (SIGCOMM) 1990, </booktitle> <month> September </month> <year> 1990. </year>
Reference-contexts: Inexpensive function composition has many applications; an important one is the optimization of networking code. The modular composition of different protocol layers has long been a goal in the networking community <ref> [7] </ref>. Unfortunately, each protocol layer frequently has data-touching operations associated with it (e.g., checksumming, byte-swapping, etc.). As a result, as data moves through each layer, data can be touched multiple times, which is expensive [7]. `C can be used to construct a network subsystem that solves this problem by dynamically integrating <p> The modular composition of different protocol layers has long been a goal in the networking community <ref> [7] </ref>. Unfortunately, each protocol layer frequently has data-touching operations associated with it (e.g., checksumming, byte-swapping, etc.). As a result, as data moves through each layer, data can be touched multiple times, which is expensive [7]. `C can be used to construct a network subsystem that solves this problem by dynamically integrating protocol data operations into a single pass over memory (e.g., by integrating encryption and compression into a single copy operation).
Reference: [8] <author> C. Consel and O. Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <booktitle> In Proceedings of the 20th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 493-501, </pages> <address> Charleston, SC, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: The result of our design effort is `C (Tick C), which is ANSI C augmented with a small number of primitives for dynamic code generation. `C inherits many of the performance advantages of partial evaluation <ref> [8, 19] </ref>. `C differs from languages that support partial evalution in two ways. First, our language extensions and prototype implementation have been done in the context of ANSI C, a complex, statically typed, but very widely used language.
Reference: [9] <author> C. Consel and F. Noel. </author> <title> A general approach for run-time specialization and its application to C. </title> <booktitle> In Proceedings of the 23th Annual Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg, FL, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Additionally, our language extensions and prototype implementation have been done in the context of ANSI C, a complex non-functional language. Several other projects address the higher-level issue of automatic compiler support for detecting runtime constants <ref> [1, 9] </ref>. They use programmer annotations to indicate some runtime constants; the compiler computes what variables are derived runtime constants. Keppel addressed some issues relevant to retargeting dynamic code generation in [20]. He developed a portable system for modifying instruction spaces on a variety of machines.
Reference: [10] <author> P. Deutsch and A.M. Schiffman. </author> <title> Efficient implementation of the Smalltalk-80 system. </title> <booktitle> In Proceedings of the 11th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297-302, </pages> <address> Salt Lake City, UT, </address> <month> January </month> <year> 1984. </year>
Reference-contexts: is approximately a factor of 2-3 slower than hand-optimized DCG code [13], because the prototype compiler emits naive DCG IR, and does not perform global optimizations. 5.2 Compiling Interpreter Interpreters can use dynamic code generation technology to improve performance by compiling and then directly executing frequently interpreted pieces of code <ref> [6, 10] </ref>. To show that `C can be used to do this easily and efficiently we present a recursive-descent compiling interpreter that accepts a subset of C, called Tiny C [13]. <p> It has been used to increase the performance of operating systems [3, 12, 27, 28], windowing operations [26], dynamically typed languages <ref> [6, 10, 17] </ref>, simulators [30, 34] and matrix manipulations [13]. `C grew out of our previous work with DCG [13], an efficient, retargetable dynamic code generation system. `C offers several improvements over DCG, but retains DCG's portability and flexibility.
Reference: [11] <author> D. R. Engler. </author> <title> VCODE: a very fast, retargetable, and extensible dynamic code generation substrate. Technical Memorandum MIT/LCS/TM534, </title> <publisher> MIT, </publisher> <month> July </month> <year> 1995. </year>
Reference-contexts: Our prototype demonstrates that despite our lack of optimization and DCG's rudimentary optimization (it does not perform instruction scheduling nor peephole optimization), the generated code still achieves good performance. We are developing a full `C compiler that will generate fast code using templates and VCODE. VCODE <ref> [11] </ref> is a retargetable, extensible, very fast dynamic code generation system. It is a portable assembly language that generates specialized code on the fly; the cost for dynamic code generation is about ten instructions per generated instruction.
Reference: [12] <author> D.R. Engler, M.F. Kaashoek, and J. O'Toole Jr. Exok-ernel: </author> <title> an operating system architecture for application-specific resource management. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <address> Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Request Permissions from Publications Dept, ACM Inc., Fax +1 (212) 869-0481, or &lt;permissions@acm.org&gt;. example, interpreters can compile frequently used code and execute it directly [6]; this technique can improve performance by an order of magnitude, even compared to heavily tuned interpreters <ref> [12] </ref>. Unfortunately, current dynamic code generation systems are not satisfactory. Programmers must choose between portability, ease of programming (including debugging), and efficiency: efficiency can be had, but only by sacrificing portability, ease of programming or, in the case of the fastest dynamic code generators [23], both. <p> While this functionality can be simulated in the original `C language, the syntactic sugar of lambda can remove awkwardness in some situations. 7 Related Work Dynamic code generation has a long history. It has been used to increase the performance of operating systems <ref> [3, 12, 27, 28] </ref>, windowing operations [26], dynamically typed languages [6, 10, 17], simulators [30, 34] and matrix manipulations [13]. `C grew out of our previous work with DCG [13], an efficient, retargetable dynamic code generation system. `C offers several improvements over DCG, but retains DCG's portability and flexibility.
Reference: [13] <author> D.R. Engler and T.A. Proebsting. </author> <title> DCG: An efficient, retargetable dynamic code generation system. </title> <booktitle> Sixth International Conference on Architecture Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 263-272, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Finally, the call to the vspec function pointer with the constructed argument list is specified, and the result is compiled. 5 Performance We have implemented a prototype `C compiler that emits ANSI C code augmented with calls to DCG's <ref> [13] </ref> dynamic code generation primitives. The compiler parses, semantically checks, and generates code for `C. It generates code correctly for most of the examples in this paper. <p> We expect the use of templates and VCODE to improve the speed of dynamic code generation by an order of magnitude. The rest of this section presents performance results using the prototype compiler for two `C programs that are based on the examples used in <ref> [13] </ref>. The experiments were conducted on a SPARC 10 system that does integer divide and multiply in software. Times were measured using the Unix system call getrusage and include both user and system time. The times given are the median time of three trials. <p> The performance of dividing a 1024x1024 matrix of shorts by a runtime constant improved by 35%. More dramatic improvements would be possible with a more sophisticated factorization scheme for reducing division in strength. The `C matrix scaling code is approximately a factor of 2-3 slower than hand-optimized DCG code <ref> [13] </ref>, because the prototype compiler emits naive DCG IR, and does not perform global optimizations. 5.2 Compiling Interpreter Interpreters can use dynamic code generation technology to improve performance by compiling and then directly executing frequently interpreted pieces of code [6, 10]. <p> To show that `C can be used to do this easily and efficiently we present a recursive-descent compiling interpreter that accepts a subset of C, called Tiny C <ref> [13] </ref>. Tiny C has only an integer type; it supports most of C's relational and arithmetic operations (/, , , etc.) and provides if statements, while loops, and function calls as control constructs. A subset of the parser is shown in Figure 4. <p> It has been used to increase the performance of operating systems [3, 12, 27, 28], windowing operations [26], dynamically typed languages [6, 10, 17], simulators [30, 34] and matrix manipulations <ref> [13] </ref>. `C grew out of our previous work with DCG [13], an efficient, retargetable dynamic code generation system. `C offers several improvements over DCG, but retains DCG's portability and flexibility. <p> It has been used to increase the performance of operating systems [3, 12, 27, 28], windowing operations [26], dynamically typed languages [6, 10, 17], simulators [30, 34] and matrix manipulations <ref> [13] </ref>. `C grew out of our previous work with DCG [13], an efficient, retargetable dynamic code generation system. `C offers several improvements over DCG, but retains DCG's portability and flexibility. First, `C provides a high-level interface for code specification, whereas DCG's interface is based on the intermediate representation of lcc [14].
Reference: [14] <author> C.W. Fraser and D.R. Hanson. </author> <title> A code generation interface for ANSI C. </title> <type> Technical Report CS-TR-270-90, </type> <institution> Princeton University, Dept. of Computer Science, </institution> <address> Prince-ton, New Jersey, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: First, `C provides a high-level interface for code specification, whereas DCG's interface is based on the intermediate representation of lcc <ref> [14] </ref>. Second, it provides the opportunity for static analysis, which reduces the cost of dynamic compilation; because it has no compiler support, DCG must do runtime analysis. Finally, because we have made dynamic code generation a first-class capability of a high-level language, both profiling and debugging facilities can be added.
Reference: [15] <author> T. Granlund and P.L. Montgomery. </author> <title> Division by invariant integers using multiplication. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 61-72, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: For instance, multiplication can be reduced in strength to shifts and adds [2]; division can be reduced in strength to multiplication, and then to shifts and adds <ref> [15] </ref>. Additionally, loop bounds can be encoded in branch checks as constants, which can alleviate register pressure. The `C code for expressing matrix scaling by a runtime constant is shown in Figure 3. We compare its performance to that of a static matrix scaling routine.
Reference: [16] <author> S.P. Harbison and G.L. Steele Jr. </author> <title> C, A Reference Manual. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, third edition, </address> <year> 1991. </year>
Reference: [17] <author> U. H olzle and D. Ungar. </author> <title> Optimizing dynamically-dispatched calls with run-time type feedback. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 326-335, </pages> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year> <month> 13 </month>
Reference-contexts: It has been used to increase the performance of operating systems [3, 12, 27, 28], windowing operations [26], dynamically typed languages <ref> [6, 10, 17] </ref>, simulators [30, 34] and matrix manipulations [13]. `C grew out of our previous work with DCG [13], an efficient, retargetable dynamic code generation system. `C offers several improvements over DCG, but retains DCG's portability and flexibility.
Reference: [18] <author> SPARC International. </author> <title> The SPARC Architecture Manual Verson 8. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey 07632, </address> <year> 1992. </year>
Reference-contexts: Such optimizations are increasingly profitable on modern architectures, where cache misses are very expensive and division and multiplication are frequently provided in only software <ref> [18, 31] </ref>. This examples also illustrates that turning a C function into `C requires few changes. The cost of using the `C generated function is an indirect jump on a function pointer. 4.2 Matrix Dot Product Matrix manipulations such as dot product are a fruitful realm for dynamic code generation.
Reference: [19] <author> N. D. Jones, P. Sestoft, and H. Sondergaard. </author> <title> Mix: a self-applicable partial evaluator for experiments in compiler generation. </title> <journal> LISP and Symbolic Computation, </journal> <volume> 2(1) </volume> <pages> 9-50, </pages> <year> 1989. </year>
Reference-contexts: The result of our design effort is `C (Tick C), which is ANSI C augmented with a small number of primitives for dynamic code generation. `C inherits many of the performance advantages of partial evaluation <ref> [8, 19] </ref>. `C differs from languages that support partial evalution in two ways. First, our language extensions and prototype implementation have been done in the context of ANSI C, a complex, statically typed, but very widely used language.
Reference: [20] <author> D. Keppel. </author> <title> A portable interface for on-the-fly instruction space modification. </title> <booktitle> In Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 86-95, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Several other projects address the higher-level issue of automatic compiler support for detecting runtime constants [1, 9]. They use programmer annotations to indicate some runtime constants; the compiler computes what variables are derived runtime constants. Keppel addressed some issues relevant to retargeting dynamic code generation in <ref> [20] </ref>. He developed a portable system for modifying instruction spaces on a variety of machines. His system dealt with the difficulties presented by caches and operating system restrictions, but it did not address how to select and emit actual binary instructions.
Reference: [21] <author> D. Keppel, S.J. Eggers, and R.R. Henry. </author> <title> Evaluating runtime-compiled value-specific optimizations. </title> <type> TR 93-11-02, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: The small query languages used to interogate data bases are well-known targets for dynamic code generation <ref> [21] </ref>; because databases are large, dynamically compiled queries will be applied many times. We provide a small example below. <p> He developed a portable system for modifying instruction spaces on a variety of machines. His system dealt with the difficulties presented by caches and operating system restrictions, but it did not address how to select and emit actual binary instructions. Keppel, Eggers, and Henry <ref> [21] </ref> demonstrated that dynamic code generation could be effective for several different applications. Many Unix systems provide utilities to dynamically link object files to an executing process.
Reference: [22] <author> M. Leone and P. Lee. </author> <title> Lightweight run-time code generation. </title> <booktitle> In Proceedings of the Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 97-106, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Massalin et al. briefly note that they are designing a language for code synthesis, Lambda-C [28]. They do not discuss design or implementation issues other than to note that type-checking of synthesized code is non-trivial. Leone and Lee <ref> [22] </ref> use programmer-supplied hints to perform compile-time specialization in a primitive functional language: their data structures are not mutable, and the only heap-allocated data structures are pointers and integers. They achieve low code generation costs through templates.
Reference: [23] <author> H. Massalin. </author> <title> Synthesis: an efficient implementation of fundamental operating system services. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <year> 1992. </year>
Reference-contexts: Unfortunately, current dynamic code generation systems are not satisfactory. Programmers must choose between portability, ease of programming (including debugging), and efficiency: efficiency can be had, but only by sacrificing portability, ease of programming or, in the case of the fastest dynamic code generators <ref> [23] </ref>, both. <p> Templates are highly specialized code emitters where the instructions have been chosen statically; any holes in the instructions (e.g., runtime constants and addresses of variables) are filled at runtime <ref> [23] </ref>. Since templates, combined with `C's static type system, allow the bulk of code generation analysis to be done at compile time, we will emit code very quickly. We expect the use of templates and VCODE to improve the speed of dynamic code generation by an order of magnitude.
Reference: [24] <author> J.C. Mogul, R.F. Rashid, and M.J. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Comparing the `C results to the interpreter, we see that using dynamic code generation is 50 times faster than the evaluator. From a more global perspective, this same technique can give order of magnitude improvements in the performance of operating system extension languages such as packet filters <ref> [24] </ref>. The `C results are within 10% of hand-generated DCG code. The simple IR generation that the `C compiler performs does not lower the performance as much as in the matrix scaling example, because the dynamic code fragments are so simple. 6 Language Extensions Language design is an iterative process.
Reference: [25] <author> J.K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley Professional Computing Series. Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1994. </year>
Reference-contexts: The generation of unmarshaling code is equally profitable. Dynamic generation of unmarshaling routines relies on our mechanisms for constructing calls (to arbitrary functions) at runtime. The ability to invoke arbitrary functions is not just useful for efficiency: it is also useful for functionality. For example, in Tcl <ref> [25] </ref> the runtime system can make upcalls into an application. However, because Tcl cannot dynamically create code to call an arbitrary function, it marshals all of the upcall arguments into a single byte vector, and forces applications to explicitly unmarshal them. <p> Finally, because we have made dynamic code generation a first-class capability of a high-level language, both profiling and debugging facilities can be added. Many languages, such as most Lisp dialects [29, 32], Tcl <ref> [25] </ref>, and Perl [35], provide an eval operation that allows code to be generated dynamically. This approach is extremely flexible but, unfortunately, comes at a high price: since these languages are dynamically typed, little code generation cost can be pushed to compile time.
Reference: [26] <author> R. Pike, B.N. Locanthi, and J.F. Reiser. </author> <title> Hardware/software trade-offs for bitmap graphics on the Blit. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 15(2) </volume> <pages> 131-151, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: While this functionality can be simulated in the original `C language, the syntactic sugar of lambda can remove awkwardness in some situations. 7 Related Work Dynamic code generation has a long history. It has been used to increase the performance of operating systems [3, 12, 27, 28], windowing operations <ref> [26] </ref>, dynamically typed languages [6, 10, 17], simulators [30, 34] and matrix manipulations [13]. `C grew out of our previous work with DCG [13], an efficient, retargetable dynamic code generation system. `C offers several improvements over DCG, but retains DCG's portability and flexibility.
Reference: [27] <author> C. Pu, T. Autry, A. Black, C. Consel, C. Cowan, J. In-ouye, L. Kethana, J. Walpole, and K. Zhang. </author> <title> Optimistic incremental specialization: streamlining a commerical operating system. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <address> Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: While this functionality can be simulated in the original `C language, the syntactic sugar of lambda can remove awkwardness in some situations. 7 Related Work Dynamic code generation has a long history. It has been used to increase the performance of operating systems <ref> [3, 12, 27, 28] </ref>, windowing operations [26], dynamically typed languages [6, 10, 17], simulators [30, 34] and matrix manipulations [13]. `C grew out of our previous work with DCG [13], an efficient, retargetable dynamic code generation system. `C offers several improvements over DCG, but retains DCG's portability and flexibility.
Reference: [28] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <year> 1988. </year>
Reference-contexts: While this functionality can be simulated in the original `C language, the syntactic sugar of lambda can remove awkwardness in some situations. 7 Related Work Dynamic code generation has a long history. It has been used to increase the performance of operating systems <ref> [3, 12, 27, 28] </ref>, windowing operations [26], dynamically typed languages [6, 10, 17], simulators [30, 34] and matrix manipulations [13]. `C grew out of our previous work with DCG [13], an efficient, retargetable dynamic code generation system. `C offers several improvements over DCG, but retains DCG's portability and flexibility. <p> Interestingly, although perhaps not surprisingly, the syntax we chose turned out to be similar to that used by Weise and Crew. Massalin et al. briefly note that they are designing a language for code synthesis, Lambda-C <ref> [28] </ref>. They do not discuss design or implementation issues other than to note that type-checking of synthesized code is non-trivial.
Reference: [29] <editor> J. Rees, W. Clinger (editors), et al. </editor> <title> Revised 4 report on the algorithmic language Scheme. </title> <institution> AIM 848b, MIT AI Lab, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: Finally, because we have made dynamic code generation a first-class capability of a high-level language, both profiling and debugging facilities can be added. Many languages, such as most Lisp dialects <ref> [29, 32] </ref>, Tcl [25], and Perl [35], provide an eval operation that allows code to be generated dynamically. This approach is extremely flexible but, unfortunately, comes at a high price: since these languages are dynamically typed, little code generation cost can be pushed to compile time.
Reference: [30] <author> M. Rosenblum, S. A. Herrod, E. Witchel, and A. Gupta. </author> <title> Complete computer simulation: The SimOS approach. </title> <booktitle> IEEE Parallel and Distributed Technology, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: It has been used to increase the performance of operating systems [3, 12, 27, 28], windowing operations [26], dynamically typed languages [6, 10, 17], simulators <ref> [30, 34] </ref> and matrix manipulations [13]. `C grew out of our previous work with DCG [13], an efficient, retargetable dynamic code generation system. `C offers several improvements over DCG, but retains DCG's portability and flexibility.
Reference: [31] <author> R. L. </author> <title> Sites. Alpha AXP architecture. </title> <journal> Communications of the ACM, </journal> <volume> 36(2), </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: Such optimizations are increasingly profitable on modern architectures, where cache misses are very expensive and division and multiplication are frequently provided in only software <ref> [18, 31] </ref>. This examples also illustrates that turning a C function into `C requires few changes. The cost of using the `C generated function is an indirect jump on a function pointer. 4.2 Matrix Dot Product Matrix manipulations such as dot product are a fruitful realm for dynamic code generation.
Reference: [32] <author> G.L. Steele Jr. </author> <title> Common Lisp. </title> <note> Digital Press, second edition, </note> <year> 1990. </year>
Reference-contexts: Finally, because we have made dynamic code generation a first-class capability of a high-level language, both profiling and debugging facilities can be added. Many languages, such as most Lisp dialects <ref> [29, 32] </ref>, Tcl [25], and Perl [35], provide an eval operation that allows code to be generated dynamically. This approach is extremely flexible but, unfortunately, comes at a high price: since these languages are dynamically typed, little code generation cost can be pushed to compile time.
Reference: [33] <author> C. A. Thekkath and H. M. Levy. </author> <title> Limits to low-latency communication on high-speed networks. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(2) </volume> <pages> 179-203, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: These operations are frequently performed to support remote procedure call [4]. By generating specialized code for the most active functions it is possible to gain substantial performance benefits <ref> [33] </ref>. The generation of marshaling code relies on `C's ability to specify arbitrary numbers of incoming parameters. Figure 1 gives a simplified code fragment that generates a marshaling function for a particular type set (in this example, INT, POINTER, and DOUBLE). The code works as follows.
Reference: [34] <author> J.E. Veenstra and R.J. Fowler. MINT: </author> <title> a front end for efficient simulation of shared-memory multiprocessors. </title> <booktitle> In Modeling and Simulation of Computers and Telecommunications Systems, </booktitle> <year> 1994. </year>
Reference-contexts: It has been used to increase the performance of operating systems [3, 12, 27, 28], windowing operations [26], dynamically typed languages [6, 10, 17], simulators <ref> [30, 34] </ref> and matrix manipulations [13]. `C grew out of our previous work with DCG [13], an efficient, retargetable dynamic code generation system. `C offers several improvements over DCG, but retains DCG's portability and flexibility.
Reference: [35] <author> D. Wall. </author> <title> The Perl Programming Language. </title> <publisher> Prentice Hall Software Series, </publisher> <year> 1994. </year>
Reference-contexts: Finally, because we have made dynamic code generation a first-class capability of a high-level language, both profiling and debugging facilities can be added. Many languages, such as most Lisp dialects [29, 32], Tcl [25], and Perl <ref> [35] </ref>, provide an eval operation that allows code to be generated dynamically. This approach is extremely flexible but, unfortunately, comes at a high price: since these languages are dynamically typed, little code generation cost can be pushed to compile time.
Reference: [36] <author> D. Weise and R. </author> <title> Crew. Programmable syntax macros. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 156-165, </pages> <address> Albuquerque, NM, </address> <month> June </month> <year> 1993. </year> <title> A `C Grammar The grammar for `C consists of the grammar specified in Har-bison and Steele's C reference manual [16] with the following additions: </title> <journal> unary-expression : backquote-expression at-expression dollar-expression backquote-expression : ` unary-expression ` compound-statement at-expression : @ unary-expression dollar-expression : $ unary-expression pointer : cspec type-qualifier-list opt vspec type-qualifier-list opt cspec type-qualifier-list opt pointer vspec type-qualifier-list opt pointer 14 </journal>
Reference-contexts: This approach is extremely flexible but, unfortunately, comes at a high price: since these languages are dynamically typed, little code generation cost can be pushed to compile time. Many of the language design issues involved in `C also appear in designing macro languages, such as Weise and Crew's work <ref> [36] </ref>. The difference is that macro languages allow programmers to specify code templates that are compiled statically, whereas dynamic code templates are compiled at run-time. Interestingly, although perhaps not surprisingly, the syntax we chose turned out to be similar to that used by Weise and Crew.
References-found: 36

