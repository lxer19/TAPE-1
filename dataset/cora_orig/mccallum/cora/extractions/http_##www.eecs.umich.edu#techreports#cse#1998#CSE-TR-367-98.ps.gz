URL: http://www.eecs.umich.edu/techreports/cse/1998/CSE-TR-367-98.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse98.html
Root-URL: http://www.cs.umich.edu
Email: fzou,farnam@eecs.umich.edug  
Title: Optimization of a Real-Time Primary-Backup Replication Service  
Author: Hengming Zou and Farnam Jahanian 
Address: Ann Arbor, Michigan 48109  
Affiliation: Real-time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: The primary-backup replication model is one of the commonly adopted approaches to providing fault tolerant data services. The extension of the primary-backup protocol to the real-time environment, however, imposes the additional constraint of timing predictability, which requires a bounded overhead for managing redundancy. There is a trade-off between reducing system overhead and increasing (temporal) consistency between the primary and backup, and the way to achieve balance between them is not so obvious. In this paper, we try to explore ways to optimize scheduling update messages from primary to backup while maintaining the temporal consistency guarantees of the system. Depending on the purpose of the individual replication service and the environment in which it is running, very different objectives can be sought in the process of optimization. This paper considers the optimization problem from two perspectives with one aimed to minimize the average temporal distance between the primary and backup, and the other aimed to minimize the resource being used in maintaining a given temporal constraint on the system. Corresponding optimization techniques have been developed for these two diverse objectives and an implementation of such techniques is also presented. The implementation is built on top of the existing RTPB model developed in [20] which in turn was developed within the x-kernel architecture on the Mach OSF platform running MK (mach kernel) 7.2. Results of an experimental evaluation of the proposed optimization techniques are also discussed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alonso, D. Barbara, and H. Garcia-Molina. </author> <title> Data caching issues in an information retrieval system. </title> <journal> ACM Transaction on Database Systems, </journal> <volume> 15(3) </volume> <pages> 359-384, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Weak consistency can also improve performance in non-real-time applications. For instance, the quasi-copy model permits some inconsistency between the central data and its cached copies at remote sites <ref> [1] </ref>. This gives the scheduler more flexibility in propagating updates to the cached copies.
Reference: [2] <author> M. Gagliardi, R.Rajkumar, and L. Sha. </author> <title> Designing for evolvability: Building blocks for evolvable real-time systems. </title> <booktitle> In Proc. Real-Time Technology and Applications Symposium, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: It guarantees agreement on membership among the communicating processors, and ensures that membership changes resulting from processor joins or departures are atomic and ordered with respect to multicast messages. Both TTP and RTCAST are based on active replication whereas RTPB is a passive scheme. Rajkumar <ref> [2, 17] </ref> presents a publisher/subscriber model for distributed real-time systems. It provides a simple user interface for publishing messages on a logical "channel", and for subscribing to selected channels as needed by each application.
Reference: [3] <author> C-C Han and K-J Lin. </author> <title> Scheduling distance-constrained real-time tasks. </title> <booktitle> In Proc. Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1992. </year>
Reference-contexts: constraint: n X (e U i + e P i ) 2n (2 1=2n 1) p P i ffi B The constraint P n i =p U i =p P i ) 2n (2 1=2n 1) is needed to guarantee task schedula bility under both the Rate-Monotonic [13] and Distance-Constrained <ref> [3] </ref> scheduling algorithms. 1 The inequality p U i ffi B i ensures that the temporal constraint imposed on object i at the backup is maintained while inequality p P i p U i guarantees that no unnecessary update is sent to the 1 An exposition of scheduling algorithms is beyond <p> In this case, since all objects are given before hand, the algorithm for scheduling updates from primary to backup is relatively straightforward: 1. Assign p U i = ffi B i initially. 2. Check schedulability test using rate-monotonic [13] or distance-constrained <ref> [3] </ref> scheduling. If the test fails, then it is impossible to schedule the task set without violating the given temporal constraint so we stop here. Otherwise go to next step. 3. <p> The last condition ensures that the whole task set is schedulable under rate-monotonic [13] or distance-constrained scheduling <ref> [3] </ref> algorithm. 2. If the above allocation is not feasible, then reject the object. Global optimal 1. Insert term p P i =p U i into the ordered list that we obtained in static or previous allocations. 2. Rerun the static allocation algorithm. 8 3. <p> With proper substitution of terms, the same algorithm introduced in section 3 can be applied here. Specifically, the algorithm is as follows: 1. Assign p U i = ffi B i initially. 2. Check schedulability test using rate-monotonic [13] or distance-constrained <ref> [3] </ref> scheduling algorithm. If the test fails, then it is impossible to schedule the task set without violating the given temporal constraint so we stop here. Otherwise go to next step. 3.
Reference: [4] <author> H.F.Korth, N.Soparkar, and A. Silberschatz. </author> <title> Triggered real-time databases with consistency constraints. </title> <booktitle> In Proc. Int'l Conf. on Very Large Data Bases, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: In particular, a number of researchers have observed that serializability is too strict as a correctness criterion for real-time databases. Relaxed correctness criteria facilitate higher concurrency by permitting a limited amount of inconsistency in how a transaction views the database state <ref> [4, 7-12, 16, 18] </ref>. For example, a recent work [8] [10] proposed a class of real-time data access protocols called SSP (Similarity Stack Protocol) applicable to distributed real-time systems.
Reference: [5] <author> H.Kopetz and G. Grunsteidl. </author> <title> Ttp a protocol for fault-tolerant real-time systems. </title> <journal> In IEEE Computer, </journal> <volume> volume 27, </volume> <pages> pages 14-23, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Hence, the problem of server replication posses additional challenges in a real-time environment. In recent years, several experimental projects have begun to address the problem of replication in distributed hard real-time systems. For example, TTP <ref> [5] </ref> is a time-triggered distributed real-time system: its architecture is based on the assumption that the worst-case load is determined apriori at design time, and the system response to external events is cyclic at predetermined time-intervals. The TTP architecture provides fault-tolerance by implementing active redundancy.
Reference: [6] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Janruary </month> <year> 1991. </year>
Reference-contexts: This new modified RTPB system is implemented as a user-level x-kernel <ref> [6] </ref> based server on the MK 7.2 microkernel from the Open Group. 2 The protocol objects communicate with each other through a set of uniform x-kernel protocol interfaces. A given instance of the x-kernel can be configured by specifying a protocol graph in the configuration file.
Reference: [7] <author> B. Kao and H. Garcia-Molina. </author> <title> An overview of real-time database systems. </title> <editor> In S.H. Son, editor, </editor> <booktitle> Advances in Real-Time systems, </booktitle> <pages> pages 463-486. </pages> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference: [8] <author> T-W Kuo and A.K.Mok. </author> <title> Ssp: A semantics-based protocol for real-time data access. </title> <booktitle> In Proceedings of IEEE 14th Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: Relaxed correctness criteria facilitate higher concurrency by permitting a limited amount of inconsistency in how a transaction views the database state [4, 7-12, 16, 18]. For example, a recent work <ref> [8] </ref> [10] proposed a class of real-time data access protocols called SSP (Similarity Stack Protocol) applicable to distributed real-time systems.
Reference: [9] <author> T-W Kuo and A.K.Mok. </author> <title> Real-time database similarity semantics and resource scheduling. </title> <booktitle> In ACM SIGMOD Record, </booktitle> <month> March </month> <year> 1997. </year>
Reference: [10] <author> Tei-Wei Kuo, D. Locke, and F. Wang. </author> <title> Error propagation analysis of real-time data intensive application. </title> <booktitle> In IEEE Real-Time Technology and Applications Symposium, </booktitle> <month> June </month> <year> 1997. </year> <month> 19 </month>
Reference-contexts: Relaxed correctness criteria facilitate higher concurrency by permitting a limited amount of inconsistency in how a transaction views the database state [4, 7-12, 16, 18]. For example, a recent work [8] <ref> [10] </ref> proposed a class of real-time data access protocols called SSP (Similarity Stack Protocol) applicable to distributed real-time systems. The correctness of the SSP protocol is justified by the concept of similarity which allows different but sufficiently timely data to be used in a computation without adversely affecting the outcome.
Reference: [11] <author> K-J Lin. </author> <title> Consistency issues in real-time database systems. </title> <booktitle> In Proc. 22nd Hawaii International Conference on System Sciences, </booktitle> <pages> pages 654-661, </pages> <month> January </month> <year> 1989. </year>
Reference: [12] <author> K-J Lin and F. Jahanian. </author> <title> Issues and applications. In Sang Son, editor, Real-time Database Systems. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1997. </year>
Reference: [13] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: p U under constraint: n X (e U i + e P i ) 2n (2 1=2n 1) p P i ffi B The constraint P n i =p U i =p P i ) 2n (2 1=2n 1) is needed to guarantee task schedula bility under both the Rate-Monotonic <ref> [13] </ref> and Distance-Constrained [3] scheduling algorithms. 1 The inequality p U i ffi B i ensures that the temporal constraint imposed on object i at the backup is maintained while inequality p P i p U i guarantees that no unnecessary update is sent to the 1 An exposition of scheduling <p> Static allocation: Suppose we are given a set of objects. In this case, since all objects are given before hand, the algorithm for scheduling updates from primary to backup is relatively straightforward: 1. Assign p U i = ffi B i initially. 2. Check schedulability test using rate-monotonic <ref> [13] </ref> or distance-constrained [3] scheduling. If the test fails, then it is impossible to schedule the task set without violating the given temporal constraint so we stop here. Otherwise go to next step. 3. <p> The last condition ensures that the whole task set is schedulable under rate-monotonic <ref> [13] </ref> or distance-constrained scheduling [3] algorithm. 2. If the above allocation is not feasible, then reject the object. Global optimal 1. Insert term p P i =p U i into the ordered list that we obtained in static or previous allocations. 2. Rerun the static allocation algorithm. 8 3. <p> With proper substitution of terms, the same algorithm introduced in section 3 can be applied here. Specifically, the algorithm is as follows: 1. Assign p U i = ffi B i initially. 2. Check schedulability test using rate-monotonic <ref> [13] </ref> or distance-constrained [3] scheduling algorithm. If the test fails, then it is impossible to schedule the task set without violating the given temporal constraint so we stop here. Otherwise go to next step. 3. <p> Simply put, the primary will perform a schedulability test based on the rate-monotonic scheduling algorithm <ref> [13] </ref>. If all existing update tasks as well as the newly added update task for object i are schedulable, the object is admitted into the system. 6.2 Update scheduling In our model, client updates are decoupled from the updates to the backup.
Reference: [14] <author> J.W.S. Liu, W.-K. Shih, and K.-J. Lin. </author> <title> Imprecise computation. </title> <booktitle> In Proceedings of IEEE, </booktitle> <volume> volume 82, </volume> <pages> pages 83-94, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: SSP schedules are deadlock-free, subject to limited blocking and do not use locks. Furthermore, a schedulability bound can be given for the SSP scheduler. Simulation results show that SSP is especially useful for scheduling real-time data access on multiprocessor systems. Similarly, the notion of imprecise computation <ref> [14] </ref> explores weaker application semantics and guarantees timely completion of tasks by relaxing the accuracy requirements of the computation. This is particularly useful in applications that use discrete samples of continuous time variables, since these values can be approximated when there is not sufficient time to compute an exact value.
Reference: [15] <author> G. S. Lueker. </author> <title> Two np-complete problems in nonnegative integer programming. </title> <type> Technical Report Report No. 178, </type> <institution> Computer Science Laboratory, Princeton University, </institution> <year> 1975. </year>
Reference-contexts: Furthermore, from P i p P i , we have P i v i p P i v i = K. Hence p U i is also a solution to the integer knapsack problem. Since the integer knapsack problem is NP-complete <ref> [15] </ref>, the optimization problem is NP-complete. 2 However, the problem becomes polynomial if we impose a temporal constraint on every in dividual object (instead an overall temporal constraint on the average temporal distance for the whole object set).
Reference: [16] <author> C. Pu and A. Leff. </author> <title> Replica control in distributed systems: An asynchronous approach. </title> <booktitle> In Proceedings of ACM SIGMOD, </booktitle> <pages> pages 377-386, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: In particular, a number of researchers have observed that serializability is too strict as a correctness criterion for real-time databases. Relaxed correctness criteria facilitate higher concurrency by permitting a limited amount of inconsistency in how a transaction views the database state <ref> [4, 7-12, 16, 18] </ref>. For example, a recent work [8] [10] proposed a class of real-time data access protocols called SSP (Similarity Stack Protocol) applicable to distributed real-time systems.
Reference: [17] <author> R. Rajkumar, M. Gagliardi, and L. Sha. </author> <title> The real-time publisher/subscriber inter-process communication model for distributed real-time systems: </title> <booktitle> Design and implementation. In Proc. Real-Time Technology and Applications Symposium, </booktitle> <pages> pages 66-75, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: It guarantees agreement on membership among the communicating processors, and ensures that membership changes resulting from processor joins or departures are atomic and ordered with respect to multicast messages. Both TTP and RTCAST are based on active replication whereas RTPB is a passive scheme. Rajkumar <ref> [2, 17] </ref> presents a publisher/subscriber model for distributed real-time systems. It provides a simple user interface for publishing messages on a logical "channel", and for subscribing to selected channels as needed by each application.
Reference: [18] <author> S.B.Davidson and A. Watters. </author> <title> Partial computation in real-time database systems. </title> <booktitle> In Proc. Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 117-121, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: In particular, a number of researchers have observed that serializability is too strict as a correctness criterion for real-time databases. Relaxed correctness criteria facilitate higher concurrency by permitting a limited amount of inconsistency in how a transaction views the database state <ref> [4, 7-12, 16, 18] </ref>. For example, a recent work [8] [10] proposed a class of real-time data access protocols called SSP (Similarity Stack Protocol) applicable to distributed real-time systems.
Reference: [19] <author> T.Abdelzaher, A.Shaikh, S.Johnson, F.Jahanian, and K.G.Shin. Rtcast: </author> <title> Lightweight multicast for real-time process groups. </title> <booktitle> In IEEE Real-Time Technology and Applications Symposium, </booktitle> <year> 1996. </year>
Reference-contexts: A Fault-Tolerant Unit (FTU) in a 17 TTP system consists of a collection of replicated components operating in active redundancy. A component, consisting of a node and its application software, relies on a number of hardware and software mechanisms for error detection to ensure a fail-silent behavior. RTCAST <ref> [19] </ref> is a lightweight fault-tolerant multicast and membership service for real-time process groups which exchange periodic and aperiodic messages. The service supports bounded-time message transport, atomicity, and order for multicasts within a group of communicating processes in the presence of processor crashes and communication failures.
Reference: [20] <author> Hengming Zou and Farnam Jahanian. </author> <title> Real-time primary-backup replications with temporal consistency guarantees. </title> <booktitle> In IEEE Proceedings International Conference on Distributed Computing System, </booktitle> <pages> pages 48-56, </pages> <month> May </month> <year> 1998. </year> <month> 20 </month>
Reference-contexts: Particularly, when time is scarce and the overhead for managing redundancy is too high, an alternative solution is required to provide both timing predictability and fault tolerance. With the introduction of the concept of external temporal consistency, inter-object temporal consistency, and phase variance, we <ref> [20] </ref> have developed a real-time primary-backup (RTPB) replication service that achieves the balance between fault tolerance and timing dependability. <p> This paper tackles the optimization problem in real-time primary-backup replication from the two perspectives described above. This work builds on the Real-Time Primary-Backup (RTPB) 2 Replication with Temporal Consistency Guarantees by Zou and Jahanian <ref> [20] </ref> but distinguishes itself from that work and focuses on the area of optimization within the system. The most important contributions of this paper are the formulation of the optimization problems and the solutions to them. <p> Section 6 is the implementation followed by performance analysis in Section 7. Section 8 discusses the related work, and finally, Section 9 is our conclusion. 2 The RTPB model The work by Zou and Jahanian in <ref> [20] </ref> was an attempt to construct a fault tolerant primary-backup replication service that supports real-time computation and temporal consistency guarantees. The primary-backup replication is a widely-used approach for providing fault tolerance by replicating servers that fail independently. <p> In our replication system, these two types of temporal consistency must be ensured at all times if the replication service is to function properly in a real-time fashion. The real-time primary-backup (RTPB) model developed in <ref> [20] </ref> consists of a primary and a backup with the primary being responsible for processing client requests and keeping the backup up to date in system state. The consistency at the primary is maintained by the timely updates 3 of objects by the clients of the system. <p> can be used here if we substitute the upper bound ffi B i in the constraining inequality by ffi B i log ()= log (1 P ). 6 Implementation We have integrated the optimization techniques developed in this paper into the RTPB prototype that was built in our previous work <ref> [20] </ref>. This new modified RTPB system is implemented as a user-level x-kernel [6] based server on the MK 7.2 microkernel from the Open Group. 2 The protocol objects communicate with each other through a set of uniform x-kernel protocol interfaces. <p> Hence, it is the responsibility of the client to send updates frequently enough to make sure the primary has a fresh copy of the data. The primary server performs the temporal constraint test according to the rules developed in <ref> [20] </ref>. Specifically, it compares the value of ffi P i and p i . If p i ffi P i , then the inconsistency between the real data and the primary copy will always fall into the specified consistency window. <p> The temporal constraint for object i on the backup is also checked to ensure that it can be met <ref> [20] </ref>. <p> The optimized RTPB sends as much update as possible to the backup while the one without optimization does not. It must be noted that in both graphs, larger window size results in smaller average temporal distance, which conforms to the result presented in <ref> [20] </ref>. message loss is considered.
References-found: 20

