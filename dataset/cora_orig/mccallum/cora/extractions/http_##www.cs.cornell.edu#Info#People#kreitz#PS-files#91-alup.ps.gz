URL: http://www.cs.cornell.edu/Info/People/kreitz/PS-files/91-alup.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/kreitz/papers.html
Root-URL: http://www.cs.cornell.edu
Title: Automated Logic and Programming  
Author: Christoph Kreitz 
Abstract-found: 0
Intro-found: 1
Reference: [AC90] <author> Peter Aczel and D. Carlisle. </author> <title> The logical theory of constructions: A formal framework and its implementation. </title> <booktitle> In First workshop on logical frameworks, Antibes, </booktitle> <month> May </month> <year> 1990, 1990. </year>
Reference-contexts: HOW TO COMPUTE WELL? 139 7.2.1 Girard's Theory 7.2.2 The calculus of constructions [CH85, CH88, Coq90]CoquandHuet in VL einflieen lassen als Konkurrenz, intro o.a. wegen der vielen guten eigenschaften. KOntexte etc. 7.2.3 Other Type theoretic calculi <ref> [AC90, Ber68, Sup72] </ref> 7.3 How to compute well? This means better evaluators, compilers for Type Theory, faster computation For -PRL, a previous version, there are already some studies by Jim Sasaki [Sas85].
Reference: [ACHA90] <author> Stuart F. Allen, Robert L. Constable, Douglas J. Howe, and William E. Aitken. </author> <title> The semantics of reflected proof. </title> <editor> In John C. Mitchell, editor, </editor> <booktitle> LICS-90 | Proceedings of the Fifth Annual Symposium on Logic in Computer Science, 1990, </booktitle> <address> Philadelphia, PA, </address> <month> June </month> <year> 1990, </year> <pages> pages 95-106. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference-contexts: Both of them are very difficult and not quite solved yet. Particularly expressing partial functions in an always terminating reduction concept is extremely complicated. In the following we sketch some ideas and the current NuPRL solution [CH90a] 7.1.2 Reflection <ref> [ACHA90, GS89] </ref> 7.2 Alternative theories (optional) Since the introduction of dependent types in many of the rules defined so far we are forced to specify the exact universe. This is particularly annoying when trying to model set theoretic notions. <p> of functional programming in general [Car84] from which we may import tech nologies * procedural components to be added to NuPRL This would help making NuPRL as effective as other programming languages which means it might compete with "real" languages. 7.4 References and further reading a fairly new subject, Weyhrauch <ref> [AL84, ACHA90, CH90a, Coq90, How88b, KC86b, BM81, Wey80] </ref> [Gri88b, Gri88a, HHP87, Myh75] for other foundational theories 140 CHAPTER 7.
Reference: [Ack54] <author> W. Ackermann. </author> <title> Solvable cases of the decision problem. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1954. </year>
Reference-contexts: As discussed in Section 2.4.4 equality reasoning essentially involves reflexivity, symmetry, transitivity and substitution rules. But a formal proof using these axioms can become extremely tedious and since 1954 this particular problem is know to be decidable (see <ref> [Ack54] </ref>). Therefore it is reasonable to implement equality reasoning as a decision procedure that subsumes multiple application of reflexivity, commutativity, and transitivity rules in a single step. There are several algorithms for dealing with equality. The one we will describe here is based on work by Greg Nelson and Derek.
Reference: [AL84] <author> Luigia Aiello and Giorgio Levi. </author> <title> The uses of metaknowledge in AI systems. </title> <editor> In Tim O'Shea, editor, </editor> <booktitle> ECAI-84 | Proceedings of the 6 th European Conference on Artificial Intelligence, </booktitle> <address> Pisa, Italy, </address> <month> September </month> <year> 1984, </year> <pages> pages 705-717. </pages> <publisher> Elsevier Science Publishers B.V. (North-Holland) Amsterdam, </publisher> <year> 1984. </year>
Reference-contexts: of functional programming in general [Car84] from which we may import tech nologies * procedural components to be added to NuPRL This would help making NuPRL as effective as other programming languages which means it might compete with "real" languages. 7.4 References and further reading a fairly new subject, Weyhrauch <ref> [AL84, ACHA90, CH90a, Coq90, How88b, KC86b, BM81, Wey80] </ref> [Gri88b, Gri88a, HHP87, Myh75] for other foundational theories 140 CHAPTER 7.
Reference: [All87a] <author> Stuart Allen. </author> <title> A non-type-theoretic definition of Martin-Lof's types. </title> <editor> In David Gries, editor, </editor> <booktitle> LICS-87 | Proceedings of the Second Annual Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, New York, USA, </address> <month> June </month> <year> 1987, </year> <pages> pages 215-224. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference-contexts: Several other books and articles [ML84, NPS90, BCM88a, BCM88b, Bac89] give introductions to Martin-Lof's theory of types, on which the above theory is based. Semantical questions have been dealt with in <ref> [All87a, All87b, Con89, CH90b, Men87a] </ref>. The aspect of programming in Type Theory and extracting proofs from programs has been investigated in [BC85, Bac85, Con83, Con84, Con85, Con88, Hay86, Chi87, Smi83, NS84, NPS90, Lei90]. The concept of recursive types is fairly new.
Reference: [All87b] <author> Stuart Allen. </author> <title> A non-type-theoretic semantics for type-theoretic language. </title> <type> PhD thesis, </type> <institution> Cor-nell University. Department of Computer Science, </institution> <address> Ithaca, NY 14853-7501, </address> <month> December </month> <year> 1987. </year> <type> TR 87-866. </type>
Reference-contexts: Several other books and articles [ML84, NPS90, BCM88a, BCM88b, Bac89] give introductions to Martin-Lof's theory of types, on which the above theory is based. Semantical questions have been dealt with in <ref> [All87a, All87b, Con89, CH90b, Men87a] </ref>. The aspect of programming in Type Theory and extracting proofs from programs has been investigated in [BC85, Bac85, Con83, Con84, Con85, Con88, Hay86, Chi87, Smi83, NS84, NPS90, Lei90]. The concept of recursive types is fairly new.
Reference: [And71] <author> Peter B. Andrews. </author> <title> Resolution in type theory. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 36(3) </volume> <pages> 414-432, </pages> <month> September </month> <year> 1971. </year>
Reference-contexts: The algorithm is described in Figure 5.5. 5.2.3 Other Methods For classical first order logic there is a rich variety of proof methods which usually code some complete search strategy (see, for instance <ref> [Rob65, And71, Bib87] </ref>). Inherent in these methods is the possibility that the procedure will fail after an investment of considerable resources. Since 5.3.
Reference: [And86] <author> Peter B. Andrews. </author> <title> An Introduction to mathematical logic and Type Theory: To Truth through Proof. </title> <publisher> Academic Press, </publisher> <address> London, Orlando, </address> <year> 1986. </year>
Reference: [Bac85] <author> Roland C. Backhouse. </author> <title> Algorithm development in Martin-Lof's Type Theory. </title> <type> Technical report, </type> <institution> Computer Science Department, University of Essex, </institution> <address> England, </address> <year> 1985. </year>
Reference: [Bac89] <author> Roland C. Backhouse. </author> <title> Constructive Type Theory an introduction. </title> <editor> In Manfred Broy, editor, </editor> <booktitle> Constructive Methods in Computer Science, volume 55 of NATO ASI Series, Series F: Computer & System Sciences, </booktitle> <pages> pages 9-62. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1989. </year>
Reference-contexts: THE TYPE THEORY OF NUPRL 4.6 References and further reading Most details about the individual type constructs can be found in the book describing the NuPRL proof development system [CAB + 86]. Several other books and articles <ref> [ML84, NPS90, BCM88a, BCM88b, Bac89] </ref> give introductions to Martin-Lof's theory of types, on which the above theory is based. Semantical questions have been dealt with in [All87a, All87b, Con89, CH90b, Men87a].
Reference: [Bar81] <author> Henk P. Barendregt. </author> <title> The Lambda Calculus. Its syntax and semantics, </title> <booktitle> volume 103 of Studies in Logic and The Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1981. </year> <note> (revised version 1984). </note>
Reference: [Bas89] <author> David A. Basin. </author> <title> Building theories in NuPRL. </title> <editor> In A. R. Meyer and M. A. Taitslin, editors, </editor> <booktitle> Logic at Botik 89, number 363 in Lecture Notes in Computer Science, </booktitle> <pages> pages 12-25. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1989. </year> <note> 155 156 BIBLIOGRAPHY </note>
Reference-contexts: The tactic mechanism also allows to structure the deductive power of the system around specialized reasoners. Users have been able to write a collection of tactics and theorems designed to construct proofs about a particular concept (see, for instance <ref> [How86, How87, How88a, Kre86, Bas89] </ref>) Experiences with tactics have demonstrated the effectiveness of the tactic mechanism. Tactics provide a level of abstraction comparable to that of the object theory. Thus users can build proofs and tactics with nearly equal facility.
Reference: [BC85] <author> Joseph L. Bates and Robert L. Constable. </author> <title> Proofs as programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 113-136, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: In Type Theory, however, we can turn this theorem into a method for developing programs. Principle 4 In Type Theory program development is the same as proof construction. This principle, which has become known under the name "proofs as programs principle" <ref> [BC85] </ref>, provides a meaningful way to develop programs which are guaranteed to be correct. At a first glance, programming by proving the satisfiability of a program specification seems to be quite unnatural and inefficient. <p> in int, a6=b by (a=b in int)!void, a&gt;b by b&lt;a , ab by (b&lt;a)!void, and ab by (a&lt;b)!void. 19 For instance, if i 1 refers to t1&gt;t2 and i 2 to t3=t4 and op is +, then the new hypotheses are t1+t3t2+t4+1 and t1+t4t2+t3+1 20 The example goes back to <ref> [BC85] </ref> where the principle of proofs of programs was first elaborated. 4.3.
Reference: [BCM88a] <author> Roland C. Backhouse, P. Chisholm, and Grant Malcolm. </author> <title> Do it yourself type theory (part I). </title> <journal> EATCS Bulletin, </journal> <volume> 34 </volume> <pages> 68-110, </pages> <year> 1988. </year> <note> Also in Formal aspects of computing </note> 1:19-84, 1989. 
Reference-contexts: THE TYPE THEORY OF NUPRL 4.6 References and further reading Most details about the individual type constructs can be found in the book describing the NuPRL proof development system [CAB + 86]. Several other books and articles <ref> [ML84, NPS90, BCM88a, BCM88b, Bac89] </ref> give introductions to Martin-Lof's theory of types, on which the above theory is based. Semantical questions have been dealt with in [All87a, All87b, Con89, CH90b, Men87a].
Reference: [BCM88b] <author> Roland C. Backhouse, P. Chisholm, and Grant Malcolm. </author> <title> Do it yourself type theory (part II). </title> <journal> EATCS Bulletin, </journal> <volume> 35 </volume> <pages> 205-245, </pages> <year> 1988. </year>
Reference-contexts: THE TYPE THEORY OF NUPRL 4.6 References and further reading Most details about the individual type constructs can be found in the book describing the NuPRL proof development system [CAB + 86]. Several other books and articles <ref> [ML84, NPS90, BCM88a, BCM88b, Bac89] </ref> give introductions to Martin-Lof's theory of types, on which the above theory is based. Semantical questions have been dealt with in [All87a, All87b, Con89, CH90b, Men87a].
Reference: [Ber68] <author> Paul Bernays. </author> <title> Axiomatic Set Theory. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1968. </year>
Reference-contexts: HOW TO COMPUTE WELL? 139 7.2.1 Girard's Theory 7.2.2 The calculus of constructions [CH85, CH88, Coq90]CoquandHuet in VL einflieen lassen als Konkurrenz, intro o.a. wegen der vielen guten eigenschaften. KOntexte etc. 7.2.3 Other Type theoretic calculi <ref> [AC90, Ber68, Sup72] </ref> 7.3 How to compute well? This means better evaluators, compilers for Type Theory, faster computation For -PRL, a previous version, there are already some studies by Jim Sasaki [Sas85].
Reference: [BG90] <author> Lee Blaine and Allen Goldberg. </author> <title> Verifiably correct data type refinement. </title> <type> Technical report, </type> <institution> Kestrel Institute, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: A theory presentation is a pair (; ) where is a signature giving the vocabulary of the theory and is a set of axioms for the theory. A concrete theory presentation can have the following components: 1 taken from <ref> [BG90] </ref> and the quoted standard books 133 134 CHAPTER 6. BUILDING THEORIES * A name used to identify the theory * A list of names of imported theories, i.e. theories where the new theory depends on. * A list of type variables involved.
Reference: [Bib87] <author> Wolfgang Bibel. </author> <title> Automated Theorem Proving. </title> <publisher> Vieweg Verlag, </publisher> <address> Braunschweig, </address> <note> second edition, </note> <year> 1987. </year>
Reference-contexts: The level of machine support is extremely low and the loss factor between formal and 'ordinary' proofs is very high which makes formal proofs also difficult to read. * At the other extreme is automatic theorem proving, as exemplified by various well-known provers <ref> [Ble77, Bib87, BM79, LSBB90, WOLB84] </ref>. They rely on Godel's completeness theorem which essentially says that for each theorem that is true a proof can be found by an exhaustive search procedure. <p> The algorithm is described in Figure 5.5. 5.2.3 Other Methods For classical first order logic there is a rich variety of proof methods which usually code some complete search strategy (see, for instance <ref> [Rob65, And71, Bib87] </ref>). Inherent in these methods is the possibility that the procedure will fail after an investment of considerable resources. Since 5.3.
Reference: [Bis67] <author> Errett Bishop. </author> <title> Foundations of Constructive Analysis. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1967. </year> <note> revised and extended version: </note> [?]. 
Reference: [Ble77] <author> W. Bledsoe. </author> <title> Non-resolution theorem proving. </title> <journal> Artificial Intelligence, </journal> <volume> 9(1) </volume> <pages> 1-35, </pages> <year> 1977. </year>
Reference-contexts: The level of machine support is extremely low and the loss factor between formal and 'ordinary' proofs is very high which makes formal proofs also difficult to read. * At the other extreme is automatic theorem proving, as exemplified by various well-known provers <ref> [Ble77, Bib87, BM79, LSBB90, WOLB84] </ref>. They rely on Godel's completeness theorem which essentially says that for each theorem that is true a proof can be found by an exhaustive search procedure.
Reference: [BM79] <author> Robert S. Boyer and J. Strother Moore. </author> <title> A computational Logic. </title> <publisher> Academic Press, </publisher> <address> London, New York, </address> <year> 1979. </year>
Reference-contexts: The level of machine support is extremely low and the loss factor between formal and 'ordinary' proofs is very high which makes formal proofs also difficult to read. * At the other extreme is automatic theorem proving, as exemplified by various well-known provers <ref> [Ble77, Bib87, BM79, LSBB90, WOLB84] </ref>. They rely on Godel's completeness theorem which essentially says that for each theorem that is true a proof can be found by an exhaustive search procedure.
Reference: [BM81] <author> Robert S. Boyer and J. Strother Moore. Metafunctions: </author> <title> Proving them correct and using them efficiently as new proof procedures. </title> <editor> In Robert S. Boyer and J. Strother Moore, editors, </editor> <booktitle> The Correctness Problem in Computer Science, </booktitle> <pages> pages 103-184. </pages> <publisher> Academic Press, </publisher> <address> London, New York, </address> <year> 1981. </year>
Reference-contexts: of functional programming in general [Car84] from which we may import tech nologies * procedural components to be added to NuPRL This would help making NuPRL as effective as other programming languages which means it might compete with "real" languages. 7.4 References and further reading a fairly new subject, Weyhrauch <ref> [AL84, ACHA90, CH90a, Coq90, How88b, KC86b, BM81, Wey80] </ref> [Gri88b, Gri88a, HHP87, Myh75] for other foundational theories 140 CHAPTER 7.
Reference: [Bru80] <author> N. G. De Bruijn. </author> <title> A survey of the project AUTOMATH. </title> <editor> In J.P. Seldin and J.R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <publisher> Academic Press, </publisher> <address> London, New York, </address> <year> 1980. </year>
Reference-contexts: It should therefore be investigated how to provide sufficient machine support for proving theorems and developing programs in Type Theory efficiently. One can identify at least three distinct general approaches to automating reasoning. * At one extreme is pure proof checking, as exemplified by AUTOMATH <ref> [Bru80, vBJ77] </ref>. These methods rely on a very expressive language to capture the abstractions that make rigorous mathematics possible. They require large libraries and use a minimum amount of algorithmic metamathematics.
Reference: [Bun89] <author> Alan Bundy. </author> <title> Automatic guidance of program synthesis proofs. </title> <booktitle> In Proceedings of the Workshop on Automating Software Design, IJCAI-89, Kestrel Institute, </booktitle> <address> Palo Alto, </address> <pages> pages 57-59, </pages> <year> 1989. </year>
Reference-contexts: The concept of tactical theorem proving has been first discussed in [GMW79] and been elaborated for Type Theory in [CKB85]. Tactical theorem proving is also used in Cambridge LCF [Pau87], -PROLOG [FM88], the Oyster system <ref> [Bun89] </ref>, and the KIV system [HRS90]. Chapter 6 Building Theories We have discussed the theory in which to express mathematics and programming and concepts for efficient proofs and program development. We will now investigate aspects of "implementing mathematics", i.e. developing object theories in a system that implements Type Theory.
Reference: [CAB + 86] <author> Robert L. Constable, Stuart F. Allen, H. Mark Bromley, W. Rance Cleaveland, J. F. Cremer, Robert W. Harper, Douglas J. Howe, Todd B. Knoblock, Nax Paul Mendler, Prakash Panangaden, Jim T. Sasaki, and Scott F. Smith. </author> <title> Implementing Mathematics with the NuPRL proof development system. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: The definition of natural numbers by 0 and the successor function s may be considered as a particular instance of lists over a type with only one element. Therefore the rules for lists can be derived as extensions of those of IN. See page 159 of <ref> [CAB + 86] </ref> for details. 4.3.4 A programming example Having introduced the standard types for programming we will show by a larger example 20 that programming and mathematical problem solving are in fact closely related and that applying the "proofs-as-programs" principle is a meaningful way to develop programs. <p> 25 For anyone experienced with mathematics or programming recursive definition needs no motivation; its expressiveness, elegance, and computational efficiency is unsurpassed by any 23 Note the similarity of set and product rules except for the handling of extract terms. 24 This is a simplification of the elimination rule described in <ref> [CAB + 86] </ref>. The well-formedness subgoal has been removed since it turned out to cause unacceptable practical problems. The equality rule which differed from being an extension of the introduction rule for the set constructor had to be dropped. 25 This section is not completed yet. <p> See [Men87a] for a detailed analysis of infinite types. 4.5 Other types In this section we will briefly discuss types not mentioned yet. Details can be found in the NuPRL-book <ref> [CAB + 86] </ref>. 104 CHAPTER 4. THE TYPE THEORY OF NUPRL 4.5.1 Quotients Quotient Types are helpful to define new types from given ones by changing the equality relation. Rational numbers, for instance, are defined by fractions of integers (c.f. chapter 11 of [CAB + 86]). <p> Details can be found in the NuPRL-book <ref> [CAB + 86] </ref>. 104 CHAPTER 4. THE TYPE THEORY OF NUPRL 4.5.1 Quotients Quotient Types are helpful to define new types from given ones by changing the equality relation. Rational numbers, for instance, are defined by fractions of integers (c.f. chapter 11 of [CAB + 86]). Real numbers are constructed by converging sequences of rationals. In these and similar cases a new equality needs to be defined. Since this kind of equality should not be treated differently from equality of other types a quotient type construct (x,y):A//E has been introduced. <p> THE TYPE THEORY OF NUPRL 4.6 References and further reading Most details about the individual type constructs can be found in the book describing the NuPRL proof development system <ref> [CAB + 86] </ref>. Several other books and articles [ML84, NPS90, BCM88a, BCM88b, Bac89] give introductions to Martin-Lof's theory of types, on which the above theory is based. Semantical questions have been dealt with in [All87a, All87b, Con89, CH90b, Men87a]. <p> The aspect of programming in Type Theory and extracting proofs from programs has been investigated in [BC85, Bac85, Con83, Con84, Con85, Con88, Hay86, Chi87, Smi83, NS84, NPS90, Lei90]. The concept of recursive types is fairly new. Chapter 12 of <ref> [CAB + 86] </ref> and [CM85, CS87, CS88, Men87a, Men87b, Smi88] present the current research. Chapter 5 Implementing Automated Reasoning In the previous chapters we have discussed the development of NuPRL's type theory out of the typed -calculus. <p> See [GMW79] and <ref> [CAB + 86] </ref>, chapters 6, 9, and Appendix A for a complete account. 5.1. BUILDING SYSTEMS FOR INTERACTIVE PROOF DEVELOPMENT 109 . <p> We will now briefly discuss features of the NuPRL system for interactive proof development in Type Theory. The reader interested in further details may look up chapters 3-5 and 7 of <ref> [CAB + 86] </ref>. The purpose of such a system is developing mathematical knowledge and programs in a style as it is done in mathematical textbooks. <p> It is rather advisable to write small and controllable tactics which are fast and powerful for a special purpose and are initiated by a user at the right position in a proof. 5.4 References and further reading The book describing the NuPRL proof development system <ref> [CAB + 86] </ref> should be considered as a reference book for this chapter. Futher informations about decision procedures can be found in [CJE82] (particularly the Appendix "An algorithm for checking PL/CV arithmetic inferences" by Tat-hung Chan) and [NO79, NO80].
Reference: [Car84] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. In Semantics of Data Types, </title> <booktitle> number 173 in Lecture Notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1984. </year>
Reference-contexts: Very helpful are also * A study of functional programming in general <ref> [Car84] </ref> from which we may import tech nologies * procedural components to be added to NuPRL This would help making NuPRL as effective as other programming languages which means it might compete with "real" languages. 7.4 References and further reading a fairly new subject, Weyhrauch [AL84, ACHA90, CH90a, Coq90, How88b, KC86b,
Reference: [CC90] <author> F. Cardone and M. Coppo. </author> <title> Two extendsions of Curry's type inference system. </title> <editor> In Piergiorgio Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 19-76. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1990. </year>
Reference: [CFC58] <author> Haskell B. Curry, R. Feys, and W. Craig. </author> <booktitle> Combinatory Logic, </booktitle> <volume> volume 1. </volume> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference: [CH85] <author> Thierry Coquand and Gerard Huet. </author> <title> Constructions: A higher order proof system for mechanizing mathematics. </title> <booktitle> In EUROCAL'85, </booktitle> <pages> pages 151-184, </pages> <address> Linz, Austria, </address> <month> April </month> <year> 1985. </year> <note> BIBLIOGRAPHY 157 </note>
Reference-contexts: Function types do not need a hierarchy like (IN!IN) 2 in their definition 7.3. HOW TO COMPUTE WELL? 139 7.2.1 Girard's Theory 7.2.2 The calculus of constructions <ref> [CH85, CH88, Coq90] </ref>CoquandHuet in VL einflieen lassen als Konkurrenz, intro o.a. wegen der vielen guten eigenschaften.
Reference: [CH88] <author> Thierry Coquand and Gerard Huet. </author> <title> The calculus of constructions. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 95-120, </pages> <year> 1988. </year>
Reference-contexts: Function types do not need a hierarchy like (IN!IN) 2 in their definition 7.3. HOW TO COMPUTE WELL? 139 7.2.1 Girard's Theory 7.2.2 The calculus of constructions <ref> [CH85, CH88, Coq90] </ref>CoquandHuet in VL einflieen lassen als Konkurrenz, intro o.a. wegen der vielen guten eigenschaften.
Reference: [CH90a] <author> Robert L. Constable and Douglas J. Howe. </author> <title> Implementing metamathematics as an approach to automatic theorem proving. </title> <editor> In R. B. Banerjee, editor, </editor> <booktitle> Formal techniques in Artificial Intelligence, a sourcebook, </booktitle> <pages> pages 45-75. </pages> <publisher> Elsevier Science Publishers B.V. (North-Holland) Amsterdam, </publisher> <year> 1990. </year>
Reference-contexts: BUILDING THEORIES 6.3 Automated Theorem Proving <ref> [CH90a] </ref> 6.4 Application to Program Construction/Development and verification 6.4.1 program synthesis, verification,... KIDS, LOPS,... 6.5 References and further reading Chapter 7 Advanced Topics There are still a lot of issues about NuPRL which will be the research topics for the next years: 1. How to compute well? 2. <p> Both of them are very difficult and not quite solved yet. Particularly expressing partial functions in an always terminating reduction concept is extremely complicated. In the following we sketch some ideas and the current NuPRL solution <ref> [CH90a] </ref> 7.1.2 Reflection [ACHA90, GS89] 7.2 Alternative theories (optional) Since the introduction of dependent types in many of the rules defined so far we are forced to specify the exact universe. This is particularly annoying when trying to model set theoretic notions. <p> of functional programming in general [Car84] from which we may import tech nologies * procedural components to be added to NuPRL This would help making NuPRL as effective as other programming languages which means it might compete with "real" languages. 7.4 References and further reading a fairly new subject, Weyhrauch <ref> [AL84, ACHA90, CH90a, Coq90, How88b, KC86b, BM81, Wey80] </ref> [Gri88b, Gri88a, HHP87, Myh75] for other foundational theories 140 CHAPTER 7.
Reference: [CH90b] <author> Robert L. Constable and Douglas J. Howe. </author> <title> Nuprl as a general logic. </title> <editor> In Piergiorgio Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 77-90. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1990. </year>
Reference-contexts: Several other books and articles [ML84, NPS90, BCM88a, BCM88b, Bac89] give introductions to Martin-Lof's theory of types, on which the above theory is based. Semantical questions have been dealt with in <ref> [All87a, All87b, Con89, CH90b, Men87a] </ref>. The aspect of programming in Type Theory and extracting proofs from programs has been investigated in [BC85, Bac85, Con83, Con84, Con85, Con88, Hay86, Chi87, Smi83, NS84, NPS90, Lei90]. The concept of recursive types is fairly new.
Reference: [Chi87] <author> Paul Chisholm. </author> <title> Derivation of a parsing algorithm in Martin-Lof's Type Theory. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 1-42, </pages> <year> 1987. </year>
Reference: [CHS72] <author> Haskell B. Curry, J. Roger Hindley, and Jonathan P. </author> <title> Seldin. </title> <booktitle> Combinatory Logic, </booktitle> <volume> volume 2. </volume> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1972. </year>
Reference: [Chu40] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference: [CJE82] <author> Robert L. Constable, Scott D. Johnson, and Carl D. Eichenlaub. </author> <title> Introduction to the PL/CV2 Programming Logic, </title> <booktitle> volume 135 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1982. </year>
Reference-contexts: This can be accomplished by formaling the (informally present) metalanguage of the underlying theory as an interactive programming language. During the LCF project this idea resulted in the design of the metalanguage ML which now has become a widely accepted functional programming language. Experiences with LCF [GMW79], PL/CV <ref> [CJE82] </ref>, and -PRL have shown that implementing a proof system within such a metalanguage also results in a greater flexibility of the proof system. <p> In this section we will give a rather short and informal description. Details can be found in <ref> [CJE82] </ref>. 11 Let us begin with some examples that can be handled by arith and would have been quite difficult to prove without it. 12 Example 5.2.1 Let i :hyp denote that i is is the number of the hypothesis hyp. <p> Its version for NuPRL required some modifications since the previous systems did not use Type Theory as underlying formalism. The article "An algorithm for checking PL/CV arithmetic inferences" by Tat-hung Chan in <ref> [CJE82] </ref> gives a detailed account and a proof of the correctness. 12 It should be noted that all the problems which are proven by the arith procedure could also be proven in Type Theory directly. Adding arith comes out of purely practical considerations . 5.2. DECISION PROCEDURES 119 2. <p> These general tactics have allowed to achieve in a matter of days most of the capabilities of the mechanisms 132 CHAPTER 5. IMPLEMENTING AUTOMATED REASONING in earlier systems (e.g. PL/CV <ref> [CJE82] </ref>) which had to be hand coded (on a scale of weeks). Moreover, these tactics are much easier understood in detail and can be employed in building more complicated tactics. The tactic mechanism also allows to structure the deductive power of the system around specialized reasoners. <p> Futher informations about decision procedures can be found in <ref> [CJE82] </ref> (particularly the Appendix "An algorithm for checking PL/CV arithmetic inferences" by Tat-hung Chan) and [NO79, NO80]. The concept of tactical theorem proving has been first discussed in [GMW79] and been elaborated for Type Theory in [CKB85].
Reference: [CKB85] <author> Robert L. Constable, Todd B. Knoblock, and Joseph L. Bates. </author> <title> Writing programs that construct proofs. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 1 </volume> <pages> 285-326, </pages> <year> 1985. </year>
Reference-contexts: Futher informations about decision procedures can be found in [CJE82] (particularly the Appendix "An algorithm for checking PL/CV arithmetic inferences" by Tat-hung Chan) and [NO79, NO80]. The concept of tactical theorem proving has been first discussed in [GMW79] and been elaborated for Type Theory in <ref> [CKB85] </ref>. Tactical theorem proving is also used in Cambridge LCF [Pau87], -PROLOG [FM88], the Oyster system [Bun89], and the KIV system [HRS90]. Chapter 6 Building Theories We have discussed the theory in which to express mathematics and programming and concepts for efficient proofs and program development.
Reference: [CM85] <author> Robert L. Constable and Nax Paul Mendler. </author> <title> Recursive definitions in Type Theory. </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Proceedings of the Logics of Programs Conference, </booktitle> <address> Brooklyn, NY, USA, </address> <month> June </month> <year> 1985, </year> <booktitle> volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 61-78. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1985. </year>
Reference-contexts: Details can be found in <ref> [CM85, Men87a, MPC86] </ref>. 4.4.1 Inductive Types Inductive definition means interpreting a recursively defined object by the smallest fixed point of the equation defining it. Nearly all recursive equations are to be understood as inductive definition. A typical example of an inductively defined type are binary trees over integer numbers. <p> The so called 3x+1-function is defined by f (x) &gt; &lt; 0 if x = 1; f (x=2) if x is even; f (3x + 1) otherwise 26 Such types are legal in languages like Algol or ML but require a notion of partial functions (see Section 4.4.2). 27 See <ref> [CM85, Men87a] </ref> for a full definition. 102 CHAPTER 4. THE TYPE THEORY OF NUPRL It could be easily defined as x.rec ind (x;f,y.int eq (y;1;0;int eq (y mod 2;0;f (x/2);f (3*x+1)))) and applied although its domain is unknown. <p> The aspect of programming in Type Theory and extracting proofs from programs has been investigated in [BC85, Bac85, Con83, Con84, Con85, Con88, Hay86, Chi87, Smi83, NS84, NPS90, Lei90]. The concept of recursive types is fairly new. Chapter 12 of [CAB + 86] and <ref> [CM85, CS87, CS88, Men87a, Men87b, Smi88] </ref> present the current research. Chapter 5 Implementing Automated Reasoning In the previous chapters we have discussed the development of NuPRL's type theory out of the typed -calculus.
Reference: [Con83] <author> Robert L. Constable. </author> <title> Programs as proofs. </title> <journal> Information Processing Letters, </journal> <volume> 16(3) </volume> <pages> 105-112, </pages> <year> 1983. </year>
Reference: [Con84] <author> Robert L. Constable. </author> <note> Mathematics as programming. </note> <editor> In Edmund Clarke and Dexter Kozen, editors, </editor> <booktitle> Logics of Programs, number 164 in Lecture Notes in Computer Science, </booktitle> <pages> pages 116-128. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1984. </year>
Reference: [Con85] <author> Robert L. Constable. </author> <title> Constructive mathematics as a programming logic I: Some principles of theory. </title> <journal> Annals of Discrete Mathematics, </journal> <volume> 24 </volume> <pages> 21-38, </pages> <year> 1985. </year>
Reference: [Con88] <author> Robert L. Constable. </author> <booktitle> Themes in the development of programming logics circa 1963-1987. Annual Reviews in Computer Science, </booktitle> <pages> pages 147-165, </pages> <year> 1988. </year>
Reference: [Con89] <author> Robert L. Constable. </author> <title> Assigning meaning to proofs: a semantic basis for problem solving environments. </title> <editor> In Manfred Broy, editor, </editor> <booktitle> Constructive Methods in Computer Science, volume 55 of NATO ASI Series, Series F: Computer & System Sciences, </booktitle> <pages> pages 63-94. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1989. </year>
Reference-contexts: Several other books and articles [ML84, NPS90, BCM88a, BCM88b, Bac89] give introductions to Martin-Lof's theory of types, on which the above theory is based. Semantical questions have been dealt with in <ref> [All87a, All87b, Con89, CH90b, Men87a] </ref>. The aspect of programming in Type Theory and extracting proofs from programs has been investigated in [BC85, Bac85, Con83, Con84, Con85, Con88, Hay86, Chi87, Smi83, NS84, NPS90, Lei90]. The concept of recursive types is fairly new.
Reference: [Coq90] <author> Thierry Coquand. </author> <title> Metamathematical investigations of a calculus of constructions. </title> <editor> In Pier-giorgio Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 91-122. </pages> <publisher> Academic Press, </publisher> <address> Lon-don, </address> <year> 1990. </year> <note> 158 BIBLIOGRAPHY </note>
Reference-contexts: Function types do not need a hierarchy like (IN!IN) 2 in their definition 7.3. HOW TO COMPUTE WELL? 139 7.2.1 Girard's Theory 7.2.2 The calculus of constructions <ref> [CH85, CH88, Coq90] </ref>CoquandHuet in VL einflieen lassen als Konkurrenz, intro o.a. wegen der vielen guten eigenschaften. <p> of functional programming in general [Car84] from which we may import tech nologies * procedural components to be added to NuPRL This would help making NuPRL as effective as other programming languages which means it might compete with "real" languages. 7.4 References and further reading a fairly new subject, Weyhrauch <ref> [AL84, ACHA90, CH90a, Coq90, How88b, KC86b, BM81, Wey80] </ref> [Gri88b, Gri88a, HHP87, Myh75] for other foundational theories 140 CHAPTER 7.
Reference: [CR36] <author> Alonzo Church and B. J. Rosser. </author> <title> Some properties of conversion. </title> <journal> Trans. Am. Math. Soc., </journal> <volume> 39 </volume> <pages> 472-482, </pages> <year> 1936. </year>
Reference: [CS87] <author> Robert L. Constable and Scott Fraser Smith. </author> <title> Partial objects in constructive Type Theory. </title> <editor> In David Gries, editor, </editor> <booktitle> LICS-87 | Proceedings of the Second Annual Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, New York, USA, </address> <month> June </month> <year> 1987, </year> <pages> pages 183-193. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference-contexts: The aspect of programming in Type Theory and extracting proofs from programs has been investigated in [BC85, Bac85, Con83, Con84, Con85, Con88, Hay86, Chi87, Smi83, NS84, NPS90, Lei90]. The concept of recursive types is fairly new. Chapter 12 of [CAB + 86] and <ref> [CM85, CS87, CS88, Men87a, Men87b, Smi88] </ref> present the current research. Chapter 5 Implementing Automated Reasoning In the previous chapters we have discussed the development of NuPRL's type theory out of the typed -calculus.
Reference: [CS88] <author> Robert L. Constable and Scott Fraser Smith. </author> <title> Computational foundations of basic recursive function theory. </title> <editor> In Yuri Gurevich, editor, </editor> <booktitle> LICS-88 | Proceedings of the Third Annual Symposium on Logic in Computer Science, </booktitle> <address> Edinburgh, Scotland, </address> <month> July </month> <year> 1988, </year> <pages> pages 360-371. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: The aspect of programming in Type Theory and extracting proofs from programs has been investigated in [BC85, Bac85, Con83, Con84, Con85, Con88, Hay86, Chi87, Smi83, NS84, NPS90, Lei90]. The concept of recursive types is fairly new. Chapter 12 of [CAB + 86] and <ref> [CM85, CS87, CS88, Men87a, Men87b, Smi88] </ref> present the current research. Chapter 5 Implementing Automated Reasoning In the previous chapters we have discussed the development of NuPRL's type theory out of the typed -calculus.
Reference: [Cur70] <author> Haskell B. Curry. </author> <title> Outline of a formalist philosophy of mathematics. </title> <publisher> North-Holland, </publisher> <address> Ams-terdam, </address> <year> 1970. </year>
Reference: [Dij76] <author> Edsger W. Dijkstra. </author> <title> A discipline of Programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1976. </year>
Reference-contexts: At a first glance, programming by proving the satisfiability of a program specification seems to be quite unnatural and inefficient. However, it has turned out that many program methodologies made by Hoare [Hoa72], Dijkstra <ref> [Dij76] </ref>, and others are nothing but special reformulations of methodologies for proofs, a fact which was discovered by David Gries [Gri81]. <p> Still another possibility is to generalize some property of A (p; n) by adding an extra parameter m and performing induction on m. This technique which we will use below is called generalization in Polya's book on mathematical problem solving [Pol45] while in the context of programming <ref> [Gri81, Dij76, Rey81] </ref> it is called weakening. Quite often the formal specification of the problem already suggests a method for solving it.
Reference: [DM82] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proceedings of the 9 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <year> 1982. </year>
Reference: [Dum77] <author> Michael Dummett. </author> <title> Elements of Intuitionism. </title> <booktitle> Oxford Logic Series. </booktitle> <publisher> Clarenden Press, Oxford, </publisher> <year> 1977. </year>
Reference: [FM88] <author> Amy Felty and Dale Miller. </author> <title> Specifying theorem provers in a higher-order logic programming language. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proceedings of the 9 th Conference on Automated Deduction, </booktitle> <address> Argonne, Illinois, </address> <month> May </month> <year> 1988, </year> <booktitle> volume 310 of Lecture Notes in Computer Science, </booktitle> <pages> pages 61-80. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1988. </year>
Reference-contexts: The concept of tactical theorem proving has been first discussed in [GMW79] and been elaborated for Type Theory in [CKB85]. Tactical theorem proving is also used in Cambridge LCF [Pau87], -PROLOG <ref> [FM88] </ref>, the Oyster system [Bun89], and the KIV system [HRS90]. Chapter 6 Building Theories We have discussed the theory in which to express mathematics and programming and concepts for efficient proofs and program development.
Reference: [Gal86] <author> Jean H. Gallier. </author> <title> Logic for Computer Science: Foundations of Automated Theorem Proving. </title> <publisher> Harper and Row, </publisher> <address> New York, </address> <year> 1986. </year>
Reference: [Gen35] <author> Gerhard Gentzen. </author> <title> Untersuchungen uber das logische Schlieen. </title> <journal> Mathematische Zeitschrift, </journal> <volume> 39 </volume> <pages> 176-210, 405-431, </pages> <year> 1935. </year> <title> English Translation: "Investigations into logical deduction" in [?] pages 68-131. </title>
Reference: [Gir71] <author> Jean-Yves Girard. </author> <title> Une extension de l'interpretation de godel a l'analyse, et son application a l'elimination des coupures dans l'analyse at la theorie des types. </title> <editor> In J. Fenstad, editor, </editor> <booktitle> Proceedings of the second Scandinavian Logic Symposium, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1971. </year>
Reference: [Gir72] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures dans l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universsite Paris VII, </institution> <year> 1972. </year>
Reference: [Gir86] <author> Jean-Yves Girard. </author> <title> The system F of variable types: Fifteen years later. </title> <journal> Theoretical Computer Science, </journal> <volume> 45 </volume> <pages> 159-192, </pages> <year> 1986. </year>
Reference: [GLT89] <author> Jean-Yves Girard, Yves Lafont, and Paul Taylor. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference: [GMW79] <author> Michael J. Gordon, Robin Milner, and Christopher P. Wadsworth. </author> <title> Edinburgh LCF: A mechanized Logic of Computation. </title> <booktitle> Number 78 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1979. </year> <note> BIBLIOGRAPHY 159 </note>
Reference-contexts: The t i are bound in all the T j but x i only in T i . Recursive types are a manifestation of the basic ideas about recursive data structures (see [Hoa75] and <ref> [GMW79] </ref> for a detailed rigorous account) in the setting of Type Theory. Far more delicate than the above examples is the concept of recursive types when function 4.4. RECURSIVE DEFINITION 101 spaces are involved as in rec (T.T!T) or rec (T.T!A). 26 Example 4.4.1 Consider the type S rec (T.T!int). <p> This means that it can be used to define its domain which depends on what can be proven about it. Partial functions, therefore, are handled by viewing them as total functions over their domain of convergence. Following the approach of LCF <ref> [GMW79] </ref> we denote a partial recursive function by fix (f ,x.t) where f and x are variables which become bound in the term t. 28 Application is denoted by f [a] to keep a distinction from application in the context of total functions. fix (f ,x.t)[a] reduces to t [fix (f <p> Algorithms for simple theories such as equality and arithmetic have been quite successful and efficient. The paradigm of tactical theorem proving, first investigated within the LCF Project <ref> [GMW79] </ref> offers a method to combine the strengths of all these approaches. The idea was to build a 107 108 CHAPTER 5. <p> This can be accomplished by formaling the (informally present) metalanguage of the underlying theory as an interactive programming language. During the LCF project this idea resulted in the design of the metalanguage ML which now has become a widely accepted functional programming language. Experiences with LCF <ref> [GMW79] </ref>, PL/CV [CJE82], and -PRL have shown that implementing a proof system within such a metalanguage also results in a greater flexibility of the proof system. <p> See <ref> [GMW79] </ref> and [CAB + 86], chapters 6, 9, and Appendix A for a complete account. 5.1. BUILDING SYSTEMS FOR INTERACTIVE PROOF DEVELOPMENT 109 . <p> The idea of validations arose first within the LCF concept of proof tactics <ref> [GMW79] </ref> and will be discussed further in Section 5.3 when we investigate programming proofs on the metalevel. Adopting this concept to the implementation of Type Theory led to viewing a rule as a special (single step) instance of a tactic. <p> Therefore a system should provide a mechanism that allows a user to experiment with a various strategies while providing the greatest possible security against faulty proofs. This idea first came up in the LCF Project <ref> [GMW79] </ref> and has been realized by allowing the user to program proof strategies interactively using the metalanguage ML. <p> Here, a problem or goal is viewed as "a set of possible solutions and a test for verifying whether a given element of this set is in fact a solution to this problem" ([Min63]). In LCF <ref> [GMW79] </ref> the latter is expressed by a notion of achievement between events and goals. Thus "many problem solving situations can be understood as instances of three notions: goal, event, and achievement." Tactics are the result of formalizing the idea of top-down heuristics. <p> Futher informations about decision procedures can be found in [CJE82] (particularly the Appendix "An algorithm for checking PL/CV arithmetic inferences" by Tat-hung Chan) and [NO79, NO80]. The concept of tactical theorem proving has been first discussed in <ref> [GMW79] </ref> and been elaborated for Type Theory in [CKB85]. Tactical theorem proving is also used in Cambridge LCF [Pau87], -PROLOG [FM88], the Oyster system [Bun89], and the KIV system [HRS90].
Reference: [Gri81] <editor> David Gries. </editor> <booktitle> The science of programming. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1981. </year>
Reference-contexts: However, it has turned out that many program methodologies made by Hoare [Hoa72], Dijkstra [Dij76], and others are nothing but special reformulations of methodologies for proofs, a fact which was discovered by David Gries <ref> [Gri81] </ref>. Therefore programming may be considered to be just a special case of proving theorems and as a result, prescriptions of proof methodologists like Polya [Pol45] automatically become program methodologies as well. <p> Still another possibility is to generalize some property of A (p; n) by adding an extra parameter m and performing induction on m. This technique which we will use below is called generalization in Polya's book on mathematical problem solving [Pol45] while in the context of programming <ref> [Gri81, Dij76, Rey81] </ref> it is called weakening. Quite often the formal specification of the problem already suggests a method for solving it.
Reference: [Gri88a] <author> Timothy George Griffin. </author> <title> Notational definition a formal account. </title> <editor> In Yuri Gurevich, editor, </editor> <booktitle> LICS-88 | Proceedings of the Third Annual Symposium on Logic in Computer Science, </booktitle> <address> Edinburgh, Scotland, </address> <month> July </month> <year> 1988, </year> <pages> pages 372-383. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: we may import tech nologies * procedural components to be added to NuPRL This would help making NuPRL as effective as other programming languages which means it might compete with "real" languages. 7.4 References and further reading a fairly new subject, Weyhrauch [AL84, ACHA90, CH90a, Coq90, How88b, KC86b, BM81, Wey80] <ref> [Gri88b, Gri88a, HHP87, Myh75] </ref> for other foundational theories 140 CHAPTER 7. ADVANCED TOPICS Chapter 8 Summary and future views For a powerful theorem proving system we need the following parts * A maximum expressive language 1 Otherwise there are ideas about proofs one can not express in full generality.
Reference: [Gri88b] <author> Timothy George Griffin. </author> <title> Notational definition and top-down refinement for interactive proof development systems. </title> <type> PhD thesis, </type> <institution> Cornell University. Department of Computer Science, </institution> <address> Ithaca, NY 14853-7501, </address> <month> August </month> <year> 1988. </year> <type> TR 88-937. </type>
Reference-contexts: we may import tech nologies * procedural components to be added to NuPRL This would help making NuPRL as effective as other programming languages which means it might compete with "real" languages. 7.4 References and further reading a fairly new subject, Weyhrauch [AL84, ACHA90, CH90a, Coq90, How88b, KC86b, BM81, Wey80] <ref> [Gri88b, Gri88a, HHP87, Myh75] </ref> for other foundational theories 140 CHAPTER 7. ADVANCED TOPICS Chapter 8 Summary and future views For a powerful theorem proving system we need the following parts * A maximum expressive language 1 Otherwise there are ideas about proofs one can not express in full generality.
Reference: [GS89] <author> Fausto Giunchiglia and Alan Smaill. </author> <title> Reflection in constructive and non-constructive automated reasoning. </title> <editor> In Harvey Abramson and M. H. Rogers, editors, </editor> <booktitle> Meta-Programming in Logic Programming, chapter 6, </booktitle> <pages> pages 123-140. </pages> <publisher> MIT Press, </publisher> <address> Cambridge Mass., </address> <year> 1989. </year>
Reference-contexts: Both of them are very difficult and not quite solved yet. Particularly expressing partial functions in an always terminating reduction concept is extremely complicated. In the following we sketch some ideas and the current NuPRL solution [CH90a] 7.1.2 Reflection <ref> [ACHA90, GS89] </ref> 7.2 Alternative theories (optional) Since the introduction of dependent types in many of the rules defined so far we are forced to specify the exact universe. This is particularly annoying when trying to model set theoretic notions.
Reference: [Hay86] <author> S. Hayashi. PX: </author> <title> a system extracting programs from proofs. </title> <booktitle> In Proceedings of the IFIP Confereence on Formal Description of Programming Concepts, </booktitle> <pages> pages 399-424, </pages> <year> 1986. </year>
Reference: [Hey31] <author> Arend Heyting. </author> <title> Die intuitionistische Grundlegung der Mathematik. </title> <journal> Erkenntnis, </journal> <volume> 2 </volume> <pages> 106-115, </pages> <year> 1931. </year>
Reference: [Hey71] <author> Arend Heyting. </author> <title> Intuitionism: An Introduction. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, 3 rd edition, </address> <year> 1971. </year>
Reference: [HHP87] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <editor> In David Gries, editor, </editor> <booktitle> LICS-87 | Proceedings of the Second Annual Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, New York, USA, </address> <month> June </month> <year> 1987, </year> <pages> pages 194-204. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference-contexts: we may import tech nologies * procedural components to be added to NuPRL This would help making NuPRL as effective as other programming languages which means it might compete with "real" languages. 7.4 References and further reading a fairly new subject, Weyhrauch [AL84, ACHA90, CH90a, Coq90, How88b, KC86b, BM81, Wey80] <ref> [Gri88b, Gri88a, HHP87, Myh75] </ref> for other foundational theories 140 CHAPTER 7. ADVANCED TOPICS Chapter 8 Summary and future views For a powerful theorem proving system we need the following parts * A maximum expressive language 1 Otherwise there are ideas about proofs one can not express in full generality.
Reference: [Hin69] <author> J. Roger Hindley. </author> <title> The principal type scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <year> 1969. </year>
Reference: [Hin83] <author> J. Roger Hindley. </author> <title> The completeness theorem for typing -terms. </title> <journal> Theoretical Computer Science, </journal> <volume> 22 </volume> <pages> 1-17, </pages> <year> 1983. </year>
Reference: [Hoa72] <author> Charles Antony Richard Hoare. </author> <title> Notes on data structuring. In [?], pages 83-174. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1972. </year>
Reference-contexts: At a first glance, programming by proving the satisfiability of a program specification seems to be quite unnatural and inefficient. However, it has turned out that many program methodologies made by Hoare <ref> [Hoa72] </ref>, Dijkstra [Dij76], and others are nothing but special reformulations of methodologies for proofs, a fact which was discovered by David Gries [Gri81].
Reference: [Hoa75] <author> C. A. R. Hoare. </author> <title> Recursive data structures. </title> <journal> International Journal of Computer and Information Sciences, </journal> <volume> 4(2) </volume> <pages> 105-132, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: Any of the x i parameters (and the corresponding instance a i ) can be omitted. The t i are bound in all the T j but x i only in T i . Recursive types are a manifestation of the basic ideas about recursive data structures (see <ref> [Hoa75] </ref> and [GMW79] for a detailed rigorous account) in the setting of Type Theory. Far more delicate than the above examples is the concept of recursive types when function 4.4.
Reference: [How80] <author> W. Howard. </author> <title> The formulas-as-types notion of construction. </title> <editor> In J. Roger Hindley and Jonathan P. Seldin, editors, To H. B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 479-490. </pages> <publisher> Academic Press, </publisher> <address> London, New York, </address> <year> 1980. </year> <note> First published 1969. </note>
Reference: [How86] <author> Douglas J. Howe. </author> <title> Implementing number theory: An experiment with NuPRL. </title> <editor> In J. H. Siek-mann, editor, </editor> <booktitle> Proceedings of the 8 th Conference on Automated Deduction, </booktitle> <address> Oxford, England, </address> <year> 1986, </year> <booktitle> volume 230 of Lecture Notes in Computer Science, </booktitle> <pages> pages 404-415. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1986. </year>
Reference-contexts: The tactic mechanism also allows to structure the deductive power of the system around specialized reasoners. Users have been able to write a collection of tactics and theorems designed to construct proofs about a particular concept (see, for instance <ref> [How86, How87, How88a, Kre86, Bas89] </ref>) Experiences with tactics have demonstrated the effectiveness of the tactic mechanism. Tactics provide a level of abstraction comparable to that of the object theory. Thus users can build proofs and tactics with nearly equal facility.
Reference: [How87] <author> Douglas J. Howe. </author> <title> The computational behaviour of girard's paradox. </title> <editor> In David Gries, editor, </editor> <booktitle> LICS-87 | Proceedings of the Second Annual Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, New York, USA, </address> <month> June </month> <year> 1987, </year> <pages> pages 205-214. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year> <note> 160 BIBLIOGRAPHY </note>
Reference-contexts: The tactic mechanism also allows to structure the deductive power of the system around specialized reasoners. Users have been able to write a collection of tactics and theorems designed to construct proofs about a particular concept (see, for instance <ref> [How86, How87, How88a, Kre86, Bas89] </ref>) Experiences with tactics have demonstrated the effectiveness of the tactic mechanism. Tactics provide a level of abstraction comparable to that of the object theory. Thus users can build proofs and tactics with nearly equal facility.
Reference: [How88a] <author> Douglas J. Howe. </author> <title> Automating reasoning in an implementation of constructive Type Theory. </title> <type> PhD thesis, </type> <institution> Cornell University. Department of Computer Science, </institution> <address> Ithaca, NY 14853-7501, </address> <month> June </month> <year> 1988. </year> <type> TR 88-925. </type>
Reference-contexts: The tactic mechanism has proved very successful for a broad class of very simple proof techniques. A number of users have written several small special purpose tactics and a variety of general tactics such as those discussed above (See, most of all <ref> [How88a] </ref>). These general tactics have allowed to achieve in a matter of days most of the capabilities of the mechanisms 132 CHAPTER 5. IMPLEMENTING AUTOMATED REASONING in earlier systems (e.g. PL/CV [CJE82]) which had to be hand coded (on a scale of weeks). <p> The tactic mechanism also allows to structure the deductive power of the system around specialized reasoners. Users have been able to write a collection of tactics and theorems designed to construct proofs about a particular concept (see, for instance <ref> [How86, How87, How88a, Kre86, Bas89] </ref>) Experiences with tactics have demonstrated the effectiveness of the tactic mechanism. Tactics provide a level of abstraction comparable to that of the object theory. Thus users can build proofs and tactics with nearly equal facility.
Reference: [How88b] <author> Douglas J. Howe. </author> <title> Computational metatheory in NuPRL. </title> <booktitle> In Proceedings of the 9 th Conference on Automated Deduction, </booktitle> <address> Argonne, Illinois, </address> <month> May </month> <year> 1988, </year> <pages> pages 238-257, </pages> <year> 1988. </year>
Reference-contexts: of functional programming in general [Car84] from which we may import tech nologies * procedural components to be added to NuPRL This would help making NuPRL as effective as other programming languages which means it might compete with "real" languages. 7.4 References and further reading a fairly new subject, Weyhrauch <ref> [AL84, ACHA90, CH90a, Coq90, How88b, KC86b, BM81, Wey80] </ref> [Gri88b, Gri88a, HHP87, Myh75] for other foundational theories 140 CHAPTER 7.
Reference: [How89] <author> Douglas J. Howe. </author> <title> Equality in lazy computation systems. </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> LICS-89 | Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <year> 1989, </year> <pages> pages 198-203. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year> <editor> [HR67] jr. Hartley Rogers. </editor> <title> Theory of recursive functions and effective computability. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1967. </year>
Reference: [HRS90] <author> M. Heisel, W. Reif, and W. Stephan. </author> <title> Tactical theorem proving in program verification. </title> <editor> In M. E. Stickel, editor, </editor> <booktitle> Proceedings of the 10 th Conference on Automated Deduction, </booktitle> <address> Kaiser-slautern, Germany, </address> <month> July </month> <year> 1990, </year> <booktitle> number 449 in Lecture Notes in Computer Science, </booktitle> <pages> pages 117-131. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1990. </year>
Reference-contexts: The concept of tactical theorem proving has been first discussed in [GMW79] and been elaborated for Type Theory in [CKB85]. Tactical theorem proving is also used in Cambridge LCF [Pau87], -PROLOG [FM88], the Oyster system [Bun89], and the KIV system <ref> [HRS90] </ref>. Chapter 6 Building Theories We have discussed the theory in which to express mathematics and programming and concepts for efficient proofs and program development. We will now investigate aspects of "implementing mathematics", i.e. developing object theories in a system that implements Type Theory.
Reference: [HS86] <author> J. Roger Hindley and Jonathan P. Seldin. </author> <title> Introduction to combinators and -calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference: [Hue86] <author> Gerard Huet. </author> <title> Deduction and computation. </title> <editor> In Wolfgang Bibel and Ph. Jorrand, editors, </editor> <booktitle> Fundamentals of Artificial Intelligence | An Advanced Course, volume 232 of Lecture Notes in Computer Science, </booktitle> <pages> pages 39-74. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1986. </year>
Reference: [KC86a] <author> Todd B. Knoblock and Robert L. Constable. </author> <title> Formalized metareasoning in Type Theory. </title> <type> Technical Report TR 86-742, </type> <institution> Cornell University. Department of Computer Science, </institution> <address> Ithaca, NY 14853-7501, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: Therefore, the question arises if we could drop the distinction between universes and just have one universe type U . This would make things a lot easier. 1 i.e. reasoning about proofs and proof methods 2 But see <ref> [KC86a, KC86b] </ref> for recent work intended to change this 3 see Section ?? 4 This is mainly a problem caused by defining sets. Function types do not need a hierarchy like (IN!IN) 2 in their definition 7.3.
Reference: [KC86b] <author> Todd B. Knoblock and Robert L. Constable. </author> <title> Formalized metareasoning in Type Theory. </title> <booktitle> In LICS-86 | Proceedings of the First Annual Symposium on Logic in Computer Science, 1986. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1986. </year>
Reference-contexts: Therefore, the question arises if we could drop the distinction between universes and just have one universe type U . This would make things a lot easier. 1 i.e. reasoning about proofs and proof methods 2 But see <ref> [KC86a, KC86b] </ref> for recent work intended to change this 3 see Section ?? 4 This is mainly a problem caused by defining sets. Function types do not need a hierarchy like (IN!IN) 2 in their definition 7.3. <p> of functional programming in general [Car84] from which we may import tech nologies * procedural components to be added to NuPRL This would help making NuPRL as effective as other programming languages which means it might compete with "real" languages. 7.4 References and further reading a fairly new subject, Weyhrauch <ref> [AL84, ACHA90, CH90a, Coq90, How88b, KC86b, BM81, Wey80] </ref> [Gri88b, Gri88a, HHP87, Myh75] for other foundational theories 140 CHAPTER 7.
Reference: [Kle52] <author> Stephen C. Kleene. </author> <title> Introduction to Metamathematics. </title> <publisher> Van Nostrand, </publisher> <address> Princeton, NJ, </address> <year> 1952. </year>
Reference: [Kno87] <author> Todd B. Knoblock. </author> <title> Metamathematical extensibility in Type Theory. </title> <type> PhD thesis, </type> <institution> Cornell University. Department of Computer Science, </institution> <address> Ithaca, NY 14853-7501, </address> <month> December </month> <year> 1987. </year> <type> TR 87-892. </type>
Reference-contexts: We could prove results like fl: "if P (proof ) then t: tactic succeeds" and create new rules of inference like H ` proof by tactic t 1:H ` P (proof ) 2:H ` fl See the Ph.D. Thesis of Todd Knoblock <ref> [Kno87] </ref> for more details. 137 138 CHAPTER 7. ADVANCED TOPICS Experience shows that there is a lot of metareasoning 1 in usual mathematical proofs which is not as easy in formal proof systems.
Reference: [Kol32] <author> A. N. </author> <title> Kolmogorov. </title> <journal> Zur Deutung der intuitionistischen Logik. Mathematische Zeitschrift, </journal> <volume> 35 </volume> <pages> 58-65, </pages> <year> 1932. </year>
Reference: [Kre86] <author> Christoph Kreitz. </author> <title> Constructive automata theory implemented with the NuPRL proof development system. </title> <type> Technical Report TR 86-779, </type> <institution> Cornell University. Department of Computer Science, </institution> <address> Ithaca, NY 14853-7501, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: The tactic mechanism also allows to structure the deductive power of the system around specialized reasoners. Users have been able to write a collection of tactics and theorems designed to construct proofs about a particular concept (see, for instance <ref> [How86, How87, How88a, Kre86, Bas89] </ref>) Experiences with tactics have demonstrated the effectiveness of the tactic mechanism. Tactics provide a level of abstraction comparable to that of the object theory. Thus users can build proofs and tactics with nearly equal facility.
Reference: [Lak76] <author> Imre Lakatos. </author> <title> Proofs and Refutations. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1976. </year>
Reference: [Lei90] <author> Daniel Leivant. </author> <title> Contracting proofs to programs. </title> <editor> In Piergiorgio Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 279-328. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1990. </year>
Reference: [LSBB90] <author> Reinhold Letz, Johannes Schumann, Stephan Bayerl, and Wolfgang Bibel. </author> <title> Setheo | a high-performance theorem prover for first-order logic. </title> <journal> Journal of Automated Reasoning, </journal> <note> 1990. BIBLIOGRAPHY 161 </note>
Reference-contexts: The level of machine support is extremely low and the loss factor between formal and 'ordinary' proofs is very high which makes formal proofs also difficult to read. * At the other extreme is automatic theorem proving, as exemplified by various well-known provers <ref> [Ble77, Bib87, BM79, LSBB90, WOLB84] </ref>. They rely on Godel's completeness theorem which essentially says that for each theorem that is true a proof can be found by an exhaustive search procedure.
Reference: [Men87a] <author> Paul Francis Mendler. </author> <title> Inductive definition in Type Theory. </title> <type> PhD thesis, </type> <institution> Cornell University. Department of Computer Science, </institution> <address> Ithaca, NY 14853-7501, </address> <month> September </month> <year> 1987. </year> <type> TR 87-870. </type>
Reference-contexts: Details can be found in <ref> [CM85, Men87a, MPC86] </ref>. 4.4.1 Inductive Types Inductive definition means interpreting a recursively defined object by the smallest fixed point of the equation defining it. Nearly all recursive equations are to be understood as inductive definition. A typical example of an inductively defined type are binary trees over integer numbers. <p> The so called 3x+1-function is defined by f (x) &gt; &lt; 0 if x = 1; f (x=2) if x is even; f (3x + 1) otherwise 26 Such types are legal in languages like Algol or ML but require a notion of partial functions (see Section 4.4.2). 27 See <ref> [CM85, Men87a] </ref> for a full definition. 102 CHAPTER 4. THE TYPE THEORY OF NUPRL It could be easily defined as x.rec ind (x;f,y.int eq (y;1;0;int eq (y mod 2;0;f (x/2);f (3*x+1)))) and applied although its domain is unknown. <p> Such types can be implemented via cyclic pointer structures which are computed on demand only (lazy types). In NuPRL they are represented by terms of the form inf (t,x.T ;a) and the rules coming with these types are in some sense dual to those of the rec type. See <ref> [Men87a] </ref> for a detailed analysis of infinite types. 4.5 Other types In this section we will briefly discuss types not mentioned yet. Details can be found in the NuPRL-book [CAB + 86]. 104 CHAPTER 4. <p> Several other books and articles [ML84, NPS90, BCM88a, BCM88b, Bac89] give introductions to Martin-Lof's theory of types, on which the above theory is based. Semantical questions have been dealt with in <ref> [All87a, All87b, Con89, CH90b, Men87a] </ref>. The aspect of programming in Type Theory and extracting proofs from programs has been investigated in [BC85, Bac85, Con83, Con84, Con85, Con88, Hay86, Chi87, Smi83, NS84, NPS90, Lei90]. The concept of recursive types is fairly new. <p> The aspect of programming in Type Theory and extracting proofs from programs has been investigated in [BC85, Bac85, Con83, Con84, Con85, Con88, Hay86, Chi87, Smi83, NS84, NPS90, Lei90]. The concept of recursive types is fairly new. Chapter 12 of [CAB + 86] and <ref> [CM85, CS87, CS88, Men87a, Men87b, Smi88] </ref> present the current research. Chapter 5 Implementing Automated Reasoning In the previous chapters we have discussed the development of NuPRL's type theory out of the typed -calculus.
Reference: [Men87b] <author> Paul Francis Mendler. </author> <title> Recursive types and type constraints in second order lambda calculus. </title> <editor> In David Gries, editor, </editor> <booktitle> LICS-87 | Proceedings of the Second Annual Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, New York, USA, </address> <month> June </month> <year> 1987, </year> <pages> pages 30-36. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference-contexts: The aspect of programming in Type Theory and extracting proofs from programs has been investigated in [BC85, Bac85, Con83, Con84, Con85, Con88, Hay86, Chi87, Smi83, NS84, NPS90, Lei90]. The concept of recursive types is fairly new. Chapter 12 of [CAB + 86] and <ref> [CM85, CS87, CS88, Men87a, Men87b, Smi88] </ref> present the current research. Chapter 5 Implementing Automated Reasoning In the previous chapters we have discussed the development of NuPRL's type theory out of the typed -calculus.
Reference: [Mil78] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17(3) </volume> <pages> 348-375, </pages> <month> December </month> <year> 1978. </year>
Reference: [Min63] <author> M. Minsky. </author> <booktitle> Steps toward artificial intelligence. Computers and Thought, </booktitle> <pages> pages 406-450, </pages> <year> 1963. </year>
Reference: [ML70] <author> Per Martin-Lof. </author> <title> A theory of types. </title> <type> unpublished manuscript, </type> <year> 1970. </year>
Reference: [ML73] <author> Per Martin-Lof. </author> <title> An intuitionistic theory of types: predicative part. </title> <editor> In H. E. Rose and J. C. Shepherdson, editors, </editor> <booktitle> Logic Colloquium '73, </booktitle> <address> Amsterdam, 1973. </address> <publisher> North-Holland, Amsterdam. </publisher>
Reference: [ML82] <author> Per Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In 6-th International Congress for Logic, Methodology and Philosophy of Science, </booktitle> <year> 1979, </year> <pages> pages 153-175. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1982. </year>
Reference: [ML84] <author> Per Martin-Lof. </author> <title> Intuitionistic Type Theory, </title> <booktitle> volume 1 of Studies in Proof Theory Lecture Notes. </booktitle> <publisher> Bibliopolis, Napoli, </publisher> <year> 1984. </year>
Reference-contexts: THE TYPE THEORY OF NUPRL 4.6 References and further reading Most details about the individual type constructs can be found in the book describing the NuPRL proof development system [CAB + 86]. Several other books and articles <ref> [ML84, NPS90, BCM88a, BCM88b, Bac89] </ref> give introductions to Martin-Lof's theory of types, on which the above theory is based. Semantical questions have been dealt with in [All87a, All87b, Con89, CH90b, Men87a].
Reference: [MPC86] <author> Paul Francis Mendler, Prakash Panangaden, and Robert L. Constable. </author> <title> Infinite objects in Type Theory. </title> <type> Technical Report TR 86-743, </type> <institution> Cornell University. Department of Computer Science, </institution> <address> Ithaca, NY 14853-7501, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: Details can be found in <ref> [CM85, Men87a, MPC86] </ref>. 4.4.1 Inductive Types Inductive definition means interpreting a recursively defined object by the smallest fixed point of the equation defining it. Nearly all recursive equations are to be understood as inductive definition. A typical example of an inductively defined type are binary trees over integer numbers.
Reference: [MW85] <author> Zohar Manna and Richard J. Waldinger. </author> <title> The logical basis for computer programming, volume I: Deductive Reasoning. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1985. </year>
Reference: [Myh75] <author> John Myhill. </author> <title> Constructive set theory. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 40(3) </volume> <pages> 347-383, </pages> <month> September </month> <year> 1975. </year>
Reference-contexts: we may import tech nologies * procedural components to be added to NuPRL This would help making NuPRL as effective as other programming languages which means it might compete with "real" languages. 7.4 References and further reading a fairly new subject, Weyhrauch [AL84, ACHA90, CH90a, Coq90, How88b, KC86b, BM81, Wey80] <ref> [Gri88b, Gri88a, HHP87, Myh75] </ref> for other foundational theories 140 CHAPTER 7. ADVANCED TOPICS Chapter 8 Summary and future views For a powerful theorem proving system we need the following parts * A maximum expressive language 1 Otherwise there are ideas about proofs one can not express in full generality.
Reference: [NO79] <author> Greg Nelson and Derek. C. Oppen. </author> <title> Simplification by cooperating decision procedures. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 1(2) </volume> <pages> 245-257, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: There is, however, a method to combine decision procedures in a way that they cooperate by exchanging information about all the equalites detected. 18 An algorithm which combines decision procedures for quantifier-free theories into a single decision procedure for their combination is described in <ref> [NO79] </ref>. It has been sucessfully used in -PRL. 5.2.4 Limitations In the early -PRL which did not have the rich type structure of NuPRL the cooperation of built-in decision procedures (arith, equality, list-theory etc.) was quite powerful. <p> Futher informations about decision procedures can be found in [CJE82] (particularly the Appendix "An algorithm for checking PL/CV arithmetic inferences" by Tat-hung Chan) and <ref> [NO79, NO80] </ref>. The concept of tactical theorem proving has been first discussed in [GMW79] and been elaborated for Type Theory in [CKB85]. Tactical theorem proving is also used in Cambridge LCF [Pau87], -PROLOG [FM88], the Oyster system [Bun89], and the KIV system [HRS90].
Reference: [NO80] <author> Greg Nelson and Derek. C. Oppen. </author> <title> Fast decision procedures based on congruence closure. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 27(2) </volume> <pages> 356-364, </pages> <month> April </month> <year> 1980. </year>
Reference-contexts: Futher informations about decision procedures can be found in [CJE82] (particularly the Appendix "An algorithm for checking PL/CV arithmetic inferences" by Tat-hung Chan) and <ref> [NO79, NO80] </ref>. The concept of tactical theorem proving has been first discussed in [GMW79] and been elaborated for Type Theory in [CKB85]. Tactical theorem proving is also used in Cambridge LCF [Pau87], -PROLOG [FM88], the Oyster system [Bun89], and the KIV system [HRS90].
Reference: [NPS90] <author> Bengt Nordstrom, Kent Petersson, and Jan M. Smith. </author> <title> Programming in Martin-Lofs Type Theory. An introduction. </title> <publisher> Clarendon Press, Oxford, </publisher> <year> 1990. </year>
Reference-contexts: THE TYPE THEORY OF NUPRL 4.6 References and further reading Most details about the individual type constructs can be found in the book describing the NuPRL proof development system [CAB + 86]. Several other books and articles <ref> [ML84, NPS90, BCM88a, BCM88b, Bac89] </ref> give introductions to Martin-Lof's theory of types, on which the above theory is based. Semantical questions have been dealt with in [All87a, All87b, Con89, CH90b, Men87a].
Reference: [NS84] <author> Bengt Nordstrom and Jan M. Smith. </author> <title> Propositions and specifications of programs in Martin-Lofs Type Theory. </title> <journal> BIT, </journal> <volume> 24 </volume> <pages> 288-301, </pages> <year> 1984. </year>
Reference: [NSS63] <author> A. Newell, M. Shaw, and H. Simon. </author> <title> Empirical explorations with the logic theory machine. </title> <booktitle> Computers and Thought, </booktitle> <pages> pages 109-133, </pages> <year> 1963. </year>
Reference-contexts: This method was systematized already by the Greeks and is a key element in Polya's heuristic [Pol45] and also the basis of the Logic Theorist of Newell, Shaw, and Simon <ref> [NSS63] </ref>. Here, a problem or goal is viewed as "a set of possible solutions and a test for verifying whether a given element of this set is in fact a solution to this problem" ([Min63]).
Reference: [Pau87] <author> Lawrence C. Paulson. </author> <title> Logic and Computation: Interactive Proof with Cambridge LCF. </title> <publisher> Cambridge University Press, </publisher> <year> 1987. </year>
Reference-contexts: The concept of tactical theorem proving has been first discussed in [GMW79] and been elaborated for Type Theory in [CKB85]. Tactical theorem proving is also used in Cambridge LCF <ref> [Pau87] </ref>, -PROLOG [FM88], the Oyster system [Bun89], and the KIV system [HRS90]. Chapter 6 Building Theories We have discussed the theory in which to express mathematics and programming and concepts for efficient proofs and program development.
Reference: [Pol45] <author> G. Polya. </author> <title> How to solve it. </title> <publisher> Princeton University Press, </publisher> <address> Princeton, New Jersey, </address> <year> 1945. </year>
Reference-contexts: Therefore programming may be considered to be just a special case of proving theorems and as a result, prescriptions of proof methodologists like Polya <ref> [Pol45] </ref> automatically become program methodologies as well. We will discuss this in further detail after introducing type constructs which are necessary for "real" mathematics and programming. 4.3.2 Natural numbers Most of mathematics and programming is based on fundamental arithmetical constructs. <p> Still another possibility is to generalize some property of A (p; n) by adding an extra parameter m and performing induction on m. This technique which we will use below is called generalization in Polya's book on mathematical problem solving <ref> [Pol45] </ref> while in the context of programming [Gri81, Dij76, Rey81] it is called weakening. Quite often the formal specification of the problem already suggests a method for solving it. <p> This method was systematized already by the Greeks and is a key element in Polya's heuristic <ref> [Pol45] </ref> and also the basis of the Logic Theorist of Newell, Shaw, and Simon [NSS63]. Here, a problem or goal is viewed as "a set of possible solutions and a test for verifying whether a given element of this set is in fact a solution to this problem" ([Min63]).
Reference: [Pra65] <author> Dag Prawitz. </author> <title> Natural Deduction: A Proof-Theoretical study. </title> <publisher> Almquist & Wiksell, </publisher> <year> 1965. </year> <note> 162 BIBLIOGRAPHY </note>
Reference: [Qui63] <author> Willard Van Orman Quine. </author> <title> Set Theory and its logic. </title> <publisher> Belknap Press, </publisher> <address> Cambridge, MA, </address> <year> 1963. </year>
Reference: [Rey81] <author> John C. Reynolds. </author> <title> The craft of programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, Engle-wood Cliffs, N.J., </address> <year> 1981. </year>
Reference-contexts: Still another possibility is to generalize some property of A (p; n) by adding an extra parameter m and performing induction on m. This technique which we will use below is called generalization in Polya's book on mathematical problem solving [Pol45] while in the context of programming <ref> [Gri81, Dij76, Rey81] </ref> it is called weakening. Quite often the formal specification of the problem already suggests a method for solving it.
Reference: [Ric78] <editor> Michel M. Richter. Logikkalkule, </editor> <booktitle> volume 43 of Teubner Studienbucher Informatik. </booktitle> <address> B.G.Teubner, Stuttgart, </address> <year> 1978. </year>
Reference: [Rob65] <author> J. A. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <month> January </month> <year> 1965. </year>
Reference-contexts: The algorithm is described in Figure 5.5. 5.2.3 Other Methods For classical first order logic there is a rich variety of proof methods which usually code some complete search strategy (see, for instance <ref> [Rob65, And71, Bib87] </ref>). Inherent in these methods is the possibility that the procedure will fail after an investment of considerable resources. Since 5.3.
Reference: [Rus08] <author> Bertrand Russel. </author> <title> Mathematical logic as based on a theory of types. </title> <journal> Am. J. of Math., </journal> <volume> 30 </volume> <pages> 222-262, </pages> <year> 1908. </year>
Reference: [Sas85] <author> James T. Sasaki. </author> <title> The Extraction and Optimization of Programs from Constructive Proofs. </title> <type> PhD thesis, </type> <institution> Cornell University. Department of Computer Science, </institution> <address> Ithaca, NY 14853-7501, </address> <year> 1985. </year>
Reference-contexts: KOntexte etc. 7.2.3 Other Type theoretic calculi [AC90, Ber68, Sup72] 7.3 How to compute well? This means better evaluators, compilers for Type Theory, faster computation For -PRL, a previous version, there are already some studies by Jim Sasaki <ref> [Sas85] </ref>.
Reference: [Sch77] <author> Kurt Schutte. </author> <title> Proof Theory. </title> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1977. </year>
Reference: [Sch85] <author> Alan H. Schoenfield. </author> <title> Mathematical Problem Solving. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1985. </year>
Reference: [Smi83] <author> Jan M. Smith. </author> <title> The identification of propositions and types in Martin-Lof's Type Theory: A programming example. </title> <booktitle> In International Conference on Foundations of Computation Theory, </booktitle> <address> Borgholm, Sweden, </address> <month> August </month> <year> 1983, </year> <pages> pages 445-456. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1983. </year>
Reference: [Smi84] <author> Jan M. Smith. </author> <title> An interpretation of Martin-Lof's Type Theory in a type-free theory of propositions. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 49(3) </volume> <pages> 730-753, </pages> <year> 1984. </year>
Reference: [Smi88] <author> Scott Fraser Smith. </author> <title> Partial objects in Type Theory. </title> <type> PhD thesis, </type> <institution> Cornell University. Department of Computer Science, </institution> <address> Ithaca, NY 14853-7501, </address> <month> August </month> <year> 1988. </year> <type> TR 88-938. </type>
Reference-contexts: The aspect of programming in Type Theory and extracting proofs from programs has been investigated in [BC85, Bac85, Con83, Con84, Con85, Con88, Hay86, Chi87, Smi83, NS84, NPS90, Lei90]. The concept of recursive types is fairly new. Chapter 12 of [CAB + 86] and <ref> [CM85, CS87, CS88, Men87a, Men87b, Smi88] </ref> present the current research. Chapter 5 Implementing Automated Reasoning In the previous chapters we have discussed the development of NuPRL's type theory out of the typed -calculus.
Reference: [Ste72] <author> Soren Stenlund. </author> <title> Combinators, -terms and Proof Theory. </title> <address> D. </address> <publisher> Reidel, </publisher> <address> Dordrecht, The Netherlands, </address> <year> 1972. </year>
Reference: [Sup72] <author> Patrick Suppes. </author> <title> Axiomatic Set Theory. </title> <publisher> Dover Publications, </publisher> <year> 1972. </year>
Reference-contexts: HOW TO COMPUTE WELL? 139 7.2.1 Girard's Theory 7.2.2 The calculus of constructions [CH85, CH88, Coq90]CoquandHuet in VL einflieen lassen als Konkurrenz, intro o.a. wegen der vielen guten eigenschaften. KOntexte etc. 7.2.3 Other Type theoretic calculi <ref> [AC90, Ber68, Sup72] </ref> 7.3 How to compute well? This means better evaluators, compilers for Type Theory, faster computation For -PRL, a previous version, there are already some studies by Jim Sasaki [Sas85].
Reference: [Tai67] <author> William W. Tait. </author> <title> Intensional interpretation of functionals of finite type. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 32(2) </volume> <pages> 187-199, </pages> <year> 1967. </year>
Reference: [Tak75] <author> Gaisi Takeuti. </author> <title> Proof Theory. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1975. </year>
Reference: [Tur84] <author> R. Turner. </author> <booktitle> Logics for Artificial Intelligence. </booktitle> <publisher> Ellis Horwood Ltd., </publisher> <year> 1984. </year>
Reference: [vBJ77] <author> L. S. van Benthem Jutting. </author> <title> Checking Landau's Grundlagen in the AUTOMATH System. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, Eindhoven, Netherlands, </institution> <month> March </month> <year> 1977. </year> <note> also: </note> <institution> Mathematical Centre Tracts 83, Math. Centre, </institution> <address> Amsterdam, </address> <year> 1979. </year>
Reference-contexts: It should therefore be investigated how to provide sufficient machine support for proving theorems and developing programs in Type Theory efficiently. One can identify at least three distinct general approaches to automating reasoning. * At one extreme is pure proof checking, as exemplified by AUTOMATH <ref> [Bru80, vBJ77] </ref>. These methods rely on a very expressive language to capture the abstractions that make rigorous mathematics possible. They require large libraries and use a minimum amount of algorithmic metamathematics.
Reference: [vH67] <editor> J. van Heijenoort. </editor> <title> From Frege to Godel: A Sourcebook of Mathematical Logic. </title> <publisher> Harvard University Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1967. </year>
Reference-contexts: For this we have to accept algorithms which by their very nature could be partial. A convenient and natural account of partial functions follows insights from Herbrand <ref> [vH67] </ref> which arose from studying algorithms in the context of constructive mathematics and logic. The key idea is that a computation rule as the reduction rule for rec ind can be understood and treated as a formal concept before the domain of application can be given.
Reference: [Wey80] <author> Richard W. Weyhrauch. </author> <title> Prolegomena to theory of mechanized formal reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13 </volume> <pages> 133-170, </pages> <year> 1980. </year>
Reference-contexts: of functional programming in general [Car84] from which we may import tech nologies * procedural components to be added to NuPRL This would help making NuPRL as effective as other programming languages which means it might compete with "real" languages. 7.4 References and further reading a fairly new subject, Weyhrauch <ref> [AL84, ACHA90, CH90a, Coq90, How88b, KC86b, BM81, Wey80] </ref> [Gri88b, Gri88a, HHP87, Myh75] for other foundational theories 140 CHAPTER 7.
Reference: [WOLB84] <author> Larry Wos, Russ Overbeek, Ewing Lusk, and J. Boyle. </author> <title> Automated Reasoning. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1984. </year> <note> BIBLIOGRAPHY 163 </note>
Reference-contexts: The level of machine support is extremely low and the loss factor between formal and 'ordinary' proofs is very high which makes formal proofs also difficult to read. * At the other extreme is automatic theorem proving, as exemplified by various well-known provers <ref> [Ble77, Bib87, BM79, LSBB90, WOLB84] </ref>. They rely on Godel's completeness theorem which essentially says that for each theorem that is true a proof can be found by an exhaustive search procedure.
Reference: [WR25] <author> Alan N. Whitehead and Bertrand Russell. </author> <title> Principia Mathematicae, volume 1. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, MA, </address> <year> 1925. </year>
References-found: 129

