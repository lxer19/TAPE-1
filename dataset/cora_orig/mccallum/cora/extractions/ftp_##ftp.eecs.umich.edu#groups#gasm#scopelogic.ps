URL: ftp://ftp.eecs.umich.edu/groups/gasm/scopelogic.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: kwon@se.donga.ac.kr)  
Title: A Structured Presentation of a Closure-Based Compilation Method for a Scoping Notion in Logic Programming  
Author: Keehang Kwon 
Address: Korea  
Affiliation: (DongA University,  
Abstract: We present a systematic reconstruction of a compilation method for an extension to logic programming that permits procedure definitions to be given a scope. At a logical level, this possibility is realized by permitting implications to be embedded in goals. Program clauses that appear in the antecedents of such implications may contain variables that are bound by external quantifiers, leading to non-local variables in procedure declarations. In compiling programs in this extended language, there is, therefore, a need to consider the addition to given programs of program clauses that are parameterized by bindings for some of their variables. A proposed approach to dealing with this aspect uses a closure representation for clauses. This representation separates an instance of a clause with parameterized bindings into a skeleton part that is fixed at compile-time and an environment that maintains the part that is dynamically determined. A development of this implementation scheme is provided here by starting with an abstract interpreter for the language and then refining this to arrive at an interpreter that uses the closure representation for clauses. The abstract state machine formalism of Gurevich is used in specifying the interpreters that are of interest at the two different stages. We also justify this refinement by showing that the essential notion of a computation is preserved by the refinement and thus the refinement is a correct one. Key Words: logic programming, embedded implication, scoping, closure, compilation 
Abstract-found: 1
Intro-found: 1
Reference: [Blakley 92] <author> Bob Blakley. </author> <title> A Smalltalk Evolving Algberas and Its Uses. </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <year> 1992. </year>
Reference-contexts: Because of these attributes of abstract state machines, they have been successfully used in describing the operational semantics of various programming languages including Modula-2 [Gurevich and Morris 88], Smalltalk <ref> [Blakley 92] </ref>, Occam [Gurevich and Moss 90], Prolog [Borger 90a, Borger 90b] as well as in proving the correctness of a Prolog machine [Borger and Rosenzweig 94]. 2.1 The Basic Terminology We define formally some of the notions relating to abstract state machines. Definition 2.1.
Reference: [Borger 90a] <author> Egon Borger. </author> <title> A logical operational semantics of full Prolog. part I. selection core and control. </title> <editor> In H. Kleine Buning E. Borger and M. Richter, editors, </editor> <booktitle> 3rd Workshop on Computer Science Logic, volume 440 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 36-64. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Because of these attributes of abstract state machines, they have been successfully used in describing the operational semantics of various programming languages including Modula-2 [Gurevich and Morris 88], Smalltalk [Blakley 92], Occam [Gurevich and Moss 90], Prolog <ref> [Borger 90a, Borger 90b] </ref> as well as in proving the correctness of a Prolog machine [Borger and Rosenzweig 94]. 2.1 The Basic Terminology We define formally some of the notions relating to abstract state machines. Definition 2.1.
Reference: [Borger 90b] <author> Egon Borger. </author> <title> A logical operational semantics of full Prolog. part II. built-in predicates for database manipulations. </title> <editor> In B. Rovan, editor, </editor> <booktitle> Mathematical Foundations of Computer Science, volume 452 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 1-14. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Because of these attributes of abstract state machines, they have been successfully used in describing the operational semantics of various programming languages including Modula-2 [Gurevich and Morris 88], Smalltalk [Blakley 92], Occam [Gurevich and Moss 90], Prolog <ref> [Borger 90a, Borger 90b] </ref> as well as in proving the correctness of a Prolog machine [Borger and Rosenzweig 94]. 2.1 The Basic Terminology We define formally some of the notions relating to abstract state machines. Definition 2.1.
Reference: [Borger and Rosenzweig 94] <author> Egon Borger and Dean Rosenzweig. </author> <title> The WAM | definition and compiler correctness. </title> <editor> In L. C. Beierle and L. Plumer, editors, </editor> <booktitle> Logic Programming: Formal Methods and Practical Applications, Studies in Computer Science and Artificial Intelligence. </booktitle> <publisher> North-Holland, </publisher> <year> 1994. </year>
Reference-contexts: these attributes of abstract state machines, they have been successfully used in describing the operational semantics of various programming languages including Modula-2 [Gurevich and Morris 88], Smalltalk [Blakley 92], Occam [Gurevich and Moss 90], Prolog [Borger 90a, Borger 90b] as well as in proving the correctness of a Prolog machine <ref> [Borger and Rosenzweig 94] </ref>. 2.1 The Basic Terminology We define formally some of the notions relating to abstract state machines. Definition 2.1. A many-sorted first-order algebra A consists of a number of disjoint sets called universes and functions on the Cartesian product of these sets. <p> As mentioned in Section 3, the interpreter described here is not complete in that it may follow an infinite path even when a successful derivation exists. We note that the specification in this section is modelled closely on the specification of Prolog in <ref> [Borger and Rosenzweig 94] </ref>. In the next section, we will have to consider clauses and goals that are identical to given ones except for the fact that quantifier prefixes may be reordered.
Reference: [Gabbay and Reyle 84] <author> D. M. Gabbay and U. Reyle. N-Prolog: </author> <title> An extension of Prolog with hypothetical implications. I. </title> <journal> Journal of Logic Programming, </journal> <volume> 1:319 - 355, </volume> <year> 1984. </year>
Reference: [Giordano et al. 88] <author> L. Giordano, A. Martelli, and G. F. Rossi. </author> <title> Local definitions with static scope rules in logic languages. </title> <booktitle> In Proceedings of the FGCS International Conference, </booktitle> <address> Tokyo, </address> <year> 1988. </year>
Reference: [Gurevich 91] <author> Yuri Gurevich. </author> <title> Evolving algebras. A tutorial introduction. </title> <journal> Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <year> 1991. </year>
Reference-contexts: We have used the abstract state machine formalism of Gurevich <ref> [Gurevich 91] </ref> as a specification language in this task. This formalism is especially suited to our task since it permits perspicuous yet mathematically precise description of machines to be provided at various levels of granularity. <p> The collection of these function symbols is referred to as the signature of A. A function of arity zero is called a distinguished element or constant. Following Gurevich <ref> [Gurevich 91] </ref>, we assume that both the universes and the associated signature are fixed throughout the computation. Among the configurations, some are identified, as usual, as initial and final states. The following notation corresponding to universes will be useful: Definition 2.2.
Reference: [Gurevich and Morris 88] <author> Yuri Gurevich and James M. Morris. </author> <title> Algebraic operational semantics and Modula-2. </title> <editor> In H. Kleine E. Borger and M. Richter, editors, </editor> <booktitle> 1st Workshop on Computer Science Logic, volume 329 of Lecture Notes in Computer Science, </booktitle> <pages> pages 81-101. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Because of these attributes of abstract state machines, they have been successfully used in describing the operational semantics of various programming languages including Modula-2 <ref> [Gurevich and Morris 88] </ref>, Smalltalk [Blakley 92], Occam [Gurevich and Moss 90], Prolog [Borger 90a, Borger 90b] as well as in proving the correctness of a Prolog machine [Borger and Rosenzweig 94]. 2.1 The Basic Terminology We define formally some of the notions relating to abstract state machines. Definition 2.1.
Reference: [Gurevich and Moss 90] <author> Yuri Gurevich and Larry Moss. </author> <title> Algebraic operational semantics and Occam. </title> <editor> In H. Kleine E. Borger and M. Richter, editors, </editor> <booktitle> 3rd Workshop on Computer Science Logic, volume 440 of Lecture Notes in Computer Science, </booktitle> <pages> pages 176-192. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Because of these attributes of abstract state machines, they have been successfully used in describing the operational semantics of various programming languages including Modula-2 [Gurevich and Morris 88], Smalltalk [Blakley 92], Occam <ref> [Gurevich and Moss 90] </ref>, Prolog [Borger 90a, Borger 90b] as well as in proving the correctness of a Prolog machine [Borger and Rosenzweig 94]. 2.1 The Basic Terminology We define formally some of the notions relating to abstract state machines. Definition 2.1.
Reference: [Hodas and Miller 94] <author> Joshua Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic. </title> <journal> Information and Computation, </journal> <volume> 110(2) </volume> <pages> 327-365, </pages> <month> May </month> <year> 1994. </year>
Reference: [Kwon 94] <author> Keehang Kwon. </author> <title> Towards a Verified Abstract Machine for a Logic Programming Language with a Notion of Scope. </title> <type> PhD thesis, </type> <institution> Duke University, </institution> <note> Decem-ber 1994. Also available as Technical Report CS-1994-36 from Department of Computer Science, </note> <institution> Duke University. </institution>
Reference-contexts: The work in this paper is part of a larger effort to provide a rational re-construction of, and to thereby verify, these implementation ideas <ref> [Kwon 94] </ref>.
Reference: [Lamma et al. 92] <author> Evelina Lamma, Paola Mello, and Antonio Natali. </author> <title> An extended Warren abstract machine for the execution of structured logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 14 </volume> <pages> 187-222, </pages> <year> 1992. </year>
Reference-contexts: We refer the reader to [Nadathur et al. 95] for further details. Besides the work in [Nadathur et al. 95], there have been another proposal related to the implementation of scoped program clauses: Lamma, Mello and Natali in <ref> [Lamma et al. 92] </ref> presented, in the extended context of the WAM, 374 Kwon K.: A Structured Presentation of a Closure-Based Compilation Method for ... a stack-based approach to manage the dynamically changing program.
Reference: [McCarty 88a] <author> L. Thorne McCarty. </author> <title> Clausal intuitionistic logic I. Fixed point semantics. </title> <journal> Journal of Logic Programming, </journal> <volume> 5(1) </volume> <pages> 1-31, </pages> <year> 1988. </year>
Reference: [McCarty 88b] <author> L. Thorne McCarty. </author> <title> Clausal intuitionistic logic II. Tableau proof procedures. </title> <journal> Journal of Logic Programming, </journal> <volume> 5 </volume> <pages> 93-132, </pages> <year> 1988. </year> <editor> 375Kwon K.: </editor> <title> A Structured Presentation of a Closure-Based Compilation Method for </title> ... 
Reference: [Miller 89] <author> Dale Miller. </author> <title> A logical analysis of modules in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 6 </volume> <pages> 79-108, </pages> <year> 1989. </year>
Reference-contexts: One approach that is of interest to us in this paper involves the enrichment of the underlying logic to allow for hypothetical or implication goals <ref> [Miller 89, Miller et al. 91] </ref>.
Reference: [Miller 94] <editor> Dale Miller. A multiple-conclusion meta-logic. In S. Abramsky, editor, </editor> <booktitle> Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 272-281, </pages> <address> Paris, France, July 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [Miller et al. 91] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: One approach that is of interest to us in this paper involves the enrichment of the underlying logic to allow for hypothetical or implication goals <ref> [Miller 89, Miller et al. 91] </ref>. <p> For this reason, we refer to a G-formula as a goal or query, to a C-formula as a clause, to a D-formula as a program clause, and to a collection of clauses as a program. 1 As explained in <ref> [Miller et al. 91] </ref>, the programming language based on Horn clause logic can also be characterized in a fashion similar to that done here, with the main difference that implications are not permitted in G-formulas. <p> This symbol is included in the language we consider here so as to provide a notion of scope. In the framework of <ref> [Miller et al. 91] </ref>, the notion of programming consists of describing relationships between objects through a program and of querying such a specification through a G-formula. <p> The symbols , on the other hand, provide a scoping mechanism: it allows for the augmentation of the program in the course of solving a query. The above notion of "computation-as-search" is referred to as uniform provability in <ref> [Miller et al. 91] </ref> and is justified there as a basis for programming in logic. A standard way of obtaining an answer (or an output) from a computation in logic programming is by solving a goal with free variables.
Reference: [Miller et al. 87] <author> Dale Miller, Gopalan Nadathur, and Andre Scedrov. </author> <title> Hereditary Har-rop formulas and uniform proof systems. </title> <editor> In David Gries, editor, </editor> <booktitle> Symposium on Logic in Computer Science, </booktitle> <pages> pages 98-105, </pages> <address> Ithaca, NY, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: The C-formulas defined here are a subclass of first-order hereditary Harrop formulas <ref> [Miller et al. 87] </ref>. In the programming language to be considered, G-formulas will function as queries and collections of C-formulas will constitute programs.
Reference: [Monteiro and Porto 89] <author> Lus Monteiro and Antonio Porto. </author> <title> Contextual logic programming. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Sixth International Logic Programming Conference, </booktitle> <pages> pages 284-299, </pages> <address> Lisbon, Portugal, June 1989. </address> <publisher> MIT Press. </publisher>
Reference: [Nadathur 93] <author> Gopalan Nadathur. </author> <title> A proof procedure for the logic of hereditary Harrop formulas. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 11 </volume> <pages> 115-145, </pages> <year> 1993. </year>
Reference-contexts: In this case, n restricted to F (G) is referred to as the corresponding answer substitution. 349Kwon K.: A Structured Presentation of a Closure-Based Compilation Method for ... The following proposition, whose proof is immediate from the discussions in <ref> [Nadathur 93] </ref> 2 , relates our transition system to an existing deduction system. Proposition 1. Let P be a set of closed clauses and let G be a query whose free variables are included in fx 1 ; : : : ; x n g. <p> Thus the stack algebra is of the form (NODE; root; cnode; b) 2 Our transition system is a simplified variant of the one described in <ref> [Nadathur 93] </ref>: it dispenses with the elaboration operation, the INSTANCE and the GENERIC rules.
Reference: [Nadathur et al. 95] <author> Gopalan Nadathur, Bharat Jayaraman, and Keehang Kwon. </author> <title> Scoping constructs in logic programming: Implementation problems and their solution. </title> <journal> Journal of Logic Programming, </journal> <volume> 25(2) </volume> <pages> 119-161, </pages> <year> 1995. </year>
Reference-contexts: However, the code that is produced must include some means for the run-time coordination of different occurrences of variables bound by the same quantifier. An approach to handling these and related problems has been described in <ref> [Nadathur et al. 95] </ref>. The proposed scheme utilizes a stack-based approach to managing dynamically changing program contexts and has built into it relevant book-keeping devices for backtracking. <p> This is rather cumbersome and is avoided by managing the program context in a stack-based manner. Hence, a goal such as D G is solved by adding D to the program context, solving G, and then removing D from the program context. In <ref> [Nadathur et al. 95] </ref>, we introduced an implication stack to permit the incremental addition and subsequent retraction of clauses from a program context that is needed in an implementation of this approach. However, backtracking may require reinstating states previously in existence and bookkeeping devices are needed to implement this efficiently. <p> We incorporated an efficient bookkeeping mechanism into our model by embedding the implication stack and the stack of choice points into a single stack and by managing them on a chronological basis. We refer the reader to <ref> [Nadathur et al. 95] </ref> for further details. Besides the work in [Nadathur et al. 95], there have been another proposal related to the implementation of scoped program clauses: Lamma, Mello and Natali in [Lamma et al. 92] presented, in the extended context of the WAM, 374 Kwon K.: A Structured Presentation <p> We incorporated an efficient bookkeeping mechanism into our model by embedding the implication stack and the stack of choice points into a single stack and by managing them on a chronological basis. We refer the reader to <ref> [Nadathur et al. 95] </ref> for further details. Besides the work in [Nadathur et al. 95], there have been another proposal related to the implementation of scoped program clauses: Lamma, Mello and Natali in [Lamma et al. 92] presented, in the extended context of the WAM, 374 Kwon K.: A Structured Presentation of a Closure-Based Compilation Method for ... a stack-based approach to <p> Their proposal is quite similar to the one in <ref> [Nadathur et al. 95] </ref>, but they concerned just program clauses, not closures. Finally, the ideas presented in this paper are used in the development of an abstract machine for Prolog [Nadathur and Miller 88] | a superset of the language considered here.
Reference: [Nadathur and Miller 88] <author> Gopalan Nadathur and Dale Miller. </author> <title> An Overview of Prolog. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Fifth International Logic Programming Conference, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Washington, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Their proposal is quite similar to the one in [Nadathur et al. 95], but they concerned just program clauses, not closures. Finally, the ideas presented in this paper are used in the development of an abstract machine for Prolog <ref> [Nadathur and Miller 88] </ref> | a superset of the language considered here.
Reference: [Warren 83] <author> D.H.D. Warren. </author> <title> An abstract Prolog instruction set. </title> <type> Technical report, </type> <institution> SRI International, </institution> <month> October </month> <year> 1983. </year> <title> Technical Note 309. Acknowledgements This paper is based on the author's doctoral dissertation. The author would like to thank Gopalan Nadathur for guidance and helpful comments. This re search was supported in part by NSF Grants CCR-89-05825, CCR-92-08465 and 1996 University Basic Research Grant from the Korea Ministry of Information and Communications. 376 Kwon K.: A Structured Presentation of a Closure-Based Compilation Method for </title> ... 
Reference-contexts: The standard technique for delaying renaming substitutions is to record them in a data structure called an environment and to read a relevant formula skeleton in conjunction with this environment. This technique is used, for instance, in the WAM <ref> [Warren 83] </ref>. We adapt this method to our context in this section and also extend it to handle the new feature of our language.
References-found: 23

