URL: http://www.cs.princeton.edu/~erez/cards.ps
Refering-URL: http://www.cs.princeton.edu/~erez/publications.html
Root-URL: http://www.cs.princeton.edu
Email: E-mail: azagury@haifa.vnet.ibm.com. E-mail: kolodner@haifa.vnet.ibm.com. E-mail: erezp@haifa.vnet.ibm.com. E-mail: yehudai@haifa.vnet.ibm.com.  
Title: Combining Card Marking with Remembered Sets: How to Save Scanning Time  
Author: Alain Azagury Elliot K. Kolodner Erez Petrank Zvi Yehudai 
Keyword: Garbage collection, Generational  
Address: 31905, Israel.  
Affiliation: Department of System Technology, IBM Haifa Research Lab, MATAM, Haifa  
Note: garbage collection, The train algorithm.  Postal address (of all authors):  
Abstract: We consider the combination of card marking with remembered sets for generational garbage collection as suggested by Hosking and Hudson [3]. When more than two generations are used, a naive implementation may cause excessive and wasteful scanning of the cards and thus increase the collection time. We offer a simple data structure and a corresponding algorithm to keep track of which cards need be scanned for which generation. We then extend these ideas for the Train Algorithm of [4]. Here, the solution is more involved, and allows tracking of which card should be scanned for which car-collection in the train. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. E. Jones and R. D. Lins. </author> <title> Garbage Collection: Algorithms for Automatic Dynamic Memory Management. </title> <publisher> John Wiley & Sons, </publisher> <month> July </month> <year> 1996. </year>
Reference-contexts: In the remembered set of generation g, all locations of the inter-generational pointers that reference objects in generation g are kept. Maintenance of this set is done by the application whenever a pointer is stored, and by the collector when objects are promoted. The reader is referred to <ref> [1, 9] </ref> for a detailed description of various variants on this method. Maintaining the remembered set implies a costly overhead on the application during normal operation. Card marking reduces this cost [7].
Reference: [2] <author> U. Holzle. </author> <title> A fast write barrier for generational garbage collectors. </title> <editor> In Eliot Moss, Paul R. Wilson, and Benjamin Zorn, editors. </editor> <booktitle> OOPSLA/ECOOP '93 Workshop on Garbage Collection in Object-Oriented Systems, </booktitle> <month> October </month> <year> 1993 </year>
Reference-contexts: Card marking reduces this cost [7]. Here, the heap is partitioned into cards of equal size, and whenever the application modifies an object in a card, it marks the card as dirty. Marking a card is a very short operation <ref> [7, 10, 2] </ref>. Depending on the specific processor, it may be implemented in 3-6 instructions. However, the collector performs more work in a card marking system. It must scan all the dirty cards to find the inter-generational pointers, instead of just getting the pointer from the remembered set. <p> This understanding leads to the compaction of the information that has to be kept per card, and to the efficient use of this information. Wilson and Moher [10] suggest to keep a byte per card in the card table. This idea was adopted in subsequent collectors <ref> [2, 3] </ref>. It is this "waste" of space that allows the very low overhead on the application. When the muta-tor has to mark a card dirty, it is much cheaper to clear a byte in the card table, than to modify a single bit. <p> Very efficient card marking implementations have been suggested for several systems <ref> [3, 10, 2] </ref>. In our above approach, there is a change in the application overhead. Instead of writing the constant zero into the entry in the card table, we now move a value, i.e., the time, kept in some variable, into this entry.
Reference: [3] <author> A. L. Hosking and R. L. Hudson. </author> <title> Remembered Sets Can Also Play Cards. </title> <booktitle> In OOPSLA'93 Workshop on Garbage Collection and Memory Management. </booktitle> <address> Washing-ton, DC, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: Two common solutions are remembered sets and card marking [5, 8, 7, 10]. We explain these methods in Section 2.2 below. Hosking and Hudson <ref> [3] </ref> suggested a hybrid method enjoying the advantages of both methods. In this work, we study this method for a generational scheme that uses more than two generations. <p> We go into more details in Section 3.1. When collecting a car (a part of the old generation), we must scan all pointers that reference objects in the car from the outside. Here, again, one may use the combination of card marking and remembered sets as suggested in <ref> [3] </ref>. In this case, the problem of which cards to scan for which car collection is more involved. We provide a data structure and a corresponding algorithm that deals efficiently with choosing the cards to be scanned for the current car collection. <p> Two possible data structures were suggested [5, 8, 7]: card marking and remembered sets. A combination of the two was suggested in <ref> [3] </ref>. 2.2 Card Marking and Remembered Sets One way to keep inter-generational pointers to a given generation is to keep a remembered set for the generation [5, 8]. In the remembered set of generation g, all locations of the inter-generational pointers that reference objects in generation g are kept. <p> Dirty cards here are both cards that were recently modified by the application and also cards that contain inter-generational pointers. The latter are being scanned repeatedly. The advantage of combining these two methods was pointed out by Hosking and Moss <ref> [3] </ref>. After scanning a card once to find all modifications, the relevant inter-generational pointers can be kept in a remembered set and the card need not be scanned again unless it is modified. <p> This understanding leads to the compaction of the information that has to be kept per card, and to the efficient use of this information. Wilson and Moher [10] suggest to keep a byte per card in the card table. This idea was adopted in subsequent collectors <ref> [2, 3] </ref>. It is this "waste" of space that allows the very low overhead on the application. When the muta-tor has to mark a card dirty, it is much cheaper to clear a byte in the card table, than to modify a single bit. <p> In order to keep the overhead during normal operation low, we also propose to combine card marking with the remembered sets method as suggested in <ref> [3, 4] </ref>. The old heap is partitioned into cards and when the application modifies a card, it marks the card dirty. When a car has to be scanned, all "dirty" cards are traversed and the remembered set is updated and later used to find roots for the collection. <p> Very efficient card marking implementations have been suggested for several systems <ref> [3, 10, 2] </ref>. In our above approach, there is a change in the application overhead. Instead of writing the constant zero into the entry in the card table, we now move a value, i.e., the time, kept in some variable, into this entry.
Reference: [4] <author> R. L. Hudson and J. E. B. Moss. </author> <title> Incre--mental garbage collection for mature objects. </title> <editor> In Yves Bekkers and Jacques Co-hen, editors. </editor> <booktitle> Proceedings of International Workshop on Memory Management, volume 637 of Lecture Notes in Computer Science, 1992. </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: However, when collecting the old generation (or the full heap) the application suffers long delays. The train algorithm <ref> [4] </ref> deals with this problem by partitioning the old generation to small parts (that can be thought of as cars in trains) and collecting one part at a time. Thus, each collection does not cause a long delay to the application. We go into more details in Section 3.1. <p> However, when the old generation is collected, the delay is still long. Hudson and Moss <ref> [4] </ref> suggested the train algorithm to deal with this problem. The train algorithm partitions the old generation into parts called cars, and collects one car at a time. The problem with a naive implementation of this idea is that cycles of garbage that spread among several cars cannot be collected. <p> In this paper, we do not discuss the correctness of the algorithm, nor its efficiency. We refer the reader to <ref> [4, 6] </ref> for motivations, details, and an implementation. Here, we specify some details of the algorithm that are relevant for our solution. First, when a car is collected, the young generation is collected as well. Actually, the young generation may sometimes be collected without any car collection. <p> In order to keep the overhead during normal operation low, we also propose to combine card marking with the remembered sets method as suggested in <ref> [3, 4] </ref>. The old heap is partitioned into cards and when the application modifies a card, it marks the card dirty. When a car has to be scanned, all "dirty" cards are traversed and the remembered set is updated and later used to find roots for the collection. <p> It is also possible to adapt our scheme for a scheme with several young generations and one old generation that is split into cars (such a scheme was suggested in <ref> [4, 6] </ref>.) We only have to add for each generation a time-stamp indicating when the remembered set of this generation was last updated. This time-stamp should be updated by the collector whenever it scans the corresponding generation.
Reference: [5] <author> H. Lieberman and C. E. Hewitt. </author> <title> A Real Time Garbage Collector Based on the Lifetimes of Objects. </title> <journal> Communications of the ACM, </journal> <volume> 26(6), </volume> <pages> pages 419-429, </pages> <year> 1983. </year>
Reference-contexts: 1 Introduction Generational garbage collection was introduced by Lieberman and Hewitt <ref> [5] </ref> and has been accepted as an excellent solution for reducing pause times induced by garbage collection. Generational garbage collectors rely on the assumption that most objects die young. Under this assumption, it is useful to collect the garbage in the young area more frequently. <p> Scanning the full heap to dis-cover the pointers that go into the young generation is an expensive operation which would foil the quick collection of the young generation. Two common solutions are remembered sets and card marking <ref> [5, 8, 7, 10] </ref>. We explain these methods in Section 2.2 below. Hosking and Hudson [3] suggested a hybrid method enjoying the advantages of both methods. In this work, we study this method for a generational scheme that uses more than two generations. <p> Typically, the number of such pointers is relatively small and thus, generational collections can use a data structure to maintain an (almost) updated list of these inter-generational pointers. Two possible data structures were suggested <ref> [5, 8, 7] </ref>: card marking and remembered sets. A combination of the two was suggested in [3]. 2.2 Card Marking and Remembered Sets One way to keep inter-generational pointers to a given generation is to keep a remembered set for the generation [5, 8]. <p> Two possible data structures were suggested [5, 8, 7]: card marking and remembered sets. A combination of the two was suggested in [3]. 2.2 Card Marking and Remembered Sets One way to keep inter-generational pointers to a given generation is to keep a remembered set for the generation <ref> [5, 8] </ref>. In the remembered set of generation g, all locations of the inter-generational pointers that reference objects in generation g are kept. Maintenance of this set is done by the application whenever a pointer is stored, and by the collector when objects are promoted.
Reference: [6] <author> J. Seligmann and S. Grarup. </author> <title> Incremental mature garbage collection using the train algorithm. </title> <editor> In O. Nierstras, editor. </editor> <booktitle> Proceedings of 1995 European Conference on Object-Oriented Programming, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: In this paper, we do not discuss the correctness of the algorithm, nor its efficiency. We refer the reader to <ref> [4, 6] </ref> for motivations, details, and an implementation. Here, we specify some details of the algorithm that are relevant for our solution. First, when a car is collected, the young generation is collected as well. Actually, the young generation may sometimes be collected without any car collection. <p> It is also possible to adapt our scheme for a scheme with several young generations and one old generation that is split into cars (such a scheme was suggested in <ref> [4, 6] </ref>.) We only have to add for each generation a time-stamp indicating when the remembered set of this generation was last updated. This time-stamp should be updated by the collector whenever it scans the corresponding generation.
Reference: [7] <author> Patrick Sobalvarro. </author> <title> A lifetime-based garbage collector for Lisp systems on general-purpose computers. </title> <type> Technical Report AITR-1417, </type> <institution> MIT, AI Lab, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: Scanning the full heap to dis-cover the pointers that go into the young generation is an expensive operation which would foil the quick collection of the young generation. Two common solutions are remembered sets and card marking <ref> [5, 8, 7, 10] </ref>. We explain these methods in Section 2.2 below. Hosking and Hudson [3] suggested a hybrid method enjoying the advantages of both methods. In this work, we study this method for a generational scheme that uses more than two generations. <p> Typically, the number of such pointers is relatively small and thus, generational collections can use a data structure to maintain an (almost) updated list of these inter-generational pointers. Two possible data structures were suggested <ref> [5, 8, 7] </ref>: card marking and remembered sets. A combination of the two was suggested in [3]. 2.2 Card Marking and Remembered Sets One way to keep inter-generational pointers to a given generation is to keep a remembered set for the generation [5, 8]. <p> The reader is referred to [1, 9] for a detailed description of various variants on this method. Maintaining the remembered set implies a costly overhead on the application during normal operation. Card marking reduces this cost <ref> [7] </ref>. Here, the heap is partitioned into cards of equal size, and whenever the application modifies an object in a card, it marks the card as dirty. Marking a card is a very short operation [7, 10, 2]. Depending on the specific processor, it may be implemented in 3-6 instructions. <p> Card marking reduces this cost [7]. Here, the heap is partitioned into cards of equal size, and whenever the application modifies an object in a card, it marks the card as dirty. Marking a card is a very short operation <ref> [7, 10, 2] </ref>. Depending on the specific processor, it may be implemented in 3-6 instructions. However, the collector performs more work in a card marking system. It must scan all the dirty cards to find the inter-generational pointers, instead of just getting the pointer from the remembered set.
Reference: [8] <author> D. Ungar. </author> <title> Generation Scavenging: A Non-disruptive High Performance Storage Reclamation Algorithm. </title> <booktitle> Proceedings of the ACM Symposium on Practical Software Development Environments, ACM SIG-PLAN Notices Vol. </booktitle> <volume> 19, No. 5, </volume> <month> May </month> <year> 1984, </year> <pages> pp. 157-167. </pages>
Reference-contexts: Scanning the full heap to dis-cover the pointers that go into the young generation is an expensive operation which would foil the quick collection of the young generation. Two common solutions are remembered sets and card marking <ref> [5, 8, 7, 10] </ref>. We explain these methods in Section 2.2 below. Hosking and Hudson [3] suggested a hybrid method enjoying the advantages of both methods. In this work, we study this method for a generational scheme that uses more than two generations. <p> Typically, the number of such pointers is relatively small and thus, generational collections can use a data structure to maintain an (almost) updated list of these inter-generational pointers. Two possible data structures were suggested <ref> [5, 8, 7] </ref>: card marking and remembered sets. A combination of the two was suggested in [3]. 2.2 Card Marking and Remembered Sets One way to keep inter-generational pointers to a given generation is to keep a remembered set for the generation [5, 8]. <p> Two possible data structures were suggested [5, 8, 7]: card marking and remembered sets. A combination of the two was suggested in [3]. 2.2 Card Marking and Remembered Sets One way to keep inter-generational pointers to a given generation is to keep a remembered set for the generation <ref> [5, 8] </ref>. In the remembered set of generation g, all locations of the inter-generational pointers that reference objects in generation g are kept. Maintenance of this set is done by the application whenever a pointer is stored, and by the collector when objects are promoted.
Reference: [9] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <editor> In Yves Bekkers and Jacques Cohen, editors. </editor> <booktitle> Proceedings of International Workshop on Memory Management, volume 637 of Lecture Notes in Computer Science, 1992. </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In the remembered set of generation g, all locations of the inter-generational pointers that reference objects in generation g are kept. Maintenance of this set is done by the application whenever a pointer is stored, and by the collector when objects are promoted. The reader is referred to <ref> [1, 9] </ref> for a detailed description of various variants on this method. Maintaining the remembered set implies a costly overhead on the application during normal operation. Card marking reduces this cost [7].
Reference: [10] <author> P. R. Wilson and T. G. Moher. </author> <title> A card-marking scheme for controlling intergen-erational references in generation-based garbage collection on stock hardware. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(5) </volume> <pages> 87-92, </pages> <year> 1989. </year>
Reference-contexts: Scanning the full heap to dis-cover the pointers that go into the young generation is an expensive operation which would foil the quick collection of the young generation. Two common solutions are remembered sets and card marking <ref> [5, 8, 7, 10] </ref>. We explain these methods in Section 2.2 below. Hosking and Hudson [3] suggested a hybrid method enjoying the advantages of both methods. In this work, we study this method for a generational scheme that uses more than two generations. <p> Card marking reduces this cost [7]. Here, the heap is partitioned into cards of equal size, and whenever the application modifies an object in a card, it marks the card as dirty. Marking a card is a very short operation <ref> [7, 10, 2] </ref>. Depending on the specific processor, it may be implemented in 3-6 instructions. However, the collector performs more work in a card marking system. It must scan all the dirty cards to find the inter-generational pointers, instead of just getting the pointer from the remembered set. <p> In both cases, the key to the solution is to understand the relations between the cards and the generations or cars. This understanding leads to the compaction of the information that has to be kept per card, and to the efficient use of this information. Wilson and Moher <ref> [10] </ref> suggest to keep a byte per card in the card table. This idea was adopted in subsequent collectors [2, 3]. It is this "waste" of space that allows the very low overhead on the application. <p> Very efficient card marking implementations have been suggested for several systems <ref> [3, 10, 2] </ref>. In our above approach, there is a change in the application overhead. Instead of writing the constant zero into the entry in the card table, we now move a value, i.e., the time, kept in some variable, into this entry.
References-found: 10

