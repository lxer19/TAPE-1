URL: http://www.cs.purdue.edu/homes/palsberg/paper/tse-to-appear.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: email: seiter@cs.bc.edu  email: palsberg@theory.lcs.mit.edu  email: lieber@ccs.neu.edu  
Title: Evolution of Object Behavior using Context Relations  
Author: Linda M. Seiter Jens Palsberg Karl J. Lieberherr 
Keyword: Reusable design, a new class relation, behavior composition.  
Address: Boston College Chestnut Hill, MA 02167  545 Technology Square Cambridge, MA 02139  360 Huntington Avenue Boston, MA 02155  
Affiliation: Computer Science Dept.  Laboratory for Computer Science MIT  College of Computer Science Northeastern University  
Abstract: A collection of design patterns was described by Gamma, Helm, Johnson, and Vlissides in 1994. Recognizing that designs change, each pattern ensures that a certain system aspect can vary over time such as the operations that can be applied to an object or the algorithm of a method. The patterns are described by constructs such as the inheritance and reference relations, attempting to emulate more dynamic relationships. As a result, the design patterns demonstrate how awkward it is to program natural concepts of behavioral evolution when using a traditional object-oriented language. In this paper we present a new relation between classes: the context relation. It directly supports behavioral evolution, and it is meaningful at the analysis, design, and implementation level. At the design level we picture a context relation as a new form of arrow between classes. At the implementation level we use a small extension of C++. The basic idea is that if class C is context-related to a base class B, then B-objects can get their functionality dynamically altered by C-objects. Our language construct for doing this is a generalization of the method update in Abadi and Cardelli's imperative object calculus. A C-object may be explicitly attached to a B-object, or it may be implicitly attached to a group of B-objects for the duration of a method invocation. We demonstrate how the context relation can be used to easily model and program the Adapter, Bridge, Chain of Responsibility, Decorator, Iterator, Observer, State, Strategy, and Visitor patterns. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Luca Cardelli. </author> <title> An imperative object calculus. </title> <booktitle> In Proc. TAPSOFT'95, Theory and Practice of Software Development, </booktitle> <pages> pages 471-485. </pages> <publisher> Springer-Verlag (LNCS 915), </publisher> <address> Aarhus, Denmark, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: The basic idea is that if class C is context-related to a base class B, then B-objects can get their functionality dynamically altered by the presence of C-objects. Our language construct for doing this is a generalization of the method update in Abadi and Cardelli's imperative object calculus <ref> [1] </ref>. A C-object may be explicitly attached to a B-object, or it may be implicitly attached to a group of B-objects for the duration of a method invocation. This supports reuse of the class B because like inheritance, the class B does not know about class C.
Reference: [2] <author> Constantin Arapis. </author> <title> Specifying Object Life-Cycles. </title> <booktitle> Object Management, </booktitle> <year> 1990. </year>
Reference-contexts: with incremental context object attachment to compute both visitors during one traversal, simply by using the + operator. 4 Related Work Holland summarizes extensions to the object model that have been proposed for varying the interface and behavior of an object [10], such as perspectives [7], views [22], and contexts <ref> [2] </ref>. <p> As with perspectives, the required view must be explicitly paired with an object to access an attribute or invoke a method of the object. Both perspectives and views require clients to know about the interface subset partitioning, thus violating encapsulation. Arapis <ref> [2] </ref> proposed the notion of contexts to represent the roles of an object. As with perspectives and views, the client of an object must specifically state the method of a particular context to be invoked.
Reference: [3] <author> Daniel G. Bobrow, Linda G. DeMichiel, Richard P. Gabriel, Sonya E. Keene, Gregor Kiczales, and David A. Moon. </author> <title> Common Lisp object system specification:X3J13 document 88-002R. volume 23. </title> <publisher> ACM Press, </publisher> <month> September </month> <year> 1988. </year> <journal> Special Issue of SIGPLAN Notices. </journal>
Reference-contexts: As a context object scopes its attributes and methods, incremental composition will not result in naming issues. 4.3 Meta-level approaches A metaobject protocol (MOP) is an interface that allows a programmer to customize properties of the programming language, such as adding persistence and concurrency <ref> [3, 12] </ref>. A reflective programming language is one which supports such customizations, allowing the program to reason about its own execution state and alter behavior accordingly [23]. The context relation and context objects can be implemented using reflection.
Reference: [4] <author> Grady Booch. </author> <title> Object-Oriented Design With Applications. </title> <publisher> Benjamin/Cummings Publishing Company, Inc., </publisher> <year> 1991. </year>
Reference-contexts: Researchers have acknowledged the need to lift abstraction above the class level, and several approaches have been proposed for modeling collaborative, task-based behavior, including Frameworks [11], Clusters [18], Mechanisms <ref> [4] </ref>, Contracts [9, 10], Propagation Patterns [26, 14], and Subjects [20]. As an example, a Contract [9, 10] models a set of object interactions. The participants of the contract have certain obligations (attributes and behaviors) that they must support.
Reference: [5] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year> <note> ISBN 0-201-51459-1. </note>
Reference-contexts: Like the Strategy pattern, all of the design patterns in [6] are described using constructs such as the static inheritance and aggregation relations, with examples of each pattern given in C++ <ref> [5] </ref>. The code unintentionally demonstrates how awkward it is to program natural concepts of behavioral evolution in a static, class-based language.
Reference: [6] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. Professional Computing Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <month> October </month> <year> 1994. </year> <note> ISBN 0-201-63361-2. </note>
Reference-contexts: traversal Observer inter-object dependency State value-dependent object behavior Strategy algorithm implementation Visitor class responsibilities Table 1: Variations defined by design patterns engineering community has only recently been provided with a clear notion of reusable design constructs, in the form of design patterns as presented by Gamma, Helm, Johnson, and Vlissides <ref> [6] </ref>. The patterns have been fundamental in helping the software engineering community recognize forms of evolution for objects in an application domain. Each design pattern identifies an aspect of a system that may vary, and proposes a way of writing programs such that the variation is possible. <p> Each design pattern identifies an aspect of a system that may vary, and proposes a way of writing programs such that the variation is possible. Table 1 contains a partial list of design patterns from <ref> [6] </ref>, along with the variation each is intended to support. As an example, the Strategy pattern allows an algorithm to be encapsulated as a construct, and supports a mechanism for varying parts of the algorithm. Thus, a strategy allows multiple implementations to be defined for a single interface. <p> This violates class encapsulation by requiring the client class to know details about the implementation of the receiver class. Like the Strategy pattern, all of the design patterns in <ref> [6] </ref> are described using constructs such as the static inheritance and aggregation relations, with examples of each pattern given in C++ [5]. The code unintentionally demonstrates how awkward it is to program natural concepts of behavioral evolution in a static, class-based language. <p> require an implementation of the method to either exist directly in the base class, as in Figure 4, or to exist in some context-related class that is declared to be the default implementation, as in Figure 5. 1.4 Paper organization Design patterns have been categorized as creational, structural, and behavioral <ref> [6] </ref>. Creational patterns abstract the instantiation process, structural patterns abstract object composition, and behavioral patterns abstract object communication and responsibilities. <p> This allows the algorithm to vary independently of the clients that use it <ref> [6] </ref>. relation between a Composition class used to maintain and update the line-breaks of text displayed in a text viewer, and a Compositor class which represents different variations of the line-breaking algorithm. <p> An object in different states may react differently to the same message. Figure 10 contains a partial dynamic model for representing a TCP connection network connection, based on the example presented in <ref> [6] </ref>. A TCP connection can be in one of several states such as closed, established, or listening, and may receive messages such as open, close, send, etc. Figure 10 also contains a partial object model, with TCPConnection linked to TCPState through an aggregation relation labeled state. <p> A more flexible pattern of object traversal allows navigation through composite objects of any form, not just homogeneous list structures. A composite is a structural pattern that represents a whole-part hierarchy <ref> [6] </ref>. For example, the class structure in Figure 11 describes a containment hierarchy for a computer consisting of equipment, which may contain other equipment as parts. Iterators at each level in the composite hierarchy could be written to traverse a computer object, performing some task during the traversal. <p> One or more contexts will be used to override the default empty behavior, providing task-specific implementations. 3.2 Visitor Pattern The visitor pattern is used to specify the operations to perform during traversal <ref> [6] </ref>. A visitor allows behavior to be added to a composite structure, without changing the existing class definitions. Visitors reduce the number of operations directly embedded within a class, thus preventing class definitions from becoming cluttered. <p> Visitors group related operations performed on multiple classes (which need not be related through inheritance) together into one program component, supporting a task-based style of programming. For example, two operations to be performed on the equipment class structure include computing inventory of materials and calculating total cost of equipment <ref> [6] </ref>. Inventory simply accumulates a list of equipment objects. Equipment cost is calculated by computing the net price of simple equipment and the discount price of composite equipment.
Reference: [7] <author> Ira P. Goldstein and Dainel G. Bobrow. </author> <title> Extending Object-Oriented Programming in Smalltalk. </title> <booktitle> In Proceedings of the Lisp Conference, 1980. </booktitle> <address> Stanford, CA. </address>
Reference-contexts: shows the main program rewritten with incremental context object attachment to compute both visitors during one traversal, simply by using the + operator. 4 Related Work Holland summarizes extensions to the object model that have been proposed for varying the interface and behavior of an object [10], such as perspectives <ref> [7] </ref>, views [22], and contexts [2]. <p> site: is the interface selected explic itly at the call site, or implicitly? * Scope of the interface: is the interface defined over many object types or just one? In the remainder of this section, we compare other proposals for evolving object behavior. 4.1 Evolving object interfaces and behavior Perspectives <ref> [7] </ref> were among the earliest proposals for varying the interface of an object. Software components are represented as a network of nodes. The attributes of a node are grouped into perspectives, each providing a different view of the entity.
Reference: [8] <author> Mary Jean Harrold, John D. McGregor, and Kevin J. Fitzpatrick. </author> <title> Incremental Testing of Object-Oriented Class Structures. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <pages> pages 68-80. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1992. </year>
Reference-contexts: If a base class is well tested, and a context class is added to alter its methods, how much retesting is required? Harrold, McGregor and Fitzpatrick present a hierarchical incremental testing (HIT) technique for reusing base class tests with derived classes <ref> [8] </ref>. The algorithm can be customized for testing the context relation. Software engineering principles have long supported a black-box or strongly encapsulated form of programming, with a strict boundary formed around a software component, namely its interface.
Reference: [9] <author> Richard Helm, Ian M. Holland, and Dipayan Gan-gopadhyay. </author> <title> Contracts: Specifying Behavioral Compositions in Object-Oriented Systems. </title> <booktitle> In Object-Oriented Programming Systems, Languages and Applications Conference, in Special Issue of SIGPLAN Notices, </booktitle> <pages> pages 169-180, </pages> <address> Ottawa, </address> <year> 1990. </year> <note> ACM Press. Joint conference ECOOP/OOPSLA. </note>
Reference-contexts: Researchers have acknowledged the need to lift abstraction above the class level, and several approaches have been proposed for modeling collaborative, task-based behavior, including Frameworks [11], Clusters [18], Mechanisms [4], Contracts <ref> [9, 10] </ref>, Propagation Patterns [26, 14], and Subjects [20]. As an example, a Contract [9, 10] models a set of object interactions. The participants of the contract have certain obligations (attributes and behaviors) that they must support. <p> Researchers have acknowledged the need to lift abstraction above the class level, and several approaches have been proposed for modeling collaborative, task-based behavior, including Frameworks [11], Clusters [18], Mechanisms [4], Contracts <ref> [9, 10] </ref>, Propagation Patterns [26, 14], and Subjects [20]. As an example, a Contract [9, 10] models a set of object interactions. The participants of the contract have certain obligations (attributes and behaviors) that they must support.
Reference: [10] <author> Ian M. Holland. </author> <title> The design and representation of object-oriented components. </title> <type> PhD thesis, </type> <institution> Northeastern University, </institution> <year> 1993. </year> <note> http://www.ccs.neu.edu/home/lieber/theses-index.html. </note>
Reference-contexts: Figure 18 shows the main program rewritten with incremental context object attachment to compute both visitors during one traversal, simply by using the + operator. 4 Related Work Holland summarizes extensions to the object model that have been proposed for varying the interface and behavior of an object <ref> [10] </ref>, such as perspectives [7], views [22], and contexts [2]. <p> Researchers have acknowledged the need to lift abstraction above the class level, and several approaches have been proposed for modeling collaborative, task-based behavior, including Frameworks [11], Clusters [18], Mechanisms [4], Contracts <ref> [9, 10] </ref>, Propagation Patterns [26, 14], and Subjects [20]. As an example, a Contract [9, 10] models a set of object interactions. The participants of the contract have certain obligations (attributes and behaviors) that they must support. <p> Researchers have acknowledged the need to lift abstraction above the class level, and several approaches have been proposed for modeling collaborative, task-based behavior, including Frameworks [11], Clusters [18], Mechanisms [4], Contracts <ref> [9, 10] </ref>, Propagation Patterns [26, 14], and Subjects [20]. As an example, a Contract [9, 10] models a set of object interactions. The participants of the contract have certain obligations (attributes and behaviors) that they must support.
Reference: [11] <author> Ralph E. Johnson and Brian Foote. </author> <title> Designing reusable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(2) </volume> <pages> 22-35, </pages> <month> June/July </month> <year> 1988. </year>
Reference-contexts: Researchers have acknowledged the need to lift abstraction above the class level, and several approaches have been proposed for modeling collaborative, task-based behavior, including Frameworks <ref> [11] </ref>, Clusters [18], Mechanisms [4], Contracts [9, 10], Propagation Patterns [26, 14], and Subjects [20]. As an example, a Contract [9, 10] models a set of object interactions. The participants of the contract have certain obligations (attributes and behaviors) that they must support.
Reference: [12] <author> G. Kiczales, J. des Rivieres, and D.G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: As a context object scopes its attributes and methods, incremental composition will not result in naming issues. 4.3 Meta-level approaches A metaobject protocol (MOP) is an interface that allows a programmer to customize properties of the programming language, such as adding persistence and concurrency <ref> [3, 12] </ref>. A reflective programming language is one which supports such customizations, allowing the program to reason about its own execution state and alter behavior accordingly [23]. The context relation and context objects can be implemented using reflection.
Reference: [13] <author> Gregor Kiczales, </author> <title> editor. </title> <note> internet publication (http://www.parc.xerox.com/PARC/spl/eca/oi/workshop-94). </note>
Reference-contexts: The context relation and context objects can be implemented using reflection. Open Implementation (OI) principles advocate reflection to provide the programmer with more control, to avoid the inefficient work-arounds often caused from black-box languages and systems <ref> [13] </ref>. The context relation supports OI principles, providing the programmer with a better tool for controlling dynamic behavior. 5 Summary To model and implement the evolution of behavior, we propose the context relation as an extension to the existing object-oriented model.
Reference: [14] <author> Karl J. Lieberherr. </author> <title> Adaptive Object-Oriented Software: The Demeter Method with Propagation Patterns. </title> <publisher> PWS Publishing Company, </publisher> <address> Boston, </address> <year> 1996. </year> <note> ISBN 0-534-94620-X. </note>
Reference-contexts: Modification of the class design requires maintenance of the traversal-oriented code. A traversal specification may be used to define paths within class structures adaptively, implying details of the actual class structure are not hard-coded <ref> [14] </ref>. A traversal specification supplies the minimal information required for abstracting a path from a class structure. void Computer::allEquip () traverse to Equipment; - Traversing the parts of a computer requires navigation along paths that lead to pieces of equipment, thus the target of traversal is the equipment class. <p> Researchers have acknowledged the need to lift abstraction above the class level, and several approaches have been proposed for modeling collaborative, task-based behavior, including Frameworks [11], Clusters [18], Mechanisms [4], Contracts [9, 10], Propagation Patterns <ref> [26, 14] </ref>, and Subjects [20]. As an example, a Contract [9, 10] models a set of object interactions. The participants of the contract have certain obligations (attributes and behaviors) that they must support. <p> An additional difference arises from the composition mechanism, which is the process of creating new components from existing ones. Contracts support composition through refinement (inheritance) and inclusion, which involves injecting the code of one component into another. Propagation patterns <ref> [14] </ref> provide an adaptive approach to collaborative behavior, in that behavior is defined in a manner that can be reused with many class structures.
Reference: [15] <author> Karl J. Lieberherr and Cun Xiao. </author> <title> Minimizing Dependency on Class Structures with Adaptive Programs. </title> <editor> In S. Nishio and A. Yonezawa, editors, </editor> <booktitle> International Symposium on Object Technologies for Advanced Software, </booktitle> <pages> pages 424-441, </pages> <address> Kanazawa, Japan, </address> <month> November </month> <year> 1993. </year> <title> JSSST, </title> <publisher> Springer Verlag. </publisher>
Reference-contexts: In this paper, we separate the two, allowing adaptive traversal specifications to be reused with many tasks. To execute both visitors during a single traversal, the traversal directive would have to be removed from one of the propagation patterns, which would be converted into a transportation pattern <ref> [15] </ref>. The two visitors could then be composed by injecting the code wrappers from the transportation pattern into the propagation pattern. The composition mechanism used with propagation patterns, namely transportation pattern inclusion, suffer from the same problem found with many approaches, including contracts.
Reference: [16] <author> Henry Lieberman. </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems. In Object-Oriented Programming Systems, </title> <journal> Languages and Applications Conference, in Special Issue of SIG-PLAN Notices, </journal> <volume> number 11, </volume> <pages> pages 214-223. </pages> <publisher> ACM, </publisher> <year> 1986. </year>
Reference-contexts: The strategy object then executes the appropriate behavior for the receiver object. Conceptually, the implementation of m given in the Strategy class should be executed upon the receiver of the message, namely the Receiver class instance. This corresponds to the self-reference principle supported with the implicit delegation relation <ref> [16] </ref>. <p> An alternative to modeling behavioral evolution with static aggregation and inheritance is the use of dynamic inheritance, as is found in prototype-based languages such as Self [25] and Lieberman <ref> [16] </ref>. Dynamic inheritance, or delegation, allows the behavior of an object to evolve dynamically by modifying its parent relation to other objects.
Reference: [17] <author> Cristina Videira Lopes and Karl Lieberherr. </author> <title> AP/S++: case-study of a MOP for purposes of software evolution. In Reflection '96, </title> <editor> S. </editor> <address> Francisco, CA, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: Figure 12 shows example code to accomplish this task, using a traversal expression style proposed by Lopes and Lieberherr <ref> [17] </ref>. The keyword traverse is used along with a path description, for example, indicating paths that lead to equipment objects.
Reference: [18] <author> Betrand Meyer. </author> <title> Tools for the new culture: Lessons from the design of the Eiffel libraries. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 68-88, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Researchers have acknowledged the need to lift abstraction above the class level, and several approaches have been proposed for modeling collaborative, task-based behavior, including Frameworks [11], Clusters <ref> [18] </ref>, Mechanisms [4], Contracts [9, 10], Propagation Patterns [26, 14], and Subjects [20]. As an example, a Contract [9, 10] models a set of object interactions. The participants of the contract have certain obligations (attributes and behaviors) that they must support.
Reference: [19] <author> Sun Microsystems. </author> <title> The Java Language: </title> <note> A White Paper. http://www.javasoft.com. </note>
Reference-contexts: Ensuring that one of the implementations is declared as a default will protect against a "message not understood" error. There have been various proposals for separating an interface from an implementation. For example the language Java supports this separation <ref> [19] </ref>. An Interface defines a set of method signatures, while a Class defines the structure and behavior of its instances. A class may match several interfaces, if it implements the methods defined by each interface. Classes are instantiable, while interfaces are not. <p> The expression this ::+ _comp; alters the Composition object by updating the Compose method implementation to be that defined in the context class. In C++, a dynamic method lookup is required when a virtual method is invoked through a pointer. In a language such as Java <ref> [19] </ref>, all methods are assumed virtual (unless declared final) and all objects are referenced through pointers. Each method invocation will require a dynamic lookup. The context relation allows method update, not just for subclasses but for the base class itself.
Reference: [20] <author> Harold Ossher, Matthew Kaplan, William Harrison, Alexander Katz, and Vincent Kruskal. </author> <title> Subject-oriented composition rules. </title> <booktitle> In Object-Oriented Programming Systems, Languages and Applications Conference, in Special Issue of SIGPLAN Notices, </booktitle> <pages> pages 235-250, </pages> <address> Austin, Texas, </address> <month> October </month> <year> 1995. </year> <note> ACM Press. </note>
Reference-contexts: Researchers have acknowledged the need to lift abstraction above the class level, and several approaches have been proposed for modeling collaborative, task-based behavior, including Frameworks [11], Clusters [18], Mechanisms [4], Contracts [9, 10], Propagation Patterns [26, 14], and Subjects <ref> [20] </ref>. As an example, a Contract [9, 10] models a set of object interactions. The participants of the contract have certain obligations (attributes and behaviors) that they must support.
Reference: [21] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: The essence of the state pattern is to define a relation between the attribute values of an object and its behavior. This is modeled through the conceptual link between the object model and the dynamic model <ref> [21] </ref>. However, the translation of the dynamic model into a corresponding class-based model usually turns the relation into aggregation and inheritance. As with the strategy pattern, the state pattern is poorly modeled using aggregation and inheritance.
Reference: [22] <author> J.J. Schilling and P.F. Sweeny. </author> <title> Three steps to logical views: Extending the object-oriented paradigm. </title> <booktitle> In Object-Oriented Programming Systems, Languages and Applications Conference, in Special Issue of SIGPLAN Notices, </booktitle> <pages> pages 353-361, </pages> <address> New Orleans, LA, 1989. </address> <publisher> ACM Press. </publisher>
Reference-contexts: main program rewritten with incremental context object attachment to compute both visitors during one traversal, simply by using the + operator. 4 Related Work Holland summarizes extensions to the object model that have been proposed for varying the interface and behavior of an object [10], such as perspectives [7], views <ref> [22] </ref>, and contexts [2]. <p> Software components are represented as a network of nodes. The attributes of a node are grouped into perspectives, each providing a different view of the entity. To access a particular attribute of an object, one must specify the perspective along with the object. Views <ref> [22] </ref> present another approach to partitioning an object interface. As with perspectives, the required view must be explicitly paired with an object to access an attribute or invoke a method of the object. Both perspectives and views require clients to know about the interface subset partitioning, thus violating encapsulation.
Reference: [23] <author> B.C. Smith. </author> <title> Reflection and Semantics in Lisp. </title> <booktitle> In Proceedings of the 14th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 23-35, </pages> <year> 1984. </year>
Reference-contexts: A reflective programming language is one which supports such customizations, allowing the program to reason about its own execution state and alter behavior accordingly <ref> [23] </ref>. The context relation and context objects can be implemented using reflection. Open Implementation (OI) principles advocate reflection to provide the programmer with more control, to avoid the inefficient work-arounds often caused from black-box languages and systems [13].
Reference: [24] <author> Antero Taivalsaari. </author> <title> Object Oriented programming with modes. </title> <type> Technical report, </type> <institution> University of Jyvaskyla, Fin-land, </institution> <year> 1991. </year>
Reference-contexts: As with perspectives and views, the client of an object must specifically state the method of a particular context to be invoked. The mode concept of Taivalsaari partitions the implementations of an interface, rather than the interfaces of an object <ref> [24] </ref>. When an object receives a message, the implementation triggered depends on the mode or state of the object. As opposed to roles and views, clients need not be aware of the current mode at the call site.
Reference: [25] <author> David Ungar and Randall B. Smith. </author> <title> Self: The power of Simplicity. In Object-Oriented Programming Systems, </title> <journal> Languages and Applications Conference, in Special Issue of SIGPLAN Notices, </journal> <volume> number 12, </volume> <pages> pages 227-242. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: An alternative to modeling behavioral evolution with static aggregation and inheritance is the use of dynamic inheritance, as is found in prototype-based languages such as Self <ref> [25] </ref> and Lieberman [16]. Dynamic inheritance, or delegation, allows the behavior of an object to evolve dynamically by modifying its parent relation to other objects.
Reference: [26] <author> Cun Xiao. </author> <title> Adaptive Software: Automatic Navigation Through Partially Specified Data Structures. </title> <type> PhD thesis, </type> <institution> Northeastern University, </institution> <year> 1994. </year> <note> http://www.ccs.neu.edu/home/lieber/theses-index.html. </note>
Reference-contexts: Researchers have acknowledged the need to lift abstraction above the class level, and several approaches have been proposed for modeling collaborative, task-based behavior, including Frameworks [11], Clusters [18], Mechanisms [4], Contracts [9, 10], Propagation Patterns <ref> [26, 14] </ref>, and Subjects [20]. As an example, a Contract [9, 10] models a set of object interactions. The participants of the contract have certain obligations (attributes and behaviors) that they must support.
References-found: 26

