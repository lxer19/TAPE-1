URL: http://www.cs.mu.oz.au/tr_db/mu_93_03.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: First-Order Incremental Evaluation of Datalog Queries 1  
Author: Guozhu Dong, Jianwen Su and Rodney Topor Dong Jianwen Su Rodney Topor 
Date: March 30, 1993  
Address: Parkville, Vic. 3052, Australia  Santa Barbara, CA 93106 USA  4111, Australia  
Affiliation: Department of Computer Science The University of Melbourne  Department of Computer Science University of California  School of Computing and Information Technology Griffith University Nathan, Qld  
Note: Guozhu  
Abstract: Technical Report 93/3 Computer Science Department University of Melbourne 1 Part of results in this paper appeared under the title "Incremental Evaluation of Datalog Queries" in Proceedings of the 1992 International Conference on Database Theory, LNCS 646, Springer-Verlag. 2 This author gratefully acknowledges support of Australian Research Council through research grants and the Centre for Intelligient Decision Systems. 3 Work by this author supported in part by NSF grants IRI-9109520 and IRI-9117094. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Afrati and S.S. Cosmadakis. </author> <title> Expressiveness of restricted recursive queries. </title> <booktitle> In Proc. ACM SIGACT Symp. on the Theory of Computing, </booktitle> <pages> pages 113-126, </pages> <year> 1989. </year> <month> 25 </month>
Reference-contexts: Note that chain Datalog programs contain only variables and binary predicate symbols. Chain Datalog programs and generalizations allow special optimization techniques. Indeed, several papers have considered efficiency issues of such programs <ref> [1, 12, 13] </ref>. The current paper also explores such possibilities. It is well known that, for each chain Datalog program , the query (; p) can be associated with a context-free grammar 5 G constructed as follows.
Reference: [2] <author> K. R. Apt, H. A. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, edi-tor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Our task is closely related to the problem of efficiently updating the standard model <ref> [2] </ref> of a definite or more generally stratified database [4, 24]. Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [26].
Reference: [3] <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <title> Foundations of Databases. </title> <type> Manuscript. </type> <year> 1992. </year>
Reference-contexts: Note that first-order or nonrecursive programs define unions of conjunctive database queries [11]. Such queries allow very efficient computations, and have received extensive attention in the literature <ref> [3, 31] </ref>. As we shall argue later, queries computable by FOIES's strictly generalize queries computable by nonrecursive programs. We assume familiarity with the relational databases and the Datalog language [31]. We assume the existence of three pairwise disjoint infinite sets of constants, variables, and predicates. <p> The problem is a variation of the transitive closure query and it can be shown not expressible by first-order queries using an argument of playing Fraisse games similar to the proof for the graph connectivity query in <ref> [3] </ref>. <p> The most desirable aspect of q ffi is its parallel efficiency. Indeed, membership of facts in the answer to the query can be checked in constant time using q ffi since ffi is a first-order query <ref> [3] </ref>. We illustrate the above discussion using Examples 2.1 and 3.5. For Example 2.1, E = edge + , there are four rules in ffi and the number of joins needed is four. <p> Hence has 1-CCI. 2 As an aside, by using a reduction to the undecidable problem of satisfiability of relational calculus <ref> [3] </ref>, it can be shown that it is undecidable if a binary relational calculus (algebra) query has CCI (the detail is omitted). We note that the notion of CCI can be generalized to predicates with arity &gt; 2 and all the results on CCI reported here can also be generalized.
Reference: [4] <author> K. R. Apt and J.-M. Pugin. </author> <title> Maintenance of stratified databases viewed as a belief revision system. </title> <booktitle> In Proc. Sixth ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 136-145, </pages> <year> 1987. </year>
Reference-contexts: Our task is closely related to the problem of efficiently updating the standard model [2] of a definite or more generally stratified database <ref> [4, 24] </ref>. Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [26]. <p> Our approach, for query evaluation rather than for constraint checking, differs in storing previous derived relations and in transforming the programs used in query evaluation. Efficient maintenance of (stratified) databases <ref> [4, 24] </ref>. The goal of this approach is to efficiently compute the standard model of a stratified database after a database update. <p> It is similar to our approach in using the previous standard model (analogous to our stored relations) to simplify the task of computing the standard model (query answer) after the update. Our approach differs by storing intermediate relations rather than reasons (or "supports") for including computed facts <ref> [4] </ref>, by not using meta-programs to compute the difference between successive models [24], and by transforming the programs used in query evaluation. Our approach is, however, more restricted as it does not allow negation in rules and queries. Incremental evaluation by counting [16].
Reference: [5] <author> A. Aho and J. Ullman. </author> <title> Universality of data retrieval languages. </title> <booktitle> In Proc. ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 110-120, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction Relational query languages have limited power since they cannot express recursive queries such as transitive closure queries <ref> [5] </ref>. Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation.
Reference: [6] <author> F. Bancilhon. </author> <title> Naive evaluation of recursively defined relations. </title> <editor> In M. L. Brodie and J. Mylopoulos, editors, </editor> <booktitle> On Knowledge Base Management Systems: Integrating Artificial Intelligence and Database Technologies. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 16, 17, 23, 24, 26] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> More importantly, we emphasize the transformation of the original program into a more efficient nonrecursive program. The second basis is designed to fit database application by virtue of efficiency and easy programmability in database query languages. We now briefly compare our approach with related work. Semi-naive evaluation <ref> [6] </ref>. The basic idea of semi-naive evaluation is, in each iteration in the bottom-up evaluation, to compute only those facts that depend on at least one fact computed in the previous iteration.
Reference: [7] <author> V. Breazu-Tannen, P. Buneman, and L. Wong. </author> <title> Naturally embedded query languages. </title> <booktitle> In Proc. 1992 Int. Conference on Database Theory, </booktitle> <volume> LNCS 646, </volume> <pages> pages 140-154. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In the incremental approach only one or two joins are necessary since the needed steps have previously been computed in anticipation. Structural induction <ref> [7] </ref>. The idea is to build a simple programming language whose main computational engine is structural recursion on sets. Our work can be viewed as special cases of structural 24 induction where structural recursion is deterministic and one fact at a time, and uses first-order queries to compute the increment.
Reference: [8] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proc. Fifth ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <year> 1986. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 16, 17, 23, 24, 26] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> In this sense, this approach is also similar to ours, though it does not involve database updates or storage of derived relations. Our results may contribute to research on partial evaluation. Magic sets <ref> [8] </ref>. Our incremental approach differs considerably from approaches such as the magic set approach [8] to query optimization. Indeed, incremental query evaluation is driven by anticipation, whereas magic set evaluation is driven by need. Consequently, it is difficult to combine the two approaches. <p> In this sense, this approach is also similar to ours, though it does not involve database updates or storage of derived relations. Our results may contribute to research on partial evaluation. Magic sets <ref> [8] </ref>. Our incremental approach differs considerably from approaches such as the magic set approach [8] to query optimization. Indeed, incremental query evaluation is driven by anticipation, whereas magic set evaluation is driven by need. Consequently, it is difficult to combine the two approaches. To see this, consider the path problem in Example 2.1.
Reference: [9] <author> F. Bry, H. Decker and R. Manthey. </author> <title> A uniform approach to constraint satisfaction and constraint satisfiability in deductive databases. </title> <booktitle> In Proc. First Int. Conf. on Extending Database Technology, </booktitle> <pages> pages 488-505, </pages> <year> 1988. </year>
Reference-contexts: We use first-order queries to compute the differences, and call this process "first-order incremental query evaluation." This optimization approach is analogous to the incremental checking of integrity constraint satisfaction by using (i) database updates and (ii) the fact that the integrity constraints were satisfied prior to the updates <ref> [9, 27, 28] </ref>. Our task is closely related to the problem of efficiently updating the standard model [2] of a definite or more generally stratified database [4, 24]. Our approach is very useful in maintaining materialized views upon updates. <p> Integrity constraint simplification <ref> [9, 27, 28] </ref>. The basic idea of integrity constraint simplification is to use an update to determine a simplified set of constraint instances that need to be checked after 23 the update.
Reference: [10] <author> A.L. Buchsbaum, P.C. Kanellakis and J.S. Vitter. </author> <title> A data structure for arc insertion and regular path finding. </title> <booktitle> In Proc. ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <year> 1990. </year>
Reference-contexts: Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [26]. Finally, when restricted to standard transitive closure programs, our task can be viewed as solving the incremental transitive closure computation problem for graphs <ref> [10, 14, 19, 20] </ref>. More detailed comparison will be given in Section 6. In general, all these optimization approaches store extra information to reduce the time required for subsequent computations.
Reference: [11] <author> A. Chandra and P. Merlin. </author> <title> Optimal implementation of conjunctive queries in relational data bases. </title> <booktitle> In Proc. ACM SIGACT Symp. on the Theory of Computing, </booktitle> <pages> pages 77-90, </pages> <year> 1977. </year>
Reference-contexts: However, the results cannot be extended to the case where arbitrary set of tuples is inserted, since for example the transitive closure query (on the inserted set) cannot be computed by a nonrecursive program. Note that first-order or nonrecursive programs define unions of conjunctive database queries <ref> [11] </ref>. Such queries allow very efficient computations, and have received extensive attention in the literature [3, 31]. As we shall argue later, queries computable by FOIES's strictly generalize queries computable by nonrecursive programs. We assume familiarity with the relational databases and the Datalog language [31].
Reference: [12] <author> G. Dong. </author> <title> On Datalog linearization of chain queries. </title> <editor> In J.D. Ullman, editor, </editor> <booktitle> Theoretical Studies in Computer Science, </booktitle> <pages> pages 181-206. </pages> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 16, 17, 23, 24, 26] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> Note that chain Datalog programs contain only variables and binary predicate symbols. Chain Datalog programs and generalizations allow special optimization techniques. Indeed, several papers have considered efficiency issues of such programs <ref> [1, 12, 13] </ref>. The current paper also explores such possibilities. It is well known that, for each chain Datalog program , the query (; p) can be associated with a context-free grammar 5 G constructed as follows.
Reference: [13] <author> G. Dong. </author> <title> Datalog expressiveness of chain queries: Grammar tools and characterizations. </title> <booktitle> In Proc. Eleventh ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 81-90, </pages> <year> 1992. </year>
Reference-contexts: Note that chain Datalog programs contain only variables and binary predicate symbols. Chain Datalog programs and generalizations allow special optimization techniques. Indeed, several papers have considered efficiency issues of such programs <ref> [1, 12, 13] </ref>. The current paper also explores such possibilities. It is well known that, for each chain Datalog program , the query (; p) can be associated with a context-free grammar 5 G constructed as follows.
Reference: [14] <author> G. Dong and J. Su. </author> <title> First-order on-line computation of transitive closure queries. </title> <booktitle> In Proc. of 16th Australian Computer Science Conference, </booktitle> <pages> pages 721-729, </pages> <year> 1993. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 16, 17, 23, 24, 26] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [26]. Finally, when restricted to standard transitive closure programs, our task can be viewed as solving the incremental transitive closure computation problem for graphs <ref> [10, 14, 19, 20] </ref>. More detailed comparison will be given in Section 6. In general, all these optimization approaches store extra information to reduce the time required for subsequent computations. <p> Incremental evaluation by counting [16]. The basic idea of this work is to use the number of derivation trees to achieve incremental evaluation of Datalog queries. In contrast, among other things, our incremental approach do not create new constants not in the original input database. Incremental evaluation after deletion <ref> [14] </ref>. Complementary to the insertion case presented in this paper, [14] considers the computation of the transitive closure of graphs after the deletion of an edge, and gives first-order queries for such computations for two classes of graphs (including the acyclic graphs). Incremental evaluation of arbitrary Datalog [15]. <p> In contrast, among other things, our incremental approach do not create new constants not in the original input database. Incremental evaluation after deletion <ref> [14] </ref>. Complementary to the insertion case presented in this paper, [14] considers the computation of the transitive closure of graphs after the deletion of an edge, and gives first-order queries for such computations for two classes of graphs (including the acyclic graphs). Incremental evaluation of arbitrary Datalog [15].
Reference: [15] <author> G. Dong and R. Topor. </author> <title> Incremental evaluation of Datalog queries. </title> <booktitle> In Proc. Int. Conference on Database Theory, </booktitle> <volume> LNCS 646, </volume> <pages> pages 282-296. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Complementary to the insertion case presented in this paper, [14] considers the computation of the transitive closure of graphs after the deletion of an edge, and gives first-order queries for such computations for two classes of graphs (including the acyclic graphs). Incremental evaluation of arbitrary Datalog <ref> [15] </ref>. An algorithm is given in [15] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms [20, 19, 25, 23]. <p> Incremental evaluation of arbitrary Datalog <ref> [15] </ref>. An algorithm is given in [15] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms [20, 19, 25, 23].
Reference: [16] <author> A. Gupta, D. Katiyar, and I. S. Mumick. </author> <title> Counting solutions to the view maintenance problem. </title> <editor> In K. Ramamohanarao, J. Harland, and G. Dong, editors, </editor> <booktitle> Proceedings of the JICSLP Workshop on Deductive Databases, </booktitle> <year> 1992. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 16, 17, 23, 24, 26] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> Our approach is, however, more restricted as it does not allow negation in rules and queries. Incremental evaluation by counting <ref> [16] </ref>. The basic idea of this work is to use the number of derivation trees to achieve incremental evaluation of Datalog queries. In contrast, among other things, our incremental approach do not create new constants not in the original input database. Incremental evaluation after deletion [14].
Reference: [17] <author> G. G. Hillerbrand, P. C. Kanellakis, H. G. Mairson, and M. Y. Vardi. </author> <title> Tools for Datalog boundedness. </title> <booktitle> In Proc. Tenth ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 1-12, </pages> <year> 1991. </year> <month> 26 </month>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 16, 17, 23, 24, 26] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> This technique also applies to other examples described below. We will discuss the complexity of more general FOIES's in Section 3. 2 We now discuss the equivalence between "predicate boundedness" and the existence of FOIES of a certain form. Predicate boundedness is a special case of boundedness <ref> [21, 17] </ref>. A Datalog program is called p-bounded, where p is a predicate, if there is a nonrecursive Datalog program 0 such that 0 (D)j p = (D)j p for each database D. <p> Combining this with Lemma 2.2, we see that FOIES's strictly generalizes bounded programs as a means of efficient query computation. Since it is undecidable whether an arbitrary Datalog program is predicate bounded <ref> [17] </ref> (even when the program has only one IDB predicate and has only binary IDB predicates [32]), Lemma 2.2 implies the following result: Theorem 2.3: It is undecidable for each arbitrary query (; p) whether there is an FOIES of the form h p ; fpg; ffi i. <p> We considered some complexity issues associated with the incremental programs. We also gave decidability result on weak regularity and results on when programs have the cartesian-closed increment property. Queries possessinging first-order incremental evaluation systems can be viewed as a strict generalization of bounded recursive Datalog queries <ref> [21, 17] </ref>. In fact, such queries can perhaps be appropriately called "incrementally bounded queries." Several problems for future research are listed below. * Incremental evaluation can compute more facts than computation using the original programs.
Reference: [18] <author> G. Hillebrand, P. Kanellakis, H. Mairson, and M. Vardi. </author> <title> Undecidable boundedness problems for Datalog programs. </title> <type> Technical Report RJ 8739, </type> <institution> IBM Almaden Research Center, </institution> <address> San Jose, CA, </address> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: Proposition 5.8: It is undecidable whether an arbitrary program has CCI with respect to a predicate. Proof: The proof is based on a reduction from the halting problem of Turing machines on empty inputs. The reduction is modified from the one used by Vardi et al <ref> [32, 18] </ref> in proving the undecidability of boundedness for binary Datalog programs. We briefly describe their reduction and the changes below. Let M be a Turing machine with one-way infinite tape, an alphabet , a set K of states, and a starting state s 2 K. <p> A constant c encodes a iff q a (c) is true. The predicates succ represents the adjacency relation and first the first symbol. Intuitively, succ "represents" a word over 0 [ f#g which possibly encodes a computation of M . In <ref> [32, 18] </ref>, it was shown that a Datalog program 0 with only one binary IDB predicate FING can be constructed such that when the input is not a proper encoding or is an encoded halting computation, then 0 "floods" FING, i.e., inserting every pair of constants into FING.
Reference: [19] <author> T. Ibaraki and N. Katoh. </author> <title> On-line computation of transitive closure of graphs. </title> <journal> Information Processing Letters, </journal> <volume> 16 </volume> <pages> 95-97, </pages> <year> 1983. </year>
Reference-contexts: Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [26]. Finally, when restricted to standard transitive closure programs, our task can be viewed as solving the incremental transitive closure computation problem for graphs <ref> [10, 14, 19, 20] </ref>. More detailed comparison will be given in Section 6. In general, all these optimization approaches store extra information to reduce the time required for subsequent computations. <p> Incremental evaluation of arbitrary Datalog [15]. An algorithm is given in [15] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms <ref> [20, 19, 25, 23] </ref>. Graph algorithms for on-line evaluation of transitive closure of graphs are given in [20, 19], and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in [23]. <p> An algorithm is given in [15] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms [20, 19, 25, 23]. Graph algorithms for on-line evaluation of transitive closure of graphs are given in <ref> [20, 19] </ref>, and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in [23]. The main difference is that they use more elaborate data structures and recursive algorithms, whereas we only use relations and nonrecursive Datalog programs.
Reference: [20] <author> G.F. </author> <title> Italiano. Amortized efficiency of a path retrieval data structure. </title> <journal> Theoretical Computer Science, </journal> <volume> 48 </volume> <pages> 273-281, </pages> <year> 1986. </year>
Reference-contexts: Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [26]. Finally, when restricted to standard transitive closure programs, our task can be viewed as solving the incremental transitive closure computation problem for graphs <ref> [10, 14, 19, 20] </ref>. More detailed comparison will be given in Section 6. In general, all these optimization approaches store extra information to reduce the time required for subsequent computations. <p> Incremental evaluation of arbitrary Datalog [15]. An algorithm is given in [15] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms <ref> [20, 19, 25, 23] </ref>. Graph algorithms for on-line evaluation of transitive closure of graphs are given in [20, 19], and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in [23]. <p> An algorithm is given in [15] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms [20, 19, 25, 23]. Graph algorithms for on-line evaluation of transitive closure of graphs are given in <ref> [20, 19] </ref>, and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in [23]. The main difference is that they use more elaborate data structures and recursive algorithms, whereas we only use relations and nonrecursive Datalog programs.
Reference: [21] <author> Y. Ioannidis. </author> <title> A time bound on the materialization of some recursively defined views. </title> <booktitle> In Proc. of International Conference on Very Large Data Bases, </booktitle> <year> 1985. </year>
Reference-contexts: This technique also applies to other examples described below. We will discuss the complexity of more general FOIES's in Section 3. 2 We now discuss the equivalence between "predicate boundedness" and the existence of FOIES of a certain form. Predicate boundedness is a special case of boundedness <ref> [21, 17] </ref>. A Datalog program is called p-bounded, where p is a predicate, if there is a nonrecursive Datalog program 0 such that 0 (D)j p = (D)j p for each database D. <p> We considered some complexity issues associated with the incremental programs. We also gave decidability result on weak regularity and results on when programs have the cartesian-closed increment property. Queries possessinging first-order incremental evaluation systems can be viewed as a strict generalization of bounded recursive Datalog queries <ref> [21, 17] </ref>. In fact, such queries can perhaps be appropriately called "incrementally bounded queries." Several problems for future research are listed below. * Incremental evaluation can compute more facts than computation using the original programs.
Reference: [22] <author> D. Jacobs and R. Hull. </author> <title> Database programming with delayed updates. </title> <booktitle> In Proc. 3rd Int. Workshop on Database Programming Languages, </booktitle> <pages> pages 416-428, </pages> <year> 1991. </year>
Reference-contexts: Computing Datalog queries using FOIES is also related to the bounded iteration constructs [29] and the more general treatment of database states and their differences (deltas) <ref> [22] </ref>. 7 Conclusions and Research Problems We have considered the incremental evaluation problem for Datalog queries. The main idea is to use the facts computed in one state to reduce the cost of computing the answer to the same query after the insertion of a bounded number of facts.
Reference: [23] <author> H. Jakobsson. </author> <title> On materializing views and on-line queries. </title> <booktitle> In Proc. Int. Conference on Database Theory, </booktitle> <volume> LNCS 646, </volume> <pages> pages 407-420. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 16, 17, 23, 24, 26] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> Incremental evaluation of arbitrary Datalog [15]. An algorithm is given in [15] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms <ref> [20, 19, 25, 23] </ref>. Graph algorithms for on-line evaluation of transitive closure of graphs are given in [20, 19], and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in [23]. <p> Graph algorithms [20, 19, 25, 23]. Graph algorithms for on-line evaluation of transitive closure of graphs are given in [20, 19], and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in <ref> [23] </ref>. The main difference is that they use more elaborate data structures and recursive algorithms, whereas we only use relations and nonrecursive Datalog programs. We now compare with some other optimization approaches which are not incremental. Partial evaluation in logic programming [26].
Reference: [24] <author> V. Kuchenhoff. </author> <title> On the efficient computation of the difference between consecutive database states. </title> <editor> In C. Delobel, M. Kifer, and Y. Masunaga, editors, </editor> <booktitle> Proc. Second Int. Conf. on Deductive Object-Oriented Databases, </booktitle> <volume> LNCS 566, </volume> <pages> pages 478-502. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 16, 17, 23, 24, 26] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> Our task is closely related to the problem of efficiently updating the standard model [2] of a definite or more generally stratified database <ref> [4, 24] </ref>. Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [26]. <p> Our approach, for query evaluation rather than for constraint checking, differs in storing previous derived relations and in transforming the programs used in query evaluation. Efficient maintenance of (stratified) databases <ref> [4, 24] </ref>. The goal of this approach is to efficiently compute the standard model of a stratified database after a database update. <p> Our approach differs by storing intermediate relations rather than reasons (or "supports") for including computed facts [4], by not using meta-programs to compute the difference between successive models <ref> [24] </ref>, and by transforming the programs used in query evaluation. Our approach is, however, more restricted as it does not allow negation in rules and queries. Incremental evaluation by counting [16].
Reference: [25] <author> J. La Poutre and J. van Leeuwen. </author> <title> Maintenance of transitive closures and transitive reductions of graphs. </title> <type> Technical Report RUU-CS-87-25, </type> <institution> Department of Computer Science, University of Utrecht, </institution> <address> The Netherlands, </address> <year> 1987. </year> <note> An extended abstract of this paper appeared in LNCS 314, pp. 106-120. </note>
Reference-contexts: Incremental evaluation of arbitrary Datalog [15]. An algorithm is given in [15] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms <ref> [20, 19, 25, 23] </ref>. Graph algorithms for on-line evaluation of transitive closure of graphs are given in [20, 19], and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in [23].
Reference: [26] <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial evaluation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 217-242, </pages> <year> 1991. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 16, 17, 23, 24, 26] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs <ref> [26] </ref>. Finally, when restricted to standard transitive closure programs, our task can be viewed as solving the incremental transitive closure computation problem for graphs [10, 14, 19, 20]. More detailed comparison will be given in Section 6. <p> The main difference is that they use more elaborate data structures and recursive algorithms, whereas we only use relations and nonrecursive Datalog programs. We now compare with some other optimization approaches which are not incremental. Partial evaluation in logic programming <ref> [26] </ref>. The idea of partial evaluation is to propagate given facts into programs so that subsequent queries involving those facts can be evaluated more efficiently. In this sense, this approach is also similar to ours, though it does not involve database updates or storage of derived relations.
Reference: [27] <author> J. W. Lloyd, E. A. Sonenberg, and R. W. Topor. </author> <title> Integrity constraint checking in stratified databases. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(4) </volume> <pages> 331-343, </pages> <year> 1987. </year>
Reference-contexts: We use first-order queries to compute the differences, and call this process "first-order incremental query evaluation." This optimization approach is analogous to the incremental checking of integrity constraint satisfaction by using (i) database updates and (ii) the fact that the integrity constraints were satisfied prior to the updates <ref> [9, 27, 28] </ref>. Our task is closely related to the problem of efficiently updating the standard model [2] of a definite or more generally stratified database [4, 24]. Our approach is very useful in maintaining materialized views upon updates. <p> Integrity constraint simplification <ref> [9, 27, 28] </ref>. The basic idea of integrity constraint simplification is to use an update to determine a simplified set of constraint instances that need to be checked after 23 the update.
Reference: [28] <author> J-M. Nicolas. </author> <title> Logic for improving integrity checking in relational data bases. </title> <journal> Acta Informatica, </journal> <volume> 18(3) </volume> <pages> 227-253, </pages> <year> 1982. </year>
Reference-contexts: We use first-order queries to compute the differences, and call this process "first-order incremental query evaluation." This optimization approach is analogous to the incremental checking of integrity constraint satisfaction by using (i) database updates and (ii) the fact that the integrity constraints were satisfied prior to the updates <ref> [9, 27, 28] </ref>. Our task is closely related to the problem of efficiently updating the standard model [2] of a definite or more generally stratified database [4, 24]. Our approach is very useful in maintaining materialized views upon updates. <p> Integrity constraint simplification <ref> [9, 27, 28] </ref>. The basic idea of integrity constraint simplification is to use an update to determine a simplified set of constraint instances that need to be checked after 23 the update.
Reference: [29] <author> X. Qian. </author> <title> On the expressive power of the bounded iteration construct. </title> <booktitle> In Proc. 2nd Int. Workshop on Database Programming Languages, </booktitle> <pages> pages 411-421, </pages> <year> 1989. </year>
Reference-contexts: Our work can be viewed as special cases of structural 24 induction where structural recursion is deterministic and one fact at a time, and uses first-order queries to compute the increment. Computing Datalog queries using FOIES is also related to the bounded iteration constructs <ref> [29] </ref> and the more general treatment of database states and their differences (deltas) [22]. 7 Conclusions and Research Problems We have considered the incremental evaluation problem for Datalog queries.
Reference: [30] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: The result (D) of applying a Datalog program to a set D of facts is the set of IDB facts in the 2 least (Herbrand) model for [ D or, equivalently, the set of IDB facts that are logical consequences of [ D <ref> [30] </ref>. The answer Q (D) to a query Q = (; p) on a database D is simply the set 4 of facts (D)j p .
Reference: [31] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge-base Systems, Vols I and II. 1989, </title> <publisher> Computer Science Press. </publisher>
Reference-contexts: Nonrecursive Datalog programs are effectively unions of conjunctive queries or first-order queries, which permit efficient computation methods <ref> [31] </ref> and are more suitable for parallel computation. For database applications, we believe that nonrecursive Datalog programs are much better than recursive graph algorithms using elaborate data structures even though the latter have lower sequential complexity. <p> Note that first-order or nonrecursive programs define unions of conjunctive database queries [11]. Such queries allow very efficient computations, and have received extensive attention in the literature <ref> [3, 31] </ref>. As we shall argue later, queries computable by FOIES's strictly generalize queries computable by nonrecursive programs. We assume familiarity with the relational databases and the Datalog language [31]. We assume the existence of three pairwise disjoint infinite sets of constants, variables, and predicates. <p> Such queries allow very efficient computations, and have received extensive attention in the literature [3, 31]. As we shall argue later, queries computable by FOIES's strictly generalize queries computable by nonrecursive programs. We assume familiarity with the relational databases and the Datalog language <ref> [31] </ref>. We assume the existence of three pairwise disjoint infinite sets of constants, variables, and predicates. Predicates are divided into extensional (or EDB) predicates and intensional (or IDB) predicates. Built-in predicates such as equality are disallowed. Each predicate has a positive arity. <p> A program is nonredundant if, for each rule r in , r is nonredundant and 6 frg. In <ref> [31] </ref> nonredundant rules (programs) are termed "minimal" rules (programs), and a detailed discussion and a method (based on containment substitution defined below) for obtaining minimal equivalent program of a nonrecursive program are given. <p> Again by Lemma 5.3 is redundant, a contradiction. 2 Since a nonredundant equivalent of a nonrecursive, single IDB-predicate program can be constructed <ref> [31] </ref>, we have the following: Corollary 5.6: It is decidable whether arbitrary nonrecursive, single IDB-predicate programs with binary IDB predicates (or unions of binary conjunctive queries) have CCI. 2 Although CCI for unions of conjunctive queries is decidable, it is also interesting to know, for a fixed k, if a nonrecursive
Reference: [32] <author> M. Vardi. </author> <title> Decidability and undecidability results for boundedness of linear recursive programs. </title> <booktitle> In Proc. of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 341-351, </pages> <year> 1988. </year> <month> 27 </month>
Reference-contexts: Combining this with Lemma 2.2, we see that FOIES's strictly generalizes bounded programs as a means of efficient query computation. Since it is undecidable whether an arbitrary Datalog program is predicate bounded [17] (even when the program has only one IDB predicate and has only binary IDB predicates <ref> [32] </ref>), Lemma 2.2 implies the following result: Theorem 2.3: It is undecidable for each arbitrary query (; p) whether there is an FOIES of the form h p ; fpg; ffi i. <p> Proposition 5.8: It is undecidable whether an arbitrary program has CCI with respect to a predicate. Proof: The proof is based on a reduction from the halting problem of Turing machines on empty inputs. The reduction is modified from the one used by Vardi et al <ref> [32, 18] </ref> in proving the undecidability of boundedness for binary Datalog programs. We briefly describe their reduction and the changes below. Let M be a Turing machine with one-way infinite tape, an alphabet , a set K of states, and a starting state s 2 K. <p> A constant c encodes a iff q a (c) is true. The predicates succ represents the adjacency relation and first the first symbol. Intuitively, succ "represents" a word over 0 [ f#g which possibly encodes a computation of M . In <ref> [32, 18] </ref>, it was shown that a Datalog program 0 with only one binary IDB predicate FING can be constructed such that when the input is not a proper encoding or is an encoded halting computation, then 0 "floods" FING, i.e., inserting every pair of constants into FING.
References-found: 32

