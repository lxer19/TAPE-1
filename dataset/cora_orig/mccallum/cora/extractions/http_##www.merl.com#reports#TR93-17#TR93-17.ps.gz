URL: http://www.merl.com/reports/TR93-17/TR93-17.ps.gz
Refering-URL: http://www.merl.com/reports/TR93-17/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: by  
Author: Richard C. Waters 
Address: Cambridge Massachusetts 02139  
Note: Submitted to ACM Lisp Pointers. 201  
Date: 93-17 August, 1993  
Affiliation: Mitsubishi Electric Research Laboratories  Broadway  
Pubnum: Technical Report  
Abstract: Chapter 1 "Using the New Common Lisp Pretty Printer" explains how the pretty printing facilities that have been adopted as part of the forthcoming Common Lisp standard can be used to gain detailed control over the printing of lists. As an example, it shows how the pretty printer can be used to print a subset of Lisp as Pascal. Chapter 2 "Macroexpand-All: An Example of a Simple Lisp Code Walker" presents a function macroexpand-all for expanding all the macro calls in a Lisp expression. This is useful when debugging macros and can be helpful as a subroutine when writing complex macros. In addition, the chapter serves as an introduction to code walkers|the general class of programs of which macroexpand-all is an example. Code walkers are important because they are a vital part of the foundation of many Lisp programming tools and macro packages. Chapter 3 "To NReverse When Consing a List or By Pointer Manipulation, To Avoid It; That Is the Question" discusses a question that Lisp programmers have argued about for decades. When creating an ordered list of elements it is often convenient to push the items onto the list one at a time and then call nreverse to put resulting list in the correct order. By writing more complex code, you can enter the elements in the list in the correct order in the first place. It seems that this latter approach should be better since it avoids calling nreverse, but is it? 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Goldstein I., </author> <title> "Pretty Printing, Converting List to Linear Structure", </title> <address> MIT/AIM-279, </address> <month> February </month> <year> 1973. </year>
Reference-contexts: All rights reserved. Lisp Algorithms 1 1. Using the New Common Lisp Pretty Printer Richard C. Waters Although not part of the initial definition of the language, pretty printing has been an important feature of Lisp programming environments for twenty years or more <ref> [1] </ref>. By the time Common Lisp was being defined, the importance of pretty printing was clear enough that pretty printing was made a formal part of the language [2].
Reference: [2] <author> Steele G.L.Jr., </author> <title> Common Lisp: the Language, </title> <publisher> Digital Press, </publisher> <address> Maynard MA, </address> <year> 1984. </year>
Reference-contexts: By the time Common Lisp was being defined, the importance of pretty printing was clear enough that pretty printing was made a formal part of the language <ref> [2] </ref>. However, little was done beyond recognizing the least common denominator of the pretty printing facilities available at the time|[2] specifies how pretty printing can be turned on and off, but says very little else.
Reference: [3] <author> R.C. Waters, </author> <title> "The Programmer's Apprentice: A Session With KBEmacs", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(11) </volume> <pages> 1296-1320, </pages> <month> November </month> <year> 1985. </year>
Reference-contexts: However, it is worthy of note that the system is not totally contrived. A similar system was used as part of the Knowledge-Based Editor in Emacs <ref> [3] </ref> to display a Lisp-like internal representation as Ada code. Figures 1-4 contain definitions that cause 2 R.C.
Reference: [4] <author> Waters R.C., </author> <title> XP: A Common Lisp Pretty Printing System, </title> <institution> MIT AI Laboratory technical memo MIT/AIM-1102a, </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: In particular, no provision was made for allowing the user to control what the pretty printer does. Since the late 1970s, efficient pretty printers that allow extensive user control over the format of the output produced have been a particular interest of mine. In 1989, my pretty printer <ref> [4] </ref> was adopted as part of the proposed Common Lisp standard [5]. This adds a number of very useful facilities to Common Lisp, however, some study and experimentation on the part of the user is required to make the best use of these facilities. <p> As discussed at length in <ref> [4, 5] </ref>, logical blocks are a central feature of the pretty printing algorithm. Each logical block is printed on a single line if possible. However, if this is not possible, a block is broken across multiple lines as specified by the conditional newlines within it and appropriate indentation is inserted.

Reference: [1] <author> Curtis, P., </author> <title> "Algorithms", </title> <journal> ACM Lisp Pointers, </journal> <volume> 3(1) </volume> <pages> 48-61, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: All rights reserved. Lisp Algorithms 1 1. Using the New Common Lisp Pretty Printer Richard C. Waters Although not part of the initial definition of the language, pretty printing has been an important feature of Lisp programming environments for twenty years or more <ref> [1] </ref>. By the time Common Lisp was being defined, the importance of pretty printing was clear enough that pretty printing was made a formal part of the language [2].
Reference: [2] <author> Pitman, K.M., </author> <title> "Special Forms in Lisp", </title> <booktitle> in Proc. 1980 Lisp Conference, </booktitle> <pages> 179-187, </pages> <month> August </month> <year> 1980. </year>
Reference-contexts: By the time Common Lisp was being defined, the importance of pretty printing was clear enough that pretty printing was made a formal part of the language <ref> [2] </ref>. However, little was done beyond recognizing the least common denominator of the pretty printing facilities available at the time|[2] specifies how pretty printing can be turned on and off, but says very little else.
Reference: [3] <author> Steele G.L.Jr., </author> <title> Common Lisp: the Language, </title> <publisher> Digital Press, </publisher> <address> Maynard MA, </address> <year> 1984. </year>
Reference-contexts: However, it is worthy of note that the system is not totally contrived. A similar system was used as part of the Knowledge-Based Editor in Emacs <ref> [3] </ref> to display a Lisp-like internal representation as Ada code. Figures 1-4 contain definitions that cause 2 R.C.

References-found: 7

