URL: http://www.cs.uoregon.edu/research/paracomp/proj/confluence/related/darwin.ps
Refering-URL: http://www.cs.uoregon.edu/research/paracomp/proj/confluence/index.html
Root-URL: http://www.cs.uoregon.edu
Email: jk@doc.ic.ac.uk  
Title: Specifying Distributed Software Architectures  
Author: Jeff Magee, Naranker Dulay, Susan Eisenbach and Jeff Kramer 
Address: London SW7 2BZ, United Kingdom jnm, nd, se,  
Affiliation: Department of Computing Imperial College  
Abstract: There is a real need for clear and sound design specifications of distributed systems at the architectural level. This is the level of the design which deals with the high-level organisation of computational elements and the interactions between those elements. The paper presents the Darwin notation for specifying this high-level organisation. Darwin is in essence a declarative binding language which can be used to define hierarchic compositions of interconnected components. Distribution is dealt with orthogonally to system structuring. The language supports the specification of both static structures and dynamic structures which may evolve during execution. The central abstractions managed by Darwin are components and services. Services are the means by which components interact. In addition to its use in specifying the architecture of a distributed system, Darwin has an operational semantics for the elaboration of specifications such that they may be used at runtime to direct the construction of the desired system. The paper describes the operational semantics of Darwin in terms of the -calculus, Milner's calculus of mobile processes. The correspondence between the treatment of names in the -calculus and the management of services in Darwin leads to an elegant and concise -calculus model of Darwin's operational semantics. The model is used to argue the correctness of the Darwin elaboration process. The overall objective is to provide a soundly based notation for specifying and constructing distributed software architectures. This paper will appear in the Fifth European Software Engineering Conference, ESEC '95 on 26 September 1995 in Barcelona. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> D. Garlan and M Shaw, </author> <title> An Introduction to Software Architecture, </title> <booktitle> in Advances in Software Engineering and Knowledge Engineering, </booktitle> <volume> Vol. 1, </volume> <editor> ed. Ambriola and Tortora, </editor> <publisher> World Scientific Publishing Co., </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction It has been recently recognised within the Software Engineering community, most notably by Garlan and Shaw <ref> [1] </ref> and Perry and Wolf [2], that when systems are constructed from many components, the organisation or architecture of the overall system presents a new set of design problems.
Reference: 2. <author> D.E. Perry and A.L. Wolf, </author> <title> Foundations for the study of Software Architectures, </title> <booktitle> ACM SIGSOFT, Software Engineering Notes, </booktitle> <volume> 17 (4), </volume> <year> 1992, </year> <pages> pp 40-52. </pages>
Reference-contexts: 1 Introduction It has been recently recognised within the Software Engineering community, most notably by Garlan and Shaw [1] and Perry and Wolf <ref> [2] </ref>, that when systems are constructed from many components, the organisation or architecture of the overall system presents a new set of design problems. One of the architectural concerns identified by Garlan and Perry [3] is the high-level description of systems based on graphs of interacting components.
Reference: 3. <author> D. Garlan and D. Perry, </author> <title> Software Architecture: Practice, Potential and Pitfalls (Panel Introduction), </title> <booktitle> Proc. of 16th Intl. Conf. on Software Engineering, </booktitle> <address> S orrento, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: One of the architectural concerns identified by Garlan and Perry <ref> [3] </ref> is the high-level description of systems based on graphs of interacting components. They identify components as the primary points of computation in a system and connectors to define the interactions between these components.
Reference: 4. <author> J. Magee, J. Kramer, and M. Sloman, </author> <title> Constructing Distributed Systems in Conic, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-15 (6), </volume> <year> 1989. </year>
Reference-contexts: We are concerned with the provision of sound and practical means for the design and construction of distributed systems. To this end we have been involved in the development and use of structural configuration languages <ref> [4, 5, 6] </ref> as a means of specifying and subsequently managing system structure. The languages we have developed have in common the notion of a component as the basic element from which systems are constructed. <p> Distributed programs can be constructed directly from their Darwin specifications. Darwin thus has an operational interpretation such that elaboration at runtime of the Darwin specification results in a distributed set of interconnected primitive components. In contrast with its predecessors, Conic <ref> [4] </ref> and Rex [5] which had centralised sequential interpretations, Darwin has a distributed and concurrent interpretation permitting the construction of large distributed systems in an efficient manner. In addition, it allows physical distribution to be specified completely orthogonally to logical structure.
Reference: 5. <author> J. Kramer, J. Magee, M. Sloman and N. Dulay, </author> <title> Configuring Object-Based Distributed Programs in Rex, </title> <journal> IEE Software Engineering Journal, </journal> <volume> Vol. 7, 2, </volume> <month> March </month> <year> 1992, </year> <month> pp139-149. </month>
Reference-contexts: We are concerned with the provision of sound and practical means for the design and construction of distributed systems. To this end we have been involved in the development and use of structural configuration languages <ref> [4, 5, 6] </ref> as a means of specifying and subsequently managing system structure. The languages we have developed have in common the notion of a component as the basic element from which systems are constructed. <p> Darwin allows the specification of both static structures fixed during system initialisation and dynamic structures which evolve as execution progresses. An earlier version of Darwin was used in conjunction with the Rex distributed systems platform <ref> [5] </ref>. The version described here differs in its treatment of dynamic structures and in the ability to deal with diverse interaction mechanisms. Distributed programs can be constructed directly from their Darwin specifications. <p> Distributed programs can be constructed directly from their Darwin specifications. Darwin thus has an operational interpretation such that elaboration at runtime of the Darwin specification results in a distributed set of interconnected primitive components. In contrast with its predecessors, Conic [4] and Rex <ref> [5] </ref> which had centralised sequential interpretations, Darwin has a distributed and concurrent interpretation permitting the construction of large distributed systems in an efficient manner. In addition, it allows physical distribution to be specified completely orthogonally to logical structure.
Reference: 6. <author> J. Magee, N. Dulay and J. Kramer, </author> <title> Structuring Parallel and Distributed Programs, </title> <journal> IEE Software Engineering Journal, </journal> <volume> Vol. 8, No. 2, </volume> <month> March </month> <year> 1993, </year> <month> pp73-82. </month>
Reference-contexts: We are concerned with the provision of sound and practical means for the design and construction of distributed systems. To this end we have been involved in the development and use of structural configuration languages <ref> [4, 5, 6] </ref> as a means of specifying and subsequently managing system structure. The languages we have developed have in common the notion of a component as the basic element from which systems are constructed.
Reference: 7. <author> J.M. Purtilo, </author> <title> The POLYLITH Software Bus, </title> <journal> ACM Transactions on Programming Languages, </journal> <volume> 16(1), </volume> <month> January </month> <year> 1994, </year> <pages> pp 151-174. </pages>
Reference-contexts: These primitive components have a behavioural specification as opposed to a structural description. Others that have also adopted a similar use of configuration languages for distributed systems include Polylith <ref> [7] </ref>, Durra [8] and Leap [9]. The version of Darwin used in this paper is the latest in a line of configuration languages.
Reference: 8. <author> M. Barbacci, C. Weinstock, D. Doubleday, M. Gardner and R. Lichota, Durra: </author> <title> a structure description language for developing distributed applications, </title> <journal> IEE Software Engineering Journal, </journal> <volume> Vol. 8, No. 2, </volume> <month> March </month> <year> 1993, </year> <month> pp83-94. </month>
Reference-contexts: These primitive components have a behavioural specification as opposed to a structural description. Others that have also adopted a similar use of configuration languages for distributed systems include Polylith [7], Durra <ref> [8] </ref> and Leap [9]. The version of Darwin used in this paper is the latest in a line of configuration languages. Darwin is a declarative language which is intended to be a general purpose notation for specifying the structure of systems composed from diverse components using diverse interaction mechanisms.
Reference: 9. <author> H. Graves, </author> <title> Lockheed Environment for Automatic Programming, </title> <booktitle> Proc. of KBSE 91, 6th IEEE Knowledge Based Software Engineering Conference, </booktitle> <year> 1991, </year> <pages> pp 68-76. </pages>
Reference-contexts: These primitive components have a behavioural specification as opposed to a structural description. Others that have also adopted a similar use of configuration languages for distributed systems include Polylith [7], Durra [8] and Leap <ref> [9] </ref>. The version of Darwin used in this paper is the latest in a line of configuration languages. Darwin is a declarative language which is intended to be a general purpose notation for specifying the structure of systems composed from diverse components using diverse interaction mechanisms.
Reference: 10. <author> J.Magee, N. Dulay and J. Kramer, Regis: </author> <title> A Constructive Development Environment for Distributed Programs, </title> <journal> Distributed Systems Engineering Journal, </journal> <note> to appear. </note>
Reference-contexts: Darwin is a declarative language which is intended to be a general purpose notation for specifying the structure of systems composed from diverse components using diverse interaction mechanisms. It is currently being used in the context of the Regis system <ref> [10] </ref> which supports multiple interaction primitives and in the Sysman project [11] with Ansaware [12] which uses remote object invocation for component interaction. Darwin allows the specification of both static structures fixed during system initialisation and dynamic structures which evolve as execution progresses. <p> The type of the service is specified in angle brackets. In the example, the communication mechanism used to implement the service is a stream and the datatype communicated is char. Darwin does not interpret service type information, it is used by the underlying distributed platform. In the Regis system <ref> [10] </ref>, this information is used to directly select the correct communication 2 code. <p> The integer machine identifiers are mapped to real machine addresses by the runtime system for Darwin. This level of indirection in mapping permits portable specifications. In general, instances are located at the machine on which the enclosing component is elaborated unless they are annotated. The reader is referred to <ref> [10] </ref> for further (and more realistic) 4 examples of Darwin configuration programs. The -calculus [13] is an elementary calculus for describing and analysing concurrent systems with evolving communication structure. In this paper, we use the simple monadic form. <p> It is consequently not surprising that Darwin, a language primarily concerned with reference and binding, can be elegantly modelled in the -calculus. Finally, we would like to emphasise that, together with others, we have accumulated extensive experience in using Darwin for constructing distributed systems <ref> [10, 11] </ref>. We are therefore confident in proposing Darwin as both a practical and sound means for specifying and manipulating the software architecture 16 of distributed systems. The authors would like to acknowledge discussions with our colleagues in the Distributed Software Engineering Section Group during the formulation of these ideas.
Reference: 11. <author> S. Crane, N. Dulay, H. Foss-a, J. Kramer, J. Magee, M. Sloman and K. Twidle, </author> <title> Configuration Management for Distributed Systems, </title> <note> to be presented at ISINM 95. </note>
Reference-contexts: It is currently being used in the context of the Regis system [10] which supports multiple interaction primitives and in the Sysman project <ref> [11] </ref> with Ansaware [12] which uses remote object invocation for component interaction. Darwin allows the specification of both static structures fixed during system initialisation and dynamic structures which evolve as execution progresses. An earlier version of Darwin was used in conjunction with the Rex distributed systems platform [5]. <p> In addition, it allows physical distribution to be specified completely orthogonally to logical structure. Darwin allows interaction with external management agents <ref> [11] </ref> which can direct structural changes in 1 response to changing system requirements whether operational or evolutionary. The aim that Darwin be general purpose requires that there should be a clear and well specified division of responsibilities between Darwin and the primitive components it configures. <p> It is consequently not surprising that Darwin, a language primarily concerned with reference and binding, can be elegantly modelled in the -calculus. Finally, we would like to emphasise that, together with others, we have accumulated extensive experience in using Darwin for constructing distributed systems <ref> [10, 11] </ref>. We are therefore confident in proposing Darwin as both a practical and sound means for specifying and manipulating the software architecture 16 of distributed systems. The authors would like to acknowledge discussions with our colleagues in the Distributed Software Engineering Section Group during the formulation of these ideas.
Reference: 12. <author> Ansaware 4.1: </author> <title> Application Programming in Ansaware, Document RM.102.02, Architecture Projects Management Agency, </title> <publisher> Poseidon House, </publisher> <address> Cambridge Feb. </address> <year> 1993. </year>
Reference-contexts: It is currently being used in the context of the Regis system [10] which supports multiple interaction primitives and in the Sysman project [11] with Ansaware <ref> [12] </ref> which uses remote object invocation for component interaction. Darwin allows the specification of both static structures fixed during system initialisation and dynamic structures which evolve as execution progresses. An earlier version of Darwin was used in conjunction with the Rex distributed systems platform [5].
Reference: 13. <author> R.Milner, J. Parrow, and D.Walker, </author> <title> A calculus of mobile processes, Parts I and II, </title> <journal> Journal of Information and Computation, </journal> <volume> Vol. 100, </volume> <pages> pp 1-40 and pp 41-77, </pages> <year> 1992. </year>
Reference-contexts: The requirement that Darwin should be capable of concurrent elaboration demands that the re must be a clear and unambiguous model of Darwin's operational behaviour against which implementations can be validated. We have attempted to satisfy both these requirements by modelling Darwin in the -calculus <ref> [13] </ref>, Robin Milner's calculus of mobile processes. The reasons for choosing this formalism are discussed in the concluding sections of the paper. The paper initially describes the basic features of Darwin and outlines how these are modelled in the -calculus. <p> This level of indirection in mapping permits portable specifications. In general, instances are located at the machine on which the enclosing component is elaborated unless they are annotated. The reader is referred to [10] for further (and more realistic) 4 examples of Darwin configuration programs. The -calculus <ref> [13] </ref> is an elementary calculus for describing and analysing concurrent systems with evolving communication structure. In this paper, we use the simple monadic form. A system in the -calculus is a collection of independent processes which communicate via channels. Channels or links are referred to by name.
Reference: 14. <author> K. Ng, J. Kramer, J. Magee and N. Dulay, </author> <title> The Software Architect's Assistant A Visual Environment for Distributed Programming, </title> <address> HICSS-28, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: Similarly services provided internally which are required outside are bound to an interface service provision e.g. output -- F [n 1]:output. The Darwin design <ref> [14] </ref> and construction tools check that 3 component pipeline (int n)f provide output; require input; array F [n]: filter; forall k:0..n-1 f inst F [k] @ k+1; when k &lt; n-1; bind F [k+1].input -- F [k].output; g bind F [0].input -- input; output -- F [n-1].output; g Fig. 2. composite
Reference: 15. <author> R. Milner, </author> <title> The polyadic -calculus: a tutorial, in Logic and Algebra of Specification, </title> <editor> ed. F.L. Bauer, W. Brauer and H. Schwichttenberg, </editor> <publisher> Springer Verlag, </publisher> <year> 1993, </year> <month> pp203-246. </month>
Reference-contexts: Darwin supports static checking to ensure only bindings between compatible requirements and provisions are allowed. Service types can be modelled using the concepts of sort and sorting provided by the polyadic -calculus <ref> [15] </ref>, but unavailable in the simple monadic form of the -calculus used in this paper. For simplicity, in the following, the types of Darwin services and type discipline for binding are omitted.
Reference: 16. <author> S. Eisenbach and R. Paterson, </author> <title> -Calculus Semantics for the Concurrent Configuration Language Darwin, </title> <address> HICSS-26, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: The opposite is necessary in case (b) and (c), where the interface require must act like a Prov agent internally and a Req agent externally <ref> [16] </ref>.
Reference: 17. <author> A. Harter and A. Hopper, </author> <title> A Distributed Location System for the Active Office, </title> <journal> IEEE Network, </journal> <volume> Jan./Feb. </volume> <year> 1994, </year> <pages> pp. 62-70. </pages>
Reference-contexts: Figure 9 is an example of a component which creates new poller components in response to the requests of an external manager. The example comes from a distributed system which monitors the location of Active Badges <ref> [17] </ref>. Active Badges emit infrared signals which are picked up by sensors distributed around a building. Each poller component monitors a string of sensors.
Reference: 18. <author> R. Allan and D. Garlan, </author> <title> Formalizing Architectural Connection, </title> <booktitle> Proc. of 16th International Conference on Software Engineering, </booktitle> <address> Sorrento, </address> <month> May </month> <year> 1994. </year> <month> 17 </month>
Reference-contexts: Components may be sequential, concurrent or distributed. They are only required to supply the names or references of services and accept bindings. The -calculus description of Darwin clearly illustrates this separation between architecture and computation/communication in systems constructed using Darwin. Unlike Allan and Garlan <ref> [18] </ref>, we do not make any assumptions about the way instantiated primitive components interact. We have deliberately not considered in any detail the modelling of component interaction mechanisms. However, some of the communication mechanisms supported by the Regis system have been modelled in detail in the -calculus [19].
Reference: 19. <author> M. Radestock and S. Eisenbach, </author> <title> What Do You Get From a -calculus Semantics?, </title> <booktitle> PARLE 94, </booktitle> <publisher> Springer-Verlag, LNCS No. </publisher> <address> 817, pp635-647, </address> <year> 1994. </year>
Reference-contexts: We have deliberately not considered in any detail the modelling of component interaction mechanisms. However, some of the communication mechanisms supported by the Regis system have been modelled in detail in the -calculus <ref> [19] </ref>. These interaction models do not impact the configuration of Darwin programs but rather their runtime behaviour. We can thus modularise our reasoning about Darwin/Regis programs or indeed any distributed system using Darwin for configuration support. Section 3 described a general model of the elaboration of Darwin programs.
Reference: 20. <author> G. Abowd, R. Allen and D. Garlan, </author> <title> Using style to give meaning to software architecture, </title> <booktitle> In Proceedings of the SIGSOFT'93: Foundations of Software Engineering, Software Engineering Notes 118(3), </booktitle> <address> pp.9-20, </address> <publisher> ACM Press, </publisher> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Work is currently in progress to provide open systems binding, the ability to manage group communication abstractions and component migration. We are also extending the definition of the Darwin language together with its -calculus semantics to capture the notion of architectural styles <ref> [20] </ref>. We have chosen to ignore component parameterisation in arriving at the -calculus model. Component parameters can determine the final structure of a system through the conditional and replicator constructs.
Reference: 21. <author> M.D. Rice and S.B. Seidman, </author> <title> A Formal Model for Module Interconnection Languages, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20 (1), </volume> <year> 1994, </year> <pages> 88-101. </pages>
Reference-contexts: One of the major benefits of using the -calculus to model Darwin has been our increased understanding of the role and nature of configuration languages. Rice and Seidman <ref> [21] </ref> chose to use the Z specification language [22] as a means for modelling component instantiation, interconnection, and hierarchical composition for configuration languages such as Conic. We felt that the process algebras might be more appropriate to model component interaction and elaboration.
Reference: 22. <author> J.M. Spivey, </author> <title> The Z Notation, a Reference Manual, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1989. </year>
Reference-contexts: One of the major benefits of using the -calculus to model Darwin has been our increased understanding of the role and nature of configuration languages. Rice and Seidman [21] chose to use the Z specification language <ref> [22] </ref> as a means for modelling component instantiation, interconnection, and hierarchical composition for configuration languages such as Conic. We felt that the process algebras might be more appropriate to model component interaction and elaboration.
Reference: 23. <author> R. Milner, </author> <title> Communication and Concurrency, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1989. </year>
Reference-contexts: We felt that the process algebras might be more appropriate to model component interaction and elaboration. Initially, we attempted to define the semantics of Conic using the CCS <ref> [23] </ref> and CSP [24] formalisms. While it was possible to reason about the behaviour of the set of communicating processes resulting from the elaboration of a configuration program, we were unable to develop a satisfactory model for the elaboration process itself.
Reference: 24. <author> C.A.R. Hoare, </author> <title> Communicating sequential processes, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1985. </year>
Reference-contexts: We felt that the process algebras might be more appropriate to model component interaction and elaboration. Initially, we attempted to define the semantics of Conic using the CCS [23] and CSP <ref> [24] </ref> formalisms. While it was possible to reason about the behaviour of the set of communicating processes resulting from the elaboration of a configuration program, we were unable to develop a satisfactory model for the elaboration process itself.
Reference: 25. <author> R. Milner, </author> <title> Elements of Interaction - Turing Award Lecture, </title> <journal> CACM, </journal> <volume> Vol 36, No. 1, </volume> <month> January </month> <year> 1993, </year> <title> pp78-79. This article was processed using the L A T E X macro package with LLNCS style 18 </title>
Reference-contexts: The requirement that Darwin be a general purpose configuration language led us to develop a more general model for binding which involved the management of service references. The requirement that the elaboration process be distributed meant that these service references must be freely transmitted between processes in messages. Milner <ref> [25] </ref> stresses the fundamental importance of naming or reference in concurrent computation and considers the -calculus as the beginnings of a tractable theory for reference. It is consequently not surprising that Darwin, a language primarily concerned with reference and binding, can be elegantly modelled in the -calculus.
References-found: 25

