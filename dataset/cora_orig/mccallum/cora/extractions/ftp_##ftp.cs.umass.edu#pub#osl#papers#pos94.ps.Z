URL: ftp://ftp.cs.umass.edu/pub/osl/papers/pos94.ps.Z
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Title: Expressing Object Residency Optimizations Using Pointer Type Annotations  
Author: J. Eliot B. Moss and Antony L. Hosking 
Date: 5-9 September 1994  
Note: Sixth International Workshop on Persistent Object Systems Tarascon, Provence, France,  
Address: Amherst, MA 01003, USA  
Affiliation: Object Systems Laboratory, Department of Computer Science University of Massachusetts;  
Abstract: We consider some issues in optimizing persistent programming languages. In particular, we show how to express optimizations of object residency checks in strongly typed persistent languages as annotations on pointer types. These annotations essentially extend and refine the type system of the language, and they have at least two significant uses. First, a programmer can use them to express desired residency properties to be enforced by the language implementation (compiler plus run time). Second, we can use them to separate a persistence optimizer, which adds annotations, from the remainder of the compiler, which simply obeys them. This gives rise to a nice separation of concerns in supporting high-performance persistence: the intelligent optimizer can be factored off from the rest of the compiler. In addition to modularity benefits, the separation allows us to explore the value of various optimizations without actually implementing them in the optimizer. Rather, we can optimize programs by hand and compare optimized and unoptimized code to develop sound data to use when deciding whether to implement an optimization. While the approach is similar to source-to-source optimizers, which are by no means a new idea, in our case the target language is an extension of the source language, and one specifically designed to be easier to compile well. We are applying the approach in our ongoing implementation of Persistent Modula-3. We present the type annotation approach in the context of Modula-3, but it should be applicable to any strongly typed persistent programming language, as well as to a range of other kinds of optimizations.
Abstract-found: 1
Intro-found: 1
Reference: [ACC82] <author> Malcolm Atkinson, Ken Chisolm, and Paul Cockshott. </author> <title> PS-Algol: an Algol with a persistent heap. </title> <journal> ACM SIGPLAN Not., </journal> <volume> 17(7) </volume> <pages> 24-31, </pages> <month> July </month> <year> 1982. </year>
Reference: [BBB + 88] <author> Francois Bancilhon, Gilles Barbedette, Veronique Benzaken, Claude Delobel, Sophie Gamerman, Cristophe Lecluse, Patrick Pfeffer, Philippe Richard, and Fernando Velez. </author> <title> The design and implementation of O 2 , an object-oriented database system. </title> <booktitle> In Dittrich [Dit88], </booktitle> <pages> pages 1-22. </pages>
Reference: [BC86] <author> A. L. Brown and W. P. Cockshott. </author> <title> The CPOMS persistent object management system. Technical Report Persistent Programming Research Project 13, </title> <institution> University of St. </institution> <address> Andrews, Scotland, </address> <year> 1986. </year>
Reference: [BHJ + 87] <author> A. Black, N. Hutchinson, E. Jul, H. Levy, and L. Carter. </author> <title> Distribution and abstract types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(1) </volume> <pages> 65-76, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Similar annotation techniques have been used in distributed programming languages to distinguish local versus remote, and so forth <ref> [BHJ + 87] </ref>. Perhaps we can take credit for a slightly new application of old ideas.
Reference: [CDG + 88] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <type> Modula-3 report. Technical Report ORC-1, </type> <institution> DEC Systems Research Center/Olivetti Research Center, </institution> <address> Palo Alto/Menlo Park, CA, </address> <year> 1988. </year>
Reference-contexts: Most of the optimizations we have thought of require reasonably powerful data flow analysis and code transformations, such as hoisting or combining residency checks, or imposing special rules that complicate the compiler such as: the first argument of 1 For further information on Modula-3 see <ref> [CDG + 88, CDG + 89, CDG + 91, Nel91, Har92] </ref>; for further information on our persistence work see [MS88, Mos89, Mos87, Mos90, HMB90, HM90, HM91, Hos91, Mos92, HM93a, HBM93, HM93b]. a method call (i.e., the target object) will (somehow) automatically be made resident throughout the execution of the method (so
Reference: [CDG + 89] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <note> Modula-3 report (revised). Technical Report DEC SRC 52, </note> <institution> DEC Systems Research Center/Olivetti Research Center, </institution> <address> Palo Alto/Menlo Park, CA, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: Most of the optimizations we have thought of require reasonably powerful data flow analysis and code transformations, such as hoisting or combining residency checks, or imposing special rules that complicate the compiler such as: the first argument of 1 For further information on Modula-3 see <ref> [CDG + 88, CDG + 89, CDG + 91, Nel91, Har92] </ref>; for further information on our persistence work see [MS88, Mos89, Mos87, Mos90, HMB90, HM90, HM91, Hos91, Mos92, HM93a, HBM93, HM93b]. a method call (i.e., the target object) will (somehow) automatically be made resident throughout the execution of the method (so
Reference: [CDG + 91] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <title> Modula-3 language definition. </title> <editor> In Nelson [Nel91], </editor> <volume> chapter 2, </volume> <pages> pages 11-66. </pages>
Reference-contexts: Most of the optimizations we have thought of require reasonably powerful data flow analysis and code transformations, such as hoisting or combining residency checks, or imposing special rules that complicate the compiler such as: the first argument of 1 For further information on Modula-3 see <ref> [CDG + 88, CDG + 89, CDG + 91, Nel91, Har92] </ref>; for further information on our persistence work see [MS88, Mos89, Mos87, Mos90, HMB90, HM90, HM91, Hos91, Mos92, HM93a, HBM93, HM93b]. a method call (i.e., the target object) will (somehow) automatically be made resident throughout the execution of the method (so
Reference: [CM84] <author> George Copeland and David Maier. </author> <title> Making Smalltalk a database system. </title> <booktitle> In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 316-325, </pages> <address> Boston, Massachusetts, </address> <month> June </month> <year> 1984. </year> <booktitle> ACM SIGMOD Rec. </booktitle> <volume> 14, </volume> <month> 2 </month> <year> (1984). </year>
Reference: [Dit88] <editor> K. R. Dittrich, editor. </editor> <booktitle> Proceedings of the Second International Workshop on Object-Oriented Database Systems, volume 334 of Lecture Notes in Computer Science, </booktitle> <address> Bad Munster am Stein-Ebernburg, Federal Republic of Germany, </address> <month> September </month> <year> 1988. </year> <title> Advances in Object-Oriented Database Systems, </title> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference: [Diw91] <author> Amer Diwan. </author> <title> Stack tracing in a statically typed language, </title> <month> October </month> <year> 1991. </year> <title> Position paper for OOPSLA '91 Workshop on Garbage Collection. </title>
Reference-contexts: is likely always to be profitableits only negative effect is pinning objects longer (and requiring support for such pinning, which may in turn require compiler produced tables for the run time system to use in determining which objects are pinned (along the lines of compiler support for accurate garbage collection <ref> [DMH92, Diw91, HMDW91] </ref>)). Similarly, target object residency is probably almost always a good idea: it would be rare for the target of a message not to be used and for the method to be statically known.
Reference: [DMH92] <author> Amer Diwan, J. Eliot B. Moss, and Richard L. Hudson. </author> <title> Compiler support for garbage collection in a statically typed language. </title> <booktitle> In Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 273-282, </pages> <address> San Francisco, California, </address> <month> June </month> <year> 1992. </year> <title> SIGPLAN, </title> <publisher> ACM Press. </publisher>
Reference-contexts: is likely always to be profitableits only negative effect is pinning objects longer (and requiring support for such pinning, which may in turn require compiler produced tables for the run time system to use in determining which objects are pinned (along the lines of compiler support for accurate garbage collection <ref> [DMH92, Diw91, HMDW91] </ref>)). Similarly, target object residency is probably almost always a good idea: it would be rare for the target of a message not to be used and for the method to be statically known.
Reference: [DSZ90] <editor> Alan Dearle, Gail M. Shaw, and Stanley B. Zdonik, editors. </editor> <booktitle> Proceedings of the Fourth International Workshop on Persistent Object Systems, </booktitle> <address> Martha's Vineyard, Massachusetts, </address> <month> September </month> <year> 1990. </year> <title> Published as Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Here we are most concerned with types, procedure calls, and method calls in Modula-3, and assume the reader can grasp other constructs intuitively from a knowledge of Pascal or Modula-2. Unlike some object oriented languages (e.g., Smalltalk <ref> [GR83] </ref> and Trellis/Owl [SCB + 86]), Modula-3 is not uniformly object oriented: it has a full collection of non-object primitive types (INTEGER, REAL, range, enumeration, etc.) and type constructors (RECORD, ARRAY, REF, PROC, etc.) in addition to object types.
Reference: [Har92] <author> S. P. Harbison. </author> <title> Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1992. </year>
Reference-contexts: Most of the optimizations we have thought of require reasonably powerful data flow analysis and code transformations, such as hoisting or combining residency checks, or imposing special rules that complicate the compiler such as: the first argument of 1 For further information on Modula-3 see <ref> [CDG + 88, CDG + 89, CDG + 91, Nel91, Har92] </ref>; for further information on our persistence work see [MS88, Mos89, Mos87, Mos90, HMB90, HM90, HM91, Hos91, Mos92, HM93a, HBM93, HM93b]. a method call (i.e., the target object) will (somehow) automatically be made resident throughout the execution of the method (so
Reference: [HBM93] <author> Antony L. Hosking, Eric Brown, and J. Eliot B. Moss. </author> <title> Update logging for persistent programming languages: A comparative performance evaluation. </title> <booktitle> In Proceedings of the Nineteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 429-440, </pages> <address> Dublin, Ireland, August 1993. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: However, we have gathered evidence that such totally transparent schemes do not always offer the best performance <ref> [HM93a, HM93b, HBM93, HMS92] </ref>. Hence we will be most interested in schemes that have more than one representation. We list below a range of possible representations. Any given scheme may combine a number of them, though not all subsets make a lot of sense.
Reference: [HM90] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Towards compile-time optimisations for persistence. </title> <editor> In Dearle et al. </editor> <booktitle> [DSZ90], </booktitle> <pages> pages 17-27. </pages>
Reference-contexts: 1 Introduction and Motivation We have been developing run time support and an optimizing compiler for Persistent Modula-3 1 for some time. In the process we have conceived of a number of optimizations one might consider to improve performance of persistent programs <ref> [HM90, HM91] </ref>, and have compared several approaches to dealing with (among other things) object faults (attempts to use persistent objects that are not currently resident (i.e., not actually in the process's virtual address space)), in our Persistent Smalltalk implementation [HM93a, HM93b]. <p> The language's (sub)type checking rules allow scale point as an implementation of scale in this case. Here is an example of a method call: p: point := ...; p.scale (2.5); Thus far we have described non-persistent Modula-3. To add persistence to Modula-3, we changed very little <ref> [HM90] </ref>: we re-interpreted REF t to mean a reference to a (possibly) persistent instance of t, and likewise for object types. <p> They are useful on occasion, e.g., for allocating fixed I/O buffers and the like. In <ref> [HM90] </ref> we added TRANSIENT REF t. By analogy with untraced types, transient pointer types refer to instances that can never become persistent.
Reference: [HM91] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Compiler support for persistent programming. </title> <type> COINS Technical Report 91-25, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: 1 Introduction and Motivation We have been developing run time support and an optimizing compiler for Persistent Modula-3 1 for some time. In the process we have conceived of a number of optimizations one might consider to improve performance of persistent programs <ref> [HM90, HM91] </ref>, and have compared several approaches to dealing with (among other things) object faults (attempts to use persistent objects that are not currently resident (i.e., not actually in the process's virtual address space)), in our Persistent Smalltalk implementation [HM93a, HM93b].
Reference: [HM93a] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Object fault handling for persistent programming languages: A performance evaluation. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 288-303, </pages> <address> Washington, DC, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: of optimizations one might consider to improve performance of persistent programs [HM90, HM91], and have compared several approaches to dealing with (among other things) object faults (attempts to use persistent objects that are not currently resident (i.e., not actually in the process's virtual address space)), in our Persistent Smalltalk implementation <ref> [HM93a, HM93b] </ref>. <p> However, we have gathered evidence that such totally transparent schemes do not always offer the best performance <ref> [HM93a, HM93b, HBM93, HMS92] </ref>. Hence we will be most interested in schemes that have more than one representation. We list below a range of possible representations. Any given scheme may combine a number of them, though not all subsets make a lot of sense.
Reference: [HM93b] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Protection traps and alternatives for memory management of an object-oriented language. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 106-119, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: of optimizations one might consider to improve performance of persistent programs [HM90, HM91], and have compared several approaches to dealing with (among other things) object faults (attempts to use persistent objects that are not currently resident (i.e., not actually in the process's virtual address space)), in our Persistent Smalltalk implementation <ref> [HM93a, HM93b] </ref>. <p> However, we have gathered evidence that such totally transparent schemes do not always offer the best performance <ref> [HM93a, HM93b, HBM93, HMS92] </ref>. Hence we will be most interested in schemes that have more than one representation. We list below a range of possible representations. Any given scheme may combine a number of them, though not all subsets make a lot of sense.
Reference: [HMB90] <author> Antony L. Hosking, J. Eliot B. Moss, and Cynthia Bliss. </author> <title> Design of an object faulting persistent Smalltalk. </title> <type> COINS Technical Report 90-45, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> May </month> <year> 1990. </year>
Reference: [HMDW91] <author> Richard L. Hudson, J. Eliot B. Moss, Amer Diwan, and Christopher F. </author> <title> Weight. A language-independent garbage collector toolkit. </title> <type> COINS Technical Report 91-47, </type> <institution> University of Massachusetts, Amherst, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: is likely always to be profitableits only negative effect is pinning objects longer (and requiring support for such pinning, which may in turn require compiler produced tables for the run time system to use in determining which objects are pinned (along the lines of compiler support for accurate garbage collection <ref> [DMH92, Diw91, HMDW91] </ref>)). Similarly, target object residency is probably almost always a good idea: it would be rare for the target of a message not to be used and for the method to be statically known.
Reference: [HMS92] <author> Antony L. Hosking, J. Eliot B. Moss, and Darko Stefanovic. </author> <title> A comparative performance evaluation of write barrier implementations. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 92-109, </pages> <address> Vancouver, Canada, </address> <month> October </month> <year> 1992. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 27, </volume> <month> 10 (October </month> <year> 1992). </year>
Reference-contexts: However, we have gathered evidence that such totally transparent schemes do not always offer the best performance <ref> [HM93a, HM93b, HBM93, HMS92] </ref>. Hence we will be most interested in schemes that have more than one representation. We list below a range of possible representations. Any given scheme may combine a number of them, though not all subsets make a lot of sense.
Reference: [Hos91] <author> Antony L. Hosking. </author> <title> Main memory management for persistence, </title> <month> October </month> <year> 1991. </year> <title> Position paper presented at the OOPSLA '91 Workshop on Garbage Collection. </title>
Reference: [Kae86] <author> Ted Kaehler. </author> <title> Virtual memory on a narrow machine for an object-oriented language. </title> <booktitle> In OOPSLA [OOP86], </booktitle> <pages> pages 87-106. </pages>
Reference: [KK83] <author> Ted Kaehler and Glenn Krasner. </author> <title> LOOMlarge object-oriented memory for Smalltalk-80 systems. </title> <editor> In Glenn Krasner, editor, </editor> <title> Smalltalk-80: Bits of History, Words of Advice, </title> <booktitle> chapter 14, </booktitle> <pages> pages 251-270. </pages> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference: [LLOW91] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Weinreb. </author> <title> The ObjectStore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: We are concerned only with situations that require the compiler to generate distinct code; such distinct situations give rise to corresponding representations. For example, in schemes that drive all faulting with memory protection traps and make object faulting entirely transparent to compiled code (such as <ref> [SMR89, SCD90, LLOW91, SKW92] </ref>), there is only one representation: apparently resident objects. However, we have gathered evidence that such totally transparent schemes do not always offer the best performance [HM93a, HM93b, HBM93, HMS92]. Hence we will be most interested in schemes that have more than one representation.
Reference: [Mos87] <author> J. Eliot B. Moss. </author> <title> Implementing persistence for an object oriented language. </title> <type> COINS Technical Report 87-69, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> September </month> <year> 1987. </year>
Reference: [Mos89] <author> J. Eliot B. Moss. </author> <title> Addressing large distributed collections of persistent objects: The Mneme project's approach. </title> <editor> In Richard Hull, Ron Morrison, and David Stemple, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Database Programming Languages, </booktitle> <pages> pages 269-285, </pages> <address> Gleneden Beach, Oregon, </address> <month> June </month> <year> 1989. </year> <note> Morgan Kaufmann. Also available as COINS Technical Report 89-68, </note> <institution> University of Massachusetts. </institution>
Reference: [Mos90] <author> J. Eliot B. Moss. </author> <title> Design of the Mneme persistent object store. </title> <journal> ACM Trans. Inf. Syst., </journal> <volume> 8(2) </volume> <pages> 103-139, </pages> <month> April </month> <year> 1990. </year>
Reference: [Mos92] <author> J. Eliot B. Moss. </author> <title> Working with persistent objects: To swizzle or not to swizzle. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(8) </volume> <pages> 657-673, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: memory. 4 Direct pointer: a direct (virtual memory) pointer to an apparently resident object; either the object is actually resident, or hardware traps may be used to make it resident if the pointer is used; requires no check 5 4 For more background on swizzling, the reader may start with <ref> [Mos92, WD92, WK92] </ref>. 5 While the pointer manipulation code is the same, pointers to resident objects (arranged by prefetching, etc.), and pointers that will trap when used, have different performance characteristics, and ultimately we might care to distinguish between them.
Reference: [MS88] <author> J. Eliot B. Moss and Steven Sinofsky. </author> <title> Managing persistent data with Mneme: Designing a reliable, shared object interface. </title> <booktitle> In Dittrich [Dit88], </booktitle> <pages> pages 298-316. </pages>
Reference: [Nel91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1991. </year>
Reference-contexts: Most of the optimizations we have thought of require reasonably powerful data flow analysis and code transformations, such as hoisting or combining residency checks, or imposing special rules that complicate the compiler such as: the first argument of 1 For further information on Modula-3 see <ref> [CDG + 88, CDG + 89, CDG + 91, Nel91, Har92] </ref>; for further information on our persistence work see [MS88, Mos89, Mos87, Mos90, HMB90, HM90, HM91, Hos91, Mos92, HM93a, HBM93, HM93b]. a method call (i.e., the target object) will (somehow) automatically be made resident throughout the execution of the method (so <p> This difficulty is not an artifact of our notation, but is inherent: a given program must represent a given object consistently. 10 Similar concerns precluded subtyping between record types (etc.) in Modula-3 (see the How the Language Got Its Spots discussions in <ref> [Nel91] </ref>). It is not yet clear whether the restriction to consistent annotations has significant performance impact. As an additional note, we observe that one can unroll a recursive type any fixed number of times, and place different assertions at each place around the type loop.
Reference: [OOP86] <institution> Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, Portland, Oregon, </institution> <month> September </month> <year> 1986. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 21, </volume> <month> 11 (November </month> <year> 1986). </year>
Reference: [RC90] <author> Joel E. Richardson and Michael J. Carey. </author> <title> Persistence in the E language: Issues and implementation. </title> <journal> Software: Practice and Experience, </journal> 19(12) 1115-1150, December 1990. 
Reference-contexts: such assertions on the recursion pointers (such as the next field of our ilist type example) may require a large closure of objects to be made resident (but may be a good idea if the objects are likely to be used). 6 The original implementation of the E programming language <ref> [Ric90, RC90, Ric89] </ref> included an optimization similar to subsumption. It operated in a more general model, where the unit of access was byte ranges of objects, and could unify overlapping ranges in both space and time.
Reference: [Ric89] <author> Joel Edward Richardson. E: </author> <title> A Persistent Systems Implementation Language. </title> <type> PhD thesis, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI, </institution> <month> August </month> <year> 1989. </year> <note> Available as Computer Sciences Technical Report #868. </note>
Reference-contexts: such assertions on the recursion pointers (such as the next field of our ilist type example) may require a large closure of objects to be made resident (but may be a good idea if the objects are likely to be used). 6 The original implementation of the E programming language <ref> [Ric90, RC90, Ric89] </ref> included an optimization similar to subsumption. It operated in a more general model, where the unit of access was byte ranges of objects, and could unify overlapping ranges in both space and time.
Reference: [Ric90] <author> Joel E. Richardson. </author> <title> Compiled item faulting: A new technique for managing I/O in a persistent language. </title> <editor> In Dearle et al. </editor> <booktitle> [DSZ90], </booktitle> <pages> pages 3-16. </pages>
Reference-contexts: such assertions on the recursion pointers (such as the next field of our ilist type example) may require a large closure of objects to be made resident (but may be a good idea if the objects are likely to be used). 6 The original implementation of the E programming language <ref> [Ric90, RC90, Ric89] </ref> included an optimization similar to subsumption. It operated in a more general model, where the unit of access was byte ranges of objects, and could unify overlapping ranges in both space and time.
Reference: [RMS88] <author> Steve Riegel, Fred Mellender, and Andrew Straw. </author> <title> Integration of database management with an object-oriented programming language. </title> <booktitle> In Dittrich [Dit88], </booktitle> <pages> pages 317-322. </pages>
Reference: [SCB + 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In OOPSLA [OOP86], </booktitle> <pages> pages 9-16. </pages>
Reference-contexts: Here we are most concerned with types, procedure calls, and method calls in Modula-3, and assume the reader can grasp other constructs intuitively from a knowledge of Pascal or Modula-2. Unlike some object oriented languages (e.g., Smalltalk [GR83] and Trellis/Owl <ref> [SCB + 86] </ref>), Modula-3 is not uniformly object oriented: it has a full collection of non-object primitive types (INTEGER, REAL, range, enumeration, etc.) and type constructors (RECORD, ARRAY, REF, PROC, etc.) in addition to object types.
Reference: [SCD90] <author> D. Schuh, M. Carey, and D. DeWitt. </author> <title> Persistence in E revisitedimplementation experiences. </title> <editor> In Dearle et al. </editor> <booktitle> [DSZ90], </booktitle> <pages> pages 345-359. </pages>
Reference-contexts: We are concerned only with situations that require the compiler to generate distinct code; such distinct situations give rise to corresponding representations. For example, in schemes that drive all faulting with memory protection traps and make object faulting entirely transparent to compiled code (such as <ref> [SMR89, SCD90, LLOW91, SKW92] </ref>), there is only one representation: apparently resident objects. However, we have gathered evidence that such totally transparent schemes do not always offer the best performance [HM93a, HM93b, HBM93, HMS92]. Hence we will be most interested in schemes that have more than one representation.
Reference: [SKW92] <author> Vivek Singhal, Sheetal V. Kakkad, and Paul R. Wilson. </author> <title> Texas, an efficient, portable persistent store. </title> <booktitle> In Proceedings of the Fifth International Workshop on Persistent Object Systems, </booktitle> <pages> pages 11-33, </pages> <address> San Miniato, Italy, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: We are concerned only with situations that require the compiler to generate distinct code; such distinct situations give rise to corresponding representations. For example, in schemes that drive all faulting with memory protection traps and make object faulting entirely transparent to compiled code (such as <ref> [SMR89, SCD90, LLOW91, SKW92] </ref>), there is only one representation: apparently resident objects. However, we have gathered evidence that such totally transparent schemes do not always offer the best performance [HM93a, HM93b, HBM93, HMS92]. Hence we will be most interested in schemes that have more than one representation.
Reference: [SMR89] <author> Andrew Straw, Fred Mellender, and Steve Riegel. </author> <title> Object management in a persistent Smalltalk system. </title> <journal> Software: Practice and Experience, </journal> <volume> 19(8) </volume> <pages> 719-737, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: We are concerned only with situations that require the compiler to generate distinct code; such distinct situations give rise to corresponding representations. For example, in schemes that drive all faulting with memory protection traps and make object faulting entirely transparent to compiled code (such as <ref> [SMR89, SCD90, LLOW91, SKW92] </ref>), there is only one representation: apparently resident objects. However, we have gathered evidence that such totally transparent schemes do not always offer the best performance [HM93a, HM93b, HBM93, HMS92]. Hence we will be most interested in schemes that have more than one representation.
Reference: [SRA94] <author> Zhong Shao, John H. Reppy, and Andrew W. Appel. </author> <title> Unrolling lists. </title> <booktitle> In 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: However, since this appears to require similar unrolling of all related recursive procedures (as well as iterative loops), it is not obvious one would want to do it very often. (A similar optimization has been suggested for a Standard ML implementation <ref> [SRA94] </ref>.) 6 Clustering While we have focused on the problem of residency check optimization, the annotations we propose also bear some relation to clustering and prefetching of persistent data, especially in the case of data type assertions.
Reference: [WD92] <author> Seth J. White and David J. DeWitt. </author> <title> A performance study of alternative object faulting and pointer swizzling strategies. </title> <booktitle> In Proceedings of the Eighteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 419-431, </pages> <address> Vancouver, Canada, August 1992. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: memory. 4 Direct pointer: a direct (virtual memory) pointer to an apparently resident object; either the object is actually resident, or hardware traps may be used to make it resident if the pointer is used; requires no check 5 4 For more background on swizzling, the reader may start with <ref> [Mos92, WD92, WK92] </ref>. 5 While the pointer manipulation code is the same, pointers to resident objects (arranged by prefetching, etc.), and pointers that will trap when used, have different performance characteristics, and ultimately we might care to distinguish between them.
Reference: [WK92] <author> Paul R. Wilson and Sheetal V. Kakkad. </author> <title> Pointer swizzling at page fault time: Efficiently and compatibly supporting huge address spaces on standard hardware. </title> <booktitle> In Proceedings of the 1992 International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 364-377, </pages> <address> Paris, France, </address> <month> September </month> <year> 1992. </year> <note> IEEE Press. </note>
Reference-contexts: memory. 4 Direct pointer: a direct (virtual memory) pointer to an apparently resident object; either the object is actually resident, or hardware traps may be used to make it resident if the pointer is used; requires no check 5 4 For more background on swizzling, the reader may start with <ref> [Mos92, WD92, WK92] </ref>. 5 While the pointer manipulation code is the same, pointers to resident objects (arranged by prefetching, etc.), and pointers that will trap when used, have different performance characteristics, and ultimately we might care to distinguish between them.
References-found: 44

