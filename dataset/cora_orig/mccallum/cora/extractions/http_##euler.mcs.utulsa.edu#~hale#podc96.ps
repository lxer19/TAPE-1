URL: http://euler.mcs.utulsa.edu/~hale/podc96.ps
Refering-URL: http://euler.mcs.utulsa.edu/~hale/moose.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: hale@euler.mcs.utulsa.edu  (email: sujeet@euler.mcs.utulsa.edu).  
Title: A Process Calculus for Distributed Objects  
Author: Jody Threet John Hale Sujeet Shenoi 
Keyword: Tracks: long presentation  
Note: Contact Author: John Hale,  Student paper: yes, John Hale and Jody Threet are full-time students. To whom correspondence should be addressed  Research supported by OCAST Grant AR2-002 and MPO Contract MDA904-94-C-6117. Submitted to PODC'96.  
Address: Keplinger Hall,  74104, USA  
Affiliation: Department of Computer Science  University of Tulsa Tulsa, Oklahoma  
Abstract: Distributed system specification and verification are active areas of research. Object technologies have shown great promise for managing the complexities of distributed systems. However, existing formal models for object systems do not capture the concurrency inherent in parallel and distributed systems, and available concurrency formalisms do not easily model objects. This paper describes the Robust Object Calculus (ROC) a process calculus for modeling concurrent and distributed objects. ROC supports complex message-passing and promotes agent encapsulation which make it ideal for modeling distributed object systems. A formal notion of behavioral equivalence is provided for ROC. This represents an important first step in developing a practical verification scheme for distributed object systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. </author> <title> America. Issues in the design of a parallel object-oriented language. </title> <journal> Formal Aspects of Computing, </journal> <volume> 1(4), </volume> <year> 1989. </year> <month> 12 </month>
Reference-contexts: However, relatively few of these methods are geared for distributed object systems. Related work in formal methods and concurrent objects have supplied theoretical underpinnings for concurrency in object-oriented systems [10, 13, 14]. Other efforts in this vein have focused on developing formal semantics for parallel object-oriented languages <ref> [1, 2, 5, 7] </ref>. The Object Calculus (OC) of Nierstrasz [13] was one of the first process calculi designed for concurrent objects. OC is similar to the -calculus [12], except that it supports complex message-passing.
Reference: [2] <author> P. America and J. Rutten. </author> <title> A layered semantics for a parallel object-oriented language. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4(4) </volume> <pages> 376-408, </pages> <year> 1992. </year>
Reference-contexts: However, relatively few of these methods are geared for distributed object systems. Related work in formal methods and concurrent objects have supplied theoretical underpinnings for concurrency in object-oriented systems [10, 13, 14]. Other efforts in this vein have focused on developing formal semantics for parallel object-oriented languages <ref> [1, 2, 5, 7] </ref>. The Object Calculus (OC) of Nierstrasz [13] was one of the first process calculi designed for concurrent objects. OC is similar to the -calculus [12], except that it supports complex message-passing.
Reference: [3] <author> A.J. Camilleri. </author> <title> Mechanizing CSP trace theory in higher order logic. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 993-1004, </pages> <year> 1990. </year>
Reference-contexts: This would require a mechanization of ROC into HOL. The mechanization would lend HOL semantics to ROC expressions, thereby providing a rich logic for reasoning about distributed object systems. Mechanizations of CSP and the -calculus into HOL have demonstrated both the utility and practicality of such an approach <ref> [3, 9] </ref>. HOL permits the specification and verification of abstract system properties which are not suitably modeled, but more adequately represented with logical statements about events and states.
Reference: [4] <author> C. T. Chou. </author> <title> Mechanical verification of distributed algorithms in higher order logic. </title> <journal> The Computer Journal, </journal> <volume> 38(1), </volume> <year> 1995. </year>
Reference-contexts: However, intuition fails in the face of the extreme complexity and non-determinism that characterize most real-world distributed systems. The sound analysis of such systems requires the application of formal methods. Formal methods for distributed systems is an expanding area of research <ref> [4, 5, 16] </ref>. However, relatively few of these methods are geared for distributed object systems. Related work in formal methods and concurrent objects have supplied theoretical underpinnings for concurrency in object-oriented systems [10, 13, 14]. <p> While structural congruence rules define when two agents have equivalent structures, behavioral equivalence determines when two agents have equivalent behavior. Theories of behavioral equivalence are important for system specification and verification <ref> [4, 11, 12, 16] </ref>. By constructing a simple model that is behaviorally equivalent to a more complex model, it is also possible to better understand complex system behavior. Furthermore, behavioral equivalence forms the basis of subtyping, interoperability and substitutability [8, 15]. <p> It is similar to the one proposed by Chou <ref> [4] </ref>. Chou's system uses abstract simulations of concrete systems to derive abstract system properties expressed as Higher Order Logic (HOL) propositions. While proving that one system simulates another can be very difficult, a mechanized tool can make the task more manageable. This would require a mechanization of ROC into HOL.
Reference: [5] <author> S. Eisenbach and R. Paterson. </author> <title> calculus semantics for the concurrent configuration language darwin. </title> <booktitle> In Hawaii International Conference on System Sciences, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: However, intuition fails in the face of the extreme complexity and non-determinism that characterize most real-world distributed systems. The sound analysis of such systems requires the application of formal methods. Formal methods for distributed systems is an expanding area of research <ref> [4, 5, 16] </ref>. However, relatively few of these methods are geared for distributed object systems. Related work in formal methods and concurrent objects have supplied theoretical underpinnings for concurrency in object-oriented systems [10, 13, 14]. <p> However, relatively few of these methods are geared for distributed object systems. Related work in formal methods and concurrent objects have supplied theoretical underpinnings for concurrency in object-oriented systems [10, 13, 14]. Other efforts in this vein have focused on developing formal semantics for parallel object-oriented languages <ref> [1, 2, 5, 7] </ref>. The Object Calculus (OC) of Nierstrasz [13] was one of the first process calculi designed for concurrent objects. OC is similar to the -calculus [12], except that it supports complex message-passing.
Reference: [6] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: This provides a basis for the verification of complex distributed object systems. 2 ROC Syntax and Semantics The syntax and semantics of ROC are largely derived from Nierstrasz's OC [13]. OC has its roots in more traditional process calculi such as CSP <ref> [6] </ref>, CCS [11] and the -calculus [12]. As a process calculus designed for concurrent objects, OC supports complex message-passing. ROC adds unbindable values and a non-deterministic choice operator. The atomic elements defining ROC agents are described below. 2.1 Values and Patterns Communication in ROC is based on pattern-matching.
Reference: [7] <author> C.B. Jones. </author> <title> Process-algebraic foundations for an object-based design notation. </title> <type> Technical Report UMCS-93-10-1, </type> <institution> University of Manchester, </institution> <year> 1993. </year>
Reference-contexts: However, relatively few of these methods are geared for distributed object systems. Related work in formal methods and concurrent objects have supplied theoretical underpinnings for concurrency in object-oriented systems [10, 13, 14]. Other efforts in this vein have focused on developing formal semantics for parallel object-oriented languages <ref> [1, 2, 5, 7] </ref>. The Object Calculus (OC) of Nierstrasz [13] was one of the first process calculi designed for concurrent objects. OC is similar to the -calculus [12], except that it supports complex message-passing.
Reference: [8] <author> B. Liskov and J. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(11) </volume> <pages> 1811-1841, </pages> <year> 1994. </year>
Reference-contexts: By constructing a simple model that is behaviorally equivalent to a more complex model, it is also possible to better understand complex system behavior. Furthermore, behavioral equivalence forms the basis of subtyping, interoperability and substitutability <ref> [8, 15] </ref>. While all these applications are interesting, this work focuses on behavioral equivalence as a tool to facilitate distributed object system verification. Behavioral equivalence theories are often built on formal definitions of simulation and bisimulation [11, 12]. The definitions below convey two basic forms of simulation.
Reference: [9] <author> T.F. Melham. </author> <title> A mechanized theory of the -calculus in HOL. </title> <type> Technical Report 244, </type> <institution> University of Cambridge Computer Laboratory, </institution> <address> Cambridge, UK, </address> <year> 1992. </year>
Reference-contexts: This would require a mechanization of ROC into HOL. The mechanization would lend HOL semantics to ROC expressions, thereby providing a rich logic for reasoning about distributed object systems. Mechanizations of CSP and the -calculus into HOL have demonstrated both the utility and practicality of such an approach <ref> [3, 9] </ref>. HOL permits the specification and verification of abstract system properties which are not suitably modeled, but more adequately represented with logical statements about events and states.
Reference: [10] <author> J. Meseguer. </author> <title> A logical theory of concurrent objects and its realizationin the maude language. </title> <editor> In G. Agha, P. Wegner, and A. Yonezawa, editors, </editor> <booktitle> Research Directions in Concurrent Object-Oriented Programming, </booktitle> <pages> pages 315-389. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1993. </year>
Reference-contexts: Formal methods for distributed systems is an expanding area of research [4, 5, 16]. However, relatively few of these methods are geared for distributed object systems. Related work in formal methods and concurrent objects have supplied theoretical underpinnings for concurrency in object-oriented systems <ref> [10, 13, 14] </ref>. Other efforts in this vein have focused on developing formal semantics for parallel object-oriented languages [1, 2, 5, 7]. The Object Calculus (OC) of Nierstrasz [13] was one of the first process calculi designed for concurrent objects.
Reference: [11] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: This provides a basis for the verification of complex distributed object systems. 2 ROC Syntax and Semantics The syntax and semantics of ROC are largely derived from Nierstrasz's OC [13]. OC has its roots in more traditional process calculi such as CSP [6], CCS <ref> [11] </ref> and the -calculus [12]. As a process calculus designed for concurrent objects, OC supports complex message-passing. ROC adds unbindable values and a non-deterministic choice operator. The atomic elements defining ROC agents are described below. 2.1 Values and Patterns Communication in ROC is based on pattern-matching. <p> While structural congruence rules define when two agents have equivalent structures, behavioral equivalence determines when two agents have equivalent behavior. Theories of behavioral equivalence are important for system specification and verification <ref> [4, 11, 12, 16] </ref>. By constructing a simple model that is behaviorally equivalent to a more complex model, it is also possible to better understand complex system behavior. Furthermore, behavioral equivalence forms the basis of subtyping, interoperability and substitutability [8, 15]. <p> Furthermore, behavioral equivalence forms the basis of subtyping, interoperability and substitutability [8, 15]. While all these applications are interesting, this work focuses on behavioral equivalence as a tool to facilitate distributed object system verification. Behavioral equivalence theories are often built on formal definitions of simulation and bisimulation <ref> [11, 12] </ref>. The definitions below convey two basic forms of simulation. One is a strict form of simulation that considers all actions. The other considers only the observable behavior of agents. <p> The following definitions are patterned after notions of bisimulation found in <ref> [11] </ref>: StronglyBisimilar : ROC ! ROC ! bool W eaklyBisimilar : ROC ! ROC ! bool StronglyBisimilar P Q def StrongSimulation S ^ StrongSimulation (x y:S y x) W eaklyBisimilar P Q def W eakSimulation S ^ W eakSimulation (x y:S y x): A practical verification scheme that applies these definitions
Reference: [12] <author> R. Milner. </author> <title> The polyadic -calculus: A tutorial. </title> <editor> In M. Broy, editor, </editor> <title> Logic and Algebra of Specification. </title> <publisher> Springer-Verlag, </publisher> <address> Amsterdam, The Nether-lands, </address> <year> 1992. </year>
Reference-contexts: Other efforts in this vein have focused on developing formal semantics for parallel object-oriented languages [1, 2, 5, 7]. The Object Calculus (OC) of Nierstrasz [13] was one of the first process calculi designed for concurrent objects. OC is similar to the -calculus <ref> [12] </ref>, except that it supports complex message-passing. While OC demonstrates the potential of formalisms tailored to the concurrent object domain, it does not support robust object encapsulation. The Robust Object Calculus (ROC) presented here extends OC by supporting object encapsulation, thereby rendering it ideal for modeling distributed object systems. <p> This provides a basis for the verification of complex distributed object systems. 2 ROC Syntax and Semantics The syntax and semantics of ROC are largely derived from Nierstrasz's OC [13]. OC has its roots in more traditional process calculi such as CSP [6], CCS [11] and the -calculus <ref> [12] </ref>. As a process calculus designed for concurrent objects, OC supports complex message-passing. ROC adds unbindable values and a non-deterministic choice operator. The atomic elements defining ROC agents are described below. 2.1 Values and Patterns Communication in ROC is based on pattern-matching. <p> For example, when v# binds to n? in a, each free occurrence of n in a is replaced by v. 3 2.3 Syntax The ROC syntax is derived from OC [13]. The symbol "#" distinguishes bind-able values from unbindable values. The non-deterministic choice operator "+" from calculus <ref> [12] </ref> is added. <p> While structural congruence rules define when two agents have equivalent structures, behavioral equivalence determines when two agents have equivalent behavior. Theories of behavioral equivalence are important for system specification and verification <ref> [4, 11, 12, 16] </ref>. By constructing a simple model that is behaviorally equivalent to a more complex model, it is also possible to better understand complex system behavior. Furthermore, behavioral equivalence forms the basis of subtyping, interoperability and substitutability [8, 15]. <p> Furthermore, behavioral equivalence forms the basis of subtyping, interoperability and substitutability [8, 15]. While all these applications are interesting, this work focuses on behavioral equivalence as a tool to facilitate distributed object system verification. Behavioral equivalence theories are often built on formal definitions of simulation and bisimulation <ref> [11, 12] </ref>. The definitions below convey two basic forms of simulation. One is a strict form of simulation that considers all actions. The other considers only the observable behavior of agents.
Reference: [13] <author> O. Nierstrasz. </author> <title> Towards an object calculus. </title> <editor> In M. Tokoro, O. Nierstrasz, P. Wegner, and A. Yonezawa, editors, </editor> <booktitle> Proceedings of the ECOOP '91 Workshop on Object-Based Concurrent Computing, </booktitle> <pages> pages 1-20, </pages> <address> Amsterdam, The Netherlands, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Formal methods for distributed systems is an expanding area of research [4, 5, 16]. However, relatively few of these methods are geared for distributed object systems. Related work in formal methods and concurrent objects have supplied theoretical underpinnings for concurrency in object-oriented systems <ref> [10, 13, 14] </ref>. Other efforts in this vein have focused on developing formal semantics for parallel object-oriented languages [1, 2, 5, 7]. The Object Calculus (OC) of Nierstrasz [13] was one of the first process calculi designed for concurrent objects. <p> Related work in formal methods and concurrent objects have supplied theoretical underpinnings for concurrency in object-oriented systems [10, 13, 14]. Other efforts in this vein have focused on developing formal semantics for parallel object-oriented languages [1, 2, 5, 7]. The Object Calculus (OC) of Nierstrasz <ref> [13] </ref> was one of the first process calculi designed for concurrent objects. OC is similar to the -calculus [12], except that it supports complex message-passing. While OC demonstrates the potential of formalisms tailored to the concurrent object domain, it does not support robust object encapsulation. <p> A formal theory of behavioral equivalence for ROC is presented. This provides a basis for the verification of complex distributed object systems. 2 ROC Syntax and Semantics The syntax and semantics of ROC are largely derived from Nierstrasz's OC <ref> [13] </ref>. OC has its roots in more traditional process calculi such as CSP [6], CCS [11] and the -calculus [12]. As a process calculus designed for concurrent objects, OC supports complex message-passing. ROC adds unbindable values and a non-deterministic choice operator. <p> For example, when v# binds to n? in a, each free occurrence of n in a is replaced by v. 3 2.3 Syntax The ROC syntax is derived from OC <ref> [13] </ref>. The symbol "#" distinguishes bind-able values from unbindable values. The non-deterministic choice operator "+" from calculus [12] is added.
Reference: [14] <author> I. Satoh and M. Tokoro. </author> <title> A formalism for real-time concurrent object-oriented computing. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(10) </volume> <pages> 315-326, </pages> <year> 1992. </year>
Reference-contexts: Formal methods for distributed systems is an expanding area of research [4, 5, 16]. However, relatively few of these methods are geared for distributed object systems. Related work in formal methods and concurrent objects have supplied theoretical underpinnings for concurrency in object-oriented systems <ref> [10, 13, 14] </ref>. Other efforts in this vein have focused on developing formal semantics for parallel object-oriented languages [1, 2, 5, 7]. The Object Calculus (OC) of Nierstrasz [13] was one of the first process calculi designed for concurrent objects.
Reference: [15] <author> A. Zaremski and J. Wing. </author> <title> Specification matching of software components. </title> <booktitle> In Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <year> 1995. </year> <month> 13 </month>
Reference-contexts: By constructing a simple model that is behaviorally equivalent to a more complex model, it is also possible to better understand complex system behavior. Furthermore, behavioral equivalence forms the basis of subtyping, interoperability and substitutability <ref> [8, 15] </ref>. While all these applications are interesting, this work focuses on behavioral equivalence as a tool to facilitate distributed object system verification. Behavioral equivalence theories are often built on formal definitions of simulation and bisimulation [11, 12]. The definitions below convey two basic forms of simulation.
Reference: [16] <author> C. Zhang, R. Shaw, M. R. Heckman, G. D. Benson, M. Archer, K. Levitt, and R. A. Olsson. </author> <title> Towards a formal verification of a secure distributed system and its applications. </title> <editor> In T. Melham and J. Camilleri, editors, </editor> <booktitle> Supplementary Proceedings of the 7th International Workshop on Higher Order Logic Theorem and its Applications, </booktitle> <year> 1994. </year> <month> 14 </month>
Reference-contexts: However, intuition fails in the face of the extreme complexity and non-determinism that characterize most real-world distributed systems. The sound analysis of such systems requires the application of formal methods. Formal methods for distributed systems is an expanding area of research <ref> [4, 5, 16] </ref>. However, relatively few of these methods are geared for distributed object systems. Related work in formal methods and concurrent objects have supplied theoretical underpinnings for concurrency in object-oriented systems [10, 13, 14]. <p> While structural congruence rules define when two agents have equivalent structures, behavioral equivalence determines when two agents have equivalent behavior. Theories of behavioral equivalence are important for system specification and verification <ref> [4, 11, 12, 16] </ref>. By constructing a simple model that is behaviorally equivalent to a more complex model, it is also possible to better understand complex system behavior. Furthermore, behavioral equivalence forms the basis of subtyping, interoperability and substitutability [8, 15].
References-found: 16

