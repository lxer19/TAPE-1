URL: http://www-cad.eecs.berkeley.edu/HomePages/dealfaro/tacas97.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/dealfaro/papers.html
Root-URL: http://www.cs.berkeley.edu
Email: luca|manna|sipma|uribe@cs.stanford.edu  
Title: Visual Verification of Reactive Systems  
Author: Luca de Alfaro, Zohar Manna, Henny B. Sipma and Tomas E. Uribe 
Address: Stanford, CA. 94305  
Affiliation: Computer Science Department, Stanford University  
Date: April 1997.  
Note: To appear in TACAS-97, LNCS, Springer-Verlag,  
Abstract: We describe diagram-based formal methods for verifying temporal properties of finite- and infinite-state reactive systems. These methods, which share a common background and tools, differ in the way they use automatic procedures within an interactive setting based on deduction. They can be used to produce a static proof object, or to perform incremental analysis of systems and specifications.
Abstract-found: 1
Intro-found: 1
Reference: [BBC + 96] <author> N. S. Bjtrner, A. Browne, E. Chang, M. Colon, A. Kapur, Z. Manna, H.B. Sipma, and T.E. Uribe. </author> <title> STeP: Deductive-algorithmic verification of reactive and real-time systems. </title> <booktitle> In Proc. 8 th Intl. Conference on Computer Aided Verification, volume 1102 of LNCS, </booktitle> <pages> pages 415-418. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1996. </year>
Reference-contexts: Program bakery 2 The STeP system <ref> [BBC + 96] </ref> parses such SPL programs into fair transition systems, or can take transition systems directly as input. 3 2.2 Temporal Logic Specifications are expressed as formulas in linear-time temporal logic. Assertions, or state-formulas, are first-order formulas with no temporal operators, and can include quantifiers.
Reference: [BBM95] <author> N.S. Bjtrner, A. Browne, and Z. Manna. </author> <title> Automatic generation of invariants and intermediate assertions. </title> <booktitle> In 1 st Intl. Conf. on Principles and Practice of Constraint Programming, volume 976 of LNCS, </booktitle> <pages> pages 589-623. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: By expressing temporal properties as automata, the methods allow the direct verification of general temporal logic specifications, eliminating the need to express the formulas in the normal forms required by a fixed set of classic deductive verification rules. A related formalism is used in <ref> [BBM95] </ref>, as part of a procedure for automatically generating invariants and establishing temporal safety properties based on assertion graphs similar to the diagrams in this paper. <p> Then we can simultaneously replace, for all 1 i n, the label (v i ) of v i with (v i ) ^ ' i . ut The strengthening assertions ' i can be obtained using the techniques presented in <ref> [BBM95] </ref>. These methods generate invariants by propagating pre- and post-conditions over assertion graphs, which are diagrams for general safety properties. Abstraction domains, which approximate the system, make automatic propagation possible.
Reference: [BMS95] <author> A. Browne, Z. Manna, and H.B. Sipma. </author> <title> Generalized verification diagrams. </title> <booktitle> In 15th Conference on the Foundations of Software Technology and Theoretical Computer Science, volume 1026 of LNCS, </booktitle> <pages> pages 484-498, </pages> <year> 1995. </year>
Reference-contexts: This paper presents an overview of three diagram-based formalisms for the verification of temporal properties of systems, which correspond to different methods of proof construction. Verification diagrams <ref> [MP94, BMS95] </ref> represent a completed direct proof, and offer a compact representation of the necessary verification conditions. Fairness diagrams [dAM96] represent abstractions of the system, and the proof of a specification is constructed by stepwise diagram transformations. <p> In the original proposal for verification diagrams [MP94], property-dependent well-formedness constraints on the diagram ensure that A satisfies '. This was generalized in <ref> [BMS95] </ref> to an algorithmic language inclusion check L (A) L ('). Example. Mutual exclusion for program bakery is expressed by the formula ' mut : 0 :(` 3 ^ m 3 ). Figure 2 presents a verification diagram that proves that L (bakery) L (' mut ). <p> In <ref> [BMS95] </ref>, Streett acceptance conditions are added to the diagram to show that it satisfies '. Alternatively, we can show that L (A) L (') by extending 15 the algorithmic test of Section 3.
Reference: [BMS96] <author> A. Browne, Z. Manna, and H.B. Sipma. </author> <title> Hierarchical verification using verification diagrams. </title> <booktitle> In 2 nd Asian Computing Science Conf., volume 1179 of LNCS, </booktitle> <pages> pages 276-286. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1996. </year>
Reference-contexts: To highlight the similarities and relationships between these verification methods, we have adopted as much as possible a uniform notation, deviating occasionally from that used in the original proposals. However, their essential features have been preserved. These methods have been recently extended to hierarchical verification <ref> [BMS96] </ref> and modular verification [dAMS97]. The fairness diagrams method has also been successfully extended to the study of hybrid systems [dAKM97]. Section 2 summarizes the definitions and notation used in the ensuing presentation. Section 3 presents the basic definition of diagrams.
Reference: [CE81] <author> E.M. Clarke and E.A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching time temporal logic. </title> <booktitle> In Proc. IBM Workshop on Logics of Programs, volume 131 of LNCS, </booktitle> <pages> pages 52-71. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: The textbook [MP95] presents a set of rules that is complete for proving safety properties. Algorithmic verification. Algorithmic verification, or model checking , can automatically decide whether a given system S satisfies its temporal specification ' <ref> [CE81, QS82] </ref>. These algorithms are based on explicit state enumeration or specialized data structures to represent the transition relation and compute fixpoints over it, as in BDD-based symbolic model checking [McM93].
Reference: [dAKM97] <author> L. de Alfaro, A. Kapur, and Z. Manna. </author> <title> Hybrid diagrams: A deductive-algorithmic approach to hybrid system verification. </title> <booktitle> In 14th Symposium on Theoretical Aspects of Computer Science, </booktitle> <month> February </month> <year> 1997. </year>
Reference-contexts: However, their essential features have been preserved. These methods have been recently extended to hierarchical verification [BMS96] and modular verification [dAMS97]. The fairness diagrams method has also been successfully extended to the study of hybrid systems <ref> [dAKM97] </ref>. Section 2 summarizes the definitions and notation used in the ensuing presentation. Section 3 presents the basic definition of diagrams. Section 4 presents an overview of the three proof methods. <p> Otherwise, each fulfilling SCS of A k T :' points to a possible counterexample to ', and provides guidance for the extension of the sequence of diagrams, as described in <ref> [dAKM97] </ref>. Specifically, let X be the set of vertices of a fulfilling SCS of A k T :' . Let Y be the set of vertices that appear in paths from initial vertex to X in A k T :' .
Reference: [dAM96] <author> L. de Alfaro and Z. Manna. </author> <title> Temporal verification by diagram transformations. </title> <booktitle> In Proc. 8 th Intl. Conference on Computer Aided Verification, volume 1102 of LNCS, </booktitle> <pages> pages 287-299, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: This paper presents an overview of three diagram-based formalisms for the verification of temporal properties of systems, which correspond to different methods of proof construction. Verification diagrams [MP94, BMS95] represent a completed direct proof, and offer a compact representation of the necessary verification conditions. Fairness diagrams <ref> [dAM96] </ref> represent abstractions of the system, and the proof of a specification is constructed by stepwise diagram transformations. <p> Unlike in <ref> [dAM96] </ref>, we do not require the validity of J (v) ! (v), C (v) ! (v), G (u; v) ! (u; v). Associated with each diagram is a set F of fairness constraints. <p> To discard all the fulfilling SCS's of A T :' , it is sometimes necessary to add fairness constraints to a diagram A. For this purpose, the fairness rules proposed in <ref> [dAM96] </ref> can be easily adapted to the notation of this paper. In order to add a constraint, the rules first check that the constraint accepts all the fair trails of the diagram: this ensures that the set of fair trails does not change with the addition of the new constraint.
Reference: [dAMS97] <author> L. de Alfaro, Z. Manna, and H.B. Sipma. </author> <title> Decomposing, transforming and composing diagrams: The joys of modular verification. </title> <note> Submitted, </note> <year> 1997. </year>
Reference-contexts: To highlight the similarities and relationships between these verification methods, we have adopted as much as possible a uniform notation, deviating occasionally from that used in the original proposals. However, their essential features have been preserved. These methods have been recently extended to hierarchical verification [BMS96] and modular verification <ref> [dAMS97] </ref>. The fairness diagrams method has also been successfully extended to the study of hybrid systems [dAKM97]. Section 2 summarizes the definitions and notation used in the ensuing presentation. Section 3 presents the basic definition of diagrams. Section 4 presents an overview of the three proof methods.
Reference: [Har87] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <journal> Sci. Comp. Prog., </journal> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: However, we define the set of computations of a diagram, L (A), as the set of all runs that correspond to trails that satisfy the acceptance conditions of the diagram. 5 To make diagrams more succinct, we often use encapsulation conventions, based on those of Statecharts <ref> [Har87] </ref>. The assertion labeling a compound vertex is added, as a conjunct, to its subvertices. Edges leaving (entering) a compound vertex are interpreted as leaving (entering) all of its subvertices. We omit from our diagrams all edges (u; v) such that -(u; v) = ;.
Reference: [KMMP93] <author> Y. Kesten, Z. Manna, H. McGuire, and A. Pnueli. </author> <title> A decision algorithm for full propositional temporal logic. </title> <booktitle> In Proc. 5 th Intl. Conference on Computer Aided Verification, volume 697 of LNCS, </booktitle> <pages> pages 97-109. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The formula tableau. Given a temporal formula ', it is possible to construct the tableau T ' = hV; V in ; E; ai of ', a finite automaton that describes all the sequences in L (') <ref> [KMMP93, MP95] </ref>. The vertices V of this automaton correspond to the atoms of ', which are consistent sets of subformulas of ': to v 2 V is associated atom a (v). The formulas in the atom a (v) are expected to hold whenever the automaton is at vertex v.
Reference: [Kur94] <author> R. P. Kurshan. </author> <title> Computer-Aided Verification of Coordinating Processes: The Automata-Theoretic Approach. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: These algorithms are based on explicit state enumeration or specialized data structures to represent the transition relation and compute fixpoints over it, as in BDD-based symbolic model checking [McM93]. Automata-based model checking methods <ref> [Kur94, VW86] </ref> represent both the system and property as !-automata, and then use algorithmic procedures to test that L (S) L ('). Model checking has been particularly successful for the verification of hardware systems.
Reference: [McM93] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Pub., </publisher> <year> 1993. </year>
Reference-contexts: Algorithmic verification, or model checking , can automatically decide whether a given system S satisfies its temporal specification ' [CE81, QS82]. These algorithms are based on explicit state enumeration or specialized data structures to represent the transition relation and compute fixpoints over it, as in BDD-based symbolic model checking <ref> [McM93] </ref>. Automata-based model checking methods [Kur94, VW86] represent both the system and property as !-automata, and then use algorithmic procedures to test that L (S) L ('). Model checking has been particularly successful for the verification of hardware systems.
Reference: [MP91] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year> <month> 16 </month>
Reference-contexts: 1 Introduction Reactive systems have an ongoing interaction with their environment. They include distributed and concurrent algorithms, hardware systems, and control programs. Temporal logic has proved to be a convenient language for expressing safety, progress and response properties of reactive systems <ref> [MP91, MP95] </ref>. The classic approach to verifying temporal properties of reactive systems is based on verification rules, which reduce the system validity of a temporal property to the general validity of a set of first-order verification conditions. <p> Assertions, or state-formulas, are first-order formulas with no temporal operators, and can include quantifiers. Temporal formulas are constructed from assertions, boolean connectives, and the usual future (0 ; 1 ; 2 ; U ; W ) and past (` ; Q ; ; B ; S ) temporal operators <ref> [MP91] </ref>. For instance, the formula 0 :(at ` 3 ^ at m 3 ) expresses mutual exclusion for bakery. Given a formula ', L (') is the set of all infinite sequences that satisfy '. The formula tableau. <p> The symbols J , C, G take their names from the concepts of Justice, Compassion and Gratification <ref> [MP91] </ref>. We say that a trail is accepted by F if it is accepted by all the constraints in F : such a trail is called a fair trail. We define L (A) to be the set of state sequences corresponding to the fair trails of A. Implicit constraints.
Reference: [MP94] <author> Z. Manna and A. Pnueli. </author> <title> Temporal verification diagrams. </title> <booktitle> In Proc. Int. Symp. on Theoretical Aspects of Computer Software, volume 789 of LNCS, </booktitle> <pages> pages 726-765. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: This paper presents an overview of three diagram-based formalisms for the verification of temporal properties of systems, which correspond to different methods of proof construction. Verification diagrams <ref> [MP94, BMS95] </ref> represent a completed direct proof, and offer a compact representation of the necessary verification conditions. Fairness diagrams [dAM96] represent abstractions of the system, and the proof of a specification is constructed by stepwise diagram transformations. <p> In the original proposal for verification diagrams <ref> [MP94] </ref>, property-dependent well-formedness constraints on the diagram ensure that A satisfies '. This was generalized in [BMS95] to an algorithmic language inclusion check L (A) L ('). Example. Mutual exclusion for program bakery is expressed by the formula ' mut : 0 :(` 3 ^ m 3 ).
Reference: [MP95] <author> Z. Manna and A. Pnueli. </author> <title> Temporal Verification of Reactive Systems: Safety. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: 1 Introduction Reactive systems have an ongoing interaction with their environment. They include distributed and concurrent algorithms, hardware systems, and control programs. Temporal logic has proved to be a convenient language for expressing safety, progress and response properties of reactive systems <ref> [MP91, MP95] </ref>. The classic approach to verifying temporal properties of reactive systems is based on verification rules, which reduce the system validity of a temporal property to the general validity of a set of first-order verification conditions. <p> The formula tableau. Given a temporal formula ', it is possible to construct the tableau T ' = hV; V in ; E; ai of ', a finite automaton that describes all the sequences in L (') <ref> [KMMP93, MP95] </ref>. The vertices V of this automaton correspond to the atoms of ', which are consistent sets of subformulas of ': to v 2 V is associated atom a (v). The formulas in the atom a (v) are expected to hold whenever the automaton is at vertex v. <p> Other verification rules are available for proving different classes of temporal properties, e.g. nested wait-for formulas and response formulas. The textbook <ref> [MP95] </ref> presents a set of rules that is complete for proving safety properties. Algorithmic verification. Algorithmic verification, or model checking , can automatically decide whether a given system S satisfies its temporal specification ' [CE81, QS82].
Reference: [QS82] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in CESAR. </title> <editor> In M. Dezani-Ciancaglini and U. Montanari, editors, </editor> <booktitle> Intl. Symposium on Programming, volume 137 of LNCS, </booktitle> <pages> pages 337-351. </pages> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: The textbook [MP95] presents a set of rules that is complete for proving safety properties. Algorithmic verification. Algorithmic verification, or model checking , can automatically decide whether a given system S satisfies its temporal specification ' <ref> [CE81, QS82] </ref>. These algorithms are based on explicit state enumeration or specialized data structures to represent the transition relation and compute fixpoints over it, as in BDD-based symbolic model checking [McM93].
Reference: [SUM96] <author> H.B. Sipma, T.E. Uribe, and Z. Manna. </author> <title> Deductive model checking. </title> <booktitle> In Proc. 8 th Intl. Conference on Computer Aided Verification, volume 1102 of LNCS, </booktitle> <pages> pages 208-219. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Verification diagrams [MP94, BMS95] represent a completed direct proof, and offer a compact representation of the necessary verification conditions. Fairness diagrams [dAM96] represent abstractions of the system, and the proof of a specification is constructed by stepwise diagram transformations. Deductive model checking <ref> [SUM96] </ref> uses diagrams to conduct an exhaustive search for a counterexample, giving a semi-automatic proof procedure. ? This research was supported in part by the National Science Foundation under grant CCR-95-27927, the Defense Advanced Research Projects Agency under NASA grant NAG2-892, ARO under grant DAAH04-95-1-0317, ARO under MURI grant DAAH04-96-1-0341, and <p> Instead of the simulation rule, deductive model checking uses specialized versions, which carry out specific tasks in the process of proof construction. For conciseness, we present a minimal set of rules. Note that neither this set of rules nor the original one of <ref> [SUM96] </ref> is equivalent to the simulation rule, i.e. it is not possible to mimic all applications of the simulation rule by repeated applications of the specialized rules. Nonetheless, the set enables the proof of arbitrary safety properties, and is thus complete in this more relevant and practical respect. <p> Intuitively, each assertion ' i is a "contract" containing an obligation not to visit vertex v i : each time a contract is voided, ffi is decreased. With this rule, not in <ref> [SUM96] </ref>, deductive model checking is complete for proving general temporal properties of fair transition systems (again, for formulas whose quantifiers appear only within assertions). 6.3 Verification Diagrams: Fairness Similarly to falsification diagrams, a trail (v 0 ; s 0 ); (v 1 ; s 1 ); : : : in a
Reference: [VW86] <author> M.Y. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 32 </volume> <pages> 183-221, </pages> <year> 1986. </year> <month> 17 </month>
Reference-contexts: These algorithms are based on explicit state enumeration or specialized data structures to represent the transition relation and compute fixpoints over it, as in BDD-based symbolic model checking [McM93]. Automata-based model checking methods <ref> [Kur94, VW86] </ref> represent both the system and property as !-automata, and then use algorithmic procedures to test that L (S) L ('). Model checking has been particularly successful for the verification of hardware systems.
References-found: 18

