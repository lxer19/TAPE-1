URL: http://osl.cs.uiuc.edu/Papers/kluwer.ps
Refering-URL: http://osl.cs.uiuc.edu/ExMembers/sturman/
Root-URL: http://www.cs.uiuc.edu
Title: A Methodology for Adapting to Patterns of Faults an embedded system which is required to
Author: Gul Agha and Daniel C. Sturman 
Address: 1304 W. Spring-field Avenue, Urbana, Illinois 61801, USA.  
Affiliation: Department of Computer Science, University of Illinois at Urbana-Champaign,  
Note: To appear in: G. Koob (ed.), Foundations of Ultradependability, Vol. 1, Kluwer Academic  1.2.1 Introduction Consider  Authors address:  
Pubnum: SECTION  
Email: Email: f agha j sturman g@cs.uiuc.edu  
Date: 1.2  1994  
Abstract: In this paper, we present a language framework for describing dependable systems. Our framework emphasizes modularity and composition. The dependability and functionality aspects of an application may be described independently, providing separation of design concerns. Furthermore, the dependability protocols of an application may be constructed bottom-up as simple protocols that are composed into more complex protocols. Composition makes it easier to reason about the behavior of complex protocols and supports the construction of generic reusable dependability schemes. A significant aspect of our language framework is that dependability protocols may be loaded into a running application and installed dynamically. Dynamic installation makes it possible to impose additional dependability protocols on a server as clients with new dependability demands are integrated into a system. Similarly, if a given dependability protocol is only necessary during some particular phase of execution it may be installed during that period only. A number of systems have been developed to support the development of dependable computing applications. Such support is given in terms of failure semantics which specify legal ways in which a component can fail [11]. Failure semantics are enforced through the use of dependability protocols which guarantee that the probability of a failure of a type not specified in the semantics is acceptably small. However, existing systems assume that the failure semantics of a service are static and, therefore, the dependability protocols used may be fixed. In many computer systems, it is either unsatisfactory to adhere to a static failure semantics or impossible to adequately enforce the semantics with a fixed group of dependability protocols. We illustrate this concept with two example systems: fl The research described has been made possible by support from the Office of Naval Research (ONR contract numbers N00014-90-J-1899 and N00014-93-1-0273), by an Incentives for Excellence Award from the Digital Equipment Corporation Faculty Program, and by joint support from the Department of Defense Advanced Research Projects Agency and the National Science Foundation (NSF CCR 90-07195). The research described in here has benefitted from fruitful discussions with, and critical comments from, Christian Callsen, Svend Frolund, WooYoung Kim, Rajendra Panwar, Anna Patterson, Shangping Ren, Carolyn Talcott, Nalini Venkatasubramaniam, Takuo Watanabe among others. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Acceta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <note> Mach: </note>
Reference-contexts: For example, check-pointing may be composed with replication without requiring that the representation of either protocol know about the other. Non-reflective systems which support customization do so only in a system-wide basis. For example, customization in a micro-kernel based system <ref> [1] </ref> affects all the objects collectively. In an object-oriented system such as Choices [8], frameworks may be customized for a particular application. However, once customized, the characteristics may not change dynamically. Reflection in an object based system allows customization of the underlying system independently for each object. <p> () == members [i]) /* Since the message was from a replica, * we know that the first argument is a tag and * the second is the original message. */ if (m.arg [0] &lt; tag) /* Discard message */ return; else if (m [0] == tag) f self.enqueue (m <ref> [1] </ref>); tag = tag + 1; g Eliminator removes tags (which have been added to all server replies by some other dispatcher) and takes the first message labeled by a new tag. Gul Agha and Daniel C.
References-found: 1

