URL: http://www.cs.tamu.edu/faculty/bettati/Papers/icdcs92.paper.ps
Refering-URL: http://www.cs.tamu.edu/faculty/bettati/selected_papers.html
Root-URL: http://www.cs.tamu.edu
Title: End-to-End Scheduling to Meet Deadlines in Distributed Systems  
Author: R. Bettati and Jane W.-S. Liu 
Date: June 1992, pages 452-459.  
Address: Yokohama, Japan,  Urbana, IL 61801  
Affiliation: Computing Systems,  Department of Computer Science University of Illinois at Urbana-Champaign  
Note: Appeared in: Proceedings of the 12th International Conference on Distributed  
Abstract: In a distributed system or communication network tasks may need to be executed on more than one processor. For time-critical tasks, the timing constraints are typically given as end-to-end release-times and deadlines. This paper describes algorithms to schedule a class of systems where all the tasks execute on different processors in turn in the same order. This end-to-end scheduling problem is known as the flow-shop problem. We present two cases where the problem is tractable and evaluate a heuristic for the N P-hard general case. We generalize the traditional flow-shop model in two directions. First, we present an algorithm for scheduling flow shops where tasks can be serviced more than once by some processors. Second, we describe a heuristic algorithm to schedule flow shops that consist of periodic tasks. Some considerations are made about scheduling systems with more than one flow shop. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Bettati and J. W.-S. Liu. </author> <title> Algorithms for end-to-end scheduling to meet deadlines. </title> <booktitle> In Proceedings of the 2nd IEEE Conference on Parallel and Distributed Systems, </booktitle> <address> Dallas, Texas, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: An algorithm is optimal if it always finds a feasible schedule whenever the tasks can be scheduled to meet all deadlines. The problem of scheduling tasks in a flow shop to meet deadlines is N P-hard, except for a few special cases [5, 10]. In <ref> [1] </ref> we described two optimal O (nlogn) algorithms for scheduling tasks that have identical processing times on all processors and tasks that have identical processing times on each of the processors but have different processing times on different processors. <p> We review the traditional flow-shop model in Section 2. The flow shop with recurrence and the periodic flow-shop model are described. Section 3 summarizes our earlier results on optimally scheduling homogeneous tasks with identical processing times on each processor on traditional flow shops <ref> [1] </ref> and an extension to scheduling such tasks on flow shops with recurrence. In Section 4 we generalize this approach to schedule tasks where the processing times are identical on any processor, but may vary between processors. We describe a heuristic to schedule tasks with arbitrary processing times. <p> Since T ij cannot be scheduled until earlier subtasks are completed, r ij = r i + P j1 With arbitrary task parameters, the flow-shop problem is N P-hard, even where preemption is allowed <ref> [1, 2] </ref>. In two special cases of task sets, the scheduling problem becomes tractable. In the first case the processing times t ij of all subtasks are equal to a unit t on all processors. We call these task sets identical-length task sets. <p> The processing time of the subtask on processor P j of each task in the job J i is t ij . 3 Scheduling Identical-Length Task Sets In this section we describe an extension of an optimal algorithm for scheduling identical-length task sets on tra ditional flow shops <ref> [1] </ref>. The extension is optimal when used to schedule identical-length tasks on flow-shops with simple recurrence patterns. In many systems, tasks are designed to have regular structures. <p> By release times, we mean modified release times. By the EEDF algorithm, we mean the EEDF algorithm using the modified release times as input parameters rather than the effective release times. We proved in <ref> [1] </ref> that the EEDF algorithm is optimal for non-preemptive flow-shop scheduling of identical-length task sets with arbitrary release times and deadlines. We now extend the EEDF algorithm to optimally schedule simple task sets on flow shops with recurrence. <p> The scheduling decision is made on P 2 , the first reused processor in the loop. 4 Scheduling Arbitrary Task Sets The assumption that the task sets must have identical processing times is restrictive. Taking a step toward the removal of this assumption, we considered in <ref> [1] </ref> a class of flow shops called flow shops with homogeneous task sets, where the subtasks T ij have identical processing times t j 0 2 4 6 8 10 12 time P 1 P 3 P 5 T 1;2 T 2;2 T 3;2 T 1;5 T 2;5 T 4;2 T <p> We can use Algorithm A, described in The optimality of Algorithm A for nonpreemptive flow-shop scheduling of homogeneous task sets that have arbitrary release times and deadlines was proven in <ref> [1] </ref>. An example illustrating Algorithm A is shown in Table 2 and Figure 5. The bottleneck processor is the one on which tasks have the longest processing times. In this example, it is P 3 , or b = 3.
Reference: [2] <author> R. Bettati and J. W.-S. Liu. </author> <title> Algorithms for end-to-end scheduling to meet deadlines. </title> <type> Technical Report UIUCDCS-R-1594, </type> <institution> Department of Computer Science, University of Illinois, </institution> <year> 1990. </year>
Reference-contexts: Since T ij cannot be scheduled until earlier subtasks are completed, r ij = r i + P j1 With arbitrary task parameters, the flow-shop problem is N P-hard, even where preemption is allowed <ref> [1, 2] </ref>. In two special cases of task sets, the scheduling problem becomes tractable. In the first case the processing times t ij of all subtasks are equal to a unit t on all processors. We call these task sets identical-length task sets. <p> Because of this change of the effective release times of later subtasks after earlier subtasks are scheduled, the optimality of Algorithm R does no longer obviously follow from the optimality of the EEDF Algorithm. In <ref> [2] </ref> we used a schedule-transformation argument to prove that for nonpreemptive scheduling of tasks in a flow shop with recurrence, Algorithm R is optimal, for tasks with identical processing times and release times, arbitrary deadlines, and a visit sequence that can be characterized by a visit graph containing a single loop.
Reference: [3] <author> M. R. Garey and D. S. Johnson. </author> <title> Scheduling tasks with nonuniform deadlines on two processors. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 23 </volume> <pages> 461-467, </pages> <year> 1976. </year>
Reference-contexts: The periodic flow shop can be viewed as a special case of the flow shop with recurrence, as well as a generalization of the traditional flow shop. Past efforts in flow-shop scheduling have focused on the minimization of completion time <ref> [3, 6, 10] </ref>. Johnson [3] showed that tasks in a two-processor flow shop can be scheduled to minimize completion time in O (n log n) time. Beyond the two-processor flow shop, however, almost every flow-shop scheduling problem is N P-complete. <p> The periodic flow shop can be viewed as a special case of the flow shop with recurrence, as well as a generalization of the traditional flow shop. Past efforts in flow-shop scheduling have focused on the minimization of completion time [3, 6, 10]. Johnson <ref> [3] </ref> showed that tasks in a two-processor flow shop can be scheduled to minimize completion time in O (n log n) time. Beyond the two-processor flow shop, however, almost every flow-shop scheduling problem is N P-complete. <p> When release times and deadlines are multiples of t , we can simply use the classical earliest-effective-deadline-first (EEDF) algorithm to optimally schedule all tasks <ref> [3] </ref>. Again, an algorithm is optimal if it always produces a feasible schedule whenever such schedule exists. In the EEDF algorithm, the subtasks T ij on each processor P j are scheduled nonpreemptively in a priority-driven manner.
Reference: [4] <author> M. R. Garey and D. S. Johnson. </author> <title> Two-processor scheduling with start-times and deadlines. </title> <journal> SIAM J. Comput., </journal> <volume> 6 </volume> <pages> 416-426, </pages> <year> 1977. </year>
Reference-contexts: Several algorithms for scheduling pipelines to maximize throughput are described in [9, 14]. The general problem of scheduling to meet deadlines on identical multiprocessor systems is also N P-hard [5, 10]. However, polynomial algorithms for optimally scheduling tasks with identical processing times on one or two processors exist <ref> [4, 7] </ref>. Our algorithms make use of one of them. We review the traditional flow-shop model in Section 2. The flow shop with recurrence and the periodic flow-shop model are described.
Reference: [5] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: An algorithm is optimal if it always finds a feasible schedule whenever the tasks can be scheduled to meet all deadlines. The problem of scheduling tasks in a flow shop to meet deadlines is N P-hard, except for a few special cases <ref> [5, 10] </ref>. In [1] we described two optimal O (nlogn) algorithms for scheduling tasks that have identical processing times on all processors and tasks that have identical processing times on each of the processors but have different processing times on different processors. <p> Flow-shop scheduling is similar to scheduling in pipelined multiprocessors. Several algorithms for scheduling pipelines to maximize throughput are described in [9, 14]. The general problem of scheduling to meet deadlines on identical multiprocessor systems is also N P-hard <ref> [5, 10] </ref>. However, polynomial algorithms for optimally scheduling tasks with identical processing times on one or two processors exist [4, 7]. Our algorithms make use of one of them. We review the traditional flow-shop model in Section 2. The flow shop with recurrence and the periodic flow-shop model are described.
Reference: [6] <author> M. R. Garey, D. S. Johnson, and R. Sethi. </author> <title> The complexity of flowshop and jobshop scheduling. </title> <journal> Math. Oper. Res., </journal> <volume> 1 </volume> <pages> 117-129, </pages> <year> 1976. </year>
Reference-contexts: The periodic flow shop can be viewed as a special case of the flow shop with recurrence, as well as a generalization of the traditional flow shop. Past efforts in flow-shop scheduling have focused on the minimization of completion time <ref> [3, 6, 10] </ref>. Johnson [3] showed that tasks in a two-processor flow shop can be scheduled to minimize completion time in O (n log n) time. Beyond the two-processor flow shop, however, almost every flow-shop scheduling problem is N P-complete. <p> Beyond the two-processor flow shop, however, almost every flow-shop scheduling problem is N P-complete. For example, the general problem of minimizing completion time on three processors is strictly N P-hard <ref> [6] </ref>. Consequently, many studies of flow-shop problems were concerned with restrictions of the problem that make it tractable, or focused on enumerative methods and heuristic algorithms. Flow-shop scheduling is similar to scheduling in pipelined multiprocessors. Several algorithms for scheduling pipelines to maximize throughput are described in [9, 14].
Reference: [7] <author> M. R. Garey, D. S. Johnson, B. Simons, and R. E. Tar-jan. </author> <title> Scheduling unit-time tasks with arbitrary release times and deadlines. </title> <journal> SIAM J. Comput., </journal> <volume> 10-2:256-269, </volume> <year> 1981. </year>
Reference-contexts: Several algorithms for scheduling pipelines to maximize throughput are described in [9, 14]. The general problem of scheduling to meet deadlines on identical multiprocessor systems is also N P-hard [5, 10]. However, polynomial algorithms for optimally scheduling tasks with identical processing times on one or two processors exist <ref> [4, 7] </ref>. Our algorithms make use of one of them. We review the traditional flow-shop model in Section 2. The flow shop with recurrence and the periodic flow-shop model are described. <p> The scheduling decision is more complicated if release times and deadlines are arbitrary rational numbers, that is, not multiples of t . Garey et al. <ref> [7] </ref> introduce the concept of forbidden regions during which tasks are not allowed to start execution. The release times of selected tasks are postponed to insert the necessary idle times to make an EEDF schedule optimal.
Reference: [8] <author> D. D. Kandlur, K. G. Shin, and D. Ferrari. </author> <title> Real-time communication in multi-hop networks. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: These subtasks must be scheduled on the corresponding processors to meet the overall deadline. Similarly, the transmissions of real-time messages over an n-hop virtual circuit proposed in <ref> [8] </ref> can be thought of as tasks, each consisting of a chain of n subtasks. Each subtask forwards the message through one hop, modeled as a processor on which this subtask executes. The maximum allowed end-to-end delay gives us the deadline by which the nth subtask must be completed.
Reference: [9] <author> E. Lawler, J. K. Lenstra, C. Martel, B. Simons, and L. Stockmeyer. </author> <title> Pipeline scheduling: A survey. </title> <type> Technical Report RJ 5738, </type> <institution> IBM Research Division, </institution> <address> San Jose, CA, </address> <year> 1987. </year>
Reference-contexts: Consequently, many studies of flow-shop problems were concerned with restrictions of the problem that make it tractable, or focused on enumerative methods and heuristic algorithms. Flow-shop scheduling is similar to scheduling in pipelined multiprocessors. Several algorithms for scheduling pipelines to maximize throughput are described in <ref> [9, 14] </ref>. The general problem of scheduling to meet deadlines on identical multiprocessor systems is also N P-hard [5, 10]. However, polynomial algorithms for optimally scheduling tasks with identical processing times on one or two processors exist [4, 7]. Our algorithms make use of one of them.
Reference: [10] <author> E. L. Lawler, J. K. Lenstra, A. H. G. Rinnooy Kan, and D. B. Shmoys. </author> <title> Sequencing and scheduling: Algorithms and complexity. </title> <type> Technical report, </type> <institution> Centre for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1989. </year>
Reference-contexts: An algorithm is optimal if it always finds a feasible schedule whenever the tasks can be scheduled to meet all deadlines. The problem of scheduling tasks in a flow shop to meet deadlines is N P-hard, except for a few special cases <ref> [5, 10] </ref>. In [1] we described two optimal O (nlogn) algorithms for scheduling tasks that have identical processing times on all processors and tasks that have identical processing times on each of the processors but have different processing times on different processors. <p> The periodic flow shop can be viewed as a special case of the flow shop with recurrence, as well as a generalization of the traditional flow shop. Past efforts in flow-shop scheduling have focused on the minimization of completion time <ref> [3, 6, 10] </ref>. Johnson [3] showed that tasks in a two-processor flow shop can be scheduled to minimize completion time in O (n log n) time. Beyond the two-processor flow shop, however, almost every flow-shop scheduling problem is N P-complete. <p> Flow-shop scheduling is similar to scheduling in pipelined multiprocessors. Several algorithms for scheduling pipelines to maximize throughput are described in [9, 14]. The general problem of scheduling to meet deadlines on identical multiprocessor systems is also N P-hard <ref> [5, 10] </ref>. However, polynomial algorithms for optimally scheduling tasks with identical processing times on one or two processors exist [4, 7]. Our algorithms make use of one of them. We review the traditional flow-shop model in Section 2. The flow shop with recurrence and the periodic flow-shop model are described.
Reference: [11] <author> J. P. Lehoczky and L. Sha. </author> <title> Performance of real-time bus scheduling algorithms. </title> <journal> ACM Performance Evaluation Review, </journal> <year> 1986. </year>
Reference-contexts: An example is a database that is queried before and updated after a specific operation. The periodic flow-shop model is a generalization of both the traditional flow-shop model and the traditional periodic-job model <ref> [11, 13] </ref>. As in the traditional periodic-job model, the periodic job system J to be scheduled in a flow shop consists of n independent periodic jobs; each job consists of a periodic sequence of requests for the same computation. In our previous terms, each request is a task. <p> This generates a feasible schedule where all precedence constraints and all deadlines are met. Given the parameters of J , we can compute the set fu j g and use the existing schedulability bounds given in <ref> [11, 12, 13] </ref> to determine whether there is a set of fffi j g where ffi i &gt; 0 and P m j=1 ffi j 1. The job system J can be feasibly scheduled in the manner described above if such a set of ffi j ' exists.
Reference: [12] <author> J. P. Lehoczky, L. Sha, J. K. Strosnider, and H. Tokuda. </author> <title> Fixed priority scheduling theory for hard real-time systems. </title> <editor> In A. M. Tilborg and G. M. Koob, editors, </editor> <title> Foundations of Real-Time Computing, Scheduling and Resource Management, chapter 1. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: This generates a feasible schedule where all precedence constraints and all deadlines are met. Given the parameters of J , we can compute the set fu j g and use the existing schedulability bounds given in <ref> [11, 12, 13] </ref> to determine whether there is a set of fffi j g where ffi i &gt; 0 and P m j=1 ffi j 1. The job system J can be feasibly scheduled in the manner described above if such a set of ffi j ' exists. <p> Jobs t i1 t i2 p i J 1 5 5 10 Table 5: Set of periodic jobs on a 2-processor flow shop. u 2 = 0:45, respectively. Equation (1) <ref> [12] </ref> gives the least upper bound of the total utilization; a set of jobs whose total utilization is equal to or less than u max (ffi) is surely schedulable by the rate-monotone algorithm to complete within ffip i units after their ready time. u max (ffi) = n ((2ffi) 1=n 1) <p> Every invocation of J 1 is completed at or before time 6.9 units after its release time and therefore before the end of its period. Hence, it meets its deadline. The same holds for J 2 and J 3 . Table 5 shows an example described in <ref> [12] </ref> of a job set that can not always be scheduled so that both jobs meet their deadlines at the end of their period. When the two jobs have the same phase, J 1 has to be interrupted to let J 2 execute and will miss its deadline.
Reference: [13] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard real-time environment. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 20 </volume> <pages> 46-61, </pages> <year> 1973. </year>
Reference-contexts: An example is a database that is queried before and updated after a specific operation. The periodic flow-shop model is a generalization of both the traditional flow-shop model and the traditional periodic-job model <ref> [11, 13] </ref>. As in the traditional periodic-job model, the periodic job system J to be scheduled in a flow shop consists of n independent periodic jobs; each job consists of a periodic sequence of requests for the same computation. In our previous terms, each request is a task. <p> This generates a feasible schedule where all precedence constraints and all deadlines are met. Given the parameters of J , we can compute the set fu j g and use the existing schedulability bounds given in <ref> [11, 12, 13] </ref> to determine whether there is a set of fffi j g where ffi i &gt; 0 and P m j=1 ffi j 1. The job system J can be feasibly scheduled in the manner described above if such a set of ffi j ' exists.
Reference: [14] <author> K. V. Palem and B. Simons. </author> <title> Scheduling time-critical instructions on risc machines. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 270-280, </pages> <year> 1990. </year>
Reference-contexts: Consequently, many studies of flow-shop problems were concerned with restrictions of the problem that make it tractable, or focused on enumerative methods and heuristic algorithms. Flow-shop scheduling is similar to scheduling in pipelined multiprocessors. Several algorithms for scheduling pipelines to maximize throughput are described in <ref> [9, 14] </ref>. The general problem of scheduling to meet deadlines on identical multiprocessor systems is also N P-hard [5, 10]. However, polynomial algorithms for optimally scheduling tasks with identical processing times on one or two processors exist [4, 7]. Our algorithms make use of one of them.
Reference: [15] <author> D. T. Peng and K. G. Shin. </author> <title> A new performance measure for scheduling independent real-time tasks. </title> <type> Technical report, </type> <institution> Department of Electrical Engineering and Computer Science, University of Michigan, </institution> <year> 1989. </year>
Reference: [16] <author> L. Sha, J. P. Lehoczky, and R. Raikumar. </author> <title> Solutions for some practical problems in prioritized preemptive scheduling. </title> <booktitle> In Proceedings of Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1986. </year>
Reference-contexts: The systems in the last paragraph are examples of flow shops. The examples of integrated processor and I/O scheduling given by Sha et al. <ref> [16] </ref> also can be modeled as flow shops or variations of flow shops. A distributed system may contain many classes of tasks. Tasks in each class execute on different processors in the same order, but tasks in different classes execute in different orders.
References-found: 16

