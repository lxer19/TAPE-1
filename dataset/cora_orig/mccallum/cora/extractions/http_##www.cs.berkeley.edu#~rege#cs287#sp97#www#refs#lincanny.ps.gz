URL: http://www.cs.berkeley.edu/~rege/cs287/sp97/www/refs/lincanny.ps.gz
Refering-URL: http://www.cs.berkeley.edu/~rege/cs287/sp97/www/refs/colldet.html
Root-URL: 
Title: A Fast Algorithm for Incremental Distance Calculation  
Author: Ming C. Lin and John F. Canny 
Address: Berkeley, CA 94720  
Affiliation: University of California, Berkeley  
Abstract: A simple and efficient algorithm for finding the closest points between two convex polyhedra is described here. Data from numerous experiments tested on a broad set of convex polyhedra on &lt; 3 show that the running time is roughly constant for finding closest points when nearest points are approximately known and is linear in total number of vertices if no special initialization is done. This algorithm can be used for collision detection, computation of the distance between two polyhedra in three-dimensional space, and other robotics problems. It forms the heart of the motion planning algorithm of [1]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. F. Canny and M. C. Lin. </author> <title> An opportunistic global path planner. </title> <booktitle> Proc. IEEE ICRA, </booktitle> <pages> pages pp. 1554-1559, </pages> <year> 1990. </year>
Reference-contexts: Its also clear that the algorithm must terminate, in a number of steps at most equal to the number of feature pairs. This algorithm is a key part of our general planning algorithm, described in <ref> [1] </ref>. That algorithm creates a one-dimensional roadmap of the free space of a robot by tracing out curves of maximal clearance from obstacles. We use the algorithm in this paper to compute distances and closest points.
Reference: [2] <author> J. W. Boyse. </author> <title> Interference detection among solids and surfaces. </title> <journal> Comm ACM, </journal> <volume> 22(1) </volume> <pages> 3-9, </pages> <year> 1979. </year>
Reference-contexts: From there we can easily compute gradients of the distance function in configuration space, and thereby find the direction of the maximal clearance curves. 2 Related Work Collision detection has a long history. It has been considered in both static and dynamic (moving objects) versions in <ref> [2] </ref>, [3], [4], [5], [6], [7] and [8]. Our work shares with [6], [7], and [8] the calculation and maintenance of closest points during incremental motion.
Reference: [3] <author> M. Orlowski. </author> <title> The computation of the distance between polyhedra in 3-space. </title> <booktitle> Presented SIAM Conf. on Geometric Modeling and Robotics, 1985. Albany, </booktitle> <address> NY. </address>
Reference-contexts: From there we can easily compute gradients of the distance function in configuration space, and thereby find the direction of the maximal clearance curves. 2 Related Work Collision detection has a long history. It has been considered in both static and dynamic (moving objects) versions in [2], <ref> [3] </ref>, [4], [5], [6], [7] and [8]. Our work shares with [6], [7], and [8] the calculation and maintenance of closest points during incremental motion. <p> This is what we would expect, since it seems unlikely that the algorithm would need to visit a given feature more than once. In practice, we believe our algorithm compares very favorably with other algorithms designed for distance computations or collision detection. (Please see <ref> [3] </ref>, [4], [5], [6], [7], [16], [17], [18], and [19].) 8 Conclusion A new algorithm for computing the Euclidean distance between two polyhedra has been presented here. It utilizes the geometry of polyhedra to establish three important applicability criteria for detecting collisions.
Reference: [4] <author> S. A. Cameron and R. K. Culley. </author> <title> Determining the minimum translational distance between two convex polyhedra. </title> <booktitle> Proc. IEEE ICRA, </booktitle> <pages> pages pp. 591-596, </pages> <year> 1986. </year>
Reference-contexts: From there we can easily compute gradients of the distance function in configuration space, and thereby find the direction of the maximal clearance curves. 2 Related Work Collision detection has a long history. It has been considered in both static and dynamic (moving objects) versions in [2], [3], <ref> [4] </ref>, [5], [6], [7] and [8]. Our work shares with [6], [7], and [8] the calculation and maintenance of closest points during incremental motion. <p> This is what we would expect, since it seems unlikely that the algorithm would need to visit a given feature more than once. In practice, we believe our algorithm compares very favorably with other algorithms designed for distance computations or collision detection. (Please see [3], <ref> [4] </ref>, [5], [6], [7], [16], [17], [18], and [19].) 8 Conclusion A new algorithm for computing the Euclidean distance between two polyhedra has been presented here. It utilizes the geometry of polyhedra to establish three important applicability criteria for detecting collisions.
Reference: [5] <author> J. F. Canny. </author> <title> Collision detection for moving polyhedra. </title> <journal> IEEE Trans. PAMI, </journal> <volume> 8:pp. </volume> <pages> 200-209, </pages> <year> 1986. </year>
Reference-contexts: From there we can easily compute gradients of the distance function in configuration space, and thereby find the direction of the maximal clearance curves. 2 Related Work Collision detection has a long history. It has been considered in both static and dynamic (moving objects) versions in [2], [3], [4], <ref> [5] </ref>, [6], [7] and [8]. Our work shares with [6], [7], and [8] the calculation and maintenance of closest points during incremental motion. <p> This is what we would expect, since it seems unlikely that the algorithm would need to visit a given feature more than once. In practice, we believe our algorithm compares very favorably with other algorithms designed for distance computations or collision detection. (Please see [3], [4], <ref> [5] </ref>, [6], [7], [16], [17], [18], and [19].) 8 Conclusion A new algorithm for computing the Euclidean distance between two polyhedra has been presented here. It utilizes the geometry of polyhedra to establish three important applicability criteria for detecting collisions.
Reference: [6] <author> E. G. Gilbert and D. W. Johnson. </author> <title> Distance functions and their application to robot path planning in the presence of obstacles. </title> <journal> IEEE J. Robotics Automat., </journal> <volume> RA-1:pp. </volume> <pages> 21-30, </pages> <year> 1985. </year>
Reference-contexts: It has been considered in both static and dynamic (moving objects) versions in [2], [3], [4], [5], <ref> [6] </ref>, [7] and [8]. Our work shares with [6], [7], and [8] the calculation and maintenance of closest points during incremental motion. But whereas [6], [7], and [8] require linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. <p> It has been considered in both static and dynamic (moving objects) versions in [2], [3], [4], [5], <ref> [6] </ref>, [7] and [8]. Our work shares with [6], [7], and [8] the calculation and maintenance of closest points during incremental motion. But whereas [6], [7], and [8] require linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. <p> It has been considered in both static and dynamic (moving objects) versions in [2], [3], [4], [5], <ref> [6] </ref>, [7] and [8]. Our work shares with [6], [7], and [8] the calculation and maintenance of closest points during incremental motion. But whereas [6], [7], and [8] require linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. <p> The experiment results are briefly summarized in Table 1. A more detailed table of running time with comparison to the other algorithm available now <ref> [6] </ref> is present in [15]. With initialization to the previous closest feature, the subroutine can almost always keep track of the closest features of two given poly-topes at constant time (about 3 to 4 msec). <p> This is what we would expect, since it seems unlikely that the algorithm would need to visit a given feature more than once. In practice, we believe our algorithm compares very favorably with other algorithms designed for distance computations or collision detection. (Please see [3], [4], [5], <ref> [6] </ref>, [7], [16], [17], [18], and [19].) 8 Conclusion A new algorithm for computing the Euclidean distance between two polyhedra has been presented here. It utilizes the geometry of polyhedra to establish three important applicability criteria for detecting collisions.
Reference: [7] <author> E. G. Gilbert and S. M. Hong. </author> <title> A new algorithm for detecting the collision of moving objects. </title> <booktitle> Proc. IEEE ICRA, </booktitle> <pages> pages pp. 8-14, </pages> <year> 1989. </year>
Reference-contexts: It has been considered in both static and dynamic (moving objects) versions in [2], [3], [4], [5], [6], <ref> [7] </ref> and [8]. Our work shares with [6], [7], and [8] the calculation and maintenance of closest points during incremental motion. But whereas [6], [7], and [8] require linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. <p> It has been considered in both static and dynamic (moving objects) versions in [2], [3], [4], [5], [6], <ref> [7] </ref> and [8]. Our work shares with [6], [7], and [8] the calculation and maintenance of closest points during incremental motion. But whereas [6], [7], and [8] require linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. <p> It has been considered in both static and dynamic (moving objects) versions in [2], [3], [4], [5], [6], <ref> [7] </ref> and [8]. Our work shares with [6], [7], and [8] the calculation and maintenance of closest points during incremental motion. But whereas [6], [7], and [8] require linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. In this aspect, it recalls work in [9] and [10] where local applicability constraints are used to check when two features can come into contact. <p> This is what we would expect, since it seems unlikely that the algorithm would need to visit a given feature more than once. In practice, we believe our algorithm compares very favorably with other algorithms designed for distance computations or collision detection. (Please see [3], [4], [5], [6], <ref> [7] </ref>, [16], [17], [18], and [19].) 8 Conclusion A new algorithm for computing the Euclidean distance between two polyhedra has been presented here. It utilizes the geometry of polyhedra to establish three important applicability criteria for detecting collisions.
Reference: [8] <author> E. G. Gilbert, D. W. Johnson, and S. S. Keerthi. </author> <title> A fast procedure for computing the distance between objects in three-dimensional space. </title> <journal> IEEE J. Robotics and Automation, </journal> <volume> vol RA-4:pp. </volume> <pages> 193-203, </pages> <year> 1988. </year>
Reference-contexts: It has been considered in both static and dynamic (moving objects) versions in [2], [3], [4], [5], [6], [7] and <ref> [8] </ref>. Our work shares with [6], [7], and [8] the calculation and maintenance of closest points during incremental motion. But whereas [6], [7], and [8] require linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. <p> It has been considered in both static and dynamic (moving objects) versions in [2], [3], [4], [5], [6], [7] and <ref> [8] </ref>. Our work shares with [6], [7], and [8] the calculation and maintenance of closest points during incremental motion. But whereas [6], [7], and [8] require linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. <p> It has been considered in both static and dynamic (moving objects) versions in [2], [3], [4], [5], [6], [7] and <ref> [8] </ref>. Our work shares with [6], [7], and [8] the calculation and maintenance of closest points during incremental motion. But whereas [6], [7], and [8] require linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. In this aspect, it recalls work in [9] and [10] where local applicability constraints are used to check when two features can come into contact.
Reference: [9] <author> T. Lozano-Perez and M. Wesley. </author> <title> An algorithm for planning collision-free paths among polyhedral obstacles. </title> <journal> Comm. ACM, </journal> <volume> 22(10):pp. </volume> <pages> 560-570, </pages> <year> 1979. </year>
Reference-contexts: But whereas [6], [7], and [8] require linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. In this aspect, it recalls work in <ref> [9] </ref> and [10] where local applicability constraints are used to check when two features can come into contact. A fact that has often been overlooked is that collision detection for convex polyhedra can be done in 1 linear time in the worst case.
Reference: [10] <author> B. R. Donald. </author> <title> Motion Planning with Six Degrees of Freedom. </title> <type> PhD thesis, </type> <institution> MIT Artificial Intelligence Lab., </institution> <year> 1984. </year>
Reference-contexts: But whereas [6], [7], and [8] require linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. In this aspect, it recalls work in [9] and <ref> [10] </ref> where local applicability constraints are used to check when two features can come into contact. A fact that has often been overlooked is that collision detection for convex polyhedra can be done in 1 linear time in the worst case. The proof is by reduc-tion to linear programming.
Reference: [11] <author> N. Megiddo. </author> <title> Linear-time algorithms for linear programming in r 3 and related problems. </title> <journal> SIAM J. Computing, </journal> <volume> 12:pp. </volume> <pages> 759-776, </pages> <year> 1983. </year>
Reference-contexts: Megiddo and Dyers work <ref> [11] </ref>, [12], [13] showed that linear programming is solvable in linear time for any fixed number of variables. More recent work [14] has shown that linear time linear programming algorithms are quite practical for a small number of variables.
Reference: [12] <author> N. Megiddo. </author> <title> Linear programming in linear time when the dimension is fixed. </title> <journal> Jour. ACM, </journal> <volume> 31:pp. </volume> <pages> 114-127, </pages> <year> 1984. </year>
Reference-contexts: Megiddo and Dyers work [11], <ref> [12] </ref>, [13] showed that linear programming is solvable in linear time for any fixed number of variables. More recent work [14] has shown that linear time linear programming algorithms are quite practical for a small number of variables.
Reference: [13] <author> M. E. Dyer. </author> <title> Linear algorithms for two and three-variable linear programs. </title> <journal> SIAM J. on Computing, </journal> <volume> 13:pp. </volume> <pages> 31-45, </pages> <year> 1984. </year>
Reference-contexts: Megiddo and Dyers work [11], [12], <ref> [13] </ref> showed that linear programming is solvable in linear time for any fixed number of variables. More recent work [14] has shown that linear time linear programming algorithms are quite practical for a small number of variables.
Reference: [14] <author> R. Seidel. </author> <title> Linear programming and convex hulls made easy. </title> <booktitle> In Proc. 6th Ann. ACM Conf. on Computational Geometry, </booktitle> <pages> pages 211-215, </pages> <address> Berke-ley, California, </address> <year> 1990. </year>
Reference-contexts: Megiddo and Dyers work [11], [12], [13] showed that linear programming is solvable in linear time for any fixed number of variables. More recent work <ref> [14] </ref> has shown that linear time linear programming algorithms are quite practical for a small number of variables. The algorithm of [14] has been implemented, and seems fast in practice. 3 Ob ject Representations and Basic Definitions Each object is represented as a convex polyhedron, or a union of convex polyhedra. <p> Megiddo and Dyers work [11], [12], [13] showed that linear programming is solvable in linear time for any fixed number of variables. More recent work <ref> [14] </ref> has shown that linear time linear programming algorithms are quite practical for a small number of variables. The algorithm of [14] has been implemented, and seems fast in practice. 3 Ob ject Representations and Basic Definitions Each object is represented as a convex polyhedron, or a union of convex polyhedra. Many real-world objects that have curved surfaces are represented by polyhedral approximations.
Reference: [15] <author> J. F. Canny and M. C. Lin. </author> <title> Local methods for fast computation of distance functions. In Preparation, </title> <booktitle> 1990. </booktitle> <address> U. C. Berkeley. </address>
Reference-contexts: The details for computing these nearest points are rather trivial, thus omitted here. (Please refer to <ref> [15] </ref>, if necessary.) (1) If the features are a pair of vertices, then they both have to satisfy the applicability conditions imposed by each other, in order for them to be the closest features. <p> If the two objects are just touching or intersecting, it gives an error message to indicate collision and terminates the procedure with the contacting-feature pair as returned values. The proof of algorithm's completeness can be found in <ref> [15] </ref>. 7 Numerical Experiments The algorithm described in this paper has been implemented in Lucid Common Lisp. The input data are a random pair of features from two given objects in three dimensional space. <p> The experiment results are briefly summarized in Table 1. A more detailed table of running time with comparison to the other algorithm available now [6] is present in <ref> [15] </ref>. With initialization to the previous closest feature, the subroutine can almost always keep track of the closest features of two given poly-topes at constant time (about 3 to 4 msec). Without initialization, the algorithm runs in average time not worse than linear in the total number of vertices.
Reference: [16] <author> E. G. Gilbert and C. P. Foo. </author> <title> Computing the distance between general convex objects in three dimensional space. </title> <journal> IEEE Trans. Robotics Automat., </journal> <volume> 6(1), </volume> <year> 1990. </year>
Reference-contexts: This is what we would expect, since it seems unlikely that the algorithm would need to visit a given feature more than once. In practice, we believe our algorithm compares very favorably with other algorithms designed for distance computations or collision detection. (Please see [3], [4], [5], [6], [7], <ref> [16] </ref>, [17], [18], and [19].) 8 Conclusion A new algorithm for computing the Euclidean distance between two polyhedra has been presented here. It utilizes the geometry of polyhedra to establish three important applicability criteria for detecting collisions.
Reference: [17] <author> D. P. Dobkin and D. G. Kirkpatrick. </author> <title> A linear algorithm for determining the separation of convex polyhedra. </title> <journal> J. Algorithms, </journal> <volume> 6:pp. </volume> <pages> 381-392, </pages> <year> 1985. </year>
Reference-contexts: In practice, we believe our algorithm compares very favorably with other algorithms designed for distance computations or collision detection. (Please see [3], [4], [5], [6], [7], [16], <ref> [17] </ref>, [18], and [19].) 8 Conclusion A new algorithm for computing the Euclidean distance between two polyhedra has been presented here. It utilizes the geometry of polyhedra to establish three important applicability criteria for detecting collisions.
Reference: [18] <author> W. E. </author> <title> Red. Minimum distances for robot task simulation. </title> <journal> Robotics, </journal> <volume> 1:pp. </volume> <pages> 231-238, </pages> <year> 1983. </year>
Reference-contexts: In practice, we believe our algorithm compares very favorably with other algorithms designed for distance computations or collision detection. (Please see [3], [4], [5], [6], [7], [16], [17], <ref> [18] </ref>, and [19].) 8 Conclusion A new algorithm for computing the Euclidean distance between two polyhedra has been presented here. It utilizes the geometry of polyhedra to establish three important applicability criteria for detecting collisions.
Reference: [19] <author> P. Wolfe. </author> <title> Finding the nearest points in a polytope. </title> <journal> Math. Programming, </journal> <volume> 11:pp. </volume> <pages> 128-149, </pages> <year> 1976. </year>
Reference-contexts: In practice, we believe our algorithm compares very favorably with other algorithms designed for distance computations or collision detection. (Please see [3], [4], [5], [6], [7], [16], [17], [18], and <ref> [19] </ref>.) 8 Conclusion A new algorithm for computing the Euclidean distance between two polyhedra has been presented here. It utilizes the geometry of polyhedra to establish three important applicability criteria for detecting collisions.
References-found: 19

