URL: ftp://ftp.cs.umd.edu/pub/realtime/rtss93-TCEL.ps.gz
Refering-URL: http://www.cs.umd.edu/projects/TimeWare/TimeWare-index-no-abs.html
Root-URL: 
Email: rich@cs.umd.edu sshong@cs.umd.edu  
Title: Semantics-Based Compiler Transformations for Enhanced Schedulability  
Author: Richard Gerber and Seongsoo Hong 
Address: College Park, MD 20742  
Affiliation: Department of Computer Science University of Maryland  
Date: 232-242, December, 1993  
Note: In Proc. of 14th IEEE Real-Time Systems Symposium, pp.  
Abstract: We present TCEL (Time-Constrained Event Language), whose timing semantics is based solely on the constrained relationships between observable events. Using this semantics, the unobservable code can be automatically moved to convert an unschedulable task set into a schedulable one. We illustrate this by an application of program-slicing, which we use to automatically tune control-domain systems driven by rate-monotonic scheduling. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Allen, B. Rosen, and K. Zadeck. </author> <title> the forthcoming Optimization in Compilers. </title> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1992. </year>
Reference-contexts: The first assumption allows us to avoid interprocedural slicing [8]. The next two assumptions simplify problems induced by spurious data dependences such as anti-dependences and output dependences <ref> [1] </ref>. However, we can easily alleviate the restrictions, relying on dependence breaking transformations, such as scalar expansion [1]. Static single assignment is one such transformation. <p> The first assumption allows us to avoid interprocedural slicing [8]. The next two assumptions simplify problems induced by spurious data dependences such as anti-dependences and output dependences <ref> [1] </ref>. However, we can easily alleviate the restrictions, relying on dependence breaking transformations, such as scalar expansion [1]. Static single assignment is one such transformation. A slice of program P with respect to program point p and variable v consists of P 's statements and control predicates that may affect the value of v at point p.
Reference: [2] <author> R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and F. Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and systems, </journal> <volume> 9 </volume> <pages> 319-345, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: For the sake of brevity, we assume the following: * Function calls are inlined. * Loops are unrolled. * The intermediate code of programs is translated into static single assignment form <ref> [2, 7] </ref>. The first assumption allows us to avoid interprocedural slicing [8]. The next two assumptions simplify problems induced by spurious data dependences such as anti-dependences and output dependences [1]. However, we can easily alleviate the restrictions, relying on dependence breaking transformations, such as scalar expansion [1].
Reference: [3] <author> B. Dasarathy. </author> <title> Timing constraints of real-time systems: Constructs for expressing them, method for validating them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(1) </volume> <pages> 80-86, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: 1 Introduction The construction of a real-time system involves reconciling two "adversersial" factors: the system's real-time specification and the timing characteristics of its hardware platform. Specification-based properties "come from above," and establish constraints between occurrences of events <ref> [3, 10] </ref>. An example is the robot arm must receive a next-position update every 10 ms. Such a constraint arises from the system's requirements, or from a detailed analysis of the application environment.
Reference: [4] <author> J. Ferrante and K. Ottenstein. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and systems, </journal> <volume> 9 </volume> <pages> 319-345, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Thus the computation of slices is based on data dependence as well as control dependence. In this regard, using a program dependence graph <ref> [4, 8, 19] </ref> is ideal, since it represents both types of dependences in a single graph. The program dependence graph is defined as follows.
Reference: [5] <author> J. Fisher. </author> <title> Trace scheduling: A technique for global microcode compaction. </title> <journal> IEEE Transactions on Computer, </journal> <volume> 30 </volume> <pages> 478-490, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: Since these timing constraints may conflict with the task's execution time, it may appear to be inherently unschedulable. Hence the objective is to automatically achieve "internal" consistency between real-time requirements and elapsed execution time. Our approach is to use instruction-scheduling techniques <ref> [5] </ref>, with which our compiler moves code from blocks constrained by tight deadlines into blocks with sufficient slack. In this paper we address a more aggressive goal - inter-task transformations for schedulability.
Reference: [6] <author> P. Gopinath and R. Gupta. </author> <title> Applying compiler techniques to scheduling in real-time systems. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 247-256. </pages> <publisher> IEEE, </publisher> <month> De-cember </month> <year> 1990. </year>
Reference-contexts: There have been several other compiler-based approaches to real-time programming. In [22] a schedu-lability analyzer is embedded in a compiler to extract and analyze timing information from the assembly-language output. In <ref> [6] </ref> a compiler classifies application code on the basis of its predictability and mono-tonicity, and creates partitions which have a higher degree of adaptability. In [18] a partial evaluator is applied to a source program, which produces residual code that is both more optimized and more deterministic. <p> Unlike the semantics for TCEL, however, the execution times of non-time-critical statements are not explicitly decoupled from timing constraints imposed on the events. Thus, the applicability of some transformations may be unnecessarily restricted. The compiler-assisted scheduling approach in <ref> [6] </ref> is also similar to this work, in that the compiler creates code partitions to mainly support run-time adaptability of a real-time scheduler. However, the partitioning is guided by "hints" supplied by the programmer. Further, it is limited to code segment breaking.
Reference: [7] <author> S. Hong and R. Gerber. </author> <title> Compiling real-time programs into schedulable code. </title> <booktitle> In Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation. </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year> <journal> SIGPLAN Notices, </journal> <volume> 28(6) </volume> <pages> 166-176. </pages>
Reference-contexts: In performing these transformations, the TCEL compiler uses the observable events as "semantic markers," which establish boundaries of code decomposition, and constrain the places where code can be moved. In previous work we show how to use code-motion optimizations to resolve conflicts within single tasks <ref> [7] </ref>. These conflicts can arise when tasks have nested constraints; e.g., when deadlines are tighter than periods, or when there are inserted delay statements. Since these timing constraints may conflict with the task's execution time, it may appear to be inherently unschedulable. <p> For the sake of brevity, we assume the following: * Function calls are inlined. * Loops are unrolled. * The intermediate code of programs is translated into static single assignment form <ref> [2, 7] </ref>. The first assumption allows us to avoid interprocedural slicing [8]. The next two assumptions simplify problems induced by spurious data dependences such as anti-dependences and output dependences [1]. However, we can easily alleviate the restrictions, relying on dependence breaking transformations, such as scalar expansion [1]. <p> In [17] time-critical statements (or events) are assumed in the underlying programming language, and used for developing the notion of safe real-time code transformations. Based on this notion of safety, a large number of conventional code transformations are examined, and then classified for application in real-time programming. Finally, in <ref> [7] </ref> a code scheduling algorithm is presented, which is used to achieve the timing consistency of sequential real-time programs. Each of these efforts addresses a different problem associated with real-time programming.
Reference: [8] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graph. </title> <journal> ACM Transactions on Programming Languages and systems, </journal> <volume> 12 </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: For the sake of brevity, we assume the following: * Function calls are inlined. * Loops are unrolled. * The intermediate code of programs is translated into static single assignment form [2, 7]. The first assumption allows us to avoid interprocedural slicing <ref> [8] </ref>. The next two assumptions simplify problems induced by spurious data dependences such as anti-dependences and output dependences [1]. However, we can easily alleviate the restrictions, relying on dependence breaking transformations, such as scalar expansion [1]. Static single assignment is one such transformation. <p> Thus the computation of slices is based on data dependence as well as control dependence. In this regard, using a program dependence graph <ref> [4, 8, 19] </ref> is ideal, since it represents both types of dependences in a single graph. The program dependence graph is defined as follows.
Reference: [9] <author> Y. Ishikawa, H. Tokuda, and C. Mercer. </author> <title> Object-oriented real-time language design: Constructs for timing constraints. </title> <booktitle> In Proceedings of OOPSLA-90, </booktitle> <pages> pages 289-298, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: As we show in this paper, it is precisely the TCEL semantics which makes the compiler transformations possible. The TCEL Language. TCEL contains constructs quite similar to those developed in other experimental languages <ref> [9, 11, 13, 15, 18, 26] </ref>. In these approaches, however, timing constraints are established between blocks of code. The TCEL semantics, on the other hand, establishes constraints between the observable events within the code.
Reference: [10] <author> F. Jahanian and Al Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(9) </volume> <pages> 890-904, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: 1 Introduction The construction of a real-time system involves reconciling two "adversersial" factors: the system's real-time specification and the timing characteristics of its hardware platform. Specification-based properties "come from above," and establish constraints between occurrences of events <ref> [3, 10] </ref>. An example is the robot arm must receive a next-position update every 10 ms. Such a constraint arises from the system's requirements, or from a detailed analysis of the application environment.
Reference: [11] <author> E. Kligerman and A. Stoyenko. </author> <title> Real-time Euclid: A language for reliable real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12 </volume> <pages> 941-949, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: As we show in this paper, it is precisely the TCEL semantics which makes the compiler transformations possible. The TCEL Language. TCEL contains constructs quite similar to those developed in other experimental languages <ref> [9, 11, 13, 15, 18, 26] </ref>. In these approaches, however, timing constraints are established between blocks of code. The TCEL semantics, on the other hand, establishes constraints between the observable events within the code.
Reference: [12] <author> J. Krause. </author> <title> GN&C domain modeling: Functionality requirements for fixed rate algorithms. </title> <type> Technical Report (DRAFT) version 0.2, </type> <institution> Honeywell Systems and Research Center, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: In this section we present the overview of the transformation algorithm, while in the next section we provide a more detailed development of program-slicing. 3.1 Characterization of Control Software One of the major properties of control algorithms is that computations fit a fixed-rate algorithm paradigm <ref> [12] </ref>. Fixed-rate algorithms are those which execute repetitively with fixed periods. During each period, the physical world measurement data is sampled, and then actuator commands are computed. Meanwhile, a set of states is updated, based on current states and sampled data.
Reference: [13] <author> I. Lee and V. Gehlot. </author> <title> Language constructs for real-time programming. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 57-66. </pages> <publisher> IEEE, </publisher> <year> 1985. </year>
Reference-contexts: As we show in this paper, it is precisely the TCEL semantics which makes the compiler transformations possible. The TCEL Language. TCEL contains constructs quite similar to those developed in other experimental languages <ref> [9, 11, 13, 15, 18, 26] </ref>. In these approaches, however, timing constraints are established between blocks of code. The TCEL semantics, on the other hand, establishes constraints between the observable events within the code. <p> We end the section (and the paper) with remarks on our future work. 2 Overview of TCEL In this section we present two of TCEL's constructs to denote timing constraints within a program. Both constructs are syntactic descendents of the temporal scope, introduced in <ref> [13] </ref>. However, as we have stated, our semantics is quite different, in that it relies on constrained relationships between observable events.
Reference: [14] <author> J. Lehoczky, L. Sha, and Y. Ding. </author> <title> The rate monotonic scheduling algorithm: Exact characterization and average case behavior. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 166-171. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: Whereas 1 The operator ";" denotes sequential composition of code fragments. there has been significant amount of research on an-alytical characterization of the algorithm <ref> [14] </ref> and its practical application to various problems [21], there has been little work on the automatic translation of unschedulable task sets into schedulable ones. However, complex real-time system development can be supported by such an automatic scheme. <p> In this setting, most of the task tuning must be repeated if the task set is determined to be unschedulable. Of course, the situation is even worse if the code is rehosted. Our task transformation approach is motivated by the exact (necessary and sufficient) schedulability test in <ref> [14] </ref>, which is based on the critical instant analysis. A critical instant for a task occurs whenever the task is initiated simultaneously with all higher priority tasks [16]. Let T i and C i be the period and the worst case computation time of task t i , respectively.
Reference: [15] <author> K. J. Lin and S. Natarajan. </author> <title> Expressing and maintaining timing constraints in FLEX. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium. IEEE, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: As we show in this paper, it is precisely the TCEL semantics which makes the compiler transformations possible. The TCEL Language. TCEL contains constructs quite similar to those developed in other experimental languages <ref> [9, 11, 13, 15, 18, 26] </ref>. In these approaches, however, timing constraints are established between blocks of code. The TCEL semantics, on the other hand, establishes constraints between the observable events within the code.
Reference: [16] <author> C. Liu and J. Layland. </author> <title> Scheduling algorithm for multiprogramming in a hard real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: In this paper we address a more aggressive goal - inter-task transformations for schedulability. To help attack this problem, we have developed a compiler decomposition technique to support control-domain programs under rate-monotonic scheduling <ref> [16] </ref>. <p> Our task transformation approach is motivated by the exact (necessary and sufficient) schedulability test in [14], which is based on the critical instant analysis. A critical instant for a task occurs whenever the task is initiated simultaneously with all higher priority tasks <ref> [16] </ref>. Let T i and C i be the period and the worst case computation time of task t i , respectively. Assume that the t i 's are numbered in the increasing order of their T i 's. <p> = F2 (state); [0.9ms,1.35ms] L5: t3 = F3 (data); [0.9ms,1.35ms] L6: t4 = F4 (data); [0.9ms,1.35ms] L7: cmd = t1 fl ( t3 + t4 ); [0.09ms,0.1ms] L8: send (Actuator, cmd); [0.2ms,0.5ms] L9: state = t1 fl ( t2 + t3 ); [0.11ms,0.15ms] g 0:83 = 2 (2 1=2 1) <ref> [16] </ref>.
Reference: [17] <author> T. Marlowe and S. Masticola. </author> <title> Safe optimization for hard real-time programming. </title> <booktitle> In Second International Conference on Systems Integration, </booktitle> <pages> pages 438-446, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: In [6] a compiler classifies application code on the basis of its predictability and mono-tonicity, and creates partitions which have a higher degree of adaptability. In [18] a partial evaluator is applied to a source program, which produces residual code that is both more optimized and more deterministic. In <ref> [17] </ref> time-critical statements (or events) are assumed in the underlying programming language, and used for developing the notion of safe real-time code transformations. Based on this notion of safety, a large number of conventional code transformations are examined, and then classified for application in real-time programming. <p> Finally, in [7] a code scheduling algorithm is presented, which is used to achieve the timing consistency of sequential real-time programs. Each of these efforts addresses a different problem associated with real-time programming. The work in <ref> [17] </ref> comes closest to this work, in that the timing behavior of real-time programs is described in terms of events or the executions of time-critical statements. Unlike the semantics for TCEL, however, the execution times of non-time-critical statements are not explicitly decoupled from timing constraints imposed on the events.
Reference: [18] <author> V. Nirkhe. </author> <title> Application of Partial Evaluation to Hard Real-Time Programming. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Maryland at College Park, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: As we show in this paper, it is precisely the TCEL semantics which makes the compiler transformations possible. The TCEL Language. TCEL contains constructs quite similar to those developed in other experimental languages <ref> [9, 11, 13, 15, 18, 26] </ref>. In these approaches, however, timing constraints are established between blocks of code. The TCEL semantics, on the other hand, establishes constraints between the observable events within the code. <p> In [22] a schedu-lability analyzer is embedded in a compiler to extract and analyze timing information from the assembly-language output. In [6] a compiler classifies application code on the basis of its predictability and mono-tonicity, and creates partitions which have a higher degree of adaptability. In <ref> [18] </ref> a partial evaluator is applied to a source program, which produces residual code that is both more optimized and more deterministic. In [17] time-critical statements (or events) are assumed in the underlying programming language, and used for developing the notion of safe real-time code transformations. <p> However, the partitioning is guided by "hints" supplied by the programmer. Further, it is limited to code segment breaking. Our transformation, on the other hand, uses static dataflow analysis to isolate intertwined threads of control. Also, the partial evaluator in <ref> [18] </ref> is tangentially related to program slicing, in that both techniques specialize programs. However, our approach also decomposes programs producing multiple specialized versions for different variables and inputs. In this manner, the program slicer can adapt to a given scheduling technique.
Reference: [19] <author> K. Ottenstein and L. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: Many factors make this the case, among which are intertwined threads of control, nested control structures, complex data dependences between statements, procedure calls in the task code, etc. To cope with these problems in a systematic manner, we harness a novel application of program slicing <ref> [19, 24, 25] </ref>. For the sake of brevity, we assume the following: * Function calls are inlined. * Loops are unrolled. * The intermediate code of programs is translated into static single assignment form [2, 7]. The first assumption allows us to avoid interprocedural slicing [8]. <p> Thus the computation of slices is based on data dependence as well as control dependence. In this regard, using a program dependence graph <ref> [4, 8, 19] </ref> is ideal, since it represents both types of dependences in a single graph. The program dependence graph is defined as follows.
Reference: [20] <author> C. Park and A. Shaw. </author> <title> Experimenting with a program timing tool based on source-level timing schema. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 72-81. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1990. </year>
Reference-contexts: These times are generated by a timing analysis tool, such as those found in <ref> [20, 27] </ref>.
Reference: [21] <author> L. Sha, J. Lehoczky, and R. Rajkumar. </author> <title> Solutions for some practical problems in prioritized preemptive scheduling. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 181-191. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1986. </year>
Reference-contexts: To help attack this problem, we have developed a compiler decomposition technique to support control-domain programs under rate-monotonic scheduling [16]. In particular, our technique can be viewed as a safe, automatic way to use deadline postponement <ref> [21] </ref>. (We explain deadline postponement in Section 3.3.) The framework consists of the following ingredients: (1) An algorithm which uses standard rate-monotonic analysis to find unschedulable tasks, and determines the amount that they must be transformed. (2) A program slicer, which decomposes a task and isolates the component that can have <p> Whereas 1 The operator ";" denotes sequential composition of code fragments. there has been significant amount of research on an-alytical characterization of the algorithm [14] and its practical application to various problems <ref> [21] </ref>, there has been little work on the automatic translation of unschedulable task sets into schedulable ones. However, complex real-time system development can be supported by such an automatic scheme. For example, consider a task set which is derived from a real-time application. <p> This can be done by postponing the deadline (i.e. expanding the period) of t 3 , as suggested by Sha et al. in <ref> [21] </ref>. The application of deadline postponement to task t can be described with the following steps: Step 1 Task t is duplicated into two tasks t x and t y .
Reference: [22] <author> A. Stoyenko. </author> <title> A schedulability analyzer for real-time Eu-clid. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 218-227. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1987. </year>
Reference-contexts: There have been several other compiler-based approaches to real-time programming. In <ref> [22] </ref> a schedu-lability analyzer is embedded in a compiler to extract and analyze timing information from the assembly-language output. In [6] a compiler classifies application code on the basis of its predictability and mono-tonicity, and creates partitions which have a higher degree of adaptability.
Reference: [23] <author> K. Tindell. </author> <title> Using offset information to analyse static priority pre-emptively scheduled task sets. </title> <type> Technical Report YCS 182 (1992), </type> <institution> Department of Computer Science, University of York, </institution> <address> England, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: This, in turn, may enhance the schedulability of the entire task set. In the same manner, our semantics-based compiler transformations will be even more beneficial for schedulers that handle periodic tasks with inserted offsets <ref> [23] </ref>.
Reference: [24] <author> G. Venkatesh. </author> <title> The semantic approach to program slicing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Many factors make this the case, among which are intertwined threads of control, nested control structures, complex data dependences between statements, procedure calls in the task code, etc. To cope with these problems in a systematic manner, we harness a novel application of program slicing <ref> [19, 24, 25] </ref>. For the sake of brevity, we assume the following: * Function calls are inlined. * Loops are unrolled. * The intermediate code of programs is translated into static single assignment form [2, 7]. The first assumption allows us to avoid interprocedural slicing [8].
Reference: [25] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10 </volume> <pages> 352-357, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Many factors make this the case, among which are intertwined threads of control, nested control structures, complex data dependences between statements, procedure calls in the task code, etc. To cope with these problems in a systematic manner, we harness a novel application of program slicing <ref> [19, 24, 25] </ref>. For the sake of brevity, we assume the following: * Function calls are inlined. * Loops are unrolled. * The intermediate code of programs is translated into static single assignment form [2, 7]. The first assumption allows us to avoid interprocedural slicing [8].
Reference: [26] <author> V. Wolfe, S. Davidson, and I. Lee. RTC: </author> <title> Language support for real-time concurrency. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 43-52. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1991. </year>
Reference-contexts: As we show in this paper, it is precisely the TCEL semantics which makes the compiler transformations possible. The TCEL Language. TCEL contains constructs quite similar to those developed in other experimental languages <ref> [9, 11, 13, 15, 18, 26] </ref>. In these approaches, however, timing constraints are established between blocks of code. The TCEL semantics, on the other hand, establishes constraints between the observable events within the code.
Reference: [27] <author> N. Zhang, A. Burns, and M. Nicholson. </author> <title> Pipelined processors and worst case execution times. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 5(4), </volume> <month> October </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: These times are generated by a timing analysis tool, such as those found in <ref> [20, 27] </ref>.
References-found: 27

