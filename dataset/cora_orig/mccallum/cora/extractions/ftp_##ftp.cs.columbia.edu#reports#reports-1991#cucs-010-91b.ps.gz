URL: ftp://ftp.cs.columbia.edu/reports/reports-1991/cucs-010-91b.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1991.html
Root-URL: http://www.cs.columbia.edu
Title: approach is to exploit the object-oriented paradigm in distribution, i.e., impose object-oriented decomposition on the
Note: The second  
Abstract: Preface Over a year ago, the Programming Systems Group at Columbia University (also known as ``frodo''), headed by Prof. Gail Kaiser, decided to upgrade MARVEL, a prototype process-based software development environment, from a single-task single-user system, into a multi-tasking multi-user system. After three years of research in programming environments, the notion of process programming was well understood in the context of a single user, and the group was ready to look into the problems and challenges of synchronizing multiple users while providing mechanisms for cooperation among them. Similar efforts in the general area of design environments are currently being made in the database and software-engineering research communities. Upgrading a single-task system into a multi-tasking system is apparently a hard task that requires both a major redesign and implementation of existing modules, and creation of new modules. In particular, the issue of modeling, managing, and controlling the access to data is crucial and much more complicated in the context of multiple users, especially when existing technologies from traditional databases are unsuitable. This thesis covers over a year of research work in an attempt to provide models, specifications and implementation for data management in such environments. Two philosophical approaches with respect to system design are taken here. The first one exploits the principle of ``componentization''. According to this principle, a complex system is built from independent, loosely-connected and replaceable components. As a result, these components must have broad interfaces and must support a variety of different policies employed by components with the same functionality (i.e., components that provide the same services in different ways). This is in contrast to the monolithic approach in which components are tightly-connected and interdependent. In particular, when the components interconnect in a layered fashion, the higher the layer is, the more semantics it has about the domain. In programming environments, the highest layer is the human programmer, the middle layer is the environment itself, with limited knowledge, and the lowest layers that support the environment have minimal semantic knowledge about the domain. The various layers should have great flexibility in implementing their functionality. This is the intuition for the first model presented in chapter 2 and its implementation in MARVEL, presented in 6. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ahlsen et al. </author> <title> An Architecture for Object Management in OIS. </title> <journal> In ACM Transactions on Office Information Systems. </journal> <month> July, </month> <year> 1984. </year>
Reference-contexts: Overview While distributed relational databases have reached maturity (e.g., R* [40] and INGRES* [39], the distributed extensions of R [4] and INGRES [38] respectively), the research on distributed OODBs is still in its infancy. (Examples of existing prototypes include distributed versions of ORION [25] and AVANCE <ref> [1] </ref>.) As mentioned in section 1, the main problem with distributing an OODB is with the high inter-connection among many small objects. In the context of data partitioning, the problem is how to partition the data effectively and still maintain high degrees of distribution, location-transparency and high visibility.
Reference: [2] <author> A. Albano, L. Cardelli, and R. Orsini. </author> <title> Galileo: A Strongly Typed, Interactive Conceptual Language. </title> <journal> In ACM Transactions on Database Systems, </journal> <pages> pages 230-260. </pages> <year> 1985. </year>
Reference-contexts: It is intended to provide the supporting platform for the implementation of persistent programming languages, such as Napier88 [29] and Galileo <ref> [2] </ref>. 69 ObServer ( [16], [36], [17]) is an object server specifically designed for SDEs. It assumes a distributed environment, and includes a rich set of locks including non-restrictive locks and notification-modes that support cooperation.
Reference: [3] <author> Neil Arora. </author> <title> Evaluation of ObServer for implementation in Marvel. December, </title> <institution> 1989 Columbia University. </institution>
Reference-contexts: ObServer does not define a data-model, which is an advantage as a storage manager, from DHOMS point of view. However, the support for transactions at the data management level violates the separation between data and process management. Another drawback of ObServer (based on <ref> [3] </ref>) is that there is no support for single-level store, and the client must know how and where to store objects. EXODUS [35] is an extensible DBMS that supports development of application-specific DBMS, and resembles DHOMS in the sense that it is not restricted to specific policies.
Reference: [4] <author> M. M. Astrahan et al. </author> <title> System R: A Relational Approach to Database Management. </title> <journal> In ACM Transactions on Database Systems. </journal> <year> 1976. </year>
Reference-contexts: Utilize local resources. This is common to all distributed systems. 2. Provide a platform for cooperation. This will be clarified later. 3.2. Overview While distributed relational databases have reached maturity (e.g., R* [40] and INGRES* [39], the distributed extensions of R <ref> [4] </ref> and INGRES [38] respectively), the research on distributed OODBs is still in its infancy. (Examples of existing prototypes include distributed versions of ORION [25] and AVANCE [1].) As mentioned in section 1, the main problem with distributing an OODB is with the high inter-connection among many small objects.
Reference: [5] <author> Morris Bach. </author> <title> The Design of the Unix Operating System. </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: Rule Context Switching To address the second problem it was necessary to to build some kind of context-switch mechanism in the rule engine. Context switch in multi-tasking operating systems (OS) <ref> [5] </ref> is the mechanism that enables multiple tasks to be interleaved in their execution to create the illusion that they are being executed concurrently. The basic idea is to maintain for each task a context that holds its current state. <p> Rule-chain context switching is analogous to OS context switching <ref> [5] </ref>. A rule-chain is initiated by a user-invoked rule. When this rule arrives at RP, RP creates a context that essentially consists of a special data-structure (the rule-stack), and some additional state information.
Reference: [6] <author> Jay Banerjee, Haong-Tai Chou, Jorge F. Garza, Won Kim, Darrell Woelk, Nat Ballou, and Hyoung-Joo Kim. </author> <title> Data Model Issues for Object-Oriented Applications. </title> <journal> ACM Transactions on Office Information Systems 5(1) </journal> <pages> 3-26, </pages> <month> January, </month> <year> 1987. </year>
Reference-contexts: Section 7.1 presents work on OODBMSs, i.e., systems that support an object-oriented data model and provide all the required functionality defined in section 1. Section 7.2 presents work on systems and models that provide partial functionality such as storage, object and transaction management. 7.1. OODBMS ORION ( <ref> [6] </ref>, [24], [18] [25]), was originally developed as a LISP-machine system that integrated object-oriented programming with a database system by extending the language to include primitives that manipulate its object-oriented database. It was later extended into a generic OODBMS, and was ported to UNIX.
Reference: [7] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Implementation of a Knowledge-Based Programming Environment. </title> <booktitle> In 21st Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 54-63. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <month> January, </month> <year> 1988. </year>
Reference: [8] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Multi-Agent Rule-Based Software Development Environments. </title> <booktitle> In 5th Annual Knowledge-Based Software Assistant Conference, </booktitle> <pages> pages 375-387. </pages> <address> Syracuse NY, </address> <month> September, </month> <year> 1990. </year>
Reference-contexts: Conflicts among transactions originating at different sites can be resolved without TM-TM interaction, assuming that every TM maintains the same policy. However, TM-TM interaction may be optionally desired in case of special TM policies such as in <ref> [8] </ref>. Every DTM must implement an equivalent of the two-phase-commit protocol for the commitment of transactions. <p> However, as pointed out along the thesis, the architecture of DHOMS was driven towards supporting a variety of concurrency control policies, and cooperative models in particular. Major research efforts are given towards enhancing transaction management in programming environments in general ( [23], [37]) and rule-base environments in particular <ref> [8] </ref>. It is anticipated that future versions of MARVEL will incorporate more enhanced concurrency control policies. 6.4.2. Transaction Recovery Tolerating transaction recovery is made through the following observation: Recall that rules in MARVEL chain for two different reasons: automation and consistency.
Reference: [9] <author> Gail E. Kaiser, Israel Z. Ben-Shaul and Naser S. Barghouti. </author> <title> Preliminary Design of an Object Management System for Multi-User MARVEL. </title> <editor> In Takuya Katayama (editor), </editor> <booktitle> 6th International Software Process Workshop: Support for the Software Process. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <address> Hakodate, Hokkaido, Japan, </address> <month> October, </month> <year> 1990. </year> <note> Position paper. In press. </note>
Reference: [10] <author> Grady Booch. </author> <title> Object Oriented Design. </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <address> Redwood City, California, </address> <year> 1991, </year> <note> Chapter 1. 80 </note>
Reference: [11] <author> Alfred Brown and John Rosenberg. </author> <title> Persistent Object Stores: An Implementation Technique. </title> <editor> In Alan Dearle and Gail M. Shaw and Stanley B. Zdonik (editor), </editor> <title> Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice, </booktitle> <pages> pages 199-212. </pages> <booktitle> The Fourth International Workshop on Persistent Object Systems, </booktitle> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: No specific data model is defined, but concurrency control is built-in, and there is no separation between data and transaction management. Other work in this area include Gemstone, IRIS, O2. 7.2. Storage and Object Managers The work of Brown <ref> [11] </ref> is closely related to single-server DHOMS in its layered approach to the architecture of an OMS, in particular in the separation of data-management from transactions.
Reference: [12] <author> Stefano Ceri and Giuseppe Pelagatti. </author> <title> Distributed Databases. </title> <publisher> McGraw Hill, </publisher> <year> 1985. </year>
Reference-contexts: Transaction Manager (TM) Like other transaction managers, it is responsible for controlling concurrent access to the data and maintaining its consistency. As defined in <ref> [12] </ref>, it must provide concurrency control, transaction recovery to maintain consistency in case of internal exceptions due to user interruption or conflict resolution, and crash recovery to maintain consistency in case of external system/network breakdown. This section focuses on concurrency control. Recovery is discussed extensively in section 6.
Reference: [13] <author> C. Godart and F. Charoy. </author> <title> Computer Aided Software Engineering Object Management Systems: Requirements and ongoing Work. </title>
Reference-contexts: Persistence is provided through SM, the lowest layer in the system, which lacks any knowledge about the model, and performs an efficient byte-level storage and buffer management. Each component's implementation will be described in detail in the following sections. 6.1. MARVEL Object Manager (OM) As suggested in <ref> [13] </ref>, object management in programming environments must combine the capabilities of a DBMS and a File Management System (FMS). The alternatives are: (1) to extend an existing DBMS to handle file-like entities; (2) to integrate the FMS with an OMS.
Reference: [14] <author> C. J. Date. </author> <title> An Introduction to Data Base Systems. </title> <publisher> Addison Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Concurrency Control MARVEL's current concurrency control is a variation of two-phase locking (2PL) <ref> [14] </ref> as applied to nested transactions . A lock acquired by a subtransaction ST is also considered as a lock of its parent transaction PT.
Reference: [15] <author> Perasun Dewan and Eric Vasilik. </author> <title> An Object Model for Conventional Operating Systems. </title> <booktitle> Computing Systems, the Journal of the USENIX Association 3(4) </booktitle> <pages> 517-549, </pages> <month> Fall, </month> <year> 1990. </year>
Reference: [16] <author> Mary F. Fernandez and Stanley B. Zdonik. </author> <title> Transaction Groups: A Model for Controlling Cooperative Work. </title> <booktitle> In 3rd International Workshop on Persistent Object Systems: Their Design, Implementation and Use, </booktitle> <pages> pages 128-138. </pages> <address> Queensland, Australia, </address> <month> January, </month> <year> 1989. </year>
Reference-contexts: It is intended to provide the supporting platform for the implementation of persistent programming languages, such as Napier88 [29] and Galileo [2]. 69 ObServer ( <ref> [16] </ref>, [36], [17]) is an object server specifically designed for SDEs. It assumes a distributed environment, and includes a rich set of locks including non-restrictive locks and notification-modes that support cooperation.
Reference: [17] <author> Mary Fernandez. </author> <title> ObServer II Server Interface Specification Brown University, </title> <year> 1989. </year>
Reference-contexts: It is intended to provide the supporting platform for the implementation of persistent programming languages, such as Napier88 [29] and Galileo [2]. 69 ObServer ( [16], [36], <ref> [17] </ref>) is an object server specifically designed for SDEs. It assumes a distributed environment, and includes a rich set of locks including non-restrictive locks and notification-modes that support cooperation.
Reference: [18] <author> Jorge F. Garza and Won Kim. </author> <title> Transaction Management in an Object-Oriented Database System. </title> <booktitle> In SIGMOD International Conference on Data Management, </booktitle> <pages> pages 37-45. </pages> <address> Chicago IL, </address> <month> June, </month> <year> 1988. </year> <journal> Special issue of SIGMOD Record, </journal> <volume> 17(3), </volume> <month> September </month> <year> 1988. </year>
Reference-contexts: Basically, it allows only one client per top object in the hierarchy. Another solution, implemented also in the ORION system <ref> [18] </ref>, is to use intention locks, also known as granularity locking. When operating on an object O1, all O1's ancestors are locked in intention mode. When a client wants to apply an operation on an ancestor of O1, LM checks for conflicts against the intention lock. <p> Section 7.1 presents work on OODBMSs, i.e., systems that support an object-oriented data model and provide all the required functionality defined in section 1. Section 7.2 presents work on systems and models that provide partial functionality such as storage, object and transaction management. 7.1. OODBMS ORION ( [6], [24], <ref> [18] </ref> [25]), was originally developed as a LISP-machine system that integrated object-oriented programming with a database system by extending the language to include primitives that manipulate its object-oriented database. It was later extended into a generic OODBMS, and was ported to UNIX.
Reference: [19] <author> Theo Haerder and Kurt Rothermal. </author> <title> Concepts for Transaction Recovery in Nested Transactions. </title> <editor> In Umeshwar Dayal and Irv Traiger (editor), </editor> <booktitle> SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 239-248. </pages> <publisher> ACM Press, </publisher> <address> San Francisco, CA, </address> <month> May, </month> <year> 1987. </year>
Reference: [20] <author> Anthony L. Hosking and J. Eliot B. Moss. </author> <title> Towards Compile-Time Optimisations for Persistence. </title> <editor> In Alan Dearle and Gail M. Shaw and Stanley B. Zdonik (editor), </editor> <title> Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice, </booktitle> <pages> pages 17-28. </pages> <booktitle> The Fourth International Workshop on Persistent Object Systems, </booktitle> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA., </address> <year> 1990. </year>
Reference-contexts: When OM receives a request to read an object, it first checks whether the object is resident in its pool. If the object is not resident an object fault occurs and OM has to be able to fetch it from SM. As noted in <ref> [20] </ref>, the main two techniques to handle object faulting are node marking and edge marking. In node marking a non-resident 6 object is marked with a stub (fault block) that encodes its location in secondary memory , while in edge marking, the links are tagged as pointing to non-resident objects.
Reference: [21] <author> Gail E. Kaiser, Naser S. Barghouti, Peter H. Feiler and Robert W. Schwanke. </author> <title> Database Support for Knowledge-Based Engineering Environments. </title> <booktitle> IEEE Expert 3(2) </booktitle> <pages> 18-32, </pages> <month> May, </month> <year> 1988. </year> <month> 81 </month>
Reference: [22] <author> Gail E. </author> <note> Kaiser. </note>
Reference-contexts: MARVEL SEssion Manager (SEM) This module is part of the Environmental Support module. Session management encapsulates an entire session between a human user and the environment <ref> [22] </ref>. The idea is to provide another layer in which user-specific parameters that are valid throughout the session can be defined once (at initialization) and last for all interactions of the user with the system. Sessions can be used to express a desired behavior that differs from the default one.
References-found: 22

