URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS95-22.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Eliminating Virtual Function Calls in C++ Programs  
Author: Gerald Aigner Urs Hlzle 
Note: Technical Report TRCS 95-22,  Computer Science technical reports are available via ftp from ftp.cs.ucsb.edu or via WWW from http://www.cs.ucsb.edu/TRs.  
Date: December 10, 1995  December 1995. UCSB  
Web: http://www.cs.ucsb.edu/oocsb  
Address: Santa Barbara, CA 93106  Santa Barbara,  
Affiliation: Department of Computer Science University of California  Department of Computer Science, University of California,  
Abstract: We have designed and implemented an optimizing source-to-source C++ compiler that reduces the frequency of virtual function calls. This technical report describes our preliminary experience with this system. The prototype implementation demonstrates the value of OO-specific optimization of C++. Despite some limitations of our system, and despite the low frequency of virtual function calls in some of the programs, optimization improves the performance of a suite of two small and six large C++ applications totalling over 90,000 lines of code by a median of 20% over the original programs and reduces the number of virtual function calls by a median factor of 5. For more call-intensive versions of the same programs, performance improved by a median of 40% and the number of virtual calls dropped by a factor of 21. Our measurements indicate that inlining does not necessarily lead to large increases in code size, and that for most programs, the instruction cache miss ratio does not increase significantly. 
Abstract-found: 1
Intro-found: 1
Reference: [Age95] <author> Ole Agesen. </author> <title> The Cartesian Product Algorithm: Simple and Precise Type Inference of Parametric Polymor-phism. </title> <booktitle> In ECOOP95, Ninth European Conference on Object-Oriented Programming, p. </booktitle> <pages> 2-26, </pages> <address> rhus, Denmark, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag LNCS 952. </note>
Reference-contexts: In both studies, the analysis impact on virtual call frequency was significantly higher than in our system, as discussed in section 6.1. Srivastava and Wall [SW92] perform more extensive link-time optimization but do not optimize calls. More ambitious analyses such as concrete type inference systems (e.g., <ref> [Age95] </ref>, [PR94], [PC94]) can determine the concrete receiver types of message sends. Compared to type feedback, a type inferencer may provide more precise information since it may be able to prove that only a single receiver type is possible at a given call site.
Reference: [AH95] <author> Ole Agesen and Urs Hlzle. </author> <title> Type Feedback vs. Concrete Type Inference: A Comparison of Optimization Techniques for Object-Oriented Languages. </title> <booktitle> In OOPSLA95, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 91-107, </pages> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: However, its information may also be less precise since it may include types that could occur in theory but never happen in practice. (In other words, the information lacks frequency data.) For SELF, concrete type inference removed more dispatches than type feedback for most programs <ref> [AH95] </ref>. Like link-time optimizations, the main problem with type inference is that it requires knowledge of the entire program, thus precluding dynamic linking. 4.
Reference: [App88] <institution> Apple Computer, Inc. </institution> <note> Object Pascal Users Manual. Cupertino, </note> <year> 1988. </year>
Reference-contexts: Profile-driven customization (procedure cloning) resulted in an additional improvement of 1-5%. Several systems use whole-program or link-time analysis to optimize object-oriented programs, starting with the Apple Object Pascal linker <ref> [App88] </ref> which turned dynamically-dispatched calls into statically-bound calls if a type had exactly one implementation (e.g., the system contained only a CartesianPoint class and no PolarPoint class). To our knowledge, this system was the first to statically bind dynamically-dispatched calls, although it did not perform any inlining.
Reference: [CGZ94] <author> Brad Calder, Dirk Grunwald, and Benjamin Zorn. </author> <title> Quantifying Behavioral Differences Between C and C++ Programs. </title> <journal> Journal of Programming Languages 2 </journal> <pages> 313-351, </pages> <year> 1994. </year>
Reference-contexts: Finally, we will continue to look for other C++ applications that can be used for benchmarking. Although we are already using large programs totalling over 90,000 lines of code, we feel that currently available benchmarks (including those used in other studies <ref> [CGZ94] </ref>) do not represent the entire spectrum of program characteristics. In particular, programs using large class libraries and frameworks are underrepresented.
Reference: [CG94] <author> Brad Calder and Dirk Grunwald. </author> <title> Reducing Indirect Function Call Overhead in C++ Programs. </title> <booktitle> In 21st Annual ACM Symposium on Principles of Programming Languages, p. </booktitle> <pages> 397-408, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Based on measurements of C++ programs, Calder and Grunwald <ref> [CG94] </ref> argued that type feedback would be beneficial for C++ and proposed (but did not implement) a weaker form of class hierarchy analysis to improve efficiency.
Reference: [CUL89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 49-70, </pages> <address> New Orleans, LA, </address> <month> October </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October </month> <year> 1989. </year>
Reference-contexts: So far, much of the research on such optimizations has concentrated on pure object-oriented languages because the frequency of dynamic dispatch is especially high in such languages. Several studies (e.g., <ref> [CUL89] </ref>, [HU94a], [G+95]) have demonstrated that optimization can greatly reduce the frequency of dynamic dispatch in pure object-oriented languages and significantly improve performance.
Reference: [CU90] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <booktitle> In Proceedings of the SIGPLAN 90 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 150-164, </pages> <address> White Plains, NY, </address> <month> June </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(6), </note> <month> June </month> <year> 1990. </year>
Reference-contexts: Third, type feedback could be complemented with additional optimizations to improve performance further. In particular, profile-based customization and some form of splitting <ref> [CU90] </ref> are attractive candidates, although the latter might not be needed if the back-end C++ compiler did a better job of alias analysis. Finally, some of our benchmarks just dont execute that many virtual function calls to start with. a program uses virtual function calls, the better it is optimized.
Reference: [CM+92] <author> Pohua P. Chang, Scott A. Mahlke, William Y. Chen, and Wen-Mei W. Hwu. </author> <title> Profile-guided automatic inline expansion for C programs. </title> <booktitle> SoftwarePractice and Experience 22 (5): </booktitle> <pages> 349-369, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Related Work Profile information has been used for optimization in many systems; as usual, Knuth [Knu70] was the first to suggest profile-based optimization, and today it is part of many research systems (e.g., <ref> [CM+92] </ref>, [Hl94] [G+95]) as well as production compilers. Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., [DH88], [HwC89], [CHT91], [CM+92], [Hall91]). <p> and today it is part of many research systems (e.g., <ref> [CM+92] </ref>, [Hl94] [G+95]) as well as production compilers. Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., [DH88], [HwC89], [CHT91], [CM+92], [Hall91]). Our results indicate that these previous results do not apply to C++ programs. In implementations of dynamic or object-oriented languages, profiling information has often been used to identify (and optimize for) common cases.
Reference: [CHT91] <author> K. D. Cooper, M. W. Hall, and L. Torczon. </author> <title> An experiment with inline substitution. </title> <booktitle> SoftwarePractice and Experience 21 (6): </booktitle> <pages> 581-601, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., [DH88], [HwC89], <ref> [CHT91] </ref>, [CM+92], [Hall91]). Our results indicate that these previous results do not apply to C++ programs. In implementations of dynamic or object-oriented languages, profiling information has often been used to identify (and optimize for) common cases.
Reference: [DH88] <author> Jack W. Davidson and Anne M. Holler. </author> <title> A study of a C function inliner. </title> <journal> SoftwarePractice and Experience 18(8): </journal> <pages> 775-90, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., <ref> [DH88] </ref>, [HwC89], [CHT91], [CM+92], [Hall91]). Our results indicate that these previous results do not apply to C++ programs. In implementations of dynamic or object-oriented languages, profiling information has often been used to identify (and optimize for) common cases.
Reference: [DGC95] <author> Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis. </title> <booktitle> In ECOOP95, Ninth European Conference on Object-Oriented Programming, rhus, 1995. </booktitle> <publisher> Springer-Verlag LNCS 952. </publisher>
Reference-contexts: To our knowledge, this system was the first to statically bind dynamically-dispatched calls, although it did not perform any inlining. As mentioned above, Fernandez [Fer95] used class hierarchy analysis for Modula-3, and Dean et al. <ref> [DGC95] </ref> describe its use for Cecil. In both studies, the analysis impact on virtual call frequency was significantly higher than in our system, as discussed in section 6.1. Srivastava and Wall [SW92] perform more extensive link-time optimization but do not optimize calls. <p> Our measurements produced some surprising results: On the original programs (but not on the all-virtuals programs, class hierarchy analysis is ineffective, contrary to the results previously published for Modula-2 programs [Fer95] or the pure object-oriented language Cecil <ref> [DGC95] </ref>. Inlining does not necessarily lead to large increases in code size. On average, optimized programs only expand by 19%. Moreover, this code expansion does not impact performance much; for most programs, the instruction cache miss ratio does not increase significantly, and for some programs it even decreases.
Reference: [Dea95] <author> Jeffrey Dean. </author> <title> New Cecil performance numbers. </title> <type> Private communication, </type> <month> May </month> <year> 1995. </year>
Reference: [Dec95] <institution> Declarative Systems. The C++ Auditor. Palo Alto, </institution> <year> 1995. </year> <month> (auditor@declarative.com) </month>
Reference-contexts: To implement this pre-pass, and for the actual optimizing compiler, we used a commercial tool, the CCAuditor C++ parser from Declarative Systems <ref> [Dec95] </ref>. CCAuditor contains an empty attribute grammar for C++ which can be extended to implement arbitrary analyses or transformations. We used CCAuditor to build a simplified parse tree of the program which is then traversed and transformed by a C++ program.
Reference: [DHV95] <author> Karel Driesen, Urs Hlzle, and Jan Vitek. </author> <title> Message Dispatch On Pipelined Processors. </title> <booktitle> ECOOP 95 Conference Proceedings, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year> <booktitle> Published as Springer Verlag Lecture Notes in Computer Science 952, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: In particular, more aggressively pipelined superscalar CPUs are likely to benefit more from virtual call elimination since the cost of indirect calls tends to increase on such architectures <ref> [DHV95] </ref>. In fact, this trend is already visible on the SuperSPARC: whereas type feedback reduces the number of instructions executed by a median of only 5%, it reduces execution time by 20%. Clearly, optimization improves the effectiveness of superscalar issue and pipelining.
Reference: [DS84] <author> L. Peter Deutsch and Alan Schiffman. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, p. </booktitle> <pages> 297-302, </pages> <address> Salt Lake City, UT, </address> <month> January </month> <year> 1984. </year>
Reference-contexts: For example, Lisp systems usually inline the integer case of generic arithmetic and handle all other type combinations with a call to a routine in the runtime system. The Deutsch-Schiffman Smalltalk compiler was the first object-oriented system to predict integer receivers for common message names such as + <ref> [DS84] </ref>. All these systems do not use application-specific profiles. The SELF system pioneered the use of profile information for optimizing object-oriented languages. An experimental proof-of-concept system [HCU91] was the first one to use type feedback (then called PIC-based inlining) for optimization purposes.
Reference: [Deu87] <author> L. Peter Deutsch. </author> <title> Reusability in the Smalltalk-80 system. </title> <booktitle> Workshop On Reusability In Programming, </booktitle> <address> Newport, RI, </address> <year> 1983. </year>
Reference-contexts: Unfortunately, object-oriented programs are harder to optimize than programs written in languages like C or Fortran. There are two main reasons for this. First, object-oriented programming encourages code factoring and differential programming <ref> [Deu87] </ref>; as a result, procedures are smaller and procedure calls more frequent. Second, it is hard to optimize calls in object-oriented programs because they use dynamic dispatch: the procedure invoked by the call is not known until runtime since it depends on the dynamic type of the receiver.
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: VPROF inserts a non-virtual call to a run-time routine before each virtual call, passing in all information needed to identify the call site (e.g., file name, line number, and call number within the line). Additionally, the run-time routine receives a pointer to the receivers dispatch table (vtable <ref> [ES90] </ref>) and the index of the vtable entry being used to dispatch the call. In order to obtain the class name of receiver and the method name, the compiler enhances the vtable with one extra element per entry containing the necessary information.
Reference: [Fer95] <author> M. F. Fernandez. </author> <title> Simple and effective link-time optimization of Modula-3 programs. </title> <booktitle> In Proceedings of the SIGPLAN 95 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 103-115, </pages> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year> <note> Published as SIGPLAN Notices 30(6), </note> <month> June </month> <year> 1995. </year>
Reference-contexts: Their estimate of the performance benefits of this optimization (2-24% improvements, excluding benefits from inlining) exceeds the improvements measured in our system, partially because they assume a more aggressively pipelined CPU (DEC Alpha) which benefits more from reduced pipeline stalls than the SuperSPARC system we measured. Fernandez <ref> [Fer95] </ref> applied link-time optimization to Modula-3 programs and found that class hierarchy analysis eliminated between 2% and 79% of the virtual calls in the Modula-3 applications measured, reducing the number of instructions executed by 3-11%. Profile-driven customization (procedure cloning) resulted in an additional improvement of 1-5%. <p> To our knowledge, this system was the first to statically bind dynamically-dispatched calls, although it did not perform any inlining. As mentioned above, Fernandez <ref> [Fer95] </ref> used class hierarchy analysis for Modula-3, and Dean et al. [DGC95] describe its use for Cecil. In both studies, the analysis impact on virtual call frequency was significantly higher than in our system, as discussed in section 6.1. <p> Our measurements produced some surprising results: On the original programs (but not on the all-virtuals programs, class hierarchy analysis is ineffective, contrary to the results previously published for Modula-2 programs <ref> [Fer95] </ref> or the pure object-oriented language Cecil [DGC95]. Inlining does not necessarily lead to large increases in code size. On average, optimized programs only expand by 19%.
Reference: [G+95] <author> David Grove, Jeffrey Dean, Charles D. Garrett, and Craig Chambers. </author> <title> Profile-Guided Receiver Class Prediction. </title> <booktitle> In OOPSLA95, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 108-123, </pages> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year> <month> 25 </month>
Reference-contexts: So far, much of the research on such optimizations has concentrated on pure object-oriented languages because the frequency of dynamic dispatch is especially high in such languages. Several studies (e.g., [CUL89], [HU94a], <ref> [G+95] </ref>) have demonstrated that optimization can greatly reduce the frequency of dynamic dispatch in pure object-oriented languages and significantly improve performance. <p> Related Work Profile information has been used for optimization in many systems; as usual, Knuth [Knu70] was the first to suggest profile-based optimization, and today it is part of many research systems (e.g., [CM+92], [Hl94] <ref> [G+95] </ref>) as well as production compilers. Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., [DH88], [HwC89], [CHT91], [CM+92], [Hall91]). <p> An experimental proof-of-concept system [HCU91] was the first one to use type feedback (then called PIC-based inlining) for optimization purposes. The SELF-93 system [HU94a] used on-line profile information to select frequently executed methods for optimization and to determine receiver types via type feedback. Similarly, the Cecil compiler <ref> [G+95] </ref> uses off-line profiling for optimization and inlining. Grove et al. [G+95] also examined the cross-input stability of receiver class profiled in C++ and Cecil and found it good enough to be used for optimization. 5 Until now, few profile-based techniques have been applied to hybrid, statically-typed languages like Modula-3 or <p> The SELF-93 system [HU94a] used on-line profile information to select frequently executed methods for optimization and to determine receiver types via type feedback. Similarly, the Cecil compiler <ref> [G+95] </ref> uses off-line profiling for optimization and inlining. Grove et al. [G+95] also examined the cross-input stability of receiver class profiled in C++ and Cecil and found it good enough to be used for optimization. 5 Until now, few profile-based techniques have been applied to hybrid, statically-typed languages like Modula-3 or C++. <p> The resulting executable is then used to obtain receiver class distribution information for each call site. At the end of the program run, a small run-time library collects and outputs the data collected; this output is later used by the optimizing compiler. In Groves terminology <ref> [G+95] </ref>, VPROF produces 1-CCP profiles, i.e., individual receiver class distributions for each call site. 4.5 The Optimizing Compiler The main optimization step in our system consists of a source-to-source optimizing compiler that eliminates virtual function calls using either the profile information, knowledge of the complete class hierarchy, or both. <p> Furthermore, type feedback should be extended with profile-driven customization to further improve performance. Profiling could be extended to use k-CCP profiles (i.e., take call chains into account), although the improvement from the additional precision may be small <ref> [G+95] </ref>. Also, a more detailed investigation of the interaction of optimization with superscalar architectures is needed. Modern processors are increasingly deeply pipelined, contain multiple execution units, and can execute instructions out-of-order or speculatively.
Reference: [Hall91] <author> Mary Wolcott Hall. </author> <title> Managing Interprocedural Optimization. </title> <type> Technical Report COMP TR91-157 (Ph.D. Thesis), </type> <institution> Computer Science Department, Rice University, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., [DH88], [HwC89], [CHT91], [CM+92], <ref> [Hall91] </ref>). Our results indicate that these previous results do not apply to C++ programs. In implementations of dynamic or object-oriented languages, profiling information has often been used to identify (and optimize for) common cases.
Reference: [HCU91] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Optimizing Dynamically-Typed Object-Oriented Languages with Polymorphic Inline Caches. </title> <booktitle> In ECOOP91, Fourth European Conference on Object-Oriented Programming, p. </booktitle> <pages> 21-38, </pages> <address> Geneva, </address> <month> July </month> <year> 1991. </year> <note> Springer-Verlag LNCS 512. </note>
Reference-contexts: The Deutsch-Schiffman Smalltalk compiler was the first object-oriented system to predict integer receivers for common message names such as + [DS84]. All these systems do not use application-specific profiles. The SELF system pioneered the use of profile information for optimizing object-oriented languages. An experimental proof-of-concept system <ref> [HCU91] </ref> was the first one to use type feedback (then called PIC-based inlining) for optimization purposes. The SELF-93 system [HU94a] used on-line profile information to select frequently executed methods for optimization and to determine receiver types via type feedback.
Reference: [Hl94] <author> Urs Hlzle. </author> <title> Adaptive Optimization for SELF: Reconciling High Performance with Exploratory Programming. </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <month> August </month> <year> 1994. </year> <note> (Available via http://www.cs.ucsb.edu/~urs.) </note>
Reference-contexts: Related Work Profile information has been used for optimization in many systems; as usual, Knuth [Knu70] was the first to suggest profile-based optimization, and today it is part of many research systems (e.g., [CM+92], <ref> [Hl94] </ref> [G+95]) as well as production compilers. Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., [DH88], [HwC89], [CHT91], [CM+92], [Hall91]). <p> The compilers inlining strategies could also be improved. A simple extension of our system would inline more than one case per call site (e.g., the two most frequent cases). Inlining should 22 probably take into account the size of the inlinee <ref> [Hl94] </ref>, and the compiler should estimate how much the inlinees code can be simplified (i.e., because of constant arguments). Furthermore, type feedback should be extended with profile-driven customization to further improve performance.
Reference: [HU94a] <author> Urs Hlzle and David Ungar. </author> <title> Optimizing Dynamically-Dispatched Calls with Run-Time Type Feedback. </title> <booktitle> In Proceedings of the SIGPLAN 94 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 326-336. </pages> <note> Published as SIGPLAN Notices 29(6), </note> <month> June </month> <year> 1994. </year>
Reference-contexts: So far, much of the research on such optimizations has concentrated on pure object-oriented languages because the frequency of dynamic dispatch is especially high in such languages. Several studies (e.g., [CUL89], <ref> [HU94a] </ref>, [G+95]) have demonstrated that optimization can greatly reduce the frequency of dynamic dispatch in pure object-oriented languages and significantly improve performance. <p> In this section, we briey review these optimizations before describing our C++-specific implementation in the next section. 2.1 Profile-Based Optimization: Type Feedback Type feedback <ref> [HU94a] </ref> is an optimization technique originally developed for the SELF language. Its main idea is to use profile information gathered at run-time to eliminate dynamic dispatches. <p> All these systems do not use application-specific profiles. The SELF system pioneered the use of profile information for optimizing object-oriented languages. An experimental proof-of-concept system [HCU91] was the first one to use type feedback (then called PIC-based inlining) for optimization purposes. The SELF-93 system <ref> [HU94a] </ref> used on-line profile information to select frequently executed methods for optimization and to determine receiver types via type feedback. Similarly, the Cecil compiler [G+95] uses off-line profiling for optimization and inlining.
Reference: [HwC89] <author> W. W. Hwu and P. P. Chang. </author> <title> Inline function expansion for compiling C programs. </title> <booktitle> In Proceedings of the SIGPLAN 89 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 246-57, </pages> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(7), </note> <month> July </month> <year> 1989. </year>
Reference-contexts: Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., [DH88], <ref> [HwC89] </ref>, [CHT91], [CM+92], [Hall91]). Our results indicate that these previous results do not apply to C++ programs. In implementations of dynamic or object-oriented languages, profiling information has often been used to identify (and optimize for) common cases.
Reference: [Knu70] <author> Donald Knuth. </author> <title> An empirical study of FORTRAN programs. </title> <type> Technical Report CS-186, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1970. </year>
Reference-contexts: Furthermore, being profile-based, it can also better determine whether the send is actually worth optimizing (i.e., executed often enough). 3. Related Work Profile information has been used for optimization in many systems; as usual, Knuth <ref> [Knu70] </ref> was the first to suggest profile-based optimization, and today it is part of many research systems (e.g., [CM+92], [Hl94] [G+95]) as well as production compilers.
Reference: [Lea90] <editor> Douglas Lea. Customization in C++. </editor> <booktitle> In Proceedings of the 1990 Usenix C++ Conference, p. </booktitle> <pages> 301-314, </pages> <address> San Francisco, CA, </address> <month> April, </month> <year> 1990. </year>
Reference: [PR94] <author> Hemant D. Pande and Barbara G. Ryder. </author> <title> Static Type Determination and Aliasing for C++. </title> <type> Technical Report LCSR-TR-236, </type> <institution> Rutgers University, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: In both studies, the analysis impact on virtual call frequency was significantly higher than in our system, as discussed in section 6.1. Srivastava and Wall [SW92] perform more extensive link-time optimization but do not optimize calls. More ambitious analyses such as concrete type inference systems (e.g., [Age95], <ref> [PR94] </ref>, [PC94]) can determine the concrete receiver types of message sends. Compared to type feedback, a type inferencer may provide more precise information since it may be able to prove that only a single receiver type is possible at a given call site.
Reference: [PC94] <author> John B. Plevyak and Andrew A. Chien. </author> <title> Precise Concrete Type Inference for Object-Oriented Languages. </title> <booktitle> OOPSLA 94, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 324-340, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year> <note> Published as SIGPLAN Notices 29(10), </note> <month> October </month> <year> 1994. </year>
Reference-contexts: In both studies, the analysis impact on virtual call frequency was significantly higher than in our system, as discussed in section 6.1. Srivastava and Wall [SW92] perform more extensive link-time optimization but do not optimize calls. More ambitious analyses such as concrete type inference systems (e.g., [Age95], [PR94], <ref> [PC94] </ref>) can determine the concrete receiver types of message sends. Compared to type feedback, a type inferencer may provide more precise information since it may be able to prove that only a single receiver type is possible at a given call site.
Reference: [Ser95] <author> Mauricio Serrano. </author> <title> Virtual function call frequencies in C++ programs. </title> <type> Private communication, </type> <year> 1995. </year>
Reference-contexts: For example, the Taligent CommonPoint frameworks provide all functionality through virtual functions, and thus programs using Commonpoint (or similar frameworks) will exhibit much higher virtual function call frequencies <ref> [Ser95] </ref>.
Reference: [SW92] <author> Amitabh Srivastava and David Wall. </author> <title> A Practical System for Intermodule Code Optimization at Link Time. </title> <note> DEC WRL Research Report 92/6, </note> <month> December </month> <year> 1992. </year>
Reference-contexts: As mentioned above, Fernandez [Fer95] used class hierarchy analysis for Modula-3, and Dean et al. [DGC95] describe its use for Cecil. In both studies, the analysis impact on virtual call frequency was significantly higher than in our system, as discussed in section 6.1. Srivastava and Wall <ref> [SW92] </ref> perform more extensive link-time optimization but do not optimize calls. More ambitious analyses such as concrete type inference systems (e.g., [Age95], [PR94], [PC94]) can determine the concrete receiver types of message sends.
Reference: [US87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 227-241, </pages> <address> Orlando, FL, </address> <month> October </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June </month> <year> 1991. </year>
Reference: [Wall91] <author> David Wall. </author> <title> Predicting Program Behavior Using Real or Estimated Profiles. </title> <booktitle> In Proceedings of the SIGPLAN 91 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 59-70, </pages> <address> Toronto, Canada, </address> <month> June </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(6), </note> <month> June </month> <year> 1991. </year>
References-found: 32

