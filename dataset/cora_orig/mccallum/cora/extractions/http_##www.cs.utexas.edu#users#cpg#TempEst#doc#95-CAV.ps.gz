URL: http://www.cs.utexas.edu/users/cpg/TempEst/doc/95-CAV.ps.gz
Refering-URL: http://www.cs.utexas.edu/users/cpg/TempEst/docs.html
Root-URL: 
Phone: 2  3  
Title: Safety Property Verification of ESTEREL Programs and Applications to Telecommunications Software versions of two features
Author: Lalita Jategaonkar Jagadeesan Carlos Puchol ? and James E. Von Olnhausen 
Address: IL 60566 (USA)  Austin, Austin, TX 78712 (USA)  IL 60566 (USA)  
Affiliation: 1 Software Production Research Dept., AT&T Bell Laboratories, Naperville,  Dept. of Computer Sciences, The University of Texas at  Global Software Platform Lab, AT&T Bell Laboratories, Naperville,  
Date: July 1995.  
Note: In Proc. of the Seventh Conference on Computer-Aided Verification,  TEREL  
Abstract: We present a technique for automatically verifying linear-time temporal logic safety properties of programs written in ESTEREL, a formally-defined language for programming reactive systems. In our approach, linear-time temporal logic safety properties are first translated into ESTEREL programs that model these properties. Using the ESTEREL compiler, the translations are compiled in parallel with the ESTEREL program to be verified. A trivial reachability analysis of the output of the compiler then indicates whether or not the safety property is satisfied by the program. We describe two real-world software problems ES that we have verified using our technique and associated tool set. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <institution> AGEL workshop manual version 3.0, </institution> <year> 1989. </year> <note> Produced by ILOG. </note>
Reference-contexts: The program derived from the formula is then composed in parallel with the given ESTEREL program to be verified. The program resulting from this composition is compiled using commercially available ESTEREL tools <ref> [1] </ref>; a trivial analysis of the output of the compiler then indicates whether or not the property is satisfied by the original program. By exhaustively generating all the reachable states of the composed program, the ESTEREL compiler in effect performs model checking [7]. <p> The current verifier supported in the native ESTEREL environment <ref> [1] </ref> is based on bisimulation reduction and does not support temporal logic properties. Our paper is organized as follows. Section 2 describes the class of temporal logic safety properties currently supported by our approach, and a brief introduction to ES <p>- TEREL is given in Section 3. <p> The program derived from s is then composed in parallel with the original ESTEREL program to be verified. The ESTEREL program resulting from this composition is then translated into a single finite-state automaton by the ESTEREL compiler <ref> [1] </ref>. The ES <p>- TEREL compiler in effect performs model checking as it compiles, by exhaustively generating all the reachable states. In particular, the process of compilation computes the value of all subformulas of the formula along with the program itself.
Reference: 2. <author> R. Alur, T. Feder, and T. Henzinger. </author> <title> The benefits of relaxing punctuality. </title> <booktitle> Proc. ACM Symp. on Principles of Distributed Computing, </booktitle> <year> 1991. </year>
Reference-contexts: In real-time systems the interest lies fundamentally in the ability to limit the delay of responses to stimuli, thus stronger formulas than these are needed. Adding timing constraints to temporal operators is a standard way to capture real-time requirements. Stan- dard bounded-response formulas <ref> [3, 2] </ref> 5 are of the form 2 (p ! 3 d q) which state that every p-position is followed by a q-position within d reactions.
Reference: 3. <author> R. Alur and T. Henzinger. </author> <title> Time for logic. </title> <journal> ACM SIGACT News, </journal> <volume> 22(3), </volume> <year> 1991. </year>
Reference-contexts: In real-time systems the interest lies fundamentally in the ability to limit the delay of responses to stimuli, thus stronger formulas than these are needed. Adding timing constraints to temporal operators is a standard way to capture real-time requirements. Stan- dard bounded-response formulas <ref> [3, 2] </ref> 5 are of the form 2 (p ! 3 d q) which state that every p-position is followed by a q-position within d reactions.
Reference: 4. <author> M. Ardis, John A. Chaves, L. Jagadeesan, P. Mataga, C. Puchol, M. Staskauskas, and J. Von Olnhausen. </author> <title> A framework for evaluating specification methods for reactive systems. </title> <booktitle> In Proc. 17th Intl. Conf. on Software Engineering, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: A set of safety properties was drawn from a 5ESS application for automatic protection switching. We implemented a protocol in ESTEREL, and verified that our implementation satisfies these safety properties, using the technique and tools presented here. A more detailed presentation of the problem and our solution appears in <ref> [4] </ref>. 10 Case Study: Generalized Railroad Crossing The generalized railroad crossing problem is a benchmark problem that has been recently proposed [12] to compare formal methods that exist for specifying, designing and analyzing real-time systems and to better understand their utility in the development of practical systems.
Reference: 5. <author> G. Berry and G. Gonthier. </author> <title> The ESTEREL synchronous programming language: </title> <booktitle> design, se-mantics, implementation. Science of Computer Programming, </booktitle> <volume> 19 </volume> <pages> 87-152, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction The ESTEREL programming language <ref> [5] </ref> is a formally-defined, high-level language designed specifically for programming reactive systems. It is based on the synchrony hypothesis, which states that every reaction of a system to a set of inputs is theoretically instantaneous. <p> f and fl n f fl ( fl n1 f ) for a past temporal logic formula f . 4 The alternative form 2 3p may be more familiar. 5 We do not currently consider interval operations such as p ! -3 [a;b] q. 3 The ESTEREL programming language ESTEREL <ref> [5] </ref> is a language, with a precisely defined formal semantics, for programming the class of deterministic reactive systems that wait for a set of possibly simultaneous inputs, react to the inputs by computing and producing outputs, and then quiesce, waiting for new inputs. <p> Then the program VE RIF (E; s) does not have causality cycles in it. The proof for Lemma 4 follows from an induction on the structure of safety formulas. Lemma 6 follows easily from the definition of causality cycles <ref> [5] </ref>. Theorem 7 now gives a sound and complete verification technique for pure ESTEREL programs, namely those without if statements. The control structure of such programs is fully determined at compile-time. Theorem 7.
Reference: 6. <author> A. Bouajjani, J.C. Fernandez, and N. Halbwachs. </author> <title> On the verification of safety properties, 1994. </title> <type> Draft. </type>
Reference-contexts: In [20], this result was used to improve a procedure for model checking ([14]) by combining the automata for the program and the formula and checking the language of the resulting automaton for emptiness. Our work was originally inspired by the work of Halbwachs et al. <ref> [6, 9, 10, 18] </ref>, which develops a technique for verifying safety properties for programs written in the synchronous language Lustre [8].
Reference: 7. <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite state concurrent systems using temporal logic specifications. </title> <journal> ACM TOPLAS, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: By exhaustively generating all the reachable states of the composed program, the ESTEREL compiler in effect performs model checking <ref> [7] </ref>. The foundations for this approach were first introduced in [21] and [20] in the context of temporal logic and finite-state automata. Specifically, given any propositional temporal formula, [21] introduced a procedure to build a finite automaton on infinite words that accepts precisely the sequences that satisfy the formula.
Reference: 8. <author> N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud. </author> <title> The synchronous data-flow program-ming language LUSTRE. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79 </volume> <pages> 1305-1320, </pages> <year> 1991. </year>
Reference-contexts: Our work was originally inspired by the work of Halbwachs et al. [6, 9, 10, 18], which develops a technique for verifying safety properties for programs written in the synchronous language Lustre <ref> [8] </ref>.
Reference: 9. <author> N. Halbwachs, F. Lagnier, and C. Ratel. </author> <title> Programming and verifying real-time systems by means of the synchronous data-flow language LUSTRE. </title> <journal> Transactions on Software Engineering, </journal> <volume> 18(9) </volume> <pages> 785-793, </pages> <year> 1992. </year>
Reference-contexts: In [20], this result was used to improve a procedure for model checking ([14]) by combining the automata for the program and the formula and checking the language of the resulting automaton for emptiness. Our work was originally inspired by the work of Halbwachs et al. <ref> [6, 9, 10, 18] </ref>, which develops a technique for verifying safety properties for programs written in the synchronous language Lustre [8].
Reference: 10. <author> N. Halbwachs, D. Pilaud, F. Ouabdesselam, and A.C. Glory. </author> <title> Specifying, programming and verifying reactive systems, using a synchronous declarative language. In Workshop on Automatic Verification Methods for Finite State Systems, </title> <booktitle> LNCS Vol. </booktitle> <volume> 407, </volume> <year> 1989. </year>
Reference-contexts: In [20], this result was used to improve a procedure for model checking ([14]) by combining the automata for the program and the formula and checking the language of the resulting automaton for emptiness. Our work was originally inspired by the work of Halbwachs et al. <ref> [6, 9, 10, 18] </ref>, which develops a technique for verifying safety properties for programs written in the synchronous language Lustre [8].
Reference: 11. <author> G. Haugk, F.M. Lax, R.D. Royer, and J.R. Williams. </author> <title> The 5ESS(TM) switching system: Maintenance capabilities. </title> <journal> AT&T Tech. Journal, </journal> <volume> 64(6 part </volume> 2):1385-1416, Jul-Aug 1985. 
Reference-contexts: Telephones are connected to switches via lines. Inputs to the switch include requests for placing and disconnecting telephone calls, requests for call forwarding and other calling features, as well status changes such as malfunctions or recoveries from malfunctions on carriers and lines <ref> [11] </ref>. In response to these inputs, the switch connects or disconnects calls, activates calling features, or in the case of malfunctions/recoveries, removes/restores the associated carriers and lines and routes new calls over functioning carriers and lines. <p> The Carrier Group Alarms (CGA) software in the 5ESS switch is responsible for reporting status changes malfunctions or recoveries from malfunctions on carrier groups, so that other 5ESS software can respectively remove or restore the associated carrier groups from service, and route new telephone calls accordingly <ref> [11] </ref>. One of the main sources of inputs to the CGA software are summary-requests from higher-level entities.
Reference: 12. <author> C. Heitmeyer, R.D. Jeffords, and B. Labaw. </author> <title> A benchmark for comparing different ap-proaches for specifying and verifying real-time systems. </title> <booktitle> In Proc. 10th International Workshop on Real-Time Operating Systems and Software, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: The work described here was per <p>- formed while the author was visiting AT&T Bell Laboratories. these features has been successfully tested in the 5ESS switch environments; a detailed presentation appears in [13]. We have also verified an ESTEREL solution of the generalized railroad crossing problem <ref> [12] </ref> using our technique and tools. <p> A more detailed presentation of the problem and our solution appears in [4]. 10 Case Study: Generalized Railroad Crossing The generalized railroad crossing problem is a benchmark problem that has been recently proposed <ref> [12] </ref> to compare formal methods that exist for specifying, designing and analyzing real-time systems and to better understand their utility in the development of practical systems.
Reference: 13. <author> L.J. Jagadeesan, C. Puchol, and J.E. Von Olnhausen. </author> <title> A formal approach to reactive systems software: A telecommunications application in ESTEREL. </title> <booktitle> In Proc. Workshop on Industrialstrength Formal Spec. Techniques, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: We present a technique for automatically verifying a large class of propositional linear-time temporal logic safety properties of ESTEREL programs. We then describe two real-world software problems and one benchmark problem that we have verified using our technique and associated tools. In particular, we have performed a case study <ref> [13] </ref> to assess the suitability of ESTEREL to switching software by writing ESTEREL versions of two features of the AT&T 5ESS R fl telephone switching system a reactive real-time system which provides telecommunications services. <p> The work described here was per <p>- formed while the author was visiting AT&T Bell Laboratories. these features has been successfully tested in the 5ESS switch environments; a detailed presentation appears in <ref> [13] </ref>. We have also verified an ESTEREL solution of the generalized railroad crossing problem [12] using our technique and tools. <p> This completes the presentation of our technique. The remainder of the paper describes the use of the technique to two problems from industry and a benchmark problem. 7 An Overview of Our Case Studies for Switching Software We have performed a case study <ref> [13] </ref> to assess the suitability of ESTEREL to switching software by writing ESTEREL versions of two features in the AT&T 5ESS telephone switching system [17]. We then used our technique and tools to verify that our ESTEREL versions satisfy some safety properties required for the existing switch software. <p> Our ESTEREL program is simply an implementation of each of these modules, and is described in more detail in <ref> [13] </ref>. Figure 2 is actually a simplified picture of our ESTEREL version.
Reference: 14. <author> O Lichtenstein and A. Pnueli. </author> <title> Checking that finite-state concurrent programs satisfy their linear specifications. </title> <booktitle> In ACM Symposium on Priciples of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <year> 1985. </year>
Reference: 15. <author> O. Lichtenstein, A. Pnueli, and L. Zuck. </author> <title> The glory of the past. </title> <booktitle> In Conference on Logics of Programs, </booktitle> <year> 1985. </year>
Reference-contexts: Most temporal logics typically contain only future-tense operators, however, past-tense operators are considered to make the formulation of properties more modular as well as natural and convenient <ref> [15] </ref>. We have found past-tense operators to be as convenient as the future-tense operators in proving properties of actual systems.
Reference: 16. <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems, Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Safety properties are typically sufficient to describe most intended properties of real- time systems, since responses are required within bounded intervals. One of the more widely accepted languages for specifying temporal behavior and safety properties of reactive systems is linear-time temporal logic <ref> [16] </ref>. We present a technique for automatically verifying a large class of propositional linear-time temporal logic safety properties of ESTEREL programs. We then describe two real-world software problems and one benchmark problem that we have verified using our technique and associated tools. <p> We have found past-tense operators to be as convenient as the future-tense operators in proving properties of actual systems. In our approach, we consider the class of canonical safety formulas <ref> [16] </ref>, further restricted so that the state formulas consist only of signal identifiers; in particular, we do not allow variables to occur in state formulas. Formally, Definition 1. Let Sig be a fixed finite alphabet of signal names, containing the constants TRUE and FIRST. <p> The definition of satisfaction of a formula in PAST and SAF E is standard, thus not repeated here. PAST is the class of past-tense temporal logic formulas and SAF E is the class of safety formulas, which can be characterized as follows <ref> [16] </ref>: a formula s is a safety formula iff any sequence violating s (i.e., satisfying :s) contains a prefix all whose infinite extensions violate s. Informally these formulas stipulate that something bad never happens.
Reference: 17. <author> K.E. Martersteck and A.E. Spencer. </author> <title> Introduction to the 5ESS(TM) switching system. </title> <journal> AT&T Tech. Journal, </journal> <volume> 64(6 part </volume> 2):1305-1314, Jul-Aug 1985. 
Reference-contexts: technique to two problems from industry and a benchmark problem. 7 An Overview of Our Case Studies for Switching Software We have performed a case study [13] to assess the suitability of ESTEREL to switching software by writing ESTEREL versions of two features in the AT&T 5ESS telephone switching system <ref> [17] </ref>. We then used our technique and tools to verify that our ESTEREL versions satisfy some safety properties required for the existing switch software. The descriptions of our case studies appear in the following two sections. The 5ESS switch is a reactive, real-time system which provides telecommunications services.
Reference: 18. <author> D. Pilaud and N. Halbwachs. </author> <title> From a synchronous declarative language to a temporal logic dealing with multi-form time. </title> <booktitle> In Symposium on Formal Techniques in Real-Time and FaultTolerant Techniques, </booktitle> <volume> LNCS Vol. 331, </volume> <year> 1988. </year>
Reference-contexts: In [20], this result was used to improve a procedure for model checking ([14]) by combining the automata for the program and the formula and checking the language of the resulting automaton for emptiness. Our work was originally inspired by the work of Halbwachs et al. <ref> [6, 9, 10, 18] </ref>, which develops a technique for verifying safety properties for programs written in the synchronous language Lustre [8].
Reference: 19. <author> C. Puchol. </author> <title> A solution to the generalized railroad crossing problem in ESTEREL. </title> <type> Technical Report UTCS-TR95-05, </type> <institution> Dept. of Com. Sci., Univ. of Texas at Austin, </institution> <month> Feb </month> <year> 1995. </year>
Reference-contexts: run Train_0 || ... || run Train_N || run Properties end signal end module The problem then consists of developing a system to control the crossing gate that ensures the satisfaction of the following properties, which we have formally verified with the tools and techniques shown in this paper (see <ref> [19] </ref> for details): Safety Property: 2 IN I ! DOWN. The gate is down if there is any train in the crossing. Utility Property: 2 :(IN R _ IN I) ; -3 5 UP.
Reference: 20. <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verifica-tion. </title> <booktitle> In Proc. LICS, </booktitle> <pages> pages 332-339, </pages> <year> 1986. </year>
Reference-contexts: By exhaustively generating all the reachable states of the composed program, the ESTEREL compiler in effect performs model checking [7]. The foundations for this approach were first introduced in [21] and <ref> [20] </ref> in the context of temporal logic and finite-state automata. Specifically, given any propositional temporal formula, [21] introduced a procedure to build a finite automaton on infinite words that accepts precisely the sequences that satisfy the formula. In [20], this result was used to improve a procedure for model checking ([14]) <p> The foundations for this approach were first introduced in [21] and <ref> [20] </ref> in the context of temporal logic and finite-state automata. Specifically, given any propositional temporal formula, [21] introduced a procedure to build a finite automaton on infinite words that accepts precisely the sequences that satisfy the formula. In [20], this result was used to improve a procedure for model checking ([14]) by combining the automata for the program and the formula and checking the language of the resulting automaton for emptiness.
Reference: 21. <author> P. Wolper, M.Y. Vardi, and A.P. Sistla. </author> <title> Reasoning about infinite computation paths. </title> <booktitle> In IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 185-194, </pages> <year> 1983. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: By exhaustively generating all the reachable states of the composed program, the ESTEREL compiler in effect performs model checking [7]. The foundations for this approach were first introduced in <ref> [21] </ref> and [20] in the context of temporal logic and finite-state automata. Specifically, given any propositional temporal formula, [21] introduced a procedure to build a finite automaton on infinite words that accepts precisely the sequences that satisfy the formula. <p> By exhaustively generating all the reachable states of the composed program, the ESTEREL compiler in effect performs model checking [7]. The foundations for this approach were first introduced in <ref> [21] </ref> and [20] in the context of temporal logic and finite-state automata. Specifically, given any propositional temporal formula, [21] introduced a procedure to build a finite automaton on infinite words that accepts precisely the sequences that satisfy the formula.
References-found: 21

