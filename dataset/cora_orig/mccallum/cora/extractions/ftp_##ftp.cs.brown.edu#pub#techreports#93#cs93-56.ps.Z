URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-56.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-56.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Samuel J. Cardman. </author> <title> Time management in a real-time animation/graphics environment. </title> <booktitle> Computer Graphics (SIGGRAPH '75 Proceedings), </booktitle> <volume> 9(1) </volume> <pages> 201-207, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: Finally, non-linear relationships over time link separate time coordinate systems, a procedure that is commonly called "time warping" [19] [2]. More recently, the concept of linking logical (modeling) time to real-time <ref> [1] </ref> has been rediscovered [3], allowing dynamic behavior to be synchronized to wall-time. None of the contemporary computer graphics systems we know of [24] [3] [21] [10] [15] [18] [5] handle update rate as an explicit concept. Accordingly, they cannot benefit from the advantages mentioned in Section 1. <p> The reader operates in logical time, not in wall-time <ref> [1] </ref>, i.e., behaviors are always sampled in logical time. A scheduler component elsewhere in the system is responsible for linking the logical time to wall-time.
Reference: [2] <author> Conal Elliott, Greg Schechter, Salim Abi-Ezzi, and Michael Deering. TBAG: </author> <title> Time, behavior, and geometry. Available from the authors upon request, </title> <year> 1991. </year>
Reference-contexts: Hierarchical coordinate systems, common in the space domain, are applied to time, e.g., as "time coordinate systems" [20] [21]. Finally, non-linear relationships over time link separate time coordinate systems, a procedure that is commonly called "time warping" [19] <ref> [2] </ref>. More recently, the concept of linking logical (modeling) time to real-time [1] has been rediscovered [3], allowing dynamic behavior to be synchronized to wall-time. None of the contemporary computer graphics systems we know of [24] [3] [21] [10] [15] [18] [5] handle update rate as an explicit concept.
Reference: [3] <author> Conal Elliott, Greg Schechter, Ricky Yeung, and Salim Abi-Ezzi. </author> <title> A system for interactive, animated 3D graphics based on continuous high level constraints. Available from the authors upon request, </title> <month> January </month> <year> 1993. </year>
Reference-contexts: Update rates are common to both multimedia and computer graphics. Most multimedia data is presampled and therefore has an implicit sampling or update rate associated with it. Computer graphics, while based on continuous time models [24] <ref> [3] </ref>, is ultimately sampled, for example, when displaying discrete frames. Just as polygon resolution is a parameter that controls rendering quality of abstract graphics primitives, update rate is a parameter that controls rendered behavior quality. <p> Finally, non-linear relationships over time link separate time coordinate systems, a procedure that is commonly called "time warping" [19] [2]. More recently, the concept of linking logical (modeling) time to real-time [1] has been rediscovered <ref> [3] </ref>, allowing dynamic behavior to be synchronized to wall-time. None of the contemporary computer graphics systems we know of [24] [3] [21] [10] [15] [18] [5] handle update rate as an explicit concept. Accordingly, they cannot benefit from the advantages mentioned in Section 1. <p> More recently, the concept of linking logical (modeling) time to real-time [1] has been rediscovered <ref> [3] </ref>, allowing dynamic behavior to be synchronized to wall-time. None of the contemporary computer graphics systems we know of [24] [3] [21] [10] [15] [18] [5] handle update rate as an explicit concept. Accordingly, they cannot benefit from the advantages mentioned in Section 1. In particular, since update rate is implicit to the system, the user cannot control it. <p> Various systems attempt to regain this lost efficiency, for example, via elaborate and costly caching schemes [24] or via complicated code analysis and compilation <ref> [3] </ref>. Worse, updating faster than frame rate is impossible [24] or done outside the usual evaluation process [3] [18]. While Inventor [18] does not address dynamic behavior per se, it is interesting that its builtin support for timers is potentially used for simulating dynamic behavior and even sampling. <p> Various systems attempt to regain this lost efficiency, for example, via elaborate and costly caching schemes [24] or via complicated code analysis and compilation <ref> [3] </ref>. Worse, updating faster than frame rate is impossible [24] or done outside the usual evaluation process [3] [18]. While Inventor [18] does not address dynamic behavior per se, it is interesting that its builtin support for timers is potentially used for simulating dynamic behavior and even sampling. Timers are autonomous objects that are directly linked to wall-time. <p> It allows a user to describe synthetic scenes, often consisting of geometric shapes, lights, and cameras and all their associated attributes and operators. Modern systems are often designed to easily expand 5 this module to include new shapes or attributes [24] <ref> [3] </ref>, effectively allowing the interchange of the present module with one that has a richer set of primitives. As pointed out in [14], sharing is practiced on many different levels. Sharing simplifies and automates the user's task of designing and modeling a coherent, synthetic scene. <p> To some extent, it is also responsible for integrating the functionality of the various modules. Graphics system's implementations for this module range from home-brew languages, e.g. FLESH [24], to commercially available, high-level languages, e.g. Scheme <ref> [3] </ref>. Often, these languages are interpreted, and not compiled, to improve the user's ability to quickly prototype and view new geometric models and their behavior. All these modules must be integrated as equals to obtain maximum functionality. <p> All these modules must be integrated as equals to obtain maximum functionality. For example, constraints between objects should be allowed to vary over time, just as constraints should be allowed to operate on object behaviors <ref> [3] </ref>.
Reference: [4] <author> Jr. Frederick P. Brooks. </author> <title> Grasping reality through illusion interactive graphics serving science. </title> <booktitle> In Proceedings of ACM CHI'88 Conference on Human Factors in Computing Systems, </booktitle> <pages> pages 1-11, </pages> <year> 1988. </year>
Reference-contexts: moves away from the viewpoint prevalent in the graphics community of "it takes as long as it takes to generate the next frame" towards a more user-friendly philosophy of guaranteeing certain response times [22] [5], heightening the user's perception of reality in dynamic, computer-generated scenes by making it act real <ref> [4] </ref>. Note that while this feature is merely "nice" for conventional desktop environments, it becomes essential for immersive environments to sustain the illusion of immersion and even avoid motion sickness [8] [16] due to lagging feedback. We imagine our time-critical graphics system to also incorporate multimedia data.
Reference: [5] <author> Thomas A. Funkhouser and Carlo H. Sequin. </author> <title> Adaptive display algorithm for interactive frame rates during visiualization of complex virtual environments. </title> <booktitle> Computer Graphics (SIGGRAPH '93 Proceedings), </booktitle> <pages> pages 247-254, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Such a system moves away from the viewpoint prevalent in the graphics community of "it takes as long as it takes to generate the next frame" towards a more user-friendly philosophy of guaranteeing certain response times [22] <ref> [5] </ref>, heightening the user's perception of reality in dynamic, computer-generated scenes by making it act real [4]. <p> More recently, the concept of linking logical (modeling) time to real-time [1] has been rediscovered [3], allowing dynamic behavior to be synchronized to wall-time. None of the contemporary computer graphics systems we know of [24] [3] [21] [10] [15] [18] <ref> [5] </ref> handle update rate as an explicit concept. Accordingly, they cannot benefit from the advantages mentioned in Section 1. In particular, since update rate is implicit to the system, the user cannot control it. <p> While a step in the right direction, the authors fail to recognize the full potential of being able to specify and control a multitude of update rates. Most recently, several researchers [13] [12] <ref> [5] </ref> [7] have independently started to address the problem of time-critical rendering. A time-critical renderer produces frames in prespecified amounts of time, degrading various renderer-specific attributes to achieve its goal. In effect, the user specifies the update rate for the renderer in relation to wall-time.
Reference: [6] <author> Simon Gibbs. </author> <title> Composite multimedia and active objects. </title> <booktitle> In Proceedings of OOPSLA'91, </booktitle> <pages> pages 97-112, </pages> <year> 1991. </year>
Reference-contexts: However, it is therefore also susceptible to hardware assistance, which complicates the time-critical rendering problem considerably [12]. In contrast, multimedia systems, being based on presampled data types that are inherently wall-time based, are aware of update rates. Recent work <ref> [6] </ref> [9] also addresses issues in controlling jitter and degrading the data stream in order to stay synchronized. However, since the involved data types are presampled, thus prespecified and often sampled at periodic intervals, there is no need for complex update rate models.
Reference: [7] <author> Rich Gossweiler. </author> <title> Time-critical rendering in an immersive virtual environment. </title> <type> Thesis Proposal, </type> <note> available from author on request, </note> <year> 1993. </year>
Reference-contexts: While a step in the right direction, the authors fail to recognize the full potential of being able to specify and control a multitude of update rates. Most recently, several researchers [13] [12] [5] <ref> [7] </ref> have independently started to address the problem of time-critical rendering. A time-critical renderer produces frames in prespecified amounts of time, degrading various renderer-specific attributes to achieve its goal. In effect, the user specifies the update rate for the renderer in relation to wall-time.
Reference: [8] <author> Lawrence J. Hettinger, Kevin S. Berbaum, and Robert S. Kennedy. </author> <title> Vection and simulator sickness. </title> <journal> Military Psychology, </journal> <volume> 2(3) </volume> <pages> 171-181, </pages> <year> 1990. </year> <month> 24 </month>
Reference-contexts: Note that while this feature is merely "nice" for conventional desktop environments, it becomes essential for immersive environments to sustain the illusion of immersion and even avoid motion sickness <ref> [8] </ref> [16] due to lagging feedback. We imagine our time-critical graphics system to also incorporate multimedia data. Most multimedia data, for example, live or prerecorded audio and video streams, is inherently dynamic and sensitive to timing and synchronization issues.
Reference: [9] <institution> IMA Services Focus Group and Architectural Technical Working Group. Request for technology: Multimedia system services. </institution> <note> Available via anonymous ftp from world.std.com:/pub/IMA, </note> <month> December </month> <year> 1992. </year>
Reference-contexts: However, it is therefore also susceptible to hardware assistance, which complicates the time-critical rendering problem considerably [12]. In contrast, multimedia systems, being based on presampled data types that are inherently wall-time based, are aware of update rates. Recent work [6] <ref> [9] </ref> also addresses issues in controlling jitter and degrading the data stream in order to stay synchronized. However, since the involved data types are presampled, thus prespecified and often sampled at periodic intervals, there is no need for complex update rate models.
Reference: [10] <author> Devendra Kalra. </author> <title> A Unified Framework for Constraint-based Modeling. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: More recently, the concept of linking logical (modeling) time to real-time [1] has been rediscovered [3], allowing dynamic behavior to be synchronized to wall-time. None of the contemporary computer graphics systems we know of [24] [3] [21] <ref> [10] </ref> [15] [18] [5] handle update rate as an explicit concept. Accordingly, they cannot benefit from the advantages mentioned in Section 1. In particular, since update rate is implicit to the system, the user cannot control it.
Reference: [11] <author> Devendra Kalra and Alan H. Barr. </author> <title> Modeling with time and events in computer animation. </title> <journal> Computer Graphics Forum (EUROGRAPHICS'92), </journal> <volume> 11(3):C45-C58, </volume> <year> 1992. </year>
Reference-contexts: So far, the main thrust of these efforts has 3 introduced successful concepts in the space domain to the time domain. Ex--amples of these concepts include encapsulation, hierarchy, and non-linear relationships. Dynamic behaviors are encapsulated into reusable building blocks, e.g., as "time-dependent behaviors" [20] or "time graphs" <ref> [11] </ref>. Hierarchical coordinate systems, common in the space domain, are applied to time, e.g., as "time coordinate systems" [20] [21]. Finally, non-linear relationships over time link separate time coordinate systems, a procedure that is commonly called "time warping" [19] [2]. <p> The update rate specification we propose in this paper assumes a continuous time model: the synthetic scene can be sampled at arbitrary points in time. Note that computer graphics systems prefer continuous time models even when concentrating on modeling discontinuous, event-based behaviors <ref> [11] </ref>, due to the synthetic nature of computer graphics. Note also that we wish to maintain the continuous view of time; the introduction of temporal sampling is a necessary post-process that is executed on top of the continuous time model.
Reference: [12] <author> George Kyriazis. </author> <title> Time-critical rendering and the temporal behavior of graphics systems. </title> <type> Master's thesis, </type> <institution> Rensselaer Polytechnic Institute, VTP Program, Rensselaer Design Research Center, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: While a step in the right direction, the authors fail to recognize the full potential of being able to specify and control a multitude of update rates. Most recently, several researchers [13] <ref> [12] </ref> [5] [7] have independently started to address the problem of time-critical rendering. A time-critical renderer produces frames in prespecified amounts of time, degrading various renderer-specific attributes to achieve its goal. In effect, the user specifies the update rate for the renderer in relation to wall-time. <p> In addition, because for certain applications rendering constitutes the computational bottleneck, it is susceptible to be improved by new techniques such as time-critical computing. However, it is therefore also susceptible to hardware assistance, which complicates the time-critical rendering problem considerably <ref> [12] </ref>. In contrast, multimedia systems, being based on presampled data types that are inherently wall-time based, are aware of update rates. Recent work [6] [9] also addresses issues in controlling jitter and degrading the data stream in order to stay synchronized.
Reference: [13] <author> Robert O'Bara. </author> <title> Time rendering research. Draft of a thesis proposal, available from author on request, </title> <year> 1992. </year>
Reference-contexts: While a step in the right direction, the authors fail to recognize the full potential of being able to specify and control a multitude of update rates. Most recently, several researchers <ref> [13] </ref> [12] [5] [7] have independently started to address the problem of time-critical rendering. A time-critical renderer produces frames in prespecified amounts of time, degrading various renderer-specific attributes to achieve its goal. In effect, the user specifies the update rate for the renderer in relation to wall-time.
Reference: [14] <author> Paul S. Strauss (organizer), Ben Trumbore (organizer), Andrew Glassner, Eben Ostby, and Robert Zeleznik. </author> <title> Developing large-scale graphics software toolkits. </title> <booktitle> Course Notes of Course 03 at SIGGRAPH'93, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: The following partitioning is derived from Robert Zeleznik's contribution to <ref> [14] </ref>. In our view, a graphics system consists of several key modules. Each module encapsulates basic functionality and is self-contained to the extent of being interchangeable with another module that provides similar functionality. <p> Modern systems are often designed to easily expand 5 this module to include new shapes or attributes [24] [3], effectively allowing the interchange of the present module with one that has a richer set of primitives. As pointed out in <ref> [14] </ref>, sharing is practiced on many different levels. Sharing simplifies and automates the user's task of designing and modeling a coherent, synthetic scene.
Reference: [15] <author> Randy Pausch, Matthew Conway, Robert DeLine, Rich Gossweiler, Steve Miale, Jonathan Ashton, and Richard Stoakley. </author> <title> An interdisciplinary approach to building virtual reality environments. available form author on request, </title> <year> 1992. </year>
Reference-contexts: More recently, the concept of linking logical (modeling) time to real-time [1] has been rediscovered [3], allowing dynamic behavior to be synchronized to wall-time. None of the contemporary computer graphics systems we know of [24] [3] [21] [10] <ref> [15] </ref> [18] [5] handle update rate as an explicit concept. Accordingly, they cannot benefit from the advantages mentioned in Section 1. In particular, since update rate is implicit to the system, the user cannot control it. <p> Furthermore, because update rate is implicit, it is automatically set equal to the frame rate. (The work described in <ref> [15] </ref> is an exception; the authors distinguish two update rates | animation update rate and rendering frame rate | which are both operated in "as fast as possible mode." We discuss [15] in more detail below.) Therefore, efficiency is lost due to the uniform update rate for all objects, i.e., degrading <p> Furthermore, because update rate is implicit, it is automatically set equal to the frame rate. (The work described in <ref> [15] </ref> is an exception; the authors distinguish two update rates | animation update rate and rendering frame rate | which are both operated in "as fast as possible mode." We discuss [15] in more detail below.) Therefore, efficiency is lost due to the uniform update rate for all objects, i.e., degrading individual update rates is impossible. Various systems attempt to regain this lost efficiency, for example, via elaborate and costly caching schemes [24] or via complicated code analysis and compilation [3]. <p> Updating objects and attributes in this discrete fashion is the equivalent of sampling. However, since all of the dynamic behavior support has to reside within the timer objects, the user alone is responsible for modeling dynamic behavior, without support from Inventor. The Alice and DIVER system <ref> [15] </ref>, driven by the exacting processing needs of virtual reality, divorces animation frame rate from rendering frame rate. While a step in the right direction, the authors fail to recognize the full potential of being able to specify and control a multitude of update rates.
Reference: [16] <author> Randy Pausch, Tom Crea, and Matthew Conway. </author> <title> A literature survey for virtual environments: Military flight simulator visual systems and simulator sickness. Presence: Teleoperators and Virtual Environments, </title> <type> 1(3), </type> <month> January </month> <year> 1993. </year> <note> In press. </note>
Reference-contexts: Note that while this feature is merely "nice" for conventional desktop environments, it becomes essential for immersive environments to sustain the illusion of immersion and even avoid motion sickness [8] <ref> [16] </ref> due to lagging feedback. We imagine our time-critical graphics system to also incorporate multimedia data. Most multimedia data, for example, live or prerecorded audio and video streams, is inherently dynamic and sensitive to timing and synchronization issues.
Reference: [17] <author> Michael Sannella. </author> <title> The SkyBlue constraint solver. </title> <type> Technical Report 92-07-02, </type> <institution> Dept. of Computer Science and Engineering, University of Washington, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: It is conceivable to interchange such a one-way dependency module with a more powerful sharing module, e.g., a constraint solver such as SkyBlue <ref> [17] </ref>. We foresee that future graphics systems employ sharing modules that are based on optimizing constraint solvers and possibly more sophisticated mechanisms. The dynamics module allows the user to specify how the described synthetic scene changes over time, i.e., how objects, attributes, their relations, and their constraints vary dynamicly.
Reference: [18] <author> Paul S. Strauss and Rikk Carey. </author> <title> An object-oriented 3D graphics toolkit. </title> <booktitle> Computer Graphics (SIGGRAPH '92 Proceedings), </booktitle> <volume> 26(2) </volume> <pages> 341-349, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: More recently, the concept of linking logical (modeling) time to real-time [1] has been rediscovered [3], allowing dynamic behavior to be synchronized to wall-time. None of the contemporary computer graphics systems we know of [24] [3] [21] [10] [15] <ref> [18] </ref> [5] handle update rate as an explicit concept. Accordingly, they cannot benefit from the advantages mentioned in Section 1. In particular, since update rate is implicit to the system, the user cannot control it. <p> Various systems attempt to regain this lost efficiency, for example, via elaborate and costly caching schemes [24] or via complicated code analysis and compilation [3]. Worse, updating faster than frame rate is impossible [24] or done outside the usual evaluation process [3] <ref> [18] </ref>. While Inventor [18] does not address dynamic behavior per se, it is interesting that its builtin support for timers is potentially used for simulating dynamic behavior and even sampling. Timers are autonomous objects that are directly linked to wall-time. <p> Various systems attempt to regain this lost efficiency, for example, via elaborate and costly caching schemes [24] or via complicated code analysis and compilation [3]. Worse, updating faster than frame rate is impossible [24] or done outside the usual evaluation process [3] <ref> [18] </ref>. While Inventor [18] does not address dynamic behavior per se, it is interesting that its builtin support for timers is potentially used for simulating dynamic behavior and even sampling. Timers are autonomous objects that are directly linked to wall-time.
Reference: [19] <author> Mark A. Tarlton and P. Nong Tarlton. </author> <title> Visualization substrate: Animation, simulation and interaction in the user-interface. </title> <type> Technical Report ACT-HI-270-91(Q), </type> <institution> Microelectronics and Computer Technology Corporation (MCC), </institution> <year> 1991. </year>
Reference-contexts: Hierarchical coordinate systems, common in the space domain, are applied to time, e.g., as "time coordinate systems" [20] [21]. Finally, non-linear relationships over time link separate time coordinate systems, a procedure that is commonly called "time warping" <ref> [19] </ref> [2]. More recently, the concept of linking logical (modeling) time to real-time [1] has been rediscovered [3], allowing dynamic behavior to be synchronized to wall-time. None of the contemporary computer graphics systems we know of [24] [3] [21] [10] [15] [18] [5] handle update rate as an explicit concept.
Reference: [20] <author> Mark A. Tarlton and P. Nong Tarlton. </author> <title> A framework for dynamic visual applications. </title> <booktitle> Computer Graphics (1992 Symposium on Interactive 3D Graphics), </booktitle> <volume> 25(2) </volume> <pages> 161-164, </pages> <month> March </month> <year> 1992. </year> <month> 25 </month>
Reference-contexts: So far, the main thrust of these efforts has 3 introduced successful concepts in the space domain to the time domain. Ex--amples of these concepts include encapsulation, hierarchy, and non-linear relationships. Dynamic behaviors are encapsulated into reusable building blocks, e.g., as "time-dependent behaviors" <ref> [20] </ref> or "time graphs" [11]. Hierarchical coordinate systems, common in the space domain, are applied to time, e.g., as "time coordinate systems" [20] [21]. Finally, non-linear relationships over time link separate time coordinate systems, a procedure that is commonly called "time warping" [19] [2]. <p> Ex--amples of these concepts include encapsulation, hierarchy, and non-linear relationships. Dynamic behaviors are encapsulated into reusable building blocks, e.g., as "time-dependent behaviors" <ref> [20] </ref> or "time graphs" [11]. Hierarchical coordinate systems, common in the space domain, are applied to time, e.g., as "time coordinate systems" [20] [21]. Finally, non-linear relationships over time link separate time coordinate systems, a procedure that is commonly called "time warping" [19] [2]. More recently, the concept of linking logical (modeling) time to real-time [1] has been rediscovered [3], allowing dynamic behavior to be synchronized to wall-time.
Reference: [21] <author> Mark Alan Tarlton. </author> <title> A Declarative Representation System for Dynamic Visualization. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Ex--amples of these concepts include encapsulation, hierarchy, and non-linear relationships. Dynamic behaviors are encapsulated into reusable building blocks, e.g., as "time-dependent behaviors" [20] or "time graphs" [11]. Hierarchical coordinate systems, common in the space domain, are applied to time, e.g., as "time coordinate systems" [20] <ref> [21] </ref>. Finally, non-linear relationships over time link separate time coordinate systems, a procedure that is commonly called "time warping" [19] [2]. More recently, the concept of linking logical (modeling) time to real-time [1] has been rediscovered [3], allowing dynamic behavior to be synchronized to wall-time. <p> More recently, the concept of linking logical (modeling) time to real-time [1] has been rediscovered [3], allowing dynamic behavior to be synchronized to wall-time. None of the contemporary computer graphics systems we know of [24] [3] <ref> [21] </ref> [10] [15] [18] [5] handle update rate as an explicit concept. Accordingly, they cannot benefit from the advantages mentioned in Section 1. In particular, since update rate is implicit to the system, the user cannot control it.
Reference: [22] <author> Andries van Dam (chair), Salim Abi-Ezzi, Rick Carey, and Mark Tarlton. </author> <title> Graphics software architecture for the future notes of panel discussion at SIGGRAPH'92. </title> <journal> Computer Graphics (SIGGRAPH'92), </journal> <volume> 26 </volume> <pages> 389-390, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Such a system moves away from the viewpoint prevalent in the graphics community of "it takes as long as it takes to generate the next frame" towards a more user-friendly philosophy of guaranteeing certain response times <ref> [22] </ref> [5], heightening the user's perception of reality in dynamic, computer-generated scenes by making it act real [4].
Reference: [23] <author> Matthias M. </author> <title> Wloka. </title> <type> Thesis proposal: Time-critical graphics. Technical Report CS-93-50, </type> <institution> Brown University, Department of Computer Science, Providence, RI, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: on the supporting hardware, new technologies, e.g., time-critical computing, need to be explored. 1.1 Time Critical Computing Systems Our ultimate goal is to design and implement a graphics system that is time-critical, i.e., that trades quality for computation speed, thus allowing us to adhere to implicit and explicit timing information <ref> [23] </ref>.
Reference: [24] <author> Robert C. Zeleznik, D. Brookshire Conner, Matthias M. Wloka, Daniel G. Aliaga, Nathan T. Huang, Philip M. Hubbard, Brian Knep, Henry Kauf-man, John F. Hughes, and Andries van Dam. </author> <title> An object-oriented framework for the integration of interactive animation techniques. </title> <journal> Computer Graphics (SIGGRAPH'91 Proceedings), </journal> <volume> 25(4) </volume> <pages> 105-112, </pages> <month> July </month> <year> 1991. </year> <month> 26 </month>
Reference-contexts: Update rates are common to both multimedia and computer graphics. Most multimedia data is presampled and therefore has an implicit sampling or update rate associated with it. Computer graphics, while based on continuous time models <ref> [24] </ref> [3], is ultimately sampled, for example, when displaying discrete frames. Just as polygon resolution is a parameter that controls rendering quality of abstract graphics primitives, update rate is a parameter that controls rendered behavior quality. <p> More recently, the concept of linking logical (modeling) time to real-time [1] has been rediscovered [3], allowing dynamic behavior to be synchronized to wall-time. None of the contemporary computer graphics systems we know of <ref> [24] </ref> [3] [21] [10] [15] [18] [5] handle update rate as an explicit concept. Accordingly, they cannot benefit from the advantages mentioned in Section 1. In particular, since update rate is implicit to the system, the user cannot control it. <p> Various systems attempt to regain this lost efficiency, for example, via elaborate and costly caching schemes <ref> [24] </ref> or via complicated code analysis and compilation [3]. Worse, updating faster than frame rate is impossible [24] or done outside the usual evaluation process [3] [18]. <p> Various systems attempt to regain this lost efficiency, for example, via elaborate and costly caching schemes <ref> [24] </ref> or via complicated code analysis and compilation [3]. Worse, updating faster than frame rate is impossible [24] or done outside the usual evaluation process [3] [18]. While Inventor [18] does not address dynamic behavior per se, it is interesting that its builtin support for timers is potentially used for simulating dynamic behavior and even sampling. Timers are autonomous objects that are directly linked to wall-time. <p> It allows a user to describe synthetic scenes, often consisting of geometric shapes, lights, and cameras and all their associated attributes and operators. Modern systems are often designed to easily expand 5 this module to include new shapes or attributes <ref> [24] </ref> [3], effectively allowing the interchange of the present module with one that has a richer set of primitives. As pointed out in [14], sharing is practiced on many different levels. Sharing simplifies and automates the user's task of designing and modeling a coherent, synthetic scene. <p> The most common forms of sharing in graphics systems are inheritance and global data propagation networks. To simplify the graphics system's structure, it is advantageous to support all types of sharing via the same underlying mechanism, as done in <ref> [24] </ref>, where both hierarchical inheritance and global data propagation are implemented via the same one-way dependencies. It is conceivable to interchange such a one-way dependency module with a more powerful sharing module, e.g., a constraint solver such as SkyBlue [17]. <p> The glue module supplies the language that lets the user access all the functionality of the other modules consistently and coherently. To some extent, it is also responsible for integrating the functionality of the various modules. Graphics system's implementations for this module range from home-brew languages, e.g. FLESH <ref> [24] </ref>, to commercially available, high-level languages, e.g. Scheme [3]. Often, these languages are interpreted, and not compiled, to improve the user's ability to quickly prototype and view new geometric models and their behavior. All these modules must be integrated as equals to obtain maximum functionality. <p> Similarly, module functionality should be applicable to all (and not only some) primitives of other modules, e.g., dynamics should be applicable to all object attributes, including object type <ref> [24] </ref>. 6 3 How to Incorporate Update Rates in Today's Graphics Systems In this section we discuss how to incorporate update rates into graphics systems, namely, for which parts of the system update rates are specified (i.e., which incorporation model to choose), what operations on update rates are useful to ease
References-found: 24

