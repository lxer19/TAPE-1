URL: http://www.cs.unc.edu/~ehmann/Publications/thesis.ps.gz
Refering-URL: http://www.cs.unc.edu/~ehmann/
Root-URL: http://www.cs.unc.edu
Title: AN ARCHITECTURE FOR ACCELERATED ANISOTROPIC SHADING  
Author: BY STEPHEN EHMANN SUPERVISOR: M. VAN DE PANNE 
Degree: A THESIS SUBMITTED IN PARTIAL FULFILLMENT OF THE REQUIREMENTS FOR THE DEGREE OF BACHELOR OF APPLIED SCIENCE  
Date: APRIL 1998  
Affiliation: DIVISION OF ENGINEERING SCIENCE FACULTY OF APPLIED SCIENCE AND ENGINEERING UNIVERSITY OF TORONTO  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. D. Foley, A. van Dam, S. K. Feiner, and J. F. Hughes. </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: The evaluation of the Phong illumination model (equation (3.1)) is usually truncated to the range <ref> [0; 1] </ref> and then mapped linearly to the pixel value range. This can cause inaccuracies to occur in the shading if the user does not pick good constants and light source intensities correctly. <p> We will be aiming at developing an algorithm for implementation in hardware. Modern graphics hardware typically shade triangles by first evaluating Phong's illumination model at the vertices. Either Gouraud or Phong shading (see <ref> [1] </ref> for a description) is then applied to determine the pixel values for the rest of the triangle as it is scan converted. Gouraud shading is especially fast due to the fact that only three evaluations of the full illumination model are required to be able to shade each triangle. <p> PI) ); phi_r_weight = Fraction ( phi_r * num_phi_div / (2.0 * PI) ); /* Step 4: Perform quadrilinear interpolation (loop 16 times) */ brdf = 0.0; for ( I = each combination of lower/upper indices ) - W = set of weights for I; brdf += BRDF_Samples ( I <ref> [1] </ref>, I [2], I [3], I [4] ) * W [1] * W [2] * W [3] * W [4]; /* Step 5: Evaluate the illumination model */ result = La_ka + Li_ki * brdf * N_dot_S; 12 and reflected angles. <p> (2.0 * PI) ); /* Step 4: Perform quadrilinear interpolation (loop 16 times) */ brdf = 0.0; for ( I = each combination of lower/upper indices ) - W = set of weights for I; brdf += BRDF_Samples ( I <ref> [1] </ref>, I [2], I [3], I [4] ) * W [1] * W [2] * W [3] * W [4]; /* Step 5: Evaluate the illumination model */ result = La_ka + Li_ki * brdf * N_dot_S; 12 and reflected angles. <p> Note that upper indices need to be calculated as well. They are equal to the lower indices incremented by 1. Likewise, 1 minus the weights must be computed. This however, can be achieved by complementing the bits of the weight values which are assumed to lie in the range <ref> [0; 1] </ref>. A fixed point representation of the weights is assumed. This will not work if a weight is exactly 1 however, in which case 0 is the desired answer, so this must be checked as well.
Reference: [2] <author> J. T. Kajiya. </author> <title> Anisotropic reflection models. </title> <booktitle> Computer Graphics (Proc. </booktitle> <address> SIG-GRAPH '85), 19(3):1521, </address> <month> July </month> <year> 1985. </year>
Reference-contexts: Anisotropic models, on the other hand, are more complex, but do a better jobs of representing reality. Some of the analytic models are physically-based, and are usually tailored to model a restricted subset of all possible types of surfaces. One such example is given by Kajiya <ref> [2] </ref>. Other models suffer from the fact that they are not usually physically-based, forcing the user to provide a variety of parameters, as seen in the model developed by Poulin and Fournier [5]. <p> phi_r_weight = Fraction ( phi_r * num_phi_div / (2.0 * PI) ); /* Step 4: Perform quadrilinear interpolation (loop 16 times) */ brdf = 0.0; for ( I = each combination of lower/upper indices ) - W = set of weights for I; brdf += BRDF_Samples ( I [1], I <ref> [2] </ref>, I [3], I [4] ) * W [1] * W [2] * W [3] * W [4]; /* Step 5: Evaluate the illumination model */ result = La_ka + Li_ki * brdf * N_dot_S; 12 and reflected angles. <p> ); /* Step 4: Perform quadrilinear interpolation (loop 16 times) */ brdf = 0.0; for ( I = each combination of lower/upper indices ) - W = set of weights for I; brdf += BRDF_Samples ( I [1], I <ref> [2] </ref>, I [3], I [4] ) * W [1] * W [2] * W [3] * W [4]; /* Step 5: Evaluate the illumination model */ result = La_ka + Li_ki * brdf * N_dot_S; 12 and reflected angles.
Reference: [3] <author> P. Lalonde and A. Fournier. </author> <title> A wavelet representation of reflectance functions. </title> <journal> IEEE Transactions on Visualization and Computer Graphics, </journal> <volume> 3(4):329336, </volume> <month> October </month> <year> 1997. </year>
Reference-contexts: An example of the use of wavelets to do compression of reflectance functions is seen 1 Isotropic surfaces have reflective properties which are symmetric about the surface normal, while anisotropic surfaces do not. 1 in the work of Lalonde and Fournier <ref> [3] </ref>. Since we are more concerned with speed over accuracy, compression will be ignored and a less accurate representation will be opted for. The forthcoming discussion proposes a general model which attempts to capture the reflective properties of surfaces. First, an in-depth description is given of the reflectance function. <p> Fraction ( phi_r * num_phi_div / (2.0 * PI) ); /* Step 4: Perform quadrilinear interpolation (loop 16 times) */ brdf = 0.0; for ( I = each combination of lower/upper indices ) - W = set of weights for I; brdf += BRDF_Samples ( I [1], I [2], I <ref> [3] </ref>, I [4] ) * W [1] * W [2] * W [3] * W [4]; /* Step 5: Evaluate the illumination model */ result = La_ka + Li_ki * brdf * N_dot_S; 12 and reflected angles. <p> 4: Perform quadrilinear interpolation (loop 16 times) */ brdf = 0.0; for ( I = each combination of lower/upper indices ) - W = set of weights for I; brdf += BRDF_Samples ( I [1], I [2], I <ref> [3] </ref>, I [4] ) * W [1] * W [2] * W [3] * W [4]; /* Step 5: Evaluate the illumination model */ result = La_ka + Li_ki * brdf * N_dot_S; 12 and reflected angles.
Reference: [4] <author> B. Phong. </author> <title> Illumination for computer generated pictures. </title> <journal> Communications of the ACM, </journal> <volume> 18(6):311317, </volume> <month> June </month> <year> 1975. </year>
Reference-contexts: If one wishes to trade speed for representation space, a piece-wise quadricubic spline interpolation could be employed. 6 Chapter 3 Illumination Model In 1975, Phong proposed what has become the most widely used illumination model <ref> [4] </ref>. <p> phi_r * num_phi_div / (2.0 * PI) ); /* Step 4: Perform quadrilinear interpolation (loop 16 times) */ brdf = 0.0; for ( I = each combination of lower/upper indices ) - W = set of weights for I; brdf += BRDF_Samples ( I [1], I [2], I [3], I <ref> [4] </ref> ) * W [1] * W [2] * W [3] * W [4]; /* Step 5: Evaluate the illumination model */ result = La_ka + Li_ki * brdf * N_dot_S; 12 and reflected angles. <p> interpolation (loop 16 times) */ brdf = 0.0; for ( I = each combination of lower/upper indices ) - W = set of weights for I; brdf += BRDF_Samples ( I [1], I [2], I [3], I <ref> [4] </ref> ) * W [1] * W [2] * W [3] * W [4]; /* Step 5: Evaluate the illumination model */ result = La_ka + Li_ki * brdf * N_dot_S; 12 and reflected angles. The angles are then used to find the sixteen nearest samples forming a four dimensional hypercube in the angle space on which the BRDF is defined.
Reference: [5] <author> P. Poulin and A. Fournier. </author> <title> A model for anisotropic reflection. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '90), </booktitle> <address> 24(4):273282, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: One such example is given by Kajiya [2]. Other models suffer from the fact that they are not usually physically-based, forcing the user to provide a variety of parameters, as seen in the model developed by Poulin and Fournier <ref> [5] </ref>. Some of the parameters are non-intuitive and experimentation is usually required to get the reflective properties of the surface just right. Using a measured or simulated surface reflection function requires less expert knowledge about the model and less experimentation to get the necessary effects. A surface type selection suffices. <p> Each uses the same resolution: 32 divisions in azimuth, 8 divisions in altitude, and 900 rays were shot at the surface from each incident direction. The first surface is similar to the cylindrical method presented in <ref> [5] </ref>. The parameters used are d = 2r and h = 0 where r is the radius of the cylinders, d is the distance between the centres, and h is the height of the sea level from the centres.
Reference: [6] <author> F. X. Sillion and C. Puech. </author> <title> Radiosity & Global Illumination. </title> <publisher> Morgan Kauf-mann, </publisher> <year> 1994. </year> <month> 23 </month>
Reference-contexts: Directions are given as the vector of angles ~ w. Incident angles and directions are denoted with subscript `i' and reflected angles and directions with subscript `r'. A brief description of the BRDF will be given here. The interested reader is referred to <ref> [6] </ref> for more details, some useful BRDF's, and alternative representations. A familiarity with the concept of solid angles is assumed. The BRDF is defined as the ratio of radiance (L) in the reflected direction to the irradiance (F) in the incident direction at a point ~x. <p> The dw refers to an infinitesimal solid angle. The BRDF has values in the range [0; ) as the equation above shows. An example of a value of is in the BRDF of a perfect specular reflector which is defined using Dirac delta functions <ref> [6] </ref>. However, since the BRDF is determined by real devices, the uppermost value of this range will just be a large number. This causes problems when scaling intensity values to pixel values and will be addressed in Chapter 3.
References-found: 6

