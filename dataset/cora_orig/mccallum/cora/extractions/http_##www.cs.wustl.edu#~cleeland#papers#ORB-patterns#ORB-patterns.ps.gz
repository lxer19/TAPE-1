URL: http://www.cs.wustl.edu/~cleeland/papers/ORB-patterns/ORB-patterns.ps.gz
Refering-URL: http://www.cs.wustl.edu/~cleeland/papers/index.html
Root-URL: 
Email: fschmidt,cleelandg@cs.wustl.edu  
Phone: (314) 935-7538  
Title: Applying Patterns to Develop Extensible and Maintainable ORB Middleware Id ORB patterns:tex; v1:831998=01=1419 17 28levineExp  
Author: Douglas C. Schmidt and Chris Cleeland 
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science Washington University  
Abstract: Distributed object computing forms the basis for next-generation application middleware. At the heart of distributed object computing are Object Request Brokers (ORBs), which automate many tedious and error-prone distributed programming tasks. Like many other distributed applications, conventional ORBs use statically configured software designs, which are hard to maintain, port, and optimize. Likewise, conventional ORBs cannot be extended without modifying their source code, which forces recompilation, relinking, and restarting running ORBs and their associated application objects. This article makes two contributions to the study of extensible and maintainable ORB middleware. First, it presents a case study of key design patterns needed to develop ORBs that can be dynamically configured and evolved for specific application requirements and system characteristics. Second, we quantify the impact of applying patterns to reduce the complexity and improve the maintainability of common ORB tasks. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Johnson, </author> <title> Frameworks = Patterns + Components, </title> <journal> Communications of the ACM, </journal> <volume> vol. 40, </volume> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Four trends are shaping the future of commercial software development. First, the software industry is moving away from programming applications from scratch to integrating applications using reusable components <ref> [1] </ref> such as ActiveX and Java Beans. Second, there is great demand for distribution technology such as remote method invocation or message-oriented middleware that simplifies application collaboration within and across enterprises [2].
Reference: [2] <author> S. Landis and S. Maffeis, </author> <title> Building Reliable Distributed Systems with CORBA, </title> <booktitle> Theory and Practice of Object Systems, </booktitle> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: First, the software industry is moving away from programming applications from scratch to integrating applications using reusable components [1] such as ActiveX and Java Beans. Second, there is great demand for distribution technology such as remote method invocation or message-oriented middleware that simplifies application collaboration within and across enterprises <ref> [2] </ref>. Third, there are increasing efforts to define standard software infrastructures such as CORBA that allow applications to interwork seemlessly throughout hetero fl This research is supported in part by grants from Boeing, NSF grant NCR-9628218, Siemens, and Sprint. geneous environments [3].
Reference: [3] <author> S. Vinoski, </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments, </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 14, </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: Third, there are increasing efforts to define standard software infrastructures such as CORBA that allow applications to interwork seemlessly throughout hetero fl This research is supported in part by grants from Boeing, NSF grant NCR-9628218, Siemens, and Sprint. geneous environments <ref> [3] </ref>. Finally, next-generation distributed applications such as video-on-demand and teleconferencing require Quality of Service (QoS) guarantees for latency, bandwidth, and reliability [4]. A key software technology supporting these trends is distributed object computing (DOC) middleware. DOC middle-ware facilitates the collaboration of local and remote application components in heterogeneous distributed environments.
Reference: [4] <author> J. A. Zinky, D. E. Bakken, and R. Schantz, </author> <title> Architectural Support for Quality of Service for CORBA Objects, </title> <journal> Theory and Practice of Object Systems, </journal> <volume> vol. 3, no. 1, </volume> <year> 1997. </year>
Reference-contexts: Finally, next-generation distributed applications such as video-on-demand and teleconferencing require Quality of Service (QoS) guarantees for latency, bandwidth, and reliability <ref> [4] </ref>. A key software technology supporting these trends is distributed object computing (DOC) middleware. DOC middle-ware facilitates the collaboration of local and remote application components in heterogeneous distributed environments. The goal of DOC middleware is to eliminate many tedious, error-prone, and non-portable aspects of developing and maintaining distributed applications.
Reference: [5] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.0 ed., </editor> <month> July </month> <year> 1995. </year>
Reference-contexts: In particular, DOC middle-ware automates common network programming tasks such as object location, object activation, parameter marshaling, fault recovery, and security. At the heart of DOC middleware are Object Request Brokers (ORBs), such as CORBA <ref> [5] </ref>, DCOM [6], and Java RMI [7]. This article describes how design patterns can be used to develop dynamically configurable ORB middleware that can be extended and maintained more easily than conventional statically configured middleware. <p> ORB Core: When a client invokes an operation on a servant, the ORB Core is responsible for delivering the request to the servant and returning a response, if any, to the client. For servants executing remotely, a CORBA-compliant <ref> [5] </ref> ORB Core communicates via the Internet Inter-ORB Protocol (IIOP), a version of the General Inter-ORB Protocol (GIOP) which runs atop the TCP transport protocol. An ORB Core is typically implemented as a run-time library linked into client and server applications.
Reference: [6] <author> D. </author> <title> Box, Understanding COM. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1997. </year>
Reference-contexts: In particular, DOC middle-ware automates common network programming tasks such as object location, object activation, parameter marshaling, fault recovery, and security. At the heart of DOC middleware are Object Request Brokers (ORBs), such as CORBA [5], DCOM <ref> [6] </ref>, and Java RMI [7]. This article describes how design patterns can be used to develop dynamically configurable ORB middleware that can be extended and maintained more easily than conventional statically configured middleware.
Reference: [7] <author> A. Wollrath, R. Riggs, and J. Waldo, </author> <title> A Distributed Object Model for the Java System, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: In particular, DOC middle-ware automates common network programming tasks such as object location, object activation, parameter marshaling, fault recovery, and security. At the heart of DOC middleware are Object Request Brokers (ORBs), such as CORBA [5], DCOM [6], and Java RMI <ref> [7] </ref>. This article describes how design patterns can be used to develop dynamically configurable ORB middleware that can be extended and maintained more easily than conventional statically configured middleware. Generally defined, a pattern represents a recurring solution to a software development problem within a particular context [8].
Reference: [8] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: This article describes how design patterns can be used to develop dynamically configurable ORB middleware that can be extended and maintained more easily than conventional statically configured middleware. Generally defined, a pattern represents a recurring solution to a software development problem within a particular context <ref> [8] </ref>. Patterns help to alleviate the continual re-discovery and re-invention of software concepts and components by documenting proven solutions to standard software development problems [9]. For instance, patterns are useful for documenting the structure and participants in common communication software micro-architectures like Reactors [10], Active Objects [11], and Brokers [12]. <p> In addition to being tedious and error-prone, these APIs are not portable across OS platforms; many operating systems like Win32 and VxWorks, lack features like Pthreads. Section 3.3.1 illustrates how we used the Wrapper Facade pattern <ref> [8] </ref> to improve TAO's portability. * Lack of configurability: Like many ORBs and other mid-dleware, SunSoft IIOP is statically configured, which makes it hard to extend without modifying its source code directly. This violated a key design goal of TAO, namely dynamic adaptation to diverse application requirements and system environments. <p> This violated a key design goal of TAO, namely dynamic adaptation to diverse application requirements and system environments. Sections 3.3.7, 3.3.6, and 3.3.8 explain how we used the Abstract Factory <ref> [8] </ref>, Strategy [8], and Service Configurator [22] patterns to simplify the configurability of TAO for different use-cases. * Lack of software cohesion: Like many applications, Sun-Soft IIOP focuses on solving a specific problem, i.e., implementing an ORB Core and an IIOP protocol engine. <p> This violated a key design goal of TAO, namely dynamic adaptation to diverse application requirements and system environments. Sections 3.3.7, 3.3.6, and 3.3.8 explain how we used the Abstract Factory <ref> [8] </ref>, Strategy [8], and Service Configurator [22] patterns to simplify the configurability of TAO for different use-cases. * Lack of software cohesion: Like many applications, Sun-Soft IIOP focuses on solving a specific problem, i.e., implementing an ORB Core and an IIOP protocol engine. <p> The references point to additional material on each pattern. The intent and usage of these patterns are outlined below: The Wrapper Facade pattern: which simplifies the OS system programming interface by combining multiple related OS system calls like the socket API or POSIX Pthreads into cohesive OO abstractions <ref> [8] </ref>. TAO uses this pattern to avoid tedious, non-portable, and non-type-safe programming of low level, OS-specific system calls. 5 The Reactor pattern: which provides flexible event demul--tiplexing and event handler dispatching [10]. TAO uses this pattern to notify ORB-specific handlers synchronously when I/O events occur in the OS. <p> TAO uses this pattern to minimize lock contention and priority inversion for real-time applications. The Strategy pattern: which provides an abstraction for selecting one of several candidate algorithms and packaging it into an object <ref> [8] </ref>. This pattern is the foundation of TAO's extensible software architecture and makes it possible to configure custom ORB strategies for concurrency, communication, scheduling, and demultiplexing. The Abstract Factory pattern: which provides a single factory that builds related objects. <p> TAO uses this pattern to consolidate its dozens of Strategy objects into a manageable number of abstract factories that can be reconfigured en masse into clients and servers conveniently and consistently. TAO components use these factories to access related strategies without explicitly specifying their subclass name <ref> [8] </ref>. The Service Configurator pattern: which permits dynamic run-time configuration of abstract factories and strategies in an ORB [22]. <p> This pattern is a variant of the Facade pattern <ref> [8] </ref>. The intent of the Facade pattern is to simplify the interface for a subsystem. The intent of the Wrapper Facade pattern is more specific: it provides type-safe, modular, and portable class interfaces that encapsulate lower-level, stand-alone system mechanisms such as sockets, select, and Pthreads. <p> and transparent to other ORB components and (2) encapsulate the state and behavior of each strategy so that changes to one component do not permeate throughout an ORB haphazardly? Solution ! the Strategy pattern: An effective way to support multiple transparently pluggable ORB strategies is to apply the Strategy pattern <ref> [8] </ref>. This pattern factors out similarity among algorithmic alternatives and explicitly associates the name of a strategy with its algorithm and state. Moreover, the Strategy pattern removes lexical dependencies on strategy implementations since applications only access specialized behaviors through common base class interfaces. <p> VME backplane Medical Imaging Thread-per-connection FIFO Active demultiplexing TCP/IP Table 1: Example Applications and Their ORB Strategy Configurations enforce semantic consistency when combining discrete strategies? Solution ! the Abstract Factory pattern: An effective way to consolidate multiple ORB strategies into semantically compatible configurations is to apply the Abstract Factory pattern <ref> [8] </ref>. This pattern provides a single access point that integrates all strategies used to configure an ORB. Concrete subclasses then aggregate semantically compatible application-specific or domain-specific strategies, which can be replaced wholesale in semantically meaningful ways. <p> In general, the Abstract Factory pattern should be used when an application needs to consolidate the configuration of many strategies, each having multiple variations. Using the Abstract Factory pattern in TAO: All of TAO's ORB strategies are consolidated into two abstract factories implemented as Singletons <ref> [8] </ref>. One factory encapsulates client-specific strategies, while the factory shown in Figure 14 encapsulates server-specific strategies. These abstract factories encapsulate concurrency strategies in both the client and the server, and request demultiplexing, scheduling, and dispatch strategies in the server. <p> Not only does the use of monolithic methods increase the maintenance effort, it also degrades the TypeCode interpreter's performance due to reduced processor cache hits [33]. Therefore, we plan to experiment with the application of other patterns, such as Command and Template Method <ref> [8] </ref>, to simplify and optimize these monolithic methods into smaller, more cohesive methods. There are a few methods with v (G) greater than 10 which are not part of the TypeCode interpreter, and they will likely remain that way.
Reference: [9] <author> D. C. Schmidt, </author> <title> Experience Using Design Patterns to Develop Reuseable Object-Oriented Communication Software, </title> <journal> Communications of the ACM (Special Issue on Object-Oriented Experiences), </journal> <volume> vol. 38, </volume> <month> October </month> <year> 1995. </year>
Reference-contexts: Generally defined, a pattern represents a recurring solution to a software development problem within a particular context [8]. Patterns help to alleviate the continual re-discovery and re-invention of software concepts and components by documenting proven solutions to standard software development problems <ref> [9] </ref>. For instance, patterns are useful for documenting the structure and participants in common communication software micro-architectures like Reactors [10], Active Objects [11], and Brokers [12]. These patterns are generalizations of object-structures that have been used successfully to build flexible and efficient event-driven and concurrent communication software such as ORBs. <p> For instance, adding a new Secure Connection Handler that performs encryption/decryption of all traffic does not affect the implementation of the Reactor. Finally, unlike the event demultiplexing code in SunSoft IIOP, which is tightly coupled to one use-case, the ACE implementation of the Reactor pattern <ref> [9] </ref> used by TAO has been applied in many other OO event-driven applications ranging from HTTP servers [28] to real-time avionics infrastructure [14]. 3.3.3 Managing Connections in an ORB Using Acceptor Connector Pattern Context: Connection management is another key responsibility of an ORB Core.
Reference: [10] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, </editor> <booktitle> eds.), </booktitle> <pages> pp. 529545, </pages> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Patterns help to alleviate the continual re-discovery and re-invention of software concepts and components by documenting proven solutions to standard software development problems [9]. For instance, patterns are useful for documenting the structure and participants in common communication software micro-architectures like Reactors <ref> [10] </ref>, Active Objects [11], and Brokers [12]. These patterns are generalizations of object-structures that have been used successfully to build flexible and efficient event-driven and concurrent communication software such as ORBs. <p> TAO is a freely available, highly extensible ORB targeted for applications with real-time quality of 1 service (QoS) requirements. These applications include avion-ics mission computers [14], telecommunication switch management systems <ref> [10] </ref>, and electronic medical imaging systems [15]. A novel aspect of TAO is its extensible design, which can be customized dynamically to meet specific application QoS requirements and network/endsystem characteristics. <p> TAO uses this pattern to avoid tedious, non-portable, and non-type-safe programming of low level, OS-specific system calls. 5 The Reactor pattern: which provides flexible event demul--tiplexing and event handler dispatching <ref> [10] </ref>. TAO uses this pattern to notify ORB-specific handlers synchronously when I/O events occur in the OS. The Reactor pattern drives the main event loop in TAO's ORB Core, which accepts connections and receives/sends client requests/responses. <p> How then can an ORB implementation render itself independent of a specific event demultiplexing mechanism and decouple its demultiplexing code from its handling code? Solution ! the Reactor pattern: An effective way to reduce coupling and increase the extensibility of an ORB Core is to apply the Reactor pattern <ref> [10] </ref>. This pattern supports synchronous demultiplexing and dispatching of multiple event handlers, which are triggered by events that can arrive concurrently from multiple sources. The Reactor pattern simplifies event-driven applications by integrating the demultiplexing of events and the dispatching of their corresponding event handlers.
Reference: [11] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Patterns help to alleviate the continual re-discovery and re-invention of software concepts and components by documenting proven solutions to standard software development problems [9]. For instance, patterns are useful for documenting the structure and participants in common communication software micro-architectures like Reactors [10], Active Objects <ref> [11] </ref>, and Brokers [12]. These patterns are generalizations of object-structures that have been used successfully to build flexible and efficient event-driven and concurrent communication software such as ORBs. <p> TAO uses this pattern in the ORB Core on servers and clients to passively and actively establish GIOP connections that are independent of the underlying transport mechanisms. The Active Object pattern: which supports flexible con-currency architectures by decoupling request reception from request execution <ref> [11] </ref>. TAO uses this pattern to facilitate the use of multiple concurrency strategies that can be configured flexibly into its ORB Core at run-time. <p> How then can an ORB support a simple, extensible, and portable concurrency mechanism? Solution ! the Active Object pattern: An effective way to increase the portability, correctness, and extensibility of ORB concurrency strategies is to apply the Active Object pattern <ref> [11] </ref>. This pattern provides a higher-level concurrency architecture that decouples the thread that initially receives and processes a client request from the thread that ultimately executes the request. While Wrapper Facades provide the genesis for portability, they are simply thin veneers over the low-level system mechanisms.
Reference: [12] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: Patterns help to alleviate the continual re-discovery and re-invention of software concepts and components by documenting proven solutions to standard software development problems [9]. For instance, patterns are useful for documenting the structure and participants in common communication software micro-architectures like Reactors [10], Active Objects [11], and Brokers <ref> [12] </ref>. These patterns are generalizations of object-structures that have been used successfully to build flexible and efficient event-driven and concurrent communication software such as ORBs. To focus the discussion, this article presents a case study that illustrates how we have applied patterns to develop The ACE ORB (TAO) [13].
Reference: [13] <author> D. C. Schmidt, D. L. Levine, and S. Mungee, </author> <title> The Design and Performance of Real-Time Object Request Brokers, </title> <journal> Computer Communications, </journal> <note> to appear, </note> <year> 1998. </year>
Reference-contexts: These patterns are generalizations of object-structures that have been used successfully to build flexible and efficient event-driven and concurrent communication software such as ORBs. To focus the discussion, this article presents a case study that illustrates how we have applied patterns to develop The ACE ORB (TAO) <ref> [13] </ref>. TAO is a freely available, highly extensible ORB targeted for applications with real-time quality of 1 service (QoS) requirements. These applications include avion-ics mission computers [14], telecommunication switch management systems [10], and electronic medical imaging systems [15]. <p> CORBA and ORB endsystems: * Identifying enhancements to standard ORB specifications, particularly OMG CORBA, that will enable applications to specify their QoS requirements concisely to ORB endsystems [17]. * Empirically determining the features required to build real-time ORB endsystems that can enforce deterministic and statistical end-to-end application QoS guaran tees <ref> [13] </ref>. * Integrating the strategies for I/O subsystem architectures and optimizations [18] with ORB middleware to provide end-to-end bandwidth, latency, and reliability guarantees to distributed applications. * Capturing and documenting the key design patterns [19] necessary to develop, maintain, configure, and extend real-time ORB endsystems. <p> are specified and enforced end-to-end [20]. * Real-time Object Adapter and ORB Core: In addition to associating servants with the ORB and demultiplexing incoming requests to servants, TAO's Object Adapter (OA) implementation dispatches servant operations in accordance with various real-time scheduling strategies such as Rate Monotonic and Earliest Deadline First <ref> [13] </ref>. * ORB QoS Interface: Applications can use TAO's QoS interface to map real-time processing requirements to ORB endsystem/network resources. Common real-time processing requirements include end-to-end latency bounds and periodic scheduling deadlines. <p> TAO implements many of these missing features and also provides several new features such as real-time scheduling and dispatching mechanisms <ref> [13] </ref>. * Lack of portability: Like most communication software, SunSoft IIOP is directly programmed with low-level networking and OS APIs such as sockets, select, and POSIX Pthreads.
Reference: [14] <author> T. H. Harrison, D. L. Levine, and D. C. Schmidt, </author> <title> The Design and Performance of a Real-time CORBA Event Service, </title> <booktitle> in Proceedings of OOPSLA '97, </booktitle> <address> (Atlanta, GA), </address> <publisher> ACM, </publisher> <month> October </month> <year> 1997. </year>
Reference-contexts: To focus the discussion, this article presents a case study that illustrates how we have applied patterns to develop The ACE ORB (TAO) [13]. TAO is a freely available, highly extensible ORB targeted for applications with real-time quality of 1 service (QoS) requirements. These applications include avion-ics mission computers <ref> [14] </ref>, telecommunication switch management systems [10], and electronic medical imaging systems [15]. A novel aspect of TAO is its extensible design, which can be customized dynamically to meet specific application QoS requirements and network/endsystem characteristics. <p> Time inefficiency can stem from restricting an ORB to use statically configured algorithms or data structures for key processing tasks. This can make it hard for application developers to customize an ORB to handle new user-cases. For instance, real-time avionics mission computing systems <ref> [14] </ref> can instantiate all their servants off-line. These systems can benefit from an ORB that uses perfect hashing [24] to demultiplex incoming requests to servants. However, ORBs that are configured statically to use a general-purpose, one-size-fits-all demulti-plex strategy will not perform as well for mission computing systems. <p> Finally, unlike the event demultiplexing code in SunSoft IIOP, which is tightly coupled to one use-case, the ACE implementation of the Reactor pattern [9] used by TAO has been applied in many other OO event-driven applications ranging from HTTP servers [28] to real-time avionics infrastructure <ref> [14] </ref>. 3.3.3 Managing Connections in an ORB Using Acceptor Connector Pattern Context: Connection management is another key responsibility of an ORB Core. For instance, an ORB Core that implements the IIOP protocol must establish TCP connections and initialize the protocol handlers for each IIOP server endpoint. <p> It is important to develop efficient concurrent ORBs. For instance, concurrency allows long-running tasks to execute simultaneously without impeding the progress of other tasks. Likewise, preemptive multi-threading is crucial to minimize the dispatch latency of real-time systems <ref> [14] </ref>. Concurrency is often implemented via the multi-threading capabilities available on OS platforms. For instance, SunSoft IIOP supports the two concurrency architectures shown in Figure 10: a single-threaded Reactive architecture and a thread-per-connection architecture. <p> Several of these strategies are illustrated in Figure 13. For instance, TAO supports multiple request demultiplexing strategies (e.g., perfect hashing vs. active demultiplexing [24]) and scheduling strategies (i.e., FIFO vs. rate monotonic vs. earliest deadline first <ref> [14] </ref>) in its Object Adapter, as well as connection management strategies (e.g., process-wide cached connections vs. thread-specific cached connections) and handler concurrency strategies (e.g., Reactive vs. variations of Active Objects) in its ORB Core. 3.3.7 Consolidate ORB Strategies Using the Abstract Factory Pattern Context: There are dozens of potential strategy variants <p> Table 1 shows a simple example of the strategies used to create two configurations of TAO. One is an avionics application with hard real-time requirements <ref> [14] </ref> and the other is an electronic medical imaging application [15] with high throughput requirements.
Reference: [15] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: TAO is a freely available, highly extensible ORB targeted for applications with real-time quality of 1 service (QoS) requirements. These applications include avion-ics mission computers [14], telecommunication switch management systems [10], and electronic medical imaging systems <ref> [15] </ref>. A novel aspect of TAO is its extensible design, which can be customized dynamically to meet specific application QoS requirements and network/endsystem characteristics. <p> Table 1 shows a simple example of the strategies used to create two configurations of TAO. One is an avionics application with hard real-time requirements [14] and the other is an electronic medical imaging application <ref> [15] </ref> with high throughput requirements. In general, the forces that must be resolved to compose all ORB strategies correctly are the need to (1) ensure the configuration of semantically compatible strategies and (2) simplify the management of a large number of individual strategies.
Reference: [16] <author> E. Eide, K. Frei, B. Ford, J. Lepreau, and G. Lindstrom, </author> <month> Flick: </month>
Reference-contexts: Conversely, skeletons demarshal the packet-level representation back into typed data that is meaningful to an application. An IDL compiler automatically transforms OMG IDL definitions into an application programming language like C++ or Java. IDL compilers eliminate common sources of network programming errors and provide opportunities for automated compiler optimizations <ref> [16] </ref>. Dynamic Invocation Interface (DII): The DII allows a client to access the underlying request transport mechanisms provided by the ORB Core. The DII is useful when an application has no compile-time knowledge of the interface it is accessing.
References-found: 16

