URL: http://renoir.csc.ncsu.edu/Faculty/Vouk/Papers/Predicate.ps
Refering-URL: http://renoir.csc.ncsu.edu/UNET/Personnel/vouk.Jan96.html
Root-URL: http://www.csc.ncsu.edu
Title: A Predicate-Based Software Testing Strategy  
Author: K. C. Tai M. A. Vouk A. Paradkar and P. Lu 
Abstract: In this paper, we describe the basic theory underlying BOR (boolean operator) testing and BRO (boolean and relational operator) testselection criteria, and discuss experimental evidence that shows that BOR testing requires a far smaller number of test-cases than some more traditional strategies, while retaining fault-detection capabilities that are as good as, or better than these strategies. The approach we describe can be used to develop test cases based on software specifications, or based on the implementation, that is, it can be used for both functional and structural testing. We evaluate the BOR strategy with respect to branch testing, traditional cause-effect graph testing, and informal functional and random testing. Two simulation experiments showed that BOR testing is very effective at detecting faults in predicates. We also performed two experiments where we applied BOR strategy to software specification cause-effect graphs of a real-time control system and a set of N-version programs. Our results indicate that BOR testing is practical, and has detected faults that the previously applied strategies have not. 
Abstract-found: 1
Intro-found: 1
Reference: [Adr82] <author> W.R. Adrion, M.A. Branstad and J.C. Cherniavsky, </author> <title> "Validation, verification, and testing of computer software", </title> <journal> ACM Computing Survey, </journal> <volume> Vol 14(2), </volume> <pages> 159-192, </pages> <year> 1982. </year>
Reference-contexts: 1. Introduction There are two basic ways of showing that code is 100% correct program proving and exhaustive testing <ref> [Adr82, And74, How87] </ref>. Neither technique, as yet, is an option when it comes to major real-life systems. Techniques for proving software correct are not mature enough, while exhaustive testing is not practical because the costs are prohibitive.
Reference: [Ake78] <author> Akers, S. B., </author> <title> "Binary decision diagrams", </title> <journal> IEEE Trans. Computers, </journal> <volume> Vol. C-27, No. 6, </volume> <month> June </month> <year> 1978, </year> <pages> 509-516. </pages>
Reference-contexts: BDD Path Testing For a compound predicate C, this strategy requires that all paths in the BDD (binary decision diagram) of C be covered at least once. The notion of BDDs has been used in the representation, verification and testing of boolean functions and logical circuits <ref> [Ake78, Bry86] </ref>. The BDD of a compound predicate is equivalent to the compound predicate modified by replacing "AND" and "OR" with "AND THEN" and "OR ELSE", respectively. (For C1 AND THEN C2, if C1 is false, then C2 is ignored.
Reference: [Anr74] <author> R. Anderson, </author> <title> "Proving programs correct", </title> <editor> J. </editor> <publisher> Wiley, </publisher> <year> 1974 </year>
Reference: [Bei90] <author> B. Beizer, </author> <title> Software Testing Techniques, 2nd edition, </title> <publisher> Van Nostrand, </publisher> <year> 1990. </year>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others <ref> [How87, Bei90] </ref>. The field of evaluation of testing strategies is very active and a number of theoretical [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] and experimental [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] studies are available. <p> In our study, the shutdown CEG was constructed by one person in about 20 hours, and CEG-based test-case generation can be automated. Also, CEGs can be analyzed for the detection of ambiguities and inconsistencies in system specification <ref> [Mye79, Bei90] </ref>. It is obvious, that use of CEGs for software specification and test generation has significant advantages. 6.4 Measurement of BOR Coverage of a Module in the Boiler's Implementation As mentioned earlier, we chose one module in the boiler control software implementation to sample the BOR coverage.
Reference: [Bry86] <author> Bryant, R. E., </author> <title> Graph-based algorithms for boolean function manipulation", </title> <journal> IEEE Trans. Computers, </journal> <volume> C-35, No. 8, </volume> <month> August </month> <year> 1986, </year> <pages> 677-691. </pages>
Reference-contexts: BDD Path Testing For a compound predicate C, this strategy requires that all paths in the BDD (binary decision diagram) of C be covered at least once. The notion of BDDs has been used in the representation, verification and testing of boolean functions and logical circuits <ref> [Ake78, Bry86] </ref>. The BDD of a compound predicate is equivalent to the compound predicate modified by replacing "AND" and "OR" with "AND THEN" and "OR ELSE", respectively. (For C1 AND THEN C2, if C1 is false, then C2 is ignored.
Reference: [Cla85] <author> L.A. Clarke, A. Podgurski, D. Richardson, and S. Zeil, </author> <title> "A comparison of data flow path selection criteria," </title> <booktitle> in Proc. 8th ICSE, </booktitle> <pages> pp 244-251, </pages> <year> 1985. </year>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical <ref> [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] </ref> and experimental [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions.
Reference: [Dur84] <author> J.W. Duran and S.C. Ntafos, </author> <title> "An Evaluation of Random Testing," </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. SE-10, </volume> <pages> pp. 438-444, </pages> <year> 1984. </year>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] and experimental <ref> [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] </ref> studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions.
Reference: [Elm73] <author> Elmendorf, W. R., </author> <title> "Cause-effect graphs in functional testing", </title> <institution> TR-00.2487, IBM Systems Development Division, </institution> <address> Poughkeepsie, NY, </address> <year> 1973. </year>
Reference-contexts: For C#, -t3, t4, t5, t6) satisfies the constraint set satisfied by -t7, t8, t9, t10-, but not vice versa. Elmendorf's Algorithm The notion of cause-effect graphs (CEGs) was developed for system specification and test generation <ref> [Elm73, Mye79] </ref>. A CEG consists of causes, effects, and graphical notations expressing logical relationships among causes and effects. A cause is an input condition, an effect is an output condition, and logical operators include AND ("^"), OR ("V"), and NOT ("~"). <p> A cause is an input condition, an effect is an output condition, and logical operators include AND ("^"), OR ("V"), and NOT ("~"). In [Mye79] a test generation algorithm for cause-effect graphs was described, which was developed by Elmendorf <ref> [Elm73] </ref>. Since a cause-effect graph is a collection of compound predicates, Elmendorf's algorithm can be applied to generate tests for a compound predicate.
Reference: [For93] <author> Foreman L. M., and Zweben S. H., </author> <title> "A study of the effectiveness of control and data flow testing strategies", </title> <journal> J. Systems Software, </journal> <volume> No. 21, </volume> <year> 1993, </year> <pages> 215-228. </pages>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] and experimental <ref> [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] </ref> studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions. <p> But the programs considered in these studies were small, and some of the defects in these programs were deliberately manipulated to satisfy the constraints of the experiment. <ref> [For93] </ref> reports results on the effectiveness of control and data flow testing strategies as applied to a subset of defects observed in the development of the computer typesetting program TeX.
Reference: [Fra88] <author> P.G. Frankl and E.J. Weyuker, </author> <title> "An applicable family of data flow testing criteria," </title> <journal> IEEE Trans. Soft. Eng., </journal> <volume> Vol. 14 (10), </volume> <pages> pp 1483-1498, </pages> <year> 1988. </year>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical <ref> [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] </ref> and experimental [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions. <p> Each of the five programs (using individual drivers) was tested by two different test sets, one with 1,000 randomly selected tests the other with 103 manually selected functional tests (i.e., special value functional tests). For each of these five programs, the coverages of puses <ref> [Fra88, Wey88] </ref>, BRO constraints, branches and statements was measured. The results are summarized in Figures 6 to 9. The programs are marked L1 through L5. The figures show the BRO and branch code coverage achieved by functional and random specification-based test cases.
Reference: [Fra93a] <author> Frankl, P. G., and Weyuker, E. J., </author> <title> "A formal analysis of the fault-detecting ability of testing methods", </title> <journal> IEEE TSE, </journal> <volume> Vol. 19, No. 3, </volume> <month> Mar. </month> <year> 1993, </year> <pages> 202-213. </pages>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical <ref> [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] </ref> and experimental [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions. <p> Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions. For example, it has been shown in <ref> [Fra93a, Fra93b] </ref> that the structural metric of data flow testing has better coverage and fault exposure properties than the decision metric of branch testing.
Reference: [Fra93b] <author> Frankl, P. G., and Weiss S. N., </author> <title> "An experimental comparison of the effectiveness of branch testing and data flow testing", </title> <journal> IEEE TSE, </journal> <volume> Vol. 19, No. 8, </volume> <month> Aug. </month> <year> 1993, </year> <pages> 774-787. </pages>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] and experimental <ref> [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] </ref> studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions. <p> Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions. For example, it has been shown in <ref> [Fra93a, Fra93b] </ref> that the structural metric of data flow testing has better coverage and fault exposure properties than the decision metric of branch testing.
Reference: [Ham90] <author> Hamlet, D., and Taylor, R., </author> <title> "Partition testing does not inspire confidence", </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> Vol. 16, No. 12, </volume> <month> Dec. </month> <year> 1990, </year> <pages> 1402-1411. </pages>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical <ref> [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] </ref> and experimental [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions. <p> The task of generating these special and boundary value test cases is tedious as it involved careful inspection of the code. On the other hand, Hamlet has put forward arguments which indicate that "in testing for true reliability clever partition methods may be no better than random testing" <ref> [Ham92, Ham90] </ref>. In this paper we focus on evaluation of a particular set of predicate-based test generation and selection criteria, called boolean operator (BOR) and boolean and relational operator (BRO) testing, that have been proposed by Tai [Tai87, Tai93].
Reference: [Ham92] <author> Hamlet, D., </author> <title> "Are we testing for true reliability", </title> <journal> IEEE Software, </journal> <month> Jul. </month> <year> 1992, </year> <pages> 21-27. </pages>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical <ref> [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] </ref> and experimental [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions. <p> The task of generating these special and boundary value test cases is tedious as it involved careful inspection of the code. On the other hand, Hamlet has put forward arguments which indicate that "in testing for true reliability clever partition methods may be no better than random testing" <ref> [Ham92, Ham90] </ref>. In this paper we focus on evaluation of a particular set of predicate-based test generation and selection criteria, called boolean operator (BOR) and boolean and relational operator (BRO) testing, that have been proposed by Tai [Tai87, Tai93].
Reference: [How82] <author> Howden, W. E., </author> <title> "Weak mutation testing and completeness of test cases," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> Vol. SE-8, No. 4, </volume> <month> July </month> <year> 1982, </year> <pages> 371-379. </pages>
Reference-contexts: Relational Operator Testing For a relational expression, say (E &lt;rop&gt; E"), this strategy requires three tests satisfying the following requirements <ref> [How82] </ref>: (1) one test makes E &gt; E", (2) one test makes E &lt; E", and (3) one test makes E = E". If &lt;rop&gt; is incorrect and E and E" are correct, then this strategy guarantees the detection of the incorrect &lt;rop&gt;.
Reference: [How87] <author> W.E. Howden, </author> <title> "Functional Program Testing and Analysis", </title> <publisher> McGraw-Hill Book Co., </publisher> <year> 1987. </year>
Reference-contexts: 1. Introduction There are two basic ways of showing that code is 100% correct program proving and exhaustive testing <ref> [Adr82, And74, How87] </ref>. Neither technique, as yet, is an option when it comes to major real-life systems. Techniques for proving software correct are not mature enough, while exhaustive testing is not practical because the costs are prohibitive. <p> A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others <ref> [How87, Bei90] </ref>. The field of evaluation of testing strategies is very active and a number of theoretical [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] and experimental [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] studies are available.
Reference: [IRR93] <author> Inst. </author> <title> for Risk Research, "Generic problem competition", </title> <booktitle> International Symposium Design and Review of Software Controlled Safety-Related Systems, </booktitle> <address> Waterloo, Canada, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The specifications were developed as part of the the generic problem exercise conducted for the 1993 International Workshop on the Design and Review of Software Controlled Safety-Related Systems <ref> [IRR93] </ref>. A version of the boiler control and monitoring system was developed at North Carolina State University [Vou93a]. This software was used in our empirical study. A brief description of the boiler system is given below. <p> request if any are discovered, (c) to display at all times "best estimates" of various readings for the boiler operator, and (d) to accept any appropriate operator commands. 6.1 Motivation, Objectives, and Procedures During the development of the boiler system at NCSU, the original, informal, specification of the 19 system <ref> [IRR93] </ref> was rewritten in terms of a number of extended finitestate machines 5 (EFSMs), and test suites for the unit, integration and system testing of the boiler system were constructed according to the boiler's EFSM specification [Par93].
Reference: [Kor88] <author> B. Koren and J. Laski, </author> <title> "STAD - A system for testing and debugging: user perspective," </title> <booktitle> Proc. Second Workshop on Software Testing, Verification, and 30 Analysis, </booktitle> <address> Banff, Canada, </address> <publisher> Computer Society Press, </publisher> <pages> pp 13 - 20, </pages> <year> 1988. </year>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical <ref> [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] </ref> and experimental [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions.
Reference: [Mye79] <author> Myers, G. J., </author> <title> The Art of Software Testing, </title> <publisher> Wiley, </publisher> <year> 1979. </year>
Reference-contexts: For C#, -t3, t4, t5, t6) satisfies the constraint set satisfied by -t7, t8, t9, t10-, but not vice versa. Elmendorf's Algorithm The notion of cause-effect graphs (CEGs) was developed for system specification and test generation <ref> [Elm73, Mye79] </ref>. A CEG consists of causes, effects, and graphical notations expressing logical relationships among causes and effects. A cause is an input condition, an effect is an output condition, and logical operators include AND ("^"), OR ("V"), and NOT ("~"). <p> A CEG consists of causes, effects, and graphical notations expressing logical relationships among causes and effects. A cause is an input condition, an effect is an output condition, and logical operators include AND ("^"), OR ("V"), and NOT ("~"). In <ref> [Mye79] </ref> a test generation algorithm for cause-effect graphs was described, which was developed by Elmendorf [Elm73]. Since a cause-effect graph is a collection of compound predicates, Elmendorf's algorithm can be applied to generate tests for a compound predicate. <p> More discussion on infeasible constraints can be found in [Tai93]. 3 . Testing Based on Cause-Effect Graphs The CEG for a software system can be analyzed to determine its completeness and consistency <ref> [Mye79] </ref>. Also, the CEG provides a basis for deriving specification-based test cases for the software system. One approach to test generation is to consider all possible combinations of causes. <p> In our study, the shutdown CEG was constructed by one person in about 20 hours, and CEG-based test-case generation can be automated. Also, CEGs can be analyzed for the detection of ambiguities and inconsistencies in system specification <ref> [Mye79, Bei90] </ref>. It is obvious, that use of CEGs for software specification and test generation has significant advantages. 6.4 Measurement of BOR Coverage of a Module in the Boiler's Implementation As mentioned earlier, we chose one module in the boiler control software implementation to sample the BOR coverage.
Reference: [Nag82] <author> Nagel, P. M., and Skrivan J. A., </author> <title> "Software reliability: Repetitive run experimentation and modelling", </title> <institution> BSC-40336, Boeing, </institution> <address> Seattle, Wa., </address> <year> 1982. </year>
Reference-contexts: Six functionally equivalent programs were produced as part of another study [Vou86a, Vou86b]. Programs solve a navigational problem, an extended version of the "Earth Satellite Problem" used by Nagle et al. <ref> [Nag82] </ref>. They were written independently by graduate level students to the same specification. The programming language was Pascal. The size of the Pascal programs ranged from 400 to 800 Pascal statements.
Reference: [Nta84] <author> S.C. Ntafos, </author> <title> "On Required Element Testing", </title> <journal> IEEE Trans. Soft. Eng., </journal> <volume> Vol. SE-10, </volume> <pages> pp 793-803, </pages> <year> 1984. </year>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] and experimental <ref> [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] </ref> studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions.
Reference: [Nta88] <author> S.C. Ntafos, </author> <title> "A Comparison of Some Structural Testing Strategies", </title> <journal> IEEE Trans. Soft. Eng., </journal> <volume> Vol. SE-14 (6), </volume> <pages> pp 868-874, </pages> <year> 1988. </year>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] and experimental <ref> [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] </ref> studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions.
Reference: [Par93] <author> A. Paradkar, I. Shields, and J. Waters, </author> <title> "The NCSU Solution to the Generic Problem Exercise: Boiler Control and Monitoring System,", </title> <address> NCSU, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: of the boiler system at NCSU, the original, informal, specification of the 19 system [IRR93] was rewritten in terms of a number of extended finitestate machines 5 (EFSMs), and test suites for the unit, integration and system testing of the boiler system were constructed according to the boiler's EFSM specification <ref> [Par93] </ref>. The EFSM specification-based test suites were then developed to ensure thorough testing of the boiler system. In addition to the coverage of every state and branch of individual EFSMs, great effort was made to construct additional test cases to cover special event situations.
Reference: [Tai87] <author> Tai, K. C., and Su, H. K., </author> <title> "Test generation for boolean expressions," </title> <booktitle> Proc. COMPSAC (Computer Software and Applications) '87, </booktitle> <year> 1987, </year> <pages> 278-283. </pages>
Reference-contexts: In this paper we focus on evaluation of a particular set of predicate-based test generation and selection criteria, called boolean operator (BOR) and boolean and relational operator (BRO) testing, that have been proposed by Tai <ref> [Tai87, Tai93] </ref>. The BOR testing strategy for a predicate requires a test set to guarantee the detection of boolean operator faults. <p> A test set T for a boolean expression B is said to be a BOR test set for B if T satisfies the BOR testing strategy for B. In <ref> [Tai87] </ref> we showed that a BOR test set for a boolean expression is very effective for detecting all types of boolean expression faults, including boolean operator faults, incorrect boolean variables and parentheses, and their combinations.
Reference: [Tai93] <author> Tai, K. C., </author> <title> "Predicate-based test generation for computer programs", </title> <booktitle> Proc. Inter. Conf. on Software Engineering, </booktitle> <month> May </month> <year> 1993, </year> <pages> 267-276. </pages>
Reference-contexts: In this paper we focus on evaluation of a particular set of predicate-based test generation and selection criteria, called boolean operator (BOR) and boolean and relational operator (BRO) testing, that have been proposed by Tai <ref> [Tai87, Tai93] </ref>. The BOR testing strategy for a predicate requires a test set to guarantee the detection of boolean operator faults. <p> An ideal strategy would be reliable and valid for all P. 2.2 Strategies In this section we provide an overview of several predicate testing strategies that are related to our empirical studies. More details can be found in <ref> [Tai93] </ref>. The predicate ((E1&lt;E2) & (E3&gt;=E4)) | (E5=E6), where Ei, 1&lt;=i&lt;=6, denotes an arithmetic expression and is shown in Figure 1. We will call it C# and use it below to illustrate different predicate testing strategies. <p> An algorithm, called BOR_GEN, for generating a minimum BOR constraint set for a compound predicate was given in <ref> [Tai93] </ref>. For a predicate with n, n&gt;0, AND/OR operators, its minimum BOR constraint set contains at most n+2 constraints. For a compound predicate, BOR testing requires the coverage of a minimum BOR constraint set for this predicate. <p> The constraint set -(t,t,*), (t,f,t), (t,f,f), (f,*,f)- does not guarantee to distinguish C# from the following two predicate ((E1&lt;E2) | (E3&gt;=E4)) & (E5=E6) which differ from C# in boolean operators only. A constraint generation algorithm for BDD path testing was given in <ref> [Tai93] </ref>. For a predicate with n, n&gt;0, AND/OR operators, this testing strategy requires (n+2) or more, up to O (2**n), constraints. BDD path testing requires at least as many as tests as BOR testing, but these two testing strategies are incomparable. <p> A algorithm, called BRO_GEN for generating a minimum BRO constraint set for a compound predicate was given in <ref> [Tai93] </ref>. For a predicate with n, n&gt;0, AND/OR operators, its minimum BRO constraint set contains at most 2*n+3 constraints. For a compound predicate, BRO testing requires the coverage of a minimum BRO constraint set for this predicate. <p> Consider the predicate C#. If a constraint for C# can never be covered by any test for C#, it is said to be an infeasible constraint for C#. More discussion on infeasible constraints can be found in <ref> [Tai93] </ref>. 3 . Testing Based on Cause-Effect Graphs The CEG for a software system can be analyzed to determine its completeness and consistency [Mye79]. Also, the CEG provides a basis for deriving specification-based test cases for the software system. <p> Since a CEG represents a set of compound predicates, the BOR testing strategy can be applied to generate tests. For the sake of simplicity, each cause node is viewed as a boolean variable and has "t" or "f" as its value. In <ref> [Tai93] </ref>, algorithm BOR_GEN produces a minimum BOR constraint set for a compound predicate.
Reference: [Voa91] <author> Voas, J. M., </author> <title> "Preliminary observations on program testability", </title> <booktitle> Proc. Pacific Northwest Quality Conf., </booktitle> <address> PNQC, Portland, </address> <year> 1991, </year> <pages> 235-247. </pages>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] and experimental <ref> [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] </ref> studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions.
Reference: [Voa93] <author> Voas, J. M., and Miller, K. W., </author> <title> "Improving the software development process using testability research", </title> <booktitle> Proc. Third International Symposium on Software Reliability Engineering, </booktitle> <year> 1993, </year> <pages> 114-121. </pages>
Reference: [Vou86a] <author> M.A. Vouk, D.F. McAllister, and K.C. Tai, </author> <title> "An Experimental Evaluation of the Effectiveness of Random Testing of Fault-tolerant Software", </title> <booktitle> Proc. Workshop on Software Testing, </booktitle> <address> Banff, Canada, </address> <publisher> IEEE CS Press, </publisher> <pages> 74-81, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Six functionally equivalent programs were produced as part of another study <ref> [Vou86a, Vou86b] </ref>. Programs solve a navigational problem, an extended version of the "Earth Satellite Problem" used by Nagle et al. [Nag82]. They were written independently by graduate level students to the same specification. The programming language was Pascal.
Reference: [Vou86b] <author> Vouk, M. A., Helsabeck, M. L., McAllister, D. F, and Tai, K. C., </author> <title> "On testing of functionally equivalent components of fault-tolerant software", </title> <booktitle> Proc. COMPSAC (Computer Software and Applications) '86, </booktitle> <month> Oct. </month> <year> 1986, </year> <pages> 414-419. </pages>
Reference-contexts: Six functionally equivalent programs were produced as part of another study <ref> [Vou86a, Vou86b] </ref>. Programs solve a navigational problem, an extended version of the "Earth Satellite Problem" used by Nagle et al. [Nag82]. They were written independently by graduate level students to the same specification. The programming language was Pascal. <p> Special consideration was given to extremal and special values, explicit or implicit, in the specification (boundaries, singularities, etc.), as well as in the known problem solution algorithms. Random data were generated using a uniform distribution for all input parameters. Failures observed in the components are described in <ref> [Vou86b] </ref>.
Reference: [Vou89] <author> Vouk, M. A., Coyle, R. E., "BGG: </author> <title> A testing coverage tool " Proc. </title> <booktitle> 7th Northwest Software Quality Conference, </booktitle> <year> 1989, </year> <pages> 212-233 </pages>
Reference-contexts: A tool called BGG, developed at North Carolina State University to measure the test coverage of statements, branches, and various types of data flow metrics for Pascal programs <ref> [Vou89] </ref>, was extended to generate BOR and BRO constraint sets for predicates in a Pascal program, and to measure the coverage of BOR and BRO constraints in a Pascal program according 8 Remember that only a portion of the shutdown test set is meant for the selected module. 9 N-version programming
Reference: [Vou93a] <author> Vouk, M. A., and Paradkar, A., </author> <title> "Design and Review of Software Controlled Safety-Related Systems: The NCSU Experience With the Generic Problem Exercise," </title> <booktitle> Proc. Inter. Invitational Workshop on the Design and Review of Software Controlled Safety-Related Systems, </booktitle> <address> Ottawa, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The specifications were developed as part of the the generic problem exercise conducted for the 1993 International Workshop on the Design and Review of Software Controlled Safety-Related Systems [IRR93]. A version of the boiler control and monitoring system was developed at North Carolina State University <ref> [Vou93a] </ref>. This software was used in our empirical study. A brief description of the boiler system is given below.
Reference: [Vou93b] <author> M.A. Vouk, </author> <title> "Fault and Failure Analysis," </title> <booktitle> In Proc. of Third Workshop on Issues in Software Reliability Workshop Program, </booktitle> <institution> U.S. West Advanced Technologies, Boulder Colorado, </institution> <month> November 1-2, </month> <year> 1993, </year> <pages> 39 pages. </pages>
Reference-contexts: Similar variance in coverage metrics has been seen in experiments with other software <ref> [Vou93b] </ref>. This indicates that any type of reliability modeling that is based on coverage metrics will have to account for this variability.
Reference: [Wey88] <author> E.J. Weyuker, </author> <title> "An empirical study of the complexity of data flow testing", </title> <booktitle> Proc. Second Workshop on Software Testing, Verification, and Analysis, </booktitle> <address> Banff, Canada, </address> <publisher> Computer Society Press, </publisher> <pages> pp 188-195, </pages> <year> 1988. </year>
Reference-contexts: Each of the five programs (using individual drivers) was tested by two different test sets, one with 1,000 randomly selected tests the other with 103 manually selected functional tests (i.e., special value functional tests). For each of these five programs, the coverages of puses <ref> [Fra88, Wey88] </ref>, BRO constraints, branches and statements was measured. The results are summarized in Figures 6 to 9. The programs are marked L1 through L5. The figures show the BRO and branch code coverage achieved by functional and random specification-based test cases.
Reference: [Whi80] <author> White, L. J., and Cohen, E. I., </author> <title> "A domain strategy for computer program testing," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> Vol. SE-6, </volume> <month> May </month> <year> 1980, </year> <pages> 247-257. </pages>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical <ref> [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] </ref> and experimental [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions.
Reference: [Zei92] <author> S.J. Zeil, F.H. Afifi, and L.J. White, </author> <title> "Detection of Linear Errors via Domain Testing," </title> <journal> ACM Trans. Soft. Eng., </journal> <volume> Vol 1(4), </volume> <pages> pp. 422-451, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: A number of predicate testing strategies have been proposed, including branch testing, domain testing, and others [How87, Bei90]. The field of evaluation of testing strategies is very active and a number of theoretical <ref> [e.g., Whi80, Cla85, Fra88, Kor88, Ham90, Ham92, Zei92, Fra93a] </ref> and experimental [e.g., Dur84, Nta84, Nta88, Voa91, For93, Fra93b] studies are available. Most of the time, the results can not be generalized, either because of the nature of the experiments, or because of the underlying assumptions.
References-found: 35

