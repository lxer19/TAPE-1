URL: http://www.cis.udel.edu/~jochen/passages/papers/debugopt.ps
Refering-URL: http://www.cis.udel.edu/~jochen/passages/pubs.htm
Root-URL: http://www.cis.udel.edu
Email: pollock@udel.edu mbivens@alleg.edu soffa@pitt.edu  
Phone: 302 831-1953 814 332-2880 412 624-8425  
Title: Debugging Optimized Code via Tailoring  
Author: Lori Pollock Mary Bivens Mary Lou Soffa 
Address: 19716 Meadville, PA 16335 Pittsburgh, PA 15260  
Affiliation: University of Delaware Allegheny College University of Pittsburgh Newark, DE  
Abstract: Although programmers have come to expect compilers that generate high quality code through ambitious optimization, a lack of good interactive source level d ebuggers for optimized programs still remains. Techniques to debug optimized programs place restrictions on either the application of optimizations or the types of debugging capabilities provided. Even with the restrictions, the current debugging techniques often have to r eport the existence of noncurrent values. This paper presents a new approach to the problem of debugging optimized code. By employing techniques from incremental optimization analyses, optimizations are tailored to the type and context of debugging commands. Therefore, there are no a priori restrictions placed on either debugging commands or optimizations. In the presence of both ambitious, machine independent optimization and smart register allocation, we enable standard debugging commands such as breakpoint insertion, single stepping, and program state display and more advanced commands including the modification of variable values and program code with continued program execution. In response to a request specified during debugging, an optimization profile is used to determine if the expected response can be provided by the debugger. When an optimization inhibits transparently servicing the request, the profile is then used to recover the desired information or to tailor the code such that the debugging request can be honored transparently in a subsequent execution. Unnecessary limitations on optimization are avoided by basing the optimization on the conicts with the user's current debugging requests rather than the entire repertoire of debugging commands. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Ali-Reza Adl-Tabatabai and Thomas Gross, </author> <title> ``Detection and recovery of endangered variables caused by instruction scheduling,'' </title> <booktitle> ACM SIGPLAN '93 Conf on Prog Lang Design and Implementation, </booktitle> <pages> pp. 13-25, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Debugging requests that modify data and control ow information, such as insertion or deletion of statements and changes in the value of a variable, are not supported by this system. A technique to detect and recover variable values that have been affected by instruction scheduling has been developed <ref> [1] </ref>. Instruction scheduling does not include the complete range of code modifications that optimizations encompass. Another research project addressed the detection of nonresident variables, that is, a variable who has no value due to register allocation [2].
Reference: 2. <author> Ali-Reza Adl-Tabatabai and Thomas Gross, </author> <title> ``Evicted variables and the interaction of global register allocation and symbolic debugging,'' </title> <booktitle> Conf Rec of the 20th POPL, </booktitle> <pages> pp. 371-383, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Instruction scheduling does not include the complete range of code modifications that optimizations encompass. Another research project addressed the detection of nonresident variables, that is, a variable who has no value due to register allocation <ref> [2] </ref>. Noncurrency is not addressed nor are the effects of optimizations other than register allocation. In both of these works, commands that change the value or code during debugging are not permitted.
Reference: 3. <author> M. P. Biv ens and M. L. Soffa, </author> <title> ``Incremental Register Allocation,'' </title> <journal> Software-Practice and Experience, </journal> <volume> vol. 20, no. 10, </volume> <pages> pp. 1015-1047, </pages> <year> 1990. </year> <month> - 20 </month> - 
Reference-contexts: The techniques to implement this scheme rely on analyses that are used to incrementally incorporate source code changes into compiled optimized programs while exploiting the same opportunities for optimizations as an exhaustive approach <ref> [3, 18] </ref>. The incremental optimizing techniques include incremental data ow analysis, an incremental intermediate code optimizer and an incremental target code generator. Both the information saved by these systems and the incremental analyses that they perform have been exploited in our approach to symbolic debugging of optimized code. <p> This necessitates reallocation of registers. Reallocation of registers can cause changes to machine code, including the update of register numbers when allocations are changed and the addition or deletion of instructions that move data between memory and registers. Bivens and Soffa <ref> [3] </ref> developed a technique for incremental register allocation in conjunction with an incremental target code generator, which also deals with the incremental regeneration of target code. This incremental technique supports both local register allocation within a basic block and global register allocation across basic block boundaries. <p> In particular, it is directed toward register allocation that uses some form of graph coloring. If simpler allocation schemes are used, then all of the information in the summary may not be needed <ref> [3] </ref>. The register allocation summary acts as the interface between name spans (definition of a variable and all its uses) and physical register usage.
Reference: 4. <author> Gary Brooks, Gilbert J. Hansen, and Steve Simmons, </author> <title> ``A new approach to debugging optimized code,'' </title> <booktitle> ACM S IGPLAN '92 Conf on Prog Lang Design and Implementation, </booktitle> <pages> pp. 1-11, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Finally, conclusions are discussed in Section 6. 2. Previous Approaches to Debugging Optimized Code Based on the premise that the programmer should be debugging the optimized code and be presented with the picture of what is actually happening at execution time, Brooks, Hansen, and Simmons <ref> [4] </ref> developed a visual debugger that includes highlighting and annotations to the source and assembly code. However, the programmer must use this visual feedback to understand how o ptimization has changed the code and to deduce the expected program behavior.
Reference: 5. <author> M. Burke, </author> <title> ``An interval-based approach to exhaustive and incremental interprocedural data-ow analysis,'' </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 12, no. 3, </volume> <pages> pp. 341-395, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Changes in optimizing transformations can initiate changes in a procedure's data ow. A number of techniques, which vary in their approach and power, hav e been developed to incrementally update data ow information <ref> [5, 13, 14, 16, 20, 23] </ref>. As we are not concerned in this paper with the particular technique used for incremental data ow analysis, we refer the reader to the appropriate references above for more information on each approach. 3.2.
Reference: 6. <author> G.J. Chaitin, </author> <title> ``Register Allocation and Spilling Via Graph Coloring,'' </title> <booktitle> Proceedings of SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <pages> pp. 98-105, </pages> <year> 1982. </year>
Reference-contexts: Demands for registers are modeled by an interference graph in which nodes represent live ranges and edges connect nodes that may have demands for registers at the same point in the program. Register allocation is performed by coloring the interference graph <ref> [6, 7] </ref>. - 6 - 4. The Program Database The information that we maintain for our debugger as a program database consists of an optimization profile, register summary, global data ow information, and mappings between the program representations.
Reference: 7. <author> Fred C. Chow and John L. Hennessy, </author> <title> ``The Priority-Based Coloring Approach to Register Allocation,'' </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 12, no. 4, </volume> <pages> pp. 501-536, </pages> <year> 1990. </year>
Reference-contexts: Demands for registers are modeled by an interference graph in which nodes represent live ranges and edges connect nodes that may have demands for registers at the same point in the program. Register allocation is performed by coloring the interference graph <ref> [6, 7] </ref>. - 6 - 4. The Program Database The information that we maintain for our debugger as a program database consists of an optimization profile, register summary, global data ow information, and mappings between the program representations.
Reference: 8. <author> Deborah S. Coutant, Sue Meloy, and Michelle Ruscetta, </author> <title> ``DOC: A Practical Approach to Source-Level D ebugging of Globally Optimized Code,'' </title> <booktitle> Proceedings of SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 125-134, </pages> <year> 1988. </year>
Reference-contexts: Other systems attempt to support more significant optimization by collecting information during optimizing compilation and using this information during debugging <ref> [8, 11, 21, 24] </ref>. Hennessy [11] augments the structures built during optimization to maintain information about intermediate code optimizations that were performed during - 4 - compilation. <p> Other techniques use tables constructed during code optimization and generation to provide the correct location of variables at any point in the program <ref> [8, 15] </ref>. Debugging requests that modify data and control ow information, such as insertion or deletion of statements and changes in the value of a variable, are not supported by this system.
Reference: 9. <author> Peter H. Feiler and R. Medina-Mora, </author> <title> ``An Incremental Programming Environment,'' </title> <booktitle> 5th International Conference on Software Engineering, </booktitle> <pages> pp. 44-53, </pages> <year> 1981. </year>
Reference-contexts: Other approaches to symbolic debugging of optimized code have been described in the literature. Several debugging systems provide correct debugging information in the presence of optimization, but limit the application of optimization to small regions of the program thereby avoiding the contention between the transformations and correct symbolic debugging <ref> [9, 10, 22] </ref>. Other systems attempt to support more significant optimization by collecting information during optimizing compilation and using this information during debugging [8, 11, 21, 24]. Hennessy [11] augments the structures built during optimization to maintain information about intermediate code optimizations that were performed during - 4 - compilation.
Reference: 10. <author> Peter Fritzson, </author> <title> ``A Systematic Approach to Advanced Debugging,'' </title> <booktitle> Proceedings of SIGSOFT/SIGPLAN Software E ngi-neering Symposium on High-Level Debugging, </booktitle> <pages> pp. 130-139, </pages> <year> 1983. </year>
Reference-contexts: Other approaches to symbolic debugging of optimized code have been described in the literature. Several debugging systems provide correct debugging information in the presence of optimization, but limit the application of optimization to small regions of the program thereby avoiding the contention between the transformations and correct symbolic debugging <ref> [9, 10, 22] </ref>. Other systems attempt to support more significant optimization by collecting information during optimizing compilation and using this information during debugging [8, 11, 21, 24]. Hennessy [11] augments the structures built during optimization to maintain information about intermediate code optimizations that were performed during - 4 - compilation.
Reference: 11. <author> John Hennessy, </author> <title> ``Symbolic Debugging of Optimized Code,'' </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 4, no. 3, </volume> <pages> pp. 323-344, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Other systems attempt to support more significant optimization by collecting information during optimizing compilation and using this information during debugging <ref> [8, 11, 21, 24] </ref>. Hennessy [11] augments the structures built during optimization to maintain information about intermediate code optimizations that were performed during - 4 - compilation. <p> Other systems attempt to support more significant optimization by collecting information during optimizing compilation and using this information during debugging [8, 11, 21, 24]. Hennessy <ref> [11] </ref> augments the structures built during optimization to maintain information about intermediate code optimizations that were performed during - 4 - compilation. His algorithms can detect non-current values of variables, and if possible, the correct values are recovered; otherwise the user is informed that the value is not current. <p> An optimization profile is constructed by annotating the dag nodes of this intermediate representation. The annotations enable the intermediate representation to simultaneously represent the unoptimized and optimized program code with a condensed history of the machine independent optimizations responsible for the current form of the optimized code <ref> [11, 18] </ref>. The optimized code can be obtained from this annotated intermediate representation by traversing the control ow graph with a postorder traversal of each dag, ignoring the annotations.
Reference: 12. <author> R. Hood and B. Chase, </author> <title> ``Selective interpretation as a technique for debugging computationally intensive programs,'' </title> <booktitle> SIGPLAN '87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <pages> pp. 113-124, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: By accommodating the coexistence of interpreted and compiled code, Hood and Chase have dev eloped a debugger that exploits the sophisticated debugging capabilities of an interpretive debugger in the module under development while providing fast execution through other modules in the program by executing their corresponding compiled, optimized code <ref> [12] </ref>. Although this approach should certainly improve the execution speed of large programs composed of relatively small modules, it will still suffer from slow execution when individual modules are large. More importantly, both an interpreter and compiler must be available and consistency maintained between them.
Reference: 13. <author> James Keables, Katherine Roberson, and Anneliese von Mayrhauser, </author> <title> ``Data ow analysis and its application to software maintenance,'' </title> <booktitle> Proceedings of Conference on Software Maintenance, </booktitle> <pages> pp. 335-347, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Changes in optimizing transformations can initiate changes in a procedure's data ow. A number of techniques, which vary in their approach and power, hav e been developed to incrementally update data ow information <ref> [5, 13, 14, 16, 20, 23] </ref>. As we are not concerned in this paper with the particular technique used for incremental data ow analysis, we refer the reader to the appropriate references above for more information on each approach. 3.2.
Reference: 14. <author> T. Marlowe and B. Ryder, </author> <title> ``An efficient hybrid algorithm for incremental data ow analysis,'' </title> <booktitle> Conf Rec of the 17th Annual ACM Symp on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1990. </year>
Reference-contexts: Changes in optimizing transformations can initiate changes in a procedure's data ow. A number of techniques, which vary in their approach and power, hav e been developed to incrementally update data ow information <ref> [5, 13, 14, 16, 20, 23] </ref>. As we are not concerned in this paper with the particular technique used for incremental data ow analysis, we refer the reader to the appropriate references above for more information on each approach. 3.2.
Reference: 15. <author> P. P. Pineo and M. L. Soffa, </author> <title> ``Debugging Parallelized Code Using Code Liberation Techniques,'' </title> <booktitle> ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. 108-119, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Other techniques use tables constructed during code optimization and generation to provide the correct location of variables at any point in the program <ref> [8, 15] </ref>. Debugging requests that modify data and control ow information, such as insertion or deletion of statements and changes in the value of a variable, are not supported by this system.
Reference: 16. <author> Lori Pollock and Mary Lou Soffa, </author> <title> ``An incremental version of iterative data ow analysis,'' </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 15, no. 11, </volume> <pages> pp. 1537-1549, </pages> <year> 1989. </year>
Reference-contexts: Changes in optimizing transformations can initiate changes in a procedure's data ow. A number of techniques, which vary in their approach and power, hav e been developed to incrementally update data ow information <ref> [5, 13, 14, 16, 20, 23] </ref>. As we are not concerned in this paper with the particular technique used for incremental data ow analysis, we refer the reader to the appropriate references above for more information on each approach. 3.2.
Reference: 17. <author> L. Pollock and M. L. Soffa, </author> <title> ``Incremental global reoptimization of programs,'' </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 14, no. 2, </volume> <pages> pp. 173-200, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: To avoid having to reoptimize the resultant large procedures from scratch, techniques for incrementally incorporating changes into globally optimized code can be applied. In earlier work, we present algorithms for incrementally incorporating edits into globally optimized code <ref> [17] </ref>. In response to program modifications, changes in the conditions for safe machine-independent optimizing transformations are identified using an annotated intermediate representation of - 5 - the program and incremental changes in the data ow information.
Reference: 18. <author> L. L. Pollock and M. L. Soffa, </author> <title> ``Incremental Compilation of Locally Optimized Code,'' </title> <booktitle> Conference Record of the Twelfth Annual ACM Symposium on POPL, </booktitle> <pages> pp. 152-164, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: The techniques to implement this scheme rely on analyses that are used to incrementally incorporate source code changes into compiled optimized programs while exploiting the same opportunities for optimizations as an exhaustive approach <ref> [3, 18] </ref>. The incremental optimizing techniques include incremental data ow analysis, an incremental intermediate code optimizer and an incremental target code generator. Both the information saved by these systems and the incremental analyses that they perform have been exploited in our approach to symbolic debugging of optimized code. <p> An optimization profile is constructed by annotating the dag nodes of this intermediate representation. The annotations enable the intermediate representation to simultaneously represent the unoptimized and optimized program code with a condensed history of the machine independent optimizations responsible for the current form of the optimized code <ref> [11, 18] </ref>. The optimized code can be obtained from this annotated intermediate representation by traversing the control ow graph with a postorder traversal of each dag, ignoring the annotations.
Reference: 19. <author> L. L. Pollock and M. L. Soffa, </author> <title> ``High-Level Debugging with the Aid of an Incremental Optimizer,'' </title> <booktitle> Proceedings of the 21st Hawaii International Conference on System Sciences, </booktitle> <pages> pp. 524-532, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Without the incremental optimization and code generation techniques, the tailoring of the optimized code to the current set of debugging commands would be impractical. This paper extends previous work by the authors in two important ways <ref> [19] </ref>. First, the prior work only considered the use of incremental techniques to remove optimizations prior to a debugging session by having the user submit a set of planned debugging requests. Those optimizations that only interfered with the planned requests were eliminated from the optimized code.
Reference: 20. <author> Barbara Ryder and Marvin Paull, </author> <title> ``Incremental Data Flow Analysis,'' </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 10, no. 1, </volume> <pages> pp. 1-50, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Changes in optimizing transformations can initiate changes in a procedure's data ow. A number of techniques, which vary in their approach and power, hav e been developed to incrementally update data ow information <ref> [5, 13, 14, 16, 20, 23] </ref>. As we are not concerned in this paper with the particular technique used for incremental data ow analysis, we refer the reader to the appropriate references above for more information on each approach. 3.2.
Reference: 21. <author> Ron Tischler, Robin Schauer, and Charlotte Payne, </author> <title> ``Static Analysis of Programs as an Aid to Debugging,'' </title> <booktitle> Proceedings of SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging, </booktitle> <pages> pp. 155-158, </pages> <year> 1983. </year>
Reference-contexts: Other systems attempt to support more significant optimization by collecting information during optimizing compilation and using this information during debugging <ref> [8, 11, 21, 24] </ref>. Hennessy [11] augments the structures built during optimization to maintain information about intermediate code optimizations that were performed during - 4 - compilation.
Reference: 22. <author> H.S. Warren, Jr. </author> <title> and H.P. Schlaeppi, Design of the FDS interactive debugging system, </title> <institution> RC7214, IBM T.J. Watson Center, </institution> <address> Yorktown, NY, </address> <month> June </month> <year> 1978. </year>
Reference-contexts: Other approaches to symbolic debugging of optimized code have been described in the literature. Several debugging systems provide correct debugging information in the presence of optimization, but limit the application of optimization to small regions of the program thereby avoiding the contention between the transformations and correct symbolic debugging <ref> [9, 10, 22] </ref>. Other systems attempt to support more significant optimization by collecting information during optimizing compilation and using this information during debugging [8, 11, 21, 24]. Hennessy [11] augments the structures built during optimization to maintain information about intermediate code optimizations that were performed during - 4 - compilation.
Reference: 23. <author> Frank Kenneth Zadeck, </author> <title> ``Incremental Data Flow Analysis in a Structured Program Editor,'' </title> <booktitle> Proceedings of SIGPLAN '84 Symposium on Compiler Construction, </booktitle> <pages> pp. 132-143, </pages> <year> 1984. </year>
Reference-contexts: Changes in optimizing transformations can initiate changes in a procedure's data ow. A number of techniques, which vary in their approach and power, hav e been developed to incrementally update data ow information <ref> [5, 13, 14, 16, 20, 23] </ref>. As we are not concerned in this paper with the particular technique used for incremental data ow analysis, we refer the reader to the appropriate references above for more information on each approach. 3.2.
Reference: 24. <author> Polle Zellweger, </author> <title> ``An Interactive High-Level D ebugger for Control-Flow Optimized Programs,'' </title> <booktitle> Proceedings of SIG-SOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging, </booktitle> <pages> pp. 159-171, </pages> <year> 1983. </year>
Reference-contexts: Other systems attempt to support more significant optimization by collecting information during optimizing compilation and using this information during debugging <ref> [8, 11, 21, 24] </ref>. Hennessy [11] augments the structures built during optimization to maintain information about intermediate code optimizations that were performed during - 4 - compilation. <p> His algorithms can detect non-current values of variables, and if possible, the correct values are recovered; otherwise the user is informed that the value is not current. Navigator, dev eloped by Zellweger <ref> [24] </ref>, is a source level debugger that gives the user expected behavior for setting breakpoints, determining the current execution location and reporting procedure traceback on code that includes only in-line procedure expansion and cross-jumping optimizations.
References-found: 24

