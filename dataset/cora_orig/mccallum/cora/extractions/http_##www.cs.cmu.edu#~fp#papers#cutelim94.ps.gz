URL: http://www.cs.cmu.edu/~fp/papers/cutelim94.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/fp/www/papers/Pfenning.html
Root-URL: 
Title: A Structural Proof of Cut Elimination and Its Representation in a Logical Framework  
Author: Frank Pfenning 
Note: This work was supported by NSF Grant CCR-9303383 The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of NSF or the U.S. government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: November 1994  
Pubnum: CMU-CS-94-218  
Abstract: We present new proofs of cut elimination for intuitionistic and classical sequent calculi. In both cases the proofs proceed by three nested structural inductions, avoiding the explicit use of multi-sets and termination measures on sequent derivations. This makes them amenable to elegant and concise representations in LF, which are given in full detail. 
Abstract-found: 1
Intro-found: 1
Reference: [Abr93] <author> Samson Abramsky. </author> <title> Computational interpretations of linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 111 </volume> <pages> 3-57, </pages> <year> 1993. </year>
Reference: [BTKP93] <author> Val Breazu-Tannen, Delia Kesner, and Laurence Puel. </author> <title> A typed pattern calculus. </title> <editor> In Moshe Y. Vardi, editor, </editor> <booktitle> Proceedings of the Eight Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 262-274, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: This is also an important intermediate step toward the representation of the rules in LF. There are at least three distinct roles that proof terms may play for a sequent calculus, an issue recognized by Gallier [Gal93] and Breazu-Tannen et al. <ref> [BTKP93] </ref>. The most immediate perhaps is to annotate sequent derivations with -terms that represent the natural deductions they correspond to. The second is to think of proof terms as expressions in a programming language and view a sequent derivation as a typing derivation.
Reference: [DFH + 93] <author> Gilles Dowek, Amy Felty, Hugo Herbelin, Gerard Huet, Chet Murthy, Catherine Parent, Christine Paulin-Mohring, and Benjamin Werner. </author> <title> The Coq proof assistant user's guide. Rapport Techniques 154, </title> <institution> INRIA, Rocquencourt, France, </institution> <year> 1993. </year> <note> Version 5.8. </note>
Reference-contexts: For the predicate calculus this overhead would be even higher, since a theory binding would have to be developed first. Once the structural proof of admissibility has been found and implemented, it is natural to ask if it can also be encoded in stronger frameworks such as Coq <ref> [DFH + 93] </ref> so that structural inductions are made explicit and the proof is fully formally verified. There are several aspects of our proof which make this difficult. The first is the use of higher-order abstract syntax, which is not available in a similarly straightforward fashion in other candidate environments.
Reference: [DH94] <author> Joelle Despeyroux and Andre Hirschowitz. </author> <title> Higher-order abstract syntax with induction in Coq. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Proceedings of the 5th International Conference on Logic Programming and Automated Reasoning, </booktitle> <pages> pages 159-173, </pages> <address> Kiev, Ukraine, July 1994. </address> <publisher> Springer-Verlag LNAI 822. </publisher>
Reference-contexts: There are several aspects of our proof which make this difficult. The first is the use of higher-order abstract syntax, which is not available in a similarly straightforward fashion in other candidate environments. Thus one either has to try ideas from <ref> [DH94] </ref> (which we have not attempted) or use an encoding such as de Bruijn indices and explicitly represent contexts. In either case one has to prove a number of auxiliary lemmas regarding substitutions which are not needed in our representation.
Reference: [Fel89] <author> Amy Felty. </author> <title> Specifying and Implementing Theorem Provers in a Higher-Order Logic Programming Language. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <month> August </month> <year> 1989. </year> <note> Available as Technical Report MS-CIS-89-53. </note>
Reference: [Gal93] <author> Jean Gallier. </author> <title> Constructive logics Part I: A tutorial on proof systems and typed -calculi. </title> <journal> Theoretical Computer Science, </journal> <volume> 110 </volume> <pages> 249-339, </pages> <year> 1993. </year>
Reference-contexts: This is also an important intermediate step toward the representation of the rules in LF. There are at least three distinct roles that proof terms may play for a sequent calculus, an issue recognized by Gallier <ref> [Gal93] </ref> and Breazu-Tannen et al. [BTKP93]. The most immediate perhaps is to annotate sequent derivations with -terms that represent the natural deductions they correspond to. The second is to think of proof terms as expressions in a programming language and view a sequent derivation as a typing derivation. <p> Then there is a proof term f and a cut-free sequent derivation of F :: ( f Proof: By three nested structural inductions on A, d, and e. 2 24 STRUCTURAL CUT ELIMINATION The notion of a cross-cut <ref> [Gal93] </ref>, though without multiplicities, surfaces naturally in this proof: Since formulas are never discarded they must be eliminated explicitly from both premises of a cut in a "cross-cut" fashion before the essential cut reduction can take place. <p> This means that our cut conversions do not identify intuitively unrelated sequent derivations, which has been a problem in other systems as noted by Lafont (see <ref> [Gal93] </ref>). Finally, we have a formulation of a sequent calculus for classical linear logic based on the ideas in this paper. There is a combinatorial explosion of cases (and we have not checked all of them), but we conjecture that a structural proof of cut-elimination is still possible.
Reference: [Gen35] <author> Gerhard Gentzen. </author> <title> Untersuchungen uber das logische Schlieen. </title> <journal> Mathematische Zeitschrift, </journal> <volume> 39 </volume> <pages> 176-210, 405-431, </pages> <year> 1935. </year> <title> English translation in M. </title> <editor> E. Szabo, editor, </editor> <booktitle> The Collected Papers of Gerhard Gentzen, </booktitle> <pages> pages 68-131, </pages> <publisher> North-Holland, </publisher> <year> 1969. </year>
Reference: [Gir87] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference: [Gir93] <author> Jean-Yves Girard. </author> <title> On the unity of logic. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 59 </volume> <pages> 201-217, </pages> <year> 1993. </year>
Reference: [HHP93] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: First, the representation of formulas. The obvious representation function pq is a compositional bijection between canonical (= long fi) LF objects of type o (in an appropriate context) and formulas (see <ref> [HHP93] </ref>). An important characteristic of this encoding (and the others we give below) is that variables of the object language are mapped to variables of the meta-language.
Reference: [Kle52] <author> Stephen Cole Kleene. </author> <title> Introduction to Metamathematics. </title> <publisher> North-Holland, </publisher> <year> 1952. </year>
Reference: [Mat94] <author> Sean Matthews. </author> <title> A theory and its metatheory in F S 0 . In Dov Gabbay and Franz Guenthner, editors, What is a Logical System? Oxford University Press, </title> <note> 1994. To appear. REFERENCES 63 </note>
Reference-contexts: Writing the program which generates the informal version of the proof from its formalization took about 2 weeks, with several false starts (this involved programming in Elf, Emacs Lisp, and LaTeX). Another analysis of cut elimination for a small propositional fragment of classical logic is given by Matthews <ref> [Mat94] </ref> in F S 0 . His proof is traditional|sequents are represented as lists, and termination is proved by induction on a standard complexity measure.
Reference: [Mil94] <editor> Dale Miller. A multiple-conclusion meta-logic. In S. Abramsky, editor, </editor> <booktitle> Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 272-281, </pages> <address> Paris, France, </address> <month> July </month> <year> 1994. </year>
Reference: [MNPS91] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference: [MP91] <author> Spiro Michaylov and Frank Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <editor> In L.-H. Eriksson, L. Hallnas, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 299-344, </pages> <address> Stockholm, Sweden, </address> <month> January </month> <year> 1991. </year> <note> Springer-Verlag LNAI 596. </note>
Reference: [Nip91] <author> Tobias Nipkow. </author> <title> Higher-order critical pairs. </title> <editor> In G. Kahn, editor, </editor> <booktitle> Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 342-349, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: In other future work we plan to reexamine the connection between normalization and cut elimination (see, for example, [Zuc74]) in the same framework. Another direction is to study cut elimination in a formulation as a higher-order rewrite system along the lines of Nipkow <ref> [Nip91] </ref>, but using dependent types. We first note that our system of rules is terminating (note that we cannot permute adjacent cuts!). Assuming the completeness of a critical pair criterion for the dependently typed calculus, the system is confluent modulo Kleene's permutations of adjacent inference rules in the cut-free system.
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Readers interested primarily in the proof of cut elimination itself may safely skip this section. 4 REPRESENTING SEQUENT DERIVATIONS IN LF 11 For the sake of brevity we show the actual code in Elf <ref> [Pfe91] </ref>, an implementation of LF which permits type declarations with implicit quantifiers. Elf also gives an operational interpretation to signatures as logic programs which will be of interest later in the implementation of cut elimination. First, the representation of formulas.
Reference: [Roh94] <author> Ekkehard Rohwedder. </author> <title> Verifying the meta-theory of deductive systems. </title> <type> Thesis Proposal, </type> <month> February </month> <year> 1994. </year>
Reference-contexts: We conclude that a similarly elegant representation of cut elimination in other systems is a non-trivial challenge which, we hope, others will take up. In future work we plan to verify mechanically that the given signatures indeed implement proofs. The prototype implementation of the schema-checker sketched in <ref> [Roh94] </ref> currently accepts them, but the (meta-meta-)theoretical analysis of schema-checker itself is not yet complete. In other future work we plan to reexamine the connection between normalization and cut elimination (see, for example, [Zuc74]) in the same framework.
Reference: [Wal90] <author> Lincoln A. Wallen. </author> <title> Automated Proof Search in Non-Classical Logics: Efficient Matrix Proof Methods for Modal and Intuitionistic Logics. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: [Zuc74] <author> Jeffrey Zucker. </author> <title> The correspondence between cut-elimination and normalization I. </title> <journal> Annals of Mathematical Logic, </journal> <volume> 7 </volume> <pages> 1-112, </pages> <year> 1974. </year>
Reference-contexts: The prototype implementation of the schema-checker sketched in [Roh94] currently accepts them, but the (meta-meta-)theoretical analysis of schema-checker itself is not yet complete. In other future work we plan to reexamine the connection between normalization and cut elimination (see, for example, <ref> [Zuc74] </ref>) in the same framework. Another direction is to study cut elimination in a formulation as a higher-order rewrite system along the lines of Nipkow [Nip91], but using dependent types. We first note that our system of rules is terminating (note that we cannot permute adjacent cuts!).
References-found: 20

