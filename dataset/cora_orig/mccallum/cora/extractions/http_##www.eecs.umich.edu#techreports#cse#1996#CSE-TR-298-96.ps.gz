URL: http://www.eecs.umich.edu/techreports/cse/1996/CSE-TR-298-96.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse96.html
Root-URL: http://www.eecs.umich.edu
Email: fsdawson,farnam,mittong@eecs.umich.edu  
Title: Experiments on Six Commercial TCP Implementations Using a Software Fault Injection Tool  
Author: Scott Dawson, Farnam Jahanian, and Todd Mitton 
Keyword: distributed systems, communication protocol, fault injection tool, protocol testing.  
Note: This work is supported in part by a research grant from the U.S. Office of Naval Research, N0014-95-1-0261, and a research grant from the National Science Foundation, CCR-9502341.  
Address: Ann Arbor, MI 48109-2122 USA  
Affiliation: Real-Time Computing Laboratory Electrical Engineering and Computer Science Department University of Michigan  
Abstract: TCP has become the de facto standard transport protocol in today's operating systems. It is a very robust protocol which can adapt to various network characteristics, packet loss, link congestion, and even significant differences in vendor implementations. This paper, presents an implementation of a tool, called orchestra, that can be used for testing distributed protocols such as TCP, and a set of experiments performed on six different vendor TCP implementations using the tool. The paper also disusses some lessons learned about TCP implementations through experimentation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Mogul, R. Rashid, and M. Accetta, </author> <title> "The packet filter: An efficient mechanism for user-level network code," </title> <booktitle> in Proc. ACM Symp. on Operating Systems Principles, </booktitle> <pages> pp. 39-51, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987, </year> <note> ACM. </note>
Reference-contexts: To minimize data copying across kernel/user-space protection boundaries, a kernel agent, called a packet filter, is often used to discard unwanted packets as early as possible. Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter <ref> [1] </ref>, a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [2], and the Mach Packet Filter (MPF) [3] which is an extension of the BPF, are related to the work presented in this paper.
Reference: [2] <author> Steven McCanne and Van Jacobson, </author> <title> "The BSD Packet Filter: A New Architecture for User-level Packet Capture," </title> <booktitle> in Winter USENIX Conference, </booktitle> <pages> pp. 259-269, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [1], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator <ref> [2] </ref>, and the Mach Packet Filter (MPF) [3] which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network. <p> After 30 ACKs had been delayed, the send filter triggered the receive filter to begin dropping incoming packets. Each incoming packet (both the dropped and non dropped ones) were logged by the receive filter with a timestamp. It is important to note that approaches which depend on filtering packets <ref> [2, 4] </ref> cannot perform this type of experiment because they do not have the ability to manipulate messages. In particular, they cannot direct the system to perform a task such as delaying ACK type packets.
Reference: [3] <author> M. Yuhara, B. N. Bershad, C. Maeda, and J. E. B. Moss, </author> <title> "Efficient packet demultiplexing for multiple endpoints and large messages," </title> <booktitle> in Winter USENIX Conference, </booktitle> <month> January </month> <year> 1994. </year> <note> Second Edition. </note>
Reference-contexts: Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [1], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [2], and the Mach Packet Filter (MPF) <ref> [3] </ref> which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
Reference: [4] <author> D. E. Comer and J. C. Lin, </author> <title> "Probing TCP implementations," </title> <booktitle> in Proc. Summer USENIX Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Furthermore, our approach requires that a filter be inserted at various levels in a protocol stack, unlike packet filters that are inserted on top of link-level device drivers and below the listening applications. In one case <ref> [4] </ref>, a network monitoring tool was used to collect data on TCP performance in the presence of network/machine crash failures. After a connection had been made between two TCP participants, the network device on one machine was disabled, emulating a network or processor crash failure. <p> After 30 ACKs had been delayed, the send filter triggered the receive filter to begin dropping incoming packets. Each incoming packet (both the dropped and non dropped ones) were logged by the receive filter with a timestamp. It is important to note that approaches which depend on filtering packets <ref> [2, 4] </ref> cannot perform this type of experiment because they do not have the ability to manipulate messages. In particular, they cannot direct the system to perform a task such as delaying ACK type packets.
Reference: [5] <author> David B. Ingham and Graham D. Parrington, "Delayline: </author> <title> A Wide-Area Network Emulation Tool," </title> <journal> Computing Systems, </journal> <volume> vol. 7, no. 3, </volume> <pages> pp. 313-332, </pages> <month> Summer </month> <year> 1994. </year>
Reference-contexts: For example, it is not possible to, say, receive three messages and then kill the connection. It is not even possible to delay messages. Nevertheless, many interesting facts about different TCPs were discovered in this work. The Delayline tool presented in <ref> [5] </ref> allows the user to introduce delays into user-level protocols. However, the tool is intended to be used for emulating a wide-area network in a local network development environment, and only allows for delay specification on a per path basis.
Reference: [6] <author> Klaus Echtle and Martin Leu, </author> <title> "The EFA Fault Injector for Fault-Tolerant Distributed System Testing," </title> <booktitle> in Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <pages> pp. 28-35. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: It does not allow the user to delay messages on a per message basis, nor is it intended for manipulating or injecting new messages. Much work has been performed in the area of fault injection. In communication fault injection, two tools, EFA <ref> [6] </ref> and DOCTOR [7], are most closely related to this work. EFA differs from 3 the work presented in this paper on several key points. The first is that their fault injection layer is driven by a program which is compiled into the fault injection layer. <p> This allows the user to focus on only the messages being sent and received by the target layer, rather than having to parse each message sent and received at the data link layer. In a more recent paper [8], the authors of <ref> [6] </ref> have concentrated on automatic generation of the fault cases to be injected, which is an important problem. In the DOCTOR system [7], an x-kernel layer is presented that can be used to inject various faults into the messages exchanged by communication layers.
Reference: [7] <author> Seungjae Han and Kang G. Shin and Harold A. Rosenberg, "DOCTOR: </author> <title> an integrateD sOftware fault injeCTiOn enviRonment for distributed real-time systems," </title> <booktitle> in Proceedings of the IEEE International Computer Performance and Dependability Symposium, </booktitle> <pages> pp. 204-213, </pages> <publisher> Erlangen, </publisher> <address> Germany, </address> <year> 1995. </year>
Reference-contexts: It does not allow the user to delay messages on a per message basis, nor is it intended for manipulating or injecting new messages. Much work has been performed in the area of fault injection. In communication fault injection, two tools, EFA [6] and DOCTOR <ref> [7] </ref>, are most closely related to this work. EFA differs from 3 the work presented in this paper on several key points. The first is that their fault injection layer is driven by a program which is compiled into the fault injection layer. <p> In a more recent paper [8], the authors of [6] have concentrated on automatic generation of the fault cases to be injected, which is an important problem. In the DOCTOR system <ref> [7] </ref>, an x-kernel layer is presented that can be used to inject various faults into the messages exchanged by communication layers. Most of the faults injected in the DOCTOR system are injected with probability distributions. We have found that probabilistic fault generation is useful for uncovering strange behaviors in protocols.
Reference: [8] <author> Klaus Echtle and Martin Leu, </author> <title> "Test of fault tolerant distributed systems by fault injection," IEEE Fault Tolerant Parallel and Distributed Systems, </title> <month> June </month> <year> 1995. </year>
Reference-contexts: This allows the user to focus on only the messages being sent and received by the target layer, rather than having to parse each message sent and received at the data link layer. In a more recent paper <ref> [8] </ref>, the authors of [6] have concentrated on automatic generation of the fault cases to be injected, which is an important problem. In the DOCTOR system [7], an x-kernel layer is presented that can be used to inject various faults into the messages exchanged by communication layers.
Reference: [9] <author> Scott Dawson and Farnam Jahanian, </author> <title> "Probing and Fault Injection of Protocol Implementations," </title> <booktitle> Proc. Int. Conf. on Distributed Computer Systems, </booktitle> <pages> pp. 351-359, </pages> <month> May </month> <year> 1995. </year> <month> 19 </month>
Reference: [10] <author> Scott Dawson and Farnam Jahanian and Todd Mitton, </author> <title> "A Software Fault-Injection Tool on Real-Time Mach," </title> <booktitle> in IEEE Real-Time Systems Symposium, </booktitle> <address> Pisa, Italy, </address> <month> December </month> <year> 1995. </year>
Reference: [11] <author> Scott Dawson and Farnam Jahanian and Todd Mitton, </author> <title> "Testing of Fault-Tolerant and Real-Time Distributed Systems via Protocol Fault Injection," </title> <booktitle> in International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pp. 404-414, </pages> <address> Sendai, Japan, </address> <month> June </month> <year> 1996. </year>
Reference: [12] <author> J. Postel, "RFC-793: </author> <title> Transmission control protocol," Request for Comments, </title> <month> September </month> <year> 1981. </year> <institution> Network Information Center. </institution>
Reference: [13] <author> R. Braden, "RFC-1122: </author> <title> Requirements for internet hosts," Request for Comments, </title> <month> October </month> <year> 1989. </year> <institution> Network Information Center. </institution>
Reference: [14] <author> V. Jacobson, </author> <title> "Congestion avoidance and control," </title> <booktitle> in Proc. of ACM SIGCOMM, </booktitle> <pages> pp. 314-329, </pages> <month> August </month> <year> 1988. </year>
Reference: [15] <author> P. Karn and C. Partridge, </author> <title> "Round trip time estimation," </title> <booktitle> in Proc. SIGCOMM 87, </booktitle> <address> Stowe, Vermont, </address> <month> August </month> <year> 1987. </year> <month> 20 </month>
References-found: 15

