URL: http://graphics.lcs.mit.edu/~seth/pubs/radianceinterps.ps.Z
Refering-URL: http://graphics.lcs.mit.edu/~seth/pubs/pubs.html
Root-URL: 
Title: Conservative Radiance Interpolants for Ray Tracing  
Author: Seth Teller Kavita Bala Julie Dorsey 
Affiliation: MIT Imagery and Simulation Group  
Note: In Proc. 1996 Eurographics Workshop on Rendering, pp. 257-268 and 294.  
Abstract: Classical ray-tracing algorithms compute radiance returning to the eye along one or more sample rays through each pixel of an image. The output of a ray-tracing algorithm, although potentially photorealistic, is a two-dimensional quantity an image array of radiance values and is not directly useful from any viewpoint other than the one for which it was computed. This paper makes several contributions. First, it directly incorporates the notion of radiometric error into classical ray-tracing, by lazy construction of conservative radiance interpolants in ray space. For any relative error tolerance *, we show how to construct interpolants which return radiance values within * of those that would be computed by classical (e.g., Whitted) ray-tracing. The second contribution of the paper is an explication of the four sources of aliasing inherent in classical ray tracing termed gaps, blockers, funnels, and peaks and an adaptive subdivision algorithm for identifying ray space regions guaranteed to be free of these phenomena. Finally, we describe a novel data structure that exploits object-space coherence in the radiance function to accelerate not only the generation of single images, but of image sequences arising from a smoothly varying sequence of eyepoints. We describe a preliminary implementation incorporating each of these ideas. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Amanatides, J. </author> <title> Ray Tracing with Cones. </title> <booktitle> In Computer Graphics (SIGGRAPH '84 Proceedings) (July 1984), </booktitle> <editor> H. Christiansen, Ed., </editor> <volume> vol. 18, </volume> <pages> pp. 129-135. </pages>
Reference-contexts: Most ray tracing acceleration methods have concentrated on reducing or amortizing the cost of ray casting. This has been done by casting bundles of rays, as did beam-tracing for polyhedral scenes [15] and cone-tracing <ref> [1] </ref>; employing a fixed-grid [6] or adaptive [8] 3D spatial hierarchy of scene objects; and employing a 5D hierarchy associating ray sets and the object (s) encountered by rays in the set [3]. <p> However, a conservative subdivision strategy preserves the correctness of our approach: we simply label any raytree containing a dense/sparse interface as non-isotopic. This may cause excessive sampling; however, it will never allow interpolation across a funnel. We note that existing beam-tracing [15] cone-tracing <ref> [1] </ref>, and pencil-tracing [23] algorithms encounter this problem in a different form; refraction causes linear descriptions of ray bundles to become nonlinear.
Reference: [2] <author> Appel, A. </author> <title> Some Techniques for Shading Machine Renderings of Solids. </title> <booktitle> In Proceedings of SJCC (1968), </booktitle> <publisher> Thompson Books, </publisher> <address> Washington, D.C., </address> <pages> pp. 37-45. </pages>
Reference-contexts: explicitly decoupled from the fundamental radiometric operation, integration of irradiance, yielding a sampling scheme that suffers absolutely no unrecognized geometric aliasing, and strictly bounded radiometric aliasing, at every pixel. 2 Previous Work Ray casting was introduced in 1968 as a technique for visibility determination and the rendering of hard shadows <ref> [2] </ref>. Classical ray tracing was proposed in 1980 to simulate reflection and refraction 1 We do not consider texture mapping in this work. phenomena [29]. This approach identifies only those paths along which radiance reaches the eye from the specified light sources or background [10].
Reference: [3] <author> Arvo, J., and Kirk, D. B. </author> <title> Fast Ray Tracing by Ray Classification. </title> <booktitle> In Computer Graphics (SIGGRAPH '87 Proceedings) (July 1987), </booktitle> <editor> M. C. Stone, Ed., </editor> <volume> vol. 21, </volume> <pages> pp. 55-64. </pages>
Reference-contexts: This has been done by casting bundles of rays, as did beam-tracing for polyhedral scenes [15] and cone-tracing [1]; employing a fixed-grid [6] or adaptive [8] 3D spatial hierarchy of scene objects; and employing a 5D hierarchy associating ray sets and the object (s) encountered by rays in the set <ref> [3] </ref>. While many researchers have concentrated on reducing the per-ray intersection cost, relatively few published algorithms have the intent of reducing the number of rays cast. Popular public domain ray tracers such as RayShade [17] use an adaptive subdivision technique based on variance of screen space radiance samples.
Reference: [4] <author> Chen, S. E., Rushmeier, H., Miller, G., and Turner, D. </author> <title> A Progressive Multi-Pass Method for Global Illumination. </title> <booktitle> Computer Graphics (SIGGRAPH '91 Proceedings) 25, </booktitle> <month> 4 (July </month> <year> 1991), </year> <pages> 165-174. </pages>
Reference-contexts: A class of hybrid techniques has arisen that compute more general representations of the radiance function typically, some discretized approximation to the radiance and/or irradiance field at each surface, or in space <ref> [27, 28, 25, 24, 4] </ref>. However, these representations have typically been extremely expensive to compute and store. Thus, the important visual cues provided by these algorithms (shadows, smooth shading, transparency, reflections, etc.) have not been achievable in interactive visual simulation applications. 1.2 Solution Error vs.
Reference: [5] <author> Cook, R. L., Porter, T., and Carpenter, L. </author> <title> Distributed Ray Tracing. </title> <booktitle> In Computer Graphics (SIG-GRAPH '84 Proceedings) (July 1984), </booktitle> <volume> vol. 18, </volume> <pages> pp. 137-45. </pages>
Reference-contexts: This "truncated" integration can give rise to error by excluding ray paths along which significant radiance may flow (e.g., light bouncing among many surfaces before reaching the eye). Researchers have addressed this source of error using distribution ray tracing <ref> [5] </ref>, forward ray tracing [10] and path tracing [16]. This paper does not address truncation error, as our system is designed to compute an *-approximation to the radiance values computed by classical ray tracing. 3 Algorithm Overview This section presents a brief overview of our algorithm.
Reference: [6] <author> Fujimoto, A., and Iwata, K. </author> <title> Accelerated Ray Tracing. </title> <booktitle> Computer Graphics: Visual Technology and Art (Proc. Computer Graphics Tokyo '85) (1985), </booktitle> <pages> 41-65. </pages>
Reference-contexts: Most ray tracing acceleration methods have concentrated on reducing or amortizing the cost of ray casting. This has been done by casting bundles of rays, as did beam-tracing for polyhedral scenes [15] and cone-tracing [1]; employing a fixed-grid <ref> [6] </ref> or adaptive [8] 3D spatial hierarchy of scene objects; and employing a 5D hierarchy associating ray sets and the object (s) encountered by rays in the set [3].
Reference: [7] <author> Glassner, A. </author> <title> Principles of Digital Image Synthesis. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Francisco, CA, </address> <year> 1995. </year>
Reference-contexts: Radiance values are computed by recursively spawning a ray tree for each eye ray [10]. Exemplary pseudocode for a backward ray-tracer can be found in [14]. A host of refinements and generalizations have since been proposed <ref> [10, 7] </ref>. 2.1 Ray Tracing Acceleration Ray tracing algorithms perform an expensive operation finding the first intersection of a ray with some scene object tensor hundreds of times per image pixel, and are therefore extremely compute intensive.
Reference: [8] <author> Glassner, A. S. </author> <title> Space Subdivision for Fast Ray Tracing. </title> <journal> IEEE Computer Graphics and Applications 4, </journal> <volume> 10 (1984), </volume> <pages> 15-22. </pages>
Reference-contexts: Most ray tracing acceleration methods have concentrated on reducing or amortizing the cost of ray casting. This has been done by casting bundles of rays, as did beam-tracing for polyhedral scenes [15] and cone-tracing [1]; employing a fixed-grid [6] or adaptive <ref> [8] </ref> 3D spatial hierarchy of scene objects; and employing a 5D hierarchy associating ray sets and the object (s) encountered by rays in the set [3].
Reference: [9] <author> Glassner, A. S. </author> <title> Spacetime Ray Tracing for Animation. </title> <journal> IEEE Computer Graphics and Applications 8, </journal> <month> 2 (Mar. </month> <year> 1988), </year> <pages> 60-70. </pages>
Reference-contexts: Popular public domain ray tracers such as RayShade [17] use an adaptive subdivision technique based on variance of screen space radiance samples. This is a necessary, but not sufficient, criterion for avoiding aliasing. Some researchers have addressed the problem of generating image sequences for scenes whose geometry <ref> [9] </ref> or material properties [22] change with time.
Reference: [10] <author> Glassner, A. S., Ed. </author> <title> An Introduction to Ray Tracing. </title> <publisher> Academic Press, </publisher> <year> 1989. </year>
Reference-contexts: Ray tracing algorithms, at the other end of the spectrum, estimate radiance (in units of power per source area per receiver steradian) for one or more rays through each pixel of an image <ref> [29, 10] </ref>. Radiance is a four-dimensional quantity over each surface, whose computation involves diffuse and specular effects, as well as reflection, transmission, and secondary emission effects. <p> Classical ray tracing was proposed in 1980 to simulate reflection and refraction 1 We do not consider texture mapping in this work. phenomena [29]. This approach identifies only those paths along which radiance reaches the eye from the specified light sources or background <ref> [10] </ref>. <p> Radiance values are computed by recursively spawning a ray tree for each eye ray <ref> [10] </ref>. Exemplary pseudocode for a backward ray-tracer can be found in [14]. <p> Radiance values are computed by recursively spawning a ray tree for each eye ray [10]. Exemplary pseudocode for a backward ray-tracer can be found in [14]. A host of refinements and generalizations have since been proposed <ref> [10, 7] </ref>. 2.1 Ray Tracing Acceleration Ray tracing algorithms perform an expensive operation finding the first intersection of a ray with some scene object tensor hundreds of times per image pixel, and are therefore extremely compute intensive. <p> These algorithms can be accelerated by making individual intersection tests faster via spatial subdivision or creative use of a z-buffer; by amortizing the per-ray intersection cost with a more general ray representation; or by spawning fewer rays via adaptive sampling or importance sampling (see <ref> [10] </ref>, pp. 204-5 for a taxonomy of such techniques current to 1989). Most ray tracing acceleration methods have concentrated on reducing or amortizing the cost of ray casting. <p> This "truncated" integration can give rise to error by excluding ray paths along which significant radiance may flow (e.g., light bouncing among many surfaces before reaching the eye). Researchers have addressed this source of error using distribution ray tracing [5], forward ray tracing <ref> [10] </ref> and path tracing [16]. This paper does not address truncation error, as our system is designed to compute an *-approximation to the radiance values computed by classical ray tracing. 3 Algorithm Overview This section presents a brief overview of our algorithm. <p> Thus, it should be possible to interpolate between radiance samples to produce values which are weighted averages of those associated with the samples. When is it sensible to interpolate radiance samples? The spawning of a ray can be thought of as inducing a ray tree <ref> [10] </ref> (Figure 2). Each tree leaf corresponds to an aggregation of direct illumination from a light source or the background, is labeled with a unique identifier for that source, and stores the radiance collected from the source. <p> Detecting Blockers: We detect blockers using a dynamic version of shaft culling [12]. Shaft culling was originally developed for use in a radiosity algorithm based on ray-casting. Our implementation uses kd-trees to partition the scene hierarchically for efficient ray casting <ref> [10] </ref>. Every ray between two points A and B propagates through some well-defined set of cells in this spatial subdivision. Every two cells in the subdivision have some "least common ancestor"; that is, the deepest (smallest) cell which contains them both.
Reference: [11] <author> Goral, C. M., Torrance, K. E., Greenberg, D. P., and Battaile, B. </author> <title> Modeling the Interaction of Light Between Diffuse Surfaces. </title> <journal> Computer Graphics (Proc. </journal> <volume> Siggraph '84) 18, 3 (1984), </volume> <pages> 213-222. </pages>
Reference-contexts: Viewing Freedom Radiosity algorithms, at one extreme, estimate radiosity (in units of power per area) on every input surface <ref> [11, 26] </ref>. Radiosity algorithms are usually formulated for polyhedral scenes, and can correctly handle only ideal diffuse emitters and receivers. Since the human visual system is very good at detecting and interpreting highlights that result from the directional variation of radiance, this representation is restrictive.
Reference: [12] <author> Haines, E., and Wallace, J. </author> <title> Shaft Culling for Efficient Ray-Traced Radiosity. </title> <booktitle> In Proc. 2 nd Eurographics Workshop on Rendering (May 1991). </booktitle>
Reference-contexts: Thus, the presence of gaps inside a ray subregion can be detected by comparing the topologies of the region's extremal ray trees. Detecting Blockers: We detect blockers using a dynamic version of shaft culling <ref> [12] </ref>. Shaft culling was originally developed for use in a radiosity algorithm based on ray-casting. Our implementation uses kd-trees to partition the scene hierarchically for efficient ray casting [10]. Every ray between two points A and B propagates through some well-defined set of cells in this spatial subdivision.
Reference: [13] <author> Hanrahan, P., Salzman, D., and Aupperle, L. </author> <title> A Rapid Hierarchical Radiosity Algorithm. </title> <journal> Computer Graphics (Proc. </journal> <volume> Siggraph '91) 25, 4 (1991), </volume> <pages> 197-206. </pages>
Reference-contexts: Given a fixed scene geometry and reflectance model, another long-standing problem in computer graphics is to achieve a controllable tradeoff between the time expended computing a solution, and the fidelity of that solution. Hierarchical radiosity techniques <ref> [13] </ref> explicitly incorporate solution error via lazy enumeration of coupling coefficients according to a per-coefficient error estimate. Sophisticated error bounds for radiosity solutions have also been described (e.g. in [18]).
Reference: [14] <author> Heckbert, P. </author> <title> Writing a Ray Tracer. In Introduction to Ray Tracing, </title> <editor> A. Glassner, Ed. </editor> <publisher> Academic Press, </publisher> <year> 1989, </year> <pages> pp. 263 - 294. </pages>
Reference-contexts: Radiance values are computed by recursively spawning a ray tree for each eye ray [10]. Exemplary pseudocode for a backward ray-tracer can be found in <ref> [14] </ref>. A host of refinements and generalizations have since been proposed [10, 7]. 2.1 Ray Tracing Acceleration Ray tracing algorithms perform an expensive operation finding the first intersection of a ray with some scene object tensor hundreds of times per image pixel, and are therefore extremely compute intensive.
Reference: [15] <author> Heckbert, P., and Hanrahan, P. </author> <title> Beam Tracing Polygonal Objects. </title> <journal> Computer Graphics (Proc. </journal> <volume> Siggraph '84) 18, 3 (1984), </volume> <pages> 119-127. </pages>
Reference-contexts: Most ray tracing acceleration methods have concentrated on reducing or amortizing the cost of ray casting. This has been done by casting bundles of rays, as did beam-tracing for polyhedral scenes <ref> [15] </ref> and cone-tracing [1]; employing a fixed-grid [6] or adaptive [8] 3D spatial hierarchy of scene objects; and employing a 5D hierarchy associating ray sets and the object (s) encountered by rays in the set [3]. <p> However, a conservative subdivision strategy preserves the correctness of our approach: we simply label any raytree containing a dense/sparse interface as non-isotopic. This may cause excessive sampling; however, it will never allow interpolation across a funnel. We note that existing beam-tracing <ref> [15] </ref> cone-tracing [1], and pencil-tracing [23] algorithms encounter this problem in a different form; refraction causes linear descriptions of ray bundles to become nonlinear.
Reference: [16] <author> Kajiya, J. T. </author> <title> The Rendering Equation. </title> <booktitle> In Computer Graphics (SIGGRAPH '86 Proceedings) (Aug. </booktitle> <year> 1986), </year> <editor> D. C. Evans and R. J. Athay, Eds., </editor> <volume> vol. 20, </volume> <pages> pp. 143-150. </pages>
Reference-contexts: This "truncated" integration can give rise to error by excluding ray paths along which significant radiance may flow (e.g., light bouncing among many surfaces before reaching the eye). Researchers have addressed this source of error using distribution ray tracing [5], forward ray tracing [10] and path tracing <ref> [16] </ref>. This paper does not address truncation error, as our system is designed to compute an *-approximation to the radiance values computed by classical ray tracing. 3 Algorithm Overview This section presents a brief overview of our algorithm.
Reference: [17] <author> Kolb, C. </author> <note> RayShade Homepage http://www-graphics.stanford.edu/ ~ cek/rayshade/. </note>
Reference-contexts: While many researchers have concentrated on reducing the per-ray intersection cost, relatively few published algorithms have the intent of reducing the number of rays cast. Popular public domain ray tracers such as RayShade <ref> [17] </ref> use an adaptive subdivision technique based on variance of screen space radiance samples. This is a necessary, but not sufficient, criterion for avoiding aliasing. Some researchers have addressed the problem of generating image sequences for scenes whose geometry [9] or material properties [22] change with time.
Reference: [18] <author> Lischinski, D., Smits, B., and Greenberg, D. P. </author> <title> Bounds and Error Estimates for Radiosity. </title> <booktitle> In Proceedings of SIGGRAPH '94 (Orlando, </booktitle> <address> Florida, </address> <month> July 24-29, </month> <year> 1994) </year> <month> (July </month> <year> 1994), </year> <editor> A. Glassner, Ed., </editor> <booktitle> Computer Graphics Proceedings, Annual Conference Series, ACM SIGGRAPH, </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 67-74. </pages> <note> ISBN 0-89791-667-0. </note>
Reference-contexts: Hierarchical radiosity techniques [13] explicitly incorporate solution error via lazy enumeration of coupling coefficients according to a per-coefficient error estimate. Sophisticated error bounds for radiosity solutions have also been described (e.g. in <ref> [18] </ref>). Ray tracing and hybrid algorithms have historically employed supersampling or distribution sampling to decrease solution error. 1.3 Our Approach Even using today's most powerful workstations, it is overambitious to attempt to represent the radiance distribution for all surfaces, from all viewing directions, for a non-trivial scene.
Reference: [19] <author> Megiddo, N. </author> <title> Linear-time algorithms for Linear Programming in R 3 and Related Problems. </title> <journal> SIAM Journal Computing 12 (1983), </journal> <pages> 759-776. </pages>
Reference-contexts: This 3D linear programming problem can be solved in time linear in the total number of vectors <ref> [19] </ref>. 6 Radiance Interpolants It remains to elucidate an interpolant mechanism that, given an isotopic region of rayspace, produces for every query ray in the region radiance values within * of those that would be computed by classical ray tracing.
Reference: [20] <author> Mitchell, D. P., and Hanrahan, P. </author> <title> Illumination From Curved Reflectors. </title> <booktitle> In Computer Graphics (SIGGRAPH '92 Proceedings) (July 1992), </booktitle> <editor> E. E. Catmull, Ed., </editor> <volume> vol. 26, </volume> <pages> pp. 283-291. </pages>
Reference-contexts: Finally, an intervening ray might encounter a peak in radiance centered on a specular highlight (for example, at point p in Figure 1-d). Radiance peaks occur at extremal paths, that is, those of locally minimal or maximal optical length (see <ref> [20] </ref> for a discussion of such paths in the context of ray tracing algorithms). 5 Ray Trees Rays spawned by a ray tracing algorithm not only have geometric attributes, but can also be thought of as "carrying" radiance, a physical quantity.
Reference: [21] <author> Nimeroff, J., Dorsey, J., and Rushmeier, H. </author> <title> A Framework for Global Illumination in Animated Environments. </title> <booktitle> In 6th Annual Eurographics Workshop on Rendering (June 12-14 1995), </booktitle> <pages> pp. 223-236. </pages>
Reference: [22] <author> S equin, C. H., and Smyrl, E. K. </author> <title> Parameterized Ray Tracing. </title> <booktitle> In Computer Graphics (SIGGRAPH '89 Proceedings) (July 1989), </booktitle> <editor> J. Lane, Ed., </editor> <volume> vol. 23, </volume> <pages> pp. 307-314. </pages>
Reference-contexts: This is a necessary, but not sufficient, criterion for avoiding aliasing. Some researchers have addressed the problem of generating image sequences for scenes whose geometry [9] or material properties <ref> [22] </ref> change with time.
Reference: [23] <author> Shinya, M., Takahashi, T., and Naito, S. </author> <title> Principles and Applications of Pencil Tracing. </title> <booktitle> In Computer Graphics (SIGGRAPH '87 Proceedings) (July 1987), </booktitle> <editor> M. C. Stone, Ed., </editor> <volume> vol. 21, </volume> <pages> pp. 45-54. </pages>
Reference-contexts: However, a conservative subdivision strategy preserves the correctness of our approach: we simply label any raytree containing a dense/sparse interface as non-isotopic. This may cause excessive sampling; however, it will never allow interpolation across a funnel. We note that existing beam-tracing [15] cone-tracing [1], and pencil-tracing <ref> [23] </ref> algorithms encounter this problem in a different form; refraction causes linear descriptions of ray bundles to become nonlinear.
Reference: [24] <author> Sillion, F., Arvo, J., Westin, S., and Greenberg, D. </author> <title> A Global Illumination Solution for General Reflectance Distributions. </title> <booktitle> Computer Graphics (SIGGRAPH '91 Proceedings) 25, </booktitle> <month> 4 (July </month> <year> 1991), </year> <pages> 187-196. </pages>
Reference-contexts: A class of hybrid techniques has arisen that compute more general representations of the radiance function typically, some discretized approximation to the radiance and/or irradiance field at each surface, or in space <ref> [27, 28, 25, 24, 4] </ref>. However, these representations have typically been extremely expensive to compute and store. Thus, the important visual cues provided by these algorithms (shadows, smooth shading, transparency, reflections, etc.) have not been achievable in interactive visual simulation applications. 1.2 Solution Error vs.
Reference: [25] <author> Sillion, F., and Puech, C. </author> <title> A General Two-Pass Method Integrating Specular and Diffuse Reflection. </title> <booktitle> Computer Graphics (SIGGRAPH '89 Proceedings) 23, </booktitle> <month> 3 (July </month> <year> 1989), </year> <pages> 335-344. </pages>
Reference-contexts: A class of hybrid techniques has arisen that compute more general representations of the radiance function typically, some discretized approximation to the radiance and/or irradiance field at each surface, or in space <ref> [27, 28, 25, 24, 4] </ref>. However, these representations have typically been extremely expensive to compute and store. Thus, the important visual cues provided by these algorithms (shadows, smooth shading, transparency, reflections, etc.) have not been achievable in interactive visual simulation applications. 1.2 Solution Error vs.
Reference: [26] <author> Sillion, F., and Puech, C. </author> <title> Radiosity and Global Illumination. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Francisco, CA, </address> <year> 1994. </year>
Reference-contexts: Viewing Freedom Radiosity algorithms, at one extreme, estimate radiosity (in units of power per area) on every input surface <ref> [11, 26] </ref>. Radiosity algorithms are usually formulated for polyhedral scenes, and can correctly handle only ideal diffuse emitters and receivers. Since the human visual system is very good at detecting and interpreting highlights that result from the directional variation of radiance, this representation is restrictive.
Reference: [27] <author> Wallace, J., Cohen, M., and Greenberg, D. </author> <title> A Two-Pass Solution to the Rendering Equation: A Synthesis of Ray Tracing and Radiosity Methods_ Computer Graphics (SIGGRAPH '87 Proceedings) 21, </title> <month> 4 (July </month> <year> 1987), </year> <pages> 311-320. </pages>
Reference-contexts: A class of hybrid techniques has arisen that compute more general representations of the radiance function typically, some discretized approximation to the radiance and/or irradiance field at each surface, or in space <ref> [27, 28, 25, 24, 4] </ref>. However, these representations have typically been extremely expensive to compute and store. Thus, the important visual cues provided by these algorithms (shadows, smooth shading, transparency, reflections, etc.) have not been achievable in interactive visual simulation applications. 1.2 Solution Error vs.
Reference: [28] <author> Ward, G. J., Rubinstein, F. M., and Clear, R. D. </author> <title> A Ray Tracing Solution for Diffuse Interreflection. </title> <booktitle> In Computer Graphics (SIGGRAPH '88 Proceedings) (Aug. </booktitle> <year> 1988), </year> <editor> J. Dill, Ed., </editor> <volume> vol. 22, </volume> <pages> pp. 85-92. </pages>
Reference-contexts: A class of hybrid techniques has arisen that compute more general representations of the radiance function typically, some discretized approximation to the radiance and/or irradiance field at each surface, or in space <ref> [27, 28, 25, 24, 4] </ref>. However, these representations have typically been extremely expensive to compute and store. Thus, the important visual cues provided by these algorithms (shadows, smooth shading, transparency, reflections, etc.) have not been achievable in interactive visual simulation applications. 1.2 Solution Error vs.
Reference: [29] <author> Whitted, T. </author> <title> An Improved Illumination Model for Shaded Display. </title> <journal> CACM 23, </journal> <volume> 6 (1980), </volume> <pages> 343-349. </pages>
Reference-contexts: Ray tracing algorithms, at the other end of the spectrum, estimate radiance (in units of power per source area per receiver steradian) for one or more rays through each pixel of an image <ref> [29, 10] </ref>. Radiance is a four-dimensional quantity over each surface, whose computation involves diffuse and specular effects, as well as reflection, transmission, and secondary emission effects. <p> Classical ray tracing was proposed in 1980 to simulate reflection and refraction 1 We do not consider texture mapping in this work. phenomena <ref> [29] </ref>. This approach identifies only those paths along which radiance reaches the eye from the specified light sources or background [10].
References-found: 29

