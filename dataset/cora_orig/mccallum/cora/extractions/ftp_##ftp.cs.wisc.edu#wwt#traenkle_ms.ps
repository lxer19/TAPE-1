URL: ftp://ftp.cs.wisc.edu/wwt/traenkle_ms.ps
Refering-URL: http://www.cs.wisc.edu/~wwt/wwt_papers.html
Root-URL: 
Title: PARALLEL PROGRAMMING MODELS AND BOUNDARY INTEGRAL EQUATION METHODS FOR MICROSTRUCTURE ELECTROSTATICS  
Author: By Frank Traenkle 
Degree: A thesis submitted in partial fulfillment of the requirements for the degree of Master of Science (Chemical Engineering) at the  
Date: 1993  
Address: WISCONSIN MADISON  
Affiliation: UNIVERSITY OF  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> N. Amann. </author> <title> Mobility Problems in Bounded Stokes Flow by Boundary Integral Methods. </title> <type> Master's thesis, </type> <institution> University of Wisconsin - Madison, </institution> <year> 1992. </year>
Reference-contexts: */ #else # define VTSTART (); ; # define VTSTOP (ulVTSym); ; #endif #ifdef WWT # define PRINT_ADDRESS (sz, p) " fprintf (pFileStd, "%20s %12u %12u"n", sz, p, (ULONG)p % (ULONG)BLOCK_SIZE); #endif #ifdef CONTAINER # define CONTAINER_1 " fpRy = AABS (afpY);" afpD [0] = afpY [0] / fpRy;" afpD <ref> [1] </ref> = afpY [1] / fpRy;" afpD [2] = afpY [2] / fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ [1] = afpD [1] * fpRz;" afpZ [2] = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX <p> define VTSTART (); ; # define VTSTOP (ulVTSym); ; #endif #ifdef WWT # define PRINT_ADDRESS (sz, p) " fprintf (pFileStd, "%20s %12u %12u"n", sz, p, (ULONG)p % (ULONG)BLOCK_SIZE); #endif #ifdef CONTAINER # define CONTAINER_1 " fpRy = AABS (afpY);" afpD [0] = afpY [0] / fpRy;" afpD <ref> [1] </ref> = afpY [1] / fpRy;" afpD [2] = afpY [2] / fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ [1] = afpD [1] * fpRz;" afpZ [2] = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX [1] - afpZ <p> sz, p, (ULONG)p % (ULONG)BLOCK_SIZE); #endif #ifdef CONTAINER # define CONTAINER_1 " fpRy = AABS (afpY);" afpD [0] = afpY [0] / fpRy;" afpD <ref> [1] </ref> = afpY [1] / fpRy;" afpD [2] = afpY [2] / fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ [1] = afpD [1] * fpRz;" afpZ [2] = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX [1] - afpZ [1];" afpXmZ [2] = afpX [2] - afpZ [2];" fpRxz = AABS (afpXmZ);" for (ulII = 0; ulII &lt; 3; ulII++)" -" afpSum1 <p> % (ULONG)BLOCK_SIZE); #endif #ifdef CONTAINER # define CONTAINER_1 " fpRy = AABS (afpY);" afpD [0] = afpY [0] / fpRy;" afpD <ref> [1] </ref> = afpY [1] / fpRy;" afpD [2] = afpY [2] / fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ [1] = afpD [1] * fpRz;" afpZ [2] = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX [1] - afpZ [1];" afpXmZ [2] = afpX [2] - afpZ [2];" fpRxz = AABS (afpXmZ);" for (ulII = 0; ulII &lt; 3; ulII++)" -" afpSum1 [ulII] = 0.;" <p> fpRy;" afpD <ref> [1] </ref> = afpY [1] / fpRy;" afpD [2] = afpY [2] / fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ [1] = afpD [1] * fpRz;" afpZ [2] = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX [1] - afpZ [1];" afpXmZ [2] = afpX [2] - afpZ [2];" fpRxz = AABS (afpXmZ);" for (ulII = 0; ulII &lt; 3; ulII++)" -" afpSum1 [ulII] = 0.;" for (ulJJ = 0; ulJJ &lt; 3; ulJJ++)" 160 afpSum1 [ulII] += (DELTA (ulII, ulJJ) - 2. * afpD <p> = afpY <ref> [1] </ref> / fpRy;" afpD [2] = afpY [2] / fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ [1] = afpD [1] * fpRz;" afpZ [2] = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX [1] - afpZ [1];" afpXmZ [2] = afpX [2] - afpZ [2];" fpRxz = AABS (afpXmZ);" for (ulII = 0; ulII &lt; 3; ulII++)" -" afpSum1 [ulII] = 0.;" for (ulJJ = 0; ulJJ &lt; 3; ulJJ++)" 160 afpSum1 [ulII] += (DELTA (ulII, ulJJ) - 2. * afpD [ulII] *" afpD <p> / fpRy;" afpD [2] = afpY [2] / fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ <ref> [1] </ref> = afpD [1] * fpRz;" afpZ [2] = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX [1] - afpZ [1];" afpXmZ [2] = afpX [2] - afpZ [2];" fpRxz = AABS (afpXmZ);" for (ulII = 0; ulII &lt; 3; ulII++)" -" afpSum1 [ulII] = 0.;" for (ulJJ = 0; ulJJ &lt; 3; ulJJ++)" 160 afpSum1 [ulII] += (DELTA (ulII, ulJJ) - 2. * afpD [ulII] *" afpD [ulJJ]) * afpXmZ <p> (afpXmZ);" for (ulII = 0; ulII &lt; 3; ulII++)" -" afpSum1 [ulII] = 0.;" for (ulJJ = 0; ulJJ &lt; 3; ulJJ++)" 160 afpSum1 [ulII] += (DELTA (ulII, ulJJ) - 2. * afpD [ulII] *" afpD [ulJJ]) * afpXmZ [ulJJ];" -" #define CONTAINER_2 " ((pgeoJ-&gt;afpN [0]*afpXmY [0] +" pgeoJ-&gt;afpN <ref> [1] </ref>*afpXmY [1] +" pgeoJ-&gt;afpN [2]*afpXmY [2]) /" (fpRxy * fpRxy * fpRxy) +" (-fpRz *" (pgeoJ-&gt;afpN [0] * afpSum1 [0] +" pgeoJ-&gt;afpN [1] * afpSum1 [1] +" pgeoJ-&gt;afpN [2] * afpSum1 [2]) /" SQR (fpRxz) +" pgeoJ-&gt;afpN [0] * afpD [0] +" pgeoJ-&gt;afpN [1] * afpD [1] +" pgeoJ-&gt;afpN [2] * afpD <p> ulJJ++)" 160 afpSum1 [ulII] += (DELTA (ulII, ulJJ) - 2. * afpD [ulII] *" afpD [ulJJ]) * afpXmZ [ulJJ];" -" #define CONTAINER_2 " ((pgeoJ-&gt;afpN [0]*afpXmY [0] +" pgeoJ-&gt;afpN <ref> [1] </ref>*afpXmY [1] +" pgeoJ-&gt;afpN [2]*afpXmY [2]) /" (fpRxy * fpRxy * fpRxy) +" (-fpRz *" (pgeoJ-&gt;afpN [0] * afpSum1 [0] +" pgeoJ-&gt;afpN [1] * afpSum1 [1] +" pgeoJ-&gt;afpN [2] * afpSum1 [2]) /" SQR (fpRxz) +" pgeoJ-&gt;afpN [0] * afpD [0] +" pgeoJ-&gt;afpN [1] * afpD [1] +" pgeoJ-&gt;afpN [2] * afpD [2]) *" SQR (fpRz) / (fpRxz * pg-&gt;fpR3)); #endif #ifdef WWT /*-------------------- Initialize WWT Environment ---------------------*/ #endif /*-------------------- INCLUDEs ---------------------*/ #include <p> [ulII] += (DELTA (ulII, ulJJ) - 2. * afpD [ulII] *" afpD [ulJJ]) * afpXmZ [ulJJ];" -" #define CONTAINER_2 " ((pgeoJ-&gt;afpN [0]*afpXmY [0] +" pgeoJ-&gt;afpN <ref> [1] </ref>*afpXmY [1] +" pgeoJ-&gt;afpN [2]*afpXmY [2]) /" (fpRxy * fpRxy * fpRxy) +" (-fpRz *" (pgeoJ-&gt;afpN [0] * afpSum1 [0] +" pgeoJ-&gt;afpN [1] * afpSum1 [1] +" pgeoJ-&gt;afpN [2] * afpSum1 [2]) /" SQR (fpRxz) +" pgeoJ-&gt;afpN [0] * afpD [0] +" pgeoJ-&gt;afpN [1] * afpD [1] +" pgeoJ-&gt;afpN [2] * afpD [2]) *" SQR (fpRz) / (fpRxz * pg-&gt;fpR3)); #endif #ifdef WWT /*-------------------- Initialize WWT Environment ---------------------*/ #endif /*-------------------- INCLUDEs ---------------------*/ #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; <p> CONTAINER_2 " ((pgeoJ-&gt;afpN [0]*afpXmY [0] +" pgeoJ-&gt;afpN <ref> [1] </ref>*afpXmY [1] +" pgeoJ-&gt;afpN [2]*afpXmY [2]) /" (fpRxy * fpRxy * fpRxy) +" (-fpRz *" (pgeoJ-&gt;afpN [0] * afpSum1 [0] +" pgeoJ-&gt;afpN [1] * afpSum1 [1] +" pgeoJ-&gt;afpN [2] * afpSum1 [2]) /" SQR (fpRxz) +" pgeoJ-&gt;afpN [0] * afpD [0] +" pgeoJ-&gt;afpN [1] * afpD [1] +" pgeoJ-&gt;afpN [2] * afpD [2]) *" SQR (fpRz) / (fpRxz * pg-&gt;fpR3)); #endif #ifdef WWT /*-------------------- Initialize WWT Environment ---------------------*/ #endif /*-------------------- INCLUDEs ---------------------*/ #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;string.h&gt; #include &lt;assert.h&gt; #ifdef WWT #include &lt;align.h&gt; #endif #include "my.h" #include "geometry.h" /*-------------------- TYPEDEFs ---------------------*/ <p> [0]*afpXmY [0] +" pgeoJ-&gt;afpN <ref> [1] </ref>*afpXmY [1] +" pgeoJ-&gt;afpN [2]*afpXmY [2]) /" (fpRxy * fpRxy * fpRxy) +" (-fpRz *" (pgeoJ-&gt;afpN [0] * afpSum1 [0] +" pgeoJ-&gt;afpN [1] * afpSum1 [1] +" pgeoJ-&gt;afpN [2] * afpSum1 [2]) /" SQR (fpRxz) +" pgeoJ-&gt;afpN [0] * afpD [0] +" pgeoJ-&gt;afpN [1] * afpD [1] +" pgeoJ-&gt;afpN [2] * afpD [2]) *" SQR (fpRz) / (fpRxz * pg-&gt;fpR3)); #endif #ifdef WWT /*-------------------- Initialize WWT Environment ---------------------*/ #endif /*-------------------- INCLUDEs ---------------------*/ #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;string.h&gt; #include &lt;assert.h&gt; #ifdef WWT #include &lt;align.h&gt; #endif #include "my.h" #include "geometry.h" /*-------------------- TYPEDEFs ---------------------*/ /* body data <p> void CreateAkl (); static void CreateBn (); static void Solve (); /*-------------------- MAIN ---------------------*/ int main (iAN, szA) int iAN; char *szA []; - #ifdef WWT /* init WWT environment */ INITENV #endif /* get general input file name from argument list */ assert (iAN == 2); strcpy (szFileIn, szA <ref> [1] </ref>); /* open standard output file */ /* pFileStd = fopen ("out", "w"); */ pFileStd = stdout; fprintf (pFileStd, "--- Initialize ---"n"); Initialize (); fprintf (pFileStd, "--- CreateGeometry ---"n"); CreateGeometry (pg-&gt;usPolyN, pg-&gt;usTessN); fprintf (pFileStd, "--- StoreElements ---"n"); StoreElements (); fprintf (pFileStd, "--- AdjustGeometry ---"n"); AdjustGeometry (); fprintf (pFileStd, "--- CloseGeometry ---"n"); <p> fclose (pFileInSol); - /* read input file for geometrical data */ pFileGeo = fopen (szFileGeo, "r"); assert (pFileGeo != NULL); fscanf (pFileGeo, "%u", &ulN); 170 /* check if geo file is consistent to num file */ assert (pg-&gt;ulN == ulN); #ifdef SINGLEPREC fscanf (pFileGeo, "%f %f %f", &pg-&gt;afpE0 [0], &pg-&gt;afpE0 <ref> [1] </ref>, &pg-&gt;afpE0 [2]); #else fscanf (pFileGeo, "%lf %lf %lf", &pg-&gt;afpE0 [0], &pg-&gt;afpE0 [1], &pg-&gt;afpE0 [2]); #endif for (ulI = 0; ulI &lt; pg-&gt;ulN; ulI++) #ifdef SINGLEPREC fscanf (pFileGeo, "%f %f %f %f %f", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], &pg-&gt;abody [ulI].fpR, &pg-&gt;abody [ulI].fpQ); #else fscanf (pFileGeo, "%lf %lf <p> = fopen (szFileGeo, "r"); assert (pFileGeo != NULL); fscanf (pFileGeo, "%u", &ulN); 170 /* check if geo file is consistent to num file */ assert (pg-&gt;ulN == ulN); #ifdef SINGLEPREC fscanf (pFileGeo, "%f %f %f", &pg-&gt;afpE0 [0], &pg-&gt;afpE0 <ref> [1] </ref>, &pg-&gt;afpE0 [2]); #else fscanf (pFileGeo, "%lf %lf %lf", &pg-&gt;afpE0 [0], &pg-&gt;afpE0 [1], &pg-&gt;afpE0 [2]); #endif for (ulI = 0; ulI &lt; pg-&gt;ulN; ulI++) #ifdef SINGLEPREC fscanf (pFileGeo, "%f %f %f %f %f", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], &pg-&gt;abody [ulI].fpR, &pg-&gt;abody [ulI].fpQ); #else fscanf (pFileGeo, "%lf %lf %lf %lf %lf", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], <p> == ulN); #ifdef SINGLEPREC fscanf (pFileGeo, "%f %f %f", &pg-&gt;afpE0 [0], &pg-&gt;afpE0 <ref> [1] </ref>, &pg-&gt;afpE0 [2]); #else fscanf (pFileGeo, "%lf %lf %lf", &pg-&gt;afpE0 [0], &pg-&gt;afpE0 [1], &pg-&gt;afpE0 [2]); #endif for (ulI = 0; ulI &lt; pg-&gt;ulN; ulI++) #ifdef SINGLEPREC fscanf (pFileGeo, "%f %f %f %f %f", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], &pg-&gt;abody [ulI].fpR, &pg-&gt;abody [ulI].fpQ); #else fscanf (pFileGeo, "%lf %lf %lf %lf %lf", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], &pg-&gt;abody [ulI].fpR, &pg-&gt;abody [ulI].fpQ); #endif pg-&gt;abody [ulI].ulNumber = ulI; - #ifdef CONTAINER # ifdef SINGLEPREC fscanf (pFileGeo, "%f", &pg-&gt;fpR); # else fscanf (pFileGeo, "%lf", &pg-&gt;fpR); # <p> &pg-&gt;afpE0 [0], &pg-&gt;afpE0 <ref> [1] </ref>, &pg-&gt;afpE0 [2]); #endif for (ulI = 0; ulI &lt; pg-&gt;ulN; ulI++) #ifdef SINGLEPREC fscanf (pFileGeo, "%f %f %f %f %f", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], &pg-&gt;abody [ulI].fpR, &pg-&gt;abody [ulI].fpQ); #else fscanf (pFileGeo, "%lf %lf %lf %lf %lf", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], &pg-&gt;abody [ulI].fpR, &pg-&gt;abody [ulI].fpQ); #endif pg-&gt;abody [ulI].ulNumber = ulI; - #ifdef CONTAINER # ifdef SINGLEPREC fscanf (pFileGeo, "%f", &pg-&gt;fpR); # else fscanf (pFileGeo, "%lf", &pg-&gt;fpR); # endif /* its square, cube */ pg-&gt;fpR2 = SQR (pg-&gt;fpR); #endif fclose (pFileGeo); #ifdef WWT PRINT_ADDRESS ("usQuadN", &pg-&gt;usQuadN); PRINT_ADDRESS ("afpQuadX", &pg-&gt;afpQuadX); <p> ulI++) GetElementAll (ulI, &pg-&gt;ageo [ulI]); pg-&gt;fpGeoA += pg-&gt;ageo [ulI].fpDA; - /*-------------------- ADJUSTGEOMETRY ---------------------*/ static void AdjustGeometry () - ULONG ulI; FPTYPE fpRadiusPolyInv; 172 PGEO pgeo; fpRadiusPolyInv = sqrt ((4. * PI) / pg-&gt;fpGeoA); for (ulI = 0; ulI &lt; pg-&gt;ulM; ulI++) pgeo = &pg-&gt;ageo [ulI]; pgeo-&gt;afpP1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP1 <ref> [1] </ref> *= fpRadiusPolyInv; pgeo-&gt;afpP1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [1] *= fpRadiusPolyInv; <p> ---------------------*/ static void AdjustGeometry () - ULONG ulI; FPTYPE fpRadiusPolyInv; 172 PGEO pgeo; fpRadiusPolyInv = sqrt ((4. * PI) / pg-&gt;fpGeoA); for (ulI = 0; ulI &lt; pg-&gt;ulM; ulI++) pgeo = &pg-&gt;ageo [ulI]; pgeo-&gt;afpP1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP1 <ref> [1] </ref> *= fpRadiusPolyInv; pgeo-&gt;afpP1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpX [0] *= fpRadiusPolyInv; pgeo-&gt;afpX [1] *= fpRadiusPolyInv; <p> pgeo; fpRadiusPolyInv = sqrt ((4. * PI) / pg-&gt;fpGeoA); for (ulI = 0; ulI &lt; pg-&gt;ulM; ulI++) pgeo = &pg-&gt;ageo [ulI]; pgeo-&gt;afpP1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP1 <ref> [1] </ref> *= fpRadiusPolyInv; pgeo-&gt;afpP1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpX [0] *= fpRadiusPolyInv; pgeo-&gt;afpX [1] *= fpRadiusPolyInv; pgeo-&gt;afpX [2] *= fpRadiusPolyInv; pgeo-&gt;fpDA *= fpRadiusPolyInv * fpRadiusPolyInv; pgeo-&gt;fpJacob *= fpRadiusPolyInv <p> 0; ulI &lt; pg-&gt;ulM; ulI++) pgeo = &pg-&gt;ageo [ulI]; pgeo-&gt;afpP1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP1 <ref> [1] </ref> *= fpRadiusPolyInv; pgeo-&gt;afpP1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpX [0] *= fpRadiusPolyInv; pgeo-&gt;afpX [1] *= fpRadiusPolyInv; pgeo-&gt;afpX [2] *= fpRadiusPolyInv; pgeo-&gt;fpDA *= fpRadiusPolyInv * fpRadiusPolyInv; pgeo-&gt;fpJacob *= fpRadiusPolyInv * fpRadiusPolyInv; - pg-&gt;fpGeoA *= fpRadiusPolyInv * fpRadiusPolyInv; - LOADBALANCE ---------------------------*/ static <p> fpRadiusPolyInv; pgeo-&gt;afpP1 <ref> [1] </ref> *= fpRadiusPolyInv; pgeo-&gt;afpP1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpX [0] *= fpRadiusPolyInv; pgeo-&gt;afpX [1] *= fpRadiusPolyInv; pgeo-&gt;afpX [2] *= fpRadiusPolyInv; pgeo-&gt;fpDA *= fpRadiusPolyInv * fpRadiusPolyInv; pgeo-&gt;fpJacob *= fpRadiusPolyInv * fpRadiusPolyInv; - pg-&gt;fpGeoA *= fpRadiusPolyInv * fpRadiusPolyInv; - LOADBALANCE ---------------------------*/ static void LoadBalance () - ULONG ulI, ulJ, ulK; ULONG ulP; ULONG *aulCrit; <p> fpRadiusPolyInv; pgeo-&gt;afpP2 <ref> [1] </ref> *= fpRadiusPolyInv; pgeo-&gt;afpP2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpX [0] *= fpRadiusPolyInv; pgeo-&gt;afpX [1] *= fpRadiusPolyInv; pgeo-&gt;afpX [2] *= fpRadiusPolyInv; pgeo-&gt;fpDA *= fpRadiusPolyInv * fpRadiusPolyInv; pgeo-&gt;fpJacob *= fpRadiusPolyInv * fpRadiusPolyInv; - pg-&gt;fpGeoA *= fpRadiusPolyInv * fpRadiusPolyInv; - LOADBALANCE ---------------------------*/ static void LoadBalance () - ULONG ulI, ulJ, ulK; ULONG ulP; ULONG *aulCrit; ULONG *aulCritSum; ULONG *aulN; ULONG *aulPrio; ULONG ulCritMax; ULONG ulIMax; ULONG ulCritSumMin; <p> "); # endif #else fprintf (pFileOut, "# cico=0 "); #endif #ifdef LOCK_ fprintf (pFileOut, "lock=1"); 176 #else fprintf (pFileOut, "lock=0"); #endif fprintf (pFileOut, ""n"); #ifdef CONTAINER fprintf (pFileOut, "# Container R = %21.12g"n", pg-&gt;fpR); #else fprintf (pFileOut, "# No Container"n"); #endif fprintf (pFileOut, "# E0 = (%21.12g,%21.12g,%21.12g)"n#"n", pg-&gt;afpE0 [0], pg-&gt;afpE0 <ref> [1] </ref>, pg-&gt;afpE0 [2]); fprintf (pFileOut, "# In Files = %s"n", szFileIn); fprintf (pFileOut, "# In Quad = %s"n", szFileQuad); fprintf (pFileOut, "# In Num = %s"n", szFileNum); fprintf (pFileOut, "# In Geo = %s"n", szFileGeo); fprintf (pFileOut, "# In Sol = %s"n", szFileInSol); fprintf (pFileOut, "# Out Psi = %s"n", szFileOutPsi); <p> 0; ulIter &lt; pg-&gt;ulIterN; ulIter++) - fprintf (pFileOutPsi, "--- Iteration %3hu ---"n", ulIter + 1); fprintf (pFileOutPsi, "Sphere Q X Y Z R Psi"n"); for (ulK = 0; ulK &lt; pg-&gt;ulN; ulK++) fprintf (pFileOutPsi, "%4lu %7.3g %7.3g %7.3g %7.3g %7.3g %21.12g"n", pg-&gt;abody [ulK].ulNumber, pg-&gt;abody [ulK].fpQ, pg-&gt;abody [ulK].afpZ [0], pg-&gt;abody [ulK].afpZ <ref> [1] </ref>, pg-&gt;abody [ulK].afpZ [2], pg-&gt;abody [ulK].fpR, *pfpPsi); pfpPsi++; - fprintf (pFileOutPsi, ""n"); 177 OutputInfo (pFileOutPsi); /* close output file */ fclose (pFileOutPsi); - OUTPUTSOL ---------------------------*/ static void OutputSol () - FILE *pFileOutSol; ULONG ulK, ulL; ULONG ulI; pFileOutSol = fopen (szFileOutSol, "w"); /* output x on every element */ for (ulK <p> pbodyN = &pg-&gt;abody [ulN]; fpNR2 = SQR (pbodyN-&gt;fpR); fpS1 = .5 * fpNR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpX <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpX [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; <p> [ulN]; fpNR2 = SQR (pbodyN-&gt;fpR); fpS1 = .5 * fpNR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpX <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpX [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = <p> fpS1 = .5 * fpNR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpX <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpX [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + <p> pgeoI-&gt;afpX <ref> [1] </ref> * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpX [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY <p> pbodyN-&gt;fpR + pbodyN-&gt;afpZ <ref> [1] </ref>; afpX [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + 184 <p> [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + 184 afpXmY [2]*afpXmY [2]; /* check <p> pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + 184 afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpNR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = <p> pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + 184 afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpNR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 <p> - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + 184 afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpNR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 *pfpAAA = -pgeoJ-&gt;fpDA <p> = pgeoI-&gt;afpX <ref> [1] </ref> * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + 184 afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpNR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 *pfpAAA = -pgeoJ-&gt;fpDA / pg-&gt;fpGeoA - fpS1 * pgeoJ-&gt;fpDA * CONTAINER_2 - /* check if large distance */ else - <p> */ else - /* Gaussian-Legendre Quadrature */ fpSum = 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY <ref> [1] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] <p> */ fpSum = 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY <ref> [1] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; <p> (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY <ref> [1] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] <p> usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY <ref> [1] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; <p> for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY <ref> [1] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 <p> <ref> [1] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -pgeoJ-&gt;fpDA / pg-&gt;fpGeoA - fpSum * fpS1; - /* check if large distance */ - /* loop through <p> [usIXs] * pgeoJ-&gt;afpU1 <ref> [1] </ref> + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -pgeoJ-&gt;fpDA / pg-&gt;fpGeoA - fpSum * fpS1; - /* check if large distance */ - /* loop through columns */ - <p> <ref> [1] </ref> + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -pgeoJ-&gt;fpDA / pg-&gt;fpGeoA - fpSum * fpS1; - /* check if large distance */ - /* loop through columns */ - /* loop through <p> pbodyL = &pg-&gt;abody [ulL]; fpLR2 = SQR (pbodyL-&gt;fpR); fpS1 = .5 * fpLR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [0]; afpX <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ <p> [ulL]; fpLR2 = SQR (pbodyL-&gt;fpR); fpS1 = .5 * fpLR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [0]; afpX <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] <p> fpS1 = .5 * fpLR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [0]; afpX <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR <p> <ref> [1] </ref> * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY <p> + pbodyK-&gt;afpZ <ref> [1] </ref>; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY <p> = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if <p> ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpLR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt <p> ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpLR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 *pfpAAA <p> pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpLR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 *pfpAAA = -fpS1 * <p> = pgeoI-&gt;afpX <ref> [1] </ref> * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpLR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 *pfpAAA = -fpS1 * pgeoJ-&gt;fpDA * CONTAINER_2 - /* check if large distance */ else - /* Gaussian-Legendre Quadrature */ fpSum <p> */ fpSum = 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - /* FRANK: factor out w_s */ for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY <ref> [1] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] <p> = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - /* FRANK: factor out w_s */ for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY <ref> [1] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; <p> usIXs++) - /* FRANK: factor out w_s */ for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY <ref> [1] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] <p> FRANK: factor out w_s */ for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY <ref> [1] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; <p> for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY <ref> [1] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 <p> <ref> [1] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -fpSum * fpS1; - /* check if large distance */ 187 - /* loop through columns */ - <p> [usIXs] * pgeoJ-&gt;afpU1 <ref> [1] </ref> + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -fpSum * fpS1; - /* check if large distance */ 187 - /* loop through columns */ - /* loop through <p> <ref> [1] </ref> + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -fpSum * fpS1; - /* check if large distance */ 187 - /* loop through columns */ - /* loop through rows */ - <p> = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; /* check if diagonal element */ if (ulJ == ulI) *pfpAAA = -pgeoI-&gt;fpDA / pg-&gt;fpGeoA; - /* check if diagonal element */ else - afpXmY [0] = (pgeoI-&gt;afpX [0] - pgeoJ-&gt;afpX [0]) * fpR; afpXmY <ref> [1] </ref> = (pgeoI-&gt;afpX [1] - pgeoJ-&gt;afpX [1]) * 188 afpXmY [2] = (pgeoI-&gt;afpX [2] - pgeoJ-&gt;afpX [2]) * fpR; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpR * fpR) - /* no <p> = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; /* check if diagonal element */ if (ulJ == ulI) *pfpAAA = -pgeoI-&gt;fpDA / pg-&gt;fpGeoA; - /* check if diagonal element */ else - afpXmY [0] = (pgeoI-&gt;afpX [0] - pgeoJ-&gt;afpX [0]) * fpR; afpXmY <ref> [1] </ref> = (pgeoI-&gt;afpX [1] - pgeoJ-&gt;afpX [1]) * 188 afpXmY [2] = (pgeoI-&gt;afpX [2] - pgeoJ-&gt;afpX [2]) * fpR; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpR * fpR) - /* no Gaussian-Legendre Quadrature */ <p> &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; /* check if diagonal element */ if (ulJ == ulI) *pfpAAA = -pgeoI-&gt;fpDA / pg-&gt;fpGeoA; - /* check if diagonal element */ else - afpXmY [0] = (pgeoI-&gt;afpX [0] - pgeoJ-&gt;afpX [0]) * fpR; afpXmY <ref> [1] </ref> = (pgeoI-&gt;afpX [1] - pgeoJ-&gt;afpX [1]) * 188 afpXmY [2] = (pgeoI-&gt;afpX [2] - pgeoJ-&gt;afpX [2]) * fpR; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpR * fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt <p> -pgeoI-&gt;fpDA / pg-&gt;fpGeoA; - /* check if diagonal element */ else - afpXmY [0] = (pgeoI-&gt;afpX [0] - pgeoJ-&gt;afpX [0]) * fpR; afpXmY <ref> [1] </ref> = (pgeoI-&gt;afpX [1] - pgeoJ-&gt;afpX [1]) * 188 afpXmY [2] = (pgeoI-&gt;afpX [2] - pgeoJ-&gt;afpX [2]) * fpR; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpR * fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA * fpR * fpR * .5 * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY <p> + afpXmY <ref> [1] </ref>*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpR * fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA * fpR * fpR * .5 * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (PI * fpRxy * fpRxy * fpRxy) - pgeoJ-&gt;fpDA / pg-&gt;fpGeoA; - /* check if large distance */ else - /* Gaussian-Legendre Quadrature */ fpSum = 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - <p> /* check if large distance */ else - /* Gaussian-Legendre Quadrature */ fpSum = 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY <ref> [1] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; <p> else - /* Gaussian-Legendre Quadrature */ fpSum = 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY <ref> [1] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - <p> */ fpSum = 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY <ref> [1] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy <p> 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY <ref> [1] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY <p> *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY <ref> [1] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN <p> [0] + pgeoJ-&gt;afpP2 [0]; afpY <ref> [1] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / <p> [0]; afpY <ref> [1] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy <p> * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY <ref> [1] </ref> = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - 189 *pfpAAA = -fpSum * .5 * fpR * fpR / PI - pgeoJ-&gt;fpDA / pg-&gt;fpGeoA; - /* check <p> fpR; afpXmY <ref> [1] </ref> = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - 189 *pfpAAA = -fpSum * .5 * fpR * fpR / PI - pgeoJ-&gt;fpDA / pg-&gt;fpGeoA; - /* check if large distance */ - /* check if diagonal element */ - /* loop through columns */ - /* loop <p> static FPTYPE fpSum; static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static FPTYPE afpZdst [3]; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; /* distance between particle centers */ afpZdst [0] = pbodyK-&gt;afpZ [0] - pbodyL-&gt;afpZ [0]; afpZdst <ref> [1] </ref> = pbodyK-&gt;afpZ [1] - pbodyL-&gt;afpZ [1]; afpZdst [2] = pbodyK-&gt;afpZ [2] - pbodyL-&gt;afpZ [2]; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR; afpX [1] = pgeoI-&gt;afpX [1] <p> static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static FPTYPE afpZdst [3]; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; /* distance between particle centers */ afpZdst [0] = pbodyK-&gt;afpZ [0] - pbodyL-&gt;afpZ [0]; afpZdst <ref> [1] </ref> = pbodyK-&gt;afpZ [1] - pbodyL-&gt;afpZ [1]; afpZdst [2] = pbodyK-&gt;afpZ [2] - pbodyL-&gt;afpZ [2]; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR; afpX [1] = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR; afpX <p> [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static FPTYPE afpZdst [3]; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; /* distance between particle centers */ afpZdst [0] = pbodyK-&gt;afpZ [0] - pbodyL-&gt;afpZ [0]; afpZdst <ref> [1] </ref> = pbodyK-&gt;afpZ [1] - pbodyL-&gt;afpZ [1]; afpZdst [2] = pbodyK-&gt;afpZ [2] - pbodyL-&gt;afpZ [2]; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR; afpX [1] = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR; afpX [2] = pgeoI-&gt;afpX <p> pbodyL-&gt;afpZ [0]; afpZdst <ref> [1] </ref> = pbodyK-&gt;afpZ [1] - pbodyL-&gt;afpZ [1]; afpZdst [2] = pbodyK-&gt;afpZ [2] - pbodyL-&gt;afpZ [2]; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR; afpX [1] = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; 190 ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpXmY [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] <p> <ref> [1] </ref> = pbodyK-&gt;afpZ [1] - pbodyL-&gt;afpZ [1]; afpZdst [2] = pbodyK-&gt;afpZ [2] - pbodyL-&gt;afpZ [2]; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR; afpX [1] = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; 190 ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpXmY [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - pgeoJ-&gt;afpX [1] <p> * pbodyK-&gt;fpR; afpX <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; 190 ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpXmY [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - pgeoJ-&gt;afpX [1] * pbodyL-&gt;fpR + afpZdst [1]; afpXmY [2] = afpX [2] - pgeoJ-&gt;afpX [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * <p> <ref> [1] </ref> = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; 190 ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpXmY [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - pgeoJ-&gt;afpX [1] * pbodyL-&gt;fpR + afpZdst [1]; afpXmY [2] = afpX [2] - pgeoJ-&gt;afpX [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR) <p> <ref> [1] </ref> * pbodyK-&gt;fpR; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; 190 ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpXmY [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - pgeoJ-&gt;afpX [1] * pbodyL-&gt;fpR + afpZdst [1]; afpXmY [2] = afpX [2] - pgeoJ-&gt;afpX [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR) - /* no <p> = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; 190 ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpXmY [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY <ref> [1] </ref> = afpX [1] - pgeoJ-&gt;afpX [1] * pbodyL-&gt;fpR + afpZdst [1]; afpXmY [2] = afpX [2] - pgeoJ-&gt;afpX [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = <p> = &pg-&gt;ageo [ulJ]; afpXmY [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY <ref> [1] </ref> = afpX [1] - pgeoJ-&gt;afpX [1] * pbodyL-&gt;fpR + afpZdst [1]; afpXmY [2] = afpX [2] - pgeoJ-&gt;afpX [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR * .5 * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY <p> + afpXmY <ref> [1] </ref>*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR * .5 * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (PI * fpRxy * fpRxy * fpRxy); - /* check if large distance */ else - /* Gaussian-Legendre Quadrature */ fpSum = 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX <p> /* check if large distance */ else - /* Gaussian-Legendre Quadrature */ fpSum = 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY <ref> [1] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY <p> else - /* Gaussian-Legendre Quadrature */ fpSum = 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY <ref> [1] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst <p> */ fpSum = 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY <ref> [1] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX <p> 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY <ref> [1] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY <p> [0] + pgeoJ-&gt;afpP2 [0]; afpY <ref> [1] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY <p> [0]; afpY <ref> [1] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN <p> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 <ref> [1] </ref> + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + <p> + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 <ref> [1] </ref> + pgeoJ-&gt;afpP2 [1]; afpY [2] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * <p> [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY <ref> [1] </ref> = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - *pfpAAA = -fpSum * .5 * pbodyL-&gt;fpR * pbodyL-&gt;fpR / PI; - /* check if large distance */ - <p> afpY <ref> [1] </ref> * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - *pfpAAA = -fpSum * .5 * pbodyL-&gt;fpR * pbodyL-&gt;fpR / PI; - /* check if large distance */ - /* loop through columns */ - /* loop through rows */ - #endif /*------------------------- CREATEBN parallel ulN particle number pfpB <p> *pfpBB; static PBODY pbodyK, pbodyL; #ifdef CONTAINER static FPTYPE fpRz, fpRy; static FPTYPE afpD [3]; #endif pbodyK = &pg-&gt;abody [ulK]; /* loop through rows */ for (ulI = 0, pfpBB = pfpB; ulI &lt; pg-&gt;ulM; ulI++, pfpBB++) - afpX [0] = pg-&gt;ageo [ulI].afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [0]; afpX <ref> [1] </ref> = pg-&gt;ageo [ulI].afpX [1] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX [2] = pg-&gt;ageo [ulI].afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; 192 fpSum = 0.; /* loop through particles */ for (ulL = 0; ulL &lt; pg-&gt;ulN; ulL++) pbodyL = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ <p> pbodyL; #ifdef CONTAINER static FPTYPE fpRz, fpRy; static FPTYPE afpD [3]; #endif pbodyK = &pg-&gt;abody [ulK]; /* loop through rows */ for (ulI = 0, pfpBB = pfpB; ulI &lt; pg-&gt;ulM; ulI++, pfpBB++) - afpX [0] = pg-&gt;ageo [ulI].afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [0]; afpX <ref> [1] </ref> = pg-&gt;ageo [ulI].afpX [1] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX [2] = pg-&gt;ageo [ulI].afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; 192 fpSum = 0.; /* loop through particles */ for (ulL = 0; ulL &lt; pg-&gt;ulN; ulL++) pbodyL = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ [1] = afpX [1] <p> fpRz, fpRy; static FPTYPE afpD [3]; #endif pbodyK = &pg-&gt;abody [ulK]; /* loop through rows */ for (ulI = 0, pfpBB = pfpB; ulI &lt; pg-&gt;ulM; ulI++, pfpBB++) - afpX [0] = pg-&gt;ageo [ulI].afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [0]; afpX <ref> [1] </ref> = pg-&gt;ageo [ulI].afpX [1] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX [2] = pg-&gt;ageo [ulI].afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; 192 fpSum = 0.; /* loop through particles */ for (ulL = 0; ulL &lt; pg-&gt;ulN; ulL++) pbodyL = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ [1] = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ [2] <p> = pg-&gt;ageo [ulI].afpX <ref> [1] </ref> * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX [2] = pg-&gt;ageo [ulI].afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; 192 fpSum = 0.; /* loop through particles */ for (ulL = 0; ulL &lt; pg-&gt;ulN; ulL++) pbodyL = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ [1] = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ [2] = afpX [2] - pbodyL-&gt;afpZ [2]; fpSum += pbodyL-&gt;fpQ / AABS (afpXmZ); #ifdef CONTAINER fpRy = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD [1] = pbodyL-&gt;afpZ [1] / fpRy; afpD [2] = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 <p> <ref> [1] </ref> * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX [2] = pg-&gt;ageo [ulI].afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; 192 fpSum = 0.; /* loop through particles */ for (ulL = 0; ulL &lt; pg-&gt;ulN; ulL++) pbodyL = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ [1] = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ [2] = afpX [2] - pbodyL-&gt;afpZ [2]; fpSum += pbodyL-&gt;fpQ / AABS (afpXmZ); #ifdef CONTAINER fpRy = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD [1] = pbodyL-&gt;afpZ [1] / fpRy; afpD [2] = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ <p> + pbodyK-&gt;afpZ <ref> [1] </ref>; afpX [2] = pg-&gt;ageo [ulI].afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; 192 fpSum = 0.; /* loop through particles */ for (ulL = 0; ulL &lt; pg-&gt;ulN; ulL++) pbodyL = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ [1] = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ [2] = afpX [2] - pbodyL-&gt;afpZ [2]; fpSum += pbodyL-&gt;fpQ / AABS (afpXmZ); #ifdef CONTAINER fpRy = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD [1] = pbodyL-&gt;afpZ [1] / fpRy; afpD [2] = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX <p> pg-&gt;ulN; ulL++) pbodyL = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ <ref> [1] </ref> = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ [2] = afpX [2] - pbodyL-&gt;afpZ [2]; fpSum += pbodyL-&gt;fpQ / AABS (afpXmZ); #ifdef CONTAINER fpRy = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD [1] = pbodyL-&gt;afpZ [1] / fpRy; afpD [2] = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX [0] - afpD [0] * fpRz; afpXmZ [1] = afpX [1] - afpD [1] * fpRz; afpXmZ [2] = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ <p> = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ <ref> [1] </ref> = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ [2] = afpX [2] - pbodyL-&gt;afpZ [2]; fpSum += pbodyL-&gt;fpQ / AABS (afpXmZ); #ifdef CONTAINER fpRy = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD [1] = pbodyL-&gt;afpZ [1] / fpRy; afpD [2] = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX [0] - afpD [0] * fpRz; afpXmZ [1] = afpX [1] - afpD [1] * fpRz; afpXmZ [2] = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ * fpRz / <p> [2]; fpSum += pbodyL-&gt;fpQ / AABS (afpXmZ); #ifdef CONTAINER fpRy = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD <ref> [1] </ref> = pbodyL-&gt;afpZ [1] / fpRy; afpD [2] = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX [0] - afpD [0] * fpRz; afpXmZ [1] = afpX [1] - afpD [1] * fpRz; afpXmZ [2] = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ * fpRz / (AABS (afpXmZ) * pg-&gt;fpR); #endif - *pfpBB = -fpSum + pg-&gt;afpE0 [0] * afpX [0] + pg-&gt;afpE0 [1] * afpX [1] + pg-&gt;afpE0 [2] * afpX <p> pbodyL-&gt;fpQ / AABS (afpXmZ); #ifdef CONTAINER fpRy = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD <ref> [1] </ref> = pbodyL-&gt;afpZ [1] / fpRy; afpD [2] = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX [0] - afpD [0] * fpRz; afpXmZ [1] = afpX [1] - afpD [1] * fpRz; afpXmZ [2] = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ * fpRz / (AABS (afpXmZ) * pg-&gt;fpR); #endif - *pfpBB = -fpSum + pg-&gt;afpE0 [0] * afpX [0] + pg-&gt;afpE0 [1] * afpX [1] + pg-&gt;afpE0 [2] * afpX [2]; - /*------------------------- <p> (afpXmZ); #ifdef CONTAINER fpRy = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD <ref> [1] </ref> = pbodyL-&gt;afpZ [1] / fpRy; afpD [2] = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX [0] - afpD [0] * fpRz; afpXmZ [1] = afpX [1] - afpD [1] * fpRz; afpXmZ [2] = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ * fpRz / (AABS (afpXmZ) * pg-&gt;fpR); #endif - *pfpBB = -fpSum + pg-&gt;afpE0 [0] * afpX [0] + pg-&gt;afpE0 [1] * afpX [1] + pg-&gt;afpE0 [2] * afpX [2]; - /*------------------------- SOLVE parallel ---------------------------*/ <p> afpX [0] - afpD [0] * fpRz; afpXmZ <ref> [1] </ref> = afpX [1] - afpD [1] * fpRz; afpXmZ [2] = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ * fpRz / (AABS (afpXmZ) * pg-&gt;fpR); #endif - *pfpBB = -fpSum + pg-&gt;afpE0 [0] * afpX [0] + pg-&gt;afpE0 [1] * afpX [1] + pg-&gt;afpE0 [2] * afpX [2]; - /*------------------------- SOLVE parallel ---------------------------*/ static void Solve () - ULONG ulI, ulII, ulJJ, ulK, ulKK, ulL; ULONG ulIter; FPTYPE fpSum; FPTYPE *afpX; FPTYPE *afpXCom; FPTYPE *afpATemp; /* non buffered temporary submatrix */ FPTYPE *pfpA; /* pointer to submatrix */ FPTYPE <p> afpD [0] * fpRz; afpXmZ <ref> [1] </ref> = afpX [1] - afpD [1] * fpRz; afpXmZ [2] = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ * fpRz / (AABS (afpXmZ) * pg-&gt;fpR); #endif - *pfpBB = -fpSum + pg-&gt;afpE0 [0] * afpX [0] + pg-&gt;afpE0 [1] * afpX [1] + pg-&gt;afpE0 [2] * afpX [2]; - /*------------------------- SOLVE parallel ---------------------------*/ static void Solve () - ULONG ulI, ulII, ulJJ, ulK, ulKK, ulL; ULONG ulIter; FPTYPE fpSum; FPTYPE *afpX; FPTYPE *afpXCom; FPTYPE *afpATemp; /* non buffered temporary submatrix */ FPTYPE *pfpA; /* pointer to submatrix */ FPTYPE *afpXBuf; FPTYPE *pfpPsi, <p> FPTYPE fpE00, fpE01, fpE02, fpE10, fpE11, fpE12; FPTYPE afpX [3]; usEndX1 = ausElement [usK][usI]; usEndX2 = ausElement [usK][usJ]; fpE00 = afpNode [usEndX1][0]; fpE01 = afpNode [usEndX1]<ref> [1] </ref>; fpE02 = afpNode [usEndX1][2]; fpE10 = afpNode [usEndX2][0]; 206 fpE11 = afpNode [usEndX2][1]; fpE12 = afpNode [usEndX2][2]; afpX [0] = fpE00 + fpE10; afpX [1] = fpE01 + fpE11; afpX [2] = fpE02 + fpE12; /* project new node onto surface */ fpNorm = sqrt (afpX [0]*afpX [0] + afpX [1]*afpX [1] + afpX [2]*afpX [2]); afpX [0] /= fpNorm; afpX [1] /= fpNorm; afpX [2] /= fpNorm; afpNode [usLastNode][0] = afpX [0]; afpNode [usLastNode][1] <p> = afpNode [usEndX1][2]; fpE10 = afpNode [usEndX2][0]; 206 fpE11 = afpNode [usEndX2]<ref> [1] </ref>; fpE12 = afpNode [usEndX2][2]; afpX [0] = fpE00 + fpE10; afpX [1] = fpE01 + fpE11; afpX [2] = fpE02 + fpE12; /* project new node onto surface */ fpNorm = sqrt (afpX [0]*afpX [0] + afpX [1]*afpX [1] + afpX [2]*afpX [2]); afpX [0] /= fpNorm; afpX [1] /= fpNorm; afpX [2] /= fpNorm; afpNode [usLastNode][0] = afpX [0]; afpNode [usLastNode][1] = afpX [1]; afpNode [usLastNode][2] = afpX [2]; ausNewNode [usI] = usLastNode; usLastNode++; - /* FUNCTION NewElements */ /*--------------------*/ static void NewElements (usK) USHORT usK; - USHORT <p> afpNode [usEndX2]<ref> [1] </ref>; fpE12 = afpNode [usEndX2][2]; afpX [0] = fpE00 + fpE10; afpX [1] = fpE01 + fpE11; afpX [2] = fpE02 + fpE12; /* project new node onto surface */ fpNorm = sqrt (afpX [0]*afpX [0] + afpX [1]*afpX [1] + afpX [2]*afpX [2]); afpX [0] /= fpNorm; afpX [1] /= fpNorm; afpX [2] /= fpNorm; afpNode [usLastNode][0] = afpX [0]; afpNode [usLastNode][1] = afpX [1]; afpNode [usLastNode][2] = afpX [2]; ausNewNode [usI] = usLastNode; usLastNode++; - /* FUNCTION NewElements */ /*--------------------*/ static void NewElements (usK) USHORT usK; - USHORT usNewNodeX1 = ausNewNode [0]; USHORT usNewNodeX2 = ausNewNode [1]; USHORT <p> + fpE11; afpX [2] = fpE02 + fpE12; /* project new node onto surface */ fpNorm = sqrt (afpX [0]*afpX [0] + afpX <ref> [1] </ref>*afpX [1] + afpX [2]*afpX [2]); afpX [0] /= fpNorm; afpX [1] /= fpNorm; afpX [2] /= fpNorm; afpNode [usLastNode][0] = afpX [0]; afpNode [usLastNode][1] = afpX [1]; afpNode [usLastNode][2] = afpX [2]; ausNewNode [usI] = usLastNode; usLastNode++; - /* FUNCTION NewElements */ /*--------------------*/ static void NewElements (usK) USHORT usK; - USHORT usNewNodeX1 = ausNewNode [0]; USHORT usNewNodeX2 = ausNewNode [1]; USHORT usNewNodeX3 = ausNewNode [2]; USHORT usOldNodeX1 = ausElement [usK][0]; USHORT usOldNodeX2 = ausElement [usK][1]; USHORT usOldNodeX3 <p> afpX <ref> [1] </ref> /= fpNorm; afpX [2] /= fpNorm; afpNode [usLastNode][0] = afpX [0]; afpNode [usLastNode][1] = afpX [1]; afpNode [usLastNode][2] = afpX [2]; ausNewNode [usI] = usLastNode; usLastNode++; - /* FUNCTION NewElements */ /*--------------------*/ static void NewElements (usK) USHORT usK; - USHORT usNewNodeX1 = ausNewNode [0]; USHORT usNewNodeX2 = ausNewNode [1]; USHORT usNewNodeX3 = ausNewNode [2]; USHORT usOldNodeX1 = ausElement [usK][0]; USHORT usOldNodeX2 = ausElement [usK][1]; USHORT usOldNodeX3 = ausElement [usK][2]; AddElement (usOldNodeX1, usNewNodeX1, usNewNodeX3); AddElement (usOldNodeX2, usNewNodeX1, usNewNodeX2); AddElement (usOldNodeX3, usNewNodeX2, usNewNodeX3); RenameElement (usK, usNewNodeX1, usNewNodeX2, usNewNodeX3); - /* FUNCTION AddElement */ /*--------------------*/ static void AddElement (usI, usJ, usK) USHORT <p> PGEO pgeo; - USHORT usNode1 = ausElement [usK][0]; USHORT usNode2 = ausElement [usK]<ref> [1] </ref>; USHORT usNode3 = ausElement [usK][2]; FPTYPE afpP1 [3], afpP2 [3], afpP3 [3]; FPTYPE afpU1 [3], afpU2 [3]; FPTYPE afpX [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 [1] = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 <p> USHORT usNode1 = ausElement [usK][0]; USHORT usNode2 = ausElement [usK]<ref> [1] </ref>; USHORT usNode3 = ausElement [usK][2]; FPTYPE afpP1 [3], afpP2 [3], afpP3 [3]; FPTYPE afpU1 [3], afpU2 [3]; FPTYPE afpX [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 [1] = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode <p> [3]; FPTYPE afpU1 [3], afpU2 [3]; FPTYPE afpX [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 <ref> [1] </ref> = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 <p> [3], afpU2 [3]; FPTYPE afpX [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 <ref> [1] </ref> = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 <p> [usNode1][0]; pgeo-&gt;afpP1 <ref> [1] </ref> = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - <p> = afpP1 <ref> [1] </ref> = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 <p> [usNode2]<ref> [1] </ref>; pgeo-&gt;afpP2 [2] = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 <p> = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 <ref> [1] </ref> = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 <p> = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 <ref> [1] </ref> = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid <p> pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 <ref> [1] </ref> = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] <p> /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 <ref> [1] </ref> = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 <p> edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 <ref> [1] </ref> = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 <p> [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 <ref> [1] </ref> = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; <p> [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 <ref> [1] </ref> = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = <p> [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 <ref> [1] </ref> = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 <p> [0] - afpP2 [0]; pgeo-&gt;afpU2 <ref> [1] </ref> = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 <p> [0]; pgeo-&gt;afpU2 <ref> [1] </ref> = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN <p> = afpU2 <ref> [1] </ref> = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 <p> = afpP3 <ref> [1] </ref> - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - <p> afpP3 [0]) / 3.; pgeo-&gt;afpX <ref> [1] </ref> = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN [1]*afpN [1] + afpN [2]*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN <p> / 3.; pgeo-&gt;afpX <ref> [1] </ref> = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN [1]*afpN [1] + afpN [2]*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= <p> afpP3 <ref> [1] </ref>) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN [1]*afpN [1] + afpN [2]*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX [2]*afpN [2]; <p> afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 <ref> [1] </ref>*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN [1]*afpN [1] + afpN [2]*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX [2]*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN <p> - afpU1 [2]*afpU2 <ref> [1] </ref>; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN [1]*afpN [1] + afpN [2]*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX [2]*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN [2] = -afpN [2]; - else - pgeo-&gt;afpN [0] = afpN [0]; pgeo-&gt;afpN [1] = <p> [2] = afpU1 [0]*afpU2 <ref> [1] </ref> - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN [1]*afpN [1] + afpN [2]*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX [2]*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN [2] = -afpN [2]; - else - pgeo-&gt;afpN [0] = afpN [0]; pgeo-&gt;afpN [1] = afpN [1]; pgeo-&gt;afpN [2] = afpN [2]; - B.5.3 C Header File my.h /*--------------------*/ /*--------------------*/ <p> [0] + afpN <ref> [1] </ref>*afpN [1] + afpN [2]*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX [2]*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN [2] = -afpN [2]; - else - pgeo-&gt;afpN [0] = afpN [0]; pgeo-&gt;afpN [1] = afpN [1]; pgeo-&gt;afpN [2] = afpN [2]; - B.5.3 C Header File my.h /*--------------------*/ /*--------------------*/ /* C header file with */ /* general definitions */ /*--------------------*/ #ifdef SINGLEPREC # define FPTYPE <p> <ref> [1] </ref>*afpN [1] + afpN [2]*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX [2]*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN [2] = -afpN [2]; - else - pgeo-&gt;afpN [0] = afpN [0]; pgeo-&gt;afpN [1] = afpN [1]; pgeo-&gt;afpN [2] = afpN [2]; - B.5.3 C Header File my.h /*--------------------*/ /*--------------------*/ /* C header file with */ /* general definitions */ /*--------------------*/ #ifdef SINGLEPREC # define FPTYPE float # define <p> afpN <ref> [1] </ref> /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX [2]*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN [2] = -afpN [2]; - else - pgeo-&gt;afpN [0] = afpN [0]; pgeo-&gt;afpN [1] = afpN [1]; pgeo-&gt;afpN [2] = afpN [2]; - B.5.3 C Header File my.h /*--------------------*/ /*--------------------*/ /* C header file with */ /* general definitions */ /*--------------------*/ #ifdef SINGLEPREC # define FPTYPE float # define FPMASK "%f" #else # define FPTYPE double # define FPMASK "%lf" #endif 209 #define USHORT <p> fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX <ref> [1] </ref>*afpN [1] + afpX [2]*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN [2] = -afpN [2]; - else - pgeo-&gt;afpN [0] = afpN [0]; pgeo-&gt;afpN [1] = afpN [1]; pgeo-&gt;afpN [2] = afpN [2]; - B.5.3 C Header File my.h /*--------------------*/ /*--------------------*/ /* C header file with */ /* general definitions */ /*--------------------*/ #ifdef SINGLEPREC # define FPTYPE float # define FPMASK "%f" #else # define FPTYPE double # define FPMASK "%lf" #endif 209 #define USHORT unsigned short #define <p> INT long #define BOOL unsigned short #define PI 3.14159265358979323844 #ifndef RAND_MAX # define RAND_MAX 2147483648 #endif #define max (a,b) ( ((a)&gt;(b)) ? (a) : (b) ) #define min (a,b) ( ((a)&lt;(b)) ? (a) : (b) ) #define SQR (x) ((x)*(x)) #define AABS (x) sqrt (SQR (x [0]) + SQR (x <ref> [1] </ref>) + SQR (x [2])) #define DELTA (i,j) (((i) == (j)) ? 1.0 : 0.0) #define FILENAM_SIZE 80 #define STRING_SIZE 80 #ifndef WWT # ifndef XX_NUM_NODES # define XX_NUM_NODES 1 # endif # ifndef G_MALLOC # define G_MALLOC (ulSize) malloc (ulSize); # endif #endif B.5.4 C Header File geometry.h /*-----------------------*/ /*
Reference: [2] <author> N. Amann and S. Kim. </author> <title> Parallel Computational Microhydrodynamics: Scalable Load-Balancing Strategies. Engineering Analysis with Boundary Elements, </title> <booktitle> 11 </booktitle> <pages> 269-276, </pages> <year> 1993. </year>
Reference-contexts: # define VTSTOP (ulVTSym); ; #endif #ifdef WWT # define PRINT_ADDRESS (sz, p) " fprintf (pFileStd, "%20s %12u %12u"n", sz, p, (ULONG)p % (ULONG)BLOCK_SIZE); #endif #ifdef CONTAINER # define CONTAINER_1 " fpRy = AABS (afpY);" afpD [0] = afpY [0] / fpRy;" afpD [1] = afpY [1] / fpRy;" afpD <ref> [2] </ref> = afpY [2] / fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ [1] = afpD [1] * fpRz;" afpZ [2] = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX [1] - afpZ [1];" afpXmZ [2] = <p> (ulVTSym); ; #endif #ifdef WWT # define PRINT_ADDRESS (sz, p) " fprintf (pFileStd, "%20s %12u %12u"n", sz, p, (ULONG)p % (ULONG)BLOCK_SIZE); #endif #ifdef CONTAINER # define CONTAINER_1 " fpRy = AABS (afpY);" afpD [0] = afpY [0] / fpRy;" afpD [1] = afpY [1] / fpRy;" afpD <ref> [2] </ref> = afpY [2] / fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ [1] = afpD [1] * fpRz;" afpZ [2] = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX [1] - afpZ [1];" afpXmZ [2] = afpX [2] - <p> CONTAINER # define CONTAINER_1 " fpRy = AABS (afpY);" afpD [0] = afpY [0] / fpRy;" afpD [1] = afpY [1] / fpRy;" afpD <ref> [2] </ref> = afpY [2] / fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ [1] = afpD [1] * fpRz;" afpZ [2] = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX [1] - afpZ [1];" afpXmZ [2] = afpX [2] - afpZ [2];" fpRxz = AABS (afpXmZ);" for (ulII = 0; ulII &lt; 3; ulII++)" -" afpSum1 [ulII] = 0.;" for (ulJJ = 0; <p> CONTAINER_1 " fpRy = AABS (afpY);" afpD [0] = afpY [0] / fpRy;" afpD [1] = afpY [1] / fpRy;" afpD <ref> [2] </ref> = afpY [2] / fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ [1] = afpD [1] * fpRz;" afpZ [2] = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX [1] - afpZ [1];" afpXmZ [2] = afpX [2] - afpZ [2];" fpRxz = AABS (afpXmZ);" for (ulII = 0; ulII &lt; 3; ulII++)" -" afpSum1 [ulII] = 0.;" for (ulJJ = 0; ulJJ &lt; 3; <p> afpD <ref> [2] </ref> = afpY [2] / fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ [1] = afpD [1] * fpRz;" afpZ [2] = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX [1] - afpZ [1];" afpXmZ [2] = afpX [2] - afpZ [2];" fpRxz = AABS (afpXmZ);" for (ulII = 0; ulII &lt; 3; ulII++)" -" afpSum1 [ulII] = 0.;" for (ulJJ = 0; ulJJ &lt; 3; ulJJ++)" 160 afpSum1 [ulII] += (DELTA (ulII, ulJJ) - 2. * afpD [ulII] *" afpD [ulJJ]) * afpXmZ [ulJJ];" -" <p> afpY <ref> [2] </ref> / fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ [1] = afpD [1] * fpRz;" afpZ [2] = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX [1] - afpZ [1];" afpXmZ [2] = afpX [2] - afpZ [2];" fpRxz = AABS (afpXmZ);" for (ulII = 0; ulII &lt; 3; ulII++)" -" afpSum1 [ulII] = 0.;" for (ulJJ = 0; ulJJ &lt; 3; ulJJ++)" 160 afpSum1 [ulII] += (DELTA (ulII, ulJJ) - 2. * afpD [ulII] *" afpD [ulJJ]) * afpXmZ [ulJJ];" -" #define CONTAINER_2 " <p> fpRy;" fpRz = pg-&gt;fpR2 / fpRy;" afpZ [0] = afpD [0] * fpRz;" afpZ [1] = afpD [1] * fpRz;" afpZ <ref> [2] </ref> = afpD [2] * fpRz;" afpXmZ [0] = afpX [0] - afpZ [0];" afpXmZ [1] = afpX [1] - afpZ [1];" afpXmZ [2] = afpX [2] - afpZ [2];" fpRxz = AABS (afpXmZ);" for (ulII = 0; ulII &lt; 3; ulII++)" -" afpSum1 [ulII] = 0.;" for (ulJJ = 0; ulJJ &lt; 3; ulJJ++)" 160 afpSum1 [ulII] += (DELTA (ulII, ulJJ) - 2. * afpD [ulII] *" afpD [ulJJ]) * afpXmZ [ulJJ];" -" #define CONTAINER_2 " ((pgeoJ-&gt;afpN [0]*afpXmY [0] <p> 0; ulII &lt; 3; ulII++)" -" afpSum1 [ulII] = 0.;" for (ulJJ = 0; ulJJ &lt; 3; ulJJ++)" 160 afpSum1 [ulII] += (DELTA (ulII, ulJJ) - 2. * afpD [ulII] *" afpD [ulJJ]) * afpXmZ [ulJJ];" -" #define CONTAINER_2 " ((pgeoJ-&gt;afpN [0]*afpXmY [0] +" pgeoJ-&gt;afpN [1]*afpXmY [1] +" pgeoJ-&gt;afpN <ref> [2] </ref>*afpXmY [2]) /" (fpRxy * fpRxy * fpRxy) +" (-fpRz *" (pgeoJ-&gt;afpN [0] * afpSum1 [0] +" pgeoJ-&gt;afpN [1] * afpSum1 [1] +" pgeoJ-&gt;afpN [2] * afpSum1 [2]) /" SQR (fpRxz) +" pgeoJ-&gt;afpN [0] * afpD [0] +" pgeoJ-&gt;afpN [1] * afpD [1] +" pgeoJ-&gt;afpN [2] * afpD [2]) *" SQR (fpRz) <p> (ulII, ulJJ) - 2. * afpD [ulII] *" afpD [ulJJ]) * afpXmZ [ulJJ];" -" #define CONTAINER_2 " ((pgeoJ-&gt;afpN [0]*afpXmY [0] +" pgeoJ-&gt;afpN [1]*afpXmY [1] +" pgeoJ-&gt;afpN <ref> [2] </ref>*afpXmY [2]) /" (fpRxy * fpRxy * fpRxy) +" (-fpRz *" (pgeoJ-&gt;afpN [0] * afpSum1 [0] +" pgeoJ-&gt;afpN [1] * afpSum1 [1] +" pgeoJ-&gt;afpN [2] * afpSum1 [2]) /" SQR (fpRxz) +" pgeoJ-&gt;afpN [0] * afpD [0] +" pgeoJ-&gt;afpN [1] * afpD [1] +" pgeoJ-&gt;afpN [2] * afpD [2]) *" SQR (fpRz) / (fpRxz * pg-&gt;fpR3)); #endif #ifdef WWT /*-------------------- Initialize WWT Environment ---------------------*/ #endif /*-------------------- INCLUDEs ---------------------*/ #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include <p> 2. * afpD [ulII] *" afpD [ulJJ]) * afpXmZ [ulJJ];" -" #define CONTAINER_2 " ((pgeoJ-&gt;afpN [0]*afpXmY [0] +" pgeoJ-&gt;afpN [1]*afpXmY [1] +" pgeoJ-&gt;afpN <ref> [2] </ref>*afpXmY [2]) /" (fpRxy * fpRxy * fpRxy) +" (-fpRz *" (pgeoJ-&gt;afpN [0] * afpSum1 [0] +" pgeoJ-&gt;afpN [1] * afpSum1 [1] +" pgeoJ-&gt;afpN [2] * afpSum1 [2]) /" SQR (fpRxz) +" pgeoJ-&gt;afpN [0] * afpD [0] +" pgeoJ-&gt;afpN [1] * afpD [1] +" pgeoJ-&gt;afpN [2] * afpD [2]) *" SQR (fpRz) / (fpRxz * pg-&gt;fpR3)); #endif #ifdef WWT /*-------------------- Initialize WWT Environment ---------------------*/ #endif /*-------------------- INCLUDEs ---------------------*/ #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;string.h&gt; #include &lt;assert.h&gt; <p> pgeoJ-&gt;afpN [1]*afpXmY [1] +" pgeoJ-&gt;afpN <ref> [2] </ref>*afpXmY [2]) /" (fpRxy * fpRxy * fpRxy) +" (-fpRz *" (pgeoJ-&gt;afpN [0] * afpSum1 [0] +" pgeoJ-&gt;afpN [1] * afpSum1 [1] +" pgeoJ-&gt;afpN [2] * afpSum1 [2]) /" SQR (fpRxz) +" pgeoJ-&gt;afpN [0] * afpD [0] +" pgeoJ-&gt;afpN [1] * afpD [1] +" pgeoJ-&gt;afpN [2] * afpD [2]) *" SQR (fpRz) / (fpRxz * pg-&gt;fpR3)); #endif #ifdef WWT /*-------------------- Initialize WWT Environment ---------------------*/ #endif /*-------------------- INCLUDEs ---------------------*/ #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;string.h&gt; #include &lt;assert.h&gt; #ifdef WWT #include &lt;align.h&gt; #endif #include "my.h" #include "geometry.h" /*-------------------- TYPEDEFs ---------------------*/ /* body data */ typedef struct <p> +" pgeoJ-&gt;afpN <ref> [2] </ref>*afpXmY [2]) /" (fpRxy * fpRxy * fpRxy) +" (-fpRz *" (pgeoJ-&gt;afpN [0] * afpSum1 [0] +" pgeoJ-&gt;afpN [1] * afpSum1 [1] +" pgeoJ-&gt;afpN [2] * afpSum1 [2]) /" SQR (fpRxz) +" pgeoJ-&gt;afpN [0] * afpD [0] +" pgeoJ-&gt;afpN [1] * afpD [1] +" pgeoJ-&gt;afpN [2] * afpD [2]) *" SQR (fpRz) / (fpRxz * pg-&gt;fpR3)); #endif #ifdef WWT /*-------------------- Initialize WWT Environment ---------------------*/ #endif /*-------------------- INCLUDEs ---------------------*/ #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;string.h&gt; #include &lt;assert.h&gt; #ifdef WWT #include &lt;align.h&gt; #endif #include "my.h" #include "geometry.h" /*-------------------- TYPEDEFs ---------------------*/ /* body data */ typedef struct _BODY - ULONG <p> - /* read input file for geometrical data */ pFileGeo = fopen (szFileGeo, "r"); assert (pFileGeo != NULL); fscanf (pFileGeo, "%u", &ulN); 170 /* check if geo file is consistent to num file */ assert (pg-&gt;ulN == ulN); #ifdef SINGLEPREC fscanf (pFileGeo, "%f %f %f", &pg-&gt;afpE0 [0], &pg-&gt;afpE0 [1], &pg-&gt;afpE0 <ref> [2] </ref>); #else fscanf (pFileGeo, "%lf %lf %lf", &pg-&gt;afpE0 [0], &pg-&gt;afpE0 [1], &pg-&gt;afpE0 [2]); #endif for (ulI = 0; ulI &lt; pg-&gt;ulN; ulI++) #ifdef SINGLEPREC fscanf (pFileGeo, "%f %f %f %f %f", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], &pg-&gt;abody [ulI].fpR, &pg-&gt;abody [ulI].fpQ); #else fscanf (pFileGeo, "%lf %lf %lf %lf <p> (szFileGeo, "r"); assert (pFileGeo != NULL); fscanf (pFileGeo, "%u", &ulN); 170 /* check if geo file is consistent to num file */ assert (pg-&gt;ulN == ulN); #ifdef SINGLEPREC fscanf (pFileGeo, "%f %f %f", &pg-&gt;afpE0 [0], &pg-&gt;afpE0 [1], &pg-&gt;afpE0 <ref> [2] </ref>); #else fscanf (pFileGeo, "%lf %lf %lf", &pg-&gt;afpE0 [0], &pg-&gt;afpE0 [1], &pg-&gt;afpE0 [2]); #endif for (ulI = 0; ulI &lt; pg-&gt;ulN; ulI++) #ifdef SINGLEPREC fscanf (pFileGeo, "%f %f %f %f %f", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], &pg-&gt;abody [ulI].fpR, &pg-&gt;abody [ulI].fpQ); #else fscanf (pFileGeo, "%lf %lf %lf %lf %lf", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], &pg-&gt;abody [ulI].fpR, <p> SINGLEPREC fscanf (pFileGeo, "%f %f %f", &pg-&gt;afpE0 [0], &pg-&gt;afpE0 [1], &pg-&gt;afpE0 <ref> [2] </ref>); #else fscanf (pFileGeo, "%lf %lf %lf", &pg-&gt;afpE0 [0], &pg-&gt;afpE0 [1], &pg-&gt;afpE0 [2]); #endif for (ulI = 0; ulI &lt; pg-&gt;ulN; ulI++) #ifdef SINGLEPREC fscanf (pFileGeo, "%f %f %f %f %f", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], &pg-&gt;abody [ulI].fpR, &pg-&gt;abody [ulI].fpQ); #else fscanf (pFileGeo, "%lf %lf %lf %lf %lf", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], &pg-&gt;abody [ulI].fpR, &pg-&gt;abody [ulI].fpQ); #endif pg-&gt;abody [ulI].ulNumber = ulI; - #ifdef CONTAINER # ifdef SINGLEPREC fscanf (pFileGeo, "%f", &pg-&gt;fpR); # else fscanf (pFileGeo, "%lf", &pg-&gt;fpR); # endif /* its <p> [1], &pg-&gt;afpE0 <ref> [2] </ref>); #endif for (ulI = 0; ulI &lt; pg-&gt;ulN; ulI++) #ifdef SINGLEPREC fscanf (pFileGeo, "%f %f %f %f %f", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], &pg-&gt;abody [ulI].fpR, &pg-&gt;abody [ulI].fpQ); #else fscanf (pFileGeo, "%lf %lf %lf %lf %lf", &pg-&gt;abody [ulI].afpZ [0], &pg-&gt;abody [ulI].afpZ [1], &pg-&gt;abody [ulI].afpZ [2], &pg-&gt;abody [ulI].fpR, &pg-&gt;abody [ulI].fpQ); #endif pg-&gt;abody [ulI].ulNumber = ulI; - #ifdef CONTAINER # ifdef SINGLEPREC fscanf (pFileGeo, "%f", &pg-&gt;fpR); # else fscanf (pFileGeo, "%lf", &pg-&gt;fpR); # endif /* its square, cube */ pg-&gt;fpR2 = SQR (pg-&gt;fpR); #endif fclose (pFileGeo); #ifdef WWT PRINT_ADDRESS ("usQuadN", &pg-&gt;usQuadN); PRINT_ADDRESS ("afpQuadX", &pg-&gt;afpQuadX); PRINT_ADDRESS ("afpQuadW", &pg-&gt;afpQuadW); <p> [ulI]); pg-&gt;fpGeoA += pg-&gt;ageo [ulI].fpDA; - /*-------------------- ADJUSTGEOMETRY ---------------------*/ static void AdjustGeometry () - ULONG ulI; FPTYPE fpRadiusPolyInv; 172 PGEO pgeo; fpRadiusPolyInv = sqrt ((4. * PI) / pg-&gt;fpGeoA); for (ulI = 0; ulI &lt; pg-&gt;ulM; ulI++) pgeo = &pg-&gt;ageo [ulI]; pgeo-&gt;afpP1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP1 <ref> [2] </ref> *= fpRadiusPolyInv; pgeo-&gt;afpP2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [2] *= fpRadiusPolyInv; <p> () - ULONG ulI; FPTYPE fpRadiusPolyInv; 172 PGEO pgeo; fpRadiusPolyInv = sqrt ((4. * PI) / pg-&gt;fpGeoA); for (ulI = 0; ulI &lt; pg-&gt;ulM; ulI++) pgeo = &pg-&gt;ageo [ulI]; pgeo-&gt;afpP1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP1 <ref> [2] </ref> *= fpRadiusPolyInv; pgeo-&gt;afpP2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpX [0] *= fpRadiusPolyInv; pgeo-&gt;afpX [1] *= fpRadiusPolyInv; pgeo-&gt;afpX [2] *= fpRadiusPolyInv; <p> ((4. * PI) / pg-&gt;fpGeoA); for (ulI = 0; ulI &lt; pg-&gt;ulM; ulI++) pgeo = &pg-&gt;ageo [ulI]; pgeo-&gt;afpP1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP1 <ref> [2] </ref> *= fpRadiusPolyInv; pgeo-&gt;afpP2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpX [0] *= fpRadiusPolyInv; pgeo-&gt;afpX [1] *= fpRadiusPolyInv; pgeo-&gt;afpX [2] *= fpRadiusPolyInv; pgeo-&gt;fpDA *= fpRadiusPolyInv * fpRadiusPolyInv; pgeo-&gt;fpJacob *= fpRadiusPolyInv * fpRadiusPolyInv; - pg-&gt;fpGeoA <p> ulI++) pgeo = &pg-&gt;ageo [ulI]; pgeo-&gt;afpP1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP1 <ref> [2] </ref> *= fpRadiusPolyInv; pgeo-&gt;afpP2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpX [0] *= fpRadiusPolyInv; pgeo-&gt;afpX [1] *= fpRadiusPolyInv; pgeo-&gt;afpX [2] *= fpRadiusPolyInv; pgeo-&gt;fpDA *= fpRadiusPolyInv * fpRadiusPolyInv; pgeo-&gt;fpJacob *= fpRadiusPolyInv * fpRadiusPolyInv; - pg-&gt;fpGeoA *= fpRadiusPolyInv * fpRadiusPolyInv; - LOADBALANCE ---------------------------*/ static void LoadBalance () - <p> fpRadiusPolyInv; pgeo-&gt;afpP1 <ref> [2] </ref> *= fpRadiusPolyInv; pgeo-&gt;afpP2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpX [0] *= fpRadiusPolyInv; pgeo-&gt;afpX [1] *= fpRadiusPolyInv; pgeo-&gt;afpX [2] *= fpRadiusPolyInv; pgeo-&gt;fpDA *= fpRadiusPolyInv * fpRadiusPolyInv; pgeo-&gt;fpJacob *= fpRadiusPolyInv * fpRadiusPolyInv; - pg-&gt;fpGeoA *= fpRadiusPolyInv * fpRadiusPolyInv; - LOADBALANCE ---------------------------*/ static void LoadBalance () - ULONG ulI, ulJ, ulK; ULONG ulP; ULONG *aulCrit; ULONG *aulCritSum; ULONG *aulN; <p> fpRadiusPolyInv; pgeo-&gt;afpP2 <ref> [2] </ref> *= fpRadiusPolyInv; pgeo-&gt;afpP3 [0] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [1] *= fpRadiusPolyInv; pgeo-&gt;afpP3 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU1 [2] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [0] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [1] *= fpRadiusPolyInv; pgeo-&gt;afpU2 [2] *= fpRadiusPolyInv; pgeo-&gt;afpX [0] *= fpRadiusPolyInv; pgeo-&gt;afpX [1] *= fpRadiusPolyInv; pgeo-&gt;afpX [2] *= fpRadiusPolyInv; pgeo-&gt;fpDA *= fpRadiusPolyInv * fpRadiusPolyInv; pgeo-&gt;fpJacob *= fpRadiusPolyInv * fpRadiusPolyInv; - pg-&gt;fpGeoA *= fpRadiusPolyInv * fpRadiusPolyInv; - LOADBALANCE ---------------------------*/ static void LoadBalance () - ULONG ulI, ulJ, ulK; ULONG ulP; ULONG *aulCrit; ULONG *aulCritSum; ULONG *aulN; ULONG *aulPrio; ULONG ulCritMax; ULONG ulIMax; ULONG ulCritSumMin; ULONG ulPMin; BODY bodyTemp; <p> endif #else fprintf (pFileOut, "# cico=0 "); #endif #ifdef LOCK_ fprintf (pFileOut, "lock=1"); 176 #else fprintf (pFileOut, "lock=0"); #endif fprintf (pFileOut, ""n"); #ifdef CONTAINER fprintf (pFileOut, "# Container R = %21.12g"n", pg-&gt;fpR); #else fprintf (pFileOut, "# No Container"n"); #endif fprintf (pFileOut, "# E0 = (%21.12g,%21.12g,%21.12g)"n#"n", pg-&gt;afpE0 [0], pg-&gt;afpE0 [1], pg-&gt;afpE0 <ref> [2] </ref>); fprintf (pFileOut, "# In Files = %s"n", szFileIn); fprintf (pFileOut, "# In Quad = %s"n", szFileQuad); fprintf (pFileOut, "# In Num = %s"n", szFileNum); fprintf (pFileOut, "# In Geo = %s"n", szFileGeo); fprintf (pFileOut, "# In Sol = %s"n", szFileInSol); fprintf (pFileOut, "# Out Psi = %s"n", szFileOutPsi); fprintf (pFileOut, <p> pg-&gt;ulIterN; ulIter++) - fprintf (pFileOutPsi, "--- Iteration %3hu ---"n", ulIter + 1); fprintf (pFileOutPsi, "Sphere Q X Y Z R Psi"n"); for (ulK = 0; ulK &lt; pg-&gt;ulN; ulK++) fprintf (pFileOutPsi, "%4lu %7.3g %7.3g %7.3g %7.3g %7.3g %21.12g"n", pg-&gt;abody [ulK].ulNumber, pg-&gt;abody [ulK].fpQ, pg-&gt;abody [ulK].afpZ [0], pg-&gt;abody [ulK].afpZ [1], pg-&gt;abody [ulK].afpZ <ref> [2] </ref>, pg-&gt;abody [ulK].fpR, *pfpPsi); pfpPsi++; - fprintf (pFileOutPsi, ""n"); 177 OutputInfo (pFileOutPsi); /* close output file */ fclose (pFileOutPsi); - OUTPUTSOL ---------------------------*/ static void OutputSol () - FILE *pFileOutSol; ULONG ulK, ulL; ULONG ulI; pFileOutSol = fopen (szFileOutSol, "w"); /* output x on every element */ for (ulK = 0; ulK <p> .5 * fpNR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpX [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpX <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; <p> / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpX [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpX <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = <p> rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpX [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpX <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + <p> pgeoI-&gt;afpX <ref> [2] </ref> * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + 184 afpXmY [2]*afpXmY [2]; /* check if large <p> pbodyN-&gt;fpR + pbodyN-&gt;afpZ <ref> [2] </ref>; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + 184 afpXmY [2]*afpXmY [2]; /* check if large distance */ if <p> loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + 184 afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA <p> = &pg-&gt;ageo [ulJ]; afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + 184 afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpNR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 *pfpAAA = -pgeoJ-&gt;fpDA / pg-&gt;fpGeoA <p> afpY [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + 184 afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpNR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 *pfpAAA = -pgeoJ-&gt;fpDA / pg-&gt;fpGeoA - fpS1 * <p> pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + 184 afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpNR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 *pfpAAA = -pgeoJ-&gt;fpDA / pg-&gt;fpGeoA - fpS1 * pgeoJ-&gt;fpDA * CONTAINER_2 <p> + pbodyN-&gt;afpZ [1]; afpY <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + 184 afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpNR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 *pfpAAA = -pgeoJ-&gt;fpDA / pg-&gt;fpGeoA - fpS1 * pgeoJ-&gt;fpDA * CONTAINER_2 - /* check if large distance */ else - /* Gaussian-Legendre Quadrature */ fpSum <p> = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += <p> - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob <p> [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = <p> [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -pgeoJ-&gt;fpDA / pg-&gt;fpGeoA <p> [0] + pgeoJ-&gt;afpP2 [0]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpY [1] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -pgeoJ-&gt;fpDA / pg-&gt;fpGeoA - fpSum * fpS1; - <p> *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -pgeoJ-&gt;fpDA / pg-&gt;fpGeoA - fpSum * fpS1; - /* check if large distance */ - /* loop through columns */ - /* loop through rows */ <p> [1] + pgeoJ-&gt;afpP2 [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -pgeoJ-&gt;fpDA / pg-&gt;fpGeoA - fpSum * fpS1; - /* check if large distance */ - /* loop through columns */ - /* loop through rows */ - CREATEAKL parallel <p> [1]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -pgeoJ-&gt;fpDA / pg-&gt;fpGeoA - fpSum * fpS1; - /* check if large distance */ - /* loop through columns */ - /* loop through rows */ - CREATEAKL parallel ulK particle number <p> .5 * fpLR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [0]; afpX [1] = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ <p> / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [0]; afpX [1] = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] <p> rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [0]; afpX [1] = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR <p> <ref> [2] </ref> * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance <p> + pbodyK-&gt;afpZ <ref> [2] </ref>; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY [2] = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 <p> through columns */ for (ulJ = 0, pfpAAA = pfpAA; ulJ &lt; pg-&gt;ulM; ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * <p> &pg-&gt;ageo [ulJ]; 186 afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpLR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 *pfpAAA = -fpS1 * pgeoJ-&gt;fpDA * <p> afpY [0] = pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpLR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 *pfpAAA = -fpS1 * pgeoJ-&gt;fpDA * CONTAINER_2 - /* <p> pgeoI-&gt;afpX [0] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = pgeoI-&gt;afpX [1] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpLR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 *pfpAAA = -fpS1 * pgeoJ-&gt;fpDA * CONTAINER_2 - /* check if large <p> pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY <ref> [2] </ref> = pgeoI-&gt;afpX [2] * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpLR2) - /* 1-point Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); CONTAINER_1 *pfpAAA = -fpS1 * pgeoJ-&gt;fpDA * CONTAINER_2 - /* check if large distance */ else - /* Gaussian-Legendre Quadrature */ fpSum = 0.; for (usIXs <p> = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += <p> - afpY [0] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob <p> [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = <p> [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -fpSum * fpS1; <p> [0] + pgeoJ-&gt;afpP2 [0]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [0]; afpY [1] = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -fpSum * fpS1; - /* check if large <p> *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -fpSum * fpS1; - /* check if large distance */ 187 - /* loop through columns */ - /* loop through rows */ - #else /*------------------------- <p> [1] + pgeoJ-&gt;afpP2 [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -fpSum * fpS1; - /* check if large distance */ 187 - /* loop through columns */ - /* loop through rows */ - #else /*------------------------- CREATEANN parallel ulN <p> [1]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [1]; afpY <ref> [2] </ref> = (pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]) * pbodyL-&gt;fpR + pbodyL-&gt;afpZ [2]; afpXmY [0] = afpX [0] - afpY [0]; afpXmY [1] = afpX [1] - afpY [1]; afpXmY [2] = afpX [2] - afpY [2]; fpRxy = AABS (afpXmY); CONTAINER_1 fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * CONTAINER_2 - *pfpAAA = -fpSum * fpS1; - /* check if large distance */ 187 - /* loop through columns */ - /* loop through rows */ - #else /*------------------------- CREATEANN parallel ulN particle number pfpA <p> - pgeoJ = &pg-&gt;ageo [ulJ]; /* check if diagonal element */ if (ulJ == ulI) *pfpAAA = -pgeoI-&gt;fpDA / pg-&gt;fpGeoA; - /* check if diagonal element */ else - afpXmY [0] = (pgeoI-&gt;afpX [0] - pgeoJ-&gt;afpX [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - pgeoJ-&gt;afpX [1]) * 188 afpXmY <ref> [2] </ref> = (pgeoI-&gt;afpX [2] - pgeoJ-&gt;afpX [2]) * fpR; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpR * fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA <p> &pg-&gt;ageo [ulJ]; /* check if diagonal element */ if (ulJ == ulI) *pfpAAA = -pgeoI-&gt;fpDA / pg-&gt;fpGeoA; - /* check if diagonal element */ else - afpXmY [0] = (pgeoI-&gt;afpX [0] - pgeoJ-&gt;afpX [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - pgeoJ-&gt;afpX [1]) * 188 afpXmY <ref> [2] </ref> = (pgeoI-&gt;afpX [2] - pgeoJ-&gt;afpX [2]) * fpR; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpR * fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA * fpR * <p> check if diagonal element */ if (ulJ == ulI) *pfpAAA = -pgeoI-&gt;fpDA / pg-&gt;fpGeoA; - /* check if diagonal element */ else - afpXmY [0] = (pgeoI-&gt;afpX [0] - pgeoJ-&gt;afpX [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - pgeoJ-&gt;afpX [1]) * 188 afpXmY <ref> [2] </ref> = (pgeoI-&gt;afpX [2] - pgeoJ-&gt;afpX [2]) * fpR; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpR * fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA * fpR * fpR * .5 <p> /* check if diagonal element */ else - afpXmY [0] = (pgeoI-&gt;afpX [0] - pgeoJ-&gt;afpX [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - pgeoJ-&gt;afpX [1]) * 188 afpXmY <ref> [2] </ref> = (pgeoI-&gt;afpX [2] - pgeoJ-&gt;afpX [2]) * fpR; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpR * fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA * fpR * fpR * .5 * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (PI * <p> + afpXmY <ref> [2] </ref>*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * fpR * fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA * fpR * fpR * .5 * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (PI * fpRxy * fpRxy * fpRxy) - pgeoJ-&gt;fpDA / pg-&gt;fpGeoA; - /* check if large distance */ else - /* Gaussian-Legendre Quadrature */ fpSum = 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX <p> (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY [1] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] <p> usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY [1] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY <p> 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY [1] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW <p> pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY [1] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) <p> pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - 189 <p> pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - 189 *pfpAAA = -fpSum <p> *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - 189 *pfpAAA = -fpSum * .5 * <p> *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 <ref> [2] </ref> + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = (pgeoI-&gt;afpX [0] - afpY [0]) * fpR; afpXmY [1] = (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY [2] = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - 189 *pfpAAA = -fpSum * .5 * fpR * fpR / PI - pgeoJ-&gt;fpDA / pg-&gt;fpGeoA; - /* check if large distance */ <p> (pgeoI-&gt;afpX [1] - afpY [1]) * fpR; afpXmY <ref> [2] </ref> = (pgeoI-&gt;afpX [2] - afpY [2]) * fpR; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - 189 *pfpAAA = -fpSum * .5 * fpR * fpR / PI - pgeoJ-&gt;fpDA / pg-&gt;fpGeoA; - /* check if large distance */ - /* check if diagonal element */ - /* loop through columns */ - /* loop through rows */ - <p> FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static FPTYPE afpZdst [3]; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; /* distance between particle centers */ afpZdst [0] = pbodyK-&gt;afpZ [0] - pbodyL-&gt;afpZ [0]; afpZdst [1] = pbodyK-&gt;afpZ [1] - pbodyL-&gt;afpZ [1]; afpZdst <ref> [2] </ref> = pbodyK-&gt;afpZ [2] - pbodyL-&gt;afpZ [2]; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR; afpX [1] = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR; afpX [2] = pgeoI-&gt;afpX [2] * <p> static FPTYPE *pfpAA, *pfpAAA; static FPTYPE afpZdst [3]; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; /* distance between particle centers */ afpZdst [0] = pbodyK-&gt;afpZ [0] - pbodyL-&gt;afpZ [0]; afpZdst [1] = pbodyK-&gt;afpZ [1] - pbodyL-&gt;afpZ [1]; afpZdst <ref> [2] </ref> = pbodyK-&gt;afpZ [2] - pbodyL-&gt;afpZ [2]; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR; afpX [1] = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR; /* loop <p> *pfpAAA; static FPTYPE afpZdst [3]; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; /* distance between particle centers */ afpZdst [0] = pbodyK-&gt;afpZ [0] - pbodyL-&gt;afpZ [0]; afpZdst [1] = pbodyK-&gt;afpZ [1] - pbodyL-&gt;afpZ [1]; afpZdst <ref> [2] </ref> = pbodyK-&gt;afpZ [2] - pbodyL-&gt;afpZ [2]; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR; afpX [1] = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR; /* loop through columns */ <p> - pbodyL-&gt;afpZ [1]; afpZdst <ref> [2] </ref> = pbodyK-&gt;afpZ [2] - pbodyL-&gt;afpZ [2]; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR; afpX [1] = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; 190 ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpXmY [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - pgeoJ-&gt;afpX [1] * pbodyL-&gt;fpR + afpZdst <p> afpZdst <ref> [2] </ref> = pbodyK-&gt;afpZ [2] - pbodyL-&gt;afpZ [2]; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR; afpX [1] = pgeoI-&gt;afpX [1] * pbodyK-&gt;fpR; afpX [2] = pgeoI-&gt;afpX [2] * pbodyK-&gt;fpR; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; 190 ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpXmY [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - pgeoJ-&gt;afpX [1] * pbodyL-&gt;fpR + afpZdst [1]; afpXmY [2] <p> <ref> [2] </ref> * pbodyK-&gt;fpR; /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; 190 ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpXmY [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - pgeoJ-&gt;afpX [1] * pbodyL-&gt;fpR + afpZdst [1]; afpXmY [2] = afpX [2] - pgeoJ-&gt;afpX [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); <p> /* loop through columns */ for (ulJ = 0, pfpAAA = pfpAA; 190 ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpXmY [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - pgeoJ-&gt;afpX [1] * pbodyL-&gt;fpR + afpZdst [1]; afpXmY <ref> [2] </ref> = afpX [2] - pgeoJ-&gt;afpX [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA <p> columns */ for (ulJ = 0, pfpAAA = pfpAA; 190 ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpXmY [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - pgeoJ-&gt;afpX [1] * pbodyL-&gt;fpR + afpZdst [1]; afpXmY <ref> [2] </ref> = afpX [2] - pgeoJ-&gt;afpX [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * <p> 0, pfpAAA = pfpAA; 190 ulJ++, pfpAAA++) - pgeoJ = &pg-&gt;ageo [ulJ]; afpXmY [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - pgeoJ-&gt;afpX [1] * pbodyL-&gt;fpR + afpZdst [1]; afpXmY <ref> [2] </ref> = afpX [2] - pgeoJ-&gt;afpX [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR * .5 * (pgeoJ-&gt;afpN <p> [0] = afpX [0] - pgeoJ-&gt;afpX [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - pgeoJ-&gt;afpX [1] * pbodyL-&gt;fpR + afpZdst [1]; afpXmY <ref> [2] </ref> = afpX [2] - pgeoJ-&gt;afpX [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy2 = afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR * .5 * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (PI * <p> + afpXmY <ref> [2] </ref>*afpXmY [2]; /* check if large distance */ if (fpRxy2 &gt; 18. * pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR) - /* no Gaussian-Legendre Quadrature */ fpRxy = sqrt (fpRxy2); *pfpAAA = -pgeoJ-&gt;fpDA * pbodyL-&gt;fpR * pbodyL-&gt;fpR * .5 * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (PI * fpRxy * fpRxy * fpRxy); - /* check if large distance */ else - /* Gaussian-Legendre Quadrature */ fpSum = 0.; for (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] <p> (usIXs = 0; usIXs &lt; pg-&gt;usQuadN; usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY [1] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * <p> usIXs++) - for (usIXt = 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY [1] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = <p> 0; usIXt &lt; pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY [1] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + <p> pg-&gt;usQuadN; usIXt++) - afpY [0] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [0] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [0] + pgeoJ-&gt;afpP2 [0]; afpY [1] = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [1] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] <p> * pgeoJ-&gt;afpU2 [1] + pgeoJ-&gt;afpP2 [1]; afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * <p> + pgeoJ-&gt;afpP2 [1]; afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - *pfpAAA <p> afpY <ref> [2] </ref> = pg-&gt;afpQuadX [usIXs] * pgeoJ-&gt;afpU1 [2] + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - *pfpAAA = -fpSum * <p> * pgeoJ-&gt;afpU1 <ref> [2] </ref> + *(pg-&gt;afpQuadXt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;afpU2 [2] + pgeoJ-&gt;afpP2 [2]; afpXmY [0] = afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY [2] = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - *pfpAAA = -fpSum * .5 * pbodyL-&gt;fpR * pbodyL-&gt;fpR <p> afpX [0] - afpY [0] * pbodyL-&gt;fpR + afpZdst [0]; afpXmY [1] = afpX [1] - afpY [1] * pbodyL-&gt;fpR + 191 afpZdst [1]; afpXmY <ref> [2] </ref> = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - *pfpAAA = -fpSum * .5 * pbodyL-&gt;fpR * pbodyL-&gt;fpR / PI; - /* check if large distance */ - /* loop through columns <p> + 191 afpZdst [1]; afpXmY <ref> [2] </ref> = afpX [2] - afpY [2] * pbodyL-&gt;fpR + afpZdst [2]; fpRxy = sqrt (afpXmY [0]*afpXmY [0] + afpXmY [1]*afpXmY [1] + afpXmY [2]*afpXmY [2]); fpSum += pg-&gt;afpQuadW [usIXs] * *(pg-&gt;afpQuadWt+usIXs*pg-&gt;usQuadN+usIXt) * pgeoJ-&gt;fpJacob * (pgeoJ-&gt;afpN [0]*afpXmY [0] + pgeoJ-&gt;afpN [1]*afpXmY [1] + pgeoJ-&gt;afpN [2]*afpXmY [2]) / (fpRxy * fpRxy * fpRxy); - *pfpAAA = -fpSum * .5 * pbodyL-&gt;fpR * pbodyL-&gt;fpR / PI; - /* check if large distance */ - /* loop through columns */ - /* loop through rows */ - #endif /*------------------------- CREATEBN parallel ulN particle number pfpB position of subvector ---------------------------*/ <p> static FPTYPE afpD [3]; #endif pbodyK = &pg-&gt;abody [ulK]; /* loop through rows */ for (ulI = 0, pfpBB = pfpB; ulI &lt; pg-&gt;ulM; ulI++, pfpBB++) - afpX [0] = pg-&gt;ageo [ulI].afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [0]; afpX [1] = pg-&gt;ageo [ulI].afpX [1] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX <ref> [2] </ref> = pg-&gt;ageo [ulI].afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; 192 fpSum = 0.; /* loop through particles */ for (ulL = 0; ulL &lt; pg-&gt;ulN; ulL++) pbodyL = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ [1] = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ [2] = afpX <p> #endif pbodyK = &pg-&gt;abody [ulK]; /* loop through rows */ for (ulI = 0, pfpBB = pfpB; ulI &lt; pg-&gt;ulM; ulI++, pfpBB++) - afpX [0] = pg-&gt;ageo [ulI].afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [0]; afpX [1] = pg-&gt;ageo [ulI].afpX [1] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX <ref> [2] </ref> = pg-&gt;ageo [ulI].afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; 192 fpSum = 0.; /* loop through particles */ for (ulL = 0; ulL &lt; pg-&gt;ulN; ulL++) pbodyL = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ [1] = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ [2] = afpX [2] - pbodyL-&gt;afpZ [2]; <p> /* loop through rows */ for (ulI = 0, pfpBB = pfpB; ulI &lt; pg-&gt;ulM; ulI++, pfpBB++) - afpX [0] = pg-&gt;ageo [ulI].afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [0]; afpX [1] = pg-&gt;ageo [ulI].afpX [1] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX <ref> [2] </ref> = pg-&gt;ageo [ulI].afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; 192 fpSum = 0.; /* loop through particles */ for (ulL = 0; ulL &lt; pg-&gt;ulN; ulL++) pbodyL = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ [1] = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ [2] = afpX [2] - pbodyL-&gt;afpZ [2]; fpSum += pbodyL-&gt;fpQ / AABS <p> [1]; afpX <ref> [2] </ref> = pg-&gt;ageo [ulI].afpX [2] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; 192 fpSum = 0.; /* loop through particles */ for (ulL = 0; ulL &lt; pg-&gt;ulN; ulL++) pbodyL = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ [1] = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ [2] = afpX [2] - pbodyL-&gt;afpZ [2]; fpSum += pbodyL-&gt;fpQ / AABS (afpXmZ); #ifdef CONTAINER fpRy = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD [1] = pbodyL-&gt;afpZ [1] / fpRy; afpD [2] = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX [0] - <p> = pg-&gt;ageo [ulI].afpX <ref> [2] </ref> * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; 192 fpSum = 0.; /* loop through particles */ for (ulL = 0; ulL &lt; pg-&gt;ulN; ulL++) pbodyL = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ [1] = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ [2] = afpX [2] - pbodyL-&gt;afpZ [2]; fpSum += pbodyL-&gt;fpQ / AABS (afpXmZ); #ifdef CONTAINER fpRy = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD [1] = pbodyL-&gt;afpZ [1] / fpRy; afpD [2] = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX [0] - afpD [0] * <p> <ref> [2] </ref> * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [2]; 192 fpSum = 0.; /* loop through particles */ for (ulL = 0; ulL &lt; pg-&gt;ulN; ulL++) pbodyL = &pg-&gt;abody [ulL]; afpXmZ [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ [1] = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ [2] = afpX [2] - pbodyL-&gt;afpZ [2]; fpSum += pbodyL-&gt;fpQ / AABS (afpXmZ); #ifdef CONTAINER fpRy = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD [1] = pbodyL-&gt;afpZ [1] / fpRy; afpD [2] = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX [0] - afpD [0] * fpRz; afpXmZ [1] <p> [0] = afpX [0] - pbodyL-&gt;afpZ [0]; afpXmZ [1] = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ <ref> [2] </ref> = afpX [2] - pbodyL-&gt;afpZ [2]; fpSum += pbodyL-&gt;fpQ / AABS (afpXmZ); #ifdef CONTAINER fpRy = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD [1] = pbodyL-&gt;afpZ [1] / fpRy; afpD [2] = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX [0] - afpD [0] * fpRz; afpXmZ [1] = afpX [1] - afpD [1] * fpRz; afpXmZ [2] = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ * fpRz / (AABS (afpXmZ) * pg-&gt;fpR); <p> [0] - pbodyL-&gt;afpZ [0]; afpXmZ [1] = afpX [1] - pbodyL-&gt;afpZ [1]; afpXmZ <ref> [2] </ref> = afpX [2] - pbodyL-&gt;afpZ [2]; fpSum += pbodyL-&gt;fpQ / AABS (afpXmZ); #ifdef CONTAINER fpRy = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD [1] = pbodyL-&gt;afpZ [1] / fpRy; afpD [2] = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX [0] - afpD [0] * fpRz; afpXmZ [1] = afpX [1] - afpD [1] * fpRz; afpXmZ [2] = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ * fpRz / (AABS (afpXmZ) * pg-&gt;fpR); #endif - *pfpBB <p> = AABS (pbodyL-&gt;afpZ); afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD [1] = pbodyL-&gt;afpZ [1] / fpRy; afpD <ref> [2] </ref> = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX [0] - afpD [0] * fpRz; afpXmZ [1] = afpX [1] - afpD [1] * fpRz; afpXmZ [2] = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ * fpRz / (AABS (afpXmZ) * pg-&gt;fpR); #endif - *pfpBB = -fpSum + pg-&gt;afpE0 [0] * afpX [0] + pg-&gt;afpE0 [1] * afpX [1] + pg-&gt;afpE0 [2] * afpX [2]; - /*------------------------- SOLVE parallel ---------------------------*/ static void Solve () <p> afpD [0] = pbodyL-&gt;afpZ [0] / fpRy; afpD [1] = pbodyL-&gt;afpZ [1] / fpRy; afpD <ref> [2] </ref> = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX [0] - afpD [0] * fpRz; afpXmZ [1] = afpX [1] - afpD [1] * fpRz; afpXmZ [2] = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ * fpRz / (AABS (afpXmZ) * pg-&gt;fpR); #endif - *pfpBB = -fpSum + pg-&gt;afpE0 [0] * afpX [0] + pg-&gt;afpE0 [1] * afpX [1] + pg-&gt;afpE0 [2] * afpX [2]; - /*------------------------- SOLVE parallel ---------------------------*/ static void Solve () - ULONG ulI, <p> pbodyL-&gt;afpZ [0] / fpRy; afpD [1] = pbodyL-&gt;afpZ [1] / fpRy; afpD <ref> [2] </ref> = pbodyL-&gt;afpZ [2] / fpRy; fpRz = pg-&gt;fpR2 / fpRy; afpXmZ [0] = afpX [0] - afpD [0] * fpRz; afpXmZ [1] = afpX [1] - afpD [1] * fpRz; afpXmZ [2] = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ * fpRz / (AABS (afpXmZ) * pg-&gt;fpR); #endif - *pfpBB = -fpSum + pg-&gt;afpE0 [0] * afpX [0] + pg-&gt;afpE0 [1] * afpX [1] + pg-&gt;afpE0 [2] * afpX [2]; - /*------------------------- SOLVE parallel ---------------------------*/ static void Solve () - ULONG ulI, ulII, ulJJ, ulK, <p> fpRz; afpXmZ [1] = afpX [1] - afpD [1] * fpRz; afpXmZ <ref> [2] </ref> = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ * fpRz / (AABS (afpXmZ) * pg-&gt;fpR); #endif - *pfpBB = -fpSum + pg-&gt;afpE0 [0] * afpX [0] + pg-&gt;afpE0 [1] * afpX [1] + pg-&gt;afpE0 [2] * afpX [2]; - /*------------------------- SOLVE parallel ---------------------------*/ static void Solve () - ULONG ulI, ulII, ulJJ, ulK, ulKK, ulL; ULONG ulIter; FPTYPE fpSum; FPTYPE *afpX; FPTYPE *afpXCom; FPTYPE *afpATemp; /* non buffered temporary submatrix */ FPTYPE *pfpA; /* pointer to submatrix */ FPTYPE *afpXBuf; FPTYPE *pfpPsi, *pfpPsi1; FPTYPE *pfpXBuf, <p> = afpX [1] - afpD [1] * fpRz; afpXmZ <ref> [2] </ref> = afpX [2] - afpD [2] * fpRz; fpSum -= pbodyL-&gt;fpQ * fpRz / (AABS (afpXmZ) * pg-&gt;fpR); #endif - *pfpBB = -fpSum + pg-&gt;afpE0 [0] * afpX [0] + pg-&gt;afpE0 [1] * afpX [1] + pg-&gt;afpE0 [2] * afpX [2]; - /*------------------------- SOLVE parallel ---------------------------*/ static void Solve () - ULONG ulI, ulII, ulJJ, ulK, ulKK, ulL; ULONG ulIter; FPTYPE fpSum; FPTYPE *afpX; FPTYPE *afpXCom; FPTYPE *afpATemp; /* non buffered temporary submatrix */ FPTYPE *pfpA; /* pointer to submatrix */ FPTYPE *afpXBuf; FPTYPE *pfpPsi, *pfpPsi1; FPTYPE *pfpXBuf, *pfpXBuf1; FPTYPE *afpXErr; <p> fpE12; FPTYPE afpX [3]; usEndX1 = ausElement [usK][usI]; usEndX2 = ausElement [usK][usJ]; fpE00 = afpNode [usEndX1][0]; fpE01 = afpNode [usEndX1][1]; fpE02 = afpNode [usEndX1]<ref> [2] </ref>; fpE10 = afpNode [usEndX2][0]; 206 fpE11 = afpNode [usEndX2][1]; fpE12 = afpNode [usEndX2][2]; afpX [0] = fpE00 + fpE10; afpX [1] = fpE01 + fpE11; afpX [2] = fpE02 + fpE12; /* project new node onto surface */ fpNorm = sqrt (afpX [0]*afpX [0] + afpX [1]*afpX [1] + afpX [2]*afpX [2]); afpX [0] /= fpNorm; afpX [1] /= fpNorm; afpX [2] /= fpNorm; afpNode [usLastNode][0] = afpX [0]; afpNode [usLastNode][1] = afpX [1]; afpNode [usLastNode][2] = <p> = afpNode [usEndX2][0]; 206 fpE11 = afpNode [usEndX2][1]; fpE12 = afpNode [usEndX2]<ref> [2] </ref>; afpX [0] = fpE00 + fpE10; afpX [1] = fpE01 + fpE11; afpX [2] = fpE02 + fpE12; /* project new node onto surface */ fpNorm = sqrt (afpX [0]*afpX [0] + afpX [1]*afpX [1] + afpX [2]*afpX [2]); afpX [0] /= fpNorm; afpX [1] /= fpNorm; afpX [2] /= fpNorm; afpNode [usLastNode][0] = afpX [0]; afpNode [usLastNode][1] = afpX [1]; afpNode [usLastNode][2] = afpX [2]; ausNewNode [usI] = usLastNode; usLastNode++; - /* FUNCTION NewElements */ /*--------------------*/ static void NewElements (usK) USHORT usK; - USHORT usNewNodeX1 = ausNewNode [0]; <p> afpNode [usEndX2]<ref> [2] </ref>; afpX [0] = fpE00 + fpE10; afpX [1] = fpE01 + fpE11; afpX [2] = fpE02 + fpE12; /* project new node onto surface */ fpNorm = sqrt (afpX [0]*afpX [0] + afpX [1]*afpX [1] + afpX [2]*afpX [2]); afpX [0] /= fpNorm; afpX [1] /= fpNorm; afpX [2] /= fpNorm; afpNode [usLastNode][0] = afpX [0]; afpNode [usLastNode][1] = afpX [1]; afpNode [usLastNode][2] = afpX [2]; ausNewNode [usI] = usLastNode; usLastNode++; - /* FUNCTION NewElements */ /*--------------------*/ static void NewElements (usK) USHORT usK; - USHORT usNewNodeX1 = ausNewNode [0]; USHORT usNewNodeX2 = ausNewNode [1]; USHORT usNewNodeX3 = ausNewNode [2]; <p> fpE02 + fpE12; /* project new node onto surface */ fpNorm = sqrt (afpX [0]*afpX [0] + afpX [1]*afpX [1] + afpX <ref> [2] </ref>*afpX [2]); afpX [0] /= fpNorm; afpX [1] /= fpNorm; afpX [2] /= fpNorm; afpNode [usLastNode][0] = afpX [0]; afpNode [usLastNode][1] = afpX [1]; afpNode [usLastNode][2] = afpX [2]; ausNewNode [usI] = usLastNode; usLastNode++; - /* FUNCTION NewElements */ /*--------------------*/ static void NewElements (usK) USHORT usK; - USHORT usNewNodeX1 = ausNewNode [0]; USHORT usNewNodeX2 = ausNewNode [1]; USHORT usNewNodeX3 = ausNewNode [2]; USHORT usOldNodeX1 = ausElement [usK][0]; USHORT usOldNodeX2 = ausElement [usK][1]; USHORT usOldNodeX3 = ausElement [usK][2]; AddElement (usOldNodeX1, <p> <ref> [2] </ref> /= fpNorm; afpNode [usLastNode][0] = afpX [0]; afpNode [usLastNode][1] = afpX [1]; afpNode [usLastNode][2] = afpX [2]; ausNewNode [usI] = usLastNode; usLastNode++; - /* FUNCTION NewElements */ /*--------------------*/ static void NewElements (usK) USHORT usK; - USHORT usNewNodeX1 = ausNewNode [0]; USHORT usNewNodeX2 = ausNewNode [1]; USHORT usNewNodeX3 = ausNewNode [2]; USHORT usOldNodeX1 = ausElement [usK][0]; USHORT usOldNodeX2 = ausElement [usK][1]; USHORT usOldNodeX3 = ausElement [usK][2]; AddElement (usOldNodeX1, usNewNodeX1, usNewNodeX3); AddElement (usOldNodeX2, usNewNodeX1, usNewNodeX2); AddElement (usOldNodeX3, usNewNodeX2, usNewNodeX3); RenameElement (usK, usNewNodeX1, usNewNodeX2, usNewNodeX3); - /* FUNCTION AddElement */ /*--------------------*/ static void AddElement (usI, usJ, usK) USHORT usI; USHORT usJ; USHORT usK; <p> USHORT usNode2 = ausElement [usK][1]; USHORT usNode3 = ausElement [usK]<ref> [2] </ref>; FPTYPE afpP1 [3], afpP2 [3], afpP3 [3]; FPTYPE afpU1 [3], afpU2 [3]; FPTYPE afpX [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 [1] = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 <p> ausElement [usK][1]; USHORT usNode3 = ausElement [usK]<ref> [2] </ref>; FPTYPE afpP1 [3], afpP2 [3], afpP3 [3]; FPTYPE afpU1 [3], afpU2 [3]; FPTYPE afpX [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 [1] = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 [2] = afpNode <p> [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 [1] = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 <ref> [2] </ref> = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 <p> [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 [1] = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 <ref> [2] </ref> = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 <p> [usNode1][1]; pgeo-&gt;afpP1 <ref> [2] </ref> = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = <p> = afpP1 <ref> [2] </ref> = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] = afpP2 [2] = afpNode [usNode2][2]; pgeo-&gt;afpP3 [0] = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 [2] = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - <p> = afpP3 [0] = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 <ref> [2] </ref> = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX <p> = afpNode [usNode3][0]; pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 <ref> [2] </ref> = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 <p> pgeo-&gt;afpP3 [1] = afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 <ref> [2] </ref> = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 <p> afpP3 [1] = afpNode [usNode3][1]; pgeo-&gt;afpP3 <ref> [2] </ref> = afpP3 [2] = afpNode [usNode3][2]; /* vectors of edges */ pgeo-&gt;afpU1 [0] = afpU1 [0] = afpP1 [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 [2] = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 <p> [0] - afpP2 [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 <ref> [2] </ref> = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = <p> [0]; pgeo-&gt;afpU1 [1] = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 <ref> [2] </ref> = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + <p> = afpU1 [1] = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 <ref> [2] </ref> = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + <p> = afpP1 [1] - afpP2 [1]; pgeo-&gt;afpU1 <ref> [2] </ref> = afpU1 [2] = afpP1 [2] - afpP2 [2]; pgeo-&gt;afpU2 [0] = afpU2 [0] = afpP3 [0] - afpP2 [0]; pgeo-&gt;afpU2 [1] = afpU2 [1] = afpP3 [1] - afpP2 [1]; 208 pgeo-&gt;afpU2 [2] = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / <p> afpP2 [1]; 208 pgeo-&gt;afpU2 <ref> [2] </ref> = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob <p> pgeo-&gt;afpU2 <ref> [2] </ref> = afpU2 [2] = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = <p> afpU2 <ref> [2] </ref> = afpP3 [2] - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN <p> afpP3 <ref> [2] </ref> - afpP2 [2]; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN <p> afpP2 <ref> [2] </ref>; /* centroid */ pgeo-&gt;afpX [0] = afpX [0] = (afpP1 [0] + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX [2] = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN [1]*afpN [1] + <p> + afpP2 [0] + afpP3 [0]) / 3.; pgeo-&gt;afpX [1] = afpX [1] = (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX <ref> [2] </ref> = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN [1]*afpN [1] + afpN [2]*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN <p> (afpP1 [1] + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX <ref> [2] </ref> = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN [1]*afpN [1] + afpN [2]*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX <p> + afpP2 [1] + afpP3 [1]) / 3.; pgeo-&gt;afpX <ref> [2] </ref> = afpX [2] = (afpP1 [2] + afpP2 [2] + afpP3 [2]) / 3.; /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 [2] - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN [1]*afpN [1] + afpN [2]*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] <p> /* jacobian, area, normal */ afpN [0] = afpU1 [1]*afpU2 <ref> [2] </ref> - afpU1 [2]*afpU2 [1]; afpN [1] = afpU1 [2]*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN [1]*afpN [1] + afpN [2]*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX [2]*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN [2] = -afpN [2]; <p> afpN [1] = afpU1 <ref> [2] </ref>*afpU2 [0] - afpU1 [0]*afpU2 [2]; afpN [2] = afpU1 [0]*afpU2 [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN [1]*afpN [1] + afpN [2]*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX [2]*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN [2] = -afpN [2]; - else - pgeo-&gt;afpN [0] = afpN [0]; pgeo-&gt;afpN [1] = afpN [1]; pgeo-&gt;afpN [2] <p> [1] - afpU1 [1]*afpU2 [0]; pgeo-&gt;fpJacob = fpNorm = sqrt (afpN [0]*afpN [0] + afpN [1]*afpN [1] + afpN <ref> [2] </ref>*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX [2]*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN [2] = -afpN [2]; - else - pgeo-&gt;afpN [0] = afpN [0]; pgeo-&gt;afpN [1] = afpN [1]; pgeo-&gt;afpN [2] = afpN [2]; - B.5.3 C Header File my.h /*--------------------*/ /*--------------------*/ /* C header file <p> + afpN <ref> [2] </ref>*afpN [2]); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX [2]*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN [2] = -afpN [2]; - else - pgeo-&gt;afpN [0] = afpN [0]; pgeo-&gt;afpN [1] = afpN [1]; pgeo-&gt;afpN [2] = afpN [2]; - B.5.3 C Header File my.h /*--------------------*/ /*--------------------*/ /* C header file with */ /* general definitions */ /*--------------------*/ #ifdef SINGLEPREC # define FPTYPE float # define FPMASK "%f" <p> <ref> [2] </ref>); pgeo-&gt;fpDA = fpNorm * .5; afpN [0] /= fpNorm; afpN [1] /= fpNorm; afpN [2] /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX [2]*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN [2] = -afpN [2]; - else - pgeo-&gt;afpN [0] = afpN [0]; pgeo-&gt;afpN [1] = afpN [1]; pgeo-&gt;afpN [2] = afpN [2]; - B.5.3 C Header File my.h /*--------------------*/ /*--------------------*/ /* C header file with */ /* general definitions */ /*--------------------*/ #ifdef SINGLEPREC # define FPTYPE float # define FPMASK "%f" #else # define <p> <ref> [2] </ref> /= fpNorm; fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX [2]*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN [2] = -afpN [2]; - else - pgeo-&gt;afpN [0] = afpN [0]; pgeo-&gt;afpN [1] = afpN [1]; pgeo-&gt;afpN [2] = afpN [2]; - B.5.3 C Header File my.h /*--------------------*/ /*--------------------*/ /* C header file with */ /* general definitions */ /*--------------------*/ #ifdef SINGLEPREC # define FPTYPE float # define FPMASK "%f" #else # define FPTYPE double # define FPMASK "%lf" #endif 209 #define USHORT unsigned short #define SHORT short <p> fpDot = afpX [0]*afpN [0] + afpX [1]*afpN [1] + afpX <ref> [2] </ref>*afpN [2]; if (fpDot &lt; 0.) - pgeo-&gt;afpN [0] = -afpN [0]; pgeo-&gt;afpN [1] = -afpN [1]; pgeo-&gt;afpN [2] = -afpN [2]; - else - pgeo-&gt;afpN [0] = afpN [0]; pgeo-&gt;afpN [1] = afpN [1]; pgeo-&gt;afpN [2] = afpN [2]; - B.5.3 C Header File my.h /*--------------------*/ /*--------------------*/ /* C header file with */ /* general definitions */ /*--------------------*/ #ifdef SINGLEPREC # define FPTYPE float # define FPMASK "%f" #else # define FPTYPE double # define FPMASK "%lf" #endif 209 #define USHORT unsigned short #define SHORT short #define ULONG unsigned <p> unsigned short #define PI 3.14159265358979323844 #ifndef RAND_MAX # define RAND_MAX 2147483648 #endif #define max (a,b) ( ((a)&gt;(b)) ? (a) : (b) ) #define min (a,b) ( ((a)&lt;(b)) ? (a) : (b) ) #define SQR (x) ((x)*(x)) #define AABS (x) sqrt (SQR (x [0]) + SQR (x [1]) + SQR (x <ref> [2] </ref>)) #define DELTA (i,j) (((i) == (j)) ? 1.0 : 0.0) #define FILENAM_SIZE 80 #define STRING_SIZE 80 #ifndef WWT # ifndef XX_NUM_NODES # define XX_NUM_NODES 1 # endif # ifndef G_MALLOC # define G_MALLOC (ulSize) malloc (ulSize); # endif #endif B.5.4 C Header File geometry.h /*-----------------------*/ /* geometry.h */ /*-----------------------*/ /*
Reference: [3] <author> G.M. </author> <title> Amdahl. Validity of the Single-Processor Approach to Achieving Large Scale Computing Capabilities. </title> <booktitle> AFIPS Conference Proceedings, </booktitle> <pages> pages 483-485, </pages> <month> April </month> <year> 1967. </year>
Reference-contexts: The main difficulty is that, in general, programs have sections that are inherently sequential, such as input or output subroutines. Those sections become bottlenecks in the highly parallelized version of the program. This is known as Amdahl's law <ref> [3] </ref> and can be quantified as follows: if a program consists of two sections, one that is inherently sequential and the other that is fully parallelizable, and if the sequential section consumes a fraction f of the total execution time, the attainable speedup is bounded by: S p (N ) f <p> #endif #ifdef WWT /*-------------------- Initialize WWT Environment ---------------------*/ #endif /*-------------------- INCLUDEs ---------------------*/ #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;string.h&gt; #include &lt;assert.h&gt; #ifdef WWT #include &lt;align.h&gt; #endif #include "my.h" #include "geometry.h" /*-------------------- TYPEDEFs ---------------------*/ /* body data */ typedef struct _BODY - ULONG ulNumber; /* original number */ FPTYPE afpZ <ref> [3] </ref>; /* center */ FPTYPE fpR; /* radius */ 161 FPTYPE fpQ; /* charge */ BODY, *PBODY; #ifdef WWT /* lock declaration */ typedef LOCKDEC (XLOCK) #endif /* global data space */ typedef struct _GLOBAL - /* --- R/O data during calculation --- */ /* Gaussian-Legendre Quadrature */ USHORT usQuadN; FPTYPE <p> /* Gaussian-Legendre Quadrature */ USHORT usQuadN; FPTYPE *afpQuadX; FPTYPE *afpQuadW; FPTYPE *afpQuadXt; FPTYPE *afpQuadWt; /* Stored Element Data */ PGEO ageo; FPTYPE fpGeoA; #ifdef CONTAINER /* radius of spherical container */ FPTYPE fpR; /* its square, cube */ FPTYPE fpR2; FPTYPE fpR3; #endif /* Superimposed Electric Field */ FPTYPE afpE0 <ref> [3] </ref>; /* Geometrical Data of Particles */ PBODY abody; /* --- elements in iteration */ /* numbers */ ULONG ulN; ULONG ulM; ULONG ulNM; ULONG ulNP; ULONG ulNMP; ULONG ulNBuf; /* output mode */ USHORT fOutMode; /* flag word for output modes 0 0 0 0 (bit mask) | | | <p> (ulK, &afpB [ulKK * pg-&gt;ulM]); - #ifdef CONTAINER /*------------------------- CREATEANN parallel ulN particle number pfpA position of submatrix ulIncr increment from row to row ---------------------------*/ static void CreateAnn (ulN, pfpA, ulIncr) 183 ULONG ulN; FPTYPE *pfpA; ULONG ulIncr; - static ULONG ulI, ulJ; static USHORT usIXs, usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyN; static FPTYPE fpS1; static FPTYPE fpNR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static FPTYPE <p> number pfpA position of submatrix ulIncr increment from row to row ---------------------------*/ static void CreateAnn (ulN, pfpA, ulIncr) 183 ULONG ulN; FPTYPE *pfpA; ULONG ulIncr; - static ULONG ulI, ulJ; static USHORT usIXs, usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyN; static FPTYPE fpS1; static FPTYPE fpNR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static FPTYPE afpZ [3]; static FPTYPE afpXmZ [3]; static FPTYPE fpRxz; static FPTYPE afpSum1 [3]; <p> submatrix ulIncr increment from row to row ---------------------------*/ static void CreateAnn (ulN, pfpA, ulIncr) 183 ULONG ulN; FPTYPE *pfpA; ULONG ulIncr; - static ULONG ulI, ulJ; static USHORT usIXs, usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyN; static FPTYPE fpS1; static FPTYPE fpNR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static FPTYPE afpZ [3]; static FPTYPE afpXmZ [3]; static FPTYPE fpRxz; static FPTYPE afpSum1 [3]; pbodyN = &pg-&gt;abody [ulN]; <p> usIXs, usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyN; static FPTYPE fpS1; static FPTYPE fpNR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static FPTYPE afpZ [3]; static FPTYPE afpXmZ [3]; static FPTYPE fpRxz; static FPTYPE afpSum1 [3]; pbodyN = &pg-&gt;abody [ulN]; fpNR2 = SQR (pbodyN-&gt;fpR); fpS1 = .5 * fpNR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA <p> FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX <ref> [3] </ref>; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyN; static FPTYPE fpS1; static FPTYPE fpNR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static FPTYPE afpZ [3]; static FPTYPE afpXmZ [3]; static FPTYPE fpRxz; static FPTYPE afpSum1 [3]; pbodyN = &pg-&gt;abody [ulN]; fpNR2 = SQR (pbodyN-&gt;fpR); fpS1 = .5 * fpNR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; <p> fpRxy; static FPTYPE fpSum; static FPTYPE afpX <ref> [3] </ref>; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyN; static FPTYPE fpS1; static FPTYPE fpNR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static FPTYPE afpZ [3]; static FPTYPE afpXmZ [3]; static FPTYPE fpRxz; static FPTYPE afpSum1 [3]; pbodyN = &pg-&gt;abody [ulN]; fpNR2 = SQR (pbodyN-&gt;fpR); fpS1 = .5 * fpNR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX <p> <ref> [3] </ref>; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyN; static FPTYPE fpS1; static FPTYPE fpNR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static FPTYPE afpZ [3]; static FPTYPE afpXmZ [3]; static FPTYPE fpRxz; static FPTYPE afpSum1 [3]; pbodyN = &pg-&gt;abody [ulN]; fpNR2 = SQR (pbodyN-&gt;fpR); fpS1 = .5 * fpNR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyN-&gt;fpR + pbodyN-&gt;afpZ [0]; afpX <p> - CREATEAKL parallel ulK particle number (x) 185 ulL particle number (y) pfpA position of submatrix ulIncr increment from row to row ---------------------------*/ static void CreateAkl (ulK, ulL, pfpA, ulIncr) ULONG ulK; ULONG ulL; FPTYPE *pfpA; ULONG ulIncr; - static ULONG ulI, ulJ; static USHORT usIXs, usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; static FPTYPE fpS1; static FPTYPE fpLR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static <p> position of submatrix ulIncr increment from row to row ---------------------------*/ static void CreateAkl (ulK, ulL, pfpA, ulIncr) ULONG ulK; ULONG ulL; FPTYPE *pfpA; ULONG ulIncr; - static ULONG ulI, ulJ; static USHORT usIXs, usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; static FPTYPE fpS1; static FPTYPE fpLR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static FPTYPE afpZ [3]; static FPTYPE afpXmZ [3]; static FPTYPE fpRxz; static FPTYPE afpSum1 <p> increment from row to row ---------------------------*/ static void CreateAkl (ulK, ulL, pfpA, ulIncr) ULONG ulK; ULONG ulL; FPTYPE *pfpA; ULONG ulIncr; - static ULONG ulI, ulJ; static USHORT usIXs, usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; static FPTYPE fpS1; static FPTYPE fpLR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static FPTYPE afpZ [3]; static FPTYPE afpXmZ [3]; static FPTYPE fpRxz; static FPTYPE afpSum1 [3]; pbodyK = &pg-&gt;abody <p> usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; static FPTYPE fpS1; static FPTYPE fpLR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static FPTYPE afpZ [3]; static FPTYPE afpXmZ [3]; static FPTYPE fpRxz; static FPTYPE afpSum1 [3]; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; fpLR2 = SQR (pbodyL-&gt;fpR); fpS1 = .5 * fpLR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI <p> fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX <ref> [3] </ref>; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; static FPTYPE fpS1; static FPTYPE fpLR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static FPTYPE afpZ [3]; static FPTYPE afpXmZ [3]; static FPTYPE fpRxz; static FPTYPE afpSum1 [3]; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; fpLR2 = SQR (pbodyL-&gt;fpR); fpS1 = .5 * fpLR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - <p> static FPTYPE fpSum; static FPTYPE afpX <ref> [3] </ref>; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; static FPTYPE fpS1; static FPTYPE fpLR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static FPTYPE afpZ [3]; static FPTYPE afpXmZ [3]; static FPTYPE fpRxz; static FPTYPE afpSum1 [3]; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; fpLR2 = SQR (pbodyL-&gt;fpR); fpS1 = .5 * fpLR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; <p> static FPTYPE afpY <ref> [3] </ref>; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; static FPTYPE fpS1; static FPTYPE fpLR2; static ULONG ulII, ulJJ; static FPTYPE fpRy; static FPTYPE afpD [3]; static FPTYPE fpRz; static FPTYPE afpZ [3]; static FPTYPE afpXmZ [3]; static FPTYPE fpRxz; static FPTYPE afpSum1 [3]; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; fpLR2 = SQR (pbodyL-&gt;fpR); fpS1 = .5 * fpLR2 / PI; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; afpX [0] = pgeoI-&gt;afpX [0] * pbodyK-&gt;fpR <p> */ - /* loop through rows */ - #else /*------------------------- CREATEANN parallel ulN particle number pfpA position of submatrix ulIncr increment from row to row ---------------------------*/ static void CreateAnn (ulN, pfpA, ulIncr) ULONG ulN; FPTYPE *pfpA; ULONG ulIncr; - static ULONG ulI, ulJ; static USHORT usIXs, usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpR; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; /* radius of particle ulN */ fpR = pg-&gt;abody [ulN].fpR; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, <p> position of submatrix ulIncr increment from row to row ---------------------------*/ static void CreateAnn (ulN, pfpA, ulIncr) ULONG ulN; FPTYPE *pfpA; ULONG ulIncr; - static ULONG ulI, ulJ; static USHORT usIXs, usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpR; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static PGEO pgeoI, pgeoJ; /* radius of particle ulN */ fpR = pg-&gt;abody [ulN].fpR; /* loop through rows */ for (ulI = 0, pfpAA = pfpA; ulI &lt; pg-&gt;ulM; ulI++, pfpAA += ulIncr) - pgeoI = &pg-&gt;ageo [ulI]; /* loop through columns */ for (ulJ = <p> */ - CREATEAKL parallel ulK particle number (x) ulL particle number (y) pfpA position of submatrix ulIncr increment from row to row ---------------------------*/ static void CreateAkl (ulK, ulL, pfpA, ulIncr) ULONG ulK; ULONG ulL; FPTYPE *pfpA; ULONG ulIncr; - static ULONG ulI, ulJ; static USHORT usIXs, usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static FPTYPE afpZdst [3]; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; /* distance between particle centers */ afpZdst [0] = <p> position of submatrix ulIncr increment from row to row ---------------------------*/ static void CreateAkl (ulK, ulL, pfpA, ulIncr) ULONG ulK; ULONG ulL; FPTYPE *pfpA; ULONG ulIncr; - static ULONG ulI, ulJ; static USHORT usIXs, usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static FPTYPE afpZdst [3]; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; /* distance between particle centers */ afpZdst [0] = pbodyK-&gt;afpZ [0] - pbodyL-&gt;afpZ [0]; afpZdst [1] = pbodyK-&gt;afpZ [1] - pbodyL-&gt;afpZ [1]; <p> increment from row to row ---------------------------*/ static void CreateAkl (ulK, ulL, pfpA, ulIncr) ULONG ulK; ULONG ulL; FPTYPE *pfpA; ULONG ulIncr; - static ULONG ulI, ulJ; static USHORT usIXs, usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static FPTYPE afpZdst [3]; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; /* distance between particle centers */ afpZdst [0] = pbodyK-&gt;afpZ [0] - pbodyL-&gt;afpZ [0]; afpZdst [1] = pbodyK-&gt;afpZ [1] - pbodyL-&gt;afpZ [1]; afpZdst [2] = pbodyK-&gt;afpZ <p> CreateAkl (ulK, ulL, pfpA, ulIncr) ULONG ulK; ULONG ulL; FPTYPE *pfpA; ULONG ulIncr; - static ULONG ulI, ulJ; static USHORT usIXs, usIXt; static FPTYPE afpXmY <ref> [3] </ref>; static FPTYPE fpRxy2; static FPTYPE fpRxy; static FPTYPE fpSum; static FPTYPE afpX [3]; static FPTYPE afpY [3]; static FPTYPE *pfpAA, *pfpAAA; static FPTYPE afpZdst [3]; static PGEO pgeoI, pgeoJ; static PBODY pbodyK, pbodyL; pbodyK = &pg-&gt;abody [ulK]; pbodyL = &pg-&gt;abody [ulL]; /* distance between particle centers */ afpZdst [0] = pbodyK-&gt;afpZ [0] - pbodyL-&gt;afpZ [0]; afpZdst [1] = pbodyK-&gt;afpZ [1] - pbodyL-&gt;afpZ [1]; afpZdst [2] = pbodyK-&gt;afpZ [2] - pbodyL-&gt;afpZ [2]; /* loop through rows <p> large distance */ - /* loop through columns */ - /* loop through rows */ - #endif /*------------------------- CREATEBN parallel ulN particle number pfpB position of subvector ---------------------------*/ static void CreateBn (ulK, pfpB) ULONG ulK; FPTYPE *pfpB; - static ULONG ulI; static ULONG ulL; static FPTYPE fpSum; static FPTYPE afpX <ref> [3] </ref>; static FPTYPE afpXmZ [3]; static FPTYPE *pfpBB; static PBODY pbodyK, pbodyL; #ifdef CONTAINER static FPTYPE fpRz, fpRy; static FPTYPE afpD [3]; #endif pbodyK = &pg-&gt;abody [ulK]; /* loop through rows */ for (ulI = 0, pfpBB = pfpB; ulI &lt; pg-&gt;ulM; ulI++, pfpBB++) - afpX [0] = pg-&gt;ageo [ulI].afpX [0] <p> /* loop through columns */ - /* loop through rows */ - #endif /*------------------------- CREATEBN parallel ulN particle number pfpB position of subvector ---------------------------*/ static void CreateBn (ulK, pfpB) ULONG ulK; FPTYPE *pfpB; - static ULONG ulI; static ULONG ulL; static FPTYPE fpSum; static FPTYPE afpX <ref> [3] </ref>; static FPTYPE afpXmZ [3]; static FPTYPE *pfpBB; static PBODY pbodyK, pbodyL; #ifdef CONTAINER static FPTYPE fpRz, fpRy; static FPTYPE afpD [3]; #endif pbodyK = &pg-&gt;abody [ulK]; /* loop through rows */ for (ulI = 0, pfpBB = pfpB; ulI &lt; pg-&gt;ulM; ulI++, pfpBB++) - afpX [0] = pg-&gt;ageo [ulI].afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ <p> particle number pfpB position of subvector ---------------------------*/ static void CreateBn (ulK, pfpB) ULONG ulK; FPTYPE *pfpB; - static ULONG ulI; static ULONG ulL; static FPTYPE fpSum; static FPTYPE afpX <ref> [3] </ref>; static FPTYPE afpXmZ [3]; static FPTYPE *pfpBB; static PBODY pbodyK, pbodyL; #ifdef CONTAINER static FPTYPE fpRz, fpRy; static FPTYPE afpD [3]; #endif pbodyK = &pg-&gt;abody [ulK]; /* loop through rows */ for (ulI = 0, pfpBB = pfpB; ulI &lt; pg-&gt;ulM; ulI++, pfpBB++) - afpX [0] = pg-&gt;ageo [ulI].afpX [0] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [0]; afpX [1] = pg-&gt;ageo [ulI].afpX [1] * pbodyK-&gt;fpR + pbodyK-&gt;afpZ [1]; afpX [2] = pg-&gt;ageo [ulI].afpX <p> (); static void CreateOctahedron (); static void CreateIcosahedron (); static void Tesselate (); static void Bisector (); 199 static void NewElements (); static void AddElement (); static void RenameElement (); /*--------------------*/ /* VARIABLEs */ /*--------------------*/ static FPTYPE (*afpNode)<ref> [3] </ref>; static USHORT (*ausElement)[3]; static USHORT usLastElement; static USHORT usLastNode; static USHORT ausNewNode [3]; /*--------------------*/ /* FUNCTION CreateGeometry */ /*--------------------*/ extern USHORT CreateGeometry (usMstart, usNtess) USHORT usMstart; USHORT usNtess; - USHORT usI; USHORT usM; /* check if number of elements is too high */ usM = usMstart; for (usI = 0; usI &lt; usNtess; usI++) - - - /* not enough memory for this <p> usK++) - Bisector (usK, 0, 1); Bisector (usK, 1, 2); Bisector (usK, 2, 0); NewElements (usK); - /*--------------------*/ /* FUNCTION Bisector */ /*--------------------*/ static void Bisector (usK, usI, usJ) USHORT usK; USHORT usI; USHORT usJ; - USHORT usEndX1, usEndX2; FPTYPE fpNorm; FPTYPE fpE00, fpE01, fpE02, fpE10, fpE11, fpE12; FPTYPE afpX <ref> [3] </ref>; usEndX1 = ausElement [usK][usI]; usEndX2 = ausElement [usK][usJ]; fpE00 = afpNode [usEndX1][0]; fpE01 = afpNode [usEndX1][1]; fpE02 = afpNode [usEndX1][2]; fpE10 = afpNode [usEndX2][0]; 206 fpE11 = afpNode [usEndX2][1]; fpE12 = afpNode [usEndX2][2]; afpX [0] = fpE00 + fpE10; afpX [1] = fpE01 + fpE11; afpX [2] = fpE02 + <p> USHORT usM; USHORT usN; - ausElement [usK][0] = usL; ausElement [usK][1] = usM; ausElement [usK][2] = usN; - /* FUNCTION GetElementAll */ /*--------------------*/ extern void GetElementAll (usK, pgeo) USHORT usK; PGEO pgeo; - USHORT usNode1 = ausElement [usK][0]; USHORT usNode2 = ausElement [usK][1]; USHORT usNode3 = ausElement [usK][2]; FPTYPE afpP1 <ref> [3] </ref>, afpP2 [3], afpP3 [3]; FPTYPE afpU1 [3], afpU2 [3]; FPTYPE afpX [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 [1] = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = <p> USHORT usN; - ausElement [usK][0] = usL; ausElement [usK][1] = usM; ausElement [usK][2] = usN; - /* FUNCTION GetElementAll */ /*--------------------*/ extern void GetElementAll (usK, pgeo) USHORT usK; PGEO pgeo; - USHORT usNode1 = ausElement [usK][0]; USHORT usNode2 = ausElement [usK][1]; USHORT usNode3 = ausElement [usK][2]; FPTYPE afpP1 <ref> [3] </ref>, afpP2 [3], afpP3 [3]; FPTYPE afpU1 [3], afpU2 [3]; FPTYPE afpX [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 [1] = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; <p> - ausElement [usK][0] = usL; ausElement [usK][1] = usM; ausElement [usK][2] = usN; - /* FUNCTION GetElementAll */ /*--------------------*/ extern void GetElementAll (usK, pgeo) USHORT usK; PGEO pgeo; - USHORT usNode1 = ausElement [usK][0]; USHORT usNode2 = ausElement [usK][1]; USHORT usNode3 = ausElement [usK][2]; FPTYPE afpP1 <ref> [3] </ref>, afpP2 [3], afpP3 [3]; FPTYPE afpU1 [3], afpU2 [3]; FPTYPE afpX [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 [1] = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] <p> = usL; ausElement [usK][1] = usM; ausElement [usK][2] = usN; - /* FUNCTION GetElementAll */ /*--------------------*/ extern void GetElementAll (usK, pgeo) USHORT usK; PGEO pgeo; - USHORT usNode1 = ausElement [usK][0]; USHORT usNode2 = ausElement [usK][1]; USHORT usNode3 = ausElement [usK][2]; FPTYPE afpP1 <ref> [3] </ref>, afpP2 [3], afpP3 [3]; FPTYPE afpU1 [3], afpU2 [3]; FPTYPE afpX [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 [1] = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] <p> ausElement [usK][1] = usM; ausElement [usK][2] = usN; - /* FUNCTION GetElementAll */ /*--------------------*/ extern void GetElementAll (usK, pgeo) USHORT usK; PGEO pgeo; - USHORT usNode1 = ausElement [usK][0]; USHORT usNode2 = ausElement [usK][1]; USHORT usNode3 = ausElement [usK][2]; FPTYPE afpP1 <ref> [3] </ref>, afpP2 [3], afpP3 [3]; FPTYPE afpU1 [3], afpU2 [3]; FPTYPE afpX [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 [1] = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode <p> usM; ausElement [usK][2] = usN; - /* FUNCTION GetElementAll */ /*--------------------*/ extern void GetElementAll (usK, pgeo) USHORT usK; PGEO pgeo; - USHORT usNode1 = ausElement [usK][0]; USHORT usNode2 = ausElement [usK][1]; USHORT usNode3 = ausElement [usK][2]; FPTYPE afpP1 <ref> [3] </ref>, afpP2 [3], afpP3 [3]; FPTYPE afpU1 [3], afpU2 [3]; FPTYPE afpX [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 [1] = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] <p> = usN; - /* FUNCTION GetElementAll */ /*--------------------*/ extern void GetElementAll (usK, pgeo) USHORT usK; PGEO pgeo; - USHORT usNode1 = ausElement [usK][0]; USHORT usNode2 = ausElement [usK][1]; USHORT usNode3 = ausElement [usK][2]; FPTYPE afpP1 <ref> [3] </ref>, afpP2 [3], afpP3 [3]; FPTYPE afpU1 [3], afpU2 [3]; FPTYPE afpX [3]; FPTYPE afpN [3], fpDot, fpNorm; /* vertices */ pgeo-&gt;afpP1 [0] = afpP1 [0] = afpNode [usNode1][0]; pgeo-&gt;afpP1 [1] = afpP1 [1] = afpNode [usNode1][1]; pgeo-&gt;afpP1 [2] = afpP1 [2] = afpNode [usNode1][2]; pgeo-&gt;afpP2 [0] = afpP2 [0] = afpNode [usNode2][0]; pgeo-&gt;afpP2 [1] = afpP2 [1] = afpNode [usNode2][1]; pgeo-&gt;afpP2 [2] = afpP2 [2] <p> endif # ifndef G_MALLOC # define G_MALLOC (ulSize) malloc (ulSize); # endif #endif B.5.4 C Header File geometry.h /*-----------------------*/ /* geometry.h */ /*-----------------------*/ /* header file for geometry.c */ /* and lap.c */ /* programmed by Frank Traenkle */ /*-----------------------*/ /* STRUCTs */ /*--------------------*/ typedef struct _GEO - FPTYPE afpP1 <ref> [3] </ref>; /* vertices */ 210 FPTYPE afpP2 [3]; FPTYPE afpP3 [3]; FPTYPE afpU1 [3]; /* vectors of edges */ FPTYPE afpU2 [3]; FPTYPE afpX [3]; /* centroid */ FPTYPE afpN [3]; /* normal vector */ FPTYPE fpDA; /* area */ FPTYPE fpJacob; /* Jacobian */ - GEO, *PGEO; /*--------------------*/ /* PROTOTYPEs <p> (ulSize) malloc (ulSize); # endif #endif B.5.4 C Header File geometry.h /*-----------------------*/ /* geometry.h */ /*-----------------------*/ /* header file for geometry.c */ /* and lap.c */ /* programmed by Frank Traenkle */ /*-----------------------*/ /* STRUCTs */ /*--------------------*/ typedef struct _GEO - FPTYPE afpP1 <ref> [3] </ref>; /* vertices */ 210 FPTYPE afpP2 [3]; FPTYPE afpP3 [3]; FPTYPE afpU1 [3]; /* vectors of edges */ FPTYPE afpU2 [3]; FPTYPE afpX [3]; /* centroid */ FPTYPE afpN [3]; /* normal vector */ FPTYPE fpDA; /* area */ FPTYPE fpJacob; /* Jacobian */ - GEO, *PGEO; /*--------------------*/ /* PROTOTYPEs */ /*--------------------*/ extern USHORT CreateGeometry (); extern <p> # endif #endif B.5.4 C Header File geometry.h /*-----------------------*/ /* geometry.h */ /*-----------------------*/ /* header file for geometry.c */ /* and lap.c */ /* programmed by Frank Traenkle */ /*-----------------------*/ /* STRUCTs */ /*--------------------*/ typedef struct _GEO - FPTYPE afpP1 <ref> [3] </ref>; /* vertices */ 210 FPTYPE afpP2 [3]; FPTYPE afpP3 [3]; FPTYPE afpU1 [3]; /* vectors of edges */ FPTYPE afpU2 [3]; FPTYPE afpX [3]; /* centroid */ FPTYPE afpN [3]; /* normal vector */ FPTYPE fpDA; /* area */ FPTYPE fpJacob; /* Jacobian */ - GEO, *PGEO; /*--------------------*/ /* PROTOTYPEs */ /*--------------------*/ extern USHORT CreateGeometry (); extern void CloseGeometry (); <p> B.5.4 C Header File geometry.h /*-----------------------*/ /* geometry.h */ /*-----------------------*/ /* header file for geometry.c */ /* and lap.c */ /* programmed by Frank Traenkle */ /*-----------------------*/ /* STRUCTs */ /*--------------------*/ typedef struct _GEO - FPTYPE afpP1 <ref> [3] </ref>; /* vertices */ 210 FPTYPE afpP2 [3]; FPTYPE afpP3 [3]; FPTYPE afpU1 [3]; /* vectors of edges */ FPTYPE afpU2 [3]; FPTYPE afpX [3]; /* centroid */ FPTYPE afpN [3]; /* normal vector */ FPTYPE fpDA; /* area */ FPTYPE fpJacob; /* Jacobian */ - GEO, *PGEO; /*--------------------*/ /* PROTOTYPEs */ /*--------------------*/ extern USHORT CreateGeometry (); extern void CloseGeometry (); extern void GetElementAll <p> */ /*-----------------------*/ /* header file for geometry.c */ /* and lap.c */ /* programmed by Frank Traenkle */ /*-----------------------*/ /* STRUCTs */ /*--------------------*/ typedef struct _GEO - FPTYPE afpP1 <ref> [3] </ref>; /* vertices */ 210 FPTYPE afpP2 [3]; FPTYPE afpP3 [3]; FPTYPE afpU1 [3]; /* vectors of edges */ FPTYPE afpU2 [3]; FPTYPE afpX [3]; /* centroid */ FPTYPE afpN [3]; /* normal vector */ FPTYPE fpDA; /* area */ FPTYPE fpJacob; /* Jacobian */ - GEO, *PGEO; /*--------------------*/ /* PROTOTYPEs */ /*--------------------*/ extern USHORT CreateGeometry (); extern void CloseGeometry (); extern void GetElementAll (); B.5.5 Make File lap.mak.include #------------------------------------ # lap.mak.include <p> header file for geometry.c */ /* and lap.c */ /* programmed by Frank Traenkle */ /*-----------------------*/ /* STRUCTs */ /*--------------------*/ typedef struct _GEO - FPTYPE afpP1 <ref> [3] </ref>; /* vertices */ 210 FPTYPE afpP2 [3]; FPTYPE afpP3 [3]; FPTYPE afpU1 [3]; /* vectors of edges */ FPTYPE afpU2 [3]; FPTYPE afpX [3]; /* centroid */ FPTYPE afpN [3]; /* normal vector */ FPTYPE fpDA; /* area */ FPTYPE fpJacob; /* Jacobian */ - GEO, *PGEO; /*--------------------*/ /* PROTOTYPEs */ /*--------------------*/ extern USHORT CreateGeometry (); extern void CloseGeometry (); extern void GetElementAll (); B.5.5 Make File lap.mak.include #------------------------------------ # lap.mak.include #------------------------------------ # included <p> and lap.c */ /* programmed by Frank Traenkle */ /*-----------------------*/ /* STRUCTs */ /*--------------------*/ typedef struct _GEO - FPTYPE afpP1 <ref> [3] </ref>; /* vertices */ 210 FPTYPE afpP2 [3]; FPTYPE afpP3 [3]; FPTYPE afpU1 [3]; /* vectors of edges */ FPTYPE afpU2 [3]; FPTYPE afpX [3]; /* centroid */ FPTYPE afpN [3]; /* normal vector */ FPTYPE fpDA; /* area */ FPTYPE fpJacob; /* Jacobian */ - GEO, *PGEO; /*--------------------*/ /* PROTOTYPEs */ /*--------------------*/ extern USHORT CreateGeometry (); extern void CloseGeometry (); extern void GetElementAll (); B.5.5 Make File lap.mak.include #------------------------------------ # lap.mak.include #------------------------------------ # included general file into makefiles for different
Reference: [4] <author> G.K. Batchelor. </author> <title> Transport Properties of Two-Phase Materials with Random Structure. </title> <journal> Ann. Rev. Fluid Mech., </journal> <volume> 6 </volume> <pages> 227-255, </pages> <year> 1974. </year>
Reference-contexts: Because of the analogy of the electrostatics to time-independent heat conduction, this dielectic constant is equal to the thermal conductivity of a two-phase material, where the N bodies are perfectly conducting inclusions in a medium with a finite thermal conductivity surrounded by a perfectly conducting container <ref> [4] </ref>. The Stokes equations describe the creeping flow of Newtonian fluids with very high viscosity or negligible inertia [31]. CDLBIEM solves the mobility problem where the forces and torques acting on the particles are given and the velocity and the rigid body motion of the particles are to be calculated. <p> This method may be extended to calculate the effective dielectric constant of these perfectly conducting inclusions in a void 1 matrix according to the lines in <ref> [4] </ref>. The dielectric constant is a 2nd order tensor * in the general case of anisotropic inclusions. <p> XLOCK xulProc; #endif /* Numerical Data */ USHORT usPolyN; USHORT usTessN; #ifdef WWT /* --- dummy variable to align next cache block to 32 bytes --- */ # ifdef CONTAINER # ifdef SINGLEPREC ULONG aulDummy [5]; # else ULONG aulDummy [6]; # endif # else # ifndef SINGLEPREC ULONG aulDummy <ref> [4] </ref>; # endif # endif #endif /* --- read and write data --- */ /* whole solution vector of previous iteration */ FPTYPE *afpXOld; #ifdef WWT /* locks for different parts of this vector */ XLOCK *axafpXOld; #endif /* surface potential */ FPTYPE *afpPsi; /* error in each iteration */ FPTYPE
Reference: [5] <author> D.P. Bertsekas and J.N. Tsitsiklis. </author> <title> Parallel and Distributed Computation Numerical Methods. </title> <address> PrenticeHall, </address> <year> 1989. </year>
Reference-contexts: are not copied to the local cache of the accessing processor. 2 The term polling states that a processor has to check its input buffer, in order to see if it has received any messages. 57 5.2 Parallel Programming 5.2.1 Performance Issues The expressions and methods as already discussed in <ref> [5, 17] </ref> and summarized in this section provide information about the efficiency and quality of a parallel program. These methods are necessary to predict the performance of a program on future large-scale parallel machines. For example, we want to simulate ER fluids with up to one million particles. <p> This guarantees that the most recent solution vector is always used, which accelerates the convergence of the solution as the Gauss-Seidel Iteration does in the sequential case <ref> [5] </ref>. Furthermore, the synchronization 72 and communication overhead is reduced. Removing the synchronization barrier gives us more freedom in choosing a suitable iteration scheme. <p> #ifdef WWT /* processor number (unique) */ ULONG ulProc; /* lock on node number */ XLOCK xulProc; #endif /* Numerical Data */ USHORT usPolyN; USHORT usTessN; #ifdef WWT /* --- dummy variable to align next cache block to 32 bytes --- */ # ifdef CONTAINER # ifdef SINGLEPREC ULONG aulDummy <ref> [5] </ref>; # else ULONG aulDummy [6]; # endif # else # ifndef SINGLEPREC ULONG aulDummy [4]; # endif # endif #endif /* --- read and write data --- */ /* whole solution vector of previous iteration */ FPTYPE *afpXOld; #ifdef WWT /* locks for different parts of this vector */ XLOCK
Reference: [6] <author> R.B. Bird, W.E. Stewart, and E.N. Lightfoot. </author> <title> Transport Phenomena. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1960. </year>
Reference-contexts: The physical motivation for studying these equations is as follows. The Laplace equation describes the electric potential in electrostatics [25] but is also the equation for the temperature T in time-independent heat conduction <ref> [6] </ref>. In the considered electrostatic problems, N charged bodies that are perfect conductors are distributed in an unbounded, 3-dimensional domain. CDLBIEM solves for the electric potential on the bodies' surfaces and in the surrounding medium. <p> (unique) */ ULONG ulProc; /* lock on node number */ XLOCK xulProc; #endif /* Numerical Data */ USHORT usPolyN; USHORT usTessN; #ifdef WWT /* --- dummy variable to align next cache block to 32 bytes --- */ # ifdef CONTAINER # ifdef SINGLEPREC ULONG aulDummy [5]; # else ULONG aulDummy <ref> [6] </ref>; # endif # else # ifndef SINGLEPREC ULONG aulDummy [4]; # endif # endif #endif /* --- read and write data --- */ /* whole solution vector of previous iteration */ FPTYPE *afpXOld; #ifdef WWT /* locks for different parts of this vector */ XLOCK *axafpXOld; #endif /* surface potential
Reference: [7] <author> C.Y. Chan, A.N. Beris, and S.G. Advani. </author> <title> Second-order Boundary Element Method Calculations of Hydrodynamic Interactions between Particles in Close Proximity. </title> <journal> Intl. J. Numer. Meth. Fluids, </journal> <volume> 14 </volume> <pages> 1063-1087, </pages> <year> 1992. </year>
Reference: [8] <author> W.C. Chew and P.N. Sen. </author> <title> Dielectric Enhancement due to Electrochemical Double Layer: Thin Double Layer Approximation. </title> <journal> J. Chem. Phys., </journal> <volume> 77(9), </volume> <year> 1992. </year>
Reference: [9] <author> E.G. Coffman and G.S. Lueker. </author> <title> Probalistic Analysis of Packing and Partitioning Algorithms. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: The sum of these criteria g k over all bodies on one processor p g = k=(p1)N P +1 79 should have a minimal variance with respect to the processors. This problem is called offline makespan scheduling <ref> [9] </ref>, where N nonnegative numbers, g k , are partitioned into P blocks. The sum of the numbers in one block p, g p , have a maximum. This maximal sum has to be minimized, so that the variance of g p is minimal. <p> LPT yields the following two sets for the two blocks: f5; 3g ; f4; 3; 3g : But the optimal solution is f5; 4g ; f3; 3; 3g : However, if N is much larger than P , both the absolute and the relative error of LPT tend to zero <ref> [9] </ref>. 5.6 Implementation in Parallel Programming Models The implementation of the algorithm in a programming model is used to analyze the performance both of the algorithm and of the programming model. This analysis indicates whether the algorithm can be applied to large-scale problems and which programming model is most promising.
Reference: [10] <author> D. Culler, R. Karp, D. Patterson, A. Sahay, K.E. Schauser, E. Santos, R. Subramonian, and T. von Eicken. </author> <title> Logp: Toward a Realistic Model of Parallel Computation. </title> <booktitle> In Fifth ACM SIGPLAN Symposium on Principles & Practice of Parallel Programming (PPOPP), </booktitle> <pages> pages 1-12, </pages> <month> May </month> <year> 1993. </year>
Reference: [11] <author> D.E. Culler, A. Dusseau, S.C. Goldstein, A. Krishnamurthy, S. Lumetta, T. von Eicken, and K. Yelick. </author> <title> Introduction to Split-C Version 1.0. </title> <institution> University of California, Berkeley, </institution> <year> 1993. </year>
Reference-contexts: Data between these processors is exchanged by sending messages on the data network, which connects the processors of the CM-5 in a fat tree structure [48]. * Split-C. Split-C is a multi-processing programming language developed by the Computer Science Devision at the University of California - Berkeley <ref> [11, 12] </ref>. The programming model of Split-C is the static shared-memory model. The address space in Split-C is shared and 2-dimensional, where the first coordinate is the processor number and the second the local address on this processor. <p> Furthermore, the request-and-send scheme includes less local synchronization of processor A and processor B. 5.6.2 Split-C Split-C supports SPMD programming by adding parallel computing directives to ANSI-C, such as global data assignments, barriers, atomic functions, and locks <ref> [11, 12] </ref>. Split-C's programming model is the static shared memory (or non-uniform memory access, NUMA) model where each processor stores a fixed portion of global memory and communicates with other processors in order to access the other portions of global memory.
Reference: [12] <author> D.E. Culler, A. Dusseau, S.C. Goldstein, A. Krishnamurthy, T. von Eicken, and K. Yelick. </author> <title> Parallel Programming in Split-C. </title> <booktitle> In Proceedings of Supercomputing 1993, </booktitle> <year> 1993. </year>
Reference-contexts: Data between these processors is exchanged by sending messages on the data network, which connects the processors of the CM-5 in a fat tree structure [48]. * Split-C. Split-C is a multi-processing programming language developed by the Computer Science Devision at the University of California - Berkeley <ref> [11, 12] </ref>. The programming model of Split-C is the static shared-memory model. The address space in Split-C is shared and 2-dimensional, where the first coordinate is the processor number and the second the local address on this processor. <p> Furthermore, the request-and-send scheme includes less local synchronization of processor A and processor B. 5.6.2 Split-C Split-C supports SPMD programming by adding parallel computing directives to ANSI-C, such as global data assignments, barriers, atomic functions, and locks <ref> [11, 12] </ref>. Split-C's programming model is the static shared memory (or non-uniform memory access, NUMA) model where each processor stores a fixed portion of global memory and communicates with other processors in order to access the other portions of global memory.
Reference: [13] <author> T.von Eicken, D.E. Culler, S.C. Goldstein, and K.E. Schauser. </author> <title> Active Messages: A Mechanism for Integrated Communication and Computation. </title> <booktitle> 19th Ann. Symp. on Computer Architecture, </booktitle> <pages> pages 256266, </pages> <year> 1992. </year>
Reference-contexts: Split-C's address space is 2-dimensional where one coordinate is the processor number and the other one the local address. The underlying hardware of Split-C is also the CM-5. It uses the data network of the CM- 5 very efficiently by basing the communication on active messages <ref> [13] </ref>. Active messages are asynchronous point-to-point messages that have a built-in handler, which is called upon arrival of the message on the target processor B.
Reference: [14] <author> M.J. Flynn. </author> <title> Very High-speed Computers. </title> <journal> Proc. IEEE, </journal> <volume> 54 </volume> <pages> 1901-1909, </pages> <year> 1966. </year>
Reference: [15] <author> A. Friedman. </author> <title> Foundations of Modern Analysis. </title> <publisher> Dover, </publisher> <address> New York, </address> <year> 1982. </year>
Reference-contexts: This system of equations has to be solved by algorithms such as Gaussian elemination, which are notoriously difficult and inefficient to implement on parallel computers. Furthermore (3.14) is a Fredholm equation of the first kind <ref> [15, 45] </ref>, that is the unknown only appears under the integrals. In the sense of Hadamard this equation is ill-posed, which can result in convergence problems especially when fine meshes for discretization are used. <p> Since the double layer operator is compact it has a discrete spectrum of eigenvalues, with at most one accumulation point (see Theorem 5.3.2 in <ref> [15] </ref>). Let '(x) be an eigenfunction of the double layer operator K and its corresponding eigenvalue, that is: K'(x) = S There is a system of 2 characteristic equations. <p> The operators K and 1 + K are defined in a Banach space, which is a normed linear real (or complex) space that is complete. Furthermore, our operator K is a completely continuous 30 linear operator in this space x 2 V 0 , and the Fredholm-Riesz-Schauder theory <ref> [15] </ref> is applicable. One of its theorems states that the dimension of the null-spaces of both operators 1 + K and 1 + K fl are identical. Thus we also have dim [N (1 + K)] 1.
Reference: [16] <author> Y.O. Fuentes. </author> <title> Parallel Computational Strategies for Multiparticle Systems in Stokes Flow. </title> <type> PhD thesis, </type> <institution> University of Wisconsin - Madison, </institution> <year> 1990. </year>
Reference: [17] <author> Y.O. Fuentes and S. Kim. </author> <title> Parallel Computational Microhydrodynamics: Communication Scheduling Strategies. </title> <journal> A.I.Ch.E. Journal, </journal> <volume> 38 </volume> <pages> 1059-1078, </pages> <year> 1992. </year> <pages> 213 214 </pages>
Reference-contexts: are not copied to the local cache of the accessing processor. 2 The term polling states that a processor has to check its input buffer, in order to see if it has received any messages. 57 5.2 Parallel Programming 5.2.1 Performance Issues The expressions and methods as already discussed in <ref> [5, 17] </ref> and summarized in this section provide information about the efficiency and quality of a parallel program. These methods are necessary to predict the performance of a program on future large-scale parallel machines. For example, we want to simulate ER fluids with up to one million particles. <p> In our approach s kl is proportional to the distance between the bodies k and l, scaled by the maximum distance occuring in the given array of bodies. There might be better criteria for the degree of influence between two bodies, e.g. as presented in <ref> [17] </ref>, but our choice already speeds up the execution time significantly. 76 5.4.4 Creating the System Matrices This section describes how the system matrix C and the constant vector d are calculated.
Reference: [18] <author> Y.O. Fuentes, S. Kim, and D.J. Jeffrey. </author> <title> Mobility Functions for Two Unequal Viscous Drops in Stokes Flow. I. Axisymmetric Motions. </title> <journal> Phys. Fluids, </journal> <volume> 31(9) </volume> <pages> 2445-2455, </pages> <year> 1988. </year>
Reference: [19] <author> Y.O. Fuentes, S. Kim, and D.J. Jeffrey. </author> <title> Mobility Functions for Two Unequal Viscous Drops in Stokes Flow. II. Asymmetric Motions. </title> <journal> Phys. Fluids A, </journal> <volume> 1(1) </volume> <pages> 61-76, </pages> <year> 1989. </year>
Reference: [20] <author> A. Gerstlauer. </author> <title> Boundary Integral Equation Methods for Thin Particles in Stokes Flow. </title> <type> Master's thesis, </type> <institution> University of Wisconsin - Madison, </institution> <year> 1989. </year>
Reference: [21] <author> G.L. Graham. </author> <title> Bounds on Multiprocessing Timing Anomalies. </title> <journal> SIAM Journal on Applied Mathematics, </journal> <volume> 17 </volume> <pages> 263-269, </pages> <year> 1969. </year>
Reference-contexts: This problem is N P -complete. It is generally believed that algorithms solving N P -complete problems both exactly and efficiently do not exist. For this reason, a heuristic algorithm is used to solve this problem. We use a reversed and modified form of Largest Processing Time first (LPT) <ref> [21] </ref>. Our algorithm is reversed because we take the "smallest" processing time first, and modified, since each processor has to have the same number of bodies. The load balancing routine works as follows: 1. The bodies are sorted so that g k is in a strictly decreasing order. 2.
Reference: [22] <author> S.R. Graubard. </author> <title> A New Era in Computation. </title> <journal> DAEDALUS J. Amer. Acad. Arts and Sciences, </journal> <month> Winter </month> <year> 1992. </year>
Reference: [23] <author> M.D. Hill and J.R. Larus. </author> <title> Cache Considerations for Multiprocessor Programmers. </title> <journal> Communications of the A.C.M., </journal> <volume> 33(8) </volume> <pages> 97-102, </pages> <year> 1990. </year>
Reference-contexts: A cache maintains a high-speed memory buffer closely coupled to a processor, and copies memory locations into this buffer, which are likely to be accessed in one of the subsequent instructions issued by the processor <ref> [23] </ref>. <p> Using caches a programmer has to consider several rules for a fast program execution. Since caches are arranged in cache blocks, a key issue for the program's performance is the locality of its data. There are two different forms of locality <ref> [23] </ref>. Spatial locality occurs because two simultaneous memory references are likely to access nearby words. Temporal locality arises because a recently referenced memory word is likely to be accessed again. Therefore, the data in our program is organized in blocks according to these locality forms.
Reference: [24] <author> M.D. Hill, J.R. Larus, S.K. Reinhardt, and D.A. Wood. </author> <title> Cooperative Shared Memory: Software and Hardware for Scalable Multiprocessors. </title> <journal> ACM Transactions on Computer Systems, </journal> <note> To appear, </note> <month> November </month> <year> 1993. </year>
Reference-contexts: For this reason, the Split-C program has many similarities to the message-passing program, where receiving messages is also based on polling. * Cooperative shared memory (CSM). The programming model of CSM <ref> [24] </ref> is the dynamic shared-memory model, where accessed remote data is automatically copied to the local cache of the accessing processor. <p> Differing from the first two implementations the CSM implementation does not assume 81 the CM-5 as the underlying hardware. Its underlying hardware is Dir 1 SW, which is discussed in <ref> [24] </ref>. This section discusses the different aspects of these implementations and presents the used programming models in more detail. <p> the communication in the current Version 1.0 of Split-C is closely related to the message- passing model. 94 5.6.3 Cooperative Shared Memory The first part of this section gives a brief introduction into the Cooperative Shared Memory CSM model implemented as the CICO model as described in more detail in <ref> [24] </ref>. In the second part, special issues of the algorithm's implementation in this model and the key differences to the message-passing and Split-C implementations are discussed. This section is also covered in our paper [51].
Reference: [25] <author> J.D. Jackson. </author> <title> Classical Electrodynamics. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: By appropriate extensions of the optimized program for the Laplace equation, the computationally more 3 expensive Stokes and Navier equations can be solved. The physical motivation for studying these equations is as follows. The Laplace equation describes the electric potential in electrostatics <ref> [25] </ref> but is also the equation for the temperature T in time-independent heat conduction [6]. In the considered electrostatic problems, N charged bodies that are perfect conductors are distributed in an unbounded, 3-dimensional domain. CDLBIEM solves for the electric potential on the bodies' surfaces and in the surrounding medium. <p> The amount of computation is increased by one order of magnitude, but the amount of communication and the memory usage stays constant because the number of unknowns does not increase. 1.4 Organization Chapter 2 gives an overview of the electrostatics according to Jackson's book <ref> [25] </ref>, and the Poisson equation and its special form, the Laplace equation, are derived. In Chapter 3 the Completed Double Layer Integral Equation Method for the Laplace equation is presented. <p> The final chapter, Chapter 8, summarizes this thesis and proposes future work. Chapter 2 Classical Electrostatics Classical electrostatics provides the physical foundation for the problems considered in this work. Following the book by J.D. Jackson <ref> [25] </ref>, the fundamental equations of electrostatics are presented and Poisson's equation and its special form Laplace's equation are derived which describe the electric potential in a vacuum with or without charges. <p> The solution of Laplace's equation for one charged unit sphere may be written in spherical harmonics <ref> [25] </ref>: n (r; ; ) = a n r n X P n (cos )e (3.28) (i) n1 m=n m im where (i) n is one mode of the potential in the interior region (x 2 V 0 ) and (e) n one mode in the exterior region (x =2 V <p> In electrostatics the method of images is a well known trick for matching BCs on boundaries of simple shape by placing virtual point charges in the domain in addition to the physically existing point charges <ref> [25] </ref>. The boundary conditions on these boundaries determine the magnitudes and the positions of these point charges. To apply the method of images to charged bodies not only virtual point charges but also the image of the double layer is needed. <p> This appendix describes the conversion of electrostatic units to rationalized MKSA units or SI units. Table A.1 lists some electrostatic quantities, their elecrostatic units, and their corresponding MKSA units according to <ref> [25] </ref>.
Reference: [26] <author> D.J. Jeffrey. </author> <title> Conduction through a Random Suspension of Spheres. Proc.Roy.Soc.Lond., A 335(355), </title> <year> 1973. </year>
Reference-contexts: By using the method of images, we solve problems where the bodies are inclusions in a macroscopic medium which is surrounded by a spherical perfect conductor. The solution returned by CDLBIEM is used to calculate the macroscopic dielectric constant of this two- phase material <ref> [26, 53] </ref>. Because of the analogy of the electrostatics to time-independent heat conduction, this dielectic constant is equal to the thermal conductivity of a two-phase material, where the N bodies are perfectly conducting inclusions in a medium with a finite thermal conductivity surrounded by a perfectly conducting container [4].
Reference: [27] <author> S.J. Karrila. </author> <title> Linear Operator Theory Applied to Fast Computational Strategies for Particle Interactions in Viscous Flows. </title> <type> PhD thesis, </type> <institution> University of Wisconsin - Madison, </institution> <year> 1988. </year>
Reference: [28] <author> S.J. Karrila, Y.O. Fuentes, and S. Kim. </author> <title> Parallel Computational Strategies for Hydrodynamic Interactions between Rigid Particles of Arbitrary Shape in a Viscous Fluid. </title> <journal> J. Rheology, </journal> <volume> 33 </volume> <pages> 913-947, </pages> <year> 1989. </year>
Reference: [29] <author> S.J. Karrila and S. Kim. </author> <title> Integral Equations of the Second Kind for Stokes Flow: Direct Solution for Physical Variables and Removal of Inherent Accuracy Limitations. </title> <journal> Chem. Eng. Comm., </journal> <volume> 89 </volume> <pages> 123-161, </pages> <year> 1989. </year>
Reference: [30] <institution> Kendall Square Research. Kendall Square Research Technical Summary, </institution> <year> 1992. </year>
Reference: [31] <author> S. Kim and S.J. Karrila. Microhydrodynamics: </author> <booktitle> Principles and Selected Applications. </booktitle> <address> ButterworthHeinemann, Boston, </address> <year> 1991. </year>
Reference-contexts: This work discusses the numerical Completed Double Layer Boundary Integral Equation Method (CDLBIEM) which is presented for the Stokes equations in Kim & Karrila's Micro- hydrodynamics <ref> [31] </ref>. CDLBIEM can be applied to all three equations. For the first time, CDLBIEM is used to solve the Laplace equation. The main purpose of this work is to optimize CDLBIEM on parallel machines and to investigate different programming models. <p> The Stokes equations describe the creeping flow of Newtonian fluids with very high viscosity or negligible inertia <ref> [31] </ref>. CDLBIEM solves the mobility problem where the forces and torques acting on the particles are given and the velocity and the rigid body motion of the particles are to be calculated. <p> This is a guess, but a reasonable one looking at the analogous problem of the image system for the Stokeslet <ref> [31] </ref>. <p> Note that this is not a valid approach for the image system of a Stokeslet, since the image of a Stokeslet outside the container is a whole distribution of singularities inside the container <ref> [31] </ref>. The position of the point charge inside the container is given by y and its magnitude by Q.
Reference: [32] <editor> D.J. Klingenberg, F. van Swol, and C.F. Zukoski. </editor> <title> Dynamic Simulation of Electrorheological Suspensions. </title> <journal> J. Chem. Phys., </journal> <volume> 91 </volume> <pages> 7888-7895, </pages> <year> 1989. </year>
Reference-contexts: A simultaneous solution of the Stokes and the Laplace equations is of great importance in the form of electrorheological fluid simulations. An electrorheological fluid is a suspension of polarizable particles in a nonconducting oil <ref> [32] </ref>. Its outstanding rheological property is the change of its viscosity, which is of orders of magnitude greater under an applied electric 4 field.
Reference: [33] <author> D. Lenoski, J. Laudon, K. Gharachorloo, W.D. Weber, A. Gupta, J. Hennessy, M. Horowitz, and M. Lam. </author> <title> The Stanford DASH Multiprocessor. </title> <journal> IEEE Computer, </journal> <volume> 25(3) </volume> <pages> 63-79, </pages> <month> March </month> <year> 1992. </year>
Reference: [34] <author> C. Lin and L. Snyder. </author> <title> A Comparison of Programming Models for Shared Memory Multiprocessors. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing, </booktitle> <volume> 2 </volume> <pages> 163-170, </pages> <month> August </month> <year> 1990. </year>
Reference: [35] <author> S.Y. Lu. </author> <title> On the Effective Transport Properties of Composite Materials. </title> <type> PhD thesis, </type> <institution> University of Wisconsin - Madison, </institution> <year> 1988. </year>
Reference: [36] <author> S.Y. Lu and S. Kim. </author> <title> Effective Thermal Conductivity of Composites Containing Spheroidal Inclusions. </title> <journal> A.I.Ch.E. Journal, </journal> <volume> 36(6), </volume> <year> 1990. </year>
Reference: [37] <author> L.E. </author> <title> Malvern. Introduction to the Mechanics of a Continuous Medium. </title> <publisher> Prentice-Hall, </publisher> <year> 1969. </year>
Reference-contexts: equations rp + r v = 0 ; r v = 0 (1.2) where v is the velocity and p the pressure, and * the time-independent version of the Navier equation ( + )r (r u) + r u + b = 0 (1.3) where u is the elastic displacement <ref> [37] </ref>. This work discusses the numerical Completed Double Layer Boundary Integral Equation Method (CDLBIEM) which is presented for the Stokes equations in Kim & Karrila's Micro- hydrodynamics [31]. CDLBIEM can be applied to all three equations. For the first time, CDLBIEM is used to solve the Laplace equation.
Reference: [38] <author> C. Maul. </author> <title> Boundary Integral Equation Methods for Polyhedra in Stokes Flow. </title> <type> Master's thesis, </type> <institution> University of Wisconsin - Madison, </institution> <year> 1990. </year>
Reference: [39] <author> J. Maxwell. </author> <title> Electricity and Magnetism. </title> <publisher> Dover, </publisher> <year> 1954. </year>
Reference: [40] <editor> C.W. Oseen. Hydrodynamik. </editor> <publisher> Akad. </publisher> <address> Verlagsgesellschaft, Leipzig, </address> <year> 1927. </year> <month> 215 </month>
Reference: [41] <author> P. Pakdel and S. Kim. </author> <title> Mobility and Stresslet Functions of Particles with Rough Surfaces in Viscous Fluids: A Numerical Study. </title> <journal> J. Rheol., </journal> <volume> 11 </volume> <pages> 797-823, </pages> <year> 1991. </year>
Reference-contexts: However, numerical considerations can help to find an optimal position, for which the numerical solution is most accurate and the convergence time is optimal <ref> [41] </ref>. This optimal position depends on the particle configurations considered and the given shape of the bodies, so that there is no simple approach to this optimal position.
Reference: [42] <author> N. Phan-Thien and S. Kim. </author> <title> Microstructures in Elastic Media. </title> <note> To appear, </note> <year> 1994. </year>
Reference: [43] <author> H. Power and G. Miranda. </author> <title> Second Kind Integral Equation Formulation of Stokes' Flows past a Particle of Arbitrary Shape. </title> <journal> SIAM J. Appl. Math., </journal> <volume> 47(4) </volume> <pages> 689-698, </pages> <year> 1987. </year>
Reference: [44] <author> W.H. Press, S.A. Teukolsky, W.T. Vetterling, and B.P. Flannery. </author> <title> Numerical Recipes in C. </title> <address> Cambridge, New York, 2nd edition, </address> <year> 1992. </year>
Reference: [45] <author> D. Ramkrishna and N.R. Amundson. </author> <title> Linear Operator Methods in Chemical Engineering. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, </address> <year> 1985. </year>
Reference-contexts: This system of equations has to be solved by algorithms such as Gaussian elemination, which are notoriously difficult and inefficient to implement on parallel computers. Furthermore (3.14) is a Fredholm equation of the first kind <ref> [15, 45] </ref>, that is the unknown only appears under the integrals. In the sense of Hadamard this equation is ill-posed, which can result in convergence problems especially when fine meshes for discretization are used.
Reference: [46] <author> S.K. Reinhardt, M.D. Hill, J.R. Larus, A.R. Lebeck, J.C. Lewis, and D.A. Wood. </author> <title> The Wisconsin Wind Tunnel: Virtual Prototyping of Parallel Computers. </title> <booktitle> In Proceedings of the 1993 ACM Sigmetrics Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 48-60, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: For this reason, the measurements in this paper are performed on the Wisconsin Wind Tunnel (WWT), a virtual prototype for cache-coherent, shared-memory computers <ref> [46] </ref>. WWT runs parallel shared-memory programs on a parallel message-passing computer (a Thinking Machines CM-5 [48]) and uses a distributed, discrete-event simulation to concurrently calculate the programs' execution times on a proposed target computer. Wherever possible, WWT exploits the similarities between Dir 1 SW and the CM-5 to run faster. <p> Network topology and contention are ignored, and all messages are assumed a fixed latency. There are two important drawbacks to using WWT. First, when WWT predicts the per <p>- formance of the proposed Dir 1 SW computer, it actually runs programs about 100 times slower <ref> [46] </ref>. This means that full-scale data sets cannot be used in practice. Second, any model of a real physical system may fail to include key aspects of that system. 130 WWT, however, provides several advantages for this research.
Reference: [47] <author> A.H. Stroud and D. Secrest. </author> <title> Gaussian Quadrature Formulas. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, </address> <year> 1966. </year>
Reference-contexts: The function f (x) is approximated by polynomials, which have the same functional values as f (x) at the Q collocation points x r . This theory is well described and the values of w r and x r are listed in <ref> [47] </ref>. In our case, we have a 2-dimensional integration to evaluate instead of a 1-dimensional one, as described in Formula (4.4). A common way to evaluate this integration is to divide the 44 integration domain into a 2-dimensional grid of lines parallel to both coordinate axes spanning one boundary element.
Reference: [48] <author> Thinking Machines Corporation. </author> <title> The Connection Machine CM-5 Technical Summary, </title> <year> 1991. </year>
Reference-contexts: The program's data set is distributed to the local address spaces of the different processors. Data between these processors is exchanged by sending messages on the data network, which connects the processors of the CM-5 in a fat tree structure <ref> [48] </ref>. * Split-C. Split-C is a multi-processing programming language developed by the Computer Science Devision at the University of California - Berkeley [11, 12]. The programming model of Split-C is the static shared-memory model. <p> Figure 5.4 shows the phases of the iteration algorithm. 5.6.1 ANSI-C and CMMD This programming model is the standard message-passing model on the CM-5 as suggested by Thinking Machines Corporation [49]. To understand this model a brief introduction into the CM-5 hardware is given <ref> [48] </ref>. The CM-5 is a distributed-memory, message-passing parallel machine. It has comparatively powerful workstation-like processing nodes that include a 22 MIPS SPARC processor, a network controller, up to 32 MByte of DRAM and optional four 32 MFLOPS vector units. The SPARC processor has a 64 KByte instruction and data cache. <p> For this reason, the measurements in this paper are performed on the Wisconsin Wind Tunnel (WWT), a virtual prototype for cache-coherent, shared-memory computers [46]. WWT runs parallel shared-memory programs on a parallel message-passing computer (a Thinking Machines CM-5 <ref> [48] </ref>) and uses a distributed, discrete-event simulation to concurrently calculate the programs' execution times on a proposed target computer. Wherever possible, WWT exploits the similarities between Dir 1 SW and the CM-5 to run faster. Each processor in the simulated Dir 1 SW computer (the target system) executes SPARC binaries.
Reference: [49] <institution> Thinking Machines Corporation. </institution> <note> CMMD User's Guide Version 3.0, </note> <year> 1993. </year>
Reference-contexts: The algorithm described in the upcoming sections has been implemented as programs in three different programming environments: * CMMD message-passing library. The program is implemented in ANSI-C on a Think- ing Machines CM-5 and calls CMMD library functions <ref> [49] </ref>. The program's data set is distributed to the local address spaces of the different processors. Data between these processors is exchanged by sending messages on the data network, which connects the processors of the CM-5 in a fat tree structure [48]. * Split-C. <p> Figure 5.4 shows the phases of the iteration algorithm. 5.6.1 ANSI-C and CMMD This programming model is the standard message-passing model on the CM-5 as suggested by Thinking Machines Corporation <ref> [49] </ref>. To understand this model a brief introduction into the CM-5 hardware is given [48]. The CM-5 is a distributed-memory, message-passing parallel machine.
Reference: [50] <author> F. Traenkle, M.I. Frank, M.K. Vernon, and S. Kim. </author> <title> Solving Microstructure Electrostatics with MIMD Parallel Supercomputers and Split-C. </title> <note> To appear in J. </note> <institution> Non-Newtonian Fluid Mech., </institution> <year> 1993. </year>
Reference-contexts: However, the decrease in the overall iteration time is not as big. We believe this is due to the optimizer in the Split-C compiler not being as good as that in the "gcc" compiler on the CM-5 (a problem that can be corrected) <ref> [50] </ref>. 7.4 Performance of the CSM Implementation This section presents scaling results of the CSM implementation. First of all, the underlying hardware is discussed.
Reference: [51] <author> F. Traenkle, M.D. Hill, and S. Kim. </author> <title> Solving Microstructure Electrostatics on a Proposed Parallel Computer. </title> <note> To appear in Computers and Chemical Engineering, </note> <year> 1993. </year>
Reference-contexts: Each processor runs the same program, but in the case of the MIMD model it can control its instruction flow by control directives, like if or for. Programming Models. This paragraph is also covered in our paper <ref> [51] </ref>. A programming model is an abstraction from both programming languages and computer hardware that specifies the operations that may be performed and the cost of performing them without going into too much detail. <p> In the second part, special issues of the algorithm's implementation in this model and the key differences to the message-passing and Split-C implementations are discussed. This section is also covered in our paper <ref> [51] </ref>. A widespread belief is that shared memory and shared-memory hardware is not scalable because of the assumption that all memory references have the same cost. This assumption is incorrect, since access to remote memory requires communication and, in orders of magnitude, is slower than the access to local memory. <p> The shown execution times are the maxima over all processors. machine. An architecture which closely fits the CSM programming model is a distributed <p>- memory machine with the cache-coherence protocol Dir 1 SW. These results are also presented in our paper <ref> [51] </ref>. 7.4.1 Dir 1 SW: An Implementation of CSM Although the underlying hardware has distributed memory similar to the architecture in Fig <p>- ure 5.1, the Dir 1 SW protocol provides a shared-memory model on the programming level.
Reference: [52] <author> S. Wolfram. </author> <title> Mathematica. </title> <publisher> Addison-Wesley, </publisher> <address> 2nd edition, </address> <year> 1991. </year>
Reference: [53] <author> M. Zuzovsky and H. Brenner. </author> <title> Effective Conductivities of Composite Materials Composed of Cubic Arrangements of Spherical Particles Embedded in an Isotropic Matrix. </title> <journal> J. Appl. Math. Phys., </journal> <volume> 28(6), </volume> <year> 1977. </year>
Reference-contexts: By using the method of images, we solve problems where the bodies are inclusions in a macroscopic medium which is surrounded by a spherical perfect conductor. The solution returned by CDLBIEM is used to calculate the macroscopic dielectric constant of this two- phase material <ref> [26, 53] </ref>. Because of the analogy of the electrostatics to time-independent heat conduction, this dielectic constant is equal to the thermal conductivity of a two-phase material, where the N bodies are perfectly conducting inclusions in a medium with a finite thermal conductivity surrounded by a perfectly conducting container [4]. <p> By using the method of images, we can solve for the dielectric constants and thermal conductivities of two-phase materials. The computational predictions of these properties match closely the analytical solutions obtained by Zuzovsky and Brenner <ref> [53] </ref> (error of less than 0:6% for small volume fractions c). <p> Analytical results were obtained by Zuzovsky and Brenner <ref> [53] </ref> for a two-phase material with a regular distribution of spherical inclusions in an unbounded 3- dimensional domain. The matrix surrounding the spheres is a vacuum and has the dielectric constant 1, the spheres are perfect conductors and have infinite dielectric constants. <p> For instance, we have shown that its relative error is less than 0:5% for two almost touching spheres. The relative 147 error of the macroscopic dielectric constant is less than 0:6% compared to the result obtained by Zuzovsky and Brenner <ref> [53] </ref>. The comparison between the different implementations has shown that the cooperative shared memory model is the most promising of the three programming models for a standard programming model, which will allow the application programmer to easily port his or her programs from one computer to another.
References-found: 53

