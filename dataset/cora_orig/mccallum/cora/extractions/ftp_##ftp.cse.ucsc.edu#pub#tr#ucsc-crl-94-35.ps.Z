URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-94-35.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: A taxonomy of race detection algorithms.  
Author: D. P. Helmbold, C. E. McDowell 
Keyword: trace analysis, race detection, debugging, parallel programming, event ordering  
Address: Santa Cruz, CA 95064  
Affiliation: Board of Studies in Computer and Information Sciences University of California, Santa Cruz  
Date: September 28, 1994  
Pubnum: UCSC-CRL-94-35  
Abstract: This paper presents a taxonomy that categorizes methods for determining event orders in executions of parallel programs. These event orderings can then be used to detect race conditions in parallel programs. The paper also shows how recent race results fit into the event ordering taxonomy, and presents some new results for previously unexamined points in the taxonomy. 
Abstract-found: 1
Intro-found: 1
Reference: [CKS90] <author> D. Callahan, K. Kennedy, and J. Subhlok. </author> <title> Analysis of event synchronization in a parallel programming tool. </title> <booktitle> In Proceedings of Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPOPP), SIGPLAN Notices, </booktitle> <pages> pages 21-30, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: in P [LKN93], * post/wait/clear is N P-hard (Thm: 1), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear <ref> [CKS90] </ref> Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 2.1: What <p> N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear <ref> [CKS90] </ref> Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 2.1: What ordering relationships hold between statement (instances)? Monotonic synchronization operations include nested fork-join (e.g. nested parallel loops), ordered critical sections (i.e. properly paired and nested lock-unlock <p> Details of known results in our taxonomy of ordering event results 11 Post/Wait no Clear Callahan et.al. <ref> [CKS90] </ref> have studied simple programs containing only if-then-else conditionals and Post/Wait synchronization without Clear (i.e. no loops). The Post/Wait operations are permitted to specify events within an array. <p> In an earlier paper [CS88] they prove that the problem of determining if a program is race free is CoN P-hard for even these relatively simple programs under the further assumption that all program paths are feasible. In <ref> [CKS90] </ref>, they have gone on to develop a dataflow formulation of the problem for which they can compute an approximate solution in polynomial time (the paper does not give the actual complexity). <p> Some approximation algorithms can be found in <ref> [MC91, DS90, NR88, CKS90] </ref>. Post/Wait/Clear The CoN P-Hard result from [CS88] also applies here. In fact, with the addition of Clear, even detecting races in branch-free (i.e. no conditionals or loops) programs is N P-Hard (see Theorem 1).
Reference: [CS88] <author> D. Callahan and J. Subhlok. </author> <title> Static analysis of low-level synchronization. </title> <booktitle> In Proc. Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 100-111, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: For each input, the program with branching can be viewed as a set of branch-free programs. Each legal combination of branch choices for that input leads to one branch-free program. A simplifying assumption <ref> [CS88] </ref> is that all branch combinations are possible, so that any set of branch choices is legal. Without this assumption it is N P-hard to determine which branch choices are legal (see Theorem 2). <p> * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 1), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard <ref> [CS88] </ref> even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered <p> are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard <ref> [CS88] </ref> even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 2.1: What ordering relationships hold between statement (instances)? Monotonic synchronization operations include nested fork-join <p> Non-monotonic synchronization operations for which results have been published include post and wait with clear <ref> [CS88] </ref>, and semaphores [LKN93, NM90]. 3. <p> They claim that as generally used, the index expressions for these events are amenable to standard dependence analysis for computing a dependence distance (i.e. the difference between the parallel loop index and the array index used by the Post or Wait). In an earlier paper <ref> [CS88] </ref> they prove that the problem of determining if a program is race free is CoN P-hard for even these relatively simple programs under the further assumption that all program paths are feasible. <p> Some approximation algorithms can be found in [MC91, DS90, NR88, CKS90]. Post/Wait/Clear The CoN P-Hard result from <ref> [CS88] </ref> also applies here. In fact, with the addition of Clear, even detecting races in branch-free (i.e. no conditionals or loops) programs is N P-Hard (see Theorem 1). Semaphores Determining precisely the ordering relationships for branch-free programs containing semaphore synchronization is coN P-hard [NM90].
Reference: [DKF93] <author> S. K. Damodaran-Kamal and J. M Francioni. </author> <title> Nondeterminacy: Testing and debugging in message passing parallel programs. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 118-128, </pages> <year> 1993. </year>
Reference-contexts: [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing <ref> [DKF93] </ref>, rendezvous [Tay83, LC89] Table 2.1: What ordering relationships hold between statement (instances)? Monotonic synchronization operations include nested fork-join (e.g. nested parallel loops), ordered critical sections (i.e. properly paired and nested lock-unlock operations where whenever multiple locks are simultaneously held, they are always obtained in the same order), buffered send-receive where
Reference: [DS90] <author> A. Dinning and E. Schonberg. </author> <title> An empirical comparison of monitoring algorithms for access anomaly detection. </title> <booktitle> In Proceedings of Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPOPP), </booktitle> <year> 1990. </year>
Reference-contexts: However, the assumption that all combinations of branches are possible alleviates this problem. 6 2. A taxonomy of event ordering approaches Exact Solution Approximations Branch free Mono tonic * all monotonic are in P [HM93a], * fork/join is in P <ref> [MC91, DS90, NR88] </ref>, * ordered critical sections are in P (section 3.1), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 1), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is <p> mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 1), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], <p> loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 2.1: What ordering relationships hold between statement (instances)? Monotonic synchronization operations include nested fork-join (e.g. nested parallel loops), ordered critical sections <p> is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 2.1: What ordering relationships hold between statement (instances)? Monotonic synchronization operations include nested fork-join (e.g. nested parallel loops), ordered critical sections (i.e. properly paired and nested lock-unlock operations where whenever multiple locks are simultaneously held, <p> Fork/Join A number of methods have been developed in the context of on-the-fly race detection that could be used as polynomial time algorithms for determining event orders in branch free fork/join programs <ref> [MC91, DS90, NR88] </ref>. Some recent efforts have focused on reducing the number of events that must be traced [MC93] or recorded [Net93]. <p> Some approximation algorithms can be found in <ref> [MC91, DS90, NR88, CKS90] </ref>. Post/Wait/Clear The CoN P-Hard result from [CS88] also applies here. In fact, with the addition of Clear, even detecting races in branch-free (i.e. no conditionals or loops) programs is N P-Hard (see Theorem 1).
Reference: [DS91] <author> A. Dinning and E. Schonberg. </author> <title> Detecting access anomalies in programs with critical sections. </title> <booktitle> In Proc. Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 79-90, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: For branch-free programs, this comparison can easily be done using O (L 2 ) time and O (L) space per event, where L is the maximum lock nesting depth. In practice the lock nesting depth is very small (i.e. 0 or 1) <ref> [DS91] </ref>. Post/Wait no Clear Netzer and Ghosh [NG92] have an algorithm that precisely determines the event orderings for a trace of a program that uses Post/Wait synchronization with no Clears. The algorithm 8 3. <p> The most significant contribution of Offset-Span labeling is that a single execution is sufficient to identify a non-empty subset of the races that could occur for a given input. 4.2 Critical Sections Dinning and Schonberg <ref> [DS91] </ref> describe an approach to detecting access anomalies in programs that contain critical sections (i.e. properly nested binary semaphores). This approach can use any existing method for determining when two blocks are ordered (e.g. Offset-Span labeling) ignoring the orderings imposed by the unlock-lock operations.
Reference: [HM91] <author> D. P. Helmbold and C. E. McDowell. </author> <title> Computing reachable states of parallel programs (extended abstract). </title> <booktitle> SIGPLAN Notices: Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <volume> 26(12) </volume> <pages> 76-84, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Nevertheless, programmers must still uncover data races in their parallel programs. Therefore approaches that compute approximate answers to the problem have been studied and continue to be investigated <ref> [Tay83, LC89, HM91] </ref>. 4 Are there any races in this program? Because the problem of detecting races in parallel programs is in general intractable, approximations must suffice.
Reference: [HM93a] <author> D. P. Helmbold and C. E. McDowell. </author> <title> A class of synchronization operations that permit efficient race detection. </title> <type> Technical report, </type> <institution> U. of Calif. Santa Cruz, UCSC-CRL-93-29, </institution> <year> 1993. </year>
Reference-contexts: At the top level we only distinguish two types of synchronization: monotonic and non-monotonic. These terms were first applied to synchronization in <ref> [HM93a] </ref>. Intuitively, a synchronization construct is monotonic if once a blocking operation becomes unblocked, it remains unblocked for the duration of the program (e.g. <p> However, the assumption that all combinations of branches are possible alleviates this problem. 6 2. A taxonomy of event ordering approaches Exact Solution Approximations Branch free Mono tonic * all monotonic are in P <ref> [HM93a] </ref>, * fork/join is in P [MC91, DS90, NR88], * ordered critical sections are in P (section 3.1), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 1), * semaphores are coN P-hard [NM90] semaphores [HMW93] No <p> The categories are presented in order of increasing computational complexity. Since unrestricted programs create undecidability problems regardless of the synchronization primitives used, we have combined the two unrestricted program categories. 3.1 No Branches and Monotonically Synchronized We proved in a previous paper <ref> [HM93a] </ref> that computing the precise ordering relationships between events in branch-free monotonically synchronized programs can be done in polynomial time. (This generalizes a result of Netzer and Gosh [NG92], see Section 3.1.) For completeness we include here several previous polynomial time results for determining the precise ordering relationships between events for
Reference: [HM93b] <author> D. P. Helmbold and C. E. McDowell. </author> <title> What is a race in a program and when can we detect it? Technical report, </title> <type> U. </type> <institution> of Calif. Santa Cruz, UCSC-CRL-93-30, </institution> <year> 1993. </year>
Reference-contexts: In <ref> [HM93b] </ref> we examine all possible ordering relationships that can hold between two program events and classify each possibility as either a non-race or belonging to one of four classes of races 2 . The remaining questions above are addressed by this paper. <p> We use the term "thread" throughout. 2 Most of the definitions found in <ref> [HM93b] </ref> are included in the appendix of this paper. 2 2. A taxonomy of event ordering approaches 2 A taxonomy of event ordering approaches Previously, results in race detection have been classified as static analysis, post-mortem trace based, or on-the-fly.
Reference: [HM94] <author> D. P. Helmbold and C. E. McDowell. </author> <title> A taxonomy of race conditions. </title> <type> Technical report, </type> <note> in preparation, </note> <year> 1994. </year>
Reference: [HMW91] <author> D. P. Helmbold, C. E. McDowell, and J. Z. Wang. </author> <title> Detecting data races from sequential traces. </title> <booktitle> In Proc. of Hawaii International Conference on System Sciences, </booktitle> <pages> pages 408-417, </pages> <year> 1991. </year>
Reference-contexts: However, if these operations are removed then the program will have many executions which end in deadlock. Semaphores Determining precisely the ordering relationships for even branch-free programs containing semaphore synchronization is coN P-hard [NM90]. The results in this area are therefore restricted to approximations. Helmbold et.al. <ref> [HMW91] </ref> and Netzer and Miller [NM91] have pursed two complimentary approaches.
Reference: [HMW93] <author> D. P. Helmbold, C. E. McDowell, and J. Z. Wang. </author> <title> Determining possible event orders by analyzing sequential traces. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <note> 1993. Also UCSC Tech. Rep. UCSC-CRL-91-36. </note>
Reference-contexts: P [HM93a], * fork/join is in P [MC91, DS90, NR88], * ordered critical sections are in P (section 3.1), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 1), * semaphores are coN P-hard [NM90] semaphores <ref> [HMW93] </ref> No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard <p> In <ref> [HMW93] </ref> we proved that our algorithm will find at least one race from the set of possible races that can occur for a given input if any exist. 5 Simply checking the intersection of the locks held when accessing a variable is not sufficient.
Reference: [LC89] <author> D. L. Long and L. A. Clarke. </author> <title> Task interaction graphs for concurrency analysis. </title> <booktitle> In Proc. 11th Int. Conf. on Software Engineering, </booktitle> <year> 1989. </year>
Reference-contexts: NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous <ref> [Tay83, LC89] </ref> Table 2.1: What ordering relationships hold between statement (instances)? Monotonic synchronization operations include nested fork-join (e.g. nested parallel loops), ordered critical sections (i.e. properly paired and nested lock-unlock operations where whenever multiple locks are simultaneously held, they are always obtained in the same order), buffered send-receive where the sender <p> Nevertheless, programmers must still uncover data races in their parallel programs. Therefore approaches that compute approximate answers to the problem have been studied and continue to be investigated <ref> [Tay83, LC89, HM91] </ref>. 4 Are there any races in this program? Because the problem of detecting races in parallel programs is in general intractable, approximations must suffice.
Reference: [LKN93] <author> H-I. Lu, P. N. Klein, and R. H. B. Netzer. </author> <title> Detecting race conditions in parallel programs that use one semaphore. </title> <type> Technical report, </type> <institution> Brown Univ., </institution> <year> 1993. </year>
Reference-contexts: event ordering approaches Exact Solution Approximations Branch free Mono tonic * all monotonic are in P [HM93a], * fork/join is in P [MC91, DS90, NR88], * ordered critical sections are in P (section 3.1), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P <ref> [LKN93] </ref>, * post/wait/clear is N P-hard (Thm: 1), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono <p> Non-monotonic synchronization operations for which results have been published include post and wait with clear [CS88], and semaphores <ref> [LKN93, NM90] </ref>. 3. Details of known results in our taxonomy of ordering event results 7 3 Details of known results in our taxonomy of ordering event results The taxonomy introduced in the previous section has six major categories fmonotonically synchronized, non-monotonically synchronizedg fi fno branches, no loops, unrestrictedg. <p> The only exception that we are aware of is a recent result by Lu et.al. <ref> [LKN93] </ref> showing that the exact solution for programs using only a single semaphore can be found in polynomial time. Single Semaphore Computing the exact ordering relationship between events for a loop-free program that synchronizes using only a single semaphore can be done in O (n 1:5 p) time [LKN93] where n <p> Lu et.al. <ref> [LKN93] </ref> showing that the exact solution for programs using only a single semaphore can be found in polynomial time. Single Semaphore Computing the exact ordering relationship between events for a loop-free program that synchronizes using only a single semaphore can be done in O (n 1:5 p) time [LKN93] where n is the number of events and p is the number of threads. The algorithm presented by Lu, Klein, and Netzer determines if two events are ordered by solving a kind of scheduling problem.
Reference: [MC91] <author> J. Mellor-Crummey. </author> <title> On-the-fly detection of data races for programs with nested fork-join parallelism. </title> <booktitle> In Supercomputing '91, </booktitle> <pages> pages 24-33, </pages> <month> November </month> <year> 1991. </year> <title> Albu-querque, </title> <journal> NM. </journal> <volume> 16 7. </volume> <pages> Appendix </pages>
Reference-contexts: However, the assumption that all combinations of branches are possible alleviates this problem. 6 2. A taxonomy of event ordering approaches Exact Solution Approximations Branch free Mono tonic * all monotonic are in P [HM93a], * fork/join is in P <ref> [MC91, DS90, NR88] </ref>, * ordered critical sections are in P (section 3.1), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 1), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is <p> mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 1), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], <p> loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 2.1: What ordering relationships hold between statement (instances)? Monotonic synchronization operations include nested fork-join (e.g. nested parallel loops), ordered critical sections <p> is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 2.1: What ordering relationships hold between statement (instances)? Monotonic synchronization operations include nested fork-join (e.g. nested parallel loops), ordered critical sections (i.e. properly paired and nested lock-unlock operations where whenever multiple locks are simultaneously held, <p> Fork/Join A number of methods have been developed in the context of on-the-fly race detection that could be used as polynomial time algorithms for determining event orders in branch free fork/join programs <ref> [MC91, DS90, NR88] </ref>. Some recent efforts have focused on reducing the number of events that must be traced [MC93] or recorded [Net93]. <p> Some approximation algorithms can be found in <ref> [MC91, DS90, NR88, CKS90] </ref>. Post/Wait/Clear The CoN P-Hard result from [CS88] also applies here. In fact, with the addition of Clear, even detecting races in branch-free (i.e. no conditionals or loops) programs is N P-Hard (see Theorem 1). <p> A compromise that has been achieved in some situations is to guarantee to report a non-empty subset of the actual races. While some races may still be missed, if a program (or execution) is reported to be race free, then the report is accurate. 4.1 Fork/Join Mellor-Crummey <ref> [MC91] </ref> describes a method for analyzing programs containing only properly nested fork/join parallelism. This approach requires O (V N ) space where V is the number of shared variables and N is the maximum nesting depth of the forks. Also each monitoring operation requires O (N ) time.
Reference: [MC93] <author> John Mellor-Crummey. </author> <title> Compile-time support for efficient data race detection in shared-memory parallel programs. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 129-139, </pages> <year> 1993. </year>
Reference-contexts: Some recent efforts have focused on reducing the number of events that must be traced <ref> [MC93] </ref> or recorded [Net93]. As these fork/join analysis algorithms read the trace only once and have limited storage requirements they can often be executed "on-the-fly," concurrently with the parallel program they are analyzing.
Reference: [McD89] <author> C. E. McDowell. </author> <title> A practical algorithm for static analysis of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <month> June </month> <year> 1989. </year>
Reference-contexts: are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores <ref> [McD89] </ref>, message passing [DKF93], rendezvous [Tay83, LC89] Table 2.1: What ordering relationships hold between statement (instances)? Monotonic synchronization operations include nested fork-join (e.g. nested parallel loops), ordered critical sections (i.e. properly paired and nested lock-unlock operations where whenever multiple locks are simultaneously held, they are always obtained in the same order),
Reference: [Net93] <author> R. H. B. Netzer. </author> <title> Optimal tracing and replay for debugging shared-memory parallel programs. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <year> 1993. </year>
Reference-contexts: Some recent efforts have focused on reducing the number of events that must be traced [MC93] or recorded <ref> [Net93] </ref>. As these fork/join analysis algorithms read the trace only once and have limited storage requirements they can often be executed "on-the-fly," concurrently with the parallel program they are analyzing.
Reference: [NG92] <author> R. H. B. Netzer and S. Ghosh. </author> <title> Efficient race condition detection for shared-memory programs with Post/Wait synchronization. </title> <booktitle> In Proc. International Conf. on Parallel Processing, </booktitle> <year> 1992. </year>
Reference-contexts: A taxonomy of event ordering approaches Exact Solution Approximations Branch free Mono tonic * all monotonic are in P [HM93a], * fork/join is in P [MC91, DS90, NR88], * ordered critical sections are in P (section 3.1), * post/wait no clear is in P <ref> [NG92] </ref>, mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 1), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <p> primitives used, we have combined the two unrestricted program categories. 3.1 No Branches and Monotonically Synchronized We proved in a previous paper [HM93a] that computing the precise ordering relationships between events in branch-free monotonically synchronized programs can be done in polynomial time. (This generalizes a result of Netzer and Gosh <ref> [NG92] </ref>, see Section 3.1.) For completeness we include here several previous polynomial time results for determining the precise ordering relationships between events for programs using specific sets of monotonic synchronization constructs. <p> For branch-free programs, this comparison can easily be done using O (L 2 ) time and O (L) space per event, where L is the maximum lock nesting depth. In practice the lock nesting depth is very small (i.e. 0 or 1) [DS91]. Post/Wait no Clear Netzer and Ghosh <ref> [NG92] </ref> have an algorithm that precisely determines the event orderings for a trace of a program that uses Post/Wait synchronization with no Clears. The algorithm 8 3.
Reference: [NM90] <author> R. H. B. Netzer and B. P. Miller. </author> <title> On the complexity of event ordering for shared-memory parallel program executions. </title> <booktitle> In Proc. International Conf. on Parallel Processing, </booktitle> <volume> volume II, </volume> <pages> pages 93-97, </pages> <year> 1990. </year>
Reference-contexts: are in P [HM93a], * fork/join is in P [MC91, DS90, NR88], * ordered critical sections are in P (section 3.1), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 1), * semaphores are coN P-hard <ref> [NM90] </ref> semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are <p> Non-monotonic synchronization operations for which results have been published include post and wait with clear [CS88], and semaphores <ref> [LKN93, NM90] </ref>. 3. Details of known results in our taxonomy of ordering event results 7 3 Details of known results in our taxonomy of ordering event results The taxonomy introduced in the previous section has six major categories fmonotonically synchronized, non-monotonically synchronizedg fi fno branches, no loops, unrestrictedg. <p> NOTE: The operations on the XisT and XisF events are not necessary for the theorem. However, if these operations are removed then the program will have many executions which end in deadlock. Semaphores Determining precisely the ordering relationships for even branch-free programs containing semaphore synchronization is coN P-hard <ref> [NM90] </ref>. The results in this area are therefore restricted to approximations. Helmbold et.al. [HMW91] and Netzer and Miller [NM91] have pursed two complimentary approaches. <p> Post/Wait/Clear The CoN P-Hard result from [CS88] also applies here. In fact, with the addition of Clear, even detecting races in branch-free (i.e. no conditionals or loops) programs is N P-Hard (see Theorem 1). Semaphores Determining precisely the ordering relationships for branch-free programs containing semaphore synchronization is coN P-hard <ref> [NM90] </ref>. Therefore the problem is also coN P-hard when branches are permitted. 12 4. Are there any races in this program? 3.5 Unrestricted programs If programs are allowed to have branches and unbounded loops, determining the ordering relationships between statement instances is undecidable, regardless of the type of synchronization used.
Reference: [NM91] <author> R. H. B. Netzer and B. P. Miller. </author> <title> Improving the accuracy of data race detection. </title> <journal> SIGPLAN Notices (Proc. PPOPP), </journal> <volume> 26(7) </volume> <pages> 133-144, </pages> <year> 1991. </year>
Reference-contexts: Semaphores Determining precisely the ordering relationships for even branch-free programs containing semaphore synchronization is coN P-hard [NM90]. The results in this area are therefore restricted to approximations. Helmbold et.al. [HMW91] and Netzer and Miller <ref> [NM91] </ref> have pursed two complimentary approaches. <p> Also each monitoring operation requires O (N ) time. The method is called Offset-Span labeling and 4 A related problem has been observed by Netzer and Miller <ref> [NM91] </ref>. Even reporting only races that can actually occur (feasible races) can be too much. There may be a small number of important "first" races towards which the programer should be directed and then a possibly large number of other "artifact" races. 4.
Reference: [NR88] <author> I. Nudler and L. Rudolph. </author> <title> Tools for efficient development of efficient parallel programs. </title> <booktitle> In First Israeli Conference on Computer Systems Engineering, </booktitle> <year> 1988. </year>
Reference-contexts: However, the assumption that all combinations of branches are possible alleviates this problem. 6 2. A taxonomy of event ordering approaches Exact Solution Approximations Branch free Mono tonic * all monotonic are in P [HM93a], * fork/join is in P <ref> [MC91, DS90, NR88] </ref>, * ordered critical sections are in P (section 3.1), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 1), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is <p> mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 1), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], <p> loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 2.1: What ordering relationships hold between statement (instances)? Monotonic synchronization operations include nested fork-join (e.g. nested parallel loops), ordered critical sections <p> is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 2.1: What ordering relationships hold between statement (instances)? Monotonic synchronization operations include nested fork-join (e.g. nested parallel loops), ordered critical sections (i.e. properly paired and nested lock-unlock operations where whenever multiple locks are simultaneously held, <p> Fork/Join A number of methods have been developed in the context of on-the-fly race detection that could be used as polynomial time algorithms for determining event orders in branch free fork/join programs <ref> [MC91, DS90, NR88] </ref>. Some recent efforts have focused on reducing the number of events that must be traced [MC93] or recorded [Net93]. <p> Some approximation algorithms can be found in <ref> [MC91, DS90, NR88, CKS90] </ref>. Post/Wait/Clear The CoN P-Hard result from [CS88] also applies here. In fact, with the addition of Clear, even detecting races in branch-free (i.e. no conditionals or loops) programs is N P-Hard (see Theorem 1). <p> There may be a small number of important "first" races towards which the programer should be directed and then a possibly large number of other "artifact" races. 4. Are there any races in this program? 13 is similar to English-Hebrew labeling <ref> [NR88] </ref>. In particular the label for each thread that is created during the execution of the program is computed based only on the labels of its immediate predecessors (the thread executing the fork or the threads resulting in a successful join).
Reference: [Ste93] <author> N. Sterling. </author> <title> WARLOCK a static data race analysis tool. </title> <booktitle> In Proc. Winter Usenix, </booktitle> <pages> pages 97-106, </pages> <year> 1993. </year>
Reference-contexts: all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 1 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 3) fork/join [MC91, DS90, NR88], ordered critical sections <ref> [Ste93] </ref>, semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 2.1: What ordering relationships hold between statement (instances)? Monotonic synchronization operations include nested fork-join (e.g. nested parallel loops), ordered critical sections (i.e. properly paired and nested lock-unlock operations where whenever multiple locks are simultaneously held, they are always obtained in the

References-found: 22

