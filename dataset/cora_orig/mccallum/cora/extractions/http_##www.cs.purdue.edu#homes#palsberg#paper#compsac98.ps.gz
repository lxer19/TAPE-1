URL: http://www.cs.purdue.edu/homes/palsberg/paper/compsac98.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: palsberg@cs.purdue.edu  cbj@socs.uts.edu.au  
Phone: 2  
Title: The Essence of the Visitor Pattern  
Author: Jens Palsberg C. Barry Jay 
Address: Lafayette, IN 47907, USA,  P.O. Box 123 Broadway, 2007, Australia,  
Affiliation: 1 Purdue University, Dept of Computer Science, W  University of Technology, Sydney, School of Computing Sciences,  
Abstract: For object-oriented programming, the Visitor pattern enables the definition of a new operation on an object structure without changing the classes of the objects. The price has been that the set of classes must be fixed in advance, and they must each have a so-called accept method. In this paper we demonstrate how to program visitors without relying on accept methods and without knowing all classes of the objects in advance. The idea, derived from related work on shape polymorphism in functional programming, is to separate (1) accessing subobjects, and (2) acting on them. In the object-oriented setting, reflection techniques support access to sub-objects, as demonstrated in our Java class, Walkabout. It supports all visitors as subclasses, and they can be programmed without any further use of reflection. Thus a program using the Visitor pattern can now be understood as a specialized version of a program using the Walkabout class.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> G. Belle, C.B. Jay, and E. Moggi. </author> <title> Functorial ML. </title> <booktitle> In Proc. PLILP '96, </booktitle> <pages> pages 32-46. </pages> <publisher> Springer-Verlag (LNCS 1140), </publisher> <year> 1996. </year>
Reference-contexts: Benchmarking can then be used to establish the chief sources of inefficiency, for which specialised code can be constructed. The theoretical possibility of walkabouts was foreshadowed in [6] which was inspired by the emergence of shape polymorphism in functional programming <ref> [5, 1] </ref>. Shape polymorphism recognises that many common functions can be applied to a wide variety of data structures. Closest to the Visitor pattern is the higher-order function map. The high-level algorithm for map f is expressed as: (1) find every datum, and (2) apply f to it. <p> From this developed shape polymorphic programming <ref> [5, 1] </ref>. It shares the same goals as Charity, but uses parametrically polymorphic algorithms, instead of type-based specialisation. That is, the run-time code for, say, mapping is the same for lists and trees, instead of being specialised according to the type.
Reference: 2. <author> J.R.B. Cockett and T. Fukushima. </author> <title> About Charity. </title> <type> Technical Report 92/480/18, </type> <institution> University of Calgary, </institution> <year> 1992. </year>
Reference-contexts: The first attempt to regularise this situation was made in Charity <ref> [2] </ref>.
Reference: 3. <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: 1 Introduction Design patterns <ref> [3] </ref> aim to make object-oriented systems more flexible. In particular, the Visitor pattern enables the definition of a new operation on an object structure without changing the classes of the objects.
Reference: 4. <author> P. Jansson and J. Jeuring. </author> <title> PolyP a polytypic programming language extension. </title> <booktitle> In Proc. POPL'97, 24th Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 470-482, </pages> <year> 1997. </year>
Reference-contexts: The high-level algorithm for map f is expressed as: (1) find every datum, and (2) apply f to it. The challenge is to find all the data using a single algorithm. The analogy extends further. Just as visitors can be seen as specialised forms of walkabouts, polytypic programming <ref> [4, 10] </ref> can be seen as a specialised form of shape polymorphism. In the following section we review existing methods of visiting objects, and in Section 3 we introduce walkabouts. <p> Code reuse arises since the means of locating the data can be described in general terms that applies to arbitrary tree types, by including a little more information than usual at each node of the tree. In another related development, polytypic programming <ref> [4, 10] </ref> has eliminated the need for constructor annotations in Charity by improved type inference techniques, on which code specialisation is based. That is, polytypic programming is a principled form of ad hoc polymorphism in that the compiler uses type inference to determine the appropriate choice of algorithm.
Reference: 5. <author> C.B. Jay. </author> <title> A semantics for shape. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 25 </volume> <pages> 251-283, </pages> <year> 1995. </year>
Reference-contexts: Benchmarking can then be used to establish the chief sources of inefficiency, for which specialised code can be constructed. The theoretical possibility of walkabouts was foreshadowed in [6] which was inspired by the emergence of shape polymorphism in functional programming <ref> [5, 1] </ref>. Shape polymorphism recognises that many common functions can be applied to a wide variety of data structures. Closest to the Visitor pattern is the higher-order function map. The high-level algorithm for map f is expressed as: (1) find every datum, and (2) apply f to it. <p> From this developed shape polymorphic programming <ref> [5, 1] </ref>. It shares the same goals as Charity, but uses parametrically polymorphic algorithms, instead of type-based specialisation. That is, the run-time code for, say, mapping is the same for lists and trees, instead of being specialised according to the type.
Reference: 6. <author> C.B. Jay and J. Noble. </author> <title> Shaping object-oriented programs. </title> <type> Technical Report 96-16, </type> <institution> University of Technology, </institution> <address> Sydney, </address> <year> 1996. </year>
Reference-contexts: Some suggestions are considered in Section 5. More generally, one can view programs constructed from walkabouts as executable specifications. Benchmarking can then be used to establish the chief sources of inefficiency, for which specialised code can be constructed. The theoretical possibility of walkabouts was foreshadowed in <ref> [6] </ref> which was inspired by the emergence of shape polymorphism in functional programming [5, 1]. Shape polymorphism recognises that many common functions can be applied to a wide variety of data structures. Closest to the Visitor pattern is the higher-order function map. <p> Of course, the specialised polytypic programs execute faster than the generic shape polymorphic ones, so the challenge is to automate the specialisation of shape polymorphic programs to their polytypic counterparts. The striking analogy with visitors was first noted in <ref> [6] </ref>, and is here put to good effect. Walkabouts correspond to shape polymorphic programs. In particular, the high level mapping algorithm find all data, act on each one. is very similar to the high-level walkabout algorithm find all objects, act at each one.
Reference: 7. <author> Neil D. Jones, Carsten K. Gomard, and Peter Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1993. </year>
Reference-contexts: Walkabout with Accept Methods Ideally, one would like to avoid reflection where specialised code is supplied, but retain the ability to invoke it in exceptional cases. Perhaps partial evaluation <ref> [7] </ref> could be used to eliminate the reflection where specialised code exists. We have not yet investigated this. 6 Shape Polymorphism The Walkabout class is inspired by novel techniques for functional programming with recursive data types.
Reference: 8. <author> Karl J. Lieberherr. </author> <title> Adaptive Object-Oriented Software: The Demeter Method with Propagation Patterns. </title> <publisher> PWS Publishing Company, </publisher> <address> Boston, </address> <year> 1996. </year>
Reference-contexts: Thus, one could extract the names of all files which reference a particular individual, or update all occurrences of her address, without knowing the structure of the database itself. The goal of supporting such applications is shared with Lieberherr's adaptive programming <ref> [8, 9, 12] </ref>, but this requires new language constructs whereas we are able to exploit the reflection capabilities of, say, Java 1.1. Reflection introduces a significant performance penalty. One might say that this is the price of complete flexibility (which may or may not be worth paying).
Reference: 9. <author> Karl J. Lieberherr, Ignacio Silva-Lepe, and Cun Xiao. </author> <title> Adaptive object-oriented programming using graph-based customization. </title> <journal> Communications of the ACM, </journal> <volume> 37(5) </volume> <pages> 94-101, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Thus, one could extract the names of all files which reference a particular individual, or update all occurrences of her address, without knowing the structure of the database itself. The goal of supporting such applications is shared with Lieberherr's adaptive programming <ref> [8, 9, 12] </ref>, but this requires new language constructs whereas we are able to exploit the reflection capabilities of, say, Java 1.1. Reflection introduces a significant performance penalty. One might say that this is the price of complete flexibility (which may or may not be worth paying).
Reference: 10. <author> L. </author> <title> Meertens. </title> <booktitle> Calculate polytypically! In Proc. PLILP '96. </booktitle> <publisher> Springer-Verlag (LNCS 1140), </publisher> <year> 1996. </year>
Reference-contexts: The high-level algorithm for map f is expressed as: (1) find every datum, and (2) apply f to it. The challenge is to find all the data using a single algorithm. The analogy extends further. Just as visitors can be seen as specialised forms of walkabouts, polytypic programming <ref> [4, 10] </ref> can be seen as a specialised form of shape polymorphism. In the following section we review existing methods of visiting objects, and in Section 3 we introduce walkabouts. <p> Code reuse arises since the means of locating the data can be described in general terms that applies to arbitrary tree types, by including a little more information than usual at each node of the tree. In another related development, polytypic programming <ref> [4, 10] </ref> has eliminated the need for constructor annotations in Charity by improved type inference techniques, on which code specialisation is based. That is, polytypic programming is a principled form of ad hoc polymorphism in that the compiler uses type inference to determine the appropriate choice of algorithm.
Reference: 11. <author> Sun Microsystems. </author> <title> The java compiler compiler. </title> <note> www.suntest.com/Jack/, 1997. </note>
Reference-contexts: In particular, the Visitor pattern enables the definition of a new operation on an object structure without changing the classes of the objects. Recent examples of uses of the Visitor pattern include the Java Tree Builder (JTB) tool [13] and the JJTree tool <ref> [11] </ref>, which are frontends for the Java Compiler Compiler (JavaCC) [11]. In both cases, the idea is that the user of the tool can write syntax-tree operations as so-called visitors rather than changing and recompiling the syntax-tree-node classes. <p> Recent examples of uses of the Visitor pattern include the Java Tree Builder (JTB) tool [13] and the JJTree tool <ref> [11] </ref>, which are frontends for the Java Compiler Compiler (JavaCC) [11]. In both cases, the idea is that the user of the tool can write syntax-tree operations as so-called visitors rather than changing and recompiling the syntax-tree-node classes. The experience with the Visitor pattern is that many tasks can conveniently be written as visitors.
Reference: 12. <author> Jens Palsberg, Cun Xiao, and Karl Lieberherr. </author> <title> Efficient implementation of adaptive software. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(2) </volume> <pages> 264-292, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Thus, one could extract the names of all files which reference a particular individual, or update all occurrences of her address, without knowing the structure of the database itself. The goal of supporting such applications is shared with Lieberherr's adaptive programming <ref> [8, 9, 12] </ref>, but this requires new language constructs whereas we are able to exploit the reflection capabilities of, say, Java 1.1. Reflection introduces a significant performance penalty. One might say that this is the price of complete flexibility (which may or may not be worth paying).
Reference: 13. <author> Kevin Tao and Jens Palsberg. </author> <title> The Java tree builder. Purdue University, www.cs.purdue.edu/people/palsberg, 1997. This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: 1 Introduction Design patterns [3] aim to make object-oriented systems more flexible. In particular, the Visitor pattern enables the definition of a new operation on an object structure without changing the classes of the objects. Recent examples of uses of the Visitor pattern include the Java Tree Builder (JTB) tool <ref> [13] </ref> and the JJTree tool [11], which are frontends for the Java Compiler Compiler (JavaCC) [11]. In both cases, the idea is that the user of the tool can write syntax-tree operations as so-called visitors rather than changing and recompiling the syntax-tree-node classes. <p> We will explore two related avenues: one leads to the Visitor pattern as described in Section 1, and another leads to a variant which is used, for example, in the Java Tree Builder tool <ref> [13] </ref>. The specialization of class Walkabout is in two steps. <p> The class Walkabout then takes the form in Figure 9. Notice that the type casts and instanceof disappear because of the dynamic binding. Such a class is used in the Java Tree Builder tool <ref> [13] </ref>. B: In the latter case, all subclasses of Walkabout have a visit method for all of the classes C 1 ; : : : ; C n which will be invoked directly by the accept methods.
References-found: 13

