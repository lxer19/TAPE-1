URL: http://now.cs.berkeley.edu/WebOS/papers/trec.ps
Refering-URL: http://www.cs.washington.edu/homes/tom/
Root-URL: 
Author: Amin Vahdat Thomas Anderson 
Address: Seattle  
Affiliation: Computer Science Division University of California, Berkeley  Department of Computer Science and Engineering University of Washington,  
Abstract: Transparent Result Caching fl Abstract The goal of this work is to develop a general framework for transparently managing the interactions and dependencies among input files, development tools, and output files. By unobtrusively monitoring the execution of unmodified programs, we are able to track process lineageeach process's parent, children, input files, and output files, and file dependencyfor each file, the sequence of operations and the set of input files used to create the file. We use this information to implement Transparent Result Caching (TREC) and describe how TREC is used to build a number of useful user utilities. Unmake allows users to query TREC for file lineage information, including the full sequence of programs executed to create a particular output file. Transparent Make uses TREC to automatically generate dependency information by observing program execution, freeing end users from the need to explicitly specify dependency information (i.e., Makefiles can be replaced by shell scripts). Dynamic Web Object Caching allows for the caching of certain dynamically generated web pages, improving server performance and client latency. 
Abstract-found: 1
Intro-found: 1
Reference: [Alvisi & Marzullo 1996] <author> L. Alvisi and K. Marzullo. </author> <title> Tradeoffs in Implementing Optimal Message Logging Protocols. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Principles of Distributed Computing, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: For example, a program that terminates prematurely because it received a signal may not have generated complete dependency information, leav ing TREC in an inconsistent or incorrect state. 1 Note that techniques from the fault tolerance community could potentially address this limitation <ref> [Alvisi & Marzullo 1996] </ref>. Despite the limitations outlined above, we will demonstrate that TREC remains a useful tool in a number of different contexts.
Reference: [Apa 1995] <institution> Apache HTTP Server Project, </institution> <year> 1995. </year> <note> http:// www.apache.org/. </note>
Reference-contexts: While the 54.8% overhead imposed by TREC is significant, the next two benchmarks demonstrate the slowdown of individual system calls do not adversely affect the performance of real applications. The next benchmark is a compilation of the Apache HTTP server, version 1.2.4 <ref> [Apa 1995] </ref>. The source tree consists of 38,000 lines of C code and was compiled over NFS. While the 13.9% slowdown is noticeable, we believe it to be tolerable. The final benchmark, Latex, involved running latex four times, bibtex, and finally dvips to produce postscript for a 17 page document.
Reference: [Baker et al. 1991] <author> M. Baker, J. Hartman, M. Kupfer, K. Shirriff, and J. Ousterhout. </author> <title> Measurements of a Distributed File System. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. </pages> <address> 198212, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: For some programs, we observed that read and write operations were executed four times as often as all other traced system calls combined. Note that earlier file system tracing studies also inferred read and write operations to avoid the extra overhead of tracing the read/write system calls <ref> [Baker et al. 1991] </ref>. The overall TREC system architecture is summarized in attaches to a target process using the proc file system interface. A trace thread is responsible for building lineage information. Other threads use this lineage information to implement the higher-level services described in Section 3.
Reference: [Bershad & Pinkerton 1988] <author> B. N. Bershad and C. B. Pinker-ton. </author> <title> WatchdogsExtending the UNIX File System. </title> <booktitle> Computing Systems, </booktitle> <address> 1(2):169188, </address> <month> Spring </month> <year> 1988. </year>
Reference-contexts: Since the Latex benchmark executes only 16 traced system calls per second, it suffers the smallest slowdown. To address the overhead imposed by the proc and related tracing facilities, we could implement TREC functionality in the kernel. Various tools such as Watchdogs <ref> [Bershad & Pinkerton 1988] </ref>, Interposition Agents [Jones 1993], or SLIC [Ghormley et al. 1996] can be used to trace system call activity with little or no overhead.
Reference: [Braun & Claffy 1994] <author> H.-W. Braun and K. Claffy. </author> <title> Web Traffic Characterization: An Assessment of the Impact of Caching Documents From NCSA's Web Server. </title> <booktitle> In Second International World Wide Web Conference, </booktitle> <month> October </month> <year> 1994. </year>
Reference: [Bubenik & Zwaenepoel 1989] <author> R. Bubenik and W. Zwaenepoel. </author> <title> Performance of Optimistic Make. </title> <booktitle> In Proceedings of Sigmetrics, </booktitle> <pages> pp. 3948, </pages> <year> 1989. </year>
Reference-contexts: However, such automatic re-synchronization can produce undefined behavior in the general case (e.g., users saving intermediate versions of program source files that will not compile). Of course, earlier work in optimistic make <ref> [Bubenik & Zwaenepoel 1989] </ref> has demonstrated the value of creating output files in anticipation of user requests.
Reference: [Cate 1992] <author> V. Cate. </author> <title> Alex a Global Filesystem. </title> <booktitle> In Proceedings of the 1992 USENIX File System Workshop, </booktitle> <pages> pp. 112, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Harvest [Chankhunthod et al. 1996] and Squid [Squ 1996] are efforts into hierarchical web proxy caching. We believe that such caching efforts would benefit from our work in dynamic object caching. Gwertzman and Seltzer [Gwertzman & Seltzer 1996] recently proposed using the Alex protocol <ref> [Cate 1992] </ref> for maintaining cache consistency across the wide area. While this protocol provides weaker consistency guarantees than a wide-area file system, it would be simpler to deploy and could be used in our model for caching dynamic web objects at proxy caches.
Reference: [Chankhunthod et al. 1996] <author> A. Chankhunthod, P. Danzig, C. Neerdaels, M. Schwartz, and K. Worrell. </author> <title> A Hierarchical Internet Object Cache. </title> <booktitle> In Proceedings of the 1996 USENIX Technical Conference, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: Thus, the wide-area file system can act as a shared file cache for both the HTTP server and interested proxies, with TREC invalidations maintaining relatively strong consistency semantics. Another approach is to allow proxy caches to cache dynamic objects with a TTL-based invalidation scheme <ref> [Chankhunthod et al. 1996, Gwertzman & Seltzer 1996, Squ 1996] </ref>. <p> Each tool explicitly reports the files it will read and write. By contrast, unmake observes file-system activity at a low enough level that modifying tools to work with TREC is unnecessary. Recently, a large body of research is being conducted in web caching. Harvest <ref> [Chankhunthod et al. 1996] </ref> and Squid [Squ 1996] are efforts into hierarchical web proxy caching. We believe that such caching efforts would benefit from our work in dynamic object caching.
Reference: [Clemm & Osterweil 1990] <author> G. Clemm and L. Osterweil. </author> <title> A Mechanism for Environment Integration. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1):125, </volume> <month> Jan </month> <year> 1990. </year>
Reference: [Colby et al. 1996] <author> L. S. Colby, T. Griffin, L. Libkin, I. S. Mu-mick, and H. Trickey. </author> <title> Algorithms for Derred View Maintenance. </title> <booktitle> In SIGMOD, </booktitle> <pages> pp. 469480, </pages> <year> 1996. </year>
Reference: [Danzig et al. 1993] <author> P. B. Danzig, M. F. Schwartz, and R. S. Hall. </author> <title> A Case for Caching File Objects Inside Internetworks. </title> <booktitle> In ACM SIGCOMM 93 Conference, </booktitle> <pages> pp. 239248, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: One early study <ref> [Danzig et al. 1993] </ref> found that strategically-placed caches could reduce FTP file traffic by as much as 50%. Similar studies of WWW traffic yielded similar results [Braun & Claffy 1994, Duska et al. 1997, Gribble & Brewer 1997].
Reference: [Douglis & Ousterhout 1991] <author> F. Douglis and J. Ousterhout. </author> <title> Transparent Process Migration: Design Alternatives and the Sprite Implementation. </title> <journal> Software Practice and Experience, </journal> <volume> 21(8):75785, </volume> <month> August </month> <year> 1991. </year>
Reference-contexts: Further, TREC caches dynamic ob jects as normal files, simplifying system integration with existing Web servers. The performance results presented in Section 2.2 here are similar to overhead studies of process migration and remote execution in Sprite <ref> [Douglis & Ousterhout 1991] </ref>. In Sprite, a number of system calls must be forwarded to the home node of a job for local processing. While the overhead of these operations in isolation is high, the overall perceived slowdown is tolerable because of the low frequency of forwarded operations.
Reference: [Dozier 1993] <author> J. </author> <title> Dozier. </title> <type> Personal Communication, </type> <month> March </month> <year> 1993. </year>
Reference-contexts: It is believed that several journal articles have since been published still based on the incorrect data <ref> [Dozier 1993] </ref>. As another example, one error common to program developers is introducing a new header file without manually updating dependency information.
Reference: [Duska et al. 1997] <author> B. Duska, D. Marwood, and M. J. Feeley. </author> <title> The Measured Access Characteristics of World Wide Web Client Proxy Caches. </title> <booktitle> In Proceedings of the 1997 Usenix Symposium on Internet Technologies and Systems, </booktitle> <address> Monterey, California, </address> <month> December </month> <year> 1997. </year>
Reference: [Ghormley et al. 1996] <author> D. P. Ghormley, D. Petrou, and T. E. Anderson. SLIC: </author> <title> Secure Loadable Interposition Code. </title> <type> Technical Report CSD-96-920, </type> <institution> University of California at Berkeley, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: To address the overhead imposed by the proc and related tracing facilities, we could implement TREC functionality in the kernel. Various tools such as Watchdogs [Bershad & Pinkerton 1988], Interposition Agents [Jones 1993], or SLIC <ref> [Ghormley et al. 1996] </ref> can be used to trace system call activity with little or no overhead.
Reference: [Goldberg et al. 1996] <author> I. Goldberg, D. Wagner, R. Thomas, and E. Brewer. </author> <title> A Secure Environment for Untrusted Helper Applications. </title> <booktitle> In Proceedings of the Sixth USENIX Security Symposium, </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: Such a tool can also be extended to monitor system calls, disallowing certain accesses based on the effective uid of the calling process <ref> [Goldberg et al. 1996] </ref>. For example, Bob acting as root may be disallowed write access to all files in /dev and /etc. * Transparent Make: This version of the make utility allows users to specify the sequence of operations for constructing output files as simple shell scripts.
Reference: [Gribble & Brewer 1997] <author> S. D. Gribble and E. A. Brewer. </author> <title> System Design Issues for Internet Middleware Services: Deductions from a Large Client Trace. </title> <booktitle> In Proceedings of the 1997 Usenix Symposium on Internet Technologies and Systems, </booktitle> <address> Monterey, California, </address> <month> December </month> <year> 1997. </year>
Reference: [Gupta & Mumick 1995] <author> A. Gupta and I. S. Mumick. </author> <title> Maintenance of Materialized Views: Problems, Techniques, </title> <journal> and Applications. In Data Engineering Bulletin, </journal> <month> June </month> <year> 1995. </year>
Reference: [Gupta et al. 1993] <author> A. Gupta, I. S. Mumick, and V. S. Subrah-manian. </author> <title> Maintaining View Incrementally. </title> <booktitle> In SIGMOD, </booktitle> <year> 1993. </year>
Reference: [Gwertzman & Seltzer 1996] <author> J. Gwertzman and M. Seltzer. </author> <title> World-Wide Web Cache Consistency. </title> <booktitle> In Proceedings of the 1996 USENIX Technical Conference, </booktitle> <pages> pp. 141151, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Thus, the wide-area file system can act as a shared file cache for both the HTTP server and interested proxies, with TREC invalidations maintaining relatively strong consistency semantics. Another approach is to allow proxy caches to cache dynamic objects with a TTL-based invalidation scheme <ref> [Chankhunthod et al. 1996, Gwertzman & Seltzer 1996, Squ 1996] </ref>. <p> Recently, a large body of research is being conducted in web caching. Harvest [Chankhunthod et al. 1996] and Squid [Squ 1996] are efforts into hierarchical web proxy caching. We believe that such caching efforts would benefit from our work in dynamic object caching. Gwertzman and Seltzer <ref> [Gwertzman & Seltzer 1996] </ref> recently proposed using the Alex protocol [Cate 1992] for maintaining cache consistency across the wide area.
Reference: [Heydon et al. 1997] <author> A. Heydon, J. Horning, R. Levin, T. Mann, and Y. Yu. </author> <title> The Vesta-2 Software Description Language. </title> <type> Technical Report 1997-005, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, California 94301, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: While omitted from executed the compilation shell script, and /bin/tcsh, the root process of the TREC trace, is also returned. While not currently implemented, unmake combined with a source control system or, more generally, a file system capable of transparently producing older file versions <ref> [Heydon et al. 1997] </ref> can be used to rollback to earlier versions of output files. For example, users debugging a program executable may use an interactive process lineage visualization tool, similar to the display in Figure 2 (b), to identify input files that may have potentially introduced bugs. <p> DSEE [Leblang & Chase 1984, Leblang & McLean 1985], Odin [Clemm & Oster-weil 1990] and Vesta <ref> [Levin & McJones 1993, Heydon et al. 1997] </ref> provide tools for modeling the behavior of programs, enabling the concise specification of derivation rules, and distributing changes to developers. Their declarative style suits large-scale programming environments, which are highly structured and employ a well defined set of tools (compilers, linkers, etc.).
Reference: [Howard et al. 1988] <author> J. Howard, M. Kazar, S. Menees, D. Nichols, M. Satyanarayanan, R. Sidebotham, and M. West. </author> <title> Scale and Performance in a Distributed File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1):5182, </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: If such caching could be extended to Web proxies, performance could be further improved by caching dynamic objects closer to clients, potentially reducing both consumed wide-area bandwidth and user-perceived latency. One approach to addressing this limitation is to use a wide-area file system such as AFS <ref> [Howard et al. 1988] </ref> or WebFS [Vah-dat et al. 1998] to store and to cache dynamic web objects as normal files. Thus, the wide-area file system can act as a shared file cache for both the HTTP server and interested proxies, with TREC invalidations maintaining relatively strong consistency semantics.
Reference: [Iyenger & Challenger 1997] <author> A. Iyenger and J. Challenger. </author> <title> Improving Web Server Performance by Caching Dynamic Data. </title> <booktitle> In Proceedings of USENIX Symposium on Internet Technologies and Systems, </booktitle> <pages> pp. 4960, </pages> <month> December </month> <year> 1997. </year>
Reference-contexts: While existing work allows for applications to be written that can cache their results <ref> [Iyenger & Challenger 1997] </ref>, TREC automates this process by automatically caching program results and invalidates such results when the input to a CGI program changes (e.g., a new version of Navigator becomes available). <p> Approximately 20% of the queries to IBM's Web server for the 1996 Olympic games resulted in the dynamic generation of HTML (e.g., to get current medal standings) <ref> [Iyenger & Challenger 1997] </ref>. In general, the contents of such pages cannot be cached because the result of the program can change from execution to execution. <p> Finally, one proposal advocates using HTTP profiles to predict accesses to dynamically generated data, allowing servers to pre-generate potentially expensive pages in anticipation of user requests [Schechter et al. 1998]. Iyenger and Challenger <ref> [Iyenger & Challenger 1997] </ref> have implemented a caching system and API as part of IBM's web server that allows for caching of dynamic data. Their system allows for caching of dynamic data generated by arbitrary programs.
Reference: [Jones 1993] <author> M. B. Jones. </author> <title> Interposition Agents: Transparently Interposing User Code at the System Interface. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 80 93, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Since the Latex benchmark executes only 16 traced system calls per second, it suffers the smallest slowdown. To address the overhead imposed by the proc and related tracing facilities, we could implement TREC functionality in the kernel. Various tools such as Watchdogs [Bershad & Pinkerton 1988], Interposition Agents <ref> [Jones 1993] </ref>, or SLIC [Ghormley et al. 1996] can be used to trace system call activity with little or no overhead.
Reference: [Kawaguchi et al. 1996] <author> A. Kawaguchi, D. Lieuwen, I. S. Mumick, D. Quass, and K. A. Ross. </author> <title> Concur-rency Control Theory for Deferred Materialized Views. </title> <type> Unpublished, </type> <year> 1996. </year>
Reference: [Leblang & Chase 1984] <author> D. B. Leblang and R. P. Chase, Jr.. </author> <title> Computer-Aided Software Engineering in a Distributed Workstation Environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pp. 104112, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: While this approach provides weaker consistency semantics, it is easier to deploy given the current Web infrastructure. 4 Related Work Several systems have attempted to extend the automatic control of derived objects beyond the simple (but powerful) model used by make. DSEE <ref> [Leblang & Chase 1984, Leblang & McLean 1985] </ref>, Odin [Clemm & Oster-weil 1990] and Vesta [Levin & McJones 1993, Heydon et al. 1997] provide tools for modeling the behavior of programs, enabling the concise specification of derivation rules, and distributing changes to developers.
Reference: [Leblang & McLean 1985] <author> D. B. Leblang and G. D. McLean, Jr.. </author> <title> Configuration management for large-scale software development efforts. </title> <booktitle> In Proceedings of the Workshop on Software Engineering Environments for Programming-in-the-Large, </booktitle> <pages> pp. 122 127, </pages> <address> Harwichport, Massachusetts, </address> <month> June </month> <year> 1985. </year>
Reference-contexts: While this approach provides weaker consistency semantics, it is easier to deploy given the current Web infrastructure. 4 Related Work Several systems have attempted to extend the automatic control of derived objects beyond the simple (but powerful) model used by make. DSEE <ref> [Leblang & Chase 1984, Leblang & McLean 1985] </ref>, Odin [Clemm & Oster-weil 1990] and Vesta [Levin & McJones 1993, Heydon et al. 1997] provide tools for modeling the behavior of programs, enabling the concise specification of derivation rules, and distributing changes to developers.
Reference: [Levin & McJones 1993] <author> R. Levin and P. R. McJones. </author> <title> The Vesta Approach to Precise Configuration of Large Software Systems. </title> <type> Technical Report 105, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, California 94301, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: During subsequent executions of the shell script, TREC can re-run only those commands that have been invalidated by changes to input files. This approach has two advantages. First, it frees users from manually specifying dependency information in a language that can be restrictive <ref> [Levin & McJones 1993] </ref>. Next, transparent make does not require users to manually update dependency information. Thus, when a new header file is added to a source tree, TREC transparently adds the new dependency to its lineage information by observing the inputs to subsequent compilations. <p> DSEE [Leblang & Chase 1984, Leblang & McLean 1985], Odin [Clemm & Oster-weil 1990] and Vesta <ref> [Levin & McJones 1993, Heydon et al. 1997] </ref> provide tools for modeling the behavior of programs, enabling the concise specification of derivation rules, and distributing changes to developers. Their declarative style suits large-scale programming environments, which are highly structured and employ a well defined set of tools (compilers, linkers, etc.).
Reference: [McCarthy & Dayal 1989] <author> D. R. McCarthy and U. Dayal. </author> <title> The Architecure of an Active Data Base Management System. </title> <booktitle> In SIGMOD, </booktitle> <month> June </month> <year> 1989. </year>
Reference: [Microsoft Corporation ] <editor> ISAPI Overview. </editor> <address> http: //www.microsft.com/msdn/sdk/ platforms/doc/sdk/internet/src/ isapimr%g.htm. </address> <publisher> Microsoft Corporation. </publisher>
Reference-contexts: Given the inherent inefficiency of spawning a new process for dynamically generated content, a number of systems, such as ISAPI <ref> [Microsoft Corporation ] </ref>, NSAPI [Netscape ], and FastCGI [Open Market ], address this issue either by creating long-lived server processes responsible for creating dynamic content or by linking dynamic content producers into the servers address space.
Reference: [Netscape ] <institution> The Server-Application Function and Netscape Server API. </institution> <address> http://www.netscape. com/newsref/srd/server_api.html. </address>
Reference-contexts: Given the inherent inefficiency of spawning a new process for dynamically generated content, a number of systems, such as ISAPI [Microsoft Corporation ], NSAPI <ref> [Netscape ] </ref>, and FastCGI [Open Market ], address this issue either by creating long-lived server processes responsible for creating dynamic content or by linking dynamic content producers into the servers address space.
Reference: [Open Market ] <author> Fastcgi. </author> <note> http://www.fastcgi.com. </note>
Reference-contexts: Given the inherent inefficiency of spawning a new process for dynamically generated content, a number of systems, such as ISAPI [Microsoft Corporation ], NSAPI [Netscape ], and FastCGI <ref> [Open Market ] </ref>, address this issue either by creating long-lived server processes responsible for creating dynamic content or by linking dynamic content producers into the servers address space. Relative to CGI scripts, these approaches offer better performance but sacrifice some of the simplicity of writing CGI scripts.
Reference: [RTDA ] <author> VOV. </author> <title> http://www.rtda.com/vov. html. Runtime Design Automation. </title>
Reference-contexts: Like tmake, Odin implements transparent re-creation of files. A sentinel in Odin is a data object that is automatically regenerated (if necessary) at the time a user requests it, based on rules that were specified in advance for objects of its type. VOV <ref> [RTDA ] </ref>, a configuration management toolkit, is similar to TREC, in that it observes program invocations to generate a trace of lineage information. However, VOV is limited to a specialized application domain (Electronic CAD), and it requires assistance from tool programmers.
Reference: [Schechter et al. 1998] <author> S. Schechter, M. Kirshnan, and M. D. Smith. </author> <title> Using Path Profiles to Predict HTTP Requests. </title> <booktitle> In Proceedings of the Seventh International World Wide Web Conference, </booktitle> <month> April </month> <year> 1998. </year>
Reference-contexts: Finally, one proposal advocates using HTTP profiles to predict accesses to dynamically generated data, allowing servers to pre-generate potentially expensive pages in anticipation of user requests <ref> [Schechter et al. 1998] </ref>. Iyenger and Challenger [Iyenger & Challenger 1997] have implemented a caching system and API as part of IBM's web server that allows for caching of dynamic data. Their system allows for caching of dynamic data generated by arbitrary programs.
Reference: [Squ 1996] <institution> Squid Internet Object Cache, </institution> <year> 1996. </year> <note> http:// squid.nlanr.net/Squid/. </note>
Reference-contexts: Thus, the wide-area file system can act as a shared file cache for both the HTTP server and interested proxies, with TREC invalidations maintaining relatively strong consistency semantics. Another approach is to allow proxy caches to cache dynamic objects with a TTL-based invalidation scheme <ref> [Chankhunthod et al. 1996, Gwertzman & Seltzer 1996, Squ 1996] </ref>. <p> By contrast, unmake observes file-system activity at a low enough level that modifying tools to work with TREC is unnecessary. Recently, a large body of research is being conducted in web caching. Harvest [Chankhunthod et al. 1996] and Squid <ref> [Squ 1996] </ref> are efforts into hierarchical web proxy caching. We believe that such caching efforts would benefit from our work in dynamic object caching. Gwertzman and Seltzer [Gwertzman & Seltzer 1996] recently proposed using the Alex protocol [Cate 1992] for maintaining cache consistency across the wide area.
Reference: [Stonebraker et al. 1990] <author> M. Stonebraker, A. Jhingran, J. Goh, and S. Potamianos. </author> <title> On Rules, Procedures, Caching and Views In Database Systems. </title> <booktitle> In SIGMOD, </booktitle> <month> May </month> <year> 1990. </year>
Reference: [Vahdat et al. 1998] <author> A. Vahdat, T. Anderson, and M. Dahlin. WebOS: </author> <title> Operating System Services for Wide Area Applications. </title> <booktitle> In To appear in the Proceedings of the Seventh IEEE Symposium on High Performance Distributed Systems, </booktitle> <address> Chicago, Illi-nois, </address> <month> July </month> <year> 1998. </year>
Reference: [Widom & Finkelstein 1990] <author> J. Widom and S. J. Finkelstein. </author> <title> Set-Oriented Production Rules in Relational Database Systems. </title> <booktitle> In SIGMOD, </booktitle> <month> May </month> <year> 1990. </year>
Reference: [Zhang et al. 1997] <author> L. Zhang, S. Floyd, and V. Jacobsen. </author> <title> Adaptive Web Caching. In Web Caching Workshop. </title> <institution> National Laboratory for Applied Network Research, </institution> <month> June </month> <year> 1997. </year>
References-found: 39

