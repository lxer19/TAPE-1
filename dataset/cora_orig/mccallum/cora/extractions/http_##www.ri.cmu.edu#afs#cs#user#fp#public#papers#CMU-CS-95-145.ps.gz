URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/papers/CMU-CS-95-145.ps.gz
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/papers/
Root-URL: 
Title: A Modal Analysis of Staged Computation  
Author: Rowan Davies and Frank Pfenning 
Note: Also published as FOX Memorandum CMU-CS-FOX-95-02 This research was sponsored by the Defense Advance Research Project Agency, CSTO, under the title "The Fox Project: Advanced Development of Systems Software", ARPA Order No. 8313, issued by ESD/AVS under Contract No. F19628-91-C-0168. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the Defense Advanced Research Projects Agency or the U.S. Government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: May 1995  
Abstract: We show that a type system based on the intuitionistic modal logic S4 provides an expressive framework for specifying and analyzing computation stages in the context of functional languages. Our main technical result is a conservative embedding of Nielson & Nielson's two-level functional language in our language Mini-ML 2 , which in addition to partial evaluation also supports multiple computation stages, sharing of code across multiple stages, and run-time code generation. 
Abstract-found: 1
Intro-found: 1
Reference: [BdP92] <author> Gavin Bierman and Valeria de Paiva. </author> <title> Intuitionistic necessity revisited. </title> <booktitle> In Proceedings of the Logic at Work Conference, </booktitle> <address> Amsterdam, Holland, </address> <month> December </month> <year> 1992. </year>
Reference-contexts: The starting points for our investigation are the systems for the intuitionistic modal logic S4 in <ref> [BdP92, PW95] </ref> and the two-level -calculus in [NN92]. We augment the former with recursion to obtain Mini-ML 2 and then show that a two-level functional language may be fully and faithfully embedded in Mini-ML 2 . <p> e expresses the staging in a form that may be more directly executed. 2 MODAL ANALYSIS OF STAGED COMPUTATION 2 Modal Mini-ML: An Explicit Formulation This section presents Mini-ML 2 e , a language that combines some elements of Mini-ML [CDDK86] with a modal -calculus for intuitionistic S4, !2 e <ref> [BdP92, PW95] </ref>. The presentation of the modal constructs differs from !2 e in that we have a let form for de-constructing boxed values, and use two contexts in the typing rules. This avoids the need for syntactic substitutions, but does not alter the essential properties of the system. <p> The problem of typing the modal fragment is well understood; we present here a variant of known systems <ref> [BdP92, PW95] </ref> inspired by zonal formulations of linear logic such as Girard's LU [Gir93]. In our formulation the typing judgment has two contexts. The first contains variables that may appear anywhere, since they represent code.
Reference: [BW93] <author> Lars Birkedal and Morten Welinder. </author> <title> Partial evaluation of Standard ML. </title> <type> Technical Report DIKU-report 93/22, </type> <institution> DIKU, Department of Computer Science, University of Copenhagen, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: Our operational semantics is also rather naive from a partial evaluation point of view. In particular, we do not memoize during specialization. A memoizing semantics would be desirable for a serious implementation, and would require some restrictions on side-effects. See <ref> [BW93] </ref> for a description of a serious partial evaluator for Standard ML, which in part inspired this work. This paper does not treat polymorphism, though it seems that it should not cause any problems. We expect our type system to interact very well with ML's module system.
Reference: [CDDK86] <author> Dominique Clement, Joelle Despeyroux, Thierry Despeyroux, and Gilles Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In Proceedings of the 1986 Conference on LISP and Functional Programming, </booktitle> <pages> pages 13-27. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: be easily divided into stages, while the language Mini-ML 2 e expresses the staging in a form that may be more directly executed. 2 MODAL ANALYSIS OF STAGED COMPUTATION 2 Modal Mini-ML: An Explicit Formulation This section presents Mini-ML 2 e , a language that combines some elements of Mini-ML <ref> [CDDK86] </ref> with a modal -calculus for intuitionistic S4, !2 e [BdP92, PW95]. The presentation of the modal constructs differs from !2 e in that we have a let form for de-constructing boxed values, and use two contexts in the typing rules.
Reference: [FP91] <author> Tim Freeman and Frank Pfenning. </author> <title> Refinement types for ML. </title> <booktitle> In Proceedings of the SIGPLAN '91 Symposium on Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pages 268-277. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: We intend to study a language in which the modal types are considered refinements of the usual Mini-ML types, using intersections to express principal types (see <ref> [FP91] </ref> for analogous non-modal refinement types). Refinement type inference for this language would be a form of generalized, polyvariant binding-time analysis. Compilation would be type-directed, generating different versions of functions appropriate for different stagings of computation.
Reference: [Gir93] <author> Jean-Yves Girard. </author> <title> On the unity of logic. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 59 </volume> <pages> 201-217, </pages> <year> 1993. </year>
Reference-contexts: The problem of typing the modal fragment is well understood; we present here a variant of known systems [BdP92, PW95] inspired by zonal formulations of linear logic such as Girard's LU <ref> [Gir93] </ref>. In our formulation the typing judgment has two contexts. The first contains variables that may appear anywhere, since they represent code. The second contains variables that are only available in the current computation stage, including all ordinary Mini-ML variables.
Reference: [GJ91] <author> Carsten Gomard and Neil Jones. </author> <title> A partial evaluator for the untyped lambda-calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1) </volume> <pages> 21-69, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: This suggests that the binding-time properties of a function should be expressed in its types in a prescriptive type system, and that binding-time analysis should be a form of type checking. The work on two-level functional languages [NN92] and some work on partial evaluation (e.g. <ref> [GJ91, Hen91] </ref>) shows that this view is indeed possible and fruitful. Up to now these type systems have been motivated algorithmically, that is, they are explicitly designed to support partial evaluation. <p> This justifies the inclusion of the lift primitive in two-level languages such as in <ref> [GJ91] </ref>, and in fact in a more realistic version of our language it could also be included as a primitive. 3.4 Translation to Explicit Language We do not define an operational semantics for Mini-ML 2 directly; instead we depend upon a translation to Mini-ML 2 e . <p> Our language differs slightly from [NN92] in that we inject all run-time types into compile-time types, instead of just function types. This follows <ref> [GJ91] </ref>, where there is no such restriction. Also, we find it convenient to divide the variables and contexts into run-time and compile-time, which involves a small change in the "up" and "down" rules. <p> The two-level language we consider, Mini-ML 2 , is directly based on the one in [NN92], but has a stricter binding-time correctness criterion than used, for example, in <ref> [GJ91] </ref>. Essentially, this restriction may be traced to the fact that our underlying evaluation model applies only to closed terms, while [GJ91] seems to require evaluation of terms with free variables. <p> The two-level language we consider, Mini-ML 2 , is directly based on the one in [NN92], but has a stricter binding-time correctness criterion than used, for example, in <ref> [GJ91] </ref>. Essentially, this restriction may be traced to the fact that our underlying evaluation model applies only to closed terms, while [GJ91] seems to require evaluation of terms with free variables. Gluck and Jtrgensen [GJ95] present a multi-level binding-time analysis with the less strict binding-time correctness criterion, along with practical motivations for multi-level partial evaluation, though they do not treat higher order functions.
Reference: [GJ95] <author> Robert Gluck and Jesper Jtrgensen. </author> <title> Efficient multi-level generating extensions. </title> <type> Unpublished Manuscript, </type> <year> 1995. </year>
Reference-contexts: It is also similar to the Multi-level Generating Extensions of <ref> [GJ95] </ref>. It is interesting then to consider what the reflexitivity and transitivity assumptions model in the context of staged computation. Essentially they allow us to execute generated code at any future time, or immediately. <p> This could be avoided if memoization was employed during the compilation. 5.2 Inner Products In <ref> [GJ95] </ref> the calculation of inner products is given as an example of a program with more than two phases. We now show how this example can be coded in Mini-ML 2 . <p> Essentially, this restriction may be traced to the fact that our underlying evaluation model applies only to closed terms, while [GJ91] seems to require evaluation of terms with free variables. Gluck and Jtrgensen <ref> [GJ95] </ref> present a multi-level binding-time analysis with the less strict binding-time correctness criterion, along with practical motivations for multi-level partial evaluation, though they do not treat higher order functions.
Reference: [Hen91] <author> Fritz Henglein. </author> <title> Efficient type inference for higher-order binding-time analysis. </title> <editor> In J. Hughes, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, 5th ACM Conference, volume 523 of Lecture Notes in Computer Science, </booktitle> <pages> pages 448-472. </pages> <publisher> Springer, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1991. </year>
Reference-contexts: This suggests that the binding-time properties of a function should be expressed in its types in a prescriptive type system, and that binding-time analysis should be a form of type checking. The work on two-level functional languages [NN92] and some work on partial evaluation (e.g. <ref> [GJ91, Hen91] </ref>) shows that this view is indeed possible and fruitful. Up to now these type systems have been motivated algorithmically, that is, they are explicitly designed to support partial evaluation.
Reference: [KEH93] <author> David Keppel, Susan J. Eggers, and Robert R. Henry. </author> <title> A case for runtime code generation. </title> <type> Technical Report TR 93-11-02, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> November </month> <year> 1993. </year> <note> REFERENCES 21 </note>
Reference-contexts: The representation must support substitution of one code fragment into another, as required by the ev let box rule. If the code is machine code, this naturally leads to the idea of templates, as used in run-time code generation (see <ref> [KEH93] </ref>).
Reference: [LL94] <author> Mark Leone and Peter Lee. </author> <title> Deferred compilation: The automation of run-time code generation. </title> <booktitle> In Proceedings of the Workshop on Partial Evaluation and Semantics-based Program Manipulation (PEPM'94), </booktitle> <address> Orlando, </address> <month> June </month> <year> 1994. </year> <note> An earlier version appears as Carnegie Mellon School of Computer Science Technical Report CMU-CS-93-225, </note> <month> November </month> <year> 1993. </year>
Reference-contexts: The representation must support substitution of one code fragment into another, as required by the ev let box rule. If the code is machine code, this naturally leads to the idea of templates, as used in run-time code generation (see [KEH93]). The deferred compilation approach in <ref> [LL94] </ref> would provide a more sophisticated implementation, supporting fast run-time generation of optimized code. 6 MODAL ANALYSIS OF STAGED COMPUTATION 3 Modal Mini-ML: An Implicit Formulation We now define an implicit version Mini-ML 2 of the explicit Mini-ML 2 e , following [PW95] where an implicit system !2 was defined.
Reference: [MM94] <author> Simone Martini and Andrea Masini. </author> <title> A computational interpretation of modal proofs. </title> <editor> In H. Wansing, editor, </editor> <title> Proof theory of Modal Logics. </title> <publisher> Kluwer, </publisher> <year> 1994. </year> <note> Workshop proceedings, To appear. </note>
Reference-contexts: As an example of this translation, it maps the above definition of power to the previous explicit one. It is important to note that the operational semantics induced by the translation is very different from the natural one defined directly on Mini-ML 2 . In <ref> [MM94] </ref> a simple reduction semantics for a system similar to our implicit system is introduced which does not reflect binding time separation in any way. <p> This corresponds to a weaker modal logic, K, in which we drop the assumption in S4 that the accessibility relation is reflexive and transitive <ref> [MM94] </ref>. In fact, we can define a language Mini-ML 2 K by replacing the unbox and pop constructors with one equivalent to unbox 1 as in [MM94]. <p> This corresponds to a weaker modal logic, K, in which we drop the assumption in S4 that the accessibility relation is reflexive and transitive <ref> [MM94] </ref>. In fact, we can define a language Mini-ML 2 K by replacing the unbox and pop constructors with one equivalent to unbox 1 as in [MM94]. Then, Mini-ML 2 K closely models Mini-ML 2 , but permits an arbitrary number of phases, each of which can only execute the code generated by the immediately preceding one.
Reference: [NN92] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> Two-Level Functional Languages. </title> <publisher> Cam-bridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: This suggests that the binding-time properties of a function should be expressed in its types in a prescriptive type system, and that binding-time analysis should be a form of type checking. The work on two-level functional languages <ref> [NN92] </ref> and some work on partial evaluation (e.g. [GJ91, Hen91]) shows that this view is indeed possible and fruitful. Up to now these type systems have been motivated algorithmically, that is, they are explicitly designed to support partial evaluation. <p> The starting points for our investigation are the systems for the intuitionistic modal logic S4 in [BdP92, PW95] and the two-level -calculus in <ref> [NN92] </ref>. We augment the former with recursion to obtain Mini-ML 2 and then show that a two-level functional language may be fully and faithfully embedded in Mini-ML 2 . This verifies that Mini-ML 2 is indeed a conservative extension of the two-level language of [NN92] and thus correctly expresses standard binding-time <p> PW95] and the two-level -calculus in <ref> [NN92] </ref>. We augment the former with recursion to obtain Mini-ML 2 and then show that a two-level functional language may be fully and faithfully embedded in Mini-ML 2 . This verifies that Mini-ML 2 is indeed a conservative extension of the two-level language of [NN92] and thus correctly expresses standard binding-time separation. Following [PW95], we also sketch a compilation from Mini-ML 2 to a related language Mini-ML 2 e whose operational semantics embodies the separation of evaluation into multiple stages. <p> It is instead used to prove a Church-Rosser theorem and strong normalization for a pure modal -calculus. 4 A Two-level Language In this section we define Mini-ML 2 , a two-level functional language very close to the one described in <ref> [NN92] </ref>. We then define a simple translation into Mini-ML 2 and prove that binding-time correctness in Mini-ML 2 is equivalent to modal correctness of the translation in Mini-ML 2 . Our language differs slightly from [NN92] in that we inject all run-time types into compile-time types, instead of just function types. <p> define Mini-ML 2 , a two-level functional language very close to the one described in <ref> [NN92] </ref>. We then define a simple translation into Mini-ML 2 and prove that binding-time correctness in Mini-ML 2 is equivalent to modal correctness of the translation in Mini-ML 2 . Our language differs slightly from [NN92] in that we inject all run-time types into compile-time types, instead of just function types. This follows [GJ91], where there is no such restriction. <p> This follows [GJ91], where there is no such restriction. Also, we find it convenient to divide the variables and contexts into run-time and compile-time, which involves a small change in the "up" and "down" rules. All other differences to <ref> [NN92] </ref> are due to minor differences between their underlying language and Mini-ML. 10 MODAL ANALYSIS OF STAGED COMPUTATION 4.1 Syntax Run-time Types t ::= nat j t 1 !t 2 j t 1 fit 2 Compile-time Types ::= nat j 1 ! 2 j 1 fi 2 j t Terms e <p> : nat ` c e 3 : tpc case ` c (case e 1 of z ) e 2 | s y ) e 3 ) : ; ` r e : t ` c e : t Note that we remove run-time assumptions at the down rule, while in <ref> [NN92] </ref> this is done later at the up rule. This change is justified since by the structure of their rules, such assumptions can never be used in the compile-time deduction in between. 4.3 Translation to Implicit Modal Mini-ML The translation to Mini-ML 2 is now very simple. <p> Then, Mini-ML 2 K closely models Mini-ML 2 , but permits an arbitrary number of phases, each of which can only execute the code generated by the immediately preceding one. This is similar to the idea of B-level languages in <ref> [NN92] </ref> (with B linearly ordered), and in fact a B-level version of Mini-ML would be exactly equivalent to Mini-ML 2 K , by a natural extension of the two-level translation. It is also similar to the Multi-level Generating Extensions of [GJ95]. <p> The operational semantics of Mini-ML 2 is given by a compilation to Mini-ML 2 e . It generalizes Nielson & Nielson's two-level functional language <ref> [NN92] </ref> which is demonstrated by a conservative embedding theorem, the main technical result of this paper. The two-level language we consider, Mini-ML 2 , is directly based on the one in [NN92], but has a stricter binding-time correctness criterion than used, for example, in [GJ91]. <p> It generalizes Nielson & Nielson's two-level functional language <ref> [NN92] </ref> which is demonstrated by a conservative embedding theorem, the main technical result of this paper. The two-level language we consider, Mini-ML 2 , is directly based on the one in [NN92], but has a stricter binding-time correctness criterion than used, for example, in [GJ91]. Essentially, this restriction may be traced to the fact that our underlying evaluation model applies only to closed terms, while [GJ91] seems to require evaluation of terms with free variables.
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: As such it should allow efficient code to be generated within a more declarative style of programming, and provides an automatic check that the intended staging is achieved. We have implemented a simple version of Mini-ML 2 in the logic programming language Elf <ref> [Pfe91] </ref>.
Reference: [PW95] <author> Frank Pfenning and Hao-Chi Wong. </author> <title> On a modal -calculus for S4. </title> <editor> In S. Brookes and M. Main, editors, </editor> <booktitle> Proceedings of the Eleventh Conference on Mathematical Foundations of Programming Sematics, </booktitle> <address> New Orleans, Louisiana, </address> <month> March </month> <year> 1995. </year> <note> To appear in Electronic Notes in Theoretical Computer Science, Volume 1, Elsevier. </note>
Reference-contexts: The starting points for our investigation are the systems for the intuitionistic modal logic S4 in <ref> [BdP92, PW95] </ref> and the two-level -calculus in [NN92]. We augment the former with recursion to obtain Mini-ML 2 and then show that a two-level functional language may be fully and faithfully embedded in Mini-ML 2 . <p> This verifies that Mini-ML 2 is indeed a conservative extension of the two-level language of [NN92] and thus correctly expresses standard binding-time separation. Following <ref> [PW95] </ref>, we also sketch a compilation from Mini-ML 2 to a related language Mini-ML 2 e whose operational semantics embodies the separation of evaluation into multiple stages. <p> e expresses the staging in a form that may be more directly executed. 2 MODAL ANALYSIS OF STAGED COMPUTATION 2 Modal Mini-ML: An Explicit Formulation This section presents Mini-ML 2 e , a language that combines some elements of Mini-ML [CDDK86] with a modal -calculus for intuitionistic S4, !2 e <ref> [BdP92, PW95] </ref>. The presentation of the modal constructs differs from !2 e in that we have a let form for de-constructing boxed values, and use two contexts in the typing rules. This avoids the need for syntactic substitutions, but does not alter the essential properties of the system. <p> The problem of typing the modal fragment is well understood; we present here a variant of known systems <ref> [BdP92, PW95] </ref> inspired by zonal formulations of linear logic such as Girard's LU [Gir93]. In our formulation the typing judgment has two contexts. The first contains variables that may appear anywhere, since they represent code. <p> The deferred compilation approach in [LL94] would provide a more sophisticated implementation, supporting fast run-time generation of optimized code. 6 MODAL ANALYSIS OF STAGED COMPUTATION 3 Modal Mini-ML: An Implicit Formulation We now define an implicit version Mini-ML 2 of the explicit Mini-ML 2 e , following <ref> [PW95] </ref> where an implicit system !2 was defined. This system is more reasonable as a programming language, since we do not have to explicitly stage computation as required with let box x = E 1 in E 2 . <p> The operational semantics of the new system is given in terms of a type-preserving compilation to the explicit system. Our development differs from <ref> [PW95] </ref> in that we introduce a term constructor pop. <p> At present we have not formally proven that the translation above maps well-typed explicit terms to well-typed implicit terms. A related, slightly more complicated translation has been proven correct in <ref> [PW95] </ref>. As an example of this translation, it maps the above definition of power to the previous explicit one. It is important to note that the operational semantics induced by the translation is very different from the natural one defined directly on Mini-ML 2 .
References-found: 14

