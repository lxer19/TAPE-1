URL: ftp://ftp.cm.deakin.edu.au/pub/TR/Computing/TR-C94-31.ps.gz
Refering-URL: http://gollum.cm.deakin.edu.au/techreports.html
Root-URL: 
Title: Minor revisions of text Revision of Bibliography Revision of scope rules page 10 Revision of
Note: Reference 13 is incomplete. Used the CSIRO TR reference from Tim Jones Removed widow lines. Removed blank page. Changed header for left master page  
Date: Revised 1240, 8 Dec 94 Revised 1610, 7 Dec 94.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Ambler A. L., Burnett M. M. </author> <title> Influence of Visual Technology on the Evolution of Language Environments. </title> <journal> IEEE Computer, </journal> <volume> 22(10):922, </volume> <month> October </month> <year> 1989. </year>
Reference-contexts: The concept of providing programmers with multiple views of their program through multiple windows has been recognised as the next step in improving programming environments <ref> [1] </ref>. Such visual technology extends to visual programming languages such as PICT [7], and environments such as BALSA [2] that provide animation of algorithms during testing and debugging.
Reference: [2] <author> Brown M. H. </author> <title> Perspectives on Algorithm Animation, </title> <booktitle> Proceedings, CHI 88:Human Factors in Computing Systems, </booktitle> <pages> pages 338. </pages> <publisher> ACM Press, </publisher> <year> 1988. </year>
Reference-contexts: The concept of providing programmers with multiple views of their program through multiple windows has been recognised as the next step in improving programming environments [1]. Such visual technology extends to visual programming languages such as PICT [7], and environments such as BALSA <ref> [2] </ref> that provide animation of algorithms during testing and debugging. These points combined with the ever increasing availability of high powered graphic workstations lead to the conclusion that program visualization is an emerging field in software engineering.
Reference: [3] <author> Chen Y. F., Grass J. E. </author> <title> The C++ Information Abstractor. </title> <booktitle> Proceedings of the Second C++ Conference, </booktitle> <pages> pages 3450. </pages> <publisher> USENIX, </publisher> <month> April </month> <year> 1990. </year> <title> DUCAT: A tool for the interactive visualization of program structure 19 </title>
Reference: [4] <author> Chen Y. F., Ramamoorthy C. V. </author> <title> The C Information Abstractor. </title> <booktitle> Proceedings of the Tenth International Computer Software and Application Conference, </booktitle> <pages> pages 29198. </pages> <address> COMPAC, </address> <publisher> IEEE Computer Society Press, </publisher> <month> October </month> <year> 1986. </year>
Reference-contexts: Global dependencies may themselves refer to other global dependencies. All elements that are global in scope may be global dependencies of a container. In a C program containers are files and functions. Global dependencies that may be found in C programs are <ref> [4, 5] </ref>: global type declarations; global variables; macros; functions; and files. From the relationships between these global entities we can derive the following useful views of modular structure in C programs: Call graphs or Call hierarchies; Global function dependencies; Module dependencies; Include file hierarchies; Type hierarchies; and Independent subsystems.
Reference: [5] <author> Chen Y.F., Nishimoto M. Y., Ramamoorthy C. V. </author> <title> The C Information Abstraction System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3):32534, </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: Global dependencies may themselves refer to other global dependencies. All elements that are global in scope may be global dependencies of a container. In a C program containers are files and functions. Global dependencies that may be found in C programs are <ref> [4, 5] </ref>: global type declarations; global variables; macros; functions; and files. From the relationships between these global entities we can derive the following useful views of modular structure in C programs: Call graphs or Call hierarchies; Global function dependencies; Module dependencies; Include file hierarchies; Type hierarchies; and Independent subsystems. <p> Based on this and the fact that Reprise is designed as an information base for other tools Rosenblum and Wolf [18] indicate that Reprise and CIA++ <ref> [5] </ref> are very similar tools. However CIA++ only constructs a database about nonlocal entities in a C++ program where Reprise represents all syntax and semantics of the program. Reprise can be used as a basis for almost any type of programming or analysis tool.
Reference: [6] <author> Cordy J. R., Eliot N. L. Robertson M. G. TuringTool: </author> <title> A User Interface to aid the Software Maintenance Task. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3):294301, </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: However, they do not allow the programmer to extract information about program structure. Examples of such tools are the Maintainers Assistant [22] and TuringTool <ref> [6] </ref>. Integrated environments such as Pecan [16] and PegaSys [14] provide some limited graphical views of a programs structure, but provide very little navigation between the views. A more relevant group of tools extract structural information as it is needed, either for immediate presentation or for use by other tools.
Reference: [7] <author> Glinert E. P., Tanimoto S. L. </author> <title> Pict: An Interactive Graphical Programming Environment. </title> <booktitle> Computer, </booktitle> <address> 17(11):725, </address> <month> November </month> <year> 1984. </year>
Reference-contexts: The concept of providing programmers with multiple views of their program through multiple windows has been recognised as the next step in improving programming environments [1]. Such visual technology extends to visual programming languages such as PICT <ref> [7] </ref>, and environments such as BALSA [2] that provide animation of algorithms during testing and debugging. These points combined with the ever increasing availability of high powered graphic workstations lead to the conclusion that program visualization is an emerging field in software engineering.
Reference: [8] <author> Harrold M. J., Soffa M. L. </author> <title> Computation of Interprocedural Definition and Use Dependencies. </title> <booktitle> Proceedings of the 1990 IEEE International Conference on Computer Languages, </booktitle> <pages> pages 297 306. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1990. </year>
Reference: [9] <author> Horwitz S., Reps T. </author> <title> The Use of Program Dependence Graphs in Software Engineering. </title> <booktitle> Proceedings of the Fourteenth International Conference on Software Engineering, </booktitle> <pages> pages 392410, </pages> <address> Mel-bourne, Australia, May 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Control structure is the flow of control represented by the individual statements in a program. Some well established representations of control structure are: Flow charts; Nassi-Shneiderman diagrams; and Program dependence graphs <ref> [9] </ref>. Since modular structure is an overlay on control structure the scope of a structure analysis tool may be concerned with modular structure, control structure or both.
Reference: [10] <author> Jones T., Allison W., Carrington D. </author> <title> Relational Views for Program Comprehension. </title> <booktitle> 3rd Workshop on Program Comprehension, </booktitle> <address> Washington D.C., November 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [11] <author> Kay J., Kummerfeld B. </author> <title> C Programming in a Unix Environment. </title> <publisher> Addison-Wesley, </publisher> <address> Sydney, </address> <year> 1989. </year>
Reference-contexts: The same names for different identifier types can be differentiated as follows <ref> [11] </ref>: Functions and variables may have the same label but can be differentiated because function labels must be followed by ()s; Types must not be the same as variables or functions; Structures, unions and enumerations do not have to have unique identifiers but can be differentiated from other identifiers because they <p> Another very important point is that macros and enumerators can be redefined. A reference to a macro or enumerator is to the most recent definition. The following is a list of rules which defines the global scope of identifiers in C <ref> [11] </ref>: The scope of an automatic variable is restricted to the block in which it is declared.
Reference: [12] <author> Keables J., Roberson K., Mayrhauser A. </author> <title> Data Flow Analysis and its Application to Software Maintenance. </title> <booktitle> Proceedings of the 88 Conference on Software Maintenance, </booktitle> <pages> pages 33547, </pages> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1988. </year> <journal> IEEE Computer Society. </journal>
Reference: [13] <author> Lin T., Eades P., </author> <title> Integration of Declarative and Algorithmic Approaches for Layout Creation, </title> <institution> Information Technology Technical Report TR-HJ-94-10, Division of Information Technology, CSIRO, Canberra, Australia. </institution>
Reference-contexts: The major issues are described by Lin and Eades in <ref> [13] </ref>. They are: Readability - the layout must be aesthetically pleasing.
Reference: [14] <author> Moriconi M., Hare D. F. </author> <title> Pegasys: A System for Graphical Explanation of Program Designs. </title> <journal> SIG-PLAN Notices, </journal> <volume> 20(7):14860, </volume> <month> July </month> <year> 1985. </year> <booktitle> ACM SIGPLAN Symposium on Language Issues in Programming Environments. </booktitle>
Reference-contexts: However, they do not allow the programmer to extract information about program structure. Examples of such tools are the Maintainers Assistant [22] and TuringTool [6]. Integrated environments such as Pecan [16] and PegaSys <ref> [14] </ref> provide some limited graphical views of a programs structure, but provide very little navigation between the views. A more relevant group of tools extract structural information as it is needed, either for immediate presentation or for use by other tools.
Reference: [15] <author> Podgurski A., Clarke L. A. </author> <title> A Formal Model of Program Dependencies and its Implications for Software Testing, Debugging and Maintenance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9):96579, </volume> <month> September </month> <year> 1990. </year>
Reference: [16] <author> Reiss S.P. </author> <title> Pecan: Program Development Systems that support Multiple Views. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(3):27684, </volume> <month> March </month> <year> 1985. </year>
Reference-contexts: However, they do not allow the programmer to extract information about program structure. Examples of such tools are the Maintainers Assistant [22] and TuringTool [6]. Integrated environments such as Pecan <ref> [16] </ref> and PegaSys [14] provide some limited graphical views of a programs structure, but provide very little navigation between the views. A more relevant group of tools extract structural information as it is needed, either for immediate presentation or for use by other tools.
Reference: [17] <author> Roman G., Cox K. C. </author> <title> A Taxonomy of Program Visualization Systems. </title> <journal> IEEE Computer, </journal> <volume> 26(12):1124, </volume> <month> December </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Roman and Cox <ref> [17] </ref> define program visualization as the mapping of programs to graphical representations. They point out that visualization is one of the most powerful methods of human communication, and emphasise the power of abstraction that is in a visual form.
Reference: [18] <author> Rosenblum D. S., Wolf A. L. </author> <title> Representing Semantically Analysed C++ Code with REPRISE. </title> <booktitle> Proceedings of the USENIX C++ Conference, </booktitle> <pages> pages 11934. </pages> <publisher> USENIX, </publisher> <month> April </month> <year> 1991. </year>
Reference-contexts: A more relevant group of tools extract structural information as it is needed, either for immediate presentation or for use by other tools. Examples are cflow, cxref, and calls [21, [20]; The C Information Abstraction System (CIA) [4][5][3]; and Reprise <ref> [18] </ref>. Each of these tools differ in the following aspects: what information they produce; how they produce the information; and how they provide the information to the user and/or other tools. <p> Based on this and the fact that Reprise is designed as an information base for other tools Rosenblum and Wolf <ref> [18] </ref> indicate that Reprise and CIA++ [5] are very similar tools. However CIA++ only constructs a database about nonlocal entities in a C++ program where Reprise represents all syntax and semantics of the program. Reprise can be used as a basis for almost any type of programming or analysis tool.
Reference: [19] <author> Schwanke R. W., Platoff M. A. </author> <title> Cross References are Features. </title> <booktitle> ACM 2nd International Workshop on Software Configuration Management, </booktitle> <pages> pages 8695, </pages> <publisher> Princeton, </publisher> <editor> N. J., </editor> <month> October </month> <year> 1989. </year> <note> ACM Press. 20 References </note>
Reference: [20] <author> Sobel M. G. </author> <title> A Practical Guide to the Unix System. </title> <booktitle> Series in Computing and Information Science. </booktitle> <publisher> The Benjamin/Cummings Publishing Company, </publisher> <address> Redwood City, California 94065, 2nd edition, </address> <year> 1989. </year>
Reference-contexts: A more relevant group of tools extract structural information as it is needed, either for immediate presentation or for use by other tools. Examples are cflow, cxref, and calls [21, <ref> [20] </ref>; The C Information Abstraction System (CIA) [4][5][3]; and Reprise [18]. Each of these tools differ in the following aspects: what information they produce; how they produce the information; and how they provide the information to the user and/or other tools. <p> This relieves the programmer from having to use a tool such as grep <ref> [20] </ref> to search every file in the system to find this type of information. Unfortunately graphical representations of queries can only be achieved by executing a command line call to various programs, specifying the relationships to be viewed.
Reference: [21] <author> Sun Microsystems. </author> <title> SunOS Reference Manual. </title> <type> Technical report, </type> <institution> Sun Microsystems Inc., </institution> <year> 1990. </year>
Reference-contexts: A more relevant group of tools extract structural information as it is needed, either for immediate presentation or for use by other tools. Examples are cflow, cxref, and calls <ref> [21, [20] </ref>; The C Information Abstraction System (CIA) [4][5][3]; and Reprise [18]. Each of these tools differ in the following aspects: what information they produce; how they produce the information; and how they provide the information to the user and/or other tools.
Reference: [22] <author> Ward M., Calliss F. W., Munro M. </author> <title> The Maintainers Assistant. </title> <booktitle> Proceedings: Conference on Software Maintenance, </booktitle> <pages> pages 30715. </pages> <publisher> IEEE Computing Press, </publisher> <month> October </month> <year> 1989. </year>
Reference-contexts: Many program development tools allow the programmer to abstract code for the purpose of gaining greater understanding of its functionality by simplifying navigation through the source code. However, they do not allow the programmer to extract information about program structure. Examples of such tools are the Maintainers Assistant <ref> [22] </ref> and TuringTool [6]. Integrated environments such as Pecan [16] and PegaSys [14] provide some limited graphical views of a programs structure, but provide very little navigation between the views.
Reference: [23] <author> Weiser M. </author> <title> Program Slicing. </title> <booktitle> Proceedings of the 5th International Conference on Software Engineering, </booktitle> <pages> pages 43949, </pages> <address> San Diego, California, March 1981. </address> <publisher> IEEE Computer Society. </publisher>
Reference: [24] <author> Weiser M. </author> <title> Programmers use Slices when Debugging. </title> <journal> Communications of the ACM, </journal> <volume> 25(7):446 52, </volume> <month> July </month> <year> 1982. </year>
Reference: [25] <author> Wilde N. </author> <title> Understanding Program Dependencies. Curriculum Module SEI-CM-26, </title> <institution> Camegie Mellon University, </institution> <month> August </month> <year> 1990. </year>
Reference: [26] <author> Yau S. S. </author> <title> Methodology for Software Maintenance. </title> <type> Technical Report RADT-TR-83-262, </type> <institution> Rome Air Development Centre, Griffis Air Force Base N. Y., </institution> <month> February </month> <year> 1984. </year>
Reference: [27] <author> Yau S. S., Collofello J. S., MacGregor T. </author> <title> Ripple Effect Analysis of Software Maintenance. </title> <booktitle> Proceedings of COMPSAC 78, </booktitle> <pages> pages 6065. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1978. </year>
Reference: [28] <author> Yourdon E., Constantine L. L. </author> <title> Structured Design: Fundementals of a Discipline of Computer Program and System Design. </title> <publisher> Yourdon Press, </publisher> <address> 2nd edition, </address> <year> 1978. </year> <title> DUCAT: A tool for the interactive visualization of program structure 21 </title>
Reference-contexts: Type hierarchies show a hierarchy of type declarations. Independent subsystems are groups of objects which have no global dependencies outside the group identified. Identifying subsystems is very important for reuse and for grouping objects into modules <ref> [28] </ref>. DUCAT: A tool for the interactive visualization of program structure 3 Each of these relationships offer the programmer a different view of the structure of a program, based on the dependencies of each object in the system.
References-found: 28

