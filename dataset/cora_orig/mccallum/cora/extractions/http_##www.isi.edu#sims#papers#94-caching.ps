URL: http://www.isi.edu/sims/papers/94-caching.ps
Refering-URL: http://www.isi.edu/~knoblock/
Root-URL: 
Email: farens, knoblockg@isi.edu  
Phone: 310-822-1511  
Title: Intelligent Caching: Selecting, Representing, and Reusing Data in an Information Server  
Author: Yigal Arens and Craig A. Knoblock ; 
Address: 4676 Admiralty Way Marina del Rey, CA  
Affiliation: 1 Information Sciences Institute and 2 Department of Computer Science University of Southern California  
Abstract: Accessing information sources to retrieve data requested by a user can be expensive, especially when dealing with distributed information sources. One way to reduce this cost is to cache the results of queries, or related classes of data. This paper presents an approach to caching and addresses the issues of which information to cache, how to describe what has been cached, and how to use the cached information to answer future queries. We consider these issues in the context of the SIMS information server, which is a system for retrieving information from multiple heterogeneous and distributed information sources. The design of this information server is ideal for representing and reusing cached information since each class of cached information is simply viewed as another information source that is available for answering future queries. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Yigal Arens, Chin Y. Chee, Chun-Nan Hsu, and Craig A. Knoblock. </author> <title> Retrieving and integrating data from multiple information sources. </title> <journal> International Journal on Intelligent and Cooperative Information Systems, </journal> <volume> 2(2) </volume> <pages> 127-158, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction The SIMS project <ref> [1, 4] </ref> is addressing the problem of accessing information stored in heterogeneous distributed sources databases and knowledge bases in a convenient, transparent, and efficient manner. <p> Joins within Loom are more costly both because data from several sources must be moved to Loom, and because Loom's reasoning is slower. Details, including discussions of what happens if the simplifying assumptions made above are not met, are provided in <ref> [1] </ref>. 2.1 What to Cache in this Example? Offhand, one might consider the classes listed below as potential ones to cache for future use. <p> However, it is our position that such a semantic model is an absolute requirement for any serious attempt to attack the problem of accessing heterogeneous distributed information sources in a convenient, transparent and efficient manner. We demonstrate the capabilities of such modeling in <ref> [1] </ref>. We believe that the issue of caching will become even more pressing in the near future. Computer networks are spreading at a high rate, and their use for disseminating information is growing. Networks like the Internet are very slow when compared to communication directly with a local DB.
Reference: [2] <author> Michael J. Carey, Michael J. Franklin, Miron Livny, and Eugene J. Shekita. </author> <title> Data caching tradeoffs in client-server DBMS architectures. </title> <editor> In James Clifford and Roger King, editors, </editor> <booktitle> Proceedings of the 1991 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 357-366, </pages> <address> Denver, CO, </address> <year> 1991. </year>
Reference-contexts: It might appear at first glance that one should simply consider caching the data for which the user's query asked, or some structurally/syntactically determined subset of it - after all, it is going to be retrieved anyway. This approach is taken in other systems <ref> [3, 11, 2] </ref>. It is the only reasonable approach available when the only way to index/classify the cached data is by the query it corresponds to. <p> There has been other work that deals with the issue of caching in an information server environment, but this work has focused on the issue of maintaining the consistency of client cached data <ref> [11, 2] </ref>. <p> There are two considerations involved: First, we wish to avoid caching too much information in the knowledge representation system, as mentioned earlier. Second, databases get updated, and the cached information will likely not remain valid indefinitely <ref> [11, 2] </ref>. To address the first point, we intend to employ a system of tracking the actual usage of cached classes and eliminating those that are not used often enough.
Reference: [3] <author> Sheldon Finkelstein. </author> <title> Common expression analysis in database applications. </title> <editor> In Schkolnick, editor, </editor> <booktitle> Proceedings of ACM SIGMOD, </booktitle> <pages> pages 235-245, </pages> <year> 1982. </year>
Reference-contexts: It might appear at first glance that one should simply consider caching the data for which the user's query asked, or some structurally/syntactically determined subset of it - after all, it is going to be retrieved anyway. This approach is taken in other systems <ref> [3, 11, 2] </ref>. It is the only reasonable approach available when the only way to index/classify the cached data is by the query it corresponds to. <p> the data returned for this query is not even a subset of obtained for the first one the typical situation caching is envisioned for. 6 Related Work The most closely related work on caching in the database literature is the work by Finkelstein on the topic of common subexpression analysis <ref> [3] </ref>. Finkelstein presents an approach to reusing previously retrieved data to answer queries or subexpressions of queries. His approach is to cache the results of queries and then look for subexpressions of a new query that match classes of previously cached data and reuse that data where appropriate.
Reference: [4] <author> Chun-Nan Hsu and Craig A. Knoblock. </author> <title> Reformulating query plans for multidatabase systems. </title> <booktitle> In Proceedings of the Second International Conference of Information and Knowledge Management, </booktitle> <address> Washington, D.C., 1993. </address> <publisher> ACM. </publisher>
Reference-contexts: 1 Introduction The SIMS project <ref> [1, 4] </ref> is addressing the problem of accessing information stored in heterogeneous distributed sources databases and knowledge bases in a convenient, transparent, and efficient manner. <p> In the example above the port-name, depth, and location are relevant to the port class. The threshold is then used to decide whether the relations on some class have been 1 A similar reevaluation and purging process takes place with SIMS' learned reformulation rules <ref> [4] </ref>. accessed frequently enough in previous queries to be considered relevant. If certain information has never been accessed, then it is probably not worth retrieving and caching. * For a given query, the server splits the query into components, each corresponding to the individual domain-level concepts that comprise the query.
Reference: [5] <author> Chun-Nan Hsu and Craig A. Knoblock. </author> <title> Rule induction for semantic query optimization. </title> <booktitle> In Proceedings of the Eleventh International Conference on Machine Learning, </booktitle> <address> San Mateo, CA, 1994. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: This follows a process similar to that which we already use with learned abstractions of information source contents, structures that are used elsewhere in SIMS <ref> [5] </ref>. The second point cannot be addressed until SIMS includes in its Loom representation of information sources details about their update frequency and the temporal persistence of their contents. We view these topics as areas for future research.
Reference: [6] <author> Robert MacGregor. </author> <title> A deductive pattern matcher. </title> <booktitle> In Proceedings of AAAI-88, The National Conference on Artificial Intelligence, </booktitle> <address> St. Paul, MN, </address> <year> 1988. </year>
Reference-contexts: Queries to SIMS are expressed in the Loom language. Loom <ref> [6, 7] </ref> is a member of the KL-ONE family of knowledge representation systems. In Loom objects in the world are grouped into classes and there are a set of relations that describe the relationships and properties of classes.
Reference: [7] <author> Robert MacGregor. </author> <title> The evolving technology of classification-based knowledge representation systems. </title> <editor> In John Sowa, editor, </editor> <booktitle> Principles of Semantic Networks: Explorations in the Representation of Knowledge. </booktitle> <publisher> Mor-gan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: Queries to SIMS are expressed in the Loom language. Loom <ref> [6, 7] </ref> is a member of the KL-ONE family of knowledge representation systems. In Loom objects in the world are grouped into classes and there are a set of relations that describe the relationships and properties of classes.
Reference: [8] <author> Donald P. McKay, Timothy W. Finin, and Anthony O'Hare. </author> <title> The intelligent database interface: Integrating AI and database systems. </title> <booktitle> In Proceedings of the Eighth National Conference on Artificial Intelligence, </booktitle> <address> Boston, MA, </address> <year> 1990. </year>
Reference-contexts: Determine if and when joins must be performed and that the available information supports them (e.g., in this case, that the units of depth and draft are the same). 5. Send appropriate queries to the respective information sources (the LIM/IDI <ref> [8, 10] </ref> system is used to generate queries to relational databases) and manipulate the results as necessary to obtain the precise data requested by the user. Generally speaking, SIMS attempts to obtain the required information using as few information sources as possible and to avoid joins performed locally (in Loom).
Reference: [9] <author> M.A. Merzbacher and W.W. Chu. </author> <title> Query-based semantic nearness for cooperative query answering. </title> <booktitle> In In Proceedings of the ISMM International Conference on Information and Knowledge Management, CIKM-92, </booktitle> <pages> pages 361-368, </pages> <address> Baltimore, MD, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: This is a common situation with cooperative query-answering systems <ref> [9] </ref>. There are several problems that must be considered in order to assure that data can be efficiently cached and reused: 1. First, one needs a scheme for selecting an appropriate set of information to cache based on a user's query.
Reference: [10] <author> Jon A. Pastor, Donald P. McKay, and Timothy W. Finin. View-concepts: </author> <title> Knowledge-based access to databases. </title> <booktitle> In Proceedings of the First International Conference on Information and Knowledge Management, </booktitle> <pages> pages 84-91, </pages> <address> Baltimore, MD, </address> <year> 1992. </year>
Reference-contexts: Determine if and when joins must be performed and that the available information supports them (e.g., in this case, that the units of depth and draft are the same). 5. Send appropriate queries to the respective information sources (the LIM/IDI <ref> [8, 10] </ref> system is used to generate queries to relational databases) and manipulate the results as necessary to obtain the precise data requested by the user. Generally speaking, SIMS attempts to obtain the required information using as few information sources as possible and to avoid joins performed locally (in Loom).
Reference: [11] <author> Kevin Wilkinson and Marie-Anne Neimat. </author> <title> Maintaining consistency of client-cached data. </title> <editor> In Dennis McLeod, Ron Sacks-Davis, and Hans Schek, editors, </editor> <booktitle> Proceedings of the 16th International Conference on Very Large Data Bases, </booktitle> <pages> pages 122-133, </pages> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: It might appear at first glance that one should simply consider caching the data for which the user's query asked, or some structurally/syntactically determined subset of it - after all, it is going to be retrieved anyway. This approach is taken in other systems <ref> [3, 11, 2] </ref>. It is the only reasonable approach available when the only way to index/classify the cached data is by the query it corresponds to. <p> There has been other work that deals with the issue of caching in an information server environment, but this work has focused on the issue of maintaining the consistency of client cached data <ref> [11, 2] </ref>. <p> There are two considerations involved: First, we wish to avoid caching too much information in the knowledge representation system, as mentioned earlier. Second, databases get updated, and the cached information will likely not remain valid indefinitely <ref> [11, 2] </ref>. To address the first point, we intend to employ a system of tracking the actual usage of cached classes and eliminating those that are not used often enough.
References-found: 11

