URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1996/UM-CS-1996-017.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/96-017.html
Root-URL: 
Email: email: -chamilla|clarke-@cs.umass.edu  
Title: Improving the Accuracy of Petri Net-based Analysis of Concurrent Programs  
Author: A. T. Chamillard Lori A. Clarke 
Address: Amherst, MA 01003  
Affiliation: Department of Computer Science University of Massachusetts, Amherst  
Abstract: In general, we would like any static analysis method to be conservative ; for a given property, the analysis must not overlook cases where the property fails to hold. To ensure conservativeness, methods typically use program representations that overestimate the behavior of the program being analyzed. As a result, these methods may produce spurious results - that is, report that a property fails when in fact the cases in which it fails do not correspond to actual program behaviors. Usually, an analysis method produces a spurious result as a consequence of considering paths that can never be executed in the program (commonly called infeasible paths ) or of considering aliasing that can never occur in the program. For an example of an infeasible path, consider the program in Figure 1. In the caller2 task, the path through the true branch of the first conditional and the false branch of the second conditional is infeasible, assuming the value of BranchCond does not change between the two conditionals. Infeasible paths are natural phenomena of the internal representations we use for analysis and are usually not indicative of a fault in the code. Abstract Spurious results are an inherent problem of most static analysis methods. These methods, in an effort to produce conservative results, overestimate the executable behavior of a program. Infeasible paths and imprecise alias resolution are the two causes of such inaccuracies. In this paper we present an approach for improving the accuracy of Petri net-based analysis of concurrent programs by including additional program state information in the Petri net. We present empirical results that demonstrate the improvements in accuracy and, in some cases, the reduction in the search space that result from applying this approach to concurrent Ada programs. 
Abstract-found: 1
Intro-found: 1
Reference: [ABC+91] <author> George S. Avrunin, Ugo A. Buy, James C. Corbett, Laura K. Dillon, and Jack C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Transactions on Software Engineering , 17(11) </journal> <pages> 1204-1222, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Finally, we use the Petri net to generate a reachability graph to represent an estimate of all states the program can enter when started in the initial The Constrained Expression method <ref> [ABC+91] </ref> avoids representing the state space of the program altogether. Selected program behavior and a set of necessary conditions for the property of interest are expressed as a system of inequalities, and integer linear programming techniques are used to determine whether the necessary conditions can be satisfied by the program.
Reference: [DC94] <author> Matthew B. Dwyer and Lori A. Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <booktitle> In Proceedings of the Second ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 62-75, </pages> <address> New Orleans, Louisiana, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: One proposed approach is to combine reachability analysis with symbolic execution to prune infeasible paths from the estimated reachable state space [YT88]. Symbolic execution, however, is an expensive method that can not be guaranteed to determine feasibility. Our approach entails straightforward extensions of the Petri net representation. properties <ref> [TO80, RS90, MR91, CK93, DC94] </ref>. Infeasible synchronization events can be excluded from consideration by identifying program statements that can not execute concurrently [MR93]. <p> Infeasible synchronization events can be excluded from consideration by identifying program statements that can not execute concurrently [MR93]. An approach, similar to the approach described here, is being explored where the number of infeasible paths is reduced by including selected information about program paths and program variable values <ref> [DC94] </ref>. This approach encodes the information with the property, whereas our approach encodes the information in the program representation. Other proposed approaches use program variable value information to exclude some infeasible paths from consideration [BDF92, DBD+94]. <p> Additionally, the effect of modeling selected variable values is not quantified in [BDF92] or [DBD+94], while Section 5 below compares the sizes of reachability graphs generated with and without modeling of selected variable values. An advantage of our approach and that described in <ref> [DC94] </ref> is that they provide a flexible means for incrementally including additional program state information to improve the accuracy of the analysis. After examining the anomaly report from an analysis run, an analyst can specify additional information to be included to improve the accuracy of the results as needed. <p> It is not as easy to modify the semantics of other internal representations that are commonly used for analysis, such as control flow graphs, abstract syntax trees, and program dependency graphs. A complementary and somewhat similar approach is explored in <ref> [DC94] </ref>, but instead of modifying the internal representation, the approach incorporates the additional semantic constraints in the analysis algorithms. Similarly, information about impossible pairs or variable values could be incorporated in the reachability graph generation algorithm rather than in the Petri net representation of the program.
Reference: [BCM+90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking : 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science , pages 428-439, </booktitle> <year> 1990. </year>
Reference-contexts: In addition, the analyst can choose whether to represent this additional information in terms of control or data information, depending on which representation is best suited to the situation at hand. Symbolic model checking methods <ref> [BCM+90] </ref> represent the program state space symbolically rather than explicitly. With this method, the program to be analyzed is modeled using Binary Decision Diagrams (BDDs), and the property of interest is specified by a formula.
Reference: [DCN95] <author> Matthew B. Dwyer, Lori A. Clarke, and Kari A. Nies. </author> <title> A compact petri net representation for concurrent programs. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Software Engineering, </booktitle> <address> Seattle, Washington, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: The set of reachable program states can be generated using a variety of program representations, including flow graphs [Tay83a, YTF+89] and Petri nets <ref> [Pet77, SC88, DCN95] </ref>. Theoretical results [Tay83b] imply that, in general, the time and space requirements for this method are exponential. <p> The nodes in the TIG for a task are connected by edges representing possible interactions (entry calls/accepts) between that task and other tasks in the program. We then combine the set of TIGs for all the tasks in a program into a Petri net <ref> [DCN95] </ref> to model the system as a whole. Finally, we use the Petri net to generate a reachability graph to represent an estimate of all states the program can enter when started in the initial The Constrained Expression method [ABC+91] avoids representing the state space of the program altogether. <p> We use TIG-based Petri Nets (TPNs) because it has been shown that TPNs substantially reduce the size of the Petri net, thereby increasing the size of the programs that can be successfully analyzed <ref> [DCN95] </ref>. Although this example is small, in general Petri nets can be extremely complex and are not usually visualized. Petri Nets Petri nets have been proposed as a natural and powerful model of information flow in a system [Pet77].
Reference: [BDF92] <author> Gianfranco Balbo, Susanna Donatelli, and Giuliana Franceschinis. </author> <title> Understanding parallel program behavior through petri net models. </title> <journal> Journal of Parallel and Distributed Computing , 15(3) </journal> <pages> 171-187, </pages> <month> July </month> <year> 1992. </year> <editor> [GMO76] Harold N. Gabow, Shachindra N. Maheshwari, and Leon J. </editor> <title> Osterweil. On two problems in the generation of program test paths. </title> <journal> IEEE Transactions on Software Engineering , SE-2(3):227-231, </journal> <month> September </month> <year> 1976. </year>
Reference-contexts: This approach encodes the information with the property, whereas our approach encodes the information in the program representation. Other proposed approaches use program variable value information to exclude some infeasible paths from consideration <ref> [BDF92, DBD+94] </ref>. These approaches assume that, if a variable value is to be modeled, that value is always statically determinable. This assumption seems overly restrictive in general. <p> This assumption seems overly restrictive in general. In contrast, our variable value technique accounts for regions in which the value is not statically determinable, but can only improve accuracy in regions in which the value is determinable. Additionally, the effect of modeling selected variable values is not quantified in <ref> [BDF92] </ref> or [DBD+94], while Section 5 below compares the sizes of reachability graphs generated with and without modeling of selected variable values.
Reference: [Cha95] <author> A.T. Chamillard. </author> <title> Improving static analysis accuracy on concurrent Ada programs: Complexity results and empirical findings. </title> <type> Technical Report TR 95-49, </type> <institution> University of Massachusetts, Amherst, </institution> <year> 1995. </year>
Reference-contexts: A Petri net is called safe if each place in the Petri net can contain at most one token. Safety is a desirable property, because safe Petri nets are guaranteed to have a finite number of reachable states. It has been shown that TPNs are safe <ref> [Cha95] </ref>. Reachability Graphs Often, developers want to determine whether or not the concurrent program being analyzed could potentially enter a state in which a specified property is violated; for instance, is it possible for the program to enter a state in which it deadlocks. <p> Impossible pairs identification is concerned with identifying invalid sequences of statements, whereas CHT analysis is concerned with identifying statements that can not execute concurrently. To simplify our explanation, we assume a single impossible pair in the program but note that the technique can be extended to multiple impossible pairs <ref> [Cha95] </ref>. Also note that, using the same basic technique, more complicated flow constraints than impossible pairs could be incorporated given Petri net representations of those constraints. The technique described below involves representing additional program state information to eliminate infeasible paths that contain both members of an impossible pair.
Reference: [HL85] <author> D. Helmbold and D.C. Luckham. </author> <title> Debugging Ada tasking programs. </title> <booktitle> IEEE Software , pages 47-57, </booktitle> <month> March </month> <year> 1985. </year>
Reference-contexts: The notation rwXY indicates an instance of the readers/writers problem with X readers and Y writers. The code for readers/writers programs is fairly standard, with a Boolean variable WriterPresent used to track the presence of a writer. The notation gasXY indicates an instance of the standard gas station problem <ref> [HL85] </ref> with The effects of using these techniques for the sample programs can be found in Table 1. In the table, NA means that no additional information is included in the Petri net for the program.
Reference: [LC89] <author> Douglas L. Long and Lori A. Clarke. </author> <title> Task interaction graphs for concurrency analysis. </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering , pages 44-52, </booktitle> <address> Pittsburgh PA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Our static analysis method builds upon a variety of internal representations of a concurrent Ada program to capture information about the program. First, we represent each task with a Task Interaction Graph (TIG) <ref> [LC89] </ref>, which abstracts sequential regions of control flow into single nodes. The nodes in the TIG for a task are connected by edges representing possible interactions (entry calls/accepts) between that task and other tasks in the program.
Reference: [YT88] <author> Michal Young and Richard N. Taylor. </author> <title> Combining static concurrency analysis with symbolic execution. </title> <journal> IEEE Transactions on Software Engineering , 14(10) </journal> <pages> 1499-1511, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: The basic idea is to introduce information about the states that the program being analyzed can reachability analysis. One proposed approach is to combine reachability analysis with symbolic execution to prune infeasible paths from the estimated reachable state space <ref> [YT88] </ref>. Symbolic execution, however, is an expensive method that can not be guaranteed to determine feasibility. Our approach entails straightforward extensions of the Petri net representation. properties [TO80, RS90, MR91, CK93, DC94]. Infeasible synchronization events can be excluded from consideration by identifying program statements that can not execute concurrently [MR93].
Reference: [MR91] <author> Stephen P. Masticola and Barbara G. Ryder. </author> <title> A model of Ada programs for static deadlock detection in polynomial time. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Debugging , pages 97-107, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: One proposed approach is to combine reachability analysis with symbolic execution to prune infeasible paths from the estimated reachable state space [YT88]. Symbolic execution, however, is an expensive method that can not be guaranteed to determine feasibility. Our approach entails straightforward extensions of the Petri net representation. properties <ref> [TO80, RS90, MR91, CK93, DC94] </ref>. Infeasible synchronization events can be excluded from consideration by identifying program statements that can not execute concurrently [MR93].
Reference: [YTF+89] <author> Michal Young, Richard N. Taylor, Kari Forester, and Debra Brodbeck. </author> <title> Integrated concurrency analysis in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT '89 Third Symposium on Testing, Analysis and Verification (TAV3), </booktitle> <pages> pages 200-209, </pages> <note> 1989. </note> <author> [MR93] Stephen P. Masticola and Barbara G. Ryder. </author> <title> Non-concurrency analysis. </title> <booktitle> In Proceedings of the ACM Symposium on Principles and Practices of Parallel Programming (PPOPP) , 1993. </booktitle>
Reference-contexts: Reachability analysis checks whether a selected property, often called the property of interest , can occur in a concurrent program by considering all reachable states of the program being analyzed. The set of reachable program states can be generated using a variety of program representations, including flow graphs <ref> [Tay83a, YTF+89] </ref> and Petri nets [Pet77, SC88, DCN95]. Theoretical results [Tay83b] imply that, in general, the time and space requirements for this method are exponential.
Reference: [Pet77] <author> James L. Peterson. </author> <title> Petri nets. </title> <journal> Computing Surveys , 9(3) </journal> <pages> 223-252, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: The set of reachable program states can be generated using a variety of program representations, including flow graphs [Tay83a, YTF+89] and Petri nets <ref> [Pet77, SC88, DCN95] </ref>. Theoretical results [Tay83b] imply that, in general, the time and space requirements for this method are exponential. <p> Although this example is small, in general Petri nets can be extremely complex and are not usually visualized. Petri Nets Petri nets have been proposed as a natural and powerful model of information flow in a system <ref> [Pet77] </ref>. A Petri net can be represented as a 5-tuple (P, T, I, O, M0). P is the set of places in the Petri net, where a place can hold zero or more tokens. If a place holds one or more tokens, the place is said to be marked .
Reference: [Pet81] <author> James L. Peterson. </author> <title> Petri Net Theory and the Modeling of Systems . Prentice-Hall, </title> <year> 1981. </year>
Reference-contexts: To make the resulting subnet safe, we modify the Petri net to ensure the operation places can never contain more than one token, using transformations similar to those described by Peterson <ref> [Pet81] </ref>. For every operation place for the variable, we add an operation prime place, yielding two places for each possible operation on the variable. For each transition with an operation place as an output, we add the corresponding operation prime place as an input.
Reference: [RS90] <author> John H. Reif and Scott A. Smolka. </author> <title> Data flow analysis of distributed communicating processes. </title> <booktitle> International Journal of Parallel Programming , 19(1) </booktitle> <pages> 1-30, </pages> <year> 1990. </year>
Reference-contexts: One proposed approach is to combine reachability analysis with symbolic execution to prune infeasible paths from the estimated reachable state space [YT88]. Symbolic execution, however, is an expensive method that can not be guaranteed to determine feasibility. Our approach entails straightforward extensions of the Petri net representation. properties <ref> [TO80, RS90, MR91, CK93, DC94] </ref>. Infeasible synchronization events can be excluded from consideration by identifying program statements that can not execute concurrently [MR93].
Reference: [SC88] <author> S.M. Shatz and W.K. Cheng. </author> <title> A petri net framework for automated static analysis of Ada tasking behavior. </title> <journal> The Journal of Systems and Software , 8(5) </journal> <pages> 343-359, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: The set of reachable program states can be generated using a variety of program representations, including flow graphs [Tay83a, YTF+89] and Petri nets <ref> [Pet77, SC88, DCN95] </ref>. Theoretical results [Tay83b] imply that, in general, the time and space requirements for this method are exponential. <p> One method for answering such questions is to enumerate all possible program states and check the property at each state. A reachability graph can be used to represent the program state space. Petri nets appear to be a valuable representation for modeling concurrent software <ref> [SC88] </ref>. In our analysis method, we use a Petri net representation generated from the set of TIGs for the concurrent program. <p> To improve accuracy, we include additional program state information in the Petri net. Although we describe the approach in terms of TPNs, the approach is also applicable to other Petri net representations, such as those from <ref> [SC88] </ref>. The reachability graph generated from this enhanced Petri net representation provides a more accurate estimate of the program state space than the original reachability graph.
Reference: [Tay83a] <author> Richard N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent programs. </title> <journal> Communications of the ACM , 26(5) </journal> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Reachability analysis checks whether a selected property, often called the property of interest , can occur in a concurrent program by considering all reachable states of the program being analyzed. The set of reachable program states can be generated using a variety of program representations, including flow graphs <ref> [Tay83a, YTF+89] </ref> and Petri nets [Pet77, SC88, DCN95]. Theoretical results [Tay83b] imply that, in general, the time and space requirements for this method are exponential.
Reference: [Tay83b] <author> Richard Taylor. </author> <title> Complexity of analyzing the synchronization structure of concurrent programs. </title> <journal> Acta Informatica, </journal> <volume> 19 </volume> <pages> 57-84, </pages> <year> 1983. </year>
Reference-contexts: The set of reachable program states can be generated using a variety of program representations, including flow graphs [Tay83a, YTF+89] and Petri nets [Pet77, SC88, DCN95]. Theoretical results <ref> [Tay83b] </ref> imply that, in general, the time and space requirements for this method are exponential. Several approaches have been proposed to reduce the number of infeasible paths considered by Our approach allows the analyst to include selected control and/or data information in the Petri net model of the program.
Reference: [TO80] <author> Richard N. Taylor and Leon J. Osterweil. </author> <title> Anomaly detection in concurrent software by static data flow analysis. </title> <journal> IEEE Transaction on Software Engineering , SE-6(3):265-277, </journal> <month> May </month> <year> 1980. </year>
Reference-contexts: One proposed approach is to combine reachability analysis with symbolic execution to prune infeasible paths from the estimated reachable state space [YT88]. Symbolic execution, however, is an expensive method that can not be guaranteed to determine feasibility. Our approach entails straightforward extensions of the Petri net representation. properties <ref> [TO80, RS90, MR91, CK93, DC94] </ref>. Infeasible synchronization events can be excluded from consideration by identifying program statements that can not execute concurrently [MR93].
References-found: 18

