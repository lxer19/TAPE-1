URL: http://www.cis.udel.edu/~case/papers/journal-chen5plus.ps
Refering-URL: http://www.cis.udel.edu/~case/colt.html
Root-URL: http://www.cis.udel.edu
Email: Email: case@cis.udel.edu  Email: sanjay@comp.nus.edu.sg  
Title: Costs of General Purpose Learning  
Author: John Case Keh-Jiann Chen Sanjay Jain 
Keyword: Topic Classification: Algorithmic Learning Theory  
Address: 19716  Taipei, 15, Taiwan Republic of China  Singapore 119260  
Affiliation: Department of CIS University of Delaware Newark, DE  Institute for Information Sciences Academica Sinica  School of Computing National University of Singapore  
Abstract: Leo Harrington surprisingly constructed a machine which can learn any computable function f according to the following criterion (called Bc fl -identification). His machine, on the successive graph points of f , outputs a corresponding infinite sequence of programs p 0 ; p 1 ; p 2 ; : : :, and, for some i, the programs p i ; p i+1 ; p i+2 ; : : : each compute a variant of f which differs from f at only finitely many argument places. A machine with this property is called general purpose. The sequence p i ; p i+1 ; p i+2 ; : : : is called a final sequence. For Harrington's general purpose machine, for distinct m and n, the finitely many argument places where p i+m fails to compute f can be very different from the finitely many argument places where p i+n fails to compute f . One would hope though, that if Harrington's machine, or an improvement thereof, inferred the program p i+m based on the data points f (0); f (1); : : : ; f (k), then p i+m would make very few mistakes computing f at the "near future" arguments k + 1; k + 2; : : : ; k + `, where ` is reasonably large. Ideally, p i+m 's finitely many mistakes or anomalies would (mostly) occur at arguments x k, i.e., ideally, its anomalies would be well placed beyond near future arguments. In the present paper, for general purpose learning machines, it is analyzed just how well or badly placed these anomalies may be with respect to near future arguments and what are the various tradeoffs. In particular, there is good news and bad. Bad news is that, for any learning machine M (including general purpose M), for all m, there exist infinitely many computable functions f such that, infinitely often M incorrectly predicts f 's next m near future values. Good news is that, for a suitably clever general purpose learning machine M, for each computable f , for M on f , the density of any such associated bad prediction intervals of size m is vanishingly small. Considered too is the possibility of providing a general purpose learner which additionally learns some interesting classes with respect to much stricter criteria than Bc fl -identification. Again there is good news and bad. The criterion of finite identification requires for success that a learner M on a function f output exactly one program which correctly computes f . Bc n -identification is just like Bc fl -identification above except that the number of anomalies in each program of a final sequence is n. Bad news is that there is a finitely identifiable class of computable functions C such that for no general purpose learner M and for no n, does M additionally Bc n -identify C. Ex-identification by M on f requires that M on f converges, after 
Abstract-found: 1
Intro-found: 1
Reference: [B 71] <author> J. Barzdi~ns. </author> <title> Complexity and Frequency Solution of Some Algorithmically Unsolvable Problems. </title> <type> PhD thesis, </type> <institution> Novosibirsk State University, </institution> <year> 1971. </year> <note> In Russian. </note>
Reference-contexts: We often write Bc for Bc 0 . Some relationships between the above criteria are summarized in the following theorem. Theorem 1 <ref> [CS83, BB75, B 71] </ref> Ex 0 Ex 1 Ex fl Bc Bc 1 Bc fl = 2 R . Since R 2 Bc fl , we often call a machine which Bc fl -identifies R a general purpose learning machine.
Reference: [B 74] <author> J. Barzdi~ns. </author> <title> Two theorems on the limiting synthesis of functions. </title> <booktitle> In Theory of Algorithms and Programs, </booktitle> <volume> vol. 1, </volume> <pages> pages 82-88. </pages> <institution> Latvian State University, </institution> <year> 1974. </year> <note> In Russian. </note>
Reference-contexts: For example, any recursively enumerable class of computable functions such as the class of polynomials or the class of primitive recursive functions [Rog67a] is Ex-identifiable. <ref> [B 74, CS78, CS83] </ref> considered a generalization of Ex-identification called Bc-identification. <p> Hence, some form of learning must take place in order for M to learn f . For this reason, hereafter the terms identify, learn and infer are used interchangeably. Definition 2 <ref> [B 74, CS83] </ref> Let a 2 N [ fflg.
Reference: [BB75] <author> L. Blum and M. Blum. </author> <title> Toward a mathematical theory of inductive inference. </title> <journal> Information and Control, </journal> <volume> 28 </volume> <pages> 125-155, </pages> <year> 1975. </year>
Reference-contexts: A reliable learner (by definition) never deceives by false convergence; more precisely: whenever it converges to a final program on a function f , it must Ex-identify f <ref> [Min76, BB75, CJNM94] </ref>. For example, r.e. classes of computable functions (such as the class of polynomial functions and the class of primitive recursive functions [Rog67a]) as well as the class of total run time functions can be reliably Ex-identified [BB75, CS83]. <p> For example, r.e. classes of computable functions (such as the class of polynomial functions and the class of primitive recursive functions [Rog67a]) as well as the class of total run time functions can be reliably Ex-identified <ref> [BB75, CS83] </ref>. <p> We say that M (f ) converges to i (written: M (f )# = i) iff (8 1 n)[M (f [n]) = i]; M (f ) is undefined if no such i exists. The next definitions describe several criteria of function identification. Definition 1 <ref> [Gol67, BB75, CS83] </ref> Let a; b 2 N [ fflg. <p> We often write Bc for Bc 0 . Some relationships between the above criteria are summarized in the following theorem. Theorem 1 <ref> [CS83, BB75, B 71] </ref> Ex 0 Ex 1 Ex fl Bc Bc 1 Bc fl = 2 R . Since R 2 Bc fl , we often call a machine which Bc fl -identifies R a general purpose learning machine. <p> On can think of a program for a computable function as a predictive explanation for the function's I/O behavior <ref> [BB75, CS83] </ref>. Popper's Refutability Principle [Pop68] essentially says that explanations with mistakes should be refutable. <p> Since general purpose learners are always quite erroneous (of course the density of erroneous, near future intervals can be made small), it is interesting to consider which classes a general purpose learner may additionally identify in a better or stricter sense. Definition 4 <ref> [Min76, BB75, CJNM94] </ref> M is said to be reliable iff, for all f such that M (f )#, M Ex-identifies f . M is said to reliably Ex-identify C, iff M is reliable and M Ex-identifies C. RelEx = fC j some machine reliably Ex-identifies Cg. <p> Hence, almost all of its conjectures satisfy Popper's Refutability Principle. We also showed that for every class of computable functions, S, which can be Ex-identified by a reliable machine <ref> [Min76, BB75, CJNM94] </ref> (see definition in Section 5 above), some general purpose learning machine additionally Ex-identifies S. We further show, though, that reliable identification in the just above statement cannot be replaced by finite identification.
Reference: [Blu67] <author> M. Blum. </author> <title> A machine-independent theory of the complexity of recursive functions. </title> <journal> Journal of the ACM, </journal> <volume> 14 </volume> <pages> 322-336, </pages> <year> 1967. </year>
Reference-contexts: Note that in this paper all programs are interpreted with respect to the '-system. We let be an arbitrary Blum complexity measure <ref> [Blu67] </ref> associated with the acceptable programming system '; many such measures exist for any acceptable programming system [Blu67]. Let ' i;s be defined as follows. 3 ' i;s (x) = ' i (x); if x &lt; s and i (x) s; "; otherwise. <p> Note that in this paper all programs are interpreted with respect to the '-system. We let be an arbitrary Blum complexity measure <ref> [Blu67] </ref> associated with the acceptable programming system '; many such measures exist for any acceptable programming system [Blu67]. Let ' i;s be defined as follows. 3 ' i;s (x) = ' i (x); if x &lt; s and i (x) s; "; otherwise. For a given partial computable function , we define MinProg () to denote min (fi j ' i = g).
Reference: [Cas74] <author> J. </author> <title> Case. Periodicity in generations of automata. </title> <journal> Mathematical Systems Theory, </journal> <volume> 8 </volume> <pages> 15-32, </pages> <year> 1974. </year>
Reference-contexts: It is easy to verify that C 2 Bc n+1 . We now show that C 62 Bc n n+1 . Suppose by way of contradiction, M Bc n n+1 -identifies C. Then, by operator recursion theorem <ref> [Cas74] </ref>, there exists a computable, 1-1, increasing p such that p (0) &gt; 0, and ' p (i) may be described in stages as follows. Below, let ' s p (y) denote ' p (y) defined before stage s. Let X k = fx j (n+2)k &lt; x &lt; (n+2)(k+1)g.
Reference: [CJNM94] <author> J. Case, S. Jain, and S. Ngo Manguelle. </author> <title> Refinements of inductive inference by Popperian and reliable machines. </title> <journal> Kybernetika, </journal> <volume> 30 </volume> <pages> 23-52, </pages> <year> 1994. </year>
Reference-contexts: A reliable learner (by definition) never deceives by false convergence; more precisely: whenever it converges to a final program on a function f , it must Ex-identify f <ref> [Min76, BB75, CJNM94] </ref>. For example, r.e. classes of computable functions (such as the class of polynomial functions and the class of primitive recursive functions [Rog67a]) as well as the class of total run time functions can be reliably Ex-identified [BB75, CS83]. <p> On can think of a program for a computable function as a predictive explanation for the function's I/O behavior [BB75, CS83]. Popper's Refutability Principle [Pop68] essentially says that explanations with mistakes should be refutable. As pointed out in [CS83] (see also <ref> [CJNM94] </ref>), an erroneous predictive explanation (program) for a computable function satisfies Popper's Principle if it computes a total function. 2 The following theorem says that one can construct a general purpose learner which, on computable function input, almost always outputs programs for total functions; hence, it almost always outputs predictive explanations <p> Since general purpose learners are always quite erroneous (of course the density of erroneous, near future intervals can be made small), it is interesting to consider which classes a general purpose learner may additionally identify in a better or stricter sense. Definition 4 <ref> [Min76, BB75, CJNM94] </ref> M is said to be reliable iff, for all f such that M (f )#, M Ex-identifies f . M is said to reliably Ex-identify C, iff M is reliable and M Ex-identifies C. RelEx = fC j some machine reliably Ex-identifies Cg. <p> Hence, almost all of its conjectures satisfy Popper's Refutability Principle. We also showed that for every class of computable functions, S, which can be Ex-identified by a reliable machine <ref> [Min76, BB75, CJNM94] </ref> (see definition in Section 5 above), some general purpose learning machine additionally Ex-identifies S. We further show, though, that reliable identification in the just above statement cannot be replaced by finite identification.
Reference: [CS78] <author> J. Case and C. Smith. </author> <title> Anomaly hierarchies of mechanized inductive inference. </title> <booktitle> In Symposium on the Theory of Computation, </booktitle> <pages> pages 314-319, </pages> <year> 1978. </year>
Reference-contexts: For example, any recursively enumerable class of computable functions such as the class of polynomials or the class of primitive recursive functions [Rog67a] is Ex-identifiable. <ref> [B 74, CS78, CS83] </ref> considered a generalization of Ex-identification called Bc-identification. <p> Bc-identification of a function f by a machine M one requires that the sequence of programs output by M on f either converges to a program for f , or the sequence of programs is infinite, with all but finitely many of them being (possibly different) programs for f . <ref> [CS78, CS83] </ref> also considered the variants of the Ex and Bc-identification criteria in which the final programs need not be perfect, but are allowed to have some anomalies or mistakes in their predictions of I/O behavior.
Reference: [CS83] <author> J. Case and C. Smith. </author> <title> Comparison of identification criteria for machine inductive inference. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <pages> 193-220, </pages> <year> 1983. </year> <month> 15 </month>
Reference-contexts: For example, any recursively enumerable class of computable functions such as the class of polynomials or the class of primitive recursive functions [Rog67a] is Ex-identifiable. <ref> [B 74, CS78, CS83] </ref> considered a generalization of Ex-identification called Bc-identification. <p> Bc-identification of a function f by a machine M one requires that the sequence of programs output by M on f either converges to a program for f , or the sequence of programs is infinite, with all but finitely many of them being (possibly different) programs for f . <ref> [CS78, CS83] </ref> also considered the variants of the Ex and Bc-identification criteria in which the final programs need not be perfect, but are allowed to have some anomalies or mistakes in their predictions of I/O behavior. <p> If the final programs are allowed to make at most finitely many errors, then the criteria of inference are called Ex fl and Bc fl respectively. Harrington <ref> [CS83] </ref> constructed a machine which Bc fl -identifies each computable function! In the present paper, we call machines which do this general purpose. <p> For example, r.e. classes of computable functions (such as the class of polynomial functions and the class of primitive recursive functions [Rog67a]) as well as the class of total run time functions can be reliably Ex-identified <ref> [BB75, CS83] </ref>. <p> We say that M (f ) converges to i (written: M (f )# = i) iff (8 1 n)[M (f [n]) = i]; M (f ) is undefined if no such i exists. The next definitions describe several criteria of function identification. Definition 1 <ref> [Gol67, BB75, CS83] </ref> Let a; b 2 N [ fflg. <p> Hence, some form of learning must take place in order for M to learn f . For this reason, hereafter the terms identify, learn and infer are used interchangeably. Definition 2 <ref> [B 74, CS83] </ref> Let a 2 N [ fflg. <p> We often write Bc for Bc 0 . Some relationships between the above criteria are summarized in the following theorem. Theorem 1 <ref> [CS83, BB75, B 71] </ref> Ex 0 Ex 1 Ex fl Bc Bc 1 Bc fl = 2 R . Since R 2 Bc fl , we often call a machine which Bc fl -identifies R a general purpose learning machine. <p> Proof. Clearly, for m 1, Bc Bc 0 m Bc 0 1 . NV 00 defined by Podnieks [Pod74] is identical to Bc 0 1 . The proposition follows from NV 00 = Bc <ref> [Pod74, CS83] </ref>. The following theorem shows some advantages of having to predict fewer correct values in the near future. Theorem 3 Suppose m 0 &gt; m. Then, Bc 1 m Bc m 0 m Proof. <p> On can think of a program for a computable function as a predictive explanation for the function's I/O behavior <ref> [BB75, CS83] </ref>. Popper's Refutability Principle [Pop68] essentially says that explanations with mistakes should be refutable. <p> On can think of a program for a computable function as a predictive explanation for the function's I/O behavior [BB75, CS83]. Popper's Refutability Principle [Pop68] essentially says that explanations with mistakes should be refutable. As pointed out in <ref> [CS83] </ref> (see also [CJNM94]), an erroneous predictive explanation (program) for a computable function satisfies Popper's Principle if it computes a total function. 2 The following theorem says that one can construct a general purpose learner which, on computable function input, almost always outputs programs for total functions; hence, it almost always <p> It would be interesting to study what other useful properties a suitable general purpose learner can be made to satisfy. 14 6 Conclusions Harrington <ref> [CS83] </ref> surprisingly constructed a general purpose learner, i.e., a machine which Bc fl - identifies all the computable functions. However, the programs output by Harrington's machine become more and more degenerate, i.e., in general, the finite set of anomalies in each final program grows without bound.
Reference: [Gol67] <author> E. M. Gold. </author> <title> Language identification in the limit. </title> <journal> Information and Control, </journal> <volume> 10 </volume> <pages> 447-474, </pages> <year> 1967. </year>
Reference-contexts: A class of functions is Ex-identifiable iff some machine Ex-identifies the class. Even though one cannot Ex-identify the class of all the computable functions <ref> [Gol67] </ref>, there are large and useful classes of functions which can be Ex-identified. For example, any recursively enumerable class of computable functions such as the class of polynomials or the class of primitive recursive functions [Rog67a] is Ex-identifiable. [B 74, CS78, CS83] considered a generalization of Ex-identification called Bc-identification. <p> Let jj denote the length of . We often identify (partial) functions with their graphs. Thus for example, for = f [n] and for x &lt; n, (x) denotes f (x). A learning machine (also called an inductive inference machine (IIM)) <ref> [Gol67] </ref> is an algorithmic device that computes a mapping from SEG into N [ f?g. Intuitively, "?" above denotes the case when the machine may not wish to make a conjecture. <p> We say that M (f ) converges to i (written: M (f )# = i) iff (8 1 n)[M (f [n]) = i]; M (f ) is undefined if no such i exists. The next definitions describe several criteria of function identification. Definition 1 <ref> [Gol67, BB75, CS83] </ref> Let a; b 2 N [ fflg.
Reference: [JORS98] <author> S. Jain, D. Osherson, J. Royer, and A. Sharma. </author> <title> Systems that Learn: An Introduction to Learning Theory. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <note> second edition edition, 1998. To appear. </note>
Reference-contexts: 1 Introduction The learning situation often studied in inductive inference <ref> [OSW86, JORS98] </ref> may be described as follows. A learner receives as input, one at a time, the successive graph points of a function f . As the learner is receiving its input, it conjectures a sequence of programs as hypotheses. <p> Since R 2 Bc fl , we often call a machine which Bc fl -identifies R a general purpose learning machine. We let I and J range over identification criteria defined above. For all criteria I of inference considered in this paper, one can show that <ref> [OSW86, JORS98] </ref>: there exists an r.e. sequence M 0 ; M 1 ; M 2 ; : : :, of inductive inference machines such that, for all C 2 I, there exists an i 2 N such that C I (M i ).
Reference: [Min76] <author> E. Minicozzi. </author> <title> Some natural properties of strong identification in inductive inference. </title> <booktitle> Theoretical Computer Science, </booktitle> <pages> pages 345-360, </pages> <year> 1976. </year>
Reference-contexts: A reliable learner (by definition) never deceives by false convergence; more precisely: whenever it converges to a final program on a function f , it must Ex-identify f <ref> [Min76, BB75, CJNM94] </ref>. For example, r.e. classes of computable functions (such as the class of polynomial functions and the class of primitive recursive functions [Rog67a]) as well as the class of total run time functions can be reliably Ex-identified [BB75, CS83]. <p> Since general purpose learners are always quite erroneous (of course the density of erroneous, near future intervals can be made small), it is interesting to consider which classes a general purpose learner may additionally identify in a better or stricter sense. Definition 4 <ref> [Min76, BB75, CJNM94] </ref> M is said to be reliable iff, for all f such that M (f )#, M Ex-identifies f . M is said to reliably Ex-identify C, iff M is reliable and M Ex-identifies C. RelEx = fC j some machine reliably Ex-identifies Cg. <p> Hence, almost all of its conjectures satisfy Popper's Refutability Principle. We also showed that for every class of computable functions, S, which can be Ex-identified by a reliable machine <ref> [Min76, BB75, CJNM94] </ref> (see definition in Section 5 above), some general purpose learning machine additionally Ex-identifies S. We further show, though, that reliable identification in the just above statement cannot be replaced by finite identification.
Reference: [OSW86] <author> D. Osherson, M. Stob, and S. Weinstein. </author> <title> Systems that Learn: An Introduction to Learning Theory for Cognitive and Computer Scientists. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction The learning situation often studied in inductive inference <ref> [OSW86, JORS98] </ref> may be described as follows. A learner receives as input, one at a time, the successive graph points of a function f . As the learner is receiving its input, it conjectures a sequence of programs as hypotheses. <p> Since R 2 Bc fl , we often call a machine which Bc fl -identifies R a general purpose learning machine. We let I and J range over identification criteria defined above. For all criteria I of inference considered in this paper, one can show that <ref> [OSW86, JORS98] </ref>: there exists an r.e. sequence M 0 ; M 1 ; M 2 ; : : :, of inductive inference machines such that, for all C 2 I, there exists an i 2 N such that C I (M i ).
Reference: [Pod74] <author> K. Podnieks. </author> <title> Comparing various concepts of function prediction, Part I. </title> <booktitle> In Theory of Algorithms and Programs, </booktitle> <volume> vol. 1, </volume> <pages> pages 68-81. </pages> <institution> Latvian State University, Riga, Latvia, </institution> <year> 1974. </year>
Reference-contexts: Then Bc k m Bc n Proposition 4 Suppose m k n. Then Bc n m Bc n Proposition 5 For all m &gt; 0, Bc = Bc 0 m . Proof. Clearly, for m 1, Bc Bc 0 m Bc 0 1 . NV 00 defined by Podnieks <ref> [Pod74] </ref> is identical to Bc 0 1 . The proposition follows from NV 00 = Bc [Pod74, CS83]. The following theorem shows some advantages of having to predict fewer correct values in the near future. Theorem 3 Suppose m 0 &gt; m. <p> Proof. Clearly, for m 1, Bc Bc 0 m Bc 0 1 . NV 00 defined by Podnieks [Pod74] is identical to Bc 0 1 . The proposition follows from NV 00 = Bc <ref> [Pod74, CS83] </ref>. The following theorem shows some advantages of having to predict fewer correct values in the near future. Theorem 3 Suppose m 0 &gt; m. Then, Bc 1 m Bc m 0 m Proof.
Reference: [Pop68] <author> K. </author> <title> Popper. The Logic of Scientific Discovery. </title> <publisher> Harper Torch Books, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1968. </year>
Reference-contexts: On can think of a program for a computable function as a predictive explanation for the function's I/O behavior [BB75, CS83]. Popper's Refutability Principle <ref> [Pop68] </ref> essentially says that explanations with mistakes should be refutable.
Reference: [Ric80] <author> G. Riccardi. </author> <title> The Independence of Control Structures in Abstract Programming Systems. </title> <type> PhD thesis, </type> <institution> SUNY/Buffalo, </institution> <year> 1980. </year>
Reference-contexts: R denotes the class of all computable functions, i.e., total computable functions with arguments and values from N . C and S, with or without decorations, range over subsets of R. ' denotes a fixed standard or so-called acceptable programming system <ref> [Rog58, Rog67a, Ric80, Ric81, Roy87] </ref>. ' i denotes the partial computable function computed by program i in the '-system. Note that in this paper all programs are interpreted with respect to the '-system.
Reference: [Ric81] <author> G. Riccardi. </author> <title> The independence of control structures in abstract programming systems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 22 </volume> <pages> 107-143, </pages> <year> 1981. </year>
Reference-contexts: R denotes the class of all computable functions, i.e., total computable functions with arguments and values from N . C and S, with or without decorations, range over subsets of R. ' denotes a fixed standard or so-called acceptable programming system <ref> [Rog58, Rog67a, Ric80, Ric81, Roy87] </ref>. ' i denotes the partial computable function computed by program i in the '-system. Note that in this paper all programs are interpreted with respect to the '-system.
Reference: [Rog58] <author> H. Rogers. </author> <title> Godel numberings of partial recursive functions. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 23 </volume> <pages> 331-341, </pages> <year> 1958. </year>
Reference-contexts: R denotes the class of all computable functions, i.e., total computable functions with arguments and values from N . C and S, with or without decorations, range over subsets of R. ' denotes a fixed standard or so-called acceptable programming system <ref> [Rog58, Rog67a, Ric80, Ric81, Roy87] </ref>. ' i denotes the partial computable function computed by program i in the '-system. Note that in this paper all programs are interpreted with respect to the '-system.
Reference: [Rog67a] <author> H. Rogers. </author> <title> Theory of Recursive Functions and Effective Computability. </title> <publisher> McGraw-Hill, </publisher> <address> 1967. </address> <publisher> Reprinted, MIT Press 1987. </publisher>
Reference-contexts: Even though one cannot Ex-identify the class of all the computable functions [Gol67], there are large and useful classes of functions which can be Ex-identified. For example, any recursively enumerable class of computable functions such as the class of polynomials or the class of primitive recursive functions <ref> [Rog67a] </ref> is Ex-identifiable. [B 74, CS78, CS83] considered a generalization of Ex-identification called Bc-identification. <p> For example, r.e. classes of computable functions (such as the class of polynomial functions and the class of primitive recursive functions <ref> [Rog67a] </ref>) as well as the class of total run time functions can be reliably Ex-identified [BB75, CS83]. <p> R denotes the class of all computable functions, i.e., total computable functions with arguments and values from N . C and S, with or without decorations, range over subsets of R. ' denotes a fixed standard or so-called acceptable programming system <ref> [Rog58, Rog67a, Ric80, Ric81, Roy87] </ref>. ' i denotes the partial computable function computed by program i in the '-system. Note that in this paper all programs are interpreted with respect to the '-system. <p> Proof. Define M as follows. M on f [n], outputs a program p n such that ' p n may be defined as follows. 2 Then the halting problem <ref> [Rog67a] </ref> does not stand in the way of algorithmically locating the mistakes. 11 ' p n (x) 2. If S x = ;, then let ' p n (x) = 0. 3. Else let p = min (S x ). 4.
Reference: [Rog67b] <author> H. Rogers. </author> <title> Theory of Recursive Functions and Effective Computability. </title> <publisher> McGraw-Hill, </publisher> <year> 1967. </year> <note> Reprinted by MIT Press in 1987. </note>
Reference-contexts: We now proceed formally. 2 Notation and Preliminaries Recursion-theoretic concepts not explained below are treated in <ref> [Rog67b] </ref>. N denotes the set of natural numbers. fl denotes a non-member of N and is assumed to satisfy (8n)[n &lt; fl &lt; 1]. <p> Proof. Suppose M and g are as given in the hypothesis. We will construct one f such that for infinitely many n, ' M (f [n]) 6= g (n) f . The construction can be easily modified to produce infinitely many distinct such f . By Kleene Recursion Theorem <ref> [Rog67b] </ref>, there exists an e such that ' e may be defined as follows. Let ' e (0) = e. Let x 0 = 1. Go to stage 0. Stage s 1. Let h = zeroext (' e [x s ]). 2.
Reference: [Roy87] <author> J. Royer. </author> <title> A Connotational Theory of Program Structure, </title> <booktitle> volume 273 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <month> 16 </month>
Reference-contexts: R denotes the class of all computable functions, i.e., total computable functions with arguments and values from N . C and S, with or without decorations, range over subsets of R. ' denotes a fixed standard or so-called acceptable programming system <ref> [Rog58, Rog67a, Ric80, Ric81, Roy87] </ref>. ' i denotes the partial computable function computed by program i in the '-system. Note that in this paper all programs are interpreted with respect to the '-system.
References-found: 20

