URL: http://www.cs.cmu.edu/afs/cs/project/venari/papers/scp/big-tr.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/venari/www/scp.html
Root-URL: 
Title: A Case Study in Model Checking Software Systems  
Author: Jeannette M. Wing Mandana Vaziri-Farahani 
Note: To appear in Science of Computer Programming. A shorter version appeared in the Proceedings of the ACM SIGSOFT Foundations of Software Engineering Conference 1995. 1 Work done while at the  
Date: April 1996  
Address: Pittsburgh, PA 15213, USA  Cambridge, MA 02139, USA  Pittsburgh, PA 15213  
Affiliation: Computer Science Department Carnegie Mellon University  Laboratory for Computer Science Massachusetts Institute of Technology  School of Computer Science Carnegie Mellon University  Electrical and Computer Engineering Department, Carnegie Mel- lon University.  
Pubnum: CMU-CS-96-124  
Abstract: This research is sponsored by the Wright Laboratory, Aeronautical Systems Cen- ter, Air Force Materiel Command, USAF, and the Advanced Research Projects Agency (ARPA) under grant number F33615-93-1-1330. Views and conclusions contained in this document are those of the authors and should not be interpreted as necessarily representing official policies or endorsements, either expressed or implied, of Wright Laboratory or the United States Government. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Allen and D. Garlan. </author> <title> Formalizing architectural connection. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: They use FDR to detect deadlocks in software architectures described in the Wright architectural description language <ref> [1] </ref>. Wright is based on a subset of CSP, and thus it leaves states completely uninterpreted. Our approach complements all three of the above since in each case, the researchers first build some finite model of the real system and express it in terms of SCR, Z, or Wright.
Reference: [2] <author> A. Arnold. Mec: </author> <title> a system for constructing and analysing transition sys-tems. </title> <editor> In J. Sifakis, editor, </editor> <title> Automatic verification methods of finite state systems, </title> <booktitle> volume LNCS 407. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware [5, 16, 32, 11, 10, 4]. Tool support for model checking includes SMV [31], FDR [19], COSPAN [22], the Concurrency Workbench [12], Mur [17], and Mec <ref> [2] </ref>. There are more and more documented case studies; for example, the proceedings of the 1995 Workshop of Industrial-Strength Formal Techniques contains four model checking case study papers [20]. We are not the first to explore the use of model checking in the software domain.
Reference: [3] <author> J.M. Atlee and J.D. Gannon. </author> <title> State-based model checking of event driven systems requirements. </title> <journal> IEEE Trans. Soft. Eng., </journal> <month> January </month> <year> 1993. </year>
Reference-contexts: Three other approaches complement ours and each other. Since they are all recent (dated 1993-94), we expect that over time results from one approach will carry over to the others. * Atlee and Gannon follow a specification-language based approach <ref> [3] </ref>. 25 They verify safety properties for event-driven systems described by the SCR tabular requirements language. Their case studies include an automobile cruise control system and a water-level monitoring system. They show how to represent any specification written in a subset of SCR as a finite state machine.
Reference: [4] <author> G. Barrett. </author> <title> Model checking in practice: The t9000 virtual channel proces-sor. </title> <journal> IEEE Trans. on Soft. Eng., </journal> <volume> 21(2) </volume> <pages> 69-78, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: It has been used to prove safety and liveness properties of the T9000 virtual channel processor <ref> [4] </ref>. Fundamental to model checking is its reliance on finite state machines. Model checking exploits this finiteness property by performing an exhaustive case analysis of the machine's set of states. <p> As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware <ref> [5, 16, 32, 11, 10, 4] </ref>. Tool support for model checking includes SMV [31], FDR [19], COSPAN [22], the Concurrency Workbench [12], Mur [17], and Mec [2].
Reference: [5] <author> M. C. Browne, E. M. Clarke, D. L. Dill, and B. Mishra. </author> <title> Automatic veri-fication of sequential circuits using temporal logic. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(12):1035-1044, </volume> <year> 1986. </year>
Reference-contexts: For example, it has been used to find bugs in published circuits <ref> [5, 16] </ref>, the cache coherence protocol for the Encore Gigamax multiprocessor [32], the IEEE Futurebus+ Standard [10], and telephone switching systems [18]. It has been used to prove safety and liveness properties of the T9000 virtual channel processor [4]. Fundamental to model checking is its reliance on finite state machines. <p> As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware <ref> [5, 16, 32, 11, 10, 4] </ref>. Tool support for model checking includes SMV [31], FDR [19], COSPAN [22], the Concurrency Workbench [12], Mur [17], and Mec [2].
Reference: [6] <author> M. Burrows, M. Abadi, and R. Needham. </author> <title> A logic of authentication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 18-36, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: We call Mummert's extension to Coda's protocol Coda+. It was this work that inspired our initial investigation of this case study since Mummert wanted a way to prove formally that her protocol design was correct. Inspired by the logic of authentication <ref> [6] </ref>, Mummert et al. [34] formalized the notions of belief and validity, as used above, and applied the extended logic to reason about cache coherence for AFS-1, AFS- 2, and Mummert's variation of Coda's protocol. The actual proofs were done by hand.
Reference: [7] <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Finally, we could have used other, more general, proof-based approaches such as Unity <ref> [7] </ref> or I/O automata [29], than the Burrows-Abadi-Needham Logic of Authentication, to reason about our protocol examples; however, the particular proof system in which we do our reasoning is secondary to the main point of this paper.
Reference: [8] <author> S.C. Cheung and J. Kramer. </author> <title> An integrated method for effective behavior analysis of distributed systems. </title> <booktitle> In Proc. 16th Int'l Conf. on Soft. </booktitle> <address> Eng., Sorrento, Italy, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Thus, our focus is on finding "appropriate" abstractions that work across different domains and different problems, not on checking models expressed in a particular specification language. Cheung and Kramer's two-step analysis approach applied to reasoning about large-scale distributed systems is similar in spirit to ours <ref> [8] </ref>. They use dataflow analysis as a way to approximate a system's behavior and then contextual analysis to do an exhaustive search of the resulting state space.
Reference: [9] <author> E. M. Clarke and E. A. Emerson. </author> <title> Synthesis of synchronization skeletons for branching time temporal logic. In Logic of Programs: </title> <booktitle> Workshop, </booktitle> <address> Yorktown Heights, NY, </address> <month> May </month> <year> 1981, </year> <booktitle> volume 131 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year> <month> 29 </month>
Reference-contexts: For Coda+, this reduces the number of cases to consider from forty-four to fifteen (corresponding to the fifteen paths in the client state transition diagram of Figure 9) [34]. 6 Related Work Model checking originated with Clarke and Emerson's work in 1981 <ref> [9] </ref>. As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware [5, 16, 32, 11, 10, 4]. Tool support for model checking includes SMV [31], FDR [19], COSPAN [22], the Concurrency Workbench [12], Mur [17], and Mec [2].
Reference: [10] <author> E. M. Clarke, O. Grumberg, H. Hiraishi, S. Jha, D.E. Long, K. L. McMillan, and L. A. Ness. </author> <title> Verification of the futurebus+ cache coherence protocol. </title> <booktitle> In Proc. of CHDL '93, </booktitle> <year> 1993. </year>
Reference-contexts: For example, it has been used to find bugs in published circuits [5, 16], the cache coherence protocol for the Encore Gigamax multiprocessor [32], the IEEE Futurebus+ Standard <ref> [10] </ref>, and telephone switching systems [18]. It has been used to prove safety and liveness properties of the T9000 virtual channel processor [4]. Fundamental to model checking is its reliance on finite state machines. <p> As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware <ref> [5, 16, 32, 11, 10, 4] </ref>. Tool support for model checking includes SMV [31], FDR [19], COSPAN [22], the Concurrency Workbench [12], Mur [17], and Mec [2].
Reference: [11] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstrac-tion. </title> <booktitle> In Proc. of POPL '92, </booktitle> <year> 1992. </year>
Reference-contexts: Recent technological advances have greatly improved the ability to apply this technique to real systems: model checkers can now check systems on the order of 10 20 states, and for some systems this number can be as large as 10 1300 <ref> [11] </ref>. The rationale behind why theorem proving has been the primary approach for reasoning about software is that software systems are, in general, infinite state machines. We thus rely on induction to prove in a finite number of steps a property over infinite domains. <p> As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware <ref> [5, 16, 32, 11, 10, 4] </ref>. Tool support for model checking includes SMV [31], FDR [19], COSPAN [22], the Concurrency Workbench [12], Mur [17], and Mec [2].
Reference: [12] <author> R. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The concurrency workbench: A semantics-based tool for the verification of concurrent systems. </title> <type> Technical Report ECS-LFCS-89-83, </type> <institution> Edinburgh Univeristy, </institution> <year> 1983. </year>
Reference-contexts: As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware [5, 16, 32, 11, 10, 4]. Tool support for model checking includes SMV [31], FDR [19], COSPAN [22], the Concurrency Workbench <ref> [12] </ref>, Mur [17], and Mec [2]. There are more and more documented case studies; for example, the proceedings of the 1995 Workshop of Industrial-Strength Formal Techniques contains four model checking case study papers [20]. We are not the first to explore the use of model checking in the software domain.
Reference: [13] <author> W. Courtright and G. Gibson. </author> <title> Backward error recovery in redundant disk arrays. </title> <booktitle> In Proceedings of the 1994 Computer Measurement Group Conference (CMG), </booktitle> <pages> pages 63-74, </pages> <address> Orlando, FL, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: This formalization is also an abstraction of the real system. In our own work, toward making progress both in demonstrating feasibility and in understanding characteristics of good abstractions, we plan to push on more examples. We have recently applied the approach described in this paper to validate recovery protocols <ref> [13] </ref> for redundant disk arrays, in particular for the RAID Level-5 architecture. We are just beginning to work on protocols proposed and in use for electronic commerce. Our primary goal is to provide more convincing evidence to systems designers and builders that formal reasoning tools are ready for day-to-day use.
Reference: [14] <author> D. Craigen, S. Gerhart, and T. Ralston. </author> <title> Formal methods reality check: Industrial usage. </title> <journal> IEEE Trans. on Soft. Eng., </journal> <volume> 21(2) </volume> <pages> 90-98, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Yet, it still has drawbacks: * The size of a program we can prove correct is on the order of only a couple thousand lines of code <ref> [14] </ref>. * To do such a proof requires highly-skilled people, such as theorem-proving experts, domain experts, or both. * The human time to do such a proof is on the order of months or even years; the machine time, on the order of hours [14]. * In the course of such <p> a couple thousand lines of code <ref> [14] </ref>. * To do such a proof requires highly-skilled people, such as theorem-proving experts, domain experts, or both. * The human time to do such a proof is on the order of months or even years; the machine time, on the order of hours [14]. * In the course of such a proof, we are often forced to prove "obvious" or "uninteresting" theorems; the amount of effort to prove them is often the same as that for proving the "essential" property of interest.
Reference: [15] <author> D.R. Dams, O. Grumberg, and R. Gerth. </author> <title> Abstract interpretation of re-active systems: </title> <booktitle> Abstractions preserving ACTL fl , ECTL fl and CTL fl . In IFIP working conference on Programming Concepts, Methods and Calculi (PROCOMET'94), </booktitle> <address> San Miniato, Italy, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Dams, Grumberg, and Gerth use the idea of exploiting the form of in extending abstract interpretation to nondeterministic systems; they consider two different subsets of CTL*, universal CTL* and existential CTL* <ref> [15] </ref>, where path quantifiers are restricted to be only of one kind (universal or existential). 5.2 Exploiting Domain-Specific Knowledge In our domain of distributed systems, we need to worry about failures and transmission delays.
Reference: [16] <author> D. L. Dill and E. M. Clarke. </author> <title> Automatic verification of asynchronous circuits using temporal logic. </title> <booktitle> IEE Proceedings, Part E 133(5), </booktitle> <year> 1986. </year>
Reference-contexts: For example, it has been used to find bugs in published circuits <ref> [5, 16] </ref>, the cache coherence protocol for the Encore Gigamax multiprocessor [32], the IEEE Futurebus+ Standard [10], and telephone switching systems [18]. It has been used to prove safety and liveness properties of the T9000 virtual channel processor [4]. Fundamental to model checking is its reliance on finite state machines. <p> As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware <ref> [5, 16, 32, 11, 10, 4] </ref>. Tool support for model checking includes SMV [31], FDR [19], COSPAN [22], the Concurrency Workbench [12], Mur [17], and Mec [2].
Reference: [17] <author> David L. Dill, Andreas J. Drexler, Alan J. Hu, and C. Han Yang. </author> <title> Protocol verification as a hardware design aid. </title> <booktitle> In IEEE International Conference on Computer Design VLSI in Computers and Processors, </booktitle> <pages> pages 522-525, </pages> <year> 1992. </year>
Reference-contexts: As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware [5, 16, 32, 11, 10, 4]. Tool support for model checking includes SMV [31], FDR [19], COSPAN [22], the Concurrency Workbench [12], Mur <ref> [17] </ref>, and Mec [2]. There are more and more documented case studies; for example, the proceedings of the 1995 Workshop of Industrial-Strength Formal Techniques contains four model checking case study papers [20]. We are not the first to explore the use of model checking in the software domain. <p> our approach of using abstraction mappings, Havelund and Shankar used PVS to justify formally 2 April 1995 version. 26 an abstraction mapping they use in a case study on a bounded retransmission protocol [23]; the point behind their case study was to compare the performance of Dill's model checker Mur <ref> [17] </ref>, SMV, and the PVS model checker on a finite abstraction of the protocol.
Reference: [18] <author> A.R. Flora-Holmquist and M.G. Staskauskas. </author> <title> Formal validation of virtual finite state machines. </title> <booktitle> In Proceedings of the Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <month> April </month> <year> 1995. </year> <note> to appear. </note>
Reference-contexts: For example, it has been used to find bugs in published circuits [5, 16], the cache coherence protocol for the Encore Gigamax multiprocessor [32], the IEEE Futurebus+ Standard [10], and telephone switching systems <ref> [18] </ref>. It has been used to prove safety and liveness properties of the T9000 virtual channel processor [4]. Fundamental to model checking is its reliance on finite state machines. Model checking exploits this finiteness property by performing an exhaustive case analysis of the machine's set of states.
Reference: [19] <institution> Limited Formal Systems Europe. </institution> <month> FDR: </month> <title> User Manual and Tutorial. </title> <publisher> Oxford, </publisher> <address> England, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware [5, 16, 32, 11, 10, 4]. Tool support for model checking includes SMV [31], FDR <ref> [19] </ref>, COSPAN [22], the Concurrency Workbench [12], Mur [17], and Mec [2]. There are more and more documented case studies; for example, the proceedings of the 1995 Workshop of Industrial-Strength Formal Techniques contains four model checking case study papers [20].
Reference: [20] <author> R. France and S. Gerhart. </author> <booktitle> Proceedings of the Workshop on IndustrialStrength Formal Specification Techniques. IEEE, </booktitle> <year> 1995. </year>
Reference-contexts: Tool support for model checking includes SMV [31], FDR [19], COSPAN [22], the Concurrency Workbench [12], Mur [17], and Mec [2]. There are more and more documented case studies; for example, the proceedings of the 1995 Workshop of Industrial-Strength Formal Techniques contains four model checking case study papers <ref> [20] </ref>. We are not the first to explore the use of model checking in the software domain. Three other approaches complement ours and each other.
Reference: [21] <author> J.Y. Halpern and Y. Moses. </author> <title> Knowledge and common knowledge in a dis-tributed environment. </title> <booktitle> In Proceedings of the Third ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 50-61, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Cache coherence in a distributed system is more difficult to achieve than on a multiprocessor because of the presence of failures and transmission delay. Thus, since global knowledge is impossible to achieve in a distributed system <ref> [21] </ref>, we settle for pairwise knowledge between clients and servers. Our notion of belief captures this pairwise knowledge [34].
Reference: [22] <author> Z. Har'El and R. P. Kurshan. </author> <title> Software for analytical development of com-munications protocols. </title> <journal> AT&T Technical Journal, </journal> <volume> 69(1) </volume> <pages> 45-59, </pages> <address> Jan.-Feb. </address> <year> 1990. </year>
Reference-contexts: As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware [5, 16, 32, 11, 10, 4]. Tool support for model checking includes SMV [31], FDR [19], COSPAN <ref> [22] </ref>, the Concurrency Workbench [12], Mur [17], and Mec [2]. There are more and more documented case studies; for example, the proceedings of the 1995 Workshop of Industrial-Strength Formal Techniques contains four model checking case study papers [20].
Reference: [23] <author> Klaus Havelund and Natarajan Shankar. </author> <title> Experiments in theorem proving and model checking for protocol verification. </title> <note> Submitted to FME '96, </note> <year> 1996. </year>
Reference-contexts: Relevant to our approach of using abstraction mappings, Havelund and Shankar used PVS to justify formally 2 April 1995 version. 26 an abstraction mapping they use in a case study on a bounded retransmission protocol <ref> [23] </ref>; the point behind their case study was to compare the performance of Dill's model checker Mur [17], SMV, and the PVS model checker on a finite abstraction of the protocol.
Reference: [24] <author> John Howard, Michael Kazar, Sherri Menees, David Nichols, Mahadev Satyanarayanan, Robert Sidebotham, and Michael West. </author> <title> Scale and Performance in a Distributed File System. </title> <journal> ACM Transactions of Computer Systems, </journal> <volume> 6(1) </volume> <pages> 51-81, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: A validation-based technique, AFS-1, was used in the Andrew File System from 1984-1985 [38]; for performance reasons, an invalidation-based technique, AFS-2, replaced AFS-1 and has been in use in Andrew since 1985 <ref> [24] </ref>. In 1993 Mummert, as part of her Ph.D. thesis work, started implementing a more complicated invalidation-based cache coherence protocol [33], similar to AFS-2, as a variation for the Coda Distributed File System [37]. We call Mummert's extension to Coda's protocol Coda+. <p> line after resources used: says that SMV takes fractions of a second to check both properties and the last line says that the number of reachable states for AFS-1 is 26. 4.2 AFS-2 The two main differences between AFS-1 and AFS-2 are that (1) AFS-2 maintains cache coherence using callbacks <ref> [24] </ref>, and (2) it needs to handle the case of failures. When a client caches a file, the server promises that it will notify that client if the file changes. This is called a callback promise, or simply callback.
Reference: [25] <author> H. Hungar. </author> <title> Combining model checking and theorem proving to verify par-allel processes. </title> <booktitle> In Proc. 5th Int'l. Conf. on Computer Aided Verification, </booktitle> <volume> volume LNCS 697, </volume> <pages> pages 154-165. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: They use dataflow analysis as a way to approximate a system's behavior and then contextual analysis to do an exhaustive search of the resulting state space. Approaches to combine model checking with theorem proving include work by Hungar <ref> [25] </ref> and Kurshan and Lamport [28], and in tools such as the Stanford Temporal Prover (STeP) [30] and SRI's PVS [40] 2 .
Reference: [26] <author> D. Jackson. </author> <title> Abstract model checking of infinite specifications. </title> <booktitle> In Proc. of FME '94, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: State variables for hardware (and SCR) are of simple types like boolean, but in software they range over more complex type like sets, graphs, and relations. He exploits symmetry in mathematical relations to reduce the state space; he shows how to model check Z specifications <ref> [26] </ref>, which is essentially based on his relational calculus.
Reference: [27] <author> Daniel Jackson. Nitpick: </author> <title> A checkable specification language. </title> <booktitle> In Proc. Workshop on Formal Methods in Software Practice, </booktitle> <address> San Diego, CA, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: He exploits symmetry in mathematical relations to reduce the state space; he shows how to model check Z specifications [26], which is essentially based on his relational calculus. His Nitpick tool implements his model enumeration method <ref> [27] </ref>. * Allen and Garlan's use of model checking focuses at the level of software architecture, a level of abstraction far above the real system, but again where many design flaws can be detected.
Reference: [28] <author> R. Kurshan and L. Lamport. </author> <title> Verification of a multiplier: 64 bits and beyond. </title> <booktitle> In Proc. 5th Int'l. Conf. on Computer Aided Verification, </booktitle> <volume> volume LNCS 697, </volume> <pages> pages 166-179. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: They use dataflow analysis as a way to approximate a system's behavior and then contextual analysis to do an exhaustive search of the resulting state space. Approaches to combine model checking with theorem proving include work by Hungar [25] and Kurshan and Lamport <ref> [28] </ref>, and in tools such as the Stanford Temporal Prover (STeP) [30] and SRI's PVS [40] 2 .
Reference: [29] <author> N. Lynch and M. Tuttle. </author> <title> Hierarchical correctness proofs for distributed al-gorithms. </title> <type> Technical report, </type> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> April </month> <year> 1987. </year>
Reference-contexts: Finally, we could have used other, more general, proof-based approaches such as Unity [7] or I/O automata <ref> [29] </ref>, than the Burrows-Abadi-Needham Logic of Authentication, to reason about our protocol examples; however, the particular proof system in which we do our reasoning is secondary to the main point of this paper.
Reference: [30] <author> Z. Manna. </author> <title> Beyond model checking. </title> <booktitle> In Proc. 6th Int'l. Conf. on Computer Aided Verification, </booktitle> <volume> volume LNCS 818, </volume> <pages> pages 220-221. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Approaches to combine model checking with theorem proving include work by Hungar [25] and Kurshan and Lamport [28], and in tools such as the Stanford Temporal Prover (STeP) <ref> [30] </ref> and SRI's PVS [40] 2 .
Reference: [31] <author> K. L. McMillan. </author> <title> Symbolic Model Checking: An Approach to the State Explosion Problem. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year> <month> CMUCS-92-131. </month>
Reference-contexts: However, if a client and server both believe a run is in progress, then the run ends once both principals detect the failure. 3.2 SMV and CTL Users can describe synchronous or asynchronous finite state machines with the model checker SMV <ref> [31] </ref>. Although for our application domain of distributed systems, it might seem more natural to use an asynchronous model, the protocol itself is more easily described in terms of a synchronous model. <p> As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware [5, 16, 32, 11, 10, 4]. Tool support for model checking includes SMV <ref> [31] </ref>, FDR [19], COSPAN [22], the Concurrency Workbench [12], Mur [17], and Mec [2]. There are more and more documented case studies; for example, the proceedings of the 1995 Workshop of Industrial-Strength Formal Techniques contains four model checking case study papers [20].
Reference: [32] <author> K. L. McMillan and J. Schwalbe. </author> <title> Formal verification of the gigamax cache consistency protocol. </title> <editor> In N. Suzuki, editor, </editor> <booktitle> Shared Memory Multiprocessing. </booktitle> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: For example, it has been used to find bugs in published circuits [5, 16], the cache coherence protocol for the Encore Gigamax multiprocessor <ref> [32] </ref>, the IEEE Futurebus+ Standard [10], and telephone switching systems [18]. It has been used to prove safety and liveness properties of the T9000 virtual channel processor [4]. Fundamental to model checking is its reliance on finite state machines. <p> As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware <ref> [5, 16, 32, 11, 10, 4] </ref>. Tool support for model checking includes SMV [31], FDR [19], COSPAN [22], the Concurrency Workbench [12], Mur [17], and Mec [2].
Reference: [33] <author> L. Mummert and M. Satyanarayanan. </author> <title> Large Granularity Cache Coherence for Intermittent Connectivity. </title> <booktitle> In USENIX Summer Conference Proceedings, </booktitle> <pages> pages 279 - 289. </pages> <publisher> USENIX Association, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: In 1993 Mummert, as part of her Ph.D. thesis work, started implementing a more complicated invalidation-based cache coherence protocol <ref> [33] </ref>, similar to AFS-2, as a variation for the Coda Distributed File System [37]. We call Mummert's extension to Coda's protocol Coda+. It was this work that inspired our initial investigation of this case study since Mummert wanted a way to prove formally that her protocol design was correct.
Reference: [34] <author> L. Mummert, J.M. Wing, and M. Satyanarayanan. </author> <title> Using belief to reason about cache coherence. </title> <booktitle> In Proceedings of the Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1994. </year> <note> Also CMU-CS-94-151, </note> <month> May </month> <year> 1994. </year> <month> 31 </month>
Reference-contexts: Thus, since global knowledge is impossible to achieve in a distributed system [21], we settle for pairwise knowledge between clients and servers. Our notion of belief captures this pairwise knowledge <ref> [34] </ref>. An invariant property to prove of all cache coherence protocols is that if a client believes that a cached file is valid, then the server that is the authority on the file believes the client's copy is valid. <p> More formally, CC: 8 C : client : 8 S : server : 8 f : f ile: C believes valid (f C ) ) S believes valid (f C ) where f C stands for the copy of f at C <ref> [34] </ref>. A validation-based technique, AFS-1, was used in the Andrew File System from 1984-1985 [38]; for performance reasons, an invalidation-based technique, AFS-2, replaced AFS-1 and has been in use in Andrew since 1985 [24]. <p> We call Mummert's extension to Coda's protocol Coda+. It was this work that inspired our initial investigation of this case study since Mummert wanted a way to prove formally that her protocol design was correct. Inspired by the logic of authentication [6], Mummert et al. <ref> [34] </ref> formalized the notions of belief and validity, as used above, and applied the extended logic to reason about cache coherence for AFS-1, AFS- 2, and Mummert's variation of Coda's protocol. The actual proofs were done by hand. <p> The actual proofs were done by hand. We observed, however, that the state machine models for all protocols described in <ref> [34] </ref> are finite and small|trivial for a model checker. So to complete the formal analysis, we subjected all three protocols to model checking. Before we present the details of the examples, we need to give some background information. <p> We start with an informal description of our system model for reasoning about cache coherence based on the notion of belief. Assumptions made for our model are common to all three protocols we analyzed. The system model and assumptions are taken directly from Mummert et al.'s work in <ref> [34] </ref>. We then give a brief high-level description of SMV and CTL. 5 3.1 System Model and Assumptions We designate hosts as clients or servers of the file system. <p> We consider classes of runs, categorized by a protocol's sets of initial and final states. For Coda+, this reduces the number of cases to consider from forty-four to fifteen (corresponding to the fifteen paths in the client state transition diagram of Figure 9) <ref> [34] </ref>. 6 Related Work Model checking originated with Clarke and Emerson's work in 1981 [9]. As mentioned in the introduction, it has already proven to be extremely successful in debugging hardware [5, 16, 32, 11, 10, 4]. <p> Rather, we show that we can take a finite state model such as that which was already developed (using the BAN logic) in Mummert et al. <ref> [34] </ref> and "feed it" into an existing model checker. <p> Indeed the first formalization of these protocols is given in the Mummert et al. paper <ref> [34] </ref>, which we have reproduced in part in Sections 3.1, 4.1.1, 4.2.1, and 4.3.1. This formalization is also an abstraction of the real system. In our own work, toward making progress both in demonstrating feasibility and in understanding characteristics of good abstractions, we plan to push on more examples.
Reference: [35] <author> Fong Pong and Michel Dubois. </author> <title> A new approach for the verification of cache coherence protocols. </title> <journal> IEEE Trans. Parallel and Distributed Systems, </journal> <volume> 6(8), </volume> <month> August </month> <year> 1995. </year>
Reference-contexts: Only a single step is needed since we assume clients and servers will detect failures within t in which case the run of the protocol ends. Pong and Dubois exploit knowledge of their domain in choosing abstractions for verifying cache coherence protocols for shared memory multiprocessor systems <ref> [35] </ref> (a different domain from ours since we have a different model of communication and we need to deal with faults). They observe that correctness of a cache coherence protocol for those systems is not dependent on the exact number of cached copies, which in general could be unbounded.
Reference: [36] <author> A.W. Roscoe and H. MacCarthy. </author> <title> A case study in model-checking CSP. </title> <note> submitted for publication, </note> <month> October </month> <year> 1994. </year>
Reference-contexts: Roscoe and MacCarthy make a similar point in their work using FDR to model check data-independent properties of concurrent processes <ref> [36] </ref>; Wolper provides a formal justification for data-independence [43].
Reference: [37] <author> M. Satyanarayanan, J.J. Kistler, P. Kumar, </author> <title> M.E. Okasaki, E.H. Siegel, and D.C. Steere. Coda: A highly available file system for a distributed workstation environment. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(4), </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: In 1993 Mummert, as part of her Ph.D. thesis work, started implementing a more complicated invalidation-based cache coherence protocol [33], similar to AFS-2, as a variation for the Coda Distributed File System <ref> [37] </ref>. We call Mummert's extension to Coda's protocol Coda+. It was this work that inspired our initial investigation of this case study since Mummert wanted a way to prove formally that her protocol design was correct.
Reference: [38] <author> Mahadev Satyanarayanan, John Howard, David Nicols, Robert Sidebotham, Alfred Spector, and Michael West. </author> <title> The ITC Distributed File System: </title> <booktitle> Principles and Design. In The Tenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 35-50. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1985. </year>
Reference-contexts: A validation-based technique, AFS-1, was used in the Andrew File System from 1984-1985 <ref> [38] </ref>; for performance reasons, an invalidation-based technique, AFS-2, replaced AFS-1 and has been in use in Andrew since 1985 [24].
Reference: [39] <author> Fred B. Schneider. </author> <title> What good are models and what models are good? In Sape Mullender, editor, </title> <booktitle> Distributed Systems, </booktitle> <address> New York, 1993. </address> <publisher> AddisonWesley Publishing Company. </publisher> <pages> pp. 20-21. </pages>
Reference-contexts: Moreover, since the protocol relies on timeouts for detecting failures, in fact the actual system can be viewed as synchronous <ref> [39] </ref>. Thus, we need only use SMV's synchronous modeling capability. SMV expects input specifications ( of Figure 1) in the form of Computa- tional Tree Logic (CTL), a subset of branching time temporal logic.
Reference: [40] <author> N. Shankar, S. Owre, and J. Rushby. </author> <title> The pvs proof checker: A reference manual (draft). </title> <type> Technical report, </type> <institution> Comp. Sci. Lab. SRI International, </institution> <address> Menlo Park, CA, </address> <year> 1993. </year>
Reference-contexts: Approaches to combine model checking with theorem proving include work by Hungar [25] and Kurshan and Lamport [28], and in tools such as the Stanford Temporal Prover (STeP) [30] and SRI's PVS <ref> [40] </ref> 2 .
Reference: [41] <author> R.N. Sidebotham. </author> <title> Volumes: The Andrew File System data structuring primitive. </title> <booktitle> In European Unix User Group Conference Proceedings, </booktitle> <month> August </month> <year> 1986. </year> <note> Also available as technical report CMU-ITC-053, </note> <institution> Carnegie Mellon University, Information Technology Center. </institution>
Reference-contexts: A volume is a collection of files forming a partial subtree in the file name space <ref> [41] </ref>. A file is contained in exactly one volume. The servers on which a volume is stored is called the volume storage group (VSG). At any time, the subset of those servers available is called the accessible volume storage group (AVSG).
Reference: [42] <author> Mandana Vaziri-Farahani. </author> <title> Using symbolic model checking to verify cache coherence in a distributed file system. </title> <type> Technical Report CMU-CS-95-156, </type> <institution> Carnegie Mellon Computer Science Department, 1995. CMU Electrical and Computer Engineering Bachelor's Thesis. </institution>
Reference-contexts: Each arc is labeled by the name of the message received by the client (server). 4.3.2 SMV Input and Output for Coda+ We omit the actual SMV input and output for Coda+ since they are similar to that for AFS-1 and AFS-2 (see <ref> [42] </ref> for details). The property we check is the same cache coherence property, CC 0 , as that checked for AFS-2 (since we need to take into account transmission delay for Coda+ too). SMV's output for Coda+ indicates that the cache coherence invariant (CC 0 ) is true.
Reference: [43] <author> P. Wolper. </author> <title> Expressing interesting properties of programs in propositional temporal logic. </title> <booktitle> In Proc. of Principles of Programming Languages, </booktitle> <pages> pages 184-193, </pages> <year> 1986. </year>
Reference-contexts: Roscoe and MacCarthy make a similar point in their work using FDR to model check data-independent properties of concurrent processes [36]; Wolper provides a formal justification for data-independence <ref> [43] </ref>.
References-found: 43

