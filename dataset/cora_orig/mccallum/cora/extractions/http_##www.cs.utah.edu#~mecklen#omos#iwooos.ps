URL: http://www.cs.utah.edu/~mecklen/omos/iwooos.ps
Refering-URL: http://www.cs.utah.edu/~mecklen/publications.html
Root-URL: 
Email: dbo@cs.utah.edu mecklen@cs.utah.edu  
Title: OMOS An Object Server for Program Execution  
Author: Douglas B. Orr Robert W. Mecklenburg 
Address: Salt Lake City, UT 84112 Salt Lake City, UT 84112  
Affiliation: Department of Computer Science Department of Computer Science  
Abstract: The benefits of object-oriented programming are well known, but popular operating systems provide very few object-oriented features to users, and few are implemented using object-oriented techniques themselves. In this paper we discuss a mechanism for applying object-oriented programming concepts to program binding (linking) and execution. We describe OMOS, an object/meta-object server that embodies a flexible object framework. The OMOS framework projects an object-oriented structure onto programs and shared libraries that may not have been originally developed for use within an object-oriented environment. This framework provides natural facilities for inheritance, interposition, and overloading of operations, as well as development of classes with dynamically evolving behavior. 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mike Accetta, Robert Baron, William Bolosky, David Golub, Richard Rashid, Avadis Tevanian, and Michael Young. </author> <title> Mach: A new kernel foundation for UNIX development. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 93-112, </pages> <address> Atlanta, GA, June 9-13, 1986. </address> <publisher> Usenix Association. </publisher>
Reference-contexts: Since the invocation mechanism is not lightweight, it is expected most OMOS meta-objects will specify medium and heavy-weight objects. Thus we do not envision OMOS as an object construction server in the customary object-oriented run-time system sense. OMOS is designed to support clients running on microkernels such as Mach <ref> [1] </ref> or Chorus [25], or on traditional monolithic kernels that have adequate VM and IPC facilities. 3.1 Meta-objects The primary function of OMOS is to produce instances of the classes specified by meta-objects. OMOS meta-objects export a construct method which can produce instances of the class.
Reference: [2] <author> G. T. Almes, A. P. Black, E. D. Lazowska, and J. D. Noe. </author> <title> The Eden system: A technical review. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(1):43-59, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: References to native libc routines in the debugging routine are preserved. 6 Related work Many other systems exist that support dynamic creation of objects and invocation of methods on those objects. The majority of the systems, such as Argus [19], Eden <ref> [2] </ref>, COOL [14], CLOUDS [10], SOS [27], and COMANDOS/Guide [3] provide a more comprehensive object model which dictate how object distribution and migration are to be accomplished. They tend to use large-grained, active objects. Emerald [5] provides a language model for both active and passive objects.
Reference: [3] <author> R. Balter, J. Bernadat, D. Decouchant, A. Duda, A. Freyssinet, S. Krakowiak, M. Meysembourg, P. Le Dot, H. Nguyen Van, E. Paire, M. Riveill, C. Roisin, X. Rousset de Pina, R. Scoiville, and G. Vandome. </author> <title> Architecture and implementation of Guide, an object-oriented distributed system. </title> <journal> Computing Systems, </journal> <volume> 4(1) </volume> <pages> 31-67, </pages> <month> Winter </month> <year> 1991. </year>
Reference-contexts: The majority of the systems, such as Argus [19], Eden [2], COOL [14], CLOUDS [10], SOS [27], and COMANDOS/Guide <ref> [3] </ref> provide a more comprehensive object model which dictate how object distribution and migration are to be accomplished. They tend to use large-grained, active objects. Emerald [5] provides a language model for both active and passive objects.
Reference: [4] <author> A. D. Birrell and B. J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1), </volume> <month> February </month> <year> 1984. </year>
Reference-contexts: The source file may be provided by a user or dynamically generated within OMOS. 4.5 User interface OMOS exports an interface to clients that permits them to instantiate objects and to create meta-objects and fragments. To instantiate an object, the client invokes OMOS through a remote procedure call <ref> [4] </ref> and presents the path name of a meta-object which is to be executed. The user also provides a list of memory regions (a memory constraint) specifying where the resulting object should be placed. A zero-length constraint vector means the object may be placed anywhere.
Reference: [5] <author> A. P. Black, N. Huchinson, E. Jul, H. Levy, and L. Carter. </author> <title> Distribution and abstract types in Emerald. </title> <journal> IEEE Trans on Software Engineering, </journal> <volume> SE-13(1):65-76, </volume> <year> 1987. </year>
Reference-contexts: The majority of the systems, such as Argus [19], Eden [2], COOL [14], CLOUDS [10], SOS [27], and COMANDOS/Guide [3] provide a more comprehensive object model which dictate how object distribution and migration are to be accomplished. They tend to use large-grained, active objects. Emerald <ref> [5] </ref> provides a language model for both active and passive objects. Argus places a special focus on reliability, providing transactional control of operations on objects.
Reference: [6] <author> Gilad Bracha. </author> <title> The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> March </month> <year> 1992. </year> <pages> 143 pp. </pages>
Reference-contexts: Inheritance, as formulated in particular programming languages, is inappropriate as a basis for module combination because it is too burdened with linguistic constraints not directly related to modules. Fortunately, recent work by Bracha <ref> [6, 7] </ref> and others [8, 15, 22, 29, 17, 9] has centered on formulating a theoretical basis for module combination and manipulation independent of inheritance. The work assumes that we have decoupled inheritance from subtyping and focuses on decomposing inheritance into more basic module operators.
Reference: [7] <author> Gilad Bracha and Gary Lindstrom. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages, </booktitle> <pages> pages 282-290, </pages> <address> San Francisco, CA, April 20-23 1992. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: Inheritance, as formulated in particular programming languages, is inappropriate as a basis for module combination because it is too burdened with linguistic constraints not directly related to modules. Fortunately, recent work by Bracha <ref> [6, 7] </ref> and others [8, 15, 22, 29, 17, 9] has centered on formulating a theoretical basis for module combination and manipulation independent of inheritance. The work assumes that we have decoupled inheritance from subtyping and focuses on decomposing inheritance into more basic module operators. <p> Modules may include both declarations and definitions of symbols. A declaration gives the type of a symbol but no value binding for it. The set of module operators, as de scribed by Bracha <ref> [7] </ref>, is small and well defined 3 : Merge: k g : m 1 k g m 2 yields the concatenation of m 1 and m 2 . The modules must not have any names in common. <p> When combining modules name conflicts are not allowed and produce an error when encountered. Other operators in the Bracha suite are used to resolve name conflicts. 3 In <ref> [7] </ref>, Bracha develops a denotational semantics for module operations based on the lambda calculus. This formal semantics represents modules as generators, which are functions with a self parameter which becomes bound upon module instantiation. Hence, we use a subscript, g, on module operator names.
Reference: [8] <author> L. Cardelli and J. C. Mitchell. </author> <title> Operations on records. </title> <type> Technical Report Tech. Rep. 48, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: Inheritance, as formulated in particular programming languages, is inappropriate as a basis for module combination because it is too burdened with linguistic constraints not directly related to modules. Fortunately, recent work by Bracha [6, 7] and others <ref> [8, 15, 22, 29, 17, 9] </ref> has centered on formulating a theoretical basis for module combination and manipulation independent of inheritance. The work assumes that we have decoupled inheritance from subtyping and focuses on decomposing inheritance into more basic module operators.
Reference: [9] <author> W. Cook, W. Hill, and P. Canning. </author> <title> Inheritancee is not subtyping. </title> <booktitle> In Proceeding of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <year> 1990. </year>
Reference-contexts: Inheritance, as formulated in particular programming languages, is inappropriate as a basis for module combination because it is too burdened with linguistic constraints not directly related to modules. Fortunately, recent work by Bracha [6, 7] and others <ref> [8, 15, 22, 29, 17, 9] </ref> has centered on formulating a theoretical basis for module combination and manipulation independent of inheritance. The work assumes that we have decoupled inheritance from subtyping and focuses on decomposing inheritance into more basic module operators.
Reference: [10] <author> Partha Dasgupta, R. Ananthanarayanan, Sathis Menon, Ajay Mohindra, Mark Pearson, Raymond Chen, and Christoper Wilkenloh. </author> <title> Language and operating system support for distributed pro-gramming in Clouds. </title> <booktitle> In Proceedings of the Symposium on Experiences with Distributed and Mul-tiprocesor Systems (SEDMS II), </booktitle> <pages> pages 321-340, </pages> <address> Atlanta, GA, March 21-22, 1990. </address> <publisher> Usenix Association. </publisher>
Reference-contexts: References to native libc routines in the debugging routine are preserved. 6 Related work Many other systems exist that support dynamic creation of objects and invocation of methods on those objects. The majority of the systems, such as Argus [19], Eden [2], COOL [14], CLOUDS <ref> [10] </ref>, SOS [27], and COMANDOS/Guide [3] provide a more comprehensive object model which dictate how object distribution and migration are to be accomplished. They tend to use large-grained, active objects. Emerald [5] provides a language model for both active and passive objects.
Reference: [11] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference: [12] <author> R. A. Gingell, M. Lee, X. T. Dang, and M. S. Weeks. </author> <title> Shared libraries in SunOS. </title> <booktitle> In Usenix Conference Proceedings, </booktitle> <pages> pages 131-145, </pages> <address> Phoenix, AZ, </address> <month> Summer </month> <year> 1987. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: Furthermore, OMOS is oriented towards integration with existing operating system environments rather than rebuilding the foundations of program structure. Towards the other end of the spectrum, there are a number of interesting shared library implementations <ref> [12] </ref> which allow multiple clients to share code and data. Most of these facilities are based on a pragmatic, traditional view of programs, and do not provide the ability to dynamically load or recombine objects. Packages also exist to aid programmers in the dynamic loading of code and data [16].
Reference: [13] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Thus a meta-object, in effect, contains a class declaration for the object it describes. The class declaration embodied within an OMOS meta-object is interpreted at run-time. These are similar to the first-class objects used to represent classes within languages such as Smalltalk <ref> [13] </ref> and CLOS [28]. OMOS uses module operations as a mechanism for implementing class hierarchies. While elegant from a language perspective, this framework also provides the building blocks with which one can construct complex object-based systems.
Reference: [14] <author> Sabine Habert, Laurence Mosseri, and Vadim Abrossimov. </author> <title> COOL: Kernel support for object-oriented environments. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 26(4) </volume> <pages> 269-277, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: References to native libc routines in the debugging routine are preserved. 6 Related work Many other systems exist that support dynamic creation of objects and invocation of methods on those objects. The majority of the systems, such as Argus [19], Eden [2], COOL <ref> [14] </ref>, CLOUDS [10], SOS [27], and COMANDOS/Guide [3] provide a more comprehensive object model which dictate how object distribution and migration are to be accomplished. They tend to use large-grained, active objects. Emerald [5] provides a language model for both active and passive objects.
Reference: [15] <author> R. Harper and B. Pierce. </author> <title> A record calculus based on symmetric concatenation. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 131-142, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Inheritance, as formulated in particular programming languages, is inappropriate as a basis for module combination because it is too burdened with linguistic constraints not directly related to modules. Fortunately, recent work by Bracha [6, 7] and others <ref> [8, 15, 22, 29, 17, 9] </ref> has centered on formulating a theoretical basis for module combination and manipulation independent of inheritance. The work assumes that we have decoupled inheritance from subtyping and focuses on decomposing inheritance into more basic module operators.
Reference: [16] <author> W. Ho and Wilson. DLD: </author> <title> A Dynamic Link/Unlink Editor. Free Software Foundation. </title>
Reference-contexts: Most of these facilities are based on a pragmatic, traditional view of programs, and do not provide the ability to dynamically load or recombine objects. Packages also exist to aid programmers in the dynamic loading of code and data <ref> [16] </ref>.
Reference: [17] <author> R. E. Johnson and V. F. Russo. </author> <title> Reusing object-oriented designs. </title> <type> Technical Report UIUCDCS 91-1696, </type> <institution> University of Illinois at Urbana-Champagne, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Inheritance, as formulated in particular programming languages, is inappropriate as a basis for module combination because it is too burdened with linguistic constraints not directly related to modules. Fortunately, recent work by Bracha [6, 7] and others <ref> [8, 15, 22, 29, 17, 9] </ref> has centered on formulating a theoretical basis for module combination and manipulation independent of inheritance. The work assumes that we have decoupled inheritance from subtyping and focuses on decomposing inheritance into more basic module operators.
Reference: [18] <author> W. N. Joy, R. S. Fabry, S. J. Le*er, and M. K. McKusick. </author> <title> 4.2 BSD System Manual. </title> <institution> Computer Systems Research Group, Computer Science Division, University of California, Berkeley, </institution> <address> CA, </address> <year> 1983. </year>
Reference-contexts: The majority of module operations have been implemented. A port to BSD Unix <ref> [18] </ref> is planned. OMOS has been used to conduct experiments in automatically generating locality-of-reference optimization in running systems [23]. The basic OMOS system comprises 7,100 lines of C++ code. Tests show OMOS to be efficient. OMOS meta--objects cache intermediate results, allowing them to avoid unnecessary recalculations.
Reference: [19] <author> Barbara H. Liskov. </author> <title> Distributed Systems: Methods and Tools for Specifications, </title> <booktitle> chapter The Argus Language and System, </booktitle> <pages> pages 343-430. </pages> <booktitle> Lecture Notes in Computer Science no. </booktitle> <volume> 190. </volume> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: References to native libc routines in the debugging routine are preserved. 6 Related work Many other systems exist that support dynamic creation of objects and invocation of methods on those objects. The majority of the systems, such as Argus <ref> [19] </ref>, Eden [2], COOL [14], CLOUDS [10], SOS [27], and COMANDOS/Guide [3] provide a more comprehensive object model which dictate how object distribution and migration are to be accomplished. They tend to use large-grained, active objects. Emerald [5] provides a language model for both active and passive objects.
Reference: [20] <author> B. Meyer. </author> <title> Eiffel: Programming for reusability and extendability. </title> <journal> SIGPLAN Notices, </journal> <volume> 22(2), </volume> <month> February 187. </month>
Reference-contexts: Emerald [5] provides a language model for both active and passive objects. Argus places a special focus on reliability, providing transactional control of operations on objects. CLOUDS has further refined the notion of locality and defined its own extensions to popular languages (notably Eiffel <ref> [20] </ref>, C++, and LISP), segregating its objects into those used locally and those used remotely. Relative to complete systems such as these, OMOS provides simple, basic technology. OMOS concentrates on making existing objects available, and allowing extensive combinations of existing objects.
Reference: [21] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Hertfor-shire, England, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction In recent years object-oriented programming has gained widespread support due to its facilities for controlling modularity, division of responsibility, support for code reuse, and scalability <ref> [21] </ref>. We believe these features can be profitably applied to the problem of program binding and execution to achieve a more elegant solution than is currently available, while also providing increased functionality.
Reference: [22] <author> J. Mitchell, S. Meldal, and N. Madhav. </author> <title> An extension of standard ML modules with subtyping and inheritance. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 270-278, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Inheritance, as formulated in particular programming languages, is inappropriate as a basis for module combination because it is too burdened with linguistic constraints not directly related to modules. Fortunately, recent work by Bracha [6, 7] and others <ref> [8, 15, 22, 29, 17, 9] </ref> has centered on formulating a theoretical basis for module combination and manipulation independent of inheritance. The work assumes that we have decoupled inheritance from subtyping and focuses on decomposing inheritance into more basic module operators.
Reference: [23] <author> Douglas B. Orr, Robert W. Mecklenburg, Pete Hoogenboom, and Jay Lepreau. </author> <title> Dynamic program monitoring and transformation using the OMOS object server. </title> <note> Submitted for publication. </note>
Reference-contexts: Obviously, many other forms of program transformation can be performed by meta-objects in response to various events or conditions. Once profiling information has been collected, it might be used to automatically produce an improved version of the object <ref> [23] </ref>. Another use of dynamic meta-object modification might be to collect objects into sharable groups. Clustering and sharing related objects have well-known benefits in savings of physical resources, as in the case of shared libraries [26]. <p> The majority of module operations have been implemented. A port to BSD Unix [18] is planned. OMOS has been used to conduct experiments in automatically generating locality-of-reference optimization in running systems <ref> [23] </ref>. The basic OMOS system comprises 7,100 lines of C++ code. Tests show OMOS to be efficient. OMOS meta--objects cache intermediate results, allowing them to avoid unnecessary recalculations.
Reference: [24] <author> D. M. Ritchie and K. Thompson. </author> <title> The UNIX time-sharing system. </title> <journal> The Bell System Technical Journal, </journal> <volume> 57(6) </volume> <pages> 1905-1930, </pages> <month> July/August </month> <year> 1978. </year>
Reference-contexts: Government, or Hewlett-Packard. tion. We also describe the implementation of OMOS, an object/meta-object server which implements these concepts as a process in the Unix 2 operating system. Current technology for constructing programs from modules is clumsy and lacks structure <ref> [24] </ref>. This clumsiness results in inefficiency which manifests as poor use of programmer skills, poor locality of program reference, poor reuse of existing code, poor use of virtual address space, and poor use of cpu time (i.e., avoidable recalculations). This lack of structure is, of course, not without reason.
Reference: [25] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> The Chorus distributed operating system. </title> <journal> Computing Systems, </journal> <volume> 1(4) </volume> <pages> 287-338, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Thus we do not envision OMOS as an object construction server in the customary object-oriented run-time system sense. OMOS is designed to support clients running on microkernels such as Mach [1] or Chorus <ref> [25] </ref>, or on traditional monolithic kernels that have adequate VM and IPC facilities. 3.1 Meta-objects The primary function of OMOS is to produce instances of the classes specified by meta-objects. OMOS meta-objects export a construct method which can produce instances of the class.
Reference: [26] <author> Donn Seeley. </author> <title> Shared libraries as objects. </title> <booktitle> In Proceedings of the Summer 1990 USENIX Conference, </booktitle> <pages> pages 1-12, </pages> <address> Anaheim, California, June 11-15, 1990. </address> <publisher> Usenix Association. </publisher>
Reference-contexts: Another use of dynamic meta-object modification might be to collect objects into sharable groups. Clustering and sharing related objects have well-known benefits in savings of physical resources, as in the case of shared libraries <ref> [26] </ref>.
Reference: [27] <author> Marc Shapiro, Yvon Gourhant, Sabine Habert, Laurence Mosseri, Michel Ruffin, and Celine Valot. </author> <title> SOS: An object-oriented operating systems|assessment and perspectives. </title> <journal> Computing Systems, </journal> <volume> 2(4) </volume> <pages> 287-337, </pages> <month> Fall </month> <year> 1989. </year>
Reference-contexts: References to native libc routines in the debugging routine are preserved. 6 Related work Many other systems exist that support dynamic creation of objects and invocation of methods on those objects. The majority of the systems, such as Argus [19], Eden [2], COOL [14], CLOUDS [10], SOS <ref> [27] </ref>, and COMANDOS/Guide [3] provide a more comprehensive object model which dictate how object distribution and migration are to be accomplished. They tend to use large-grained, active objects. Emerald [5] provides a language model for both active and passive objects.
Reference: [28] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <note> Digital Press, second edition, </note> <year> 1990. </year>
Reference-contexts: Thus a meta-object, in effect, contains a class declaration for the object it describes. The class declaration embodied within an OMOS meta-object is interpreted at run-time. These are similar to the first-class objects used to represent classes within languages such as Smalltalk [13] and CLOS <ref> [28] </ref>. OMOS uses module operations as a mechanism for implementing class hierarchies. While elegant from a language perspective, this framework also provides the building blocks with which one can construct complex object-based systems. <p> The construct method may be overridden to permit dynamic meta-object modification, as described in Section 3.2. 5.2 Blueprint language Within OMOS meta-objects, the actual description of how to construct an object instance is encoded in a blueprint using a simple language. The blueprint language uses a simple LISP-like syntax <ref> [28] </ref>. The language includes operations corresponding to each of the module operations described above. Each operation takes a variable-sized list of arguments; arguments are object names, strings, or other operation expressions. Each operation produces an object as its output.
Reference: [29] <author> Alan Synder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proceedings of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications, </booktitle> <pages> pages 38-45, </pages> <year> 1986. </year>
Reference-contexts: Inheritance, as formulated in particular programming languages, is inappropriate as a basis for module combination because it is too burdened with linguistic constraints not directly related to modules. Fortunately, recent work by Bracha [6, 7] and others <ref> [8, 15, 22, 29, 17, 9] </ref> has centered on formulating a theoretical basis for module combination and manipulation independent of inheritance. The work assumes that we have decoupled inheritance from subtyping and focuses on decomposing inheritance into more basic module operators.
References-found: 29

