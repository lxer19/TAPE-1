URL: http://www.cs.utexas.edu/users/taowang/paper/wizard.ps
Refering-URL: http://www.cs.utexas.edu/users/taowang/research.html
Root-URL: 
Title: Page 1 Design Wizards and Visual Languages for Generators  
Author: Don Batory, Gang Chen, Eric Robertson, and Tao Wang 
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences University of Texas at Austin  
Abstract: Domainspecific generators will increasingly rely on graphical specification languages applets for declarative specifications of target applications. Applets will provide front-ends to generators and related tools to produce customized code on demand. Critical to the success of this approach will be domainspecific design wizards, tools that guide users in their selection of components for constructing particular applications. In this paper, we present the P3 ContainerStore applet, its generator, and design wizard. 
Abstract-found: 1
Intro-found: 1
Reference: [Bal85] <author> R. Balzer, </author> <title> A Fifteen-Year Perspective on Automatic Programming, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> November </month> <year> 1985. </year>
Reference-contexts: Generators are compilers for DSLs [Sma97]. Component-based generators, such as P2 and P3, show how reusable components form the basis of a powerful technology for producing high-performance, customized applications in a DSL setting. The automatic selection of data structures is an example of automatic programming <ref> [Bal85] </ref>. SETL is a set-oriented language where implementations of sets can be specified manually or determined automatically [Sch81]. <p> AP5 has comparable capabilities and takes a similar approach [Coh93]. Deductive program synthesis is another way to achieve automatic programming <ref> [Bal85, Smi90, Man92, Low94, Kan93] </ref>. The idea is to define a domain theory (typically in first order logic) that expresses fundamental relationships among basic domain entities.
Reference: [Bat93] <author> D. Batory, V. Singhal, M. Sirkin, and J. Thomas, </author> <title> Scalable Software Libraries, </title> <booktitle> ACM SIGSOFT 1993. </booktitle>
Reference-contexts: 1 Introduction Domainspecific languages (DSLs) will become progressively more important as a medium for specifying customized applications <ref> [Bat93, Kie96, Due97, Sma97] </ref>. Generators will be the tools that convert DSL application specifications into optimized source code. Visual programming languages, such as Visual Basic and Java applets, will simplify the use of DSLs and promote their promulgation. <p> in 3 include parameterized selections (i.e., city () == x, where x is specified at runtime) and declarations of cursor usage (e.g., retrieval only, element modification/deletion, etc.) for optimizing generated code. 4 Performance of P3-Generated Code Generators, contrary to handwritten component libraries, offer a scalable way to produce customized software <ref> [Bat93, Big94] </ref>. The declarative way in which P3 users specify container and cursor implementations through component composition leads to scalable families of customized data structures. As shown in [Bat97c], significant increases in productivity and major cost reductions both in maintenance and experimentation with different container implementations can result from generators. <p> We performed a number of experiments that benchmarked productivity and performance; the most revealing of which are presented here. The benchmark of <ref> [Bat93] </ref> was used to evaluate the performance of the Booch Components, libg++, and the P1 and P2 generators. We used this program for our studies. The program spellchecks a document against a dictionary of 25,000 words. <p> DSLs offer concise ways of expressing complex, domainspecific concepts and applications, which in turn can offer substantially reduced maintenance costs, more evolvable software, and significant increases in software productivity <ref> [Bat93, Kie96, Due97] </ref>. Generators are compilers for DSLs [Sma97]. Component-based generators, such as P2 and P3, show how reusable components form the basis of a powerful technology for producing high-performance, customized applications in a DSL setting. The automatic selection of data structures is an example of automatic programming [Bal85].
Reference: [Bat94] <author> D. Batory, J. Thomas, and M. Sirkin, </author> <title> Reengineering a Complex Application Using a Scalable Data Structure Compiler, </title> <booktitle> ACM SIGSOFT 1994. </booktitle>
Reference: [Bat97a] <author> D. Batory and B.J. Geraci, </author> <title> Validating Component Compositions and Subjectivity in GenVoca Generators, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> February </month> <year> 1997, </year> <pages> 67-82. </pages>
Reference-contexts: In the case that an equation is incorrect i.e., constraints for the correct usage of a component have been violated . Tab Page 3 (see <ref> [Bat97a] </ref>) the Explain Window lists the errors and suggests reparations. <p> Knowledge of when and how to use a component effectively to maximize performance or to meet a design objective is quite different than design rules (i.e., requirements that define the correct usage of a component <ref> [Bat97a] </ref>). What form this knowledge will take, what is a general model to express such knowledge, and how to optimize type equations remain open problems. Short of proposing a general-purpose theory, it is possible to develop ad hoc techniques for given domains, and in particular, for data structures. <p> Properties are attributes that classify components <ref> [Bat97a] </ref>. In Figure 6 seven different properties are defined. logical_key is the propositional symbol for the attribute that defines a key-ordered component, i.e., a P3 component that implements a data structure that stores elements in key order. Red-black trees, ordered doubly-linked lists, etc. are components that have this property. <p> As we will see shortly, properties are used to express both design rules and type equation rewrite rules (discussed in the next section). Consistent with the experience discussed in <ref> [Bat97a] </ref>, determining these properties is a fairly straightforward task. Signatures define the export and import interfaces of a component; these properties are used to determine if a component usage in a type equation is syntactically correct. In Figure 6, we circled the signature for red-black trees . <p> Domainspecific constraints called design rules are needed to define the legal uses of a component. The algorithms that we use for design rule checking are given in <ref> [Bat97a] </ref>. Design rules are expressed in two parts. First, properties that are asserted or negated by a component are broadcast to all layers that lie above it and below it in a type equation. These properties are declared by the asserted properties and negated properties statements. <p> In contrast, GenVoca is different both in component scale and in the simplicity of the relationships among domain entities. GenVoca components are subsystems suites of interrelated OO classes. (A P3 component for example encapsulates three classes: a cursor class, a container class, and an element class). As noted in <ref> [Bat97a] </ref>, scaling the size of components and designing components to be plug-compatible has a nonobvious effect: the relationships that exist among components tend to be very simple, and elementary inferencing (i.e., no theorem provers) is adequate.
Reference: [Bat97b] <author> D. Batory, B. Lofaso, and Y. Smaragdakis, JTS: </author> <title> A Tool Suite for Building GenVoca Generators, </title> <note> submitted for publication, 1997. 5. The capabilities described in this paper were demonstrated at the DARPA EDCS Workshop in Seattle, </note> <month> July </month> <year> 1997. </year> <pages> Page 13 </pages>
Reference-contexts: last button sends this specification to ContainerStores design wizard to be analyzed and critiqued for its efficiency. (Section 5 elaborates this workload specification and analysis). 3 The P3 Generator The Jakarta Tool Suite (JTS) is a set of domain-independent tools for building extensible domainspecific languages and GenVoca (or component-based) generators <ref> [Bat97b] </ref>. JTS is written in Jak, an extensible superset of the Java language. Jak minimally extends Java with the addition of metaprogramming features (e.g., syntax tree constructors) so that Java programs can create and manipulate other Java programs.
Reference: [Bat97c] <author> D. Batory, </author> <title> Intelligent Components and Software Generators, </title> <booktitle> Software Quality Institute Symposium on Software Reliability, </booktitle> <address> Austin, Texas, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: The declarative way in which P3 users specify container and cursor implementations through component composition leads to scalable families of customized data structures. As shown in <ref> [Bat97c] </ref>, significant increases in productivity and major cost reductions both in maintenance and experimentation with different container implementations can result from generators.
Reference: [Bax92] <author> I. Baxter, </author> <title> Design Maintenance Systems, </title> <journal> CACM April 1992, </journal> <pages> 73-89. </pages>
Reference: [Big94] <author> T. Biggerstaff, </author> <title> The Library Scaling Problem and the Limits of Concrete Component Reuse, </title> <booktitle> International Conference on Software Reuse, </booktitle> <address> Rio de Janeiro, </address> <month> November 1-4, </month> <year> 1994, </year> <pages> 102-110. </pages>
Reference-contexts: in 3 include parameterized selections (i.e., city () == x, where x is specified at runtime) and declarations of cursor usage (e.g., retrieval only, element modification/deletion, etc.) for optimizing generated code. 4 Performance of P3-Generated Code Generators, contrary to handwritten component libraries, offer a scalable way to produce customized software <ref> [Bat93, Big94] </ref>. The declarative way in which P3 users specify container and cursor implementations through component composition leads to scalable families of customized data structures. As shown in [Bat97c], significant increases in productivity and major cost reductions both in maintenance and experimentation with different container implementations can result from generators.
Reference: [Bro97] <author> S.V. Browne and J.W. Moore, </author> <title> Reuse Library Interoperability and the World Wide Web, </title> <booktitle> Int. Conference on Software Engineering, </booktitle> <month> May </month> <year> 1997, </year> <pages> 684 691. </pages>
Reference: [Che97] <author> G. Chen, </author> <title> P3 Performance Report, </title> <institution> UTCS, University of Texas at Austin, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: Internally, CAL implements Set by hash table. *** Pizza Vector data structure is used here. Table 3 Execution times of dictionary benchmark programs (in secs) Page 6 generators can provide. Further analysis is given in <ref> [Che97] </ref> The point of our experiments was to provide minimal confirmation that P3 generates code comparable to that written by hand. Clearly, many more experiments are needed.
Reference: [Coh93] <author> D. Cohen and N. Campbell, </author> <title> Automating Relational Operations on Data Structures, </title> <journal> IEEE Software, </journal> <month> May </month> <year> 1993. </year>
Reference-contexts: SETL offers very few set implementations (bit vector, indexed set, and hashing), and relies on a static analysis of a SETL program using heuristics rather than using cost-based optimizations to decide which set implementation to use. AP5 has comparable capabilities and takes a similar approach <ref> [Coh93] </ref>. Deductive program synthesis is another way to achieve automatic programming [Bal85, Smi90, Man92, Low94, Kan93]. The idea is to define a domain theory (typically in first order logic) that expresses fundamental relationships among basic domain entities.
Reference: [Das95] <author> D. Das and D. Batory, Prairie: </author> <title> A Rule Specification Framework for Query Optimizers. </title> <booktitle> International Conference on Data Engineering, </booktitle> <address> Taipei, </address> <month> March </month> <year> 1995, </year> <pages> 201-210. </pages>
Reference-contexts: The techniques we used for optimizing type equations are similar to those of rule-based query optimization <ref> [Das95, War97] </ref>. A query is represented by an expression where terms correspond to relational operators (e.g., join, sort, select). Query optimization progressively rewrites a query expression according to a set of rules, where the goal is to Page 12 find the expression with the lowest cost.
Reference: [Due97] <author> A. Van Duersen and P. Klint, </author> <title> Little Languages: Little Maintenance?, </title> <booktitle> Proc. First ACM SIGPLAN Workshop on DomainSpecific Languages, </booktitle> <address> Paris 1997. </address>
Reference-contexts: 1 Introduction Domainspecific languages (DSLs) will become progressively more important as a medium for specifying customized applications <ref> [Bat93, Kie96, Due97, Sma97] </ref>. Generators will be the tools that convert DSL application specifications into optimized source code. Visual programming languages, such as Visual Basic and Java applets, will simplify the use of DSLs and promote their promulgation. <p> DSLs offer concise ways of expressing complex, domainspecific concepts and applications, which in turn can offer substantially reduced maintenance costs, more evolvable software, and significant increases in software productivity <ref> [Bat93, Kie96, Due97] </ref>. Generators are compilers for DSLs [Sma97]. Component-based generators, such as P2 and P3, show how reusable components form the basis of a powerful technology for producing high-performance, customized applications in a DSL setting. The automatic selection of data structures is an example of automatic programming [Bal85].
Reference: [Eas73] <author> C.M. Eastman, </author> <title> Automated Space Planning, </title> <booktitle> Artificial Intelligence 4(1973), </booktitle> <pages> 41-64. </pages>
Reference-contexts: There are also shrink rules i.e., rules that remove components from type equations. An example is: remove a component from a type equation if it increases Cost. The optimization of a P3 type equation is similar to an AI planning process <ref> [Eas73] </ref>. We discovered that optimizing P3 equations manually followed a best-first (greedy) heuristic; we automated this search to find a correct type equation with the lowest cost with regard to the given workload, cost models, and layer declarations.
Reference: [Gog86] <author> J.A. Goguen, </author> <title> Reusing and Interconnecting Software Components, </title> <booktitle> IEEE Computer, </booktitle> <month> February </month> <year> 1986. </year>
Reference-contexts: By abstracting from specific solutions in different domains (i.e., performing a domain analysis on these solutions), a general theory may result. GenVoca offers a general framework for modeling systems as equations (see also <ref> [Gog86, Sre97] </ref>). Heuristics for improving equations (software designs) may be understood as rewrites (i.e., replace the component composition a [b []] with c [] under specific conditions). We are working on a formal model that explores this approach, and will report our results in future papers.
Reference: [Jen97] <author> P. Jenkins, D. Whitmore, G. Glass, and M. Klobe, JGL: </author> <title> the Generic Collection Library for Java, </title> <publisher> ObjectSpace Inc., </publisher> <address> URL: http:// www.objectspace.com/jgl/ , 1997. </address>
Reference: [Kan93] <editor> E. Kant, et al., </editor> <booktitle> Synthesis of Mathematical Modeling Software, IEEE Software, </booktitle> <month> May </month> <year> 1993, </year> <pages> 30 41. </pages>
Reference-contexts: AP5 has comparable capabilities and takes a similar approach [Coh93]. Deductive program synthesis is another way to achieve automatic programming <ref> [Bal85, Smi90, Man92, Low94, Kan93] </ref>. The idea is to define a domain theory (typically in first order logic) that expresses fundamental relationships among basic domain entities. <p> All container and cursor operations will be processed, but not efficiently. The challenge is finding a P3 type equation that efficiently processes that workload. Second, work on program synthesis has largely focussed on generating algorithms (e.g., algorithms for solving PDEs <ref> [Kan93] </ref>, algorithms for scheduling [Smi90], algorithms for computing solar incidence angles [Low94], etc.); subroutine libraries are the components from which generated algorithms are built. The inferences needed for algorithm synthesis tends to be quite sophisticated (thus requiring theorem provers) because there are very complex relationships among domain entities.
Reference: [Kie96] <author> R. Kieburtz, et al., </author> <title> A Software Engineering Experiment in Software Component Generation, </title> <booktitle> International Conference on Software Engineering, </booktitle> <year> 1996. </year>
Reference-contexts: 1 Introduction Domainspecific languages (DSLs) will become progressively more important as a medium for specifying customized applications <ref> [Bat93, Kie96, Due97, Sma97] </ref>. Generators will be the tools that convert DSL application specifications into optimized source code. Visual programming languages, such as Visual Basic and Java applets, will simplify the use of DSLs and promote their promulgation. <p> DSLs offer concise ways of expressing complex, domainspecific concepts and applications, which in turn can offer substantially reduced maintenance costs, more evolvable software, and significant increases in software productivity <ref> [Bat93, Kie96, Due97] </ref>. Generators are compilers for DSLs [Sma97]. Component-based generators, such as P2 and P3, show how reusable components form the basis of a powerful technology for producing high-performance, customized applications in a DSL setting. The automatic selection of data structures is an example of automatic programming [Bal85].
Reference: [Lad97] <author> R. Laddaga, </author> <title> Self-Adaptive Software Workshop, </title> <institution> Kestrel Institute, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: That is, the application determines when enough statistics have been collected, a tool called a design wizard infers an optimal data structure given this workload, and if regeneration is warranted, class regeneration and replacement is performed automatically. Such software is called self-adaptive <ref> [Lad97] </ref>, and may be the penultimate way to minimize software development and maintenance costs through component reuse. The key to achieving self-adaptive software requires a solution to the second problem deducing an efficient type equation for given a workload.
Reference: [Low94] <author> M. Lowry, A. Philpot, T. Pressburger, and I. Underwood, AMPHION: </author> <title> Automatic Programming for Scientific Subroutine Libraries. </title> <booktitle> Intl. Symp. on Methodologies for Intelligent Systems, </booktitle> <address> Charlotte, North Carolina, </address> <month> Oct. </month> <pages> 16-19, </pages> <year> 1994, </year> <pages> 326-335. </pages>
Reference-contexts: AP5 has comparable capabilities and takes a similar approach [Coh93]. Deductive program synthesis is another way to achieve automatic programming <ref> [Bal85, Smi90, Man92, Low94, Kan93] </ref>. The idea is to define a domain theory (typically in first order logic) that expresses fundamental relationships among basic domain entities. <p> The challenge is finding a P3 type equation that efficiently processes that workload. Second, work on program synthesis has largely focussed on generating algorithms (e.g., algorithms for solving PDEs [Kan93], algorithms for scheduling [Smi90], algorithms for computing solar incidence angles <ref> [Low94] </ref>, etc.); subroutine libraries are the components from which generated algorithms are built. The inferences needed for algorithm synthesis tends to be quite sophisticated (thus requiring theorem provers) because there are very complex relationships among domain entities.
Reference: [Man92] <author> Z. Manna and R. Waldinger, </author> <title> Fundamentals of Deductive Program Synthesis, </title> <journal> IEEE Trans. Software Engineering, </journal> <month> August </month> <year> 1992, </year> <pages> 674-704. </pages>
Reference-contexts: AP5 has comparable capabilities and takes a similar approach [Coh93]. Deductive program synthesis is another way to achieve automatic programming <ref> [Bal85, Smi90, Man92, Low94, Kan93] </ref>. The idea is to define a domain theory (typically in first order logic) that expresses fundamental relationships among basic domain entities.
Reference: [Mit75] <author> M.F. </author> <title> Mitoma and K.B. Irani, Automatic Database Schema Design and Optimization, </title> <booktitle> 1975 Very Large Databases Conference, </booktitle> <pages> 286-321. </pages>
Reference-contexts: Because P3 presents a relational-like interface to data Page 7 structures, relational database optimization models are an obvious starting point <ref> [Mit75] </ref>. A workload on a database relation (or P3 container) is characterized by the type and cardinality of individual attributes of an element, plus the frequency with which each container or cursor operation is performed.
Reference: [Nov95] <author> G. Novak, </author> <title> Automatic Programmer Server, </title> <note> http://www.cs.utexas.edu/novak, 1995. </note>
Reference: [Nov97] <author> G. Novak, </author> <title> Software Reuse by Specialization of Generic Procedures through Views, </title> <journal> IEEE Trans. Software Engineering, </journal> <month> July </month> <year> 1997, </year> <pages> 401-417. </pages>
Reference: [Ode97] <author> M. Odersky and P. Wadler, </author> <title> Pizza into Java Translating Theory into Practice, </title> <booktitle> ACM POPL 1997. </booktitle>
Reference-contexts: Table 1 P3 Data Structure Components Page 5 two popular and publicly available Java data structure libraries. Both are based on STL [Ste94] and are optimized for performance. Pizza (a dialect of Java that supports parametric polymorphism <ref> [Ode97] </ref>) and Suns Java Development Kit (JDK) also provide some simple data structures, so we also included them in our study.
Reference: [Sch81] <author> E. Schonberg, J.T. Schwartz, and M. Sharir, </author> <title> An Automatic Technique for Selection of Data Representations in SETL Programs, </title> <journal> ACM Trans. Prog. Languages and Systems, </journal> <month> April </month> <year> 1981, </year> <pages> 126-143. </pages>
Reference-contexts: The automatic selection of data structures is an example of automatic programming [Bal85]. SETL is a set-oriented language where implementations of sets can be specified manually or determined automatically <ref> [Sch81] </ref>. SETL offers very few set implementations (bit vector, indexed set, and hashing), and relies on a static analysis of a SETL program using heuristics rather than using cost-based optimizations to decide which set implementation to use. AP5 has comparable capabilities and takes a similar approach [Coh93].
Reference: [Sma97] <author> Y. Smaragdakis and D. Batory, DiSTiL: </author> <title> a Transformation Library for Data Structures, </title> <booktitle> USENIX Conf. on DomainSpecific Languages, </booktitle> <year> 1997. </year>
Reference-contexts: 1 Introduction Domainspecific languages (DSLs) will become progressively more important as a medium for specifying customized applications <ref> [Bat93, Kie96, Due97, Sma97] </ref>. Generators will be the tools that convert DSL application specifications into optimized source code. Visual programming languages, such as Visual Basic and Java applets, will simplify the use of DSLs and promote their promulgation. <p> DSLs offer concise ways of expressing complex, domainspecific concepts and applications, which in turn can offer substantially reduced maintenance costs, more evolvable software, and significant increases in software productivity [Bat93, Kie96, Due97]. Generators are compilers for DSLs <ref> [Sma97] </ref>. Component-based generators, such as P2 and P3, show how reusable components form the basis of a powerful technology for producing high-performance, customized applications in a DSL setting. The automatic selection of data structures is an example of automatic programming [Bal85].
Reference: [Smi90] <author> D.R. Smith, KIDS: </author> <title> A Semiautomatic Program Development System, </title> <journal> IEEE Trans. Software Engineering, </journal> <month> September </month> <year> 1990, </year> <pages> 1024-1043. </pages>
Reference-contexts: AP5 has comparable capabilities and takes a similar approach [Coh93]. Deductive program synthesis is another way to achieve automatic programming <ref> [Bal85, Smi90, Man92, Low94, Kan93] </ref>. The idea is to define a domain theory (typically in first order logic) that expresses fundamental relationships among basic domain entities. <p> All container and cursor operations will be processed, but not efficiently. The challenge is finding a P3 type equation that efficiently processes that workload. Second, work on program synthesis has largely focussed on generating algorithms (e.g., algorithms for solving PDEs [Kan93], algorithms for scheduling <ref> [Smi90] </ref>, algorithms for computing solar incidence angles [Low94], etc.); subroutine libraries are the components from which generated algorithms are built. The inferences needed for algorithm synthesis tends to be quite sophisticated (thus requiring theorem provers) because there are very complex relationships among domain entities.
Reference: [Sre97] <author> S. Sreerama, D. Fleming, M. Sitaraman, </author> <title> Graceful Object-Based Performance Evolution, </title> <journal> Software Practice and Experience, </journal> <month> January </month> <year> 1997. </year>
Reference-contexts: By abstracting from specific solutions in different domains (i.e., performing a domain analysis on these solutions), a general theory may result. GenVoca offers a general framework for modeling systems as equations (see also <ref> [Gog86, Sre97] </ref>). Heuristics for improving equations (software designs) may be understood as rewrites (i.e., replace the component composition a [b []] with c [] under specific conditions). We are working on a formal model that explores this approach, and will report our results in future papers.
Reference: [Ste94] <author> A.A. Stepanov and M. Lee, </author> <title> The Standard Template Library, HP Laboratories, </title> <type> TR HPL-94-34, </type> <year> 1994. </year>
Reference-contexts: Table 1 P3 Data Structure Components Page 5 two popular and publicly available Java data structure libraries. Both are based on STL <ref> [Ste94] </ref> and are optimized for performance. Pizza (a dialect of Java that supports parametric polymorphism [Ode97]) and Suns Java Development Kit (JDK) also provide some simple data structures, so we also included them in our study.
Reference: [War97] <author> L. Warshaw, D. Miranker, and T. Wang, </author> <title> A General Purpose Rule Language as the Basis of a Query Optimizer, </title> <institution> UTCS TR97-19, University of Texas at Austin, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: The techniques we used for optimizing type equations are similar to those of rule-based query optimization <ref> [Das95, War97] </ref>. A query is represented by an expression where terms correspond to relational operators (e.g., join, sort, select). Query optimization progressively rewrites a query expression according to a set of rules, where the goal is to Page 12 find the expression with the lowest cost.
Reference: [Pou95] <author> J.S. Poulin and K.J. Werkman, </author> <title> Melding Structured Abstracts and the World Wide Web for Retrieval of Reusable Components, </title> <booktitle> Symposium on Software Reusability (1995), </booktitle> <pages> 160-168. </pages>
Reference: [X3M97] <author> X3M Solutions, </author> <title> CAL: The Container and Algorithm Library for the Java Platform, </title> <note> URL: http://www.x3m.com/products/cal/, 1997. </note>
Reference-contexts: While we have not yet used P3 in a sophisticated Java application, we have performed preliminary benchmarks on P3-generated code to assure us that P3 is on a trajectory that is comparable with its predecessors. The Container and Algorithm Library (CAL) <ref> [X3M97] </ref> and the Java Generic Collection Library (JGL) [Jer97] are container&lt; emp &gt; empcont; cursor&lt; empcont &gt; empcursor; container ec implements empcont using odlist ( age, malloc ( ) ); cursor all (ec e); cursor few (ec e) where name () == Don && age () &gt; 20 orderby age; interface
References-found: 33

