URL: http://www.cs.washington.edu:80/homes/pardy/research/papers/GC/memUtilization.ps.Z
Refering-URL: http://www.cs.washington.edu:80/homes/pardy/research/gc/papers.html
Root-URL: http://www.cs.washington.edu
Title: Improving the Memory Utilization of a Garbage Collector  
Author: Tian F. Lim Przemys law Pardyak Brian N. Bershad 
Date: December 8, 1997  
Note: Draft of  DO NOT DISTRIBUTE  
Address: Seattle, WA, USA  
Affiliation: Department of Computer Science and Engineering University of Washington,  
Abstract: We present a new garbage collector that is both time and space efficient. Previous work on garbage collection has focussed on reducing the run time penalty of garbage collectors and has largely ignored the issue of memory utilization. This is inappropriate for new garbage collected systems like Java, Inferno, or SPIN, that may operate in environments with limited memory, such as embedded systems. Poor memory utilization requires larger heaps and increases collection overhead by forcing more frequent collections. In this paper, we demonstrate that improving memory utilization offers new opportunities to reduce the time and space requirements of garbage collectors. To this end we have developed a set of techniques that reduce fragmentation and memory requirements through page-level memory management. We have implemented these techniques in a Treadmill collector for the SPIN Modula-3 runtime. Our results demonstrate that improving memory utilization can drastically improve overhead without compromising latency. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Embeddedjava T M . http://java.sun.com/, 1997. </institution>
Reference-contexts: 1 Introduction Advanced runtime systems that provide garbage collection are becoming commonplace and are to be deployed in environments with severely limited resources. For instance, Java is expected to run on network computers and embedded devices <ref> [1] </ref>. Inferno [9] is a garbage collected operating system designed for small devices such as telephones and set-top boxes. SPIN [6] is an extensible, general-purpose operating system kernel that shares its limited-size heap among a potentially large number of extensions.
Reference: [2] <author> Brenda Baker, E. G. Coffman, and D. E. Willard. </author> <title> Algorithms for resolving conflicts in dynamic storage allocation. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 327-343, </pages> <month> April </month> <year> 1985. </year>
Reference: [3] <author> H. G. Baker. </author> <title> List processing in real-time on a serial computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-94, </pages> <year> 1978. </year>
Reference-contexts: latencies according to their causes and how different techniques improve them. 2 The bound chosen was based on the fact that 50ms is the human threshold for noticing a pause. 5 Related work Treadmill [4] and Wilson's modifications [19] to it are non-copying extensions to the original Baker real-time collector <ref> [3] </ref>. These improvements reduce overhead and support bounded allocations for objects of any size. They do not, however, address memory utilization. Page migration has been mentioned briefly [17] and implemented in Mike Haertel's quick-fit [14] allocator, but has typically relied on per-page object counts to reclaim pages.
Reference: [4] <author> H. G. Baker. </author> <title> The Treadmill, real-time garbage collection without motion sickness. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(3), </volume> <year> 1992. </year>
Reference-contexts: In addition, for a given heap size, they will collect more often because less memory is available for allocation. In this paper, we present a number of techniques based on page-level heap management that together reduce the memory requirements of a common non-copying real-time garbage collector, Treadmill <ref> [4] </ref>, without reducing its performance. 1.1 Motivation Three parameters: overhead, latency, and memory utilization determine the performance of a garbage collector. Overhead is the total allocation and collection time and should be low to improve total execution time. <p> The techniques include page migration between multiple free lists to allow any free pages to serve any allocation, page remapping to eliminate page-level fragmentation, and an allocator that fills underutilized pages to reduce sub-page fragmentation. We have implemented our techniques in Treadmill, a real-time, non-copying collector <ref> [4, 19] </ref>, which offers short and bounded pauses. It suffers from high fragmentation, however, and our techniques improve its memory utilization substantially while preserving its real-time behavior. Our new collector allows all of our benchmarks to be executed within 15MB of memory, while the unimproved Treadmill collector requires 21MB. <p> All of the techniques described in this paper focus on increasing peak memory utilization by reducing internal or external fragmentation. 2.2 Treadmill We present our work in the context of Treadmill <ref> [4] </ref>, a real-time, non-copying, implicit collector that offers bounded time allocation and memory reclamation. All objects, whether free or allocated, are kept in doubly-linked lists. Objects are allocated in constant time by moving them from the free list to the allocated list. Treadmill uses a four-color collection scheme. <p> In the full paper we split the latencies according to their causes and how different techniques improve them. 2 The bound chosen was based on the fact that 50ms is the human threshold for noticing a pause. 5 Related work Treadmill <ref> [4] </ref> and Wilson's modifications [19] to it are non-copying extensions to the original Baker real-time collector [3]. These improvements reduce overhead and support bounded allocations for objects of any size. They do not, however, address memory utilization.
Reference: [5] <author> Joel F. Bartlett. </author> <title> Compacting Garbage Collection with Ambiguous Roots. </title> <type> Technical Report WRL-TR-88-2, </type> <institution> Digital Equipment Corporation Western Research Labs, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: The 15ms bound is enforced by bounding the amount of work done at each collection increment, and starting and finishing collections before memory is exhausted. * CP the original SRC Modula-3 mostly-copying collector <ref> [5] </ref>; it is incremental but not generational. It uses VM protection for read barriers. 4.3 Minimum heap requirements To succinctly demonstrate the improved memory utilization that our collectors offer, we have measured the minimum heap size required to run each workload (Table 2).
Reference: [6] <author> B. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. Fi-uczynski, D. Becker, S. Eggers, and C. Chambers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 267-284, </pages> <year> 1995. </year>
Reference-contexts: For instance, Java is expected to run on network computers and embedded devices [1]. Inferno [9] is a garbage collected operating system designed for small devices such as telephones and set-top boxes. SPIN <ref> [6] </ref> is an extensible, general-purpose operating system kernel that shares its limited-size heap among a potentially large number of extensions.
Reference: [7] <author> Edsgar W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. </author> <title> On-the-fly garbage collection: An exercise in cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 965-975, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: Memory utilization has been largely neglected in today's collectors because memory has not been a critical resource in traditional garbage collected systems. Instead, garbage collection research has focussed on improving latency and overhead through techniques such as aggressive compiler support [18], or incremental <ref> [7] </ref> and generational [10] collection. These collectors often underutilize memory to reduce latency or overhead [18]. This approach was reasonable in the past because the operating system could be relied upon to provide ample heap space.
Reference: [8] <author> J.H. Howard, M.L. Kazar, S.G. Menees, D.A. Nichols, M. Satyanarayanan, R.N. Sidebotham, and M.J West. </author> <title> Scale and Performance in a Distributed File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1), </volume> <month> Febru-ary </month> <year> 1988. </year>
Reference-contexts: our techniques: * TRANS The RVMbench [13] transactions benchmark exercises SPIN's in-kernel transac tion services. * HTTPD The entire SPIN web tree (79 files and 5MB) is accessed 400 times by a remote machine through the SPIN in-kernel web server. * LFS A subset of the Andrew file system benchmark <ref> [8] </ref> is run on the SPIN log structured file system [12]. * BLUR A 2.5 MB image is blurred while maintaining copies of the modified pixels, similar to the way a paint program would operate. The first three benchmarks are typical OS work-loads.
Reference: [9] <author> Inferno. </author> <note> http://inferno.lucent.com/, 1996. </note>
Reference-contexts: 1 Introduction Advanced runtime systems that provide garbage collection are becoming commonplace and are to be deployed in environments with severely limited resources. For instance, Java is expected to run on network computers and embedded devices [1]. Inferno <ref> [9] </ref> is a garbage collected operating system designed for small devices such as telephones and set-top boxes. SPIN [6] is an extensible, general-purpose operating system kernel that shares its limited-size heap among a potentially large number of extensions.
Reference: [10] <author> Henry Lieberman and Carl E. Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Communications of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-29, </pages> <year> 1983. </year>
Reference-contexts: Memory utilization has been largely neglected in today's collectors because memory has not been a critical resource in traditional garbage collected systems. Instead, garbage collection research has focussed on improving latency and overhead through techniques such as aggressive compiler support [18], or incremental [7] and generational <ref> [10] </ref> collection. These collectors often underutilize memory to reduce latency or overhead [18]. This approach was reasonable in the past because the operating system could be relied upon to provide ample heap space.
Reference: [11] <author> Greg Nelson, </author> <title> editor. Systems Programming in Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Section 4 evaluates their performance. Section 5 presents some related work, and Section 6 concludes. 2 Background SPIN is an extensible operating system that allows untrusted applications to link extensions directly into the kernel. The kernel is protected from extensions by using a type-safe language, Modula-3 <ref> [11] </ref>, to guarantee memory safety. A garbage collector is used to avoid dangling references. Although SPIN does not currently run in embedded devices, it has garbage collection requirements similar to Inferno and JavaOS. An operating system's performance affects all applications, so its heap should be small to avoid paging.
Reference: [12] <author> M. Rosemblum and J.K. Ousterhout. </author> <title> The design and implementation of a log-structured file system. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <address> Pacific Grove, CA, USA, </address> <year> 1991. </year>
Reference-contexts: SPIN's in-kernel transac tion services. * HTTPD The entire SPIN web tree (79 files and 5MB) is accessed 400 times by a remote machine through the SPIN in-kernel web server. * LFS A subset of the Andrew file system benchmark [8] is run on the SPIN log structured file system <ref> [12] </ref>. * BLUR A 2.5 MB image is blurred while maintaining copies of the modified pixels, similar to the way a paint program would operate. The first three benchmarks are typical OS work-loads.
Reference: [13] <author> M. Satyanarayanan, H. Mashburn, P. Kumar, D. Steere, and J. Kistler. </author> <title> Lightweight recoverable virtual memory. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12(1) </volume> <pages> 33-57, </pages> <year> 1994. </year>
Reference-contexts: memory utilization| smaller memory requirements, lower collection frequencies, lower overheads, and shorter end to-end running times, * that our techniques do not compromise latency, and can be used in real-time systems. 5 4.1 Benchmarks Four benchmarks are used to evaluate the perfor mance of our techniques: * TRANS The RVMbench <ref> [13] </ref> transactions benchmark exercises SPIN's in-kernel transac tion services. * HTTPD The entire SPIN web tree (79 files and 5MB) is accessed 400 times by a remote machine through the SPIN in-kernel web server. * LFS A subset of the Andrew file system benchmark [8] is run on the SPIN log
Reference: [14] <author> C. Weinstock. </author> <title> Dynamic Storage Allocation Techniques. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> April </month> <year> 1976. </year>
Reference-contexts: These improvements reduce overhead and support bounded allocations for objects of any size. They do not, however, address memory utilization. Page migration has been mentioned briefly [17] and implemented in Mike Haertel's quick-fit <ref> [14] </ref> allocator, but has typically relied on per-page object counts to reclaim pages. Since objects are not explicitly deallocated in our implicit collector, page-wise collection is necessary to reclaim pages. In addition, we have extended the idea of migration with remapping to further reduce external fragmentation.
Reference: [15] <author> Jon L. White. </author> <title> Address/memory management for a gigantic Lisp environment, or, GC Considered Harmful. </title> <booktitle> In Conference Record of the 1980 Lisp Conference, </booktitle> <pages> pages 119-127, </pages> <address> Redwood Estates, CA, </address> <month> August </month> <year> 1980. </year>
Reference: [16] <author> J. Wilkes, R. Golding, C. Staelin, and T. Sullivan. </author> <title> The HP AutoRAID hierarchical storage system. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 96-108, </pages> <address> Copper Mountain Resort, CO, USA, </address> <year> 1995. </year>
Reference-contexts: We use remapping to create contiguous regions, and to ensure that allocations which require remapping occur in bounded time. Our page-filling allocator is similar to the hole-plugging collector in the AutoRAID storage system <ref> [16] </ref> in that both try to use the gaps created by fragmentation. Our scheme, however, fills in the gaps during during allocation and does so in bounded time.
Reference: [17] <author> P. R. Wilson, M. S. Johnstone, M. Neely, and D. Boles. </author> <title> Dynamic storage allocation: A survey and critical review. </title> <booktitle> In Proceedings of International Workshop on Memory Management, </booktitle> <year> 1995. </year>
Reference-contexts: Memory utilization can be improved by reducing fragmentation, which requires that allocators waste minimal space and coalesce memory to maintain large ranges of free memory. Smart allocation techniques and coalescing require at least sublogarith-mic time and may increase overhead <ref> [17] </ref>. This is un 1 acceptable for real-time applications which require bounded time operations. 1.2 Our approach In this paper, we describe an alternative to smart allocation and coalescing that improves memory utilization without incurring unbounded latencies or increasing overheads. <p> These improvements reduce overhead and support bounded allocations for objects of any size. They do not, however, address memory utilization. Page migration has been mentioned briefly <ref> [17] </ref> and implemented in Mike Haertel's quick-fit [14] allocator, but has typically relied on per-page object counts to reclaim pages. Since objects are not explicitly deallocated in our implicit collector, page-wise collection is necessary to reclaim pages.
Reference: [18] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <booktitle> In Proceedings of International Workshop on Memory Management, </booktitle> <institution> University of Texas, USA, </institution> <year> 1992. </year>
Reference-contexts: Memory utilization has been largely neglected in today's collectors because memory has not been a critical resource in traditional garbage collected systems. Instead, garbage collection research has focussed on improving latency and overhead through techniques such as aggressive compiler support <ref> [18] </ref>, or incremental [7] and generational [10] collection. These collectors often underutilize memory to reduce latency or overhead [18]. This approach was reasonable in the past because the operating system could be relied upon to provide ample heap space. <p> Instead, garbage collection research has focussed on improving latency and overhead through techniques such as aggressive compiler support <ref> [18] </ref>, or incremental [7] and generational [10] collection. These collectors often underutilize memory to reduce latency or overhead [18]. This approach was reasonable in the past because the operating system could be relied upon to provide ample heap space. As garbage collectors are being integrated into operating systems and run in small-memory devices, more emphasis needs to be put on their memory utilization.
Reference: [19] <author> Paul R. Wilson and Mark S. Johnstone. </author> <title> Truly real-time non-copying garbage collection. </title> <editor> In Eliot Moss, Paul R. Wilson, and Benjamin Zorn, editors, </editor> <booktitle> OOPSLA/ECOOP '93 Workshop on Garbage Collection in Object-Oriented Systems, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: The techniques include page migration between multiple free lists to allow any free pages to serve any allocation, page remapping to eliminate page-level fragmentation, and an allocator that fills underutilized pages to reduce sub-page fragmentation. We have implemented our techniques in Treadmill, a real-time, non-copying collector <ref> [4, 19] </ref>, which offers short and bounded pauses. It suffers from high fragmentation, however, and our techniques improve its memory utilization substantially while preserving its real-time behavior. Our new collector allows all of our benchmarks to be executed within 15MB of memory, while the unimproved Treadmill collector requires 21MB. <p> Treadmill ensures allocation time is bounded by requiring that all objects be of the same size, thus avoiding the need to search for a free block large enough for the allocation request. Wilson <ref> [19] </ref> relaxes this restriction by using segregated free lists for differently sized objects with sizes increasing in powers of two. Each list is managed separately by the Treadmill algorithm. Allocation requests are rounded up to the nearest power of two and sent to the appropriate list. <p> If no memory can be returned to that list, more is requested from the operating system. This collector offers constant time allocation for any request size, but Wilson notes that memory utilization deteriorates rapidly under programs with large varieties of allocation sizes <ref> [19] </ref>. Because allocation requests are rounded up to powers of two, the worst case internal fragmentation is 50% . In addition, free memory is neither coalesced nor moved from list to list, so external fragmentation can be arbitrarily high. <p> In the full paper we split the latencies according to their causes and how different techniques improve them. 2 The bound chosen was based on the fact that 50ms is the human threshold for noticing a pause. 5 Related work Treadmill [4] and Wilson's modifications <ref> [19] </ref> to it are non-copying extensions to the original Baker real-time collector [3]. These improvements reduce overhead and support bounded allocations for objects of any size. They do not, however, address memory utilization.
Reference: [20] <author> P. T. Withington. </author> <title> How real is "real time" garbage collection? In Paul R. </title> <editor> Wilson and Barry Hayes, editors, </editor> <booktitle> OOP-SLA/ECOOP '91 Workshop on Garbage Collection in Object-Oriented Systems, </booktitle> <month> October </month> <year> 1991. </year> <month> 11 </month>
Reference-contexts: In addition, we have extended the idea of migration with remapping to further reduce external fragmentation. Virtual memory remapping has been used to re-allocate mapped memory (Doug Lea's allocator) or to remap large objects instead of copying them <ref> [20] </ref>. We use remapping to create contiguous regions, and to ensure that allocations which require remapping occur in bounded time. Our page-filling allocator is similar to the hole-plugging collector in the AutoRAID storage system [16] in that both try to use the gaps created by fragmentation.
References-found: 20

