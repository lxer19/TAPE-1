URL: http://www.cs.wustl.edu/cs/techreports/1994/wucs-94-06.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: 
Title: An Incremental Distributed Algorithm for Computing Biconnected Components  
Author: Bala Swaminathan Kenneth J. Goldman 
Address: Campus Box 1045 One Brookings Drive Saint Louis, MO 63130-4899  
Affiliation: Department of Computer Science Washington University  
Date: March 1994  
Pubnum: WUCS-94-6  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, John E. Hopcroft, and Jeffery D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: The mappings of the neighboring coordinators and both the mappings and the local bcc topologies of each new bcc formed are to be recomputed to maintain the global consistent state. In the algorithm, the coordinator node for both r and p runs a standard sequential algorithm <ref> [1] </ref> to compute the local bcc topologies of all nodes within this bcc, and sends a 23 Coord Update message to all coordinators of the new bcc's formed as a result of the deletion.
Reference: [2] <author> Mohan Ahuja and Yahui Zhu. </author> <title> An efficient distributed algorithm for finding articulation points, bridges, and biconnected components in asynchronous networks. </title> <booktitle> In Proceedings of the 9th Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <address> Bangalore, India. </address> <publisher> LNCS 405, </publisher> <pages> pages 99-108. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1989. </year> <month> 33 </month>
Reference-contexts: A distributed algorithm for finding biconnected components was given by Chang [4]. This algorithm has a message complexity of 4m n, where m and n are the number of edges and vertices in the graph respectively. The distributed algorithm by Ahuja and Zhu <ref> [2] </ref> has the same message complexity but improves on the message size bound. Hohberg [8] and Park et al. [10] present distributed algorithms for finding biconnected components in a graph with a message complexity of O (m + n log n).
Reference: [3] <author> Kenneth Birman, Andre Schiper, and Pat Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Informally, it guarantees that if event A directly or indirectly "causes" event B, then no process will receive information about event B before receiving information about event A. Causal ordering is supported by the ISIS <ref> [3] </ref> system. ISIS programmers declare causal broadcast groups. Within these groups, causal ordering is maintained by an algorithm whose message header (a timestamp vector) has length proportional to the size of the group.
Reference: [4] <author> E. J. H. Chang. </author> <title> Echo algorithms: Depth parallel operations on general graphs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 8(4) </volume> <pages> 391-401, </pages> <year> 1982. </year>
Reference-contexts: A distributed algorithm for finding biconnected components was given by Chang <ref> [4] </ref>. This algorithm has a message complexity of 4m n, where m and n are the number of edges and vertices in the graph respectively. The distributed algorithm by Ahuja and Zhu [2] has the same message complexity but improves on the message size bound.
Reference: [5] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: We use standard definitions <ref> [5] </ref> for path, reachability, cycle, graph union, etc. Recall that an articulation point is a vertex whose removal would disconnect the connected component containing it. A bridge edge is an edge whose removal would place its endpoints in different connected components.
Reference: [6] <author> Jerome R. Cox, Jr., Mike Gaddis, and Jonathan S. Turner. </author> <title> Project Zeus: Design of a broadband network and its application on a university campus. </title> <journal> IEEE Network, </journal> <pages> pages 20-30, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Although the problem is a general one and is interesting in its own right, our particular motivation to study this problem arose as part of some work we are doing in conjunction with the ATM networking project at Washington University <ref> [6] </ref>. We are developing an abstraction and supporting software designed to simplify the construction of distributed multimedia applications [7]. In our approach, called I/O abstraction, each module has a presentation that consists of data structures that may be observed and/or manipulated by its external environment.
Reference: [7] <author> Kenneth J. Goldman, Michael D. Anderson, and Bala Swaminathan. </author> <title> The Programmers' Playground: I/O abstraction for heterogeneous distributed systems. </title> <booktitle> In 27th Hawaii International Conference on System Sciences (HICSS), </booktitle> <pages> pages 363-372, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: We are developing an abstraction and supporting software designed to simplify the construction of distributed multimedia applications <ref> [7] </ref>. In our approach, called I/O abstraction, each module has a presentation that consists of data structures that may be observed and/or manipulated by its external environment. An application consists of a collection of independent modules and a configuration of logical connections among the data structures in the module presentations.
Reference: [8] <author> Walter Hohberg. </author> <title> How to find biconnected components in distributed networks. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9(4) </volume> <pages> 374-386, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: This algorithm has a message complexity of 4m n, where m and n are the number of edges and vertices in the graph respectively. The distributed algorithm by Ahuja and Zhu [2] has the same message complexity but improves on the message size bound. Hohberg <ref> [8] </ref> and Park et al. [10] present distributed algorithms for finding biconnected components in a graph with a message complexity of O (m + n log n). These algorithms require the computation of a depth-first search tree.
Reference: [9] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 27(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Our current run-time support for I/O abstraction provides no ordering guarantees; when one module changes a value in its presentation, communication occurs asynchronously according to the configuration. However, many applications require stronger ordering properties for consistency. Causal ordering (Lamport's "happens before" relation <ref> [9] </ref>), is one of the most useful ordering restrictions. Informally, it guarantees that if event A directly or indirectly "causes" event B, then no process will receive information about event B before receiving information about event A. Causal ordering is supported by the ISIS [3] system. <p> The algorithm serializes these requests within each connected component using a timestamping technique that uses logical clocks <ref> [9] </ref>. In order to allow at most one update request to proceed within a connected component at any one time, we maintain a queue of requests (along with their timestamps) at all coordinator nodes. <p> This ensures that all nodes see the same sequence of requests. Building on the serial algorithm, we add a timestamp collection stage, that immediately follows the coordinator notification stage and serves to serialize the requests within a connected component. We use logical clocks <ref> [9] </ref> to assign a time to each request, and requests are processed in timestamp 25 Message type Purpose Request Timestamp requests maximum timestamp from the subtree of the receiver Return Timestamp returns to the parent, the maximum of all timestamps collected Final Timestamp informs coordinators of the final timestamp for a
Reference: [10] <author> Jungho Park, Nobuki Tokura, Toshimitsu Masuzawa, and Kenichi Hagihara. </author> <title> Efficient distributed algorithms solving problems about the connectivity of network. </title> <journal> Systems and Computers in Japan, </journal> <volume> 22(8) </volume> <pages> 1-16, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The distributed algorithm by Ahuja and Zhu [2] has the same message complexity but improves on the message size bound. Hohberg [8] and Park et al. <ref> [10] </ref> present distributed algorithms for finding biconnected components in a graph with a message complexity of O (m + n log n). These algorithms require the computation of a depth-first search tree.
Reference: [11] <author> Monika Rauch. </author> <title> Fully dynamic biconnectivity in graphs. </title> <booktitle> In Proceedings of the 33rd Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 50-59, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: A block forest of block trees is constructed using the biconnected components and the vertices in the graph. This block forest is used in maintaining the biconnected components of the original graph. Rauch <ref> [11] </ref> presented a sequential algorithm for maintaining biconnected components. This algorithm involves precomputation and "lazy" updating. The algorithms presented in this paper are dynamic as well as distributed, and are designed to scale up for large systems.
Reference: [12] <author> Robert E. Tarjan and Uzi Vishikin. </author> <title> An efficient parallel biconnectivity algorithm. </title> <journal> SIAM Journal of Computing, </journal> <volume> 14(4) </volume> <pages> 862-874, </pages> <year> 1985. </year>
Reference-contexts: Hence, they are appropriate for a static graph, but the cost of recomputation of the depth-first search tree (for every change in topology) makes these algorithms impractical for a dynamic setting. Tarjan and Vishkin proposed an optimal parallel algorithm on CRCW PRAM model <ref> [12] </ref>. This algorithm is also not incremental, but instead of using depth-first-search, it reduces the biconnec-tivity problem to the problem of computing connected components. Westbrook and Tarjan [13] proposed a sequential algorithm to compute biconnected components in a dynamically changing graph structure.
Reference: [13] <author> Jeffery Westbrook and Robert E. Tarjan. </author> <title> Maintaining bridge-connected and biconnected components on-line. </title> <journal> Algorithmica, </journal> <volume> 7 </volume> <pages> 433-464, </pages> <year> 1992. </year> <month> 34 </month>
Reference-contexts: Tarjan and Vishkin proposed an optimal parallel algorithm on CRCW PRAM model [12]. This algorithm is also not incremental, but instead of using depth-first-search, it reduces the biconnec-tivity problem to the problem of computing connected components. Westbrook and Tarjan <ref> [13] </ref> proposed a sequential algorithm to compute biconnected components in a dynamically changing graph structure. A block forest of block trees is constructed using the biconnected components and the vertices in the graph. This block forest is used in maintaining the biconnected components of the original graph. <p> Consider the set of articulation points and the set of super nodes. Create an edge between a super node and an articulation point whenever the articulation point belongs to the corresponding bcc. The resulting graph is a tree. (That is, a connected component induces a tree of biconnected components <ref> [13] </ref>.) 5 Lemma 5: Let a be a vertex in graph G = (V; E), let n = BCC G (a), and let b and c be vertices such that b is reachable from c. <p> It should be noted that any such path from r to p will have the same subsequence of link vertices. We call this "path condensation" after <ref> [13] </ref>. Messages: Nodes participate in the algorithm by message-passing. Each message has a name (its type) and includes the source and destination nodes, and the requesting node r and peer node p for the request. Some messages contain additional information.
References-found: 13

