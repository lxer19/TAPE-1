URL: http://www.cs.concordia.ca/~faculty/grogono/graphmodel.ps
Refering-URL: http://www.cs.concordia.ca/~faculty/grogono/techpubs.html
Root-URL: http://www.cs.concordia.ca
Email: E-Mail: grogono@cs.concordia.ca  
Phone: Tel: (514) 848 3000  
Title: A Model for Computing with Objects  
Author: Peter Grogono 
Address: 1455 de Maisonneuve Blvd. West Montreal, Quebec, Canada H3G 1M8  
Affiliation: Department of Computer Science, Concordia University  
Abstract: The paper describes a model for object oriented computation. The model provides a context for reasoning about most of the important features of object oriented programming, including objects, classes, message, dynamic binding, encapsulation, subtype polymorphism, and type systems. The model is unusual in that it is not based on -calculus. Although it is thereby deprived of many useful results, the model accurately captures the critical aspects that distinguish object oriented programming from conventional styles of programming. The model represents a state of a computation as a directed graph. The state graph is updated by programs written in a language with only eight constructs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: The simplicity of the metaphor contrasts with the difficulty of providing foundations for object oriented programming. Recent work has overcome many of the difficulties, but only by applying powerful tools, such as second-order typed -calculus <ref> [1, 2, 14] </ref>. The model described in this paper is not intended to compete with these approaches but rather to complement them. It is intended to be of interest to designers and developers of object oriented programs. <p> There are good reasons for this choice, too well-known to describe here. But many of the key features of object oriented programming, such as object state, circular dependencies between objects, and dynamic binding are not easily modeled in -calculus, although impressive results have been achieved <ref> [1, 2, 3, 4, 14] </ref>. The purpose of the graph model is not to improve on these results, but rather to provide a different perspective on object oriented programming.
Reference: [2] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: design, static typing, and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 127-206, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: The simplicity of the metaphor contrasts with the difficulty of providing foundations for object oriented programming. Recent work has overcome many of the difficulties, but only by applying powerful tools, such as second-order typed -calculus <ref> [1, 2, 14] </ref>. The model described in this paper is not intended to compete with these approaches but rather to complement them. It is intended to be of interest to designers and developers of object oriented programs. <p> There are good reasons for this choice, too well-known to describe here. But many of the key features of object oriented programming, such as object state, circular dependencies between objects, and dynamic binding are not easily modeled in -calculus, although impressive results have been achieved <ref> [1, 2, 3, 4, 14] </ref>. The purpose of the graph model is not to improve on these results, but rather to provide a different perspective on object oriented programming.
Reference: [3] <author> Giuseppe Castagna. </author> <title> Covariance and Contravariance: conflict without a cause. </title> <type> Technical Report liens-94-18, </type> <institution> LIENS(CNRS)-DMI, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: There are good reasons for this choice, too well-known to describe here. But many of the key features of object oriented programming, such as object state, circular dependencies between objects, and dynamic binding are not easily modeled in -calculus, although impressive results have been achieved <ref> [1, 2, 3, 4, 14] </ref>. The purpose of the graph model is not to improve on these results, but rather to provide a different perspective on object oriented programming.
Reference: [4] <author> Giuseppe Castagna and Gary T. Leavens. </author> <title> Foundations of object-oriented languages. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 30(2) </volume> <pages> 5-11, </pages> <month> February </month> <year> 1995. </year> <booktitle> Report on the workshop Foundations of Object-Oriented Languages, </booktitle> <address> Paris, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: There are good reasons for this choice, too well-known to describe here. But many of the key features of object oriented programming, such as object state, circular dependencies between objects, and dynamic binding are not easily modeled in -calculus, although impressive results have been achieved <ref> [1, 2, 3, 4, 14] </ref>. The purpose of the graph model is not to improve on these results, but rather to provide a different perspective on object oriented programming.
Reference: [5] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: The effect of "if P then Q else Q 0 " is obtained by evaluating P ; q () in a program with (True; q) = Q and (False; q) = Q 0 . The mechanism is similar to that of Smalltalk <ref> [5] </ref> but GM lacks the convenience of Smalltalk's "blocks". 7 Completeness We can show that the graph model is complete by demonstrating that, for a given Turing machine T , there is a GM program that performs an equivalent computation.
Reference: [6] <author> Peter Grogono and Mark Gargul. </author> <title> A graph model for object oriented programming. </title> <journal> ACM SIGPLAN Notices, </journal> <pages> 21-28, </pages> <month> July </month> <year> 1994. </year> <month> 10 </month>
Reference-contexts: It accomplishes this with the aid of a simple language that formalizes the essential features of object oriented programming. An earlier version of the model was presented in <ref> [6] </ref>. 2 Specifications and Programs We characterize a programming problem as a predicate on pairs of state graphs.
Reference: [7] <author> C. A. R. Hoare. </author> <title> Unified theories of programming. See World Wide Web http://www.comlab.ox.ac.uk/oucl/users/tony.hoare/sabatical.html. </title>
Reference-contexts: This approach, inspired by Hoare's work on conventional programming <ref> [7] </ref>, has proved to be fruitful for object oriented programming. The motivation for using predicates is the natural ordering that it induces on specifications and programs.
Reference: [8] <author> D. Ingalls. </author> <title> A simple technique for handling multiple polymorphism. </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> Proc. ACM Conf. on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 347-349, </pages> <year> 1986. </year>
Reference-contexts: The method succ requires an auxiliary function, link. Similarly, eq has an auxiliary function eqr. Such auxiliary functions perform a similar operation to the primary functions, but with the argument and receiver interchanged. This corresponds to "double dispatching" <ref> [8] </ref>. 5 Since the language has no conditional, we use dynamic binding to implement choices. The effect of "if P then Q else Q 0 " is obtained by evaluating P ; q () in a program with (True; q) = Q and (False; q) = Q 0 .
Reference: [9] <author> Peter Landin. </author> <title> A correspondence between Algol 60 and Church's lambda calculus, Part I. </title> <journal> Comm. ACM, </journal> <volume> 8(2) </volume> <pages> 89-101, </pages> <month> February </month> <year> 1965. </year>
Reference-contexts: of the result of the message is the union of these types. (C; A; R) ` P : A 1 ff 2 C ^ (C; A 1 ; R) ` (ff; m) : R ff [ R ff 10 Discussion Ever since Landin demonstrated the correspondence between Algol and -calculus <ref> [9] </ref>, the -calculus has been used in foundational studies of programming. There are good reasons for this choice, too well-known to describe here.
Reference: [10] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about object-oriented programs that use subtypes. </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> Proc. ACM Conf. on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 212-223, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Given two classes ff and ff 0 , we can decide whether ff 0 actually does inherit ff. If it does, we write ff 0 ff. The definition of the inheritance relation is straightforward. It corresponds to "subtype polymorphism" <ref> [10] </ref> rather than "code reuse". ff 0 ff () 8m : 8s 0 ; s 1 : (ff 0 ; m) ) (ff; m): Recall that, if a class ff does not define method m, then (ff; m) = T.
Reference: [11] <author> Tom Mens, Kim Mens, and Patrick Steyaert. </author> <title> OPUS: a Calculus for Modelling Object-Oriented Concepts. </title> <type> Technical Report vub-tinf-tr-94-04, </type> <institution> Vrije Universiteit Brussel, </institution> <year> 1994. </year>
Reference-contexts: As a result, it has few simple and general properties. It is, however, capable of describing the anomalies that arise in practical object oriented languages. Since it is a model, it may serve as a ground for object oriented calculi, such as that of Mens <ref> [11, 12] </ref>. The main virtue of GM is its simplicity and concreteness. It shows that all reasoning about object oriented programs can be expressed as simple operations on a directed graph. Acknowledgements The results presented in this paper are the result of numerous discussions.
Reference: [12] <author> Tom Mens, Kim Mens, and Patrick Steyaert. </author> <title> OPUS: a Formal Approach to Object-Orientation. </title> <type> Technical Report vub-tinf-tr-94-02, </type> <institution> Vrije Universiteit Brussel, </institution> <year> 1994. </year>
Reference-contexts: As a result, it has few simple and general properties. It is, however, capable of describing the anomalies that arise in practical object oriented languages. Since it is a model, it may serve as a ground for object oriented calculi, such as that of Mens <ref> [11, 12] </ref>. The main virtue of GM is its simplicity and concreteness. It shows that all reasoning about object oriented programs can be expressed as simple operations on a directed graph. Acknowledgements The results presented in this paper are the result of numerous discussions.
Reference: [13] <author> Jens Palsberg and M. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: A number of type systems for object oriented programming have been proposed. An approach that appears to match GM well is that of Palsberg and Schwartzbach <ref> [13] </ref>. We cannot always determine the precise class of an object from the program text. For example, the class of the current vertex after executing a program equivalent to (new Zero; succ n ; pred) depends on the value of n.
Reference: [14] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Object-oriented programming without recursive types. </title> <booktitle> In Proc. 20th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 299-312, </pages> <month> January </month> <year> 1993. </year> <month> c:"oopmodel"oopsla.tex April 7, </month> <year> 1995 </year> <month> 11 </month>
Reference-contexts: The simplicity of the metaphor contrasts with the difficulty of providing foundations for object oriented programming. Recent work has overcome many of the difficulties, but only by applying powerful tools, such as second-order typed -calculus <ref> [1, 2, 14] </ref>. The model described in this paper is not intended to compete with these approaches but rather to complement them. It is intended to be of interest to designers and developers of object oriented programs. <p> There are good reasons for this choice, too well-known to describe here. But many of the key features of object oriented programming, such as object state, circular dependencies between objects, and dynamic binding are not easily modeled in -calculus, although impressive results have been achieved <ref> [1, 2, 3, 4, 14] </ref>. The purpose of the graph model is not to improve on these results, but rather to provide a different perspective on object oriented programming.
References-found: 14

