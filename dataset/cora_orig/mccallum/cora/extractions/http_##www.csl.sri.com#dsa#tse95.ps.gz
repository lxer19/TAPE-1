URL: http://www.csl.sri.com/dsa/tse95.ps.gz
Refering-URL: http://www.csl.sri.com/dsa/sadl-main.html
Root-URL: 
Title: Architecture Refinement  
Author: Mark Moriconi, Xiaolei Qian, and R. A. Riemenschneider 
Keyword: Software architecture, hierarchy, stepwise refinement, refinement patterns, formal methods, relative correctness, composition  
Note: Correct Appeared in IEEE Transactions on Software Engineering, April, 1995, Volume 21, Number 4, pp. 356-372.  
Abstract: A method is presented for the stepwise refinement of an abstract architecture into a relatively correct lower-level architecture that is intended to implement it. A refinement step involves the application of a predefined refinement pattern that provides a routine solution to a standard architectural design problem. A pattern contains an abstract architecture schema and a more detailed schema intended to implement it. The two schemas usually contain very different architectural concepts (from different architectural styles). Once a refinement pattern is proven correct, instances of it can be used without proof in developing specific architectures. Individual refinements are compositional, permitting incremental development and local reasoning. A special correctness criterion is defined for the domain of software architecture, as well as an accompanying proof technique. A useful syntactic form of correct composition is defined. The main points are illustrated by means of familiar architectures for a compiler. A prototype implementation of the method has been used successfully in a real application. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport, </author> <title> "Composing Specifications", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 15, No. 1, </volume> <month> January </month> <year> 1993, </year> <pages> pp. 73-132. </pages>
Reference-contexts: Garlan et al [8], [9] also have done important work on identifying and exploiting architectural styles. We build on their work, developing schematic style mappings and schematic refinements involving style-to-style transformations. Composition has been studied recently by Abadi and Lamport <ref> [1] </ref>, [2]. Their results are semantic and applicable to any domain, whereas ours are syntactic and specialized to the domain of software architecture. It is easy to state general criteria for the correctness of horizontal composition of architectures.
Reference: [2] <author> M. Abadi and L. Lamport, </author> <title> "Conjoining Specifications", </title> <type> Technical Report 118, </type> <institution> Digital Systems Research Center, Palo Alto, California, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Garlan et al [8], [9] also have done important work on identifying and exploiting architectural styles. We build on their work, developing schematic style mappings and schematic refinements involving style-to-style transformations. Composition has been studied recently by Abadi and Lamport [1], <ref> [2] </ref>. Their results are semantic and applicable to any domain, whereas ours are syntactic and specialized to the domain of software architecture. It is easy to state general criteria for the correctness of horizontal composition of architectures.
Reference: [3] <author> R. Allen and D. Garlan, </author> <title> "Formalizing Architectural Connection", </title> <booktitle> Proceedings of the Sixteenth International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1994, </year> <pages> pp. 71-80. </pages>
Reference-contexts: We appear to be the first to observe that, in an architectural correctness proof, it is important to establish the semantic correctness of the relevant style mappings. The importance of reasoning about connectors was recognized by Allen and Garlan <ref> [3] </ref>, who formalize them in a subset of CSP [11] and then proved absence of deadlock. In [18] we define the meaning of connectors axiomatically in a temporal logic and prove both fairness and safety properties of an implementation of the dataflow connector in shared memory.
Reference: [4] <author> E. Brinksma, B. Jonsson, and F. Orava, </author> <title> "Refining Interfaces of Communicating Systems", </title> <booktitle> TAPSOFT'91: Lecture Notes in Computer Science 494, </booktitle> <editor> S. Abramsky and T.S.E. Maibaum, Eds., </editor> <publisher> Springer-Verlag, </publisher> <year> 1991, </year> <pages> pp. 297-312. </pages>
Reference-contexts: In [17], Moriconi and Hare study the relative correctness of two architectures under the completeness assumption. They make the simplifying assumption that an architecture can contain only a fixed, finite number of objects. Broy [5], Brinksma <ref> [4] </ref>, and others have applied the standard approach to correctness to architectures. Broy's component refinements turn out to be conservative (and, hence, faithful) because interface signatures are preserved, but his connection refinements may not be because additional flows could be added to a channel.
Reference: [5] <author> M. Broy, </author> <title> "Compositional Refinement of Interactive Systems", No. </title> <type> 89, </type> <institution> Digital Systems Research Center, Palo Alto, California, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: In [17], Moriconi and Hare study the relative correctness of two architectures under the completeness assumption. They make the simplifying assumption that an architecture can contain only a fixed, finite number of objects. Broy <ref> [5] </ref>, Brinksma [4], and others have applied the standard approach to correctness to architectures. Broy's component refinements turn out to be conservative (and, hence, faithful) because interface signatures are preserved, but his connection refinements may not be because additional flows could be added to a channel. <p> However, it requires a difficult proof that it is not possible to infer new facts about the composite abstract architecture from the composite concrete architecture. Therefore, we defined a new specialized form of horizontal composition that requires only very simple syntactic checks. Broy <ref> [5] </ref> gives three operators for composing functional-style architectures, but does not consider the composition of architectures involving multiple styles. Vertical composition in a hierarchy of architectures is immediate provided each level in the hierarchy is correct with respect to the immediately preceding level. XI.
Reference: [6] <author> H. B. Enderton, </author> <title> A Mathematical Introduction to Logic, </title> <publisher> Academic Press, </publisher> <year> 1972. </year> <journal> 372 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, </journal> <volume> VOL. 21, NO. 4, </volume> <month> APRIL </month> <year> 1995 </year>
Reference-contexts: An interpretation mapping I is determined from a name mapping N and a style mapping S, as follows: for every 5 Note that our languages contain no function symbols. A formal treatment of interpretations for languages that include them can be found in <ref> [6] </ref>. predicate P , all terms t 1 ; t 2 ; : : : ; t n , every variable x, and all formulas F and G of the abstract language, I (P (t 1 ; t 2 ; : : : ; t n )) = S (P )(N <p> A. Criterion Let fi and fi 0 be instance theories (containing no schema variables) associated with an abstract and a concrete architecture, respectively. Let I be an interpretation mapping 6 In general, the range of quantifiers must be restricted to a subset of the concrete domain, see <ref> [6] </ref>. But no restriction is required for our example, because every concrete-level object implements an abstract-level object. 362 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 21, NO. 4, APRIL 1995 from the language of fi to the language of fi 0 .
Reference: [7] <author> T. DeMarco, </author> <title> Structured Analysis and System Specification, </title> <publisher> Yourdan Press, </publisher> <year> 1979. </year>
Reference-contexts: In both instances, schemas can be used to increase the reusability of designs and proofs. Of course, the utility of architecture hierarchies has been recognized for some time. For example, in the 1970s Jack-son [13], Yourdan and Constantine [20], DeMarco <ref> [7] </ref>, and others describe system architectures and, more recently, architectural description has been the basis for commercial offerings. However, previous work has given little attention to the mapping between levels of abstraction.
Reference: [8] <author> D. Garlan, R. Allen, and J. Ockerbloom, </author> <title> "Exploiting Style in Architectural Design Environments", </title> <booktitle> Proceedings of ACM SIG-SOFT'94: Symposium on Foundations of Software Engineering, </booktitle> <address> New Orleans, Louisiana, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: In [18] we define the meaning of connectors axiomatically in a temporal logic and prove both fairness and safety properties of an implementation of the dataflow connector in shared memory. Garlan et al <ref> [8] </ref>, [9] also have done important work on identifying and exploiting architectural styles. We build on their work, developing schematic style mappings and schematic refinements involving style-to-style transformations. Composition has been studied recently by Abadi and Lamport [1], [2].
Reference: [9] <author> D. Garlan and M. Shaw, </author> <title> "An Introduction to Software Architecture", </title> <booktitle> In Advances in Software Engineering and Knowledge Engineering, </booktitle> <volume> Volume 1, </volume> <editor> V. Ambriola and G. Tortora, Eds., </editor> <publisher> World Scientific Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: In [18] we define the meaning of connectors axiomatically in a temporal logic and prove both fairness and safety properties of an implementation of the dataflow connector in shared memory. Garlan et al [8], <ref> [9] </ref> also have done important work on identifying and exploiting architectural styles. We build on their work, developing schematic style mappings and schematic refinements involving style-to-style transformations. Composition has been studied recently by Abadi and Lamport [1], [2].
Reference: [10] <author> S.L. Gerhart, </author> <title> "Knowledge about programs", </title> <booktitle> Proceedings of the International Conference on Software Reliability, </booktitle> <address> Los Angeles, California, </address> <month> April </month> <year> 1975, </year> <pages> pp. 88-95. </pages>
Reference-contexts: An analogous problem arises in architecture refinement when there is a change in style. We have introduced the notion of a style mapping to related the styles in the abstract and concrete architectures. We are not the first to recognize the importance of schematic transformations in stepwise refinement. In <ref> [10] </ref>, Gerhart gives several examples of schema transformations that preserve functional correctness. We define schema transformations that preserve architecture correctness. The two forms of refinement are complementary. An architecture refinement hierarchy describes system organization | its components, interfaces, and connections.
Reference: [11] <author> C.A.R. Hoare, </author> <title> Communicating Sequential Processes, </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: We appear to be the first to observe that, in an architectural correctness proof, it is important to establish the semantic correctness of the relevant style mappings. The importance of reasoning about connectors was recognized by Allen and Garlan [3], who formalize them in a subset of CSP <ref> [11] </ref> and then proved absence of deadlock. In [18] we define the meaning of connectors axiomatically in a temporal logic and prove both fairness and safety properties of an implementation of the dataflow connector in shared memory.
Reference: [12] <author> C.A.R. Hoare, </author> <title> "Proof of correctness of data representations", </title> <journal> Acta Informatica, </journal> <volume> Vol. 1, No. 4, </volume> <year> 1972, </year> <pages> pp. 271-281. </pages>
Reference-contexts: Previous approaches to specification refinement have concentrated on the preservation of functional properties, which occurs when the mapping between specifications is a theory interpretation. The mapping often is complicated by a change in data representation. This can be taken into account by adapting the technique of Hoare <ref> [12] </ref> to relate the types in the abstract and concrete specifications. An analogous problem arises in architecture refinement when there is a change in style. We have introduced the notion of a style mapping to related the styles in the abstract and concrete architectures.
Reference: [13] <author> M.A. Jackson, </author> <title> Principles of Program Design, </title> <publisher> Academic Press, </publisher> <year> 1975. </year>
Reference-contexts: Functional refinement is used to develop the behavior of the system components in the architecture. In both instances, schemas can be used to increase the reusability of designs and proofs. Of course, the utility of architecture hierarchies has been recognized for some time. For example, in the 1970s Jack-son <ref> [13] </ref>, Yourdan and Constantine [20], DeMarco [7], and others describe system architectures and, more recently, architectural description has been the basis for commercial offerings. However, previous work has given little attention to the mapping between levels of abstraction.
Reference: [14] <author> D. Katiyar, D.C. Luckham, and J. Mitchell, </author> <title> "A type system for prototyping languages", </title> <booktitle> Proceedings of the 21st ACM Symposium on Principles of Programming Languages, </booktitle> <address> Portland, Ore-gon, </address> <year> 1994. </year>
Reference-contexts: The mapping also provides the basis for traceability of architectural design decisions, which is useful in practice. Recently, another form of a mapping between architectures has been developed for the Rapide architecture definition language <ref> [14] </ref>, [15]. Rapide is used to define executable architectures based on distributed event processing. Two architectures are related by mapping concrete events to abstract events. Event mappings provide the basis for comparative simulation, a technique that complements static modeling.
Reference: [15] <author> D.C. Luckham, J. Vera, D. Bryan, L. Augustin, and F. Belz", </author> <title> "Partial Orderings of Event Sets and Their Application to Pro-totyping Concurrent, Timed Systems", </title> <journal> Journal of Systems and Software, </journal> <volume> Vol. 21, No. 3, </volume> <month> June </month> <year> 1993, </year> <pages> pp. 253-265. </pages>
Reference-contexts: The mapping also provides the basis for traceability of architectural design decisions, which is useful in practice. Recently, another form of a mapping between architectures has been developed for the Rapide architecture definition language [14], <ref> [15] </ref>. Rapide is used to define executable architectures based on distributed event processing. Two architectures are related by mapping concrete events to abstract events. Event mappings provide the basis for comparative simulation, a technique that complements static modeling.
Reference: [16] <author> G.R. McClain, </author> <title> editor, Open Systems Interconnection Handbook, </title> <publisher> McGraw-Hill, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: Future work involves the development and evaluation of a handbook of architectural refinement patterns. Good designers tend to use well-established architectural styles, including both basic idioms (such as pipe-filter, client-server, and layering) and reference models (such as the ISO OSI 7-layer model <ref> [16] </ref>). We are now expanding our library to relate more styles as well as to elaborate more configurations involving the styles in the paper. Eventually, we would like to have a large enough library to support "industrial strength" architecture design.
Reference: [17] <author> M. Moriconi and D.F. Hare, </author> <title> "The PegaSys System: Pictures as Formal Documentation of Large Programs", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 8, No. 4, </volume> <month> October </month> <year> 1986, </year> <pages> pp. 524-546. </pages>
Reference-contexts: For example, we allow quantification over infinite types (such as integers) and dynamic architectures with an unbounded number of processes and connections. Because of the completeness assumption, an abstract architecture must be faithfully interpreted in the concrete architecture. In <ref> [17] </ref>, Moriconi and Hare study the relative correctness of two architectures under the completeness assumption. They make the simplifying assumption that an architecture can contain only a fixed, finite number of objects. Broy [5], Brinksma [4], and others have applied the standard approach to correctness to architectures.
Reference: [18] <author> M. Moriconi and X. Qian, </author> <title> "Correctness and Composition of Software Architectures", </title> <booktitle> Proceedings of ACM SIGSOFT'94: Symposium on Foundations of Software Engineering, </booktitle> <address> New Orleans, Louisiana, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: Correctness Two instance architectures, represented as theories, are proven correct with respect to an interpretation mapping between them and the completeness assumption. An interpretation mapping contains a style mapping whose semantic correctness should be established as a proof obligation. Proof of style mappings is discussed in a companion paper <ref> [18] </ref>, which gives a proof of mapping S D M from the dataflow to the shared-memory style. The connectors in the styles are defined in a temporal logic, and both safety and fairness conditions are shown to be satisfied by the shared-memory implementation. <p> The importance of reasoning about connectors was recognized by Allen and Garlan [3], who formalize them in a subset of CSP [11] and then proved absence of deadlock. In <ref> [18] </ref> we define the meaning of connectors axiomatically in a temporal logic and prove both fairness and safety properties of an implementation of the dataflow connector in shared memory. Garlan et al [8], [9] also have done important work on identifying and exploiting architectural styles. <p> The methodology was used successfully to explicate the architectural design of an operational power-control system. To develop a theory of correctness for architecture refinement, we adapted the technique of faithful interpretation that was introduced in an earlier paper for after-the-fact verification of complete architectures <ref> [18] </ref>. A new proof technique for checking faithfulness was presented. The interpretation mapping between architectures was simplified by decomposing it into an architecture-specific name mapping and a general style-to-style mapping. We are not aware of this distinction being made elsewhere in the literature.
Reference: [19] <author> R. Reiter, </author> <title> "Deductive Question-Answering on Relational Databases", in Logic and Data Bases, </title> <editor> H. Gallaire and J Minker, Eds., </editor> <publisher> Plenum Press, </publisher> <year> 1978, </year> <pages> pp. 149-177. </pages>
Reference-contexts: The standard criterion for functional correctness is not applicable to architectures because of the completeness as MORICONI, QIAN, AND RIEMENSCHNEIDER: CORRECT ARCHITECTURE REFINEMENT 369 sumption. A similar completeness assumption is made widely in the database community for analogous reasons, see Reiter <ref> [19] </ref>. However, Reiter allows only finitely many objects, so a "domain closure axiom" can be used to enumerate the domain of discourse. No similar technique can be applied here because, in general, an architecture can be infinite.

References-found: 19

