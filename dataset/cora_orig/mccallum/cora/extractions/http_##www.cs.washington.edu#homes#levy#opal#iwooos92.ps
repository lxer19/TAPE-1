URL: http://www.cs.washington.edu/homes/levy/opal/iwooos92.ps
Refering-URL: http://www.cs.washington.edu/homes/levy/opal/opalpapers.html
Root-URL: 
Title: Using Virtual Addresses as Object References  
Author: Jeff Chase, Hank Levy, and Ashutosh Tiwary 
Address: Seattle, WA 98195 USA  
Affiliation: Department of Computer Science and Engineering FR-35 University of Washington  
Abstract: Most object-oriented systems that support distributed or persistent data structures use software-interpreted object identifiers for inter-object referencing. These identifiers are often called pointer surrogates, because they are used as substitutes for virtual memory pointers. Surrogates are the traditional means of referencing objects that are viewed as existing "outside" of an application's virtual address space, e.g., because they reside in a database. An alternative to surrogates is to use ordinary virtual addresses for inter-object referencing. Usually (but not always) this involves mapping distributed or persistent data into specified parts of the application's address space, relying on page faults to trap and resolve references to nonresident data. The choice between these two referencing schemes involves tradeoffs. Virtual addresses promise easier integration with programming languages and faster local pointer dereferences, whereas surrogates can simplify object-based aspects of storage management, such as garbage collection and heap compaction. We believe that the key justifications for surrogate pointers are eliminated by 64-bit address spaces and proper operating system virtual memory support. When these facilities are available, the flexibility of surrogate pointers may not be worth their cost. We are investigating approaches to storage management that combine object-based and page-based techniques, and are compatible with the use of virtual addresses as object references. 
Abstract-found: 1
Intro-found: 1
Reference: [Appel & Li 91] <author> A. W. Appel and K. Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Proc. of the ACM Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: In Section 3 we argue that this dilemma is less severe than it appears, and that many solutions to these storage management problems are compatible with the use of virtual address pointers. 2 Operating System Support for Shared Virtual Storage Operating system advances, particularly innovative uses of virtual page protections <ref> [Appel & Li 91] </ref>, are the catalyst for increased use of virtual address pointers. For example, extensible memory man agement interfaces (as in Mach and Chorus) have produced a flood of specialized paging servers that support persistent and distributed virtual storage transparently to the language implementation.
Reference: [Appel et al. 88] <author> A. W. Appel, J. R. Ellis, and K. Li. </author> <title> Real-time concurrent garbage collection on stock multiprocessors. </title> <booktitle> SIGPLAN Notices (Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation), </booktitle> <volume> 23(7), </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: The runtime system can use this information to drive garbage collection. Mark-and-sweep garbage collection algorithms do not require that objects be moved. Some algorithms for concurrent copying garbage collection can move objects without pointer indirection, by using virtual page protections to trap dereferences through the old pointers <ref> [Appel et al. 88] </ref>. (2) Fragmentation. Storage may become fragmented if the heap is not compacted; even if the system allows the heap manager to release physical pages out of the middle of the heap, a page cannot be freed until all objects overlapping it have been reclaimed.
Reference: [Balter et al. ] <author> R. Balter, J. Bernadat, D. Decouchant, A. Duda, A. Freyssinet, S. Krakowiak, M. Meysembourg, P. LeDot, H. N. Van, E. Paire, M. Riveill, C. Roisin, X. R. de Pina, R. Scioville, and G. Vandome. </author> <title> Architecture and implementation of Guide, an object-oriented distributed system. </title> <journal> Computing Systems, </journal> <volume> 4(1) </volume> <pages> 31-68. </pages>
Reference-contexts: Surrogate pointers have been used in distributed programming languages (e.g., Emerald [Jul et al. 88]), per sistent object stores (e.g., Mneme [Moss 89]), object-support systems (e.g., SOS [Shapiro et al. 89] and Guide <ref> [Balter et al. ] </ref>), and most commercial object-oriented database systems. Surrogate pointers have two major drawbacks. First, they are more expensive to dereference than ordinary virtual addresses, which can affect application performance.
Reference: [Chase et al. 89] <author> J. S. Chase, F. G. Amador, E. D. Lazowska, H. M. Levy, and R. J. Littlefield. </author> <title> The Amber system: Parallel programming on a network of multiprocessors. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 147-158, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Again, strong type systems can supply this information. In this case, object-grain updates are compatible with virtual address pointers, although the difficulty of moving objects does constrain the implementation. For example, Amber <ref> [Chase et al. 89] </ref> uses such a hybrid approach for distributed memory, and Bubba for recoverable memory. (4) Heterogeneity. Heterogeneity can be supported by translating objects (e.g., swapping bytes or translating floating point representations) and rebinding their methods as they move between machines.
Reference: [Chase et al. 92a] <author> J. S. Chase, H. M. Levy, M. Baker-Harvey, and E. D. Lazowska. </author> <title> Lightweight shared objects in a 64-bit operating system. </title> <type> Technical Report 92-03-09, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: As a result of these trends, we are building a new operating system to further simplify use of this technique. This system, called Opal <ref> [Chase et al. 92a] </ref>, provides a single virtual name space that includes persistent storage and is shared by all applications. Opal encourages the use of virtual address pointers rather than surrogates because it assures uniform and stable virtual address bindings for all objects.
Reference: [Chase et al. 92b] <author> J. S. Chase, H. M. Levy, M. Baker-Harvey, and E. D. Lazowska. </author> <title> How to use a 64-bit virtual address space. </title> <type> Technical Report 92-03-02, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: Single address space systems are controversial because they prevent applications from using the same virtual addresses to name different data. Our goal in this paper is not to justify this model; instead, we refer you to <ref> [Chase et al. 92b] </ref>. Briefly, our position is that 64-bit address spaces are large enough to make a single address space viable even across a local area network, and that in a 64-bit world there are no significant benefits to private virtual address spaces.
Reference: [Copeland et al. 90] <author> G. Copeland, M. Franklin, and G. Weikum. </author> <title> Uniform object management. </title> <editor> In F. Bancilon, C. Thanos, and D. Tsichritzis, editors, </editor> <booktitle> Advances in Database Technology International Conference on Extending Database Technology 1990 (Lecture Notes in Computer Science 416), </booktitle> <pages> pages 253-268. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: For example, extensible memory man agement interfaces (as in Mach and Chorus) have produced a flood of specialized paging servers that support persistent and distributed virtual storage transparently to the language implementation. The database community is increasingly interested in this approach; Bubba <ref> [Copeland et al. 90] </ref>, Camelot [Eppinger 89], Cricket [Shekita & Zwilling 90], and ObjectStore [Lamb et al. 91] are recent examples of memory-mapped database systems. Despite these advances, today's operating systems do not adequately support the use of virtual address pointers in shared and persistent data.
Reference: [Eppinger 89] <author> J. L. Eppinger. </author> <title> Virtual Memory Management for Transaction Processing Systems. </title> <type> PhD dissertation, </type> <institution> Carnegie Mellon University, </institution> <month> February </month> <year> 1989. </year> <month> CMU-CS-89-115. </month>
Reference-contexts: For example, extensible memory man agement interfaces (as in Mach and Chorus) have produced a flood of specialized paging servers that support persistent and distributed virtual storage transparently to the language implementation. The database community is increasingly interested in this approach; Bubba [Copeland et al. 90], Camelot <ref> [Eppinger 89] </ref>, Cricket [Shekita & Zwilling 90], and ObjectStore [Lamb et al. 91] are recent examples of memory-mapped database systems. Despite these advances, today's operating systems do not adequately support the use of virtual address pointers in shared and persistent data.
Reference: [Jul et al. 88] <author> E. Jul, H. Levy, N. Hutchinson, and A. Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: A surrogate is an object name that is interpreted by software on pointer dereference, typically by hashing or indexing into a table of object descriptors that point to the actual objects. Surrogate pointers have been used in distributed programming languages (e.g., Emerald <ref> [Jul et al. 88] </ref>), per sistent object stores (e.g., Mneme [Moss 89]), object-support systems (e.g., SOS [Shapiro et al. 89] and Guide [Balter et al. ]), and most commercial object-oriented database systems. Surrogate pointers have two major drawbacks.
Reference: [Lamb et al. 91] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The ObjectStore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: The database community is increasingly interested in this approach; Bubba [Copeland et al. 90], Camelot [Eppinger 89], Cricket [Shekita & Zwilling 90], and ObjectStore <ref> [Lamb et al. 91] </ref> are recent examples of memory-mapped database systems. Despite these advances, today's operating systems do not adequately support the use of virtual address pointers in shared and persistent data.
Reference: [Lea et al. 91] <author> R. Lea, P. Amaral, and C. Jacquemot. COOL-2: </author> <title> an object-oriented support platform built above the Chorus micro-kernel. </title> <booktitle> In Proceedings of the International Workshop on Object-Oriented Operating Systems, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: In general, sharing patterns must be known in advance and hardwired into the applications. To resolve this problem, some systems (e.g., COOL-2 <ref> [Lea et al. 91] </ref>) arrange for each application to reserve a large chunk of its address space, which is then centrally allocated by the operating system to shared data segments. In the Opal operating system we extend this approach by coordinating all virtual address usage.
Reference: [Moss 89] <author> J. E. B. Moss. </author> <title> The Mneme persistent object store. </title> <type> COINS Technical Report 89-107, </type> <institution> University of Massachusetts at Amherst, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: Surrogate pointers have been used in distributed programming languages (e.g., Emerald [Jul et al. 88]), per sistent object stores (e.g., Mneme <ref> [Moss 89] </ref>), object-support systems (e.g., SOS [Shapiro et al. 89] and Guide [Balter et al. ]), and most commercial object-oriented database systems. Surrogate pointers have two major drawbacks. First, they are more expensive to dereference than ordinary virtual addresses, which can affect application performance.
Reference: [Shapiro et al. 89] <author> M. Shapiro, P. Gautron, and L. Mosseri. </author> <title> Persistence and migration for C++ objects. </title> <booktitle> In Proceedings of the Third European Conference on Object-Oriented Programming, </booktitle> <month> July </month> <year> 1989. </year>
Reference-contexts: Surrogate pointers have been used in distributed programming languages (e.g., Emerald [Jul et al. 88]), per sistent object stores (e.g., Mneme [Moss 89]), object-support systems (e.g., SOS <ref> [Shapiro et al. 89] </ref> and Guide [Balter et al. ]), and most commercial object-oriented database systems. Surrogate pointers have two major drawbacks. First, they are more expensive to dereference than ordinary virtual addresses, which can affect application performance.
Reference: [Shekita & Zwilling 90] <author> E. Shekita and M. Zwilling. Cricket: </author> <title> A mapped, persistent object store. </title> <booktitle> In Proceedings of the Fourth International Workshop on Persistent Object Systems: Design, Implementation and Use, </booktitle> <month> September </month> <year> 1990. </year>
Reference-contexts: The database community is increasingly interested in this approach; Bubba [Copeland et al. 90], Camelot [Eppinger 89], Cricket <ref> [Shekita & Zwilling 90] </ref>, and ObjectStore [Lamb et al. 91] are recent examples of memory-mapped database systems. Despite these advances, today's operating systems do not adequately support the use of virtual address pointers in shared and persistent data.
References-found: 14

