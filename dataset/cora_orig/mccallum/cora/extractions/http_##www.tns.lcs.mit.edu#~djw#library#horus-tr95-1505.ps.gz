URL: http://www.tns.lcs.mit.edu/~djw/library/horus-tr95-1505.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/
Root-URL: 
Email: rvr@cs.cornell.edu  ken@cs.cornell.edu  
Title: Protocol Composition in Horus  
Author: Robbert van Renesse Kenneth P. Birman 
Date: March 29, 1995  
Affiliation: Dept. of Computer Science Cornell University  
Abstract: Horus is a communication architecture that treats a protocol as an abstract data type. Protocol layers can be stacked on top of each other in a variety of ways, at run-time. This paper starts out with describing the many classes of protocols that can be supported this way. Next, we describe the Horus object model that we designed for this technology, and the interface between the layers that makes it all work. We then present an example layer which implements a group membership protocol. Then, we look at a example stack of protocols, which provides fault-tolerant, totally ordered communication between a group of processes. We conclude with presenting some remaining challenges in our project. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Michael J. Fischer, Nancy A. Lynch, and Michael S. Patterson. </author> <title> Impossibility of dis tributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Interestingly, the TOTAL layer does not require direct interaction with a failure detector. As providing totally ordered communication is equivalent to the consensus problem, this seems contrary to the impossibility proof of <ref> [1] </ref>. There are two reasons for this. First, the semantics that the TOTAL layer provides are slightly weaker, since it only guarantees timely delivery to the surviving members in the view.
Reference: [2] <author> Shivakan Mishra, Larry L. Peterson, and Richard D. Schlichting. </author> <title> Experience with mod ularity in Consul. </title> <journal> Software|Practice and Experience, </journal> <volume> 23(10) </volume> <pages> 1050-1075, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Horus was motivated by ideas from x-kernel, but with group communication as the fundamental abstraction. x-kernel was mainly designed for point-to-point communication, and even simple request-response style communication is not always easy to map down to this interface. We note that a follow-on to the x-kernel project, called Consul <ref> [2] </ref>, is attempting to deal with this disadvantage by supporting sophisticated micro-protocols between protocol modules. 9 Conclusion The development of critical reliability distributed systems has emerged as an important challenge, and demands new tools for distributed software development.
Reference: [3] <author> Larry L. Peterson, Norm Hutchinson, Sean O'Malley, and Mark Abbott. </author> <title> RPC in the x-Kernel: Evaluating new design techniques. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 91-101, </pages> <address> Litchfield Park, Arizona, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: In this approach, the protocols are lined up linearly, and two reliable, sequenced channels are placed between each pair of consecutive protocols. STREAMS, however, does not support group communication and has limited opportunities for concurrency. A related but more sophisticated approach is used in the x-kernel <ref> [3] </ref>. In this system, protocol objects can be linked together in acyclic graphs.
Reference: [4] <author> D. M. Ritchie. </author> <title> A stream input-output system. </title> <journal> Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1897-1910, </pages> <year> 1984. </year>
Reference-contexts: The apparent similarity to type checking merits further study. 8 Related Work We are not the first to realize that a framework for communication protocols is necessary. The most well-known framework for composing a set of protocols is the STREAMS framework <ref> [4] </ref>. In this approach, the protocols are lined up linearly, and two reliable, sequenced channels are placed between each pair of consecutive protocols. STREAMS, however, does not support group communication and has limited opportunities for concurrency. A related but more sophisticated approach is used in the x-kernel [3].
Reference: [5] <author> Robbert van Renesse, Takako M. Hickey, and Kenneth P. Birman. </author> <title> Design and perfor mance of Horus: A lightweight group communications system. </title> <type> Technical Report 94-1442, </type> <institution> Cornell University, Dept. of Computer Science, </institution> <month> August </month> <year> 1994. </year> <month> 11 </month>
Reference-contexts: Luckily, work on object-oriented systems has addressed exactly these requirements. If we can specify protocols in terms of objects, then we can use existing object-oriented techniques for composition of these protocols. The Horus system <ref> [5] </ref> provides such an object-oriented protocol composition framework. The system supports objects for communication endpoints, groups of communicating endpoints, and messages. It currently includes a library of about twenty different protocols, each providing a particular communication feature.
References-found: 5

