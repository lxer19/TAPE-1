URL: ftp://st.cs.uiuc.edu/pub/patterns/papers/mirror/ECOOP-95.ps
Refering-URL: http://st-www.cs.uiuc.edu/users/patterns/papers/
Root-URL: http://www.cs.uiuc.edu
Email: schmidt@cs.wustl.edu ebupsn@ebu.ericsson.se  
Title: Experience Using Design Patterns to Evolve Communication Software Across Diverse OS Platforms  
Author: Douglas C. Schmidt Paul Stephenson 
Address: St. Louis, MO 63130 Cypress, CA 90630  
Affiliation: Department of Computer Science Ericsson, Inc. Washington University,  
Abstract: An earlier version of this paper appeared in the proceedings of the 9 th European Conference on Object-Oriented Programming held in Aarhus, Denmark on August 7-11, 1995. Abstract Design patterns help to improve communication software quality since they address a fundamental challenge in large-scale software development: communication of architectural knowledge among developers. This paper makes several contributions to the study and practice of design patterns. It presents a case study that illustrates how design patterns helped to reduce development effort and project risk when evolving an object-oriented telecommunication software framework across UNIX and Windows NT OS platforms. Second, the paper discusses the techniques, benefits, and limitations of applying a design pattern-based reuse strategy to commercial telecommunication software systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: We were, however, able to achieve significant reuse of the design patterns underlying the framework. Design patterns capture the static and dynamic structures of solutions that occur repeatedly when developing applications in a particular context <ref> [1, 2, 3] </ref>. Systematically incorporating design patterns into the software development process helps improve software quality since patterns address a fundamental challenge in large-scale software development: communication of architectural knowledge among developers. In this paper, we describe our experience with a design pattern-based reuse strategy. <p> design pattern-based system development methodology in a production software environment; and Section 5 presents concluding remarks. 2 Overview of Design Patterns A design pattern represents a recurring solution to a design problem within a particular domain (such as business data processing, telecommunications, graphical user interfaces, databases, and distributed communication software) <ref> [1] </ref>. Design patterns facilitate architectural level reuse by providing blueprints that guide the definition, composition, and eval 1 uation of key components in a software system. In general, a large amount of experience reuse is possible at the architectural level. <p> Programmers supply concrete arguments for these types to produce an Instantiated Acceptor. Note that a similar degree of decoupling could be achieved via inheritance and dynamic binding by using the Abstract Factory or Factory Method patterns described in <ref> [1] </ref>. Parameterized types were used to implement this pattern since they improve run-time efficiency at the expense of additional compile-time and link-time time and space overhead. the Acceptor pattern. These collaborations are divided into three phases: 1. <p> Templates trade additional compile-time and link-time overhead for improved run-time efficiency. Note that a similar degree of decoupling also could be achieved via inheritance and dynamic binding by using the Abstract Factory or Factory Method patterns described in <ref> [1] </ref>. 3.4 Evolving the Design Patterns to Windows NT This section describes the Windows NT implementation of the Reactor and Acceptor design patterns performed at Eric-sson in Cypress, California. <p> This abstraction process is beneficial since it captures the essential architectural interactions while suppressing unnecessary details. One of our concerns with conventional pattern catalogs <ref> [1, 2] </ref>, however, is that they are too abstract. <p> The extended discussion in Section 3 is one example of a wide-spectrum exemplar using this approach. This example contains in-depth coverage of tradeoffs encountered in actual use. * Integrate patterns with object-oriented frameworks: Ideally, examples in pattern catalogs <ref> [2, 1] </ref> should reference (or better yet, contain hyper-text links to) source code that comprises an actual object-oriented framework that illustrate the patterns. We have begun building such an environment 12 at Ericsson, in order to disseminate our patterns and frame-works to a wider audience.
Reference: [2] <author> F. Buschmann, R. Meunier, H. Rohnert, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A Pattern System. </title> <publisher> Wileys and Sons, </publisher> <year> 1995. </year>
Reference-contexts: We were, however, able to achieve significant reuse of the design patterns underlying the framework. Design patterns capture the static and dynamic structures of solutions that occur repeatedly when developing applications in a particular context <ref> [1, 2, 3] </ref>. Systematically incorporating design patterns into the software development process helps improve software quality since patterns address a fundamental challenge in large-scale software development: communication of architectural knowledge among developers. In this paper, we describe our experience with a design pattern-based reuse strategy. <p> This abstraction process is beneficial since it captures the essential architectural interactions while suppressing unnecessary details. One of our concerns with conventional pattern catalogs <ref> [1, 2] </ref>, however, is that they are too abstract. <p> The extended discussion in Section 3 is one example of a wide-spectrum exemplar using this approach. This example contains in-depth coverage of tradeoffs encountered in actual use. * Integrate patterns with object-oriented frameworks: Ideally, examples in pattern catalogs <ref> [2, 1] </ref> should reference (or better yet, contain hyper-text links to) source code that comprises an actual object-oriented framework that illustrate the patterns. We have begun building such an environment 12 at Ericsson, in order to disseminate our patterns and frame-works to a wider audience.
Reference: [3] <editor> J. O. Coplien and D. C. Schmidt, eds., </editor> <booktitle> Pattern Languages of Program Design. </booktitle> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: We were, however, able to achieve significant reuse of the design patterns underlying the framework. Design patterns capture the static and dynamic structures of solutions that occur repeatedly when developing applications in a particular context <ref> [1, 2, 3] </ref>. Systematically incorporating design patterns into the software development process helps improve software quality since patterns address a fundamental challenge in large-scale software development: communication of architectural knowledge among developers. In this paper, we describe our experience with a design pattern-based reuse strategy.
Reference: [4] <author> D. C. Schmidt, ASX: </author> <title> an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: In this paper, we describe our experience with a design pattern-based reuse strategy. We have successfully used this strategy at Ericsson to develop a family of object-oriented telecommunication system software based on the ADAPTIVE Service eXecutive (ASX) framework <ref> [4] </ref>. The ASX framework is an integrated collection of components that collaborate to produce a reusable infrastructure for developing communication software. The framework performs common communication software activities (such as event demultiplexing, event handler dispatching, connection establishment, routing, configuration of application services, and concurrency control). <p> The Reactor pattern appears in many single-threaded event-driven frameworks (such as the Motif, Interviews [8], System V STREAMS [9], the ASX OO communication framework <ref> [4] </ref>, and implementations of DCE [10] and CORBA [11]). The Reactor pattern solves a key problem for single-threaded communication software: how to efficiently demul-tiplex multiple types of events from multiple sources of events within a single thread of control. <p> Using multi-threading to implement event demultiplexing has several drawbacks, however. It may require the use of complex concurrency control schemes; it may lead to poor performance on uni-processors <ref> [4] </ref>; and it is not available on many OS platforms. <p> A derived Event Handler returns the I/O mechanism HANDLE via its get handle method and returns the destination buffer location and length information via the Message Block abstraction described in <ref> [4] </ref>. The current implementation of the Windows NT-based Reactor pattern is about 2,600 lines C++ code (not including comments or extraneous whitespace). This code is several hundred lines longer than the UNIX version. The additional code primarily ensures the fairness of WaitForMultipleObjects event demultiplexing, as discussed above. <p> This distribution contains complete source code, documentation, and example test drivers for the C++ components developed as part of the ADAPTIVE project <ref> [4] </ref> at the University of California, Irvine and Washington University.
Reference: [5] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: In general, a large amount of experience reuse is possible at the architectural level. However, reusing design patterns does not necessarily result in direct reuse of algorithms, detailed designs, interfaces, or implementations. This paper focuses on two specific design patterns (the Reactor <ref> [5] </ref> and Acceptor patterns) that are implemented by the ASX framework. The ASX components, and the Reactor and Acceptor design patterns embodied by these components, are currently used in a number of production systems.
Reference: [6] <author> D. C. Schmidt, </author> <title> Experience with a System of Reusable Design Patterns for Motorola Iridium Communication Software, </title> <note> in Submitted to OOPSLA '95, </note> <institution> (Austin, Texas), ACM, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: The ASX components, and the Reactor and Acceptor design patterns embodied by these components, are currently used in a number of production systems. These systems include the Bellcore and Siemens Q.port ATM signaling software product, the system control segment for the Motorola Iridium global personal communications system <ref> [6] </ref>, a family of system/network management applications for Ericsson telecommunication switches [7], and a Global Limiting System developed by Credit Suisse that manages credit risk and market risk. <p> have learned and outlines workarounds for problems we encountered when using design patterns in a production software environment. 4.1 Pros and Cons of Design Patterns Many of our experiences with patterns at Ericsson are similar to those observed on other projects using design patterns, such as the Motorola Iridium project <ref> [6] </ref>. Recognizing these common themes across different companies increased our confidence that our experiences with patterns generalize to other large-scale software projects.
Reference: [7] <author> D. C. Schmidt and T. Suda, </author> <title> An Object-Oriented Framework for Dynamically Configuring Extensible Distributed Communication Systems, </title> <journal> IEE/BCS Distributed Systems Engineering Journal (Special Issue on Configurable Distributed Systems), </journal> <volume> vol. 2, </volume> <pages> pp. 280-293, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: These systems include the Bellcore and Siemens Q.port ATM signaling software product, the system control segment for the Motorola Iridium global personal communications system [6], a family of system/network management applications for Ericsson telecommunication switches <ref> [7] </ref>, and a Global Limiting System developed by Credit Suisse that manages credit risk and market risk. The design patterns described in the following section provided a concise set of architectural blueprints that guided our porting effort from UNIX to Windows NT. <p> The Reactor will also initiate the next connection acceptance sequence asynchronously. 4 Lessons Learned Our group at Ericsson has been developing object-oriented frameworks based on design patterns for the past two years <ref> [7] </ref>. During this time, we have learned many lessons, both positive and negative, about using design patterns as the basis for our system design, implementation, and documentation.
Reference: [8] <author> M. A. Linton, J. Vlissides, and P. Calder, </author> <title> Composing User Interfaces with InterViews, </title> <journal> IEEE Computer, </journal> <volume> vol. 22, </volume> <pages> pp. 8-22, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: This separation of concerns factors out the demultiplexing and dispatching mechanisms (which may be independent of an application and thus reusable) from the event handler processing policies (which are specific to an application). The Reactor pattern appears in many single-threaded event-driven frameworks (such as the Motif, Interviews <ref> [8] </ref>, System V STREAMS [9], the ASX OO communication framework [4], and implementations of DCE [10] and CORBA [11]). The Reactor pattern solves a key problem for single-threaded communication software: how to efficiently demul-tiplex multiple types of events from multiple sources of events within a single thread of control. <p> Therefore, computation and communication may not occur in parallel unless separate threads or processes are used. The original implementation of the Reactor pattern provided by the ASX framework was derived from the Dispatcher class category available in the InterViews object-oriented GUI framework <ref> [8] </ref>. The Dispatcher is an object-oriented interface to the UNIX select system call. InterViews uses the Dispatcher to define an application's main event loop and to manage connections to one or more physical window displays. The Reactor framework's first modification to the Dispatcher framework added support for signal-based event dispatching.
Reference: [9] <author> D. Ritchie, </author> <title> A Stream Input-Output System, </title> <journal> AT&T Bell Labs Technical Journal, </journal> <volume> vol. 63, </volume> <pages> pp. 311-324, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: The Reactor pattern appears in many single-threaded event-driven frameworks (such as the Motif, Interviews [8], System V STREAMS <ref> [9] </ref>, the ASX OO communication framework [4], and implementations of DCE [10] and CORBA [11]). The Reactor pattern solves a key problem for single-threaded communication software: how to efficiently demul-tiplex multiple types of events from multiple sources of events within a single thread of control.
Reference: [10] <author> J. Dilley, OODCE: </author> <title> A C++ Framework for the OSF Distributed Computing Environment, </title> <booktitle> in Proceedings of the Winter Usenix Conference, USENIX Association, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: The Reactor pattern appears in many single-threaded event-driven frameworks (such as the Motif, Interviews [8], System V STREAMS [9], the ASX OO communication framework [4], and implementations of DCE <ref> [10] </ref> and CORBA [11]). The Reactor pattern solves a key problem for single-threaded communication software: how to efficiently demul-tiplex multiple types of events from multiple sources of events within a single thread of control.
Reference: [11] <author> C. Horn, </author> <title> The Orbix Architecture, </title> <type> tech. rep., </type> <institution> IONA Technologies, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: The Reactor pattern appears in many single-threaded event-driven frameworks (such as the Motif, Interviews [8], System V STREAMS [9], the ASX OO communication framework [4], and implementations of DCE [10] and CORBA <ref> [11] </ref>). The Reactor pattern solves a key problem for single-threaded communication software: how to efficiently demul-tiplex multiple types of events from multiple sources of events within a single thread of control. This strategy provides coarse-grained concurrency control that serializes application event handling within a process at the event demultiplexing level.
Reference: [12] <author> W. R. Stevens, </author> <title> UNIX Network Programming. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: This separation of concerns enables the application-specific portion of a service to vary independently of the mechanism used to establish the connection. The Acceptor pattern appears in network su-perservers (such as inetd <ref> [12] </ref> and listen [13]). These superservers utilize a master Acceptor process that listens for connections on a set of communication ports. Each port is associated with a communication-related service (such as the standard Internet services ftp, telnet, daytime, and echo). <p> When a service request arrives on a monitored port, the Acceptor process accepts the request and dispatches an appropriate pre-registered handler to perform the service. The Acceptor pattern solves several problems encountered when writing communication software (particularly servers) using network programming interfaces like sockets <ref> [12] </ref> and TLI [13]: 1. How to avoid writing the same connection establishment code repeatedly for each server; 2. How to make the connection establishment code portable across platforms that may contain different network programming interfaces (such as sockets but not TLI, or vice versa); 3. <p> The application then reacts by processing the handle (s) accordingly (such as reading or writing data, initiating/accepting connections, etc.). Reactive demultiplexing and I/O semantics are provided on standard BSD and System V UNIX systems <ref> [12] </ref>. In contrast, proactive semantics allow an application to actively initiate I/O-related operations (such as a read, write, or connection request/accept) or general-purpose event-signaling operations (such as a semaphore lock being acquired or a thread terminating). The invoked operation proceeds asynchronously and does not block the caller. <p> SVR4 provides another event demultiplexing system call named poll. Poll is similar to select, though it uses a different interface and provides a broader, more flexible model for event demultiplexing that supports SVR4 features such as STREAM pipe band-data <ref> [12] </ref>. The SunOS 5.x port of the Reactor was enhanced to support either select or poll as the underlying event de-multiplexer. Although portions of the Reactor's internal implementation changed, its external interface remained the same for both the select-based and the poll-based versions. <p> SOCK SAP encapsulates the SOCK STREAM semantics of the socket transport layer interface within a type-secure, object-oriented interface. SOCK STREAM sockets support the reliable transfer of bytestream data between two processes, which may run on the same or on different host machines in a network <ref> [12] </ref>. By using templates, it is straightforward to instantiate a different network programming interface (such as the TLI SAP C++ wrappers that encapsulate the System V UNIX TLI interface) [17]. Templates trade additional compile-time and link-time overhead for improved run-time efficiency.
Reference: [13] <author> S. Rago, </author> <title> UNIX System V Network Programming. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: This separation of concerns enables the application-specific portion of a service to vary independently of the mechanism used to establish the connection. The Acceptor pattern appears in network su-perservers (such as inetd [12] and listen <ref> [13] </ref>). These superservers utilize a master Acceptor process that listens for connections on a set of communication ports. Each port is associated with a communication-related service (such as the standard Internet services ftp, telnet, daytime, and echo). <p> When a service request arrives on a monitored port, the Acceptor process accepts the request and dispatches an appropriate pre-registered handler to perform the service. The Acceptor pattern solves several problems encountered when writing communication software (particularly servers) using network programming interfaces like sockets [12] and TLI <ref> [13] </ref>: 1. How to avoid writing the same connection establishment code repeatedly for each server; 2. How to make the connection establishment code portable across platforms that may contain different network programming interfaces (such as sockets but not TLI, or vice versa); 3.
Reference: [14] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: </address> <publisher> Mi-crosoft Press, </publisher> <year> 1993. </year>
Reference-contexts: When an operation completes, it signals the application. At this point, the application runs a completion routine that determines the exit status of the operation. If there is more data to transfer, the program starts up another asynchronous operation. Proactive demultiplexing and I/O semantics are provided on Windows NT <ref> [14] </ref> and VMS. For performance reasons, we were not able to completely encapsulate the variation in behavior between the UNIX and Windows NT demultiplexing and I/O semantics. Thus, we could not directly reuse existing C++ code, algorithms, or detailed designs.
Reference: [15] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin-giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: The next major modification to the Reactor extended it for use with multi-threaded applications on SunOS 5.x using Solaris threads <ref> [15] </ref>. Adding multi-threading support required changes to the internals of both the select-based and poll-based versions of the Reactor. These changes involved a SunOS 5.x mutual exclusion mechanism known as a mutex. <p> These changes involved a SunOS 5.x mutual exclusion mechanism known as a mutex. A mutex serializes the execution of multiple threads by defining a critical section where only one thread executes the code at a time <ref> [15] </ref>. Critical sections of the Reactor's code that concurrently access shared resources (such as the Reactor's internal dispatch table containing Event Handler objects) are protected by a mutex. The standard SunOS 5.x synchronization type (mutex t) provides support for non-recursive mutexes.
Reference: [16] <author> D. C. Schmidt and T. Harrison, </author> <title> Object-Oriented Components for High-speed Network Programming, </title> <booktitle> in Proceedings of the Conference on Object-Oriented Technologies, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: The SOCK Stream, SOCK Acceptor and INET Addr classes used in the template instantiations are part of the SOCK SAP C++ wrapper library <ref> [16] </ref>. SOCK SAP encapsulates the SOCK STREAM semantics of the socket transport layer interface within a type-secure, object-oriented interface. SOCK STREAM sockets support the reliable transfer of bytestream data between two processes, which may run on the same or on different host machines in a network [12].
Reference: [17] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year> <month> 13 </month>
Reference-contexts: By using templates, it is straightforward to instantiate a different network programming interface (such as the TLI SAP C++ wrappers that encapsulate the System V UNIX TLI interface) <ref> [17] </ref>. Templates trade additional compile-time and link-time overhead for improved run-time efficiency.
References-found: 17

