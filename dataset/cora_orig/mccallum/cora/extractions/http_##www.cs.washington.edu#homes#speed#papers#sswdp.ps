URL: http://www.cs.washington.edu/homes/speed/papers/sswdp.ps
Refering-URL: http://www.cs.washington.edu/homes/speed/home.html
Root-URL: 
Title: How to Stop a Cheater: Secret Sharing with Dishonest Participation  
Author: Erik Warren Selberg 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: October 18, 1994  
Pubnum: CMU-CS-93-182  
Abstract: At times it is necessary to obtain a group decision from a number of different nodes over a large network. Secret sharing protocols allow a quorum q of a group of n people to arrive at decisions by having the quorum recompute a predetermined secret, such as an access code, while preventing less than q people from gaining any information about the secret. However, current protocols [6, 5] are vulnerable when participants cheat, for example by giving false information to other participants. In this work, I present a powerful new protocol which detects cheaters immediately and halts the exchange before any more information is revealed. In addition, it prevents cheaters from gaining any information without revealing an equal amount of their own. This protocol will present new paradigms in a variety of applications, such as electronic balloting and secure file system fault tolerance. This report was submitted in partial fulfillment of the requirements for the Senior Honors Research Program in the School of Computer Science at Carnegie Mellon University. Erik Selberg was the 1993 recipient of the Allen Newell Award for Excellence in Undergraduate Research. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Josh D. Cohen. </author> <title> Keeping shares of a secret secret. </title> <type> Technical Report YALEU/DCS/TR-453, </type> <institution> Yale University Dept. of Computer Science, </institution> <month> February </month> <year> 1986. </year>
Reference-contexts: In addition, it must be assured that participants in the protocol are unable to cheat. The secret sharing problem implicitly assumes that shares will be pooled by the quorum to compute the secret. Various protocols have been created <ref> [5, 8, 1] </ref>. Some of these include techniques to catch cheaters who might put bogus values into the shared pool of information. Even if cheaters can be detected, a problem remains since cheaters can still see the contents of the pool before revealing their own shares. <p> (mod 17) 15 = 10 + 9a + 3b + S (mod 17) which translated in matrix form to: 2 4 14 3 5 = 6 1 1 1 9 3 1 7 2 4 b 3 5 (mod 17) which yields the incorrect result of [a; b; S] = <ref> [9; 14; 1] </ref>. However, to the eyes of Bob and Carl, everything is as it should be until the secret is actually used and is found to be in error. <p> Yet Alice now has both Bob's and Carl's shares, and can compute S at her leisure. 4 Ben-Or/Rabin Solution Tal Rabin and Michael Ben-Or improved on the protocols of Shamir and others <ref> [8, 1] </ref> by introducing a zero-knowledge proof based upon Check Vectors into the protocol [5].
Reference: [2] <author> Maurice P. Herlihy and J. D. Tygar. </author> <title> How to make replicated data secure. </title> <editor> In Carl Pomerance, editor, </editor> <booktitle> Lecture Notes in Computer Science #293. Advances in Cryptography, </booktitle> <publisher> Springer - Verlag, </publisher> <year> 1987. </year>
Reference-contexts: For each member of the board, you could give q 2 shares. For each manager, q 3 shares, and so forth. Thus, rather than requiring q people to convene, all that is necessary is to gather people whom together have q shares. * Secure File Storage and Fault Tolerance <ref> [3, 2] </ref> Let the secret be a file. Let n be the number of disks available with each disk receiving one share, and let q be the minimum number of shares needed to re-create the file.
Reference: [3] <author> Michael O. Rabin. </author> <title> Efficient dispersal of information for security load balancing and fault tolerance. </title> <type> Technical report, </type> <institution> Aiken Computation Laboratory, Harvard University, </institution> <year> 1986. </year>
Reference-contexts: For each member of the board, you could give q 2 shares. For each manager, q 3 shares, and so forth. Thus, rather than requiring q people to convene, all that is necessary is to gather people whom together have q shares. * Secure File Storage and Fault Tolerance <ref> [3, 2] </ref> Let the secret be a file. Let n be the number of disks available with each disk receiving one share, and let q be the minimum number of shares needed to re-create the file.
Reference: [4] <author> Michael O. Rabin and J. D. Tygar. </author> <title> An integrated toolkit for operating system security. </title> <editor> In W. Litwin and H.-J. Scheli, editors, </editor> <booktitle> Lecture Notes in Computer Science #367, </booktitle> <address> Paris, France, </address> <month> June </month> <year> 1989. </year> <title> Foundations of Data Organization and Algorithms, </title> <publisher> Springer - Verlag. </publisher>
Reference-contexts: New shares can be created which can replace or supplement older shares. We assume that the secret is bounded by a public prime p, and q n. A protocol which has all of these characteristics can find application in a variety of settings. For example: * Distributed Decision Making <ref> [4] </ref> Let the secret be a key, for example an access code. The question is whether the access code is allowed to be used. The solution: divide up the key into n shares and give one share to each of the n people involved. <p> S (mod 17) 15 = 10 + 9a + 3b + S (mod 17) which translates into the following matrix form: 2 4 14 3 5 = 6 1 1 1 9 3 1 7 2 4 b 3 5 (mod 17) which naturally results in [a; b; S] = <ref> [11; 4; 13] </ref>. However, if Alice tries to fool Bob and Carl, she can submit (1; 8) instead of her actual value.
Reference: [5] <author> Tal Rabin and Michael Ben-Or. </author> <title> Verifiable secret sharing and multiparty protocols with honest majority (extended abstract). </title> <journal> Communications of the ACM, </journal> <pages> pages 73-85, </pages> <year> 1989. </year>
Reference-contexts: In addition, it must be assured that participants in the protocol are unable to cheat. The secret sharing problem implicitly assumes that shares will be pooled by the quorum to compute the secret. Various protocols have been created <ref> [5, 8, 1] </ref>. Some of these include techniques to catch cheaters who might put bogus values into the shared pool of information. Even if cheaters can be detected, a problem remains since cheaters can still see the contents of the pool before revealing their own shares. <p> Yet Alice now has both Bob's and Carl's shares, and can compute S at her leisure. 4 Ben-Or/Rabin Solution Tal Rabin and Michael Ben-Or improved on the protocols of Shamir and others [8, 1] by introducing a zero-knowledge proof based upon Check Vectors into the protocol <ref> [5] </ref>.
Reference: [6] <author> Adi Shamir. </author> <title> How to share a secret. </title> <journal> Communications of the ACM, </journal> <volume> 22(11) </volume> <pages> 612-613, </pages> <year> 1979. </year>
Reference-contexts: When someone decides to vote "yes," she simply adds her share into a general pool. When q shares are in the pool, the access code can be computed and used. Otherwise, the access code will remain safely anonymous. * Hierarchical Access <ref> [6] </ref> Similar to distributed decision making, let the secret be a key. However, instead of giving one share to everyone, prioritize people according to authority. In a business, for example, you could give the CEO q shares-the secret in essence. <p> As this method does not require an extraordinary amount of additional data over the single backup scheme, it is doubly attractive. 3 Shamir's Solution The first secret sharing protocol was created by Adi Shamir <ref> [6] </ref>.
Reference: [7] <author> Gilbert Strang. </author> <title> Linear Algebra and its Applications. </title> <publisher> Harcourt Brace Jovanovich, Inc., </publisher> <address> third edition, </address> <year> 1988. </year>
Reference-contexts: The best he can do is create an equation for S with one degree of freedom <ref> [7] </ref>, which gives no information about the actual value of S. 3.2 Weaknesses There are two major weaknesses in Shamir's protocol: 1. Bogus values are undetectable. 2. Participants need not reveal their true share.
Reference: [8] <author> Martin Tompa and Heather Woll. </author> <title> How to share a secret with cheaters. </title> <type> Research Report RC 11840, </type> <institution> IBM Research Division, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: In addition, it must be assured that participants in the protocol are unable to cheat. The secret sharing problem implicitly assumes that shares will be pooled by the quorum to compute the secret. Various protocols have been created <ref> [5, 8, 1] </ref>. Some of these include techniques to catch cheaters who might put bogus values into the shared pool of information. Even if cheaters can be detected, a problem remains since cheaters can still see the contents of the pool before revealing their own shares. <p> Yet Alice now has both Bob's and Carl's shares, and can compute S at her leisure. 4 Ben-Or/Rabin Solution Tal Rabin and Michael Ben-Or improved on the protocols of Shamir and others <ref> [8, 1] </ref> by introducing a zero-knowledge proof based upon Check Vectors into the protocol [5].
Reference: [9] <author> J. D. Tygar and B. S. Yee. </author> <title> Pysically secure coprocessors. </title> <type> Technical Report CMU-CS-91-140R, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: (mod 17) 15 = 10 + 9a + 3b + S (mod 17) which translated in matrix form to: 2 4 14 3 5 = 6 1 1 1 9 3 1 7 2 4 b 3 5 (mod 17) which yields the incorrect result of [a; b; S] = <ref> [9; 14; 1] </ref>. However, to the eyes of Bob and Carl, everything is as it should be until the secret is actually used and is found to be in error. <p> Future research on secret sharing would require that we extend the protocol to overcome these limitations. One idea would be to explore the use of a secure co-processor <ref> [9, 10] </ref> with the protocol. Proper use could remove the need for any form of check vector requirement as well as allowing the secret to be re-secured; if the secure co-processor is the only entity that interpolates and discovers the secret, then no participant will ever have knowledge of it.
Reference: [10] <author> J. D. Tygar and B. S. Yee. Strongbox. In Jeffrey L. Eppinger, Lily B. Mummert, and Alfred Z. Spector, </author> <title> editors, Camelot and Avalon: A Distributed Transaction Facility. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year> <month> 15 </month>
Reference-contexts: Future research on secret sharing would require that we extend the protocol to overcome these limitations. One idea would be to explore the use of a secure co-processor <ref> [9, 10] </ref> with the protocol. Proper use could remove the need for any form of check vector requirement as well as allowing the secret to be re-secured; if the secure co-processor is the only entity that interpolates and discovers the secret, then no participant will ever have knowledge of it.
References-found: 10

