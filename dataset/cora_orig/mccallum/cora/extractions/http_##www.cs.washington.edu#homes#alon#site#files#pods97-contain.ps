URL: http://www.cs.washington.edu/homes/alon/site/files/pods97-contain.ps
Refering-URL: http://www.cs.washington.edu/homes/alon/site/PaperAbstractPresentation_bib21.html
Root-URL: 
Email: levy@research.att.com  suciu@research.att.com  
Title: Deciding Containment for Queries with Complex Objects (Extended Abstract)  
Author: Alon Y. Levy Dan Suciu 
Affiliation: AT&T Labs  AT&T Labs  
Abstract: We address the problem of query containment and query equivalence for complex objects. We show that for a certain conjunctive query language for complex objects, query containment and weak query equivalence are decidable. Our results also have two important consequences. First, when the answers of the two queries are guaranteed not to contain empty sets, then weak equivalence coincides with equivalence, and our result answers partially an open problem about the equivalence of nest; unnest queries for complex objects [24]. Second, we show that checking the equivalence of conjunctive queries with grouping and aggregates is NP-complete. Our results rely on a translation of the containment and equivalence conditions for complex objects into novel conditions on conjunctive queries, which we call simulation and strong simulation respectively. These conditions are more complex than containment of conjunctive queries, because they involve arbitrary numbers of quantifier alternations. We show that checking simulation and strong simulation for conjunctive queries is NP-complete. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Serge Abiteboul and Catriel Beeri. </author> <title> On the power of languages for the manipulation of complex objects. </title> <journal> VLDB Journal, </journal> <month> October </month> <year> 1995. </year>
Reference-contexts: Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30]. However, containment and equivalence for query languages for complex objects have not been considered previously. Complex Objects Several query formalisms have been proposed <ref> [40, 33, 16, 7, 1] </ref>. We consider the containment and equivalence problems for a certain subset of the Object Query Language, OQL [9] which we call conjunctive idealized OQL, COQL. <p> We con sider a fragment of such languages, which we call conjunctive queries for complex objects. 3.1 How we query them: COQL Following <ref> [1, 7] </ref> we define complex objects recursively to be: (1) an atomic value d from an infinite domain D, or, (2) a record [A 1 : x 1 ; : : : ; A k : x k ] where x 1 ; : : : ; x k are complex <p> Finally we argue that conjunctive queries for complex objects are a robust language, independent of a particular formalism. By using previously known techniques [7, 16] we can prove that COQL is equivalent to: (1) The fragment of Abiteboul and Beeri's algebra <ref> [1] </ref> defined by: product, flatten, selection on equality, map, and singleton. (2) The algebra fi; A=B ; ; outernest; unnest, i.e. consisting of a fragment of Thomas&Fischer's algebra [40] in which nest is replaced with outernest (defined in Example A.1). 3.2 How we compare them: containment and equivalence Traditionally, query containment
Reference: [2] <author> Serge Abiteboul, Richard Hull, and Victor Vianu. </author> <title> Foundations of databases. </title> <publisher> Addison Wesley Publishing Co, </publisher> <year> 1995. </year>
Reference-contexts: Therefore we will have to develop a separate criteria for testing containment and equivalence, and the latter turns out to be more complex. Importantly, when the result of a COQL query is a flat set or a Verso-relation <ref> [2] </ref>, then equivalence follows from containment in both directions. 4 Main Results We summarize here our main results. First: Theorem 4.1 Containment of COQL queries is decidable. 2 Our result for equivalence is weaker.
Reference: [3] <author> Alfred Aho, Yehoshua Sagiv, and Jeffrey D. Ull-man. </author> <title> Equivalence of relational expressions. </title> <journal> SIAM Journal of Computing, </journal> (8)2:218-246, 1979. 
Reference-contexts: More recently, query containment has been used to determine when queries are independent of updates to the database [31], rewriting queries using views [12, 27], and maintenance of integrity constraints [23]. Previous work on query containment has considered queries in the relational algebra <ref> [11, 36, 3] </ref> and datalog [38, 37, 14]. Several works have considered the extension of containment algorithms for queries involving order [26, 42, 31, 44, 23]. Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30].
Reference: [4] <author> N. Bidoit. </author> <title> The Verso algebra or How to ansower queries with fewer joins. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 35(3) </volume> <pages> 321-364, </pages> <year> 1987. </year>
Reference-contexts: This however does not reduce the containment problem for complex objects to that of flat relations: we show here that the former is more difficult. This is in contrast with the containment problem of Verso relations discussed in <ref> [4] </ref>, for a different query language. A particular problem we encountered is to find a natural definition for complex object containment. The problem is that set inclusion is not preserved under complex object operations such as nesting or the set constructor. <p> We therefore consider the weakest order relation that is consistent with the relational model, and is preserved by the application of complex objects constructors. It coincides with order relations previously considered in conjunction with Verso relations <ref> [4] </ref>, partial informations [8] and or-sets [32]. Containment and Equivalence of Queries with Aggregates Complex objects and aggregates are related in a natural way [33]. We show how to derive from our results for complex objects new containment and equivalence results for queries with grouping and aggregation over flat relations. <p> This notion of containment has been used previously for Verso relations <ref> [4] </ref>, partial informations [8] and or-sets [32]. It is a particular case of the lower (Hoare) powerdomain ordering [22], and it coincides with the simulation relation between complex objects represented as graphs [6, 5].
Reference: [5] <author> Peter Buneman, Susan Davidson, Mary Fernandez, and Dan Suciu. </author> <title> Adding structure to unstructured data. </title> <booktitle> In ICDT, </booktitle> <year> 1997. </year>
Reference-contexts: This notion of containment has been used previously for Verso relations [4], partial informations [8] and or-sets [32]. It is a particular case of the lower (Hoare) powerdomain ordering [22], and it coincides with the simulation relation between complex objects represented as graphs <ref> [6, 5] </ref>.
Reference: [6] <author> Peter Buneman, Susan Davidson, Gerd Hillebrand, and Dan Suciu. </author> <title> A query language and optimization techniques for unstructured data. </title> <booktitle> In SIGMOD, </booktitle> <year> 1996. </year>
Reference-contexts: This notion of containment has been used previously for Verso relations [4], partial informations [8] and or-sets [32]. It is a particular case of the lower (Hoare) powerdomain ordering [22], and it coincides with the simulation relation between complex objects represented as graphs <ref> [6, 5] </ref>.
Reference: [7] <author> Peter Buneman, Shamim Naqvi, Val Tannen, and Limsoon Wong. </author> <title> Principles of proramming with collection types. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1995. </year>
Reference-contexts: Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30]. However, containment and equivalence for query languages for complex objects have not been considered previously. Complex Objects Several query formalisms have been proposed <ref> [40, 33, 16, 7, 1] </ref>. We consider the containment and equivalence problems for a certain subset of the Object Query Language, OQL [9] which we call conjunctive idealized OQL, COQL. <p> We con sider a fragment of such languages, which we call conjunctive queries for complex objects. 3.1 How we query them: COQL Following <ref> [1, 7] </ref> we define complex objects recursively to be: (1) an atomic value d from an infinite domain D, or, (2) a record [A 1 : x 1 ; : : : ; A k : x k ] where x 1 ; : : : ; x k are complex <p> This explains why we dropped set difference from OQL (called there except), and restricted the boolean expressions to equalities of atomic values only: had we allowed equalities of set expression then one can express set difference too <ref> [7] </ref>. Finally we dropped union: here we also had to restrict OQL's set constructor fE 1 ; : : : ; E k g to k 1, because else one can express union as E [ E 0 =flatten (fE; E 0 g). <p> A query over relations R 1 ; : : : ; R p is any closed COQL expression (i.e., no free variables except for the relation names R 1 ; : : : ; R p ) returning some relation. COQL is equivalent to the core calculus presented in <ref> [7] </ref> extended with constants and with equality over base types. The semantics of COQL is based on the semantics in [7]. COQL is indeed a natural extension of conjunctive queries to complex objects. <p> COQL is equivalent to the core calculus presented in <ref> [7] </ref> extended with constants and with equality over base types. The semantics of COQL is based on the semantics in [7]. COQL is indeed a natural extension of conjunctive queries to complex objects. Using techniques in [43] we can prove that COQL is a conservative extension of conjunctive queries, meaning that the queries it expresses over flat relations are precisely the conjunctive queries. <p> Finally we argue that conjunctive queries for complex objects are a robust language, independent of a particular formalism. By using previously known techniques <ref> [7, 16] </ref> we can prove that COQL is equivalent to: (1) The fragment of Abiteboul and Beeri's algebra [1] defined by: product, flatten, selection on equality, map, and singleton. (2) The algebra fi; A=B ; ; outernest; unnest, i.e. consisting of a fragment of Thomas&Fischer's algebra [40] in which nest is
Reference: [8] <author> Peter Buneman, Atsushi Ohori, and Achim Jung. </author> <title> Using powerdomains to generalize relational databases. </title> <journal> Theoretical Computer Science, </journal> <volume> 91 </volume> <pages> 23-55, </pages> <year> 1991. </year>
Reference-contexts: We therefore consider the weakest order relation that is consistent with the relational model, and is preserved by the application of complex objects constructors. It coincides with order relations previously considered in conjunction with Verso relations [4], partial informations <ref> [8] </ref> and or-sets [32]. Containment and Equivalence of Queries with Aggregates Complex objects and aggregates are related in a natural way [33]. We show how to derive from our results for complex objects new containment and equivalence results for queries with grouping and aggregation over flat relations. <p> This notion of containment has been used previously for Verso relations [4], partial informations <ref> [8] </ref> and or-sets [32]. It is a particular case of the lower (Hoare) powerdomain ordering [22], and it coincides with the simulation relation between complex objects represented as graphs [6, 5].
Reference: [9] <author> R. G. G. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1994. </year>
Reference-contexts: However, containment and equivalence for query languages for complex objects have not been considered previously. Complex Objects Several query formalisms have been proposed [40, 33, 16, 7, 1]. We consider the containment and equivalence problems for a certain subset of the Object Query Language, OQL <ref> [9] </ref> which we call conjunctive idealized OQL, COQL. It is a generalization of conjunctive queries [41] and also corresponds to natural fragments of other query languages for complex objects. <p> By abuse of notation we shall switch back and forth between records (like [A : x; B : y]) and tuples (like (x; y)) using whichever notation is more convenient. We choose as formalism for querying complex objects a certain idealized fragment of OQL <ref> [9] </ref> which we call conjunctive idealized OQL, COQL. Its set operators are restricted to select from where, flatten, the singleton fEg and the empty set fg: Appendix A contains a full description. The purpose of COQL is to be an analog of conjunctive queries for flat relations [41].
Reference: [10] <author> Edward P. Chan. </author> <title> Containment and minimization of positive conjunctive queries in oodb's. </title> <booktitle> In ACM PODS, </booktitle> <year> 1992. </year>
Reference-contexts: Several works have considered the extension of containment algorithms for queries involving order [26, 42, 31, 44, 23]. Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in <ref> [10, 30] </ref>. However, containment and equivalence for query languages for complex objects have not been considered previously. Complex Objects Several query formalisms have been proposed [40, 33, 16, 7, 1].
Reference: [11] <author> A.K. Chandra and P.M. Merlin. </author> <title> Optimal implementation of conjunctive queries in relational databases. </title> <booktitle> In Proceedings of the Ninth Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1977. </year>
Reference-contexts: More recently, query containment has been used to determine when queries are independent of updates to the database [31], rewriting queries using views [12, 27], and maintenance of integrity constraints [23]. Previous work on query containment has considered queries in the relational algebra <ref> [11, 36, 3] </ref> and datalog [38, 37, 14]. Several works have considered the extension of containment algorithms for queries involving order [26, 42, 31, 44, 23]. Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30]. <p> By simulation we mean: 8I:9 I 0 :[8S:8C:(Q 1 (S; I) ^ Q 2 (I; C)) =) 1 (S; I 0 ) ^ Q 0 We describe a sufficient and necessary condition for simulation which is based on extending the condition of containment mappings <ref> [11] </ref>.
Reference: [12] <author> Surajit Chaudhuri, Ravi Krishnamurthy, Spyros Potamianos, and Kyuseok Shim. </author> <title> Optimizing queries with materialized views. </title> <booktitle> In Proceedings of ICDE, </booktitle> <year> 1995. </year>
Reference-contexts: For example, query containment can be used to find redundant subgoals in a query and to test whether two formulations of a query are equivalent. More recently, query containment has been used to determine when queries are independent of updates to the database [31], rewriting queries using views <ref> [12, 27] </ref>, and maintenance of integrity constraints [23]. Previous work on query containment has considered queries in the relational algebra [11, 36, 3] and datalog [38, 37, 14]. Several works have considered the extension of containment algorithms for queries involving order [26, 42, 31, 44, 23].
Reference: [13] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Including group-by in query optimization. </title> <booktitle> In Proceedings of the 20th VLDB Conference, </booktitle> <address> Santiago, Chile, </address> <year> 1994. </year>
Reference-contexts: In particular, we show that containment is decidable for queries with arbitrary nesting of aggregation with uninterpreted aggregate functions as long as we do not perform joins or selections on aggregated columns. Previous work on optimization of queries with aggregation <ref> [17, 13, 29, 35, 28] </ref> has focussed on providing transformation rules that can be applied to queries and conserve equivalence. However, equivalence and containment tests were not considered.
Reference: [14] <author> Surajit Chaudhuri and Moshe Vardi. </author> <title> On the equivalence of recursive and nonrecursive datalog programs. </title> <booktitle> In ACM PODS, </booktitle> <year> 1992. </year>
Reference-contexts: More recently, query containment has been used to determine when queries are independent of updates to the database [31], rewriting queries using views [12, 27], and maintenance of integrity constraints [23]. Previous work on query containment has considered queries in the relational algebra [11, 36, 3] and datalog <ref> [38, 37, 14] </ref>. Several works have considered the extension of containment algorithms for queries involving order [26, 42, 31, 44, 23]. Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30].
Reference: [15] <author> Surajit Chaudhuri and Moshe Vardi. </author> <title> Optimizing real conjunctive queries. </title> <booktitle> In ACM PODS, </booktitle> <year> 1993. </year>
Reference-contexts: Previous work on query containment has considered queries in the relational algebra [11, 36, 3] and datalog [38, 37, 14]. Several works have considered the extension of containment algorithms for queries involving order [26, 42, 31, 44, 23]. Queries over bags were considered in <ref> [15] </ref>, and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30]. However, containment and equivalence for query languages for complex objects have not been considered previously. Complex Objects Several query formalisms have been proposed [40, 33, 16, 7, 1].
Reference: [16] <author> Latha S. Colby. </author> <title> Query Languages and a Unifying Framework for Non-traditional Data Models. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Indi-ana University, Bloomington, Indiana 47405-4101, </institution> <month> May </month> <year> 1993. </year> <note> Available as Indiana University Computer Science Technical Report 381. </note>
Reference-contexts: Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30]. However, containment and equivalence for query languages for complex objects have not been considered previously. Complex Objects Several query formalisms have been proposed <ref> [40, 33, 16, 7, 1] </ref>. We consider the containment and equivalence problems for a certain subset of the Object Query Language, OQL [9] which we call conjunctive idealized OQL, COQL. <p> Finally we argue that conjunctive queries for complex objects are a robust language, independent of a particular formalism. By using previously known techniques <ref> [7, 16] </ref> we can prove that COQL is equivalent to: (1) The fragment of Abiteboul and Beeri's algebra [1] defined by: product, flatten, selection on equality, map, and singleton. (2) The algebra fi; A=B ; ; outernest; unnest, i.e. consisting of a fragment of Thomas&Fischer's algebra [40] in which nest is
Reference: [17] <author> Umesh Dayal. </author> <title> Of nests and trees: A unified approach to processing queries that contain nested subqueries, aggregates, and quantifiers. </title> <booktitle> In Proceedings of VLDB-87, </booktitle> <pages> pages pages 197-208, </pages> <year> 1987. </year>
Reference-contexts: In particular, we show that containment is decidable for queries with arbitrary nesting of aggregation with uninterpreted aggregate functions as long as we do not perform joins or selections on aggregated columns. Previous work on optimization of queries with aggregation <ref> [17, 13, 29, 35, 28] </ref> has focussed on providing transformation rules that can be applied to queries and conserve equivalence. However, equivalence and containment tests were not considered.
Reference: [18] <author> Jan Van den Bussche. </author> <title> Complex object manipulation through identifiers: An algebraic perspective. </title> <type> Technical Report 92-41, </type> <institution> University of Antwerp, Department of Mathematics and Computer Science, Universiteitsplein 1, B-2610 Antwerp, Bel-gium, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: However, equivalence and containment tests were not considered. Finite Model Theory Our containment algorithm for complex objects is based on a procedure for checking simulation on conjunctive queries with grouping, which is a condition of independent interest: it arises naturally by encoding complex objects into flat relations with indexes <ref> [21, 18, 39, 25] </ref>. Informally, a query Q is simulated by a query Q 0 if, for any database, each of the groups in Q is contained in one of the groups in Q 0 , a condition which generalizes containment of conjunctive queries. <p> containment of COQL queries. 2 Note that "weak containment" is always the same as containment. 3 With the terminology in [24] the nest operator -X (; !) is restricted to having all attributes in X atomic. 5.1 Indexes Indexes have been used to encode complex objects as flat relations in <ref> [21, 18, 39, 25] </ref>. The idea is to replace every inner set (relation) with a fresh atomic value, called index , and to store separately, in another relation, the correspondence between the indexes and the relations they replace.
Reference: [19] <author> D. Dreben and W. D. Goldfarb. </author> <title> The Decision Problem: Solvable Classes of Quantificational Formulas. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The logical complexity of formulas expressing simulation (and strong simulation) is higher than for containment: simulation (to depth d) leads to d + 1 alternations of existential and universal quantifiers, while containment formulas have a single alternation, and are a particular case of Bernays and Schonfinkel formulas <ref> [19] </ref>. We describe algorithms for checking simulation and strong simulation of conjunctive queries and show that both problems are NP-complete. The fact that simulation is decidable follows also from the decidability of the Class 1.2 [19, pp.21]: the fact that it is in NP is new. <p> We describe algorithms for checking simulation and strong simulation of conjunctive queries and show that both problems are NP-complete. The fact that simulation is decidable follows also from the decidability of the Class 1.2 <ref> [19, pp.21] </ref>: the fact that it is in NP is new. However checking strong simulation is not reducible to any of the classes in [19], and its decidability and NP complexity are new results. We start by motivating the problem with an example in Section 2. <p> The fact that simulation is decidable follows also from the decidability of the Class 1.2 [19, pp.21]: the fact that it is in NP is new. However checking strong simulation is not reducible to any of the classes in <ref> [19] </ref>, and its decidability and NP complexity are new results. We start by motivating the problem with an example in Section 2. We describe the conjunctive query language for complex objects in Section 3, then state our main results in Section 4. <p> The containment condition [41] of conjunctive queries Q; Q 0 is expressed as in Equation 2 with d = 0 (recall that each of Q; Q 0 itself is an existential formula). Its negation is a Bernays-Schonfinkel formula, i.e., with prefix 9 fl 8 fl <ref> [19] </ref>. However, formulas for arbitrary d-simulation and d-strong simulation (Equations 2, 4) have d + 1 quantifier alternations, and their negations are no longer Bernays-Schonfinkel formulas. <p> However, formulas for arbitrary d-simulation and d-strong simulation (Equations 2, 4) have d + 1 quantifier alternations, and their negations are no longer Bernays-Schonfinkel formulas. By inspecting their matrix one observes that the negation of the simulation condition is in the Class 1.2 <ref> [19, pp.21] </ref>, which implies that testing simulation is decidable. The class of formulas for strong simulation (Equation 4) does not correspond to any of the decidable classes considered in [19], and their decidability result is new. <p> By inspecting their matrix one observes that the negation of the simulation condition is in the Class 1.2 [19, pp.21], which implies that testing simulation is decidable. The class of formulas for strong simulation (Equation 4) does not correspond to any of the decidable classes considered in <ref> [19] </ref>, and their decidability result is new. <p> We also mention that the proofs of Theorems 5.7 and 6.2 imply that the negations of the formulas in Equations 2 and 4 have the finite model prop erty <ref> [19, 20] </ref>. 7 Queries with Aggregation The equivalence and containment algorithms described in the previous sections can also be used to test containment and equivalence for some classes of conjunctive queries with grouping and aggregation. The following example illustrates the key idea.
Reference: [20] <author> Heinz-Dieter Ebbinghaus and Jorg Flum. </author> <title> Finite Model Theory. </title> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: We also mention that the proofs of Theorems 5.7 and 6.2 imply that the negations of the formulas in Equations 2 and 4 have the finite model prop erty <ref> [19, 20] </ref>. 7 Queries with Aggregation The equivalence and containment algorithms described in the previous sections can also be used to test containment and equivalence for some classes of conjunctive queries with grouping and aggregation. The following example illustrates the key idea.
Reference: [21] <author> Dirk Van Gucht and Patrick C. Fischer. </author> <title> Multilevel nested relational structures. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 36 </volume> <pages> 77-105, </pages> <year> 1988. </year>
Reference-contexts: However, equivalence and containment tests were not considered. Finite Model Theory Our containment algorithm for complex objects is based on a procedure for checking simulation on conjunctive queries with grouping, which is a condition of independent interest: it arises naturally by encoding complex objects into flat relations with indexes <ref> [21, 18, 39, 25] </ref>. Informally, a query Q is simulated by a query Q 0 if, for any database, each of the groups in Q is contained in one of the groups in Q 0 , a condition which generalizes containment of conjunctive queries. <p> containment of COQL queries. 2 Note that "weak containment" is always the same as containment. 3 With the terminology in [24] the nest operator -X (; !) is restricted to having all attributes in X atomic. 5.1 Indexes Indexes have been used to encode complex objects as flat relations in <ref> [21, 18, 39, 25] </ref>. The idea is to replace every inner set (relation) with a fresh atomic value, called index , and to store separately, in another relation, the correspondence between the indexes and the relations they replace.
Reference: [22] <author> Carl A. Gunter and Dana S. Scott. </author> <title> Semantic domains. In Formal Models and Semantics, </title> <booktitle> volume B of Handbook of Theoretical Computer Science, Chapter 12, </booktitle> <pages> pages 635-674. </pages> <year> 1990. </year>
Reference-contexts: This notion of containment has been used previously for Verso relations [4], partial informations [8] and or-sets [32]. It is a particular case of the lower (Hoare) powerdomain ordering <ref> [22] </ref>, and it coincides with the simulation relation between complex objects represented as graphs [6, 5].
Reference: [23] <author> Ashish Gupta, Yehoshua Sagiv, Jeffrey D. Ullman, and Jennifer Widom. </author> <title> Constraint checking with par-ial information. </title> <booktitle> In ACM PODS, </booktitle> <year> 1994. </year>
Reference-contexts: More recently, query containment has been used to determine when queries are independent of updates to the database [31], rewriting queries using views [12, 27], and maintenance of integrity constraints <ref> [23] </ref>. Previous work on query containment has considered queries in the relational algebra [11, 36, 3] and datalog [38, 37, 14]. Several works have considered the extension of containment algorithms for queries involving order [26, 42, 31, 44, 23]. <p> Previous work on query containment has considered queries in the relational algebra [11, 36, 3] and datalog [38, 37, 14]. Several works have considered the extension of containment algorithms for queries involving order <ref> [26, 42, 31, 44, 23] </ref>. Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30]. However, containment and equivalence for query languages for complex objects have not been considered previously.
Reference: [24] <author> Marc Gyssens, Jan Paredaens, and Dirk Van Gucht. </author> <title> On a hierarchy of classes for nested databases. </title> <journal> Information Processing Letters, </journal> <volume> 36 </volume> <pages> 259-266, </pages> <year> 1990. </year>
Reference-contexts: It is a generalization of conjunctive queries [41] and also corresponds to natural fragments of other query languages for complex objects. In particular, our equivalence result partially answers an open problem for testing the equivalence of sequences of nest and unnest operations in <ref> [24] </ref>. Paredaens and Van Gucht [34] and Wong [43] prove that the nested relational algebra for complex objects is a conservative extension of the relational algebra. <p> Second, if both queries are guaranteed not to contain empty sets in their results (again this is the case for nest; unnest) then this exponential component disappears too: then both containment and equivalence are NP-complete. Gyssens, Paredaens, and Van Gucht <ref> [24] </ref> ask the question whether equivalence of two sequences of nest; unnest operations is decidable. It follows that this problem is NP-complete if in every nest operator the nesting is governed only by atomic attributes 3 . <p> Finally, in Subsection 5.3 we show how to use simulation for testing containment, leading to a necessary and sufficient test for containment of COQL queries. 2 Note that "weak containment" is always the same as containment. 3 With the terminology in <ref> [24] </ref> the nest operator -X (; !) is restricted to having all attributes in X atomic. 5.1 Indexes Indexes have been used to encode complex objects as flat relations in [21, 18, 39, 25].
Reference: [25] <author> Marc Gyssens, Dan Suciu, and Dirk Van Gucht. </author> <title> On polynomially bounded fixpoint constructs for nested relations. </title> <booktitle> In Proceedings of DBPL'95, </booktitle> <address> Gub-bio, Italy, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: However, equivalence and containment tests were not considered. Finite Model Theory Our containment algorithm for complex objects is based on a procedure for checking simulation on conjunctive queries with grouping, which is a condition of independent interest: it arises naturally by encoding complex objects into flat relations with indexes <ref> [21, 18, 39, 25] </ref>. Informally, a query Q is simulated by a query Q 0 if, for any database, each of the groups in Q is contained in one of the groups in Q 0 , a condition which generalizes containment of conjunctive queries. <p> containment of COQL queries. 2 Note that "weak containment" is always the same as containment. 3 With the terminology in [24] the nest operator -X (; !) is restricted to having all attributes in X atomic. 5.1 Indexes Indexes have been used to encode complex objects as flat relations in <ref> [21, 18, 39, 25] </ref>. The idea is to replace every inner set (relation) with a fresh atomic value, called index , and to store separately, in another relation, the correspondence between the indexes and the relations they replace.
Reference: [26] <author> A. Klug. </author> <title> On conjunctive queries containing inequalities. </title> <journal> Journal of the ACM, </journal> <pages> pages 35(1): 146-160, </pages> <year> 1988. </year>
Reference-contexts: Previous work on query containment has considered queries in the relational algebra [11, 36, 3] and datalog [38, 37, 14]. Several works have considered the extension of containment algorithms for queries involving order <ref> [26, 42, 31, 44, 23] </ref>. Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30]. However, containment and equivalence for query languages for complex objects have not been considered previously.
Reference: [27] <author> Alon Y. Levy, Alberto O. Mendelzon, Yehoshua Sa-giv, and Divesh Srivastava. </author> <title> Answering queries using views. </title> <booktitle> In ACM PODS, </booktitle> <year> 1995. </year>
Reference-contexts: For example, query containment can be used to find redundant subgoals in a query and to test whether two formulations of a query are equivalent. More recently, query containment has been used to determine when queries are independent of updates to the database [31], rewriting queries using views <ref> [12, 27] </ref>, and maintenance of integrity constraints [23]. Previous work on query containment has considered queries in the relational algebra [11, 36, 3] and datalog [38, 37, 14]. Several works have considered the extension of containment algorithms for queries involving order [26, 42, 31, 44, 23]. <p> Second, we would like to carry over techniques based on query containments, such as query rewriting <ref> [27] </ref>, and update independence [31] to complex objects. Finally, we believe that our techniques offer a new approach for testing queries with aggregates: our criteria based on uninterpreted functions only scratches the surface.
Reference: [28] <author> Alon Y. Levy and Inderpal Singh Mumick. </author> <title> Reasoning with aggregation constraints. </title> <booktitle> In Proceedings of EDBT-96, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: In particular, we show that containment is decidable for queries with arbitrary nesting of aggregation with uninterpreted aggregate functions as long as we do not perform joins or selections on aggregated columns. Previous work on optimization of queries with aggregation <ref> [17, 13, 29, 35, 28] </ref> has focussed on providing transformation rules that can be applied to queries and conserve equivalence. However, equivalence and containment tests were not considered.
Reference: [29] <author> Alon Y. Levy, Inderpal Singh Mumick, and Yehoshua Sagiv. </author> <title> Query optimization by predicate move-around. </title> <booktitle> In Proceedings of the 20th VLDB Conference, Santiago, Chile, </booktitle> <pages> pages 96-107, </pages> <year> 1994. </year>
Reference-contexts: In particular, we show that containment is decidable for queries with arbitrary nesting of aggregation with uninterpreted aggregate functions as long as we do not perform joins or selections on aggregated columns. Previous work on optimization of queries with aggregation <ref> [17, 13, 29, 35, 28] </ref> has focussed on providing transformation rules that can be applied to queries and conserve equivalence. However, equivalence and containment tests were not considered.
Reference: [30] <author> Alon Y. Levy and Marie-Christine Rousset. CARIN: </author> <title> a representation language integrating rules and description logics. </title> <booktitle> In Proceedings of the European Conference on Artificial Intelligence, </booktitle> <address> Bu-dapest, Hungary, </address> <year> 1996. </year>
Reference-contexts: Several works have considered the extension of containment algorithms for queries involving order [26, 42, 31, 44, 23]. Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in <ref> [10, 30] </ref>. However, containment and equivalence for query languages for complex objects have not been considered previously. Complex Objects Several query formalisms have been proposed [40, 33, 16, 7, 1].
Reference: [31] <author> Alon Y. Levy and Yehoshua Sagiv. </author> <title> Queries independent of updates. </title> <booktitle> In Proceedings of the 19th VLDB Conference, </booktitle> <address> Dublin, Ireland, </address> <year> 1993. </year>
Reference-contexts: For example, query containment can be used to find redundant subgoals in a query and to test whether two formulations of a query are equivalent. More recently, query containment has been used to determine when queries are independent of updates to the database <ref> [31] </ref>, rewriting queries using views [12, 27], and maintenance of integrity constraints [23]. Previous work on query containment has considered queries in the relational algebra [11, 36, 3] and datalog [38, 37, 14]. <p> Previous work on query containment has considered queries in the relational algebra [11, 36, 3] and datalog [38, 37, 14]. Several works have considered the extension of containment algorithms for queries involving order <ref> [26, 42, 31, 44, 23] </ref>. Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30]. However, containment and equivalence for query languages for complex objects have not been considered previously. <p> It is still an open problem whether checking such a condition for conjunctive queries is decidable. Note that deciding this condition does not follow from previous results on containment of queries with negation <ref> [36, 31] </ref>. We generalize the above argument and prove the next proposition in the full version of the paper. This implies Theorem 4.2. <p> Second, we would like to carry over techniques based on query containments, such as query rewriting [27], and update independence <ref> [31] </ref> to complex objects. Finally, we believe that our techniques offer a new approach for testing queries with aggregates: our criteria based on uninterpreted functions only scratches the surface.
Reference: [32] <author> Leonid Libkin and Limsoon Wong. </author> <title> Semantic representations and query languages for orsets. </title> <booktitle> In Proceedings of 12th ACM Symposium on Principles of Database Systems, </booktitle> <address> Washington, D. C., </address> <year> 1993. </year>
Reference-contexts: We therefore consider the weakest order relation that is consistent with the relational model, and is preserved by the application of complex objects constructors. It coincides with order relations previously considered in conjunction with Verso relations [4], partial informations [8] and or-sets <ref> [32] </ref>. Containment and Equivalence of Queries with Aggregates Complex objects and aggregates are related in a natural way [33]. We show how to derive from our results for complex objects new containment and equivalence results for queries with grouping and aggregation over flat relations. <p> This notion of containment has been used previously for Verso relations [4], partial informations [8] and or-sets <ref> [32] </ref>. It is a particular case of the lower (Hoare) powerdomain ordering [22], and it coincides with the simulation relation between complex objects represented as graphs [6, 5].
Reference: [33] <author> G. Ozsoyoglu, Z. M. Ozsoyoglu, and V. Matos. </author> <title> Extending relational algebra and relational calculus with set-valued attributes and aggregate functions. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(4) </volume> <pages> 566-592, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30]. However, containment and equivalence for query languages for complex objects have not been considered previously. Complex Objects Several query formalisms have been proposed <ref> [40, 33, 16, 7, 1] </ref>. We consider the containment and equivalence problems for a certain subset of the Object Query Language, OQL [9] which we call conjunctive idealized OQL, COQL. <p> It coincides with order relations previously considered in conjunction with Verso relations [4], partial informations [8] and or-sets [32]. Containment and Equivalence of Queries with Aggregates Complex objects and aggregates are related in a natural way <ref> [33] </ref>. We show how to derive from our results for complex objects new containment and equivalence results for queries with grouping and aggregation over flat relations.
Reference: [34] <author> Jan Paredaens and Dirk Van Gucht. </author> <title> Converting nested relational algebra expressions into flat algebra expressions. </title> <journal> ACM Transaction on Database Systems, </journal> <volume> 17(1) </volume> <pages> 65-93, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: It is a generalization of conjunctive queries [41] and also corresponds to natural fragments of other query languages for complex objects. In particular, our equivalence result partially answers an open problem for testing the equivalence of sequences of nest and unnest operations in [24]. Paredaens and Van Gucht <ref> [34] </ref> and Wong [43] prove that the nested relational algebra for complex objects is a conservative extension of the relational algebra. This however does not reduce the containment problem for complex objects to that of flat relations: we show here that the former is more difficult.
Reference: [35] <author> Kenneth Ross, Divesh Srivastava, Peter Stuckey, and S. Sudarshan. </author> <title> Foundations of aggregation constraints. </title> <editor> In Alan Borning, editor, </editor> <booktitle> Principles and Practice of Constraint Programming. Lecture Notes in Computer Science, </booktitle> <volume> 874. </volume> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In particular, we show that containment is decidable for queries with arbitrary nesting of aggregation with uninterpreted aggregate functions as long as we do not perform joins or selections on aggregated columns. Previous work on optimization of queries with aggregation <ref> [17, 13, 29, 35, 28] </ref> has focussed on providing transformation rules that can be applied to queries and conserve equivalence. However, equivalence and containment tests were not considered.
Reference: [36] <author> Y. Sagiv and M. Yannakakis. </author> <title> Equivalence among relational expressions with the union and difference operators. </title> <journal> Journal of the ACM, </journal> <volume> 27(4) </volume> <pages> 633-655, </pages> <year> 1981. </year>
Reference-contexts: More recently, query containment has been used to determine when queries are independent of updates to the database [31], rewriting queries using views [12, 27], and maintenance of integrity constraints [23]. Previous work on query containment has considered queries in the relational algebra <ref> [11, 36, 3] </ref> and datalog [38, 37, 14]. Several works have considered the extension of containment algorithms for queries involving order [26, 42, 31, 44, 23]. Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30]. <p> It is still an open problem whether checking such a condition for conjunctive queries is decidable. Note that deciding this condition does not follow from previous results on containment of queries with negation <ref> [36, 31] </ref>. We generalize the above argument and prove the next proposition in the full version of the paper. This implies Theorem 4.2.
Reference: [37] <author> Yehoshua Sagiv. </author> <title> Optimizing datalog programs. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 659-698. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: More recently, query containment has been used to determine when queries are independent of updates to the database [31], rewriting queries using views [12, 27], and maintenance of integrity constraints [23]. Previous work on query containment has considered queries in the relational algebra [11, 36, 3] and datalog <ref> [38, 37, 14] </ref>. Several works have considered the extension of containment algorithms for queries involving order [26, 42, 31, 44, 23]. Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30].
Reference: [38] <author> Oded Shmueli. </author> <title> Equivalence of datalog queries is undecidable. </title> <journal> Journal of Logic Programming, </journal> <volume> 15 </volume> <pages> 231-241, </pages> <year> 1993. </year>
Reference-contexts: More recently, query containment has been used to determine when queries are independent of updates to the database [31], rewriting queries using views [12, 27], and maintenance of integrity constraints [23]. Previous work on query containment has considered queries in the relational algebra [11, 36, 3] and datalog <ref> [38, 37, 14] </ref>. Several works have considered the extension of containment algorithms for queries involving order [26, 42, 31, 44, 23]. Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30].
Reference: [39] <author> Dan Suciu. </author> <title> Fixpoints and bounded fixpoints for complex objects. In Catriel Beeri, Atsushi Ohori, </title> <editor> and Dennis Shasha, editors, </editor> <booktitle> Proceedings of 4th International Workshop on Database Programming Languages, </booktitle> <address> New York, </address> <month> August </month> <year> 1993, </year> <note> Springer-Verlag, </note> <month> January </month> <year> 1994. </year>
Reference-contexts: However, equivalence and containment tests were not considered. Finite Model Theory Our containment algorithm for complex objects is based on a procedure for checking simulation on conjunctive queries with grouping, which is a condition of independent interest: it arises naturally by encoding complex objects into flat relations with indexes <ref> [21, 18, 39, 25] </ref>. Informally, a query Q is simulated by a query Q 0 if, for any database, each of the groups in Q is contained in one of the groups in Q 0 , a condition which generalizes containment of conjunctive queries. <p> containment of COQL queries. 2 Note that "weak containment" is always the same as containment. 3 With the terminology in [24] the nest operator -X (; !) is restricted to having all attributes in X atomic. 5.1 Indexes Indexes have been used to encode complex objects as flat relations in <ref> [21, 18, 39, 25] </ref>. The idea is to replace every inner set (relation) with a fresh atomic value, called index , and to store separately, in another relation, the correspondence between the indexes and the relations they replace. <p> So we will assume from now on that all input relations are flat. Second, we "flatten" the queries themselves, using techniques from <ref> [39] </ref>: we show in the full version of the pa per that each COQL query Q can be encoded as m conjunctive queries Q 1 ; : : : ; Q m .
Reference: [40] <author> S. J. Thomas and P. C. Fischer. </author> <title> Nested relational structures. </title> <editor> In P. C. Kanellakis and F. P. Preparata, editors, </editor> <booktitle> Advances in Computing Research: The Theory of Databases, </booktitle> <pages> pages 269-307, </pages> <address> London, Eng-land, 1986. </address> <publisher> JAI Press. </publisher>
Reference-contexts: Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30]. However, containment and equivalence for query languages for complex objects have not been considered previously. Complex Objects Several query formalisms have been proposed <ref> [40, 33, 16, 7, 1] </ref>. We consider the containment and equivalence problems for a certain subset of the Object Query Language, OQL [9] which we call conjunctive idealized OQL, COQL. <p> using previously known techniques [7, 16] we can prove that COQL is equivalent to: (1) The fragment of Abiteboul and Beeri's algebra [1] defined by: product, flatten, selection on equality, map, and singleton. (2) The algebra fi; A=B ; ; outernest; unnest, i.e. consisting of a fragment of Thomas&Fischer's algebra <ref> [40] </ref> in which nest is replaced with outernest (defined in Example A.1). 3.2 How we compare them: containment and equivalence Traditionally, query containment for flat relations is defined in terms of set inclusion: query Q is contained in Q 0 , denoted by Q v Q 0 , iff Q (D)
Reference: [41] <author> Jeffrey D. Ullman. </author> <title> Principles of Database and Knowledge-base Systems, Volumes I, II. </title> <publisher> Computer Science Press, </publisher> <address> Rockville MD, </address> <year> 1989. </year>
Reference-contexts: Complex Objects Several query formalisms have been proposed [40, 33, 16, 7, 1]. We consider the containment and equivalence problems for a certain subset of the Object Query Language, OQL [9] which we call conjunctive idealized OQL, COQL. It is a generalization of conjunctive queries <ref> [41] </ref> and also corresponds to natural fragments of other query languages for complex objects. In particular, our equivalence result partially answers an open problem for testing the equivalence of sequences of nest and unnest operations in [24]. <p> Its set operators are restricted to select from where, flatten, the singleton fEg and the empty set fg: Appendix A contains a full description. The purpose of COQL is to be an analog of conjunctive queries for flat relations <ref> [41] </ref>. This explains why we dropped set difference from OQL (called there except), and restricted the boolean expressions to equalities of atomic values only: had we allowed equalities of set expression then one can express set difference too [7]. <p> We use the standard notation for conjunctive queries <ref> [41] </ref> over input relations R 1 ; : : : ; R n , except that we dis tinguish a set of index variables in the head of the query: Q ( I; V ) : R j 1 ( V 1 ); : : : ; R j m ( <p> Checking simulation is NP-hard because it generalizes containment of conjunctive queries. Note that conditions (1) and (2) say that ' is a containment mapping from Q 0 ( I 0 ; V 0 ) to Q ( I; V )^Q w ( I ; V w ) <ref> [41] </ref>, and they imply that the answers of Q are included in those of Q 0 (i.e., flatten (P ) flatten (P 0 ) with P; P 0 defined above). <p> Moreover, if Q; Q 0 are guaranteed not to contain empty sets, then one can take k = 1. 2 Finally we comment on the connection with finite model theory. The containment condition <ref> [41] </ref> of conjunctive queries Q; Q 0 is expressed as in Equation 2 with d = 0 (recall that each of Q; Q 0 itself is an existential formula). Its negation is a Bernays-Schonfinkel formula, i.e., with prefix 9 fl 8 fl [19].
Reference: [42] <author> Ron van der Meyden. </author> <title> The complexity of querying indefinite data about linearly ordered domains. </title> <booktitle> In ACM PODS, </booktitle> <year> 1992. </year>
Reference-contexts: Previous work on query containment has considered queries in the relational algebra [11, 36, 3] and datalog [38, 37, 14]. Several works have considered the extension of containment algorithms for queries involving order <ref> [26, 42, 31, 44, 23] </ref>. Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30]. However, containment and equivalence for query languages for complex objects have not been considered previously.
Reference: [43] <author> Limsoon Wong. </author> <title> Normal forms and conservative properties for query languages over collection types. </title> <booktitle> In ACM PODS, </booktitle> <year> 1993. </year>
Reference-contexts: In particular, our equivalence result partially answers an open problem for testing the equivalence of sequences of nest and unnest operations in [24]. Paredaens and Van Gucht [34] and Wong <ref> [43] </ref> prove that the nested relational algebra for complex objects is a conservative extension of the relational algebra. This however does not reduce the containment problem for complex objects to that of flat relations: we show here that the former is more difficult. <p> COQL is equivalent to the core calculus presented in [7] extended with constants and with equality over base types. The semantics of COQL is based on the semantics in [7]. COQL is indeed a natural extension of conjunctive queries to complex objects. Using techniques in <ref> [43] </ref> we can prove that COQL is a conservative extension of conjunctive queries, meaning that the queries it expresses over flat relations are precisely the conjunctive queries. Finally we argue that conjunctive queries for complex objects are a robust language, independent of a particular formalism.
Reference: [44] <author> X. Zhang and M. Z. Ozsoyoglu. </author> <title> On efficient reasoning with implication constraints. </title> <booktitle> In Proceedings of DOOD, </booktitle> <year> 1993. </year>
Reference-contexts: Previous work on query containment has considered queries in the relational algebra [11, 36, 3] and datalog [38, 37, 14]. Several works have considered the extension of containment algorithms for queries involving order <ref> [26, 42, 31, 44, 23] </ref>. Queries over bags were considered in [15], and modifications of containment algorithms to consider semantics of class hierarchies were considered in [10, 30]. However, containment and equivalence for query languages for complex objects have not been considered previously.
References-found: 44

