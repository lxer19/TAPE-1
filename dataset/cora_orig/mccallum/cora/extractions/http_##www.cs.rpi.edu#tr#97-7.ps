URL: http://www.cs.rpi.edu/tr/97-7.ps
Refering-URL: http://www.cs.rpi.edu/tr/
Root-URL: 
Email: E-mail: toddr@rpi.edu, glinert@cs.rpi.edu  
Title: Distributed Multi-Interface Computing with Polyglot  
Author: R. Lindsay Todd and Ephraim P. Glinert 
Keyword: multi-interface environments, distributed computing, mobile computing, ubiquitous access.  
Address: Troy, NY 12180  
Affiliation: Computer Science Department Rensselaer Polytechnic Institute  
Abstract: We introduce an architecture for multi-interface computing systems. Our architecture, based on distributed objects, allows networked presentersprograms providing user interfacesto be connected to or disconnected from running applications. Furthermore, several presenters may be simultaneously attached to the same application, and they need not support the same user interface style, so conforming applications can, without recoding, exploit new interface technologies, and third parties can introduce new user interfaces for applications. These capabilities are highly relevant to future systems, in which migratory programs (agents), mobile computing, and providing ubiquitous access for all users (including people with disabilities) are critical. We present a prototype implementation and example application (spreadsheet) to demonstrate the architecture's power, and discuss plans for future extensions. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <institution> Galaxy Application Environment: Technical Description. Visix Software, Inc., </institution> <address> Reston, VA, </address> <year> 1993. </year>
Reference-contexts: For example, platform- independent graphical user interface (PIGUI) toolkits provide a consistent procedure call interface to several different user interface toolkits. Some PIGUI toolkits, such as XVT [17], are layered over native GUI toolkits. Others, such as OpenInterface [11] and Galaxy <ref> [1] </ref>, emulate other toolkits using low-level graphics operations. These frequently have the additional advantage of allowing an application's user interface style to be changed dynamically. Yet others, such as SUIT [16], create their own unique user interface styles.
Reference: 2. <author> Fresco specification. </author> <type> Technical report, </type> <institution> X Consortium, </institution> <month> April 11, </month> <year> 1994. </year>
Reference-contexts: Other distributed object systems are Microsoft's DCOM [10] and Java's Remote Method Invocation (RMI) [19]. We observe that object-oriented user interface toolkits let applications manipulate user interface objects, typically called widgets. Editing UIMSs let user interfaces edit application objects. We can extend this observation to distributed objects. Fresco <ref> [2] </ref> is a CORBA-based toolkit whose widgets are distributed objects. Suite [4] is a distributed editing UIMS, running separate dialog managers for each application. The WWW approximates a distributed editing UIMS. Object Request Broker (CORBA) architecture. With the WWW, objects are presented as HTML documents.
Reference: 3. <author> Krishna Bharat and Marc H. Brown. </author> <title> Visual Oblique: A system for building distributed, multi-user applications by direct manipulation. </title> <type> Technical Report 130a, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> October 31, </month> <year> 1995. </year>
Reference-contexts: Furthermore, the presented style of an application depends upon the toolkit. With distributed display technologies such as the X Window System, this leads to the unaesthetic situation of applications sharing the display but using different interface styles. Visual Oblique <ref> [3] </ref> supports distributed applications, where applications may migrate and have multiple user interfaces. It uses the model of programs manipulating abstract user interface objects. These user interface objects are presented by the target system using native GUI toolkits (currently only Trestle [9]).
Reference: 4. <author> Prasun Dewan and Rajiv Choudhary. </author> <title> A high-level and flexible framework for implementing multiuser user in-terfaces. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 10(4) </volume> <pages> 345-380, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: We observe that object-oriented user interface toolkits let applications manipulate user interface objects, typically called widgets. Editing UIMSs let user interfaces edit application objects. We can extend this observation to distributed objects. Fresco [2] is a CORBA-based toolkit whose widgets are distributed objects. Suite <ref> [4] </ref> is a distributed editing UIMS, running separate dialog managers for each application. The WWW approximates a distributed editing UIMS. Object Request Broker (CORBA) architecture. With the WWW, objects are presented as HTML documents. A browser for a particular terminal renders documents appropriately for that terminal.
Reference: 5. <author> Prasun Dewan and Marvin Solomon. </author> <title> An approach to support automatic generation of user interfaces. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 566-609, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The data type declarations (maybe with additional formatting attributes) constitute the model. If a programming language supports introspection (i.e., it can analyze the type information of arbitrary objects at run time), then the model may not even be a separate entity. For example, Dost <ref> [5] </ref> compiles its programs, or classes, into the Mesa programming language. Peo- ple view instances of classes with a dialog manager, which creates user interfaces automatically from type information and attributes.
Reference: 6. <author> Martin R. Frank and James D. Foley. </author> <title> Model-based user interface design by example and by interview. </title> <booktitle> In Proc. of the ACM Symposium on User Interface Software and Technology, </booktitle> <pages> pages 129-137, </pages> <address> Atlanta, GA, </address> <month> November 35, </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: Model-based UIMSs [20], as depicted in Figure 1, rely upon descriptions of application semantics, plus additional information regarding the behavior and appearance of the user interface. This description and information constitute the so- called model, from which an interface generator constructs the user interface. Model-based systems include UIDE <ref> [6] </ref>, HUMANOID [21] and MASTERMIND [22]. Using information in the model, these systems offer sophisticated capabilities such as automatically generated help, design critics, and in <p>- for a model-based UIMS. 2 terface builders.
Reference: 7. <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: Peo- ple view instances of classes with a dialog manager, which creates user interfaces automatically from type information and attributes. Editing UIMSs are not necessarily model- based UIMSs; Smalltalk's Model-View-Controller paradigm [8] and Java's Model-View (MV) paradigm (using Observable and Observer objects) <ref> [7] </ref> are also editing UIMS designs. A distributed object system allows objects and users of those objects to be distributed over a network. Objects can belong to different processes, potentially running on different computers.
Reference: 8. <author> Glenn B. Krasner and Stephen T. Pope. </author> <title> A cookbook for using the model-view-controller user interface para-digm in Smalltalk-80. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(3) </volume> <pages> 26-49, </pages> <month> August-September </month> <year> 1988. </year>
Reference-contexts: For example, Dost [5] compiles its programs, or classes, into the Mesa programming language. Peo- ple view instances of classes with a dialog manager, which creates user interfaces automatically from type information and attributes. Editing UIMSs are not necessarily model- based UIMSs; Smalltalk's Model-View-Controller paradigm <ref> [8] </ref> and Java's Model-View (MV) paradigm (using Observable and Observer objects) [7] are also editing UIMS designs. A distributed object system allows objects and users of those objects to be distributed over a network. Objects can belong to different processes, potentially running on different computers.
Reference: 9. <author> Mark S. Manasse and Greg Nelson. </author> <title> Trestle reference manual. </title> <type> Technical Report 68, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Visual Oblique [3] supports distributed applications, where applications may migrate and have multiple user interfaces. It uses the model of programs manipulating abstract user interface objects. These user interface objects are presented by the target system using native GUI toolkits (currently only Trestle <ref> [9] </ref>). The API to these user interface objects constitutes a PIGUI. Our previous criticisms of PIGUIs still apply to Visual Oblique. Model-based UIMSs [20], as depicted in Figure 1, rely upon descriptions of application semantics, plus additional information regarding the behavior and appearance of the user interface.
Reference: 10. <author> Microsoft Corporation. </author> <title> The Component Object Model Specification, </title> <note> draft 0.9 edition, October 24, </note> <year> 1995. </year>
Reference-contexts: CORBA [12] is the Common Object Request Broker Architecture, a design for distributed object systems being promulgated by the Object Management Group. This architecture is schematically shown in Figure 2. Other distributed object systems are Microsoft's DCOM <ref> [10] </ref> and Java's Remote Method Invocation (RMI) [19]. We observe that object-oriented user interface toolkits let applications manipulate user interface objects, typically called widgets. Editing UIMSs let user interfaces edit application objects. We can extend this observation to distributed objects.
Reference: 11. <institution> Neuron Data, Palo Alto, CA. Open Interface Toolbox, </institution> <year> 1991. </year>
Reference-contexts: For example, platform- independent graphical user interface (PIGUI) toolkits provide a consistent procedure call interface to several different user interface toolkits. Some PIGUI toolkits, such as XVT [17], are layered over native GUI toolkits. Others, such as OpenInterface <ref> [11] </ref> and Galaxy [1], emulate other toolkits using low-level graphics operations. These frequently have the additional advantage of allowing an application's user interface style to be changed dynamically. Yet others, such as SUIT [16], create their own unique user interface styles.
Reference: 12. <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <address> 2.0 edi-tion, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: This use of RPC is generally hidden from the application programmer, who invokes methods on remote objects just as if they were local. CORBA <ref> [12] </ref> is the Common Object Request Broker Architecture, a design for distributed object systems being promulgated by the Object Management Group. This architecture is schematically shown in Figure 2. Other distributed object systems are Microsoft's DCOM [10] and Java's Remote Method Invocation (RMI) [19].
Reference: 13. <author> Dan R. Olsen, Jr. </author> <title> A browse / edit model for user in-terface management. </title> <booktitle> In Graphics Interface '88, </booktitle> <pages> pages 155-159, </pages> <year> 1988. </year>
Reference-contexts: Also, model-based systems have not supported varying numbers of interfaces. Some model-based UIMSs use editing to generate user interfaces from knowledge of data types of information in the application state <ref> [13, 14] </ref>. The data type declarations (maybe with additional formatting attributes) constitute the model. If a programming language supports introspection (i.e., it can analyze the type information of arbitrary objects at run time), then the model may not even be a separate entity.
Reference: 14. <author> Dan R. Olsen, Jr. </author> <title> A programming language basis for user interface management. </title> <booktitle> In Proceedings of CHI '89, </booktitle> <pages> pages 171-176, </pages> <address> Austin, TX, April 30-May4, </address> <year> 1989. </year>
Reference-contexts: Also, model-based systems have not supported varying numbers of interfaces. Some model-based UIMSs use editing to generate user interfaces from knowledge of data types of information in the application state <ref> [13, 14] </ref>. The data type declarations (maybe with additional formatting attributes) constitute the model. If a programming language supports introspection (i.e., it can analyze the type information of arbitrary objects at run time), then the model may not even be a separate entity.
Reference: 15. <author> John K. Ousterhout. </author> <title> An X11 toolkit based on the Tcl language. </title> <booktitle> In Proceedings of the Winter 1991 USENIX Conference, </booktitle> <pages> pages 105-115, </pages> <address> Berkeley, CA, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: Others, such as OpenInterface [11] and Galaxy [1], emulate other toolkits using low-level graphics operations. These frequently have the additional advantage of allowing an application's user interface style to be changed dynamically. Yet others, such as SUIT [16], create their own unique user interface styles. The Tk <ref> [15] </ref> toolkit has evolved from having its own style, to emulating the Motif style on several platforms, to supporting several native GUI toolkits. Some toolkits, such as GroupKit [18], facilitate writing applications that support multiple users. Since GroupKit is layered over Tk, it is potentially a PIGUI toolkit. <p> A module of parameterized type definitions. 6. An example application consisting of a rudimentary spreadsheet supporting labels and simple arithmetic over both constants and the values of other cells. 7. Two presenters (cf. Figure 6). One of the presenters uses a Python interface to the Tk toolkit <ref> [15] </ref> (the Tkinter module). For this presenter, we have both a presentation automatically generated from the parameterized type information and a presentation using a specialized spreadsheet editor.
Reference: 16. <author> Randy Pausch, Matthew Conway, and Robert DeLine. </author> <title> Lessons learned from SUIT, the simple user interface toolkit. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 10(4) </volume> <pages> 320-344, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Others, such as OpenInterface [11] and Galaxy [1], emulate other toolkits using low-level graphics operations. These frequently have the additional advantage of allowing an application's user interface style to be changed dynamically. Yet others, such as SUIT <ref> [16] </ref>, create their own unique user interface styles. The Tk [15] toolkit has evolved from having its own style, to emulating the Motif style on several platforms, to supporting several native GUI toolkits. Some toolkits, such as GroupKit [18], facilitate writing applications that support multiple users.
Reference: 17. <author> Marc J. Rochkind. XVT: </author> <title> a virtual toolkit for portability between window systems. </title> <booktitle> In Proc. of the Winter 1989 USENIX Conference, </booktitle> <pages> pages 151-163, </pages> <year> 1989. </year>
Reference-contexts: RELATED WORK Various UIMS designs have addressed some of the needs for multi-interface computing. For example, platform- independent graphical user interface (PIGUI) toolkits provide a consistent procedure call interface to several different user interface toolkits. Some PIGUI toolkits, such as XVT <ref> [17] </ref>, are layered over native GUI toolkits. Others, such as OpenInterface [11] and Galaxy [1], emulate other toolkits using low-level graphics operations. These frequently have the additional advantage of allowing an application's user interface style to be changed dynamically.
Reference: 18. <author> Mark Roseman and Saul Greenberg. </author> <title> Building real time groupware with GroupKit, a groupware toolkit. </title> <journal> ACM Transactions on CHI, </journal> <volume> 3(1) </volume> <pages> 66-106, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Yet others, such as SUIT [16], create their own unique user interface styles. The Tk [15] toolkit has evolved from having its own style, to emulating the Motif style on several platforms, to supporting several native GUI toolkits. Some toolkits, such as GroupKit <ref> [18] </ref>, facilitate writing applications that support multiple users. Since GroupKit is layered over Tk, it is potentially a PIGUI toolkit. However, these toolkits share a major problem common to all PIGUI toolkits: A PIGUI toolkit must encompass all the supported interaction techniques of each technology it supports.
Reference: 19. <author> Sun Microsystems, Inc., </author> <title> Mountain View, CA. Java Remote Method Invocation Specification, </title> <month> February 10, </month> <year> 1997. </year>
Reference-contexts: CORBA [12] is the Common Object Request Broker Architecture, a design for distributed object systems being promulgated by the Object Management Group. This architecture is schematically shown in Figure 2. Other distributed object systems are Microsoft's DCOM [10] and Java's Remote Method Invocation (RMI) <ref> [19] </ref>. We observe that object-oriented user interface toolkits let applications manipulate user interface objects, typically called widgets. Editing UIMSs let user interfaces edit application objects. We can extend this observation to distributed objects. Fresco [2] is a CORBA-based toolkit whose widgets are distributed objects.
Reference: 20. <author> Pedro Szekely. </author> <title> Retrospective and challenges for modelbased interface development. </title> <editor> In F. Bodert and J. Vanderdonckt, editors, </editor> <booktitle> Proc. of the 3rd Int. Eurographics Workshop on Design, Specification and Verification of Interactive Systems DSV-IS'96, Eurographic Series, </booktitle> <pages> pages 1-27. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> June 5-7, </month> <year> 1996. </year>
Reference-contexts: These user interface objects are presented by the target system using native GUI toolkits (currently only Trestle [9]). The API to these user interface objects constitutes a PIGUI. Our previous criticisms of PIGUIs still apply to Visual Oblique. Model-based UIMSs <ref> [20] </ref>, as depicted in Figure 1, rely upon descriptions of application semantics, plus additional information regarding the behavior and appearance of the user interface. This description and information constitute the so- called model, from which an interface generator constructs the user interface.
Reference: 21. <author> Pedro Szekely, Ping Luo, and Robert Neches. </author> <title> Beyond interface builders: Model-based interface tools. </title> <booktitle> In Proc. of INTERCHI'93, </booktitle> <pages> pages 383-390, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: This description and information constitute the so- called model, from which an interface generator constructs the user interface. Model-based systems include UIDE [6], HUMANOID <ref> [21] </ref> and MASTERMIND [22]. Using information in the model, these systems offer sophisticated capabilities such as automatically generated help, design critics, and in <p>- for a model-based UIMS. 2 terface builders.
Reference: 22. <author> Pedro Szekely, Piyawadee Sukaviriya, Pablo Castells, Jeyakumar Muthukumarasamy, and Ewald Salcher. </author> <title> Declarative interface models for user interface con-struction tools: the MASTERMIND approach. </title> <booktitle> In Proceedings of the 6th IFIP Working Conference on Engineering for Human Computer Interaction, Grand Targhee, </booktitle> <address> WY, </address> <year> 1995. </year>
Reference-contexts: This description and information constitute the so- called model, from which an interface generator constructs the user interface. Model-based systems include UIDE [6], HUMANOID [21] and MASTERMIND <ref> [22] </ref>. Using information in the model, these systems offer sophisticated capabilities such as automatically generated help, design critics, and in <p>- for a model-based UIMS. 2 terface builders. However, unless a model-based system con-structs its interface with a PIGUI toolkit, it will not provide a terminal-independent user interface.
Reference: 23. <author> Robert Lindsay Todd. </author> <title> Towards High-level Distributed Multi-interface Computing. </title> <type> PhD thesis, </type> <institution> Rensselaer Polytechnic Institute, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: In the following sections we will sketch the important features of the architecture. Complete and formal definition, along with relevant theorems and proofs, are in the first author's dissertation <ref> [23] </ref>. The Object Request Broker Borrowing CORBA's terminology, the critical element of POLYGLOT is called the Object Request Broker (ORB), as shown in the schematic representation of Figure 3. <p> That is, if T 0 T , then T might have had T 0 as a base interface. In reality, the projection relationship is richer, applicable to types other than interfaces. For more details, see the first author's dissertation <ref> [23] </ref>. Generating a Presentation Presenters can extract information about the expression used to define a type, including inheritance and parameterization. This information is used to automate the presentation process. Consider the family of types for a simple spreadsheet shown in Figure 5. (Several of these types, i.e.
Reference: 24. <author> Guido van Rossum. </author> <title> Python Reference Manual. </title> <publisher> Centrum voor Wiskunde en Informatica, </publisher> <address> Amsterdam, The Netherlands, 1.3 edition, </address> <month> October 13, </month> <year> 1995. </year> <month> 8 </month>
Reference-contexts: PROTOTYPE IMPLEMENTATION To demonstrate the POLYGLOT architecture, we prototyped several key system components and an example application using the object oriented Python language <ref> [24] </ref>.
References-found: 24

