URL: http://www.ri.cmu.edu/afs/cs/user/rwh/public/www/papers/xml/toplas93.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/rwh/public/www/papers.html
Root-URL: 
Title: On The Type Structure of Standard ML  
Author: Robert Harper John C. Mitchell Wallace F. and Lucille M. Davis 
Note: Suported in part by the Science and Engineering Research Council of the United Kingdom, and in part by the Defense Advanced Research Projects Agency, monitored by the Office of Naval Research under contract N00014-84-K-0415, ARPA Order No. 5404. Supported in part by an NSF PYI Award, matching funds from Digital Equipment Corporation, the Powell Foundation, and Xerox Corporation; NSF grant CCR-8814921 and the  Faculty Scholarship.  
Date: January 10, 1992  
Address: Pittsburgh, PA 15213  Stanford, CA 94305  
Affiliation: Carnegie Mellon University  Stanford University  
Abstract: Standard ML is a useful programming language with a polymorphic type system and a flexible module facility. One notable feature of the core expression language of ML is that it is implicitly typed: no explicit type information need be supplied by the programmer. In contrast, the module language of ML is explicitly typed; in particular, the types of parameters in parametric modules must be supplied by the programmer. We study the type structure of Standard ML by giving an explicitly-typed, polymorphic function calculus that captures many of the essential aspects of both the core and module language. In this setting, implicitly-typed core language expressions are regarded as a convenient short-hand for an explicitly-typed counterpart in our function calculus. In contrast to the Girard-Reynolds polymorphic calculus, our function calculus is predicative: the type system may be built up by induction on type levels. We show that, in a precise sense, the language becomes inconsistent if restrictions imposed by type levels are relaxed. More specifically, we prove that the important programming features of ML cannot be added to any impredicative language, such as the Girard-Reynolds calculus, without implicitly assuming a type of all types. fl A preliminary version of this paper appeared in Proc. 15th ACM Symp. on Principles of Programming Languages, 1988, under the title "The Essence of ML." 
Abstract-found: 1
Intro-found: 1
Reference: [ABL86] <author> R. Amadio, K. Bruce, and G. Longo. </author> <title> The finitary projection model for second order lambda calculus and solutions to higher order domain equations. </title> <booktitle> In Proc. IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 122-130, </pages> <year> 1986. </year>
Reference-contexts: Consequently, Core-XML may be interpreted in the domain-theoretic and recursion-theoretic models discussed in <ref> [ABL86, BMM90, Gir72, Tro73, McC79, Mit86b] </ref>. One difference between the languages, however, is that Core-XML has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84].
Reference: [Bar84] <author> H.P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year> <note> Second edition. </note>
Reference-contexts: An example illustrating the failure of coherence for terms that have free polymorphic variables is given in [Oho89]. However, it is not hard to show that coherence holds for all closed terms in all models, using the strong normalization property of reduction (see <ref> [Bar84, Mit90] </ref>). A caveat in future work on ML is that when we include features such as recursion, references and exceptions, it is important to consider the order of evaluation. <p> If we direct the equational axioms from left to right, we obtain a reduction system of the form familiar from other systems of lambda calculus (e.g., <ref> [Bar84, Mit90] </ref>). Strong normalization is the property that there are no infinite reduction sequences from XML terms. In other word, the simple symbolic interpreter defined by the reduction rules is guaranteed to halt, on any term. <p> It is well known that recursion is definable in the untyped lambda calculus, via the fixed-point operator Y , and that the untyped lambda calculus may be interpreted in a typed lambda calculus satisfying an equation t = t!t between types. (Further discussion of Y may be found in <ref> [Bar84] </ref>, for example, and the relationship between untyped lambda calculus and type (or domain) equations in [Bar84, Sco80].) Given this, and the fact that equality types allow us to type terms with respect to equational hypotheses, it is easy to show that equality types give us terms without normal form. <p> fixed-point operator Y , and that the untyped lambda calculus may be interpreted in a typed lambda calculus satisfying an equation t = t!t between types. (Further discussion of Y may be found in [Bar84], for example, and the relationship between untyped lambda calculus and type (or domain) equations in <ref> [Bar84, Sco80] </ref>.) Given this, and the fact that equality types allow us to type terms with respect to equational hypotheses, it is easy to show that equality types give us terms without normal form.
Reference: [BM84] <author> K. Bruce and A. Meyer. </author> <title> A completeness theorem for second-order polymorphic lambda calculus. </title> <booktitle> In Proc. Int. Symp. on Semantics of Data Types, Sophia-Antipolis (France), </booktitle> <pages> pages 131-144, </pages> <address> Berlin, 1984. </address> <publisher> Springer LNCS 173. </publisher>
Reference-contexts: Type Structure of Standard ML 11 5 Semantics of Core-XML 5.1 Introduction The Core-XML language has a straightforward Henkin-style model theory that is similar to the semantics of second-order lambda calculus described in <ref> [BM84, BMM90, Mit88] </ref>, except that we have two universes instead of one collection of types. Categorical semantics may also be developed, along the lines of [Mog91, HMM90], which resemble the indexed-categorical frameworks of [See84, See87]. However, we will not discuss categorical semantics in this paper.
Reference: [BMM90] <author> K. B. Bruce, A. R. Meyer, and J. C. Mitchell. </author> <title> The semantics of second-order lambda calculus. </title> <journal> Information and Computation, </journal> <volume> 85(1) </volume> <pages> 76-134, </pages> <year> 1990. </year> <title> Reprinted in Logical Foundations of Functional Programming, </title> <editor> ed. G. Huet, </editor> <publisher> Addison-Wesley (1990) 213-273. </publisher>
Reference-contexts: A pre-term M is a term of Core-XML if ` X . M : for some and . The difference between Core-XML and the Girard-Reynolds polymorphic -calculus <ref> [BMM90, Rey74, Gir72] </ref> lies in the distinction between universes U 1 and U 2 . Rule tapp of Core-XML only allows a type application . M [t ] : [t =t] when t is a type of the first universe U 1 . <p> Type Structure of Standard ML 11 5 Semantics of Core-XML 5.1 Introduction The Core-XML language has a straightforward Henkin-style model theory that is similar to the semantics of second-order lambda calculus described in <ref> [BM84, BMM90, Mit88] </ref>, except that we have two universes instead of one collection of types. Categorical semantics may also be developed, along the lines of [Mog91, HMM90], which resemble the indexed-categorical frameworks of [See84, See87]. However, we will not discuss categorical semantics in this paper. <p> The following model definition is in the same spirit as <ref> [BMM90] </ref>. <p> The meaning [[]] of any type expression in environment is straightforward, as in <ref> [BMM90] </ref>. If is a context, then satisfies , written j= , if (x) 2 Dom [[]] for every x: 2 . The meaning of a term ` X . <p> M : ]] exists, as defined above, for every well-typed term . M : and every j= . For further discussion of this style of environment model definition, see <ref> [BMM90] </ref>. 5.3 Equational Soundness and Completeness Equations have the form . M = N : , where M and N are terms of type (in the context ). <p> M = N : , where M and N are terms of type (in the context ). The equational proof system of Core-XML is similar to that of the Girard-Reynolds calculus <ref> [Gir71, Rey74, BMM90] </ref>, with the following additional axiom for let: . (let x: = M in N ) = [N=x]M : t A complete presentation of the equational system for Core-XML is omitted here since it is an obvious fragment of the equation calculus for XML (which is presented below.) It <p> The type associated with any constant must be a closed type expression (without free variables), so that the semantic type of the constant symbol is independent of the environment. Type Structure of Standard ML 13 In addition, the methods of <ref> [BMM90] </ref> may be used to show that the equational proof system is sound and complete for models that do not have empty types. <p> Consequently, Core-XML may be interpreted in the domain-theoretic and recursion-theoretic models discussed in <ref> [ABL86, BMM90, Gir72, Tro73, McC79, Mit86b] </ref>. One difference between the languages, however, is that Core-XML has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. <p> and U 2 by a single universe in the definition of Core-XML, then we obtain the second-order lambda calculus of Girard and Reynolds [Gir71, Gir72, Rey74]. (A similar technique is used to introduce impredicativity into Nuprl in [How87].) The Girard-Reynolds calculus has a number of reasonable theoretical properties (see, e.g., <ref> [BMM90, Mit86b, MP88] </ref>) and seems to be a useful tool for studying polymorphism in programming languages. However, if we make the full XML calculus impredicative by eliminating the distinction between U 1 and U 2 , the language becomes very different from the Girard-Reynolds calculus.
Reference: [BTCGS91] <author> V. Breazu-Tannen, T. Coquand, C.A. Gunter, and A. Scedrov. </author> <title> Inheritance as explicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 172-221, </pages> <year> 1991. </year>
Reference-contexts: In other words, do we get different semantic interpretations depending on the way we assign types to subexpressions? A well-taken criticism of our approach, on these grounds, appears in [Oho89]. Another paper which discusses the general issue of coherence is <ref> [BTCGS91] </ref>. To avoid confusion, we will make a few definitions. We say a function R from Core-ML to Core-XML is a type reconstruction function if, for every ` DM . e : t , we have R ( . e : t ) = .
Reference: [C + 86] <editor> R.L. Constable et al. </editor> <title> Implementing Mathematics with the Nuprl Proof Development System, volume 37 of Graduate Texts in Mathematics. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: For example, the Girard-Reynolds second-order -calculus seems useful for analyzing languages with polymorphic functions or abstract data type declarations [Gir72, Rey74, MP88]. The richer type systems proposed by Martin-Lof [Mar82], Constable <ref> [C + 86] </ref>, and Huet and Coquand [CH88] also provide formal logics for reasoning about programs. This general line of research has a different flavor from the original Scott-Strachey approach to programming language semantics, since the meta-language of type theory reflects the type structure of the object languages studied. <p> It is worth remarking that Martin-Lof's later type theory [Mar82, Mar84], and the NuPRL type theory <ref> [C + 86] </ref>, are type assignment systems, and hence are more closely related to the type system defined by Damas and Milner for the study of ML.
Reference: [Car85] <author> R. Cartwright. </author> <title> Types as intervals. </title> <booktitle> In Proc. 12th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 22-36, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: The predicative universes also distinguish our calculus from both the implicit polymorphic typing of <ref> [Mit88, MPS86, Car85] </ref> and the explicitly-typed polymorphic calculus of [Gir71, Gir72, Rey74]. In particular, the pure ML calculus without recursion has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. <p> In particular, the pure ML calculus without recursion has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. Some studies of ML typing (e.g., <ref> [Car85, Mit88, MPS86] </ref>) have suggested, in effect, that the restrictions imposed by universes might be relaxed to allow the full second-order polymorphism of the Girard-Reynolds calculus [Gir71, Gir72, Rey74]. However, these studies were generally based on consideration of the ML core language alone, and did not take modules into account. <p> The type inference algorithm is then treated as a decision procedure for the inference system. Milner's semantic analysis is elaborated in <ref> [MPS86, Car85] </ref>, where the meanings of polymorphic types are clarified and recursive types are given semantics (see also [Mit88]). In Milner's model, the sets denoted by type expressions do not include a special error value of the domain, called wrong.
Reference: [Car88a] <author> L. Cardelli. </author> <title> A semantics of multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 138-164, </pages> <year> 1988. </year> <title> Special issue devoted to Symp. on Semantics of Data Types, </title> <booktitle> Sophia-Antipolis (France), </booktitle> <year> 1984. </year>
Reference-contexts: It follows from previous work on type : type, specifically, [Coq86, Gir72, How87, MR86], that there exist recursion-free programs that cannot be evaluated to a normal form by any evaluation strategy. As argued in [MR86], this alters the character of the language dramatically. In addition, Cardelli <ref> [Car88a] </ref> argues that taking type : type has significant practical disadvantages because it eliminates the distinction between "compile time" and "run time" values. In particular, it is no longer possible to determine, without evaluating arbitrary expressions, whether a given expression denotes a type. <p> We refer the reader to <ref> [Coq86, How87, MR86, Car88a] </ref> for background information and further discussion of the merits of type:type. As discussed in the introduction, it seems fair to say that type:type would certainly change the character of ML dramatically.
Reference: [Car88b] <author> L. Cardelli. </author> <title> Structural subtyping and the notion of powertype. </title> <booktitle> In Proc 15th ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 70-79, </pages> <year> 1988. </year>
Reference-contexts: We also use and t to range over pre-terms, particularly when the term is intended to be a type. Following Cardelli <ref> [Car88b] </ref>, we use an explicitly "dependent" form of ordered pair, hx:=M; N : 0 i, in which the variable x is bound in N and 0 .
Reference: [CH88] <author> T. Coquand and G. Huet. </author> <title> The calculus of constructions. </title> <journal> Information and Computation, </journal> 76(2/3):95-120, 1988. 
Reference-contexts: For example, the Girard-Reynolds second-order -calculus seems useful for analyzing languages with polymorphic functions or abstract data type declarations [Gir72, Rey74, MP88]. The richer type systems proposed by Martin-Lof [Mar82], Constable [C + 86], and Huet and Coquand <ref> [CH88] </ref> also provide formal logics for reasoning about programs. This general line of research has a different flavor from the original Scott-Strachey approach to programming language semantics, since the meta-language of type theory reflects the type structure of the object languages studied. <p> One consequence of the universe distinction is that Core-XML has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. The language Core-XML is closely related to several explicitly-typed function calculi, in particular Martin-Lof's intensional type theory [Mar73], the AUTOMATH languages [DB80], the Calculus of Constructions <ref> [CH88] </ref>, and the type theory of LF [HHP87]. Since Core-XML is based on a pred-icative notion of universe, it is most closely related to Martin-Lof's early type theories, except that we do not, at this stage, take U 1 : U 2 .
Reference: [Coq86] <author> T. Coquand. </author> <title> An analysis of Girard's paradox. </title> <booktitle> In Proc. IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 227-236, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: However, we will show that if the distinction between universes is removed, it becomes possible to define a type of all types. It follows from previous work on type : type, specifically, <ref> [Coq86, Gir72, How87, MR86] </ref>, that there exist recursion-free programs that cannot be evaluated to a normal form by any evaluation strategy. As argued in [MR86], this alters the character of the language dramatically. <p> We refer the reader to <ref> [Coq86, How87, MR86, Car88a] </ref> for background information and further discussion of the merits of type:type. As discussed in the introduction, it seems fair to say that type:type would certainly change the character of ML dramatically. <p> However, by Theorem 8.4, we know that if we combine strong sums with impredicative polymorphism by taking U 1 = U 2 , the most natural way of achieving this end, then we must admit a type of all types. By Girard's paradox <ref> [Coq86, MR86, How87] </ref>, type:type (in the presence of other constructs) implies that strong normalization fails. In short, assuming we wish to avoid type:type and non-normalizing recursion-free terms, we have a trade-off between impredicative polymorphism and strong sums. <p> Hook and Howe then replied that they had discovered a similar phenomenon independently [HH86]. We also learned that Coquand had proved the same theorem by a different means in <ref> [Coq86] </ref>, which was in preparation at the time of our announcement. 4 Girard's original proof included existential types. While the somewhat simpler proof in [Mit86b] does not, normalization with existential types can easily be derived by encoding 9t: as 8r [8t (!r)!r]. <p> However, we would still have strong sums like t:U 1 :t in U 2 instead of U 1 . The normalization theorem for this calculus follows from that of the theory of constructions with strong sums at the level of types <ref> [Coq86] </ref> by considering U 1 to be prop, and U 2 to be type 0 . Type Structure of Standard ML 27 9 Extensions 9.1 Introduction ML contains a variety of language features beyond those we have considered so far.
Reference: [CW85] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, </title> <journal> and polymor-phism. Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: 1 !U 1 =t; M :i : 9t:U n (t 62 Dom ()) 1 !U 1 : ; t:U n . abstype t:U n 1 !U 1 with x: is M in N : (t 62 F V ()) For further discussion of existential types, the reader is referred to <ref> [MP88, CW85, Mac85] </ref>.
Reference: [DB80] <author> N.G. De Bruijn. </author> <title> A survey of the project Automath. In To H.B. </title> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-607. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: One consequence of the universe distinction is that Core-XML has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. The language Core-XML is closely related to several explicitly-typed function calculi, in particular Martin-Lof's intensional type theory [Mar73], the AUTOMATH languages <ref> [DB80] </ref>, the Calculus of Constructions [CH88], and the type theory of LF [HHP87]. Since Core-XML is based on a pred-icative notion of universe, it is most closely related to Martin-Lof's early type theories, except that we do not, at this stage, take U 1 : U 2 . <p> This also makes the well-formed contexts difficult to define. Therefore, we will define XML by giving a set of inference rules for determining the well-formed contexts, types and terms, in the style of Automath <ref> [DB80] </ref>, Martin-Lof [Mar82], and LF [HHP87].
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proc. 9th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <year> 1982. </year>
Reference-contexts: in such a way that every value occurs with higher rank than any values on which its existence or behavior is predicated. (For example, functions always occur at a higher rank than their arguments.) The universe distinctions are faithful to the separation of monotypes from polytypes in Milner's earlier work <ref> [Mil78, DM82] </ref>, and allow us to show that implicit ML typing is syntactically equivalent to our explicit typing rules. The predicative universes also distinguish our calculus from both the implicit polymorphic typing of [Mit88, MPS86, Car85] and the explicitly-typed polymorphic calculus of [Gir71, Gir72, Rey74]. <p> Concluding remarks appear in Section 10. All type systems are defined formally in tables at the end of the paper. Type Structure of Standard ML 5 2 Implicitly typed ML Many studies of ML have focused on the type inference algorithm for the core expression language <ref> [Mil78, DM82, MPS86, Wan84] </ref>. This algorithm allows the ML programmer to write, for example, let id (x) = x in . . . automatically inferring the fact that the function id is a function from type t to t, for any t. <p> One consequence of this view is that a given term can be assigned a variety of types; the type inference algorithm allows the programmer to enjoy the flexibility afforded by this semantics. The syntactic part of Milner's analysis is refined in <ref> [DM82] </ref>, where an inference system for assigning types to expressions is given. The type inference rules are proved sound by showing that if it is possible to infer that expression e has type , then the untyped meaning of e belongs to the set denoted by . <p> Consequently, the soundness of ML typing is often summarized by the slogan well-typed expressions cannot go wrong [Mil78]. Although there are quite a few constructs in the core expression language of ML, the behavior of the type checker may be understood by considering the fragment presented in <ref> [DM82] </ref>, which we will call Core-ML. The syntax of Core-ML is given by e :: = x j ee j x:e j let x = e in e; where x may be any identifier. <p> Syntactically, this means that there is an ff variant 8s 1 . . . s k :t 0 of 0 such that no s i (1 i k) occurs free in and v t 0 ; see <ref> [DM82, Mit88] </ref> for further discussion, and [Mit88] for an interpretation of generic instantiation as semantic containment. When v 0 , we say is more general than 0 . <p> It is shown in [KMM91, KTU90] that any algorithm which decides whether an untyped Core-ML term has a type necessarily requires exponential time for infinitely many terms. It follows that computing the principal type of a Core-ML term requires exponential time. 1 This formulation of principal typing differs from <ref> [DM82] </ref> in that the latter defines the principal typing with respect to a given context. Further discussion of this point may be found in [Lei83]. <p> Take M let x: = N in P , and observe that M ffi let x = N ffi in P ffi let x = e in e 0 , and ` X . M : t 0 . Theorem 2.2 (from <ref> [DM82] </ref>) states that there is an algorithm which finds, for any typable expression e, a principal typing for e. It is a simple matter to modify this algorithm so that it produces as well a derivation of the principal typing in the Damas-Milner system.
Reference: [Gir71] <author> J.-Y. Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <editor> In J.E. Fenstad, editor, </editor> <booktitle> 2nd Scandinavian Logic Symposium, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1971. </year> <title> Type Structure of Standard ML 36 </title>
Reference-contexts: The predicative universes also distinguish our calculus from both the implicit polymorphic typing of [Mit88, MPS86, Car85] and the explicitly-typed polymorphic calculus of <ref> [Gir71, Gir72, Rey74] </ref>. In particular, the pure ML calculus without recursion has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. <p> Some studies of ML typing (e.g., [Car85, Mit88, MPS86]) have suggested, in effect, that the restrictions imposed by universes might be relaxed to allow the full second-order polymorphism of the Girard-Reynolds calculus <ref> [Gir71, Gir72, Rey74] </ref>. However, these studies were generally based on consideration of the ML core language alone, and did not take modules into account. <p> M = N : , where M and N are terms of type (in the context ). The equational proof system of Core-XML is similar to that of the Girard-Reynolds calculus <ref> [Gir71, Rey74, BMM90] </ref>, with the following additional axiom for let: . (let x: = M in N ) = [N=x]M : t A complete presentation of the equational system for Core-XML is omitted here since it is an obvious fragment of the equation calculus for XML (which is presented below.) It <p> One way to eliminate this restriction is to eliminate the distinction between U 1 and U 2 . If we replace U 1 and U 2 by a single universe in the definition of Core-XML, then we obtain the second-order lambda calculus of Girard and Reynolds <ref> [Gir71, Gir72, Rey74] </ref>. (A similar technique is used to introduce impredicativity into Nuprl in [How87].) The Girard-Reynolds calculus has a number of reasonable theoretical properties (see, e.g., [BMM90, Mit86b, MP88]) and seems to be a useful tool for studying polymorphism in programming languages.
Reference: [Gir72] <author> J.-Y. Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <institution> These D'Etat, Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: One motivation for studying these elemental languages is that they provide some insight into programming languages with similar typing features. For example, the Girard-Reynolds second-order -calculus seems useful for analyzing languages with polymorphic functions or abstract data type declarations <ref> [Gir72, Rey74, MP88] </ref>. The richer type systems proposed by Martin-Lof [Mar82], Constable [C + 86], and Huet and Coquand [CH88] also provide formal logics for reasoning about programs. <p> The predicative universes also distinguish our calculus from both the implicit polymorphic typing of [Mit88, MPS86, Car85] and the explicitly-typed polymorphic calculus of <ref> [Gir71, Gir72, Rey74] </ref>. In particular, the pure ML calculus without recursion has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. <p> Some studies of ML typing (e.g., [Car85, Mit88, MPS86]) have suggested, in effect, that the restrictions imposed by universes might be relaxed to allow the full second-order polymorphism of the Girard-Reynolds calculus <ref> [Gir71, Gir72, Rey74] </ref>. However, these studies were generally based on consideration of the ML core language alone, and did not take modules into account. <p> However, we will show that if the distinction between universes is removed, it becomes possible to define a type of all types. It follows from previous work on type : type, specifically, <ref> [Coq86, Gir72, How87, MR86] </ref>, that there exist recursion-free programs that cannot be evaluated to a normal form by any evaluation strategy. As argued in [MR86], this alters the character of the language dramatically. <p> A pre-term M is a term of Core-XML if ` X . M : for some and . The difference between Core-XML and the Girard-Reynolds polymorphic -calculus <ref> [BMM90, Rey74, Gir72] </ref> lies in the distinction between universes U 1 and U 2 . Rule tapp of Core-XML only allows a type application . M [t ] : [t =t] when t is a type of the first universe U 1 . <p> Consequently, Core-XML may be interpreted in the domain-theoretic and recursion-theoretic models discussed in <ref> [ABL86, BMM90, Gir72, Tro73, McC79, Mit86b] </ref>. One difference between the languages, however, is that Core-XML has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. <p> One way to eliminate this restriction is to eliminate the distinction between U 1 and U 2 . If we replace U 1 and U 2 by a single universe in the definition of Core-XML, then we obtain the second-order lambda calculus of Girard and Reynolds <ref> [Gir71, Gir72, Rey74] </ref>. (A similar technique is used to introduce impredicativity into Nuprl in [How87].) The Girard-Reynolds calculus has a number of reasonable theoretical properties (see, e.g., [BMM90, Mit86b, MP88]) and seems to be a useful tool for studying polymorphism in programming languages. <p> Either impredicative polymorphism with the "weaker" existential types, or restricted predica-tive polymorphism with "stronger" sum types seems reasonable. By the normalization theorem for the impredicative Girard-Reynolds calculus <ref> [Gir72, Mit86b] </ref> 4 , we know that impredicative poly-morphism with existential types is strongly normalizing. As noted in Section 7, a translation into Martin-Lof's 1973 system [Mar73] shows that XML with predicative polymorphism and "strong" sums is also strongly normalizing.
Reference: [GMW79] <author> M.J. Gordon, R. Milner, </author> <title> and C.P. </title> <publisher> Wadsworth. Edinburgh LCF. Springer LNCS 78, </publisher> <address> Berlin, </address> <year> 1979. </year>
Reference-contexts: In a sequel to this paper, we use the categorical techniques developed in [Mog91] to refine the calculus presented here in a manner that clearly identifies the compile-time/run-time distinction in Standard ML [HMM90]. Standard ML is an updated version of the programming "meta-language" of the LCF system <ref> [GMW79] </ref>, comprising a core expression language with polymorphic functions [Mil85] and a module language for defining interdependent program units [Mac85]. The core language is designed around an automatic type inference algorithm that performs compile-time checking of "un-typed" expressions.
Reference: [HH86] <author> J. Hook and D. Howe. </author> <title> Impredicative strong existential equivalent to type:type. </title> <type> Technical Report TR 86-760, </type> <institution> Cornell University, </institution> <year> 1986. </year>
Reference-contexts: The most reasonable is this: 3 We described our "trade-off theorem" in the types electronic mail forum in the spring of 1986. Hook and Howe then replied that they had discovered a similar phenomenon independently <ref> [HH86] </ref>. We also learned that Coquand had proved the same theorem by a different means in [Coq86], which was in preparation at the time of our announcement. 4 Girard's original proof included existential types.
Reference: [HHP87] <author> R. Harper, F. Honsell, and G. Plotkin. </author> <title> A framework for defining logics. </title> <booktitle> In Proc. IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 194-204, </pages> <month> June </month> <year> 1987. </year> <note> To appear in J. Assoc. </note> <institution> Comput. Machinery. </institution>
Reference-contexts: The language Core-XML is closely related to several explicitly-typed function calculi, in particular Martin-Lof's intensional type theory [Mar73], the AUTOMATH languages [DB80], the Calculus of Constructions [CH88], and the type theory of LF <ref> [HHP87] </ref>. Since Core-XML is based on a pred-icative notion of universe, it is most closely related to Martin-Lof's early type theories, except that we do not, at this stage, take U 1 : U 2 . <p> This also makes the well-formed contexts difficult to define. Therefore, we will define XML by giving a set of inference rules for determining the well-formed contexts, types and terms, in the style of Automath [DB80], Martin-Lof [Mar82], and LF <ref> [HHP87] </ref>.
Reference: [HMM86] <author> R. Harper, D.B. MacQueen, and R. Milner. </author> <title> Standard ML. </title> <type> Technical Report ECS-LFCS-86-2, </type> <institution> Lab. for Foundations of Computer Science, University of Edinburgh, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: Using the framework of type theory, we propose an analogous case study of the programming language Standard ML <ref> [HMM86, MTH90] </ref>, only the first steps of which are completed here. In this paper, we will describe a typed -calculus that encompasses many of the essential features of Standard ML and use this to analyze some potential extensions of the language. <p> An abstract type declaration introduces a "private" concrete data type, together with a set of "public" operations on that type. We give a brief description of each form below. For more information, see <ref> [HMM86, MTH90] </ref>. In the remainder of this section, we show how the three forms of type declarations just mentioned may be treated in XML.
Reference: [HMM90] <author> R. Harper, J.C. Mitchell, and E. Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Proc. 17th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 341-354, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: In a sequel to this paper, we use the categorical techniques developed in [Mog91] to refine the calculus presented here in a manner that clearly identifies the compile-time/run-time distinction in Standard ML <ref> [HMM90] </ref>. Standard ML is an updated version of the programming "meta-language" of the LCF system [GMW79], comprising a core expression language with polymorphic functions [Mil85] and a module language for defining interdependent program units [Mac85]. <p> Categorical semantics may also be developed, along the lines of <ref> [Mog91, HMM90] </ref>, which resemble the indexed-categorical frameworks of [See84, See87]. However, we will not discuss categorical semantics in this paper. We will summarize some basic ideas regarding Henkin-style models primarily to emphasize that there is a semantic connection between Core-ML and Core-XML, as well as a syntactic one. <p> Explicit typing is central to giving a single account of both the core expression language and the module system, and seems useful for further study. In particular, in papers <ref> [Mog91, HMM90] </ref>, which were written after the work described here was completed, XML is used to study the separation between compile-time and run-time in Standard ML.
Reference: [HMT87] <author> R. Harper, R. Milner, and M. Tofte. </author> <title> A type discipline for program modules. </title> <booktitle> In TAPSOFT '87, </booktitle> <address> Berlin, 1987. </address> <publisher> Springer LNCS 250. </publisher>
Reference-contexts: In this sense we regard signature matching as a convenience similar to that afforded by the type inference algorithm for the core language. For further discussion of signature matching, we refer the reader to <ref> [HMT87, Tof88, MTH90] </ref>. Discussion of ML "sharing" specifications is deferred to Section 9.3 below.
Reference: [How80] <author> W. Howard. </author> <title> The formulas-as-types notion of construction. In To H.B. </title> <booktitle> Curry: Essays on Combinatory Logic, Lambda-Calculus and Formalism, </booktitle> <pages> pages 479-490. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: Following [Mac86], we will use general sums and products in the style of Martin-Lof's type theory [Mar82] to model the modules system. While general sums (also called "strong sums;" see <ref> [How80] </ref>) are closely related to structures, and general cartesian products seem necessary to capture dependently-typed functors, the language XML will be somewhat more general than ML.
Reference: [How87] <author> D.J. Howe. </author> <title> The computational behavior of Girard's paradox. </title> <booktitle> In Proc. IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 205-214, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: However, we will show that if the distinction between universes is removed, it becomes possible to define a type of all types. It follows from previous work on type : type, specifically, <ref> [Coq86, Gir72, How87, MR86] </ref>, that there exist recursion-free programs that cannot be evaluated to a normal form by any evaluation strategy. As argued in [MR86], this alters the character of the language dramatically. <p> We refer the reader to <ref> [Coq86, How87, MR86, Car88a] </ref> for background information and further discussion of the merits of type:type. As discussed in the introduction, it seems fair to say that type:type would certainly change the character of ML dramatically. <p> If we replace U 1 and U 2 by a single universe in the definition of Core-XML, then we obtain the second-order lambda calculus of Girard and Reynolds [Gir71, Gir72, Rey74]. (A similar technique is used to introduce impredicativity into Nuprl in <ref> [How87] </ref>.) The Girard-Reynolds calculus has a number of reasonable theoretical properties (see, e.g., [BMM90, Mit86b, MP88]) and seems to be a useful tool for studying polymorphism in programming languages. <p> However, by Theorem 8.4, we know that if we combine strong sums with impredicative polymorphism by taking U 1 = U 2 , the most natural way of achieving this end, then we must admit a type of all types. By Girard's paradox <ref> [Coq86, MR86, How87] </ref>, type:type (in the presence of other constructs) implies that strong normalization fails. In short, assuming we wish to avoid type:type and non-normalizing recursion-free terms, we have a trade-off between impredicative polymorphism and strong sums.
Reference: [KMM91] <author> P.C. Kanellakis, H.G. Mairson, and J.C. Mitchell. </author> <title> Unification and ML type reconstruction. </title> <booktitle> In Computational Logic, Essays in Honor of Alan Robinson, </booktitle> <pages> pages 444-478. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Furthermore, there is an algorithm which, given e, computes the principle typing if it exists, and fails otherwise. It is shown in <ref> [KMM91, KTU90] </ref> that any algorithm which decides whether an untyped Core-ML term has a type necessarily requires exponential time for infinitely many terms.
Reference: [KTU90] <author> A.J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> ML typability is Dexptime-complete. </title> <booktitle> In Proc. 15th Colloq. on Trees in Algebra and Programming, </booktitle> <pages> pages 206-220. </pages> <publisher> Springer LNCS 431, </publisher> <year> 1990. </year> <note> To appear in J. Assoc. Comput. Machinery under title, "An Analysis of ML Typability". </note>
Reference-contexts: Furthermore, there is an algorithm which, given e, computes the principle typing if it exists, and fails otherwise. It is shown in <ref> [KMM91, KTU90] </ref> that any algorithm which decides whether an untyped Core-ML term has a type necessarily requires exponential time for infinitely many terms.
Reference: [Lei83] <author> D. Leivant. </author> <title> Polymorphic type inference. </title> <booktitle> In Proc. 10th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 88-98, </pages> <year> 1983. </year>
Reference-contexts: It follows that computing the principal type of a Core-ML term requires exponential time. 1 This formulation of principal typing differs from [DM82] in that the latter defines the principal typing with respect to a given context. Further discussion of this point may be found in <ref> [Lei83] </ref>. Type Structure of Standard ML 7 3 Explicitly Typed ML In contrast to the Milner-style analyses of ML, we will view ML programs as being explicitly typed in the sense that a given term has at most one type in any given context (modulo type equality). <p> A related correspondence between implicit ML typing and Girard-Reynolds typing restricted by "rank," which is similar to our universe restriction, was suggested earlier in <ref> [Lei83, Section 7] </ref>. However, the statement of Theorem 7.1 in that paper is incorrect, since rank 2 typing of lambda terms allows us to type -abstractions polymorphically, whereas the typing rules of Core-ML do not.
Reference: [Mac85] <author> D.B. MacQueen. </author> <title> Modules for Standard ML. </title> <journal> Polymorphism, </journal> <volume> 2(2), </volume> <year> 1985. </year> <pages> 35 pages. </pages> <note> An earlier version appeared in Proc. 1984 ACM Symp. on Lisp and Functional Programming. </note>
Reference-contexts: Standard ML is an updated version of the programming "meta-language" of the LCF system [GMW79], comprising a core expression language with polymorphic functions [Mil85] and a module language for defining interdependent program units <ref> [Mac85] </ref>. The core language is designed around an automatic type inference algorithm that performs compile-time checking of "un-typed" expressions. The module language is designed to support the organization of programs into separately-compilable units, and involves a moderate amount of explicit type information. <p> Type Structure of Standard ML 17 6 The ML Module Language In this section we briefly review the organization of the Standard ML modules system <ref> [Mac85, MTH90, MT91] </ref>. The basic entities of the Standard ML module system are structures, signatures and functors. Roughly speaking, a structure is a packaged environment, assigning types to type identifiers, values to value identifiers, and structures to structure identifiers. <p> 1 !U 1 =t; M :i : 9t:U n (t 62 Dom ()) 1 !U 1 : ; t:U n . abstype t:U n 1 !U 1 with x: is M in N : (t 62 F V ()) For further discussion of existential types, the reader is referred to <ref> [MP88, CW85, Mac85] </ref>. <p> The typical situation in which sharing specifications are required arises when defining a functor that builds a structure out of two argument structures, each of which are to have a third component in common. (MacQueen <ref> [Mac85] </ref> gives an example in which a parser module is built from a lexer module and a symbol table module, each of which make use of a symbol module. In order for the parser to be well-defined, the lexer and the symbol table must share the same symbol implementation. See [Mac85] <p> <ref> [Mac85] </ref> gives an example in which a parser module is built from a lexer module and a symbol table module, each of which make use of a symbol module. In order for the parser to be well-defined, the lexer and the symbol table must share the same symbol implementation. See [Mac85] for more details.) Such a situation may be described schematically as follows. We are to define a functor F taking as argument two structures, R of signature SIG R and S of signature SIG S, which have a common component T of signature SIG T.
Reference: [Mac86] <author> D.B. MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In Proc. 13th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 277-286, </pages> <year> 1986. </year>
Reference-contexts: An important feature of the analysis is that our type system is stratified into levels, or universes, in the style of Martin-Lof's type theory [Mar82], and in keeping with the suggestions of <ref> [Mac86] </ref>. <p> We will adopt the view of modules proposed by MacQueen, in which the main constructs are reduced to the and types (the so-called "dependent" types) of Martin-Lof 's type theory <ref> [Mac86] </ref>. Using the typed -calculus with these constructs, we are able to show that universes play an important role. Our examination of universes involves close study of a restricted subset of the language. <p> Similarly, S.t refers to the t component of S, and is equivalent to the type int during type checking. This transparency of type definitions distinguishes ML structures from abstract data type declarations (see <ref> [Mac86, MP88] </ref> for related discussion). <p> the result signature of G in terms of the type component t of the argument S: functor G ( S : SIG ) : sig val y : S.t * S.t end = struct val y = (S.x,S.x) This formulation of dependent types is consistent with the account given in <ref> [Mac86] </ref>, and is ac counted for similarly in our model of ML. Type Structure of Standard ML 20 7 Full XML 7.1 Syntax In this section we will extend Core-XML to a function calculus XML by adding general constructs that allow us to describe the features of the previous section. <p> Type Structure of Standard ML 20 7 Full XML 7.1 Syntax In this section we will extend Core-XML to a function calculus XML by adding general constructs that allow us to describe the features of the previous section. Following <ref> [Mac86] </ref>, we will use general sums and products in the style of Martin-Lof's type theory [Mar82] to model the modules system.
Reference: [Mar73] <author> P. Martin-Lof. </author> <title> An intuitionistic theory of types: Predicative part. </title> <editor> In H. E. Rose and J. C. Shepherdson, editors, </editor> <booktitle> Logic Colloquium, </booktitle> <volume> '73, </volume> <pages> pages 73-118, </pages> <address> Amsterdam, </address> <year> 1973. </year> <title> North-Holland. Type Structure of Standard ML 37 </title>
Reference-contexts: One consequence of the universe distinction is that Core-XML has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. The language Core-XML is closely related to several explicitly-typed function calculi, in particular Martin-Lof's intensional type theory <ref> [Mar73] </ref>, the AUTOMATH languages [DB80], the Calculus of Constructions [CH88], and the type theory of LF [HHP87]. <p> Strong normalization is the property that there are no infinite reduction sequences from XML terms. In other word, the simple symbolic interpreter defined by the reduction rules is guaranteed to halt, on any term. Strong normalization for XML may be proved using a translation into Martin-Lof's 1973 system <ref> [Mar73] </ref>. It follows that the equational theory of XML is decidable. For other type systems, it is often possible to prove strong normalization by an appropriate method of logical relations [Sta85, Mit90]. <p> By the normalization theorem for the impredicative Girard-Reynolds calculus [Gir72, Mit86b] 4 , we know that impredicative poly-morphism with existential types is strongly normalizing. As noted in Section 7, a translation into Martin-Lof's 1973 system <ref> [Mar73] </ref> shows that XML with predicative polymorphism and "strong" sums is also strongly normalizing. <p> An application of F to a structure is well-formed only if the type checker can determine that the required equational specification holds. A simple way to account for sharing specifications in XML would be to employ the notion of an equality type introduced by Martin-Lof <ref> [Mar73] </ref>. Informally, the equality type M = N , for a U 2 type, is inhabited iff M and N are equal elements of type , according to the rules of equality for XML. The typing and equality rules for the equality type appear in Table 12.
Reference: [Mar82] <author> P. Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In Sixth International Congress for Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pages 153-175, </pages> <address> Amsterdam, 1982. </address> <publisher> North-Holland. </publisher>
Reference-contexts: One motivation for studying these elemental languages is that they provide some insight into programming languages with similar typing features. For example, the Girard-Reynolds second-order -calculus seems useful for analyzing languages with polymorphic functions or abstract data type declarations [Gir72, Rey74, MP88]. The richer type systems proposed by Martin-Lof <ref> [Mar82] </ref>, Constable [C + 86], and Huet and Coquand [CH88] also provide formal logics for reasoning about programs. <p> An important feature of the analysis is that our type system is stratified into levels, or universes, in the style of Martin-Lof's type theory <ref> [Mar82] </ref>, and in keeping with the suggestions of [Mac86]. <p> Since Core-XML is based on a pred-icative notion of universe, it is most closely related to Martin-Lof's early type theories, except that we do not, at this stage, take U 1 : U 2 . It is worth remarking that Martin-Lof's later type theory <ref> [Mar82, Mar84] </ref>, and the NuPRL type theory [C + 86], are type assignment systems, and hence are more closely related to the type system defined by Damas and Milner for the study of ML. <p> Following [Mac86], we will use general sums and products in the style of Martin-Lof's type theory <ref> [Mar82] </ref> to model the modules system. While general sums (also called "strong sums;" see [How80]) are closely related to structures, and general cartesian products seem necessary to capture dependently-typed functors, the language XML will be somewhat more general than ML. <p> This also makes the well-formed contexts difficult to define. Therefore, we will define XML by giving a set of inference rules for determining the well-formed contexts, types and terms, in the style of Automath [DB80], Martin-Lof <ref> [Mar82] </ref>, and LF [HHP87]. <p> expression, then (x:0) diverges in the current call-by-value implementation, but (x:0) = 0 is provable using the usual -calculus style reasoning.) It would be interesting to explore a typed calculus that is faithful to the operational semantics, following the pattern established by Plotkin's v -calculus [Plo75] and Martin-Lof's type theory <ref> [Mar82] </ref>. Some useful related ideas are developed in [Mog89]. Acknowledgements: Thanks to Dave MacQueen for many insightful discussions of ML, and comments on this paper in particular. Thanks also to John Greiner, Peter Lee, Eugenio Moggi, and Andrzej Tarlecki for comments on an earlier draft. Type Structure of Standard ML 35
Reference: [Mar84] <author> P. Martin-Lof. </author> <title> Intuitionistic Type Theory. </title> <type> Bibliopolis, </type> <institution> Napoli, </institution> <year> 1984. </year>
Reference-contexts: Since Core-XML is based on a pred-icative notion of universe, it is most closely related to Martin-Lof's early type theories, except that we do not, at this stage, take U 1 : U 2 . It is worth remarking that Martin-Lof's later type theory <ref> [Mar82, Mar84] </ref>, and the NuPRL type theory [C + 86], are type assignment systems, and hence are more closely related to the type system defined by Damas and Milner for the study of ML.
Reference: [McC79] <author> N. </author> <title> McCracken. An Investigation of a Programming Language with a Polymorphic Type Structure. </title> <type> PhD thesis, </type> <institution> Syracuse Univ., </institution> <year> 1979. </year>
Reference-contexts: Consequently, Core-XML may be interpreted in the domain-theoretic and recursion-theoretic models discussed in <ref> [ABL86, BMM90, Gir72, Tro73, McC79, Mit86b] </ref>. One difference between the languages, however, is that Core-XML has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84].
Reference: [Mil78] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> JCSS, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: It is worth noting that although the semantics is simplified, there seems to be no significant loss of generality in taking this point of view. We will see that Milner's type inference model, as described in <ref> [Mil78] </ref>, and the ideal model of [MPS86] may be viewed as models of our explicitly-typed core calculus. An important feature of the analysis is that our type system is stratified into levels, or universes, in the style of Martin-Lof's type theory [Mar82], and in keeping with the suggestions of [Mac86]. <p> in such a way that every value occurs with higher rank than any values on which its existence or behavior is predicated. (For example, functions always occur at a higher rank than their arguments.) The universe distinctions are faithful to the separation of monotypes from polytypes in Milner's earlier work <ref> [Mil78, DM82] </ref>, and allow us to show that implicit ML typing is syntactically equivalent to our explicit typing rules. The predicative universes also distinguish our calculus from both the implicit polymorphic typing of [Mit88, MPS86, Car85] and the explicitly-typed polymorphic calculus of [Gir71, Gir72, Rey74]. <p> Concluding remarks appear in Section 10. All type systems are defined formally in tables at the end of the paper. Type Structure of Standard ML 5 2 Implicitly typed ML Many studies of ML have focused on the type inference algorithm for the core expression language <ref> [Mil78, DM82, MPS86, Wan84] </ref>. This algorithm allows the ML programmer to write, for example, let id (x) = x in . . . automatically inferring the fact that the function id is a function from type t to t, for any t. <p> This algorithm allows the ML programmer to write, for example, let id (x) = x in . . . automatically inferring the fact that the function id is a function from type t to t, for any t. Milner's seminal paper <ref> [Mil78] </ref> describes the type inference algorithm and proposes a semantic framework for justifying its behavior. In Milner's semantics, an untyped expression denotes some element of an untyped value space, and a type denotes a subset of this space. Types are therefore viewed as predicates expressing properties of untyped terms. <p> In Milner's model, the sets denoted by type expressions do not include a special error value of the domain, called wrong. Consequently, the soundness of ML typing is often summarized by the slogan well-typed expressions cannot go wrong <ref> [Mil78] </ref>. Although there are quite a few constructs in the core expression language of ML, the behavior of the type checker may be understood by considering the fragment presented in [DM82], which we will call Core-ML. <p> Moreover, a semantics for an implicitly-typed language would entail identifying any two expressions that are equal as untyped terms. It is worth remarking that there is no semantic loss of generality in focusing on the explicitly-typed language, since models of the implicitly-typed system, such as Milner's original domain interpretation <ref> [Mil78] </ref> and related structures [MPS86], give rise to models of the explicitly-typed system in a natural way. (See Section 5.) We therefore introduce an explicitly-typed function calculus, called Core-XML, for core explicit ML. This calculus is essentially equivalent to Core-ML, the implicitly-typed language presented above. <p> However, we will not discuss categorical semantics in this paper. We will summarize some basic ideas regarding Henkin-style models primarily to emphasize that there is a semantic connection between Core-ML and Core-XML, as well as a syntactic one. In particular, structures such as the so-called ideal model of <ref> [Mil78, MPS86] </ref> provide models of Core-XML. A tangential reason to consider the semantics of Core-XML is that when U 1 and U 2 are isomorphic, we have a model of the impredicative Girard-Reynolds calculus (c.f. [Mit90]). <p> By the results of [Mit86b], this gives us a second-order model, and hence a model of Core-XML. A similar Core-XML model can be constructed from Milner's original description <ref> [Mil78] </ref>, taking U 1 to be the collection of monotypes, and defining the elements of U 2 (the polytypes) by quantification over U 1 .
Reference: [Mil85] <author> R. Milner. </author> <title> The Standard ML core language. </title> <journal> Polymorphism, </journal> <volume> 2(2), </volume> <year> 1985. </year> <pages> 28 pages. </pages> <note> An earlier version appeared in Proc. 1984 ACM Symp. on Lisp and Functional Programming. </note>
Reference-contexts: Standard ML is an updated version of the programming "meta-language" of the LCF system [GMW79], comprising a core expression language with polymorphic functions <ref> [Mil85] </ref> and a module language for defining interdependent program units [Mac85]. The core language is designed around an automatic type inference algorithm that performs compile-time checking of "un-typed" expressions.
Reference: [Mit86a] <author> J.C. Mitchell. </author> <title> Representation independence and data abstraction. </title> <booktitle> In Proc. 13th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 263-276, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: However, in further study of type : type, many subtle and important issues remain to be investigated. For example, we suspect that any study of representation independence <ref> [Rey83, MM85, Mit86a] </ref> or full abstraction [Plo77, Sto88] would be complicated dramatically by a type of all types. The next section contains a short summary of the usual type inference rules for the core language of ML. In Section 3, an alternative, explicitly-typed core language is given.
Reference: [Mit86b] <author> J.C. Mitchell. </author> <title> A type-inference approach to reduction properties and semantics of polymorphic expressions. </title> <booktitle> In ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 308-319, </pages> <month> August </month> <year> 1986. </year> <title> Reprinted with minor revisions in Logical Foundations of Functional Programming, </title> <editor> ed. G. Huet, </editor> <publisher> Addison-Wesley (1990) 195-212. </publisher>
Reference-contexts: Consequently, Core-XML may be interpreted in the domain-theoretic and recursion-theoretic models discussed in <ref> [ABL86, BMM90, Gir72, Tro73, McC79, Mit86b] </ref>. One difference between the languages, however, is that Core-XML has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. <p> in the given U 1 model, including U 1 , yields a full set-theoretic model. 5.4.2 Partial equivalence relation models One class of models that is pertinent to the development of the last few sections is obtained by interpreting types as partial equivalence relations (PER's) on an applicative structure (see <ref> [Mit86b] </ref> for further discussion and references.) The ideal model of [MPS86], for example, can be viewed as a PER inference model, as defined in [Mit88], by replacing each ideal I with the partial equivalence relation I fi I. By the results of [Mit86b], this gives us a second-order model, and hence <p> equivalence relations (PER's) on an applicative structure (see <ref> [Mit86b] </ref> for further discussion and references.) The ideal model of [MPS86], for example, can be viewed as a PER inference model, as defined in [Mit88], by replacing each ideal I with the partial equivalence relation I fi I. By the results of [Mit86b], this gives us a second-order model, and hence a model of Core-XML. A similar Core-XML model can be constructed from Milner's original description [Mil78], taking U 1 to be the collection of monotypes, and defining the elements of U 2 (the polytypes) by quantification over U 1 . <p> In either case, we obtain a Core-XML model with a degenerate equational theory (all terms of the same type become equal), but type membership interpreted as expected. Thus a consequence of the type soundness theorem for Core-XML models (see, e.g., <ref> [Mit86b, Mit88] </ref>) is that Core-ML expressions "cannot go wrong." Since the details are essentially straightforward, given the techniques in [Mit86b, Mit90], for example, we leave the precise construction to the reader. <p> Thus a consequence of the type soundness theorem for Core-XML models (see, e.g., [Mit86b, Mit88]) is that Core-ML expressions "cannot go wrong." Since the details are essentially straightforward, given the techniques in <ref> [Mit86b, Mit90] </ref>, for example, we leave the precise construction to the reader. <p> and U 2 by a single universe in the definition of Core-XML, then we obtain the second-order lambda calculus of Girard and Reynolds [Gir71, Gir72, Rey74]. (A similar technique is used to introduce impredicativity into Nuprl in [How87].) The Girard-Reynolds calculus has a number of reasonable theoretical properties (see, e.g., <ref> [BMM90, Mit86b, MP88] </ref>) and seems to be a useful tool for studying polymorphism in programming languages. However, if we make the full XML calculus impredicative by eliminating the distinction between U 1 and U 2 , the language becomes very different from the Girard-Reynolds calculus. <p> Either impredicative polymorphism with the "weaker" existential types, or restricted predica-tive polymorphism with "stronger" sum types seems reasonable. By the normalization theorem for the impredicative Girard-Reynolds calculus <ref> [Gir72, Mit86b] </ref> 4 , we know that impredicative poly-morphism with existential types is strongly normalizing. As noted in Section 7, a translation into Martin-Lof's 1973 system [Mar73] shows that XML with predicative polymorphism and "strong" sums is also strongly normalizing. <p> We also learned that Coquand had proved the same theorem by a different means in [Coq86], which was in preparation at the time of our announcement. 4 Girard's original proof included existential types. While the somewhat simpler proof in <ref> [Mit86b] </ref> does not, normalization with existential types can easily be derived by encoding 9t: as 8r [8t (!r)!r].
Reference: [Mit88] <author> J.C. Mitchell. </author> <title> Polymorphic type inference and containment. </title> <journal> Information and Computation, </journal> 76(2/3):211-249, 1988. Reprinted in Logical Foundations of Functional Programming, ed. G. Huet, Addison-Wesley (1990) 153-194. 
Reference-contexts: The predicative universes also distinguish our calculus from both the implicit polymorphic typing of <ref> [Mit88, MPS86, Car85] </ref> and the explicitly-typed polymorphic calculus of [Gir71, Gir72, Rey74]. In particular, the pure ML calculus without recursion has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. <p> In particular, the pure ML calculus without recursion has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. Some studies of ML typing (e.g., <ref> [Car85, Mit88, MPS86] </ref>) have suggested, in effect, that the restrictions imposed by universes might be relaxed to allow the full second-order polymorphism of the Girard-Reynolds calculus [Gir71, Gir72, Rey74]. However, these studies were generally based on consideration of the ML core language alone, and did not take modules into account. <p> The type inference algorithm is then treated as a decision procedure for the inference system. Milner's semantic analysis is elaborated in [MPS86, Car85], where the meanings of polymorphic types are clarified and recursive types are given semantics (see also <ref> [Mit88] </ref>). In Milner's model, the sets denoted by type expressions do not include a special error value of the domain, called wrong. Consequently, the soundness of ML typing is often summarized by the slogan well-typed expressions cannot go wrong [Mil78]. <p> Syntactically, this means that there is an ff variant 8s 1 . . . s k :t 0 of 0 such that no s i (1 i k) occurs free in and v t 0 ; see <ref> [DM82, Mit88] </ref> for further discussion, and [Mit88] for an interpretation of generic instantiation as semantic containment. When v 0 , we say is more general than 0 . <p> Syntactically, this means that there is an ff variant 8s 1 . . . s k :t 0 of 0 such that no s i (1 i k) occurs free in and v t 0 ; see [DM82, Mit88] for further discussion, and <ref> [Mit88] </ref> for an interpretation of generic instantiation as semantic containment. When v 0 , we say is more general than 0 . <p> Type Structure of Standard ML 11 5 Semantics of Core-XML 5.1 Introduction The Core-XML language has a straightforward Henkin-style model theory that is similar to the semantics of second-order lambda calculus described in <ref> [BM84, BMM90, Mit88] </ref>, except that we have two universes instead of one collection of types. Categorical semantics may also be developed, along the lines of [Mog91, HMM90], which resemble the indexed-categorical frameworks of [See84, See87]. However, we will not discuss categorical semantics in this paper. <p> that is pertinent to the development of the last few sections is obtained by interpreting types as partial equivalence relations (PER's) on an applicative structure (see [Mit86b] for further discussion and references.) The ideal model of [MPS86], for example, can be viewed as a PER inference model, as defined in <ref> [Mit88] </ref>, by replacing each ideal I with the partial equivalence relation I fi I. By the results of [Mit86b], this gives us a second-order model, and hence a model of Core-XML. <p> In either case, we obtain a Core-XML model with a degenerate equational theory (all terms of the same type become equal), but type membership interpreted as expected. Thus a consequence of the type soundness theorem for Core-XML models (see, e.g., <ref> [Mit86b, Mit88] </ref>) is that Core-ML expressions "cannot go wrong." Since the details are essentially straightforward, given the techniques in [Mit86b, Mit90], for example, we leave the precise construction to the reader.
Reference: [Mit90] <author> J.C. Mitchell. </author> <title> Type systems for programming languages. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Volume B, </volume> <pages> pages 365-458. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: In particular, structures such as the so-called ideal model of [Mil78, MPS86] provide models of Core-XML. A tangential reason to consider the semantics of Core-XML is that when U 1 and U 2 are isomorphic, we have a model of the impredicative Girard-Reynolds calculus (c.f. <ref> [Mit90] </ref>). Therefore, the semantics of Core-XML may be considered more basic than the semantics of the Girard-Reynolds calculus. An interesting choice in giving semantics to Core-XML lies in the interpretation of the containment U 1 U 2 . <p> Thus a consequence of the type soundness theorem for Core-XML models (see, e.g., [Mit86b, Mit88]) is that Core-ML expressions "cannot go wrong." Since the details are essentially straightforward, given the techniques in <ref> [Mit86b, Mit90] </ref>, for example, we leave the precise construction to the reader. <p> An example illustrating the failure of coherence for terms that have free polymorphic variables is given in [Oho89]. However, it is not hard to show that coherence holds for all closed terms in all models, using the strong normalization property of reduction (see <ref> [Bar84, Mit90] </ref>). A caveat in future work on ML is that when we include features such as recursion, references and exceptions, it is important to consider the order of evaluation. <p> If we direct the equational axioms from left to right, we obtain a reduction system of the form familiar from other systems of lambda calculus (e.g., <ref> [Bar84, Mit90] </ref>). Strong normalization is the property that there are no infinite reduction sequences from XML terms. In other word, the simple symbolic interpreter defined by the reduction rules is guaranteed to halt, on any term. <p> Strong normalization for XML may be proved using a translation into Martin-Lof's 1973 system [Mar73]. It follows that the equational theory of XML is decidable. For other type systems, it is often possible to prove strong normalization by an appropriate method of logical relations <ref> [Sta85, Mit90] </ref>.
Reference: [MM85] <author> J.C. Mitchell and A.R. Meyer. </author> <title> Second-order logical relations. </title> <booktitle> In Logics of Programs, </booktitle> <pages> pages 225-236, </pages> <address> Berlin, June 1985. </address> <publisher> Springer-Verlag LNCS 193. </publisher>
Reference-contexts: However, in further study of type : type, many subtle and important issues remain to be investigated. For example, we suspect that any study of representation independence <ref> [Rey83, MM85, Mit86a] </ref> or full abstraction [Plo77, Sto88] would be complicated dramatically by a type of all types. The next section contains a short summary of the usual type inference rules for the core language of ML. In Section 3, an alternative, explicitly-typed core language is given.
Reference: [MM91] <author> J.C. Mitchell and E. Moggi. </author> <title> Kripke-style models for typed lambda calculus. </title> <journal> Ann. Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 99-124, </pages> <year> 1991. </year> <note> Preliminary version in Proc. IEEE Symp. on Logic in Computer Science, </note> <year> 1987, </year> <pages> pages 303-314. </pages>
Reference-contexts: We also expect that the methods of [MMMS87] may be used to prove equational completeness for models that may have empty types, and that the approach of <ref> [MM91] </ref> will yield a completeness theorem for Kripke-style models, without making any assumptions about type inhabitation. 5.4 Examples of Models Since the only difference between Core-XML and the Girard-Reynolds second-order calculus is the distinction between universes, every second-order model may be viewed as a Core-XML model with U 1 = U
Reference: [MMMS87] <author> A. R. Meyer, J. C. Mitchell, E. Moggi, and R. Statman. </author> <title> Empty types in polymorphic lambda calculus. </title> <booktitle> In Proc. 14th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 253-262, </pages> <month> January </month> <year> 1987. </year> <title> Reprinted with minor revisions in Logical Foundations of Functional Programming, </title> <editor> ed. G. Huet, </editor> <publisher> Addison-Wesley (1990) 273-284. </publisher>
Reference-contexts: Type Structure of Standard ML 13 In addition, the methods of [BMM90] may be used to show that the equational proof system is sound and complete for models that do not have empty types. We also expect that the methods of <ref> [MMMS87] </ref> may be used to prove equational completeness for models that may have empty types, and that the approach of [MM91] will yield a completeness theorem for Kripke-style models, without making any assumptions about type inhabitation. 5.4 Examples of Models Since the only difference between Core-XML and the Girard-Reynolds second-order calculus
Reference: [Mog89] <author> E. Moggi. </author> <title> Computational lambda calculus and monads. </title> <booktitle> In Proc. IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 14-23, </pages> <year> 1989. </year>
Reference-contexts: Some useful related ideas are developed in <ref> [Mog89] </ref>. Acknowledgements: Thanks to Dave MacQueen for many insightful discussions of ML, and comments on this paper in particular. Thanks also to John Greiner, Peter Lee, Eugenio Moggi, and Andrzej Tarlecki for comments on an earlier draft. Type Structure of Standard ML 35
Reference: [Mog91] <author> E. Moggi. </author> <title> A category-theoretic account of program modules. </title> <journal> Math. Structures in Computer Science, </journal> <volume> 1(1) </volume> <pages> 103-139, </pages> <year> 1991. </year>
Reference-contexts: We have chosen Standard ML as the basis for this analysis because it is sufficiently well-developed to be interesting and useful as a "real" programming language, and sufficiently well-designed to support detailed analysis. In a sequel to this paper, we use the categorical techniques developed in <ref> [Mog91] </ref> to refine the calculus presented here in a manner that clearly identifies the compile-time/run-time distinction in Standard ML [HMM90]. <p> Categorical semantics may also be developed, along the lines of <ref> [Mog91, HMM90] </ref>, which resemble the indexed-categorical frameworks of [See84, See87]. However, we will not discuss categorical semantics in this paper. We will summarize some basic ideas regarding Henkin-style models primarily to emphasize that there is a semantic connection between Core-ML and Core-XML, as well as a syntactic one. <p> Explicit typing is central to giving a single account of both the core expression language and the module system, and seems useful for further study. In particular, in papers <ref> [Mog91, HMM90] </ref>, which were written after the work described here was completed, XML is used to study the separation between compile-time and run-time in Standard ML.
Reference: [MP88] <author> J.C. Mitchell and G.D. Plotkin. </author> <title> Abstract types have existential types. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <year> 1988. </year> <note> Preliminary version appeared in Proc. 12th ACM Symp. on Principles of Programming Languages, </note> <year> 1985. </year> <title> Type Structure of Standard ML 38 </title>
Reference-contexts: One motivation for studying these elemental languages is that they provide some insight into programming languages with similar typing features. For example, the Girard-Reynolds second-order -calculus seems useful for analyzing languages with polymorphic functions or abstract data type declarations <ref> [Gir72, Rey74, MP88] </ref>. The richer type systems proposed by Martin-Lof [Mar82], Constable [C + 86], and Huet and Coquand [CH88] also provide formal logics for reasoning about programs. <p> Similarly, S.t refers to the t component of S, and is equivalent to the type int during type checking. This transparency of type definitions distinguishes ML structures from abstract data type declarations (see <ref> [Mac86, MP88] </ref> for related discussion). <p> and U 2 by a single universe in the definition of Core-XML, then we obtain the second-order lambda calculus of Girard and Reynolds [Gir71, Gir72, Rey74]. (A similar technique is used to introduce impredicativity into Nuprl in [How87].) The Girard-Reynolds calculus has a number of reasonable theoretical properties (see, e.g., <ref> [BMM90, Mit86b, MP88] </ref>) and seems to be a useful tool for studying polymorphism in programming languages. However, if we make the full XML calculus impredicative by eliminating the distinction between U 1 and U 2 , the language becomes very different from the Girard-Reynolds calculus. <p> The "trade-off" implied by Theorem 8.4 is between impredicative polymorphism and the kind of types used to represent ML structures in XML. Generally speaking, impredicative polymorphism is more flexible than predicative polymorphism, and types allow us to type more terms than the existential types associated with data abstraction (see <ref> [MP88] </ref>). Either impredicative polymorphism with the "weaker" existential types, or restricted predica-tive polymorphism with "stronger" sum types seems reasonable. By the normalization theorem for the impredicative Girard-Reynolds calculus [Gir72, Mit86b] 4 , we know that impredicative poly-morphism with existential types is strongly normalizing. <p> ML concrete data type declarations may be accounted for in an extension of XML with disjoint union types at the U 1 level, existential types <ref> [MP88] </ref> at the U 2 level, and the ability to form recursively-defined type constructors at the U 2 level. We briefly summarize these extensions before discussing the interpretation of concrete data type declarations in XML. <p> For simplicity, we only present the formation and typing rules for the form of existential types we need. ; t:U n . 9t:U n (t 62 Dom ()) There are two differences between existential types in XML and the language considered in <ref> [MP88] </ref>. The form given here is more general in that we quantify over n-ary type constructors, rather than just types. <p> 1 !U 1 =t; M :i : 9t:U n (t 62 Dom ()) 1 !U 1 : ; t:U n . abstype t:U n 1 !U 1 with x: is M in N : (t 62 F V ()) For further discussion of existential types, the reader is referred to <ref> [MP88, CW85, Mac85] </ref>.
Reference: [MPS86] <author> D. MacQueen, G Plotkin, and R. Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> 71(1/2):95-130, 1986. 
Reference-contexts: It is worth noting that although the semantics is simplified, there seems to be no significant loss of generality in taking this point of view. We will see that Milner's type inference model, as described in [Mil78], and the ideal model of <ref> [MPS86] </ref> may be viewed as models of our explicitly-typed core calculus. An important feature of the analysis is that our type system is stratified into levels, or universes, in the style of Martin-Lof's type theory [Mar82], and in keeping with the suggestions of [Mac86]. <p> The predicative universes also distinguish our calculus from both the implicit polymorphic typing of <ref> [Mit88, MPS86, Car85] </ref> and the explicitly-typed polymorphic calculus of [Gir71, Gir72, Rey74]. In particular, the pure ML calculus without recursion has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. <p> In particular, the pure ML calculus without recursion has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. Some studies of ML typing (e.g., <ref> [Car85, Mit88, MPS86] </ref>) have suggested, in effect, that the restrictions imposed by universes might be relaxed to allow the full second-order polymorphism of the Girard-Reynolds calculus [Gir71, Gir72, Rey74]. However, these studies were generally based on consideration of the ML core language alone, and did not take modules into account. <p> Concluding remarks appear in Section 10. All type systems are defined formally in tables at the end of the paper. Type Structure of Standard ML 5 2 Implicitly typed ML Many studies of ML have focused on the type inference algorithm for the core expression language <ref> [Mil78, DM82, MPS86, Wan84] </ref>. This algorithm allows the ML programmer to write, for example, let id (x) = x in . . . automatically inferring the fact that the function id is a function from type t to t, for any t. <p> The type inference algorithm is then treated as a decision procedure for the inference system. Milner's semantic analysis is elaborated in <ref> [MPS86, Car85] </ref>, where the meanings of polymorphic types are clarified and recursive types are given semantics (see also [Mit88]). In Milner's model, the sets denoted by type expressions do not include a special error value of the domain, called wrong. <p> It is worth remarking that there is no semantic loss of generality in focusing on the explicitly-typed language, since models of the implicitly-typed system, such as Milner's original domain interpretation [Mil78] and related structures <ref> [MPS86] </ref>, give rise to models of the explicitly-typed system in a natural way. (See Section 5.) We therefore introduce an explicitly-typed function calculus, called Core-XML, for core explicit ML. This calculus is essentially equivalent to Core-ML, the implicitly-typed language presented above. <p> However, we will not discuss categorical semantics in this paper. We will summarize some basic ideas regarding Henkin-style models primarily to emphasize that there is a semantic connection between Core-ML and Core-XML, as well as a syntactic one. In particular, structures such as the so-called ideal model of <ref> [Mil78, MPS86] </ref> provide models of Core-XML. A tangential reason to consider the semantics of Core-XML is that when U 1 and U 2 are isomorphic, we have a model of the impredicative Girard-Reynolds calculus (c.f. [Mit90]). <p> yields a full set-theoretic model. 5.4.2 Partial equivalence relation models One class of models that is pertinent to the development of the last few sections is obtained by interpreting types as partial equivalence relations (PER's) on an applicative structure (see [Mit86b] for further discussion and references.) The ideal model of <ref> [MPS86] </ref>, for example, can be viewed as a PER inference model, as defined in [Mit88], by replacing each ideal I with the partial equivalence relation I fi I. By the results of [Mit86b], this gives us a second-order model, and hence a model of Core-XML.
Reference: [MR86] <author> A.R. Meyer and M.B. Reinhold. </author> <title> Type is not a type. </title> <booktitle> In Proc. 13th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 287-295, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: However, we will show that if the distinction between universes is removed, it becomes possible to define a type of all types. It follows from previous work on type : type, specifically, <ref> [Coq86, Gir72, How87, MR86] </ref>, that there exist recursion-free programs that cannot be evaluated to a normal form by any evaluation strategy. As argued in [MR86], this alters the character of the language dramatically. <p> It follows from previous work on type : type, specifically, [Coq86, Gir72, How87, MR86], that there exist recursion-free programs that cannot be evaluated to a normal form by any evaluation strategy. As argued in <ref> [MR86] </ref>, this alters the character of the language dramatically. In addition, Cardelli [Car88a] argues that taking type : type has significant practical disadvantages because it eliminates the distinction between "compile time" and "run time" values. <p> We refer the reader to <ref> [Coq86, How87, MR86, Car88a] </ref> for background information and further discussion of the merits of type:type. As discussed in the introduction, it seems fair to say that type:type would certainly change the character of ML dramatically. <p> Specifically, since we have general products and U 1 :U 2 , it is quite easy to see that if we let U 1 = U 2 , then Meyer and Reinhold's language t:t with a type of all types <ref> [MR86] </ref> becomes a sublanguage of XML. Note that although the term formation rules of XML only provide general products over U 2 types, letting U 1 = U 2 will give us products over all types. <p> Type Structure of Standard ML 25 Lemma 8.3 Any fragment of XML with U 1 :U 2 , U 1 = U 2 , and closed under the type and term formation rules associated with general products is capable of expressing all terms of t:t of <ref> [MR86] </ref>. Proof. The proof is a straightforward induction on the typing rules of t:t . Since we assume that U 1 = U 2 , we may unambiguously write U for the collection of types. <p> However, by Theorem 8.4, we know that if we combine strong sums with impredicative polymorphism by taking U 1 = U 2 , the most natural way of achieving this end, then we must admit a type of all types. By Girard's paradox <ref> [Coq86, MR86, How87] </ref>, type:type (in the presence of other constructs) implies that strong normalization fails. In short, assuming we wish to avoid type:type and non-normalizing recursion-free terms, we have a trade-off between impredicative polymorphism and strong sums.
Reference: [MT91] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Type Structure of Standard ML 17 6 The ML Module Language In this section we briefly review the organization of the Standard ML modules system <ref> [Mac85, MTH90, MT91] </ref>. The basic entities of the Standard ML module system are structures, signatures and functors. Roughly speaking, a structure is a packaged environment, assigning types to type identifiers, values to value identifiers, and structures to structure identifiers.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Using the framework of type theory, we propose an analogous case study of the programming language Standard ML <ref> [HMM86, MTH90] </ref>, only the first steps of which are completed here. In this paper, we will describe a typed -calculus that encompasses many of the essential features of Standard ML and use this to analyze some potential extensions of the language. <p> Type Structure of Standard ML 17 6 The ML Module Language In this section we briefly review the organization of the Standard ML modules system <ref> [Mac85, MTH90, MT91] </ref>. The basic entities of the Standard ML module system are structures, signatures and functors. Roughly speaking, a structure is a packaged environment, assigning types to type identifiers, values to value identifiers, and structures to structure identifiers. <p> In this sense we regard signature matching as a convenience similar to that afforded by the type inference algorithm for the core language. For further discussion of signature matching, we refer the reader to <ref> [HMT87, Tof88, MTH90] </ref>. Discussion of ML "sharing" specifications is deferred to Section 9.3 below. <p> An abstract type declaration introduces a "private" concrete data type, together with a set of "public" operations on that type. We give a brief description of each form below. For more information, see <ref> [HMM86, MTH90] </ref>. In the remainder of this section, we show how the three forms of type declarations just mentioned may be treated in XML. <p> Such a formalization would provide an interesting alternative to the methods used in the definition of ML <ref> [MTH90] </ref>. Sharing specifications, and the associated notion of "structure generativity", remain important topics for further research. Another important direction is to develop an accurate, straightforward presentation of ML operational semantics. As with other versions of lambda calculus, equality in XML is given by an equational axiom system.
Reference: [Oho89] <author> A. Ohori. </author> <title> A simple semantics for ML polymorphism. </title> <booktitle> In Functional Prog. and Computer Architecture, </booktitle> <pages> pages 281-292, </pages> <year> 1989. </year>
Reference-contexts: In other words, do we get different semantic interpretations depending on the way we assign types to subexpressions? A well-taken criticism of our approach, on these grounds, appears in <ref> [Oho89] </ref>. Another paper which discusses the general issue of coherence is [BTCGS91]. To avoid confusion, we will make a few definitions. <p> An example illustrating the failure of coherence for terms that have free polymorphic variables is given in <ref> [Oho89] </ref>. However, it is not hard to show that coherence holds for all closed terms in all models, using the strong normalization property of reduction (see [Bar84, Mit90]).
Reference: [Plo75] <author> G.D. Plotkin. </author> <title> Call-by-name, call-by-value and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: example, if is a divergent expression, then (x:0) diverges in the current call-by-value implementation, but (x:0) = 0 is provable using the usual -calculus style reasoning.) It would be interesting to explore a typed calculus that is faithful to the operational semantics, following the pattern established by Plotkin's v -calculus <ref> [Plo75] </ref> and Martin-Lof's type theory [Mar82]. Some useful related ideas are developed in [Mog89]. Acknowledgements: Thanks to Dave MacQueen for many insightful discussions of ML, and comments on this paper in particular. Thanks also to John Greiner, Peter Lee, Eugenio Moggi, and Andrzej Tarlecki for comments on an earlier draft.
Reference: [Plo77] <author> G.D. Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5 </volume> <pages> 223-255, </pages> <year> 1977. </year>
Reference-contexts: However, in further study of type : type, many subtle and important issues remain to be investigated. For example, we suspect that any study of representation independence [Rey83, MM85, Mit86a] or full abstraction <ref> [Plo77, Sto88] </ref> would be complicated dramatically by a type of all types. The next section contains a short summary of the usual type inference rules for the core language of ML. In Section 3, an alternative, explicitly-typed core language is given.
Reference: [Rey74] <author> J.C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Paris Colloq. on Programming, </booktitle> <pages> pages 408-425, </pages> <address> Berlin, 1974. </address> <publisher> Springer-Verlag LNCS 19. </publisher>
Reference-contexts: One motivation for studying these elemental languages is that they provide some insight into programming languages with similar typing features. For example, the Girard-Reynolds second-order -calculus seems useful for analyzing languages with polymorphic functions or abstract data type declarations <ref> [Gir72, Rey74, MP88] </ref>. The richer type systems proposed by Martin-Lof [Mar82], Constable [C + 86], and Huet and Coquand [CH88] also provide formal logics for reasoning about programs. <p> The predicative universes also distinguish our calculus from both the implicit polymorphic typing of [Mit88, MPS86, Car85] and the explicitly-typed polymorphic calculus of <ref> [Gir71, Gir72, Rey74] </ref>. In particular, the pure ML calculus without recursion has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84]. <p> Some studies of ML typing (e.g., [Car85, Mit88, MPS86]) have suggested, in effect, that the restrictions imposed by universes might be relaxed to allow the full second-order polymorphism of the Girard-Reynolds calculus <ref> [Gir71, Gir72, Rey74] </ref>. However, these studies were generally based on consideration of the ML core language alone, and did not take modules into account. <p> A pre-term M is a term of Core-XML if ` X . M : for some and . The difference between Core-XML and the Girard-Reynolds polymorphic -calculus <ref> [BMM90, Rey74, Gir72] </ref> lies in the distinction between universes U 1 and U 2 . Rule tapp of Core-XML only allows a type application . M [t ] : [t =t] when t is a type of the first universe U 1 . <p> M = N : , where M and N are terms of type (in the context ). The equational proof system of Core-XML is similar to that of the Girard-Reynolds calculus <ref> [Gir71, Rey74, BMM90] </ref>, with the following additional axiom for let: . (let x: = M in N ) = [N=x]M : t A complete presentation of the equational system for Core-XML is omitted here since it is an obvious fragment of the equation calculus for XML (which is presented below.) It <p> One way to eliminate this restriction is to eliminate the distinction between U 1 and U 2 . If we replace U 1 and U 2 by a single universe in the definition of Core-XML, then we obtain the second-order lambda calculus of Girard and Reynolds <ref> [Gir71, Gir72, Rey74] </ref>. (A similar technique is used to introduce impredicativity into Nuprl in [How87].) The Girard-Reynolds calculus has a number of reasonable theoretical properties (see, e.g., [BMM90, Mit86b, MP88]) and seems to be a useful tool for studying polymorphism in programming languages.
Reference: [Rey81] <author> J.C. Reynolds. </author> <title> The essence of Algol. </title> <editor> In de Bakker and van Vliet, editors, </editor> <booktitle> Algorithmic Languages, </booktitle> <pages> pages 345-372, </pages> <address> Amsterdam, 1981. </address> <publisher> IFIP, North-Holland. </publisher>
Reference-contexts: However, the long-term goals are the same: a precise understanding of programming language constructs and a sound mathematical basis for reasoning formally or informally about programs. In "The Essence of Algol" <ref> [Rey81] </ref>, Reynolds presents a study of Algol-60 in the denotational style, contending that "Algol may be obtained from the simple imperative language by imposing a procedure mechanism based on a fully typed, call-by-name lambda calculus." In addition to testing the Scott-Strachey approach for programming language analysis, Reynolds' study gave an important
Reference: [Rey83] <author> J.C. Reynolds. </author> <title> Types, abstraction, and parametric polymorphism. </title> <booktitle> In Information Processing '83, </booktitle> <pages> pages 513-523. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1983. </year>
Reference-contexts: However, in further study of type : type, many subtle and important issues remain to be investigated. For example, we suspect that any study of representation independence <ref> [Rey83, MM85, Mit86a] </ref> or full abstraction [Plo77, Sto88] would be complicated dramatically by a type of all types. The next section contains a short summary of the usual type inference rules for the core language of ML. In Section 3, an alternative, explicitly-typed core language is given. <p> For example, ML includes type constraints, type definitions, and an explicitly-typed modules language. In addition, we choose to view ML as an explicitly-typed language because it provides a better basis for studying equational properties of the language such as representation independence and full abstraction. (See <ref> [Rey83, Sto88] </ref> for discussion of these topics.) Viewing ML as an explicitly-typed language also leads to technical simplifications in the semantics of the language.
Reference: [Rey84] <author> J.C. Reynolds. </author> <title> Polymorphism is not set-theoretic. </title> <booktitle> In Proc. Int. Symp. on Semantics of Data Types, Sophia-Antipolis (France), </booktitle> <pages> pages 145-156, </pages> <address> Berlin, 1984. </address> <publisher> Springer LNCS 173. </publisher>
Reference-contexts: The predicative universes also distinguish our calculus from both the implicit polymorphic typing of [Mit88, MPS86, Car85] and the explicitly-typed polymorphic calculus of [Gir71, Gir72, Rey74]. In particular, the pure ML calculus without recursion has classical set-theoretic models, while the Girard-Reynolds calculus does not <ref> [Rey84] </ref>. Some studies of ML typing (e.g., [Car85, Mit88, MPS86]) have suggested, in effect, that the restrictions imposed by universes might be relaxed to allow the full second-order polymorphism of the Girard-Reynolds calculus [Gir71, Gir72, Rey74]. <p> However, in the Girard-Reynolds calculus, there is no universe distinction, and we can apply a term of polymorphic type to any type. One consequence of the universe distinction is that Core-XML has classical set-theoretic models, while the Girard-Reynolds calculus does not <ref> [Rey84] </ref>. The language Core-XML is closely related to several explicitly-typed function calculi, in particular Martin-Lof's intensional type theory [Mar73], the AUTOMATH languages [DB80], the Calculus of Constructions [CH88], and the type theory of LF [HHP87]. <p> Consequently, Core-XML may be interpreted in the domain-theoretic and recursion-theoretic models discussed in [ABL86, BMM90, Gir72, Tro73, McC79, Mit86b]. One difference between the languages, however, is that Core-XML has classical set-theoretic models, while the Girard-Reynolds calculus does not <ref> [Rey84] </ref>.
Reference: [Sco80] <author> D.S. Scott. </author> <title> Relating theories of the lambda calculus. In To H.B. </title> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 403-450. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: fixed-point operator Y , and that the untyped lambda calculus may be interpreted in a typed lambda calculus satisfying an equation t = t!t between types. (Further discussion of Y may be found in [Bar84], for example, and the relationship between untyped lambda calculus and type (or domain) equations in <ref> [Bar84, Sco80] </ref>.) Given this, and the fact that equality types allow us to type terms with respect to equational hypotheses, it is easy to show that equality types give us terms without normal form.
Reference: [See84] <author> R.A.G. Seely. </author> <title> Locally cartesian closed categories and type theory. </title> <journal> Math. Proc. Camb. Phil. Soc., </journal> <volume> 95 </volume> <pages> 33-48, </pages> <year> 1984. </year>
Reference-contexts: Categorical semantics may also be developed, along the lines of [Mog91, HMM90], which resemble the indexed-categorical frameworks of <ref> [See84, See87] </ref>. However, we will not discuss categorical semantics in this paper. We will summarize some basic ideas regarding Henkin-style models primarily to emphasize that there is a semantic connection between Core-ML and Core-XML, as well as a syntactic one.
Reference: [See87] <author> R.A.G. Seely. </author> <title> Categorical semantics for higher-order polymorphic lambda calculus. </title> <journal> J. Symbolic Logic, </journal> <volume> 52 </volume> <pages> 969-989, </pages> <year> 1987. </year>
Reference-contexts: Categorical semantics may also be developed, along the lines of [Mog91, HMM90], which resemble the indexed-categorical frameworks of <ref> [See84, See87] </ref>. However, we will not discuss categorical semantics in this paper. We will summarize some basic ideas regarding Henkin-style models primarily to emphasize that there is a semantic connection between Core-ML and Core-XML, as well as a syntactic one.
Reference: [Sta85] <author> R. Statman. </author> <title> Logical relations and the typed lambda calculus. </title> <journal> Information and Control, </journal> <volume> 65 </volume> <pages> 85-97, </pages> <year> 1985. </year>
Reference-contexts: Strong normalization for XML may be proved using a translation into Martin-Lof's 1973 system [Mar73]. It follows that the equational theory of XML is decidable. For other type systems, it is often possible to prove strong normalization by an appropriate method of logical relations <ref> [Sta85, Mit90] </ref>.
Reference: [Sto88] <author> A. Stoughton. </author> <title> Fully Abstract Models of Programming Languages. </title> <publisher> Pitman, London, and John Wiley and Sons, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: However, in further study of type : type, many subtle and important issues remain to be investigated. For example, we suspect that any study of representation independence [Rey83, MM85, Mit86a] or full abstraction <ref> [Plo77, Sto88] </ref> would be complicated dramatically by a type of all types. The next section contains a short summary of the usual type inference rules for the core language of ML. In Section 3, an alternative, explicitly-typed core language is given. <p> For example, ML includes type constraints, type definitions, and an explicitly-typed modules language. In addition, we choose to view ML as an explicitly-typed language because it provides a better basis for studying equational properties of the language such as representation independence and full abstraction. (See <ref> [Rey83, Sto88] </ref> for discussion of these topics.) Viewing ML as an explicitly-typed language also leads to technical simplifications in the semantics of the language.
Reference: [Tof88] <author> Mads Tofte. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> Edinburgh University, </institution> <year> 1988. </year> <note> Available as Edinburgh University Laboratory for Foundations of Computer Science Technical Report ECS-LFCS-88-54. Type Structure of Standard ML 39 </note>
Reference-contexts: In this sense we regard signature matching as a convenience similar to that afforded by the type inference algorithm for the core language. For further discussion of signature matching, we refer the reader to <ref> [HMT87, Tof88, MTH90] </ref>. Discussion of ML "sharing" specifications is deferred to Section 9.3 below.
Reference: [Tro73] <author> A.S. Troelstra. </author> <title> Mathematical Investigation of Intuitionistic Arithmetic and Analysis. </title> <publisher> Springer LNM 344, </publisher> <address> Berlin, </address> <year> 1973. </year>
Reference-contexts: Consequently, Core-XML may be interpreted in the domain-theoretic and recursion-theoretic models discussed in <ref> [ABL86, BMM90, Gir72, Tro73, McC79, Mit86b] </ref>. One difference between the languages, however, is that Core-XML has classical set-theoretic models, while the Girard-Reynolds calculus does not [Rey84].

References-found: 63

