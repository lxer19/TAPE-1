URL: ftp://info.mcs.anl.gov/pub/tech_reports/reports/TM159.ps.Z
Refering-URL: http://www.mcs.anl.gov/publications/abstracts/abstracts92.htm
Root-URL: http://www.mcs.anl.gov
Title: ADIFOR Working Note #3: ADIFOR Exception Handling  necessary Fortran intrinsic functions and for the error handler.  
Author: by Christian Bischof, George Corliss, and Andreas Griewank 
Note: Code is included for all of the  
Date: 1991  
Affiliation: Argonne  
Pubnum: Technical Memorandum MCS-TM-159,  
Abstract: Automatic differentiation uses recurrence relations based on the rules of calculus. Consequently, the results are guaranteed to be correct only if the relevant mathematical assumptions are satisfied at least in a neighborhood of the current argument. Computer programs may violate these conditions by branching or by calling intrinsic functions such as abs, max, sqrt, and asin at points where their derivative is undefined or infinite. The resulting dependence between the program's input and output variables may still be differentiable, because branch values fit together smoothly or nondifferentiabilities cancel each other out. We have two objectives. First, we would like to assure the user that the function being evaluated is indeed locally differentiable because all intrinsics are evaluated at smooth arguments and none of the branching tests are critical. Second, the derivative program should run even when the assumptions of the chain rule are not strictly satisfied. In this case, the numerical results represent at least generalized derivatives under reasonable (but usually unverifiable) regularity assumptions. To achieve these two goals, we must take into account the effects of finite-precision arithmetic. This paper addresses the detection and handling of exceptions. It is an exception in the ADIFOR-generated code to evaluate a function at a point at which the function may not be mathematically differentiable. When an exception is detected by tests written into the ADIFOR-generated code, an error handler is called. The error handler prints an error message (optionally), halts execution (optionally), and returns a value that allows the user's client program to detect that a requested derivative is not available. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Bischof, A. Carle, G. Corliss, A. Griewank, and P. Hovland, </author> <title> Generating derivative codes from Fortran programs, </title> <type> Preprint MCS-P263-0991, </type> <institution> Mathematics and Computer Science Division, Argonne National Laboratory, Argonne, Illinois, </institution> <year> 1991. </year> <note> Also appeared as Technical Report 91185, Center for Research in Parallel Computation, </note> <institution> Rice University, Houston, Texas. </institution>
Reference-contexts: This paper discusses what happens in the remaining rare events. The purpose of this paper is to make explicit the issues and alternatives associated with exception handling in ADIFOR. We assume that the reader is familiar with ADIFOR <ref> [1, 2] </ref>. The intended audience of this paper is the user of ADIFOR who wishes to better understand the error handling provided by ADIFOR and the rationale behind it. We address three questions: 1. What is an "error?" 2. <p> For univariant functions, one may obtain any value in the interval [lim inf f 0 ; lim sup f 0 ]. For example, a generalized gradient for jxj at 0 is any number in <ref> [1; 1] </ref>. The values we choose to return as "derivative" values at points of nondifferentiability are generalized gradient values, provided that the chain rule for generalized gradients holds as a set inequality, rather than as an inclusion [3].
Reference: [2] <author> C. Bischof and P. Hovland, </author> <title> Using ADIFOR to compute dense and sparse Jacobians, </title> <type> Technical Memorandum MCS-TM-158, </type> <institution> Mathematics and Computer Science Division, Argonne National Laboratory, Argonne, Illinois, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: This paper discusses what happens in the remaining rare events. The purpose of this paper is to make explicit the issues and alternatives associated with exception handling in ADIFOR. We assume that the reader is familiar with ADIFOR <ref> [1, 2] </ref>. The intended audience of this paper is the user of ADIFOR who wishes to better understand the error handling provided by ADIFOR and the rationale behind it. We address three questions: 1. What is an "error?" 2.
Reference: [3] <author> F. Clark, </author> <title> Optimization and Nonsmooth Analysis, </title> <publisher> John Wiley and Sons, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: The values we choose to return as "derivative" values at points of nondifferentiability are generalized gradient values, provided that the chain rule for generalized gradients holds as a set inequality, rather than as an inclusion <ref> [3] </ref>. Continuity of Catastrophe: The value at the point of nondifferentiability should in some sense be the limit of what happens in a neighborhood. For example, the derivative of asin (x) at 1 should be INFINITY.
Reference: [4] <author> H. Fischer, </author> <title> Special problems in automatic differentiation, In Automatic Differentiation of Algorithms: Theory, Implementation, and Application, </title> <editor> A. Griewank and G. Corliss (eds.), </editor> <publisher> SIAM, </publisher> <address> Philadelphia, Pennsylvania, </address> <year> 1991, </year> <note> to appear. </note>
Reference-contexts: An error can belong to this class even when the mathematical function is well behaved, but intermediate results produce this error. For example (from H. Fischer <ref> [4] </ref>), let f (x; z) := x 4 + z 4 ; where x and z are both active variables. The function f is differentiable at the point (x; z) = (0; 0). <p> Another unintended consequence of an IF statement is illustrated by another example from Fischer <ref> [4] </ref>. If the function f (x) := x 2 is programmed as 16 if (x .eq. 1.0) then f = 1.0 else f = x * x then automatic differentiation of this program would incorrectly compute f 0 (1) = 0. <p> Relative safety or trust region techniques will allow us to alert the user to danger. 9.3 Mathematical Pitfalls Automatic programming is no substitute for mathematical insight. Automatic differentiation is no exception. The following examples are from Fischer <ref> [4] </ref>. Example 1: Let f 2 (x) := xexp (x 2 ) and f k (x) = f k1 (x)exp (f 2 (x)). For x = 1, lim k!1 f 0 k (0) = 1, while f 0 (0) = 0.
Reference: [5] <author> G. Kedem, </author> <title> Automatic differentiation of computer programs, </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 6 (1980), </volume> <pages> pp. 150-165. 38 </pages>
Reference-contexts: The results will appear in a later paper. 9.2 Branching The user's original program may contain IF statements which have the effect of defining functions that are not differentiable or are not even continuous. The augmented code executes the appropriate branches in the manner described by Kedem <ref> [5] </ref>. However, the value of the derivatives computed at points at which equality holds are suspect. The derivatives computed are those that would result from taking limits of points for which inequality holds.
References-found: 5

