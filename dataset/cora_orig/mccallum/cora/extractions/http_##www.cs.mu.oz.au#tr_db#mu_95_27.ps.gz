URL: http://www.cs.mu.oz.au/tr_db/mu_95_27.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: (lee@cs.mu.OZ.AU,  trb@cs.mu.OZ.AU,  
Title: Towards a portable lazy functional declarative debugger  
Author: Lee Naish Tim Barbour 
Web: http://www.cs.mu.oz.au/~lee,  http://www.cs.mu.oz.au/~trb)  
Abstract: Technical Report 95/27 Department of Computer Science University of Melbourne Parkville, Victoria 3052, Australia Abstract Declarative (or algorithmic) debugging is a promising technique for debugging lazy functional programs. This paper addresses two important reasons why it is not more widespread: the difficulty of writing a declarative debugger for a lazy functional language in the language itself and the efficiency of the debugger. Using the source language to implement the debugger is desirable for portability and we discuss the reasons why this is very difficult to do. We propose a system in which nearly all the code is in the source language but there is one function which must be written at lower level. We also show how this function can be the key to significantly improving the efficiency of declarative debuggers for such languages. Keywords: algorithmic debugging, referential transparency, i/o, monads, types, trace, transformation 
Abstract-found: 1
Intro-found: 1
Reference: [LP94] <author> John Launchbury and Simpon L Peyton Jones. </author> <title> Lazy functional state threads. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(6) </volume> <pages> 24-35, </pages> <month> Jun </month> <year> 1994. </year>
Reference-contexts: Programming constructs such as monads can be used to enforce singled threading of data structures. Functional programming systems can then use such things as imperative-style destructive assignment of the data structure in a referentially transparent way [PW93] <ref> [LP94] </ref>. For debugging it is generally necessary to inspect the intermediate versions of data structures since that is where bugs may be manifest. Thus debugging and single threading are in direct conflict. If single threading was used just to improve efficiency then it could be sacrificed for debugging purposes.
Reference: [Nai91] <author> Lee Naish. </author> <title> Adding equations to NU-Prolog. </title> <booktitle> Proceedings of The Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 15-26, </pages> <month> August, </month> <year> 1991. </year>
Reference-contexts: Declarative debuggers for lazy functional languages have so far been implemented at a lower level. In the case of Nilsson et al. the lazy functional language is implemented in C and the debugger is implemented in C. In the case of Naish et al. the lazy functional language, NUE-Prolog <ref> [Nai91] </ref>, is implemented on top of Prolog and the debugger is implemented in Prolog. For portability, a debugger for a language should be implemented in the language itself.
Reference: [Nai92] <author> Lee Naish. </author> <title> Declarative diagnosis of missing answers. </title> <journal> New Generation Computing, </journal> <volume> 10(3) </volume> <pages> 255-285, </pages> <year> 1992. </year>
Reference-contexts: Space-time tradeoffs are analysed in [Pla84]. Re-execution in Prolog or strict functional languages is easy because the execution is usually independent of the context. Failure of sub-computations in Prolog with coroutining is dependent on the context, making declarative debugging of such programs difficult <ref> [Nai92] </ref>. Similarly, in lazy functional languages the extent to which an expression in a subtree is evaluated depends on what values are needed to evaluate the top level expression.
Reference: [Nai93] <author> Lee Naish. </author> <title> Declarative debugging of lazy functional programs. </title> <journal> Australian Computer Science Communications, </journal> <volume> 15(1) </volume> <pages> 287-294, </pages> <year> 1993. </year>
Reference-contexts: Declarative debugging algorithms were first developed for diagnosing wrong and missing answers in Prolog [Sha83]. More recently the ideas have been adapted to diagnosing errors in lazy functional languages [NF94] <ref> [Nai93] </ref> and related languages [NB95] [Nai95]. These debuggers have two important disadvantages: they are not portable and they are unacceptably inefficient, especially in terms of space. Most declarative debuggers for Prolog have been implemented in Prolog. This is easy to do and results in relatively portable debuggers. <p> For example, we could use the representation for expressions suggested in [SN95] which uses strings to represent constructor names and a different constructor for unevaluated expressions. The questions used in <ref> [Nai93] </ref> explicitly quantify variables and would require additional information so (representations of) unevaluated calls could be compared for equality.
Reference: [Nai95] <author> Lee Naish. </author> <title> A declarative debugging scheme. </title> <type> Technical Report 95/1, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <month> February </month> <year> 1995. </year>
Reference-contexts: Declarative debugging algorithms were first developed for diagnosing wrong and missing answers in Prolog [Sha83]. More recently the ideas have been adapted to diagnosing errors in lazy functional languages [NF94] [Nai93] and related languages [NB95] <ref> [Nai95] </ref>. These debuggers have two important disadvantages: they are not portable and they are unacceptably inefficient, especially in terms of space. Most declarative debuggers for Prolog have been implemented in Prolog. This is easy to do and results in relatively portable debuggers. <p> We also discuss how this primitive can be used to solve the most important efficiency problem in existing debuggers. Finally we summarize our proposal and how it differs from other approaches. 1 2 Declarative Debugging A general scheme for declarative debugging is proposed in <ref> [Nai95] </ref>. Here we describe how it is applied to diagnosing wrong answers in lazy functional languages. The evaluation of an expression is represented by a tree (called an evaluation dependence tree in [SN95]). <p> The essence of declarative debugging is the search for buggy nodes. A simple top-down debugger can be defined as follows. It can return a list of all "topmost" buggy nodes but lazy evaluation leads to a top-down left to right search for the first such node <ref> [Nai95] </ref>. debug :: Node -&gt; [Node] debug n | not (erroneous n) = [] debug n | erroneous n && bs /= [] = bs where bs = concat (map debug (children n)) debug n | otherwise = [n] erroneous :: Node -&gt; Bool children :: Node -&gt; [Node] The definition <p> The tree size can also be reduced by simply not building nodes for calls to "trusted" functions (such as library functions), as described in <ref> [Nai95] </ref>. However, even ignoring the size of the tree the debugger can result in a huge increase in memory consumption because it introduces a "space leak". Garbage collection of intermediate data structures is not posible since the debugger may be required to display these data structures. <p> When the debugger reaches one of the special nodes in the tree it re-evaluates the expression to build the subtree as described above. A special node can be seen as an implicit representation of the subtree and the re-evaluation can be done transparently inside the children function <ref> [Nai95] </ref>. We are currently investigating the details of this scheme further, particularly ways of encapsulating the re-execution mechanism in strongly typed languages. 5 Implementation status We are currently experimenting with prototype debuggers for the lazy functional subset of NUE-Prolog.
Reference: [NB95] <author> Lee Naish and Timothy Barbour. </author> <title> A declarative debugger for a logical-functional language. </title> <editor> In Graham Forsyth and Moonis Ali, editors, </editor> <booktitle> Eighth International Conference on Industrial and Engineering Applications of Artificial Intelligence and Expert Systems | Invited and Additional Papers, </booktitle> <volume> volume 2, </volume> <pages> pages 91-99, </pages> <address> Melbourne, </address> <month> June </month> <year> 1995. </year> <title> DSTO General Document 51. </title>
Reference-contexts: Declarative debugging algorithms were first developed for diagnosing wrong and missing answers in Prolog [Sha83]. More recently the ideas have been adapted to diagnosing errors in lazy functional languages [NF94] [Nai93] and related languages <ref> [NB95] </ref> [Nai95]. These debuggers have two important disadvantages: they are not portable and they are unacceptably inefficient, especially in terms of space. Most declarative debuggers for Prolog have been implemented in Prolog. This is easy to do and results in relatively portable debuggers.
Reference: [NF94] <author> Henrik Nilsson and Peter Fritzson. </author> <title> Algorithmic debugging of lazy functional languages. </title> <journal> Journal of functional programming, </journal> <volume> 4(3) </volume> <pages> 337-370, </pages> <year> 1994. </year>
Reference-contexts: Declarative debugging algorithms were first developed for diagnosing wrong and missing answers in Prolog [Sha83]. More recently the ideas have been adapted to diagnosing errors in lazy functional languages <ref> [NF94] </ref> [Nai93] and related languages [NB95] [Nai95]. These debuggers have two important disadvantages: they are not portable and they are unacceptably inefficient, especially in terms of space. Most declarative debuggers for Prolog have been implemented in Prolog. This is easy to do and results in relatively portable debuggers. <p> The most obvious additional space usage is for the construction of he tree, especially if it uses a relatively inefficient representation of the program data structures to stay within the type system. To quote from the conclusion of <ref> [NF94] </ref>: ". . . (the debugger) cannot be considered to be a practically usable system, mainly due to the prohibitively large trace size. . . ". Lazy evaluation can actually help us here if we are able to construct the tree lazily. <p> It may be unacceptably inefficient to re-execute the whole program each time we need to incrementally extend the tree, as suggested in <ref> [NF94] </ref>. 4 Our proposal We now present our approach to solving (most of) the problems presented above. We first describe a source to source transformation and the primitive function it relies on. Then we discuss how currying and higher order functions interact with the transformation.
Reference: [Pla84] <author> David A. Plaisted. </author> <title> An efficient bug location algorithm. </title> <editor> In Sten -Ake Tarnlund, editor, </editor> <booktitle> Proceedings of the Second International Logic Programming Conference, </booktitle> <pages> pages 151-157, </pages> <institution> Uppsala, Sweden, </institution> <month> July </month> <year> 1984. </year> <month> 13 </month>
Reference-contexts: If the debugger reaches a leaf of the (partial) tree then the sub-computation at that point is re-executed to build (the top levels of) the subtree. Space-time tradeoffs are analysed in <ref> [Pla84] </ref>. Re-execution in Prolog or strict functional languages is easy because the execution is usually independent of the context. Failure of sub-computations in Prolog with coroutining is dependent on the context, making declarative debugging of such programs difficult [Nai92].
Reference: [PW93] <editor> Simon L Peyton Jones and Philip Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In Proceedings of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 71-84, </pages> <month> Jan </month> <year> 1993. </year>
Reference-contexts: Programming constructs such as monads can be used to enforce singled threading of data structures. Functional programming systems can then use such things as imperative-style destructive assignment of the data structure in a referentially transparent way <ref> [PW93] </ref> [LP94]. For debugging it is generally necessary to inspect the intermediate versions of data structures since that is where bugs may be manifest. Thus debugging and single threading are in direct conflict. If single threading was used just to improve efficiency then it could be sacrificed for debugging purposes.
Reference: [Sha83] <author> Ehud Y. Shapiro. </author> <title> Algorithmic program debugging. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1983. </year>
Reference-contexts: A promising solution to these problems is to use declarative debugging, which uses the declarative meaning of programs rather than the sequence of steps in the execution to locate bugs. Declarative debugging algorithms were first developed for diagnosing wrong and missing answers in Prolog <ref> [Sha83] </ref>. More recently the ideas have been adapted to diagnosing errors in lazy functional languages [NF94] [Nai93] and related languages [NB95] [Nai95]. These debuggers have two important disadvantages: they are not portable and they are unacceptably inefficient, especially in terms of space.
Reference: [SN95] <author> Jan Sparud and Hendrik Nilsson. </author> <title> The architecture of a debugger for lazy functional languages. </title> <editor> In Mireille Ducasse, editor, </editor> <booktitle> Proceedings of AADEBUG'95, </booktitle> <address> Saint-Malo, France, </address> <month> May, </month> <year> 1995. </year>
Reference-contexts: Here we describe how it is applied to diagnosing wrong answers in lazy functional languages. The evaluation of an expression is represented by a tree (called an evaluation dependence tree in <ref> [SN95] </ref>). To simplify the presentation we will assume that the top level expression which is evaluated is simply mainbug. Each node in the tree contains two expressions. The root node contains the expression mainbug and the result returned by mainbug. <p> However, at the source level 1:1: ones is not of type [Int]. We would prefer to avoid complicated type analysis of the program and construction of new types for the transformed program. The transformation proposed in <ref> [SN95] </ref> uses existential types which are not widely supported and hence should also be avoided. Also, for the debugger to be written without knowledge of the program, the representation of terms in the program must be independent of the types used in the program. <p> The transformation described in <ref> [SN95] </ref> is also similar though the "plumbing" (extra variables) is hidden by higher order functions. The key difference is our use of dirt. Dirt always returns a Term, avoiding problems with strong typing, and also solves the problem of referential transparency, as we describe later. The transformation of [SN95] relies on <p> described in <ref> [SN95] </ref> is also similar though the "plumbing" (extra variables) is hidden by higher order functions. The key difference is our use of dirt. Dirt always returns a Term, avoiding problems with strong typing, and also solves the problem of referential transparency, as we describe later. The transformation of [SN95] relies on existential types and uses only referentially transparent functions. The resulting tree is used by the debugger to construct another tree and this requires functions that are not referentially transparent. <p> This makes it easier to implement user-defined methods of displaying expressions in questions and should make the other use we have for dirt (see later) easier to implement. For example, we could use the representation for expressions suggested in <ref> [SN95] </ref> which uses strings to represent constructor names and a different constructor for unevaluated expressions. The questions used in [Nai93] explicitly quantify variables and would require additional information so (representations of) unevaluated calls could be compared for equality. <p> However, it may require additional support in some systems. An alternative is to have a more complex (and less efficient) transformation such as that discussed in <ref> [SN95] </ref>. Our transformation (and also that of [SN95]) generally cannot be used if function definitions are curried. The transformed definition of take expects hd to be of type [a]-&gt;(a,Tree), which is the type of the transformed version of the normal definition of hd. <p> However, it may require additional support in some systems. An alternative is to have a more complex (and less efficient) transformation such as that discussed in <ref> [SN95] </ref>. Our transformation (and also that of [SN95]) generally cannot be used if function definitions are curried. The transformed definition of take expects hd to be of type [a]-&gt;(a,Tree), which is the type of the transformed version of the normal definition of hd. <p> The new aspect of our 12 transformation is the use of the function dirt which is not referentially transparent. The debugger architecture proposed in <ref> [SN95] </ref> is closely related to ours. Advantages of our approach include: the transformation does not need existential types, no intermediate tree is constructed and the code for the debugger does not contain any "impure" features (allowing it to be debugged more easily).
Reference: [TZ886] <author> NU-Prolog reference manual, </author> <title> version 1.0. </title> <type> Technical Report 86/10, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1986. </year> <month> 14 </month>
Reference-contexts: In subsequent versions the implementation of dirt has been changed so it returns terms that would be acceptable in typical strongly typed languages. The rest of the debugger is written in a very simple portable style. Stream IO has been implemented using the coroutining facilities of NU-Prolog <ref> [TZ886] </ref>. The debugger has been used to find bugs in small programs, including buggy versions of the debugger itself. We have also implemented a version of the debugging system which uses a different transformation and incrementqlly constructs the tree. This will be described in more detail in a future report.
References-found: 12

