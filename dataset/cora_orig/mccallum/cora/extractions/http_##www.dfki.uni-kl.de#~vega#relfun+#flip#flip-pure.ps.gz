URL: http://www.dfki.uni-kl.de/~vega/relfun+/flip/flip-pure.ps.gz
Refering-URL: http://www.dfki.uni-kl.de/~vega/relfun.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: FLIP: Functional-plus-Logic Programming on an Integrated Platform  
Author: Michael Sintek 
Date: May 1995  
Address: Postfach 2080 67608 Kaiserslautern Germany  
Affiliation: DFKI GmbH  
Abstract-found: 0
Intro-found: 1
Reference: <institution> Bibliography </institution>
Reference: [ At-Kaci, 1990 ] <author> Hassan At-Kaci. </author> <title> The WAM: A (Real) Tutorial. </title> <type> Report 5, </type> <institution> Digital, Paris Research Laboratory, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: not be required. 3 Only * the WAM heap (holding lists and structures, the compound data terms of PROLOG and RELFUN/REL), * the local stack (holding environments, which contain local variables, and choice points), and 3 For introductions into the WAM, refer to [ Gabriel et al., 1985 ] , <ref> [ At-Kaci, 1990 ] </ref> , and [ Van Roy, 1994 ] . 2.2. ABSTRACT MACHINES 13 * some of the WAM registers (the program counter and the stack and heap pointers) are shared between the WAM and the LLAMA.
Reference: [ Benker et al., 1989 ] <editor> H. Benker, J. Beacco, S. Bescos, M. Dorochevsky, Th. Jeffre, A. Pohlmann, J. Noye, B. Poterie, A. Sexton, J.C. Syre, O. Thibault, and G. Watzlawik. KCM: </editor> <booktitle> A Knowledge Crunching Machine. </booktitle> <month> May </month> <year> 1989. </year>
Reference: [ Boley and Richter, 1991 ] <editor> Harold Boley and Michael M. Richter, editors. </editor> <booktitle> Proceedings of the International Workshop on Processing Declarative Knowledge (PDK'91), number 567 in Lecture Notes in Artificial Intelligence (LNAI). </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, </address> <year> 1991. </year>
Reference: [ Boley et al., 1991 ] <author> Harold Boley, Klaus Elsbernd, Hans-Guenther Hein, and Thomas Krause. </author> <title> RFM Manual: Compiling RELFUN into the Relational/Functional Machine. Document D-91-03, </title> <institution> DFKI GmbH, </institution> <year> 1991. </year>
Reference-contexts: B.1 RELFUN Toplevel In FLIP-extended RELFUN, three different toplevels are present: the interpreter, the emulator, and the LL toplevel. They are entered with inter, emul, and ll, respectively. For the commands available at the interpreter and emulator toplevels, refer to the RELFUN documentation <ref> [ Boley et al., 1991 ] </ref> and [ Boley et al., 1993 ] .
Reference: [ Boley et al., 1993 ] <author> Harold Boley, Klaus Elsbernd, Michael Herfert, Michael Sin-tek, and Werner Stein. </author> <title> RELFUN Guide: Programming with Relations and Functions Made Easy. Document D-93-12, </title> <publisher> DFKI, </publisher> <month> July </month> <year> 1993. </year>
Reference-contexts: They are entered with inter, emul, and ll, respectively. For the commands available at the interpreter and emulator toplevels, refer to the RELFUN documentation [ Boley et al., 1991 ] and <ref> [ Boley et al., 1993 ] </ref> .
Reference: [ Boley, 1986 ] <author> Harold Boley. RELFUN: </author> <title> A Relational/Functional Integration with Valued Clauses. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(12) </volume> <pages> 87-98, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: In general, there are two different ways of integrating functional and relational programming languages [ Boley, 1992 ] : 1. by tightly integrating both paradigms into unified ones <ref> [ Boley, 1986; Hanus, 1991; Lock, 1993 ] </ref> 2. by loose coupling, obtaining hybrid languages (for classic systems, see [ Slo-man and Hardy, 1983; Robinson, 1985 ] ) which are often parts of multi language expert system shells 10 CHAPTER 2. BACKGROUND Both approaches have their advantages and disadvantages: 1. <p> in the functional or the relational sublanguage, accessing each other only via well-defined interfaces. 1 The loose integration of relational languages and LISP in this work was inspired by RELFUN [ Boley, 1992 ] , a tightly integrated relational-plus-functional programming language also building upon PROLOG and LISP (the original version <ref> [ Boley, 1986 ] </ref> not only used a LISP-like syntax for both relations and functions but also LISP-like dotted-pair patterns for unification).
Reference: [ Boley, 1991 ] <author> Harold Boley. </author> <title> A Sampler of Relational/Functional Definitions. </title> <note> DFKI Technical Memo TM-91-04, DFKI, </note> <month> March </month> <year> 1991. </year> <note> Second, Revised Edition July 1993. </note>
Reference-contexts: Especially, large relational applications tend to contain a huge number of deterministic predicates, as we were able to determine via some of our RELFUN programs <ref> [ Sintek, 1991; Boley, 1991 ] </ref> . 4. The expressiveness of relational programs can be improved by specifying new features as LL functions and using them as pseudo builtins. 8 CHAPTER 1.
Reference: [ Boley, 1992 ] <author> Harold Boley. </author> <title> Extended Logic-plus-Functional Programming. </title> <booktitle> In Workshop on Extensions of Logic Programming, </booktitle> <address> ELP '91, Stockholm 1991, </address> <publisher> LNAI. Springer, </publisher> <year> 1992. </year>
Reference-contexts: Introduction 1.1 Ob jectives The objective of this work is a novel approach to the integration of functional and logic programming languages on the basis of abstract machines in the context of the RELFUN <ref> [ Boley, 1992 ] </ref> project. This integration is motivated by the following points: 1. <p> In the case of the integration of relational and functional programming languages, their declarativeness and, in particular, their expressiveness, i.e. their suitability for partially disjoint problem classes, is inherited. In general, there are two different ways of integrating functional and relational programming languages <ref> [ Boley, 1992 ] </ref> : 1. by tightly integrating both paradigms into unified ones [ Boley, 1986; Hanus, 1991; Lock, 1993 ] 2. by loose coupling, obtaining hybrid languages (for classic systems, see [ Slo-man and Hardy, 1983; Robinson, 1985 ] ) which are often parts of multi language expert system <p> For large, modular applications this is often insignificant: complete modules can be specified either in the functional or the relational sublanguage, accessing each other only via well-defined interfaces. 1 The loose integration of relational languages and LISP in this work was inspired by RELFUN <ref> [ Boley, 1992 ] </ref> , a tightly integrated relational-plus-functional programming language also building upon PROLOG and LISP (the original version [ Boley, 1986 ] not only used a LISP-like syntax for both relations and functions but also LISP-like dotted-pair patterns for unification).
Reference: [ Debray and Warren, 1990 ] <author> Saumya K. Debray and David S. Warren. </author> <title> Towards Banishing the Cut from Prolog. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 335-349, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: (elt arg#1 1))) (if (and (equal x (- y x)) (equal y (fac/2-1 y))) (struct 'u arg#1 arg#1) (cons arg#1 (cons arg#1 nil)))) (cons arg#1 (cons arg#1 nil)))) (cons arg#1 (cons arg#1 nil)))) 9 In special cases, disjointness can be established by global analysis even for programs without type declarations <ref> [ Debray and Warren, 1990 ] </ref> . 40 CHAPTER 4. INTEGRATING RELATIONS AND LL In case of the fac function, exactly the definition a human programmer would have chosen has been created.
Reference: [ DeGroot and Lindstrom, 1986 ] <editor> D. DeGroot and G. Lindstrom, editors. </editor> <title> Logic Programming: Functions, Relations, and Equations. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year> <note> BIBLIOGRAPHY 101 </note>
Reference-contexts: In [ Lloyd, 1987 ] , an introduction to logic programming, in [ Wikstrtm, 1987 ] , an introduction to functional programming is given. 2.1 Relational-Functional Programming Lan guages Languages integrating functional and logic (relational) programming concepts <ref> [ DeGroot and Lindstrom, 1986 ] </ref> are currently often called functional logic programming languages.
Reference: [ Dorochevsky et al., 1991 ] <author> Michael Dorochevsky, Jaques Noye, and Olivier Thibault. </author> <title> Has Dedicated Hardware for Prolog a Future? In H. </title> <editor> Boley and M. M. Richter, editors, </editor> <booktitle> Processing Declarative Knowlege, number 567 in Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 17-31. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1991. </year>
Reference: [ Ershov, 1980 ] <author> A.P. Ershov. </author> <title> Mixed Computation: Potential Applications and Problems for Study. In Mathematical Logic Methods in AI Problems and Systematic Programming, </title> <booktitle> Part 1, </booktitle> <pages> pages 26-55. </pages> <address> Vil'nyus, USSR, </address> <year> 1980. </year> <note> (In Rus-sian). </note>
Reference-contexts: The origin of the field is due to Kleene [ Kleene, 1952 ] , but the application to programming languages is primarily due to Futamara [ Futamura, 1971 ] , Haraldsson [ Haraldsson, 1977 ] , Ershov <ref> [ Ershov, 1980 ] </ref> , and Jones [ Jones et al., 1989 ] . As the following example shows, non-trivial deterministic predicates can be detected without partial evaluation.
Reference: [ Futamura, 1971 ] <author> Y. Futamura. </author> <title> Partial Evaluation of Computation Process An Approach to a Compiler-Compiler. </title> <journal> Systems, Computers, Controls, </journal> <volume> 2(5) </volume> <pages> 45-50, </pages> <year> 1971. </year>
Reference-contexts: The origin of the field is due to Kleene [ Kleene, 1952 ] , but the application to programming languages is primarily due to Futamara <ref> [ Futamura, 1971 ] </ref> , Haraldsson [ Haraldsson, 1977 ] , Ershov [ Ershov, 1980 ] , and Jones [ Jones et al., 1989 ] . As the following example shows, non-trivial deterministic predicates can be detected without partial evaluation.
Reference: [ Gabriel et al., 1985 ] <author> John Gabriel, Tim Lindholm, E. L. Lusk, and R.A. Over-beek. </author> <title> A Tutorial on the Warren Abstract Machine for Computational Logic. </title> <type> Report ANL-84-84, </type> <institution> Argonne National Laboratory, Argonne, Illinois 60439, </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: a deep understanding of the WAM will not be required. 3 Only * the WAM heap (holding lists and structures, the compound data terms of PROLOG and RELFUN/REL), * the local stack (holding environments, which contain local variables, and choice points), and 3 For introductions into the WAM, refer to <ref> [ Gabriel et al., 1985 ] </ref> , [ At-Kaci, 1990 ] , and [ Van Roy, 1994 ] . 2.2. ABSTRACT MACHINES 13 * some of the WAM registers (the program counter and the stack and heap pointers) are shared between the WAM and the LLAMA.
Reference: [ Hall, 1995 ] <author> Victoria Hall. </author> <title> Integration von Sorten als ausgezeichnete, taxono-mische Pradikate in eine relational-funktionale Sprache. Document D-95-04, </title> <institution> DFKI Kaiserslautern, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: A remedy to avoid these is the introduction of type definitions and signatures (see example 4.7 on page 39), as they are currently developed for RELFUN <ref> [ Hall, 1995 ] </ref> .
Reference: [ Hanus, 1991 ] <author> Michael Hanus. </author> <title> Efficient Implementation of Narrowing and Rewriting. </title> <note> In Boley and Richter [ 1991 </note> ] . 
Reference-contexts: The expressiveness of relational programs can be improved by specifying new features as LL functions and using them as pseudo builtins. 8 CHAPTER 1. INTRODUCTION Compared with more theoretically motivated approaches using a tight integration of logic and functional languages on the source and the abstract machine levels (e.g. <ref> [ Hanus, 1991; Lock, 1993 ] </ref> ), our approach has the following strong points: * Already existing programs in PROLOG and LISP do not have to be re implemented in a new, unified formalism. * For applications requiring additional programming paradigms, further abstract machines can be coupled with the WAM and <p> In general, there are two different ways of integrating functional and relational programming languages [ Boley, 1992 ] : 1. by tightly integrating both paradigms into unified ones <ref> [ Boley, 1986; Hanus, 1991; Lock, 1993 ] </ref> 2. by loose coupling, obtaining hybrid languages (for classic systems, see [ Slo-man and Hardy, 1983; Robinson, 1985 ] ) which are often parts of multi language expert system shells 10 CHAPTER 2. BACKGROUND Both approaches have their advantages and disadvantages: 1.
Reference: [ Haraldsson, 1977 ] <author> A. Haraldsson. </author> <title> A Program Manipulation System Based on Partial Evaluation. </title> <type> PhD thesis, </type> <institution> Linkoping University, Sweden, 1977. Linkoping Studies in Science and Technology Dissertations 14. </institution>
Reference-contexts: The origin of the field is due to Kleene [ Kleene, 1952 ] , but the application to programming languages is primarily due to Futamara [ Futamura, 1971 ] , Haraldsson <ref> [ Haraldsson, 1977 ] </ref> , Ershov [ Ershov, 1980 ] , and Jones [ Jones et al., 1989 ] . As the following example shows, non-trivial deterministic predicates can be detected without partial evaluation.
Reference: [ Henderson, 1980 ] <author> Peter Henderson. </author> <title> Functional Programming Application and Implementation. </title> <booktitle> Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1980. </year>
Reference-contexts: LLAMA | THE LISP LIGHT ABSTRACT MACHINE Chapter 5 LLAMA | The LISP light Abstract Machine The LLAMA is a simple and universal abstract stack machine <ref> [ Henderson, 1980 ] </ref> which is used as the target machine for the compilation of LL. It is universal in the sense that most functional 1 and many imperative language can easily be compiled into it.
Reference: [ Jones et al., 1989 ] <author> N.D. Jones, P. Sestoft, and H. Stndergaard. </author> <title> Mix: A Self-Applicable Partial Evaluator for Experiments in Compiler Generation. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2(1) </volume> <pages> 9-50, </pages> <year> 1989. </year>
Reference-contexts: The origin of the field is due to Kleene [ Kleene, 1952 ] , but the application to programming languages is primarily due to Futamara [ Futamura, 1971 ] , Haraldsson [ Haraldsson, 1977 ] , Ershov [ Ershov, 1980 ] , and Jones <ref> [ Jones et al., 1989 ] </ref> . As the following example shows, non-trivial deterministic predicates can be detected without partial evaluation.
Reference: [ Kleene, 1952 ] <author> S.C. Kleene. </author> <title> Introduction to Metamathematics. </title> <publisher> Princeton, </publisher> <address> NJ: D. </address> <publisher> van Nostrand, </publisher> <year> 1952. </year>
Reference-contexts: The origin of the field is due to Kleene <ref> [ Kleene, 1952 ] </ref> , but the application to programming languages is primarily due to Futamara [ Futamura, 1971 ] , Haraldsson [ Haraldsson, 1977 ] , Ershov [ Ershov, 1980 ] , and Jones [ Jones et al., 1989 ] .
Reference: [ Krause, 1991 ] <institution> Thomas Krause. Globale Datenfluanalyse und horizontale Compilation der relational-funktionalen Sprache RELFUN. Diplomarbeit, DFKI D-91-08, Universitat Kaiserslautern, FB Informatik, </institution> <address> Postfach 3049, D-6750 Kaiserslautern, </address> <month> March </month> <year> 1991. </year> <note> 102 BIBLIOGRAPHY </note>
Reference-contexts: DETERMINISM TRANSFORMATION 33 In this work, a simplified version of the second solution was chosen: since PROLOG is (usually) untyped, only mode declarations are considered. A mode analyzer, e.g. the one described in <ref> [ Krause, 1991 ] </ref> , can then be used to refine the set of mode descriptions, thus further restricting the query set. In the following, a set of mode descriptions, either only declared by the user or refined with a mode analyzer, is assumed to be present.
Reference: [ Kurozumi, 1992 ] <author> Takashi Kurozumi. </author> <title> Overview of the Ten Years of the FGSC Project. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 9-19, </pages> <publisher> ICOT, </publisher> <address> Japan, </address> <year> 1992. </year> <institution> Association for Computing Machinery. </institution>
Reference: [ Lloyd, 1987 ] <author> John W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1987. </year>
Reference-contexts: Chapter 8 finishes this work with conclusions and gives some hints for future work. 9 Chapter 2 Background In this chapter, a short introduction to relational-functional programming and abstract machines is presented. The reader is expected to be familiar with the concepts of logic programming and functional programming. In <ref> [ Lloyd, 1987 ] </ref> , an introduction to logic programming, in [ Wikstrtm, 1987 ] , an introduction to functional programming is given. 2.1 Relational-Functional Programming Lan guages Languages integrating functional and logic (relational) programming concepts [ DeGroot and Lindstrom, 1986 ] are currently often called functional logic programming languages. <p> DETERMINISM TRANSFORMATION 27 partial SLD resolution tree <ref> [ Lloyd, 1987 ] </ref> for g in P created according to the PROLOG 4 refutation procedure, i.e. with PROLOG's computation rule (which always selects the leftmost goal in a goal sequence) and PROLOG's depth-first search rule (searching clauses from top to bottom).
Reference: [ Lock, 1993 ] <author> Hendrik C. R. </author> <title> Lock. </title> <booktitle> The Implementation of Functional Logic Programming Languages. GMD-Bericht Nr. </booktitle> <volume> 208. </volume> <editor> R. </editor> <publisher> Oldenbourg Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The expressiveness of relational programs can be improved by specifying new features as LL functions and using them as pseudo builtins. 8 CHAPTER 1. INTRODUCTION Compared with more theoretically motivated approaches using a tight integration of logic and functional languages on the source and the abstract machine levels (e.g. <ref> [ Hanus, 1991; Lock, 1993 ] </ref> ), our approach has the following strong points: * Already existing programs in PROLOG and LISP do not have to be re implemented in a new, unified formalism. * For applications requiring additional programming paradigms, further abstract machines can be coupled with the WAM and <p> In general, there are two different ways of integrating functional and relational programming languages [ Boley, 1992 ] : 1. by tightly integrating both paradigms into unified ones <ref> [ Boley, 1986; Hanus, 1991; Lock, 1993 ] </ref> 2. by loose coupling, obtaining hybrid languages (for classic systems, see [ Slo-man and Hardy, 1983; Robinson, 1985 ] ) which are often parts of multi language expert system shells 10 CHAPTER 2. BACKGROUND Both approaches have their advantages and disadvantages: 1.
Reference: [ McCarthy et al., 1962 ] <author> John McCarthy, Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, and Michael I. Levin. </author> <title> LISP 1.5 Programmer's Manual. </title> <publisher> The M.I.T. Press, </publisher> <month> August </month> <year> 1962. </year>
Reference-contexts: They will be described in detail in sections 5.1 and 5.2. 14 CHAPTER 3. LL: LISP LIGHT Chapter 3 LL: LISP light LL (LISP light) is a subset of (COMMON) LISP <ref> [ McCarthy et al., 1962; Steele Jr., 1984 ] </ref> extended by PROLOG structures. In addition to purely functional builtins, it contains some extra-functional builtins for the following reasons: 1. <p> builtins, and user-definable functions will be described. 3.1 Data Types In LL, the following data types 1 are supported: * symbols * numbers (integers and reals) * strings * lists and dotted pairs 1 In the context of LISP, data types are usually referred to as S-expressions (symbolic ex pressions) <ref> [ McCarthy et al., 1962 ] </ref> . 3.1. DATA TYPES 15 * structures Symbols, numbers, strings, and lists work just like their COMMON LISP counterparts. Because LL has to handle all data types that can be found on the WAM stack and heap, PROLOG structures had to be added.
Reference: [ Nilsson, 1993 ] <author> U. Nilsson. </author> <title> Towards a Methodology for the Design of Abstract Machines. </title> <journal> Journal of Logic Programming, </journal> <volume> 16(1, </volume> 2):163-189, 1993. 
Reference-contexts: Otherwise, predicates that are always used deterministically are not detected and thus compiled into inefficient code. This definition complies with the concept of partial evaluation (or partial deduction in the field of logic programming). As pointed out in <ref> [ Nilsson, 1993 ] </ref> , partial evaluation is, at least from a principal point of view, a simple form of program transformation by which a program, given some partial input data, can be specialized to solve a particular problem more efficiently than the more general program.
Reference: [ Nystrtm, 1985 ] <author> Sven Olof Nystrtm. </author> <title> NyWam A WAM Emulator Written in LISP. </title> <year> 1985. </year>
Reference-contexts: In this work, it was used to integrate an existing implementation of the WAM (our version of the NyWAM <ref> [ Nystrtm, 1985 ] </ref> ) with the newly developed LLAMA (chapter 5).
Reference: [ Robinson, 1985 ] <author> J. A. Robinson. </author> <title> Beyond LOGLISP: Combining Functional and Relational Programming in a Reduction Setting, </title> <month> April </month> <year> 1985. </year>
Reference-contexts: In general, there are two different ways of integrating functional and relational programming languages [ Boley, 1992 ] : 1. by tightly integrating both paradigms into unified ones [ Boley, 1986; Hanus, 1991; Lock, 1993 ] 2. by loose coupling, obtaining hybrid languages (for classic systems, see <ref> [ Slo-man and Hardy, 1983; Robinson, 1985 ] </ref> ) which are often parts of multi language expert system shells 10 CHAPTER 2. BACKGROUND Both approaches have their advantages and disadvantages: 1.
Reference: [ Sintek, 1991 ] <author> Michael Sintek. Monolinguistic CAD2NC: </author> <title> A Deterministic REL-FUN Application Generating Abstract NC Programs from CAD-like Geometries. </title> <institution> DFKI Kaiserslautern, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Especially, large relational applications tend to contain a huge number of deterministic predicates, as we were able to determine via some of our RELFUN programs <ref> [ Sintek, 1991; Boley, 1991 ] </ref> . 4. The expressiveness of relational programs can be improved by specifying new features as LL functions and using them as pseudo builtins. 8 CHAPTER 1.
Reference: [ Sintek, 1993 ] <author> Michael Sintek. </author> <title> Indexing PROLOG Procedures into DAGs by Heuristic Classification. </title> <note> DFKI Technical Memo TM-93-05, </note> <institution> DFKI GmbH, </institution> <year> 1993. </year>
Reference-contexts: REL without indexing 0.596 s 2. REL with indexing 0.295 s 3. LL (automatically generated) 0.142 s The speed up achieved by indexing and by transformation into LL (compared with the indexed version) are both approximately 2. 1 For a survey of indexing, see [ Stein, 1993 ] and <ref> [ Sintek, 1993 ] </ref> 90 APPENDIX A. BENCHMARKS A.2 Naive Fibonacci For the (naive) Fibonacci algorithm applied to 20, the following internal run times were measured: 1. REL without indexing 11.1 s 2. REL with indexing 6.23 s 3.
Reference: [ Sloman and Hardy, 1983 ] <author> Aaron Sloman and Steve Hardy. POPLOG: </author> <title> A Multipurpose Multi-language Program Development Environment. </title> <address> AISBQ 47, </address> <year> 1983. </year>
Reference: [ Steele Jr., 1984 ] <author> Guy L. Steele Jr. </author> <title> COMMON LISP: The Language. </title> <publisher> Digital Press, </publisher> <month> March </month> <year> 1984. </year>
Reference-contexts: They will be described in detail in sections 5.1 and 5.2. 14 CHAPTER 3. LL: LISP LIGHT Chapter 3 LL: LISP light LL (LISP light) is a subset of (COMMON) LISP <ref> [ McCarthy et al., 1962; Steele Jr., 1984 ] </ref> extended by PROLOG structures. In addition to purely functional builtins, it contains some extra-functional builtins for the following reasons: 1. <p> If the reader is familiar with COMMON LISP, most of these subsections may be skipped (except subsection 3.2.3, which describes LL structures). Only short definitions of the LL builtins are given. A detailed description can be found in the LISP literature <ref> [ Steele Jr., 1984 ] </ref> . <p> for two reasons: 1. to make the integration of existing COMMON LISP programs into REL programs easier 2. to allow tail-recursive deterministic REL relations and functions to be trans lated into LL loops in order to speed up execution For a detailed explanation of catch, throw, loop, and do, see <ref> [ Steele Jr., 1984 ] </ref> .
Reference: [ Stein and Sintek, 1991 ] <author> W. Stein and M. Sintek. RELFUN/X: </author> <title> An Experimental PROLOG Implementation of RELFUN. ARC-TEC Document 91-1, </title> <institution> DFKI GmbH, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: This also works for non-adjacent output arguments: g (X,A,Y,B) :- : : : with modes g (G,X ,G,X ) is transformed into g/4-2 (X,Y) :- : : : & values [A,B]. Such value structures can be viewed as representing multiple-valued functions as described in <ref> [ Stein and Sintek, 1991 ] </ref> . 4.2.3.2 RELFUN ! (E; ) The next transformation step takes all deterministic clauses totally apart: an internal representation, called E, is created, in which variables are associated 36 CHAPTER 4.
Reference: [ Stein, 1993 ] <author> Werner Stein. </author> <title> Indexing Principles for Relational Languages Applied to PROLOG Code Generation. </title> <type> Technical Report Document D-92-22, </type> <institution> DFKI GmbH, </institution> <month> February </month> <year> 1993. </year> <note> BIBLIOGRAPHY 103 </note>
Reference-contexts: REL without indexing 0.596 s 2. REL with indexing 0.295 s 3. LL (automatically generated) 0.142 s The speed up achieved by indexing and by transformation into LL (compared with the indexed version) are both approximately 2. 1 For a survey of indexing, see <ref> [ Stein, 1993 ] </ref> and [ Sintek, 1993 ] 90 APPENDIX A. BENCHMARKS A.2 Naive Fibonacci For the (naive) Fibonacci algorithm applied to 20, the following internal run times were measured: 1. REL without indexing 11.1 s 2. REL with indexing 6.23 s 3.
Reference: [ Taylor, 1990 ] <author> Andrew Taylor. </author> <title> LIPS on a MIPS: Results from a Prolog Compiler for a RISC. </title> <editor> In David H. D. Warren and Peter Szeredi, editors, </editor> <booktitle> Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <pages> pages 174-185, </pages> <address> Jerusalem, 1990. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: In addition to recent research in the field of native code generation for logic programs <ref> [ Taylor, 1990; Van Roy, 1994 ] </ref> , research dealing with the improved compilation of logic programs into abstract machines should be pursued, too. <p> This is consistent with recent insights that PROLOG programs should be compiled into much simpler and more specialized instructions than the WAM instructions (see <ref> [ Taylor, 1990; Van Roy, 1994 ] </ref> ). The three copies of (cons arg#1 (cons arg#1 nil)) cannot be avoided in a purely functional specification. <p> In future research it could be examined how LL 1 case is not yet implemented. 88 CHAPTER 8. CONCLUSIONS AND FUTURE WORK and the LLAMA can be useful in the compilation of PROLOG and other relational languages into native code <ref> [ Taylor, 1990; Van Roy, 1994 ] </ref> . A possible scenario for this is illustrated in the following diagram: * The loose integration, performed on the abstract machine level, is not restricted to relational and functional languages.
Reference: [ Van Roy, 1994 ] <author> Peter Van Roy. </author> <year> 1983-1993: </year> <title> The wonder years of sequential Pro-log implementation. </title> <journal> The Journal of Logic Programming, </journal> <volume> 19,20:385-441, </volume> <year> 1994. </year>
Reference-contexts: In addition to recent research in the field of native code generation for logic programs <ref> [ Taylor, 1990; Van Roy, 1994 ] </ref> , research dealing with the improved compilation of logic programs into abstract machines should be pursued, too. <p> In 1977, David H. D. Warren et. al. developed DEC-10 PROLOG, the first PRO-LOG compiler, and in 1983, he designed the WAM [ Warren, 1983 ] , the abstract machine that has become the de facto standard implementation technique for relational languages <ref> [ Van Roy, 1994 ] </ref> . <p> the WAM heap (holding lists and structures, the compound data terms of PROLOG and RELFUN/REL), * the local stack (holding environments, which contain local variables, and choice points), and 3 For introductions into the WAM, refer to [ Gabriel et al., 1985 ] , [ At-Kaci, 1990 ] , and <ref> [ Van Roy, 1994 ] </ref> . 2.2. ABSTRACT MACHINES 13 * some of the WAM registers (the program counter and the stack and heap pointers) are shared between the WAM and the LLAMA. They will be described in detail in sections 5.1 and 5.2. 14 CHAPTER 3. <p> Besides attempts at efficient compilation of deterministic PROLOG itself <ref> [ Van Roy, 1994 ] </ref> , this can be achieved by either implementing deterministic predicates in a loosely coupled imperative or functional programming language (as described in section 4.1) or by specifying them in a relational language with subsequent transformation into an efficient (e.g. imperative or functional) language by an intelligent <p> This is consistent with recent insights that PROLOG programs should be compiled into much simpler and more specialized instructions than the WAM instructions (see <ref> [ Taylor, 1990; Van Roy, 1994 ] </ref> ). The three copies of (cons arg#1 (cons arg#1 nil)) cannot be avoided in a purely functional specification. <p> In future research it could be examined how LL 1 case is not yet implemented. 88 CHAPTER 8. CONCLUSIONS AND FUTURE WORK and the LLAMA can be useful in the compilation of PROLOG and other relational languages into native code <ref> [ Taylor, 1990; Van Roy, 1994 ] </ref> . A possible scenario for this is illustrated in the following diagram: * The loose integration, performed on the abstract machine level, is not restricted to relational and functional languages.
Reference: [ Warren et al., 1977 ] <author> David H. D. Warren, Luis M. Pereira, and Fernando Pereira. </author> <title> Prolog The Language and its Implementation Compared with Lisp. </title> <journal> SIGPLAN Notices, </journal> <volume> 12(8) </volume> <pages> 109-115, </pages> <month> August </month> <year> 1977. </year> <note> Special Issue. </note>
Reference-contexts: Since the development and maintenance of software is very expensive, the loss of some declarativeness usually caused by hybrid integrations is justifiable. * Since the seminal paper <ref> [ Warren et al., 1977 ] </ref> there has been a dispute about the relative efficiencies of LISP and PROLOG: the authors gave examples where their PROLOG was as efficient as the LISPs of that time.
Reference: [ Warren, 1983 ] <author> David H. D. Warren. </author> <title> An Abstract Prolog Instruction Set. </title> <type> Technical Note 309, </type> <institution> SRI International, </institution> <address> Menlo Park, CA, </address> <month> October </month> <year> 1983. </year>
Reference-contexts: The extension of LL with PROLOG-like structures is necessary in order to permit both sublanguages to work on the same data types. This integration is carried out on two levels: * On the abstract machine level: The WAM <ref> [ Warren, 1983 ] </ref> , the abstract machine which has turned out to be a (local) optimum for the compilation of relational languages, is (loosely) coupled with the LLAMA (LISP light Abstract Machine), an abstract stack machine especially designed for the efficient execution of LL programs while handling all PROLOG data <p> In 1967, Absys (Aberdeen System), an interpreter for (a predecessor of) pure PROLOG, was developed at the University of Aberdeen. In 1977, David H. D. Warren et. al. developed DEC-10 PROLOG, the first PRO-LOG compiler, and in 1983, he designed the WAM <ref> [ Warren, 1983 ] </ref> , the abstract machine that has become the de facto standard implementation technique for relational languages [ Van Roy, 1994 ] .

References-found: 39

