URL: http://www.cs.toronto.edu/~ruppert/multiObjects.ps
Refering-URL: http://www.cs.toronto.edu/~ruppert/index.html
Root-URL: 
Email: ruppert@cs.utoronto.ca  
Title: Consensus Numbers of Multi-Objects  
Author: Eric Ruppert 
Address: Toronto, Ontario, Canada M5S 3G4  
Affiliation: Department of Computer Science University of Toronto  
Abstract: This paper studies the ability of shared memory distributed systems to solve the wait-free consensus problem if processes are permitted to access more than one shared data object in a single atomic action. Suppose T is any deterministic object type that can be used, with read/write registers, to solve consensus among n processes, with n &gt; 2. A multi-object of type T m consists of a collection of objects of type T , any m of which can be accessed in a single atomic action. It will be shown that a multi-object of type T m can be used, with registers, to solve consensus among (n m) processes. Furthermore, if the type T is equipped with operations that allow processes to read its state without altering the state, then the multi-object can be used with registers to solve consensus among (nm) processes. Neither of these lower bounds can be improved. p
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Yehuda Afek, Michael Merritt, and Gadi Taubenfeld. </author> <title> The power of multi-objects. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 213-222, </pages> <year> 1996. </year>
Reference-contexts: This paper studies the increase in the consensus number of an object type when processes are permitted to access several objects simultaneously. Let T be a shared object type, and let m be a positive integer. Afek, Merritt and Taubenfeld <ref> [1] </ref> defined a multi-object of type T m to be a collection of objects of type T , indexed by the natural numbers, that can be accessed m at a time. The type T is called the base type of the multi-object type T m . <p> A multi-object built from this base type will also be commutative and therefore have consensus number two, regardless of the number of base objects that can be accessed in a single operation <ref> [1] </ref>. The Model A shared object can be modelled as an I/O automaton (see [8]). Each operation causes the object to change its state and return a response to the process that invoked the operation. <p> Merritt and Taubenfeld [9] showed that n-process consensus can be solved using the multi-object type register m in the presence of t process failures if and only if t max (2m 3; 0). Afek, Merritt and Tauben-feld <ref> [1] </ref> studied the consensus numbers of multi-objects that use, as their base objects, queues, consensus objects and swap objects. (A swap object is equipped with a single operation that writes a new value into the state of the object and returns the old value of the state). <p> They showed that, for any type T , cons (T fl ) 2 f1; 2; 1g. Their proof used the result that cons (3-consensus m ) = ( p m) <ref> [1] </ref> to show that cons (T m ) = ( p m) for any base type T with consensus number greater than two. <p> Afek, Merritt and Taubenfeld <ref> [1] </ref> introduced the notion of direct implementations as a tool for studying consensus numbers of multi-objects. <p> The following lemma follows easily from the definition of direct implementations. Lemma 1 <ref> [1] </ref> If type T 1 directly implements type T 2 , then T m 1 directly implements T m 2 for any positive integer m. The proof of the next lemma uses a bivalency argument, the proof technique originated by Fischer, Lynch and Pa-terson [3]. <p> It will then follow from Lemma 3 that the type team (n 1 ; n 2 ) m (and therefore T m ) has consensus number at least N = (n p m). The algorithm will be similar to the one used by Afek, Merritt and Taubenfeld <ref> [1] </ref> to prove that cons (n-consensus m ) = fi (n p The algorithm will use a multi-object of type team (n 1 ; n 2 ) m with g 2 base objects, arranged into a two-dimensional g fi g array. <p> Therefore, the algorithm that uses the multi-object to solve the team (g bn 1 =2c ; n 2 ) problem is correct. 2 The bound given in Theorem 4 cannot be improved, since the consensus number of the n-consensus m multi-object type is fi (n m) <ref> [1] </ref>. However, in the next section, a better bound will be obtained for the class of readable object types.
Reference: [2] <author> Yehuda Afek, Michael Merritt, Gadi Tauben-feld, and Dan Touitou. </author> <title> Disentangling multi-object operations. </title> <booktitle> In Proc. 16th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 111-120, </pages> <year> 1997. </year>
Reference-contexts: The operation applied to one base object cannot depend on the result of an operation on another base object that is part of the same multi-object operation. Multi-objects often simplify the task of programming a distributed system <ref> [2] </ref>. It would therefore be useful to know whether it is possible to use software to implement multi-objects from the (usually single-access) objects that are provided as primitives of a distributed system. A systematic study of the consensus power of multi-objects is one way to approach this problem.
Reference: [3] <author> Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2), </volume> <pages> pages 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Lemma 1 [1] If type T 1 directly implements type T 2 , then T m 1 directly implements T m 2 for any positive integer m. The proof of the next lemma uses a bivalency argument, the proof technique originated by Fischer, Lynch and Pa-terson <ref> [3] </ref>. Some standard terminology used in bivalency arguments will be reviewed. A configuration of a protocol consists of the state of all shared objects, together with the internal states of all processes.
Reference: [4] <author> Maurice Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1), </volume> <pages> pages 124-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The power of a distributed system to solve problems depends on the types of objects that are used. It is therefore important to determine whether the set of object types provided by a distributed system are capable of implementing the shared data structures required by an application. Herlihy <ref> [4] </ref> showed that objects that solve the n-process consensus problem, where each process begins with an input value and the processes must agree on one of the values, can be used, together with read/write registers, to obtain a wait-free implementation of any other object type for n processes. <p> Thus, the ability of a shared object type to solve the wait-free consensus problem is an important measure of the type's power to implement other types of shared data structures and to solve problems. This leads to the idea of classifying object types according to their consensus number <ref> [4, 6] </ref>. The consensus number of an object type T , denoted cons (T ), is the maximum number of processes that can solve consensus using objects of type T and registers, or infinity if no such maximum exists. <p> The implementation should also specify the initial states for O 1 ; : : : ; O N to be used for any initial state of the simulated object. History Herlihy <ref> [4] </ref> showed that an array of registers, where processes are allowed to read individual registers or write to m registers in a single atomic action, has consensus number 2m 2, for m &gt; 1. <p> Proof: Consider a consensus protocol for n processes that uses objects of type T and registers. A standard biva-lency argument (see <ref> [4] </ref>) can be used to show that there is some critical configuration of the protocol. Furthermore, after the critical configuration, the next step of each process is applied to a single object X of type T . Let a be the critical value of some process.
Reference: [5] <author> Maurice P. Herlihy and Jeannette M. Wing. Lin-earizability: </author> <title> A correctness condition for concurrent objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3), </volume> <pages> pages 463-492, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Each operation causes the object to change its state and return a response to the process that invoked the operation. Objects studied in this paper are deterministic: the operation and current state of the object uniquely determine the state transition and response. Objects are also linearizable <ref> [5] </ref>, so that each operation appears to occur instantaneously at some time between its invocation and its response. The wait-free model of fault-tolerance is used in this paper.
Reference: [6] <author> Prasad Jayanti. </author> <title> Robust wait-free hierarchies. </title> <journal> Journal of the ACM, </journal> <volume> 44(4), </volume> <pages> pages 592-614, </pages> <month> July </month> <year> 1997. </year>
Reference-contexts: Thus, the ability of a shared object type to solve the wait-free consensus problem is an important measure of the type's power to implement other types of shared data structures and to solve problems. This leads to the idea of classifying object types according to their consensus number <ref> [4, 6] </ref>. The consensus number of an object type T , denoted cons (T ), is the maximum number of processes that can solve consensus using objects of type T and registers, or infinity if no such maximum exists.
Reference: [7] <author> Prasad Jayanti and Sanjay Khanna. </author> <booktitle> On the power of multi-objects. In Distributed Algorithms, 11th International Workshop, </booktitle> <year> 1997. </year>
Reference-contexts: The following two examples show why there cannot be general lower bounds on the consensus numbers of multi-objects whose base types have consensus number one or two, even if only readable object types are considered. As observed by Jayanti and Khanna <ref> [7] </ref>, a multi-object whose base objects always return the same response to all operations will have consensus number one, regardless of the number of base objects that can be accessed simultaneously. <p> commutative base type has consensus number at most two. (An object type is commutative if, for any pair of operations and any possible state of the object, the state that results from applying the two operations does not depend on the order in which they are applied.) Jayanti and Khanna <ref> [7] </ref> recently defined a different kind of multi-object, denoted T fl , where any finite number of base objects of type T can be accessed in a single atomic action. They showed that, for any type T , cons (T fl ) 2 f1; 2; 1g.
Reference: [8] <author> Nancy A. Lynch. </author> <title> Distributed Algorithms, chapter 8. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: A multi-object built from this base type will also be commutative and therefore have consensus number two, regardless of the number of base objects that can be accessed in a single operation [1]. The Model A shared object can be modelled as an I/O automaton (see <ref> [8] </ref>). Each operation causes the object to change its state and return a response to the process that invoked the operation. Objects studied in this paper are deterministic: the operation and current state of the object uniquely determine the state transition and response.
Reference: [9] <author> Michael Merritt and Gadi Taubenfeld. </author> <title> Atomic m-register operations. </title> <booktitle> In Distributed Algorithms, 5th International Workshop, volume 579 of LNCS, </booktitle> <pages> pages 289-294, </pages> <year> 1991. </year>
Reference-contexts: History Herlihy [4] showed that an array of registers, where processes are allowed to read individual registers or write to m registers in a single atomic action, has consensus number 2m 2, for m &gt; 1. Merritt and Taubenfeld <ref> [9] </ref> showed that n-process consensus can be solved using the multi-object type register m in the presence of t process failures if and only if t max (2m 3; 0).
Reference: [10] <author> Eric Ruppert. </author> <title> Determining consensus numbers. </title> <type> Technical Report 303/96, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1996. </year> <note> Available from http://www.cs.utoronto.ca/~ruppert. A condensed version appeared in Proc. 16th ACM Symposium on Principles of Distributed Computing, pages 93-99, </note> <year> 1997. </year>
Reference-contexts: This general lower bound cannot be improved, since cons (n-consensus m ) = fi (n p However, a stronger bound will be derived for the class of readable objects in Section 3. A readable object <ref> [10] </ref> is one that is equipped with read operations that allow processes to read the object's state without altering it. For a readable type T with cons (T ) &gt; 2, it will be shown that cons (T m ) = (cons (T ) m). <p> Hence, this is a direct implementation of the team (n 1 ; n 2 ) object. 2 The converse of Lemma 2 is a special case of the following lemma, whose proof makes use of a tournament algorithm. Lemma 3 <ref> [10] </ref> Suppose objects of type T and registers can be used to solve the team (n 1 ; n 2 ) problem for some positive integers n 1 and n 2 . <p> A readable object is called n-universal <ref> [10] </ref> if a set of n processes can be partitioned into two non-empty teams and a single operation can be assigned to each process so that if any group of processes each perform their own operation on an appropriately initialized object X of type T , then each process in the <p> 2 ) problem can be solved, for some positive integers n 1 and n 2 that sum to n, by a protocol that uses a single object of type T and two registers, in which each process performs exactly one update operation on the object of type T . (See <ref> [10] </ref> for more details.) It was shown in [10] that the property of being n-universal characterizes the readable object types that have consensus number at least n. Theorem 7 [10] A readable type can be used with registers to solve consensus among n processes if and only if it is n-universal. <p> positive integers n 1 and n 2 that sum to n, by a protocol that uses a single object of type T and two registers, in which each process performs exactly one update operation on the object of type T . (See <ref> [10] </ref> for more details.) It was shown in [10] that the property of being n-universal characterizes the readable object types that have consensus number at least n. Theorem 7 [10] A readable type can be used with registers to solve consensus among n processes if and only if it is n-universal. <p> T and two registers, in which each process performs exactly one update operation on the object of type T . (See <ref> [10] </ref> for more details.) It was shown in [10] that the property of being n-universal characterizes the readable object types that have consensus number at least n. Theorem 7 [10] A readable type can be used with registers to solve consensus among n processes if and only if it is n-universal. This characterization will now be used to prove a better lower bound on the consensus numbers of readable multi-objects. <p> Consider the readable object type T n defined in <ref> [10] </ref>, which behaves like a readable version of a binary consensus object that gets reset to the state ? once every n + 1 operations. The state set of T n is the set Q = f?g [ (fA; Bg fi f1; : : : ; ng). <p> the second component of X return ack end proposeA proposeB (X) if X = ? then X (B; 1) else % X is an ordered pair if X's second component is n then X ? else increment the second component of X return ack end proposeB It was shown in <ref> [10] </ref> that the consensus number of T n is n. The following proposition demonstrates that the bound given in Theorem 8 is tight. Proposition 10 Let n &gt; 1. For the readable object type T n defined above, cons (T m n ) = fi (nm). <p> This type's state set will be the disjoint union of the state sets of the types toggle and T n . Because the consensus hierarchy is robust for readable objects <ref> [10] </ref>, cons (toggle _ T n ) = max (cons (toggle); cons (T n )) = n. However, since an object of type toggle _T n can simulate a toggle object, cons ((toggle _ T n ) m ) = 1 for all m &gt; 1.
References-found: 10

