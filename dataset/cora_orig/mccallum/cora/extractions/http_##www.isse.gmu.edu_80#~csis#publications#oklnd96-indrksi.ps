URL: http://www.isse.gmu.edu:80/~csis/publications/oklnd96-indrksi.ps
Refering-URL: http://www.isse.gmu.edu:80/~csis/publication.html
Root-URL: 
Email: fpammann,jajodia,indrakshig@isse.gmu.edu  
Title: Ensuring Atomicity of Multilevel Transactions  
Author: Paul Ammann Sushil Jajodia Indrakshi Ray 
Address: Fairfax, VA 22030-4444  
Affiliation: Center for Secure Information Systems and Department of Information and Software Systems Engineering George Mason University  
Abstract: Ensuring atomicity is a major outstanding problem with present methods of handling multilevel transactions. The chief difficulty is that a high section of a transaction may be unable to complete due to violations of the integrity constraints, and a rollback of sections can be exploited to implement a covert channel. We define a notion of semantic atomicity which guarantees that either all or none of the sections of a transaction are present in any history. The notion of correct executions in our model is based on semantic correctness that is, maintenance of integrity constraints - rather than serializability. We give a method whereby the application developer can statically analyze the set of transactions in the application and determine if the set ensures semantic atomicity and other desirable properties. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. R. </author> <title> Abrial. B-Technology Technical Overview. </title> <publisher> B-Core(UK) Ltd., </publisher> <address> The Oxford Science Park, Oxford, UK, </address> <year> 1993. </year>
Reference-contexts: For future work, we intend to automate to the extent possible the process of generating and discharging the proof obligations for a given application. Industrial-level tool support for such an endeavor is essential, and we are investigating the use of the B Method <ref> [1] </ref> to this end.
Reference: [2] <author> P. Ammann, S. Jajodia, and I. Ray. </author> <title> Using formal methods to reason about semantics-based decomposition of transactions. </title> <booktitle> In Proceedings of the Twenty-First International Conference On Very Large Databases, </booktitle> <pages> pages 218-227, </pages> <address> Zurich, Switzer-land, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Room 128 U navailable (a) Table ST AT U S room guests Room 2 Lafayette . . . Room 128 Hemingway (b) Table GU EST applications with long-duration transactions <ref> [2, 8, 9, 11] </ref>. The organization of the paper is as follows. The next section outlines an example that is used to illustrate the rest of the paper. Section 3 explains the advantages of a semantic approach to atomicity. <p> The mission example has exactly the same formal structure as the hotel example. The analyses of the examples given in this paper are informal, but a formalization of related analyses for non-secure applications is given using the Z specification language in <ref> [2] </ref>. The advantage of formalization is that greater assurance can be obtained that the necessary properties do indeed hold. For future work, we intend to automate to the extent possible the process of generating and discharging the proof obligations for a given application.
Reference: [3] <author> D. E. Bell and L. J. LaPadula. </author> <title> Secure computer system: Unified exposition and multics interpretation. </title> <type> Technical Report MTR-2997, </type> <institution> MITRE Corporation, Bedford, </institution> <address> MA, </address> <month> July </month> <year> 1975. </year>
Reference-contexts: A fixed security level is associated with a single-level transaction, which can read objects that are at its level or below, but can only write those objects that are at its level. y These restrictions correspond to the simple security property and the restricted ?-property of the Bell-LaPadula model <ref> [3] </ref> and ensure that no illegal direct information flows occur across security levels. fl This work was partially supported by grants from the National Science Foundation grant numbers CCR-9202270 and IRI-9303416, by a grant from ARPA, administered by the Office of Naval Research under grant number N0014-92-J-4038,and by National Security Agency <p> Definition 2 [Multilevel Transaction] A multilevel transaction T i is a set of read and write operations in which conflicting operations [4] are ordered by the relation t i . To prevent direct violations of the usual mandatory access control policy <ref> [3] </ref> by a multilevel transaction, we follow other authors [7, 6, 12] and decompose each multilevel transaction into a set of sections, where each section is associated with a single security level.
Reference: [4] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concur-rency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: The limitation of Low-First is that it cannot make any guarantees with respect to the atomicity of the multilevel transaction. All previous work on multilevel transactions [5, 6, 7, 12] relies on the standard conflict-serializability <ref> [4] </ref> as the correctness criterion. The problem with these approaches is that complete atomicity cannot be guaranteed. Our contribution is to propose an alternative semantic-based model for multilevel secure transactions. Our model uses the notion of multilevel semantic histories to reason about correct interleavings of sections. <p> However, for the reasons outlined in the introduction, we permit a transaction to read and write data at a range of levels. Definition 2 [Multilevel Transaction] A multilevel transaction T i is a set of read and write operations in which conflicting operations <ref> [4] </ref> are ordered by the relation t i . <p> Semantic histories are sec-tionwise serial histories in which sections of different transactions are executed serially. There is a straightforward extension to the case of concurrent execution, where any multilevel history that is conflict equivalent <ref> [4] </ref> to a correct multilevel semantic history is acceptable. Consider a Reserve transaction T 1 and a Cancel transaction T 2 of example 3.
Reference: [5] <author> B. T. Blaustein, S. Jajodia, C. D. McCollum, and L. Notar-giacomo. </author> <title> A model of atomicity for multilevel transactions. </title> <booktitle> In Proc. of the IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 120-134, </pages> <address> Oakland, CA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Modeling such an application with a decomposition into a set of independent single-level sections is undesirable for two reasons. First, it forces the user to manage the scheduling of the single-level sections. Even worse, interleavings with other transactions may produce incorrect results. Consequently, multilevel transactions <ref> [5, 6, 7, 12] </ref> have been proposed to overcome this difficulty. A multilevel transaction permits read and write operations across a range of security levels to be executed as an atomic unit. Atomicity ensures that after the completion of a multilevel transaction either all its changes persist or none do. <p> To limit the size of the trusted code, a multilevel transaction is usually decomposed into a collection of single-level subtransactions called sections. The interactions between the sections can be analyzed to determine the presence of any illegal information flows across security levels <ref> [5] </ref>. If there are no illegal information flows, then the sections may be executed as atomic units. Costich and McDermott describe a transaction processing algorithm for the replicated architecture in [7], and Costich and Jajodia give one for the kernelized architecture in [6]. <p> However, attempts to reexecute S i2 may fail again. For example, the preconditions of S i2 may not be satisfied because of integrity constraint violations. The point is that the atomicity of the multilevel transaction T i cannot be ensured. Blaustein et al. <ref> [5, 12] </ref> define different degrees of atom-icity - ML atomicity, L-atomicity, and complete atomicity. The most stringent, complete atomicity, corresponds to traditional atomicity. [5] also gives two transaction processing algorithms - High-Ready-Wait and Low-First. The High-Ready-Wait algorithm is a two-phased algorithm. <p> The point is that the atomicity of the multilevel transaction T i cannot be ensured. Blaustein et al. [5, 12] define different degrees of atom-icity - ML atomicity, L-atomicity, and complete atomicity. The most stringent, complete atomicity, corresponds to traditional atomicity. <ref> [5] </ref> also gives two transaction processing algorithms - High-Ready-Wait and Low-First. The High-Ready-Wait algorithm is a two-phased algorithm. <p> Unlike High-Ready-Wait, Low-First executes and commits sections of a multilevel transaction in a low to high order. The limitation of Low-First is that it cannot make any guarantees with respect to the atomicity of the multilevel transaction. All previous work on multilevel transactions <ref> [5, 6, 7, 12] </ref> relies on the standard conflict-serializability [4] as the correctness criterion. The problem with these approaches is that complete atomicity cannot be guaranteed. Our contribution is to propose an alternative semantic-based model for multilevel secure transactions. <p> In the following paragraphs we explain how to solve this problem. First, we need the notion of dependencies from <ref> [5] </ref>. A dependency exists between two sections if they contain conflicting operations. There can be two types of dependencies between sections of a transaction, depending on the ordering of operations in the underlying multilevel transaction. 1. <p> The importance of the methods for treating H-L and L-H dependencies is that any multilevel transaction can be converted to canonical form and securely executed with the Low-First algorithm. In prior work, this transformation yielded only ML-atomicity <ref> [5] </ref>; our result is to achieve semantic atomicity, where either all or none of the sections are executed. 5. Semantic Correctness We define a database from a semantic perspective. A database is specified as a collection of objects, along with some invariants or integrity constraints on these objects.
Reference: [6] <author> O. Costich and S. Jajodia. </author> <title> Maintaining multilevel transaction atomicity in multilevel secure database systems with kernel-ized architecture. </title> <editor> In B. Thuraisingham and C. Landwehr, editors, </editor> <booktitle> Database Security VI: Status and Prospects, </booktitle> <pages> pages 249-265. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1993. </year>
Reference-contexts: By definition, a single-level transaction prevents operations at different levels from being grouped as an atomic transaction. This is a serious limitation in many applications. Consider the example, adapted from <ref> [6, 7] </ref>, of a satellite that gathers and writes various data in a multilevel secure database. <p> Modeling such an application with a decomposition into a set of independent single-level sections is undesirable for two reasons. First, it forces the user to manage the scheduling of the single-level sections. Even worse, interleavings with other transactions may produce incorrect results. Consequently, multilevel transactions <ref> [5, 6, 7, 12] </ref> have been proposed to overcome this difficulty. A multilevel transaction permits read and write operations across a range of security levels to be executed as an atomic unit. Atomicity ensures that after the completion of a multilevel transaction either all its changes persist or none do. <p> If there are no illegal information flows, then the sections may be executed as atomic units. Costich and McDermott describe a transaction processing algorithm for the replicated architecture in [7], and Costich and Jajodia give one for the kernelized architecture in <ref> [6] </ref>. A limitation of both these works, however, is that they are based on the optimistic assumption that if any low section commits, all other sections in the multilevel transaction must also commit (see Section 3 for a complete discussion). <p> Unlike High-Ready-Wait, Low-First executes and commits sections of a multilevel transaction in a low to high order. The limitation of Low-First is that it cannot make any guarantees with respect to the atomicity of the multilevel transaction. All previous work on multilevel transactions <ref> [5, 6, 7, 12] </ref> relies on the standard conflict-serializability [4] as the correctness criterion. The problem with these approaches is that complete atomicity cannot be guaranteed. Our contribution is to propose an alternative semantic-based model for multilevel secure transactions. <p> The basic requirement on such algorithms is that sections are not aborted for concurrency control reasons. Costich and Jajodia describe a multiversion timestamping algorithm that satisfies this requirement <ref> [6] </ref>. The basic idea is that when a section of a transaction begins at a given security level, the set of data elements that the section reads is compared with the set of data elements to be written by transactions with earlier timestamps. <p> To prevent direct violations of the usual mandatory access control policy [3] by a multilevel transaction, we follow other authors <ref> [7, 6, 12] </ref> and decompose each multilevel transaction into a set of sections, where each section is associated with a single security level. To keep our model simple, we assume that a transaction has at most one section at any security level. <p> However, in our model, which uses semantic correctness rather than serializability, database consistency is not automatically ensured. The following example helps to illustrate this point. Example 5 [Complete Multilevel Semantic History Leaves Database In An Inconsistent State] Consider the satellite example cited in <ref> [6, 7] </ref>. The satellite report transaction takes as input position data, and sensor data. The position data indicates the position of the satellite and is of level unclassified U. The sensor data is the information received from its sensor. The level of sensor data is secret S. <p> Not all applications can be implemented by our model. The satellite report application <ref> [6, 7] </ref> is one such example. Example 5 shows that the satellite application lacks the consistent execution property. If a developer wishes to implement this application with our model, then the semantics of the application must be revised until the necessary properties are satisfied.
Reference: [7] <author> O. Costich and J. McDermott. </author> <title> A multilevel transaction problem for multilevel secure database system and its solution for the replicated architecture. </title> <booktitle> In Proceedings of the IEEE Symposium on Researchin Security and Privacy, </booktitle> <pages> pages 192-203, </pages> <address> Oakland, CA, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: By definition, a single-level transaction prevents operations at different levels from being grouped as an atomic transaction. This is a serious limitation in many applications. Consider the example, adapted from <ref> [6, 7] </ref>, of a satellite that gathers and writes various data in a multilevel secure database. <p> Modeling such an application with a decomposition into a set of independent single-level sections is undesirable for two reasons. First, it forces the user to manage the scheduling of the single-level sections. Even worse, interleavings with other transactions may produce incorrect results. Consequently, multilevel transactions <ref> [5, 6, 7, 12] </ref> have been proposed to overcome this difficulty. A multilevel transaction permits read and write operations across a range of security levels to be executed as an atomic unit. Atomicity ensures that after the completion of a multilevel transaction either all its changes persist or none do. <p> If there are no illegal information flows, then the sections may be executed as atomic units. Costich and McDermott describe a transaction processing algorithm for the replicated architecture in <ref> [7] </ref>, and Costich and Jajodia give one for the kernelized architecture in [6]. <p> Unlike High-Ready-Wait, Low-First executes and commits sections of a multilevel transaction in a low to high order. The limitation of Low-First is that it cannot make any guarantees with respect to the atomicity of the multilevel transaction. All previous work on multilevel transactions <ref> [5, 6, 7, 12] </ref> relies on the standard conflict-serializability [4] as the correctness criterion. The problem with these approaches is that complete atomicity cannot be guaranteed. Our contribution is to propose an alternative semantic-based model for multilevel secure transactions. <p> To prevent direct violations of the usual mandatory access control policy [3] by a multilevel transaction, we follow other authors <ref> [7, 6, 12] </ref> and decompose each multilevel transaction into a set of sections, where each section is associated with a single security level. To keep our model simple, we assume that a transaction has at most one section at any security level. <p> Definition 7 [Canonical Form] A transaction T i is in canonical form if for all j; k, S ij i S ik iff L (S ij ) &lt; L (S ik ). Our canonical form is a partial order i of sections in contrast to <ref> [7] </ref> where canonical form is defined as a total order of sections. The importance of the methods for treating H-L and L-H dependencies is that any multilevel transaction can be converted to canonical form and securely executed with the Low-First algorithm. <p> However, in our model, which uses semantic correctness rather than serializability, database consistency is not automatically ensured. The following example helps to illustrate this point. Example 5 [Complete Multilevel Semantic History Leaves Database In An Inconsistent State] Consider the satellite example cited in <ref> [6, 7] </ref>. The satellite report transaction takes as input position data, and sensor data. The position data indicates the position of the satellite and is of level unclassified U. The sensor data is the information received from its sensor. The level of sensor data is secret S. <p> Not all applications can be implemented by our model. The satellite report application <ref> [6, 7] </ref> is one such example. Example 5 shows that the satellite application lacks the consistent execution property. If a developer wishes to implement this application with our model, then the semantics of the application must be revised until the necessary properties are satisfied. <p> If a developer wishes to implement this application with our model, then the semantics of the application must be revised until the necessary properties are satisfied. Of course, the given semantics can be assured if serializability is the correctness criterion <ref> [7] </ref>. When the hotel example was introduced, we asserted that its formal structure was equivalent to a military-oriented example. Consider a mission database that maintains information about asset (troops, aircraft, etc.) to threat assignments.
Reference: [8] <author> A. A. Farrag and M. T. Ozsu. </author> <title> Using semantic knowledge of transactions to increase concurrency. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(4) </volume> <pages> 503-525, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Room 128 U navailable (a) Table ST AT U S room guests Room 2 Lafayette . . . Room 128 Hemingway (b) Table GU EST applications with long-duration transactions <ref> [2, 8, 9, 11] </ref>. The organization of the paper is as follows. The next section outlines an example that is used to illustrate the rest of the paper. Section 3 explains the advantages of a semantic approach to atomicity.
Reference: [9] <author> H. Garcia-Molina. </author> <title> Using semantic knowledge for transaction processing in a distributed database. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 8(2) </volume> <pages> 186-213, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: Room 128 U navailable (a) Table ST AT U S room guests Room 2 Lafayette . . . Room 128 Hemingway (b) Table GU EST applications with long-duration transactions <ref> [2, 8, 9, 11] </ref>. The organization of the paper is as follows. The next section outlines an example that is used to illustrate the rest of the paper. Section 3 explains the advantages of a semantic approach to atomicity. <p> In some cases this is problematic. For example, a multilevel transaction may output data to users; these transactions are referred to as sensitive transactions in <ref> [9] </ref>. Consider the following example. Example 6 [Sensitive Transaction Views Inconsistent State] Let us once again consider the basic hotel example. Reserve is as in example 3. <p> S 11 , S 12 are the two sections of the Reserve transaction T 1 ; S 21 , S 22 are the two sections of the Cancel transaction. The Reserve transaction T 1 reserves -Garcia-Molina <ref> [9] </ref> has a slightly different definition of semantic atom-icity, in that he allows for compensating steps. Compensation is problematic from the security perspective, so we omit it here. (a) SG (H 4 ) (b) SG (H 6 ) a room for J ohn.
Reference: [10] <author> T. F. Keefe and W. T. Tsai. </author> <title> Multilevel concurrency control for multilevel secure database systems. </title> <booktitle> In Proceedings of the IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 369-383, </pages> <address> Oakland, CA, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: occur across security levels. fl This work was partially supported by grants from the National Science Foundation grant numbers CCR-9202270 and IRI-9303416, by a grant from ARPA, administered by the Office of Naval Research under grant number N0014-92-J-4038,and by National Security Agency under contract number MDA904-94-C-6118. y Keefe and Tsai <ref> [10] </ref> use a slightly more general model in which the single-level transactions are allowed to write to objects that are at or above its level. By definition, a single-level transaction prevents operations at different levels from being grouped as an atomic transaction. This is a serious limitation in many applications.
Reference: [11] <author> H. F. Korth and G. Speegle. </author> <title> Formal aspects of concurrency control in long-duration transaction systems using the NT/PV model. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(3) </volume> <pages> 492-535, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Room 128 U navailable (a) Table ST AT U S room guests Room 2 Lafayette . . . Room 128 Hemingway (b) Table GU EST applications with long-duration transactions <ref> [2, 8, 9, 11] </ref>. The organization of the paper is as follows. The next section outlines an example that is used to illustrate the rest of the paper. Section 3 explains the advantages of a semantic approach to atomicity.
Reference: [12] <author> K. P. Smith, B. T. Blaustein, S. Jajodia, and L. Notargiacomo. </author> <title> Correctness criteria for multilevel secure transactions. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 8(1), </volume> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: Modeling such an application with a decomposition into a set of independent single-level sections is undesirable for two reasons. First, it forces the user to manage the scheduling of the single-level sections. Even worse, interleavings with other transactions may produce incorrect results. Consequently, multilevel transactions <ref> [5, 6, 7, 12] </ref> have been proposed to overcome this difficulty. A multilevel transaction permits read and write operations across a range of security levels to be executed as an atomic unit. Atomicity ensures that after the completion of a multilevel transaction either all its changes persist or none do. <p> However, attempts to reexecute S i2 may fail again. For example, the preconditions of S i2 may not be satisfied because of integrity constraint violations. The point is that the atomicity of the multilevel transaction T i cannot be ensured. Blaustein et al. <ref> [5, 12] </ref> define different degrees of atom-icity - ML atomicity, L-atomicity, and complete atomicity. The most stringent, complete atomicity, corresponds to traditional atomicity. [5] also gives two transaction processing algorithms - High-Ready-Wait and Low-First. The High-Ready-Wait algorithm is a two-phased algorithm. <p> Unlike High-Ready-Wait, Low-First executes and commits sections of a multilevel transaction in a low to high order. The limitation of Low-First is that it cannot make any guarantees with respect to the atomicity of the multilevel transaction. All previous work on multilevel transactions <ref> [5, 6, 7, 12] </ref> relies on the standard conflict-serializability [4] as the correctness criterion. The problem with these approaches is that complete atomicity cannot be guaranteed. Our contribution is to propose an alternative semantic-based model for multilevel secure transactions. <p> To prevent direct violations of the usual mandatory access control policy [3] by a multilevel transaction, we follow other authors <ref> [7, 6, 12] </ref> and decompose each multilevel transaction into a set of sections, where each section is associated with a single security level. To keep our model simple, we assume that a transaction has at most one section at any security level. <p> Definition 5 [Read First Property] Sections in a multilevel transaction T i enjoy the read first property if for each pair of sections with a H-L Dependency, the high section reads the value x has immediately before the low section overwrites x x . We adopt a caching technique <ref> [12] </ref> as the mechanism to satisfy the read first and the internal reads property. The cache is local to the transaction; it is visible only to sections of a single transaction.
References-found: 12

