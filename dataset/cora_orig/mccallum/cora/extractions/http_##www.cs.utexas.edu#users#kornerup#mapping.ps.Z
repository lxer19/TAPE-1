URL: http://www.cs.utexas.edu/users/kornerup/mapping.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/kornerup/kornerup-papers.html
Root-URL: 
Title: Mapping a Functional Notation for Parallel Programs onto Hypercubes  
Author: Jacob Kornerup 
Keyword: Program derivation; Parallel algorithms; Functional programming; Programming calculi; Hypercubes; Prefix sum  
Address: Austin, Austin, TX 78712-1168, USA 2  
Affiliation: Department of Computer Sciences, The University of Texas at  
Abstract: The theory of powerlists was recently introduced by Jayadev Misra [7]. Powerlists can be used to specify and verify certain parallel algorithms, using a notation similar to functional programming languages. In contrast to sequential languages the powerlist notation has constructs for expressing balanced divisions of lists. We study how Prefix Sum, a fundamental parallel algorithm, can be tailored for efficient execution on hypercubic architectures. Then we derive a strategy for mapping most powerlist functions to efficient programs for hypercubic architectures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. S. Bird: </author> <title> "Lectures on Constructive Functional Programming", in "Constructive Methods in Computer Science", edited by Manfred Broy, </title> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: The only way to access the elements of a list is to break down the list using ./ and j as deconstructors. 2 The law relating zip and tie is called Commutativity (Richard Bird <ref> [1] </ref> calls this property abides): (p j q) ./ (u j v) = (p ./ u) j (q ./ v) Functions are defined using pattern matching known from functional programming languages such as ML [5] and Miranda TM [8].
Reference: [2] <author> J. Kornerup: </author> <title> "Mapping Powerlists onto Hypercubes", </title> <type> Technical Report TR94-05, </type> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <year> 1994. </year>
Reference-contexts: It can be proven <ref> [2] </ref> that: (G:u) = G:(u ? ) It can also be proven that j can be implemented efficiently under Gray coding [2], and thus we have shown that under Gray coding the fundamental operators and some derived operators have efficient implementation on the hypercube. <p> It can be proven <ref> [2] </ref> that: (G:u) = G:(u ? ) It can also be proven that j can be implemented efficiently under Gray coding [2], and thus we have shown that under Gray coding the fundamental operators and some derived operators have efficient implementation on the hypercube. From this it does not follow that all powerlist functions can be implemented as efficiently on a hypercube as on a CREW PRAM. <p> Gray coded operators we can define the Gray coded version of Ladner and Fischer's algorithm: P S G :(p ./ G q) = r ? G p ./ G r where r = P S G :(p q) As was the case for the ? operator it can be proven <ref> [2] </ref>: P S G ffi G = G ffi P S obtaining an efficient implementation of Ladner and Fischer's algorithm for hypercubic architectures. 10 6 Conclusion By using a notation that is free from indexing and other cluttering notions we were able to derive an algorithm for computing the prefix sum
Reference: [3] <author> F. T. Leighton: </author> <title> "Introduction to Parallel Algorithms and Architectures", </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1992. </year>
Reference-contexts: The nodes from the first cube all obtain a zero bit in the fixed position, whereas the nodes from the second cube obtain a one bit. The hypercube topology is very versatile, most other architectures can be embedded on the hypercube; Leighton <ref> [3] </ref> shows a number of these embeddings.
Reference: [4] <author> R. E. Ladner and M. J. Fischer: </author> <title> "Parallel prefix computation", </title> <journal> Journal of the ACM, </journal> <volume> 27 </volume> <pages> 831-838, </pages> <year> 1980. </year>
Reference-contexts: operation): hai ? = h0i The prefix sum of a list r, P S:r, can be specified [7] as the unique solution to the equation (in z): z : z = z ? r A well known algorithm for computing the prefix sum is due to Ladner and 5 Fischer <ref> [4] </ref>. In the powerlist notation it can be written as [7]: P S:(p ./ q) = t ? p ./ t where t = P S:(p q) It is a worthwhile exercise for the reader to prove that the Ladner and Fischer algorithm is a solution to the above equation.
Reference: [5] <author> R. Milner, M. Tofte and R. Harper: </author> <title> "The Definition of standard ML", </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: and j as deconstructors. 2 The law relating zip and tie is called Commutativity (Richard Bird [1] calls this property abides): (p j q) ./ (u j v) = (p ./ u) j (q ./ v) Functions are defined using pattern matching known from functional programming languages such as ML <ref> [5] </ref> and Miranda TM [8].
Reference: [6] <author> E. W. Mayr and G. Plaxton: </author> <title> "Pipelined Parallel Computations, and Sorting on a Pipelined Hypercube" Technical Report STAN-CS-89-1261, </title> <institution> Department of Computer Science, Stanford University, </institution> <year> 1989. </year>
Reference-contexts: This algorithm is well known in the literature <ref> [6] </ref>, and is considered as part of the folklore; its close connection to the algorithm by Ladner and Fischer is interesting. 5 Mapping Powerlists onto Hypercubes So far we have studied the standard encoding of powerlists onto hypercubes.
Reference: [7] <author> J. Misra: "Powerlists: </author> <title> A Structure for Parallel Recursion", </title> <note> to appear in ACM TOPLAS, </note> <year> 1994. </year>
Reference-contexts: 1 Introduction The field of parallel algorithm design has become a major area of research over the last decade. However, the field has yet to develop a standard language for expressing these algorithms. The Powerlist notation, introduced by Jayadev Misra <ref> [7] </ref>, gives us a succinct representation of a certain class of parallel algorithms, amenable to algebraic proofs of correctness. <p> The Powerlist notation <ref> [7] </ref> uses balanced division of lists in order to allow for parallel processing. We will give a brief introduction to the notation, and refer the reader to [7] for further reading. A powerlist is a list of length equal to a nonnegative power of two. <p> The Powerlist notation <ref> [7] </ref> uses balanced division of lists in order to allow for parallel processing. We will give a brief introduction to the notation, and refer the reader to [7] for further reading. A powerlist is a list of length equal to a nonnegative power of two. The elements of the list are all of the same type and size, either scalars (uninterpreted values from outside the theory) or powerlists themselves. <p> The operator ? on powerlists shifts the elements of the list one position to the right and adds a zero in the leftmost position (the rightmost element is lost by this operation): hai ? = h0i The prefix sum of a list r, P S:r, can be specified <ref> [7] </ref> as the unique solution to the equation (in z): z : z = z ? r A well known algorithm for computing the prefix sum is due to Ladner and 5 Fischer [4]. In the powerlist notation it can be written as [7]: P S:(p ./ q) = t ? <p> list r, P S:r, can be specified <ref> [7] </ref> as the unique solution to the equation (in z): z : z = z ? r A well known algorithm for computing the prefix sum is due to Ladner and 5 Fischer [4]. In the powerlist notation it can be written as [7]: P S:(p ./ q) = t ? p ./ t where t = P S:(p q) It is a worthwhile exercise for the reader to prove that the Ladner and Fischer algorithm is a solution to the above equation.
Reference: [8] <author> D. Turner: </author> <title> "An overview of Miranda", </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21 </volume> <pages> 156-166, </pages> <year> 1986. </year>
Reference-contexts: 2 The law relating zip and tie is called Commutativity (Richard Bird [1] calls this property abides): (p j q) ./ (u j v) = (p ./ u) j (q ./ v) Functions are defined using pattern matching known from functional programming languages such as ML [5] and Miranda TM <ref> [8] </ref>.
References-found: 8

