URL: http://www.cs.cornell.edu/jyh/papers/predicative_objects.ps
Refering-URL: http://www.cs.cornell.edu/jyh/cornell-papers.html
Root-URL: 
Title: A Predicative Type-Theoretic Interpretation of Objects  
Author: Jason J. Hickey 
Affiliation: Department of Computer Science Cornell University  
Abstract: Predicative type theories are powerful tools for giving foundational interpretations of programming languages. Due to their explicit inductive construction, predicative type theories have multiple mathematical models that provide precise definitions of programming language features. However, not all features have predicative interpretations, and current interpretations of objects rely on impredicative type theories, such as Girard's System F, because of the difficulty in specifying a type for objects in the presence of self-application. In this paper we show that objects have a predicative interpretation. We show that predicativity is associated with method monotonicity, and that binary methods prevent the inductive type construction. Our interpretation differs from impredicative accounts by replacing the use of recursive types for objects with conditions for method poly-morphism over the self type. We further give a propositional meaning to objects in the type theory, providing a calculus for formal verification. Our interpretation has been verified in the Nuprl predicative type theory. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: Self application occurs during method selection when the entire object is passed to the method as an implicit "self" argument. Recent type-theoretic accounts of objects <ref> [1, 21, 5, 10] </ref> have been encoded in impredicative type theory (mainly variants of Girard's System F [9]), which allow self-application through an impredicative interpretation of the self parameter. In this paper, we show that the construction of objects has an interpretation in predicative type theory. <p> A formal proof of soundness is available online. In our interpretation, object types have propositional meaning. We further extend the calculus with dependent method types to provide a basis for formal program analysis. We develop our account on the object calculus of Abadi et al. <ref> [1, 2] </ref>, which gives a precise characterization of self application and method override. We show that the type system can be developed without the use of recursive types or weak sums, and without sacrificing subtyping properties. <p> While these object calculi are simple and precise, they allow representations of class-based and object-based concepts, as shown by Abadi and Cardelli in the "Theory of Objects" <ref> [1] </ref>.
Reference: [2] <author> Martn Abadi, Luca Cardelli, and Ramesh Viswan-athan. </author> <title> An Interpretation of Objects and Object Types. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1996. </year>
Reference-contexts: A formal proof of soundness is available online. In our interpretation, object types have propositional meaning. We further extend the calculus with dependent method types to provide a basis for formal program analysis. We develop our account on the object calculus of Abadi et al. <ref> [1, 2] </ref>, which gives a precise characterization of self application and method override. We show that the type system can be developed without the use of recursive types or weak sums, and without sacrificing subtyping properties. <p> Method type dependencies are expressed using dependent records based on the very-dependent function type [11], and method polymorphism over subtypes is expressed using intersection types. 2 Review The formalism we use for objects in this paper is a functional object calculus similar to the calculus of Abadi, Cardelli, and Viswanathan <ref> [2] </ref>, in which the only primitives are objects, method invocation, and method update. While these object calculi are simple and precise, they allow representations of class-based and object-based concepts, as shown by Abadi and Cardelli in the "Theory of Objects" [1]. <p> We adopt the method of variance annotations <ref> [2] </ref>, where method labels are annotated with the symbols ( + , , ffi ), which are intended to provide the extra information.
Reference: [3] <author> Stuart F. Allen. </author> <title> The Semantics of Type Theoretic Languages. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> August </month> <year> 1986. </year>
Reference-contexts: provided by the Office of Naval Research through grant N00014-92-J-1764, from the National Science Foundation through grant CCR-9244739, from DARPA through grant 93-11-271, and from AASERT through grant N00014-95-1-0985. ticular, the Nuprl type theory that we use in this paper has multiple mathematical models, notably set theoretic [17], PER models <ref> [3, 20] </ref>, denotational models [23], and others. In addition, our interpretation is extendable to foundational formal objects that encode proofs [15, 11], a critical step toward our goal of providing a modular and object-oriented logical framework [12]. The object interpretation is more delicate but we get more information.
Reference: [4] <author> Stuart F. Allen. </author> <title> A non-type-theoretic definition of Martin-Lof's types. </title> <booktitle> In Proceedings of the Second Conference on Logic in Computer Science, </booktitle> <pages> pages 215-224, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: The object interpretation is more delicate but we get more information. For example, predicative theories have a strictly inductive construction <ref> [19, 4] </ref>, so the account of objects is inductive. An interesting feature is that impred-icative type recursion is replaced by method polymorphism. The explicit inductive construction is also valid in impred-icative type theory.
Reference: [5] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing, and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 127-206, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Self application occurs during method selection when the entire object is passed to the method as an implicit "self" argument. Recent type-theoretic accounts of objects <ref> [1, 21, 5, 10] </ref> have been encoded in impredicative type theory (mainly variants of Girard's System F [9]), which allow self-application through an impredicative interpretation of the self parameter. In this paper, we show that the construction of objects has an interpretation in predicative type theory.
Reference: [6] <author> Adriana B. Compagnoni and Benjamin C. Pierce. </author> <title> Intersection types and multiple inheritance. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: Their interpretation uses an existential encoding of objects [21, 16] in an impredicative type theory. Although the existential encoding restricts method update, the interpretation of objects does not require the use of recursive types, allowing the development of expressive type systems <ref> [6, 14] </ref>. The interpretation of object relies on a restricted sub-typing relation (we use notation ) to describe valid sub-objects. This is important because the general subtype relation would disallow updates. Our restricted subtyping is essentially the same as the positive subtyping of Hofmann and Pierce [14].
Reference: [7] <author> Karl Crary. </author> <title> Recursive computation in foundational type theory. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, Forthcoming. </institution>
Reference-contexts: However, with the introduction of recursive methods, a formal account of totality would require a specification of all the intermediate computations. Our account of partial objects is based on the partial types of Smith [25], which have been simplified by Crary <ref> [7] </ref>. A partial type, denoted T , contains a term x if the evaluation of x diverges, or if x is an element of T . The induction principle for partial types relies on an admissiblity condition, which holds for the types in our calculus.
Reference: [8] <author> K. Fisher, F. Honsell, and J.C. Mitchell. </author> <title> A lambda calculus of objects and method specialization. </title> <journal> Nordic J. Computing ( formerly BIT), </journal> <volume> 1 </volume> <pages> 3-37, </pages> <year> 1994. </year> <note> Preliminary version appeared in Logic in Computer Science, </note> <year> 1993, </year> <pages> 26-38. </pages>
Reference: [9] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'a rithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Self application occurs during method selection when the entire object is passed to the method as an implicit "self" argument. Recent type-theoretic accounts of objects [1, 21, 5, 10] have been encoded in impredicative type theory (mainly variants of Girard's System F <ref> [9] </ref>), which allow self-application through an impredicative interpretation of the self parameter. In this paper, we show that the construction of objects has an interpretation in predicative type theory. This is a stronger result because predicative theories make fewer assumptions and have more models.
Reference: [10] <editor> Carl A. Gunter and John C. Mitchell, editors. </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year> <pages> 1 - 7 </pages>
Reference-contexts: Self application occurs during method selection when the entire object is passed to the method as an implicit "self" argument. Recent type-theoretic accounts of objects <ref> [1, 21, 5, 10] </ref> have been encoded in impredicative type theory (mainly variants of Girard's System F [9]), which allow self-application through an impredicative interpretation of the self parameter. In this paper, we show that the construction of objects has an interpretation in predicative type theory.
Reference: [11] <author> Jason J. Hickey. </author> <title> Formal objects in type theory us-ing very dependent types. </title> <booktitle> In Foundations of Object Oriented Languages 3, </booktitle> <year> 1996. </year> <note> Available electronically through the FOOL 3 home page at Williams College. </note>
Reference-contexts: In addition, our interpretation is extendable to foundational formal objects that encode proofs <ref> [15, 11] </ref>, a critical step toward our goal of providing a modular and object-oriented logical framework [12]. The object interpretation is more delicate but we get more information. For example, predicative theories have a strictly inductive construction [19, 4], so the account of objects is inductive. <p> We show that the type system can be developed without the use of recursive types or weak sums, and without sacrificing subtyping properties. Method type dependencies are expressed using dependent records based on the very-dependent function type <ref> [11] </ref>, and method polymorphism over subtypes is expressed using intersection types. 2 Review The formalism we use for objects in this paper is a functional object calculus similar to the calculus of Abadi, Cardelli, and Viswanathan [2], in which the only primitives are objects, method invocation, and method update. <p> i 2 f1 : : : ng Obj sub ` S = T 2 Type ` S ffi C T ffi Sub Inv ` S - C T + Sub Cov 4.1 Encoding We encode dependent object types as dependent records, which in turn are encoded as very-dependent function types <ref> [11] </ref>. Very-dependent function types allow function values to be used to specify their range, in a well-ordered manner. We use the notation ff j x: A ! B [f; x]g to specify the functions f with domain type A, and range type B [f; a] on argument a 2 A. <p> While Jackson's framework includes many of the properties of objects, the subtyping requirements prohibit the use of self-application and constrain the shape of objects. Our work has borrowed from Jackson' interpretation; in an earlier paper <ref> [11] </ref>, we presented another existential interpretation of objects in a predicative type theory, using the very dependent function type to express the type dependencies. 6 Conclusion We have given a interpretation of objects that differs from more standard accounts by replacing the use of recursive types for objects with polymorphic restrictions
Reference: [12] <author> Jason J. Hickey. Nuprl-Light: </author> <title> An implementation framework for higher-order logics. </title> <booktitle> In 14th International Conference on Automated Deduction. </booktitle> <publisher> Springer, </publisher> <year> 1997. </year>
Reference-contexts: In addition, our interpretation is extendable to foundational formal objects that encode proofs [15, 11], a critical step toward our goal of providing a modular and object-oriented logical framework <ref> [12] </ref>. The object interpretation is more delicate but we get more information. For example, predicative theories have a strictly inductive construction [19, 4], so the account of objects is inductive. An interesting feature is that impred-icative type recursion is replaced by method polymorphism. <p> It may be possible to address this issue by giving a syntactic account of polymorphism that allows the use of recursive types to define objects. We are using the interpretation in the Nuprl-Light system <ref> [12] </ref> to implement a formal module layer on top of the Objective Caml module system [22].
Reference: [13] <author> M. Hofmann, W. Naraschewski, M. Steffen, and T. Stroup. </author> <title> Inheritance of proofs. In TAPOS. </title> <publisher> Wiley, forthcoming. </publisher>
Reference-contexts: As before, the type theory justifies standard properties for the object calculus. The functionality of the type theory guarantees progress, preservation, and substitution properties. 5 Related Work Another framework for expressive object calculi is developed by Hofmann et el. <ref> [13] </ref>, who have implemented a verification calculus based on the existential interpretation of objects. In their system, objects have three parts: an object state, the object methods, and the proofs of method correctness (dependent objects with exactly one dependency).
Reference: [14] <author> M. Hofmann and B.C. Pierce. </author> <title> Positive subtyping. </title> <journal> Information and Computation, </journal> <volume> 126(1) </volume> <pages> 11-33, </pages> <year> 1996. </year> <note> Preliminary version appeared in Principles of Programming Languages, </note> <year> 1995. </year>
Reference-contexts: Their interpretation uses an existential encoding of objects [21, 16] in an impredicative type theory. Although the existential encoding restricts method update, the interpretation of objects does not require the use of recursive types, allowing the development of expressive type systems <ref> [6, 14] </ref>. The interpretation of object relies on a restricted sub-typing relation (we use notation ) to describe valid sub-objects. This is important because the general subtype relation would disallow updates. Our restricted subtyping is essentially the same as the positive subtyping of Hofmann and Pierce [14]. <p> The interpretation of object relies on a restricted sub-typing relation (we use notation ) to describe valid sub-objects. This is important because the general subtype relation would disallow updates. Our restricted subtyping is essentially the same as the positive subtyping of Hofmann and Pierce <ref> [14] </ref>. In the definition of restricted subtyping, we describe which parts of the type are not allowed to change.
Reference: [15] <author> Martin Hofmann, Wolfgang Narashewski, Martin Stef-fan, and Terry Stroup. </author> <title> Inheritance of proofs. </title> <booktitle> In Foundations of Object Oriented Languages 3, </booktitle> <year> 1996. </year> <note> Available electronically through the FOOL 3 home page at Williams College. </note>
Reference-contexts: In addition, our interpretation is extendable to foundational formal objects that encode proofs <ref> [15, 11] </ref>, a critical step toward our goal of providing a modular and object-oriented logical framework [12]. The object interpretation is more delicate but we get more information. For example, predicative theories have a strictly inductive construction [19, 4], so the account of objects is inductive.
Reference: [16] <author> Martin Hofmann and Benjamin Pierce. </author> <title> A unifying type-theoretic framework for objects. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(4) </volume> <pages> 593-635, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: In their system, objects have three parts: an object state, the object methods, and the proofs of method correctness (dependent objects with exactly one dependency). Their interpretation uses an existential encoding of objects <ref> [21, 16] </ref> in an impredicative type theory. Although the existential encoding restricts method update, the interpretation of objects does not require the use of recursive types, allowing the development of expressive type systems [6, 14].
Reference: [17] <author> Douglas J. Howe. </author> <title> Semantic foundations for embedding HOL in Nuprl. </title> <booktitle> In AMAST '96, </booktitle> <year> 1996. </year>
Reference-contexts: this research was provided by the Office of Naval Research through grant N00014-92-J-1764, from the National Science Foundation through grant CCR-9244739, from DARPA through grant 93-11-271, and from AASERT through grant N00014-95-1-0985. ticular, the Nuprl type theory that we use in this paper has multiple mathematical models, notably set theoretic <ref> [17] </ref>, PER models [3, 20], denotational models [23], and others. In addition, our interpretation is extendable to foundational formal objects that encode proofs [15, 11], a critical step toward our goal of providing a modular and object-oriented logical framework [12].
Reference: [18] <author> Paul Bernard Jackson. </author> <title> Enhancing the NuPRL Proof Development System and Applying it to Computational Abstract Algebra. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> Jan-uary </month> <year> 1995. </year>
Reference-contexts: In their account, Hofmann and Pierce use the subtyping to define an existential encoding of objects in F ! Another existential system was developed by Jackson <ref> [18] </ref> to formalize a significant portion of constructive algebra in Nuprl. While Jackson's framework includes many of the properties of objects, the subtyping requirements prohibit the use of self-application and constrain the shape of objects.
Reference: [19] <author> Per Martin-Lof. </author> <title> An intuitionistic theory of types: </title> <booktitle> Pred-icative part. In Logic Colloquium '73, </booktitle> <pages> pages 73-118. </pages> <publisher> North-Holland, </publisher> <year> 1975. </year>
Reference-contexts: The object interpretation is more delicate but we get more information. For example, predicative theories have a strictly inductive construction <ref> [19, 4] </ref>, so the account of objects is inductive. An interesting feature is that impred-icative type recursion is replaced by method polymorphism. The explicit inductive construction is also valid in impred-icative type theory.
Reference: [20] <author> Paul Francis Mendler. </author> <title> Inductive Definition in Type Theory. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> September </month> <year> 1987. </year> <pages> 87-870. </pages>
Reference-contexts: provided by the Office of Naval Research through grant N00014-92-J-1764, from the National Science Foundation through grant CCR-9244739, from DARPA through grant 93-11-271, and from AASERT through grant N00014-95-1-0985. ticular, the Nuprl type theory that we use in this paper has multiple mathematical models, notably set theoretic [17], PER models <ref> [3, 20] </ref>, denotational models [23], and others. In addition, our interpretation is extendable to foundational formal objects that encode proofs [15, 11], a critical step toward our goal of providing a modular and object-oriented logical framework [12]. The object interpretation is more delicate but we get more information.
Reference: [21] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Self application occurs during method selection when the entire object is passed to the method as an implicit "self" argument. Recent type-theoretic accounts of objects <ref> [1, 21, 5, 10] </ref> have been encoded in impredicative type theory (mainly variants of Girard's System F [9]), which allow self-application through an impredicative interpretation of the self parameter. In this paper, we show that the construction of objects has an interpretation in predicative type theory. <p> In their system, objects have three parts: an object state, the object methods, and the proofs of method correctness (dependent objects with exactly one dependency). Their interpretation uses an existential encoding of objects <ref> [21, 16] </ref> in an impredicative type theory. Although the existential encoding restricts method update, the interpretation of objects does not require the use of recursive types, allowing the development of expressive type systems [6, 14].
Reference: [22] <author> Didier Remy and Jerome Vouillon. </author> <title> Objective ML: A simple object-oriented extension of ML. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 40-53, </pages> <year> 1997. </year>
Reference-contexts: It may be possible to address this issue by giving a syntactic account of polymorphism that allows the use of recursive types to define objects. We are using the interpretation in the Nuprl-Light system [12] to implement a formal module layer on top of the Objective Caml module system <ref> [22] </ref>.
Reference: [23] <author> Adrian Rezus. </author> <title> Semantics of constructive type theory. </title> <type> Technical Report 70, </type> <institution> Nijmegen University, The Nether-lands, </institution> <month> September </month> <year> 1985. </year>
Reference-contexts: of Naval Research through grant N00014-92-J-1764, from the National Science Foundation through grant CCR-9244739, from DARPA through grant 93-11-271, and from AASERT through grant N00014-95-1-0985. ticular, the Nuprl type theory that we use in this paper has multiple mathematical models, notably set theoretic [17], PER models [3, 20], denotational models <ref> [23] </ref>, and others. In addition, our interpretation is extendable to foundational formal objects that encode proofs [15, 11], a critical step toward our goal of providing a modular and object-oriented logical framework [12]. The object interpretation is more delicate but we get more information.
Reference: [24] <author> Robinson and Tennent. </author> <title> Bounded quantification and record-update problems. Message to types email list, </title> <year> 1988. </year>
Reference-contexts: Unfortunately, this typing also fails to produce the expected behavior because it contains only the identity functions <ref> [24] </ref>. Essentially, we don't want polymor phism over subtypes of fx: fg ! Zg, but over record extensions of fx: fg ! Z g.
Reference: [25] <author> Scott Fraser Smith. </author> <title> Partial Objects in Type Theory. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, NY, </address> <year> 1989. </year>
Reference-contexts: Until now, the interpretation has not distinguished between partial and total objects. However, with the introduction of recursive methods, a formal account of totality would require a specification of all the intermediate computations. Our account of partial objects is based on the partial types of Smith <ref> [25] </ref>, which have been simplified by Crary [7]. A partial type, denoted T , contains a term x if the evaluation of x diverges, or if x is an element of T .
References-found: 25

