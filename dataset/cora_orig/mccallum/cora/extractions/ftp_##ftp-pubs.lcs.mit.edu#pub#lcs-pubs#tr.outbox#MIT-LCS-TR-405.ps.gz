URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-405.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/trlow.html
Root-URL: 
Title: A Framework for Incorporating Abstraction Mechanisms into the Logic Programming Paradigm  
Author: by Joseph Lawrence Zachary 
Address: 1987  Cambridge, Massachusetts  
Affiliation: c Massachusetts Institute of Technology,  Massachusetts Institute of Technology Laboratory for Computer Science  
Abstract: This research was supported in part by the National Science Foundation under grant DCR-8411639, and in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research under contract N00014-83-K-0125. 
Abstract-found: 1
Intro-found: 1
Reference: [Abrial 80] <author> J. R. </author> <title> Abrial. The Specification Language Z: Syntax and "Semantics". </title> <type> Technical report, </type> <institution> Programming Research Group, Oxford University, </institution> <month> April </month> <year> 1980. </year>
Reference: [Arnborg 85] <author> S. Arnborg and E. Tiden. </author> <title> Unification Problems with One-Sided Distributivity. </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Proceedings of the First International Conference on Rewriting Techniques and Applications, Dijon, France, </booktitle> <pages> pages 398-406, </pages> <address> Berlin, </address> <month> May </month> <year> 1985. </year> <note> LNCS 202, Springer-Verlag. </note>
Reference-contexts: Equational unification procedures, and in most cases terminating algorithms, are currently known for a number of equational theories. Some examples include procedures for the associative [Plotkin 72], commutative [Siekmann 79], associative-commutative [Stickel 81, Livesey 76], identity <ref> [Arnborg 85] </ref>, and one-sided distributive [Arnborg 85] theories. The unification problem in some theories, e.g. the associative-distributive theory, has been proven undecidable [Szabo 78]. In others, such as the associative theory, no terminating procedure exists [Makanin 77]. Terminating procedures, i.e. algorithms, exist for the remainder of the theories mentioned above. <p> Equational unification procedures, and in most cases terminating algorithms, are currently known for a number of equational theories. Some examples include procedures for the associative [Plotkin 72], commutative [Siekmann 79], associative-commutative [Stickel 81, Livesey 76], identity <ref> [Arnborg 85] </ref>, and one-sided distributive [Arnborg 85] theories. The unification problem in some theories, e.g. the associative-distributive theory, has been proven undecidable [Szabo 78]. In others, such as the associative theory, no terminating procedure exists [Makanin 77]. Terminating procedures, i.e. algorithms, exist for the remainder of the theories mentioned above. <p> Typically, the execution time for existing algorithms is high. The worst-case complexity of a number of unification problems have been classified. Unification in the commutative theory is NP-complete [Garey 79] and in the associative-commutative theory is NP-hard [Benanav 85]. Identity unification is also NP-hard <ref> [Arnborg 85] </ref>, while one-sided distributive unification is polynomial [Arnborg 85]. 6.1. <p> The worst-case complexity of a number of unification problems have been classified. Unification in the commutative theory is NP-complete [Garey 79] and in the associative-commutative theory is NP-hard [Benanav 85]. Identity unification is also NP-hard <ref> [Arnborg 85] </ref>, while one-sided distributive unification is polynomial [Arnborg 85]. 6.1. Approaches to equational unification 123 We have seen that the advantage of moded unification arises from the possibility, through the establishment of a moded base and the imposition moding constraints, of restricting the domain of a unification procedure to a more easily managed subset.
Reference: [Barnes 80] <author> J. G. P. Barnes. </author> <title> An Overview of Ada. </title> <journal> Software|Practice and Experience, </journal> <volume> 10(11) </volume> <pages> 851-887, </pages> <month> November </month> <year> 1980. </year>
Reference: [Baxter 73] <author> L. D. Baxter. </author> <title> An Efficient Unification Algorithm. </title> <type> Technical Report CS-73-23, </type> <institution> Department of Applied Analysis and Computer Science, University of Waterloo, Waterloo, </institution> <address> Ontario, </address> <month> July </month> <year> 1973. </year>
Reference-contexts: The earliest was described in [Robinson 65] and runs in time that is exponential in the size of the input terms. Other algorithms have subsequently been developed that reduce worst-case running time to polynominal [Corbin 83], almost linear <ref> [Martelli 82, Baxter 73] </ref>, and linear [Paterson 78]. Equational unification procedures, and in most cases terminating algorithms, are currently known for a number of equational theories.
Reference: [Benanav 85] <author> D. Benanav, D. Kapur, and P. Narendran. </author> <title> Complexity of Matching Problems. </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Proceedings of the First International Conference on Rewriting Techniques and Applications, Dijon, France, </booktitle> <pages> pages 417-429, </pages> <address> Berlin, </address> <month> May </month> <year> 1985. </year> <note> LNCS 202, Springer-Verlag. </note>
Reference-contexts: Typically, the execution time for existing algorithms is high. The worst-case complexity of a number of unification problems have been classified. Unification in the commutative theory is NP-complete [Garey 79] and in the associative-commutative theory is NP-hard <ref> [Benanav 85] </ref>. Identity unification is also NP-hard [Arnborg 85], while one-sided distributive unification is polynomial [Arnborg 85]. 6.1.
Reference: [Burstall 81] <author> R. M. Burstall and J. A. Goguen. </author> <title> An Informal Introduction to Specifications using CLEAR. </title> <editor> In R. S. Boyer and J. S. Moore, editors, </editor> <booktitle> The Correctness Problem in Computer Science, </booktitle> <pages> pages 185-213. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference: [Clark 85] <author> K. L. Clark and S. Gregory. </author> <title> Notes on the Implementation of Par-log. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(1) </volume> <pages> 17-42, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: In the Edinburgh Prolog compiler, modes are used to annotate predicate definitions to permit more efficient compilation [Warren 77]. Several sequential logic languages use modes to control the order of evaluation of literals, including Epilog [Porto 82] and Mu-Prolog [Naish 85]. The parallel logic languages Parlog <ref> [Clark 85] </ref> and Concurrent Prolog [Shapiro 83] use modes for concurrency control. Finally, modes are used to help plan the evaluation of database queries in NAIL! [Ullman 85]. A more detailed discussion of these uses of bi-valued modes appears in Chapter 2. <p> In such languages, the literals of a query are evaluated in parallel, with the evaluation of ill-moded literals suspended until they are sufficiently instantiated. This provides a simple form of concurrency control. The mode mechanism of Parlog <ref> [Clark 85] </ref> is of the bi-valued variety that we have described. In Concurrent Prolog [Shapiro 83], the mode restrictions are attached to the point of call rather than to the point of definition. The same effect is achieved, and some additional flexibility is obtained.
Reference: [Clocksin 81] <author> W. F. Clocksin and C. S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: It is important, however, to draw a distinction between an abstract object, its denotation, and its internal representation. It is difficult to motivate the difference in pure Prolog since uninterpreted terms can conveniently serve as both denotation and representation. Instead, we examine standard Prolog <ref> [Clocksin 81] </ref> to 4.1. Requirements 71 illustrate our point. A specialized infix list notation is used extensively in Prolog programs. In this notation, a single list object can have two or more distinct denotations.
Reference: [Corbin 83] <author> J. Corbin and M. Bidoit. </author> <title> A Rehabilitation of Robinson's Unification Algorithm. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing 83. Proceedings of the IFIP Ninth World Computer Conference, Paris, </booktitle> <pages> pages 909-914, </pages> <address> Amsterdam, </address> <month> September </month> <year> 1983. </year> <title> North-Holland. </title> <type> 167 168 References </type>
Reference-contexts: The earliest was described in [Robinson 65] and runs in time that is exponential in the size of the input terms. Other algorithms have subsequently been developed that reduce worst-case running time to polynominal <ref> [Corbin 83] </ref>, almost linear [Martelli 82, Baxter 73], and linear [Paterson 78]. Equational unification procedures, and in most cases terminating algorithms, are currently known for a number of equational theories.
Reference: [Dahl 70] <author> O. Dahl, B. Myhrhaug, and K. Nygaard. </author> <title> The SIMULA 67 Common Base Language. </title> <institution> Publication S-22, Norwegian Computing Center, Oslo, </institution> <year> 1970. </year>
Reference: [Dembinski 85] <author> P. Dembinski and J. Maluszynski. </author> <title> And-parallelism with Intelligent Backtracking for Annotated Logic Programs. </title> <booktitle> In Proceedings of the 1985 Symposium on Logic Programming, Boston, </booktitle> <pages> pages 29-38, </pages> <address> Los Angeles, </address> <month> July </month> <year> 1985. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: In Concurrent Prolog [Shapiro 83], the mode restrictions are attached to the point of call rather than to the point of definition. The same effect is achieved, and some additional flexibility is obtained. Modes have also been used to plan the evaluation of queries. <ref> [Dembinski 85] </ref> describes a scheme that exploits bi-valued mode declarations to perform intelligent backtracking in a Prolog-like interpreter. In the database language NAIL! [Ullman 85], bi-valued modes are combined with capture rules to preplan the evaluation of database queries.
Reference: [Emden 76] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The Semantics of Predicate Logic as a Programming Language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <month> October </month> <year> 1976. </year>
Reference-contexts: We outline the balance of the dissertation in Section 1.5. 16 1. Introduction 1.1 Prolog Prolog exists in two substantially different forms. For our purposes, Prolog means definite clause programming. Often called pure Prolog, it has an abstract semantics based upon first-order logic <ref> [Emden 76] </ref>, and has a straightforward interpreter based upon depth-first linear resolution. Because of its simplicity and purity, it is the starting point for all other logic programming languages. In other contexts, Prolog is taken to be the more practical programming language that has evolved over the years. <p> The relation that is associated by a Prolog program with each of its predicate symbols can be determined by regarding the program as a sentence of first-order logic <ref> [Emden 76] </ref>. Prolog interpreters employ a variant of Robinson's resolution procedure [Robinson 65] to solve queries relative to a program's abstract meaning. The Prolog interpreter is based upon sld resolution [Kowalski 71]. <p> We continue in Section 5.1.2 by discussing the problem of finding equationally complete solutions to equations and queries. The terminology surrounding equational theories follows that of [Huet 80], while the terminology concerning the theory of definite clause programs follows that of <ref> [Emden 76] </ref> and [Jaffar 84]. 5.1.1 Definite clause programs with equality Let V be a countably infinite set of variables, F a finite set of function symbols, P a finite set of predicate symbols, and S a finite set of sorts.
Reference: [Fay 79] <author> M. Fay. </author> <title> First-order Unification in an Equational Theory. </title> <booktitle> In Proceedings of the Fourth Workshop on Automated Deduction, </booktitle> <address> Austin, TX, </address> <pages> pages 161-167, </pages> <month> February </month> <year> 1979. </year>
Reference-contexts: Its approach to obtaining implementations of equational unification, however, is completely different. Instead of relying upon a set of pragmatic techniques for simplifying the unification problem, Eqlog relies upon the narrowing procedure <ref> [Fay 79] </ref> to compile sets of equations into unification procedures. Unfortunately, the narrowing procedure is primarily of theoretical interest, as it is generally nonterminating and usually produces inefficient implementations. <p> In any event, the body of existing unification procedures provides a rich source for implementations of the built-in theories of Denali. 6.1.2 Narrowing An approach based upon the narrowing operation of [Slagle 74] can be used to synthesize unification procedures for equational theories presented by a convergent term rewriting system <ref> [Fay 79] </ref>. The narrowing approach has been improved by [Hullot 80], who gives sufficient conditions for its termination; by [Jouannaud 83], who generalizes it to equational term rewriting systems; and by [Rety 85], who improves its efficiency. Despite these improvements, the narrowing approach remains primarily of theoretical interest.
Reference: [Fribourg 84] <author> L. </author> <title> Fribourg. Oriented Equational Clauses as a Programming Language. </title> <journal> Journal of Logic Programming, </journal> <volume> 1(2) </volume> <pages> 165-177, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Tablog [Malachi 86] is based upon a proof system, completely independent of resolution, that explicitly incorporates both definite clauses and equations. SLOG <ref> [Fribourg 84] </ref> is based upon definite clauses that define equality, and is implemented with a variant of resolution. We discuss these languages further in Chapter 3. 1.4 Contributions In this section we summarize the primary contributions presented in this dissertation. <p> The language was designed and implemented as a demonstration that a logic programming language can be based upon something other than the resolution procedure. Its treatment of equality is incomplete, however, as it makes an asymmetrical distinction between primitive and defined function symbols. SLOG <ref> [Fribourg 84] </ref> is a logic language in which only one predicate may be defined by a programmer. This predicate is equality. Queries are solved with a variant of resolution called innermost superposition.
Reference: [Garey 79] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability; A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman & Co., </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference-contexts: Terminating procedures, i.e. algorithms, exist for the remainder of the theories mentioned above. Typically, the execution time for existing algorithms is high. The worst-case complexity of a number of unification problems have been classified. Unification in the commutative theory is NP-complete <ref> [Garey 79] </ref> and in the associative-commutative theory is NP-hard [Benanav 85]. Identity unification is also NP-hard [Arnborg 85], while one-sided distributive unification is polynomial [Arnborg 85]. 6.1.
Reference: [Goguen 86] <author> J. A. Goguen and J. Meseguer. </author> <title> EQLOG: Equality, Types, and Generic Modules for Logic Programming. </title> <editor> In D. DeGroot and G. Lindstrom, editors, </editor> <title> Logic Programming. Functions, Relations, </title> <booktitle> and Equations, </booktitle> <pages> pages 295-363. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: Of the other logic languages that incorporate equality, only Kornfeld's extension to Prolog [Kornfeld 86] adopts a comparably pragmatic approach. His approach is to permit the implementation of equality procedures in Lisp. Eqlog <ref> [Goguen 86] </ref> allows the programmer to specify equality with a set of equations; the language implementation is responsible for synthesizing an equational unification procedure from these equations. Tablog [Malachi 86] is based upon a proof system, completely independent of resolution, that explicitly incorporates both definite clauses and equations. <p> His observations have inspired a number of other efforts in this direction. He incorporates equality by allowing the Prolog unification procedure to invoke 3.4. Related work 65 Lisp procedures whenever unification fails. This ad hoc approach has no sound formal basis. Eqlog <ref> [Goguen 86] </ref> is closely related to our work, as it incorporates equational unification in much the same way as Denali. Its approach to obtaining implementations of equational unification, however, is completely different.
Reference: [Goldberg 84] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk 80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1984. </year>
Reference: [Guttag 85] <author> J. V. Guttag, J. J. Horning, and J. M. Wing. </author> <title> Larch in Five Easy Pieces. </title> <type> Technical Report 5, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> July </month> <year> 1985. </year>
Reference: [Huet 80] <author> G. Huet and D. C. Oppen. </author> <title> Equations and Rewrite Rules: A Survey. </title> <editor> In R. V. Book, editor, </editor> <booktitle> Formal Language Theory: Perspectives and Open Problems, </booktitle> <pages> pages 349-405. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: In Section 5.1.1, we describe equational theories and then define the theory of definite clause programs with equality. We continue in Section 5.1.2 by discussing the problem of finding equationally complete solutions to equations and queries. The terminology surrounding equational theories follows that of <ref> [Huet 80] </ref>, while the terminology concerning the theory of definite clause programs follows that of [Emden 76] and [Jaffar 84]. 5.1.1 Definite clause programs with equality Let V be a countably infinite set of variables, F a finite set of function symbols, P a finite set of predicate symbols, and S
Reference: [Hullot 80] <author> J.-M. Hullot. </author> <title> Canonical Forms and Unification. </title> <editor> In W. Bibel and R. A. Kowalski, editors, </editor> <booktitle> Proceedings of the Fifth Conference on Automated Deduction, Les Arcs, France, </booktitle> <pages> pages 318-334, </pages> <address> Berlin, </address> <month> July </month> <year> 1980. </year> <note> LNCS 87, Springer-Verlag. References 169 </note>
Reference-contexts: The narrowing approach has been improved by <ref> [Hullot 80] </ref>, who gives sufficient conditions for its termination; by [Jouannaud 83], who generalizes it to equational term rewriting systems; and by [Rety 85], who improves its efficiency. Despite these improvements, the narrowing approach remains primarily of theoretical interest.
Reference: [Jaffar 84] <author> J. Jaffar, J.-L. Lassez, and M. J. Maher. </author> <title> A Theory of Complete Logic Programs with Equality. </title> <journal> Journal of Logic Programming, </journal> <volume> 1(3) </volume> <pages> 211-223, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: We continue in Section 5.1.2 by discussing the problem of finding equationally complete solutions to equations and queries. The terminology surrounding equational theories follows that of [Huet 80], while the terminology concerning the theory of definite clause programs follows that of [Emden 76] and <ref> [Jaffar 84] </ref>. 5.1.1 Definite clause programs with equality Let V be a countably infinite set of variables, F a finite set of function symbols, P a finite set of predicate symbols, and S a finite set of sorts. Associated with every variable v 2 V is a sort from S.
Reference: [Jeanrond 80] <author> J. Jeanrond. </author> <title> Deciding Unique Termination of Permutative Rewrite Systems: Choose Your Term Algebra Carefully. </title> <editor> In W. Bibel and R. A. Kowalski, editors, </editor> <booktitle> Proceedings of the Fifth Conference on Automated Deduction, Les Arcs, France, </booktitle> <pages> pages 335-355, </pages> <address> Berlin, </address> <month> July </month> <year> 1980. </year> <note> LNCS 87, Springer-Verlag. </note>
Reference-contexts: First, the equational presentation given in an implicit implementation must describe a theory for which a unification procedure is known to the language implementation. The equation given in the bag cluster presents the theory of left-commutativity, for which a unification algorithm exists <ref> [Jeanrond 80] </ref>. In a real language, the name of the theory would probably appear instead of its specifying equations. Second, the equational presentation must contain only function symbols whose range is the sort of interest. Such a presentation is said to be homogeneous with respect to the sort of interest.
Reference: [Jouannaud 83] <editor> J.-P. Jouannaud, C. Kirchner, and H. Kirchner. </editor> <title> Incremental Construction of Unification Algorithms in Equational Theories. </title> <editor> In J. Diaz, editor, </editor> <booktitle> Proceedings of the Tenth EATCS International Colloquium on Automata, Languages, and Programming, Barcelona, </booktitle> <pages> pages 361-373, </pages> <address> Berlin, </address> <month> July </month> <year> 1983. </year> <note> LNCS 154, Springer-Verlag. </note>
Reference-contexts: The narrowing approach has been improved by [Hullot 80], who gives sufficient conditions for its termination; by <ref> [Jouannaud 83] </ref>, who generalizes it to equational term rewriting systems; and by [Rety 85], who improves its efficiency. Despite these improvements, the narrowing approach remains primarily of theoretical interest. Except for a small class of equational presentations, the procedures produced by narrowing are nonterminating.
Reference: [Kirchner 85] <author> C. Kirchner. </author> <title> Methodes et Outils de Conception Systematique d'Algorithms d'Unification dans les Theories Equationalles. </title> <type> PhD thesis, </type> <institution> Centre de Recherche en Informatique de Nancy, UER de Mathematiques, Universite de Nancy I, </institution> <address> Nancy, France, </address> <month> June </month> <year> 1985. </year>
Reference-contexts: The narrowing approach produces a modally complete unification procedure whenever the equational presentation upon which narrowing operates is composed entirely of moded equations. No more general condition guaranteeing modal completeness is known. 124 6. Moded equational unification 6.1.3 Combining algorithms Three researchers <ref> [Yelick 85, Kirchner 85, Tiden 86] </ref> have independently developed algorithms that address the problem of combining complete unification algorithms for disjoint theories to produce a complete unification algorithm for their union. Below, we characterize these approaches, which are designed to cope with unsorted theories and terminating algorithms.
Reference: [Kornfeld 86] <author> W. A. Kornfeld. </author> <title> Equality for Prolog. </title> <editor> In D. DeGroot and G. Lind-strom, editors, </editor> <title> Logic Programming. Functions, Relations, </title> <booktitle> and Equations, </booktitle> <pages> pages 279-293. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: We have also discussed our pragmatic approach to incorporating equality. It involves providing a collection of linguistic mechanisms that permit the programmer to restrict and thus simplify the equational unification problem. Of the other logic languages that incorporate equality, only Kornfeld's extension to Prolog <ref> [Kornfeld 86] </ref> adopts a comparably pragmatic approach. His approach is to permit the implementation of equality procedures in Lisp. Eqlog [Goguen 86] allows the programmer to specify equality with a set of equations; the language implementation is responsible for synthesizing an equational unification procedure from these equations. <p> The modification strictly enlarges the class of queries that could be solved under the old strategy without changing the evaluation of any previously solvable queries. Finally, the change is not particular to pairs of variables. It helps prevent unification-related mode failures for all terms. 3.4 Related work Kornfeld <ref> [Kornfeld 86] </ref> was one of the first to suggest the power of incorporating equality constraints into Prolog. His observations have inspired a number of other efforts in this direction. He incorporates equality by allowing the Prolog unification procedure to invoke 3.4. Related work 65 Lisp procedures whenever unification fails.
Reference: [Kowalski 71] <author> R. A. Kowalski and D. Kuehner. </author> <title> Linear Resolution with Selection Function. </title> <journal> Artificial Intelligence, </journal> 2(3/4):227-260, Winter 1971. 
Reference-contexts: Prolog interpreters employ a variant of Robinson's resolution procedure [Robinson 65] to solve queries relative to a program's abstract meaning. The Prolog interpreter is based upon sld resolution <ref> [Kowalski 71] </ref>. <p> We could equally well specify that the selection rule select an arbitrary well-moded literal for reduction. We specify that the leftmost well-moded literal be chosen so that the reduction order for any particular query is deterministic. Prolog's interpreter is based upon sld resolution <ref> [Kowalski 71] </ref>, which observes an invariant that must be respected under the new evaluation strategy. This invariant requires that a literal, once selected, be completely reduced before any other literal of the query is selected. <p> We continue in Section 5.2 by describing esl resolution, a class of procedures for interpreting such programs. esl procedures extend the sl procedures commonly used to interpret logic programs <ref> [Kowalski 71] </ref> in three ways. They deal with equational theories, they interleave resolution and overlap steps, and they afford a formal way of characterizing both completeness and incompleteness. This final aspect of esl procedures is important, because complete equational resolution procedures are difficult to implement. <p> This definition forms the basis for our development of a spectrum of equational resolution procedures in subsequent sections. esl resolution procedures operate by constructing and searching esl trees. Our esl trees are based upon the kinds of trees constructed by the sl resolution procedure <ref> [Kowalski 71] </ref>. sl resolution is a complete satisfaction procedure defined with respect to the empty theory. It is a linear resolution strategy that imposes, at each step, characteristic constraints upon the selection of the next literal for reduction. <p> No guarantee can be made about the completeness of a blocked tree. However, because unblocked esl trees are equivalent to sl trees whenever E is empty, the following lemma follows from the completeness result of <ref> [Kowalski 71] </ref>. Lemma 5.1 (Kowalski) Let T be an unblocked esl tree for the query Q with respect to a program (E; H), where E is empty. Then sols (T ) is a complete subset of S H E (Q).
Reference: [Kowalski 74] <author> R. A. Kowalski. </author> <title> Predicate Logic as Programming Language. </title> <editor> In J. L. Rosenfeld, editor, </editor> <booktitle> Information Processing 74. Proceedings of IFIP Congress 74, Stockholm, </booktitle> <pages> pages 569-574, </pages> <address> Amsterdam, </address> <month> August </month> <year> 1974. </year> <pages> North-Holland. </pages>
Reference: [Liskov 81] <author> B. Liskov, R. Atkinson, T. Bloom, E. Moss, J. C. Schaffert, R. Scheifler, and A. Snyder. </author> <title> CLU Reference Manual. </title> <publisher> LNCS 114, </publisher> <address> Spriger-Verlag, Berlin, </address> <year> 1981. </year>
Reference: [Livesey 76] <author> M. Livesey and J. H. Siekmann. </author> <title> Unification of A+C Terms (Bags) and A+C+I Terms (Sets). </title> <type> Interner Bericht 3/76, </type> <institution> Institut fur In-formatik I, Universitat Karlsruhe, </institution> <year> 1976. </year>
Reference-contexts: Equational unification procedures, and in most cases terminating algorithms, are currently known for a number of equational theories. Some examples include procedures for the associative [Plotkin 72], commutative [Siekmann 79], associative-commutative <ref> [Stickel 81, Livesey 76] </ref>, identity [Arnborg 85], and one-sided distributive [Arnborg 85] theories. The unification problem in some theories, e.g. the associative-distributive theory, has been proven undecidable [Szabo 78]. In others, such as the associative theory, no terminating procedure exists [Makanin 77].
Reference: [Makanin 77] <author> G. S. Makanin. </author> <title> The Problem of Solvability of Equations in a Free Semigroup. </title> <journal> Soviet Mathematics|Doklady, </journal> <volume> 18(2) </volume> <pages> 330-334, </pages> <month> March-April </month> <year> 1977. </year>
Reference-contexts: The unification problem in some theories, e.g. the associative-distributive theory, has been proven undecidable [Szabo 78]. In others, such as the associative theory, no terminating procedure exists <ref> [Makanin 77] </ref>. Terminating procedures, i.e. algorithms, exist for the remainder of the theories mentioned above. Typically, the execution time for existing algorithms is high. The worst-case complexity of a number of unification problems have been classified.
Reference: [Malachi 86] <author> Y. Malachi, Z. Manna, and R. Waldinger. </author> <title> TABLOG: A New Approach to Logic Programming. </title> <editor> In D. DeGroot and G. Lindstrom, </editor> <title> 170 References editors, Logic Programming. Functions, Relations, </title> <booktitle> and Equations, </booktitle> <pages> pages 365-394. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: His approach is to permit the implementation of equality procedures in Lisp. Eqlog [Goguen 86] allows the programmer to specify equality with a set of equations; the language implementation is responsible for synthesizing an equational unification procedure from these equations. Tablog <ref> [Malachi 86] </ref> is based upon a proof system, completely independent of resolution, that explicitly incorporates both definite clauses and equations. SLOG [Fribourg 84] is based upon definite clauses that define equality, and is implemented with a variant of resolution. <p> Furthermore, it is applicable only to sets of equations that can be converted into a canonical set of rewrite rules, and does not exploit modes. Under the narrowing procedure, the programmer has little control over or intuition about the efficiency characteristics of unification. Tablog <ref> [Malachi 86] </ref> is a logic language based upon the Manna-Waldinger deductive-tableau proof system [Manna 80]. This proof system explicitly handles equations as well as clauses. The language was designed and implemented as a demonstration that a logic programming language can be based upon something other than the resolution procedure.
Reference: [Manna 80] <author> Z. Manna and R. Waldinger. </author> <title> A Deductive Approach to Program Synthesis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(1) </volume> <pages> 90-121, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Under the narrowing procedure, the programmer has little control over or intuition about the efficiency characteristics of unification. Tablog [Malachi 86] is a logic language based upon the Manna-Waldinger deductive-tableau proof system <ref> [Manna 80] </ref>. This proof system explicitly handles equations as well as clauses. The language was designed and implemented as a demonstration that a logic programming language can be based upon something other than the resolution procedure.
Reference: [Martelli 82] <author> A. Martelli and U. Montanari. </author> <title> An Efficient Unification Algorithm. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(2) </volume> <pages> 258-282, </pages> <month> April </month> <year> 1982. </year>
Reference-contexts: The earliest was described in [Robinson 65] and runs in time that is exponential in the size of the input terms. Other algorithms have subsequently been developed that reduce worst-case running time to polynominal [Corbin 83], almost linear <ref> [Martelli 82, Baxter 73] </ref>, and linear [Paterson 78]. Equational unification procedures, and in most cases terminating algorithms, are currently known for a number of equational theories.
Reference: [Milner 78] <author> R. Milner. </author> <title> A Theory of Type Polymorphism in Programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17(3) </volume> <pages> 348-375, </pages> <month> Decem-ber </month> <year> 1978. </year>
Reference-contexts: However, it imposes restrictions not present in Prolog and is probably too restrictive for practical use. Modern polymorphic type systems such as that used in ML <ref> [Milner 78] </ref> would be more appropriate to Denali. As we are primarily interested in the more novel aspects of Denali, we have not incorporated these ideas here.
Reference: [Naish 85] <author> L. Naish. </author> <title> Automatic Control for Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(3) </volume> <pages> 167-183, </pages> <month> November </month> <year> 1985. </year>
Reference-contexts: In the Edinburgh Prolog compiler, modes are used to annotate predicate definitions to permit more efficient compilation [Warren 77]. Several sequential logic languages use modes to control the order of evaluation of literals, including Epilog [Porto 82] and Mu-Prolog <ref> [Naish 85] </ref>. The parallel logic languages Parlog [Clark 85] and Concurrent Prolog [Shapiro 83] use modes for concurrency control. Finally, modes are used to help plan the evaluation of database queries in NAIL! [Ullman 85]. A more detailed discussion of these uses of bi-valued modes appears in Chapter 2. <p> As long as they are correct, the annotations have no other effect. In fact, the annotations are ignored when uncompiled clauses are interpreted directly. Bi-valued moding schemes have appeared in a number of languages designed as successors to Prolog, including Epilog [Porto 82] and Mu-Prolog <ref> [Naish 85] </ref>. In these languages, the modes are used to control the selection rule as described in this section. Variants of bi-valued modes have also appeared in logic languages designed for concurrent applications. Modes are used in these languages to control the parallel solution of literals possessing shared variables.
Reference: [Nakajima 80] <author> R. Nakajima, M. Honda, and H. Nakahara. </author> <title> Hierarchical Program Specification and Verification|a Many-sorted Logical Approach. </title> <journal> Acta Informatica, </journal> <volume> 14(2) </volume> <pages> 135-155, </pages> <month> August </month> <year> 1980. </year>
Reference: [Paterson 78] <author> M. S. Paterson and M. N. Wegman. </author> <title> Linear Unification. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 16(2) </volume> <pages> 158-167, </pages> <month> April </month> <year> 1978. </year>
Reference-contexts: The earliest was described in [Robinson 65] and runs in time that is exponential in the size of the input terms. Other algorithms have subsequently been developed that reduce worst-case running time to polynominal [Corbin 83], almost linear [Martelli 82, Baxter 73], and linear <ref> [Paterson 78] </ref>. Equational unification procedures, and in most cases terminating algorithms, are currently known for a number of equational theories. Some examples include procedures for the associative [Plotkin 72], commutative [Siekmann 79], associative-commutative [Stickel 81, Livesey 76], identity [Arnborg 85], and one-sided distributive [Arnborg 85] theories.
Reference: [Plotkin 72] <author> G. D. Plotkin. </author> <title> Building-in Equational Theories. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence 7, </booktitle> <pages> pages 73-90. </pages> <publisher> John Wiley & Sons, </publisher> <address> Toronto, </address> <year> 1972. </year>
Reference-contexts: Predicate definitions are simpler when they are permitted to exploit equality instead of being required to define it. Equality constraints, such as com-mutativity, that could not be embedded into a convergent predicate definition can be handled. In this chapter we show how equational unification <ref> [Plotkin 72] </ref> can be used to systematically impose equality constraints in Denali. We begin in Section 3.1 by giving an overview of equational unification and its role of Denali. This overview is informal; we reserve until Chapters 5 and 6 a more rigorous development. <p> E-unification reduces to classical unification if the set E of equations is empty. A query can be evaluated with respect to an equational theory E and a definite clause program by replacing classical unification with E-unification in the interpreter. The resulting proof procedure is called equational resolution <ref> [Plotkin 72] </ref>. Although we will see shortly that this replacement is not straightforward, we will assume that it is for the remainder of this section. We illustrate, using two examples, the power inherent in 54 3. Equational unification in Denali making the replacement. <p> This is a new source of backtracking and can lead to multiple solutions, much as considering multiple clauses can lead to multiple solutions. The key result in equational resolution is due to Plotkin <ref> [Plotkin 72] </ref>, who showed that E-resolution is complete so long as a complete E-unification procedure is available. The problem of obtaining complete E-unification procedures is not always easily solved. <p> First, esl trees are defined with respect to arbitrary equational theories. We discussed the ramifications of incorporating non-empty equational theories into resolution in Chapter 3. This extension is straightforward, made so by the pioneering work of 92 5. Moded equational resolution Plotkin on the completeness of equational resolution <ref> [Plotkin 72] </ref>. Second, esl trees are more flexible concerning the order in which unification must be performed. We illustrated the benefits of interleaving unification and overlap steps in Chapter 3. This additional flexibility does not compromise completeness, and we will be able to exploit it to considerable advantage. <p> Lemma 5.1 (Kowalski) Let T be an unblocked esl tree for the query Q with respect to a program (E; H), where E is empty. Then sols (T ) is a complete subset of S H E (Q). Plotkin <ref> [Plotkin 72] </ref> treats the general problem of converting complete resolution strategies into complete strategies for equational theories. His results justify removing the condition upon E in Lemma 5.1. Lemma 5.2 (Plotkin) Let T be an unblocked esl tree for Q with respect to the program (E; H). <p> Equational unification procedures, and in most cases terminating algorithms, are currently known for a number of equational theories. Some examples include procedures for the associative <ref> [Plotkin 72] </ref>, commutative [Siekmann 79], associative-commutative [Stickel 81, Livesey 76], identity [Arnborg 85], and one-sided distributive [Arnborg 85] theories. The unification problem in some theories, e.g. the associative-distributive theory, has been proven undecidable [Szabo 78]. In others, such as the associative theory, no terminating procedure exists [Makanin 77].
Reference: [Porto 82] <author> A. Porto. </author> <title> A Language for Extended Programming in Logic. </title> <editor> In M. V. Carneghem, editor, </editor> <booktitle> Proceedings of the First International Logic Programming Conference, Marseille, </booktitle> <pages> pages 31-37, </pages> <month> September </month> <year> 1982. </year>
Reference-contexts: At least four applications have been found for these bi-valued modes. In the Edinburgh Prolog compiler, modes are used to annotate predicate definitions to permit more efficient compilation [Warren 77]. Several sequential logic languages use modes to control the order of evaluation of literals, including Epilog <ref> [Porto 82] </ref> and Mu-Prolog [Naish 85]. The parallel logic languages Parlog [Clark 85] and Concurrent Prolog [Shapiro 83] use modes for concurrency control. Finally, modes are used to help plan the evaluation of database queries in NAIL! [Ullman 85]. <p> Bi-valued modes are the simplest possible form of mode, and are the kind that have appeared previously in, among others, the Warren Prolog compiler [Warren 77], an extended version of Pro-log called Epilog <ref> [Porto 82] </ref>, and a concurrent logic language called Concurrent Prolog [Shapiro 83]. 2.1.1 Sorts A Denali program contains a set of encapsulated predicate implementations. An implementation consists of a sorted, moded header and a list of defining Horn clauses. We will ignore the moded portion of headers for now. <p> As long as they are correct, the annotations have no other effect. In fact, the annotations are ignored when uncompiled clauses are interpreted directly. Bi-valued moding schemes have appeared in a number of languages designed as successors to Prolog, including Epilog <ref> [Porto 82] </ref> and Mu-Prolog [Naish 85]. In these languages, the modes are used to control the selection rule as described in this section. Variants of bi-valued modes have also appeared in logic languages designed for concurrent applications.
Reference: [Rety 85] <author> P. Rety, C. Kirchner, H. Kirchner, and P. Lescanne. NARROWER: </author> <title> a New Algorithm for Unification and its Application to Logic Programming. </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Proceedings of the First International Conference on Rewriting Techniques and Applications, Dijon, France, </booktitle> <pages> pages 141-156, </pages> <address> Berlin, </address> <month> May </month> <year> 1985. </year> <note> LNCS 202, Springer-Verlag. </note>
Reference-contexts: The narrowing approach has been improved by [Hullot 80], who gives sufficient conditions for its termination; by [Jouannaud 83], who generalizes it to equational term rewriting systems; and by <ref> [Rety 85] </ref>, who improves its efficiency. Despite these improvements, the narrowing approach remains primarily of theoretical interest. Except for a small class of equational presentations, the procedures produced by narrowing are nonterminating. Furthermore, the procedures are in general too inefficient to be practical as part of a larger system.
Reference: [Robinson 65] <author> J. A. Robinson. </author> <title> A Machine-Oriented Logic Based on the Resolution Principle. </title> <journal> Journal of the ACM, </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <month> January </month> <year> 1965. </year>
Reference-contexts: The relation that is associated by a Prolog program with each of its predicate symbols can be determined by regarding the program as a sentence of first-order logic [Emden 76]. Prolog interpreters employ a variant of Robinson's resolution procedure <ref> [Robinson 65] </ref> to solve queries relative to a program's abstract meaning. The Prolog interpreter is based upon sld resolution [Kowalski 71]. <p> A complete equational unification procedure is one that enumerates, for any two terms, a complete set of unifiers. Robinson's classical unification algorithm is a complete procedure for the special case in which the set E is empty <ref> [Robinson 65] </ref>. We will survey 5.2. ESL resolution 91 existing unification procedures for other theories in Chapter 6. Let L be a literal. <p> The earliest was described in <ref> [Robinson 65] </ref> and runs in time that is exponential in the size of the input terms. Other algorithms have subsequently been developed that reduce worst-case running time to polynominal [Corbin 83], almost linear [Martelli 82, Baxter 73], and linear [Paterson 78].
Reference: [Schmidt-Schauss 86] <author> M. Schmidt-Schauss. </author> <title> Unification in Many-Sorted Equational Theories. </title> <editor> In J. H. Siekmann, editor, </editor> <booktitle> Proceedings of the Eighth International Conference on Automated Deduction, </booktitle> <address> Oxford, England, </address> <pages> pages 538-553, </pages> <address> Berlin, </address> <month> July </month> <year> 1986. </year> <note> LNCS 230, Springer-Verlag. References 171 </note>
Reference-contexts: H fl * (inference) L L 1 ; : : : ; L n 2 H ^ L 1 2 H fl E L n 2 H fl E The sort system we have adopted is particularly simple, and is an instance of the more general sort system described in <ref> [Schmidt-Schauss 86] </ref>. The unsorted case is, in turn, the special case of our system that occurs when the sort universe S contains exactly one element.
Reference: [Shapiro 83] <author> E. Shapiro. </author> <title> A Subset of Concurrent Prolog and its Interpreter. </title> <type> Technical Report TR-003, </type> <institution> ICOT, </institution> <address> Tokyo, </address> <month> February </month> <year> 1983. </year>
Reference-contexts: Several sequential logic languages use modes to control the order of evaluation of literals, including Epilog [Porto 82] and Mu-Prolog [Naish 85]. The parallel logic languages Parlog [Clark 85] and Concurrent Prolog <ref> [Shapiro 83] </ref> use modes for concurrency control. Finally, modes are used to help plan the evaluation of database queries in NAIL! [Ullman 85]. A more detailed discussion of these uses of bi-valued modes appears in Chapter 2. We have also discussed our pragmatic approach to incorporating equality. <p> Bi-valued modes are the simplest possible form of mode, and are the kind that have appeared previously in, among others, the Warren Prolog compiler [Warren 77], an extended version of Pro-log called Epilog [Porto 82], and a concurrent logic language called Concurrent Prolog <ref> [Shapiro 83] </ref>. 2.1.1 Sorts A Denali program contains a set of encapsulated predicate implementations. An implementation consists of a sorted, moded header and a list of defining Horn clauses. We will ignore the moded portion of headers for now. <p> This provides a simple form of concurrency control. The mode mechanism of Parlog [Clark 85] is of the bi-valued variety that we have described. In Concurrent Prolog <ref> [Shapiro 83] </ref>, the mode restrictions are attached to the point of call rather than to the point of definition. The same effect is achieved, and some additional flexibility is obtained.
Reference: [Siekmann 79] <author> J. H. Siekmann. </author> <title> Unification of Commutative Terms. </title> <editor> In E. W. Ng, editor, </editor> <booktitle> EUROSAM '79, An International Symposium on Symbolic and Algebraic Manipulation, Marseille, </booktitle> <pages> pages 530-545, </pages> <address> Berlin, June 1979. </address> <publisher> LNCS 72, Springer-Verlag. </publisher>
Reference-contexts: Equational unification procedures, and in most cases terminating algorithms, are currently known for a number of equational theories. Some examples include procedures for the associative [Plotkin 72], commutative <ref> [Siekmann 79] </ref>, associative-commutative [Stickel 81, Livesey 76], identity [Arnborg 85], and one-sided distributive [Arnborg 85] theories. The unification problem in some theories, e.g. the associative-distributive theory, has been proven undecidable [Szabo 78]. In others, such as the associative theory, no terminating procedure exists [Makanin 77].
Reference: [Slagle 74] <author> J. R. Slagle. </author> <title> Automated Theorem-Proving for Theories with Simplifiers, Commutativity and Associativity. </title> <journal> Journal of the ACM, </journal> <volume> 21(4) </volume> <pages> 622-642, </pages> <month> October </month> <year> 1974. </year>
Reference-contexts: For smaller moded bases it might be necessary to devise new procedures. In any event, the body of existing unification procedures provides a rich source for implementations of the built-in theories of Denali. 6.1.2 Narrowing An approach based upon the narrowing operation of <ref> [Slagle 74] </ref> can be used to synthesize unification procedures for equational theories presented by a convergent term rewriting system [Fay 79].
Reference: [Sterling 86] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog: Advanced Programming Techniques. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <month> October </month> <year> 1986. </year>
Reference-contexts: In response to the requirements imposed by applications, a number of extra-logical features have been grafted to the base language. These features encourage a number of programming paradigms that are foreign to the pure subset. <ref> [Sterling 86] </ref> gives a thorough grounding in the techniques of programming in this language, which we will call standard Prolog. We use the pure subset of Prolog as the starting point of our language design for three reasons. First, the subset is easy to characterize formally.
Reference: [Stickel 81] <author> M. E. Stickel. </author> <title> A Unification Algorithm for Associative-Commutative Theories. </title> <journal> Journal of the ACM, </journal> <volume> 28(3) </volume> <pages> 423-434, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: Equational unification procedures, and in most cases terminating algorithms, are currently known for a number of equational theories. Some examples include procedures for the associative [Plotkin 72], commutative [Siekmann 79], associative-commutative <ref> [Stickel 81, Livesey 76] </ref>, identity [Arnborg 85], and one-sided distributive [Arnborg 85] theories. The unification problem in some theories, e.g. the associative-distributive theory, has been proven undecidable [Szabo 78]. In others, such as the associative theory, no terminating procedure exists [Makanin 77].
Reference: [Szabo 78] <author> P. Szabo. </author> <title> The Undecidability of the D+A-Unification Problem. </title> <type> Technical report, </type> <institution> Institut fur Informatik I, Universitat Karlsruhe, </institution> <year> 1978. </year>
Reference-contexts: Some examples include procedures for the associative [Plotkin 72], commutative [Siekmann 79], associative-commutative [Stickel 81, Livesey 76], identity [Arnborg 85], and one-sided distributive [Arnborg 85] theories. The unification problem in some theories, e.g. the associative-distributive theory, has been proven undecidable <ref> [Szabo 78] </ref>. In others, such as the associative theory, no terminating procedure exists [Makanin 77]. Terminating procedures, i.e. algorithms, exist for the remainder of the theories mentioned above. Typically, the execution time for existing algorithms is high. The worst-case complexity of a number of unification problems have been classified.
Reference: [Tiden 86] <author> E. Tiden. </author> <title> Unification in Combinations of Collapse-Free Theories with Disjoint Function Symbols. </title> <editor> In J. H. Siekmann, editor, </editor> <booktitle> Proceedings of the Eighth International Conference on Automated Deduction, </booktitle> <address> Oxford, England, </address> <pages> pages 431-449, </pages> <address> Berlin, </address> <month> July </month> <year> 1986. </year> <note> LNCS 230, Springer-Verlag. </note>
Reference-contexts: We are not yet prepared to describe in more than cursory fashion the means by which this is done. Our approach is a generalization of the algorithms developed by Yelick [Yelick 85] and Tiden <ref> [Tiden 86] </ref> to combine unification algorithms. We will explain and justify this approach in Chapter 6. It is important to point out, however, that there are 76 4. Data abstraction in Denali two important restrictions upon the synthesis approach. <p> The narrowing approach produces a modally complete unification procedure whenever the equational presentation upon which narrowing operates is composed entirely of moded equations. No more general condition guaranteeing modal completeness is known. 124 6. Moded equational unification 6.1.3 Combining algorithms Three researchers <ref> [Yelick 85, Kirchner 85, Tiden 86] </ref> have independently developed algorithms that address the problem of combining complete unification algorithms for disjoint theories to produce a complete unification algorithm for their union. Below, we characterize these approaches, which are designed to cope with unsorted theories and terminating algorithms.
Reference: [Ullman 85] <author> J. D. Ullman. </author> <title> Implementation of Logical Query Languages for Databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 10(3) </volume> <pages> 289-321, </pages> <month> September </month> <year> 1985. </year>
Reference-contexts: The parallel logic languages Parlog [Clark 85] and Concurrent Prolog [Shapiro 83] use modes for concurrency control. Finally, modes are used to help plan the evaluation of database queries in NAIL! <ref> [Ullman 85] </ref>. A more detailed discussion of these uses of bi-valued modes appears in Chapter 2. We have also discussed our pragmatic approach to incorporating equality. It involves providing a collection of linguistic mechanisms that permit the programmer to restrict and thus simplify the equational unification problem. <p> The same effect is achieved, and some additional flexibility is obtained. Modes have also been used to plan the evaluation of queries. [Dembinski 85] describes a scheme that exploits bi-valued mode declarations to perform intelligent backtracking in a Prolog-like interpreter. In the database language NAIL! <ref> [Ullman 85] </ref>, bi-valued modes are combined with capture rules to preplan the evaluation of database queries.
Reference: [Warren 77] <author> D. Warren. </author> <title> Implementing Prolog|Compiling Predicate Logic Programs, Volume 1. </title> <type> DAI Research Report 39, </type> <institution> University of Ed-inburgh, </institution> <month> May </month> <year> 1977. </year>
Reference-contexts: We have briefly outlined the differences between Denali's multi-valued mode system and the simpler bi-valued mode systems of existing languages. At least four applications have been found for these bi-valued modes. In the Edinburgh Prolog compiler, modes are used to annotate predicate definitions to permit more efficient compilation <ref> [Warren 77] </ref>. Several sequential logic languages use modes to control the order of evaluation of literals, including Epilog [Porto 82] and Mu-Prolog [Naish 85]. The parallel logic languages Parlog [Clark 85] and Concurrent Prolog [Shapiro 83] use modes for concurrency control. <p> In Section 2.1.2, we illustrate this second component of the Denali type system by describing how bi-valued modes can be used to express mode restrictions. Bi-valued modes are the simplest possible form of mode, and are the kind that have appeared previously in, among others, the Warren Prolog compiler <ref> [Warren 77] </ref>, an extended version of Pro-log called Epilog [Porto 82], and a concurrent logic language called Concurrent Prolog [Shapiro 83]. 2.1.1 Sorts A Denali program contains a set of encapsulated predicate implementations. An implementation consists of a sorted, moded header and a list of defining Horn clauses. <p> While it is not a complete technique, the advantages of the mode signature technique are its simplicity and ease of checking. 2.6. Related work 49 2.6 Related work Bi-valued modes were first introduced by Warren as declarations for a Prolog compiler <ref> [Warren 77] </ref>. The interfaces of predicates can be annotated with bi-valued modes, permitting the Edinburgh Prolog compiler to optimize the compiled code. As long as they are correct, the annotations have no other effect. In fact, the annotations are ignored when uncompiled clauses are interpreted directly.

References-found: 51

