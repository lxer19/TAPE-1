URL: http://www.cs.brandeis.edu/~cs171a/Handouts/rivest-cryptography.ps
Refering-URL: http://www.cs.brandeis.edu/~cs171a/handouts.html
Root-URL: http://www.cs.brandeis.edu
Title: Cryptology  
Author: Prof. Ronald L. Rivest 
Address: 545 Technology Square Cambridge, Mass. 02139  
Affiliation: MIT Laboratory for Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> L. M. Adleman. </author> <title> On breaking generalized knapsack public key cryptosystems. </title> <booktitle> In Proc. 15th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 402-412, </pages> <publisher> ACM, </publisher> <address> Boston, </address> <year> 1983. </year>
Reference-contexts: See <ref> [114, 140, 142, 1, 144, 100, 32, 122] </ref>. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme [39], and the multiplicative versions of the knapsack [114] are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes [113].
Reference: [2] <author> L. M. Adleman. </author> <title> A subexponential algorithm for the discrete logarithm problem with applications to cryptography. </title> <booktitle> In Proceedings of the 18th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 55-60, </pages> <publisher> IEEE, </publisher> <address> Providence, </address> <year> 1977. </year>
Reference-contexts: Computing discrete logarithms seems to be difficult in general. However, Pohlig and Hellman [126] present effective techniques for this problem when n is prime and n 1 has only small prime factors. Adleman <ref> [2] </ref> shows how to compute discrete logarithms in the time given in equation (3), so that computing discrete logarithms and factoring integers seem to have essentially the same difficulty, as a function of the size of the numbers involved.
Reference: [3] <author> L. M. Adleman and M. A. Huang. </author> <title> Recognizing primes in random polynomial time. </title> <booktitle> In Proc. 19th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 462-469, </pages> <publisher> ACM, </publisher> <address> New York City, </address> <year> 1987. </year>
Reference-contexts: Finding large prime numbers is useful for constructing cryptographic operators, while for many cryptosystems the adversary's task is provably as hard as factoring the product of two large prime numbers. There are efficient algorithms for generating random k-bit prime numbers; these algorithms run in time polynomial in k <ref> [152, 132, 77, 5, 3] </ref> and come in two flavors: Monte Carlo probabilistic algorithms which may err with small probability, always terminate in polynomial time and are quite efficient in practice; and Las Vegas probabilistic algorithms which are always correct, generate as output a deterministic polynomial time checkable proof of correctness,
Reference: [4] <author> L. M. Adleman, K. Manders, and G. Miller. </author> <title> On taking roots in finite fields. </title> <booktitle> In Proceedings of the 18th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 175-177, </pages> <publisher> IEEE, </publisher> <address> Providence, </address> <year> 1977. </year>
Reference-contexts: If n is prime, this computation can be performed in polynomial time <ref> [22, 4, 133] </ref>, while if n is composite, this problem seems to be as hard as factoring n or computing discrete logarithms modulo n.
Reference: [5] <author> L. M. Adleman, C. Pomerance, and R. S. Rumely. </author> <title> On distinguishing prime numbers from composite numbers. </title> <journal> Ann. Math., </journal> <volume> 117 </volume> <pages> 173-206, </pages> <year> 1983. </year>
Reference-contexts: Finding large prime numbers is useful for constructing cryptographic operators, while for many cryptosystems the adversary's task is provably as hard as factoring the product of two large prime numbers. There are efficient algorithms for generating random k-bit prime numbers; these algorithms run in time polynomial in k <ref> [152, 132, 77, 5, 3] </ref> and come in two flavors: Monte Carlo probabilistic algorithms which may err with small probability, always terminate in polynomial time and are quite efficient in practice; and Las Vegas probabilistic algorithms which are always correct, generate as output a deterministic polynomial time checkable proof of correctness,
Reference: [6] <author> W. B. Alexi, B. Chor, O. Goldreich, and C. P. Schnorr. </author> <title> RSA and Rabin functions: certain parts are as hard as the whole. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 194-209, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: One might interpret this as saying that either RSA is uniformly secure or it is uniformly insecure. Even stronger results have been proven. For example, it has been shown <ref> [81, 6, 18] </ref> that if a polynomial fraction of RSA ciphertexts can't be decrypted in polynomial time, then neither can just the least significant bit of the message be guessed from the ciphertext with better than an * bias. <p> Theorem 2 (Goldwasser-Micali [78]) If trapdoor predicates exist, then the above probabilistic public-key encryption scheme is polynomial-time secure. Implementation of trapdoor predicates based on the problem of factoring integers, and of inverting the RSA function can be found in <ref> [6] </ref>. We outline the RSA-based implementation. Let n be the public modulus, e the public exponent, and d the secret exponent. Let B (x) be the least significant bit of x d mod n for x 2 Z fl n . <p> This generator follows the Blum-Micali general method, with B (x) = 1 iff x is odd, and f (x) = x 2 mod n. Alexi, Chor, Goldreich, and Schnorr <ref> [6] </ref> show that the assumption that the quadratic residuosity problem is hard can be replaced by the weaker assumption that factoring is hard. A related generator is obtained by using the RSA function x e mod n where gcd (e; (n)) = 1 [154, 6]. <p> Alexi, Chor, Goldreich, and Schnorr [6] show that the assumption that the quadratic residuosity problem is hard can be replaced by the weaker assumption that factoring is hard. A related generator is obtained by using the RSA function x e mod n where gcd (e; (n)) = 1 <ref> [154, 6] </ref>. Kaliski shows how to extend these methods so that the security of the generator depends on the difficulty of computing elliptic logarithms; his techniques also generalize to other groups [94, 93]. <p> Long and Wigderson [109] show how to extract c log log p pseudo-random bits from each x i instead of just one bit as in the Blum-Micali generator. A similar result has been shown for the RSA generator <ref> [6] </ref>.
Reference: [7] <author> B. Alpern and F. B. Schneider. </author> <title> Key exchange using `keyless cryptography'. </title> <journal> Information Processing Letters, </journal> <volume> 16 </volume> <pages> 79-81, </pages> <year> 1983. </year>
Reference-contexts: Unusual properties of the communication channel can sometimes be exploited. For example, Alpern and Schneider <ref> [7] </ref> show how to communicate securely on channels for which an eavesdropper cannot tell who broadcasts each bit. Wyner [160] defeats eavesdroppers for whom reception is less reliable than for the intended receiver, or when the channel is analog rather than digital [158, 159].
Reference: [8] <author> D. Angluin. </author> <title> Lecture notes on the complexity of some problems in number theory. </title> <type> Technical Report TR-243, </type> <institution> Yale University Computer Science Department, </institution> <month> August </month> <year> 1982. </year>
Reference-contexts: In this section we review some basic number-theoretic and computational facts. For a more extensive review of elementary number theory see [121], [105], or <ref> [8] </ref>. An excellent overview of the problems of factoring integers, testing primality, and computing discrete logarithms also appears in this volume [103].
Reference: [9] <author> D. Angluin and D. Lichtenstein. </author> <title> Provable Security of Cryptosystems: A Survey. </title> <type> Technical Report TR-288, </type> <institution> Yale University Department of Computer Science, </institution> <month> October </month> <year> 1983. </year> <month> 37 </month>
Reference: [10] <author> C. A. Asmuth and G. R. Blakley. </author> <title> An efficient algorithm for constructing a cryptosystem which is harder to break than two other cryptosystems. </title> <journal> Comp. and Maths. with Appls., </journal> <volume> 7 </volume> <pages> 447-450, </pages> <year> 1981. </year>
Reference-contexts: Thus the composed system has difficulty proportional to 2 n , rather than proportional to 2 2n , as one would naively expect. One very intuitive result, due to Even and Goldreich [60] (see also <ref> [10] </ref>), is that the composition of encryption schemes A and B is no weaker than A or B individually|security is not lost by composition.
Reference: [11] <author> Eric Bach. </author> <title> How to generate factored random numbers. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 179-193, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Not only can random primes be generated, but Bach <ref> [11] </ref> has also shown how to create a random k-bit composite number in a factored form which which uses primality testing as a subroutine.
Reference: [12] <author> James Bamford. </author> <title> The Puzzle Palace A Report on NSA, America's Most Secret Agency. </title> <publisher> Houghton Miflin, </publisher> <address> Boston, </address> <year> 1982. </year>
Reference-contexts: Author's net address: rivest@theory.lcs.mit.edu 2 The reader who wishes to explore further will find available many excellent texts, collections, and survey articles [9, 13, 29, 45, 49, 48, 53, 54, 51, 66, 91, 99, 102, 117, 146, 150, 149, 148, 151], works of historical or political interest <ref> [12, 69, 92, 138, 157] </ref>, relevant conference proceedings (CRYPTO, EUROCRYPT, FOCS, STOC, [46, 86, 100]) and bibliographies [14, 129]. 6 * A key space K: a set of strings (keys) over some alphabet. * An encryption algorithm E mapping K fi M into C. * A decryption algorithm E mapping K
Reference: [13] <author> H. Beker and F. Piper. </author> <title> Cipher Systems: The Protection of Communications. </title> <address> Northwood, London, </address> <year> 1982. </year>
Reference: [14] <author> D. A. Bell and S. E. Olding. </author> <title> An Annotated Bibliography of Cryptography. </title> <type> Technical Report COM-100, </type> <institution> National Physical Laboratory, </institution> <month> January </month> <year> 1978. </year>
Reference-contexts: available many excellent texts, collections, and survey articles [9, 13, 29, 45, 49, 48, 53, 54, 51, 66, 91, 99, 102, 117, 146, 150, 149, 148, 151], works of historical or political interest [12, 69, 92, 138, 157], relevant conference proceedings (CRYPTO, EUROCRYPT, FOCS, STOC, [46, 86, 100]) and bibliographies <ref> [14, 129] </ref>. 6 * A key space K: a set of strings (keys) over some alphabet. * An encryption algorithm E mapping K fi M into C. * A decryption algorithm E mapping K fi C into M.
Reference: [15] <author> Mihir Bellare and Silvio Micali. </author> <title> How to sign given any trapdoor function. </title> <booktitle> In Proc. 20th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 32-42, </pages> <publisher> ACM, </publisher> <address> Chicago, </address> <year> 1988. </year>
Reference-contexts: A review of signature schemes can be found in [84]. 8.1 Proving Security of Signature Schemes A theoretical treatment of digital signatures security was started by Goldwasser, Micali and Yao in [82] and continued in <ref> [84, 15] </ref>,and recently [119]. <p> In particular, Goldreich [73] has made suggestions that make the factoring-based version of this scheme more practical while preserving its security properties. 29 Bellare and Micali in <ref> [15] </ref> have shown a digital signature scheme whose security can be based on the existence of any trapdoor permutation (a weaker requirement than claw-freeness).
Reference: [16] <author> J. Benaloh. </author> <title> Secret sharing homomorphisms: keeping shares of a secret sharing. </title> <editor> In A. M. Odlyzko, editor, </editor> <booktitle> Proceedings CRYPTO 86, </booktitle> <publisher> Springer, </publisher> <year> 1987. </year> <note> Lecture Notes in Computer Science No. 263. </note>
Reference-contexts: They call the new protocol verifiable secret sharing since now every party can verify that the piece of the secret he received is indeed a proper piece. Their protocol tolerated up to O (log n) colluders. Benaloh <ref> [16] </ref>, and others [76, 63] showed how to achieve verifiable secret sharing if any one-way function exists which tolerates a minority of colluders.
Reference: [17] <editor> C. H. Bennett, G. Brassard, S. Breidbard, and S. Wiesner. </editor> <booktitle> Quantum cryptography. In Proceedings CRYPTO 82, </booktitle> <pages> pages 267-275, </pages> <publisher> Plenum Press, </publisher> <year> 1983. </year>
Reference-contexts: Wyner [160] defeats eavesdroppers for whom reception is less reliable than for the intended receiver, or when the channel is analog rather than digital [158, 159]. Bennett et al. exploit the peculiarities of quantum effects in their channels <ref> [17] </ref>. And spread-spectrum channels are effectively unobservable to enemies who don't know the details of their use [70]. We do not pursue these variations further in this paper. * Information theory.
Reference: [18] <author> M. Ben-Or, B. Chor, and A. Shamir. </author> <title> On the cryptographic security of single RSA bits. </title> <booktitle> In Proc. 15th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 421-430, </pages> <publisher> ACM, </publisher> <address> Boston, </address> <year> 1983. </year>
Reference-contexts: One might interpret this as saying that either RSA is uniformly secure or it is uniformly insecure. Even stronger results have been proven. For example, it has been shown <ref> [81, 6, 18] </ref> that if a polynomial fraction of RSA ciphertexts can't be decrypted in polynomial time, then neither can just the least significant bit of the message be guessed from the ciphertext with better than an * bias.
Reference: [19] <author> M. Ben-Or, O. Goldreich, S. Micali, and R. L. Rivest. </author> <title> A fair protocol for signing contracts. </title> <booktitle> In ICALP, </booktitle> <pages> pages 43-52, </pages> <year> 1985. </year>
Reference-contexts: Several interesting solutions to the problem have been proposed (see [62] or <ref> [19] </ref>). The certified electronic mail problem is similar to the contract-signing problem above. The goal is to achieve a simultaneous exchange of an electronic letter M and a signed receipt for M from the recipient. Another exchange problem is the simultaneous exchange of secrets.
Reference: [20] <author> M. Ben-Or, S. Goldwasser, and A. Wigderson. </author> <title> Completeness theorems for fault-tolerant distributed computing. </title> <booktitle> In Proc. 20th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 1-10, </pages> <publisher> ACM, </publisher> <address> Chicago, </address> <year> 1988. </year>
Reference-contexts: Their protocol tolerated up to O (log n) colluders. Benaloh [16], and others [76, 63] showed how to achieve verifiable secret sharing if any one-way function exists which tolerates a minority of colluders. In <ref> [20] </ref> it has been recently shown how to achieve verifiable secret sharing against a minority of colluders using error correcting codes, without making cryptographic assumptions. 10.1.2 Anonymous Transactions Chaum has advocated the use of anonymous transactions as a way of protecting individuals from the maintenance by "Big Brother" of a database <p> Their compiler correctness and privacy is based on the existence of trapdoor functions. 35 Ben-Or, Goldwasser and Wigderson <ref> [20] </ref> and Chaum, Creapau, and Damg _ard [36] go one step further. They assume secret communication between pairs of users as a primitive.
Reference: [21] <author> R. Berger, R. Peralta, and T. Tedrick. </author> <title> A provably secure oblivious transfer protocol. </title> <editor> In T. Beth, N. Cot, and I. Ingemarsson, editors, </editor> <booktitle> Proceedings of EUROCRYPT 84, </booktitle> <pages> pages 379-386, </pages> <publisher> Springer, </publisher> <year> 1985. </year>
Reference-contexts: This strange-sounding protocol has a number of useful applications (see, for example <ref> [131, 21] </ref>). In fact, Kilian has recently shown [97] that the ability to perform oblivious transfers is a sufficiently strong primitive to enable any two-party protocol to be performed. 31 9.1.5 Other examples The problem of contract signing is that of simultaneously exchanging digital signatures to a contract.
Reference: [22] <author> E. Berlekamp. </author> <title> Factoring polynomials over large finite fields. </title> <journal> Math. Comp, </journal> <volume> 24 </volume> <pages> 713-735, </pages> <year> 1970. </year>
Reference-contexts: If n is prime, this computation can be performed in polynomial time <ref> [22, 4, 133] </ref>, while if n is composite, this problem seems to be as hard as factoring n or computing discrete logarithms modulo n.
Reference: [23] <author> L. Blum, M. Blum, and M. Shub. </author> <title> A simple unpredictable pseudo-random number generator. </title> <journal> SIAM J. Computing, </journal> <volume> 15(2) </volume> <pages> 364-383, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: How efficent are the probabilistic schemes? In the schemes described so far, the ciphertext is longer than the cleartext by a factor proportional to the security parameter. However, it has been shown <ref> [23, 27] </ref> using later ideas on pseudo-random number generation how to start with trapdoor functions and build a probabilistic encryption scheme that is polynomial-time secure for which the ciphertext is longer than the cleartext by only an additive factor. <p> If computing discrete logarithms modulo p is indeed difficult, then the sequences produced will be unpredictable. Blum, Blum, and Shub <ref> [23] </ref> propose another generator, called the x 2 mod n generator , which is simpler to implement and also provably secure (assuming that the quadratic residuousity problem is hard).
Reference: [24] <author> M. Blum. </author> <title> Coin flipping by telephone. </title> <booktitle> In Proc. IEEE Spring COMPCOM, </booktitle> <pages> pages 133-137, </pages> <publisher> IEEE, </publisher> <year> 1982. </year>
Reference-contexts: Another attack has been proposed by Coppersmith [42]. A number of authors have proposed extensions and variations of this protocol. 9.1.3 Coin Flipping Blum <ref> [24] </ref> has proposed the problem of coin flipping over the telephone. If Alice and Bob don't trust each other, then if they wish to flip a coin they need a procedure that will produce an outcome (head or tails) that can not be biased by either party.
Reference: [25] <author> M. Blum. </author> <title> How to exchange (secret) keys. </title> <journal> Trans. Computer Systems, </journal> <volume> 1 </volume> <pages> 175-193, </pages> <month> May </month> <year> 1983. </year> <month> 38 </month>
Reference-contexts: The certified electronic mail problem is similar to the contract-signing problem above. The goal is to achieve a simultaneous exchange of an electronic letter M and a signed receipt for M from the recipient. Another exchange problem is the simultaneous exchange of secrets. This has been studied in <ref> [25, 155, 110, 161] </ref>. 9.2 Zero-Knowledge Protocols The previous section listed a number of cryptographic protocol applications.
Reference: [26] <author> M. Blum. </author> <title> Independent unbiased coin flips from a correlated biased source: a finite state Markov chain. </title> <booktitle> In Proceedings of the 25th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 425-433, </pages> <publisher> IEEE, </publisher> <address> Singer Island, </address> <year> 1984. </year>
Reference-contexts: The result is an unbiased uncorrelated source, since the 01 and 10 pairs will have an identical probability of occurring. Elias [58] generalizes this idea to achieve an output rate near the source entropy. Handling a correlated bit source is more difficult. Blum <ref> [26] </ref> shows how to produce unbiased uncorrelated bits from a biased correlated source which produces output bits according to a known finite Markov chain.
Reference: [27] <author> M. Blum and S. Goldwasser. </author> <title> An efficient probabilistic public-key encryption scheme which hides all partial information. </title> <editor> In G. R. Blakley and D. C. Chaum, editors, </editor> <booktitle> Proceedings CRYPTO 84, </booktitle> <pages> pages 289-302, </pages> <publisher> Springer, </publisher> <year> 1985. </year> <note> Lecture Notes in Computer Science No. 196. </note>
Reference-contexts: How efficent are the probabilistic schemes? In the schemes described so far, the ciphertext is longer than the cleartext by a factor proportional to the security parameter. However, it has been shown <ref> [23, 27] </ref> using later ideas on pseudo-random number generation how to start with trapdoor functions and build a probabilistic encryption scheme that is polynomial-time secure for which the ciphertext is longer than the cleartext by only an additive factor. <p> The most efficient probabilistic encryption scheme is due to Blum and Goldwasser <ref> [27] </ref> and is comparable with the RSA deterministic encryption scheme in speed and data expansion. 6.4 Composition of Cryptographic Operators and Multiple Encryption Sometimes new cryptographic operators can be obtained by composing existing operators. The simplest example is that of multiple encryption.
Reference: [28] <author> M. Blum and S. Micali. </author> <title> How to generate cryptographically strong sequences of pseudo-random bits. </title> <journal> SIAM J. Computing, </journal> <volume> 13(4) </volume> <pages> 850-863, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: This is not strong enough to prove that, when used in a one-time pad scheme, each bit of the message will be well-protected. Blum and Micali <ref> [28] </ref> introduced the first method for designing provably secure pseudo-random bit sequence generators, based on the use of one-way predicates. <p> If we can then predict b i+1 = B (x ni1 ) = B (y) efficiently, we have contradicted our assumption that B (y) is difficult to compute from y alone. (The above proof sketch is made rigorous in <ref> [28] </ref>; the phrases "easy" and "hard" are made precise, and the definition of computing B (y) from y is generalized to include being able to predict B (y) with an accuracy greater than 1=2.) Blum and Micali then proposed a particular generator based on the difficulty of computing discrete logarithms and
Reference: [29] <author> G. Brassard. </author> <title> Introduction to Modern Cryptology. </title> <type> Technical Report 606, </type> <institution> Department d'informatique et de recherche operationelle, </institution> <year> 1987. </year>
Reference: [30] <author> G. Brassard. </author> <title> Relativized cryptography. </title> <booktitle> In Proc. 20th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 383-391, </pages> <publisher> IEEE, </publisher> <address> San Juan, Puerto Rico, </address> <year> 1979. </year>
Reference-contexts: There is much yet to be learned about the average-case complexity of problems. However, Levin [107] has introduced a formal notion of what it means for a problem to be "complete" in the sense of its average-case complexity. Brassard <ref> [30] </ref> has shown that in certain relativized models of computation secure cryptography is possible.
Reference: [31] <author> G. Brassard and C. Crepeau. </author> <title> Nontransitive transfer of confidence: a perfect zero-knowledge interactive protocol for SAT and beyond. </title> <booktitle> In Proceedings of the 27th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 188-195, </pages> <publisher> IEEE, </publisher> <address> Toronto, </address> <year> 1986. </year>
Reference-contexts: This theory was originated by Goldwasser, Micali, and Rackoff [80], and has been extended by many others, including Galil, Haber, and Yung [67], Chaum [34], Goldwasser and Sipser [83], and Brassard and Crepeau <ref> [31] </ref>. Zero-knowledge protocols are two-party protocols; one party is called the prover and the other the verifier. The prover knows some fact and wishes to convince the verifier of this fact.
Reference: [32] <author> E. F. Brickell. </author> <title> Breaking iterated knapsacks. </title> <editor> In G. R. Blakley and D. C. Chaum, editors, </editor> <booktitle> Proceedings CRYPTO 84, </booktitle> <pages> pages 342-358, </pages> <publisher> Springer, </publisher> <year> 1985. </year> <note> Lecture Notes in Computer Science No. 196. </note>
Reference-contexts: See <ref> [114, 140, 142, 1, 144, 100, 32, 122] </ref>. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme [39], and the multiplicative versions of the knapsack [114] are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes [113].
Reference: [33] <author> D. Chaum. </author> <title> Blind signatures for untraceable payments. </title> <editor> In R. L. Rivest, A. Sherman, and D. Chaum, editors, </editor> <booktitle> Proceedings CRYPTO 82, </booktitle> <pages> pages 199-204, </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: Using pseudonyms, individuals can enter into electronic transactions 34 with assurance that the transactions can not be later traced to the individual. However, since the individual is anonymous, the other party may wish assurance that the individual is authorized to enter into the transaction, or is able to pay. <ref> [35, 33] </ref>. 10.1.3 Voting Cryptographic technology can be used to manage an election so that every voter's vote remains private, but yet every voter can be sure that the vote-counting was not manipulated. (See Cohen and Fischer [41].) 10.2 Multiparty Ping-Pong Protocols One way of demonstrating that a cryptographic protocol is
Reference: [34] <author> D. Chaum. </author> <title> Demonstrating that a public predicate can be satisfied without revealing any information about how. </title> <editor> In A. M. Odlyzko, editor, </editor> <booktitle> Proceedings CRYPTO 86, </booktitle> <pages> pages 195-199, </pages> <publisher> Springer, </publisher> <year> 1987. </year> <note> Lecture Notes in Computer Science No. 263. </note>
Reference-contexts: Informally, a protocol is a zero-knowledge protocol if one party learns nothing (zero) from the protocol above and beyond what he is supposed to learn. This theory was originated by Goldwasser, Micali, and Rackoff [80], and has been extended by many others, including Galil, Haber, and Yung [67], Chaum <ref> [34] </ref>, Goldwasser and Sipser [83], and Brassard and Crepeau [31]. Zero-knowledge protocols are two-party protocols; one party is called the prover and the other the verifier. The prover knows some fact and wishes to convince the verifier of this fact.
Reference: [35] <author> D. Chaum. </author> <title> Untraceable electronic mail, return addresses, and digital pseudonyms. </title> <journal> Com-muncations of the ACM, </journal> <volume> 24 </volume> <pages> 84-88, </pages> <month> February </month> <year> 1981. </year>
Reference-contexts: Using pseudonyms, individuals can enter into electronic transactions 34 with assurance that the transactions can not be later traced to the individual. However, since the individual is anonymous, the other party may wish assurance that the individual is authorized to enter into the transaction, or is able to pay. <ref> [35, 33] </ref>. 10.1.3 Voting Cryptographic technology can be used to manage an election so that every voter's vote remains private, but yet every voter can be sure that the vote-counting was not manipulated. (See Cohen and Fischer [41].) 10.2 Multiparty Ping-Pong Protocols One way of demonstrating that a cryptographic protocol is
Reference: [36] <author> D. Chaum, C. Crepeau, and I. Damg _ard. </author> <title> Multi-party unconditionally secure protocols. </title> <booktitle> In Proc. 20th ACM Symposium on Theory of Computing, ACM, </booktitle> <address> Chicago, </address> <year> 1988. </year>
Reference-contexts: Their compiler correctness and privacy is based on the existence of trapdoor functions. 35 Ben-Or, Goldwasser and Wigderson [20] and Chaum, Creapau, and Damg _ard <ref> [36] </ref> go one step further. They assume secret communication between pairs of users as a primitive.
Reference: [37] <author> B. Chor and O. Goldreich. </author> <title> Unbiased bits from sources of weak randomness and probabilistic communication complexity. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 230-261, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: This is a rather practical and elegant solution. Chor and Goldreich <ref> [37] </ref> generalize these results, showing how to produce independent *-biased bits from even worse sources, where some output bits can even be completely determined.
Reference: [38] <author> B. Chor, S. Goldwasser, S. Micali, and B. Awerbuch. </author> <title> Verifiable secret sharing and achieving simultaneity in the presence of faults. </title> <booktitle> In Proceedings of the 26th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 383-395, </pages> <publisher> IEEE, </publisher> <address> Portland, </address> <year> 1985. </year>
Reference-contexts: Secondly, if some of the players are dishonest, at the reconstruction stage they may provide other players with different pieces than they received and again cause an incorrect secret to be reconstructed. Chor, Goldwasser, Micali, and Awerbuch <ref> [38] </ref> have observed the above problems and showed how to achieve secret sharing based on the intractability of factoring which does not suffer from the above problems.
Reference: [39] <author> B. Chor and R. L. Rivest. </author> <title> A knapsack type public-key cryptosystem based on arithmetic in finite fields. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 34(5) </volume> <pages> 901-909, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: See [114, 140, 142, 1, 144, 100, 32, 122]. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme <ref> [39] </ref>, and the multiplicative versions of the knapsack [114] are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes [113].
Reference: [40] <author> R. Cleve. </author> <title> Limits on the security of coin flips when half the processors are faulty. </title> <booktitle> In Proc. 18th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 364-369, </pages> <publisher> ACM, </publisher> <address> Berkeley, </address> <year> 1986. </year> <month> 39 </month>
Reference-contexts: Bob picks one of the ciphertexts, and indicates his choice to Alice. Alice then reveals the secret encryption key to Bob. There are a number of interesting variations and subtleties to this problem (see, for example, <ref> [79, 40] </ref>). 9.1.4 Oblivious Transfer An oblivious transfer is an unusual protocol wherein Bob transfers a message M to Alice in such a way that * With probability 1=2, Alice receives the message, and with probability 1=2, Alice receives garbage instead. * At the end of protocol Bob doesn't know whether
Reference: [41] <author> J. D. Cohen and M. J. Fischer. </author> <title> A robust and verifiable cryptographically secure election scheme. </title> <booktitle> In Proceedings of the 26th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 372-382, </pages> <publisher> IEEE, </publisher> <address> Portland, </address> <year> 1985. </year>
Reference-contexts: individual is authorized to enter into the transaction, or is able to pay. [35, 33]. 10.1.3 Voting Cryptographic technology can be used to manage an election so that every voter's vote remains private, but yet every voter can be sure that the vote-counting was not manipulated. (See Cohen and Fischer <ref> [41] </ref>.) 10.2 Multiparty Ping-Pong Protocols One way of demonstrating that a cryptographic protocol is secure is to show that the primitive operations that each party performs can not be composed to reveal any secret information.
Reference: [42] <author> D. Coppersmith. </author> <title> Cheating at mental poker. </title> <editor> In A. M. Odlyzko, editor, </editor> <booktitle> Proceedings CRYPTO 86, </booktitle> <pages> pages 104-107, </pages> <publisher> Springer, </publisher> <year> 1987. </year> <note> Lecture Notes in Computer Science No. 263. </note>
Reference-contexts: Another attack has been proposed by Coppersmith <ref> [42] </ref>. A number of authors have proposed extensions and variations of this protocol. 9.1.3 Coin Flipping Blum [24] has proposed the problem of coin flipping over the telephone.
Reference: [43] <author> D. Coppersmith. </author> <title> Evaluating logarithms in GF (2 n ). In Proc. </title> <booktitle> 16th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 201-207, </pages> <publisher> ACM, </publisher> <address> Washington, D.C., </address> <year> 1984. </year>
Reference-contexts: It interesting to note that working over the finite field GF (2 k ) rather than working modulo n seems to make the problem substantially easier (see Coppersmith <ref> [43] </ref> and Odlyzko [123]). See [44] for further improvements and general discussion.
Reference: [44] <editor> D. Coppersmith, A. M. Odlyzko, and R. Schroeppel. Dicrete logarithms in GF (p). Algorith-mica, </editor> <volume> 1(1) </volume> <pages> 1-16, </pages> <year> 1986. </year>
Reference-contexts: It interesting to note that working over the finite field GF (2 k ) rather than working modulo n seems to make the problem substantially easier (see Coppersmith [43] and Odlyzko [123]). See <ref> [44] </ref> for further improvements and general discussion. The other way to invert modular exponentiation is to solve for x: given y; e, and n, to compute an x (if any) such that x e y (mod n) is called computing the e-th root of y modulo n.
Reference: [45] <editor> D. W. Davies, editor. </editor> <booktitle> Tutorial: The Security of Data in Networks. IEEE, 1981. IEEE Computer Society Order #366. </booktitle>
Reference: [46] <editor> R. A. DeMillo, D. P. Dobkin, A. Jones, and R. J. Lipton, editors. </editor> <title> Foundations of Secure Computation. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: to explore further will find available many excellent texts, collections, and survey articles [9, 13, 29, 45, 49, 48, 53, 54, 51, 66, 91, 99, 102, 117, 146, 150, 149, 148, 151], works of historical or political interest [12, 69, 92, 138, 157], relevant conference proceedings (CRYPTO, EUROCRYPT, FOCS, STOC, <ref> [46, 86, 100] </ref>) and bibliographies [14, 129]. 6 * A key space K: a set of strings (keys) over some alphabet. * An encryption algorithm E mapping K fi M into C. * A decryption algorithm E mapping K fi C into M.
Reference: [47] <author> R. A. DeMillo, N. Lynch, and M. J. Merritt. </author> <title> Cryptographic protocols. </title> <booktitle> In Proc. 14th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 383-400, </pages> <publisher> ACM, </publisher> <address> San Francisco, </address> <year> 1982. </year>
Reference-contexts: Naor and Yung [119] who have shown how, starting with any one-way permutation, to design a digital signature scheme which is not existentially forgeable by chosen message attack. 9 Two-Party Protocols In this section we sketch a number of cryptographic protocol problems that have been addressed in the literature; see <ref> [47] </ref> for additional examples. 9.1 Examples 9.1.1 User Identification (Friend-or-Foe) Suppose A and B share a secret key K. Later, A is communicating with someone and he wishes to verify that it is B.
Reference: [48] <author> D. E. Denning. </author> <title> Cryptography and Data Security. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1982. </year>
Reference: [49] <author> D. E. Denning and P. J. Denning. </author> <title> Data security. </title> <journal> ACM Computing Surveys, </journal> <volume> 11 </volume> <pages> 227-249, </pages> <month> September </month> <year> 1979. </year>
Reference: [50] <author> W. Diffie and M. E. Hellman. </author> <title> Exhaustive cryptanalysis of the NBS data encryption standard. </title> <journal> Computer, </journal> <volume> 10 </volume> <pages> 74-84, </pages> <month> June </month> <year> 1977. </year>
Reference-contexts: Other such modes of operation for the use of DES, as well as proposed techniques for key management, have been published by the National Bureau of Standards. Diffie and Hellman <ref> [50] </ref> argue that the choice of a 56-bit key makes DES vulnerable to a brute force attack.
Reference: [51] <author> W. Diffie and M. E. Hellman. </author> <title> An introduction to cryptography. </title> <editor> In Slonim, Unger, and Fisher, editors, </editor> <booktitle> Advances in Data Communication Management, chapter 4, </booktitle> <pages> pages 44-134, </pages> <publisher> Wiley, </publisher> <year> 1984. </year>
Reference: [52] <author> W. Diffie and M. E. Hellman. </author> <title> Multiuser cryptographic techniques. </title> <booktitle> In Proceedings AFIPS 1976 National Computer Conference, </booktitle> <pages> pages 109-112, </pages> <publisher> AFIPS, </publisher> <address> Montvale, N.J., </address> <year> 1976. </year>
Reference-contexts: who wants to determine this key is left with the problem of computing g ab mod p from g a mod p and g b mod p; an apparently intractable problem. 6.2 Deterministic Public-Key Encryption The notion of a public-key cryptosystem was first published by Diffie and Hellman in 1976 <ref> [52, 53] </ref>, although Merkle had earlier developed some of the conceptual framework [115]. The central idea is that of a trapdoor function, as defined earlier. According to Diffie and Hellman, a public-key cryptosystem should contain the following parts: * A key generation algorithm.
Reference: [53] <author> W. Diffie and M. E. Hellman. </author> <title> New directions in cryptography. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT-22:644-654, </volume> <month> November </month> <year> 1976. </year>
Reference-contexts: 1 Introduction Ten years ago Diffie and Hellman proclaimed "We stand today on the brink of a revolution in cryptography." <ref> [53] </ref> Today we are in the midst of that revolution. During the last decade we have seen an explosion of research in cryptology. Many cryptosystems have been proposed, and many have been broken. <p> In such a case two parties can establish a shared secret key using exponential key exchange; an elegant technique proposed by Diffie and Hellman <ref> [53] </ref>. Let A and B be the two parties, and suppose that A and B agree (via a public dialogue that anyone can overhear) on a large prime p and a generator g of the multiplicative group Z fl p . <p> who wants to determine this key is left with the problem of computing g ab mod p from g a mod p and g b mod p; an apparently intractable problem. 6.2 Deterministic Public-Key Encryption The notion of a public-key cryptosystem was first published by Diffie and Hellman in 1976 <ref> [52, 53] </ref>, although Merkle had earlier developed some of the conceptual framework [115]. The central idea is that of a trapdoor function, as defined earlier. According to Diffie and Hellman, a public-key cryptosystem should contain the following parts: * A key generation algorithm. <p> The verifier can convince himself that the message contents have not been altered since the message was signed. Also, the signer can not later repudiate having signed the message, since no one but the signer possesses his private key. Diffie and Hellman <ref> [53] </ref> propose that with a public-key cryptosystem, a user A can sign any message M by appending his digital signature D A (M ) to M .
Reference: [54] <author> W. Diffie and M. E. Hellman. </author> <title> Privacy and authentication: an introduction to cryptography. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 67 </volume> <pages> 397-427, </pages> <month> March </month> <year> 1979. </year>
Reference: [55] <author> John D. Dixon. </author> <title> Factorization and primality tests. </title> <journal> The American Mathematical Monthly, </journal> <volume> 91(6) </volume> <pages> 333-352, </pages> <month> June-July </month> <year> 1984. </year>
Reference-contexts: Factoring numbers of more than 110 decimal digits is currently infeasible in general. Pomerance [127], Pomerance et al. [128], Riesel [135], and Dixon <ref> [55] </ref> discuss recent factoring methods. Let Z n denote the set of residue classes modulo n, and let Z fl n denote the multiplicative subgroup of Z n consisting of those residues which are relatively prime to n.
Reference: [56] <author> D. Dolev, S. Even, and R. M. Karp. </author> <title> On the security of ping-pong protocols. </title> <editor> In R. L. Rivest, A. Sherman, and D. Chaum, editors, </editor> <booktitle> Proceedings CRYPTO 82, </booktitle> <pages> pages 177-186, </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1983. </year> <month> 40 </month>
Reference-contexts: It is sometimes possible to prove that a protocol is invulnerable to this style of attack. Dolev and Yao [57] pioneered this style of proof; additional work was performed by Dolev, Even, and Karp <ref> [56] </ref>, Yao [162], and Even and Goldreich [61].
Reference: [57] <author> D. Dolev and A. C. Yao. </author> <title> On the security of public key protocols. </title> <booktitle> In Proceedings of the 22nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 350-357, </pages> <publisher> IEEE, </publisher> <address> Nashville, </address> <year> 1981. </year>
Reference-contexts: Consider a simple example due to Dolev and Yao <ref> [57] </ref> involving the use of public keys. Alice sends a message M to Bob, encrypting it with his public key, so that the ciphertext C is E B (M ) where E B is Bob's public encryption key. <p> It is sometimes possible to prove that a protocol is invulnerable to this style of attack. Dolev and Yao <ref> [57] </ref> pioneered this style of proof; additional work was performed by Dolev, Even, and Karp [56], Yao [162], and Even and Goldreich [61].
Reference: [58] <author> P. Elias. </author> <title> The efficient construction of an unbiased random sequence. </title> <journal> Ann. Math. Statist., </journal> <volume> 43(3) </volume> <pages> 865-870, </pages> <year> 1972. </year>
Reference-contexts: The result is an unbiased uncorrelated source, since the 01 and 10 pairs will have an identical probability of occurring. Elias <ref> [58] </ref> generalizes this idea to achieve an output rate near the source entropy. Handling a correlated bit source is more difficult. Blum [26] shows how to produce unbiased uncorrelated bits from a biased correlated source which produces output bits according to a known finite Markov chain.
Reference: [59] <author> A. Evans, W. Kantrowitz, and E. Weiss. </author> <title> A user authentication scheme not requiring secrecy in the computer. </title> <journal> CACM, </journal> <volume> 17 </volume> <pages> 437-442, </pages> <month> August </month> <year> 1974. </year>
Reference-contexts: In a time-shared computer system, instead of storing a table of login passwords, one can store, for each password w, the value f (w). Passwords can easily be checked for correctness at login, but even the system administrator can not deduce any user's password by examining the stored table <ref> [59] </ref>. 2. In a public-key cryptosystem (see the following sections), it may be more efficient to sign f (M ) rather than signing M itself, since M may be relatively long whereas f can be designed to return a fixed-length result.
Reference: [60] <author> S. Even and O. Goldreich. </author> <title> On the power of cascade ciphers. </title> <journal> ACM Trans. Computer Systems, </journal> <volume> 3 </volume> <pages> 108-116, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: Thus the composed system has difficulty proportional to 2 n , rather than proportional to 2 2n , as one would naively expect. One very intuitive result, due to Even and Goldreich <ref> [60] </ref> (see also [10]), is that the composition of encryption schemes A and B is no weaker than A or B individually|security is not lost by composition.
Reference: [61] <author> S. Even and O. Goldreich. </author> <title> On the security of multi-party ping-pong protocols. </title> <booktitle> In Proceedings of the 24th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 34-39, </pages> <publisher> IEEE, </publisher> <address> Tucson, </address> <year> 1983. </year>
Reference-contexts: It is sometimes possible to prove that a protocol is invulnerable to this style of attack. Dolev and Yao [57] pioneered this style of proof; additional work was performed by Dolev, Even, and Karp [56], Yao [162], and Even and Goldreich <ref> [61] </ref>.
Reference: [62] <author> S. Even, O. Goldreich, and A. Lempel. </author> <title> A randomized protocol for signing contracts. </title> <editor> In R. L. Rivest, A. Sherman, and D. Chaum, editors, </editor> <booktitle> Proceedings CRYPTO 82, </booktitle> <pages> pages 205-210, </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: That is, we assume that an ordinary digital signature scheme is available, and want to arrange a two-party protocol so that the signatures are effectively simultaneous | neither party obtains the other's signature before giving up his own. Several interesting solutions to the problem have been proposed (see <ref> [62] </ref> or [19]). The certified electronic mail problem is similar to the contract-signing problem above. The goal is to achieve a simultaneous exchange of an electronic letter M and a signed receipt for M from the recipient. Another exchange problem is the simultaneous exchange of secrets.
Reference: [63] <author> P. Feldman. </author> <title> A practical scheme for non-interactive verifiable secret sharing. </title> <booktitle> In Proceedings of the 28th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 427-438, </pages> <publisher> IEEE, </publisher> <address> Los Angeles, </address> <year> 1985. </year>
Reference-contexts: They call the new protocol verifiable secret sharing since now every party can verify that the piece of the secret he received is indeed a proper piece. Their protocol tolerated up to O (log n) colluders. Benaloh [16], and others <ref> [76, 63] </ref> showed how to achieve verifiable secret sharing if any one-way function exists which tolerates a minority of colluders.
Reference: [64] <author> A. Fiat and A. Shamir. </author> <title> How to prove yourself: practical solutions to identification and signature problems. </title> <editor> In A. M. Odlyzko, editor, </editor> <booktitle> Proceedings CRYPTO 86, </booktitle> <pages> pages 186-194, </pages> <publisher> Springer, </publisher> <year> 1987. </year> <note> Lecture Notes in Computer Science No. 263. </note>
Reference-contexts: The proof that graph three-colorability has such a zero-knowledge interactive proof system can be used to prove that every language in NP has such a zero-knowledge proof system. 9.2.2 Applications to User Identification Zero knowledge proofs provide a revolutionary new way to realize passwords <ref> [80, 64] </ref>. The idea is for every user to store a statement of a theorem in his publicly readable directory, the proof of which only he knows. Upon login, the user engages in a zero-knowledge proof of the correctness of the theorem. <p> If the proof is convincing, access permission is granted. This guarantees that even an adversary who overhears the zero-knowledge proof can not learn enough to gain unauthorized access. This is a novel property which can not be achieved with traditional password mechanisms. Recently, Fiat and Shamir <ref> [64] </ref> have developed variations on some of the previously proposed zero-knowledge protocols [80] which are quite efficient and particularly useful for user identification and passwords. 10 Multiparty Protocols In a typical multi-party protocol problem, a number of parties wish to coordinate their activities to achieve some goal, even though some (sufficiently
Reference: [65] <author> A. M. Frieze, J. Hastad, R. Kannan, J. C. Lagarias, and A. Shamir. </author> <title> Reconstructing truncated integer variables satisfying linear congruences. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 262-280, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: the bits of each X i are revealed, but a, b, and m are known, Frieze, Hastad, Kannan, Lagarias, and Shamir show how to determine the seed X 0 (and thus the entire sequence) using the marvelous lattice basis reduction (or "L 3 ") algorithm of Lenstra, Lenstra, and Lovasz <ref> [65, 104] </ref>.
Reference: [66] <author> H. F. Gaines. </author> <title> Cryptanalysis: A Study of Ciphers and Their Solutions. </title> <publisher> Dover, </publisher> <year> 1956. </year>
Reference: [67] <author> Z. Galil, S. Haber, and M. Yung. </author> <title> A private interactive test of a boolean predicate and minimum-knowledge public-key cryptosystems. </title> <booktitle> In Proceedings of the 26th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 360-371, </pages> <publisher> IEEE, </publisher> <address> Portland, </address> <year> 1985. </year>
Reference-contexts: Informally, a protocol is a zero-knowledge protocol if one party learns nothing (zero) from the protocol above and beyond what he is supposed to learn. This theory was originated by Goldwasser, Micali, and Rackoff [80], and has been extended by many others, including Galil, Haber, and Yung <ref> [67] </ref>, Chaum [34], Goldwasser and Sipser [83], and Brassard and Crepeau [31]. Zero-knowledge protocols are two-party protocols; one party is called the prover and the other the verifier. The prover knows some fact and wishes to convince the verifier of this fact.
Reference: [68] <author> M. Garey and D. S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: This problem is NP-complete <ref> [68] </ref>. To use the knapsack problem as the basis for a public-key cryptosystem, you create a public key by creating a knapsack vector a, and publish that as your public key. <p> For example, we may observe that if it turns out to be the case that P = N P (see <ref> [68] </ref>), then computational security would be unachievable, since the adversary's problem is easily seen to be in N P . (The adversary can just guess the secret keys, check their correctness against some known plaintext/ciphertext pairs, and thereby "break" the system.) If we assume that P 6= N P , then
Reference: [69] <author> J. Garlinski. </author> <title> Intercept: The Enigma War. </title> <publisher> Dent, </publisher> <address> London, </address> <year> 1979. </year>
Reference-contexts: Author's net address: rivest@theory.lcs.mit.edu 2 The reader who wishes to explore further will find available many excellent texts, collections, and survey articles [9, 13, 29, 45, 49, 48, 53, 54, 51, 66, 91, 99, 102, 117, 146, 150, 149, 148, 151], works of historical or political interest <ref> [12, 69, 92, 138, 157] </ref>, relevant conference proceedings (CRYPTO, EUROCRYPT, FOCS, STOC, [46, 86, 100]) and bibliographies [14, 129]. 6 * A key space K: a set of strings (keys) over some alphabet. * An encryption algorithm E mapping K fi M into C. * A decryption algorithm E mapping K
Reference: [70] <author> L. A. Gerhardt and R. C. Dixon, </author> <title> editors. </title> <journal> Spread Spectrum Communications. Volume COM25, IEEE, </journal> <month> August </month> <year> 1977. </year> <journal> Special issue of IEEE Trans. Comm. </journal>
Reference-contexts: Bennett et al. exploit the peculiarities of quantum effects in their channels [17]. And spread-spectrum channels are effectively unobservable to enemies who don't know the details of their use <ref> [70] </ref>. We do not pursue these variations further in this paper. * Information theory.
Reference: [71] <author> E. N. Gilbert, F. J. MacWilliams, and N. J. A. Sloane. </author> <title> Codes which detect deception. </title> <journal> Bell System Tech. J., </journal> <volume> 53 </volume> <pages> 405-424, </pages> <year> 1974. </year>
Reference-contexts: The information-theoretic basis for cryptographic security was developed by Shannon [146] and later refined by Hellman [90]. Gilbert, MacWilliams, and Sloane <ref> [71] </ref> have also extended information-theoretic approaches to handle the authentication problem. While the one-time pad provides provable security, it is awkward to use since a large key must be generated, shared, and stored. <p> It should be infeasible for an adversary, seeing f j (M 1 ); . . .; f j (M n ), to produce a valid tag f j (M ) for any other message M with a probability of success greater than random guessing. Gilbert, MacWilliams, Sloane <ref> [71] </ref> present techniques which make it information-theoretically impossible for an adversary to forge a valid tag with probability greater than random guessing.
Reference: [72] <author> J. Gill. </author> <title> Computational complexity of probabilistic Turing machines. </title> <journal> SIAM J. Computing, </journal> <volume> 6 </volume> <pages> 675-695, </pages> <month> December </month> <year> 1977. </year> <month> 41 </month>
Reference-contexts: Each party may use a private natural source of randomness (such as a noise diode) to produce "truly random" bits in order to generate his own secret keys or to perform randomized computations <ref> [72] </ref>. * Physical protection. Each party must physically protect his secrets from the adversary. His most important secret is usually the secret key that he has randomly generated|this key will provide him with unique capabilities.
Reference: [73] <author> O. Goldreich. </author> <title> Two remarks concerning the Goldwasser-Micali-Rivest signature scheme. </title> <type> Tech--nical Report MIT/LCS/TM-315, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> September </month> <year> 1986. </year>
Reference-contexts: However, it can be modified to allow more compact signatures, to make no use of memory between signatures other than for the public and secret keys, and even to remove the need of making random choices for every new signature. In particular, Goldreich <ref> [73] </ref> has made suggestions that make the factoring-based version of this scheme more practical while preserving its security properties. 29 Bellare and Micali in [15] have shown a digital signature scheme whose security can be based on the existence of any trapdoor permutation (a weaker requirement than claw-freeness).
Reference: [74] <author> O. Goldreich, S. Goldwasser, and S. Micali. </author> <title> How to construct random functions. </title> <booktitle> In Proceedings of the 25th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 464-479, </pages> <publisher> IEEE, </publisher> <address> Singer Island, </address> <year> 1984. </year>
Reference-contexts: Gilbert, MacWilliams, Sloane [71] present techniques which make it information-theoretically impossible for an adversary to forge a valid tag with probability greater than random guessing. Goldreich, Goldwasser, and Micali <ref> [74] </ref> show how to construct a family of pseudo-random functions from a cryptographically secure pseudo-random bit sequence generator, such that an adversary can not distinguish between f j (M ) and a randomly chosen string of the same length, even if the adversary is first allowed to examine f j (x
Reference: [75] <author> O. Goldreich and L. Levin. </author> <title> A hard-core predicate for all one-way functions. </title> <note> 1989. To appear in STOC '89. </note>
Reference-contexts: Yao, in a pioneering paper [163], showed that the existence of any trapdoor length-preserving permutation implies the existence of a trapdoor predicate. Recently, Goldreich and Levin simplified Yao's construction as follows. Theorem 3 (Goldreich-Levin <ref> [75] </ref>) If trapdoor length-preserving permutations exist, then B is a trapdoor predicate, where B is defined as follows. Let f : f0; 1g fl ! f0; 1g fl be a trapdoor length-preserving permutation. Let B (f (x); y) = xy mod 2 (the inner-product of x and y).
Reference: [76] <author> O. Goldreich, S. Micali, and A. Wigderson. </author> <title> Proofs that yield nothing but their validity and a methodology of cryptographic protocol design. </title> <booktitle> In Proceedings of the 27th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 174-187, </pages> <publisher> IEEE, </publisher> <address> Toronto, </address> <year> 1986. </year>
Reference-contexts: Examples of nontrivial NP languages for which there exist zero-knowledge protocols include quadratic residuosity and graph-isomorphism. (Curiously, the complements of both of these languages also possess zero-knowledge proofs.) More generally, it has been shown by Goldreich, Micali, and Wigderson <ref> [76] </ref> that every language in NP possesses a zero-knowledge protocol, on the assumption that there secure encryption is possible. (Probabilistic encryption schemes work fine here.) As a concrete example of a zero-knoledge protocol, suppose I wish to convince you that a certain input graph is three-colorable, without revealing to you the <p> They call the new protocol verifiable secret sharing since now every party can verify that the piece of the secret he received is indeed a proper piece. Their protocol tolerated up to O (log n) colluders. Benaloh [16], and others <ref> [76, 63] </ref> showed how to achieve verifiable secret sharing if any one-way function exists which tolerates a minority of colluders. <p> In other cases a modification of the protocol can eliminate or alleviate the danger; see [136] as an example of this approach against the danger of an adversary "inserting himself into the middle" of a public-key exchange protocol. 10.3 Multiparty Protocols When Most Parties are Honest Goldreich, Micali, and Wigderson <ref> [76] </ref> have shown how to "compile" a protocol designed for honest parties into one which will still work correctly even if some number less than half of the players try to "cheat".
Reference: [77] <author> S. Goldwasser and J. Kilian. </author> <title> Almost all primes can be quickly certified. </title> <booktitle> In Proc. 18th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 316-329, </pages> <publisher> ACM, </publisher> <address> Berkeley, </address> <year> 1986. </year>
Reference-contexts: Finding large prime numbers is useful for constructing cryptographic operators, while for many cryptosystems the adversary's task is provably as hard as factoring the product of two large prime numbers. There are efficient algorithms for generating random k-bit prime numbers; these algorithms run in time polynomial in k <ref> [152, 132, 77, 5, 3] </ref> and come in two flavors: Monte Carlo probabilistic algorithms which may err with small probability, always terminate in polynomial time and are quite efficient in practice; and Las Vegas probabilistic algorithms which are always correct, generate as output a deterministic polynomial time checkable proof of correctness,
Reference: [78] <author> S. Goldwasser and S. Micali. </author> <title> Probabilistic encryption. </title> <journal> JCSS, </journal> <volume> 28(2) </volume> <pages> 270-299, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: That is, each party will publish his own trapdoor function f , and only the party who publishes a given trapdoor function f will be able to invert that function. 5.3 One-Way (and Trapdoor) Predicates A one-way predicate, first introduced in <ref> [79, 78] </ref>, is a boolean function B : f0; 1g fl ! f0; 1g such that 1. <p> The pioneering work in this direction was performed by Goldwasser and Micali <ref> [79, 78] </ref>. Although the use of randomized techniques was itself not new (for example, [113]), using randomization to achieve a provable level of security was novel. <p> Essentially, this coincides with the existing formal security notions. Achieving it rules out all of the problems listed above. 6.3.3 Definition of Security: Polynomial-Time Security Several definitions of security for probabilistic encryption schemes have been proposed and studied in <ref> [79, 163, 78] </ref>. All definitions proposed so far have been shown to be equivalent in [78, 118]. We provide one definition in detail, due to Goldwasser and Micali [78]. <p> Achieving it rules out all of the problems listed above. 6.3.3 Definition of Security: Polynomial-Time Security Several definitions of security for probabilistic encryption schemes have been proposed and studied in [79, 163, 78]. All definitions proposed so far have been shown to be equivalent in <ref> [78, 118] </ref>. We provide one definition in detail, due to Goldwasser and Micali [78]. <p> All definitions proposed so far have been shown to be equivalent in [78, 118]. We provide one definition in detail, due to Goldwasser and Micali <ref> [78] </ref>. <p> two messages m 0 and m 1 , can not distinguish between a random encryption of m 0 and a random encryption of m 1 with probability greater than 1=2 + 1=k c for all c. 19 6.3.4 Probabilistic Encryption We begin by describing the probabilistic encryption technique proposed in <ref> [79, 78] </ref>. Alice creates a public key consisting of two parts: an integer n which is the product of two large primes p and q, and a pseudo-square y 2 ~ Q n . <p> The following theorem due to Goldwasser and Micali shows that if this decision problem is hard at all then it is everywhere hard. Theorem 1 (Goldwasser-Micali <ref> [79, 78] </ref>) Let S fnjn = pq; jpj jqjg. <p> A natural generalization of the scheme based on any trapdoor predicate follows from <ref> [78] </ref>. <p> Sends x i to Alice. To decrypt, Alice, who knows the trapdoor information, computes m i = B (x i ) for all i = 1; :::; k. Theorem 2 (Goldwasser-Micali <ref> [78] </ref>) If trapdoor predicates exist, then the above probabilistic public-key encryption scheme is polynomial-time secure. Implementation of trapdoor predicates based on the problem of factoring integers, and of inverting the RSA function can be found in [6]. We outline the RSA-based implementation. <p> Then the composition of a (1 *)-secure encryption scheme with a (1 ffi)-secure encryption scheme is (*ffi (2 max (*; ffi)))-secure. This is an improvement whenever max (*; ffi) &lt; 1. In a similar vein, a number of researchers <ref> [78, 163, 106] </ref> have developed and refined proofs that the bit-wise XOR of several independent pseudo-random bit sequence generators is harder to predict (by a quantifiable amount) than any of the component generators. 7 Generating Random or Pseudo-Random Sequences and Func tions We now examine in some detail the problem of
Reference: [79] <author> S. Goldwasser and S. Micali. </author> <title> Probabilistic encryption and how to play mental poker keeping secret all partial information. </title> <booktitle> In Proc. 14th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 365-377, </pages> <publisher> ACM, </publisher> <address> San Francisco, </address> <year> 1982. </year>
Reference-contexts: That is, each party will publish his own trapdoor function f , and only the party who publishes a given trapdoor function f will be able to invert that function. 5.3 One-Way (and Trapdoor) Predicates A one-way predicate, first introduced in <ref> [79, 78] </ref>, is a boolean function B : f0; 1g fl ! f0; 1g such that 1. <p> The pioneering work in this direction was performed by Goldwasser and Micali <ref> [79, 78] </ref>. Although the use of randomized techniques was itself not new (for example, [113]), using randomization to achieve a provable level of security was novel. <p> Essentially, this coincides with the existing formal security notions. Achieving it rules out all of the problems listed above. 6.3.3 Definition of Security: Polynomial-Time Security Several definitions of security for probabilistic encryption schemes have been proposed and studied in <ref> [79, 163, 78] </ref>. All definitions proposed so far have been shown to be equivalent in [78, 118]. We provide one definition in detail, due to Goldwasser and Micali [78]. <p> two messages m 0 and m 1 , can not distinguish between a random encryption of m 0 and a random encryption of m 1 with probability greater than 1=2 + 1=k c for all c. 19 6.3.4 Probabilistic Encryption We begin by describing the probabilistic encryption technique proposed in <ref> [79, 78] </ref>. Alice creates a public key consisting of two parts: an integer n which is the product of two large primes p and q, and a pseudo-square y 2 ~ Q n . <p> The following theorem due to Goldwasser and Micali shows that if this decision problem is hard at all then it is everywhere hard. Theorem 1 (Goldwasser-Micali <ref> [79, 78] </ref>) Let S fnjn = pq; jpj jqjg. <p> Bob picks one of the ciphertexts, and indicates his choice to Alice. Alice then reveals the secret encryption key to Bob. There are a number of interesting variations and subtleties to this problem (see, for example, <ref> [79, 40] </ref>). 9.1.4 Oblivious Transfer An oblivious transfer is an unusual protocol wherein Bob transfers a message M to Alice in such a way that * With probability 1=2, Alice receives the message, and with probability 1=2, Alice receives garbage instead. * At the end of protocol Bob doesn't know whether
Reference: [80] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The knowledge complexity of interactive proof-systems. </title> <journal> SIAM. J. Computing, </journal> <volume> 18(1) </volume> <pages> 186-208, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Informally, a protocol is a zero-knowledge protocol if one party learns nothing (zero) from the protocol above and beyond what he is supposed to learn. This theory was originated by Goldwasser, Micali, and Rackoff <ref> [80] </ref>, and has been extended by many others, including Galil, Haber, and Yung [67], Chaum [34], Goldwasser and Sipser [83], and Brassard and Crepeau [31]. Zero-knowledge protocols are two-party protocols; one party is called the prover and the other the verifier. <p> The proof that graph three-colorability has such a zero-knowledge interactive proof system can be used to prove that every language in NP has such a zero-knowledge proof system. 9.2.2 Applications to User Identification Zero knowledge proofs provide a revolutionary new way to realize passwords <ref> [80, 64] </ref>. The idea is for every user to store a statement of a theorem in his publicly readable directory, the proof of which only he knows. Upon login, the user engages in a zero-knowledge proof of the correctness of the theorem. <p> This guarantees that even an adversary who overhears the zero-knowledge proof can not learn enough to gain unauthorized access. This is a novel property which can not be achieved with traditional password mechanisms. Recently, Fiat and Shamir [64] have developed variations on some of the previously proposed zero-knowledge protocols <ref> [80] </ref> which are quite efficient and particularly useful for user identification and passwords. 10 Multiparty Protocols In a typical multi-party protocol problem, a number of parties wish to coordinate their activities to achieve some goal, even though some (sufficiently small) subset of them may have been corrupted 33 by an adversary.
Reference: [81] <author> S. Goldwasser, S. Micali, and P. Tong. </author> <title> Why and how to establish a private code on a public network. </title> <booktitle> In Proceedings of the 23rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 134-144, </pages> <publisher> IEEE, </publisher> <address> Chicago, </address> <year> 1982. </year>
Reference-contexts: One might interpret this as saying that either RSA is uniformly secure or it is uniformly insecure. Even stronger results have been proven. For example, it has been shown <ref> [81, 6, 18] </ref> that if a polynomial fraction of RSA ciphertexts can't be decrypted in polynomial time, then neither can just the least significant bit of the message be guessed from the ciphertext with better than an * bias.
Reference: [82] <author> S. Goldwasser, S. Micali, and A. Yao. </author> <title> Strong signature schemes. </title> <booktitle> In Proc. 15th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 431-439, </pages> <publisher> ACM, </publisher> <address> Boston, </address> <year> 1983. </year>
Reference-contexts: A review of signature schemes can be found in [84]. 8.1 Proving Security of Signature Schemes A theoretical treatment of digital signatures security was started by Goldwasser, Micali and Yao in <ref> [82] </ref> and continued in [84, 15],and recently [119]. <p> This approach was pioneered by Goldwasser, Micali, and Yao <ref> [82] </ref>, who presented signature schemes based on the difficulty of factoring and on the difficulty of inverting the RSA function for which it is provably hard for the adversary to existentially forge using a known signature attack.
Reference: [83] <author> S. Goldwasser and M. Sipser. </author> <title> Private coins versus public coins in interactive proof systems. </title> <booktitle> In Proc. 18th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 59-68, </pages> <publisher> ACM, </publisher> <address> Berkeley, </address> <year> 1986. </year>
Reference-contexts: This theory was originated by Goldwasser, Micali, and Rackoff [80], and has been extended by many others, including Galil, Haber, and Yung [67], Chaum [34], Goldwasser and Sipser <ref> [83] </ref>, and Brassard and Crepeau [31]. Zero-knowledge protocols are two-party protocols; one party is called the prover and the other the verifier. The prover knows some fact and wishes to convince the verifier of this fact.
Reference: [84] <author> Shafi Goldwasser, S. Micali, and R. Rivest. </author> <title> A digital signature scheme secure against adaptive chosen-message attacks. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 281-308, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: In general, knapsack-type schemes are not well-suited for use as signatures schemes, since the mapping M a is not "onto", and no effective remedy has been proposed. A review of signature schemes can be found in <ref> [84] </ref>. 8.1 Proving Security of Signature Schemes A theoretical treatment of digital signatures security was started by Goldwasser, Micali and Yao in [82] and continued in [84, 15],and recently [119]. <p> A review of signature schemes can be found in [84]. 8.1 Proving Security of Signature Schemes A theoretical treatment of digital signatures security was started by Goldwasser, Micali and Yao in [82] and continued in <ref> [84, 15] </ref>,and recently [119]. <p> The choice of these messages may depend on previously obtained signatures. For example, one may think of a notary public who signs documents on demand. For a finer subdivision of the adversary's possible attacks see <ref> [84] </ref>. 8.1.2 What does it mean to successfuly forge a signature? We distinguish several levels of success for an adversary, listed below in the order of increasing success for the adversary. * Existential Forgery: The adversary succeeds in forging the signature of one message, not necessarily of his choice. * Selective <p> Goldwasser, Micali, and Rivest <ref> [84] </ref> have strengthened this result by proposing a signature scheme which is not existentially forgeable under a chosen message attack.
Reference: [85] <author> S. W. Golomb. </author> <title> Shift Register Sequences. </title> <publisher> Aegean Park Press, </publisher> <address> Laguna Hills, </address> <year> 1982. </year> <note> Revised edition. </note>
Reference-contexts: How can one construct secure pseudo-random sequence generators? 7.2.1 Classical Pseudo-random Generators are Unsuitable Classical techniques for pseudo-random number generation [98, Chapter 3] which are quite useful and effective for Monte Carlo simulations are typically unsuitable for cryptographic applications. For example, linear feedback shift registers <ref> [85] </ref> are well-known to be cryptographically insecure; one can solve for the feedback pattern given a small number of output bits. Linear congruential random number generators are also insecure.
Reference: [86] <editor> G. Goos and J. Hartmanis, editors. </editor> <booktitle> Cryptography: Proceedings of the Workshop on Cryptography. Springer, Burg Feuerstein, 1983. Lecture Notes in Computer Science No. </booktitle> <pages> 149. </pages>
Reference-contexts: to explore further will find available many excellent texts, collections, and survey articles [9, 13, 29, 45, 49, 48, 53, 54, 51, 66, 91, 99, 102, 117, 146, 150, 149, 148, 151], works of historical or political interest [12, 69, 92, 138, 157], relevant conference proceedings (CRYPTO, EUROCRYPT, FOCS, STOC, <ref> [46, 86, 100] </ref>) and bibliographies [14, 129]. 6 * A key space K: a set of strings (keys) over some alphabet. * An encryption algorithm E mapping K fi M into C. * A decryption algorithm E mapping K fi C into M.
Reference: [87] <author> J. Grollman and A. L. Selman. </author> <title> Complexity measures for public-key cryptosystems. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 309-335, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: However, this is difficult to arrange, since cryptographic problems usually have unique solutions, whereas NP-complete problems may have many solutions. It is not easy to reduce a problem with many solutions to a problem having a unique solution. Grollman and Selman <ref> [87] </ref> show that one-way functions exist if and only if P 6= U P , where U P is the class of languages accepted by a nondeterministic Turing machine which has at most one accepting computation for any input.
Reference: [88] <author> J. Hastad. </author> <title> Solving simultaneous modular equations of low degree. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 336-341, </pages> <month> April </month> <year> 1988. </year> <month> 42 </month>
Reference-contexts: For example, it has been shown [81, 6, 18] that if a polynomial fraction of RSA ciphertexts can't be decrypted in polynomial time, then neither can just the least significant bit of the message be guessed from the ciphertext with better than an * bias. Hastad <ref> [88] </ref> shows that it is unwise to use a low encryption exponent e, such as 3, if it is likely that a user may send the same message (or the same message with known variations) to a number of other users. 6.2.2 Knapsacks A number of public-key cryptosystems have been proposed
Reference: [89] <author> M. E. Hellman. </author> <title> A cryptanalytic time-memory trade off. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT--26:401-406, </volume> <year> 1980. </year>
Reference-contexts: Using a known-plaintext attack, Hellman shows how to break DES by performing a large pre-computation which essentially searches the entire key space, and which saves selected results, so that a time-memory tradeoff results for the problem of later determining an unknown key used to encrypt the known plaintext <ref> [89] </ref>. 3 The Goals and Tools of Cryptology As cryptology has developed, the number of goals addressed has expanded, as has the number of tools available for achieving those goals. In this section we survey some key goals and tools.
Reference: [90] <author> M. E. Hellman. </author> <title> An extension of the Shannon theory approach to cryptography. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT-23:289-294, </volume> <year> 1977. </year>
Reference-contexts: This one-time pad is thus provably secure in an information-theoretic sense since the interceptor never has enough information to decrypt the ciphertext, and no amount of computational power could help him. The information-theoretic basis for cryptographic security was developed by Shannon [146] and later refined by Hellman <ref> [90] </ref>. Gilbert, MacWilliams, and Sloane [71] have also extended information-theoretic approaches to handle the authentication problem. While the one-time pad provides provable security, it is awkward to use since a large key must be generated, shared, and stored. <p> Some systems, such as the Vernam one-time pad [92] are secure in an information-theoretic sense: the adversary is never given enough information to work with to break the code; no amount of computational power can help him overcome this. (See Shannon [146] and Hellman <ref> [90] </ref>.) * Computational complexity theory. The adversary's task is more often computationally infeasible, rather than information-theoretically impossible.
Reference: [91] <author> M. E. Hellman. </author> <title> The mathematics of public key cryptography. </title> <journal> Scientific American, </journal> <volume> 241 </volume> <pages> 146-157, </pages> <month> February </month> <year> 1979. </year>
Reference: [92] <editor> D. Kahn. </editor> <booktitle> The Codebreakers. </booktitle> <address> Macmillian, New York, </address> <year> 1967. </year>
Reference-contexts: The invention of radio gave a tremendous impetus to cryptography, since an adversary can eavesdrop easily over great distances. The course of World War II was significantly affected by the use, misuse, and breaking of cryptographic systems used for radio traffic <ref> [92] </ref>. It is intriguing that the computational engines designed and built by the British to crack the German Enigma cipher are deemed by some to be the first real "computers"; one could argue that cryptography is the mother (or at least the midwife) of computer science. <p> Author's net address: rivest@theory.lcs.mit.edu 2 The reader who wishes to explore further will find available many excellent texts, collections, and survey articles [9, 13, 29, 45, 49, 48, 53, 54, 51, 66, 91, 99, 102, 117, 146, 150, 149, 148, 151], works of historical or political interest <ref> [12, 69, 92, 138, 157] </ref>, relevant conference proceedings (CRYPTO, EUROCRYPT, FOCS, STOC, [46, 86, 100]) and bibliographies [14, 129]. 6 * A key space K: a set of strings (keys) over some alphabet. * An encryption algorithm E mapping K fi M into C. * A decryption algorithm E mapping K <p> It was invented in 1917 by Gilbert Vernam <ref> [92] </ref> for use in telegraphy and has stimulated much subsequent work in cryptography. The one-time pad is a secret-key cryptosystem where the key is as long as the message being encrypted. Furthermore, the key, once used, is discarded and never reused. <p> By contrast, design information such as equipment blueprints or cryptographic algorithm details is usually assumed to be unprotectable, so security does not usually require the secrecy of such design information. (Kerckhoffs second requirement <ref> [92, p. 235] </ref> of a cryptosystem was that "compromise of the system should not inconvenience the correspondents.") * Channel properties. Unusual properties of the communication channel can sometimes be exploited. <p> And spread-spectrum channels are effectively unobservable to enemies who don't know the details of their use [70]. We do not pursue these variations further in this paper. * Information theory. Some systems, such as the Vernam one-time pad <ref> [92] </ref> are secure in an information-theoretic sense: the adversary is never given enough information to work with to break the code; no amount of computational power can help him overcome this. (See Shannon [146] and Hellman [90].) * Computational complexity theory.
Reference: [93] <author> B. S. Kaliski, Jr. </author> <title> Elliptic Curves and Cryptography: A Pseudorandom Bit Generator and Other Tools. </title> <type> PhD thesis, </type> <institution> MIT EECS Dept., </institution> <month> January </month> <year> 1988. </year> <note> Published as MIT LCS Technical Report MIT/LCS/TR-411 (Jan. </note> <year> 1988). </year>
Reference-contexts: Kaliski shows how to extend these methods so that the security of the generator depends on the difficulty of computing elliptic logarithms; his techniques also generalize to other groups <ref> [94, 93] </ref>. To improve efficiency, it is desirable to obtain as many random bits as possible from each application of f . That is, B (x) should return more than one bit of information.
Reference: [94] <author> B. S. Kaliski, Jr. </author> <title> A pseudo-random bit generator based on elliptic logarithms. </title> <editor> In A. M. Odlyzko, editor, </editor> <booktitle> Proceedings CRYPTO 86, </booktitle> <pages> pages 84-103, </pages> <publisher> Springer, </publisher> <year> 1987. </year> <note> Lecture Notes in Computer Science No. 263. </note>
Reference-contexts: Kaliski shows how to extend these methods so that the security of the generator depends on the difficulty of computing elliptic logarithms; his techniques also generalize to other groups <ref> [94, 93] </ref>. To improve efficiency, it is desirable to obtain as many random bits as possible from each application of f . That is, B (x) should return more than one bit of information.
Reference: [95] <author> B. S. Kaliski, Jr., R. L. Rivest, and A. Sherman. </author> <title> Is DES a pure cipher? (results of more cycling experiments on DES),. </title> <editor> In H. C. Williams, editor, </editor> <booktitle> Proceedings CRYPTO 85, </booktitle> <pages> pages 212-226, </pages> <publisher> Springer, </publisher> <year> 1986. </year> <note> Lecture Notes in Computer Science No. 218. </note>
Reference-contexts: On the other hand, multiple encryption using DES probably does increase security somewhat (see <ref> [95, 147] </ref>). It is worth noting that the composition of two cryptosystems with n-bit keys can be broken in time O (2 n ) and space O (2 n ), using a meet-in-the-middle attack.
Reference: [96] <author> R. Kannan, A. Lenstra, and L. Lovasz. </author> <title> Polynomial factorization and non-randomness of bits of algebraic and some transcendental numbers. </title> <booktitle> In Proc. 16th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 191-200, </pages> <publisher> ACM, </publisher> <address> Washington, D.C., </address> <year> 1984. </year>
Reference-contexts: As a final example of the cryptographic unsuitability of classical methods, Kannan, Lenstra, and Lovasz <ref> [96] </ref> use the L 3 algorithm to show that the binary expansion of any algebraic number y (such as p 5 = 10:001111000110111 . . .) is insecure, since an adversary can identify y exactly from a sufficient number of bits, and then extrapolate y's expansion. 7.2.2 Provably Secure Pseudo-Random Generators
Reference: [97] <author> J. Kilian. </author> <title> Founding cryptography on oblivious transfer. </title> <booktitle> In Proc. 20th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 20-31, </pages> <publisher> ACM, </publisher> <address> Chicago, </address> <year> 1988. </year>
Reference-contexts: This strange-sounding protocol has a number of useful applications (see, for example [131, 21]). In fact, Kilian has recently shown <ref> [97] </ref> that the ability to perform oblivious transfers is a sufficiently strong primitive to enable any two-party protocol to be performed. 31 9.1.5 Other examples The problem of contract signing is that of simultaneously exchanging digital signatures to a contract.
Reference: [98] <author> D. E. Knuth. </author> <booktitle> The Art of Computer Programming: </booktitle> <volume> Vol. 2, </volume> <booktitle> Seminumerical Algorithms. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1969. </year>
Reference-contexts: Most importantly, the adversary should not be able to efficiently infer the seed x from the knowledge of some bits of y. How can one construct secure pseudo-random sequence generators? 7.2.1 Classical Pseudo-random Generators are Unsuitable Classical techniques for pseudo-random number generation <ref> [98, Chapter 3] </ref> which are quite useful and effective for Monte Carlo simulations are typically unsuitable for cryptographic applications. For example, linear feedback shift registers [85] are well-known to be cryptographically insecure; one can solve for the feedback pattern given a small number of output bits.
Reference: [99] <author> A. G. Konheim. </author> <title> Cryptography: A Primer. </title> <publisher> Wiley, </publisher> <year> 1981. </year>
Reference: [100] <author> J. C. Lagarias and A. M. Odlyzko. </author> <title> Solving low-density subset sum problems. </title> <booktitle> In Proceedings of the 24th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 1-10, </pages> <publisher> IEEE, </publisher> <address> Tucson, </address> <year> 1983. </year>
Reference-contexts: to explore further will find available many excellent texts, collections, and survey articles [9, 13, 29, 45, 49, 48, 53, 54, 51, 66, 91, 99, 102, 117, 146, 150, 149, 148, 151], works of historical or political interest [12, 69, 92, 138, 157], relevant conference proceedings (CRYPTO, EUROCRYPT, FOCS, STOC, <ref> [46, 86, 100] </ref>) and bibliographies [14, 129]. 6 * A key space K: a set of strings (keys) over some alphabet. * An encryption algorithm E mapping K fi M into C. * A decryption algorithm E mapping K fi C into M. <p> See <ref> [114, 140, 142, 1, 144, 100, 32, 122] </ref>. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme [39], and the multiplicative versions of the knapsack [114] are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes [113].
Reference: [101] <author> L. Lamport. </author> <title> Constructing Digital Signatures from a One-Way Function. </title> <type> Technical Report CSL-98, </type> <institution> SRI International, </institution> <month> October </month> <year> 1979. </year>
Reference-contexts: Just as some cryptographic schemes are suited for encryption but not signatures, some proposals have been made for signature-only schemes. Some early suggestions were made that were based on the use of one-way functions or conventional cryptography <ref> [101, 134] </ref>.
Reference: [102] <author> A. Lempel. </author> <title> Cryptology in transition: a survey. </title> <journal> Computing Surveys, </journal> <volume> 11 </volume> <pages> 285-304, </pages> <month> December </month> <year> 1979. </year>
Reference-contexts: They also show that secure public-key cryptosystems exist only if P 6= U P . Lempel and Yacobi <ref> [102] </ref> present a curious cryptographic system for which the cryptanalytic problem is NP-complete in general, even for chosen-plaintext attacks, but which is likely to be easily breakable in practice.
Reference: [103] <author> A. K. Lenstra and H. W. Lenstra, Jr. </author> <title> Algorithms in number theory. In this volume, </title> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: In this section we review some basic number-theoretic and computational facts. For a more extensive review of elementary number theory see [121], [105], or [8]. An excellent overview of the problems of factoring integers, testing primality, and computing discrete logarithms also appears in this volume <ref> [103] </ref>. It is apparently the case that it is dramatically easier to tell whether a given number is prime or composite than it is to factor a given composite number into its constituent prime factors; this difference in computational difficulty is the basis for many cryptosystems.
Reference: [104] <author> A. K. Lenstra, H. W. Lenstra, Jr., and L. Lovasz. </author> <title> Factoring polynomials with rational coefficients. </title> <journal> Methematische Ann., </journal> <volume> 261 </volume> <pages> 513-534, </pages> <year> 1982. </year>
Reference-contexts: so that the difficulty of breaking such a knapsack is no longer related to the P = N P question. 17 In fact, history has not been kind to knapsack schemes; most of them have been broken by extremely clever analysis and the use of the powerful L 3 algorithm <ref> [104] </ref> for working in lattices. See [114, 140, 142, 1, 144, 100, 32, 122]. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme [39], and the multiplicative versions of the knapsack [114] are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes [113]. <p> the bits of each X i are revealed, but a, b, and m are known, Frieze, Hastad, Kannan, Lagarias, and Shamir show how to determine the seed X 0 (and thus the entire sequence) using the marvelous lattice basis reduction (or "L 3 ") algorithm of Lenstra, Lenstra, and Lovasz <ref> [65, 104] </ref>.
Reference: [105] <author> W. J. LeVeque. </author> <title> Fundamentals of Number Theory. </title> <publisher> Addison-Wesley, </publisher> <year> 1977. </year> <month> 43 </month>
Reference-contexts: In this section we review some basic number-theoretic and computational facts. For a more extensive review of elementary number theory see [121], <ref> [105] </ref>, or [8]. An excellent overview of the problems of factoring integers, testing primality, and computing discrete logarithms also appears in this volume [103].
Reference: [106] <author> L. A. Levin. </author> <title> One-way functions and pseudorandom generators. </title> <booktitle> In Proc. 17th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 363-365, </pages> <publisher> ACM, </publisher> <address> Providence, </address> <year> 1985. </year>
Reference-contexts: Then the composition of a (1 *)-secure encryption scheme with a (1 ffi)-secure encryption scheme is (*ffi (2 max (*; ffi)))-secure. This is an improvement whenever max (*; ffi) &lt; 1. In a similar vein, a number of researchers <ref> [78, 163, 106] </ref> have developed and refined proofs that the bit-wise XOR of several independent pseudo-random bit sequence generators is harder to predict (by a quantifiable amount) than any of the component generators. 7 Generating Random or Pseudo-Random Sequences and Func tions We now examine in some detail the problem of <p> The Blum-Micali and Blum-Blum-Shub generators, together with the proof of Yao, represent a major achievement in the development of provably secure cryptosystems. Levin <ref> [106] </ref> shows that perfect pseudo-random bit generators exist if and only if there exists a one-way function f that can not be inverted easily at points of the form f t (x), the t-th iterate of f applied to a random point x 2 f0; 1g k . 25 7.2.3 Pseudo-Random
Reference: [107] <author> L. A. Levin. </author> <title> Problems, complete in `average' instance. </title> <booktitle> In Proc. 16th ACM Symposium on Theory of Computing, </booktitle> <pages> page 465, </pages> <publisher> ACM, </publisher> <address> Washington, D.C., </address> <year> 1984. </year>
Reference-contexts: There is much yet to be learned about the average-case complexity of problems. However, Levin <ref> [107] </ref> has introduced a formal notion of what it means for a problem to be "complete" in the sense of its average-case complexity. Brassard [30] has shown that in certain relativized models of computation secure cryptography is possible.
Reference: [108] <author> R. Lipton. </author> <title> How to cheat at mental poker. </title> <booktitle> In Proc. AMS Short Course on Cryptography, </booktitle> <year> 1981. </year>
Reference-contexts: This technique requires the use of commutative encryption functions. The particular scheme as proposed may be less satisfactory than desired (depending on the coding of the cards) since, as pointed out by Lipton <ref> [108] </ref>, M will have Jacobi symbol 1 if and only if E A (M ) does | the function E A leaks a bit. Another attack has been proposed by Coppersmith [42].
Reference: [109] <author> D. L. Long and A. Wigderson. </author> <title> The discrete logarithm problem hides O(log n) bits. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 363-372, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: To improve efficiency, it is desirable to obtain as many random bits as possible from each application of f . That is, B (x) should return more than one bit of information. Long and Wigderson <ref> [109] </ref> show how to extract c log log p pseudo-random bits from each x i instead of just one bit as in the Blum-Micali generator. A similar result has been shown for the RSA generator [6].
Reference: [110] <author> M. Luby, S. Micali, and C. Rackoff. </author> <title> How to simultaneously exchange a secret bit by flipping a symmetrically biased coin. </title> <booktitle> In Proceedings of the 24th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 11-22, </pages> <publisher> IEEE, </publisher> <address> Tucson, </address> <year> 1983. </year>
Reference-contexts: The certified electronic mail problem is similar to the contract-signing problem above. The goal is to achieve a simultaneous exchange of an electronic letter M and a signed receipt for M from the recipient. Another exchange problem is the simultaneous exchange of secrets. This has been studied in <ref> [25, 155, 110, 161] </ref>. 9.2 Zero-Knowledge Protocols The previous section listed a number of cryptographic protocol applications.
Reference: [111] <author> M. Luby and C. Rackoff. </author> <title> How to construct pseudorandom permutations and pseudorandom functions. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 373-386, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: They assume that the two encryption keys are chosen independently and that the adversary can request the encryption of arbitrary text (that is, he can use a chosen-plaintext attack). Luby and Rackoff <ref> [112, 111] </ref> prove a more powerful result, which shows that the composition generally increases security.
Reference: [112] <author> M. Luby and C. Rackoff. </author> <title> Pseudo-random permutation generators and cryptographic composition. </title> <booktitle> In Proc. 18th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 356-363, </pages> <publisher> ACM, </publisher> <address> Berkeley, </address> <year> 1986. </year>
Reference-contexts: They assume that the two encryption keys are chosen independently and that the adversary can request the encryption of arbitrary text (that is, he can use a chosen-plaintext attack). Luby and Rackoff <ref> [112, 111] </ref> prove a more powerful result, which shows that the composition generally increases security. <p> Define an encryption scheme A to be (1 *)-secure if no polynomial-time procedure has a chance greater than (1 + *)=2 of distinguishing encryption functions from scheme A from truly random functions over the same domain (see <ref> [112] </ref> for a more precise definition and details). Then the composition of a (1 *)-secure encryption scheme with a (1 ffi)-secure encryption scheme is (*ffi (2 max (*; ffi)))-secure. This is an improvement whenever max (*; ffi) &lt; 1. <p> To send a message M , the sender picks an r at random from the domain of the previously agreed-upon secret pseudo-random function f j , and then sends the pair (r; M f j (r)). Luby and Rackoff <ref> [112] </ref> have extended the previous result by showing how to construct a family of pseudo-random permutations which is secure in the same sense and under the same assumptions.
Reference: [113] <author> R. J. </author> <title> McEliece. A Public-Key System Based on Algebraic Coding Theory, </title> <type> pages 114-116. </type> <institution> Jet Propulsion Lab, </institution> <year> 1978. </year> <note> DSN Progress Report 44. </note>
Reference-contexts: See [114, 140, 142, 1, 144, 100, 32, 122]. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme [39], and the multiplicative versions of the knapsack [114] are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes <ref> [113] </ref>. <p> The pioneering work in this direction was performed by Goldwasser and Micali [79, 78]. Although the use of randomized techniques was itself not new (for example, <ref> [113] </ref>), using randomization to achieve a provable level of security was novel. We begin by examining the rather subtle notion of cryptographic security. 6.3.1 Attacks Against a Cryptosystem When proving that a cryptographic system is secure, it is important to carefully specify what sort of "attacks" the adversary may mount.
Reference: [114] <author> R. Merkle and M. Hellman. </author> <title> Hiding information and signatures in trapdoor knapsacks. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT-24:525-530, </volume> <month> September </month> <year> 1978. </year>
Reference-contexts: See <ref> [114, 140, 142, 1, 144, 100, 32, 122] </ref>. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme [39], and the multiplicative versions of the knapsack [114] are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes [113]. <p> See [114, 140, 142, 1, 144, 100, 32, 122]. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme [39], and the multiplicative versions of the knapsack <ref> [114] </ref> are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes [113].
Reference: [115] <author> R. C. Merkle. </author> <title> Secure communications over insecure channels. </title> <journal> Communcations of the ACM, </journal> <volume> 21 </volume> <pages> 294-299, </pages> <month> April </month> <year> 1978. </year>
Reference-contexts: computing g ab mod p from g a mod p and g b mod p; an apparently intractable problem. 6.2 Deterministic Public-Key Encryption The notion of a public-key cryptosystem was first published by Diffie and Hellman in 1976 [52, 53], although Merkle had earlier developed some of the conceptual framework <ref> [115] </ref>. The central idea is that of a trapdoor function, as defined earlier. According to Diffie and Hellman, a public-key cryptosystem should contain the following parts: * A key generation algorithm.
Reference: [116] <author> Ralph Charles Merkle. </author> <title> Secrecy, Authentication, and Public Key Systems. </title> <type> Technical Report, </type> <institution> Stanford University, </institution> <month> June </month> <year> 1979. </year>
Reference-contexts: Merkle <ref> [116] </ref> introduced some extensions of this basic idea, involving building a tree of authenticated values whose root is stored in the public key of the signer.
Reference: [117] <author> C. H. Meyer and S. M. Matyas. </author> <title> Cryptography: A New Dimension in Computer Data Security. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, </address> <year> 1982. </year>
Reference: [118] <author> S. Micali, C. Rackoff, and R. H. Sloan. </author> <title> The notion of security for probabilistic cryptosystems. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 412-426, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Achieving it rules out all of the problems listed above. 6.3.3 Definition of Security: Polynomial-Time Security Several definitions of security for probabilistic encryption schemes have been proposed and studied in [79, 163, 78]. All definitions proposed so far have been shown to be equivalent in <ref> [78, 118] </ref>. We provide one definition in detail, due to Goldwasser and Micali [78].
Reference: [119] <author> M. Naor and M. Yung. </author> <title> Universal one-way hash functions and their cryptographic applications. </title> <booktitle> In Proc. 21th ACM Symposium on Theory of Computing, ACM, </booktitle> <address> Seattle, </address> <year> 1989. </year>
Reference-contexts: A review of signature schemes can be found in [84]. 8.1 Proving Security of Signature Schemes A theoretical treatment of digital signatures security was started by Goldwasser, Micali and Yao in [82] and continued in [84, 15],and recently <ref> [119] </ref>. <p> A major leap forward has been recently made by Naor and Yung <ref> [119] </ref> who have shown how, starting with any one-way permutation, to design a digital signature scheme which is not existentially forgeable by chosen message attack. 9 Two-Party Protocols In this section we sketch a number of cryptographic protocol problems that have been addressed in the literature; see [47] for additional examples.
Reference: [120] <author> R. M. Needham and M. D. Schroeder. </author> <title> Using encryption for authentication in large networks of computers. </title> <journal> Communcations of the ACM, </journal> <volume> 21(12) </volume> <pages> 993-999, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: Moreover, each user can transmit the certificate for his public key with any message he signs, thus removing the need for a central directory and allowing one to verify signed messages with no information other than the directory manager's public key. Needham and Schroeder <ref> [120] </ref> examine some of the protocol issues involved in such a network organization, and compare it to what might be accomplished using conventional cryptography. Just as some cryptographic schemes are suited for encryption but not signatures, some proposals have been made for signature-only schemes.
Reference: [121] <author> I. Niven and H. S. Zuckerman. </author> <title> An Introduction to the Theory of Numbers. </title> <publisher> Wiley, </publisher> <year> 1972. </year>
Reference-contexts: In this section we review some basic number-theoretic and computational facts. For a more extensive review of elementary number theory see <ref> [121] </ref>, [105], or [8]. An excellent overview of the problems of factoring integers, testing primality, and computing discrete logarithms also appears in this volume [103].
Reference: [122] <author> A. M. Odlyzko. </author> <title> Cryptanalytic attacks on the multiplicative knapsack scheme and on Shamir's fast signature scheme. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT-30:594-601, </volume> <month> July </month> <year> 1984. </year> <month> 44 </month>
Reference-contexts: See <ref> [114, 140, 142, 1, 144, 100, 32, 122] </ref>. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme [39], and the multiplicative versions of the knapsack [114] are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes [113].
Reference: [123] <author> A. M. Odlyzko. </author> <title> Discrete logarithms in finite fields and their cryptographic significance. </title> <editor> In T. Beth, N. Cot, and I. Ingemarsson, editors, </editor> <booktitle> Proceedings of EUROCRYPT 84, </booktitle> <pages> pages 224-314, </pages> <publisher> Springer, </publisher> <address> Paris, </address> <year> 1985. </year> <note> Lecture Notes in Computer Science No. 209. </note>
Reference-contexts: It interesting to note that working over the finite field GF (2 k ) rather than working modulo n seems to make the problem substantially easier (see Coppersmith [43] and Odlyzko <ref> [123] </ref>). See [44] for further improvements and general discussion. The other way to invert modular exponentiation is to solve for x: given y; e, and n, to compute an x (if any) such that x e y (mod n) is called computing the e-th root of y modulo n.
Reference: [124] <author> National Bureau of Standards. </author> <title> Announcing the Data Encryption Standard. </title> <type> Technical Report FIPS Publication 46, </type> <institution> National Bureau of Standards, </institution> <month> January </month> <year> 1977. </year>
Reference-contexts: The Data Encryption Standard (or DES) is a good example of a secret-key cryptosystem designed to be computationally secure. Researchers at IBM designed DES in the 1970's, and the U.S. National Bureau of Standards adopted DES as a standard for encrypting commercial and government unclassified information <ref> [124] </ref>. It is widely used, particularly in the banking industry. However, its future as a standard is unclear since it is not certain for how much longer NBS will support DES as a standard. We now sketch the operation of DES.
Reference: [125] <author> J. Plumstead. </author> <title> Inferring a sequence generated by a linear congruence. </title> <booktitle> In Proceedings of the 23rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 153-159, </pages> <publisher> IEEE, </publisher> <address> Chicago, </address> <year> 1982. </year>
Reference-contexts: It is possible to infer the secret parameters given just a few of the X i <ref> [125] </ref>.
Reference: [126] <author> S. C. Pohlig and M. E. Hellman. </author> <title> An improved algorithm for computing logarithms over GF (p) and its cryptographic significance. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT-24:106-110, </volume> <month> January </month> <year> 1978. </year>
Reference-contexts: We note that when n is prime there are many x such that x e y (mod n) has solutions for all y 2 Z fl n ; such x's are called generators. Computing discrete logarithms seems to be difficult in general. However, Pohlig and Hellman <ref> [126] </ref> present effective techniques for this problem when n is prime and n 1 has only small prime factors.
Reference: [127] <author> C. Pomerance. </author> <title> Analysis and comparison of some integer factoring algorithms. </title> <editor> In H. W. Lenstra, Jr. and R. Tijdeman, editors, </editor> <booktitle> Computational Methods in Number Theory, </booktitle> <pages> pages 89-139, </pages> <publisher> Math. Centrum Tract, </publisher> <address> Amsterdam, </address> <year> 1982. </year>
Reference-contexts: On the other hand, to factor a number n seems to require time proportional to e c ln (n)ln ln (n) ; (3) where the constant c is 1 for the fastest algorithms. Factoring numbers of more than 110 decimal digits is currently infeasible in general. Pomerance <ref> [127] </ref>, Pomerance et al. [128], Riesel [135], and Dixon [55] discuss recent factoring methods. Let Z n denote the set of residue classes modulo n, and let Z fl n denote the multiplicative subgroup of Z n consisting of those residues which are relatively prime to n.
Reference: [128] <author> C. Pomerance, J. W. Smith, and R. Tuler. </author> <title> A pipeline architecture for factoring large integers with the quadratic sieve algorithm. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 387-403, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Factoring numbers of more than 110 decimal digits is currently infeasible in general. Pomerance [127], Pomerance et al. <ref> [128] </ref>, Riesel [135], and Dixon [55] discuss recent factoring methods. Let Z n denote the set of residue classes modulo n, and let Z fl n denote the multiplicative subgroup of Z n consisting of those residues which are relatively prime to n.
Reference: [129] <author> W. L. </author> <title> Price. </title> <journal> Annontated bibliographies of cryptography. </journal> <note> Published as National Physical Laboratories technical reports since 1978. </note>
Reference-contexts: available many excellent texts, collections, and survey articles [9, 13, 29, 45, 49, 48, 53, 54, 51, 66, 91, 99, 102, 117, 146, 150, 149, 148, 151], works of historical or political interest [12, 69, 92, 138, 157], relevant conference proceedings (CRYPTO, EUROCRYPT, FOCS, STOC, [46, 86, 100]) and bibliographies <ref> [14, 129] </ref>. 6 * A key space K: a set of strings (keys) over some alphabet. * An encryption algorithm E mapping K fi M into C. * A decryption algorithm E mapping K fi C into M.
Reference: [130] <author> M. Rabin. </author> <title> Digitalized Signatures as Intractable as Factorization. </title> <type> Technical Report MIT/LCS/TR-212, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> January </month> <year> 1979. </year>
Reference-contexts: We say that x is a square root of y, modulo n if x 2 y (mod n). If n has t prime factors, then x may have up to 2 t square roots. Rabin <ref> [130] </ref> proved that finding square roots modulo n is polynomial-time equivalent to factoring n; given an efficient algorithm for extracting square roots modulo n one can construct an efficient algorithm for factoring n, and vice versa. <p> Merkle [116] introduced some extensions of this basic idea, involving building a tree of authenticated values whose root is stored in the public key of the signer. Rabin <ref> [130] </ref> proposed a method where the signature for a message M was essentially the square root of M , modulo n, the product of two large primes.
Reference: [131] <author> M. Rabin. </author> <title> How to exchange secrets by oblivious transfer. </title> <type> Technical Report TR-81, </type> <institution> Harvard Aiken Computation Laboratory, </institution> <year> 1981. </year>
Reference-contexts: This strange-sounding protocol has a number of useful applications (see, for example <ref> [131, 21] </ref>). In fact, Kilian has recently shown [97] that the ability to perform oblivious transfers is a sufficiently strong primitive to enable any two-party protocol to be performed. 31 9.1.5 Other examples The problem of contract signing is that of simultaneously exchanging digital signatures to a contract.
Reference: [132] <author> M. Rabin. </author> <title> Probabilistic algorithms for testing primality. </title> <journal> J. Number Theory, </journal> <volume> 12 </volume> <pages> 128-138, </pages> <year> 1980. </year>
Reference-contexts: Finding large prime numbers is useful for constructing cryptographic operators, while for many cryptosystems the adversary's task is provably as hard as factoring the product of two large prime numbers. There are efficient algorithms for generating random k-bit prime numbers; these algorithms run in time polynomial in k <ref> [152, 132, 77, 5, 3] </ref> and come in two flavors: Monte Carlo probabilistic algorithms which may err with small probability, always terminate in polynomial time and are quite efficient in practice; and Las Vegas probabilistic algorithms which are always correct, generate as output a deterministic polynomial time checkable proof of correctness,
Reference: [133] <author> M. Rabin. </author> <title> Probabilistic algorithms in finite fields. </title> <journal> SIAM J. Computing, </journal> <volume> 9 </volume> <pages> 273-280, </pages> <month> May </month> <year> 1980. </year>
Reference-contexts: If n is prime, this computation can be performed in polynomial time <ref> [22, 4, 133] </ref>, while if n is composite, this problem seems to be as hard as factoring n or computing discrete logarithms modulo n.
Reference: [134] <author> M. O. Rabin. </author> <title> Digitalized signatures. </title> <editor> In Richard A. DeMillo, David P. Dobkin, Anita K. Jones, and Richard J. Lipton, editors, </editor> <booktitle> Foundations of Secure Computation, </booktitle> <pages> pages 155-168, </pages> <publisher> Academic Press, </publisher> <year> 1978. </year>
Reference-contexts: Just as some cryptographic schemes are suited for encryption but not signatures, some proposals have been made for signature-only schemes. Some early suggestions were made that were based on the use of one-way functions or conventional cryptography <ref> [101, 134] </ref>.
Reference: [135] <author> H. Riesel. </author> <title> Prime Numbers and Computer Methods for Factorization. </title> <publisher> Birkhauser, </publisher> <address> Boston, </address> <year> 1985. </year>
Reference-contexts: Factoring numbers of more than 110 decimal digits is currently infeasible in general. Pomerance [127], Pomerance et al. [128], Riesel <ref> [135] </ref>, and Dixon [55] discuss recent factoring methods. Let Z n denote the set of residue classes modulo n, and let Z fl n denote the multiplicative subgroup of Z n consisting of those residues which are relatively prime to n.
Reference: [136] <author> R. L. Rivest and A. Shamir. </author> <title> How to expose an eavesdropper. </title> <journal> Communcations of the ACM, </journal> <volume> 27 </volume> <pages> 393-395, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Dolev and Yao [57] pioneered this style of proof; additional work was performed by Dolev, Even, and Karp [56], Yao [162], and Even and Goldreich [61]. In other cases a modification of the protocol can eliminate or alleviate the danger; see <ref> [136] </ref> as an example of this approach against the danger of an adversary "inserting himself into the middle" of a public-key exchange protocol. 10.3 Multiparty Protocols When Most Parties are Honest Goldreich, Micali, and Wigderson [76] have shown how to "compile" a protocol designed for honest parties into one which will
Reference: [137] <author> R. L. Rivest, A. Shamir, and L. M. Adleman. </author> <title> A method for obtaining digital signatures and public-key cryptosystems. </title> <journal> Communcations of the ACM, </journal> <volume> 21 </volume> <pages> 120-126, </pages> <month> February </month> <year> 1978. </year>
Reference-contexts: It is frequently useful to use exponents larger than 2: the function x e mod n is called modular exponentiation; the modulus n may be either prime or composite. Unlike the squaring operator, modular exponentiation is one-to-one over Z n if gcd (e; (n)) = 1 <ref> [137] </ref>. There are two ways to devise problems inverses modular exponentiation, depending on whether e or x is to be solved for. <p> Only A possesses the decryption key D A , so only A can decrypt such a message. 16 6.2.1 RSA In 1977 Rivest, Shamir, and Adleman <ref> [137] </ref> proposed a public-key cryptosystem satisfying the requirements proposed by Diffie and Hellman. In their scheme, each user's public key is a pair (e; n) of integers, such that n is the product of two large primes p and q and gcd (e; (n)) = 1.
Reference: [138] <author> S. Sanders. </author> <title> Data privacy: what Washington doesn't want you to know. </title> <booktitle> Reason, </booktitle> <pages> 24-37, </pages> <month> January </month> <year> 1981. </year> <month> 45 </month>
Reference-contexts: Author's net address: rivest@theory.lcs.mit.edu 2 The reader who wishes to explore further will find available many excellent texts, collections, and survey articles [9, 13, 29, 45, 49, 48, 53, 54, 51, 66, 91, 99, 102, 117, 146, 150, 149, 148, 151], works of historical or political interest <ref> [12, 69, 92, 138, 157] </ref>, relevant conference proceedings (CRYPTO, EUROCRYPT, FOCS, STOC, [46, 86, 100]) and bibliographies [14, 129]. 6 * A key space K: a set of strings (keys) over some alphabet. * An encryption algorithm E mapping K fi M into C. * A decryption algorithm E mapping K
Reference: [139] <author> M. Santha and U. V. Vazirani. </author> <title> Generating quasi-random sequences from slightly-random sources. </title> <booktitle> In Proceedings of the 25th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 434-440, </pages> <publisher> IEEE, </publisher> <address> Singer Island, </address> <year> 1984. </year>
Reference-contexts: Handling a correlated bit source is more difficult. Blum [26] shows how to produce unbiased uncorrelated bits from a biased correlated source which produces output bits according to a known finite Markov chain. For a source whose correlation is more complicated, Santha and Vazirani <ref> [139] </ref> propose modelling it as a slightly random source, where each output bit is produced by a coin flip, but where an adversary is allowed to choose which coin will be flipped, from among all coins whose probability of yielding "Heads" is between ffi and 1 ffi. (Here ffi is a
Reference: [140] <author> R. Schroeppel and A. Shamir. </author> <title> A T S 2 = O(2 n ) time/space tradeoff for certain NP-complete problems. </title> <booktitle> In Proc. 20th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 328-336, </pages> <publisher> IEEE, </publisher> <address> San Juan, Puerto Rico, </address> <year> 1979. </year>
Reference-contexts: See <ref> [114, 140, 142, 1, 144, 100, 32, 122] </ref>. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme [39], and the multiplicative versions of the knapsack [114] are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes [113].
Reference: [141] <author> A. Shamir. </author> <title> How to share a secret. </title> <journal> Communcations of the ACM, </journal> <volume> 22 </volume> <pages> 612-613, </pages> <month> November </month> <year> 1979. </year>
Reference-contexts: The protocol should guarantee that the "good" parties are able to achieve the goal even though the corrupted parties send misleading information or otherwise maliciously misbehave in an attempt prevent the good parties from succeeding. 10.1 Examples 10.1.1 Secret Sharing In 1979 Shamir <ref> [141] </ref> considered the problem of sharing a secret, defined as follows.
Reference: [142] <author> A. Shamir. </author> <title> On the cryptocomplexity of knapsack schemes. </title> <booktitle> In Proc. 11th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 118-129, </pages> <publisher> ACM, </publisher> <address> Atlanta, </address> <year> 1979. </year>
Reference-contexts: See <ref> [114, 140, 142, 1, 144, 100, 32, 122] </ref>. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme [39], and the multiplicative versions of the knapsack [114] are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes [113].
Reference: [143] <author> A. Shamir. </author> <title> On the generation of cryptographically strong pseudo-random sequences. </title> <booktitle> In Proc. ICALP, </booktitle> <pages> pages 544-550, </pages> <publisher> Springer, </publisher> <year> 1981. </year>
Reference-contexts: since an adversary can identify y exactly from a sufficient number of bits, and then extrapolate y's expansion. 7.2.2 Provably Secure Pseudo-Random Generators The first pseudo-random sequence generator proposed which was provably secure (assuming that it is infeasible to invert the RSA function (see section 6.2.1)) is due to Shamir <ref> [143] </ref>. However, this scheme generates a sequence of numbers rather than a sequence of bits, and the security proof shows that an adversary is unable to predict the next number, given the previous numbers output.
Reference: [144] <author> A. Shamir. </author> <title> A polynomial-time algorithm for breaking the basic Merkle-Hellman cryptosystem. </title> <booktitle> In Proceedings of the 23rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 145-152, </pages> <publisher> IEEE, </publisher> <address> Chicago, </address> <year> 1982. </year>
Reference-contexts: See <ref> [114, 140, 142, 1, 144, 100, 32, 122] </ref>. Some knapsack or knapsack-like schemes are still unbroken. The Chor-Rivest scheme [39], and the multiplicative versions of the knapsack [114] are examples. McEliece has a knapsack-like public-key cryptosystem based on error-correcting codes [113].
Reference: [145] <author> A. Shamir, R. L. Rivest, and L. M. Adleman. </author> <title> Mental poker. </title> <editor> In D. Klarner, editor, </editor> <booktitle> The Mathematical Gardner, </booktitle> <pages> pages 37-43, </pages> <publisher> Wadsworth, </publisher> <address> Belmont, California, </address> <year> 1981. </year>
Reference-contexts: Shamir, Rivest, and Adleman <ref> [145] </ref> proposed the following simple strategy (here Alice and Bob are the two players): * The players jointly select 52 distinct messages M 1 ; . . . ; M 52 to represent the cards, and a large prime p. * The players secretly choose exponents e A and e B
Reference: [146] <author> C. E. Shannon. </author> <title> Communication theory of secrecy systems. </title> <journal> Bell Sys. Tech. J., </journal> <volume> 28 </volume> <pages> 657-715, </pages> <year> 1949. </year>
Reference-contexts: This one-time pad is thus provably secure in an information-theoretic sense since the interceptor never has enough information to decrypt the ciphertext, and no amount of computational power could help him. The information-theoretic basis for cryptographic security was developed by Shannon <ref> [146] </ref> and later refined by Hellman [90]. Gilbert, MacWilliams, and Sloane [71] have also extended information-theoretic approaches to handle the authentication problem. While the one-time pad provides provable security, it is awkward to use since a large key must be generated, shared, and stored. <p> Some systems, such as the Vernam one-time pad [92] are secure in an information-theoretic sense: the adversary is never given enough information to work with to break the code; no amount of computational power can help him overcome this. (See Shannon <ref> [146] </ref> and Hellman [90].) * Computational complexity theory. The adversary's task is more often computationally infeasible, rather than information-theoretically impossible.
Reference: [147] <author> A. Sherman. </author> <title> Cryptology and VLSI (a two-part dissertation). </title> <type> PhD thesis, </type> <institution> MIT EECS Dept, </institution> <month> October </month> <year> 1986. </year> <note> Published as MIT Laboratory for Computer Science Technical Report MIT/LCS/TR-381 (Oct. </note> <year> 1986). </year>
Reference-contexts: On the other hand, multiple encryption using DES probably does increase security somewhat (see <ref> [95, 147] </ref>). It is worth noting that the composition of two cryptosystems with n-bit keys can be broken in time O (2 n ) and space O (2 n ), using a meet-in-the-middle attack.
Reference: [148] <author> G. J. Simmons. </author> <booktitle> Cryptology. In The New Encyclopdia Brittanica, </booktitle> <pages> pages 860-873, </pages> <booktitle> Ency-clopdia Brittanica, 1989. </booktitle> <volume> (Volume 16). </volume>
Reference: [149] <author> G. J. Simmons, </author> <title> editor. Secure Communications and Asymmetric Cryptosystems. </title> <booktitle> Volume 69 of Selected Symposia, AAAS, </booktitle> <year> 1982. </year>
Reference: [150] <author> G. J. Simmons. </author> <title> Symmetric and asymmetric encryption. </title> <journal> ACM Computing Surveys, </journal> <volume> 11 </volume> <pages> 305-330, </pages> <year> 1979. </year>
Reference: [151] <author> N. J. A. Sloane. </author> <title> Error-correcting codes and cryptography. </title> <editor> In D. Klarner, editor, </editor> <booktitle> The Mathematical Gardner, </booktitle> <pages> pages 346-382, </pages> <publisher> Wadsworth, </publisher> <address> Belmont, California, </address> <year> 1981. </year>
Reference: [152] <author> R. Solovay and V. Strassen. </author> <title> A fast Monte-Carlo test for primality. </title> <journal> SIAM J. Computing, </journal> <volume> 6 </volume> <pages> 84-85, </pages> <year> 1977. </year>
Reference-contexts: Finding large prime numbers is useful for constructing cryptographic operators, while for many cryptosystems the adversary's task is provably as hard as factoring the product of two large prime numbers. There are efficient algorithms for generating random k-bit prime numbers; these algorithms run in time polynomial in k <ref> [152, 132, 77, 5, 3] </ref> and come in two flavors: Monte Carlo probabilistic algorithms which may err with small probability, always terminate in polynomial time and are quite efficient in practice; and Las Vegas probabilistic algorithms which are always correct, generate as output a deterministic polynomial time checkable proof of correctness,
Reference: [153] <author> U. V. Vazirani. </author> <title> Towards a strong communication complexity theory, or generating quasi-random sequences from two communicating slightly-random sources. </title> <booktitle> In Proc. 17th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 366-378, </pages> <publisher> ACM, </publisher> <address> Providence, </address> <year> 1985. </year>
Reference-contexts: Vazirani <ref> [153] </ref> shows that if one has two, independent, slightly-random sources X and Y then one can produce "almost independent" *-biased bits by breaking the outputs of X and Y into blocks x; y of length k = (1=ffi 2 log (1=ffi) log (1=*)) bits each, and for each pair of blocks
Reference: [154] <author> U. V. Vazirani and V. V. Vazirani. </author> <title> Efficient and secure pseudo-random number generation. </title> <booktitle> In Proceedings of the 25th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 458-463, </pages> <publisher> IEEE, </publisher> <address> Singer Island, </address> <year> 1984. </year> <month> 46 </month>
Reference-contexts: Alexi, Chor, Goldreich, and Schnorr [6] show that the assumption that the quadratic residuosity problem is hard can be replaced by the weaker assumption that factoring is hard. A related generator is obtained by using the RSA function x e mod n where gcd (e; (n)) = 1 <ref> [154, 6] </ref>. Kaliski shows how to extend these methods so that the security of the generator depends on the difficulty of computing elliptic logarithms; his techniques also generalize to other groups [94, 93].
Reference: [155] <author> U. V. Vazirani and V. V. Vazirani. </author> <title> Trapdoor pseudo-random number generators, with appli-cations to protocol design. </title> <booktitle> In Proceedings of the 24th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 23-30, </pages> <publisher> IEEE, </publisher> <address> Tucson, </address> <year> 1983. </year>
Reference-contexts: The certified electronic mail problem is similar to the contract-signing problem above. The goal is to achieve a simultaneous exchange of an electronic letter M and a signed receipt for M from the recipient. Another exchange problem is the simultaneous exchange of secrets. This has been studied in <ref> [25, 155, 110, 161] </ref>. 9.2 Zero-Knowledge Protocols The previous section listed a number of cryptographic protocol applications.
Reference: [156] <author> J. von Neumann. </author> <title> Various techniques for use in connection with random digits. </title> <booktitle> In von Neumann's Collected Works, </booktitle> <pages> pages 768-770, </pages> <publisher> Pergamon, </publisher> <year> 1963. </year>
Reference-contexts: To turn a source which supplies biased but uncorrelated bits into one which supplies unbiased uncorrelated bits, von Neumann proposed grouping the bits into pairs, and then turning 01 pairs into 0's, 10 pairs into 1's, and discarding pairs of the form 00 and 11 <ref> [156] </ref>. The result is an unbiased uncorrelated source, since the 01 and 10 pairs will have an identical probability of occurring. Elias [58] generalizes this idea to achieve an output rate near the source entropy. Handling a correlated bit source is more difficult.
Reference: [157] <author> F. W. Winterbotham. </author> <title> The Ultra Secret. </title> <address> Futura, London, </address> <year> 1975. </year>
Reference-contexts: Author's net address: rivest@theory.lcs.mit.edu 2 The reader who wishes to explore further will find available many excellent texts, collections, and survey articles [9, 13, 29, 45, 49, 48, 53, 54, 51, 66, 91, 99, 102, 117, 146, 150, 149, 148, 151], works of historical or political interest <ref> [12, 69, 92, 138, 157] </ref>, relevant conference proceedings (CRYPTO, EUROCRYPT, FOCS, STOC, [46, 86, 100]) and bibliographies [14, 129]. 6 * A key space K: a set of strings (keys) over some alphabet. * An encryption algorithm E mapping K fi M into C. * A decryption algorithm E mapping K
Reference: [158] <author> A. D. Wyner. </author> <title> An analog scrambling scheme which does not expand bandwidth, part 1. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT-25(3):261-274, </volume> <year> 1979. </year>
Reference-contexts: For example, Alpern and Schneider [7] show how to communicate securely on channels for which an eavesdropper cannot tell who broadcasts each bit. Wyner [160] defeats eavesdroppers for whom reception is less reliable than for the intended receiver, or when the channel is analog rather than digital <ref> [158, 159] </ref>. Bennett et al. exploit the peculiarities of quantum effects in their channels [17]. And spread-spectrum channels are effectively unobservable to enemies who don't know the details of their use [70]. We do not pursue these variations further in this paper. * Information theory.
Reference: [159] <author> A. D. Wyner. </author> <title> An analog scrambling scheme which does not expand bandwidth, part 2. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT-25(4):415-425, </volume> <year> 1979. </year>
Reference-contexts: For example, Alpern and Schneider [7] show how to communicate securely on channels for which an eavesdropper cannot tell who broadcasts each bit. Wyner [160] defeats eavesdroppers for whom reception is less reliable than for the intended receiver, or when the channel is analog rather than digital <ref> [158, 159] </ref>. Bennett et al. exploit the peculiarities of quantum effects in their channels [17]. And spread-spectrum channels are effectively unobservable to enemies who don't know the details of their use [70]. We do not pursue these variations further in this paper. * Information theory.
Reference: [160] <author> A. D. Wyner. </author> <title> The wire-tap channel. </title> <journal> Bell Sys. Tech. J., </journal> <volume> 54 </volume> <pages> 1355-1387, </pages> <year> 1975. </year>
Reference-contexts: Unusual properties of the communication channel can sometimes be exploited. For example, Alpern and Schneider [7] show how to communicate securely on channels for which an eavesdropper cannot tell who broadcasts each bit. Wyner <ref> [160] </ref> defeats eavesdroppers for whom reception is less reliable than for the intended receiver, or when the channel is analog rather than digital [158, 159]. Bennett et al. exploit the peculiarities of quantum effects in their channels [17].
Reference: [161] <author> A. C. Yao. </author> <title> How to generate and exchange secrets. </title> <booktitle> In Proceedings of the 27th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 162-167, </pages> <publisher> IEEE, </publisher> <address> Toronto, </address> <year> 1986. </year>
Reference-contexts: The certified electronic mail problem is similar to the contract-signing problem above. The goal is to achieve a simultaneous exchange of an electronic letter M and a signed receipt for M from the recipient. Another exchange problem is the simultaneous exchange of secrets. This has been studied in <ref> [25, 155, 110, 161] </ref>. 9.2 Zero-Knowledge Protocols The previous section listed a number of cryptographic protocol applications.
Reference: [162] <author> A. C. Yao. </author> <title> Protocols for secure computations. </title> <booktitle> In Proceedings of the 23rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 160-164, </pages> <publisher> IEEE, </publisher> <address> Chicago, </address> <year> 1982. </year>
Reference-contexts: It is sometimes possible to prove that a protocol is invulnerable to this style of attack. Dolev and Yao [57] pioneered this style of proof; additional work was performed by Dolev, Even, and Karp [56], Yao <ref> [162] </ref>, and Even and Goldreich [61].
Reference: [163] <author> A. C. Yao. </author> <title> Theory and application of trapdoor functions. </title> <booktitle> In Proceedings of the 23rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 80-91, </pages> <publisher> IEEE, </publisher> <address> Chicago, </address> <year> 1982. </year>
Reference-contexts: Essentially, this coincides with the existing formal security notions. Achieving it rules out all of the problems listed above. 6.3.3 Definition of Security: Polynomial-Time Security Several definitions of security for probabilistic encryption schemes have been proposed and studied in <ref> [79, 163, 78] </ref>. All definitions proposed so far have been shown to be equivalent in [78, 118]. We provide one definition in detail, due to Goldwasser and Micali [78]. <p> Then, to select uniformly an x 2 Z fl n such that B (x) = v simply select a y 2 Z fl n whose least significant bit is v and set x = y e mod n. Yao, in a pioneering paper <ref> [163] </ref>, showed that the existence of any trapdoor length-preserving permutation implies the existence of a trapdoor predicate. Recently, Goldreich and Levin simplified Yao's construction as follows. Theorem 3 (Goldreich-Levin [75]) If trapdoor length-preserving permutations exist, then B is a trapdoor predicate, where B is defined as follows. <p> Then the composition of a (1 *)-secure encryption scheme with a (1 ffi)-secure encryption scheme is (*ffi (2 max (*; ffi)))-secure. This is an improvement whenever max (*; ffi) &lt; 1. In a similar vein, a number of researchers <ref> [78, 163, 106] </ref> have developed and refined proofs that the bit-wise XOR of several independent pseudo-random bit sequence generators is harder to predict (by a quantifiable amount) than any of the component generators. 7 Generating Random or Pseudo-Random Sequences and Func tions We now examine in some detail the problem of <p> Long and Wigderson [109] show how to extract c log log p pseudo-random bits from each x i instead of just one bit as in the Blum-Micali generator. A similar result has been shown for the RSA generator [6]. Yao <ref> [163] </ref> shows that the pseudo-random generators defined above are perfect in the sense that no probabilistic polynomial-time algorithm can guess with probability greater than 1=2 + * whether an input string of length k was randomly selected from f0; 1g k or whether it was produced by one of the above <p> However, Levin [107] has introduced a formal notion of what it means for a problem to be "complete" in the sense of its average-case complexity. Brassard [30] has shown that in certain relativized models of computation secure cryptography is possible. Yao <ref> [163] </ref> develops the theory of trapdoor functions and pseudorandom bit sequence generators, and shows that if a strong one-way function exists, then R *&gt;0 DTIME (2 n * ); (9) since any algorithm in R can be adapted to use a pseudo-random bit sequence generator with a seed of size n
Reference: [164] <author> G. Yuval. </author> <title> How to swindle Rabin. </title> <journal> Cryptologia, </journal> <volume> 3 </volume> <pages> 187-189, </pages> <month> July </month> <year> 1979. </year> <month> 47 </month>
Reference-contexts: y) such that f (x) = f (y); such a function we call claw-free. (Because of the birthday paradox , for small message spaces it may be feasible in practice to find such a pair, even though it is infeasbile in practice to invert f at a given point z <ref> [164] </ref>.) A publicly-available one-way function has a number of useful applications. 1. In a time-shared computer system, instead of storing a table of login passwords, one can store, for each password w, the value f (w).
References-found: 164

