URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS97-13.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Optimal Dynamic Range Searching in Non-replicating Index Structures  
Author: K. V. Ravi Kanth and Ambuj K. Singh 
Address: Santa Barbara, CA 93106  
Affiliation: Computer Science Department University of California at Santa Barbara  
Abstract: We consider the problem of dynamic range searching in tree structures that do not replicate data. We propose a new dynamic structure, called the O-tree, that achieves a query time complexity of O(n (d1)=d ) on n d-dimensional points and an amortized insertion/deletion time complexity of O(log n). We show that this structure is optimal when data is not replicated. In addition to optimal query and insertion/deletion times, the O-tree also supports exact match queries in worst-case logarithmic time. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Beckmann, H. Kriegel, R. Schneider, and B. Seeger. </author> <title> The R* tree: An efficient and robust access method for points and rectangles. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 322331, </pages> <month> May 23-25 </month> <year> 1990. </year>
Reference-contexts: In this paper, we focus on non-replicating index structures for multidimensional range searching. Non-replicating index structures store each data point exactly once. These structures are easy to update and have low storage requirements. Examples of such structures are R-trees <ref> [1, 4, 17] </ref>, Bang files [15], Grid files [21], Quad trees [27], and the divided k-d trees [31]. <p> We investigate the complexity of non-replicating index structures. In this context, Mehlhorn [20] shows that query time complexity of partial match queries (a restricted form of range queries where only a few of the intervals are specified; the others are assumed to be <ref> [1; +1] </ref>) is bounded below by (n (d1)=d ) using a decision-tree model. We show that this lower bound also holds in a much general tree structure model. Next, we focus on obtaining a non-replicating index structure that has optimal query time complexity in dynamic environments. <p> We show that this lower bound also holds in a much general tree structure model. Next, we focus on obtaining a non-replicating index structure that has optimal query time complexity in dynamic environments. Current structures including R-trees <ref> [1, 4, 17] </ref>, Bang files [15, 16], grid files [21], and hB-trees [19] have a worst-case range query complexity of O (n) for n data points. Commercial spatial engines such as ESRI's SDE [11] and Oracle's SDO [23] also have O (n) worst-case query time complexity. <p> In contrast to Mehlhorn's decision tree model which has d decision trees, one for each dimension, our model has one structure. We note that our model represents most current linear-space index structures including R-trees <ref> [1, 4, 17] </ref>, Bang files [15], Quad-trees [27] and is much more general than Mehlhorn's decision trees [20]. <p> set of queries Q = S 1id Q i , where Q i is the set of queries with the following specification: * the interval along the i th dimension X i is : [2c; 2c] for some c: 1 c k, and, * intervals in all other dimensions are: <ref> [1; 2k + 1] </ref>. Note that none of the queries in Q retrieve any data from the set S d . Hence, they are referred to as hole queries in general, and as i-hole queries if they are specifically from Q i . <p> Popular linear-space structures such as R-trees <ref> [17, 1, 4] </ref>, Bang files [15, 16] support insertions/deletions in logarithmic time. However, the query time complexity in these structures is linear in the number of points. Theorem 3 The worst-case range query time complexity of an R-tree for n d-dimensional points is O (n). <p> The minimum and maximum x-coordinates for points in S 0 are 1 and 7. Therefore, the x-interval of the bounding rectangle for S 0 is b x (S 0 ) = <ref> [1; 7] </ref>. Similarly, the minimum and maximum y-coordinates are 1 and 6. Therefore, the y-interval is b y (S) = [1; 6]. Total orders, such as x and y above, can be used to partition a set S into smaller subsets that are disjoint and are of approximately same size. <p> Therefore, the x-interval of the bounding rectangle for S 0 is b x (S 0 ) = [1; 7]. Similarly, the minimum and maximum y-coordinates are 1 and 6. Therefore, the y-interval is b y (S) = <ref> [1; 6] </ref>. Total orders, such as x and y above, can be used to partition a set S into smaller subsets that are disjoint and are of approximately same size. We refer to such subsets as partitions of S in the specified order. <p> Figure 1 (b) shows the augmented B-tree using x-order for the set S 0 . The bounding rectangle for the set P = P 1 [ P 2 is h <ref> [1; 3] </ref>; [1; 6]i. This is stored in the first entry of the root vertex leading to the subtree containing P 1 and P 2 . The bounding rectangles for the other entries can be similarly explained. <p> Figure 1 (b) shows the augmented B-tree using x-order for the set S 0 . The bounding rectangle for the set P = P 1 [ P 2 is h [1; 3]; <ref> [1; 6] </ref>i. This is stored in the first entry of the root vertex leading to the subtree containing P 1 and P 2 . The bounding rectangles for the other entries can be similarly explained. Hereafter, we assume every B-tree for a set of partitions is augmented with bounding rectangles. <p> For example, in Figure 1 (b) a query accesses vertex v from the root vertex only if it intersects the bounding rectangle h <ref> [1; 3] </ref>; [1; 6]i associated with the entry for v in the root vertex. Since checking for intersection involves a conjunction of binary comparisons, this structure satisfies the model of Section 2. <p> For example, in Figure 1 (b) a query accesses vertex v from the root vertex only if it intersects the bounding rectangle h [1; 3]; <ref> [1; 6] </ref>i associated with the entry for v in the root vertex. Since checking for intersection involves a conjunction of binary comparisons, this structure satisfies the model of Section 2. <p> Appendix A Analysis of Range Query Time Complexity of Some Non-replicating Structures A.1 Range Query Time Complexity of R-trees We demonstrate that for specific data points and queries, the R-tree and its variants <ref> [1, 4, 17, 28] </ref> have a worst-case complexity of O (n) for range queries on n data points. The R-tree is an extension of the B + -tree for multidimensional data. As in the B + -tree, data is stored in the leaves. <p> This conformance of the leaf nodes to the two cluster types is a consequence of the area minimization split criteria of the R-tree [17]. Since the clusters themselves do not overlap (nor do their parents), other variants such as R*-trees <ref> [1] </ref> and X-trees [4] also yield the same configuration. Next, (M 2m) points are deleted from the leaf node N 2 . This is followed by an insertion of the next (M m) points (corresponding to a C 1 cluster at offset Lm). <p> The i th leaf node of this R-tree is a C 2 cluster if i is even and a C 1 cluster otherwise. Since the bounding box of any C 1 =C 2 type cluster overlaps with the y-interval [4; 5] and is contained in the x-interval <ref> [1; n] </ref>, it follows that the range query q = [1; n][4; 5] retrieves all the leaf nodes. <p> Since the bounding box of any C 1 =C 2 type cluster overlaps with the y-interval [4; 5] and is contained in the x-interval <ref> [1; n] </ref>, it follows that the range query q = [1; n][4; 5] retrieves all the leaf nodes. <p> We give a specific dataset for which all the leaf nodes (specified by their bounding rectangles) in the BANG file intersect a specific query q. Since, the BANG file [15] partitions the domain alternately, we choose each axis to be of length D = <ref> [1; 4 nm ] </ref>. We specify the set of points at different stages of the index construction. We start off with the following initial set of points. <p> Conse--quently, all nodes that are formed intersect a query q = <ref> [1; 4 nm ] </ref>[2; 2] leading to a time complexity of O (n). As in the case of R-trees, every query that intersects a leaf node also intersects its ancestors, the query time complexity in terms of the node accesses is O (n). <p> Proof: First, we estimate the number of i-hole queries that satisfy cond (v). Each i-hole query corresponds to a gap in the i th dimension and has an interval <ref> [1; 2k + 1] </ref> in all other dimensions. Now, consider cond (v). <p> First, we show that, when j 6= i, the conjunct C j is satisfied by the corresponding interval of every i-hole query. Consider any i-hole query. It has a query interval of <ref> [1; 2k + 1] </ref> in dimension X j . Since D (v) 6= , there exists a point p 2 D (v) and since D (v) S d , the X j -coordinate of the point p, p j , satisfies: 1 p j 2k + 1. <p> Then, from Lemma B.2 it follows that the sub-clause C j is satisfied by an interval <ref> [1; 2k + 1] </ref>, i.e., by the j th interval of any i-hole query. Given the above argument, the total number of i-holes that satisfy cond (v) is given by the number of them satisfying the sub-clause C i of cond (v). <p> Consider a specific gap in P i (D v ). This corresponds to the i th interval of an i-hole query. From Lemma B.4, this interval satisfies the sub-clause C i of cond (u). Besides, the j th interval of this i-hole query is <ref> [1; 2k+ 1] </ref>, which satisfies the sub-clause C j of cond (u) (by Lemma B.2). Hence, the i-hole query (corresponding to a gap in P i (D v )) satisfies cond (u). Note that the same i-hole also satisfies cond (v) (by Lemma B.4).
Reference: [2] <author> J. L. Bentley. </author> <title> Multi-dimensional binary search trees used for associative searching. </title> <journal> Communications of the ACM, </journal> <volume> 18:509517, </volume> <year> 1975. </year>
Reference-contexts: We propose a new structure the O-tree (short for optimal k-d tree) that achieves O (n (d1)=d ) range query time and 2 O (log n) amortized insertion and deletion times. The structure combines the static k-d tree <ref> [2] </ref> and the divided k-d tree [31] in a novel fashion and achieves optimality for both queries as well as updates. As in the divided k-d tree, the amortized times for insertions/deletions can be transformed into worst-case bounds using replication. <p> Since the number of hole queries is at most d (n 1=d 1), by pigeonhole principle it follows that there is a hole query that has time complexity of O (n (d1)=d ). 2 Bentley's k-d trees <ref> [2] </ref> (also dd-trees of [20]), achieve this query time complexity in static databases. Theorem 2 There exists a non-replicating index structure for n d-dimensional points that has O (n (d1)=d + k) query time for queries retrieving k data points. <p> This latter organization corresponds to the divided k-d tree of Kreveld and Overmars. As a side-note, note that when k and m are constants and the 2-layered tree organization is repeated O (log n) times, we obtain the static k-d tree of Bentley <ref> [2] </ref>. Consider an alternative organization for the data in sub-partitions of Figure 2 to reduce the search costs. Assume each sub-partition is organized as a static k-d tree. <p> The root of this tree corresponds to the root of the i-layered O-tree. end The layer-0 trees correspond to static k-d trees, which are constructed using the algorithms of <ref> [2] </ref>. For every other layer i, the set S is partitioned into k subsets using X j -order where k and j are determined by the value of i.
Reference: [3] <author> J. L. Bentley and H. A. Maurer. </author> <title> Efficient worst-case data structures for range searching. </title> <journal> Acta Informatica, </journal> <pages> pages 155168, </pages> <year> 1980. </year>
Reference-contexts: This type of searching in multidimensional space has important applications in geographic information systems, image databases, and computer graphics. Several structures such as the range trees <ref> [3] </ref>, P-range trees [29] have been designed to support range searching in polylogarithmic time. These structures require non-linear storage space, which may not be acceptable for large database systems. Besides, updates in these structures have to handle multiple copies of data points. <p> Time T is the query time overhead per retrieved object. For linear space structures, this equation predicts a lower bound of log d1 n for query time. However, the only structure that comes any close to this bound is Bentley's non-overlapping k-level d-range structure <ref> [3] </ref> for d-dimensional data. This structure achieves O (n (d1)=k log n) query time. By choosing k appropriately, O (n * ) query time can be achieved, for any * &gt; 0. However, this structure maintains O (k d1 ) copies of each data point to achieve this complexity. <p> Figure 1 (b) shows the augmented B-tree using x-order for the set S 0 . The bounding rectangle for the set P = P 1 <ref> [ P 2 is h [1; 3] </ref>; [1; 6]i. This is stored in the first entry of the root vertex leading to the subtree containing P 1 and P 2 . The bounding rectangles for the other entries can be similarly explained. <p> Figure 1 (b) shows the augmented B-tree using x-order for the set S 0 . The bounding rectangle for the set P = P 1 [ P 2 is h <ref> [1; 3] </ref>; [1; 6]i. This is stored in the first entry of the root vertex leading to the subtree containing P 1 and P 2 . The bounding rectangles for the other entries can be similarly explained. <p> For example, in Figure 1 (b) a query accesses vertex v from the root vertex only if it intersects the bounding rectangle h <ref> [1; 3] </ref>; [1; 6]i associated with the entry for v in the root vertex. Since checking for intersection involves a conjunction of binary comparisons, this structure satisfies the model of Section 2.
Reference: [4] <author> S. Berchtold, D. A. Keim, and H. P. Kreigel. </author> <title> The X-tree: An index structure for high dimensional data. </title> <booktitle> Proc. of the Intl. Conf. on Very Large Databases, </booktitle> <year> 1996. </year>
Reference-contexts: In this paper, we focus on non-replicating index structures for multidimensional range searching. Non-replicating index structures store each data point exactly once. These structures are easy to update and have low storage requirements. Examples of such structures are R-trees <ref> [1, 4, 17] </ref>, Bang files [15], Grid files [21], Quad trees [27], and the divided k-d trees [31]. <p> We show that this lower bound also holds in a much general tree structure model. Next, we focus on obtaining a non-replicating index structure that has optimal query time complexity in dynamic environments. Current structures including R-trees <ref> [1, 4, 17] </ref>, Bang files [15, 16], grid files [21], and hB-trees [19] have a worst-case range query complexity of O (n) for n data points. Commercial spatial engines such as ESRI's SDE [11] and Oracle's SDO [23] also have O (n) worst-case query time complexity. <p> In contrast to Mehlhorn's decision tree model which has d decision trees, one for each dimension, our model has one structure. We note that our model represents most current linear-space index structures including R-trees <ref> [1, 4, 17] </ref>, Bang files [15], Quad-trees [27] and is much more general than Mehlhorn's decision trees [20]. <p> Popular linear-space structures such as R-trees <ref> [17, 1, 4] </ref>, Bang files [15, 16] support insertions/deletions in logarithmic time. However, the query time complexity in these structures is linear in the number of points. Theorem 3 The worst-case range query time complexity of an R-tree for n d-dimensional points is O (n). <p> Appendix A Analysis of Range Query Time Complexity of Some Non-replicating Structures A.1 Range Query Time Complexity of R-trees We demonstrate that for specific data points and queries, the R-tree and its variants <ref> [1, 4, 17, 28] </ref> have a worst-case complexity of O (n) for range queries on n data points. The R-tree is an extension of the B + -tree for multidimensional data. As in the B + -tree, data is stored in the leaves. <p> This conformance of the leaf nodes to the two cluster types is a consequence of the area minimization split criteria of the R-tree [17]. Since the clusters themselves do not overlap (nor do their parents), other variants such as R*-trees [1] and X-trees <ref> [4] </ref> also yield the same configuration. Next, (M 2m) points are deleted from the leaf node N 2 . This is followed by an insertion of the next (M m) points (corresponding to a C 1 cluster at offset Lm). <p> The i th leaf node of this R-tree is a C 2 cluster if i is even and a C 1 cluster otherwise. Since the bounding box of any C 1 =C 2 type cluster overlaps with the y-interval <ref> [4; 5] </ref> and is contained in the x-interval [1; n], it follows that the range query q = [1; n][4; 5] retrieves all the leaf nodes.
Reference: [5] <author> B. Chazelle. </author> <title> Filtering search: A new approach to query-answering. </title> <booktitle> Proc. IEEE Symp. on Foundataions of Computer Science, </booktitle> <address> 24:122132, </address> <year> 1983. </year>
Reference-contexts: Using a pointer-machine model, Chazelle [6, 7, 9] showed that polylogarithmic query time for n d-dimensional points can only be obtained with O (n (log n= log log n) d1 ) space. His filtering search technique <ref> [5] </ref>, which used O (n log n= log log n) space for 2-dimensional data and achieved logarithmic query time, was optimal. Subramanian et al. [29] also considered the memory/disk block size, B, and enhanced Chazelle's results for 2-dimensions. <p> The i th leaf node of this R-tree is a C 2 cluster if i is even and a C 1 cluster otherwise. Since the bounding box of any C 1 =C 2 type cluster overlaps with the y-interval <ref> [4; 5] </ref> and is contained in the x-interval [1; n], it follows that the range query q = [1; n][4; 5] retrieves all the leaf nodes.
Reference: [6] <author> B. Chazelle. </author> <title> Lower bounds on the complexity of multi-dimensional searching. </title> <booktitle> Proc. IEEE Symp. on Foundataions of Computer Science, </booktitle> <pages> pages 8796, </pages> <year> 1986. </year>
Reference-contexts: Fredman [12, 13, 14] analyzed the complexity of range searching in dynamic environments. Yao [32] analyzed it for semi-dynamic environments. In static environments, Vaidya [30] established a storage space-query time tradeoff that was later strengthened by Chazelle <ref> [6, 8] </ref>. These analyses estimated the cost using the number of instructions and did not consider memory accesses. In large databases, the memory/disk accesses are more expensive than computation. <p> In static environments, Vaidya [30] established a storage space-query time tradeoff that was later strengthened by Chazelle [6, 8]. These analyses estimated the cost using the number of instructions and did not consider memory accesses. In large databases, the memory/disk accesses are more expensive than computation. Considering this, Chazelle <ref> [6] </ref>, Subramanian et al. [29], and Vaidya [30] analyzed the complexity in terms of the number of memory/disk accesses. <p> In large databases, the memory/disk accesses are more expensive than computation. Considering this, Chazelle [6], Subramanian et al. [29], and Vaidya [30] analyzed the complexity in terms of the number of memory/disk accesses. Using a pointer-machine model, Chazelle <ref> [6, 7, 9] </ref> showed that polylogarithmic query time for n d-dimensional points can only be obtained with O (n (log n= log log n) d1 ) space. <p> Therefore, the x-interval of the bounding rectangle for S 0 is b x (S 0 ) = [1; 7]. Similarly, the minimum and maximum y-coordinates are 1 and 6. Therefore, the y-interval is b y (S) = <ref> [1; 6] </ref>. Total orders, such as x and y above, can be used to partition a set S into smaller subsets that are disjoint and are of approximately same size. We refer to such subsets as partitions of S in the specified order. <p> Figure 1 (b) shows the augmented B-tree using x-order for the set S 0 . The bounding rectangle for the set P = P 1 [ P 2 is h [1; 3]; <ref> [1; 6] </ref>i. This is stored in the first entry of the root vertex leading to the subtree containing P 1 and P 2 . The bounding rectangles for the other entries can be similarly explained. Hereafter, we assume every B-tree for a set of partitions is augmented with bounding rectangles. <p> For example, in Figure 1 (b) a query accesses vertex v from the root vertex only if it intersects the bounding rectangle h [1; 3]; <ref> [1; 6] </ref>i associated with the entry for v in the root vertex. Since checking for intersection involves a conjunction of binary comparisons, this structure satisfies the model of Section 2.
Reference: [7] <author> B. Chazelle. </author> <title> Lower bounds for orthogonal range searching: I. The reporting case. </title> <journal> Journal of the ACM, </journal> <volume> 37(2):200212, </volume> <month> April </month> <year> 1990. </year> <month> 29 </month>
Reference-contexts: In large databases, the memory/disk accesses are more expensive than computation. Considering this, Chazelle [6], Subramanian et al. [29], and Vaidya [30] analyzed the complexity in terms of the number of memory/disk accesses. Using a pointer-machine model, Chazelle <ref> [6, 7, 9] </ref> showed that polylogarithmic query time for n d-dimensional points can only be obtained with O (n (log n= log log n) d1 ) space. <p> The minimum and maximum x-coordinates for points in S 0 are 1 and 7. Therefore, the x-interval of the bounding rectangle for S 0 is b x (S 0 ) = <ref> [1; 7] </ref>. Similarly, the minimum and maximum y-coordinates are 1 and 6. Therefore, the y-interval is b y (S) = [1; 6]. Total orders, such as x and y above, can be used to partition a set S into smaller subsets that are disjoint and are of approximately same size.
Reference: [8] <author> B. Chazelle. </author> <title> Lower bounds for orthogonal range searching: II. The arithmetic model. </title> <journal> Journal of the ACM, </journal> <volume> 37(3):439463, </volume> <month> July </month> <year> 1990. </year>
Reference-contexts: Fredman [12, 13, 14] analyzed the complexity of range searching in dynamic environments. Yao [32] analyzed it for semi-dynamic environments. In static environments, Vaidya [30] established a storage space-query time tradeoff that was later strengthened by Chazelle <ref> [6, 8] </ref>. These analyses estimated the cost using the number of instructions and did not consider memory accesses. In large databases, the memory/disk accesses are more expensive than computation.
Reference: [9] <author> B. Chazelle. </author> <title> Lower bounds for off-line range searching. </title> <booktitle> Proc. ACM Symp. on Theory of Computing, </booktitle> <pages> pages 733740, </pages> <year> 1995. </year>
Reference-contexts: In large databases, the memory/disk accesses are more expensive than computation. Considering this, Chazelle [6], Subramanian et al. [29], and Vaidya [30] analyzed the complexity in terms of the number of memory/disk accesses. Using a pointer-machine model, Chazelle <ref> [6, 7, 9] </ref> showed that polylogarithmic query time for n d-dimensional points can only be obtained with O (n (log n= log log n) d1 ) space.
Reference: [10] <author> Y. J. Chiang and R. Tamassia. </author> <title> Dynamic algorithms in computational geometry. </title> <booktitle> Proc. of the IEEE, </booktitle> <address> 80(9):14121433, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: Each entry is of the form (c; br), where c refers to a child node and br is the bounding rectangle for all points in the subtree rooted at child c. The R-tree is a dynamic structure and supports insertions/deletions by local rebuilding <ref> [10, 25] </ref>. Local rebuilding (or balancing) denotes the technique applied to search trees so that they maintain logarithmic height during a sequence of updates. Since the R-tree is based on a B + -tree structure, it employs a similar local rebuilding technique as the latter.
Reference: [11] <author> ESRI Inc. </author> <title> Spatial Data Engine. Manual, </title> <year> 1996. </year>
Reference-contexts: Current structures including R-trees [1, 4, 17], Bang files [15, 16], grid files [21], and hB-trees [19] have a worst-case range query complexity of O (n) for n data points. Commercial spatial engines such as ESRI's SDE <ref> [11] </ref> and Oracle's SDO [23] also have O (n) worst-case query time complexity. The pseudo quad and k-d trees [26] achieve a query time of O (n ((d1)=d)(1+*) ) for any * &gt; 0 and O (log 2 n) amortized time for insertions and deletions.
Reference: [12] <author> M. L. Fredman. </author> <title> A lower bound on the complexity of orthogonal range queries. </title> <journal> Journal of the ACM, </journal> <volume> 28:696705, </volume> <year> 1981. </year>
Reference-contexts: We also show that this structure is optimal when data is not replicated. Several results for the complexity of multidimensional range searching have been established in computational geometry literature. Fredman <ref> [12, 13, 14] </ref> analyzed the complexity of range searching in dynamic environments. Yao [32] analyzed it for semi-dynamic environments. In static environments, Vaidya [30] established a storage space-query time tradeoff that was later strengthened by Chazelle [6, 8].
Reference: [13] <author> M. L. Fredman. </author> <title> Lower bounds on the complexity of some optimal data structures. </title> <journal> SIAM Journal of Computing, </journal> <volume> 10:110, </volume> <year> 1981. </year>
Reference-contexts: We also show that this structure is optimal when data is not replicated. Several results for the complexity of multidimensional range searching have been established in computational geometry literature. Fredman <ref> [12, 13, 14] </ref> analyzed the complexity of range searching in dynamic environments. Yao [32] analyzed it for semi-dynamic environments. In static environments, Vaidya [30] established a storage space-query time tradeoff that was later strengthened by Chazelle [6, 8].
Reference: [14] <author> M. L. Fredman. </author> <title> The inherent complexity of dynamic data structures which accomodate range queries. </title> <booktitle> Proc. IEEE Symp. on Foundataions of Computer Science, </booktitle> <address> 21:112121, </address> <year> 1983. </year>
Reference-contexts: We also show that this structure is optimal when data is not replicated. Several results for the complexity of multidimensional range searching have been established in computational geometry literature. Fredman <ref> [12, 13, 14] </ref> analyzed the complexity of range searching in dynamic environments. Yao [32] analyzed it for semi-dynamic environments. In static environments, Vaidya [30] established a storage space-query time tradeoff that was later strengthened by Chazelle [6, 8].
Reference: [15] <author> M. W. Freeston. </author> <title> The BANG file: A new kind of grid file. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 260269, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: In this paper, we focus on non-replicating index structures for multidimensional range searching. Non-replicating index structures store each data point exactly once. These structures are easy to update and have low storage requirements. Examples of such structures are R-trees [1, 4, 17], Bang files <ref> [15] </ref>, Grid files [21], Quad trees [27], and the divided k-d trees [31]. <p> We show that this lower bound also holds in a much general tree structure model. Next, we focus on obtaining a non-replicating index structure that has optimal query time complexity in dynamic environments. Current structures including R-trees [1, 4, 17], Bang files <ref> [15, 16] </ref>, grid files [21], and hB-trees [19] have a worst-case range query complexity of O (n) for n data points. Commercial spatial engines such as ESRI's SDE [11] and Oracle's SDO [23] also have O (n) worst-case query time complexity. <p> In contrast to Mehlhorn's decision tree model which has d decision trees, one for each dimension, our model has one structure. We note that our model represents most current linear-space index structures including R-trees [1, 4, 17], Bang files <ref> [15] </ref>, Quad-trees [27] and is much more general than Mehlhorn's decision trees [20]. <p> Popular linear-space structures such as R-trees [17, 1, 4], Bang files <ref> [15, 16] </ref> support insertions/deletions in logarithmic time. However, the query time complexity in these structures is linear in the number of points. Theorem 3 The worst-case range query time complexity of an R-tree for n d-dimensional points is O (n). Proof: Details are given in Appendix A. <p> Our proof is similar to the one for the R-trees. We give a specific dataset for which all the leaf nodes (specified by their bounding rectangles) in the BANG file intersect a specific query q. Since, the BANG file <ref> [15] </ref> partitions the domain alternately, we choose each axis to be of length D = [1; 4 nm ]. We specify the set of points at different stages of the index construction. We start off with the following initial set of points.
Reference: [16] <author> M. W. Freeston. </author> <title> A general solution of the n-dimensional B-tree problem. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: We show that this lower bound also holds in a much general tree structure model. Next, we focus on obtaining a non-replicating index structure that has optimal query time complexity in dynamic environments. Current structures including R-trees [1, 4, 17], Bang files <ref> [15, 16] </ref>, grid files [21], and hB-trees [19] have a worst-case range query complexity of O (n) for n data points. Commercial spatial engines such as ESRI's SDE [11] and Oracle's SDO [23] also have O (n) worst-case query time complexity. <p> Popular linear-space structures such as R-trees [17, 1, 4], Bang files <ref> [15, 16] </ref> support insertions/deletions in logarithmic time. However, the query time complexity in these structures is linear in the number of points. Theorem 3 The worst-case range query time complexity of an R-tree for n d-dimensional points is O (n). Proof: Details are given in Appendix A.
Reference: [17] <author> A. Guttman. R-trees: </author> <title> A dynamic index structure for spatial searching. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 4757, </pages> <year> 1984. </year>
Reference-contexts: In this paper, we focus on non-replicating index structures for multidimensional range searching. Non-replicating index structures store each data point exactly once. These structures are easy to update and have low storage requirements. Examples of such structures are R-trees <ref> [1, 4, 17] </ref>, Bang files [15], Grid files [21], Quad trees [27], and the divided k-d trees [31]. <p> We show that this lower bound also holds in a much general tree structure model. Next, we focus on obtaining a non-replicating index structure that has optimal query time complexity in dynamic environments. Current structures including R-trees <ref> [1, 4, 17] </ref>, Bang files [15, 16], grid files [21], and hB-trees [19] have a worst-case range query complexity of O (n) for n data points. Commercial spatial engines such as ESRI's SDE [11] and Oracle's SDO [23] also have O (n) worst-case query time complexity. <p> In contrast to Mehlhorn's decision tree model which has d decision trees, one for each dimension, our model has one structure. We note that our model represents most current linear-space index structures including R-trees <ref> [1, 4, 17] </ref>, Bang files [15], Quad-trees [27] and is much more general than Mehlhorn's decision trees [20]. <p> Popular linear-space structures such as R-trees <ref> [17, 1, 4] </ref>, Bang files [15, 16] support insertions/deletions in logarithmic time. However, the query time complexity in these structures is linear in the number of points. Theorem 3 The worst-case range query time complexity of an R-tree for n d-dimensional points is O (n). <p> Appendix A Analysis of Range Query Time Complexity of Some Non-replicating Structures A.1 Range Query Time Complexity of R-trees We demonstrate that for specific data points and queries, the R-tree and its variants <ref> [1, 4, 17, 28] </ref> have a worst-case complexity of O (n) for range queries on n data points. The R-tree is an extension of the B + -tree for multidimensional data. As in the B + -tree, data is stored in the leaves. <p> Let N 1 be the leftmost node in this sequence (i.e., the node corresponding to the cluster C 1 ) and N 2 the other node. This conformance of the leaf nodes to the two cluster types is a consequence of the area minimization split criteria of the R-tree <ref> [17] </ref>. Since the clusters themselves do not overlap (nor do their parents), other variants such as R*-trees [1] and X-trees [4] also yield the same configuration. Next, (M 2m) points are deleted from the leaf node N 2 .
Reference: [18] <author> J. M. Hellerstein, J. M. Koutsoupias, and C. H. Papadimitrou. </author> <title> On the analysis of indexing schemes. </title> <booktitle> Proc. of the ACM Priniciples of Database Systems, </booktitle> <month> May </month> <year> 1997. </year>
Reference-contexts: In addition, the O-tree also supports exact match queries in worst-case logarithmic time. Related to range searching in multidimensional index structures is the retrieval of multidimensional data items. Hellerstein et al. <ref> [18] </ref> study the effect of blocking strategies for d-dimensional data items. For any query that retrieves k data items, they obtain lower bounds on the worst-case number of blocks accessed. Nodine et al. [22] study different ways of minimizing these block accesses assuming sufficient amount of buffering.
Reference: [19] <author> D. B. Lomet and B. Salzberg. </author> <title> The hB-tree: A multi-attribute indexing method with good guaranteed performance. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(4):625658, </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: We show that this lower bound also holds in a much general tree structure model. Next, we focus on obtaining a non-replicating index structure that has optimal query time complexity in dynamic environments. Current structures including R-trees [1, 4, 17], Bang files [15, 16], grid files [21], and hB-trees <ref> [19] </ref> have a worst-case range query complexity of O (n) for n data points. Commercial spatial engines such as ESRI's SDE [11] and Oracle's SDO [23] also have O (n) worst-case query time complexity.
Reference: [20] <author> K. Mehlhorn. </author> <title> Data Structures and Algorithms 3: Multidimensional Searching and Computational Geometry. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: However, this structure maintains O (k d1 ) copies of each data point to achieve this complexity. Furthermore, the query time becomes O (n) when no such replication is allowed. We investigate the complexity of non-replicating index structures. In this context, Mehlhorn <ref> [20] </ref> shows that query time complexity of partial match queries (a restricted form of range queries where only a few of the intervals are specified; the others are assumed to be [1; +1]) is bounded below by (n (d1)=d ) using a decision-tree model. <p> We note that our model represents most current linear-space index structures including R-trees [1, 4, 17], Bang files [15], Quad-trees [27] and is much more general than Mehlhorn's decision trees <ref> [20] </ref>. In what follows, we obtain a lower bound for range query time complexity in this model. 2.2 Lower Bound Since a lower bound in a restricted domain also holds for much general ones, we restrict the data points to have only integer values for their coordinates. <p> Since the number of hole queries is at most d (n 1=d 1), by pigeonhole principle it follows that there is a hole query that has time complexity of O (n (d1)=d ). 2 Bentley's k-d trees [2] (also dd-trees of <ref> [20] </ref>), achieve this query time complexity in static databases. Theorem 2 There exists a non-replicating index structure for n d-dimensional points that has O (n (d1)=d + k) query time for queries retrieving k data points.
Reference: [21] <author> J. Nievergelt, H. Hinterberger, and K. C. Sevcik. </author> <title> The gird file: An adaptable, symmetric multi-key file structure. </title> <booktitle> ACM Trenasactions on Database Systems, </booktitle> <address> 9(1):3871, </address> <month> March </month> <year> 1984. </year> <month> 30 </month>
Reference-contexts: In this paper, we focus on non-replicating index structures for multidimensional range searching. Non-replicating index structures store each data point exactly once. These structures are easy to update and have low storage requirements. Examples of such structures are R-trees [1, 4, 17], Bang files [15], Grid files <ref> [21] </ref>, Quad trees [27], and the divided k-d trees [31]. <p> We show that this lower bound also holds in a much general tree structure model. Next, we focus on obtaining a non-replicating index structure that has optimal query time complexity in dynamic environments. Current structures including R-trees [1, 4, 17], Bang files [15, 16], grid files <ref> [21] </ref>, and hB-trees [19] have a worst-case range query complexity of O (n) for n data points. Commercial spatial engines such as ESRI's SDE [11] and Oracle's SDO [23] also have O (n) worst-case query time complexity.
Reference: [22] <author> M. H. Nodine, M. T. Goodrich, and J. S. Vitter. </author> <title> Blocking for external graph searching. </title> <journal> Algorithmica, </journal> <volume> 16(2):181214, </volume> <year> 1996. </year>
Reference-contexts: Hellerstein et al. [18] study the effect of blocking strategies for d-dimensional data items. For any query that retrieves k data items, they obtain lower bounds on the worst-case number of blocks accessed. Nodine et al. <ref> [22] </ref> study different ways of minimizing these block accesses assuming sufficient amount of buffering. Note that both these papers address the problem of the complexity of data retrieval. They do not estimate the overheads incurred by a query before retrieving relevant data.
Reference: [23] <author> Oracle Inc. </author> <title> Spatial Data Option from Oracle. Manual, </title> <year> 1996. </year>
Reference-contexts: Current structures including R-trees [1, 4, 17], Bang files [15, 16], grid files [21], and hB-trees [19] have a worst-case range query complexity of O (n) for n data points. Commercial spatial engines such as ESRI's SDE [11] and Oracle's SDO <ref> [23] </ref> also have O (n) worst-case query time complexity. The pseudo quad and k-d trees [26] achieve a query time of O (n ((d1)=d)(1+*) ) for any * &gt; 0 and O (log 2 n) amortized time for insertions and deletions.
Reference: [24] <author> M. Overmars. </author> <title> The design of dynamic data structures. </title> <booktitle> Lecture Notes in Computer Science 156, </booktitle> <year> 1983. </year>
Reference-contexts: Since this number is O (n=(km)) = O (log 2 n), each insertion/deletion takes at least O ((log 2 2 n)) time in Step 2. In Step 3, re-balancing of the trees can be accomplished using the technique of partial rebuilding <ref> [24] </ref>. As explained later, this technique costs O (log n) amortized time, which can be transformed into worst-case time using the technique of global rebuilding [25]. Thus, a C-tree for n points supports range queries in optimal time and insertions/deletions in O (log n + (log 2 2 n)) time. <p> By ensuring that ff i s i (n 0 ) updates (insertions/deletions) occur before such rebuilding, the cost is amortized over the updates. This technique for supporting insertions and deletions is called partial rebuilding <ref> [24] </ref>. The algorithm for insertion/deletion of a new point p is given in terms of a general procedure for inserting/deleting a point in an i-layered tree T of s i (n 0 ) points. Procedure Insert-Delete (T, i, p) begin 1. <p> By ensuring that the number of such buffered updates is less than ffn 1 =2, we have at most one structure under construction at all times. This technique is called global rebuilding and is explained in more detail in <ref> [24] </ref>. The following theorem summarizes this technique. <p> Here, W I T (n) and W D T (n) denote the worst-case times for performing weak insertions and weak deletions on a structure T of n points. An insertion (or deletion) on a structure T is called weak <ref> [24] </ref> if there exists an ff, 28 0 &lt; ff &lt; 1, such that after ffn insertions (or deletions), all time and storage bounds of the structure have not increased asymptotically. We apply this theorem on each i-layered O-tree starting from i = 1 to i = 2d in succession.
Reference: [25] <author> M. Overmars and J. van Leeuwen. </author> <title> Worst-case optimal insertion and deletion methods for decomposable searching problems. </title> <journal> Information Processing Letters, </journal> <volume> 12(4):168172, </volume> <year> 1981. </year>
Reference-contexts: In Step 3, re-balancing of the trees can be accomplished using the technique of partial rebuilding [24]. As explained later, this technique costs O (log n) amortized time, which can be transformed into worst-case time using the technique of global rebuilding <ref> [25] </ref>. Thus, a C-tree for n points supports range queries in optimal time and insertions/deletions in O (log n + (log 2 2 n)) time. This is an improvement over current index structures with optimal range query complexity. <p> Insertions and deletions are supported in O (log n) amortized time. Note that the amortized times for updates can be transformed into worst-case times using the technique of global rebuilding <ref> [25] </ref>, which maintains multiple copies of data. <p> Each entry is of the form (c; br), where c refers to a child node and br is the bounding rectangle for all points in the subtree rooted at child c. The R-tree is a dynamic structure and supports insertions/deletions by local rebuilding <ref> [10, 25] </ref>. Local rebuilding (or balancing) denotes the technique applied to search trees so that they maintain logarithmic height during a sequence of updates. Since the R-tree is based on a B + -tree structure, it employs a similar local rebuilding technique as the latter.
Reference: [26] <author> M. Overmars and J. van Leeuwen. </author> <title> Dynamic multi-dimensional data structures based on quad and k-d trees. </title> <journal> Acta Informatica, </journal> <volume> 17:267283, </volume> <year> 1982. </year>
Reference-contexts: Commercial spatial engines such as ESRI's SDE [11] and Oracle's SDO [23] also have O (n) worst-case query time complexity. The pseudo quad and k-d trees <ref> [26] </ref> achieve a query time of O (n ((d1)=d)(1+*) ) for any * &gt; 0 and O (log 2 n) amortized time for insertions and deletions. The divided k-d tree [31] improves this query time to O (n (d1)=d log 1=d n) and insertion/deletion time to O (log n). <p> While the R-trees support insertions/deletions in logarithmic time, the k-d trees support queries in optimal time and insertions/deletions in O (n log n) time (to preserve query optimality). Several attempts to bridge this gap have been made. The pseudo k-d trees <ref> [26] </ref> try to reduce the insertion/deletion overhead of k-d trees. They achieve an amortized insertion/deletion complexity of O (log 2 n). The divided k-d trees [31] reduce the insertion/deletion overheads further down to O (log n).
Reference: [27] <author> H. Samet. </author> <title> The design and analysis of spatial data structures. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Non-replicating index structures store each data point exactly once. These structures are easy to update and have low storage requirements. Examples of such structures are R-trees [1, 4, 17], Bang files [15], Grid files [21], Quad trees <ref> [27] </ref>, and the divided k-d trees [31]. <p> In contrast to Mehlhorn's decision tree model which has d decision trees, one for each dimension, our model has one structure. We note that our model represents most current linear-space index structures including R-trees [1, 4, 17], Bang files [15], Quad-trees <ref> [27] </ref> and is much more general than Mehlhorn's decision trees [20].
Reference: [28] <author> T. Sellis, N. Roussopoulos, and C. Faloutsos. </author> <title> The R+ tree: A dynamic index for multi-dimensional objects. </title> <booktitle> Proc. of the Intl. Conf. on Very Large Databases, </booktitle> <pages> pages 507518, </pages> <year> 1988. </year>
Reference-contexts: Appendix A Analysis of Range Query Time Complexity of Some Non-replicating Structures A.1 Range Query Time Complexity of R-trees We demonstrate that for specific data points and queries, the R-tree and its variants <ref> [1, 4, 17, 28] </ref> have a worst-case complexity of O (n) for range queries on n data points. The R-tree is an extension of the B + -tree for multidimensional data. As in the B + -tree, data is stored in the leaves.
Reference: [29] <author> S. Subramanian and S. Ramaswamy. </author> <title> The P-range tree: A new data structure for range searching in secondary memory. </title> <booktitle> Proc. ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 378387, </pages> <year> 1995. </year>
Reference-contexts: This type of searching in multidimensional space has important applications in geographic information systems, image databases, and computer graphics. Several structures such as the range trees [3], P-range trees <ref> [29] </ref> have been designed to support range searching in polylogarithmic time. These structures require non-linear storage space, which may not be acceptable for large database systems. Besides, updates in these structures have to handle multiple copies of data points. This, in turn, leads to consistency problems in concurrent environments. <p> These analyses estimated the cost using the number of instructions and did not consider memory accesses. In large databases, the memory/disk accesses are more expensive than computation. Considering this, Chazelle [6], Subramanian et al. <ref> [29] </ref>, and Vaidya [30] analyzed the complexity in terms of the number of memory/disk accesses. Using a pointer-machine model, Chazelle [6, 7, 9] showed that polylogarithmic query time for n d-dimensional points can only be obtained with O (n (log n= log log n) d1 ) space. <p> His filtering search technique [5], which used O (n log n= log log n) space for 2-dimensional data and achieved logarithmic query time, was optimal. Subramanian et al. <ref> [29] </ref> also considered the memory/disk block size, B, and enhanced Chazelle's results for 2-dimensions.
Reference: [30] <author> P. M. Vaidya. </author> <title> Space-time tradeoffs for orthogonal range queries. </title> <journal> SIAM Journal of Computing, </journal> <volume> 18(4):748758, </volume> <year> 1989. </year>
Reference-contexts: Several results for the complexity of multidimensional range searching have been established in computational geometry literature. Fredman [12, 13, 14] analyzed the complexity of range searching in dynamic environments. Yao [32] analyzed it for semi-dynamic environments. In static environments, Vaidya <ref> [30] </ref> established a storage space-query time tradeoff that was later strengthened by Chazelle [6, 8]. These analyses estimated the cost using the number of instructions and did not consider memory accesses. In large databases, the memory/disk accesses are more expensive than computation. <p> These analyses estimated the cost using the number of instructions and did not consider memory accesses. In large databases, the memory/disk accesses are more expensive than computation. Considering this, Chazelle [6], Subramanian et al. [29], and Vaidya <ref> [30] </ref> analyzed the complexity in terms of the number of memory/disk accesses. Using a pointer-machine model, Chazelle [6, 7, 9] showed that polylogarithmic query time for n d-dimensional points can only be obtained with O (n (log n= log log n) d1 ) space. <p> They showed that O (log c B n + t=B) query time, where c is any positive integer and t is the size of the query result, can only be achieved with O ( n B (log n B ) storage space. For arbitrary number of dimensions, Vaidya <ref> [30] </ref> established a storage space (S)-query time (T) tradeoff equation for static environments: S d1 c 2 (d; n)T (log T + log log n) d1 : Here (d; n) is 1 for d = 2 and log n otherwise. Time T is the query time overhead per retrieved object. <p> In Section 4, we generalize the O-tree to arbitrary dimensions and explain how insertions and deletions are supported. We summarize these results in the concluding section. 2 Lower Bound for Range Query Time Complexity in Non-replicating Index Structures 2.1 Model Following Vaidya <ref> [30] </ref>, we model index structures as rooted trees. Each vertex v in such an index stores a set of data items (denoted by data (v)) and has at most a constant number, say r, of children (denoted by children (v)).
Reference: [31] <author> M. van Kreveld and M. Overmars. </author> <title> The divided k-d tree. </title> <journal> Algorithmica, </journal> <volume> 6:840858, </volume> <year> 1991. </year>
Reference-contexts: Non-replicating index structures store each data point exactly once. These structures are easy to update and have low storage requirements. Examples of such structures are R-trees [1, 4, 17], Bang files [15], Grid files [21], Quad trees [27], and the divided k-d trees <ref> [31] </ref>. In this paper, we propose a new dynamic structure that achieves O (n (d1)=d ) range query time complexity and fl Work supported in part by a research grant from NSF/ARPA/NASA IRI9411330 and NSF instrumentation grant CDA-9421978. 1 O (log n) insertion/deletion time complexity. <p> This structure improves the best known bound O (n (d1)=d log 1=d of the divided k-d tree <ref> [31] </ref> for query time complexity in dynamic environments. We also show that this structure is optimal when data is not replicated. Several results for the complexity of multidimensional range searching have been established in computational geometry literature. Fredman [12, 13, 14] analyzed the complexity of range searching in dynamic environments. <p> The pseudo quad and k-d trees [26] achieve a query time of O (n ((d1)=d)(1+*) ) for any * &gt; 0 and O (log 2 n) amortized time for insertions and deletions. The divided k-d tree <ref> [31] </ref> improves this query time to O (n (d1)=d log 1=d n) and insertion/deletion time to O (log n). We propose a new structure the O-tree (short for optimal k-d tree) that achieves O (n (d1)=d ) range query time and 2 O (log n) amortized insertion and deletion times. <p> We propose a new structure the O-tree (short for optimal k-d tree) that achieves O (n (d1)=d ) range query time and 2 O (log n) amortized insertion and deletion times. The structure combines the static k-d tree [2] and the divided k-d tree <ref> [31] </ref> in a novel fashion and achieves optimality for both queries as well as updates. As in the divided k-d tree, the amortized times for insertions/deletions can be transformed into worst-case bounds using replication. In addition, the O-tree also supports exact match queries in worst-case logarithmic time. <p> Several attempts to bridge this gap have been made. The pseudo k-d trees [26] try to reduce the insertion/deletion overhead of k-d trees. They achieve an amortized insertion/deletion complexity of O (log 2 n). The divided k-d trees <ref> [31] </ref> reduce the insertion/deletion overheads further down to O (log n). In their attempt to support insertions/deletions efficiently, these and other dynamic structures compromise query optimality. <p> Hence, this structure is optimal for range queries. We refer to this structure as the combined k-d tree, C-tree for short, since it combines the divided k-d tree with the static k-d trees. As in the divided k-d tree <ref> [31] </ref>, the C-tree has 2-layers of B-trees, each organized on a different dimension. However, at both the layers, every B-tree has k = O ( p n= log n) partitions. The exact value of k will be specified later. <p> Such structures are of interest due to their low storage costs and ease of updation. We proposed a new dynamic non-replicating index structure that achieves O (n (d1)=d ) query time complexity and O (log n) amortized insertion/deletion time complexity. This structure improves the previous known upper bound <ref> [31] </ref> of O (n (d1)=d log 1=d n) for query time in dynamic structures. We also proved that this structure is optimal when data is not replicated. In addition to optimal query time and logarithmic insertion/deletion times, the structure also supports exact match queries in worst-case logarithmic time. <p> Hence the result follows. 2 D Conversion of Amortized Insertion/Deletion Bounds of An O-tree to Worst-case Bounds As in the divided k-d tree, the amortized times for insertions and deletions of Theorem 6 can be changed into worst-case bounds using the general technique of global rebuilding described in <ref> [31] </ref>. This technique is based on the following idea. Consider a structure S that supports weak insertions and weak deletions.
Reference: [32] <author> A. C. Yao. </author> <title> Space-time trade-off for answering range queries. </title> <booktitle> Proc. ACM Symp. on Theory of Computing, </booktitle> <address> 14:128136, </address> <year> 1982. </year> <month> 31 </month>
Reference-contexts: We also show that this structure is optimal when data is not replicated. Several results for the complexity of multidimensional range searching have been established in computational geometry literature. Fredman [12, 13, 14] analyzed the complexity of range searching in dynamic environments. Yao <ref> [32] </ref> analyzed it for semi-dynamic environments. In static environments, Vaidya [30] established a storage space-query time tradeoff that was later strengthened by Chazelle [6, 8]. These analyses estimated the cost using the number of instructions and did not consider memory accesses.
References-found: 32

