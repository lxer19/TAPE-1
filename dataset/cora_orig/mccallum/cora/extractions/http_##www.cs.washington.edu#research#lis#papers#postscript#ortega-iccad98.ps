URL: http://www.cs.washington.edu/research/lis/papers/postscript/ortega-iccad98.ps
Refering-URL: http://www.cs.washington.edu/homes/ortega/papers/publications.html
Root-URL: http://www.cs.washington.edu
Abstract: 1. ABSTRACT 
Abstract-found: 1
Intro-found: 1
Reference: <institution> Stand Alone Full CAN Controller, Preliminary Data. Siemens, </institution> <year> 1996. </year>
Reference: [2] <author> I. Bolsens, H.J. DeMan, B. Lin, K. Van Rompaey, S. Vercau teren, D. Verkest. </author> <title> Hardware/software co-design of digital tele communication systems. </title> <booktitle> In Proceedings of the IEEE 85(3) </booktitle> <pages> 391-418, </pages> <month> March </month> <year> 1997. </year>
Reference-contexts: Yen and Wolf [22] address the problem of heterogeneous processors connected via arbitrary bus topologies. However, they assume an abstract protocol based on processor priorities. CoWare <ref> [2] </ref> supports heterogeneous processors, but focuses on shared memory communication and nonstandard protocols. Gasteier and Glesner [8] attempt to synthesize busses that do not require arbitration. This approach is more suitable for data-ow oriented systems with predictable communication patterns than for control-dominated systems.
Reference: [3] <author> P. Chou, R. Ortega, and G. Borriello. </author> <title> Synthesis of the hard ware/software interface in microcontroller-based systems. </title> <booktitle> In Proceedings of the International Conference on Computer- Aided Design , November 1992. </booktitle>
Reference-contexts: If the processor has built-in support for a bus protocol, then the given interface to this internal peripheral only requires software instructions to access the particular control registers. However, it may be necessary to use an external communications chip such as the SAE 81C90 [1]. In [4] and <ref> [3] </ref> it was shown how to automatically connect peripheral devices to a microprocessor by synthesizing any necessary glue logic and reecting the new hardware interface to the device in the low-level device-driver.
Reference: [4] <author> P.H. Chou, R.B. Ortega, and G. Borriello. </author> <title> Interface co-synthe sis techniques for embedded systems. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design November 1995. </booktitle>
Reference-contexts: If the processor has built-in support for a bus protocol, then the given interface to this internal peripheral only requires software instructions to access the particular control registers. However, it may be necessary to use an external communications chip such as the SAE 81C90 [1]. In <ref> [4] </ref> and [3] it was shown how to automatically connect peripheral devices to a microprocessor by synthesizing any necessary glue logic and reecting the new hardware interface to the device in the low-level device-driver.
Reference: [5] <author> J-M. Daveau, G.F. Marchioro, T.Ben-Ismail, and A.A. Jer raya. </author> <title> Protocol selection and interface generation for hw-sw codesign. </title> <booktitle> IEEE Trans. on Very Large Scale Integration </booktitle> (5)1:136-144, March 1997. 
Reference-contexts: Chip message router glue logic CAN Comm. Chip scheduler CAN device driver port A protocol producer initialization Processor P Processor P consumerproducer portA portB can (M1) paper can be viewed as automating this approach. Daveau al . <ref> [5] </ref> take a behavioral description and automatically select a protocol from a library to implement the communication. They use non-standard protocols such as bidirectional handshake and dual fifo.
Reference: [6] <author> R. Ernst and T. Benner. </author> <title> Communication, constraints, and user-directives in COSYMA. </title> <type> Technical Report TM CY-94-2, </type> <institution> Technical University of Braunschweig, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: Recently there has been much attention focused on the problem of communication synthesis for distributed real-time embedded systems [13]. Many of these efforts either do not consider the global properties of the communication links or map to non-standard protocols. Vahid and Tauro [21] and Ernst and Benner <ref> [6] </ref> both proposed using a communication library with a standard API (Application Program Interface). However, protocols based on message priorities require a unique allocation of all the priorities on the bus in addition to providing an API.
Reference: [7] <author> D. Gajski, F. Vahid, S. Narayan, and J. Gong. </author> <title> Specification and Design of Embedded Systems . Prentice-Hall, </title> <address> Englewood Cliffs, NJ, </address> <year> 1994. </year>
Reference-contexts: Daveau al . [5] take a behavioral description and automatically select a protocol from a library to implement the communication. They use non-standard protocols such as bidirectional handshake and dual fifo. Gajski . <ref> [7] </ref> consider all of the events on the bus, but they implement a non-standard bus protocol and do not address real-time kernel synthesis. Yen and Wolf [22] address the problem of heterogeneous processors connected via arbitrary bus topologies. However, they assume an abstract protocol based on processor priorities.
Reference: [8] <author> M. Gasteier and M. Glesner. </author> <title> Bus-based communication syn thesis on system-level. </title> <booktitle> In Proceedings of the International Symposium on System Synthesis , November, </booktitle> <year> 1996. </year>
Reference-contexts: Yen and Wolf [22] address the problem of heterogeneous processors connected via arbitrary bus topologies. However, they assume an abstract protocol based on processor priorities. CoWare [2] supports heterogeneous processors, but focuses on shared memory communication and nonstandard protocols. Gasteier and Glesner <ref> [8] </ref> attempt to synthesize busses that do not require arbitration. This approach is more suitable for data-ow oriented systems with predictable communication patterns than for control-dominated systems.
Reference: [9] <author> K. Hines and G. Borriello. </author> <title> Dynamic communication models in embedded system co-simulation. </title> <booktitle> In Proceedings of the 34th Design Automation Conference , pp. </booktitle> <pages> 395-400, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: All of the remaining details of system communication are automatically synthesized. The effect is that an application-specific real-time operating system is generated for each processor in the system. The communication synthesis tool has been fully integrated with a system co-simulator <ref> [9] </ref> to quickly provide designers with performance information for a given mapping. Throughout this paper we will use the example of the robot control system shown in Figure 4. The robot has two fundamental modes of operation. <p> Synthesis for this mapping takes longer because the deadlines are partitioned for multihop communication, generating files for the hop processes (6 messages are multihop) and their corresponding outports. Each of the architectures was executed in the Pia co-simulation environment <ref> [9] </ref>. The joystick process was modified to send out periodic commands. After 20 commands, the logging of the system was halted. A few of the more interesting statistics are shown in Table 2. This type of data can be used by system architects to quantify architectural tradeoffs.
Reference: [10] <author> D.D. Kandlur, K.G. Shin, and D. Ferrari. </author> <title> Real-time communi cation in multihop networks. </title> <journal> IEEE Trans. on Parallel and Distributed Systems </journal> (5)10:1044-1055, October, 1994. 
Reference-contexts: This approach is more suitable for data-ow oriented systems with predictable communication patterns than for control-dominated systems. There has also been work done in the area of scheduling messages in a multiprocessor environment to meet real-time and quality of service constraints <ref> [10] </ref>. Message scheduling globally analyzes the communication requirements of the system to create an effective scheduler. However it is assumed that there is a simple API providing access to the bus. As discussed above, not all protocols can be implemented without a synthesis step prior to using the API. <p> In the robot, all command messages have an overwrite policy without notification. Only the logger process has a queuing policy with notification. This particular notification routine simply records that data was lost. Similar to <ref> [10] </ref> various message attributes must be specified to enable global analysis. These attributes include the maximum size of any message generated on an outport, the maximum frequency at which the messages may be generated, and a required response-time constraint.
Reference: [11] <author> H. Kopetz et al. </author> <title> Distributed fault-tolerant real-time systems: the Mars approach. </title> <booktitle> IEEE Micro , 9(1) </booktitle> <pages> 25-40, </pages> <month> February </month> <year> 1989 </year>
Reference-contexts: COMMUNICATION MODEL We have developed a communication model suitable for reactive real-time embedded systems. The model is based on a set of processes that communicate by exchanging non-blocking messages. A non-blocking protocol is more appropriate for distributed real-time systems than a blocking protocol <ref> [11] </ref> partly because it decouples computation from communication. When a process executes a message send returns immediately after passing the message to the real-time kernel. Messages from other processors are received asynchronously via an interrupt indicating a message arrival.
Reference: [12] <author> A.H. Mebane IV, J.R. Schmedake, I-S Chen, </author> <title> and A.P. Kadon-aga. Electronic and firmware design of the HP LaserJet Draft ing Plotter. </title> <journal> Hewlett-Packard Journal 43(6) </journal> <pages> 16-23, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: These systems are characterized by having heterogeneous processors connected by heterogeneous busses. For instance, an HP LaserJet design has three different processors and two different busses connecting the processors as well as many point to point connections <ref> [12] </ref>. The designers selected the most appropriate interprocessor communication based upon the requirements of the functions mapped to each processor. Designers of distributed systems are faced with many choices in connecting the various processors together. Upender and Koopman [20] list many standard bus protocols commonly used in embedded systems.
Reference: [13] <author> R.B. Ortega, L. Lavagno, and G. Borriello. </author> <title> Models and meth ods for hw/sw intellectual property interfacing. </title> <booktitle> In 1998 NATO ASI on System-level Synthesis </booktitle>
Reference-contexts: All of these details must be considered when creating a communication infrastructure. Recently there has been much attention focused on the problem of communication synthesis for distributed real-time embedded systems <ref> [13] </ref>. Many of these efforts either do not consider the global properties of the communication links or map to non-standard protocols. Vahid and Tauro [21] and Ernst and Benner [6] both proposed using a communication library with a standard API (Application Program Interface).
Reference: [14] <author> R.B. Ortega and G. Borriello. </author> <title> Communication synthesis for embedded systems with global considerations. </title> <booktitle> In Proceedings of the 5th International Workshop on Hardware/Software Codesign , March 1997. </booktitle>
Reference: [15] <institution> I 2 C Peripherals for Microcontrollers. Philips Semiconductors, </institution> <year> 1992. </year>
Reference-contexts: Ortega Dept. of Computing and Software Systems University of Washington Bothell, WA 98021-4900 USA ortega@u.washington.edu Gaetano Borriello Dept. of Computer Science & Engineering University of Washington Seattle, WA 98195-2350 gaetano@cs.washington.edu separate CAN busses connected by an Inter-Integrated Circuit (I C) bus <ref> [15] </ref>. Without a communication synthesis tool, the designer must develop a unique communication infrastructure for both architectures.
Reference: [16] <author> R. Rajkumar, L. Sha. and J.P. Lehoczky. </author> <title> Real-time synchroni zation protocols for multiprocessors. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium </booktitle>
Reference-contexts: A handler is a subroutine invoked to perform a service on behalf of a message. The typical handler consumes the triggering message, modifies state variables, generates outgoing messages and terminates. A handler may only run for a bounded amount of time and executes with completion semantics <ref> [16] </ref>. That is, once a handler begins executing it has the illusion of running without preemption. No other handlers from the same process may begin until the currently running handler terminates. <p> Message-based priority protocols give the most exibility to the synthesis tool in meeting the timing requirements of the system. Priorities are assigned according to the deadlines of the individual messages. Messages with smaller deadlines have higher priority with ties broken arbitrarily but consecutively allocated. Because of priority inversion <ref> [16] </ref>, processor-based priorities are problematic for real-time systems and give the least exibility to the synthesis tool. For example, consider a process that generates an infrequent and short deadline message M , but normally generates long deadline message M 2 .
Reference: [17] <author> J.A. Rowson, A. </author> <title> Sangiovanni-Vincentelli. </title> <booktitle> Interface-based design. In Proceedings of the Design Automation Conference pp 178-83, </booktitle> <month> June </month> <year> 1997. </year>
Reference: [18] <author> B. Selic, G. Gullekson, and P.T. </author> <title> Ward. </title> <publisher> Real-Time Object-Ori ented Modeling . John Wiley & Sons, </publisher> <year> 1994. </year>
Reference: [19] <author> K. Tindell and A. Burns. </author> <title> Guaranteed message latencies for distributed safety-critical hard real-time control networks. </title> <type> Technical Report YCS-94-229, </type> <institution> University of York, </institution> <year> 1994. </year>
Reference-contexts: The communication synthesis tool must distribute this deadline along the messages path so that the protocol parameters for all messages can be effectively determined. Previous work in determining the worst-case delay for transmitting a message such as <ref> [19] </ref> require restrictions which are incompatible with our communication model. For example, the assumption that a messages timing constraint must be less than the period of the sending process implies that a message can only have a send queue depth of one.
Reference: [20] <author> B.P. Upender and P.J. Koopman Jr. </author> <title> Communication protocols for embedded systems. </title> <booktitle> Embedded Systems Programming 7(11) </booktitle> <pages> 46-58, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: The designers selected the most appropriate interprocessor communication based upon the requirements of the functions mapped to each processor. Designers of distributed systems are faced with many choices in connecting the various processors together. Upender and Koopman <ref> [20] </ref> list many standard bus protocols commonly used in embedded systems. It is increasingly attractive for designers to use a known protocol instead of creating an arbitrary or proprietary one. Microprocessors targeted toward the embedded market incorporate support for the most popular protocols directly on chip. <p> The first step groups all of the messages that are sent on a particular bus. Protocol attributes are assigned to the messages and processors based on the arbitration scheme of the bus. We have modified the taxonomy in <ref> [20] </ref> to focus on the attributes which are required for protocol synthesis. Our taxonomy considers protocols that base arbitration on message priority, processor priority, master/slave, time, time/processor priority hybrid, and non-priority schemes.
Reference: [21] <author> F. Vahid and L. Tauro. </author> <title> An object-oriented communication library for hardware-software codesign. </title> <booktitle> In Proceedings of the 5th International Workshop on Hardware/Software Codesign March 1997. </booktitle>
Reference-contexts: Recently there has been much attention focused on the problem of communication synthesis for distributed real-time embedded systems [13]. Many of these efforts either do not consider the global properties of the communication links or map to non-standard protocols. Vahid and Tauro <ref> [21] </ref> and Ernst and Benner [6] both proposed using a communication library with a standard API (Application Program Interface). However, protocols based on message priorities require a unique allocation of all the priorities on the bus in addition to providing an API.
Reference: [22] <author> T.-Y. Yen and W. Wolf. </author> <title> Communication synthesis for distrib uted systems. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design , November 1995. </booktitle>
Reference-contexts: They use non-standard protocols such as bidirectional handshake and dual fifo. Gajski . [7] consider all of the events on the bus, but they implement a non-standard bus protocol and do not address real-time kernel synthesis. Yen and Wolf <ref> [22] </ref> address the problem of heterogeneous processors connected via arbitrary bus topologies. However, they assume an abstract protocol based on processor priorities. CoWare [2] supports heterogeneous processors, but focuses on shared memory communication and nonstandard protocols. Gasteier and Glesner [8] attempt to synthesize busses that do not require arbitration.
Reference: [23] <author> H. Zeltwanger. </author> <title> An inside look at the fundamentals of CAN. </title> <booktitle> Control Engineering , 42(1), </booktitle> <month> January </month> <year> 1995. </year> <title> Mapping DeadManHalt (min, </title> <editor> max) Joystick (min, max) WheelsVel (min, max) AutoPilots (min, max) CAN bus 47, </editor> <volume> 47 29, 155 97, 165 38, 134 CAN/I 2 C 29, 309 29, 12275 97, </volume> <month> 132 38, </month> <title> 438 Table 2: Evaluation of the three robot mappings. Min and max transmit times are shown for selected messages. </title>
References-found: 23

