URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-17.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-17.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [ANRS92] <author> Mansoor Ansari, Linda Ness, Marek Rusinkiewicz, and Amit Sheth. </author> <title> Using flexible transactions to support multi-system telecommunications applications. </title> <booktitle> In Proceedings of the 18th VLDB Conference, </booktitle> <pages> pages 65-76, </pages> <year> 1992. </year>
Reference-contexts: This global transaction is viewed as being atomic, although their work also supports the notion of using a semantically atomic commit protocol. Flex transactions were implemented within the InterBase system [BCEP93]. They also have been implemented and used to support multi-system telecommunication applications <ref> [ANRS92] </ref>. 2.3.4 ConTracts In [WR91], Waechter and Reuter describe a database transaction model called the ConTract Model. ConTracts are very similar in structure to Interactions. ConTracts are scripts of steps.
Reference: [Bar90] <author> Kenneth Barker. </author> <title> Transaction management on multidatabase systems. </title> <type> Technical Report TR 90-23, </type> <institution> Department of Computing Science, The University of Alberta, </institution> <year> 1990. </year>
Reference-contexts: Both models assume that the local database executions are serializable. Quasi-serializability [DE89, DEK91], also called multidatabase serializability <ref> [Bar90] </ref>, states that the global transactions must be run in such a way that no two transactions executing on the same local database run concurrently.
Reference: [BCEP93] <author> O. A. Bukhres, J. Chen, A. K. Elmagarmid, and R. Pezzoli. </author> <title> InterBase: An execution environment for global applications over distributed, heterogeneous, and autonomous software systems. </title> <note> (to appear), </note> <month> August </month> <year> 1993. </year>
Reference-contexts: Flex transactions differ from Interactions in that they support flexibility within the context of a single global transaction. This global transaction is viewed as being atomic, although their work also supports the notion of using a semantically atomic commit protocol. Flex transactions were implemented within the InterBase system <ref> [BCEP93] </ref>. They also have been implemented and used to support multi-system telecommunication applications [ANRS92]. 2.3.4 ConTracts In [WR91], Waechter and Reuter describe a database transaction model called the ConTract Model. ConTracts are very similar in structure to Interactions. ConTracts are scripts of steps.
Reference: [BGRS91] <author> Yuri Breitbart, Dimitrios Georgakopoulos, Marek Rusinkiewicz, and Abraham Silberschatz. </author> <title> On rigorous transaction scheduling. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(9) </volume> <pages> 954-960, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: There are a variety of schemes that have been proposed for this, each of which has a rough analogue in the realm of concurrency control in a single local database. These schemes are described below, and are summarized in Table 2.1. 2.1.1.1 Pessimistic Schemes Breitbart et al. <ref> [BGRS91] </ref> define a desirable property for local databases called analogous execution and serialization order, which basically means that the serialization order of a database can be derived from the order in which the transactions execute. <p> However, if we relax the requirement on the local databases to strictness (which allows read locks to be released before transaction commit), then they no longer have analogous execution and serialization order. An example non-serializable multidatabase history where the local histories are strict is given in <ref> [BGRS91] </ref>. Pessimistic schemes require the local databases in the multidatabase to all be strongly recoverable. This is a subset of the types of local databases we allow when using the serialization order approaches in our prototype implementation, which are merely required to be serializable. <p> Conflict Site Graph Testing [BS88] Testing Two-Phase Lock Last Lock Forced Local Conflict [GRS91] I to Commit (Get ticket after last lock.) Timestamp Order Begin Forced Local Conflict [GRS91] I (Get ticket with transaction begin.) Rigorous 2PL Commit Strict 2PL/2PC Schemes [SKS91b] R (Rigorous 2PL local databases only) Rigorous multidatabases <ref> [BGRS91] </ref> R Commitment Order Commit Multiple Resource CO [Raz92b] R (CO local databases only) Conservative SGT Data Conflict Request-Order Linked List [PRR91] C O-schemes [MRB + 92b] C Conservative 2PL Commit Conservative TO Begin BT-schemes [MRB + 92b] C SGT Certifier Data Conflict Optimistic Ticket Method [GRS93] I 2PL Certifier Commit
Reference: [BGS92] <author> Y. Breitbart, H. Garcia-Molina, and A. Silberschatz. </author> <title> Overview of multidatabase transaction management. </title> <journal> VLDB Journal, </journal> <volume> 1(2) </volume> <pages> 181-239, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: They outlined a set of requirements on local databases in a multidatabase so that atomic transactions on the multidatabase could be supported. Since then, many interesting developments have occurred in the area of transaction models for multidatabases. Many of these are summarized in <ref> [BGS92] </ref>. In this chapter, we discuss other research that is related to our work on Interactions.
Reference: [BHG87] <author> P. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: It is easy to see that standard transactions are a one-level restriction of multilevel transactions, where a transaction can only specify read and write operations. With this restriction, multilevel serializability is equivalent to conflict serializability <ref> [BHG87] </ref>. Multilevel transactions have been implemented as a part of the DASDBS prototype [Wei91, SPSW90]. Weikum and Schek do briefly explore modeling multidatabase transactions as two-level multilevel transactions. <p> fs i ; s j g HE L , s i 2 t i , s j 2 t j , and s i &lt; LH s j (that is, s i and s j conflict in the local database), then t i &lt; T LS t j . 1 <ref> [BHG87] </ref>, page 29. 45 Because we assume that the local databases are autonomous, we must also assume that an operation--level knowledge of the local database histories is unavailable to the multidatabase. <p> For each local database whose transactions are involved in the cycle, find a path in the graph induced by its history that contains all nodes representing its transactions in the cycle. This path traverses the nodes 2 <ref> [BHG87] </ref>, p. 33, Theorem 2.1. 47 in the local serialization order for that database. Because there is a cycle, we know that at least one of these paths traverses at least two nodes in the opposite order from the global serialization order. <p> This knowledge can be used in implementing either a normal scheme (to manipulate the local serialization order) or in a certification scheme (to deduce the local serialization order) to enforce a consistent global serialization order. The different concurrency control strategies we examine here are described in <ref> [BHG87] </ref>. We first examine the rigorous 2PL, then timestamp ordering and serialization graph testing. <p> This decision cannot be revoked once it is made. The most common example of an agreement protocol used for multidatabases is two-phase commit <ref> [BHG87] </ref>. In two-phase commit, a centralized coordinator asks each global subtransaction to vote whether to commit or abort. Just one "abort" vote from a global subtransaction implies that the whole global transaction aborts.
Reference: [B OH + 91] <author> Alejandro Buchmann, M. Tamer Ozsu, Mark Hornick, Dimitrios Georgakopoulos, and Frank A. Manola. </author> <title> A transaction model for active distributed object systems. </title> <editor> In A. Elmagarmid, editor, </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: Dayal et al. [DHL90] developed the event-condition-action (ECA) rules as a part of their active database work. ECA rules were the model we originally used when determining how to specify a weak conflict. Recently, work has also been done by Buchmann et al. <ref> [B OH + 91] </ref> on active multidatabases. Interactions resemble active databases in that they monitor the multidatabase for specific changes in the values of data items, and react to those changes.
Reference: [BS88] <author> Yuri Breitbart and Avi Silberschatz. </author> <title> Multidatabase update issues. </title> <booktitle> In ACM SIGMOD, </booktitle> <pages> pages 135-142, </pages> <year> 1988. </year>
Reference-contexts: Early efforts to provide a global transaction model for multidatabases generally limited the global (and possibly local) transactions' access to the information in the database. For instance, Multibase [SBD + 81] only allowed the global transactions read access to the information in the multidatabase. In <ref> [BS88] </ref>, Breitbart and Silberschatz examined issues in allowing multidatabase updates. They proposed an algorithm based on site graphs that ensures that no two concurrent global transactions access more than one database in common. However, this method allows a very low degree of concurrency among the global transactions. <p> A multidatabase similarly tries to order conflicting global subtransactions on local databases such that the global transactions access the local databases in a consistent order. This helps ensure that the 16 Concurrency Control Serialization Corresponding Restric--Mechanism Point Multidatabase Mechanism tions Serialization Graph Data Conflict Site Graph Testing <ref> [BS88] </ref> Testing Two-Phase Lock Last Lock Forced Local Conflict [GRS91] I to Commit (Get ticket after last lock.) Timestamp Order Begin Forced Local Conflict [GRS91] I (Get ticket with transaction begin.) Rigorous 2PL Commit Strict 2PL/2PC Schemes [SKS91b] R (Rigorous 2PL local databases only) Rigorous multidatabases [BGRS91] R Commitment Order Commit <p> The first column lists different single database concurrency control schemes. Their respective serialization points are listed in the second column. In the third column we list analogous multi-database concurrency control schemes. For instance, site graph testing <ref> [BS88] </ref> uses a graph approach similar to a serialization graph, and delays submission if a cycle is found in the site graph.
Reference: [BST90] <author> Yuri Breitbart, Avi Silberschatz, and Glenn R. Thompson. </author> <title> Reliable transaction management in a multidatabase system. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 215-224, </pages> <year> 1990. </year>
Reference-contexts: In [EH88], Elmagarmid and Helal restricted the global transactions so that the set of databases read from and the set of databases written to by a single global transaction had an intersection of at most one local database. Later schemes <ref> [BST90] </ref> partitioned the information into locally- and globally-updateable information, and restricted access accordingly. This idea also plays a part in [MRKS91] and [MRB + 92a]. <p> A passive blocking protocol implements a low-level filtering at all times. The most widely-proposed examples of a passive blocking protocol partition the multidatabase according to what can be accessed in what ways by the global and local transactions <ref> [BST90, MRKS91, MRB + 92a] </ref>. Basically, the partitioning allows the global multidatabase transactions to proceed without unwanted interference from the local transactions. Several examples of active blocking protocols have been proposed.
Reference: [CBE93] <author> Jiansan Chen, Omran Bukhres, and Ahmed K. Elmagarmid. </author> <title> IPL: A multidatabase transaction specification language. </title> <booktitle> In Proceedings of the 13th International Conference on Distributed Computing Systems, </booktitle> <year> 1993. </year>
Reference-contexts: However, steps do make an easy and intuitive way to specify the task at the global level, as they encapsulate the details of the local databases. TaSL as a database language is the most procedural of the languages that support flexible executions. IPL <ref> [CBE93] </ref> specifies the subtransactions and dependencies independently, and has no concept of preferences among different alternatives. ACTA [CR90] is more of a formalism than a language. Other flexible transaction models do not define the language they use.
Reference: [CR90] <author> Panayiotis K. Chrysanthis and Krithi Rmamaritham. </author> <title> ACTA: A framework for specifying and reasoning about transaction structure and behavior. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 194-203, </pages> <year> 1990. </year>
Reference-contexts: Interactions, however, assume that more complex relationships can exist between the atomic subtasks. Also, Sagas have no weaker notion of conflict as Interactions have. Nonetheless, we consider Sagas to be an important predecessor of our work. 1 Atomicity, Consistency, Isolation, Durability 20 2.3.2 ACTA ACTA <ref> [CR90, CR91b] </ref> is not a transaction model, but rather it is a framework for characterizing the structure and behavior of existing advanced transaction models, and for allowing a relative comparison between them with respect to concurrency, concurrency control, and recovery. <p> TaSL as a database language is the most procedural of the languages that support flexible executions. IPL [CBE93] specifies the subtransactions and dependencies independently, and has no concept of preferences among different alternatives. ACTA <ref> [CR90] </ref> is more of a formalism than a language. Other flexible transaction models do not define the language they use. With respect to planning, TaSL is the only database language we know of that inherently supports a notion of backtracking to regain consistency.
Reference: [CR91a] <author> Panos K. Chrysanthis and Krithi Ramamritham. </author> <title> ACTA: The SAGA continues. </title> <editor> In A. K. Elma-garmid, editor, </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: ACTA has been used to characterize many of the different transaction models. For example, Sagas are characterized in the ACTA framework in <ref> [CR91a] </ref>. While we have not attempted to use ACTA to characterize Interactions, we suspect that ACTA is not yet comprehensive enough for this characterization to succeed.
Reference: [CR91b] <author> Panos K. Chrysanthis and Krithi Ramamritham. </author> <title> A formalism for extended transaction models. </title> <booktitle> In VLDB 1991 Proceedings, </booktitle> <pages> pages 103-112, </pages> <year> 1991. </year>
Reference-contexts: Interactions, however, assume that more complex relationships can exist between the atomic subtasks. Also, Sagas have no weaker notion of conflict as Interactions have. Nonetheless, we consider Sagas to be an important predecessor of our work. 1 Atomicity, Consistency, Isolation, Durability 20 2.3.2 ACTA ACTA <ref> [CR90, CR91b] </ref> is not a transaction model, but rather it is a framework for characterizing the structure and behavior of existing advanced transaction models, and for allowing a relative comparison between them with respect to concurrency, concurrency control, and recovery.
Reference: [Dav78] <author> C. T. Davies, Jr. </author> <title> Data processing spheres of control. </title> <journal> IBM Systems Journal, </journal> <volume> 17(2) </volume> <pages> 179-198, </pages> <year> 1978. </year>
Reference-contexts: By open nested, we mean that Interactions are defined as a related set of global transactions, each of which executes in its own sphere of control (as defined by Davies in <ref> [Dav78] </ref>). As each global transaction completes it fully commits and releases its resources. By flexible, we mean that alternative executions may be specified, though only one will actually succeed. The Interaction model is meant to support applications whose tasks execute for a long time and/or may be defined flexibly.
Reference: [DBC + 88] <author> U. Dayal, B. Blaustein, U. Chakravarthy, M. Hsu, R. Ladin, D. McCarthy, A. Rosenthal, S. Sarin, M.J. Carey, M. Livny, and R. Jauhari. </author> <title> The HiPAC project: Combining active databases and timing constraints. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 17(1) </volume> <pages> 51-70, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: If some constraint is violated, then the database itself initiates some action to rectify the information in the database so that the constraint once again holds. Examples of active databases include Cactis [HK86] and HiPAC <ref> [DBC + 88] </ref>. Dayal et al. [DHL90] developed the event-condition-action (ECA) rules as a part of their active database work. ECA rules were the model we originally used when determining how to specify a weak conflict.
Reference: [DE89] <author> Weimin Du and Ahmed K. Elmagarmid. Quasi-serializability: </author> <title> A correctness criterion for global concurrency control in InterBase. </title> <booktitle> In Proceedings of the 15th VLDB, </booktitle> <pages> pages 347-355, </pages> <year> 1989. </year>
Reference-contexts: Both models assume that the local database executions are serializable. Quasi-serializability <ref> [DE89, DEK91] </ref>, also called multidatabase serializability [Bar90], states that the global transactions must be run in such a way that no two transactions executing on the same local database run concurrently.
Reference: [DEK91] <author> Weimin Du, Ahmed K. Elmagarmid, and Won Kim. </author> <title> Maintaining quasi serilaizability in mul-tidatabase systems. </title> <booktitle> In Proceedings of the 7th International Conference on Data Engineering, </booktitle> <pages> pages 360-367, </pages> <year> 1991. </year>
Reference-contexts: Both models assume that the local database executions are serializable. Quasi-serializability <ref> [DE89, DEK91] </ref>, also called multidatabase serializability [Bar90], states that the global transactions must be run in such a way that no two transactions executing on the same local database run concurrently.
Reference: [DHL90] <author> Umeshwar Dayal, Meichun Hsu, and Rivka Ladin. </author> <title> Organizing long-running activities with triggers and transactions. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <year> 1990. </year>
Reference-contexts: If some constraint is violated, then the database itself initiates some action to rectify the information in the database so that the constraint once again holds. Examples of active databases include Cactis [HK86] and HiPAC [DBC + 88]. Dayal et al. <ref> [DHL90] </ref> developed the event-condition-action (ECA) rules as a part of their active database work. ECA rules were the model we originally used when determining how to specify a weak conflict. Recently, work has also been done by Buchmann et al. [B OH + 91] on active multidatabases. <p> This situation may be seen in the example at the end of this section. Because of this, TaSL treats weak conflicts more like exceptions than like locks. It uses a structure derived from Dayal et al.'s event-condition-action (ECA) rules <ref> [DHL90] </ref> to define the exception. Since the weak conflict may be released at some point of time that is not the end of the Interaction, there must be an 38 option to specify the ending time of the weak conflict.
Reference: [DW91] <author> Thomas L. Dean and Michael P. Wellman. </author> <title> Planning and Control. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: This work examines planning in different domains such as planning the movement and actions of a robot or planning how to move different items around (such as blocks or packages). An overview of Artificial Intelligence planning work can be found in <ref> [DW91] </ref>. Much of the problem studied in this context focuses on gathering information and developing the plan based on the information that has been gathered. Thus, their system designs are as shown in Figure 2.6.
Reference: [ECB93] <author> A. K. Elmagarmid, J. Chen, and O. Bukhres. </author> <title> A survey (taxonomy and analysis) of multi-database systems. </title> <year> 1993. </year>
Reference-contexts: Currently, the system implementation is about 57,400 lines of code. It supports basic reactivity using the compensation mode only. There are very few multidatabase implementations, or even prototypes, in existence. A summary of existing multidatabase prototypes can be found in <ref> [ECB93] </ref>. 106 Chapter 8 Conclusions In this thesis, we have examined planning applications and their requirements on an underlying multi-database. We defined a planning application as one that generates tasks that are long-lived, and that needs to respond to changes in the underlying database.
Reference: [ED90] <author> Ahmed K. Elmagarmid and Weimin Du. </author> <title> A paradigm for concurrency control in heterogeneous distributed database systems. </title> <booktitle> In Proceedings of the 6th International Conference on Data Engineering, </booktitle> <pages> pages 37-46, </pages> <year> 1990. </year>
Reference-contexts: In our work, we provide a framework for understanding, classifying, and building real multidatabase systems that require global transaction atomicity. In the first section, we provide a general approach to maintaining a consistent serialization order on all local databases. This section parallels work done by Elmagarmid and Du <ref> [ED90] </ref>. In the second section we discuss atomic and semantically atomic global transaction commitment. We give a complete theory as to when and how it can be allowed. We also present two new semantically atomic commit algorithms. <p> The normal schemes defined here for enforcing consistent global serialization order in the local databases are similar to the one used by Elmagarmid and Du in <ref> [ED90] </ref>. The basic idea is to determine for each global subtransaction what its serialization point is. This is the point at which the transaction's position in the local database's serialization order is fixed by its concurrency control protocol. <p> A history is serializable if the graph is acyclic. If an edge is added that completes a cycle, the transaction is aborted. The problem with serialization graph testing is that the serialization point for a global subtransaction may occur outside of its lifetime <ref> [ED90] </ref>. This is because arcs can be added from the node representing a transaction in the SG even after the transaction commits. <p> This work parallels work done by Elmagarmid and Du <ref> [ED90] </ref>. With respect to atomic and semantically atomic commitment we introduced a theory for understanding whether (and how) any global transaction can commit atomically. We took a graph-theoretic approach to characterizing global transactions based on the information passed between its subtransactions.
Reference: [EH88] <author> A. Elmagarmid and A. Helal. </author> <title> Supporting updates in heterogeneous distributed database systems. </title> <booktitle> In Proceedings of the 4th Int'l Conference on Data Engineering, </booktitle> <year> 1988. </year>
Reference-contexts: In [BS88], Breitbart and Silberschatz examined issues in allowing multidatabase updates. They proposed an algorithm based on site graphs that ensures that no two concurrent global transactions access more than one database in common. However, this method allows a very low degree of concurrency among the global transactions. In <ref> [EH88] </ref>, Elmagarmid and Helal restricted the global transactions so that the set of databases read from and the set of databases written to by a single global transaction had an intersection of at most one local database.
Reference: [ELLR90] <author> A. K. Elmagarmid, Y. Leu, W. Litwin, and M. Rusinkiewicz. </author> <title> A multidatabase transaction model for InterBase. </title> <booktitle> In VLDB Proceedings, </booktitle> <pages> pages 507-518, </pages> <year> 1990. </year>
Reference-contexts: While we have not attempted to use ACTA to characterize Interactions, we suspect that ACTA is not yet comprehensive enough for this characterization to succeed. For example, the dependency system defined in ACTA cannot be used to represent weak conflicts and reactivity easily. 2.3.3 Flex Transactions Flex transactions <ref> [ELLR90, Leu91, LEB92] </ref> were developed with the premise that often in advanced applications, parts of a given transaction could be accomplished in one or more functionally equivalent ways. <p> Rather, the open nested transaction needs to semantically undo the transaction back to some state that is semantically equivalent to what would have happened if the open nested transaction had not run. Open nested transaction models such as Sagas [GS87], Flex Transactions <ref> [ELLR90] </ref>, and ConTracts [WR91] use a form of recovery called compensation. This form of recovery was first defined in detail by Garcia-Molina and Salem [GS87]. In their Sagas, each transaction has a corresponding compensating transaction. <p> Thus, the car rental is tried first. However, if the car rental did not succeed, the NULL subtask succeeds automatically. In other work <ref> [GGK + 90, ELLR90] </ref>, subtasks were explicitly tagged as vital or non-vital. If a non-vital subtask could not be accomplished, it still succeeded. We instead provide an explicit NULL alternative, because the non-vital construct is ambiguous in the presence of prioritized alternatives. <p> If no compensating code blocks succeed, the default could be to allow the user to fix the problem himself. This ability we call "sloppy compensation". 5.3.2 Dealing with Flexible Transactions Flexible transaction models such as <ref> [GGK + 90, ELLR90, WR91, Nod93] </ref> allow the execution flow of an open nested transaction to depend in part on the information in the database.
Reference: [EM93] <author> Ahmed K. Elmagarmid and James G. Mullen. </author> <title> Multidatabase atomic commitment protocols: A taxonomy and unified aproach. </title> <type> Technical Report CSD-TR-93-018, </type> <institution> Purdue University Computer Sciences Department, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Some of these ideas form a basis for our work on global transaction commit in Section 5.2.4. Finally, a general taxonomy and unified approach to atomic commit done by Elmagarmid and Mullen is found in <ref> [EM93] </ref>. This work has some similarity to our work on atomic and semantically atomic global transaction commits. It draws similar conclusions. However, this work uses a different method for classifying the different subtransactions in a global transaction, based on the subtransaction's semantics.
Reference: [Fir89] <author> R. James Firby. </author> <title> Adaptive Execution in Complex Dynamic Worlds. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <year> 1989. </year> <note> (Also Technical Report YALEU/CSD/RR 672). </note>
Reference-contexts: In this section, we discuss some of the planning work that most closely relates to our work. This includes work on reactivity in robots and other planning agents in the Procedural Reasoning System (PRS) by Georgeff et. al. [Geo87] and Reactive Action Packages (RAPs) by Firby <ref> [Fir89] </ref>. It also includes replanning and plan reuse research in the PRIAR system of Kambhampati [Kai90]. <p> Thus, planning, replanning, and plan execution are deliberately interleaved. While Interactions can interleave replanning with execution, this interleaving is not deliberate. 2.6.2 Reactive Action Packages (RAPs) In his thesis <ref> [Fir89] </ref>, Firby considers adaptivity and reactivity in robots. Adaptivity concerns moving the robot around obstacles as it executes its plan. Reactivity is the ability for the robot to change what it is doing based on unexpected situations in the robot's environment.
Reference: [Fis83] <author> Michael J. Fischer. </author> <title> The consensus problem in unreliable distributed systems (a brief survey). </title> <type> Technical Report 273, </type> <institution> Yale University Computer Science Department, </institution> <month> June </month> <year> 1983. </year>
Reference-contexts: Just one "abort" vote from a global subtransaction implies that the whole global transaction aborts. The central coordinator makes the final decision and passes the result back to the local databases, who enforce the decision. A second example of agreement protocols is Byzantine agreement <ref> [PSL80, Fis83] </ref>. Byzantine agreement protocols are less biased, in that "abort" votes must be received from some fractional subset of the global transactions before a global "abort" decision is made. They are meant specifically to work in failure-prone environments.
Reference: [Geo87] <author> Michael P. Georgeff. Plannning. </author> <note> Technical Note 418, SRI International, </note> <month> March </month> <year> 1987. </year>
Reference-contexts: In this section, we discuss some of the planning work that most closely relates to our work. This includes work on reactivity in robots and other planning agents in the Procedural Reasoning System (PRS) by Georgeff et. al. <ref> [Geo87] </ref> and Reactive Action Packages (RAPs) by Firby [Fir89]. It also includes replanning and plan reuse research in the PRIAR system of Kambhampati [Kai90]. <p> to Interactions in that the problem of how an Interaction should react to a weak conflict violation is very similar to how Kambhampati formulates the problem of conservative plan reuse. 2.6.1 Procedural Reasoning System (PRS) The Procedural Reasoning System is a flexible general-purpose planning system developed by Georgeff et al. <ref> [Geo87] </ref>. PRS considers both the making of a plan and the execution of the plan in the same system. PRS is designed to be a reactive planning system in the same sense that Interactions are reactive.
Reference: [GGK + 90] <author> Hector Garcia-Molina, Dieter Gawlick, Johannes Klein, Karl Kleissner, and Kenneth Salem. </author> <title> Coordinating multi-transaction activities. </title> <type> Technical Report CS-TR-247-90, </type> <institution> Princeton University Department of Computer Science, </institution> <month> February </month> <year> 1990. </year>
Reference-contexts: The lower (transaction) level defines atomicity as the correctness criterion for transactions. The conflict relationship enforced there is serializability. At the upper (Saga) level the conflict relation is empty, meaning that concurrent Sagas can interleave their transactions arbitrarily. Nested Sagas are defined as well, <ref> [GGK + 90, GGK + 91] </ref> but since multidatabases are inherently two-level, this work does not necessarily apply to Interactions. Nested sagas also extend the transaction model to provide for more flexible transaction definitions, including adding provisions for alternative ways of accomplishing some operations, and allowing non-vital operations. <p> Nested Sagas <ref> [GGK + 90] </ref> require that the compensating Sagas be invoked recursively. The ConTracts paper [WR91] makes some additional observations concerning compensation. Compensating transactions do not need to run in the inverse order of their corresponding transactions: In fact, compensating transactions are often completely independent and can run concurrently. <p> Thus, the car rental is tried first. However, if the car rental did not succeed, the NULL subtask succeeds automatically. In other work <ref> [GGK + 90, ELLR90] </ref>, subtasks were explicitly tagged as vital or non-vital. If a non-vital subtask could not be accomplished, it still succeeded. We instead provide an explicit NULL alternative, because the non-vital construct is ambiguous in the presence of prioritized alternatives. <p> If no compensating code blocks succeed, the default could be to allow the user to fix the problem himself. This ability we call "sloppy compensation". 5.3.2 Dealing with Flexible Transactions Flexible transaction models such as <ref> [GGK + 90, ELLR90, WR91, Nod93] </ref> allow the execution flow of an open nested transaction to depend in part on the information in the database.
Reference: [GGK + 91] <author> Hector Garcia-Molina, Dieter Gawlick, Johannes Klein, Karl Kleissner, and Kenneth Salem. </author> <title> Modeling long-running activities as nested sagas. </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 14(1) </volume> <pages> 14-18, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: The lower (transaction) level defines atomicity as the correctness criterion for transactions. The conflict relationship enforced there is serializability. At the upper (Saga) level the conflict relation is empty, meaning that concurrent Sagas can interleave their transactions arbitrarily. Nested Sagas are defined as well, <ref> [GGK + 90, GGK + 91] </ref> but since multidatabases are inherently two-level, this work does not necessarily apply to Interactions. Nested sagas also extend the transaction model to provide for more flexible transaction definitions, including adding provisions for alternative ways of accomplishing some operations, and allowing non-vital operations.
Reference: [GP86] <author> Virgil Gligor and Radu Popescu-Zeletin. </author> <title> Transaction management in heterogeneous database management systems. </title> <journal> Information Systems, </journal> <volume> 11(4) </volume> <pages> 287-297, </pages> <year> 1986. </year>
Reference-contexts: In Chapter 5 we discuss new techniques for enforcing global transaction atomicity, which is a prerequisite for correct Interaction synchronization. In Chapter 7, we describe the basic design of the system that we built to manage Interactions. 11 Chapter 2 Related Research In 1986, Gligor and Popescu-Zeletin <ref> [GP86] </ref> wrote a paper on concurrency control issues in multidatabase systems. They outlined a set of requirements on local databases in a multidatabase so that atomic transactions on the multidatabase could be supported. Since then, many interesting developments have occurred in the area of transaction models for multidatabases. <p> A merged history is defined to be correct provided that it is serializable and consistent with the Interaction History. Basically, this means that the different local databases need to serialize the global subtransactions in an order consistent with the global serialization order. This requirement has been recognized for years <ref> [GP86] </ref>. However, this is the most comprehensive formal treatment of correctness that we have seen. In this chapter we gave algorithms for scheduling and executing Interactions given their flexible definitions. <p> Levy's work gives two other protocols for stratification that are more complex, but allow for greater concurrency. 6.2.2.4 Serialization Protocols It is well-known that one requirement for global transaction consistency in a multidatabase is that the different global subtransactions serialize consistently with the serialization order of the global transactions <ref> [GP86] </ref>. There are many techniques proposed to enforce this consistency during global transaction execution. One problem with commitment of multidatabase transactions is that some commitment schemes allow a global commit decision to be made before local commitment of a global subtransaction is certain.
Reference: [Gra81] <author> Jim Gray. </author> <title> The transaction concept: Virtues and limitations. </title> <booktitle> In VLDB Proceedings, </booktitle> <pages> pages 144-154, </pages> <year> 1981. </year>
Reference-contexts: Basically, this means that any concurrency among transactions does not cause any undesirable side effects. Unfortunately, long-lived tasks such as planning tasks should not be represented to the database as atomic transactions <ref> [Gra81] </ref>. This is because atomicity requirements mean that concurrent transactions interfere with each other (e.g., by deadlocking). The longer the transactions tend to run, the worse that interference becomes.
Reference: [GRS91] <author> Dimitrios Georgakopoulos, Marek Rusinkiewicz, and Amit Sheth. </author> <title> On serializability of multi-database transactions through forced local conflicts. </title> <booktitle> In 1991 Data Engineering Proceedings, </booktitle> <pages> pages 314-323, </pages> <year> 1991. </year> <month> 111 </month>
Reference-contexts: If the local databases do their job, the global serialization order is maintained. The simplest conflict-based scheme is forced local conflict <ref> [GRS91] </ref>. With forced local conflict, each local database maintains a separate data item, called the "ticket", for use by the multidatabase. The multidatabase ensures that the tickets in the local database for the different global transactions all be written in the global 14 serialization order. <p> This helps ensure that the 16 Concurrency Control Serialization Corresponding Restric--Mechanism Point Multidatabase Mechanism tions Serialization Graph Data Conflict Site Graph Testing [BS88] Testing Two-Phase Lock Last Lock Forced Local Conflict <ref> [GRS91] </ref> I to Commit (Get ticket after last lock.) Timestamp Order Begin Forced Local Conflict [GRS91] I (Get ticket with transaction begin.) Rigorous 2PL Commit Strict 2PL/2PC Schemes [SKS91b] R (Rigorous 2PL local databases only) Rigorous multidatabases [BGRS91] R Commitment Order Commit Multiple Resource CO [Raz92b] R (CO local databases only) <p> This helps ensure that the 16 Concurrency Control Serialization Corresponding Restric--Mechanism Point Multidatabase Mechanism tions Serialization Graph Data Conflict Site Graph Testing [BS88] Testing Two-Phase Lock Last Lock Forced Local Conflict <ref> [GRS91] </ref> I to Commit (Get ticket after last lock.) Timestamp Order Begin Forced Local Conflict [GRS91] I (Get ticket with transaction begin.) Rigorous 2PL Commit Strict 2PL/2PC Schemes [SKS91b] R (Rigorous 2PL local databases only) Rigorous multidatabases [BGRS91] R Commitment Order Commit Multiple Resource CO [Raz92b] R (CO local databases only) Conservative SGT Data Conflict Request-Order Linked List [PRR91] C O-schemes [MRB + 92b] C Conservative <p> A discussion of the different serialization points for different local concurrency control schemes is discussed in Section 5.1.3. In the remainder of this section, we examine our generic approach that works with local databases that use all types of concurrency control. Unlike forced local conflict <ref> [GRS91] </ref>, this approach is less intrusive but very inefficient. We observe that the global serialization order can be enforced by not allowing any subsequent global subtransaction to begin until after the current one has reached its serialization point. <p> Most local databases have concurrency control schemes that determine their serialization order is determined at the latest at commit time. However, in the cases where this is not necessarily true, forced local conflicts <ref> [GRS91] </ref> can be used to constrain the serialization order of the global transactions before the global transaction commit is processed. How inconsistencies in the different local serialization orders are dealt with depends on the global serialization order that is being enforced. <p> This can be done using any one of the known algorithms (e.g. <ref> [PRR91, GRS91, MRB + 92b] </ref>). Each global subtransaction that is executing on a local database on behalf of some global transaction has a Global Subtransaction process.
Reference: [GRS93] <author> Dimitrios Georgakopoulos, Marek Rusinkiewicz, and Amit Sheth. </author> <title> Using tickets to enforce the serializability of multidatabase transactions. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> August </month> <year> 1993. </year> <note> (to appear). </note>
Reference-contexts: For example, if the local database uses two-phase locking, either the taking of the ticket or the execution of the conflicting write operation results in a deadlock, which can be detected locally by the local deadlock detection scheme. <ref> [GRS93] </ref> describes various schemes for using forced local conflict. One is based on an optimistic approach of taking tickets when needed and validating at global transaction commit time. <p> An alternative in this case would be to use forced local conflicts in this type of local database, and make the O-vector be ordered in the order the conflicting operations are issued. In <ref> [GRS93] </ref>, Georgakopoulos et al. provide a scheme that does not deduce the serialization order at the local database, but rather forces conflicts and reports the serialization order as the order of the forced conflict. This they call the Optimistic Ticket Method. <p> databases only) Rigorous multidatabases [BGRS91] R Commitment Order Commit Multiple Resource CO [Raz92b] R (CO local databases only) Conservative SGT Data Conflict Request-Order Linked List [PRR91] C O-schemes [MRB + 92b] C Conservative 2PL Commit Conservative TO Begin BT-schemes [MRB + 92b] C SGT Certifier Data Conflict Optimistic Ticket Method <ref> [GRS93] </ref> I 2PL Certifier Commit TO Certifier Begin Superdatabases [Pu88] A (Committed GT follows older GTs.) Table 2.1: Comparison of single database concurrency control schemes to multidatabase concurrency control schemes. In the restrictions, I means the scheme requires additional information in the local databases. <p> This method assumes that local transactions do not update objects read or written by global subtransactions (they call this restriction DLU for "Denied Local Updates"). They also assume the local databases use strict 2PL, so their scheduler produces strict global schedules. <ref> [GRS93] </ref> gives a counterexample to show that local strictness may not be sufficient to ensure global serializability, and that the local databases in fact must produce rigorous schedules. This counterexample is based on the fact that strictness allows read-locks to be released early.
Reference: [GS87] <author> Hector Garcia-Molina and Kenneth Salem. Sagas. </author> <booktitle> In ACM SIGMOD Proceedings, </booktitle> <pages> pages 249-259. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: In this thesis, we assume that planning tasks are executed in a multidatabase using a two-level open nested transaction model (e.g., Sagas <ref> [GS87] </ref>). That is, a task executes a related set of atomic transactions, and commits when the plan has executed to completion. <p> In this sense, Interactions are like Sagas <ref> [GS87] </ref>, in that this commitment makes the effects of the global transaction on the database visible, to other global transactions and Interactions as well as to independent transactions on the local databases. <p> Once the planned activities are complete, the planning task and its associated conflicts can go away. 1.5.4 Recovery and Replanning Most of the work on open nested transactions and recovery deals with recovery due to process, communication, or storage failure (failure recovery). There is work on Sagas <ref> [GS87] </ref> that applies to Interaction abort. All those methods apply directly to Interactions. However, we expect Interactions to be reactive. <p> Usually this relaxation is coupled with other techniques that allow transactions to maintain some relaxed notion of correctness. This section describes some different advanced transaction models that relate to the work presented in this thesis. 2.3.1 Sagas Garcia-Molina et al. propose Sagas <ref> [GS87] </ref> as a long-lived transaction model. Sagas are long (non-atomic) transactions that are broken up into a sequence of shorter, atomic transactions. Sagas are basically a two-level restriction of multilevel transactions (see section 2.3.5). The lower (transaction) level defines atomicity as the correctness criterion for transactions. <p> Rather, the open nested transaction needs to semantically undo the transaction back to some state that is semantically equivalent to what would have happened if the open nested transaction had not run. Open nested transaction models such as Sagas <ref> [GS87] </ref>, Flex Transactions [ELLR90], and ConTracts [WR91] use a form of recovery called compensation. This form of recovery was first defined in detail by Garcia-Molina and Salem [GS87]. In their Sagas, each transaction has a corresponding compensating transaction. <p> Open nested transaction models such as Sagas <ref> [GS87] </ref>, Flex Transactions [ELLR90], and ConTracts [WR91] use a form of recovery called compensation. This form of recovery was first defined in detail by Garcia-Molina and Salem [GS87]. In their Sagas, each transaction has a corresponding compensating transaction. <p> Garcia-Molina and Salem <ref> [GS87] </ref> argue that in these situations, the only way to back out the committed changes is to ensure that some compensation procedure runs to completion. For each transaction, a compensating transaction is designed to reverse its effects. <p> A global transaction may specify steps on more than one local database. We assume the architecture described in Section 1.6, which is similar to the one proposed for Sagas <ref> [GS87] </ref>. The entire Interaction specification is saved in a layer between the application itself and the multidatabase. Thus, it is available during the Interaction execution and recovery, when different alternatives may need to be tried. <p> Thus, each of these global transactions must be considered during the reactivity process. One obvious approach to implementing reactivity is using compensation. Compensation was first defined explicitly in the context of Sagas <ref> [GS87] </ref>. <p> Then in the next sections we outline the replacement scheme, which avoids some of these pitfalls. 5.3.1 Non-Persistence of Compensation Persistence of compensation states that all (compensating) subtransactions in an open nested transaction must succeed if retried enough times. This requirement was first identified for Sagas <ref> [GS87] </ref>. While persistence of compensation may hold true in restricted situations, it does not hold true in a general open nested transaction environment. Open nested transactions periodically release the resources they hold, allowing other database transactions to interleave with their own operation. <p> The customer may no longer be able to go on the trip, but fully canceling the Pan Am flight and getting a refund is impossible. The customer has relinquished control over his money. 1 In the early work on Sagas <ref> [GS87] </ref>, a concept called recovery blocks was proposed. A recovery block provides an alternate method of compensating a particular action, under the assumption that if a particular method fails it is because its definition was faulty. <p> Both also operate by (possibly semantically) undoing and redoing work. Semantic recovery of open nested transactions in the case of failure has been defined in several contexts, e.g. <ref> [GS87] </ref>. However, using recovery techniques to evolve an Interaction from an inconsistent state to a consistent state after a weak conflict violation presents a different type of problem.
Reference: [GSW87] <author> Irene Greif, Robert Seliger, and William Weihl. </author> <title> A case study of CES: A distributed collaborative editing system implemented in Argus, </title> <year> 1987. </year>
Reference-contexts: An abort statement has the form abort (&lt;label&gt;) where label is the label of the statement that should be aborted. While we limit the handler in an event to be just an abort statement, more flexibility may be needed in the long term. <ref> [GSW87] </ref> claims that, in the implementation of the collaborative editor CES, it would have been useful for the user to have some explicit way of specifying user-oriented recovery actions.
Reference: [HK86] <author> Scott E. Hudson and Roger King. Cactis: </author> <title> A database system for specifying functionally-defined data. </title> <booktitle> In IEEE OODBS Workshop, </booktitle> <year> 1986. </year>
Reference-contexts: If some constraint is violated, then the database itself initiates some action to rectify the information in the database so that the constraint once again holds. Examples of active databases include Cactis <ref> [HK86] </ref> and HiPAC [DBC + 88]. Dayal et al. [DHL90] developed the event-condition-action (ECA) rules as a part of their active database work. ECA rules were the model we originally used when determining how to specify a weak conflict.
Reference: [Kai90] <author> Gail E. Kaiser. </author> <title> A flexible transaction model for software engineering. </title> <booktitle> In Proceedings of the 6th International Conference on Data Engineering, </booktitle> <pages> pages 560-567, </pages> <year> 1990. </year>
Reference-contexts: This includes work on reactivity in robots and other planning agents in the Procedural Reasoning System (PRS) by Georgeff et. al. [Geo87] and Reactive Action Packages (RAPs) by Firby [Fir89]. It also includes replanning and plan reuse research in the PRIAR system of Kambhampati <ref> [Kai90] </ref>. <p> We need to think about this problem in our own context. Firby also considers merging plans, which may or may not be useful in our multidatabase planning applications. 2.6.3 The PRIAR System In his PRIAR system, Kambhampati <ref> [Kai90] </ref> examines issues of plan reuse and modification. Plan modification is very related to the Interaction's recovery work in that, when a plan becomes invalid we attempt to modify the old plan into a new one, making as few changes to the original plan as possible.
Reference: [Kam90] <author> Subbarao Kambhampati. </author> <title> A theory of plan modification. </title> <booktitle> In Proceedings of the 8th National Conference on Artificial Intelligence, </booktitle> <volume> volume 1, </volume> <pages> pages 176-182, </pages> <year> 1990. </year>
Reference-contexts: Replacement can be done using compensation, and by redoing (using a different alternative where necessary). This same type of problem is encountered in the Artificial Intelligence planning community, where replanning algorithms are designed to impact the original plan as little as possible <ref> [Kam90] </ref>. 3.1.5 Flexible One of the goals for a planning task is not only to find a workable plan, but also to find the best workable plan. Thus, different ways of achieving the plan (or parts of it) are specified as alternatives. These alternatives are prioritized where needed.
Reference: [KLS90] <author> Henry F. Korth, Eliezer Levy, and Abraham Silberschatz. </author> <title> A formal approach to recovery by compensating transactions. </title> <booktitle> In VLDB Proceedings, </booktitle> <pages> pages 95-106, </pages> <year> 1990. </year>
Reference-contexts: Other Interactions or independent transactions may read and/or modify the affected information, thus their execution depends on the execution of the invalid global transaction. This problem is described in detail in <ref> [KLS90] </ref>. During replanning it is important to detect these dependencies, as the invalidation may or may not need to cascade to the dependent transactions. With Interactions, this cascading occurs via the weak conflicts. <p> This protocol enforces a weaker notion of atomicity, semantic atomicity, where a transaction may see the effects of an aborted global transaction before it is undone. It also assumes persistence of compensation <ref> [KLS90] </ref>, which states that a compensating transaction is never allowed to abort. Optimistic two-phase commit allows global subtransactions to release their locks (i.e., commit) once they have received the "prepare" message and decided to reply with a "yes". <p> Because open nested transactions make partial results visible early, recovery of one open nested transaction can cascade to others. ConTracts address this problem by explicitly maintaining all dependencies. This, however, is not feasible in a multidatabase environment. Korth et al. <ref> [KLS90] </ref> did a study on compensation with respect to their entitywise 2PL correctness specification for transaction execution. They examine the effects of intervening conflicting transactions on the success of compensating transactions, and give some ideas on how to constrain executions so the resulting history is approximately sound. <p> During this time, other transactions may read the effects of the original transaction and use that information in their own execution. These transactions then are ultimately dependent on the effects of some transaction that, in some sense, didn't run <ref> [KLS90] </ref>. While these dependencies may be difficult to compute directly, it may be important to be able to determine their existence for compensation to execute correctly.
Reference: [KRST92] <author> Piotr Karychniak, Marek Rusinkiewicz, Amit Sheth, and Gomer Thomas. </author> <title> Bounding the effects of compensation under relaxed multi-level serializability. </title> <institution> TM-TSV-021509/1, Bellcore, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: While they support semantic atomicity (as in Sagas), Levy et al. also observe that the compensating transactions do not need to be coordinated as strongly because they are largely independent. Karychniak et al. <ref> [KRST92] </ref> deal with issues of compensation in multidatabases that support assignment/deassignment transactions.
Reference: [LEB92] <author> Yungho Leu, Ahmed K. Elmagarmid, and Noureddine Boudriga. </author> <title> Specification and execution of transactions for advanced database applications. </title> <journal> Informaton Systems, </journal> <volume> 17(2), </volume> <year> 1992. </year>
Reference-contexts: While we have not attempted to use ACTA to characterize Interactions, we suspect that ACTA is not yet comprehensive enough for this characterization to succeed. For example, the dependency system defined in ACTA cannot be used to represent weak conflicts and reactivity easily. 2.3.3 Flex Transactions Flex transactions <ref> [ELLR90, Leu91, LEB92] </ref> were developed with the premise that often in advanced applications, parts of a given transaction could be accomplished in one or more functionally equivalent ways.
Reference: [Leu91] <author> Y. Leu. </author> <title> Flexible Transaction Management in the InterBase Project. </title> <type> PhD thesis, </type> <institution> Purdue University, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: While we have not attempted to use ACTA to characterize Interactions, we suspect that ACTA is not yet comprehensive enough for this characterization to succeed. For example, the dependency system defined in ACTA cannot be used to represent weak conflicts and reactivity easily. 2.3.3 Flex Transactions Flex transactions <ref> [ELLR90, Leu91, LEB92] </ref> were developed with the premise that often in advanced applications, parts of a given transaction could be accomplished in one or more functionally equivalent ways.
Reference: [LKS91a] <author> Eliezer Levy, Henry F. Korth, and Abraham Silberschatz. </author> <title> An optimistic commit protocol for distributed transaction management. </title> <booktitle> In 1991 ACM SIGMOD Proceedings, </booktitle> <pages> pages 88-97, </pages> <year> 1991. </year>
Reference-contexts: supporting atomic commitment in multidatabases is done by providing a simulated 17 Scheme Local Commit Global Decision Paradigm Before Before Global Decision Local Commit (Requires Undo) (Requires Redo) 2PC Agent [WV90] p LDB blocking rigorous LDBs full atomicity Hydro [PRR91] p LDB Blocking full atomicity Optimistic Commit p stratification Protocol <ref> [LKS91a] </ref> semantic atomicity Mehrotra et al. read-only update data partitioning [MRB + 92a] subtransactions subtransactions rigorous MDB full atomicity Non-blocking compensatable retriable allows a pivot commit [MRKS92] subtransactions subtransactions semantic atomicity Table 2.2: Summary of multidatabase global commit strategies. prepared state for a two-phase commit. <p> Several different commit strategies for global transactions have been proposed. They are summarized in Table 2.2. Systems which use the global decision before local commit strategy include the 2PC Agent method [WV90], Hydro [PRR91], and the optimistic commit protocol <ref> [LKS91a] </ref>. In the 2PC Agent Method [WV90] of Wolski and Viejalainen, a 2PC Agent associated with each local database acts for the local database as a participant in the two-phase commit protocol. <p> However, it does this by aborting local transactions rather than denying their updates. In other words, this scheme violates control autonomy rather than execution autonomy. Levy et al. <ref> [LKS91a] </ref> also use a local commit before global decision strategy in their optimistic commit protocol. This protocol enforces a weaker notion of atomicity, semantic atomicity, where a transaction may see the effects of an aborted global transaction before it is undone. <p> This paper provides a good characterization of some of the stickier problems that you can encounter when trying to implement any scheme that uses compensation. Related to this work is the compensation strategy that is embedded in the Optimistic Commit Protocol <ref> [LKS91a] </ref>. While they support semantic atomicity (as in Sagas), Levy et al. also observe that the compensating transactions do not need to be coordinated as strongly because they are largely independent. Karychniak et al. [KRST92] deal with issues of compensation in multidatabases that support assignment/deassignment transactions. <p> It should never read from both the committed global transaction on one local database, and the undone transaction on a different local database. We call protocols that ensure this type of semantic atomicity during compensation "stratification protocols" after the Optimistic Control Protocol work by Levy et al. <ref> [LKS91a] </ref>. Stratification basically means that, where compensation is used to back out of a global transaction in a multidatabase, semantic atomicity is maintained. Most multidatabase commit protocols that use compensation ensure stratification by making the compensating global transactions atomic.
Reference: [LKS91b] <author> Eliezer Levy, Henry F. Korth, and Abraham Silberschatz. </author> <title> A theory of relaxed atomicity. </title> <booktitle> In Proceedings of the ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 95-109, </pages> <year> 1991. </year> <note> (Extended Abstract). </note>
Reference-contexts: Optimistic two-phase commit was a restriction based on a generalized theory of atomic commitment defined in <ref> [LKS91b] </ref>. Mehrotra et al. [MRB + 92a] propose an interesting variant on the above global decision before/after local commit protocols. They observe that the local commit point can vary with respect to the global commit point even within a single invocation of a global transaction commit.
Reference: [Lom92] <author> David B. Lomet. MLR: </author> <title> A recovery method for multi-level systems. </title> <booktitle> In Proceedings of the 1992 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 185-194, </pages> <year> 1992. </year>
Reference-contexts: The inverse log pass generates compensating level (i-1) steps for each level i transaction that has not terminated. This recovery strategy has been implemented in the DASDBS project. A similarly structured technique is proposed for nested and multilevel transactions in <ref> [Lom92] </ref>. [Wei91] notes several other approaches, with different strategies for maintaining (semantic) undo and redo information at the various levels. The checkpoint strategies take periodic checkpoints.
Reference: [MJS] <author> James G. Mullen, Jin Jing, and Jamshid Sharif-Askary. </author> <title> Reservation commitment and its use in multidatabase systems. </title> <note> (submitted to DEXA 1993). </note>
Reference-contexts: This type of blocking protocol requires that the multidatabase can intercept the local transactions, at least to the point where they can be delayed. Mullenet al. <ref> [MJS] </ref> propose a reservation protocol where the global transactions use additional data in the database to reserve the resources they need. Mullen's protocol requires all transactions, including local ones, be modified to test the reservation information.
Reference: [MKS92] <author> James G. Mullen, Won Kim, and Jamshid Sharif-Askary. </author> <title> On the impossibility of atomic commitment in multidatabase systems. </title> <booktitle> In Proceedings of the Second International Conference on Systems Integration, </booktitle> <pages> pages 625-634, </pages> <year> 1992. </year>
Reference-contexts: In the general case, this means that atomic commitment of certain types of global transactions is not possible <ref> [MKS92] </ref>. In the global transaction commit work in this thesis, we give a simple characterization of when global transactions can and cannot atomically commit. We also give a general framework for atomic and semantically atomic commitment. All of the algorithms described in this section fit into our general commit framework.
Reference: [Mos85] <author> J. Eliot B. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1985. </year>
Reference-contexts: That is, a task executes a related set of atomic transactions, and commits when the plan has executed to completion. An open nested transaction differs from a traditional (closed) nested transaction (see <ref> [Mos85] </ref>) in that when a child transaction commits it releases its resources rather than passing them on to the parent transaction. Thus, the parent transaction is not atomic. In classic transaction processing theory, transactions are kept isolated so that dependencies cannot form.
Reference: [MR91] <author> Peter Muth and Thomas G. Rakow. </author> <title> Atomic commitment for integrated database systems. </title> <booktitle> In 1991 Data Engineering Proceedings, </booktitle> <pages> pages 296-304, </pages> <year> 1991. </year>
Reference-contexts: Muth and Rakow <ref> [MR91] </ref> analyzed in detail the requirements for providing a simulated prepared state. They divided up the schemes for doing this into two categories: (1) local commitment after global decision and (2) local commitment before global decision. <p> If some subtransaction aborts and has to be re-executed, any subtransaction following it in the information flow order must also be aborted and re-executed (because it depends on incorrect results). It is a "local commit before global decision" scheme in <ref> [MR91] </ref>, with the voting phase proceeding in an order defined by the subtransaction information flow. The detailed algorithm follows: Algorithm 6.2.1 (Best Effort Commit) 1. Start running the blocking protocol on each local database that executed some subtransaction of the global transaction. 2. Make a global commit decision. 84 3.
Reference: [MRB + 92a] <author> Sharad Mehrotra, Rajeev Rastogi, Yuri Breitbart, Henry F. Korth, and Avi Silberschatz. </author> <title> Ensuring transaction atomicity in multidatabase systems. </title> <booktitle> In PODS 1992 Proceedings, </booktitle> <pages> pages 164-175, </pages> <year> 1992. </year>
Reference-contexts: Later schemes [BST90] partitioned the information into locally- and globally-updateable information, and restricted access accordingly. This idea also plays a part in [MRKS91] and <ref> [MRB + 92a] </ref>. More recent approaches rely on two protocols; one to ensure that the global transactions' subtransactions serialize consistently on the local databases, and the other to simulate a two-phase commit. This approach is also the one we take. <p> simulated 17 Scheme Local Commit Global Decision Paradigm Before Before Global Decision Local Commit (Requires Undo) (Requires Redo) 2PC Agent [WV90] p LDB blocking rigorous LDBs full atomicity Hydro [PRR91] p LDB Blocking full atomicity Optimistic Commit p stratification Protocol [LKS91a] semantic atomicity Mehrotra et al. read-only update data partitioning <ref> [MRB + 92a] </ref> subtransactions subtransactions rigorous MDB full atomicity Non-blocking compensatable retriable allows a pivot commit [MRKS92] subtransactions subtransactions semantic atomicity Table 2.2: Summary of multidatabase global commit strategies. prepared state for a two-phase commit. Muth and Rakow [MR91] analyzed in detail the requirements for providing a simulated prepared state. <p> Optimistic two-phase commit was a restriction based on a generalized theory of atomic commitment defined in [LKS91b]. Mehrotra et al. <ref> [MRB + 92a] </ref> propose an interesting variant on the above global decision before/after local commit protocols. They observe that the local commit point can vary with respect to the global commit point even within a single invocation of a global transaction commit. <p> A passive blocking protocol implements a low-level filtering at all times. The most widely-proposed examples of a passive blocking protocol partition the multidatabase according to what can be accessed in what ways by the global and local transactions <ref> [BST90, MRKS91, MRB + 92a] </ref>. Basically, the partitioning allows the global multidatabase transactions to proceed without unwanted interference from the local transactions. Several examples of active blocking protocols have been proposed.
Reference: [MRB + 92b] <author> Sharad Mehrotra, Rajeev Rastogi, Yuri Breitbart, Henry F. Korth, and Avi Silberschatz. </author> <title> The concurrency control problem in multidatabases: Characteristics and solutions. </title> <booktitle> In SIGMOD 1992 Proceedings, </booktitle> <pages> pages 288-297, </pages> <year> 1992. </year>
Reference-contexts: Using this information, both the ROLL scheme used in Hydro [PRR91] and Mehrotra et al.'s O-schemes <ref> [MRB + 92b] </ref> generate a global serialization order that allows for maximal concurrency in the multidatabase, i.e. one that accepts all serializable multidatabase histories. Hydro [PRR91] uses request-ordered linked lists (ROLLs) to determine when a global transaction can execute. <p> Once the transaction runs to completion, its entry can be removed from the ROLL. Mehrotra et al. <ref> [MRB + 92b] </ref> provide a framework for defining conservative global concurrency control schemes for multidatabases. In this context, they also define several different schemes that generate global serialization orders consistent with the global transaction begin order. They call these BT-schemes. <p> Forced local conflict can also be used to fill in weaknesses in some of the other schemes. For example, Mehrotra et al. <ref> [MRB + 92b] </ref> use forced local conflict in their schemes with local databases where the serialization point is not externally detectable (e.g. in local databases that use serialization graph testing as their concurrency control mechanism). <p> Begin Forced Local Conflict [GRS91] I (Get ticket with transaction begin.) Rigorous 2PL Commit Strict 2PL/2PC Schemes [SKS91b] R (Rigorous 2PL local databases only) Rigorous multidatabases [BGRS91] R Commitment Order Commit Multiple Resource CO [Raz92b] R (CO local databases only) Conservative SGT Data Conflict Request-Order Linked List [PRR91] C O-schemes <ref> [MRB + 92b] </ref> C Conservative 2PL Commit Conservative TO Begin BT-schemes [MRB + 92b] C SGT Certifier Data Conflict Optimistic Ticket Method [GRS93] I 2PL Certifier Commit TO Certifier Begin Superdatabases [Pu88] A (Committed GT follows older GTs.) Table 2.1: Comparison of single database concurrency control schemes to multidatabase concurrency control <p> Rigorous 2PL Commit Strict 2PL/2PC Schemes [SKS91b] R (Rigorous 2PL local databases only) Rigorous multidatabases [BGRS91] R Commitment Order Commit Multiple Resource CO [Raz92b] R (CO local databases only) Conservative SGT Data Conflict Request-Order Linked List [PRR91] C O-schemes <ref> [MRB + 92b] </ref> C Conservative 2PL Commit Conservative TO Begin BT-schemes [MRB + 92b] C SGT Certifier Data Conflict Optimistic Ticket Method [GRS93] I 2PL Certifier Commit TO Certifier Begin Superdatabases [Pu88] A (Committed GT follows older GTs.) Table 2.1: Comparison of single database concurrency control schemes to multidatabase concurrency control schemes. <p> This can be done using any one of the known algorithms (e.g. <ref> [PRR91, GRS91, MRB + 92b] </ref>). Each global subtransaction that is executing on a local database on behalf of some global transaction has a Global Subtransaction process.
Reference: [MRKS91] <author> Sharad Mehrotra, Rajeev Rastogi, Henry F. Korth, and Abraham Silberschatz. </author> <title> Non-serializable executions in heterogeneous distributed database systems. </title> <booktitle> In Proceedings of the First International Conference on Parallel and Distributed Information Systems, </booktitle> <year> 1991. </year>
Reference-contexts: Later schemes [BST90] partitioned the information into locally- and globally-updateable information, and restricted access accordingly. This idea also plays a part in <ref> [MRKS91] </ref> and [MRB + 92a]. More recent approaches rely on two protocols; one to ensure that the global transactions' subtransactions serialize consistently on the local databases, and the other to simulate a two-phase commit. This approach is also the one we take. <p> Quasi-serializability preserves database consistency if the executions of each global transaction on the different sites are completely independent, and if replication is the only integrity constraint allowed <ref> [MRKS91] </ref>. Two-level serializability [MRKS91] differs from quasi-serializability in that its conflict model at the global level is that two transactions conflict on specific data items. Thus, two-level serializability is more general than quasi-serializability. In a two-level serializable multidatabase, data consistency is enforced using different combinations of three paradigms: 1. <p> Quasi-serializability preserves database consistency if the executions of each global transaction on the different sites are completely independent, and if replication is the only integrity constraint allowed <ref> [MRKS91] </ref>. Two-level serializability [MRKS91] differs from quasi-serializability in that its conflict model at the global level is that two transactions conflict on specific data items. Thus, two-level serializability is more general than quasi-serializability. In a two-level serializable multidatabase, data consistency is enforced using different combinations of three paradigms: 1. <p> A passive blocking protocol implements a low-level filtering at all times. The most widely-proposed examples of a passive blocking protocol partition the multidatabase according to what can be accessed in what ways by the global and local transactions <ref> [BST90, MRKS91, MRB + 92a] </ref>. Basically, the partitioning allows the global multidatabase transactions to proceed without unwanted interference from the local transactions. Several examples of active blocking protocols have been proposed.
Reference: [MRKS92] <author> Sharad Mehrotra, Rajeev Rastogi, Henry F. Korth, and Avi Silberschatz. </author> <title> A transaction model for multidatabase systems. </title> <type> Technical Report TR-92-14, </type> <institution> University of Texas at Austin, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: (Requires Redo) 2PC Agent [WV90] p LDB blocking rigorous LDBs full atomicity Hydro [PRR91] p LDB Blocking full atomicity Optimistic Commit p stratification Protocol [LKS91a] semantic atomicity Mehrotra et al. read-only update data partitioning [MRB + 92a] subtransactions subtransactions rigorous MDB full atomicity Non-blocking compensatable retriable allows a pivot commit <ref> [MRKS92] </ref> subtransactions subtransactions semantic atomicity Table 2.2: Summary of multidatabase global commit strategies. prepared state for a two-phase commit. Muth and Rakow [MR91] analyzed in detail the requirements for providing a simulated prepared state. <p> Mehrotra et al. also propose a weaker commit protocol in <ref> [MRKS92] </ref>. This protocol guarantees only semantic atomicity. It assumes that subtransactions of a global transaction are independent. <p> One is to compensate for any committed work in a global transaction that needs to be undone. Another approach is to retry any subtransactions that did not commit in a global transaction that has already decided to commit. Following the approach in <ref> [MRKS92] </ref>, we introduce properties related to subtransactions and their ability to be compensated for or retried. Definition 6.2.1 (Compensatable) A global subtransaction is compensatable if its compensating sub-transaction will always succeed, regardless of the state of the local database. <p> Similarly, the global commit before local decision algorithms all use phases 3-4, and ignore phase 2. Semantically atomic commit algorithms all include some form of phase 1 and/or phase 5. For instance, Mehrotra et.al.'s non-blocking commit algorithm <ref> [MRKS92] </ref> uses mainly phases 1 and 5, with their pivot transaction being the only one that uses a different phase (phase 3). 82 Phase Subtransaction Types Protocols Comments 1 From Maximum T Can commit once subtransaction Compensatable Subgraph ends its execution. 2 From Max. Provisionally B Can commit concurrently. <p> Thus, some form of serialization protocol must be used when a retry fails. Note that the algorithm defined in <ref> [MRKS92] </ref> follows the structure of the algorithm defined above, but it only operates on global transactions whose pivot subgraphs contain at most one subtransaction. Also, they assume no dependencies between global subtransactions. <p> If a specific subgraph contains a cycle, no atomic commitment is possible. 3. If a specific subgraph (the pivot subgraph) contains at most one transaction, nonblocking semantically atomic commitment is possible. (see also <ref> [MRKS92] </ref>). 4. Given a committable global transaction, what is the minimal amount of blocking required? 5.
Reference: [Nod91] <author> Marian H. Nodine. </author> <title> Interactions: A non-serializable global transaction model for heterogeneous multidatabases. </title> <type> Technical Report CS-91-64, </type> <institution> Brown University Department of Computer Science, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: This paper also defines the best times to take tickets based on different concurrency control schemes, and when tickets do not need to be taken (they are implicit). Much of the work in this paper is similar to our (parallel) results on global transaction serialization points from <ref> [Nod91] </ref> described later in this thesis. Forced local conflict is really an elegant solution in and of itself to the multidatabase concurrency control problem.
Reference: [Nod93] <author> Marian H. Nodine. </author> <title> Supporting long-running tasks on an evolving multidatabase using Interactions and events. </title> <booktitle> In Proceedings of the Second International Conference on Parallel and Distributed Information Systems, </booktitle> <pages> pages 125-132, </pages> <year> 1993. </year>
Reference-contexts: If no compensating code blocks succeed, the default could be to allow the user to fix the problem himself. This ability we call "sloppy compensation". 5.3.2 Dealing with Flexible Transactions Flexible transaction models such as <ref> [GGK + 90, ELLR90, WR91, Nod93] </ref> allow the execution flow of an open nested transaction to depend in part on the information in the database.
Reference: [PRR91] <author> William Perrizo, Joseph Rajkumar, and Prabhu Ram. </author> <title> Hydro: A heterogeneous distributed database system. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 32-39, </pages> <year> 1991. </year>
Reference-contexts: Using this information, both the ROLL scheme used in Hydro <ref> [PRR91] </ref> and Mehrotra et al.'s O-schemes [MRB + 92b] generate a global serialization order that allows for maximal concurrency in the multidatabase, i.e. one that accepts all serializable multidatabase histories. Hydro [PRR91] uses request-ordered linked lists (ROLLs) to determine when a global transaction can execute. <p> Using this information, both the ROLL scheme used in Hydro <ref> [PRR91] </ref> and Mehrotra et al.'s O-schemes [MRB + 92b] generate a global serialization order that allows for maximal concurrency in the multidatabase, i.e. one that accepts all serializable multidatabase histories. Hydro [PRR91] uses request-ordered linked lists (ROLLs) to determine when a global transaction can execute. Each entry in the ROLL consists of a bit vector, with each bit representing some resource in the multidatabase. <p> lock.) Timestamp Order Begin Forced Local Conflict [GRS91] I (Get ticket with transaction begin.) Rigorous 2PL Commit Strict 2PL/2PC Schemes [SKS91b] R (Rigorous 2PL local databases only) Rigorous multidatabases [BGRS91] R Commitment Order Commit Multiple Resource CO [Raz92b] R (CO local databases only) Conservative SGT Data Conflict Request-Order Linked List <ref> [PRR91] </ref> C O-schemes [MRB + 92b] C Conservative 2PL Commit Conservative TO Begin BT-schemes [MRB + 92b] C SGT Certifier Data Conflict Optimistic Ticket Method [GRS93] I 2PL Certifier Commit TO Certifier Begin Superdatabases [Pu88] A (Committed GT follows older GTs.) Table 2.1: Comparison of single database concurrency control schemes to <p> Most of the work on supporting atomic commitment in multidatabases is done by providing a simulated 17 Scheme Local Commit Global Decision Paradigm Before Before Global Decision Local Commit (Requires Undo) (Requires Redo) 2PC Agent [WV90] p LDB blocking rigorous LDBs full atomicity Hydro <ref> [PRR91] </ref> p LDB Blocking full atomicity Optimistic Commit p stratification Protocol [LKS91a] semantic atomicity Mehrotra et al. read-only update data partitioning [MRB + 92a] subtransactions subtransactions rigorous MDB full atomicity Non-blocking compensatable retriable allows a pivot commit [MRKS92] subtransactions subtransactions semantic atomicity Table 2.2: Summary of multidatabase global commit strategies. prepared <p> Several different commit strategies for global transactions have been proposed. They are summarized in Table 2.2. Systems which use the global decision before local commit strategy include the 2PC Agent method [WV90], Hydro <ref> [PRR91] </ref>, and the optimistic commit protocol [LKS91a]. In the 2PC Agent Method [WV90] of Wolski and Viejalainen, a 2PC Agent associated with each local database acts for the local database as a participant in the two-phase commit protocol. <p> This counterexample is based on the fact that strictness allows read-locks to be released early. However, if the local databases are further restricted to be rigorous, the 2PC Agent Method is correct. Hydro <ref> [PRR91] </ref> enforces the property that the semantic undo must serialize immediately after the original transaction by preventing any transaction on the local database from committing during the time between when the global subtransaction commits and the time the decision for the global transaction is reached. <p> Thus, the next global subtransaction in the serialization order can be submitted once the shadow serialization graph in the Agent indicates that the subtransaction will be serializable. A similar approach is used with Request-Ordered Linked Lists <ref> [PRR91] </ref>. 6.2 Atomic and Semantically Atomic Commit This section describes our theory concerning atomic and semantically atomic commitment in multidatabases. Based on this theory, we also present two new semantically atomic commit algorithms. Semantic atomicity differs from normal atomicity in that it does not require a state-based undo. <p> Basically, the partitioning allows the global multidatabase transactions to proceed without unwanted interference from the local transactions. Several examples of active blocking protocols have been proposed. For example, in Hydro <ref> [PRR91] </ref>, no transactions are allowed to pass operations to the local database while a global commit decision is being made. This type of blocking protocol requires that the multidatabase can intercept the local transactions, at least to the point where they can be delayed. <p> The most common serialization protocol is that, when some subtransaction aborts, all other global subtransactions that follow it in the global serialization order and that have already reached their serialization points must also abort, e.g., Hydro <ref> [PRR91] </ref>. Note here that, in all cases, a global transaction must complete its commit before any conflicting 1 global transaction that follows it in the global serialization order initiates its commit. <p> This can be done using any one of the known algorithms (e.g. <ref> [PRR91, GRS91, MRB + 92b] </ref>). Each global subtransaction that is executing on a local database on behalf of some global transaction has a Global Subtransaction process.
Reference: [PSL80] <author> Marshall Pease, Robert Shostak, and Leslie Lamport. </author> <title> Reaching agreement in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 27(2) </volume> <pages> 228-234, </pages> <month> April </month> <year> 1980. </year>
Reference-contexts: Just one "abort" vote from a global subtransaction implies that the whole global transaction aborts. The central coordinator makes the final decision and passes the result back to the local databases, who enforce the decision. A second example of agreement protocols is Byzantine agreement <ref> [PSL80, Fis83] </ref>. Byzantine agreement protocols are less biased, in that "abort" votes must be received from some fractional subset of the global transactions before a global "abort" decision is made. They are meant specifically to work in failure-prone environments.
Reference: [Pu88] <author> Calton Pu. </author> <title> Superdatabases for composition of heterogeneous databases. </title> <booktitle> In Proceedings of the 4th International Conference on Data Engineering, </booktitle> <pages> pages 548-555, </pages> <year> 1988. </year>
Reference-contexts: The commit process checks these orders for consistency, and aborts any global transaction in which the global subtransactions were ordered inconsistently. 15 In his Superdatabases work <ref> [Pu88] </ref>, Pu takes an optimistic approach to providing serializable global transactions. He requires each local database to provide the serialization order of its transactions to the global transaction manager. <p> Multiple Resource CO [Raz92b] R (CO local databases only) Conservative SGT Data Conflict Request-Order Linked List [PRR91] C O-schemes [MRB + 92b] C Conservative 2PL Commit Conservative TO Begin BT-schemes [MRB + 92b] C SGT Certifier Data Conflict Optimistic Ticket Method [GRS93] I 2PL Certifier Commit TO Certifier Begin Superdatabases <ref> [Pu88] </ref> A (Committed GT follows older GTs.) Table 2.1: Comparison of single database concurrency control schemes to multidatabase concurrency control schemes. In the restrictions, I means the scheme requires additional information in the local databases.
Reference: [Raz92a] <author> Yoav Raz. </author> <title> The principle of commitment ordering, or guaranteeing serializability in a heterogeneous environment of multiple autonomous resource-managers. </title> <type> Technical Report DEC-TR 841, </type> <institution> Digital Equipment Corporation, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: A strongly recoverable schedule is one in which for any pair of transactions T i and T j with conflicting operations op i (x) and op j (x), the commit of T i precedes the commit of T j . In <ref> [Raz92a, Raz92b] </ref>, Raz refers to this property as commitment ordering. <p> If the global transaction commit is atomic, then the resulting multidatabase schedule will also be strongly recoverable. A commonly-used property of local databases that generates a subset of the strongly recoverable schedules is rigorousness (also called strong-strict in <ref> [Raz92a] </ref>). A rigorous execution has the property that no local data item can be read or written until the previous transaction that read or wrote that data item has committed. <p> For example, a commit dependency between two subtransactions T a and T b means that the transaction model requires T a to commit before T b . A commit dependency would occur in a Commit Ordered database <ref> [Raz92a] </ref> if T a conflicts with T b , and T a 's conflicting operation preceded that of T b . Similarly, an abort dependency between two subtransactions T c and T d means that in this transaction model, if T c aborts then T d must abort as well.
Reference: [Raz92b] <author> Yoav Raz. </author> <title> The principle of commitment ordering, or guaranteeing serializability in a heterogeneous environment of multiple autonomous resource managers. </title> <booktitle> In VLDB Proceedings, </booktitle> <pages> pages 292-312, </pages> <year> 1992. </year>
Reference-contexts: A strongly recoverable schedule is one in which for any pair of transactions T i and T j with conflicting operations op i (x) and op j (x), the commit of T i precedes the commit of T j . In <ref> [Raz92a, Raz92b] </ref>, Raz refers to this property as commitment ordering. <p> Last Lock Forced Local Conflict [GRS91] I to Commit (Get ticket after last lock.) Timestamp Order Begin Forced Local Conflict [GRS91] I (Get ticket with transaction begin.) Rigorous 2PL Commit Strict 2PL/2PC Schemes [SKS91b] R (Rigorous 2PL local databases only) Rigorous multidatabases [BGRS91] R Commitment Order Commit Multiple Resource CO <ref> [Raz92b] </ref> R (CO local databases only) Conservative SGT Data Conflict Request-Order Linked List [PRR91] C O-schemes [MRB + 92b] C Conservative 2PL Commit Conservative TO Begin BT-schemes [MRB + 92b] C SGT Certifier Data Conflict Optimistic Ticket Method [GRS93] I 2PL Certifier Commit TO Certifier Begin Superdatabases [Pu88] A (Committed GT
Reference: [SBD + 81] <author> J. M. Smith, P. A. Bernstein, U. Dayal, N. Goodman, T. Landers, K. W. T. Lin, and E. Wong. </author> <title> Multibase integrating heterogeneous destributed systems. </title> <booktitle> In Proceedings of the National Computer Conference, </booktitle> <pages> pages 487-499, </pages> <year> 1981. </year>
Reference-contexts: The second is that an atomic commit protocol such as a two-phase commit is used when committing each global transaction. Early efforts to provide a global transaction model for multidatabases generally limited the global (and possibly local) transactions' access to the information in the database. For instance, Multibase <ref> [SBD + 81] </ref> only allowed the global transactions read access to the information in the multidatabase. In [BS88], Breitbart and Silberschatz examined issues in allowing multidatabase updates. They proposed an algorithm based on site graphs that ensures that no two concurrent global transactions access more than one database in common.
Reference: [SKS91a] <author> Nandit Soparkar, Henry F. Korth, and Abraham Silberschatz. </author> <title> Failure-resistent transaction management in multidatabases. </title> <journal> IEEE Computer, </journal> <volume> 24(12) </volume> <pages> 28-36, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Control autonomy refers to the amount that the multidatabase needs to control the order and timing of the messages on the input stream to the local databases. Violating control autonomy does not require modification of the local databases themselves, but rather requires controlling the input to the local database. <ref> [SKS91a] </ref> notes that it is impossible to make certain guarantees about the atomicity of global transactions on a multidatabase without violating either control autonomy or execution autonomy. <p> The global serialization order is then the global transaction commit order. The atomicity of the commit process ensures that the order is consistent across the different local databases. This observation was also made by Soparkar et al. <ref> [SKS91a] </ref>. However, if we relax the requirement on the local databases to strictness (which allows read locks to be released before transaction commit), then they no longer have analogous execution and serialization order. An example non-serializable multidatabase history where the local histories are strict is given in [BGRS91]. <p> Schemes for global transaction commitment that do not require the existence of a commit blocker for the independent transactions would be preferred for the sake of local database autonomy. However, it has been shown in <ref> [SKS91a] </ref> that such schemes cannot exist. 7.3 Step Execution The global transactions in an Interaction are specified using steps, where there is some flexibility as to which steps are actually executed to accomplish the subtask of the particular global transaction.
Reference: [SKS91b] <author> Nandit Soparkar, Henry F. Korth, and Abraham Silberschatz. </author> <title> Techniques for failure-resilient transaction management in multidatabases. </title> <type> Technical Report TR-91-10, </type> <institution> University of Texas at Austin, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: Corresponding Restric--Mechanism Point Multidatabase Mechanism tions Serialization Graph Data Conflict Site Graph Testing [BS88] Testing Two-Phase Lock Last Lock Forced Local Conflict [GRS91] I to Commit (Get ticket after last lock.) Timestamp Order Begin Forced Local Conflict [GRS91] I (Get ticket with transaction begin.) Rigorous 2PL Commit Strict 2PL/2PC Schemes <ref> [SKS91b] </ref> R (Rigorous 2PL local databases only) Rigorous multidatabases [BGRS91] R Commitment Order Commit Multiple Resource CO [Raz92b] R (CO local databases only) Conservative SGT Data Conflict Request-Order Linked List [PRR91] C O-schemes [MRB + 92b] C Conservative 2PL Commit Conservative TO Begin BT-schemes [MRB + 92b] C SGT Certifier Data
Reference: [SKS92] <author> Nandit Soparkar, Henry F. Korth, and Avi Silberschatz. </author> <title> Serializability among autonomous transaction managers. </title> <type> Technical Report TR-92-49, </type> <institution> University of Texas at Austin, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: This they call the Optimistic Ticket Method. When a global transaction is ready to enter the prepared state, the global transaction manager compares the different local serialization orders to ensure that it is serialized correctly. If not, the global transaction is aborted. <ref> [SKS92] </ref> provides a distributed optimistic scheme to ensure that a consistent global serialization order based on a potentially distributed global transaction manager. In this scheme, the piece of the global transaction manager that is responsible for coordinating a specific global transaction synchronizes the local databases via a basic agreement protocol. <p> Global serializability is proven based on the fact that no two global transactions that conflict locally can be in the synchronization process at the same time, and also based on the (Lamport-style) happens-before ordering of the synchronization messages. <ref> [SKS92] </ref> also characterizes the set of local databases that can be effectively synchronized as those that have a natural synchronization interval (serialization point) that occurs during the active execution of the global transaction.
Reference: [SPSW90] <author> Hans-Joerg Schek, Heinz-Bernhard Paul, Marc H. Scholl, and Gerhard Weikum. </author> <title> The DASDBS project: Objectives, experiences, and future prospects. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 25-43, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: It is easy to see that standard transactions are a one-level restriction of multilevel transactions, where a transaction can only specify read and write operations. With this restriction, multilevel serializability is equivalent to conflict serializability [BHG87]. Multilevel transactions have been implemented as a part of the DASDBS prototype <ref> [Wei91, SPSW90] </ref>. Weikum and Schek do briefly explore modeling multidatabase transactions as two-level multilevel transactions. Their solution requires that the global concurrency control manager in the multidatabase maintain a notion of conflict among all of the transactions on the local databases, including both the global subtrans-actions and the independent transactions.
Reference: [Wei91] <author> Gerhard Weikum. </author> <title> Principles and realization strategies of multilevel transaction management. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 16(1) </volume> <pages> 132-180, </pages> <month> March </month> <year> 1991. </year> <month> 113 </month>
Reference-contexts: Conflict and correctness is defined between each pair of adjacent levels. Weikum and Schek <ref> [Wei91, WS91a, WS91b] </ref> propose a formal definition for multilevel transactions, though not applied to multidatabases. They address issues of concurrency control and recovery. For correctness of multilevel transactions, they define multilevel serializability. <p> It is easy to see that standard transactions are a one-level restriction of multilevel transactions, where a transaction can only specify read and write operations. With this restriction, multilevel serializability is equivalent to conflict serializability [BHG87]. Multilevel transactions have been implemented as a part of the DASDBS prototype <ref> [Wei91, SPSW90] </ref>. Weikum and Schek do briefly explore modeling multidatabase transactions as two-level multilevel transactions. Their solution requires that the global concurrency control manager in the multidatabase maintain a notion of conflict among all of the transactions on the local databases, including both the global subtrans-actions and the independent transactions. <p> The inverse log pass generates compensating level (i-1) steps for each level i transaction that has not terminated. This recovery strategy has been implemented in the DASDBS project. A similarly structured technique is proposed for nested and multilevel transactions in [Lom92]. <ref> [Wei91] </ref> notes several other approaches, with different strategies for maintaining (semantic) undo and redo information at the various levels. The checkpoint strategies take periodic checkpoints. After a crash, the checkpoint is restored and undo and redo operations are applied level by level until the database is brought up to date. <p> These strategies require that semantic undo and redo information be maintained at each transaction level. Because of other limitations, the checkpoint schemes work best in a centralized database. The second new class of recovery strategies noted in <ref> [Wei91] </ref> they call "subtransaction oriented". These strategies basically treat subtransactions as independent transactions at their level. A log is kept of the active and completed subtransactions at each level. When a crash occurs, the log is read level by level.
Reference: [WHBM90] <author> Gerhard Weikum, Christof Hasse, Peter Broessler, and Peter Muth. </author> <title> Multi-level recovery. </title> <booktitle> In Proceedings of the 9th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 109-123, </pages> <year> 1990. </year>
Reference-contexts: This bounds how far a transaction can be from its "best available assignment". To aid in their scheduling mechanism, they also introduce a notion of horizon of compensation, which states that a child transaction cannot be compensated for after its parent commits. Multilevel transactions also require compensation-based recovery strategies <ref> [WHBM90] </ref>. Since multilevel transactions operate in a more restricted environment they can maintain an accurate, single log at each transaction level. During recovery, level 0 redo is first completed. Then, each level i log, starting from the level 1 log and working up, is processed in inverse order.
Reference: [WR91] <author> Helmut Waechter and Andreas Reuter. </author> <title> The ConTract model. </title> <editor> In A. Elmagarmid, editor, </editor> <title> Database Transaction Models for Advanced Applications. </title> <address> Morgan-Kauffman, </address> <year> 1991. </year>
Reference-contexts: This global transaction is viewed as being atomic, although their work also supports the notion of using a semantically atomic commit protocol. Flex transactions were implemented within the InterBase system [BCEP93]. They also have been implemented and used to support multi-system telecommunication applications [ANRS92]. 2.3.4 ConTracts In <ref> [WR91] </ref>, Waechter and Reuter describe a database transaction model called the ConTract Model. ConTracts are very similar in structure to Interactions. ConTracts are scripts of steps. <p> Rather, the open nested transaction needs to semantically undo the transaction back to some state that is semantically equivalent to what would have happened if the open nested transaction had not run. Open nested transaction models such as Sagas [GS87], Flex Transactions [ELLR90], and ConTracts <ref> [WR91] </ref> use a form of recovery called compensation. This form of recovery was first defined in detail by Garcia-Molina and Salem [GS87]. In their Sagas, each transaction has a corresponding compensating transaction. <p> Nested Sagas [GGK + 90] require that the compensating Sagas be invoked recursively. The ConTracts paper <ref> [WR91] </ref> makes some additional observations concerning compensation. Compensating transactions do not need to run in the inverse order of their corresponding transactions: In fact, compensating transactions are often completely independent and can run concurrently. <p> If no compensating code blocks succeed, the default could be to allow the user to fix the problem himself. This ability we call "sloppy compensation". 5.3.2 Dealing with Flexible Transactions Flexible transaction models such as <ref> [GGK + 90, ELLR90, WR91, Nod93] </ref> allow the execution flow of an open nested transaction to depend in part on the information in the database. <p> In fact, more concurrency is possible during the compensation process, because compensation steps are usually fixed code (no branches or loops) with predetermined inputs (based on the inputs and/or results from the original step) <ref> [WR91] </ref>. However, depending on how the state is managed, two concurrent subtransactions that conflict on some state variable may not be able to be compensated for and re-executed concurrently. Consider the Interaction shown in Figure 6.2.
Reference: [WS91a] <author> Gerhard Weikum and Hans-J Schek. </author> <title> Multi-level transactions and open nested transactions. </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 14(1) </volume> <pages> 60-64, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: Conflict and correctness is defined between each pair of adjacent levels. Weikum and Schek <ref> [Wei91, WS91a, WS91b] </ref> propose a formal definition for multilevel transactions, though not applied to multidatabases. They address issues of concurrency control and recovery. For correctness of multilevel transactions, they define multilevel serializability. <p> However, this is not feasible in a multidatabase environment that tries to guarantee the autonomy of the local databases. This is because the restriction to a level-oriented transaction structure is incompatible with allowing local databases to run transactions independent from the multidatabase. In <ref> [WS91a, WS91b] </ref>, Weikum and Schek also define open nested transactions as an extension of multilevel transactions, though they do not attempt themselves to formally characterize correctness in open nested transactions. Figure 2.2 gives an example to illustrate the difference between an open nested transaction structure and a multilevel transaction structure.
Reference: [WS91b] <author> Gerhard Wiekum and Hans-J. Schek. </author> <title> Concepts and applications of multilevel transactions and open nested transactions. </title> <editor> In A. Elmagarmid, editor, </editor> <booktitle> Database Transaction Models for Advanced Applications, </booktitle> <pages> pages 515-547. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: Conflict and correctness is defined between each pair of adjacent levels. Weikum and Schek <ref> [Wei91, WS91a, WS91b] </ref> propose a formal definition for multilevel transactions, though not applied to multidatabases. They address issues of concurrency control and recovery. For correctness of multilevel transactions, they define multilevel serializability. <p> However, this is not feasible in a multidatabase environment that tries to guarantee the autonomy of the local databases. This is because the restriction to a level-oriented transaction structure is incompatible with allowing local databases to run transactions independent from the multidatabase. In <ref> [WS91a, WS91b] </ref>, Weikum and Schek also define open nested transactions as an extension of multilevel transactions, though they do not attempt themselves to formally characterize correctness in open nested transactions. Figure 2.2 gives an example to illustrate the difference between an open nested transaction structure and a multilevel transaction structure.
Reference: [WV90] <author> Antoni Wolski and Jari Veijalainen. </author> <title> 2PC agent method: Achieving serializability in presence of failures in a heterogeneous multidatabase. </title> <booktitle> In Proceedings of PARBASE, </booktitle> <pages> pages 321-330, </pages> <year> 1990. </year>
Reference-contexts: All of the algorithms described in this section fit into our general commit framework. Most of the work on supporting atomic commitment in multidatabases is done by providing a simulated 17 Scheme Local Commit Global Decision Paradigm Before Before Global Decision Local Commit (Requires Undo) (Requires Redo) 2PC Agent <ref> [WV90] </ref> p LDB blocking rigorous LDBs full atomicity Hydro [PRR91] p LDB Blocking full atomicity Optimistic Commit p stratification Protocol [LKS91a] semantic atomicity Mehrotra et al. read-only update data partitioning [MRB + 92a] subtransactions subtransactions rigorous MDB full atomicity Non-blocking compensatable retriable allows a pivot commit [MRKS92] subtransactions subtransactions semantic atomicity <p> Several different commit strategies for global transactions have been proposed. They are summarized in Table 2.2. Systems which use the global decision before local commit strategy include the 2PC Agent method <ref> [WV90] </ref>, Hydro [PRR91], and the optimistic commit protocol [LKS91a]. In the 2PC Agent Method [WV90] of Wolski and Viejalainen, a 2PC Agent associated with each local database acts for the local database as a participant in the two-phase commit protocol. <p> Several different commit strategies for global transactions have been proposed. They are summarized in Table 2.2. Systems which use the global decision before local commit strategy include the 2PC Agent method <ref> [WV90] </ref>, Hydro [PRR91], and the optimistic commit protocol [LKS91a]. In the 2PC Agent Method [WV90] of Wolski and Viejalainen, a 2PC Agent associated with each local database acts for the local database as a participant in the two-phase commit protocol. <p> If the global transaction aborts, then one or more of the transactions that has been active during the decision phase may need to abort in order for the semantic undo to be correct. This effectively does the same thing as the denied local updates in <ref> [WV90] </ref> in that it gets rid of conflicts with the original (and compensating) 18 global transaction. However, it does this by aborting local transactions rather than denying their updates. In other words, this scheme violates control autonomy rather than execution autonomy. <p> Mullen's protocol requires all transactions, including local ones, be modified to test the reservation information. A third example of a blocking protocol is the denied local updates proposed for the 2PC agent method <ref> [WV90] </ref>. This involves slightly modifying the local databases to prevent other transactions from making updates while a global commit decision is being made. While blocking protocols are required for many (but not all) global transaction commits, they do require violating the local database autonomy.
Reference: [ZE93a] <author> Aidong Zhang and Ahmed K. Elmagarmid. </author> <title> On global transaction scheduling criteria in mul-tidatabase systems. </title> <booktitle> In Proceedings of the 2nd International Conference on Parallel and Distributed Systems, </booktitle> <pages> pages 117-124, </pages> <year> 1993. </year>
Reference-contexts: The forced local conflict restricts the histories accepted by the local database to those that serialize the global subtransactions correctly. We also take this approach in our work on enforcing global serialization order. A different set of conflict-based schemes can be developed based on the correctness criteria described in <ref> [ZE93a, ZE93b] </ref>. Unlike forced local conflict, the conflict-serializable, sharing-serializable, and hybrid-serializable schedules generated by these schemes do not require the modification of the local database schemas to add a ticket. Thus, with respect to maintaining a global serialization order, these schemes allow the local databases to remain fully autonomous.
Reference: [ZE93b] <author> Aidong Zhang and Ahmed K. Elmagarmid. </author> <title> A theory of global concurrency control in multi-database systems. </title> <journal> VLDB Journal, </journal> <volume> 2(2), </volume> <month> July </month> <year> 1993. </year> <note> (to appear). 114 </note>
Reference-contexts: The forced local conflict restricts the histories accepted by the local database to those that serialize the global subtransactions correctly. We also take this approach in our work on enforcing global serialization order. A different set of conflict-based schemes can be developed based on the correctness criteria described in <ref> [ZE93a, ZE93b] </ref>. Unlike forced local conflict, the conflict-serializable, sharing-serializable, and hybrid-serializable schedules generated by these schemes do not require the modification of the local database schemas to add a ticket. Thus, with respect to maintaining a global serialization order, these schemes allow the local databases to remain fully autonomous. <p> Note that we can bypass the long wait or the enforcement of the lull in situations where we know that the next global subtransaction reads from the previous one, or has a sharing relationship as defined in <ref> [ZE93b] </ref>. In that case, we can schedule the two global subtransactions concurrently, and merely ensure that they commit in the global serialization order.
References-found: 73

