URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/93-40.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Email: E-Mail: fbharat,osorio,kmoong@cs.buffalo.edu  
Phone: Telephone: (716) 645-3194  
Title: Partial Order Logic Programmingy  
Author: Bharat Jayaraman Mauricio Osorio Kyonghee Moon 
Keyword: Partial Orders, Lattices, Monotonic Operations, Aggregation, Sets, Stratified Semantics, Memoization, Fixed-Point Iteration  
Address: Buffalo, NY 14260  
Affiliation: Department of Computer Science State University of New York at Buffalo  
Abstract: This paper shows the use of partial-order assertions and lattice domains for logic programming. We illustrate the paradigm using a variety of examples, ranging from program analysis to deductive databases. These applications are characterized by a need to solve circular constraints and perform aggregate operations. We show in this paper that defining functions with subset assertions and, more generally, partial-order assertions renders clear formulations to problems involving aggregate operations (first-order and inductive) and recursion. Indeed, as pointed out by Van Gelder [V92], for many problems in which the use of aggregates has been proposed, the concept of subset is what is really necessary. We provide model-theoretic and operational semantics, and prove the correctness of the latter. Our proposed operational semantics employs a mixed strategy: top-down with memoization and bottom-up fixed-point iteration. y This paper is TR 93-040, Department of Computer Science, SUNY-Buffalo, November 1993. Comments are welcome, and may be sent to any of the authors. 
Abstract-found: 1
Intro-found: 1
Reference: [AU77] <author> A. Aho and J.D. Ullman, </author> <title> "Principles of Compiler Design," </title> <publisher> Addison-Wesley, </publisher> <year> 1977. </year>
Reference-contexts: For a more realistic example, the program below defines the reaching definitions and busy expressions in a program flow graph, which is computed by a compiler during its optimization phase <ref> [AU77] </ref>. reach out (B) reach in (pred (B)) - kill (B) reach out (B) gen (B) reach in (fBn g) reach out (B) busy out (B) busy in (succ (B))- def (B) busy out (B) use (B) busy in (fBn g) busy out (B) 5 where kill (B), gen (B), pred
Reference: [GSZ93] <author> S. Greco, D. Sacca, and C. Zaniolo, </author> <title> "Dynamic Programming Optimization for Logic Queries with Aggregates," </title> <booktitle> Proc. ILPS 93, </booktitle> <pages> pp. 575-589, </pages> <address> Vancouver, </address> <year> 1993. </year>
Reference-contexts: 1. Introduction In recent years there has been considerable interest in the topic of aggregation in logic programming and deductive databases <ref> [MPR90, KS91, RS92, V92, GSZ93, SSRB93] </ref>. An aggregate operation is a function that maps a set to some value, e.g., the maximum or minimum in the set, the cardinality of this set, the summation of all its members, etc.
Reference: [J91] <author> B. Jayaraman, </author> <title> "The SuRE Programming Framework," </title> <institution> Dept. of Computer Science TR 91-011, SUNY-Buffalo, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: We begin with an informal explanation of partial-order assertions. The idea is a generalization of the notion of subset assertions described in <ref> [JP87, JN88, JP89, J91, J92] </ref>. The two basic forms of a partial-order assertion are: f (terms) expr f (terms) expr where each variable in expr also occurs in terms (the syntax terms and expr is given in section 2). <p> There is more to be said about this integration, especially how normal program clauses [L87] can invoke functions defined by partial-order assertions, but space precludes a full treatment here; reference <ref> [J91] </ref> describes a language called SuRE which integrates Subset, Relational and Equational assertions. Subset assertions are a special case of partial-order assertions; indeed, partial-order assertions evolved from subset assertions. Finally, we briefly compare of our work with that of Stott Parker's concept of partial-order programming [P89].
Reference: [J92] <author> B. Jayaraman, </author> <title> "Implementation of Subset-Equational Programs," </title> <journal> JLP, </journal> <volume> 12(4) </volume> <pages> 299-324, </pages> <year> 1992. </year>
Reference-contexts: We begin with an informal explanation of partial-order assertions. The idea is a generalization of the notion of subset assertions described in <ref> [JP87, JN88, JP89, J91, J92] </ref>. The two basic forms of a partial-order assertion are: f (terms) expr f (terms) expr where each variable in expr also occurs in terms (the syntax terms and expr is given in section 2). <p> By specifying that the underlying lattice ordering is a total ordering and that min2 distributes over +, it is possible to mimic a Dijkstra-style shortest-path algorithm. While annotations for distribution are discussed in <ref> [JN88, J92] </ref> and is supported by our implementation, we do not yet support annotations that specify total-ordering. Company Controls [RS92]: c (X,Y) gt (sum (cv (X,Y)), 50). cv (X,Y) fNg :- s (Z,Y,N), c (X,Z) = true. This example illustrates the use of an inductive aggregate operation, sumy.
Reference: [JP87] <author> Jayaraman, B. and Plaisted, D. A., </author> <title> "Functional Programming with Sets," </title> <booktitle> Proc. Third FPCA, </booktitle> <address> Portland, </address> <year> 1987, </year> <pages> pp. 194-210, </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We begin with an informal explanation of partial-order assertions. The idea is a generalization of the notion of subset assertions described in <ref> [JP87, JN88, JP89, J91, J92] </ref>. The two basic forms of a partial-order assertion are: f (terms) expr f (terms) expr where each variable in expr also occurs in terms (the syntax terms and expr is given in section 2).
Reference: [JN88] <author> Jayaraman, B. and Nair A., </author> <title> "Subset-Logic Programming: Application and Implementation," </title> <booktitle> Proc. JICSLP, </booktitle> <pages> pp. 841-858, </pages> <address> Seattle, </address> <year> 1988. </year>
Reference-contexts: We begin with an informal explanation of partial-order assertions. The idea is a generalization of the notion of subset assertions described in <ref> [JP87, JN88, JP89, J91, J92] </ref>. The two basic forms of a partial-order assertion are: f (terms) expr f (terms) expr where each variable in expr also occurs in terms (the syntax terms and expr is given in section 2). <p> By specifying that the underlying lattice ordering is a total ordering and that min2 distributes over +, it is possible to mimic a Dijkstra-style shortest-path algorithm. While annotations for distribution are discussed in <ref> [JN88, J92] </ref> and is supported by our implementation, we do not yet support annotations that specify total-ordering. Company Controls [RS92]: c (X,Y) gt (sum (cv (X,Y)), 50). cv (X,Y) fNg :- s (Z,Y,N), c (X,Z) = true. This example illustrates the use of an inductive aggregate operation, sumy.
Reference: [JP89] <author> Jayaraman, B. and Plaisted, D. A., </author> <title> "Programming with Equations, Subsets, and Relations," </title> <booktitle> Proc. </booktitle> <volume> NACLP 89, </volume> <pages> pp. 1051-1068, </pages> <address> Cleveland, </address> <year> 1989. </year>
Reference-contexts: We begin with an informal explanation of partial-order assertions. The idea is a generalization of the notion of subset assertions described in <ref> [JP87, JN88, JP89, J91, J92] </ref>. The two basic forms of a partial-order assertion are: f (terms) expr f (terms) expr where each variable in expr also occurs in terms (the syntax terms and expr is given in section 2).
Reference: [KS91] <author> D.B. Kemp and P.J. Stuckey, </author> <title> "Semantics of Logic Programs with Aggregates," </title> <booktitle> Proc. ILPS 91, </booktitle> <pages> pp. 387-401, </pages> <address> San Diego, </address> <year> 1991. </year> <month> 14 </month>
Reference-contexts: 1. Introduction In recent years there has been considerable interest in the topic of aggregation in logic programming and deductive databases <ref> [MPR90, KS91, RS92, V92, GSZ93, SSRB93] </ref>. An aggregate operation is a function that maps a set to some value, e.g., the maximum or minimum in the set, the cardinality of this set, the summation of all its members, etc.
Reference: [L87] <author> J.W. Lloyd, </author> <title> "Foundations of Logic Programming," (2 ed.) </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: This requirement is analogous to the requirement that negated goals in normal programs <ref> [L87] </ref> must have ground arguments|negation-as-failure is sound only for ground negated goals. We now present a series of examples to explain the use of conditional partial-order assertions. The following table summarizes the various forms of assertions to be used in these examples. <p> There is more to be said about this integration, especially how normal program clauses <ref> [L87] </ref> can invoke functions defined by partial-order assertions, but space precludes a full treatment here; reference [J91] describes a language called SuRE which integrates Subset, Relational and Equational assertions. Subset assertions are a special case of partial-order assertions; indeed, partial-order assertions evolved from subset assertions.
Reference: [MPR90] <author> I.S. Mumick, H. Pirahesh, and R. Ramakrishnan, </author> <title> "The Magic of Duplicates and Aggregates," </title> <booktitle> Proc. 16th VLDB, </booktitle> <pages> pp. 264-277, </pages> <year> 1990. </year>
Reference-contexts: 1. Introduction In recent years there has been considerable interest in the topic of aggregation in logic programming and deductive databases <ref> [MPR90, KS91, RS92, V92, GSZ93, SSRB93] </ref>. An aggregate operation is a function that maps a set to some value, e.g., the maximum or minimum in the set, the cardinality of this set, the summation of all its members, etc.
Reference: [P88] <author> T. Przymusinski, </author> <title> "On the Declarative Semantics of Stratified Deductive Databases and Logic Programs," </title> <booktitle> Proc. Foundations of Deductive Databases and Logic Programming, </booktitle> <editor> J. Minker (ed.), </editor> <booktitle> pp. </booktitle> <pages> 193-216, </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Second, it suffices if the ground instances of program assertions are stratified in the above manner. This idea is, of course, analogous to the that of local stratification <ref> [P88] </ref>. Henceforth, we will use the term general stratified language to refer to this extended language. It is straightforward to show that the presence of monotonic functions does not call for any alteration of the model-theoretic semantics. The operational semantics, however, must be modified to incorporate fixed-point iteration.
Reference: [P89] <author> S. Parker, </author> <title> "Partial Order Programming," </title> <booktitle> Proc. 16th ACM POPL, </booktitle> <pages> pp. 260-266, </pages> <address> Austin, TX, </address> <year> 1989. </year>
Reference-contexts: Subset assertions are a special case of partial-order assertions; indeed, partial-order assertions evolved from subset assertions. Finally, we briefly compare of our work with that of Stott Parker's concept of partial-order programming <ref> [P89] </ref>.
Reference: [RS92] <author> K.A. Ross and Y. Sagiv, </author> <title> "Monotonic Aggregation in Deductive Databases," </title> <booktitle> Proc. 11th ACM PODS, </booktitle> <pages> pp. 114-126, </pages> <address> San Diego, </address> <year> 1992. </year>
Reference-contexts: 1. Introduction In recent years there has been considerable interest in the topic of aggregation in logic programming and deductive databases <ref> [MPR90, KS91, RS92, V92, GSZ93, SSRB93] </ref>. An aggregate operation is a function that maps a set to some value, e.g., the maximum or minimum in the set, the cardinality of this set, the summation of all its members, etc. <p> This is essentially the semantics for monotonic aggregation given in <ref> [RS92] </ref>. Our operational semantics combines top-down goal reduction with a bottom-up fixed-point iteration. This strategy requires memoization [W92] in order to detect circular constraints; however, in general we need more than memoization when functions are defined circularly in terms of one another through monotonic functions. <p> While annotations for distribution are discussed in [JN88, J92] and is supported by our implementation, we do not yet support annotations that specify total-ordering. Company Controls <ref> [RS92] </ref>: c (X,Y) gt (sum (cv (X,Y)), 50). cv (X,Y) fNg :- s (Z,Y,N), c (X,Z) = true. This example illustrates the use of an inductive aggregate operation, sumy. The function gt (X,Y) stands for numeric greater-than. The boolean function c (X,Y) returns true if company X controls Y.
Reference: [SSRB93] <author> S. Sudarshan, D. Srivastava, R. Ramakrishnan, and C. Beeri, </author> <title> "Extending the Well-Founded and Valid Semantics for Aggregation," </title> <booktitle> Proc. ILPS 93, </booktitle> <pages> pp. 590-608, </pages> <address> Vancou-ver, </address> <year> 1993. </year>
Reference-contexts: 1. Introduction In recent years there has been considerable interest in the topic of aggregation in logic programming and deductive databases <ref> [MPR90, KS91, RS92, V92, GSZ93, SSRB93] </ref>. An aggregate operation is a function that maps a set to some value, e.g., the maximum or minimum in the set, the cardinality of this set, the summation of all its members, etc. <p> Thus &gt; in the above table is to be thought of as a number chosen by the programmer to suit the problem at hand. We will see that specifying the least/greatest element is similar to the notion of defaults in the terminology of Sudarshan et al <ref> [SSRB93] </ref>, while specifying the lub/glb corresponds to the notion of first-order aggregate operations in the sense of Van Gelder [V92]. Furthermore, a programmer can define his or her own inductive aggregates; that is, we are not restricted to a fixed set of built-in aggregate operations.
Reference: [V92] <author> A. Van Gelder, </author> <title> "The Well-Founded Semantics of Aggregation," </title> <booktitle> Proc. ACM 11th PODS, </booktitle> <pages> pp. 127-138, </pages> <address> San Diego, </address> <year> 1992. </year>
Reference-contexts: 1. Introduction In recent years there has been considerable interest in the topic of aggregation in logic programming and deductive databases <ref> [MPR90, KS91, RS92, V92, GSZ93, SSRB93] </ref>. An aggregate operation is a function that maps a set to some value, e.g., the maximum or minimum in the set, the cardinality of this set, the summation of all its members, etc. <p> An aggregate operation is a function that maps a set to some value, e.g., the maximum or minimum in the set, the cardinality of this set, the summation of all its members, etc. In considering the problems with various semantic approaches, Van Gelder <ref> [V92] </ref> notes that, for many problems in which the use of aggregates has been proposed, the concept of subset is what is really necessary. We show in this paper that defining functions with subset assertions, and, more generally, partial-order assertions renders clear formulations to problems involving aggregate operations and recursion. <p> We will see that specifying the least/greatest element is similar to the notion of defaults in the terminology of Sudarshan et al [SSRB93], while specifying the lub/glb corresponds to the notion of first-order aggregate operations in the sense of Van Gelder <ref> [V92] </ref>. Furthermore, a programmer can define his or her own inductive aggregates; that is, we are not restricted to a fixed set of built-in aggregate operations. <p> This information can be stated through an annotation. 12 gt (sum (cv (X,Y)), 50) is legal, because gt and sum are monotonic. A similar assumption is made in the next example.) Party Invitations <ref> [V92] </ref>: accept (X) goodenough (X) and not (toobad (X)). goodenough (X) ge (sum (relplus (X)), pos thr (X)). toobad (X) gt (sum (relminus (X)), neg thr (X)). relplus (X) fCg :- pos (X,Y,C), accept (Y) = true. relminus (X) fCg :- neg (X,Y,C), accept (Y) = true. pos thr (a) =
Reference: [W92] <author> D.S. Warren, </author> <title> "Memoing for Logic Progams," </title> <journal> CACM, </journal> <volume> 35(3) </volume> <pages> 93-111, </pages> <year> 1992. </year>
Reference-contexts: This is essentially the semantics for monotonic aggregation given in [RS92]. Our operational semantics combines top-down goal reduction with a bottom-up fixed-point iteration. This strategy requires memoization <ref> [W92] </ref> in order to detect circular constraints; however, in general we need more than memoization when functions are defined circularly in terms of one another through monotonic functions. In such cases, a memoized call may have to reexecuted several times in order to progress towards the least fixed-point.
References-found: 16

