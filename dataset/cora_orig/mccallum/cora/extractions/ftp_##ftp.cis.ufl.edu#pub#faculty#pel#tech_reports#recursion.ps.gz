URL: ftp://ftp.cis.ufl.edu/pub/faculty/pel/tech_reports/recursion.ps.gz
Refering-URL: http://www.cis.ufl.edu/~pel/Ghinsu/gghinsu.html
Root-URL: http://www.cis.ufl.edu
Title: A New Algorithm for the Calculation of Transitive Dependences  
Author: Panos E. Livadas Stephen Croll 
Address: Gainesville, FL 32611  
Affiliation: Computer and Information Sciences Department University of Florida  
Abstract: Program slicing can be used to aid in a variety of software maintenance activities including code understanding, code testing, debugging, and program reengineering. Program slicing (as well as other program analysis functions including ripple analysis) can be efficiently performed on an internal program representation called a system dependence graph (SDG). This paper will describe a new method for calculating transitive dependencies in the presence of recursion. This method requires neither the (explicit) calculation of the GMOD and GREF sets nor the construction of a linkage grammar and the corresponding subordinate characteristic graphs of the linkage grammar's nonterminals. Additionally, a beneficial side effect of this method is that it provides us with a new method for performing interprocedural, flow-sensitive data flow analysis. Finally, this paper will illustrate the versatility of the SDG as an internal program representation by briefly describing a tool that we have developed that permits slicing, dicing, ripple analysis, and other static analysis functions to be performed on programs written in a subset of ANSI C (e.g., C without gotos and pointers). 
Abstract-found: 1
Intro-found: 1
Reference: [Aho74] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman. </author> <title> ``The Design and Analysis of Computer Algorithms'', </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference: [Aho86] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> ``Compilers: Principles, Techniques and Tools'', </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference-contexts: We would like to note here that our method for determining control dependences is based on a syntax-directed method (hence we do not handle such constructs such as gotos). If another, more precise method was used (such as the one described in <ref> [Aho86] </ref>, there would be no need to include return-control edges in the SDG. The return-control edge indicates the dependence between the return statement of a procedure and other statements following the return statement which will not be executed when the program exits on a return statement.
Reference: [Bad88] <author> L. Badger and M. Weiser. </author> <title> ``Minimizing Communications for Synchronizing Parallel Dataflow Programs'', </title> <booktitle> In Proceedings of the 1988 International Conference on Parallel Processing, </booktitle> <publisher> Penn State University Press, </publisher> <address> PA. </address>
Reference-contexts: In addition, program slicing provides a meaningful way to decompose a large program into smaller components and can therefore aid in program understanding. Moreover, Horwitz [Hor88] has used the concepts of slicing in integrating program variants and Badger <ref> [Bad88] </ref> has demonstrated how slicing can be used for automatic parallelization. Furthermore, slicing also aids in code reusability.
Reference: [Ban79] <author> Banning, J.P. </author> <title> ``An Efficient Way to Find the Side Effects of Procedure Calls and the Aliases of Variables''. </title> <booktitle> In Conference Record of the Sixth ACM Symposium on Principles of Programming Languages (San Antonio, Tex., </booktitle> <address> Jan. 29-31,1979). </address> <publisher> ACM, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: In this case, the presence of its actual-out node could adversely affect the precision of an interprocedural slice. A method is described in [Hor90] to detect such a phenomena that is based on the calculation of the GMOD and GREF sets 10 (via the method proposed in <ref> [Ban79] </ref>) for each procedure F k . We have determined that calculating these sets is not necessary under our method since all information required for that determination is contained in the procedure's dependence graph.
Reference: [Boe75] <author> B.W. Boehm. </author> <title> ``The High Cost of Software, Practical Strategies for Developing Large Software Systems'', </title> <editor> E. Horowitz (ed.). </editor> <address> Reading, Mass: </address> <publisher> Addison-Wesley. </publisher>
Reference-contexts: 1. Introduction Software maintenance is an expensive, demanding, and ongoing process. Lientz and Swanson [Lie80] have reported that large organizations devoted 50% of their total programming effort to the maintenance of existing systems. Boehm <ref> [Boe75] </ref> has estimated that one US Air Force system cost $30 per instruction to develop and $4,000 per instruction to maintain over its lifetime. These figures are perhaps exceptional; but, on the average, they seem to be between two and four times higher than development costs for large embedded systems.
Reference: [Cal88] <author> D. Callahan. </author> <title> ``The Program Summary Graph and Flow-Sensitive Interprocedural Data Flow Analysis'', </title> <booktitle> In Proceedings of the SIGPLAN 1988 Conference on Programming Language Design and Implementation, </booktitle> <address> Atlanta Georgia, </address> <month> June 22-24, </month> <year> 1988. </year>
Reference: [Fer87] <author> J. Ferrante, K. Ottenstein, and J. Warren. </author> <title> ``The Program Dependence Graph and its Use in Optimization'', </title> <journal> ACM TOPLAS, </journal> <month> July </month> <year> 1987. </year>
Reference-contexts: Methods for more precise interprocedural slicing have been developed by Horwitz [Hor88] where parameters are passed by value-result. This is an extension of the program dependence graph presented in <ref> [Fer87] </ref>. However, this models a simple language that supports scalar variables, assignment statements, conditional statements, and while loops. The dependence graph developed by Horwitz differentiates between loop-independent and loop-carried flow dependency edges.
Reference: [Har89] <author> M. J. Harrold and M. L. Soffa. </author> <title> ``Selecting Data for Integration Testing </title>
Reference-contexts: Recursion is handled by a method of iteration over the recursive procedure (s). The called procedure always returns to the correct address in the calling procedure. This completely eliminates the use of linkage grammar and construction of subordinate characteristic graphs which makes our algorithm more efficient. Harrold, et. al., <ref> [Har89] </ref> calculate interprocedural data dependencies in the context of inter-procedural data flow testing. Their algorithm requires an invocation ordering of the procedures. Additionally, when recursive procedures are present, processing may visit each node p times where p is the number of procedures in the program.
Reference: [Hor88] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> ``Integrating Non-interfering Versions of Programs'', </title> <booktitle> in Proceedings of the 15th ACM Symposium of Programming Languages, </booktitle> <publisher> ACM Press, </publisher> <address> N. York. </address>
Reference-contexts: In addition, program slicing provides a meaningful way to decompose a large program into smaller components and can therefore aid in program understanding. Moreover, Horwitz <ref> [Hor88] </ref> has used the concepts of slicing in integrating program variants and Badger [Bad88] has demonstrated how slicing can be used for automatic parallelization. Furthermore, slicing also aids in code reusability. <p> In addition, Weiser's method does not produce an optimum slice across procedure calls because it cannot keep track of the calling context of a called procedure. Methods for more precise interprocedural slicing have been developed by Horwitz <ref> [Hor88] </ref> where parameters are passed by value-result. This is an extension of the program dependence graph presented in [Fer87]. However, this models a simple language that supports scalar variables, assignment statements, conditional statements, and while loops. The dependence graph developed by Horwitz differentiates between loop-independent and loop-carried flow dependency edges.
Reference: [Hor89] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> ``Integrating Non-interfering Versions of Programs'', </title> <journal> ACM TOPLAS, </journal> <month> July </month> <year> 1989. </year>
Reference: [Hor90] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> ``Interprocedural Slicing Using Dependence Graphs'', </title> <journal> ACM TOPLAS, </journal> <month> January </month> <year> 1990. </year>
Reference-contexts: This definition is less general than the one given in [Wei82]; but, it is sufficient <ref> [Hor90] </ref>. <p> Weiser's slicer was based on a flow-graph representation of Simple_D programs. Otten-stein et al [Ott84], showed that an intraprocedural slice could be found in linear time by traversing a suitable graph representation of the program which they referred to as the program dependence graph (PDG). Horwitz et al <ref> [Hor90] </ref>, have introduced algorithms to construct interpro-cedural slices by extending the program dependence graph to a supergraph of the PDG which is referred to as the system dependence graph (SDG). <p> The following sections describe these conversions. 2.3.1. Global Variables The handling of global variables is based on the method suggested by <ref> [Hor90] </ref>. Specifically, glo-bals are solved by introducing them as additional pass-by-reference parameters to the procedures that use or define them. All procedures that call a procedure directly or a procedure which indirectly uses or defines global variables are modified to include the global variables as pass-by-reference parameters. <p> We note here that the possible number of alias configurations for a procedure with n passed-by-reference parameters is 2 n - n. 3. The Interprocedural Slicing Algorithm The interprocedural slicing algorithm is based on the algorithm suggested in <ref> [Hor90] </ref>. Modifications are necessary given the additional constructs introduced in the grammar. The algorithm finds the slice relative to a node s 0 of a program G P in two phases. <p> We should note that when a call to a procedure F yields aliasing and a slice at a statement s 0 that is internal to the body of procedure F, special care must be taken. As described in <ref> [Hor90] </ref>, assuming that the total number of aliasing patterns is m &gt; 0, let s 0 m represent the instance of s 0 in each procedure dependence graph associated with F. <p> Enhancing Slicing Accuracy There are a number of instances in which an actual-out node should not exist as when a passed-by-reference parameter is not modified. In this case, the presence of its actual-out node could adversely affect the precision of an interprocedural slice. A method is described in <ref> [Hor90] </ref> to detect such a phenomena that is based on the calculation of the GMOD and GREF sets 10 (via the method proposed in [Ban79]) for each procedure F k . <p> We will say that the procedure has been summarized, if and only if, all summary dependences have been calculated. On the other hand, determination of the summary information of F k requires that the procedure be solved. The method that is proposed in <ref> [Hor90] </ref> for the calculation of the transitive dependences distinguishes between grammars that do not support recursion and those that do. In the former case, the solution proposed is via the use of a separate copy of a procedure dependence graph for each call-site. <p> The set GREF (P) is defined as the set of variables that might be referenced by P itself or by a procedure (transitively) called from P <ref> [Hor90] </ref>. - 11 - In this section we will describe a method that permits one to solve all procedures including the construction of the SDG in a bottom-up fashion and so that only one copy of a procedure dependence graph is required for all sites 11 . <p> For example, we can see that the declaration of y ``reaches'' the use of y in the statement *y=*y+*x; therefore, it is detected an uninitialized variable. 8. The Interprocedural Ripple Analysis Algorithm Ripple analysis is slicing in the forward direction <ref> [Hor90] </ref>. Whereas a slice relative to a particular variable in a particular statement is the set of all statements that may affect the value of the vari able, ripple analysis will show the potential effect of changing a variable at a selected statement. <p> Our method treats these as a single type of edge -- the data flow edge -- which simplifies construction of the program dependence graph. Our method of calculating interprocedural dependences does not use linkage grammar as used in Horwitz's algorithm <ref> [Hor90] </ref>. Our algorithm is conceptually much simpler. The linkage grammar utilized by Horwitz includes one nonterminal and one production for each procedure in the system. The attributes in the linkage grammar correspond to the input and output parameters of the procedures.
Reference: [Hwa88] <author> J.C. Hwang, M.W. Du, C.R. Chou. </author> <title> ``Finding Program Slices for Recursive Procedures'', </title> <booktitle> In Proceedings of the IEEE COMPSAC 88, IEEE Computer Society, </booktitle> <year> 1988. </year>
Reference-contexts: As above, we do not need to calculate an invocation ordering. Also, we need to iterate over only the recursive procedures, not the entire program. A technique for handling slices for recursive procedures has been suggested by Hwang <ref> [Hwa88] </ref> which constructs a sequence of slices of the system - where each slice of the sequence essentially permits only one additional level of recursion - until a fixed point is reached.
Reference: [Kas80] <author> Kastens, U. </author> <title> ``Ordered Attribute Grammars''. </title> <journal> Acta Inf. </journal> <volume> 13,3, </volume> <year> 1980. </year>
Reference: [Ker88] <author> B.W. Kernigham and D. M. Ritchie. </author> <title> ``The C Programming (ANSI C) Language'', </title> <booktitle> 2nd. </booktitle> <address> Edition, </address> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey. </address>
Reference: [Leu87] <author> H.K.N. Leung and H.K. Reghbati. </author> <title> ``Comments on Program Slicing'', </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. Se-13 No. 12, </volume> <month> December </month> <year> 1987. </year>
Reference: [Liv94] <author> Panos E. Livadas, Stephen Croll. </author> <title> ``System Dependence Graphs Based on Parse Trees and their Use in Software Maintenance'', </title> <journal> Journal of Information Sciences, </journal> <volume> Vol 76, No 3&4, </volume> <month> February </month> <year> 1994; </year> <month> pp. </month> <pages> 197-232. </pages>
Reference-contexts: Realizing the versatility of this IPR, we have developed a prototype that accepts programs written in a subset of ANSI C and which generates an SDG. We have also implemented tools such as a slicer, a dicer, and a ripple analyzer that can utilize this SDG <ref> [Liv94] </ref>. In addition, we are exploring the use of this SDG in some of the software engineering activities discussed above. The grammar that we are using is as follows. First, declarations of local, global, and static variables are supported. <p> Fourth, we distinguish between functions that return values as opposed to those that do not. Fifth, all C constructs are ``handled'' except goto, break, continue, and long jumps. Sixth, in contrast to the algorithms we have presented <ref> [Liv94] </ref>, recursive procedures are allowed. Additionally, we describe our reaching definitions calculator tool that uses the SDG to show reaching definitions. These definitions can span procedure boundaries. Presently, we have implemented the algorithms that are presented here as part of our Ghinsu tool. <p> We should note that the terminology and notation used in the sequel is the same as that in <ref> [Liv94] </ref> unless otherwise noted. 2.1. Program Dependence Graph The program dependence graph (PDG) for a program P, with no procedures, denoted by G P , is a labeled, directed, multigraph. <p> In actuality, the SDG is ``resolved'' at the token level. Using a parse tree representation as the basis for our SDG allows more precise slices to be calculated <ref> [Liv94] </ref>. In the sequel, by the term SDG we will denote a parse-tree-based SDG unless otherwise noted. For the purposes of simplicity, the figures in this paper are shown to be resolved at the statement level. <p> Finally, to repeat, the algorithm operates on a parse-tree-based SDG that yields smaller slices. The Algorithm Our method is a modification of the method that we discussed in <ref> [Liv94] </ref> which handled the case where no recursive procedures were present. Specifically, we noted that with the use of our algorithm, each procedure is solved as soon as it is encountered.
Reference: [Lyl86] <author> J.R. Lyle and M. Weiser. </author> <title> ``Experiments in Slicing-based Debugging Aids'', In Elliot Soloway and Sitharama Iyengar, editors, Empirical Studies of Programmers, </title> <publisher> Ablex Publishing Corporation, </publisher> <address> Norwood, New Jersey, </address> <year> 1986. </year> <month> - 24 </month> - 
Reference: [Lyl87] <author> J.R. Lyle and M. Weiser. </author> <title> ``Automatic Program Bug Location by Program Slicing'', </title> <booktitle> In Proccedings of the 2nd International Conference on Computers and Applications, </booktitle> <month> June </month> <year> 1987. </year>
Reference-contexts: Furthermore, a number of metrics based on program slicing have been proposed [Wei82] which include coverage, component overlap, functional clustering, parallelism, and tightness. Dicing, a tool based on slicing, can be used to aid in debugging by allowing certain program bugs to be automatically located <ref> [Lyl87] </ref>. Dicing is a powerful heuristic which can further reduce the amount of code upon which the programmer must concentrate. <p> Dicing can therefore be used iteratively to locate a program bug <ref> [Lyl87] </ref>. Another analysis tool called the ripple analyzer can be thought of as a ``forward'' slicer. It finds all statements that are dependent upon a given statement. This tool can be used to visualize the statements that will be affected by a change made at any given statement. <p> These are the same sets of edges followed in slicing, but in the forward direction. Note that in forward slicing, there is no need for the ``short circuit'' operation when following return-control edges. 9. Dicing and Additional Tools Dicing is an automatic bug location heuristic. As proposed in <ref> [Lyl87] </ref>, a slice is generated from an incorrectly computed variable at a particular statement. If there exists another variable that is computed correctly, then the dicing heuristic may be employed.
Reference: [Ott84] <author> K.J. Ottenstein and L.M. Ottenstein. </author> <title> ``The Program Dependence Graph in a Software Development Environment'', </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Pittsburgh, </booktitle> <address> Pa., </address> <month> April 23-25, </month> <year> 1984). </year> <journal> ACM SIGPLAN Notices 19,5, </journal> <month> May </month> <year> 1984. </year>
Reference-contexts: Additionally, ripple analysis may help the maintainer estimate the time and resources needed to effect a change in a program based on the size and/or configuration of the resultant ripple. Weiser's slicer was based on a flow-graph representation of Simple_D programs. Otten-stein et al <ref> [Ott84] </ref>, showed that an intraprocedural slice could be found in linear time by traversing a suitable graph representation of the program which they referred to as the program dependence graph (PDG).
Reference: [Par86] <editor> G. Parikh. </editor> <booktitle> ``Handbook of Software Maintenance'', </booktitle> <publisher> Wiley-Interscience, </publisher> <address> New York, New York 1986. </address> <institution> Report, Software Engineering Research Center, SERC-TR-55-F, </institution> <month> December </month> <year> 1991. </year>
Reference: [Reps88] <author> T. Reps and W. Yang. </author> <title> ``The Semantics of Program Slicing'', </title> <institution> TR-777, Computer Sciences Dept., University of Wisconsin, Madison, </institution> <month> June </month> <year> 1988. </year>
Reference: [Reps89] <author> T. Reps and T. Bricker. </author> <title> ``Illustrating Interference in Interfering Versions of Programs'', </title> <institution> TR-827, Computer Sciences Dept., University of Wisconsin, Madison, </institution> <month> March </month> <year> 1989. </year>
Reference: [Wei81] <author> M. Weiser. </author> <title> ``Program Slicing'', </title> <booktitle> In Proceedings of the Fifth International Conference on Software Engineering, </booktitle> <address> San Diego, CA, </address> <month> March </month> <year> 1981. </year>
Reference: [Wei82] <author> M. Weiser. </author> <title> ``Programmers Use Slices When Debugging'', </title> <note> CACM July 1982. </note>
Reference-contexts: This definition is less general than the one given in <ref> [Wei82] </ref>; but, it is sufficient [Hor90]. <p> Furthermore, a number of metrics based on program slicing have been proposed <ref> [Wei82] </ref> which include coverage, component overlap, functional clustering, parallelism, and tightness. Dicing, a tool based on slicing, can be used to aid in debugging by allowing certain program bugs to be automatically located [Lyl87].
Reference: [Wei84] <author> M. Weiser. </author> <title> ``Program Slicing, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> July </month> <year> 1984. </year>
Reference-contexts: Correspondingly, the descend only tool allows the maintainer to limit the slice to only the function selected and the functions called by the selected function. This operation corresponds to slicing phase two only. Show definitions displays all the definitions of a particular variable. 10. Related Work Weiser <ref> [Wei84] </ref> has built slicers for FORTRAN and an abstract data language called Simple-D. His slices were based on flow-graph representation of programs. As far as we know, no operational slicers for C have been built.
Reference: [Yang89] <author> W. Yang, S. Horwitz, and T. Reps. </author> <title> ``Detecting Program Components With Equivalent Behaviors'', </title> <institution> TR-840, Computer Sciences Dept., University of Wisconsin, Madison, </institution> <month> June </month> <year> 1989. </year>
References-found: 26

