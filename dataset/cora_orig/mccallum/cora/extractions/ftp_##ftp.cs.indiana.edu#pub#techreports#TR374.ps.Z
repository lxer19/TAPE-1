URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR374.ps.Z
Refering-URL: http://www.cs.indiana.edu/ftp/techreports/index.html
Root-URL: http://www.cs.indiana.edu
Email: e-mail: saxton@cs.uregina.ca  email: vgucht,gandhim@cs.indiana.edu  
Title: Universal Queries for Relational Query Languages  
Author: Lawrence V. Saxton Dirk Van Gucht and Munish Gandhi 
Address: Regina, SK S4S 0A2, Canada  Bloomington Indiana 47405  
Affiliation: Department of Computer Science University of Regina  Computer Science Department Indiana University  
Abstract-found: 0
Intro-found: 1
Reference: <author> Abiteboul, S. and Beeri, C. </author> <year> (1988), </year> <title> On the power of languages for the manipulation of complex objects. </title> <type> Technical report, </type> <institution> INRIA, </institution> <year> 1988. </year>
Reference-contexts: These limitations of first-order query languages led to the addition of limited forms of recursion into query languages. Examples of such query languages are the fixpoint queries (Aho79, Chandra82, Immerman86, Vardi82) logic programming query languages <ref> (Abiteboul-Vianu88, Abiteboul-Vianu90, Bancilhon86, Chandra85, Ull-man88) </ref>, and query languages with simple programming constructs (Abiteboul-Vianu90, Aho79, Chandra80, Chandra82). Parallel to these efforts was the introduction of language-independent characteristics for query languages. <p> Notable among these are the by now accepted requirements for query languages to be 1) generic (or symmetry preserving), 2) domain preserving (or safe) and 3) typed. Furthermore, efficiency considerations led to the formal study of time and space complexity of such languages <ref> (Abiteboul-Vianu88,Abiteboul-Vianu90,Chandra82,Immerman86,Vardi82) </ref>. The requirements of more complex database applications sparked the research into data models and query languages with higher-order objects (Abiteboul et.al.89, Abiteboul-Kanellakis90, Gyssens88, Hull88, Hull89, Jaeschke82, Roth88, Thomas85). It was shown that most of the flat relational query languages could be naturally extended to these more complex data objects. <p> There were however some fundamental differences. Two notable results are 1) whereas flat relational query languages can be organized with respect to their expressive power into a strict lattice, in the world of complex objects this lattice partially collapses <ref> (Abiteboul-Beeri88, Gyssens88) </ref> and 2) without special restrictions, the time and space complexity of these languages can increase dramatically (Hull88, Hull89, Kuper88). A less explicitly stated, but nevertheless fruitful and insightful research direction consisted of the study of query language features resembling those of general purpose programming languages. <p> The best-known results of this kind came from the observation that many query languages often already have either implicitly or explicitly programming constructs such as variables, assignment statements, if-then statements, compound-statements, and sometimes while-statements <ref> (Abiteboul-Vianu88, Abiteboul-Vianu90, Aho79, Chandra80, Chandra82, Gyssens88, VandenBussche93) </ref>. The most extensive and recent example occurs in (Vanden 3 Bussche93) where the reflection construct is added to relational algebra. <p> The query u 1 will be shown to be a for-loop query with typed nested relation variables of set-height two (which is therefore also equivalent to a pow-erset algebra and a nested calculus query of set-height two <ref> (Abiteboul-Beeri88, Gyssens88, Hull88) </ref>. The query u 2 will be shown to be a while-loop query with typed nested relation variables of set-height two. By a result in (Gyssens88) this query can also be written as an (extended) powerset algebra query of set-height two. <p> We believe that the existence of universal queries offers yet another technique in the 1 Similar result are known for datalog (Chandra80) the while-loop queries with typed flat relation variables <ref> (Abiteboul-Vianu88) </ref> and the while-loop queries with typed nested relation variables (Gyssens91) 4 measurement of the relative expressiveness of query languages. The paper is organized as follows. In Section 2 we give the definition of nested relations and databases. <p> However, this mapping need not be domain preserving. We therefore also consider the notion of domain preserving calculus queries, and we will call the nested calculus the set of domain preserving calculus queries. A fundamental result in the theory of nested relation query languages is: Theorem 1 <ref> (Abiteboul-Beeri88) </ref> The powerset algebra and the nested calculus are equivalent. 8 &lt;query&gt; ! &lt;constant&gt; fl &lt;statement&gt; fl &lt;final-statement&gt; &lt;constant&gt; ! &lt;typed-relation-name&gt;" "(&lt;constant-relation&gt; j &lt;typed-relation-name&gt;)";" &lt;statement&gt; ! &lt;statement-number&gt; (&lt;assignment-statement&gt; j &lt;if-statement&gt; j &lt;loop-statement&gt; j &lt;compound-statement&gt;) &lt;assignment-statement&gt; ! &lt;typed-relation-variable&gt;" "&lt;subquery&gt;";" &lt;if-statement&gt; ! "if"&lt;boolean-expression&gt;"then&lt;statement&gt; &lt;loop-statement&gt; ! &lt;while-statement&gt; j &lt;for-loop&gt; &lt;while-statement&gt; ! "while"&lt;boolean-expression&gt;&lt;statement&gt; &lt;for-loop&gt; ! <p> Clearly, we can't expect such strong properties for the query languages we introduced in the previous section. In fact, to show such strong properties, we would need query languages that can express all computable queries <ref> (Abiteboul88,Chandra80) </ref>. We will however show that even in the context of these much weaker languages, there is the notion of interpreting a query language by a query in another query language. To show this, we will prove the existence of universal queries for various query languages. <p> consideration. 8 This syntactic restriction does not decrease the expressive power since the following results holds. 8 This normal form is closely related to the Kleene normal form of (partial) recursive functions which states that in its formulation a single application of the minimization operator suffices (Kleene52). 20 Theorem 5 <ref> (Abiteboul-Vianu88) </ref> The set of flat while-loop queries and the set of flat while--loop queries containing at most one loop-statement are equivalent. 9 More precisely, we will specify a flat database encoding f de, a flat while-loop query encoding f wqe, and a while-loop query u (F W LQ;W LQ) such that
Reference: <author> Abiteboul, S., Beeri, C., Gyssens, M., and Van Gucht, D. </author> <year> (1989), </year> <title> An introduction to the completeness of languages for complex objects and nested relations. </title> <editor> In S. Abiteboul and H.J. Schek, editors, </editor> <title> Nested Relations and Complex Objects, </title> <publisher> LNCS 361, </publisher> <pages> pages 117-138. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Furthermore, efficiency considerations led to the formal study of time and space complexity of such languages (Abiteboul-Vianu88,Abiteboul-Vianu90,Chandra82,Immerman86,Vardi82). The requirements of more complex database applications sparked the research into data models and query languages with higher-order objects <ref> (Abiteboul et.al.89, Abiteboul-Kanellakis90, Gyssens88, Hull88, Hull89, Jaeschke82, Roth88, Thomas85) </ref>. It was shown that most of the flat relational query languages could be naturally extended to these more complex data objects. Furthermore, many of the properties established for the flat query languages remained valid in this context.
Reference: <author> Abiteboul, S. and Kanellakis, P. </author> <year> (1990), </year> <title> Database theory column: Query languages for complex object databases. </title> <journal> SIGACT News, </journal> <volume> 76 </volume> <pages> 9-18, </pages> <year> 1990. </year>
Reference-contexts: These limitations of first-order query languages led to the addition of limited forms of recursion into query languages. Examples of such query languages are the fixpoint queries (Aho79, Chandra82, Immerman86, Vardi82) logic programming query languages (Abiteboul-Vianu88, Abiteboul-Vianu90, Bancilhon86, Chandra85, Ull-man88), and query languages with simple programming constructs <ref> (Abiteboul-Vianu90, Aho79, Chandra80, Chandra82) </ref>. Parallel to these efforts was the introduction of language-independent characteristics for query languages. Notable among these are the by now accepted requirements for query languages to be 1) generic (or symmetry preserving), 2) domain preserving (or safe) and 3) typed.
Reference: <author> Abiteboul, S. and Vianu, V. </author> <year> (1988), </year> <title> Datalog extensions for database queries and updates. </title> <type> Technical Report INRIA-900, </type> <institution> INRIA, </institution> <year> 1988. </year>
Reference-contexts: These limitations of first-order query languages led to the addition of limited forms of recursion into query languages. Examples of such query languages are the fixpoint queries (Aho79, Chandra82, Immerman86, Vardi82) logic programming query languages <ref> (Abiteboul-Vianu88, Abiteboul-Vianu90, Bancilhon86, Chandra85, Ull-man88) </ref>, and query languages with simple programming constructs (Abiteboul-Vianu90, Aho79, Chandra80, Chandra82). Parallel to these efforts was the introduction of language-independent characteristics for query languages. <p> Notable among these are the by now accepted requirements for query languages to be 1) generic (or symmetry preserving), 2) domain preserving (or safe) and 3) typed. Furthermore, efficiency considerations led to the formal study of time and space complexity of such languages <ref> (Abiteboul-Vianu88,Abiteboul-Vianu90,Chandra82,Immerman86,Vardi82) </ref>. The requirements of more complex database applications sparked the research into data models and query languages with higher-order objects (Abiteboul et.al.89, Abiteboul-Kanellakis90, Gyssens88, Hull88, Hull89, Jaeschke82, Roth88, Thomas85). It was shown that most of the flat relational query languages could be naturally extended to these more complex data objects. <p> There were however some fundamental differences. Two notable results are 1) whereas flat relational query languages can be organized with respect to their expressive power into a strict lattice, in the world of complex objects this lattice partially collapses <ref> (Abiteboul-Beeri88, Gyssens88) </ref> and 2) without special restrictions, the time and space complexity of these languages can increase dramatically (Hull88, Hull89, Kuper88). A less explicitly stated, but nevertheless fruitful and insightful research direction consisted of the study of query language features resembling those of general purpose programming languages. <p> The best-known results of this kind came from the observation that many query languages often already have either implicitly or explicitly programming constructs such as variables, assignment statements, if-then statements, compound-statements, and sometimes while-statements <ref> (Abiteboul-Vianu88, Abiteboul-Vianu90, Aho79, Chandra80, Chandra82, Gyssens88, VandenBussche93) </ref>. The most extensive and recent example occurs in (Vanden 3 Bussche93) where the reflection construct is added to relational algebra. <p> The query u 1 will be shown to be a for-loop query with typed nested relation variables of set-height two (which is therefore also equivalent to a pow-erset algebra and a nested calculus query of set-height two <ref> (Abiteboul-Beeri88, Gyssens88, Hull88) </ref>. The query u 2 will be shown to be a while-loop query with typed nested relation variables of set-height two. By a result in (Gyssens88) this query can also be written as an (extended) powerset algebra query of set-height two. <p> We believe that the existence of universal queries offers yet another technique in the 1 Similar result are known for datalog (Chandra80) the while-loop queries with typed flat relation variables <ref> (Abiteboul-Vianu88) </ref> and the while-loop queries with typed nested relation variables (Gyssens91) 4 measurement of the relative expressiveness of query languages. The paper is organized as follows. In Section 2 we give the definition of nested relations and databases. <p> However, this mapping need not be domain preserving. We therefore also consider the notion of domain preserving calculus queries, and we will call the nested calculus the set of domain preserving calculus queries. A fundamental result in the theory of nested relation query languages is: Theorem 1 <ref> (Abiteboul-Beeri88) </ref> The powerset algebra and the nested calculus are equivalent. 8 &lt;query&gt; ! &lt;constant&gt; fl &lt;statement&gt; fl &lt;final-statement&gt; &lt;constant&gt; ! &lt;typed-relation-name&gt;" "(&lt;constant-relation&gt; j &lt;typed-relation-name&gt;)";" &lt;statement&gt; ! &lt;statement-number&gt; (&lt;assignment-statement&gt; j &lt;if-statement&gt; j &lt;loop-statement&gt; j &lt;compound-statement&gt;) &lt;assignment-statement&gt; ! &lt;typed-relation-variable&gt;" "&lt;subquery&gt;";" &lt;if-statement&gt; ! "if"&lt;boolean-expression&gt;"then&lt;statement&gt; &lt;loop-statement&gt; ! &lt;while-statement&gt; j &lt;for-loop&gt; &lt;while-statement&gt; ! "while"&lt;boolean-expression&gt;&lt;statement&gt; &lt;for-loop&gt; ! <p> Clearly, we can't expect such strong properties for the query languages we introduced in the previous section. In fact, to show such strong properties, we would need query languages that can express all computable queries <ref> (Abiteboul88,Chandra80) </ref>. We will however show that even in the context of these much weaker languages, there is the notion of interpreting a query language by a query in another query language. To show this, we will prove the existence of universal queries for various query languages. <p> consideration. 8 This syntactic restriction does not decrease the expressive power since the following results holds. 8 This normal form is closely related to the Kleene normal form of (partial) recursive functions which states that in its formulation a single application of the minimization operator suffices (Kleene52). 20 Theorem 5 <ref> (Abiteboul-Vianu88) </ref> The set of flat while-loop queries and the set of flat while--loop queries containing at most one loop-statement are equivalent. 9 More precisely, we will specify a flat database encoding f de, a flat while-loop query encoding f wqe, and a while-loop query u (F W LQ;W LQ) such that
Reference: <author> Abiteboul, S. and Vianu, V. </author> <year> (1990), </year> <title> Procedural and declarative database update languages. </title> <journal> JCSS, </journal> <volume> 41 </volume> <pages> 181-229, </pages> <year> 1990. </year>
Reference-contexts: These limitations of first-order query languages led to the addition of limited forms of recursion into query languages. Examples of such query languages are the fixpoint queries (Aho79, Chandra82, Immerman86, Vardi82) logic programming query languages (Abiteboul-Vianu88, Abiteboul-Vianu90, Bancilhon86, Chandra85, Ull-man88), and query languages with simple programming constructs <ref> (Abiteboul-Vianu90, Aho79, Chandra80, Chandra82) </ref>. Parallel to these efforts was the introduction of language-independent characteristics for query languages. Notable among these are the by now accepted requirements for query languages to be 1) generic (or symmetry preserving), 2) domain preserving (or safe) and 3) typed.
Reference: <author> Aho, A.V. and Ullman, J.D. </author> <year> (1979), </year> <title> Universality of data retrieval languages. </title> <booktitle> In Proc. of 6th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 110-117, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction The theoretical study of query languages began with Codd's introduction of the relational algebra and calculus for flat relational databases (Codd72). It was however quickly realized and formally established that many natural queries could not be formulated in these languages <ref> (Aho79) </ref>. These limitations of first-order query languages led to the addition of limited forms of recursion into query languages. <p> It was however quickly realized and formally established that many natural queries could not be formulated in these languages (Aho79). These limitations of first-order query languages led to the addition of limited forms of recursion into query languages. Examples of such query languages are the fixpoint queries <ref> (Aho79, Chandra82, Immerman86, Vardi82) </ref> logic programming query languages (Abiteboul-Vianu88, Abiteboul-Vianu90, Bancilhon86, Chandra85, Ull-man88), and query languages with simple programming constructs (Abiteboul-Vianu90, Aho79, Chandra80, Chandra82). Parallel to these efforts was the introduction of language-independent characteristics for query languages.
Reference: <author> Bancilhon, F. and Ramakrishnan, R. </author> <year> (1986), </year> <title> An amateur's introduction to recursive query-processing strategies. </title> <booktitle> In Proceedings of ACM-SIGMOD '86 International Conference on Management of Data, </booktitle> <address> Washington, D.C., </address> <pages> pages 16-52, </pages> <year> 1986. </year>
Reference: <author> Beeri, C. and Kornatzky, Y. </author> <year> (1990), </year> <title> The many faces of query monotonicity. </title> <booktitle> In Proc. of Advances in Database Technology-EDBT '90, </booktitle> <pages> pages 120-135, </pages> <year> 1990. </year>
Reference-contexts: In Section 5 we discuss the existence of universal queries for other query languages. 2 Basic Definitions Since nested relations are more general than flat relations, we will state our definitions in terms of nested relations. Our definitions are based on <ref> (Beeri90, Gyssens88) </ref>. 2.1 Nested Relations Assume an infinitely enumerable set U of elementary attributes. Attributes are either elementary or composite, where a composite attribute is a set of elementary or composite attributes.
Reference: <author> Chandra, A. </author> <year> (1988), </year> <title> Theory of database queries. </title> <booktitle> In Proceedings of the Seventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, Austin, </booktitle> <pages> pages 1-9, </pages> <year> 1988. </year>
Reference-contexts: These limitations of first-order query languages led to the addition of limited forms of recursion into query languages. Examples of such query languages are the fixpoint queries (Aho79, Chandra82, Immerman86, Vardi82) logic programming query languages <ref> (Abiteboul-Vianu88, Abiteboul-Vianu90, Bancilhon86, Chandra85, Ull-man88) </ref>, and query languages with simple programming constructs (Abiteboul-Vianu90, Aho79, Chandra80, Chandra82). Parallel to these efforts was the introduction of language-independent characteristics for query languages. <p> Notable among these are the by now accepted requirements for query languages to be 1) generic (or symmetry preserving), 2) domain preserving (or safe) and 3) typed. Furthermore, efficiency considerations led to the formal study of time and space complexity of such languages <ref> (Abiteboul-Vianu88,Abiteboul-Vianu90,Chandra82,Immerman86,Vardi82) </ref>. The requirements of more complex database applications sparked the research into data models and query languages with higher-order objects (Abiteboul et.al.89, Abiteboul-Kanellakis90, Gyssens88, Hull88, Hull89, Jaeschke82, Roth88, Thomas85). It was shown that most of the flat relational query languages could be naturally extended to these more complex data objects. <p> The best-known results of this kind came from the observation that many query languages often already have either implicitly or explicitly programming constructs such as variables, assignment statements, if-then statements, compound-statements, and sometimes while-statements <ref> (Abiteboul-Vianu88, Abiteboul-Vianu90, Aho79, Chandra80, Chandra82, Gyssens88, VandenBussche93) </ref>. The most extensive and recent example occurs in (Vanden 3 Bussche93) where the reflection construct is added to relational algebra. <p> &lt;sub-query&gt; ! &lt;powerset-algebra-query&gt; j &lt;nested-calculus-query&gt; &lt;boolean-expression&gt; ! &lt;typed-relation-variable&gt;&lt;comparison-operator&gt; (&lt;typed-relation-constant&gt; j &lt;typed-relation-variable&gt;) &lt;comparison-operator&gt; ! "="j"6="j"" &lt;final-statement&gt; ! "Result" " " &lt;sub-query&gt;"." 3.3 Query languages with programming constructs To add expressiveness to the flat relational algebra and calculus, several extensions to these query languages have been introduced (for an excellent survey, see <ref> (Chandra88) </ref>). In particular, Chandra and Harel introduced a (typed) query language which incorporate the standard features of an imperative programming language (Chandra80), i.e. typed relation variables and constants, (correctly typed) assignment statements, if-then statements, loop statements, and compound statements 3 . <p> With this extension, the following result holds. Theorem 3 (Gyssens88) The extended powerset algebra and the while-loop query language are equivalent. 4 It should be noted that a similar result does not hold for flat relational query languages <ref> (Chandra88) </ref>. 10 4 Universal queries One of the main properties of general purpose programming languages is their ability to interpret other programming languages. This observation of course dates back to Turing's proof about the existence of Universal Turing Machines (Turing37). <p> Clearly, we can't expect such strong properties for the query languages we introduced in the previous section. In fact, to show such strong properties, we would need query languages that can express all computable queries <ref> (Abiteboul88,Chandra80) </ref>. We will however show that even in the context of these much weaker languages, there is the notion of interpreting a query language by a query in another query language. To show this, we will prove the existence of universal queries for various query languages.
Reference: <author> Chandra, A. and Harel, D. </author> <year> (1980), </year> <title> Computable queries for relational data bases. </title> <journal> JCSS, </journal> <volume> 21 </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: We believe that the existence of universal queries offers yet another technique in the 1 Similar result are known for datalog <ref> (Chandra80) </ref> the while-loop queries with typed flat relation variables (Abiteboul-Vianu88) and the while-loop queries with typed nested relation variables (Gyssens91) 4 measurement of the relative expressiveness of query languages. The paper is organized as follows. In Section 2 we give the definition of nested relations and databases. <p> In particular, for relational databases we will consider the flat relational algebra, the flat relational calculus (Codd72). and the while-loop and for-loop queries with typed flat relation variables <ref> (Chandra80) </ref>. <p> In particular, Chandra and Harel introduced a (typed) query language which incorporate the standard features of an imperative programming language <ref> (Chandra80) </ref>, i.e. typed relation variables and constants, (correctly typed) assignment statements, if-then statements, loop statements, and compound statements 3 . Similar extensions for nested relational query languages were introduced in (Gyssens88). The precise syntax for these queries is shown in Figure 3.3. <p> Since while-loop queries in general define partial functions, we also consider the subset of total while-loop queries. 3 Chandra and Harel also introduced an untyped version of this language. This untyped language is considerably more expressive than the corresponding typed one. In fact, in <ref> (Chandra80) </ref> it is shown that the untyped language can express all computable flat relational queries! 9 As an example, assume that = [R : fA; Bg] is a (flat) relational database scheme.
Reference: <author> Chandra, A. and Harel, D. </author> <year> (1982), </year> <title> Structure and complexity of relational queries. </title> <journal> JCSS, </journal> <volume> 25 </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: The encoding of this query is shown in 1. The statements 2, 3 and 8 in the program, i.e. 9 It turns out that there are variants of this theorem for datalog <ref> (Chandra82) </ref>, the least fixed point queries (Immerman86,Leivant89) and the nested while-loop queries (Gyssens91). 10 We will make the additional assumption that the boolean expression controlling this while-loop is of the form R 1 R 2 (with either =, 6=, or )where R 1 and R 2 are composite attribute names, but
Reference: <author> Chandra, A. and Harel, D. </author> <year> (1985), </year> <title> Horn clause queries and generalizations. </title> <journal> J. of Logic 28 Programming, </journal> <volume> 1 </volume> <pages> 1-15, </pages> <year> 1985. </year>
Reference: <author> Codd, E.F. </author> <title> (1972) Relational completeness of database sublanguages. </title> <editor> In R. Rustin, editor, </editor> <booktitle> Database Systems. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, </address> <year> 1972. </year>
Reference-contexts: 1 Introduction The theoretical study of query languages began with Codd's introduction of the relational algebra and calculus for flat relational databases <ref> (Codd72) </ref>. It was however quickly realized and formally established that many natural queries could not be formulated in these languages (Aho79). These limitations of first-order query languages led to the addition of limited forms of recursion into query languages. <p> In particular, for relational databases we will consider the flat relational algebra, the flat relational calculus <ref> (Codd72) </ref>. and the while-loop and for-loop queries with typed flat relation variables (Chandra80).
Reference: <author> Gyssens, M. and Van Gucht, D. </author> <year> (1991), </year> <title> A Comparison between Algebraic Query Languages for Flat and Nested Databases, </title> <booktitle> Theoretical Computer Science, 87 (1991), </booktitle> <pages> pp. 263-286. </pages>
Reference-contexts: We believe that the existence of universal queries offers yet another technique in the 1 Similar result are known for datalog (Chandra80) the while-loop queries with typed flat relation variables (Abiteboul-Vianu88) and the while-loop queries with typed nested relation variables <ref> (Gyssens91) </ref> 4 measurement of the relative expressiveness of query languages. The paper is organized as follows. In Section 2 we give the definition of nested relations and databases. In Section 3 we describe the various query languages we will deal with in this paper. <p> The encoding of this query is shown in 1. The statements 2, 3 and 8 in the program, i.e. 9 It turns out that there are variants of this theorem for datalog (Chandra82), the least fixed point queries (Immerman86,Leivant89) and the nested while-loop queries <ref> (Gyssens91) </ref>. 10 We will make the additional assumption that the boolean expression controlling this while-loop is of the form R 1 R 2 (with either =, 6=, or )where R 1 and R 2 are composite attribute names, but not constants.
Reference: <author> Gyssens, M. and Van Gucht, D. </author> <year> (1988), </year> <title> The powerset algebra as a result of adding programming constructs to the nested relation algebra. </title> <booktitle> In Proceedings of ACM-SIGMOD 1988 Annual Conference, </booktitle> <publisher> Chicago, </publisher> <pages> pages 225-232, </pages> <year> 1988. </year>
Reference-contexts: There were however some fundamental differences. Two notable results are 1) whereas flat relational query languages can be organized with respect to their expressive power into a strict lattice, in the world of complex objects this lattice partially collapses <ref> (Abiteboul-Beeri88, Gyssens88) </ref> and 2) without special restrictions, the time and space complexity of these languages can increase dramatically (Hull88, Hull89, Kuper88). A less explicitly stated, but nevertheless fruitful and insightful research direction consisted of the study of query language features resembling those of general purpose programming languages. <p> The best-known results of this kind came from the observation that many query languages often already have either implicitly or explicitly programming constructs such as variables, assignment statements, if-then statements, compound-statements, and sometimes while-statements <ref> (Abiteboul-Vianu88, Abiteboul-Vianu90, Aho79, Chandra80, Chandra82, Gyssens88, VandenBussche93) </ref>. The most extensive and recent example occurs in (Vanden 3 Bussche93) where the reflection construct is added to relational algebra. <p> The query u 1 will be shown to be a for-loop query with typed nested relation variables of set-height two (which is therefore also equivalent to a pow-erset algebra and a nested calculus query of set-height two <ref> (Abiteboul-Beeri88, Gyssens88, Hull88) </ref>. The query u 2 will be shown to be a while-loop query with typed nested relation variables of set-height two. By a result in (Gyssens88) this query can also be written as an (extended) powerset algebra query of set-height two. <p> The query u 2 will be shown to be a while-loop query with typed nested relation variables of set-height two. By a result in <ref> (Gyssens88) </ref> this query can also be written as an (extended) powerset algebra query of set-height two. <p> Similar extensions for nested relational query languages were introduced in <ref> (Gyssens88) </ref>. The precise syntax for these queries is shown in Figure 3.3. The set of queries satisfying the syntax of Figure 3.3 will be called the while-loop query language. The subset of queries in which no while-statement occurs will be called the for-loop query language. <p> The following result relates the various nested relational query languages. Theorem 2 <ref> (Gyssens88) </ref> The powerset algebra (and therefore, by Theorem 1, also the nested calculus), the total while-loop query language and the for-loop query language are equivalent 4 . <p> To take into account that while-loop queries are in general only partial functions, the powerset algebra is extended with an operator which when applied to the empty set yields an undefined result. With this extension, the following result holds. Theorem 3 <ref> (Gyssens88) </ref> The extended powerset algebra and the while-loop query language are equivalent. 4 It should be noted that a similar result does not hold for flat relational query languages (Chandra88). 10 4 Universal queries One of the main properties of general purpose programming languages is their ability to interpret other programming
Reference: <author> Hennie, F. </author> <year> (1977), </year> <title> Introduction to computability. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1977. </year>
Reference-contexts: ; m n , one has that u n+1 (e (f ); m 1 ; : : : ; m n ) = f (m 1 ; : : : ; m n ), where e (f ) denotes the natural number corresponding to the encoding of f (see e.g. <ref> (Hennie77,Kleene52) </ref>). Clearly, we can't expect such strong properties for the query languages we introduced in the previous section. In fact, to show such strong properties, we would need query languages that can express all computable queries (Abiteboul88,Chandra80).
Reference: <author> Hull, R. and Su, J. </author> <year> (1988), </year> <title> On the expressive power of database queries with intermediate types. </title> <booktitle> In Proc. of 7th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 39-51, </pages> <year> 1988. </year>
Reference-contexts: notable results are 1) whereas flat relational query languages can be organized with respect to their expressive power into a strict lattice, in the world of complex objects this lattice partially collapses (Abiteboul-Beeri88, Gyssens88) and 2) without special restrictions, the time and space complexity of these languages can increase dramatically <ref> (Hull88, Hull89, Kuper88) </ref>. A less explicitly stated, but nevertheless fruitful and insightful research direction consisted of the study of query language features resembling those of general purpose programming languages. <p> The query u 1 will be shown to be a for-loop query with typed nested relation variables of set-height two (which is therefore also equivalent to a pow-erset algebra and a nested calculus query of set-height two <ref> (Abiteboul-Beeri88, Gyssens88, Hull88) </ref>. The query u 2 will be shown to be a while-loop query with typed nested relation variables of set-height two. By a result in (Gyssens88) this query can also be written as an (extended) powerset algebra query of set-height two.
Reference: <author> Hull, R. and Su, J. </author> <year> (1989), </year> <title> Untyped sets, invention, and computable queries. </title> <booktitle> In Proc. of 8th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 347-360, </pages> <year> 1989. </year>
Reference-contexts: Furthermore, efficiency considerations led to the formal study of time and space complexity of such languages (Abiteboul-Vianu88,Abiteboul-Vianu90,Chandra82,Immerman86,Vardi82). The requirements of more complex database applications sparked the research into data models and query languages with higher-order objects <ref> (Abiteboul et.al.89, Abiteboul-Kanellakis90, Gyssens88, Hull88, Hull89, Jaeschke82, Roth88, Thomas85) </ref>. It was shown that most of the flat relational query languages could be naturally extended to these more complex data objects. Furthermore, many of the properties established for the flat query languages remained valid in this context.
Reference: <author> Immerman, N. </author> <year> (1986), </year> <title> Relational queries computable in polynomial time. </title> <journal> Inform. and Comp, </journal> <volume> 68 </volume> <pages> 86-104, </pages> <year> 1986. </year>
Reference-contexts: Probably, lesser--known results came from the observation that many query languages shared with general programming languages the property that their queries could be transformed into equivalent queries in a certain normal form. For example, it was shown by Immerman <ref> (Immerman86) </ref> (see also (Leivant89)) that a fixpoint query can be rewritten into an equivalent fixpoint query in which the least fixpoint constructor appears only once 1 . These results are of course analogous to Kleene-Normal Form of (partial) recursive functions (Kleene52). <p> The encoding of this query is shown in 1. The statements 2, 3 and 8 in the program, i.e. 9 It turns out that there are variants of this theorem for datalog (Chandra82), the least fixed point queries <ref> (Immerman86,Leivant89) </ref> and the nested while-loop queries (Gyssens91). 10 We will make the additional assumption that the boolean expression controlling this while-loop is of the form R 1 R 2 (with either =, 6=, or )where R 1 and R 2 are composite attribute names, but not constants.
Reference: <author> Jaeschke, G.H. and Schek, H.J. </author> <year> (1982), </year> <title> Remarks on the algebra of non first normal form relations. </title> <booktitle> In Proceedings of the First ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 124-138, </pages> <year> 1982. </year>
Reference: <author> Kleene, S.C. </author> <year> (1952). </year> <title> Introduction to metamathematics. </title> <publisher> Amsterdam (North-Holland Pub. Co.), </publisher> <year> 1952. </year>
Reference-contexts: For example, it was shown by Immerman (Immerman86) (see also (Leivant89)) that a fixpoint query can be rewritten into an equivalent fixpoint query in which the least fixpoint constructor appears only once 1 . These results are of course analogous to Kleene-Normal Form of (partial) recursive functions <ref> (Kleene52) </ref>. In view of these results, it appears natural to continue the investigation into the similarities of query languages and general purpose programming languages. <p> flat while-loop query under consideration. 8 This syntactic restriction does not decrease the expressive power since the following results holds. 8 This normal form is closely related to the Kleene normal form of (partial) recursive functions which states that in its formulation a single application of the minimization operator suffices <ref> (Kleene52) </ref>. 20 Theorem 5 (Abiteboul-Vianu88) The set of flat while-loop queries and the set of flat while--loop queries containing at most one loop-statement are equivalent. 9 More precisely, we will specify a flat database encoding f de, a flat while-loop query encoding f wqe, and a while-loop query u (F W
Reference: <author> Kuper, G.M. and Vardi, M.Y. </author> <year> (1984), </year> <title> A new approach to database logic. </title> <booktitle> In Proceedings of 3rd ACM SIGACT-SIGMOD Symposium on Principles of Database Systems, </booktitle> <pages> pages 86-96, </pages> <year> 1984. </year>
Reference: <author> Kuper, G.M. and Vardi, M.Y. </author> <year> (1988), </year> <title> On the complexity of queries in the logical data model. </title> <booktitle> In Proc. of the 2nd International Conference on Database Theory, </booktitle> <pages> pages 267-280, </pages> <year> 1988. </year>
Reference-contexts: notable results are 1) whereas flat relational query languages can be organized with respect to their expressive power into a strict lattice, in the world of complex objects this lattice partially collapses (Abiteboul-Beeri88, Gyssens88) and 2) without special restrictions, the time and space complexity of these languages can increase dramatically <ref> (Hull88, Hull89, Kuper88) </ref>. A less explicitly stated, but nevertheless fruitful and insightful research direction consisted of the study of query language features resembling those of general purpose programming languages.
Reference: <author> Leivant, D. </author> <year> (1989), </year> <title> Inductive definitions over finite structures. </title> <type> Technical Report CMU-CS-89-153, CMU, </type> <year> 1989. </year> <title> 29 Meyer, A.R. and Ritchie, D.M. (1967), The complexity of loop programs. </title> <booktitle> In Proc. of 22nd National Conference, ACM, </booktitle> <pages> pages 465-469, </pages> <year> 1967. </year>
Reference-contexts: Probably, lesser--known results came from the observation that many query languages shared with general programming languages the property that their queries could be transformed into equivalent queries in a certain normal form. For example, it was shown by Immerman (Immerman86) (see also <ref> (Leivant89) </ref>) that a fixpoint query can be rewritten into an equivalent fixpoint query in which the least fixpoint constructor appears only once 1 . These results are of course analogous to Kleene-Normal Form of (partial) recursive functions (Kleene52).
Reference: <author> Roth, M.A., Korth, H.F. and Silberschatz, A. </author> <year> (1988), </year> <title> Extended algebra and calculus for nested relational databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(4) </volume> <pages> 389-419, </pages> <year> 1988. </year>
Reference: <author> Ross, K. </author> <year> (1992), </year> <title> Relations with relation names as arguments: algebra and calculus. </title> <booktitle> In Proceedings of the 11th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 346-353, </pages> <year> 1992. </year>
Reference-contexts: The main results of this paper will be an affirmative answer to the above question. We will first show how a (relational) database instance and a (relational) query in L 1 can be encoded as an unique database instance. This encoding is reminiscent of the approach of Ross, <ref> (Ross92) </ref>, who proposed a model and an algebra where relations can contain relation names. Using these encodings we will show the existence of a universal query u 1 for the flat relational algebra, and a universal query u 2 for the while-loop queries with typed flat relation variables. <p> It is built from two nested relations: the first nested relation, denoted aqe (q 1 ), corresponds to the actual query. The second nested relation, denoted qce (q 1 ) is the encoding of the constant relations occurring in q 1 6 . Ross <ref> (Ross92) </ref> developed a model and an algebra for storing relation names directly into a relation.
Reference: <author> Thomas, S.J. and Fischer, </author> <title> P.C. (1985), Nested relational structures. </title> <editor> In P. C. Kanellakis, editor, </editor> <booktitle> Advances in Computing Research, Volume 3: The Theory of Databases, </booktitle> <pages> pages 269-307. </pages> <publisher> JAI Press, </publisher> <year> 1985. </year>
Reference: <author> Turing, A.M. </author> <year> (1937), </year> <title> On computable numbers, with an application to the Entscheidungsprob-lem. </title> <journal> Proc. London Math. Soc., </journal> <volume> 42 </volume> <pages> 230-265, </pages> <year> 1937. </year>
Reference-contexts: This observation of course dates back to Turing's proof about the existence of Universal Turing Machines <ref> (Turing37) </ref>. Another closely related result to this is the existence of universal (partial) recursive functions.
Reference: <author> Ullman, J.D. </author> <year> (1988), </year> <title> Principles of Database and Knowledge-Base Systems, volume 1. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1988. </year>
Reference: <author> Vardi, M.Y. </author> <title> (1982) Complexity and relational query languages. </title> <booktitle> In Proc. of 14th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 137-146, </pages> <year> 1982. </year>
Reference: <author> Van den Bussche, J., Van Gucht, D. and Vossen, G. </author> <year> (1993), </year> <title> Reflective programming in the relational algebra. </title> <booktitle> In Proceedings of the 12th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <year> 1993. </year> <month> 30 </month>
Reference-contexts: The best-known results of this kind came from the observation that many query languages often already have either implicitly or explicitly programming constructs such as variables, assignment statements, if-then statements, compound-statements, and sometimes while-statements (Abiteboul-Vianu88, Abiteboul-Vianu90, Aho79, Chandra80, Chandra82, Gyssens88, VandenBussche93). The most extensive and recent example occurs in <ref> (Vanden 3 Bussche93) </ref> where the reflection construct is added to relational algebra. Probably, lesser--known results came from the observation that many query languages shared with general programming languages the property that their queries could be transformed into equivalent queries in a certain normal form.
References-found: 31

