URL: http://www.prolangs.rutgers.edu/refs/docs/tr349.ps
Refering-URL: http://www.csd.uu.se/~thomasl/wpo/oo-compilation-papers.html
Root-URL: 
Email: framkrish,ryderg@cs.rutgers.edu  
Phone: Fax: 732 445 0537,  
Title: Modular Concrete Type-inference for Statically Typed Object-oriented Programming Languages  
Author: Ramkrishna Chatterjee Barbara G. Ryder 
Address: Piscataway, NJ 08855 USA,  
Affiliation: Department of Computer Science, Rutgers University,  
Abstract: The problem of concrete type-inference for statically typed object-oriented programming languages (e.g., Java, C ++ ) determines at each program point, those objects to which a reference may refer or a pointer may point during execution. We present a new technique called analysis-using-abstract-values which performs modular and demand-driven concrete type-inference of a robust subset of Java without threads and exceptions and C ++ without exceptions. Our algorithm is provably precise on programs with only single-level types 2 and without dynamic dispatch, and has the worst-case complexity of O(n 4 ) which is an improvement over the O(n 7 ) worst-case bound achievable by applying previous approaches of [RHS95] and [LR91] to this case. For general pro grams, the algorithm is polynomial-time and computes a safe solution.
Abstract-found: 1
Intro-found: 1
Reference: [And94] <author> L. O. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <year> 1994. </year> <note> Also available as DIKU report 94/19. </note>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for the type-inference problem for Java without exceptions and threads or C ++ without exceptions. There are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [BCCH94, Wei80, Ste96b, Ste96a, SH97, ZRL96, And94] </ref>, which are the ? The research reported here was supported, in part, by NSF grant GER-9023628 and the Hewlett-Packard Corporation. 2 types with data members only of primitive type least expensive, but also the most imprecise.
Reference: [Bar78] <author> J. M. Barth. </author> <title> A practical interprocedural data flow analysis algorithm. </title> <journal> Com munications of the ACM, </journal> <volume> 21(9) </volume> <pages> 724-736, </pages> <year> 1978. </year>
Reference-contexts: an object obj identified by its creation site, hRV,obj i belongs to the precise solution at a program point n if and only if RV is visible at n and there exists an execution path from the start-node of the program to n (under the usual assumption of data-flow analysis <ref> [Bar78] </ref>: the result of a test is independent of previous tests and all the branches are possible), such that if this path is followed, RV points to obj at n (i.e. at the top of n). 2.2 Program representation Our algorithm operates on an interprocedural control flow graph or ICFG [LR91].
Reference: [BCCH94] <author> Michael Burke, Paul Carini, Jong-Doek Choi, and Michael Hind. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <booktitle> In Proceedings of the 7th International Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 234-250. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1994. </year>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for the type-inference problem for Java without exceptions and threads or C ++ without exceptions. There are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [BCCH94, Wei80, Ste96b, Ste96a, SH97, ZRL96, And94] </ref>, which are the ? The research reported here was supported, in part, by NSF grant GER-9023628 and the Hewlett-Packard Corporation. 2 types with data members only of primitive type least expensive, but also the most imprecise.
Reference: [BS96] <author> David F. Bacon and Peter F. Sweeney. </author> <title> Fast static analysis of c++ virtual function calls. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <year> 1996. </year>
Reference-contexts: Later in Section 5.11, we will show how to handle recursive types. 5.1 Call graph decomposition The initial call graph used for obtaining strongly connected components is constructed by resolving dynamically dispatched calls using class hierarchy analysis [DMM96] and by considering only instantiated types <ref> [BS96] </ref>. Given a dynamically dispatched call site, the class hierarchy is scanned to find all the methods which override the method which would have been called in the case of static dispatch. This set is then refined by excluding those types which are not instan-tiated in the program as in [BS96]. <p> <ref> [BS96] </ref>. Given a dynamically dispatched call site, the class hierarchy is scanned to find all the methods which override the method which would have been called in the case of static dispatch. This set is then refined by excluding those types which are not instan-tiated in the program as in [BS96]. The resulting set is then used as the set of methods callable from this site. <p> We have completed the implementation of the algorithm for single-level types and the implementation for the general types is in progress. Table 1 contains data about call graph decomposition of 9 C ++ programs obtained from Hemant Pande [PR96], David Bacon <ref> [BS96] </ref> and Ben Zorn [CGZ95]. We used hierarchy analysis for constructing the initial call graphs. Table 1 shows that the call graphs of these programs have a large number of components and the cycles in these call graphs are of small size.
Reference: [CBC93] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference: [CGZ95] <author> B. Calder, D. Grunwald, and B. Zorn. </author> <title> Quantifying behavioural differences between C and C ++ programs. </title> <journal> Journal of Programming Languages, </journal> <volume> 2 </volume> <pages> 313-351, </pages> <year> 1995. </year>
Reference-contexts: We have completed the implementation of the algorithm for single-level types and the implementation for the general types is in progress. Table 1 contains data about call graph decomposition of 9 C ++ programs obtained from Hemant Pande [PR96], David Bacon [BS96] and Ben Zorn <ref> [CGZ95] </ref>. We used hierarchy analysis for constructing the initial call graphs. Table 1 shows that the call graphs of these programs have a large number of components and the cycles in these call graphs are of small size.
Reference: [CLR92] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to algorithms. </title> <publisher> The MIT Press and McGraw-Hill Book Company, </publisher> <year> 1992. </year>
Reference: [CR97] <author> Ramkrishna Chatterjee and Barbara Ryder. </author> <title> Scalable, flow-sensitive type-inference for statically typed object-oriented programming languages. </title> <type> Technical Report DCS-TR-326, </type> <institution> Dept of CS, Rutgers University, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: However, assignments to the fields of abstract values can be killed because for a given call to a method, an abstract value represents the same run-time object at all points in the method. This improves precision over other techniques in many situations <ref> [CR97] </ref>. 5.6 Demand-driven generation of initial (abstract) values In Phase I of the single-level algorithm, the worklist is initialized with the initial values of all parameters and globals at all the entry-nodes of all the methods contained in a SCC. <p> Details of this are given in <ref> [CR97] </ref>. 5.8 process exit node case. instantiate is similar to instantiate-abstract-values in Figure 8. If rdf-elm represents the value returned by M, instantiate uses the result-variable of c-node as the var for the generated points-tos.
Reference: [CRL97] <author> Ramkrishna Chatterjee, Barbara Ryder, and William Landi. </author> <title> Complexity of concrete type-inference in the presence of exceptions. </title> <type> Technical Report DCS-TR-341, </type> <institution> Dept of CS, Rutgers University, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: of Java and C ++4 ; - (Sections 4.3 and 4.4) a proof that this technique computes the precise solution for programs with only single-level types and without dynamic dispatch, and has the worst-case complexity of O (n 4 ) which improves upon the O (n 7 ) 3 In <ref> [CRL97] </ref>, we show how to do concrete type-inference in the presence of exceptions. 4 In this paper, we present our algorithm only for Java. worst-case bound achievable by applying previous techniques of [RHS95] and [LR91] to this case; - (Section 6) a new method for demand-driven computation using analysis using-abstract-values; and <p> Call graph decomposition and without dynamic dispatch (the only known natural polynomial-time solvable special case <ref> [LR91, PR96, CRL97] </ref>, if exceptions and threads are excluded). Related work of the second kind include [DGS95] and [HRS95]. In both of these, each data-flow element is treated uniformly and computed from scratch on demand, although later queries may be answered more efficiently because of caching.
Reference: [Deu94] <author> A. Deutsch. </author> <title> Interprocedural may alias for pointers: Beyond k-limiting. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <month> June </month> <year> 1994. </year>
Reference: [DGS95] <author> Evelyn Duesterwald, Rajiv Gupta, and Mary Lou Soffa. </author> <title> Demand-driven computation of interprocedural data flow. </title> <booktitle> In Proceedings of the ACM SIG-PLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <month> Jan-uary </month> <year> 1995. </year>
Reference-contexts: Call graph decomposition and without dynamic dispatch (the only known natural polynomial-time solvable special case [LR91, PR96, CRL97], if exceptions and threads are excluded). Related work of the second kind include <ref> [DGS95] </ref> and [HRS95]. In both of these, each data-flow element is treated uniformly and computed from scratch on demand, although later queries may be answered more efficiently because of caching. <p> Phase I, phase II, the construction of the DemandTable and the computation of methods reachable from a method can be seen as preprocessing, which helps in answering queries on demand quickly without data-flow analysis. In addition, analysis-using-abstract-values combines demand-driven computation with modular analysis. Nevertheless, <ref> [DGS95] </ref> and [HRS95] are demand-analysis frameworks for general data-flow problems, whereas we are restricting our attention to concrete type-inference.
Reference: [DMM96] <author> Amer Diwan, J.Eliot B. Moss, and Kathryn S. McKinley. </author> <title> Simple and effective analysis of statically-typed object-oriented programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <year> 1996. </year>
Reference-contexts: First we consider non-recursive general types. Later in Section 5.11, we will show how to handle recursive types. 5.1 Call graph decomposition The initial call graph used for obtaining strongly connected components is constructed by resolving dynamically dispatched calls using class hierarchy analysis <ref> [DMM96] </ref> and by considering only instantiated types [BS96]. Given a dynamically dispatched call site, the class hierarchy is scanned to find all the methods which override the method which would have been called in the case of static dispatch.
Reference: [EGH94] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming language design and implementation, </booktitle> <pages> pages 242-256, </pages> <year> 1994. </year>
Reference: [GDDC97] <author> D. Grove, G. DeFouw, J. Dean, and C. Chambers. </author> <title> Call graph construction in object-oriented languages. </title> <booktitle> In Proceedings of Conference on Object-Oriented Programming Systems, Languages, and Applications (OOP SLA '97), </booktitle> <pages> pages 108-124, </pages> <month> October </month> <year> 1997. </year>
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Our algorithm cannot handle such classes which are not known statically. 2.4 Single-level type Definition 1 A single-level type is one of the following: A primitive type defined in <ref> [GJS96] </ref>. For example, int, float etc. A class whose all non-static data-members have primitive types. For example, class A f int i,j; g.
Reference: [HRS95] <author> S. Horwitz, T. Reps, and M. Sagiv. </author> <title> Demand interprocedural dataflow analysis. </title> <booktitle> In Proceedings of the Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 104-115, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Call graph decomposition and without dynamic dispatch (the only known natural polynomial-time solvable special case [LR91, PR96, CRL97], if exceptions and threads are excluded). Related work of the second kind include [DGS95] and <ref> [HRS95] </ref>. In both of these, each data-flow element is treated uniformly and computed from scratch on demand, although later queries may be answered more efficiently because of caching. <p> Phase I, phase II, the construction of the DemandTable and the computation of methods reachable from a method can be seen as preprocessing, which helps in answering queries on demand quickly without data-flow analysis. In addition, analysis-using-abstract-values combines demand-driven computation with modular analysis. Nevertheless, [DGS95] and <ref> [HRS95] </ref> are demand-analysis frameworks for general data-flow problems, whereas we are restricting our attention to concrete type-inference.
Reference: [JM82] <author> N. D. Jones and S. Muchnick. </author> <title> Flow analysis and optimization of lisp-like structures. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 102-131. </pages> <year> 1982. </year>
Reference-contexts: But the algorithm as presented may generate an exponential number of abstract initial values. This can be easily avoided by enforcing a bound on the length of abstract initial values (analogous to k-limiting <ref> [JM82] </ref>). All initial values of the same type having lengths greater than this bound will be considered to be in the same equivalence class.
Reference: [Lan92] <author> W. A. Landi. </author> <title> Undecidability of static analysis. </title> <journal> acm Letters on Program ming Languages and Systems, </journal> <volume> 1(4) </volume> <pages> 323-337, </pages> <year> 1992. </year>
Reference-contexts: However, != evaluates to false if both operands are the same abstract object. Using Landi's result <ref> [Lan92] </ref> about undecidability of may alias analysis, it can be shown that concrete type-inference in the general case is undecidable. Thus, we can only hope for a safe algorithm for the general case. Now consider the complexity of analysis-using-abstract-values.
Reference: [LR91] <author> W.A. Landi and Barbara G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: In contrast, an intraprocedurally flow-sensitive algorithm computes different (sometimes approximate) solutions for distinct program points. An interprocedurally flow-sensitive (i.e. context-sensitive) algorithm considers (sometimes approximately) only interprocedurally realizable paths <ref> [SP81, RHS95, LR91] </ref>: paths along which calls and returns are properly matched, while an interprocedurally flow-insensitive (i.e. context-insensitive) algorithm does not make this distinction. The example in Appendix E illustrates this difference. <p> complexity of O (n 4 ) which improves upon the O (n 7 ) 3 In [CRL97], we show how to do concrete type-inference in the presence of exceptions. 4 In this paper, we present our algorithm only for Java. worst-case bound achievable by applying previous techniques of [RHS95] and <ref> [LR91] </ref> to this case; - (Section 6) a new method for demand-driven computation using analysis using-abstract-values; and - (Section 7) preliminary empirical evidence for effectiveness of analysis-using abstract-values for modular analysis. The rest of this paper is organized as follows. We start with some definitions. <p> [Bar78]: the result of a test is independent of previous tests and all the branches are possible), such that if this path is followed, RV points to obj at n (i.e. at the top of n). 2.2 Program representation Our algorithm operates on an interprocedural control flow graph or ICFG <ref> [LR91] </ref>. An ICFG contains a control flow graph (CFG) for each method in the program. Each statement in a method is represented by a node in the method's CFG. Each call site is represented using a pair of nodes: a call-node and a return-node. <p> Call graph decomposition and without dynamic dispatch (the only known natural polynomial-time solvable special case <ref> [LR91, PR96, CRL97] </ref>, if exceptions and threads are excluded). Related work of the second kind include [DGS95] and [HRS95]. In both of these, each data-flow element is treated uniformly and computed from scratch on demand, although later queries may be answered more efficiently because of caching. <p> Further, we have proved that analysis-using-abstract-values computes the precise solution for programs with only single-level types and without dynamic dispatch, and has the worst-case complexity of O (n 4 ) which is an improvement over the O (n 7 ) worst-case bound achievable by applying previous techniques of [RHS95] and <ref> [LR91] </ref> to this case. For general programs, the algorithm is polynomial-time and computes a safe solution. We have presented empirical data about call graph decomposition of 9 C ++ programs, which provides encouraging evidence for effectiveness of analysis-using-abstract-values as a modular analysis technique.
Reference: [LR92] <author> W.A. Landi and Barbara G. Ryder. </author> <title> A safe approximation algorithm for in-terprocedural pointer aliasing. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <year> 1992. </year>
Reference-contexts: When a data-flow element at the exit-node of a method depends upon the simultaneous occurrence of more than one data-flow element at the entry-node of the method, in many situations, the use of abstract values improves precision over other techniques like <ref> [PR96, LR92] </ref> (which represent context using concrete values) by reducing the number of data-flow elements propagated along unrealizable paths. Details of this are given in [CR97]. 5.8 process exit node case. instantiate is similar to instantiate-abstract-values in Figure 8.
Reference: [MLR + 93] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. Choi, M. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: A clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 67-70, </pages> <month> September </month> <year> 1993. </year>
Reference: [MR90] <author> T. J. Marlowe and B. G. Ryder. </author> <title> Properties of data flow frameworks: A unified model. </title> <journal> Acta Informatica, </journal> <volume> 28 </volume> <pages> 121-163, </pages> <year> 1990. </year>
Reference-contexts: This is the essence of analysis-using-abstract-values. We will see in the following sections that this use of abstract values increases efficiency and precision and facilitates modular analysis. 4 analysis-using-abstract-values for programs with only single-level types and without dynamic dispatch analysis-using-abstract-values is an iterative data-flow analysis algorithm <ref> [MR90] </ref>, but unlike ordinary data-flow analysis, data-flow elements are propagated in three distinct phases as explained below. The lattice for data-flow analysis is a subset lattice with union as the meet operator and sets of points-tos as lattice elements.
Reference: [PC94] <author> J. Plevyak and A. Chien. </author> <title> Precise concrete type inference for object oriented languages. </title> <booktitle> In Proceeding of Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '94), </booktitle> <pages> pages 324-340, </pages> <month> October </month> <year> 1994. </year>
Reference: [PR96] <author> Hemant Pande and Barbara G. Ryder. </author> <title> Data-flow-based virtual function resolution. </title> <booktitle> In LNCS 1145, Proceedings of the Third International Symposium on Static Analysis, </booktitle> <year> 1996. </year>
Reference-contexts: When a data-flow element at the exit-node of a method depends upon the simultaneous occurrence of more than one data-flow element at the entry-node of the method, in many situations, the use of abstract values improves precision over other techniques like <ref> [PR96, LR92] </ref> (which represent context using concrete values) by reducing the number of data-flow elements propagated along unrealizable paths. Details of this are given in [CR97]. 5.8 process exit node case. instantiate is similar to instantiate-abstract-values in Figure 8. <p> We have completed the implementation of the algorithm for single-level types and the implementation for the general types is in progress. Table 1 contains data about call graph decomposition of 9 C ++ programs obtained from Hemant Pande <ref> [PR96] </ref>, David Bacon [BS96] and Ben Zorn [CGZ95]. We used hierarchy analysis for constructing the initial call graphs. Table 1 shows that the call graphs of these programs have a large number of components and the cycles in these call graphs are of small size. <p> Call graph decomposition and without dynamic dispatch (the only known natural polynomial-time solvable special case <ref> [LR91, PR96, CRL97] </ref>, if exceptions and threads are excluded). Related work of the second kind include [DGS95] and [HRS95]. In both of these, each data-flow element is treated uniformly and computed from scratch on demand, although later queries may be answered more efficiently because of caching.
Reference: [PS91] <author> J. Palsberg and M. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proceedings of Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA '91), </booktitle> <pages> pages 146-161, </pages> <month> October </month> <year> 1991. </year>
Reference: [RHS95] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analy sis via graph reachability. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <year> 1995. </year>
Reference-contexts: In contrast, an intraprocedurally flow-sensitive algorithm computes different (sometimes approximate) solutions for distinct program points. An interprocedurally flow-sensitive (i.e. context-sensitive) algorithm considers (sometimes approximately) only interprocedurally realizable paths <ref> [SP81, RHS95, LR91] </ref>: paths along which calls and returns are properly matched, while an interprocedurally flow-insensitive (i.e. context-insensitive) algorithm does not make this distinction. The example in Appendix E illustrates this difference. <p> the worst-case complexity of O (n 4 ) which improves upon the O (n 7 ) 3 In [CRL97], we show how to do concrete type-inference in the presence of exceptions. 4 In this paper, we present our algorithm only for Java. worst-case bound achievable by applying previous techniques of <ref> [RHS95] </ref> and [LR91] to this case; - (Section 6) a new method for demand-driven computation using analysis using-abstract-values; and - (Section 7) preliminary empirical evidence for effectiveness of analysis-using abstract-values for modular analysis. The rest of this paper is organized as follows. We start with some definitions. <p> Hence phase I computes the precise solution. A precise solution for phase II is defined as follows. Let P be a method, x be initial entry-node of P; this corresponds to the notion of balanced path in <ref> [RHS95] </ref>. process-call-node ( rdf-elm, c-node ) - // c-node is a call-node which invokes method M if ( rdf-elm.var is an actual for parameter param ) - for ( each df-elm at the exit-node of M such that df-elm.object is param_init and df-elm.var is a global variable or return-variable of M <p> Further, we have proved that analysis-using-abstract-values computes the precise solution for programs with only single-level types and without dynamic dispatch, and has the worst-case complexity of O (n 4 ) which is an improvement over the O (n 7 ) worst-case bound achievable by applying previous techniques of <ref> [RHS95] </ref> and [LR91] to this case. For general programs, the algorithm is polynomial-time and computes a safe solution. We have presented empirical data about call graph decomposition of 9 C ++ programs, which provides encouraging evidence for effectiveness of analysis-using-abstract-values as a modular analysis technique.
Reference: [Ruf95] <author> E. Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming language design and implementation, </booktitle> <pages> pages 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference: [SH97] <author> M. Shapiro and S. Horwitz. </author> <title> Fast and accurate flow-insensitive points-to analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <year> 1997. </year>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for the type-inference problem for Java without exceptions and threads or C ++ without exceptions. There are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [BCCH94, Wei80, Ste96b, Ste96a, SH97, ZRL96, And94] </ref>, which are the ? The research reported here was supported, in part, by NSF grant GER-9023628 and the Hewlett-Packard Corporation. 2 types with data members only of primitive type least expensive, but also the most imprecise.
Reference: [SP81] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 189-234. </pages> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: In contrast, an intraprocedurally flow-sensitive algorithm computes different (sometimes approximate) solutions for distinct program points. An interprocedurally flow-sensitive (i.e. context-sensitive) algorithm considers (sometimes approximately) only interprocedurally realizable paths <ref> [SP81, RHS95, LR91] </ref>: paths along which calls and returns are properly matched, while an interprocedurally flow-insensitive (i.e. context-insensitive) algorithm does not make this distinction. The example in Appendix E illustrates this difference.
Reference: [Ste96a] <author> Bjarne Steensgaard. </author> <title> Points-to analysis by type inference of programs with structures and unions. </title> <booktitle> In Proceedings of the Sixth International Confernce on Compiler Construction, </booktitle> <pages> pages 136-150, </pages> <month> April </month> <year> 1996. </year> <note> Also available as LNCS 1060. </note>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for the type-inference problem for Java without exceptions and threads or C ++ without exceptions. There are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [BCCH94, Wei80, Ste96b, Ste96a, SH97, ZRL96, And94] </ref>, which are the ? The research reported here was supported, in part, by NSF grant GER-9023628 and the Hewlett-Packard Corporation. 2 types with data members only of primitive type least expensive, but also the most imprecise.
Reference: [Ste96b] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <year> 1996. </year>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for the type-inference problem for Java without exceptions and threads or C ++ without exceptions. There are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [BCCH94, Wei80, Ste96b, Ste96a, SH97, ZRL96, And94] </ref>, which are the ? The research reported here was supported, in part, by NSF grant GER-9023628 and the Hewlett-Packard Corporation. 2 types with data members only of primitive type least expensive, but also the most imprecise.
Reference: [Wei80] <author> W. E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label variables. </title> <booktitle> In Conference Record of the Seventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for the type-inference problem for Java without exceptions and threads or C ++ without exceptions. There are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [BCCH94, Wei80, Ste96b, Ste96a, SH97, ZRL96, And94] </ref>, which are the ? The research reported here was supported, in part, by NSF grant GER-9023628 and the Hewlett-Packard Corporation. 2 types with data members only of primitive type least expensive, but also the most imprecise.
Reference: [WL95] <author> Robert P. Wilson and Monica S. Lam. </author> <title> Efficient context-sensitive pointer analysis for c programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming language design and implementation, </booktitle> <pages> pages 1-12, </pages> <year> 1995. </year>
Reference: [ZRL96] <author> S. Zhang, B. G. Ryder, and W. Landi. </author> <title> Program decomposition for pointer aliasing: A step towards practical analyses. </title> <booktitle> In Proceedings of the 4th Symposium on the Foundations of Software Engineering, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for the type-inference problem for Java without exceptions and threads or C ++ without exceptions. There are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [BCCH94, Wei80, Ste96b, Ste96a, SH97, ZRL96, And94] </ref>, which are the ? The research reported here was supported, in part, by NSF grant GER-9023628 and the Hewlett-Packard Corporation. 2 types with data members only of primitive type least expensive, but also the most imprecise.
References-found: 34

