URL: http://www.cs.ucsb.edu/conferences/java98/papers/javab.ps
Refering-URL: http://www.cs.ucsb.edu/conferences/java98/program.html
Root-URL: http://www.cs.ucsb.edu
Email: ajcbik@extreme.indiana.edu  
Phone: 215,  
Title: javab Manual (version 1.0BETA)  
Author: Aart J.C. Bik and Dennis B. Gannon 
Affiliation: Computer Science Department, Indiana University  
Address: Lindley Hall  Bloomington, Indiana 47405-4101, USA  
Abstract: This paper provides a manual for javab, a prototype tool that supports the automatic detection and exploitation of implicit loop parallelism in JVM bytecode. Implicit parallelism is made explicit by means of the multi-threading mechanism provided by the JVM. Automatically exploiting implicit parallelism at bytecode level can be done independently from the source program and platform from which the bytecode was obtained, and independently from the platform on which the bytecode eventually will run. The parallelized bytecode remains architectural neutral and may exhibit speedup on any platform that supports the true parallel execution of JVM threads. This project is supported by DARPA under contract ARPA F19628-94-C-0057 through a subcontract from Syracuse University.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: `-p' option. 3 Automatic Loop Parallelization of JVM Bytecode If the `-p' flag is given, javab examines the JVM bytecode of every method in each class file to automatically detect and exploit implicit parallelism in the natural loops that are defined by back edges in the flow graph (see e.g. <ref> [1, 2, 10, 21, 24, 25] </ref>). <p> [] loop1 (int n) - double [] a = new double [n]; for (int i = 0; i &lt; n; i++) return a; - *** method 0x08 loop1 (I)[D 1-&gt;1 max_stack = 4 max_locals = 3 code_length = 23 ---------- [ 0] 0: iload_0 *<ref> [ 1] </ref> 1: newarray double ---------- [ 1] 3: astore_1 [ 0] 4: iconst_0 [ 1] 5: istore_2 [ 0] 6: goto 16 ---------- [ 0] 9: aload_1 [ 1] 10: iload_2 [ 2] 11: dconst_1 *[ 4] 12: dastore ---------- [ 0] 13: iinc 2 1 ---------- [ 0] 16: iload_2 [ 1] 17: iload_0 [ <p> = new double [n]; for (int i = 0; i &lt; n; i++) return a; - *** method 0x08 loop1 (I)[D 1-&gt;1 max_stack = 4 max_locals = 3 code_length = 23 ---------- [ 0] 0: iload_0 *<ref> [ 1] </ref> 1: newarray double ---------- [ 1] 3: astore_1 [ 0] 4: iconst_0 [ 1] 5: istore_2 [ 0] 6: goto 16 ---------- [ 0] 9: aload_1 [ 1] 10: iload_2 [ 2] 11: dconst_1 *[ 4] 12: dastore ---------- [ 0] 13: iinc 2 1 ---------- [ 0] 16: iload_2 [ 1] 17: iload_0 [ 2] 18: if_icmplt 9 ---------- [ 0] 21: <p> a; - *** method 0x08 loop1 (I)[D 1-&gt;1 max_stack = 4 max_locals = 3 code_length = 23 ---------- [ 0] 0: iload_0 *<ref> [ 1] </ref> 1: newarray double ---------- [ 1] 3: astore_1 [ 0] 4: iconst_0 [ 1] 5: istore_2 [ 0] 6: goto 16 ---------- [ 0] 9: aload_1 [ 1] 10: iload_2 [ 2] 11: dconst_1 *[ 4] 12: dastore ---------- [ 0] 13: iinc 2 1 ---------- [ 0] 16: iload_2 [ 1] 17: iload_0 [ 2] 18: if_icmplt 9 ---------- [ 0] 21: aload_1 [ 1] 22: areturn ---------- First, the access flags, name, and method descriptor <p> 1: newarray double ---------- <ref> [ 1] </ref> 3: astore_1 [ 0] 4: iconst_0 [ 1] 5: istore_2 [ 0] 6: goto 16 ---------- [ 0] 9: aload_1 [ 1] 10: iload_2 [ 2] 11: dconst_1 *[ 4] 12: dastore ---------- [ 0] 13: iinc 2 1 ---------- [ 0] 16: iload_2 [ 1] 17: iload_0 [ 2] 18: if_icmplt 9 ---------- [ 0] 21: aload_1 [ 1] 22: areturn ---------- First, the access flags, name, and method descriptor [16, ch4] of the method are shown (`0x08 loop1 (I)[D'). <p> 5: istore_2 [ 0] 6: goto 16 ---------- [ 0] 9: aload_1 <ref> [ 1] </ref> 10: iload_2 [ 2] 11: dconst_1 *[ 4] 12: dastore ---------- [ 0] 13: iinc 2 1 ---------- [ 0] 16: iload_2 [ 1] 17: iload_0 [ 2] 18: if_icmplt 9 ---------- [ 0] 21: aload_1 [ 1] 22: areturn ---------- First, the access flags, name, and method descriptor [16, ch4] of the method are shown (`0x08 loop1 (I)[D'). <p> show another small Java fragment together with the corresponding JVM bytecode: static void loop2 (double a [], int n) - for (int i = 0; i &lt;= n+30; i++) - *** method 0x08 loop2 ([DI)V 2-&gt;0 max_stack = 4 max_locals = 3 code_length = 21 ---------- [ 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore_2 [ 0] 2: goto 12 ---------- [ 0] 5: aload_0 [ 1] 6: iload_2 [ 2] 7: dconst_1 *[ 4] 8: dastore ---------- [ 0] 9: iinc 2 1 ---------- [ 0] 12: iload_2 [ 1] 13: iload_1 [ 2] 14: bipush 30 [ 3] 16: iadd <p> (double a [], int n) - for (int i = 0; i &lt;= n+30; i++) - *** method 0x08 loop2 ([DI)V 2-&gt;0 max_stack = 4 max_locals = 3 code_length = 21 ---------- [ 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore_2 [ 0] 2: goto 12 ---------- [ 0] 5: aload_0 [ 1] 6: iload_2 [ 2] 7: dconst_1 *[ 4] 8: dastore ---------- [ 0] 9: iinc 2 1 ---------- [ 0] 12: iload_2 [ 1] 13: iload_1 [ 2] 14: bipush 30 [ 3] 16: iadd [ 2] 17: if_icmple 5 ---------- [ 0] 20: return ---------- Here, although javab <p> 4 max_locals = 3 code_length = 21 ---------- [ 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore_2 [ 0] 2: goto 12 ---------- [ 0] 5: aload_0 [ 1] 6: iload_2 [ 2] 7: dconst_1 *[ 4] 8: dastore ---------- [ 0] 9: iinc 2 1 ---------- [ 0] 12: iload_2 [ 1] 13: iload_1 [ 2] 14: bipush 30 [ 3] 16: iadd [ 2] 17: if_icmple 5 ---------- [ 0] 20: return ---------- Here, although javab can determine that the iterations of the bytecode loop corresponding to the i-loop are independent, without inter-procedural analysis the compiler cannot determine whether an
Reference: [2] <author> Andrew W. Appel. </author> <title> Modern Compiler Implementation in C. </title> <publisher> Cambridge University Press, </publisher> <address> New York, </address> <year> 1997. </year>
Reference-contexts: `-p' option. 3 Automatic Loop Parallelization of JVM Bytecode If the `-p' flag is given, javab examines the JVM bytecode of every method in each class file to automatically detect and exploit implicit parallelism in the natural loops that are defined by back edges in the flow graph (see e.g. <ref> [1, 2, 10, 21, 24, 25] </ref>). <p> 0x08 loop1 (I)[D 1-&gt;1 max_stack = 4 max_locals = 3 code_length = 23 ---------- [ 0] 0: iload_0 *[ 1] 1: newarray double ---------- [ 1] 3: astore_1 [ 0] 4: iconst_0 [ 1] 5: istore_2 [ 0] 6: goto 16 ---------- [ 0] 9: aload_1 [ 1] 10: iload_2 <ref> [ 2] </ref> 11: dconst_1 *[ 4] 12: dastore ---------- [ 0] 13: iinc 2 1 ---------- [ 0] 16: iload_2 [ 1] 17: iload_0 [ 2] 18: if_icmplt 9 ---------- [ 0] 21: aload_1 [ 1] 22: areturn ---------- First, the access flags, name, and method descriptor [16, ch4] of the <p> [ 1] 3: astore_1 [ 0] 4: iconst_0 [ 1] 5: istore_2 [ 0] 6: goto 16 ---------- [ 0] 9: aload_1 [ 1] 10: iload_2 <ref> [ 2] </ref> 11: dconst_1 *[ 4] 12: dastore ---------- [ 0] 13: iinc 2 1 ---------- [ 0] 16: iload_2 [ 1] 17: iload_0 [ 2] 18: if_icmplt 9 ---------- [ 0] 21: aload_1 [ 1] 22: areturn ---------- First, the access flags, name, and method descriptor [16, ch4] of the method are shown (`0x08 loop1 (I)[D'). <p> n) - for (int i = 0; i &lt;= n+30; i++) - *** method 0x08 loop2 ([DI)V 2-&gt;0 max_stack = 4 max_locals = 3 code_length = 21 ---------- [ 0] 0: iconst_0 [ 1] 1: istore_2 [ 0] 2: goto 12 ---------- [ 0] 5: aload_0 [ 1] 6: iload_2 <ref> [ 2] </ref> 7: dconst_1 *[ 4] 8: dastore ---------- [ 0] 9: iinc 2 1 ---------- [ 0] 12: iload_2 [ 1] 13: iload_1 [ 2] 14: bipush 30 [ 3] 16: iadd [ 2] 17: if_icmple 5 ---------- [ 0] 20: return ---------- Here, although javab can determine that the <p> code_length = 21 ---------- [ 0] 0: iconst_0 [ 1] 1: istore_2 [ 0] 2: goto 12 ---------- [ 0] 5: aload_0 [ 1] 6: iload_2 <ref> [ 2] </ref> 7: dconst_1 *[ 4] 8: dastore ---------- [ 0] 9: iinc 2 1 ---------- [ 0] 12: iload_2 [ 1] 13: iload_1 [ 2] 14: bipush 30 [ 3] 16: iadd [ 2] 17: if_icmple 5 ---------- [ 0] 20: return ---------- Here, although javab can determine that the iterations of the bytecode loop corresponding to the i-loop are independent, without inter-procedural analysis the compiler cannot determine whether an abnormal loop-exit due to <p> 1] 1: istore_2 [ 0] 2: goto 12 ---------- [ 0] 5: aload_0 [ 1] 6: iload_2 <ref> [ 2] </ref> 7: dconst_1 *[ 4] 8: dastore ---------- [ 0] 9: iinc 2 1 ---------- [ 0] 12: iload_2 [ 1] 13: iload_1 [ 2] 14: bipush 30 [ 3] 16: iadd [ 2] 17: if_icmple 5 ---------- [ 0] 20: return ---------- Here, although javab can determine that the iterations of the bytecode loop corresponding to the i-loop are independent, without inter-procedural analysis the compiler cannot determine whether an abnormal loop-exit due to a run-time exception thrown by the dastore at address
Reference: [3] <author> Utpal Banerjee. </author> <title> Dependence Analysis. </title> <publisher> Kluwer, </publisher> <address> Boston, </address> <year> 1997. </year> <title> A Book Series on Loop Transformations for Restructuring Compilers. </title>
Reference-contexts: Java restructuring compiler javar [4, 6] renames a source file MyClass.java into MyClass.orig, so that both tools can be used without conflicts. 1 To keep compile-time limited, the prototype relies on relatively simple but generally also less expensive analysis, rather than doing, for instance, advanced data dependence analysis (see e.g. <ref> [3, 19, 22, 23, 24, 25] </ref>). <p> 0] 0: iconst_0 [ 1] 1: istore_2 [ 0] 2: goto 12 ---------- [ 0] 5: aload_0 [ 1] 6: iload_2 [ 2] 7: dconst_1 *[ 4] 8: dastore ---------- [ 0] 9: iinc 2 1 ---------- [ 0] 12: iload_2 [ 1] 13: iload_1 [ 2] 14: bipush 30 <ref> [ 3] </ref> 16: iadd [ 2] 17: if_icmple 5 ---------- [ 0] 20: return ---------- Here, although javab can determine that the iterations of the bytecode loop corresponding to the i-loop are independent, without inter-procedural analysis the compiler cannot determine whether an abnormal loop-exit due to a run-time exception thrown by
Reference: [4] <author> Aart J.C. Bik and Dennis B. Gannon. </author> <title> Automatically exploiting implicit parallelism in Java. </title> <journal> Concurrency, Practice and Experience, </journal> <volume> 9(6) </volume> <pages> 579-619, </pages> <year> 1997. </year>
Reference-contexts: Java, the transformed program is stored in the file MyClass.class again, after a copy of the original program has been saved in MyClass.old. 1 Some auxiliary classes, support the parallel execution of loops, may also be generated by the bytecode parallelization tool javab 1 Our prototype Java restructuring compiler javar <ref> [4, 6] </ref> renames a source file MyClass.java into MyClass.orig, so that both tools can be used without conflicts. 1 To keep compile-time limited, the prototype relies on relatively simple but generally also less expensive analysis, rather than doing, for instance, advanced data dependence analysis (see e.g. [3, 19, 22, 23, 24, <p> We hope that using this option may gain insight in the kind of improvements required to increase the number of loops in JVM bytecodes that can be parallelized automatically. New releases of javab (and the Java restructuring compiler javar <ref> [4, 6] </ref>) are made available at our HP-Java page (http://www.extreme.indiana.edu/hpjava/). Please send us all your comments, bug reports, experiences, and suggestions (ajcbik@extreme.indiana.edu). 5
Reference: [5] <author> Aart J.C. Bik and Dennis B. Gannon. </author> <title> javab a prototype bytecode parallelization tool. </title> <type> Technical Report 489, </type> <institution> Computer Science Department, Indiana University, </institution> <year> 1997. </year> <note> This report and the complete source of javab are made available at http://www.extreme.indiana.edu/hpjava/. </note>
Reference-contexts: However, these problems will be alleviated by the incorporation of inter-procedural analysis in environments where complete bytecode programs are available. 4 Concluding Remarks For a more detailed presentation of the techniques used by the prototype bytecode paral-lelization tool javab, we refer to <ref> [5] </ref>. Please keep in mind that javab is a prototype tool, and not a robust commercial product. We hope, however, that this bytecode parallelization tool provides an environment with sufficient functionality to enable rapid prototyping of new automatic JVM bytecode parallelization methods.
Reference: [6] <author> Aart J.C. Bik and Dennis B. Gannon. </author> <title> javar a prototype java restructuring compiler. </title> <type> Technical Report 487, </type> <institution> Computer Science Department, Indiana University, </institution> <year> 1997. </year> <note> This manual and the complete source of javar are made available at http://www.extreme.indiana.edu/hpjava/. </note>
Reference-contexts: Java, the transformed program is stored in the file MyClass.class again, after a copy of the original program has been saved in MyClass.old. 1 Some auxiliary classes, support the parallel execution of loops, may also be generated by the bytecode parallelization tool javab 1 Our prototype Java restructuring compiler javar <ref> [4, 6] </ref> renames a source file MyClass.java into MyClass.orig, so that both tools can be used without conflicts. 1 To keep compile-time limited, the prototype relies on relatively simple but generally also less expensive analysis, rather than doing, for instance, advanced data dependence analysis (see e.g. [3, 19, 22, 23, 24, <p> We hope that using this option may gain insight in the kind of improvements required to increase the number of loops in JVM bytecodes that can be parallelized automatically. New releases of javab (and the Java restructuring compiler javar <ref> [4, 6] </ref>) are made available at our HP-Java page (http://www.extreme.indiana.edu/hpjava/). Please send us all your comments, bug reports, experiences, and suggestions (ajcbik@extreme.indiana.edu). 5
Reference: [7] <author> Zoran Budimlic and Ken Kennedy. </author> <title> Optimizing Java theory and practice. </title> <journal> Concurrency, Practice and Experience, </journal> <volume> 9(6) </volume> <pages> 445-463, </pages> <year> 1997. </year>
Reference: [8] <author> Bryan Carpenter, Yuh-Jye Chang, Geoffrey Fox, Donald Leskiw, and Xiaoming Li. </author> <title> Experiments with `HP Java'. </title> <journal> Concurrency, Practice and Experience, </journal> <volume> 9(6) </volume> <pages> 633-648, </pages> <year> 1997. </year>
Reference: [9] <author> Michal Cierniak and Wei Li. </author> <title> Optimizing Java bytecodes. </title> <journal> Concurrency, Practice and Experience, </journal> <volume> 9(6) </volume> <pages> 427-444, </pages> <year> 1997. </year>
Reference: [10] <author> C.N. Fischer and R.J. LeBlanc. </author> <title> Crafting a Compiler. </title> <address> Benjamin-Cummings, Menlo Park, Cali-fornia, </address> <year> 1988. </year>
Reference-contexts: `-p' option. 3 Automatic Loop Parallelization of JVM Bytecode If the `-p' flag is given, javab examines the JVM bytecode of every method in each class file to automatically detect and exploit implicit parallelism in the natural loops that are defined by back edges in the flow graph (see e.g. <ref> [1, 2, 10, 21, 24, 25] </ref>).
Reference: [11] <author> Geoffrey C. Fox and Wojtek Furmanski. </author> <title> Java for parallel computing and as a general language for scientific and engineering simulation and modeling. </title> <journal> Concurrency, Practice and Experience, </journal> <volume> 9(6) </volume> <pages> 415-425, </pages> <year> 1997. </year>
Reference: [12] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> Java Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1996. </year>
Reference-contexts: The tool performs a bytecode to bytecode transformation, where implicit loop parallelism is made explicit by means of the multi-threading mechanism provided by the JVM <ref> [12, 16, 15, 18, 20] </ref>. In figure 1, we illustrate the automatic exploitation of implicit loop parallelism in JVM bytecode. A binary file MyClass.class in the class file format [16] is used as input of javab.
Reference: [13] <author> Brian W. Kernighan. </author> <title> The UNIX Programming Environment. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1984. </year>
Reference-contexts: If no files are specified, then javab reads a class file from standard input and, if the option `-o' is also given, writes the class file back to standard output, which enables the use of javab in Unix pipes or input-output redirections <ref> [13] </ref> (e.g. javab -op &lt; filein &gt; fileout).
Reference: [14] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1988. </year>
Reference: [15] <author> Doug Lea. </author> <title> Concurrent Programming in Java. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: The tool performs a bytecode to bytecode transformation, where implicit loop parallelism is made explicit by means of the multi-threading mechanism provided by the JVM <ref> [12, 16, 15, 18, 20] </ref>. In figure 1, we illustrate the automatic exploitation of implicit loop parallelism in JVM bytecode. A binary file MyClass.class in the class file format [16] is used as input of javab.
Reference: [16] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1996. </year>
Reference-contexts: The tool performs a bytecode to bytecode transformation, where implicit loop parallelism is made explicit by means of the multi-threading mechanism provided by the JVM <ref> [12, 16, 15, 18, 20] </ref>. In figure 1, we illustrate the automatic exploitation of implicit loop parallelism in JVM bytecode. A binary file MyClass.class in the class file format [16] is used as input of javab. <p> In figure 1, we illustrate the automatic exploitation of implicit loop parallelism in JVM bytecode. A binary file MyClass.class in the class file format <ref> [16] </ref> is used as input of javab. Thereafter, the compiler transforms the input program into a form that uses the JVM multi-threading mechanism to make all implicit parallelism explicit. <p> The default approach taken by javab to preserve the user-visible state after exceptions <ref> [16] </ref> as much as possible (without being over restrictive with respect to transformations) is to only transform regions of code for which the compiler can prove that run-time exceptions cannot occur, but to allow semantical changes with respect to the handling of JVM errors and linking exceptions. <p> 1] 10: iload_2 [ 2] 11: dconst_1 *[ 4] 12: dastore ---------- [ 0] 13: iinc 2 1 ---------- [ 0] 16: iload_2 [ 1] 17: iload_0 [ 2] 18: if_icmplt 9 ---------- [ 0] 21: aload_1 [ 1] 22: areturn ---------- First, the access flags, name, and method descriptor <ref> [16, ch4] </ref> of the method are shown (`0x08 loop1 (I)[D').
Reference: [17] <author> Jon Meyer. Jasmin: </author> <title> a Java Assembler Interface. </title> <note> This JVM bytecode assembler is made available at http://www.cat.nyu.edu/meyer/jasmin/. </note>
Reference-contexts: Hence, this approach allows the optimization of bytecodes that have been generated by the Java compiler javac, bytecodes that have been downloaded over a network, bytecodes generated by bytecode producing compilers for other high level languages, or bytecodes produced by a JVM assembler like Jasmin <ref> [17, 18] </ref>.
Reference: [18] <author> Jon Meyer and Troy Downing. </author> <title> Java Virtual Machine. </title> <publisher> O'Reilly & Associates, </publisher> <address> Sebastopol, CA, </address> <year> 1997. </year>
Reference-contexts: The tool performs a bytecode to bytecode transformation, where implicit loop parallelism is made explicit by means of the multi-threading mechanism provided by the JVM <ref> [12, 16, 15, 18, 20] </ref>. In figure 1, we illustrate the automatic exploitation of implicit loop parallelism in JVM bytecode. A binary file MyClass.class in the class file format [16] is used as input of javab. <p> Hence, this approach allows the optimization of bytecodes that have been generated by the Java compiler javac, bytecodes that have been downloaded over a network, bytecodes generated by bytecode producing compilers for other high level languages, or bytecodes produced by a JVM assembler like Jasmin <ref> [17, 18] </ref>.
Reference: [19] <author> Samuel P. Midkiff and David A. Padua. </author> <title> Compiler algorithms for synchronization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36:1485-1495, </volume> <year> 1987. </year>
Reference-contexts: Java restructuring compiler javar [4, 6] renames a source file MyClass.java into MyClass.orig, so that both tools can be used without conflicts. 1 To keep compile-time limited, the prototype relies on relatively simple but generally also less expensive analysis, rather than doing, for instance, advanced data dependence analysis (see e.g. <ref> [3, 19, 22, 23, 24, 25] </ref>).
Reference: [20] <author> Scott Oaks and Henry Wong. </author> <title> Java Threads. </title> <publisher> O'Reilly & Associates, </publisher> <address> Sebastopol, CA, </address> <year> 1997. </year>
Reference-contexts: The tool performs a bytecode to bytecode transformation, where implicit loop parallelism is made explicit by means of the multi-threading mechanism provided by the JVM <ref> [12, 16, 15, 18, 20] </ref>. In figure 1, we illustrate the automatic exploitation of implicit loop parallelism in JVM bytecode. A binary file MyClass.class in the class file format [16] is used as input of javab.
Reference: [21] <author> Thomas W. Parsons. </author> <title> Introduction to Compiler Construction. </title> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: `-p' option. 3 Automatic Loop Parallelization of JVM Bytecode If the `-p' flag is given, javab examines the JVM bytecode of every method in each class file to automatically detect and exploit implicit parallelism in the natural loops that are defined by back edges in the flow graph (see e.g. <ref> [1, 2, 10, 21, 24, 25] </ref>).
Reference: [22] <author> Constantine D. Polychronopoulos. </author> <title> Parallel Programming and Compilers. </title> <publisher> Kluwer, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: Java restructuring compiler javar [4, 6] renames a source file MyClass.java into MyClass.orig, so that both tools can be used without conflicts. 1 To keep compile-time limited, the prototype relies on relatively simple but generally also less expensive analysis, rather than doing, for instance, advanced data dependence analysis (see e.g. <ref> [3, 19, 22, 23, 24, 25] </ref>).
Reference: [23] <author> William Pugh. </author> <title> The Omega test: a fast and practical integer programming algorithm for dependence analysis. </title> <journal> Communications of the ACM, </journal> <year> 1992. </year>
Reference-contexts: Java restructuring compiler javar [4, 6] renames a source file MyClass.java into MyClass.orig, so that both tools can be used without conflicts. 1 To keep compile-time limited, the prototype relies on relatively simple but generally also less expensive analysis, rather than doing, for instance, advanced data dependence analysis (see e.g. <ref> [3, 19, 22, 23, 24, 25] </ref>).
Reference: [24] <author> Michael J. Wolfe. </author> <title> High Performance Compilers for Parallel Computers. </title> <publisher> Addison-Wesley, </publisher> <address> Redwood City, California, </address> <year> 1996. </year>
Reference-contexts: Java restructuring compiler javar [4, 6] renames a source file MyClass.java into MyClass.orig, so that both tools can be used without conflicts. 1 To keep compile-time limited, the prototype relies on relatively simple but generally also less expensive analysis, rather than doing, for instance, advanced data dependence analysis (see e.g. <ref> [3, 19, 22, 23, 24, 25] </ref>). <p> `-p' option. 3 Automatic Loop Parallelization of JVM Bytecode If the `-p' flag is given, javab examines the JVM bytecode of every method in each class file to automatically detect and exploit implicit parallelism in the natural loops that are defined by back edges in the flow graph (see e.g. <ref> [1, 2, 10, 21, 24, 25] </ref>).
Reference: [25] <author> H. Zima and B. Chapman. </author> <title> Supercompilers for Parallel and Vector Computers. </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1990. </year> <month> 6 </month>
Reference-contexts: Java restructuring compiler javar [4, 6] renames a source file MyClass.java into MyClass.orig, so that both tools can be used without conflicts. 1 To keep compile-time limited, the prototype relies on relatively simple but generally also less expensive analysis, rather than doing, for instance, advanced data dependence analysis (see e.g. <ref> [3, 19, 22, 23, 24, 25] </ref>). <p> `-p' option. 3 Automatic Loop Parallelization of JVM Bytecode If the `-p' flag is given, javab examines the JVM bytecode of every method in each class file to automatically detect and exploit implicit parallelism in the natural loops that are defined by back edges in the flow graph (see e.g. <ref> [1, 2, 10, 21, 24, 25] </ref>).
References-found: 25

