URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/chopshop/pub/papers/fse94.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/project/chopshop/pub/www/home.html
Root-URL: 
Keyword: Reverse engineering, modularity specifi cations, program slic ing, dataow dependence, program dependence graph.  
Abstract: A dependence model for reverse engineering should treat procedures in a modular fashion and should be fi ne-grained, distinguishing dependences that are due to different variables. The program dependence graph (PDG) satisfi es neither of these criteria. W e present a new form of dependence graph that satisfies both, while retaining the advantages of the PDG: it is easy to construct and allows program slicing to be imple - mented as a simple graph traversal. W e defi ne chopping, a generalization of slicing that can express most of its variants, and show that, using our dependence graph, it produces more accurate results than algorithms based directly on the PDG. 
Abstract-found: 1
Intro-found: 1
Reference: [ASU88] <author> Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman. </author> <booktitle> Compilers: principles, techniques and tools . Addison Wesley, </booktitle> <month> March </month> <year> 1988. </year>
Reference-contexts: An expression like ucd ucd makes no sense because it confuses uses and defi nitions; the second ucd treats as a use the defi nition in the range of the first. The du relation, incidentally, should not be confused with du-chaining <ref> [ASU88] </ref>. We chose to order the relations so that membership of a pair ((x, i), (y, j)) can be read x at i depends on y at j. <p> A set of reaching definitions is found for each site: a definition of variable x at node i reaches a node j if there is a path from i to j with no intervening defi nition of x <ref> [ASU88] </ref>. For each of these, if x is used at j, the edge ((x, j), (x, i)) is inserted into ud. The control dependence edges are a little trickier.
Reference: [BC85] <author> Jean-Francois Bergeretti and Bernard A. </author> <title> Carre. </title> <journal> Information-ow and data ow analysis of while-programs. ACM Trans. on Programming L anguages and Systems, </journal> <volume> 7(1), </volume> <month> January </month> <year> 1985, </year> <pages> pp. 3761. </pages>
Reference-contexts: Dependence relations were also used in the Spade tool to detect data ow anomalies and to extract partial statements similar to program slices <ref> [BC85] </ref>. These relations have a different form, however; lacking a distinction between uses and definitions of the same variable occurrence, they seem unable to handle procedure calls with side effects.
Reference: [CF89] <author> Robert Cartwright and Matthias F elleisen. </author> <title> The semantics of program dependence. </title> <booktitle> Proc. ACM Symposium on Programming L anguage Design and Implementation, </booktitle> <year> 1989. </year>
Reference-contexts: The referees provided unusually helpful comments; one, in particular, found an error in Section 6, confi rming our plan eventually to justify our model theoretically, following the examples of <ref> [CF89] </ref> and [PC90]. Appendix: Relational Operators The paper uses the Z syntax [Spi89] for operators on sets and relations.
Reference: [Ern94] <author> Michael D. Ernst. </author> <title> Practical fi ne-grained static slic - ing of optimized code . Technical report MSR -TR-94-14, Microsoft R esearch, R edmond, </title> <editor> W a., </editor> <month> July </month> <year> 1994. </year>
Reference-contexts: The value depen - dence graph (VDG) [W+94] associates summary edges with calls and supports fine-grained slicing <ref> [Ern94] </ref>. Being designed primarily as an intermediate representation for a compiler, the model does not seem to incorporate codeless procedures as smoothly. It is also functional, loops being replaced by recur - sive calls and mutation of variables being modelled explicitly with store update operations.
Reference: [FOW87] <author> Jeanne F errante, Karl J. Ottenstein and Joe D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <booktitle> ACM T rans. on Programming Languages and Systems , 9(3), </booktitle> <month> July </month> <year> 1987, </year> <pages> pp. 319349. </pages>
Reference-contexts: 1 Introduction Many analyses and transformations of programs are based on dependence relationships, often represented by the program dependence graph (PDG). Originally devised for compilers, its novelty was to combine dataow and control dependences in a single graph, making code optimizations easier to perform <ref> [FOW87] </ref>. More recently, the PDG has been adopted in soft - ware engineering, for analyses whose outputs are intended not for compiler backends but for software developers. <p> The control dependence edges are a little trickier. A post-dominator tree is calculated that associates the site of each conditional with the set of sites whose execution it inuences directly <ref> [FOW87] </ref>. F or each edge in the tree from site i to site j, the edge ((, j), (, i)) is inserted into cd.
Reference: [GL91] <author> Keith Brian Gallagher and James R . L yle. </author> <title> Using program slicing in software maintenance. </title> <journal> IEEE Trans. on Softwar e Engineering , 17(8), A ugust 1991, </journal> <pages> pp. 751761. </pages>
Reference-contexts: site i: source = V -i-, sink = Var Site (3) a backward slice on all uses and defi nitions of variables at site i [RY89]: source = Var Site, sink = Var -i (4) and a backward slice on the final value or any definition of a variable v <ref> [GL91] </ref>: source = Var Site, sink = du (-v Site) -(v, exit). The original formulation of slicing identifi es the statements that affect the value of a variable just prior to the execution of a given statement [Wei84].
Reference: [HRB90] <author> Susan Horwitz, </author> <title> Thomas R eps and David Binkley . Interprocedural slicing using dependence graphs. </title> <journal> ACM T rans. on Programming L anguages and Systems, </journal> <volume> 12(1), </volume> <month> January </month> <year> 1990, </year> <pages> pp. 2660. </pages>
Reference-contexts: And to distinguish the uses and defini-tions of a procedure call, which is essential for reasonable interprocedural slices, one can insert a mock assignment node for every passing of a parameter , and for every reading and writing of a global by the called procedure <ref> [HRB90] </ref>. Program slicing is not alone; there are many analyses based on dependences for which the PDG is not ideal. <p> A PDG based algorithm cannot generally make such distinctions without ad hoc additions, such as special nodes for the fi nal use and initial defi nition of variables [R Y89], mock assignments for passing parameters and globals in and out of procedure calls <ref> [HRB90] </ref>, and the splitting of nodes (or adaptation of the search algorithm) for separating the uses of a primitive statement. Our graph sup - ports simple traversal algorithms without such tricks. 3 Formalization of the Graph A dependence relates a variable at one program point to a variable at another.
Reference: [Jac91] <author> Daniel Jackson. </author> <title> Aspect: An Economical Bug Detector. </title> <booktitle> Proc. Inter national Conf . Softwar e Engineering, </booktitle> <address> Austin, Texas, </address> <month> May </month> <year> 1991, </year> <pages> pp. 1322. </pages>
Reference-contexts: The dependence specifi cations originate in our previous work, where they were used to fi nd bugs in a procedure by comparing its calculated and expected dependences <ref> [Jac91] </ref>. Dependence relations were also used in the Spade tool to detect data ow anomalies and to extract partial statements similar to program slices [BC85].
Reference: [Jac93] <author> Daniel Jackson. </author> <title> Abstract Analysis with Aspect. </title> <booktitle> Proc. International Symposium on Softwar e Testing and Analysis, </booktitle> <address> Cambridge, Mass., </address> <month> June </month> <year> 1993, </year> <pages> pp. </pages> <year> 1927. </year>
Reference-contexts: Program slicing is not alone; there are many analyses based on dependences for which the PDG is not ideal. W e were unable to use PDGs, for example, in a tool that used unsatis - fied dependences to detect bugs <ref> [Jac93] </ref> or in a differencing tool that compared programs according to their dependences [JL94]. Reverse engineering in particular demands two properties of a dependence model, neither of which the PDG satis - fies: 1. Procedures should have a modular r epresentation. <p> P rocedures without code, such as library routines, can be given surrogate specifications in place of code to be incorporated directly <ref> [Jac93] </ref>. To see how the dependence edges fi t together, lets slice on the use of a by the statement step (). That is, we want to determine which statements might affect the value of a just prior to the call to step.
Reference: [JL94] <author> Daniel Jackson and David A. Ladd. </author> <title> Semantic diff: a tool for summarizing the effects of modifi cations. </title> <booktitle> Proc. International Conf. on Software Maintenance, </booktitle> <address> Vancouver, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: W e were unable to use PDGs, for example, in a tool that used unsatis - fied dependences to detect bugs [Jac93] or in a differencing tool that compared programs according to their dependences <ref> [JL94] </ref>. Reverse engineering in particular demands two properties of a dependence model, neither of which the PDG satis - fies: 1. Procedures should have a modular r epresentation.
Reference: [JR94] <author> Daniel Jackson and Eugene J. R ollins. </author> <title> Abstraction mechanisms for pictorial slicing. </title> <booktitle> Proc. of Workshop on Program Compr ehension, </booktitle> <address> W ashington, D.C., </address> <month> November </month> <year> 1994. </year>
Reference-contexts: Graphs of even the smallest chops tend to be huge, but we have found that a few simple abstraction mechanismssuch as eliding primitive statements and folding calls of the same pro - cedurereduce the size drastically without adversely affecting the graphs utility <ref> [JR94] </ref>. Our current challenge is to incorporate aliasing in a modu - lar fashion, probably combining ideas taken from abstract interpretation schemes [LH88] and more specialized tech - niques [PLR94]. 8 Related Work A number of dependence representations have been developed that treat procedures in a modular fashion.
Reference: [LH88] <author> James J. Larus and P aul N. Hilfi nger. </author> <title> Detecting conicts between structure accesses. </title> <booktitle> Proc. ACM Conf. on Principles of Programming L anguage Design and Implementation, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: Our current challenge is to incorporate aliasing in a modu - lar fashion, probably combining ideas taken from abstract interpretation schemes <ref> [LH88] </ref> and more specialized tech - niques [PLR94]. 8 Related Work A number of dependence representations have been developed that treat procedures in a modular fashion. The value depen - dence graph (VDG) [W+94] associates summary edges with calls and supports fine-grained slicing [Ern94].
Reference: [MW90] <author> Mark Moriconi and T imothy C. W inkler. </author> <title> Approximate reasoning about the semantic effects of program changes. </title> <journal> IEEE T rans. on Softwar e Engineering, </journal> <volume> 16(9), </volume> <month> September </month> <year> 1990, </year> <pages> pp. 980992. </pages>
Reference-contexts: These relations have a different form, however; lacking a distinction between uses and definitions of the same variable occurrence, they seem unable to handle procedure calls with side effects. Moriconi and Winklers inference rule system for determining the scope of a program change <ref> [MW90] </ref> defi nes a depen - dence relation too, but implicitly as a set of inference rules over the syntax. Procedure calls are abstracted, since the proof of a dependence due to a call can be built from rules applied to its body.
Reference: [OO84] <author> K.J. Ottenstein and L.M. Ottenstein. </author> <title> The program dependence graph in a software development envi - ronment. </title> <booktitle> Proc. ACM SIGSOF T/SIGPLAN Symposium on Practical Softwar e Development Environments, Pittsburgh, P A, </booktitle> <month> April </month> <year> 1984. </year> <journal> ACM SIGPLAN Notices 19(5), </journal> <pages> pp. 177184, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: More recently, the PDG has been adopted in soft - ware engineering, for analyses whose outputs are intended not for compiler backends but for software developers. P rogram slicing in particular benefi ts greatly, being reduced to a simple reachability problem <ref> [OO84] </ref> far simpler than its original for - mulation [Wei84]. But the PDG is too coarse for software engineering applications.
Reference: [PC90] <author> Andy P odgurski and Lori A. Clarke. </author> <title> A formal model of program dependences and its implications for software testing, debugging and maintenance. </title> <journal> IEEE T rans. on Softwar e Engineering , 16(9), </journal> <month> September </month> <year> 1990, </year> <pages> pp. 965979. </pages>
Reference-contexts: The referees provided unusually helpful comments; one, in particular, found an error in Section 6, confi rming our plan eventually to justify our model theoretically, following the examples of [CF89] and <ref> [PC90] </ref>. Appendix: Relational Operators The paper uses the Z syntax [Spi89] for operators on sets and relations.
Reference: [PLR94] <author> Hemant D. Pande, William A. Landi and Barbara G. Ryder. </author> <title> Interprocedural def use associations for C systems with single level pointers. </title> <journal> IEEE Trans. on Software Engineering , 20(5), </journal> <month> May </month> <year> 1994, </year> <pages> pp. 385403. </pages>
Reference-contexts: Our current challenge is to incorporate aliasing in a modu - lar fashion, probably combining ideas taken from abstract interpretation schemes [LH88] and more specialized tech - niques <ref> [PLR94] </ref>. 8 Related Work A number of dependence representations have been developed that treat procedures in a modular fashion. The value depen - dence graph (VDG) [W+94] associates summary edges with calls and supports fine-grained slicing [Ern94].
Reference: [R+94] <author> Thomas R eps, Susan Horwitz, Mooly Sagiv and Genevieve R osay. </author> <title> Speeding up slicing . T echnical report D -214, </title> <institution> Datalogisk Institut, University of Copenhagen, </institution> <year> 1994. </year>
Reference-contexts: Most statements only access a few variables, so n varies linearly with the size of the program. Experiments will determine how effi - cient this approach is, but we suspect it to be no worse than the best existing methods <ref> [R+94] </ref>. 7 The Chopshop Tool The dependence model was designed for Chopshop, a tool we have built to analyze C programs. Chopshop is written in ML and runs as subprocess of emacs 19 .
Reference: [RY89] <author> Thomas Reps and Wuu Yang. </author> <title> The semantics of program slicing and program integration. </title> <booktitle> Proc. Colloquium on Cur rent Issues in Programming Languages, </booktitle> <address> Barcelona, </address> <month> March </month> <year> 1989. </year> <booktitle> Lecture Notes in Computer Science 352, </booktitle> <pages> pp. 360374, </pages> <publisher> Springer - Verlag, </publisher> <address> New York. </address>
Reference-contexts: In Weisers formulation, the slice criterion identifies one or more variables at a given line, and the slice is a subprogram whose statements might affect the value of those variables just prior to execution of that line. In PDG formulations of slicing, such as <ref> [RY89] </ref>, on the other hand, a slice criterion is a node of the graphthat is, a program statementand the slice con - tains statements that might affect the value of any variable used by that statement. <p> Composed on an Apple Macintosh in Microsoft Word and Aldus Intellidraw, and set in Quark Xpress. Text face generously provided by Bitstream, Inc. in the program <ref> [RY89] </ref>. And to distinguish the uses and defini-tions of a procedure call, which is essential for reasonable interprocedural slices, one can insert a mock assignment node for every passing of a parameter , and for every reading and writing of a global by the called procedure [HRB90]. <p> variables V at site i: source = Var Site, sink = V -i (2) a forward slice [YL88] on the definition of variables V at site i: source = V -i-, sink = Var Site (3) a backward slice on all uses and defi nitions of variables at site i <ref> [RY89] </ref>: source = Var Site, sink = Var -i (4) and a backward slice on the final value or any definition of a variable v [GL91]: source = Var Site, sink = du (-v Site) -(v, exit).
Reference: [Spi89] <author> J.M. Spivey. </author> <title> The Z Notation: </title> <publisher> A R eference Manual . Prentice Hall International (UK) Ltd., </publisher> <year> 1989. </year>
Reference-contexts: The referees provided unusually helpful comments; one, in particular, found an error in Section 6, confi rming our plan eventually to justify our model theoretically, following the examples of [CF89] and [PC90]. Appendix: Relational Operators The paper uses the Z syntax <ref> [Spi89] </ref> for operators on sets and relations.
Reference: [W+94] <author> Daniel Weise, R oger F . Crew , Michael Ernst and Bjarne Steensgaard. </author> <title> Value dependence graphs: representation without taxation . Technical report MSR - TR-94-03, Microsoft R esearch, R edmond, </title> <editor> W a., </editor> <month> April </month> <year> 1994. </year>
Reference-contexts: The value depen - dence graph (VDG) <ref> [W+94] </ref> associates summary edges with calls and supports fine-grained slicing [Ern94]. Being designed primarily as an intermediate representation for a compiler, the model does not seem to incorporate codeless procedures as smoothly.
Reference: [Wei84] <author> Mark W eiser. </author> <title> P rogram slicing. </title> <journal> IEEE T rans. on Software Engineering , SE-10(4), </journal> <month> July </month> <year> 1984, </year> <pages> pp. 352357. </pages>
Reference-contexts: P rogram slicing in particular benefi ts greatly, being reduced to a simple reachability problem [OO84] far simpler than its original for - mulation <ref> [Wei84] </ref>. But the PDG is too coarse for software engineering applications. <p> The original formulation of slicing identifi es the statements that affect the value of a variable just prior to the execution of a given statement <ref> [Wei84] </ref>. Since the variable need not be used by the statement, this criterion cannot be expressed in our model.
Reference: [WH91] <author> Norman Wilde and R oss Huitt. </author> <title> A reusable toolset for software dependency analysis. </title> <journal> Journal of Systems and Software, </journal> <volume> Vol. 14, </volume> <year> 1991, </year> <pages> pp. 97102. </pages>
Reference-contexts: It might be interesting to see how this logic is related to our dependence graph. Finally, W ilde and Huitts external dependency graphs seem to be identical to our specifications. They are mentioned briey in <ref> [WH91] </ref>, along with a variety of other dependence relations, but with no explanation of how they are constructed and used. Acknowledgments Discussions with Bill Griswold of UC SD and Mike Ernst of Microsoft R esearch occasioned a complete rewriting of this paper.
Reference: [YL88] <author> S. Yau and S.S. Liu. </author> <title> Some approaches to logical rip - ple-effect analysis . Software Engineering R esearch Center, </title> <institution> SERC -TR-24F, University of Florida, </institution> <month> October </month> <year> 1988. </year>
Reference-contexts: := true while f do step () check () end Most slicing notions that have been proposed can be expressed as forms of chopping: (1) a traditional backward slice on the use of variables V at site i: source = Var Site, sink = V -i (2) a forward slice <ref> [YL88] </ref> on the definition of variables V at site i: source = V -i-, sink = Var Site (3) a backward slice on all uses and defi nitions of variables at site i [RY89]: source = Var Site, sink = Var -i (4) and a backward slice on the final value
References-found: 23

