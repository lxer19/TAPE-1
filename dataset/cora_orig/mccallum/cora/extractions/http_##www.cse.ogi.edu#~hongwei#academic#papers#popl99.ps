URL: http://www.cse.ogi.edu/~hongwei/academic/papers/popl99.ps
Refering-URL: http://www.cse.ogi.edu/~hongwei/academic/publications.html
Root-URL: http://www.cse.ogi.edu
Email: hongwei@cse.ogi.edu  fp@cs.cmu.edu  
Title: Dependent Types in Practical Programming (Extended Abstract)  
Author: Hongwei Xi Frank Pfenning 
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science and Technology  Department of Computer Science Carnegie Mellon University  
Abstract: We present an approach to enriching the type system of ML with a restricted form of dependent types, where type index objects are drawn from a constraint domain C, leading to the DML(C) language schema. This allows specification and inference of significantly more precise type information, facilitating program error detection and compiler optimization. A major complication resulting from introducing dependent types is that pure type inference for the enriched system is no longer possible, but we show that type-checking a sufficiently annotated program in DML(C) can be reduced to constraint satisfaction in the constraint domain C. We exhibit the un-obtrusiveness of our approach through practical examples and prove that DML(C) is conservative over ML. The main contribution of the paper lies in our language design, including the formulation of type-checking rules which makes the approach practical. To our knowledge, no previous type system for a general purpose programming language such as ML has combined dependent types with features including datatype declarations, higher-order functions, general recursions, let-polymorphism, mutable references, and exceptions. In addition, we have finished a prototype implementation of DML(C) for an integer constraint domain C, where constraints are linear inequalities (Xi and Pfenning 1998). 
Abstract-found: 1
Intro-found: 1
Reference: <author> Augustsson, L. </author> <year> (1998). </year> <title> Cayenne a language with dependent types. </title> <booktitle> In Proceedings of ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pp. 239-250. </pages>
Reference-contexts: We specify and check less information about functions which avoids general theorem proving. On the other hand, we currently do not address module-level issues, although we believe that our approach should extend naturally to signatures and functors without much additional machinery. Cayenne <ref> (Augustsson 1998) </ref> is a Haskell-like language in which fully dependent types are available, that is, language expressions can be used as type index objects. The steep price for this is undecidable type-checking in Cayenne.
Reference: <author> Constable, R. L. et al. </author> <year> (1986). </year> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <address> Englewood Cliffs, New Jersey: </address> <publisher> Prentice-Hall. </publisher>
Reference-contexts: into those for rich, realistic languages such as Standard ML (Milner, Tofte, and Harper 1990), Caml (Weis and Leroy 1993), or Haskell!(Hudak, Peyton Jones, and Wadler 1992), and those for small, pure languages such as the ones underlying Coq (Dowek, Felty, Herbelin, Huet, Murthy, Parent, Paulin-Mohring, and Werner 1993), NuPrl <ref> (Constable et al. 1986) </ref>, or PX (Hayashi and Nakano 1988). Type-checking in realistic languages should be theoretically decidable and fl This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No.
Reference: <author> Danvy, O. </author> <year> (1998, </year> <month> May). </month> <title> Functional unparsing. </title> <type> Technical Report RS-98-12, </type> <institution> University of Aarhus. </institution>
Reference-contexts: The steep price for this is undecidable type-checking in Cayenne. We feel that Cayenne pays greater attention to making more programs typable than assigning programs more accurate types. In Cayenne, the printf in C, which is not typable in ML (see <ref> (Danvy 1998) </ref> for further details), can be made typable, and modules can be replaced with records, but the notion of datatype refinement does not exist. This clearly separates our language design from that of Cayenne.
Reference: <author> Dowek, G., A. Felty, H. Herbelin, G. Huet, C. Murthy, C. Parent, C. Paulin-Mohring, and B. </author> <title> Werner (1993). The Coq proof assistant user's guide. </title> <booktitle> Rapport Techniques 154, </booktitle> <address> IN-RIA, Rocquencourt, France. </address> <note> Version 5.8. </note>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML (Milner, Tofte, and Harper 1990), Caml (Weis and Leroy 1993), or Haskell!(Hudak, Peyton Jones, and Wadler 1992), and those for small, pure languages such as the ones underlying Coq <ref> (Dowek, Felty, Herbelin, Huet, Murthy, Parent, Paulin-Mohring, and Werner 1993) </ref>, NuPrl (Constable et al. 1986), or PX (Hayashi and Nakano 1988). <p> We plan to consider a combination of these ideas in future work. Parent (Parent 1995) proposed to reverse the process of extracting programs from constructive proofs in Coq <ref> (Dowek, Felty, Herbelin, Huet, Murthy, Parent, Paulin-Mohring, and Werner 1993) </ref>, synthesizing proof skeletons from annotated programs. Such proof skeletons contain "holes" corresponding to logical propositions not unlike our constraint formulas. In order to limit the verbosity of the required annotations, she also developed heuristics to reconstruct proofs using higher-order unification.
Reference: <author> Freeman, T. and F. </author> <title> Pfenning (1991). Refinement types for ML. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pp. 268-277. </pages>
Reference-contexts: Also, since his language is pure, he does not consider a value restriction. When compared to traditional type systems for programming languages, perhaps the closest related work is refinement types <ref> (Freeman and Pfenning 1991) </ref>, which also aims at expressing and checking more properties of programs that are already well-typed in ML, rather than admitting more programs as type correct, which is the goal of most other research on extending type systems. <p> Since our design explicitly separates indices from ML expressions, we expect the extension to be mostly straightforward. Another practically important extension may be the introduction of limited forms of intersection types <ref> (Freeman and Pfenning 1991) </ref>, so that more than one dependent type can be assigned to a function without code duplication. Our primary motivation is to allow the programmer to express more program properties through types and thus catch more errors at compile time.
Reference: <author> Harper, R. W., F. Honsell, and G. D. Plotkin (1993, </author> <month> January). </month> <title> A framework for defining logics. </title> <journal> Journal of the ACM 40 (1), </journal> <pages> 143-184. </pages>
Reference-contexts: For instance, it is unclear which expressions are of type i if i is an index object. A more serious problem is how subset sorts should be treated under this alternative view. In a fully dependent type system such as the one which underlies LF <ref> (Harper, Honsell, and Plotkin 1993) </ref> or Coq, there is no differentiation between type index objects and language expressions. In other words, the constraint domain is the same as the language. Therefore, constraint satisfaction is as difficult as program verification, which seems to be intractable in practice.
Reference: <author> Hayashi, S. and H. </author> <title> Nakano (1988). PX: A Computational Logic. </title> <publisher> The MIT Press. </publisher>
Reference-contexts: such as Standard ML (Milner, Tofte, and Harper 1990), Caml (Weis and Leroy 1993), or Haskell!(Hudak, Peyton Jones, and Wadler 1992), and those for small, pure languages such as the ones underlying Coq (Dowek, Felty, Herbelin, Huet, Murthy, Parent, Paulin-Mohring, and Werner 1993), NuPrl (Constable et al. 1986), or PX <ref> (Hayashi and Nakano 1988) </ref>. Type-checking in realistic languages should be theoretically decidable and fl This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No.
Reference: <editor> Hudak, P., S. L. Peyton Jones, and P. Wadler (1992, </editor> <month> May). </month> <title> Report on the programming language Haskell, a non-strict purely-functional programming language, </title> <note> Version 1.2. SIG-PLAN Notices 27 (5). </note>
Reference: <author> Hughes, J., L. Pareto, and A. </author> <title> Sabry (1996). Proving the correctness of reactive systems using sized types. </title> <booktitle> In Conference Record of 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 410-423. </pages>
Reference-contexts: This clearly separates our language design from that of Cayenne. The notion of sized types is introduced in <ref> (Hughes, Pareto, and Sabry 1996) </ref> for proving the correctness of reactive systems. Though there exist some similarities between sized types and datatype refinement in DML (C) for some domain C of natural numbers, the differences are also substantial. We feel that the language presented in (Hughes, Pareto, and Sabry 1996) is <p> sized types is introduced in <ref> (Hughes, Pareto, and Sabry 1996) </ref> for proving the correctness of reactive systems. Though there exist some similarities between sized types and datatype refinement in DML (C) for some domain C of natural numbers, the differences are also substantial. We feel that the language presented in (Hughes, Pareto, and Sabry 1996) is too restrictive for general programming since the type system there can only handle (a minor variation) of primitive recursion. On the other hand, the use of sized types in the correctness proofs of reactive systems cannot be achieved in DML at this moment.
Reference: <author> Jay, C. and M. </author> <month> Sekanina </month> <year> (1996). </year> <title> Shape checking of array programs. </title> <type> Technical Report 96.09, </type> <institution> University of Technology, </institution> <address> Sydney, Australia. </address>
Reference-contexts: On the other hand, the use of sized types in the correctness proofs of reactive systems cannot be achieved in DML at this moment. Jay and Sekanina <ref> (Jay and Sekanina 1996) </ref> have introduced a technique for array bounds checking based on the notion of shape types. Shape checking is a kind of partial evaluation and has very different characteristics and source language when compared to DML (C), where constraints are linear inequalities on integers.
Reference: <author> Kreitz, C., M. Hayden, and J. </author> <month> Hickey </month> <year> (1998, </year> <month> July). </month> <title> A proof environment for the development of group communication systems. </title> <editor> In H. Kirchner and C. Kirchner (Eds.), </editor> <booktitle> 15th International Conference on Automated Deduction, </booktitle> <publisher> LNAI 1421, Lindau, Germany, </publisher> <pages> pp. 317-332. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Some progress has been made towards bridging this gap, for example, by extracting Caml programs from Coq proofs, by synthesizing proof skeletons from Caml programs (Parent 1995), or by embedding fragments of ML into NuPrl <ref> (Kreitz, Hayden, and Hickey 1998) </ref>. In this paper, we address the issue of designing a type system for practical programming in which a restricted form of dependent types is available, allowing more program invariants to be captured by types.
Reference: <author> Milner, R., M. Tofte, and R. W. </author> <title> Harper (1990). The Definition of Standard ML. </title> <address> Cambridge, Massachusetts: </address> <publisher> MIT Press. </publisher>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML <ref> (Milner, Tofte, and Harper 1990) </ref>, Caml (Weis and Leroy 1993), or Haskell!(Hudak, Peyton Jones, and Wadler 1992), and those for small, pure languages such as the ones underlying Coq (Dowek, Felty, Herbelin, Huet, Murthy, Parent, Paulin-Mohring, and Werner 1993), NuPrl (Constable et al. 1986), or PX (Hayashi and Nakano 1988).
Reference: <author> Moggi, E. </author> <year> (1989). </year> <title> Computational lambda-calculus and mon-ads. </title> <booktitle> In Proceedings Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pp. 14-23. </pages>
Reference: <author> Necula, G. </author> <year> (1997). </year> <title> Proof-carrying code. </title> <booktitle> In Conference Record of 24th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 106-119. </pages> <publisher> ACM press. </publisher>
Reference-contexts: We are also interested in using this as a front-end for a certifying compiler (Necula and Lee 1998) which propagates program properties through a compiler where they can be used for optimizations or be packaged with the binaries in the form of proof-carrying code <ref> (Necula 1997) </ref>. 11 Acknowledgements We are grateful to Rowan Davies for many technical discussions regarding the subject of this extended abstract. We also would like to thank Chad Brown for proofreading a draft and providing us with many helpful comments, and the referees for their highly constructive suggestions.
Reference: <author> Necula, G. and P. Lee (1998, </author> <month> June). </month> <title> The design and implementation of a certifying compiler. </title> <booktitle> In ACM SIGPLAN '98 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 333-344. </pages> <publisher> ACM press. </publisher>
Reference-contexts: Our primary motivation is to allow the programmer to express more program properties through types and thus catch more errors at compile time. We are also interested in using this as a front-end for a certifying compiler <ref> (Necula and Lee 1998) </ref> which propagates program properties through a compiler where they can be used for optimizations or be packaged with the binaries in the form of proof-carrying code (Necula 1997). 11 Acknowledgements We are grateful to Rowan Davies for many technical discussions regarding the subject of this extended abstract.
Reference: <author> Owre, S., S. Rajan, J. Rushby, N. Shankar, and M. </author> <month> Srivas </month> <year> (1996, </year> <title> July/August). PVS: Combining specification, proof checking, and model checking. </title> <editor> In R. Alur and T. A. Hen-zinger (Eds.), </editor> <booktitle> Proceedings of the 8th International Conference on Computer-Aided Verification, CAV '96, </booktitle> <address> New Brunswick, NJ, </address> <pages> pp. 411-414. </pages> <publisher> Springer-Verlag LNCS 1102. </publisher>
Reference-contexts: There are many other potential applications of dependent types which can be found in (Xi 1998), including facilitating partial evaluation, performing loop-unrolling, passing dependent types to an assembly language, etc. 9 Related Work Our work falls in between full program verification, either in type theory or systems such as PVS <ref> (Owre, Rajan, Rushby, Shankar, and Srivas 1996) </ref>, and traditional type systems for programming languages. When compared to verification, our system is less expressive but more automatic when constraint domains with practical constraint satisfaction problems are chosen.
Reference: <author> Parent, C. </author> <year> (1995). </year> <title> Synthesizing proofs from programs in the calculus of inductive constructions. </title> <booktitle> In Proceedings of the International Conference on Mathematics for Programs Constructions. </booktitle> <publisher> Springer-Verlag LNCS 947. </publisher>
Reference-contexts: Some progress has been made towards bridging this gap, for example, by extracting Caml programs from Coq proofs, by synthesizing proof skeletons from Caml programs <ref> (Parent 1995) </ref>, or by embedding fragments of ML into NuPrl (Kreitz, Hayden, and Hickey 1998). In this paper, we address the issue of designing a type system for practical programming in which a restricted form of dependent types is available, allowing more program invariants to be captured by types. <p> We plan to consider a combination of these ideas in future work. Parent <ref> (Parent 1995) </ref> proposed to reverse the process of extracting programs from constructive proofs in Coq (Dowek, Felty, Herbelin, Huet, Murthy, Parent, Paulin-Mohring, and Werner 1993), synthesizing proof skeletons from annotated programs. Such proof skeletons contain "holes" corresponding to logical propositions not unlike our constraint formulas.
Reference: <author> Pierce, B. and D. </author> <title> Turner (1998). Local type inference. </title> <booktitle> In Proceedings of the 25th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 252-265. </pages>
Reference-contexts: A key feature in DML (C) which does not exist in either of the above two systems is existential dependent types, which is indispensable in our experiment. Finally, recent work by Pierce and Turner <ref> (Pierce and Turner 1998) </ref> which includes some empirical studies, is based on a similar bi-directional strategy for elaboration, although they are concerned with the interaction of polymorphism and subtyping, while we are concerned with dependent types.
Reference: <author> Sabry, A. and M. </author> <title> Felleisen (1993). Reasoning about programs in continuation-passing style. </title> <booktitle> LISP and Symbolic Computation 6 (3/4), </booktitle> <pages> 289-360. </pages>
Reference: <author> Sannella, D. and A. </author> <title> Tarlecki (1989, February). Toward formal development of ML programs: Foundations and methodology. </title> <type> Technical Report ECS-LFCS-89-71, </type> <institution> Laboratory for Foundations of Computer Science, Depatment of Computer Science, University of Edinburgh. </institution>
Reference-contexts: However, the use of existential types to represent ML types leads to a major loss of information at module boundaries. We would like soon to address this issue by exporting dependent types in signatures, extending DML to full SML. This approach closely relates to Extended ML <ref> (Sannella and Tarlecki 1989) </ref>. <p> Our aims and methods are similar, but much less general in the kind of specifications we can express. On the other hand, this allows a richer source language with fewer annotations and, in practice, avoids interaction with a theorem prover. Extended ML <ref> (Sannella and Tarlecki 1989) </ref> is proposed as a framework for the formal development of programs in a pure fragment of Standard ML. The module system of Extended ML can not only declare the type of a function but also the axioms it satisfies.
Reference: <author> Sulzmann, M., M. Odersky, and M. </author> <title> Wehr (1997). Type inference with constrained types. </title> <booktitle> In Proceedings of 4th International Workshop on Foundations of Object-Oriented Languages. </booktitle>
Reference-contexts: The use of constraints for index domains is quite different from the use of constraints to model subtyping constraints (see, for example, <ref> (Sulzmann, Odersky, and Wehr 1997) </ref>). 10 Conclusion We have extended the entire core of ML with a restricted form of dependent types, yielding the DML (C) language schema. This includes proving the soundness of the type system of DML (C) and designing a type-checking algorithm.
Reference: <author> Weis, P. and X. </author> <title> Leroy (1993). Le langage Caml. </title> <address> Paris: InterEd-itions. </address>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML (Milner, Tofte, and Harper 1990), Caml <ref> (Weis and Leroy 1993) </ref>, or Haskell!(Hudak, Peyton Jones, and Wadler 1992), and those for small, pure languages such as the ones underlying Coq (Dowek, Felty, Herbelin, Huet, Murthy, Parent, Paulin-Mohring, and Werner 1993), NuPrl (Constable et al. 1986), or PX (Hayashi and Nakano 1988).
Reference: <author> Xi, H. </author> <year> (1997, </year> <month> November). </month> <title> Some examples of DML programming. </title> <note> Available at http://www.cs.cmu.edu/~hwxi/DML/examples/. </note>
Reference-contexts: Therefore, lamexp (0) is the type for closed -expressions. A complete implementation of the evaluation function can be found in <ref> (Xi 1997) </ref>. Adding dependent types to ML raises a number of theoretical and pragmatic questions. We briefly summarize our results and design choices. The first question that arises is the meaning of expressions with effects when they occur as index objects to type families. <p> We have also implemented our design for a fragment of ML which encompasses all these features. The only main feature in the core of ML which we have not implemented is records. In addition, we have experimented with different constraint domains and applications. Many non-trivial examples are available at <ref> (Xi 1997) </ref>. For the domain of linear inequalities on integers, they include quicksort on arrays, mergesort on lists, a red/black tree implementation, a highly optimized byte copy function, an implementation of Knuth-Morris-Pratt's algorithm for string matching and others in which array bound checks can be statically eliminated without excessive annotations.
Reference: <author> Xi, H. </author> <year> (1998). </year> <title> Dependent Types in Practical Programming. </title> <publisher> Ph. </publisher>
Reference-contexts: We can maintain this purity and still make the connection to run-time values by using singleton types, such as int (n) which contains just the integer n. This is critical for practical applications such as static elimination of array bound checking <ref> (Xi and Pfenning 1998) </ref>. The second question is the decidability and practicality of type-checking. We address this in two steps: the first step is to define an explicitly typed (and unacceptably verbose) language for which type-checking is easily reduced to constraint satisfaction in C. <p> Also the annotations are mechanically verified, and therefore can be fully trusted as program documentation. Due to length restrictions, it is impossible to present here all aspects of DML (C). Instead, we concentrate on its main features. In contrast to <ref> (Xi and Pfenning 1998) </ref>, this extended abstract emphasizes the theoretical foundation of DML (C), showing that the type system of DML (C) is sound and type-checking in DML (C) can be made practical. We refer the interested reader to (Xi 1998) for the details. <p> Instead, we concentrate on its main features. In contrast to (Xi and Pfenning 1998), this extended abstract emphasizes the theoretical foundation of DML (C), showing that the type system of DML (C) is sound and type-checking in DML (C) can be made practical. We refer the interested reader to <ref> (Xi 1998) </ref> for the details. The remainder of the paper is organized as follows. We present a monomorphic language ML 0 in Section 2, which is a simply typed -calculus with general pattern matching. <p> This is the case, for example, for integer inequalities, which our implementation solves by a variant of the Fourier variable elimination method. Empirical results and further references can be found in <ref> (Xi and Pfenning 1998) </ref>. 4 Universal Dependent Types We now present ML 0 (C), which extends ML 0 with universal dependent types. Given a domain C of constraints, the syntax of ML 0 (C) is given in Figure 4. Note that only the syntax different from ML 0 is present. <p> A thoroughly explained example on elaboration and constraint generation is available in <ref> (Xi 1998) </ref>. 6 Existential Dependent Types In practice, the constraint domain must be relatively simple to permit the implementation of an effective constraint solver. Therefore there remain many properties of indices which cannot be expressed. <p> We have chosen the latter in our current implementation. Please see <ref> (Xi 1998) </ref> for details. 7 Polymorphism and Effects It is straightforward to extend ML ; 0 (C) with polymor phism. We have designed a two-phase elaboration algorithm which elaborates a program as follows. Phase one It verifies that the index erasure of the program is a well-typed ML program. <p> Soundness can be recovered if we adopt a value restriction, that is, we replace the rule (ty-ilam) with the following. ; a : fl; ` v : t After this, the development is standard, which is thoroughly explained in <ref> (Xi 1998) </ref>. 8 Applications 8.1 Program Error Detection A red/black tree is a balanced binary tree which satisfies the following conditions: (a) all leaves are marked black and all other nodes are marked either red or black; (b) for every node there are the same number of black nodes on every <p> Please see <ref> (Xi and Pfenning 1998) </ref> for the details. 8.3 Dead Code Elimination The following function zip zips two lists together. If the clause zip (_, _) = raise zipException is missing, then ML compilers will issue a warning message stating that zip may result in a match exception. <p> However, the benefit of such dead code elimination for error detection can be readily realized. We refer the interested reader to (Xi 1999) for further explanation. 8.4 Other Applications There are many other potential applications of dependent types which can be found in <ref> (Xi 1998) </ref>, including facilitating partial evaluation, performing loop-unrolling, passing dependent types to an assembly language, etc. 9 Related Work Our work falls in between full program verification, either in type theory or systems such as PVS (Owre, Rajan, Rushby, Shankar, and Srivas 1996), and traditional type systems for programming languages. <p> This includes proving the soundness of the type system of DML (C) and designing a type-checking algorithm. Type annotations are required, but not overly verbose. The algorithm has shown itself to be practical for typical programs and constraint domains, such as linear inequalities over integers for array bounds checking <ref> (Xi and Pfenning 1998) </ref>. In addition, we have finished a prototype implementation of DML (C) in which all the major features in the core of ML except records are available. The only reason for omitting records is that we already have tuples and we would like to simplify the implementation.
Reference: <author> D. </author> <type> thesis, </type> <institution> Carnegie Mellon University. </institution> <note> pp. viii+189. Forthcoming. The current version is available as http://www.cs.cmu.edu/~hwxi/DML/thesis.ps. </note>
Reference: <author> Xi, H. </author> <year> (1999, </year> <month> January). </month> <title> Dead code elimination through dependent types. </title> <booktitle> In The First International Workshop on Practical Aspects of Declarative Languages, </booktitle> <address> San Antonio, Texas. </address> <note> To appear. </note>
Reference-contexts: However, the benefit of such dead code elimination for error detection can be readily realized. We refer the interested reader to <ref> (Xi 1999) </ref> for further explanation. 8.4 Other Applications There are many other potential applications of dependent types which can be found in (Xi 1998), including facilitating partial evaluation, performing loop-unrolling, passing dependent types to an assembly language, etc. 9 Related Work Our work falls in between full program verification, either in
Reference: <author> Xi, H. and F. Pfenning (1998, </author> <month> June). </month> <title> Eliminating array bound checking through dependent types. </title> <booktitle> In Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 249-257. </pages>
Reference-contexts: We can maintain this purity and still make the connection to run-time values by using singleton types, such as int (n) which contains just the integer n. This is critical for practical applications such as static elimination of array bound checking <ref> (Xi and Pfenning 1998) </ref>. The second question is the decidability and practicality of type-checking. We address this in two steps: the first step is to define an explicitly typed (and unacceptably verbose) language for which type-checking is easily reduced to constraint satisfaction in C. <p> Also the annotations are mechanically verified, and therefore can be fully trusted as program documentation. Due to length restrictions, it is impossible to present here all aspects of DML (C). Instead, we concentrate on its main features. In contrast to <ref> (Xi and Pfenning 1998) </ref>, this extended abstract emphasizes the theoretical foundation of DML (C), showing that the type system of DML (C) is sound and type-checking in DML (C) can be made practical. We refer the interested reader to (Xi 1998) for the details. <p> Instead, we concentrate on its main features. In contrast to (Xi and Pfenning 1998), this extended abstract emphasizes the theoretical foundation of DML (C), showing that the type system of DML (C) is sound and type-checking in DML (C) can be made practical. We refer the interested reader to <ref> (Xi 1998) </ref> for the details. The remainder of the paper is organized as follows. We present a monomorphic language ML 0 in Section 2, which is a simply typed -calculus with general pattern matching. <p> This is the case, for example, for integer inequalities, which our implementation solves by a variant of the Fourier variable elimination method. Empirical results and further references can be found in <ref> (Xi and Pfenning 1998) </ref>. 4 Universal Dependent Types We now present ML 0 (C), which extends ML 0 with universal dependent types. Given a domain C of constraints, the syntax of ML 0 (C) is given in Figure 4. Note that only the syntax different from ML 0 is present. <p> A thoroughly explained example on elaboration and constraint generation is available in <ref> (Xi 1998) </ref>. 6 Existential Dependent Types In practice, the constraint domain must be relatively simple to permit the implementation of an effective constraint solver. Therefore there remain many properties of indices which cannot be expressed. <p> We have chosen the latter in our current implementation. Please see <ref> (Xi 1998) </ref> for details. 7 Polymorphism and Effects It is straightforward to extend ML ; 0 (C) with polymor phism. We have designed a two-phase elaboration algorithm which elaborates a program as follows. Phase one It verifies that the index erasure of the program is a well-typed ML program. <p> Soundness can be recovered if we adopt a value restriction, that is, we replace the rule (ty-ilam) with the following. ; a : fl; ` v : t After this, the development is standard, which is thoroughly explained in <ref> (Xi 1998) </ref>. 8 Applications 8.1 Program Error Detection A red/black tree is a balanced binary tree which satisfies the following conditions: (a) all leaves are marked black and all other nodes are marked either red or black; (b) for every node there are the same number of black nodes on every <p> Please see <ref> (Xi and Pfenning 1998) </ref> for the details. 8.3 Dead Code Elimination The following function zip zips two lists together. If the clause zip (_, _) = raise zipException is missing, then ML compilers will issue a warning message stating that zip may result in a match exception. <p> However, the benefit of such dead code elimination for error detection can be readily realized. We refer the interested reader to (Xi 1999) for further explanation. 8.4 Other Applications There are many other potential applications of dependent types which can be found in <ref> (Xi 1998) </ref>, including facilitating partial evaluation, performing loop-unrolling, passing dependent types to an assembly language, etc. 9 Related Work Our work falls in between full program verification, either in type theory or systems such as PVS (Owre, Rajan, Rushby, Shankar, and Srivas 1996), and traditional type systems for programming languages. <p> This includes proving the soundness of the type system of DML (C) and designing a type-checking algorithm. Type annotations are required, but not overly verbose. The algorithm has shown itself to be practical for typical programs and constraint domains, such as linear inequalities over integers for array bounds checking <ref> (Xi and Pfenning 1998) </ref>. In addition, we have finished a prototype implementation of DML (C) in which all the major features in the core of ML except records are available. The only reason for omitting records is that we already have tuples and we would like to simplify the implementation.
Reference: <author> Zenger, C. </author> <year> (1997). </year> <title> Indexed types. </title> <booktitle> Theoretical Computer Science 187, </booktitle> <pages> 147-165. </pages>
Reference-contexts: Most closely related to our work is the system of indexed types developed independently by Zenger in his forthcoming Ph.D. Thesis (Zenger 1998) (an earlier version of which is described in <ref> (Zenger 1997) </ref>). He works in the context of of lazy functional programming. His language is clean and elegant and his applications (which significantly overlap with ours) are compelling.
Reference: <author> Zenger, C. </author> <year> (1998). </year> <note> Indizierte Typen. </note> <author> Ph. D. </author> <type> thesis, </type> <institution> Fakultat fur Informatik, Universitat Karlsruhe. Forthcoming. </institution>
Reference-contexts: Since it extends ML conservatively, it can be used sparingly as existing ML programs will work as before (if there is no keyword conflict). Most closely related to our work is the system of indexed types developed independently by Zenger in his forthcoming Ph.D. Thesis <ref> (Zenger 1998) </ref> (an earlier version of which is described in (Zenger 1997)). He works in the context of of lazy functional programming. His language is clean and elegant and his applications (which significantly overlap with ours) are compelling.
References-found: 29

