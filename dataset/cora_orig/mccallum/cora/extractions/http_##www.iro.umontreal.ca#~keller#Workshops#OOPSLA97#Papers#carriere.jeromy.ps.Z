URL: http://www.iro.umontreal.ca/~keller/Workshops/OOPSLA97/Papers/carriere.jeromy.ps.Z
Refering-URL: http://www.iro.umontreal.ca/~keller/Workshops/OOPSLA97/index.html
Root-URL: http://www.iro.umontreal.ca
Email: -sjc, kazman-@sei.cmu.edu  
Title: Assessing Design Quality From a Software Architectural Perspective  
Author: Jeromy Carrire, Rick Kazman 
Address: Pittsburgh, PA 15213  
Affiliation: Software Engineering Institute, Carnegie Mellon University  
Abstract: In this paper, we take the position that good object oriented designs accrue from attention to both the design of objects and classes and to the architectural framework which defines how instances of those classes interact. We argue that an architecture should be assessed for conceptual integrity, and describe tool support for making such an assessment. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Abowd, L. Bass, P. Clements, R. Kazman, L. Northrop, A. Zaremski, </author> <title> Recommended Best Industrial Practice for Software Architecture Evaluation, </title> <institution> Software Engineering Institute Technical Report, CMU/SEI-96-TR-025, </institution> <year> 1996. </year>
Reference: [2] <author> L. Bass, P. Clements, R. Kazman, </author> <title> Software Architecture in Practice, </title> <publisher> Addison-Wesley, 1997 (in press). </publisher>
Reference-contexts: We have gathered and documented a considerable amount of expertise aimed at answering the question of what makes a good design, object oriented or otherwise ([1], <ref> [2] </ref>). We have also produced and widely applied a method for investigating the goodness of designs [4]. So, what has this wealth of experience taught us? In our experience, design goodness ows from the ability to do architectural reasoning. <p> This appears to merely replace one question with another, for what factors contribute to the ability to do architectural reasoning? We will discuss two of these factors (a more complete discussion can be found in <ref> [2] </ref>): the existence of an architecture, on top of any object/class design the internal regularity (sometimes called pattern-based simplicity or conceptual integrity [3]) of the architectural design For example, Figure 1 shows the software architecture of VANISH, a medium-sized (about 50,000 lines of code) system for prototyping visualizations, written in C++.
Reference: [3] <author> F. Brooks, </author> <title> The Mythical Man-MonthEssays on Software Engineering, </title> <publisher> Addison-Wesley, </publisher> <year> 1975. </year>
Reference-contexts: with another, for what factors contribute to the ability to do architectural reasoning? We will discuss two of these factors (a more complete discussion can be found in [2]): the existence of an architecture, on top of any object/class design the internal regularity (sometimes called pattern-based simplicity or conceptual integrity <ref> [3] </ref>) of the architectural design For example, Figure 1 shows the software architecture of VANISH, a medium-sized (about 50,000 lines of code) system for prototyping visualizations, written in C++.
Reference: [4] <author> R. Kazman, G. Abowd, L. Bass, P. Clements, </author> <title> Scenario-Based Analysis of Software Architecture, </title> <journal> IEEE Software, </journal> <month> Nov. </month> <year> 1996, </year> <pages> pp. 47-55. </pages>
Reference-contexts: We have gathered and documented a considerable amount of expertise aimed at answering the question of what makes a good design, object oriented or otherwise ([1], [2]). We have also produced and widely applied a method for investigating the goodness of designs <ref> [4] </ref>. So, what has this wealth of experience taught us? In our experience, design goodness ows from the ability to do architectural reasoning.
Reference: [5] <author> R. Kazman, J. Carrire, </author> <title> An Adaptable Software Architecture for Rapidly Creating Information Visualizations, </title> <booktitle> Proceedings of Graphics Interface 96, (Toronto, ON), </booktitle> <month> May </month> <year> 1996, </year> <pages> pp. 17-27. </pages>
Reference: [6] <author> G. Murphy, D. Notkin, </author> <title> Lightweight Lexical Source Model Extraction, </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> Vol. 5, No. 3, </volume> <month> July </month> <year> 1996, </year> <pages> p. 262-292. </pages>
Reference-contexts: Parsing is the most well-known method for extracting static (as opposed to dynamic or run-time) elements from source code. However, implementing a parser is difficult and time consuming. We have explored the use of an alternative for static extraction: lightweight lexical extraction using regular expression-based patterns <ref> [6] </ref>. This technique does not purport to be a fully-accurate one: there are a number of particular types of a c 3 source elements that it is not effective at extracting. One such type of element is calls through virtual functions.
Reference: [7] <editor> UIMS Tool Developers Workshop, </editor> <title> A Metamodel for the Runtime Architecture of an Interactive System, </title> <journal> SIGCHI Bulletin, </journal> <volume> 24(1), </volume> <month> January </month> <year> 1992, </year> <month> pp32-37. </month>
Reference-contexts: VANISH provides a programming environment for creating visualizations, and a means of easily integrating new domains to be visualized and new interaction toolkits. VANISHs software architecture follows the Arch metamodel <ref> [7] </ref>, which divides an interactive application into 5 layers: Functional Core (the systems core functionality or purpose), Functional Core Adapter (which mediates between the dialogue and functional core by providing a unified, generic view of the functional core to the dialogue), Dialogue (a programmable mediator between domain specific and presentation specific
References-found: 7

