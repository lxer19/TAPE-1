URL: http://www.cs.washington.edu/homes/todd/papers/quals.ps
Refering-URL: http://www.cs.washington.edu/homes/todd/papers/
Root-URL: 
Title: Dubious: A Modular, Statically Typed OO Core Language  
Author: Todd D. Millstein 
Date: January 1998  
Abstract: Three trends in the development of advanced object-oriented languages are toward better encapsulation, increased expressiveness, and strong, static typing. To understand the interaction of these three design goals we have developed Dubious, a small and highly uniform core language. Dubious provides a simple and exible object model as well as first-class modules. In addition, Dubious features several advanced language constructs, including multimethod dispatch, first-class generic functions, and the complete separation of inheritance and subtyping. Finally, the language has an orthogonal type system which statically guarantees type safety. The type system allows modules to be safely type-checked in isolation, facilitating independent development and incremental modification of programs. 
Abstract-found: 1
Intro-found: 1
Reference: [Abadi & Cardelli 96] <author> Martn Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1996. </year> <month> 22 </month>
Reference-contexts: In addition, our treatment of modules as first-class declaration blocks was inuenced by Schmidts development and discussion of modules. Abadi and Cardellis object calculus <ref> [Abadi & Cardelli 96] </ref> is a simple analogue of the lambda calculus for object-oriented programming. Dubious adopted the idea of simulating assignment via method update from this calculus. However, there are several important differences between the two languages. The Abadi/ Cardelli calculus relies on a singly-dispatched model.
Reference: [Baumgartner et al. 96] <author> Gerald Baumgartner, Konstantin Laufer, and Vincent F. Russo. </author> <title> On the Interaction of Object-Oriented Design Patterns and Programming Languages. </title> <institution> Department of Computer Science, Purdue University, CSD-TR-96-020, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: It has been argued that these three language features (first-class functions, multimethod dispatch, and separation of subtyping and inheritance) are the most important language constructs to add to conventional OO languages like C++ [Stroustrup 91] in order to allow the simple expression of many well-known design patterns <ref> [Gamma et al. 95, Baumgartner et al. 96] </ref>. Finally, similar to the evolution of functional languages, the OO community has moved toward strong, static type systems.
Reference: [Bobrow et al. 86] <author> Daniel G. Bobrow, Kenneth Kahn, George Kiczales, Larry Masinter, Mark Stefik, and Frank Zdybel. CommonLoops: </author> <title> Merging Lisp and Object-Oriented Programming. </title> <editor> In Norman Meyrowitz (editor), </editor> <booktitle> OOPSLA 86 Conference Proceedings, </booktitle> <address> Portland, Oregon, </address> <month> September </month> <year> 1986, </year> <title> volume 21, </title> <journal> number 11 of ACM SIGPLAN Notices, </journal> <pages> pp. 17-29. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> November, </month> <year> 1986. </year>
Reference-contexts: Multimethod dispatch, a natural generalization of dispatching on a single receiver class as in traditional OO languages, allows the simple expression of constructs that are otherwise unwieldy <ref> [Bobrow et al. 86, Moon 86, Chambers 92] </ref>.
Reference: [Castagna 96] <author> Giuseppe Castagna. </author> <title> Object-Oriented Programming A Unified Foundation, </title> <address> Birkhuser, Boston, </address> <year> 1996. </year>
Reference-contexts: It can do so very easily by creating a new generic function which inherits all methods of the default print generic function, while overriding the method for integers, as in Figure 2-3. The my_print * The & syntax is borrowed from Castagnas lambda-& calculus <ref> [Castagna 96] </ref>. 8 generic function acts exactly like the standard print function, except that my_print invokes its special method when passed an int. <p> However, this makes simulating inheritance infeasible, because each method has its set of specializers hard-coded rather than implicit. Simulating inheritance would necessitate a way to erase these specializers and replace them with new ones, which is fairly unnatural. Castagnas l-& calculus <ref> [Castagna 96] </ref> is closer in spirit to our work, as it attempts to formalize multimethod dispatching. However, Castagnas calculus has several simplifications that make it less expressive but easier to type-check, as compared with our work.
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <editor> In O. Lehrmann-Madsen, editor, </editor> <booktitle> ECOOP 92 Conference Proceedings, </booktitle> <address> Utrecht, the Netherlands, June/July, </address> <year> 1992, </year> <booktitle> volume 615 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 33-56. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Finally, separate type-checking allows a module to be type-checked once and then linked into a variety of applications. There has also been a push toward more expressive language features. Several OO languages have adopted elements of functional programming such as first-class functions, in order to provide more generic programming <ref> [Goldberg & Robson 83, Ungar & Smith 87, Chambers 92] </ref>. Multimethod dispatch, a natural generalization of dispatching on a single receiver class as in traditional OO languages, allows the simple expression of constructs that are otherwise unwieldy [Bobrow et al. 86, Moon 86, Chambers 92]. <p> Multimethod dispatch, a natural generalization of dispatching on a single receiver class as in traditional OO languages, allows the simple expression of constructs that are otherwise unwieldy <ref> [Bobrow et al. 86, Moon 86, Chambers 92] </ref>. <p> Java [Gosling et al. 96] guarantees type safety but does not do so completely statically, and it also does not provide any of the 3 advanced language features. Cecil <ref> [Chambers 92, Chambers 95] </ref> has the advanced language features and a strong, static type system, but it lacks support for separate type-checking. We have developed Dubious, a small and highly uniform core language for understanding the interaction of these three design goals. <p> The left-hand object E fun acts as a generic function [Paepcke 93], which is a collection of multimethods. The multimethod syntax is borrowed from Cecil <ref> [Chambers 92] </ref>. <p> The values of the argument objects determine at run-time which of the generic functions methods is to be invoked. Our method lookup semantics is borrowed from Cecil <ref> [Chambers 92] </ref>: Retrieve all methods attached to the generic function object. Retrieve the subset of the methods that are applicable to the tuple of actual argument objects (O 1 ,...,O n ). <p> The combination of these two simplifications allow Castagna to guarantee 21 type safety of the calculus with only two restrictions, while giving up the generality which Dubious retains. Finally, the l-& calculus does not model first-class modules. The syntax and semantics for multimethods is borrowed from Cecil <ref> [Chambers 92, Chambers 95] </ref> and from the work of Chambers and Leavens [Chambers & Leavens 95] on type-checking for multimethods. The ideas of extending and most-extending modules are also products of their work. Dubious has the most in common with BeCecil [Chambers & Leavens 96], its predecessor.
Reference: [Chambers 95] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale: </title> <type> Version 2.0. </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> December, </month> <year> 1995. </year>
Reference-contexts: Java [Gosling et al. 96] guarantees type safety but does not do so completely statically, and it also does not provide any of the 3 advanced language features. Cecil <ref> [Chambers 92, Chambers 95] </ref> has the advanced language features and a strong, static type system, but it lacks support for separate type-checking. We have developed Dubious, a small and highly uniform core language for understanding the interaction of these three design goals. <p> The combination of these two simplifications allow Castagna to guarantee 21 type safety of the calculus with only two restrictions, while giving up the generality which Dubious retains. Finally, the l-& calculus does not model first-class modules. The syntax and semantics for multimethods is borrowed from Cecil <ref> [Chambers 92, Chambers 95] </ref> and from the work of Chambers and Leavens [Chambers & Leavens 95] on type-checking for multimethods. The ideas of extending and most-extending modules are also products of their work. Dubious has the most in common with BeCecil [Chambers & Leavens 96], its predecessor.
Reference: [Chambers & Leavens 95] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and Modules for Multi-Methods. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(6) </volume> <pages> 805-843. </pages> <month> November, </month> <year> 1995. </year>
Reference-contexts: So colorPoint can be sent to the x, y, and equal generic functions as well as to the color generic function. The type-checking rules which are used to statically guarantee type safety can be divided into client-side and implementation-side checks <ref> [Chambers & Leavens 95] </ref>. We now discuss each of these in turn. 3.1.2 Client-sideType-checking Client-side checking ensures that clients respect the types of the objects which they manipulate. <p> This is an unacceptable restriction, as it forces entire hierarchies of objects into a single module. 18 In order to alleviate some of this inexibility, Chambers and Leavens <ref> [Chambers & Leavens 95] </ref> introduced the notion of an extension module. Their informal idea was that a module can extend another as an alternative to importing. The extending module, unlike an ordinary importer, is considered to be in the same contour as the extendee for type-checking purposes. <p> This ensures that extensions dont affect objects from an enclosing contour. Our version of extension modules is more restrictive than the model described by Chambers and Leavens <ref> [Chambers & Leavens 95] </ref>. Treating an extension module as being in the same contour as the extendee is not safe in Dubious. This would allow arbitrary modifications to a contour which, even if locally type-safe, could easily cause an existing nested contour to become unsafe. <p> The problem occurs because extend1 and extend2 do not see each other statically, although they can easily be simultaneously visible at run-time. Our solution is borrowed from Chambers and Leavens <ref> [Chambers & Leavens 95] </ref>. We impose the condition that each module must have a single most-extending module, checked at link-time. <p> Finally, the l-& calculus does not model first-class modules. The syntax and semantics for multimethods is borrowed from Cecil [Chambers 92, Chambers 95] and from the work of Chambers and Leavens <ref> [Chambers & Leavens 95] </ref> on type-checking for multimethods. The ideas of extending and most-extending modules are also products of their work. Dubious has the most in common with BeCecil [Chambers & Leavens 96], its predecessor. Problems with type-checking of BeCecil led to our redesign of the language from first principles.
Reference: [Chambers & Leavens 96] <author> Craig Chambers and Gary T. Leavens. BeCecil, </author> <title> A Core Object-Oriented Language with Block Structure and Multimethods: Semantics and Typing. </title> <institution> Department of Computer Science and Engineering, University of Washington, UW-CSE-96-12-02, </institution> <month> December </month> <year> 1996. </year>
Reference-contexts: Despite this successful type-checking, a message not understood error occurs at run-time upon invocation of x (point), because the necessary method has not yet been attached to the x generic function. Our solution to this problem is to partition a program into textual regions called contours, as in BeCecil <ref> [Chambers & Leavens 96] </ref>. Instead of type-checking a program globally, each contour is type-checked separately, given only information about lexically-enclosing contours. <p> The ideas of extending and most-extending modules are also products of their work. Dubious has the most in common with BeCecil <ref> [Chambers & Leavens 96] </ref>, its predecessor. Problems with type-checking of BeCecil led to our redesign of the language from first principles. The resulting language is simpler in several ways. First, Dubious has a global inheritance graph, rather than maintaining an inheritance graph per contour, as in BeCecil.
Reference: [Church 41] <author> Alonzo Church. </author> <title> The Calculi of Lambda Conversion, </title> <publisher> Princeton University Press, </publisher> <address> Princeton, NJ, </address> <year> 1941. </year> <editor> [Clinger & Rees 91]William Clinger and Jonathan Rees (Editors). </editor> <title> Revised 4 Report on the Algorithmic Language Scheme. </title> <month> November </month> <year> 1991. </year>
Reference-contexts: Indeed, it is Turing-equivalent. (We do not provide a proof of this, but it is easy to show how to simulate each lambda calculus <ref> [Church 41] </ref> construct in our language. Turing-equivalence then follows from the Turing-equivalence of the lambda calculus.) shows how some common idioms are programmed in Dubious.
Reference: [Gamma et al. 95] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1995. </year>
Reference-contexts: It has been argued that these three language features (first-class functions, multimethod dispatch, and separation of subtyping and inheritance) are the most important language constructs to add to conventional OO languages like C++ [Stroustrup 91] in order to allow the simple expression of many well-known design patterns <ref> [Gamma et al. 95, Baumgartner et al. 96] </ref>. Finally, similar to the evolution of functional languages, the OO community has moved toward strong, static type systems.
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: Finally, separate type-checking allows a module to be type-checked once and then linked into a variety of applications. There has also been a push toward more expressive language features. Several OO languages have adopted elements of functional programming such as first-class functions, in order to provide more generic programming <ref> [Goldberg & Robson 83, Ungar & Smith 87, Chambers 92] </ref>. Multimethod dispatch, a natural generalization of dispatching on a single receiver class as in traditional OO languages, allows the simple expression of constructs that are otherwise unwieldy [Bobrow et al. 86, Moon 86, Chambers 92].
Reference: [Gosling et al. 96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1996. </year>
Reference-contexts: For example, C++ [Stroustrup 91] has fairly sophisticated encapsulation mechanisms (the notions of protected and friends, for example) and allows separate type-checking of files, but it neither provides the advanced language features mentioned above nor type safety. Java <ref> [Gosling et al. 96] </ref> guarantees type safety but does not do so completely statically, and it also does not provide any of the 3 advanced language features. Cecil [Chambers 92, Chambers 95] has the advanced language features and a strong, static type system, but it lacks support for separate type-checking.
Reference: [Milner et al. 90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Just as the let expression allows local declarations to an expression, local is the corresponding way to provide local declarations to a declaration sequence. This construct is similar to the construct of the same name in ML <ref> [Milner et al. 90] </ref>. Finally, with explicit declarations in the language, there is no longer a need for a predefined any object, so we drop this expression from the language. The let and local constructs provide encapsulation, since the local declarations are not visible outside of the construct. <p> For example, the equal_seg application invokes the (colorPoint colorPoint) equal method. Because a module is a first-class object like any other, it can be passed as an argument to a function and returned as the result of a function. Therefore, we can encode ML-style functors <ref> [Milner et al. 90] </ref>. For example, Figure 2-6 shows a generic function that takes a module containing an element elem and a partial order function lt_eq on elements and returns a module that implements an ordered list of elems. <p> Finally, in order to make modules truly first-class entities, able to be passed as parameters and returned as results from functions, we will need to introduce a module type, similar to a signature in ML <ref> [Milner et al. 90] </ref>. In summary, there is still much work to be done in developing a language with sophisticated support for encapsulation, expressiveness, and type safety. We have defined a language which is a good basis for understanding the associated tradeoffs and conicts.
Reference: [Moon 86] <author> David A. Moon. </author> <title> Object-Oriented Programming with Flavors. </title> <editor> In Norman Meyrowitz (editor), </editor> <booktitle> OOPSLA 86 Conference Proceedings, </booktitle> <address> Portland, Oregon, </address> <month> September </month> <year> 1986, </year> <title> volume 21, </title> <journal> number 11 of ACM SIGPLAN Notices, </journal> <pages> pp. 1-8. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> November, </month> <year> 1986. </year>
Reference-contexts: Multimethod dispatch, a natural generalization of dispatching on a single receiver class as in traditional OO languages, allows the simple expression of constructs that are otherwise unwieldy <ref> [Bobrow et al. 86, Moon 86, Chambers 92] </ref>.
Reference: [Paepcke 93] <author> Andreas Paepcke. </author> <title> Object-Oriented Programming: The CLOS Perspective. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The left-hand object E fun acts as a generic function <ref> [Paepcke 93] </ref>, which is a collection of multimethods. The multimethod syntax is borrowed from Cecil [Chambers 92].
Reference: [Schmidt 94] <author> David A. Schmidt. </author> <title> The Structure of Typed Programming Languages. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1994. </year>
Reference-contexts: When the extension objects try to conform to Point, they are required to inherit from an object that already conforms to Point. Therefore, the original module is forced to provide at least one implementation of points. 4 Related Work The language design principles which are espoused by Schmidt <ref> [Schmidt 94] </ref> and used to create an elegant, simple, and highly orthogonal language were a model for our design of Dubious. In addition, our treatment of modules as first-class declaration blocks was inuenced by Schmidts development and discussion of modules.
Reference: [Snyder 86] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <editor> In Norman Meyrowitz (editor), </editor> <booktitle> OOPSLA 86 Conference Proceedings, </booktitle> <address> Portland, Oregon, </address> <month> September </month> <year> 1986, </year> <title> volume 21, </title> <journal> number 11 of ACM SIGPLAN Notices, </journal> <pages> pp. 38-45. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> November, </month> <year> 1986. </year>
Reference-contexts: There has been much work in the OO community on understanding the distinction between subtyping and inheritance <ref> [Snyder 86] </ref>, and a complete separation of these notions makes a language cleaner and allows some programming idioms to be more easily expressed in a statically type-safe way.
Reference: [Stroustrup 91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language: Second Edition. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1991. </year>
Reference-contexts: It has been argued that these three language features (first-class functions, multimethod dispatch, and separation of subtyping and inheritance) are the most important language constructs to add to conventional OO languages like C++ <ref> [Stroustrup 91] </ref> in order to allow the simple expression of many well-known design patterns [Gamma et al. 95, Baumgartner et al. 96]. Finally, similar to the evolution of functional languages, the OO community has moved toward strong, static type systems. <p> Because of these difficulties, most OO languages inevitably fail to provide adequate support for at least one of these goals. For example, C++ <ref> [Stroustrup 91] </ref> has fairly sophisticated encapsulation mechanisms (the notions of protected and friends, for example) and allows separate type-checking of files, but it neither provides the advanced language features mentioned above nor type safety. <p> Such a mechanism would play a similar role to the protected construct in C++ <ref> [Stroustrup 91] </ref>. Finally, in order to make modules truly first-class entities, able to be passed as parameters and returned as results from functions, we will need to introduce a module type, similar to a signature in ML [Milner et al. 90].
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> Self: The Power of Simplicity. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> OOPSLA 87 Conference Proceedings, Orlando, Florida, </booktitle> <volume> volume 22, number 12, </volume> <booktitle> of ACM SIGPLAN Notices, </booktitle> <pages> pp. 227-241. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> December, </month> <year> 1987. </year> <month> 23 </month>
Reference-contexts: Finally, separate type-checking allows a module to be type-checked once and then linked into a variety of applications. There has also been a push toward more expressive language features. Several OO languages have adopted elements of functional programming such as first-class functions, in order to provide more generic programming <ref> [Goldberg & Robson 83, Ungar & Smith 87, Chambers 92] </ref>. Multimethod dispatch, a natural generalization of dispatching on a single receiver class as in traditional OO languages, allows the simple expression of constructs that are otherwise unwieldy [Bobrow et al. 86, Moon 86, Chambers 92]. <p> In other words, state changes to p1 are at the same time state changes to p2, since the two objects invoke the same x method. This gives us the same semantics for state as in Self <ref> [Ungar & Smith 87] </ref>. This semantics is useful, but at times we may want an alternative semantics, where an object holds state that is not inherited by its children. To support this, we introduce a second specializer symbol, @=.
References-found: 19

