URL: http://www.cs.utexas.edu/users/lorenzo/papers/tse.ps
Refering-URL: http://www.cs.utexas.edu/users/lorenzo/publications.html
Root-URL: 
Title: Message Logging: Pessimistic, Optimistic, Causal and Optimal  
Author: Lorenzo Alvisi Keith Marzullo 
Keyword: Index Terms Message logging, optimistic protocols, pessimistic protocols, checkpoint-restart protocols, resilient processes, specification of fault-tolerance techniques.  
Address: Austin, TX  La Jolla, CA  
Affiliation: The University of Texas at Austin Department of Computer Sciences  University of California, San Diego Department of Computer Science and Engineering  
Abstract: Message-logging protocols are an integral part of a popular technique for implementing processes that can recover from crash failures. All message-logging protocols require that, when recovery is complete, there be no orphan processes, which are surviving processes whose states are inconsistent with the recovered state of a crashed process. We give a precise specification of the consistency property "no orphan processes". From this specification, we describe how different existing classes of message-logging protocols (namely optimistic, pessimistic, and a class that we call causal) implement this property. We then propose a set of metrics to evaluate the performance of message-logging protocols, and characterize the protocols that are optimal with respect to these metrics. Finally, starting from a protocol that relies on causal delivery order, we show how to derive optimal causal protocols that tolerate f overlapping failures and recoveries for a parameter f : 1 f n.
Abstract-found: 1
Intro-found: 1
Reference: [AHM93] <author> Lorenzo Alvisi, Bruce Hoppe, and Keith Marzullo. </author> <title> Nonblocking and orphan-free message logging protocols. </title> <booktitle> In Proceedings of the 23rd Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 145-154, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: We call such protocols causal message-logging protocols, for reasons that will become clear later. Examples of this class are presented in [EZ92] and <ref> [AHM93] </ref>. All message-logging protocols must address the issue of processes that communicate with the environment. It is natural to model such communications in terms of the sending and delivery of messages. <p> We call the protocols that implement Property (10) causal message-logging protocols. Family-Based-Logging <ref> [AHM93] </ref> and Manetho [EZ92] are two examples of causal message-logging protocols for the special cases f = 1 and f = n respectively. 5 Optimal Message-Logging Protocols We now consider four metrics with which one can compare different message-logging protocols.
Reference: [Alv96] <author> L. Alvisi. </author> <title> Understanding the Message Logging Paradigm for Masking Process Crashes. </title> <type> PhD thesis, </type> <institution> Cornell University Department of Computer Science, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: There are other issues of message-logging protocols that are out of the scope of this paper, such as communication with the environment, checkpointing, and recovery. A discussion of these issues in the context of causal message logging is presented in <ref> [Alv96] </ref>. The paper proceeds as follows. Section 2 describes the system model commonly assumed for message-logging protocols. Section 3 discusses the notion of consistency in message-logging protocols. <p> A thorough discussion of optimal protocols and of the tradeoffs involved in their implementation is presented in <ref> [AM96, Alv96] </ref>. Acknowledgments We would like to thank Bruce Hoppe, Fred Schneider and Sam Toueg for many discussions on this research and on early versions of this paper. We would also like to thank the anonymous referees for their helpful suggestions. <p> Details can be found in <ref> [Alv96] </ref>.
Reference: [AM96] <author> L. Alvisi and K. Marzullo. </author> <title> Tradeoffs in implementing optimal message logging protocols. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 58-67. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: We only derive this protocol far enough to illustrate how piggybacking can be used to implement causal message-logging. A thorough discussion of such optimal causal protocols and of the tradeoffs involved in their implementation is presented in <ref> [AM96] </ref>. The characterization that we give is concerned with how information can be lost in the system due to crashes, and how message-logging protocols cope with this loss of information. <p> Since the focus of this paper is not the implementation of optimal causal message-logging protocols but rather their specification, we do not address these issues here. The interested reader is referred to <ref> [AM96] </ref>, in which we discuss the implementation of a class of optimal causal message-logging protocols that tolerate f overlapping failures and recoveries for a parameter f : 1 f n. <p> A thorough discussion of optimal protocols and of the tradeoffs involved in their implementation is presented in <ref> [AM96, Alv96] </ref>. Acknowledgments We would like to thank Bruce Hoppe, Fred Schneider and Sam Toueg for many discussions on this research and on early versions of this paper. We would also like to thank the anonymous referees for their helpful suggestions.
Reference: [BBG83] <author> Anita Borg, J. Baumbach, and S. Glazer. </author> <title> A message system supporting fault tolerance. </title> <booktitle> In Proceedings of the Symposium on Operating Systems Principles, </booktitle> <pages> pages 90-99. </pages> <publisher> ACM SIGOPS, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Message-logging protocols (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) are popular for building systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state. <p> For completeness, we define pessimistic protocols that log the determinant of m in local stable storage to be 1-blocking, since there is one event (the acknowledgment of #m being written to stable storage) that must occur between deliver m:dest (m) and a subsequent send <ref> [BBG83] </ref>. A lower bound for k is 0. The existence of optimistic protocols establishes that this bound is tight. 3. Number of messages: This metric gives one measure of the load on the network generated by the message logging protocol.
Reference: [BJ87] <author> Kenneth Birman and Tommy Joseph. </author> <title> Reliable communication in the presence of failures. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(2) </volume> <pages> 47-76, </pages> <month> February </month> <year> 1987. </year>
Reference-contexts: Causal delivery order <ref> [BJ87] </ref> strengthens FIFO delivery order by removing the requirement that ordering occurs only when the source of m and m 0 are the same. <p> The second approach is for each process p to piggyback, on each message m that p sends, all messages m 0 sent in the causal history of the event send p (m) such that p does not know if m 0 has already been delivered <ref> [BJ87] </ref>. The piggybacked messages are placed in a total order that extends the partial order imposed by the happens-before relation. Before delivering m, process m.dest first checks if any message m 0 in m's piggyback has m:dest for destination.
Reference: [BSS91] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight causal and atomic group multi-cast. </title> <journal> ACM Transactions on Computer System, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The first is to add to each message m additional information that m's destination process uses to determine when m can be delivered. <ref> [RST91, SS92, BSS91] </ref> Using this approach, process r in Figure 1 would realize, when it receives m 3 , that it must wait to receive m 1 and would delay delivery of m 3 accordingly.
Reference: [EZ92] <author> E. N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(5) </volume> <pages> 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Message-logging protocols (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) are popular for building systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state. <p> We call such protocols causal message-logging protocols, for reasons that will become clear later. Examples of this class are presented in <ref> [EZ92] </ref> and [AHM93]. All message-logging protocols must address the issue of processes that communicate with the environment. It is natural to model such communications in terms of the sending and delivery of messages. <p> We call the protocols that implement Property (10) causal message-logging protocols. Family-Based-Logging [AHM93] and Manetho <ref> [EZ92] </ref> are two examples of causal message-logging protocols for the special cases f = 1 and f = n respectively. 5 Optimal Message-Logging Protocols We now consider four metrics with which one can compare different message-logging protocols.
Reference: [EZ94] <author> E.N. Elnozahy and W. Zwaenepoel. </author> <title> On the use and implementation of message logging. </title> <booktitle> In Digest of Papers: 24 Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 298-307. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: Of course, protocols that are optimal according to our definition do not necessarily outperform in practice non-optimal protocols. Other issues that are difficult to quantify, such as the cost of output commit, must be taken into consideration in assessing the performance of a message-logging protocol <ref> [EZ94] </ref>. Nevertheless, the protocols we call optimal are unique in optimally addressing the theoretical desiderata of the message-logging approach. 6 Using Causal Delivery Order to Enforce the Always-No-Orphans Consistency Condition We now derive an optimal causal message-logging protocol, i.e. an optimal message-logging protocol that implements Property (10).
Reference: [Gra77] <author> James N. Gray. </author> <title> Notes on data base operating systems. </title> <editor> In R. Bayer, R. M. Graham, and G. Seegmueller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, </booktitle> <pages> pages 393-481. </pages> <publisher> Springer-Verlag, </publisher> <year> 1977. </year> <note> Lecture Notes on Computer Science 60. </note>
Reference-contexts: subsequent state in the run satisfies b = 1. 3 Consistency in Message-Logging Protocols In message-logging protocols, each process typically records both the content and receive sequence number of all the messages it has delivered into a location (called a message log) that will survive the failure of the process <ref> [Gra77] </ref>. This action is called logging. To trim message logs, a process may also periodically create a checkpoint of its local state. For example, in some message-logging protocols once a process p checkpoints its state, all messages delivered before this state can be removed from p's message log. <p> Hence 3 need only hold when #m is not stable: 8m : 2 (:stable (m) ) (Depend (m) Log (m))) (5) We call this property the always no orphans condition. If determinants are kept in stable storage <ref> [Gra77] </ref>, then stable (m) holds when the write of #m to stable memory completes.
Reference: [JV87] <author> T.Y. Juang and S. Venkatesan. </author> <title> Crash recovery with little overhead. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 454-461. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: We keep m:dest in #m for ease of exposition. 3 One can imagine protocols where no single process knows the value of #m but a set of processes collectively do. An example of such a protocol is given in <ref> [JV87] </ref>, where the value of #m for some message m may be inferred by "holes" in the sequence of logged receive sequence numbers.
Reference: [JZ87] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Sender-based message logging. </title> <booktitle> In Digest of Papers: 17 Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 14-19. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Message-logging protocols (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) are popular for building systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state. <p> Property (8) permits the temporary creation of orphan processes, but guarantees that, by the time recovery 4 In pessimistic sender-based logging <ref> [JZ87] </ref> process m.dest increases jLog (m)j by sending the value of m.rsn to process m.source, piggybacked on the acknowledgment of message m. <p> We say that forces r roll-backs if there is a run in which requires r correct processes to roll back their state, and for all , requires no more than r correct processes to roll back their state. For example, optimistic sender-based logging <ref> [JZ87] </ref> forces jN j rollbacks. A lower bound for r is 0. <p> We say that a message-logging protocol is k-blocking if, in all failure-free runs and for all messages m, process m.dest delivers no less than k messages between deliver m:dest (m) and e. For example, pessimistic sender-based logging <ref> [JZ87] </ref> is 1-blocking because process m.dest must receive a message acknowledging the logging of m.rsn before sending a message subsequent to the delivery of m. Optimistic protocols are, by design, 0-blocking. <p> Suppose now that is run using instead of ` . We say that sends additional messages in if sends more messages than ` . For example, in order to tolerate single crash failures pessimistic sender-based logging <ref> [JZ87] </ref> potentially requires that one extra acknowledgment be sent for each application message sent. A lower bound is to send no additional messages. The existence of optimistic protocols establishes that this bound is tight. 4.
Reference: [JZ90] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Recovery in distributed systems using optimistic message logging and checkpointing. </title> <journal> Journal of Algorithms, </journal> <volume> 11 </volume> <pages> 462-491, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Message-logging protocols (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) are popular for building systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state.
Reference: [Lam78] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Processes execute events, including send events, receive events, and local events. These events are ordered by the irreflexive partial order happens before ! that represents potential causality <ref> [Lam78] </ref>. We assume that a send event specifies only a single destination, but the following could be easily extended to include multiple destination messages.
Reference: [Pnu77] <author> Amir Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proceedings of the Eighteenth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 46-57, </pages> <month> November </month> <year> 1977. </year> <month> 19 </month>
Reference-contexts: Thus, each pair of adjacent states defines an event that was executed by a process. The resulting sequence of events is consistent with the happens before relation. A property is a logical expression evaluated over runs. We use the two temporal operators 2 and 3 <ref> [Pnu77] </ref> to express properties. The property 2 (read "always ") at a state in a run means that the property holds in the current state and all subsequent states of the run.
Reference: [PP83] <author> M.L. Powell and D.L. Presotto. </author> <title> Publishing: A reliable broadcast communication mech-anism. </title> <booktitle> In Proceedings of the Ninth Symposium on Operating System Principles, </booktitle> <pages> pages 100-109. </pages> <publisher> ACM SIGOPS, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Message-logging protocols (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) are popular for building systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state.
Reference: [RST91] <author> M. Raynal, A. Schiper, and Sam Toueg. </author> <title> The causal ordering abstraction and a simple way to implement it. </title> <journal> Information Processing Letters, </journal> <volume> 39(6) </volume> <pages> 343-350, </pages> <year> 1991. </year>
Reference-contexts: The first is to add to each message m additional information that m's destination process uses to determine when m can be delivered. <ref> [RST91, SS92, BSS91] </ref> Using this approach, process r in Figure 1 would realize, when it receives m 3 , that it must wait to receive m 1 and would delay delivery of m 3 accordingly.
Reference: [SBY88] <author> R. E. Strom, D. F. Bacon, and S. A. Yemini. </author> <title> Volatile logging in n-fault-tolerant distributed systems. </title> <booktitle> In Proceedings of the Eighteenth Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 44-49, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Message-logging protocols (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) are popular for building systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state.
Reference: [Sch84] <author> Fred B. Schneider. </author> <title> Byzantine generals in action: Implementing fail-stop processors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(2) </volume> <pages> 145-154, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: We also assume that the channels between processes do not reorder messages and can fail only by transiently dropping messages. 2 Processes can fail independently according to the fail-stop failure model <ref> [Sch84] </ref>. In this model, processes fail by halting, and the fact that a process has halted is eventually detectable by all surviving processes. Outside of satisfying the happens-before relation, the exact order a process executes receive events depends on many factors, including process scheduling, routing, and flow control.
Reference: [SS92] <author> A. Sandoz and A. Schiper. </author> <title> A characterization of consistent distributed snapshots using causal order. </title> <type> Technical Report TR92-14, </type> <institution> Departement d'Informatique, Ecole Politech-nique Federale de Lausanne, </institution> <year> 1992. </year>
Reference-contexts: The first is to add to each message m additional information that m's destination process uses to determine when m can be delivered. <ref> [RST91, SS92, BSS91] </ref> Using this approach, process r in Figure 1 would realize, when it receives m 3 , that it must wait to receive m 1 and would delay delivery of m 3 accordingly.
Reference: [SW89] <author> A.P. Sistla and J.L. Welch. </author> <title> Efficient distributed recovery using message logging. </title> <booktitle> In Proceedings of the Eighth Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 223-238. </pages> <publisher> ACM SIGACT/SIGOPS, </publisher> <month> August </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Message-logging protocols (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) are popular for building systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state. <p> We will say that sends a additional data if the maximum value of jm j jmj is a for all such m and m taken from all pairs of corresponding runs. For example, for optimistic protocols that track direct dependencies, a is a constant <ref> [SW89, VJ94] </ref>; while for optimistic protocols that track transitive dependencies a is proportional to the number of processes in the system [SY85, SW89]. A lower bound for a is 0. <p> For example, for optimistic protocols that track direct dependencies, a is a constant [SW89, VJ94]; while for optimistic protocols that track transitive dependencies a is proportional to the number of processes in the system <ref> [SY85, SW89] </ref>. A lower bound for a is 0.
Reference: [SY85] <author> R. B. Strom and S. Yemeni. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Message-logging protocols (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) are popular for building systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state. <p> We denote the receive sequence number of a message m as m.rsn. Thus, if process p delivers m and m.rsn = ` then m is the ` th message that p delivered <ref> [SY85] </ref>. An execution of the system is represented by a run, which is the sequence of states the system passes through during that execution. Each state consists of the individual process states, each of which is a mapping from program variables and implicit variables (such as program counters) to values. <p> For example, for optimistic protocols that track direct dependencies, a is a constant [SW89, VJ94]; while for optimistic protocols that track transitive dependencies a is proportional to the number of processes in the system <ref> [SY85, SW89] </ref>. A lower bound for a is 0.

References-found: 21

