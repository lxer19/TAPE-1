URL: http://www.cs.wustl.edu/~schmidt/PDCS-98.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: http://www.cs.wustl.edu
Email: jxh@cs.wustl,edu  irfan@cs.wustl.edu  schmidt@cs.wustl.edu  
Title: APPLYING THE PROACTOR PATTERN TO HIGH-PERFORMANCE WEB SERVERS systems provide multiple concurrency mechanisms to develop
Author: James Hu Irfan Pyarali Douglas C. Schmidt 
Note: Modern operating  
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science, Washington University  
Abstract: This paper is to appear at the 10th International Conference on Parallel and Distributed Computing and Systems, IASTED, Las Vegas, Nevada, October 28-31, 1998. ABSTRACT This paper provides two contributions to the study of high-performance Web servers. First, it examines how synchronous and asynchronous event dispatching mechanisms impact the design and performance of JAWS, which is our high-performance Web server framework. The results reveal significant performance improvements when a proactive concurrency model is used to combine lightweight con-currency with asynchronous event dispatching. In general, however, the complexity of the proactive con-currency model makes it harder to program applications that can utilize asynchronous concurrency mechanisms effectively. Therefore, the second contribution of this paper describes how to reduce the software complexity of asynchronous concurrent applications by applying the Proactor pattern. This pattern describes the steps required to structure object-oriented applications that seamlessly combine concurrency with asynchronous event dispatching. The Proactor pattern simplifies concurrent programming and improves performance by allowing concurrent application to have multiple operations running simultaneously without requiring a large number of threads. fl This work was supported in part by Siemens Med and Siemens Corporate Research.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt and J. Hu, </author> <title> Developing Flexible and High-performance Web Servers with Frameworks and Patterns, </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 30, </volume> <year> 1998. </year>
Reference-contexts: Thus, it is increasingly important to alleviate common Web server bottlenecks, such as inappropriate choice of concurrency and dispatching strategies, excessive filesystem access, and unnecessary data copying. Our research vehicle for exploring the performance impact of applying various Web server optimization techniques is the JAWS Adaptive Web Server (JAWS) <ref> [1] </ref>. JAWS is both an adaptive Web server and a development framework for Web servers that runs on multiple OS platforms including Win32, most versions of UNIX, and MVS Open Edition. <p> JAWS server framework design; Section 3 discusses alternative event dispatching strategies and their performance impacts; Section 4 explores how to leverage the gains of asynchronous event dispatching through application of the Proactor pattern; and Section 5 presents concluding remarks. 2 JAWS FRAMEWORK OVERVIEW design patterns that comprise the JAWS framework <ref> [1] </ref>. JAWS is designed to allow the customization of various Framework Framework Tilde Framework Cached Virtual Filesystem StrategyProtocol Pipeline Concurrency Expander I/O Strategy ~ /home/... <p> By virtue of the Service Configurator pattern, the Tilde Expander can be unlinked and relinked dynamically into the server when a new user is added to the system. Our previous work on high-performance Web servers has focused on (1) the design of the JAWS framework <ref> [1] </ref> and (2) detailed measurements on the performance implications of alternative Web server optimization techniques [2]. In our earlier work, we discovered that a concurrent proactive Web server can achieve substantial performance gains [15].
Reference: [2] <author> J. Hu, S. Mungee, and D. C. Schmidt, </author> <title> Principles for Developing and Measuring High-performance Web Servers over ATM, </title> <booktitle> in Proceeedings of INFOCOM '98, </booktitle> <month> March/April </month> <year> 1998. </year>
Reference-contexts: JAWS is both an adaptive Web server and a development framework for Web servers that runs on multiple OS platforms including Win32, most versions of UNIX, and MVS Open Edition. Our experience <ref> [2] </ref> building Web servers on multiple OS platforms demonstrates that the effort required to optimize performance can be simplified significantly by leveraging OS-specific features. For example, an optimized file I/O system that automatically caches open files in main memory via mmap greatly reduces latency on Solaris. <p> Our previous work on high-performance Web servers has focused on (1) the design of the JAWS framework [1] and (2) detailed measurements on the performance implications of alternative Web server optimization techniques <ref> [2] </ref>. In our earlier work, we discovered that a concurrent proactive Web server can achieve substantial performance gains [15]. This paper focuses on a previously unexamined point in the high-performance Web server design space: the application of the Proactor pattern to simplify Web server software development, while maintaining high-performance.
Reference: [3] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: This paper describes how the Proactor pattern can be applied to improve both the performance and the design of high-performance communication applications, such as 1 Web servers. A pattern represents a recurring solution to a software development problem within a particular context <ref> [3] </ref>. Patterns identify the static and dynamic collaborations and interactions between software components. In general, applying patterns to complex object-oriented concurrent applications can significantly improve software quality, increase software maintainability, and support broad reuse of components and architectural designs [4]. <p> As events are processed, they are dispatched to the Protocol Handler, which is parameterized by an I/O strategy. JAWS ability to dynamically bind to a particular concurrency strategy and I/O strategy from a range of alternatives follows the Strategy pattern <ref> [3] </ref>. Concurrency Strategy: This framework implements con-currency mechanisms (such as single-threaded, thread-per-request, or thread pool) that can be selected adaptively at run-time using the State pattern [3] or pre-determined at initialization-time. The Service Configurator pattern [7] is used to configure a particular concurrency strategy into a Web server at run-time. <p> JAWS ability to dynamically bind to a particular concurrency strategy and I/O strategy from a range of alternatives follows the Strategy pattern <ref> [3] </ref>. Concurrency Strategy: This framework implements con-currency mechanisms (such as single-threaded, thread-per-request, or thread pool) that can be selected adaptively at run-time using the State pattern [3] or pre-determined at initialization-time. The Service Configurator pattern [7] is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern [8]. <p> Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Proactor pattern [9], while reactive I/O is accomplished through the Reactor pattern [10]. These I/O strategies may utilize the Memento <ref> [3] </ref> and Asynchronous Completion Token [11] patterns to capture and externalize the state of a request so that it can be restored at a later time. Protocol Handler: This framework allows system developers to apply the JAWS framework to a variety of Web system applications. <p> Protocol Handler: This framework allows system developers to apply the JAWS framework to a variety of Web system applications. A Protocol Handler is parameterized by a concurrency strategy and an I/O strategy. These strategies are decoupled from the protocol handler using the Adapter pattern <ref> [3] </ref>. In JAWS, this component implements the parsing and handling of HTTP/1.0 request methods. The abstraction allows for other protocols (such as HTTP/1.1, DICOM, and SFP [12]) to be incorporated easily into JAWS. <p> Pipeline components can be linked dynamically at run-time using the Service Configurator pattern. Cached Virtual Filesystem: This component improves Web server performance by reducing the overhead of filesystem access. Various caching strategies, such as LRU, LFU, Hinted, and Structured, can be selected following the Strategy pattern <ref> [3] </ref>. This allows different caching strategies to be profiled and selected based on their performance. Moreover, optimal strategies to be configured statically or dynamically using the Service Configurator pattern. The cache for each Web server is instantiated using the Singleton pattern [3]. <p> and Structured, can be selected following the Strategy pattern <ref> [3] </ref>. This allows different caching strategies to be profiled and selected based on their performance. Moreover, optimal strategies to be configured statically or dynamically using the Service Configurator pattern. The cache for each Web server is instantiated using the Singleton pattern [3]. Tilde Expander: This component is another cache component that uses a perfect hash table [14] that maps abbreviated user login names (e.g., schmidt) to user home directories (e.g., /home/cs/faculty/schmidt).
Reference: [4] <author> D. C. Schmidt, </author> <title> Experience Using Design Patterns to Develop Reuseable Object-Oriented Communication Software, </title> <journal> Communications of the ACM (Special Issue on Object-Oriented Experiences), </journal> <volume> vol. 38, </volume> <month> October </month> <year> 1995. </year>
Reference-contexts: Patterns identify the static and dynamic collaborations and interactions between software components. In general, applying patterns to complex object-oriented concurrent applications can significantly improve software quality, increase software maintainability, and support broad reuse of components and architectural designs <ref> [4] </ref>. In particular, applying the Proactor pattern to JAWS simplifies asynchronous application development by structuring the de-multiplexing of completion events and the dispatching of their corresponding completion routines.
Reference: [5] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: JAWS is structured as a framework of frameworks. The overall JAWS framework contains the following components and frameworks: an Event Dispatcher, Concurrency Strategy, I/O Strategy, Protocol Pipeline, Protocol Handlers, and Cached Virtual Filesystem. Each framework is structured as a set of collaborating objects implemented using components in ACE <ref> [5] </ref>. The collaborations among JAWS components and frameworks are guided by a family of patterns, which are listed along the borders in Figure 1. <p> * Increased synchronization complexity: Threading can increase the complexity of synchronization mechanisms necessary to serialize access to a server's shared resources (such as cached files and logging of Web page hits); 3 * Increased performance overhead: Threading can per-form poorly due to context switching, synchronization, and data movement among CPUs <ref> [5] </ref>; * Non-portability: Threading may not be available on all OS platforms. Moreover, OS platforms differ widely in terms of their support for preemptive and non-preemptive threads. Consequently, it is hard to build multi-threaded servers that behave uniformly across OS platforms. <p> The operating system is the Asynchronous Operation Processor. Results of the operations are queued up at the I/O completion port (which plays the role of the Completion Dispatcher). ACE Proactor: The Adaptive Communications Environment (ACE) <ref> [5] </ref> implements a Proactor component that encapsulates I/O Completion Ports on Windows NT. The ACE Proactor abstraction provides an OO interface to the standard C APIs supported by Windows NT. The source code for this implementation can be acquired from the ACE website at www.cs.wustl.edu/schmidt/ACE.html.
Reference: [6] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Initializing Communication Services, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: The passive establishment of connection events with Web clients follows the Acceptor pattern <ref> [6] </ref>. New incoming HTTP request events are serviced by a concurrency strategy. As events are processed, they are dispatched to the Protocol Handler, which is parameterized by an I/O strategy.
Reference: [7] <author> P. Jain and D. C. Schmidt, </author> <title> Service Configurator: A Pattern for Dynamic Configuration of Services, </title> <booktitle> in Proceedings of the 3 rd Conference on Object-Oriented Technologies and Systems, USENIX, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Concurrency Strategy: This framework implements con-currency mechanisms (such as single-threaded, thread-per-request, or thread pool) that can be selected adaptively at run-time using the State pattern [3] or pre-determined at initialization-time. The Service Configurator pattern <ref> [7] </ref> is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern [8]. I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O.
Reference: [8] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: The Service Configurator pattern [7] is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern <ref> [8] </ref>. I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Proactor pattern [9], while reactive I/O is accomplished through the Reactor pattern [10].
Reference: [9] <author> T. Harrison, I. Pyarali, D. C. Schmidt, and T. Jordan, </author> <title> Proac-tor An Object Behavioral Pattern for Dispatching Asyn chronous Event Handlers, </title> <booktitle> in The 4 th Pattern Languages of Programming Conference (Washington University technical report #WUCS-97-34), </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern [8]. I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Proactor pattern <ref> [9] </ref>, while reactive I/O is accomplished through the Reactor pattern [10]. These I/O strategies may utilize the Memento [3] and Asynchronous Completion Token [11] patterns to capture and externalize the state of a request so that it can be restored at a later time. <p> The key participants in the Proactor pattern include the following: 3 For brevity, portions of the complete description have been elided. Detailed coverage of implementation and sample code are available in <ref> [9] </ref>. Completion Dispatcher Proactive Initiator Asynchronous Operation Processor Asynchronous Operation Completion Handler Proactive Initiator (Web server application's main thread): * A Proactive Initiator is any entity in the application that initiates an Asynchronous Operation.
Reference: [10] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, </editor> <booktitle> eds.), </booktitle> <pages> pp. 529545, </pages> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Proactor pattern [9], while reactive I/O is accomplished through the Reactor pattern <ref> [10] </ref>. These I/O strategies may utilize the Memento [3] and Asynchronous Completion Token [11] patterns to capture and externalize the state of a request so that it can be restored at a later time. <p> Asynchronous Operation Processor (the Operating System): * Asynchronous Operations are run to completion by the Asynchronous Operation Processor. This component is typically imple mented by the OS. 4 In contrast, the reactive event dispatching model <ref> [10] </ref> steals the appli cation's thread of control to perform the operation synchronously. 5 Completion Dispatcher (the Notification Queue): * The Completion Dispatcher is responsible for calling back to the application's Completion Handlers when Asynchronous Operations complete.
Reference: [11] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Asynchronous Completion Token: an Object Behavioral Pattern for Efficient Asynchronous Event Handling, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Proactor pattern [9], while reactive I/O is accomplished through the Reactor pattern [10]. These I/O strategies may utilize the Memento [3] and Asynchronous Completion Token <ref> [11] </ref> patterns to capture and externalize the state of a request so that it can be restored at a later time. Protocol Handler: This framework allows system developers to apply the JAWS framework to a variety of Web system applications.
Reference: [12] <institution> Object Management Group, Control and Management of Audio/Video Streams: OMG RFP Submission, 1.2 ed., </institution> <month> Mar. </month> <year> 1997. </year>
Reference-contexts: These strategies are decoupled from the protocol handler using the Adapter pattern [3]. In JAWS, this component implements the parsing and handling of HTTP/1.0 request methods. The abstraction allows for other protocols (such as HTTP/1.1, DICOM, and SFP <ref> [12] </ref>) to be incorporated easily into JAWS. To add a new protocol, developers simply write a new Protocol Handler implementation, which is then configured into the JAWS framework. 1 Due to space limitations it is not possible to describe all the patterns mentioned below in detail.
Reference: [13] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: The references provide complete coverage of each pattern, however. 2 Protocol Pipeline: This framework allows filter operations to be incorporated easily with the data being processed by the Protocol Handler. This integration is achieved by employing the Adapter pattern. Pipelines follow the Pipes and Filters pattern <ref> [13] </ref> for input processing. Pipeline components can be linked dynamically at run-time using the Service Configurator pattern. Cached Virtual Filesystem: This component improves Web server performance by reducing the overhead of filesystem access.
Reference: [14] <author> D. C. Schmidt, GPERF: </author> <title> A Perfect Hash Function Generator, </title> <booktitle> in Proceedings of the 2 nd C++ Conference, </booktitle> <address> (San Fran-cisco, California), </address> <pages> pp. 87102, </pages> <publisher> USENIX, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: Moreover, optimal strategies to be configured statically or dynamically using the Service Configurator pattern. The cache for each Web server is instantiated using the Singleton pattern [3]. Tilde Expander: This component is another cache component that uses a perfect hash table <ref> [14] </ref> that maps abbreviated user login names (e.g., schmidt) to user home directories (e.g., /home/cs/faculty/schmidt).
Reference: [15] <author> J. Hu, I. Pyarali, and D. C. Schmidt, </author> <title> Measuring the Impact of Event Dispatching and Concurrency Models on Web Server Performance Over High-speed Networks, </title> <booktitle> in Pro ceedings of the 2 nd Global Internet Conference, IEEE, </booktitle> <month> November </month> <year> 1997. </year>
Reference-contexts: In our earlier work, we discovered that a concurrent proactive Web server can achieve substantial performance gains <ref> [15] </ref>. This paper focuses on a previously unexamined point in the high-performance Web server design space: the application of the Proactor pattern to simplify Web server software development, while maintaining high-performance. <p> The JAWS framework alleviates many of the complexities of concurrent asynchronous event dispatching by applying the Proactor pattern described in Section 4. 3.3 SUMMARY OF PERFORMANCE RESULTS In our empirical measurements <ref> [15] </ref> we have observed there is significant variance in throughput and latency depending on the concurrency and event dispatching mechanisms. For small files, the synchronous Thread Pool strategy provides better overall performance. Under moderate loads, the synchronous event dispatching model provides slightly better latency than the asynchronous model. <p> Completion Handlers can be written as if they existed in a conventional single-threaded environment. For instance, a Web server's HTTP GET Handler can access the disk through an Async Read operation (such as the Windows NT TransmitFile function <ref> [15] </ref>). 4.5.2 DRAWBACKS The Proactor pattern has the following drawbacks: Hard to debug: Applications written with the Proactor pattern can be hard to debug since the inverted flow of control oscillates between the framework infrastructure and the method callbacks on application-specific handlers.
Reference: [16] <author> J. C. </author> <title> Mogul, </title> <booktitle> The Case for Persistent-connection HTTP, in Proceedings of ACM SIGCOMM '95 Conference in Computer Communication Review, </booktitle> <address> (Boston, MA, USA), </address> <pages> pp. 299314, </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: high-performance Web server like JAWS requires the resolution of the following forces: * Concurrency: The server must perform multiple client requests simultaneously; * Efficiency: The server must minimize latency, maximize throughput, and avoid utilizing the CPU (s) unnecessarily. * Adaptability: Integrating new or improved transport protocols (such as HTTP 1.1 <ref> [16] </ref>) should incur minimal enhancement and maintenance costs. * Programming simplicity: The design of the server should simplify the use of various concurrency strategies, which may differ in performance on different OS platforms; The JAWS Web server can be implemented using several concurrency strategies, such as multiple synchronous threads, reactive synchronous
Reference: [17] <institution> Information Technology Portable Operating System Interface (POSIX) Part 1: System Application: Program Interface (API) [C Language], </institution> <year> 1995. </year>
Reference-contexts: These system calls detect and report the events that may occur simultaneously on multiple event sources. Event sources may include I/O ports, timers, synchronization objects, signals, etc. On real-time POSIX platforms, the asynchronous I/O functions are provided by the aio family of APIs <ref> [17] </ref>. <p> The source code for this implementation can be acquired from the ACE website at www.cs.wustl.edu/schmidt/ACE.html. The UNIX AIO Family of Asynchronous I/O Operations: On some real-time POSIX platforms, the Proac-tor pattern is implemented by the aio family of APIs <ref> [17] </ref>. These OS features are very similar to the ones described above for Windows NT. One difference is that UNIX signals can be used to implement an truly asynchronous Completion Dispatcher (the Windows NT API is not truly asynchronous).
Reference: [18] <institution> Microsoft Developers Studio, </institution> <note> Version 4.2 Software Development Kit, 1996. 8 </note>
Reference-contexts: Event sources may include I/O ports, timers, synchronization objects, signals, etc. On real-time POSIX platforms, the asynchronous I/O functions are provided by the aio family of APIs [17]. In Windows NT, I/O completion ports and overlapped I/O are used to implement asyn chronous I/O <ref> [18] </ref>. 6 The Completion Dispatcher encapsulates the con--currency mechanism: A benefit of decoupling the Completion Dispatcher from the Asynchronous Operation Processor is that applications can configure Completion Dispatchers with various concur-rency strategies without affecting other participants.
References-found: 18

