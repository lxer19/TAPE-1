URL: ftp://ftp.cse.cuhk.edu.hk/pub/techreports/94/tr-94-13.ps.gz
Refering-URL: ftp://ftp.cs.cuhk.hk/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: CS-TR-94-13 Interval Linear Constraint Solving in Constraint Logic Programming  
Author: Chong-kan Chiu 
Date: December 1994  
Address: Hong Kong  
Affiliation: Department of Computer Science The Chinese University of Hong Kong  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Aggoun and N. Beldiceanu. </author> <title> Overview of the CHIP compiler system. </title> <booktitle> In Proceedings of the Eighth International Conference on Logic Programming, </booktitle> <address> Paris, France, </address> <year> 1991. </year>
Reference-contexts: y The result is the average computation time of two sets of test data. fl The result is the computation time for only one set of test data. 16 Chapter 3 Limitations of Interval Narrowing Constraint in Narrowing A 2 B 2 D 2 C 1 [0; 1) (1; 0] <ref> [1; 1) C 1 [1; 1) (1; 0] </ref> [2; 1) C 1 [2; 1) (1; 0] [3; 1) C 1 [3; 1) (1; 0] [4; 1) . . . . . . <p> the average computation time of two sets of test data. fl The result is the computation time for only one set of test data. 16 Chapter 3 Limitations of Interval Narrowing Constraint in Narrowing A 2 B 2 D 2 C 1 [0; 1) (1; 0] [1; 1) C 1 <ref> [1; 1) (1; 0] </ref> [2; 1) C 1 [2; 1) (1; 0] [3; 1) C 1 [3; 1) (1; 0] [4; 1) . . . . . . <p> C 1 [1 ; 1) (1; 0] [1 ; 1) . . . . . . . . . . . . C 2 <ref> [1 ; 1) (1; 1 ] </ref> [1 ; 1) Table 3.5: Traces of A; B and D (With Splitting) The symbols -, 1 and 1 = denote a negative, the largest and the second largest floating-point number respectively. <p> From the last entry in the traces, we find that interval narrowing ends with <ref> [1 ; 1) + (1; 1 ] </ref> = [1 ; 1). This is due to the fact that, by setting the negative rounding direction, the addition of any number and the largest floating-point number results in the largest floating-point number itself, in the IEEE floating-point standard. <p> Semantically, an interval variable is an ordinary logical variable. We distinguish interval variables from logical variables purely for implementation efficiency. Resembling domain variables in finite-domain languages [57], e.g. CHIP <ref> [1, 19] </ref>, an interval variable is represented as a variable with an associated interval. Its heap representation is shown in figure 4.2, where ITAG is a new tag introduced for interval variables. Each interval variable in CIAL keeps a list of constraints in which the variable appears. <p> The simplest examples for illustrating the dependency problem are A I A I and A I ff A I . It can be checked easily that [0; 0] 6= A I A I and <ref> [1; 1] </ref> 6= A I ff A I in general. <p> In generalized interval arithmetic, an interval X I = [a; b] is represented as a generalized interval of the form, X I = Y I [c; c] Z I where y c = a; y + c = b; Y I = [y; y] and Z I = <ref> [1; 1] </ref>: Suppose X I i = Y I i for i = 1; : : : ; n. <p> We have X I X I Y I 1 Y I 2 = [2; 2] [7; 7] [7; 7] = [2; 2] 31 = Z I 21 Z I Z I 12 Z I 22 = [0; 0] <ref> [1; 1] </ref> [1; 1] = [0; 0] 3 = Y I 2 X ([c s ; c s ] Z I 30 Chapter 5 The Linear Solver Therefore, we get X I 3 = X I 1 = [4; 8] instead of [6; 10], which is obtained using ordinary interval arithmetic. <p> We have X I X I Y I 1 Y I 2 = [2; 2] [7; 7] [7; 7] = [2; 2] 31 = Z I 21 Z I Z I 12 Z I 22 = [0; 0] <ref> [1; 1] </ref> [1; 1] = [0; 0] 3 = Y I 2 X ([c s ; c s ] Z I 30 Chapter 5 The Linear Solver Therefore, we get X I 3 = X I 1 = [4; 8] instead of [6; 10], which is obtained using ordinary interval arithmetic. <p> We modify equation (5.3) as follows. X i 2 Y I i a i + b i ); '( 2 a i + b i )); ('( 2 <ref> [1; 1] </ref>) [1; 1] (5.4) In equation (5.4), ' and are functions that round a real number to its nearest and right [49] adjacent floating-point number respectively. We can easily verify that the modified generalized interval obtained from equation (5.4) is a superset of that obtained from equation (5.3). <p> We modify equation (5.3) as follows. X i 2 Y I i a i + b i ); '( 2 a i + b i )); ('( 2 <ref> [1; 1] </ref>) [1; 1] (5.4) In equation (5.4), ' and are functions that round a real number to its nearest and right [49] adjacent floating-point number respectively. We can easily verify that the modified generalized interval obtained from equation (5.4) is a superset of that obtained from equation (5.3).
Reference: [2] <author> A. Aiba, K. Sakai, Y. Sato, D.J. Hawley, and R. Hasegawa. </author> <title> Constraint logic programming language CAL. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1988, </booktitle> <pages> pages 263-276, </pages> <address> Tokyo, Japan, </address> <year> 1988. </year>
Reference-contexts: The advent of constraint logic programming [31] presents a solution to the first problem but the implementation of CLP languages, such as CLP (R) [32], are mostly based on floating-point arithmetic. The second problem remains. The languages CAL <ref> [2] </ref> and RISC-CLP (R) [30] use symbolic algebraic methods to refrain from floating-point operations. Algebraic methods guarantee the soundness of numerical computation but they are time-consuming. Previous efforts in the sub-symbolic camp, such as BNR Prolog [51], employ interval methods [45] and belong to the family of consistency techniques [42]. <p> The precisions of solutions and the speed of convergence are improved with the cooperation of the two techniques. The non-linear solver employs interval narrowing with splitting to solve inequalities and non-linear constraints. 1 Chapter 1 Introduction 1.1 Related Work Prolog III [17], CAL <ref> [2] </ref>, and RISC-CLP (R) [30] use symbolic algebraic methods to solve arithmetic constraints. Prolog III 1 employs a simplex algorithm to handle arithmetic over rational numbers. CAL computes over two domains: the real numbers and Boolean algebra with symbolic values. <p> of two sets of test data. fl The result is the computation time for only one set of test data. 16 Chapter 3 Limitations of Interval Narrowing Constraint in Narrowing A 2 B 2 D 2 C 1 [0; 1) (1; 0] [1; 1) C 1 [1; 1) (1; 0] <ref> [2; 1) C 1 [2; 1) (1; 0] </ref> [3; 1) C 1 [3; 1) (1; 0] [4; 1) . . . . . . <p> test data. fl The result is the computation time for only one set of test data. 16 Chapter 3 Limitations of Interval Narrowing Constraint in Narrowing A 2 B 2 D 2 C 1 [0; 1) (1; 0] [1; 1) C 1 [1; 1) (1; 0] [2; 1) C 1 <ref> [2; 1) (1; 0] </ref> [3; 1) C 1 [3; 1) (1; 0] [4; 1) . . . . . . <p> Substituting the coefficients with example concrete data, we get the following system of equalities. [2:0001; 2:0002] X I [1:0002; 1:0003] Y I = <ref> [2; 2] </ref> Solving the above system using naive interval Gaussian elimination yields the following results. <p> Suppose we want to compute X I 3 = X I 2 g 2 with X I 1 = [4; 8] and X I 2 = [6; 8]. We have X I X I Y I 1 Y I 2 = <ref> [2; 2] </ref> [7; 7] [7; 7] = [2; 2] 31 = Z I 21 Z I Z I 12 Z I 22 = [0; 0] [1; 1] [1; 1] = [0; 0] 3 = Y I 2 X ([c s ; c s ] Z I 30 Chapter 5 The Linear <p> Suppose we want to compute X I 3 = X I 2 g 2 with X I 1 = [4; 8] and X I 2 = [6; 8]. We have X I X I Y I 1 Y I 2 = <ref> [2; 2] </ref> [7; 7] [7; 7] = [2; 2] 31 = Z I 21 Z I Z I 12 Z I 22 = [0; 0] [1; 1] [1; 1] = [0; 0] 3 = Y I 2 X ([c s ; c s ] Z I 30 Chapter 5 The Linear Solver Therefore, we get X I 3
Reference: [3] <author> H. At-Kaci. </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: They also show how the generalized algorithm can be incorporated in CLP (R) [32] and CHIP [19] in such a way that the languages' logical semantics is preserved. Lee and Lee [37] propose an integration of constraint interval arithmetic into logic programming at the Warren Abstract Machine (WAM) <ref> [3] </ref> level. Benhamou et al [8] replaces the usual interval narrowing operator of previous interval CLP languages by an operator based on interval Newton method to speed up non-linear constraint solving. 1.2 Organizations of the Dissertation The thesis is organized as follows. <p> result is the computation time for only one set of test data. 16 Chapter 3 Limitations of Interval Narrowing Constraint in Narrowing A 2 B 2 D 2 C 1 [0; 1) (1; 0] [1; 1) C 1 [1; 1) (1; 0] [2; 1) C 1 [2; 1) (1; 0] <ref> [3; 1) C 1 [3; 1) (1; 0] </ref> [4; 1) . . . . . . <p> time for only one set of test data. 16 Chapter 3 Limitations of Interval Narrowing Constraint in Narrowing A 2 B 2 D 2 C 1 [0; 1) (1; 0] [1; 1) C 1 [1; 1) (1; 0] [2; 1) C 1 [2; 1) (1; 0] [3; 1) C 1 <ref> [3; 1) (1; 0] </ref> [4; 1) . . . . . . <p> linear solver and the non-linear solver accordingly. 21 Chapter 4 Design of CIAL In the following, we describe each component of the architecture and the interaction between the two solvers in more details. 4.2 The Inference Engine The structure of the engine resembles that of a standard structure-sharing Prolog interpreter <ref> [3] </ref>. Equations between Prolog terms are handled by a standard unification algorithm. Since constraints in CIAL are over real numbers, logical variables in constraints denote unknown real numbers. We refer to those logical variables as interval variables.
Reference: [4] <author> G. Alefeld and J. Herzberger. </author> <title> Introduction to Interval Computations. </title> <publisher> Academic Press, </publisher> <year> 1983. </year>
Reference-contexts: We then describe the syntax and semantics of the ICLP (R) language [38], which is an extension of CLP (R) with relational interval arithmetic. Most of the above materials are adopted from [38, 36, 39] except those otherwise specified. 2.1 Basics of Interval Arithmetic The manuscripts <ref> [45, 4] </ref> provide good introduction to interval analysis. Let IR be the set of real numbers and IF the set of floating-point numbers. <p> Y I = (0:80016132:::; 0:79975469:::) In the following, we show that better results can be obtained by adopting operators from generalized interval arithmetic in Gaussian elimination. 5.1.2 Generalized Interval Gaussian Elimination The interval Gaussian elimination procedure is well studied <ref> [23, 4, 22, 25] </ref>. A well-known algorithm, known as preconditioned interval Gaussian elimination, is proposed by Hansen [23]. Preconditioned Gaussian elimination transforms the coefficient matrix A I to a near identity matrix ~ I I before applying naive interval Gaussian elimination. <p> Suppose we want to compute X I 3 = X I 2 g 2 with X I 1 = <ref> [4; 8] </ref> and X I 2 = [6; 8]. <p> 21 Z I Z I 12 Z I 22 = [0; 0] [1; 1] [1; 1] = [0; 0] 3 = Y I 2 X ([c s ; c s ] Z I 30 Chapter 5 The Linear Solver Therefore, we get X I 3 = X I 1 = <ref> [4; 8] </ref> instead of [6; 10], which is obtained using ordinary interval arithmetic. Note that if multiplication or division is involved, the dependency problem effect cannot be eliminated but only reduced . Solving the system of linear equation (5.2) using generalized interval Gaussian Elimination yields a sharper result.
Reference: [5] <author> K.E. Atkinson. </author> <title> An Introduction to Numerical Analysis. </title> <publisher> John Wiley & Sons, </publisher> <year> 1978. </year>
Reference-contexts: Thus, the preconditioned interval Gauss-Seidel method may fail to converge. This phenomenon becomes more visible if the mid-point coefficient matrix is ill-conditioned <ref> [5] </ref>. The column permutation in our update algorithm is similar to pivoting in numerical methods. The difference is that the former only requires the diagonal coefficients to be greater than a small user-defined value, while the latter always puts the largest component of a row in the diagonal.
Reference: [6] <author> R. Barrett, M. Berry, T. Chan, J. Demmel, J. Donato, J. Dongarra, V. Eijkhout, R. Pozo, C. Romine, and H. van der Vorst. </author> <title> Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods. </title> <institution> Society for Industrial & Applied Mathematics, </institution> <year> 1993. </year>
Reference-contexts: Suppose we want to compute X I 3 = X I 2 g 2 with X I 1 = [4; 8] and X I 2 = <ref> [6; 8] </ref>. <p> I 12 Z I 22 = [0; 0] [1; 1] [1; 1] = [0; 0] 3 = Y I 2 X ([c s ; c s ] Z I 30 Chapter 5 The Linear Solver Therefore, we get X I 3 = X I 1 = [4; 8] instead of <ref> [6; 10] </ref>, which is obtained using ordinary interval arithmetic. Note that if multiplication or division is involved, the dependency problem effect cannot be eliminated but only reduced . Solving the system of linear equation (5.2) using generalized interval Gaussian Elimination yields a sharper result. <p> The previously computed values can be used as soon as they are available. Assuming that variable updates are coordinated in a naive round-robin fashion, a sequential version of interval Gauss-Seidel is suggested to be <ref> [6] </ref> X i ((b I j=i1 X (a I I (k) j=n X (a I I (k1) ii ) X i (5.6) The superscript (k 1) of X I (k1) i indicates that the variable is obtained in the (k 1)-th iterating cycle. <p> The interval Gauss-Seidel method terminates when all variables remain unchanged after an iteration or when the difference between the new and last computed value of each variable is less than a user-defined number. This sequential Gauss-Seidel method is also called the method of successive displacements <ref> [6] </ref>. Convergence Definition 5.2.1 [48]: A sequence of intervals converges iff both the lower and upper bounds converge. Definition 5.2.2 [48]: The hull of the solution set of a linear system is the set of tightest intervals that enclosing the solution of the linear system.
Reference: [7] <author> Bell-Northern Research Ltd. </author> <title> BNR Prolog Reference Manual, </title> <year> 1988. </year>
Reference-contexts: Suppose we want to compute X I 3 = X I 2 g 2 with X I 1 = [4; 8] and X I 2 = [6; 8]. We have X I X I Y I 1 Y I 2 = [2; 2] <ref> [7; 7] </ref> [7; 7] = [2; 2] 31 = Z I 21 Z I Z I 12 Z I 22 = [0; 0] [1; 1] [1; 1] = [0; 0] 3 = Y I 2 X ([c s ; c s ] Z I 30 Chapter 5 The Linear Solver Therefore, <p> Suppose we want to compute X I 3 = X I 2 g 2 with X I 1 = [4; 8] and X I 2 = [6; 8]. We have X I X I Y I 1 Y I 2 = [2; 2] <ref> [7; 7] </ref> [7; 7] = [2; 2] 31 = Z I 21 Z I Z I 12 Z I 22 = [0; 0] [1; 1] [1; 1] = [0; 0] 3 = Y I 2 X ([c s ; c s ] Z I 30 Chapter 5 The Linear Solver Therefore, we get <p> We further embed the incremental preconditioning algorithm in CIAL 1.1 (Beta) to improve its efficiency. The three prototypes use interval narrowing with splitting in solving inequality and non-linear constraints. In this chapter, we compare our three CIAL prototypes with BNR Prolog v3.1.0 <ref> [7, 52] </ref>, CLP (BNR) (or BNR Prolog v4.2.3) [50, 9], Echidna Version 0.947 beta [55, 54], ICL [37], and CLP (R) Version 1.2 [28, 32] over seven numerical examples of various types: the well-known mortgage program [28] which comes with the CLP (R) distribution, a simple system of simultaneous equations in
Reference: [8] <author> F. Benhamou, D. McAllester, and P. Van Hentenryck. </author> <title> CLP(Intervals) revisited. </title> <booktitle> In Logic Programming: Proceedings of the 1994 International Symposium, </booktitle> <address> Ithaca, USA, </address> <year> 1994. </year>
Reference-contexts: Lee and Lee [37] propose an integration of constraint interval arithmetic into logic programming at the Warren Abstract Machine (WAM) [3] level. Benhamou et al <ref> [8] </ref> replaces the usual interval narrowing operator of previous interval CLP languages by an operator based on interval Newton method to speed up non-linear constraint solving. 1.2 Organizations of the Dissertation The thesis is organized as follows. In chapter 2, we provide the theoretical background to this thesis. <p> This behavior shows that the efficiency of interval narrowing depends highly on such properties of the coefficient matrices as the distribution of zero-coefficients, rather than the number of zero-coefficients. The experiments presented so far are limited to linear constraint solving. Benhamou et al <ref> [8] </ref> give 2 We exclude the systems with 80% zero-coefficients since such randomly generated linear systems are usually inconsistent. 15 Chapter 3 Limitations of Interval Narrowing 20% zeros 40% zeros 60% zeros n = 5 2661.45s 8.62s 0.14s n = 7 | 3620.35s y 13.76s n = 9 | | 1298.21s <p> Therefore, interval narrowing fails to detect the trivial inconsistency of (3.2). This example exhibits two important shortcomings of interval narrowing. First, interval narrowing is "incomplete" in detecting inconsistency. Second, it may take a long time to stablize on an obviously inconsistent system. 3.3 The Newton Language Benhamou et al <ref> [8] </ref> show recently an improvement on interval narrowing. The results are implemented in the Newton language. In this section, we outline their work and shows that their improvement applies only to interval non-linear constraint solving, but not to linear constraints. <p> In this section, we outline their work and shows that their improvement applies only to interval non-linear constraint solving, but not to linear constraints. The details of Benhamou et al's experiments and analysis are beyond the scope of this thesis. We refer the readers to <ref> [8] </ref>. Benhamou et al replace the interval reduction operator in interval narrowing by a Newton reduction operator, which is a variant of the interval Newton method. <p> We expect that the Newton algorithm usually gives wider results than those obtained from interval narrowing due to the variable dependency problem. 5 In order to have consistent notations throughout this thesis, the notations used here are different from those in <ref> [8] </ref>. 19 Chapter 3 Limitations of Interval Narrowing 20 Chapter 4 Design of CIAL Our work is motivated by the inadequacy of interval narrowing for interval linear constraint solving. <p> Suppose we want to compute X I 3 = X I 2 g 2 with X I 1 = <ref> [4; 8] </ref> and X I 2 = [6; 8]. <p> Suppose we want to compute X I 3 = X I 2 g 2 with X I 1 = [4; 8] and X I 2 = <ref> [6; 8] </ref>. <p> 21 Z I Z I 12 Z I 22 = [0; 0] [1; 1] [1; 1] = [0; 0] 3 = Y I 2 X ([c s ; c s ] Z I 30 Chapter 5 The Linear Solver Therefore, we get X I 3 = X I 1 = <ref> [4; 8] </ref> instead of [6; 10], which is obtained using ordinary interval arithmetic. Note that if multiplication or division is involved, the dependency problem effect cannot be eliminated but only reduced . Solving the system of linear equation (5.2) using generalized interval Gaussian Elimination yields a sharper result. <p> First, the linear solver can only handle linear equalities. It would be interesting to investigate how linear inequalities can be accommodated. We believe that our proposed linear equality constraint solving methods, especially the incremental preconditioned interval Gauss-Seidel method, can be generalized to handle inequalities. Second, Benhamou et al <ref> [8] </ref> replace interval narrowing by a Newton reduction operator, which shows an improvement in non-linear constraint solving. However, preconditioning has not been included. It is worthwhile to study if our incremental preconditioning technique can be applied to further improve the Newton reduction operator. <p> On the theoretical side, it would be interesting to study the level of interval consistency attainable in generalized interval Gaussian elimination and the preconditioned interval Gauss-Seidel method. Both of them should reach a consistency level falling between box consistency and hull consistency <ref> [8] </ref>. Concerning implementations, our CIAL prototypes have much to be desired. First, the CIAL architecture is rudimentary. Further optimizations, such as the techniques used for CLP (R), might be applicable to CIAL. Second, the current prototypes implement constraint solvers as independent modules separating from the Prolog engine.
Reference: [9] <editor> F. Benhamou and W.J. Older. </editor> <title> Applying interval arithmetic to real, integer and boolean constraints. </title> <note> (Submitted to) Journal of Logic Programming, </note> <year> 1994. </year>
Reference-contexts: We collectively call these techniques interval narrowing. Interval narrowing has been shown to be applicable to critical path scheduling [51], X-ray diffraction crystallography [53], boolean constraint solving <ref> [9] </ref>, and disjunctive constraint solving [9, 54]. However, interval narrowing is deficient in handling systems of linear constraints over real domain. <p> We collectively call these techniques interval narrowing. Interval narrowing has been shown to be applicable to critical path scheduling [51], X-ray diffraction crystallography [53], boolean constraint solving [9], and disjunctive constraint solving <ref> [9, 54] </ref>. However, interval narrowing is deficient in handling systems of linear constraints over real domain. <p> A constraint relaxation cycle is needed to coordinate the execution of the narrowing algorithms for a network of constraints. BNR-Prolog [51] and its sequel CLP (BNR) <ref> [9] </ref> provide relational interval arithmetic in a way that is loosely based on Cleary's pre-publication idea, differing somewhat in particulars. Sidebottom and Havens [54] design and implement a version of relational interval arithmetic in the constraint reasoning system Echidna [26]. <p> We first visit one half, while the remaining half is visited upon backtracking or under user-control. The procedure of interval narrowing with splitting is shown as algorithm 2.2. 2 Different definitions are used in <ref> [36, 9] </ref>. In [36], interval narrowing refers to the interval reduction operator described here, while relaxation algorithm is assumed to have interval reduction as the domain restriction operator all the time. <p> In [36], interval narrowing refers to the interval reduction operator described here, while relaxation algorithm is assumed to have interval reduction as the domain restriction operator all the time. Interval reduction and interval narrowing described here are named as narrowing function and narrowing algorithm respectively in <ref> [9] </ref>. 3 An interval can be partitioned in different ways. Cleary [16] discusses two predicates, linear split/1 and exp split/1, which partition intervals at different points. <p> The clause (G 0 G 1 ; ; G n ) is a conditional answer to the original goal. 11 Chapter 2 Overview of ICLP (R) 12 Chapter 3 Limitations of Interval Narrowing Interval narrowing with splitting is a common constraint solving technique used in interval constraint logic programming languages <ref> [39, 37, 9, 51] </ref>. Our experiments show that, in general, this technique is impractical in solving some classes of problems in terms of both computation time and storage. We try to solve a set of randomly generated systems of linear equations in several interval narrowing based systems. <p> set of systems of linear constraints, A ~ X = ~ b; where A = (a ij ); ~ X = (X i ); ~ b = (b i ); a ij 6= 0; b i 6= 0; and X i 2 [10000; 10000] on BNR Prolog [52], CLP (BNR) <ref> [9] </ref>, Echidna [54] and ICL [37] with splitting. All coefficients a ij and b i are randomly generated non-zero floating-point numbers. The results for each problem size n are the average of three different sets of test data and are summarized in table 3.1 and table 3.2. <p> The three prototypes use interval narrowing with splitting in solving inequality and non-linear constraints. In this chapter, we compare our three CIAL prototypes with BNR Prolog v3.1.0 [7, 52], CLP (BNR) (or BNR Prolog v4.2.3) <ref> [50, 9] </ref>, Echidna Version 0.947 beta [55, 54], ICL [37], and CLP (R) Version 1.2 [28, 32] over seven numerical examples of various types: the well-known mortgage program [28] which comes with the CLP (R) distribution, a simple system of simultaneous equations in two variables, analysis of a simple DC circuit,
Reference: [10] <author> C. Bessiere. </author> <title> Arc-consistency and arc-consistency again. </title> <journal> AI Journal, </journal> <volume> 65(1) </volume> <pages> 179-190, </pages> <year> 1994. </year>
Reference-contexts: Previous efforts in the sub-symbolic camp, such as BNR Prolog [51], employ interval methods [45] and belong to the family of consistency techniques [42]. The main idea is to narrow the set of possible values of the variables of arbitrary real constraints using approximations of arc-consistency <ref> [10] </ref>. We collectively call these techniques interval narrowing. Interval narrowing has been shown to be applicable to critical path scheduling [51], X-ray diffraction crystallography [53], boolean constraint solving [9], and disjunctive constraint solving [9, 54]. However, interval narrowing is deficient in handling systems of linear constraints over real domain. <p> I 12 Z I 22 = [0; 0] [1; 1] [1; 1] = [0; 0] 3 = Y I 2 X ([c s ; c s ] Z I 30 Chapter 5 The Linear Solver Therefore, we get X I 3 = X I 1 = [4; 8] instead of <ref> [6; 10] </ref>, which is obtained using ordinary interval arithmetic. Note that if multiplication or division is involved, the dependency problem effect cannot be eliminated but only reduced . Solving the system of linear equation (5.2) using generalized interval Gaussian Elimination yields a sharper result. <p> The problem is to find the real roots of the following equation. 20 Y (X + i) + EX 19 = 0 Let E = 0. The real roots of this unperturbed polynomial in the closed interval <ref> [20; 10] </ref> are -20,-19,-18,17,-16,-15,14,-13,-12,-11,-10, respectively. A slight perturbation of the polynomial by E = 2 23 removes all roots in [20; 10], as shown in figure 6.2 (a) which consists of the curves Y = Q 20 i=1 (X + i) and Y = EX 19 . <p> The real roots of this unperturbed polynomial in the closed interval <ref> [20; 10] </ref> are -20,-19,-18,17,-16,-15,14,-13,-12,-11,-10, respectively. A slight perturbation of the polynomial by E = 2 23 removes all roots in [20; 10], as shown in figure 6.2 (a) which consists of the curves Y = Q 20 i=1 (X + i) and Y = EX 19 . CIAL returns no answers as expected.
Reference: [11] <author> B. </author> <title> Buchberger. Grobner bases: An algorithmic method in polynomial ideal theory. In N.K. Bose, editor, Recent Trends in Multidimensional Systems Theory, chapter 6. </title> <address> D. </address> <publisher> Riedel Publ. </publisher> <address> Comp., </address> <year> 1983. </year>
Reference-contexts: Prolog III 1 employs a simplex algorithm to handle arithmetic over rational numbers. CAL computes over two domains: the real numbers and Boolean algebra with symbolic values. Constraints are solved by using Buchberger algorithm for computing Grobner bases <ref> [11] </ref>. RISC-CLP (R) deals with nonlinear arithmetic constraints by using Grobner basis and Partial Cylindrical Algebraic Decomposition [29, 12]. In the sub-symbolic camp, Cleary [16] introduces "logical arithmetic," a relational version of interval arithmetic, into Prolog.
Reference: [12] <author> B. Buchberger and H. Hong. </author> <title> Speeding-up quantifier elimination by Grobner bases. </title> <type> Technical Report 91-06.0, </type> <institution> Research Institute for Symbolic Computation, Johannes Kepler University, A-4040 Linz, Austria, </institution> <year> 1991. </year>
Reference-contexts: CAL computes over two domains: the real numbers and Boolean algebra with symbolic values. Constraints are solved by using Buchberger algorithm for computing Grobner bases [11]. RISC-CLP (R) deals with nonlinear arithmetic constraints by using Grobner basis and Partial Cylindrical Algebraic Decomposition <ref> [29, 12] </ref>. In the sub-symbolic camp, Cleary [16] introduces "logical arithmetic," a relational version of interval arithmetic, into Prolog. He describes distinct algorithms, one for each kind of constraint over intervals, that narrow intervals associated with a constraint by removing values that do not satisfy the constraint.
Reference: [13] <author> X. Chen and D. Wang. </author> <title> On the optimal properties of the Krawczyk-type interval operator. </title> <journal> International Journal of Computer Mathematics, </journal> <volume> 29(2-4):235-245, </volume> <year> 1989. </year>
Reference-contexts: Hansen [23] suggests an inverse mid-point matrix as preconditioner which is shown to be optimal <ref> [13] </ref> in the sense that the preconditioned system gives the tightest bounds of the solutions of the original system. Let A denote the real mid-point matrix of A I .
Reference: [14] <author> C.K. Chiu and J.H.M. Lee. </author> <title> Interval linear constraint solving using the preconditioned interval Gauss-Seidel method. In Workshop on Constraint Languages/Systems and their use in Problem Modelling, </title> <address> Ithaca, USA, </address> <year> 1994. </year>
Reference-contexts: The former criterion implies that the real solutions should always fall into the answer intervals. To satisfy the latter, the widths of answer intervals should be less than a reasonable value, say 0:001. In this chapter, we present two proposals <ref> [15, 14] </ref> to implement such a linear constraint solver. The first, generalized interval Gaussian elimination, is a new combination of CLP (R) technology [44] and centered form [45]. This method always yields better results than naive interval Gaussian elimination. <p> CIAL (Alpha) [15], which consists of about 2800 extra lines of C code, employs generalized interval Gaussian elimination in its linear solver. The proposed preconditioned interval Gauss-Seidel method has been incorporated into CIAL 1.x (Beta) <ref> [14] </ref>. CIAL 1.0 (Beta), which is implemented in about 3000 extra lines of code, is being freely distributed to the public for experimental use, but the solver lacks incremental execution.
Reference: [15] <author> C.K. Chiu and J.H.M. Lee. </author> <title> Towards practical interval constraint solving in logic programming. </title> <booktitle> In Logic Programming: Proceedings of the 1994 International Symposium, </booktitle> <address> Ithaca, USA, </address> <year> 1994. </year>
Reference-contexts: The former criterion implies that the real solutions should always fall into the answer intervals. To satisfy the latter, the widths of answer intervals should be less than a reasonable value, say 0:001. In this chapter, we present two proposals <ref> [15, 14] </ref> to implement such a linear constraint solver. The first, generalized interval Gaussian elimination, is a new combination of CLP (R) technology [44] and centered form [45]. This method always yields better results than naive interval Gaussian elimination. <p> In general, this method cannot give as sharp results as preconditioned interval Gaussian elimination, but always performs better than naive interval Gaussian elimination. The method can also tackle some classes of problems that cannot be handled by interval narrowing based system <ref> [15] </ref>. A generalized interval Gaussian elimination procedure is obtained by replacing ordinary arithmetic operators in an ordinary Gaussian elimination procedure by the corresponding generalized interval arithmetic operators [24], which are described as follows. <p> The solver interface and the two solvers (the linear solver and the non-linear solver) are implemented from scratch. We also modify the unification algorithm of the Prolog engine to cope with unification between interval variables and other terms. CIAL (Alpha) <ref> [15] </ref>, which consists of about 2800 extra lines of C code, employs generalized interval Gaussian elimination in its linear solver. The proposed preconditioned interval Gauss-Seidel method has been incorporated into CIAL 1.x (Beta) [14].
Reference: [16] <author> J.G. Cleary. </author> <title> Logical arithmetic. </title> <journal> Future Computing Systems, </journal> <volume> 2(2) </volume> <pages> 125-149, </pages> <year> 1987. </year> <month> 59 </month>
Reference-contexts: However, interval narrowing is deficient in handling systems of linear constraints over real domain. For example, interval narrowing fails to solve such simple systems as "fX + Y = 5; X Y = 6g." Cleary <ref> [16] </ref> proposes a form of case analysis technique [57], domain splitting , as a remedy. Domain splitting partitions an interval into two, visits one, and visits the other upon backtracking. This backtracking tree search is expensive to perform. <p> CAL computes over two domains: the real numbers and Boolean algebra with symbolic values. Constraints are solved by using Buchberger algorithm for computing Grobner bases [11]. RISC-CLP (R) deals with nonlinear arithmetic constraints by using Grobner basis and Partial Cylindrical Algebraic Decomposition [29, 12]. In the sub-symbolic camp, Cleary <ref> [16] </ref> introduces "logical arithmetic," a relational version of interval arithmetic, into Prolog. He describes distinct algorithms, one for each kind of constraint over intervals, that narrow intervals associated with a constraint by removing values that do not satisfy the constraint. <p> If J I is a non-empty real interval, ~(J I ) = fJ I 0 g: The outward-rounding function gives the tightest floating-point interval containing J I . 2.2 Relational Interval Arithmetic Cleary <ref> [16] </ref> introduces "logical arithmetic" by defining distinct primitive arithmetic constraints over intervals, which remove the values of intervals that do not satisfy the constraints. Lee [36] generalizes Cleary's algorithms to interval reduction, which is applicable to any arithmetic relation p on I (IR) n . <p> Linear Equality Cleary <ref> [16] </ref> proposes a 3-ary add primitive, add = f (x; y; z) j x; y; z 2 IR; x + y = zg: Chapter 2 Overview of ICLP (R) This design is too restrictive and may cause unnecessary decompositions of constraints. We give a more general relation linear n here. <p> The result of division can be a union of two disjoint intervals in general. This does not satisfy the criterion that the function of primitive relation must map from real intervals to real intervals. Cleary <ref> [16] </ref> suggests to decompose mult into mult + and mult , where mult + = f (x; y; z) j x; y; z 2 &lt;; x 0; xy = zg mult = f (x; y; z) j x; y; z 2 &lt;; x &lt; 0; xy = zg: We perform interval <p> Interval reduction and interval narrowing described here are named as narrowing function and narrowing algorithm respectively in [9]. 3 An interval can be partitioned in different ways. Cleary <ref> [16] </ref> discusses two predicates, linear split/1 and exp split/1, which partition intervals at different points. <p> A constraint is mixed if it contains both linear and non-linear terms. In CIAL, linear constraint goes directly to the linear constraint solver without being pre-processed. A non-linear constraint is first partitioned into a set of convex primitives, as described in <ref> [16] </ref>, and then delivered to the non-linear solver. For a mixed constraint, we decompose it into a linear constraint and 23 Chapter 4 Design of CIAL 1. We linearize a mixed constraint by replacing all non-linear terms, each by a temporary variable.
Reference: [17] <author> A. Colmerauer. </author> <title> An introduction to Prolog III. </title> <journal> Communications of the ACM, </journal> <volume> 33(7) </volume> <pages> 69-90, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: The precisions of solutions and the speed of convergence are improved with the cooperation of the two techniques. The non-linear solver employs interval narrowing with splitting to solve inequalities and non-linear constraints. 1 Chapter 1 Introduction 1.1 Related Work Prolog III <ref> [17] </ref>, CAL [2], and RISC-CLP (R) [30] use symbolic algebraic methods to solve arithmetic constraints. Prolog III 1 employs a simplex algorithm to handle arithmetic over rational numbers. CAL computes over two domains: the real numbers and Boolean algebra with symbolic values.
Reference: [18] <author> T.H. Cormen, C.E. Leiserson, and R.L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> eighth edition, </address> <year> 1992. </year>
Reference-contexts: We partition the new preconditioner P, the new coefficient matrix A I , and their product as shown in figure 5.2. The product matrix R I can be calculated by the 6 We do not consider such special divide-and-conquer matrix multiplication algorithms as Strassen's algorithm (O (n 2:81 )) <ref> [18] </ref>. Those algorithms usually introduce multiple occurrences of variables and require the dimension of the matrix to be a power of 2.
Reference: [19] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. </author> <title> The constraint logic programming language CHIP. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo, Japan, </address> <year> 1988. </year>
Reference-contexts: Lee and van Emden [38, 39] generalize Cleary's algorithms for narrowing intervals constrained by any relations p on I (IR) n . They also show how the generalized algorithm can be incorporated in CLP (R) [32] and CHIP <ref> [19] </ref> in such a way that the languages' logical semantics is preserved. Lee and Lee [37] propose an integration of constraint interval arithmetic into logic programming at the Warren Abstract Machine (WAM) [3] level. <p> Semantically, an interval variable is an ordinary logical variable. We distinguish interval variables from logical variables purely for implementation efficiency. Resembling domain variables in finite-domain languages [57], e.g. CHIP <ref> [1, 19] </ref>, an interval variable is represented as a variable with an associated interval. Its heap representation is shown in figure 4.2, where ITAG is a new tag introduced for interval variables. Each interval variable in CIAL keeps a list of constraints in which the variable appears.
Reference: [20] <author> D.M. Gay. </author> <title> Solving interval linear equations. </title> <journal> SIAM Journal on Numerical Analysis, </journal> <volume> 19(4) </volume> <pages> 858-870, </pages> <year> 1982. </year>
Reference-contexts: The decomposition procedure is shown in algorithm 4.1. To improve the efficiency of linear constraint solving, we pass the linear constraint T 0 =:= P j T k ) to the non-linear solver instead of the linear solver. Interval linear constraint solving usually involves variable elimination <ref> [20, 25, 48] </ref>, which is a time consuming symbolic algorithm. <p> The problem is to find the real roots of the following equation. 20 Y (X + i) + EX 19 = 0 Let E = 0. The real roots of this unperturbed polynomial in the closed interval <ref> [20; 10] </ref> are -20,-19,-18,17,-16,-15,14,-13,-12,-11,-10, respectively. A slight perturbation of the polynomial by E = 2 23 removes all roots in [20; 10], as shown in figure 6.2 (a) which consists of the curves Y = Q 20 i=1 (X + i) and Y = EX 19 . <p> The real roots of this unperturbed polynomial in the closed interval <ref> [20; 10] </ref> are -20,-19,-18,17,-16,-15,14,-13,-12,-11,-10, respectively. A slight perturbation of the polynomial by E = 2 23 removes all roots in [20; 10], as shown in figure 6.2 (a) which consists of the curves Y = Q 20 i=1 (X + i) and Y = EX 19 . CIAL returns no answers as expected.
Reference: [21] <author> W.W. Hager. </author> <title> Updating the inverse of a matrix. </title> <journal> SIAM Review, </journal> <volume> 31(2) </volume> <pages> 221-239, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: I i Y I kr = Z I jr Generalized Interval Subtraction If X I i g X I j , then X I i Y I n X ([c r ; c r ] (Z I jr )) 1 The corresponding problem in real domain is usually somewhat easier <ref> [21] </ref> since we do not need to consider the depen dency problem. 2 We abuse the notation P to denote interval summation. 29 Chapter 5 The Linear Solver where Y I i Y I kr = Z I jr Generalized Interval Multiplication If X I i g X I j ,
Reference: [22] <author> E. Hansen. </author> <title> Global Optimization using Interval Analysis. </title> <publisher> Marcel Dekker, Inc., </publisher> <year> 1992. </year>
Reference-contexts: Real interval is shown to be closed under both the F i (mult + ) and F i (mult ). Square It is well-known that interval arithmetic suffers from the variable dependency problem <ref> [22] </ref> that causes it to produce inaccurate results. When a given variable occurs more than once in an interval computation, it is treated as a different variable in each occurrence. This causes widening of the computed intervals. <p> The first, generalized interval Gaussian elimination, is a new combination of CLP (R) technology [44] and centered form [45]. This method always yields better results than naive interval Gaussian elimination. The second is a commonly-used iterative interval method, preconditioned interval Gauss-Seidel method <ref> [22, 33, 34, 35] </ref>. These two methods, as originally designed, operate in the batch mode: all the constraints are collected before solving takes place. In this chapter, we discuss how they can be adapted to incremental execution for use in a CLP system. <p> Y I = (0:80016132:::; 0:79975469:::) In the following, we show that better results can be obtained by adopting operators from generalized interval arithmetic in Gaussian elimination. 5.1.2 Generalized Interval Gaussian Elimination The interval Gaussian elimination procedure is well studied <ref> [23, 4, 22, 25] </ref>. A well-known algorithm, known as preconditioned interval Gaussian elimination, is proposed by Hansen [23]. Preconditioned Gaussian elimination transforms the coefficient matrix A I to a near identity matrix ~ I I before applying naive interval Gaussian elimination. <p> Such a system can be solved efficiently by using some iterative methods. Preconditioned interval Gauss-Seidel method is an iterative method being widely-used in interval computation <ref> [48, 22, 33, 34] </ref>.
Reference: [23] <author> E.R. Hansen. </author> <title> Interval arithmetic in matrix computations. </title> <journal> SIAM Journal on Numerical Analysis, </journal> <volume> 2 </volume> <pages> 308-320, </pages> <year> 1965. </year>
Reference-contexts: Y I = (0:80016132:::; 0:79975469:::) In the following, we show that better results can be obtained by adopting operators from generalized interval arithmetic in Gaussian elimination. 5.1.2 Generalized Interval Gaussian Elimination The interval Gaussian elimination procedure is well studied <ref> [23, 4, 22, 25] </ref>. A well-known algorithm, known as preconditioned interval Gaussian elimination, is proposed by Hansen [23]. Preconditioned Gaussian elimination transforms the coefficient matrix A I to a near identity matrix ~ I I before applying naive interval Gaussian elimination. <p> A well-known algorithm, known as preconditioned interval Gaussian elimination, is proposed by Hansen <ref> [23] </ref>. Preconditioned Gaussian elimination transforms the coefficient matrix A I to a near identity matrix ~ I I before applying naive interval Gaussian elimination. Since all subdiagonal elements are nearly zeroes, the variable dependency effect are 28 Chapter 5 The Linear Solver highly reduced. <p> Instead of solving A I ~ X I = ~ b I , we deal with the following system: P A I ~ X I = P ~ b I (5.7) We call P the preconditioner . Hansen <ref> [23] </ref> suggests an inverse mid-point matrix as preconditioner which is shown to be optimal [13] in the sense that the preconditioned system gives the tightest bounds of the solutions of the original system. Let A denote the real mid-point matrix of A I .
Reference: [24] <author> E.R. Hansen. </author> <title> A generalized interval arithmetic. </title> <booktitle> In Interval Mathematics, </booktitle> <pages> pages 7-18, </pages> <year> 1975. </year>
Reference-contexts: Answers generated using this naive approach, however, will not be as sharp as possible, in general, due to outward rounding and variable dependency problem. The former is unavoidable in performing interval arithmetic in a floating-point system. Generalized interval arithmetic by Hansen <ref> [24] </ref> presents a way to reduce the effect of the latter. 5.1.1 Naive Interval Gaussian Elimination We begin with a quick review of the general form of the Gaussian elimination method in the real number domain. <p> The method can also tackle some classes of problems that cannot be handled by interval narrowing based system [15]. A generalized interval Gaussian elimination procedure is obtained by replacing ordinary arithmetic operators in an ordinary Gaussian elimination procedure by the corresponding generalized interval arithmetic operators <ref> [24] </ref>, which are described as follows. <p> These subterms provide information to locate multiple occurrences of a variable during computation, so as to reduce the effect of the variable dependency problem. The basic generalized interval arithmetic operators, g (addition), g (subtraction), g (multiplication) and ff g (division), are defined <ref> [24] </ref> in the following. <p> Theorem 5.1.1: Generalized interval Gaussian elimination preserves all solutions of a linear interval system. The solutions given by the generalized interval Gaussian elimination solver are sound. Proof : From the inclusion monotonicity property of generalized interval arithmetic <ref> [24] </ref> and the correctness of Gaussian elimination. Theorem 5.1.2: The constraint solving step in algorithm 4.2 with the generalized interval Gaussian elimination solver always terminates.
Reference: [25] <author> E.R. Hansen. </author> <title> Bounding the solution of interval linear equations. </title> <journal> SIAM Journal on Numerical Analysis, </journal> <volume> 29(5) </volume> <pages> 1493-1503, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The decomposition procedure is shown in algorithm 4.1. To improve the efficiency of linear constraint solving, we pass the linear constraint T 0 =:= P j T k ) to the non-linear solver instead of the linear solver. Interval linear constraint solving usually involves variable elimination <ref> [20, 25, 48] </ref>, which is a time consuming symbolic algorithm. <p> Y I = (0:80016132:::; 0:79975469:::) In the following, we show that better results can be obtained by adopting operators from generalized interval arithmetic in Gaussian elimination. 5.1.2 Generalized Interval Gaussian Elimination The interval Gaussian elimination procedure is well studied <ref> [23, 4, 22, 25] </ref>. A well-known algorithm, known as preconditioned interval Gaussian elimination, is proposed by Hansen [23]. Preconditioned Gaussian elimination transforms the coefficient matrix A I to a near identity matrix ~ I I before applying naive interval Gaussian elimination.
Reference: [26] <author> W.S. Havens, S. Sidebottom, J. Jones, M. Cuperman, and R. Davison. </author> <title> Echidna constraint reasoning system: Next-generation expert system technology. </title> <type> Technical Report CSS-IS TR 90-09, </type> <institution> Centre for Systems Science, Simon Fraser University, Burnaby, B.C., Canada, </institution> <year> 1990. </year>
Reference-contexts: BNR-Prolog [51] and its sequel CLP (BNR) [9] provide relational interval arithmetic in a way that is loosely based on Cleary's pre-publication idea, differing somewhat in particulars. Sidebottom and Havens [54] design and implement a version of relational interval arithmetic in the constraint reasoning system Echidna <ref> [26] </ref>. Based on hierarchical consistency techniques [43], Echidna can handle unions of disjoint intervals. Lhomme [40] analyzes the complexity of consistency techniques for numeric CSP's and proposes partial consistency techniques, whose complexities can be tuned by adjusting the bound width of the resulting intervals.
Reference: [27] <author> N. Heintze, S. Michaylov, and P. Stuckey. </author> <title> CLP(R) and some electrical engineering problems. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 9(2) </volume> <pages> 231-260, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: It is interesting to note that the first four systems are able to return slightly less accurate solutions when interval splitting is employed. 6.3 Analysis of DC Circuit Electrical engineering is an important application area for constraint logic programming <ref> [27] </ref>. Consider the simple DC circuit in figure 6.1. We are interested in the currents passing through the resistors. Assume that V = 10 volts and R i = i for i = 1; 2; ; 9.
Reference: [28] <author> N.C. Heintze, J. Jaffar, S. Michaylov, P.J. Stuckey, and R.H.C. Yap. </author> <title> The CLP(R) Programmer's Manual Version 1.2. </title> <institution> IBM Thomas J Watson Research Center, </institution> <year> 1992. </year>
Reference-contexts: To achieve the goal of efficient constraint solving, we decide to re-use only the Prolog engine part of CLP (R) in our subsequent CIAL prototype implementations. We have completed three different CIAL prototypes, all of which are based on CLP (R) Version 1.2 <ref> [28] </ref>. The solver interface and the two solvers (the linear solver and the non-linear solver) are implemented from scratch. We also modify the unification algorithm of the Prolog engine to cope with unification between interval variables and other terms. <p> In this chapter, we compare our three CIAL prototypes with BNR Prolog v3.1.0 [7, 52], CLP (BNR) (or BNR Prolog v4.2.3) [50, 9], Echidna Version 0.947 beta [55, 54], ICL [37], and CLP (R) Version 1.2 <ref> [28, 32] </ref> over seven numerical examples of various types: the well-known mortgage program [28] which comes with the CLP (R) distribution, a simple system of simultaneous equations in two variables, analysis of a simple DC circuit, inconsistent simultaneous equations, the ball collision problem [30], the famous Wilkinson polynomial [30], and two <p> In this chapter, we compare our three CIAL prototypes with BNR Prolog v3.1.0 [7, 52], CLP (BNR) (or BNR Prolog v4.2.3) [50, 9], Echidna Version 0.947 beta [55, 54], ICL [37], and CLP (R) Version 1.2 [28, 32] over seven numerical examples of various types: the well-known mortgage program <ref> [28] </ref> which comes with the CLP (R) distribution, a simple system of simultaneous equations in two variables, analysis of a simple DC circuit, inconsistent simultaneous equations, the ball collision problem [30], the famous Wilkinson polynomial [30], and two large systems of linear equations. <p> We conclude this chapter by giving a comparison of the performance between CIAL 1.0 (Beta) and CIAL 1.1 (Beta). It shows how the efficiency of linear constraint solving is improved by an incremental preconditioning algorithm. 47 Chapter 6 Benchmarkings 6.1 Mortgage The mortgage program <ref> [28] </ref> is a standard example from CLP (R) for relating the principal, number of months, interest rate, outstanding balance and monthly payment in a mortgage. We rewrite it in CIAL syntax. mg (P,T,I,B,MP) :- B =:= P + (I*P - MP).
Reference: [29] <author> H. Hong. </author> <title> Improvements in CAD-Based Quantifier Elimination. </title> <type> PhD thesis, </type> <institution> The Ohio State University, </institution> <year> 1990. </year>
Reference-contexts: CAL computes over two domains: the real numbers and Boolean algebra with symbolic values. Constraints are solved by using Buchberger algorithm for computing Grobner bases [11]. RISC-CLP (R) deals with nonlinear arithmetic constraints by using Grobner basis and Partial Cylindrical Algebraic Decomposition <ref> [29, 12] </ref>. In the sub-symbolic camp, Cleary [16] introduces "logical arithmetic," a relational version of interval arithmetic, into Prolog. He describes distinct algorithms, one for each kind of constraint over intervals, that narrow intervals associated with a constraint by removing values that do not satisfy the constraint.
Reference: [30] <author> H. Hong. </author> <title> Non-linear real constraints in constraint logic programming. </title> <booktitle> In Proceedings of the Second International Conference on Algebraic and Logic Programming, </booktitle> <year> 1992. </year>
Reference-contexts: The advent of constraint logic programming [31] presents a solution to the first problem but the implementation of CLP languages, such as CLP (R) [32], are mostly based on floating-point arithmetic. The second problem remains. The languages CAL [2] and RISC-CLP (R) <ref> [30] </ref> use symbolic algebraic methods to refrain from floating-point operations. Algebraic methods guarantee the soundness of numerical computation but they are time-consuming. Previous efforts in the sub-symbolic camp, such as BNR Prolog [51], employ interval methods [45] and belong to the family of consistency techniques [42]. <p> The precisions of solutions and the speed of convergence are improved with the cooperation of the two techniques. The non-linear solver employs interval narrowing with splitting to solve inequalities and non-linear constraints. 1 Chapter 1 Introduction 1.1 Related Work Prolog III [17], CAL [2], and RISC-CLP (R) <ref> [30] </ref> use symbolic algebraic methods to solve arithmetic constraints. Prolog III 1 employs a simplex algorithm to handle arithmetic over rational numbers. CAL computes over two domains: the real numbers and Boolean algebra with symbolic values. Constraints are solved by using Buchberger algorithm for computing Grobner bases [11]. <p> ICL [37], and CLP (R) Version 1.2 [28, 32] over seven numerical examples of various types: the well-known mortgage program [28] which comes with the CLP (R) distribution, a simple system of simultaneous equations in two variables, analysis of a simple DC circuit, inconsistent simultaneous equations, the ball collision problem <ref> [30] </ref>, the famous Wilkinson polynomial [30], and two large systems of linear equations. The examples range from purely linear constraints, to a mixture of linear and non-linear constraints, and to purely non-linear constraints. <p> Version 1.2 [28, 32] over seven numerical examples of various types: the well-known mortgage program [28] which comes with the CLP (R) distribution, a simple system of simultaneous equations in two variables, analysis of a simple DC circuit, inconsistent simultaneous equations, the ball collision problem <ref> [30] </ref>, the famous Wilkinson polynomial [30], and two large systems of linear equations. The examples range from purely linear constraints, to a mixture of linear and non-linear constraints, and to purely non-linear constraints. <p> This collision problem and the following program are adopted from <ref> [30] </ref>. The program describes two objects, one stationary cubic wall and a ball moving along a quadratic space curve. <p> Given the following query, ?- T &gt;= 0, object A (X,Y,Z), object B moving (T,X,Y,Z)., all CIAL prototypes give the result, T 2 (1:6972243622; 3:3166247904): It is the same as the results obtained from RISC-CLP (Real) <ref> [30] </ref>, which employs symbolic algebraic method for constraint solving. T 2 7T + 9 &lt;= 0: T 2 11 &lt;= 0: RISC-CLP (Real) cannot solve the above quadratic equations. We use some algebra packages to solve the two systems.
Reference: [31] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> Conference Record of the Fourteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1987. </year>
Reference-contexts: First, the system predicate "is" [56] is functional in nature. It is incompatible with the relational paradigm of logic programming. Second, real numbers are approximated by floating-point numbers. Roundoff errors induced by floating-point arithmetic destroy the soundness [41] of computation. The advent of constraint logic programming <ref> [31] </ref> presents a solution to the first problem but the implementation of CLP languages, such as CLP (R) [32], are mostly based on floating-point arithmetic. The second problem remains. The languages CAL [2] and RISC-CLP (R) [30] use symbolic algebraic methods to refrain from floating-point operations. <p> then remove (q; ~ J I ) from P and append it to A endif endforeach endif endif append (p; ~ I I ) to the end of P endwhile Algorithm 2.1: Relaxation Algorithm 2.3 Syntax and Semantics ICLP (R) and CLP (R) share the same syntax and declarative semantics <ref> [31, 32] </ref>. An interval constraint in ICLP (R) is expressed as, X 1 2 I I n ; p (X 1 ; : : : ; X n ); where X i 2 I I i is an appropriate pair of inequalities.
Reference: [32] <author> J. Jaffar, S. Michaylov, P.J. Stuckey, and R.H.C. Yap. </author> <title> The CLP(R) language and system. </title> <journal> In ACM Transactions on Programming Languages and Systems, </journal> <volume> volume 14, </volume> <pages> pages 339-395, </pages> <year> 1992. </year>
Reference-contexts: Second, real numbers are approximated by floating-point numbers. Roundoff errors induced by floating-point arithmetic destroy the soundness [41] of computation. The advent of constraint logic programming [31] presents a solution to the first problem but the implementation of CLP languages, such as CLP (R) <ref> [32] </ref>, are mostly based on floating-point arithmetic. The second problem remains. The languages CAL [2] and RISC-CLP (R) [30] use symbolic algebraic methods to refrain from floating-point operations. Algebraic methods guarantee the soundness of numerical computation but they are time-consuming. <p> Lee and van Emden [38, 39] generalize Cleary's algorithms for narrowing intervals constrained by any relations p on I (IR) n . They also show how the generalized algorithm can be incorporated in CLP (R) <ref> [32] </ref> and CHIP [19] in such a way that the languages' logical semantics is preserved. Lee and Lee [37] propose an integration of constraint interval arithmetic into logic programming at the Warren Abstract Machine (WAM) [3] level. <p> then remove (q; ~ J I ) from P and append it to A endif endforeach endif endif append (p; ~ I I ) to the end of P endwhile Algorithm 2.1: Relaxation Algorithm 2.3 Syntax and Semantics ICLP (R) and CLP (R) share the same syntax and declarative semantics <ref> [31, 32] </ref>. An interval constraint in ICLP (R) is expressed as, X 1 2 I I n ; p (X 1 ; : : : ; X n ); where X i 2 I I i is an appropriate pair of inequalities. <p> When two interval variables are unified successfully, their constraint lists are merged and all related constraints are waken up. 4.3 The Solver Interface and Constraint Decomposition The design of the CIAL solver interface is similar to that of CLP (R) <ref> [32] </ref>. The solver interface is called from the inference engine whenever a constraint contains an arithmetic term. If the input constraint contains any number that cannot be represented exactly as a floating-point number, the number will be first outward-rounded to an interval. <p> In the following, we present an adaptation of the generalized Gaussian elimination procedure to incremental execution and its interaction with the non-linear solver. Our algorithm is based on that of CLP (R) <ref> [32] </ref>. Many parts of the CIAL linear solver, such as trailing and backtracking, can be implemented in a similar fashion. We present only the components that differ from their counterparts in CLP (R) : detection of redundancy / inconsistency of newly added linear equation and the selection of non-parametric variables. <p> If C n contains only parametric variable (s), choose one which appears in the non-linear solver. This criterion is on the contrary to the corresponding rule in CLP (R), which tries to select a variable that does not appear in the inequality solver <ref> [32] </ref>. CIAL hopes that the variables in non-linear constraints can be further narrowed with the aid of linear solver, while CLP (R) tries to avoid invocation of the inequality solver. 3. <p> In this chapter, we compare our three CIAL prototypes with BNR Prolog v3.1.0 [7, 52], CLP (BNR) (or BNR Prolog v4.2.3) [50, 9], Echidna Version 0.947 beta [55, 54], ICL [37], and CLP (R) Version 1.2 <ref> [28, 32] </ref> over seven numerical examples of various types: the well-known mortgage program [28] which comes with the CLP (R) distribution, a simple system of simultaneous equations in two variables, analysis of a simple DC circuit, inconsistent simultaneous equations, the ball collision problem [30], the famous Wilkinson polynomial [30], and two
Reference: [33] <author> R.B. Kearfott. </author> <title> Preconditioners for the interval Gauss-Seidel method. </title> <journal> SIAM Journal on Numerical Analysis, </journal> <volume> 27(3) </volume> <pages> 804-822, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The first, generalized interval Gaussian elimination, is a new combination of CLP (R) technology [44] and centered form [45]. This method always yields better results than naive interval Gaussian elimination. The second is a commonly-used iterative interval method, preconditioned interval Gauss-Seidel method <ref> [22, 33, 34, 35] </ref>. These two methods, as originally designed, operate in the batch mode: all the constraints are collected before solving takes place. In this chapter, we discuss how they can be adapted to incremental execution for use in a CLP system. <p> Such a system can be solved efficiently by using some iterative methods. Preconditioned interval Gauss-Seidel method is an iterative method being widely-used in interval computation <ref> [48, 22, 33, 34] </ref>.
Reference: [34] <author> R.B. Kearfott, C. Hu, and M. Novoa. </author> <title> A review of preconditioners for the interval Gauss-Seidel method. Interval Computations, </title> <booktitle> 1(1) </booktitle> <pages> 59-85, </pages> <year> 1991. </year>
Reference-contexts: The first, generalized interval Gaussian elimination, is a new combination of CLP (R) technology [44] and centered form [45]. This method always yields better results than naive interval Gaussian elimination. The second is a commonly-used iterative interval method, preconditioned interval Gauss-Seidel method <ref> [22, 33, 34, 35] </ref>. These two methods, as originally designed, operate in the batch mode: all the constraints are collected before solving takes place. In this chapter, we discuss how they can be adapted to incremental execution for use in a CLP system. <p> Such a system can be solved efficiently by using some iterative methods. Preconditioned interval Gauss-Seidel method is an iterative method being widely-used in interval computation <ref> [48, 22, 33, 34] </ref>.
Reference: [35] <author> R.B. Kearfott and Xing Z. </author> <title> An interval step control for continuation methods. </title> <journal> SIAM Journal on Numerical Analysis, </journal> <volume> 31(3) </volume> <pages> 892-914, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The first, generalized interval Gaussian elimination, is a new combination of CLP (R) technology [44] and centered form [45]. This method always yields better results than naive interval Gaussian elimination. The second is a commonly-used iterative interval method, preconditioned interval Gauss-Seidel method <ref> [22, 33, 34, 35] </ref>. These two methods, as originally designed, operate in the batch mode: all the constraints are collected before solving takes place. In this chapter, we discuss how they can be adapted to incremental execution for use in a CLP system.
Reference: [36] <author> J.H.M. Lee. </author> <title> Numerical Computation As Deduction In Constraint Logic Programming. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Logic Programming Laboratory, University of Victoria, Victoria, Canada, </institution> <year> 1992. </year> <month> 60 </month>
Reference-contexts: The basics of interval arithmetic, in both functional and relational forms, are presented. We then describe the syntax and semantics of the ICLP (R) language [38], which is an extension of CLP (R) with relational interval arithmetic. Most of the above materials are adopted from <ref> [38, 36, 39] </ref> except those otherwise specified. 2.1 Basics of Interval Arithmetic The manuscripts [45, 4] provide good introduction to interval analysis. Let IR be the set of real numbers and IF the set of floating-point numbers. <p> Lee <ref> [36] </ref> generalizes Cleary's algorithms to interval reduction, which is applicable to any arithmetic relation p on I (IR) n . Interval reduction can only work on a single constraint. In practice, several constraints interact with one another in a system. <p> A relaxation algorithm (Algorithm 2.1) reduces a network into a stable one. The relaxation algorithm is similar to the arc-consistency algorithm AC-3 [42]. The use of interval reduction to narrow interval constraints is not mandatory, but can be replaced by any appropriate domain restriction operator <ref> [36] </ref>. We refer to the relaxation algorithm with interval reduction operator as interval narrowing 2 . Interval narrowing sometimes fails to narrow intervals to useful widths. Interval splitting is a divide-and-conquer algorithm used for obtaining sharp solution intervals. <p> We first visit one half, while the remaining half is visited upon backtracking or under user-control. The procedure of interval narrowing with splitting is shown as algorithm 2.2. 2 Different definitions are used in <ref> [36, 9] </ref>. In [36], interval narrowing refers to the interval reduction operator described here, while relaxation algorithm is assumed to have interval reduction as the domain restriction operator all the time. <p> We first visit one half, while the remaining half is visited upon backtracking or under user-control. The procedure of interval narrowing with splitting is shown as algorithm 2.2. 2 Different definitions are used in [36, 9]. In <ref> [36] </ref>, interval narrowing refers to the interval reduction operator described here, while relaxation algorithm is assumed to have interval reduction as the domain restriction operator all the time. <p> The operational semantics is based on the generalized M derivation <ref> [36] </ref>, which is shown as the following. <p> narrowable interval in Q, say V I , into V I 1 and V I trail V I 2 replace V I by V I 1 invoke interval narrowing if interval narrowing fails then perform backtracking endif endwhile dump solutions perform backtracking Algorithm 2.2: Interval Narrowing with Splitting Theorem 2.3.1 <ref> [36] </ref>: If C 0 is obtained from C using interval reduction on p, where C is X 1 2 I 1 ; : : : ; X n 2 I n , p (X 1 ; : : : ; X n ) and C 0 is X 1 2 I <p> Proof : Since the input constraints are finite, the preconditioner and the preconditioned system update procedures will not be invoked infinitely. Interval Gauss-Seidel method can be considered as "partial" interval narrowing (lemma 5.2.5). Since interval narrowing always terminates with an inconsistent or a stable system <ref> [36] </ref>, it follows that the constraint solving step always terminates. The system is also either inconsistent or stable. 5.3 Comparisons We have presented how the two proposed linear solvers can be adapted for incremental execution. The soundness of the solvers has also been proved.
Reference: [37] <author> J.H.M. Lee and T.W. Lee. </author> <title> A WAM-based abstract machine for interval constraint logic programming. </title> <booktitle> In Proceedings of the Sixth IEEE International Conference on Tools with Artificial Intelligence, </booktitle> <address> New Orleans, USA, </address> <year> 1994. </year>
Reference-contexts: They also show how the generalized algorithm can be incorporated in CLP (R) [32] and CHIP [19] in such a way that the languages' logical semantics is preserved. Lee and Lee <ref> [37] </ref> propose an integration of constraint interval arithmetic into logic programming at the Warren Abstract Machine (WAM) [3] level. <p> The clause (G 0 G 1 ; ; G n ) is a conditional answer to the original goal. 11 Chapter 2 Overview of ICLP (R) 12 Chapter 3 Limitations of Interval Narrowing Interval narrowing with splitting is a common constraint solving technique used in interval constraint logic programming languages <ref> [39, 37, 9, 51] </ref>. Our experiments show that, in general, this technique is impractical in solving some classes of problems in terms of both computation time and storage. We try to solve a set of randomly generated systems of linear equations in several interval narrowing based systems. <p> constraints, A ~ X = ~ b; where A = (a ij ); ~ X = (X i ); ~ b = (b i ); a ij 6= 0; b i 6= 0; and X i 2 [10000; 10000] on BNR Prolog [52], CLP (BNR) [9], Echidna [54] and ICL <ref> [37] </ref> with splitting. All coefficients a ij and b i are randomly generated non-zero floating-point numbers. The results for each problem size n are the average of three different sets of test data and are summarized in table 3.1 and table 3.2. <p> The three prototypes use interval narrowing with splitting in solving inequality and non-linear constraints. In this chapter, we compare our three CIAL prototypes with BNR Prolog v3.1.0 [7, 52], CLP (BNR) (or BNR Prolog v4.2.3) [50, 9], Echidna Version 0.947 beta [55, 54], ICL <ref> [37] </ref>, and CLP (R) Version 1.2 [28, 32] over seven numerical examples of various types: the well-known mortgage program [28] which comes with the CLP (R) distribution, a simple system of simultaneous equations in two variables, analysis of a simple DC circuit, inconsistent simultaneous equations, the ball collision problem [30], the <p> Second, the current prototypes implement constraint solvers as independent modules separating from the Prolog engine. Communications between the solvers and the Prolog engine incur high overhead. Backtracking also becomes a costly operation. We expect that the work of Lee and Lee <ref> [37] </ref> can be used as basis to integrate the interval constraint solving and the Prolog engine at the Warren Abstract Machine (WAM) level. Third, built-in predicates in CIAL are limited. To apply CIAL on real-life problems (e.g. scheduling), more relations, such as max/2, min/2, sin/1, asin/1 [50], should be provided.
Reference: [38] <author> J.H.M. Lee and M.H. van Emden. </author> <title> Adapting CLP(R) to floating-point arithmetic. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <volume> volume 16, </volume> <pages> pages 996-1003, </pages> <address> Tokyo, Japan, </address> <year> 1992. </year>
Reference-contexts: Based on hierarchical consistency techniques [43], Echidna can handle unions of disjoint intervals. Lhomme [40] analyzes the complexity of consistency techniques for numeric CSP's and proposes partial consistency techniques, whose complexities can be tuned by adjusting the bound width of the resulting intervals. Lee and van Emden <ref> [38, 39] </ref> generalize Cleary's algorithms for narrowing intervals constrained by any relations p on I (IR) n . They also show how the generalized algorithm can be incorporated in CLP (R) [32] and CHIP [19] in such a way that the languages' logical semantics is preserved. <p> In chapter 2, we provide the theoretical background to this thesis. We outline the concepts of relational interval arithmetic, followed by a description of interval narrowing and interval splitting. The operational semantics of ICLP (R) <ref> [38] </ref>, which is shared by our proposed interval constraint logic programming system, is also presented. In chapter 3, we give a detailed discussion of the limitations of interval narrowing and interval splitting. We verify our assertion empirically by running experiments on some interval narrowing based systems. <p> The basics of interval arithmetic, in both functional and relational forms, are presented. We then describe the syntax and semantics of the ICLP (R) language <ref> [38] </ref>, which is an extension of CLP (R) with relational interval arithmetic. Most of the above materials are adopted from [38, 36, 39] except those otherwise specified. 2.1 Basics of Interval Arithmetic The manuscripts [45, 4] provide good introduction to interval analysis. <p> The basics of interval arithmetic, in both functional and relational forms, are presented. We then describe the syntax and semantics of the ICLP (R) language [38], which is an extension of CLP (R) with relational interval arithmetic. Most of the above materials are adopted from <ref> [38, 36, 39] </ref> except those otherwise specified. 2.1 Basics of Interval Arithmetic The manuscripts [45, 4] provide good introduction to interval analysis. Let IR be the set of real numbers and IF the set of floating-point numbers. <p> Although CLP (R) can express interval constraints well, it fails to narrow the intervals. We embed interval narrowing for solving interval constraints. The resultant prototype is, however, only four to five times faster than the ICLP (R) meta-interpreter <ref> [38] </ref>. To achieve the goal of efficient constraint solving, we decide to re-use only the Prolog engine part of CLP (R) in our subsequent CIAL prototype implementations. We have completed three different CIAL prototypes, all of which are based on CLP (R) Version 1.2 [28]. <p> We propose to separate linear equality constraint solving from inequality and non-linear constraint solving. This idea is realized in our new interval constraint logic programming system, CIAL (for Constraint Interval Arithmetic Language), which shares the same declarative and operational semantics as those of ICLP (R) <ref> [38] </ref> (Chapter 2). We have designed an architecture for CIAL and established the interaction among the modules in the architecture. Unification between interval variables and other terms are handled in an extended unification algorithm. Input arithmetic constraints are decomposed into linear equalities and a set of convex primitive constraints.
Reference: [39] <author> J.H.M. Lee and M.H. van Emden. </author> <title> Interval computation as deduction in CHIP. </title> <journal> Journal of Logic Programming, </journal> <volume> 16 </volume> <pages> 255-276, </pages> <year> 1993. </year>
Reference-contexts: Based on hierarchical consistency techniques [43], Echidna can handle unions of disjoint intervals. Lhomme [40] analyzes the complexity of consistency techniques for numeric CSP's and proposes partial consistency techniques, whose complexities can be tuned by adjusting the bound width of the resulting intervals. Lee and van Emden <ref> [38, 39] </ref> generalize Cleary's algorithms for narrowing intervals constrained by any relations p on I (IR) n . They also show how the generalized algorithm can be incorporated in CLP (R) [32] and CHIP [19] in such a way that the languages' logical semantics is preserved. <p> The basics of interval arithmetic, in both functional and relational forms, are presented. We then describe the syntax and semantics of the ICLP (R) language [38], which is an extension of CLP (R) with relational interval arithmetic. Most of the above materials are adopted from <ref> [38, 36, 39] </ref> except those otherwise specified. 2.1 Basics of Interval Arithmetic The manuscripts [45, 4] provide good introduction to interval analysis. Let IR be the set of real numbers and IF the set of floating-point numbers. <p> The definitions of the functions F i (mult + ) and F i (mult ) <ref> [39] </ref> are, F 1 (mult + )(I I 2 ; I I 3 ff I I " F 2 (mult + )(I I 1 ; I I 3 ff (I I " F 3 (mult + )(I I 1 ; I I 1 IR + ) I I F 1 (mult <p> The clause (G 0 G 1 ; ; G n ) is a conditional answer to the original goal. 11 Chapter 2 Overview of ICLP (R) 12 Chapter 3 Limitations of Interval Narrowing Interval narrowing with splitting is a common constraint solving technique used in interval constraint logic programming languages <ref> [39, 37, 9, 51] </ref>. Our experiments show that, in general, this technique is impractical in solving some classes of problems in terms of both computation time and storage. We try to solve a set of randomly generated systems of linear equations in several interval narrowing based systems.
Reference: [40] <author> O. Lhomme. </author> <title> Consistency techniques for numeric CSPs. </title> <booktitle> In Proceedings of the 13th International Joint Conference on Artificial Intelligence, </booktitle> <year> 1993. </year>
Reference-contexts: Sidebottom and Havens [54] design and implement a version of relational interval arithmetic in the constraint reasoning system Echidna [26]. Based on hierarchical consistency techniques [43], Echidna can handle unions of disjoint intervals. Lhomme <ref> [40] </ref> analyzes the complexity of consistency techniques for numeric CSP's and proposes partial consistency techniques, whose complexities can be tuned by adjusting the bound width of the resulting intervals.
Reference: [41] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: Introduction Current status of Prolog arithmetic suffers from two deficiencies. First, the system predicate "is" [56] is functional in nature. It is incompatible with the relational paradigm of logic programming. Second, real numbers are approximated by floating-point numbers. Roundoff errors induced by floating-point arithmetic destroy the soundness <ref> [41] </ref> of computation. The advent of constraint logic programming [31] presents a solution to the first problem but the implementation of CLP languages, such as CLP (R) [32], are mostly based on floating-point arithmetic. The second problem remains.
Reference: [42] <author> A.K. Mackworth. </author> <title> Consistency in networks of relations. </title> <journal> AI Journal, </journal> <volume> 8(1) </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference-contexts: Algebraic methods guarantee the soundness of numerical computation but they are time-consuming. Previous efforts in the sub-symbolic camp, such as BNR Prolog [51], employ interval methods [45] and belong to the family of consistency techniques <ref> [42] </ref>. The main idea is to narrow the set of possible values of the variables of arbitrary real constraints using approximations of arc-consistency [10]. We collectively call these techniques interval narrowing. <p> A network is stable if all the constraints inside are stable. A relaxation algorithm (Algorithm 2.1) reduces a network into a stable one. The relaxation algorithm is similar to the arc-consistency algorithm AC-3 <ref> [42] </ref>. The use of interval reduction to narrow interval constraints is not mandatory, but can be replaced by any appropriate domain restriction operator [36]. We refer to the relaxation algorithm with interval reduction operator as interval narrowing 2 . Interval narrowing sometimes fails to narrow intervals to useful widths.
Reference: [43] <author> A.K. Mackworth, J.A. </author> <title> Mulder, and W.S. Havens. Hierarchical arc consistency: Exploiting structured domains in constraint satisfaction problems. </title> <journal> Computational Intelligence, </journal> <volume> 1 </volume> <pages> 118-126, </pages> <year> 1985. </year>
Reference-contexts: Sidebottom and Havens [54] design and implement a version of relational interval arithmetic in the constraint reasoning system Echidna [26]. Based on hierarchical consistency techniques <ref> [43] </ref>, Echidna can handle unions of disjoint intervals. Lhomme [40] analyzes the complexity of consistency techniques for numeric CSP's and proposes partial consistency techniques, whose complexities can be tuned by adjusting the bound width of the resulting intervals.
Reference: [44] <author> S. Michaylov. </author> <title> Design and Implementation of Practical Constraint Logic Programming Systems. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, U.S.A, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: The generalized M derivation ends with a floundered goal if the last goal has one or more stable constraints. Floundered goal gives "incomplete" solutions and should be interpreted as conditional answers <ref> [44] </ref>. Suppose a non-empty goal G 1 ; ; G n is derived from G 0 and is a composition of all the substitutions. <p> In all other cases, the input constraint will be decomposed and then distributed to the linear and the non-linear constraint solver accordingly. CLP (R) differentiates between directly solvable constraints and hard constraints <ref> [44] </ref>. The former is solved by either Gaussian elimination (for linear equalities) or Simplex method (for linear inequalities) once they are collected, while the latter is delayed from consideration until they become linear. We do otherwise in CIAL. We do not delay any constraint. <p> The linear solver must be amenable to efficient incremental execution. The complexity of adding and solving a new constraint should be affected more by the form of the new constraint, rather than of the constraints already collected in the linear solver <ref> [44] </ref>. 2. Linear constraint solving in the linear solver must be substantially more efficient than interval narrowing. 3. Solutions given by the solver must be sound and accurate. The former criterion implies that the real solutions should always fall into the answer intervals. <p> To satisfy the latter, the widths of answer intervals should be less than a reasonable value, say 0:001. In this chapter, we present two proposals [15, 14] to implement such a linear constraint solver. The first, generalized interval Gaussian elimination, is a new combination of CLP (R) technology <ref> [44] </ref> and centered form [45]. This method always yields better results than naive interval Gaussian elimination. The second is a commonly-used iterative interval method, preconditioned interval Gauss-Seidel method [22, 33, 34, 35]. <p> We present only the components that differ from their counterparts in CLP (R) : detection of redundancy / inconsistency of newly added linear equation and the selection of non-parametric variables. All linear equations in the linear solver will be stored in parametric solved form <ref> [44] </ref> X = P n T r ) + c n+1 , where X is a non-parametric variable, T r 's are parametric variables, and c r 's and c n+1 are non-narrowable interval variables that we treat as constants. <p> We call [IjUjPjZ] the IUPZ matrix . Incremental calculation of the row reduction transformation is achieved by adapting the familiar incremental Gaussian elimination of CLP (R) <ref> [44] </ref>. Assume that we have a collection of r interval linear equalities of c variables with r &lt; c. <p> Echidna returns a wide answer at low precision and exits abruptly at higher precision. For efficiency reason, CLP (R) does not provide non-linear constraint solving. All non-linear arithmetic constraints are classified as hard constraints, which will be considered only when they become linear <ref> [44] </ref>. In this example, since no non-linear constraints can become linear, they are delayed indefinitely.
Reference: [45] <author> R.E. Moore. </author> <title> Interval Analysis. </title> <publisher> Prentice-Hall, </publisher> <year> 1966. </year>
Reference-contexts: The second problem remains. The languages CAL [2] and RISC-CLP (R) [30] use symbolic algebraic methods to refrain from floating-point operations. Algebraic methods guarantee the soundness of numerical computation but they are time-consuming. Previous efforts in the sub-symbolic camp, such as BNR Prolog [51], employ interval methods <ref> [45] </ref> and belong to the family of consistency techniques [42]. The main idea is to narrow the set of possible values of the variables of arbitrary real constraints using approximations of arc-consistency [10]. We collectively call these techniques interval narrowing. <p> We then describe the syntax and semantics of the ICLP (R) language [38], which is an extension of CLP (R) with relational interval arithmetic. Most of the above materials are adopted from [38, 36, 39] except those otherwise specified. 2.1 Basics of Interval Arithmetic The manuscripts <ref> [45, 4] </ref> provide good introduction to interval analysis. Let IR be the set of real numbers and IF the set of floating-point numbers. <p> When realizing interval computation on a computer, care must be taken since only a finite subset of real numbers can be exactly represented. Floating-point interval is not closed under the basic interval arithmetic operators, ; ; and ff. To preserve the inclusion property, rounded interval arithmetic <ref> [45] </ref>, which is a modification of exact interval arithmetic, is introduced. If an endpoint of an interval is not a member of IF , rounding is made. The rounded floating-point interval is always wider than the original one. <p> In this chapter, we present two proposals [15, 14] to implement such a linear constraint solver. The first, generalized interval Gaussian elimination, is a new combination of CLP (R) technology [44] and centered form <ref> [45] </ref>. This method always yields better results than naive interval Gaussian elimination. The second is a commonly-used iterative interval method, preconditioned interval Gauss-Seidel method [22, 33, 34, 35]. These two methods, as originally designed, operate in the batch mode: all the constraints are collected before solving takes place. <p> Those intervals will then be treated as different logical variables with associated bounds represented as generalized intervals, X i 2 Y I i a i + b i ; 2 b i a i ; 2 A generalized interval is in centered form <ref> [45] </ref> and usually cannot be exactly stored on a computer (i.e. the center point a i +b i 2 or the quasi-width b i a i 2 cannot be exactly represented as a floating-point). We modify equation (5.3) as follows. <p> u 2 u n C A ((t 1 t 2 : : : t n ) A I O A I 0 2 B @ u 2 u n C A ((t 1 t 2 : : : t n ) A I using the subdistributivity 8 and associativity 9 <ref> [45] </ref> properties of interval arithmetic. Unfortunately, none of (5.11), (5.12), and (5.13) hold under floating-point (interval) arithmetic since associativity and sub distributivity are no longer guaranteed.
Reference: [46] <author> J.Ll. Morris. </author> <title> Computational Methods in Elementary Numerical Analysis. </title> <publisher> John Wiley & Sons, </publisher> <year> 1983. </year>
Reference-contexts: Eventually, the original equation A ~ X = ~ b will be transformed into an upper triangular form, which can be solved by backward substitution, defined by X i = (b i j=i+1 With pivoting <ref> [46] </ref>, this simple algorithm works well in the real domain. If the elements of A and ~ b are intervals, the algorithm performs poorly due to the variable dependency problem.
Reference: [47] <author> A. Neumaier. </author> <title> Overestimation in linear interval equations. </title> <journal> SIAM Journal on Numerical Analysis, </journal> <volume> 24(1) </volume> <pages> 207-214, </pages> <month> February </month> <year> 1987. </year>
Reference-contexts: The diagonal variables are narrowed to be sharp. Overestimation Since preconditioning involves many interval multiplications, small errors will be introduced due to outward-rounding. A preconditioned system usually has slightly wider solutions than the original system and these additional pseudo-solutions are called overestimation <ref> [47] </ref>. Overestimation destroys the completeness of inconsistency detection in interval Gauss-Seidel method since an inconsistent system of constraints may become consistent after preconditioning. A formal analysis of overestimation requires such knowledge as mappings [48] and fixpoint theorems [47], and is beyond the scope of this thesis. <p> wider solutions than the original system and these additional pseudo-solutions are called overestimation <ref> [47] </ref>. Overestimation destroys the completeness of inconsistency detection in interval Gauss-Seidel method since an inconsistent system of constraints may become consistent after preconditioning. A formal analysis of overestimation requires such knowledge as mappings [48] and fixpoint theorems [47], and is beyond the scope of this thesis. Readers may refer to [47, 48] for details. We end this section by explaining how the simple system fX = Y; X = Y g in section 3.1 can be solved by the preconditioned Gauss-Seidel method without using splitting. <p> Overestimation destroys the completeness of inconsistency detection in interval Gauss-Seidel method since an inconsistent system of constraints may become consistent after preconditioning. A formal analysis of overestimation requires such knowledge as mappings [48] and fixpoint theorems [47], and is beyond the scope of this thesis. Readers may refer to <ref> [47, 48] </ref> for details. We end this section by explaining how the simple system fX = Y; X = Y g in section 3.1 can be solved by the preconditioned Gauss-Seidel method without using splitting.
Reference: [48] <author> A. Neumaier. </author> <title> Interval Methods for Systems of Equations. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: Its convergence depends highly on the initial bounds of variables and the form of interval constraints. A detailed analysis and discussion can be found in <ref> [48] </ref>. We give a geometrical interpretation to illustrate the convergence of interval narrowing on a simple linear system. Figure 3.1 shows interval narrowing on the following system fX = Y; X = Y g (3.1) with initial bounds X; Y 2 [50; 50]. <p> The decomposition procedure is shown in algorithm 4.1. To improve the efficiency of linear constraint solving, we pass the linear constraint T 0 =:= P j T k ) to the non-linear solver instead of the linear solver. Interval linear constraint solving usually involves variable elimination <ref> [20, 25, 48] </ref>, which is a time consuming symbolic algorithm. <p> Such a system can be solved efficiently by using some iterative methods. Preconditioned interval Gauss-Seidel method is an iterative method being widely-used in interval computation <ref> [48, 22, 33, 34] </ref>. <p> The interval Gauss-Seidel method terminates when all variables remain unchanged after an iteration or when the difference between the new and last computed value of each variable is less than a user-defined number. This sequential Gauss-Seidel method is also called the method of successive displacements [6]. Convergence Definition 5.2.1 <ref> [48] </ref>: A sequence of intervals converges iff both the lower and upper bounds converge. Definition 5.2.2 [48]: The hull of the solution set of a linear system is the set of tightest intervals that enclosing the solution of the linear system. <p> This sequential Gauss-Seidel method is also called the method of successive displacements [6]. Convergence Definition 5.2.1 <ref> [48] </ref>: A sequence of intervals converges iff both the lower and upper bounds converge. Definition 5.2.2 [48]: The hull of the solution set of a linear system is the set of tightest intervals that enclosing the solution of the linear system. In general, interval Gauss-Seidel method cannot be guaranteed to converge to the hull of the solution set of a linear system. <p> We should not expect that it will give sharper results than interval narrowing either since interval Gauss-Seidel method can be considered as "partial" interval narrowing. The following lemmas show these claims. Definition 5.2.3 <ref> [48] </ref>: The magnitude of an interval I I = [l; u] is defined as mag (I I ) = max (jlj; juj), while its mignitude is defined as mig (I I ) = min (jlj; juj), where jaj denotes the absolute value of real number a. <p> An interval matrix A I = (a I ij ) is said to be strictly diagonal dominant if, mig (a I n X mag (a I 34 Chapter 5 The Linear Solver Lemma 5.2.4 <ref> [48] </ref>: Interval Gauss-Seidel method is guaranteed to converge to the hull of the solution set 3 of a linear system if the coefficient matrix of the linear system is strictly diagonal dominant. <p> Overestimation destroys the completeness of inconsistency detection in interval Gauss-Seidel method since an inconsistent system of constraints may become consistent after preconditioning. A formal analysis of overestimation requires such knowledge as mappings <ref> [48] </ref> and fixpoint theorems [47], and is beyond the scope of this thesis. Readers may refer to [47, 48] for details. <p> Overestimation destroys the completeness of inconsistency detection in interval Gauss-Seidel method since an inconsistent system of constraints may become consistent after preconditioning. A formal analysis of overestimation requires such knowledge as mappings [48] and fixpoint theorems [47], and is beyond the scope of this thesis. Readers may refer to <ref> [47, 48] </ref> for details. We end this section by explaining how the simple system fX = Y; X = Y g in section 3.1 can be solved by the preconditioned Gauss-Seidel method without using splitting. <p> The order of complexity remains unchanged. 5.3.3 Others Besides the time and storage complexities, there exists some minor differences between the two constraint solving methods. The preconditioned interval Gauss-Seidel method and preconditioned interval Gaussian elimination give similar sharp results <ref> [48] </ref>. Since preconditioned interval Gaussian elimination always works better than generalized interval Gaussian elimination, we can expect that the incremental preconditioned interval Gauss-Seidel method also works better than generalized interval Gaussian elimination. Both of them are, however, incomplete in detecting inconsistency due to overestimations introduced by outward-rounding.
Reference: [49] <institution> Members of the Radix-Independent Floating-point Arithmetic Working Group. IEEE standard for radix-independent floating-point arithmetic. Technical Report ANSI/IEEE Std 854-1987, The Institute of Electrical and Electronics Engineers, </institution> <address> New York, USA, </address> <year> 1987. </year>
Reference-contexts: X i 2 Y I i a i + b i ); '( 2 a i + b i )); ('( 2 [1; 1]) [1; 1] (5.4) In equation (5.4), ' and are functions that round a real number to its nearest and right <ref> [49] </ref> adjacent floating-point number respectively. We can easily verify that the modified generalized interval obtained from equation (5.4) is a superset of that obtained from equation (5.3).
Reference: [50] <author> W. </author> <title> Older. Constraints in BNR Prolog. </title> <type> Technical Report Draft 01, </type> <institution> Software Engineering Centre, Bell-Northern Research, </institution> <address> Ottawa, Canada, </address> <year> 1993. </year>
Reference-contexts: We give a geometrical interpretation to illustrate the convergence of interval narrowing on a simple linear system. Figure 3.1 shows interval narrowing on the following system fX = Y; X = Y g (3.1) with initial bounds X; Y 2 <ref> [50; 50] </ref>. Recall that interval narrowing on a constraint (p; &lt; I I 1 ; : : :; I I can be defined as the projection of the intersection of the Cartesian product of I I i and the relation p. <p> CLP (BNR) cannot solve any set of test data with interval narrowing and splitting alone. We have to further apply two predicates absolve/1 and presolve/1, which are designed for solving single non-point solutions and complex problems <ref> [50] </ref>. Two sets of test data are solved. When n = 5, ICL and BNR Prolog can solve only one of the three sets of test data in about 3.5 minutes and 2.6 hours respectively. <p> The three prototypes use interval narrowing with splitting in solving inequality and non-linear constraints. In this chapter, we compare our three CIAL prototypes with BNR Prolog v3.1.0 [7, 52], CLP (BNR) (or BNR Prolog v4.2.3) <ref> [50, 9] </ref>, Echidna Version 0.947 beta [55, 54], ICL [37], and CLP (R) Version 1.2 [28, 32] over seven numerical examples of various types: the well-known mortgage program [28] which comes with the CLP (R) distribution, a simple system of simultaneous equations in two variables, analysis of a simple DC circuit, <p> Third, built-in predicates in CIAL are limited. To apply CIAL on real-life problems (e.g. scheduling), more relations, such as max/2, min/2, sin/1, asin/1 <ref> [50] </ref>, should be provided. To establish the practicality of our approach, we need to try CIAL on more real-life applications, e.g. job shop scheduling, process planning, assembly line balancing, temporal and spatial reasoning, multiagent planning, finite element modeling, circuit design, etc. 58
Reference: [51] <author> W. Older and A. Vellino. </author> <title> Extending Prolog with constraint arithmetic on real intervals. </title> <booktitle> In Proceedings of the Canadian Conference on Computer & Electrical Engineering, </booktitle> <address> Ottawa, Canada, </address> <year> 1990. </year>
Reference-contexts: The second problem remains. The languages CAL [2] and RISC-CLP (R) [30] use symbolic algebraic methods to refrain from floating-point operations. Algebraic methods guarantee the soundness of numerical computation but they are time-consuming. Previous efforts in the sub-symbolic camp, such as BNR Prolog <ref> [51] </ref>, employ interval methods [45] and belong to the family of consistency techniques [42]. The main idea is to narrow the set of possible values of the variables of arbitrary real constraints using approximations of arc-consistency [10]. We collectively call these techniques interval narrowing. <p> The main idea is to narrow the set of possible values of the variables of arbitrary real constraints using approximations of arc-consistency [10]. We collectively call these techniques interval narrowing. Interval narrowing has been shown to be applicable to critical path scheduling <ref> [51] </ref>, X-ray diffraction crystallography [53], boolean constraint solving [9], and disjunctive constraint solving [9, 54]. However, interval narrowing is deficient in handling systems of linear constraints over real domain. <p> He describes distinct algorithms, one for each kind of constraint over intervals, that narrow intervals associated with a constraint by removing values that do not satisfy the constraint. A constraint relaxation cycle is needed to coordinate the execution of the narrowing algorithms for a network of constraints. BNR-Prolog <ref> [51] </ref> and its sequel CLP (BNR) [9] provide relational interval arithmetic in a way that is loosely based on Cleary's pre-publication idea, differing somewhat in particulars. Sidebottom and Havens [54] design and implement a version of relational interval arithmetic in the constraint reasoning system Echidna [26]. <p> The clause (G 0 G 1 ; ; G n ) is a conditional answer to the original goal. 11 Chapter 2 Overview of ICLP (R) 12 Chapter 3 Limitations of Interval Narrowing Interval narrowing with splitting is a common constraint solving technique used in interval constraint logic programming languages <ref> [39, 37, 9, 51] </ref>. Our experiments show that, in general, this technique is impractical in solving some classes of problems in terms of both computation time and storage. We try to solve a set of randomly generated systems of linear equations in several interval narrowing based systems. <p> The efficiency of interval narrowing with splitting depends on its interval subdividing method and search strategy. To use some ad-hoc subdividing methods and search strategies, some special constraints may be solved more efficiently <ref> [51] </ref>. Interval splitting is impractical for 3 main reasons: * Interval splitting is implemented using a Prolog backtracking-like mechanism. A choice point is created for each splitting. In the worst case, no partition can be rejected in each splitting and all the choice points are accumulated.
Reference: [52] <author> W. Older and A. Vellino. </author> <title> Constraint arithmetic on real intervals. </title> <editor> In A. Colmerauer and F. Benhamou, editors, </editor> <booktitle> Constraint Logic Programming: Selected Research. </booktitle> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: We solve a set of systems of linear constraints, A ~ X = ~ b; where A = (a ij ); ~ X = (X i ); ~ b = (b i ); a ij 6= 0; b i 6= 0; and X i 2 [10000; 10000] on BNR Prolog <ref> [52] </ref>, CLP (BNR) [9], Echidna [54] and ICL [37] with splitting. All coefficients a ij and b i are randomly generated non-zero floating-point numbers. The results for each problem size n are the average of three different sets of test data and are summarized in table 3.1 and table 3.2. <p> We further embed the incremental preconditioning algorithm in CIAL 1.1 (Beta) to improve its efficiency. The three prototypes use interval narrowing with splitting in solving inequality and non-linear constraints. In this chapter, we compare our three CIAL prototypes with BNR Prolog v3.1.0 <ref> [7, 52] </ref>, CLP (BNR) (or BNR Prolog v4.2.3) [50, 9], Echidna Version 0.947 beta [55, 54], ICL [37], and CLP (R) Version 1.2 [28, 32] over seven numerical examples of various types: the well-known mortgage program [28] which comes with the CLP (R) distribution, a simple system of simultaneous equations in
Reference: [53] <author> W.J. </author> <title> Older. The application of relational arithmetic to X-ray diffraction crystallography. </title> <type> Technical Report 89001, </type> <institution> Software Engineering Centre, Bell-Northern Research, </institution> <address> Ottawa, Canada, </address> <year> 1989. </year>
Reference-contexts: The main idea is to narrow the set of possible values of the variables of arbitrary real constraints using approximations of arc-consistency [10]. We collectively call these techniques interval narrowing. Interval narrowing has been shown to be applicable to critical path scheduling [51], X-ray diffraction crystallography <ref> [53] </ref>, boolean constraint solving [9], and disjunctive constraint solving [9, 54]. However, interval narrowing is deficient in handling systems of linear constraints over real domain.
Reference: [54] <author> G. Sidebottom and W.S. Havens. </author> <title> Hierarchical arc consistency for disjoint real intervals in constraint logic programming. </title> <journal> Computational Intelligence, </journal> <volume> 8(4) </volume> <pages> 601-623, </pages> <year> 1992. </year>
Reference-contexts: We collectively call these techniques interval narrowing. Interval narrowing has been shown to be applicable to critical path scheduling [51], X-ray diffraction crystallography [53], boolean constraint solving [9], and disjunctive constraint solving <ref> [9, 54] </ref>. However, interval narrowing is deficient in handling systems of linear constraints over real domain. <p> A constraint relaxation cycle is needed to coordinate the execution of the narrowing algorithms for a network of constraints. BNR-Prolog [51] and its sequel CLP (BNR) [9] provide relational interval arithmetic in a way that is loosely based on Cleary's pre-publication idea, differing somewhat in particulars. Sidebottom and Havens <ref> [54] </ref> design and implement a version of relational interval arithmetic in the constraint reasoning system Echidna [26]. Based on hierarchical consistency techniques [43], Echidna can handle unions of disjoint intervals. <p> systems of linear constraints, A ~ X = ~ b; where A = (a ij ); ~ X = (X i ); ~ b = (b i ); a ij 6= 0; b i 6= 0; and X i 2 [10000; 10000] on BNR Prolog [52], CLP (BNR) [9], Echidna <ref> [54] </ref> and ICL [37] with splitting. All coefficients a ij and b i are randomly generated non-zero floating-point numbers. The results for each problem size n are the average of three different sets of test data and are summarized in table 3.1 and table 3.2. <p> The three prototypes use interval narrowing with splitting in solving inequality and non-linear constraints. In this chapter, we compare our three CIAL prototypes with BNR Prolog v3.1.0 [7, 52], CLP (BNR) (or BNR Prolog v4.2.3) [50, 9], Echidna Version 0.947 beta <ref> [55, 54] </ref>, ICL [37], and CLP (R) Version 1.2 [28, 32] over seven numerical examples of various types: the well-known mortgage program [28] which comes with the CLP (R) distribution, a simple system of simultaneous equations in two variables, analysis of a simple DC circuit, inconsistent simultaneous equations, the ball collision
Reference: [55] <author> S. Sidebottom, W. Havens, and S. Kindersley. </author> <title> Echidna Constraint Reasoning System (Version 1): Programming Manual. </title> <institution> Expert Systems Laboratory, Simon Fraser University, British Columbia, </institution> <address> Canada, 2.0 edition, </address> <year> 1992. </year>
Reference-contexts: The precision of the answers are set to 10 decimal places for CLP (BNR) and ICL, 5 decimal places for BNR Prolog, and the highest precision (precision (30) <ref> [55] </ref>) for Echidna. Table 3.1 gives the computation time for problem size ranging from 1 to 6. The computation efficiency of these systems decreases rapidly as n grows. When n = 4, Echidna consumes more than 100MB memory and then halts abruptly. <p> The three prototypes use interval narrowing with splitting in solving inequality and non-linear constraints. In this chapter, we compare our three CIAL prototypes with BNR Prolog v3.1.0 [7, 52], CLP (BNR) (or BNR Prolog v4.2.3) [50, 9], Echidna Version 0.947 beta <ref> [55, 54] </ref>, ICL [37], and CLP (R) Version 1.2 [28, 32] over seven numerical examples of various types: the well-known mortgage program [28] which comes with the CLP (R) distribution, a simple system of simultaneous equations in two variables, analysis of a simple DC circuit, inconsistent simultaneous equations, the ball collision
Reference: [56] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <address> second edition, </address> <year> 1994. </year> <month> 61 </month>
Reference-contexts: Introduction Current status of Prolog arithmetic suffers from two deficiencies. First, the system predicate "is" <ref> [56] </ref> is functional in nature. It is incompatible with the relational paradigm of logic programming. Second, real numbers are approximated by floating-point numbers. Roundoff errors induced by floating-point arithmetic destroy the soundness [41] of computation.
Reference: [57] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> The MIT Press, </publisher> <address> London, Eng--land, </address> <year> 1989. </year>
Reference-contexts: However, interval narrowing is deficient in handling systems of linear constraints over real domain. For example, interval narrowing fails to solve such simple systems as "fX + Y = 5; X Y = 6g." Cleary [16] proposes a form of case analysis technique <ref> [57] </ref>, domain splitting , as a remedy. Domain splitting partitions an interval into two, visits one, and visits the other upon backtracking. This backtracking tree search is expensive to perform. Furthermore, interval narrowing may sometimes fail or take a long time to detect inconsistency of linear systems. <p> Semantically, an interval variable is an ordinary logical variable. We distinguish interval variables from logical variables purely for implementation efficiency. Resembling domain variables in finite-domain languages <ref> [57] </ref>, e.g. CHIP [1, 19], an interval variable is represented as a variable with an associated interval. Its heap representation is shown in figure 4.2, where ITAG is a new tag introduced for interval variables. Each interval variable in CIAL keeps a list of constraints in which the variable appears.
Reference: [58] <author> J.H. Wilkinson. </author> <title> The Algebraic Eigenvalue Problem. </title> <publisher> Oxford University Press, </publisher> <year> 1965. </year> <month> 62 </month>
Reference-contexts: There are several variants of Gaussian elimination procedure for solving linear equalities <ref> [58] </ref>. An interval version of any of them can be obtained by simply replacing each ordinary arithmetic operator by the corresponding interval arithmetic counterpart. Answers generated using this naive approach, however, will not be as sharp as possible, in general, due to outward rounding and variable dependency problem.
References-found: 58

