URL: ftp://ftp.cs.wisc.edu/wwt/pldi97_paths.ps
Refering-URL: http://www.cs.wisc.edu/~larus/Talks/path_talk/tsld042.htm
Root-URL: 
Email: ammons@cs.wisc.edu tball@research.bell-labs.com larus@cs.wisc.edu  
Title: Exploiting Hardware Performance Counters with Flow and Context Sensitive Profiling  
Author: Glenn Ammons Thomas Ball James R. Larus 
Affiliation: Dept. of Computer Sciences Bell Laboratories Dept. of Computer Sciences University of Wisconsin-Madison Lucent Technologies University of Wisconsin-Madison  
Abstract: A program profile attributes run-time costs to portions of a program's execution. Most profiling systems suffer from two major deficiencies: first, they only apportion simple metrics, such as execution frequency or elapsed time to static, syntactic units, such as procedures or statements; second, they aggressively reduce the volume of information collected and reported, although aggregation can hide striking differences in program behavior. This paper addresses both concerns by exploiting the hardware counters available in most modern processors and by incorporating two concepts from data flow analysis-flow and context sensitivity-to report more context for measurements. This paper extends our previous work on efficient path profiling to flow sensitive profiling, which associates hardware performance metrics with a path through a procedure. In addition, it describes a data structure, the calling context tree, that efficiently captures calling contexts for procedure-level measurements. Our measurements show that the SPEC95 benchmarks execute a small number (3-28) of hot paths that account for 9-98% of their L1 data cache misses. Moreover, these hot paths are concentrated in a few routines, which have complex dynamic behavior. 
Abstract-found: 1
Intro-found: 1
Reference: [Bal94] <author> Thomas Ball. </author> <title> Efficiently counting program events with support for on-line queries. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1399-1410, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: At the EXIT vertex, r indexes an array to update a count (count [r]++) or serves as a hash key into a hash table of counters. For details on how to greatly reduce the number of points at which r must be incremented, see <ref> [BL96, Bal94] </ref>. 2.2 Path Profiling of Cyclic CFGs Cycles in a CFG introduce an unbounded number of paths. Every cycle contains a backedge, as identified by a depth-first search from EN T RY .
Reference: [Ben96] <author> Jim Bennett (PureAtria, Inc.). </author> <type> Personal communication, </type> <month> November </month> <year> 1996. </year>
Reference-contexts: This results in one level of context sensitive profiling. Our work generalizes this to complete contexts. Pure Atria's commercial profiling system Quantify uses a representation similar to a CCT to record instruction counts in procedures and time spent in system calls <ref> [Ben96] </ref>. Details and overheads of this system are unpublished. This work goes further by incorporating path profiling and hardware performance metrics. 7.2 Context Sensitive Measurement Mech anisms Call path profiling is another approach to context sensitive profiling [Hal92, HG93]. It, however, differs substantially in its implementation and overhead.
Reference: [BGS97] <author> R. Bodik, R. Gupta, and M. L. Soffa. </author> <title> Interprocedural conditional branch elimination. </title> <booktitle> In Proceedings of the SIG-PLAN '97 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: The program paths identified by profiling have close ties to compilation. Many compiler optimizations attempt to reduce the number of instructions executed on paths through a procedure <ref> [MR81, MW95, BGS97] </ref>. In order to ensure profitability, these optimizations must not increase the total instructions executed along all paths through a procedure or, more strongly, over any path through a procedure.
Reference: [BL94] <author> T. Ball and J. R. Larus. </author> <title> Optimally profiling and tracing programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 1319-1360, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: For example, Sun's UltraSPARC processors [Sun96] count events such as instructions executed, cycles executed, instruction stalls of various types, and cache misses (collectively, hardware performance metrics). Existing profiling systems do not exploit these counters and are limited to a few, simple metrics, such as instruction execution frequency <ref> [BL94] </ref>, time in a procedure [GKM83, Sof93], or cache misses [LW94]. Our second extension increases the usefulness of program profiles by reporting a richer context for measurements, by applying two concepts from static program analysis|flow and context sensitivity. <p> Labeling a metric with its calling context can separate measurements from different invocations of a procedure. Without a calling context, profiling tools can only approximate a program's context-dependent behavior. For example, profiling systems such as gprof [GKM83] or qpt <ref> [BL94] </ref> apportion the cost of a pro-cedure to its callers in proportion to the relative frequency of calls between each pair of procedures, although this calculation can produce misleading results [PF88]. Moreover, context is essential to elucidate hardware measurements. <p> metrics are for the entire run, or the last input file in the case of programs, such as gcc, with multiple input files. 6.1 Run-Time Overhead The overhead of intraprocedural path profiling is low (an average of 32% overhead on the SPEC95 benchmarks, roughly twice that of efficient edge profiling <ref> [BL94] </ref>). Details are reported elsewhere [BL96]. The extensions described in this paper increase the run-time cost of profiling, but the overheads remain reasonable. Table 1 reports the cost of three forms of profiling. Recording hardware metrics along in-traprocedural paths (Flow and HW) incurs an average overhead of 80%. <p> Tools such as gprof [GKM83] and qpt <ref> [BL94] </ref> use counts of the number of times that a caller invokes a callee to approximate the time in a procedure attributable to different callers. Because these profiling tools do not label procedure timings by context, information is lost that cannot be accurately recovered.
Reference: [BL96] <author> T. Ball and J. R. Larus. </author> <title> Efficient path profiling. </title> <booktitle> In Proceedings of MICRO 96, </booktitle> <pages> pages 46-57, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: Our contributions are three-fold: * Flow sensitive profiling extends our technique of path profiling, which previously recorded only the execution frequency of paths in a procedure's control flow graph <ref> [BL96] </ref>. This paper generalizes path profiling by associating hardware performance metrics with paths. * Context sensitive profiling provides a calling context for flow sensitive (or other) procedure-level profiles. <p> Section 6 presents experimental measurements that show that the overhead and perturbation of this technique are reasonable, and examines the hot path phenomenon. Section 7 describes related work. 2 Efficient Path Profiling This section summarizes our previous work on intrapro-cedural path profiling <ref> [BL96] </ref>, which this work extends. Given a procedure's control flow graph (CFG), our path profiling algorithm: * Assigns an integer label to every edge in an acyclic CFG such that the sum of integers is unique along each unique path from the entry to exit of a procedure. <p> Each path has a unique path sum, as shown in Figure 1 (b). Figure 1 (c) shows a simple instrumentation scheme for tracking the path sum in a register r, while Figure 1 (d) shows an optimized instrumentation scheme (see <ref> [BL96] </ref> for details). To instrument a CFG for efficient path profiling, it must have a unique entry vertex EN T RY from which all vertices are reachable and a unique exit vertex EXIT that is reachable from all vertices. <p> At the EXIT vertex, r indexes an array to update a count (count [r]++) or serves as a hash key into a hash table of counters. For details on how to greatly reduce the number of points at which r must be incremented, see <ref> [BL96, Bal94] </ref>. 2.2 Path Profiling of Cyclic CFGs Cycles in a CFG introduce an unbounded number of paths. Every cycle contains a backedge, as identified by a depth-first search from EN T RY . <p> Details are reported elsewhere <ref> [BL96] </ref>. The extensions described in this paper increase the run-time cost of profiling, but the overheads remain reasonable. Table 1 reports the cost of three forms of profiling. Recording hardware metrics along in-traprocedural paths (Flow and HW) incurs an average overhead of 80%.
Reference: [CMH91] <author> P. P. Chang, S. A. Mahlke, and W-M. W. Hwu. </author> <title> Using profile information to assist classic code optimizations. </title> <journal> Software-Practice and Experience, </journal> <volume> 21(12) </volume> <pages> 1301-1321, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: S. Government. To appear at the 1997 ACM SIGPLAN Conference on Programming Language Design and Implementation, Las Vegas, Nevada, 15-18 June, 1997. parts of a program that offer the largest potential for improvement <ref> [CMH91] </ref>. Profiles also provide a compact summary of a program's execution, which forms the basis for program coverage testing and other software engineering tasks [WHH80, RBDL97].
Reference: [GKM83] <author> S. L. Graham, P. B. Kessler, and M. K. McKusick. </author> <title> An execution profiler for modular programs. </title> <journal> Software-Practice and Experience, </journal> <volume> 13 </volume> <pages> 671-685, </pages> <year> 1983. </year>
Reference-contexts: Existing profiling systems do not exploit these counters and are limited to a few, simple metrics, such as instruction execution frequency [BL94], time in a procedure <ref> [GKM83, Sof93] </ref>, or cache misses [LW94]. Our second extension increases the usefulness of program profiles by reporting a richer context for measurements, by applying two concepts from static program analysis|flow and context sensitivity. A flow sensitive profile associates a performance metric with an acyclic path through a procedure. <p> Labeling a metric with its calling context can separate measurements from different invocations of a procedure. Without a calling context, profiling tools can only approximate a program's context-dependent behavior. For example, profiling systems such as gprof <ref> [GKM83] </ref> or qpt [BL94] apportion the cost of a pro-cedure to its callers in proportion to the relative frequency of calls between each pair of procedures, although this calculation can produce misleading results [PF88]. Moreover, context is essential to elucidate hardware measurements. <p> Path profiling offers a low-cost way to provide insight into a program's dynamic behavior. 7 Related Work This section describes previous work related to flow and context sensitive profiling. 7.1 Call-related Performance Measure ment Many profiling tools approximate context sensitive profiling information with heuristics. Tools such as gprof <ref> [GKM83] </ref> and qpt [BL94] use counts of the number of times that a caller invokes a callee to approximate the time in a procedure attributable to different callers. Because these profiling tools do not label procedure timings by context, information is lost that cannot be accurately recovered.
Reference: [Hal92] <author> R. J. Hall. </author> <title> Call path profiling. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering (ICSE92), </booktitle> <pages> pages 296-306, </pages> <year> 1992. </year>
Reference-contexts: Details and overheads of this system are unpublished. This work goes further by incorporating path profiling and hardware performance metrics. 7.2 Context Sensitive Measurement Mech anisms Call path profiling is another approach to context sensitive profiling <ref> [Hal92, HG93] </ref>. It, however, differs substantially in its implementation and overhead. Hall's scheme re-instruments and re-executes programs to collect call path profiling of LISP programs in a top-down manner [Hal92]. Initially, the call-sites in the "main" function are instrumented to record the time spent in each callee. <p> It, however, differs substantially in its implementation and overhead. Hall's scheme re-instruments and re-executes programs to collect call path profiling of LISP programs in a top-down manner <ref> [Hal92] </ref>. Initially, the call-sites in the "main" function are instrumented to record the time spent in each callee. Once measurements have been made, the system re-instruments the program at the next deepest level of the call graph and re-executes it to examine particular behavior of interest, and so on.
Reference: [HG93] <author> R. J. Hall and A. J. Goldberg. </author> <title> Call path profiling of monotonic program resources in UNIX. </title> <booktitle> In Proceedings of the USENIX Summer 1993 Technical Conference, </booktitle> <pages> pages 1-14., </pages> <address> Cincinnati, OH, </address> <year> 1993. </year>
Reference-contexts: Details and overheads of this system are unpublished. This work goes further by incorporating path profiling and hardware performance metrics. 7.2 Context Sensitive Measurement Mech anisms Call path profiling is another approach to context sensitive profiling <ref> [Hal92, HG93] </ref>. It, however, differs substantially in its implementation and overhead. Hall's scheme re-instruments and re-executes programs to collect call path profiling of LISP programs in a top-down manner [Hal92]. Initially, the call-sites in the "main" function are instrumented to record the time spent in each callee. <p> By contrast, our technique requires only one instrumentation and execution phase to record complete information for all calling contexts. Goldberg and Hall used process sampling to record context sensitive metrics for Unix processes <ref> [HG93] </ref>. By interrupting a process and tracing the call stack, they constructed a context for the performance metric. Beyond the inaccuracy introduced by sampling, their approach has two disadvantages. Every sample requires walking the call stack to establish the context.
Reference: [JSB97] <author> D. F. Jerding, J. T. Stasko, and T. Ball. </author> <title> Visualizing interactions in program executions. </title> <booktitle> In Proceedings of 1997 International Conference on Software Engineering (to appear), </booktitle> <month> May </month> <year> 1997. </year>
Reference-contexts: CCTs, because they only need to capture a single execution behavior, rather than all possible behaviors, are a practical data structure. Jerding, Stasko and Ball describe another approach for compacting dynamic call trees that proceeds in a bottom-up fashion <ref> [JSB97] </ref>. Using hash consing, they create a dag structure in which identical subtrees from the call tree are represented exactly once in the dag.
Reference: [Knu71] <author> D. E. Knuth. </author> <title> An empirical study of FORTRAN programs. </title> <journal> Software-Practice and Experience, </journal> <volume> 1(2) </volume> <pages> 105-133, </pages> <month> June </month> <year> 1971. </year>
Reference-contexts: 1 Introduction A program profile attributes run-time costs to portions of a program's execution. Profiles can direct a programmer's attention to algorithmic bottlenecks or inefficient code <ref> [Knu71] </ref>, and can focus compiler optimizations on the fl This research supported by: Wright Laboratory Avionics Directorate, Air Force Material Command, USAF, under grant #F33615-94-1-1525 and ARPA order no. B550; NSF NYI Award CCR-9357779, with support from Hewlett Packard and Sun Microsystems; and NSF Grant MIP-9625558. The U.S.
Reference: [LS95] <author> James R. Larus and Eric Schnarr. EEL: </author> <title> Machine-independent executable editing. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 291-300, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: This combination provides an efficient approximation to interprocedural path profiling. 1.2 Measurements Using the Executable Editing Library (EEL) <ref> [LS95] </ref>, we built a tool called PP (Path Profiler) that instruments program executables to record flow sensitive and context sensitive profiles. PP records not only instruction frequency, but also fine-grain timing and event count information by accessing the hardware counters on UltraSPARC processors. <p> PP is built using EEL (Exe cutable Editing Library), which is a C++ library that hides much of the complexity and system-specific detail of editing executables <ref> [LS95] </ref>.
Reference: [LW94] <author> Alvin R. Lebeck and David A. Wood. </author> <title> Cache profiling and the spec benchmarks: A case study. </title> <journal> IEEE Computer, </journal> <volume> 27(10) </volume> <pages> 15-26, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Existing profiling systems do not exploit these counters and are limited to a few, simple metrics, such as instruction execution frequency [BL94], time in a procedure [GKM83, Sof93], or cache misses <ref> [LW94] </ref>. Our second extension increases the usefulness of program profiles by reporting a richer context for measurements, by applying two concepts from static program analysis|flow and context sensitivity. A flow sensitive profile associates a performance metric with an acyclic path through a procedure.
Reference: [MR81] <author> E. Morel and C. </author> <title> Renvoise. Interprocedural elimination of partial redundancies. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: Theory and Applications. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: The program paths identified by profiling have close ties to compilation. Many compiler optimizations attempt to reduce the number of instructions executed on paths through a procedure <ref> [MR81, MW95, BGS97] </ref>. In order to ensure profitability, these optimizations must not increase the total instructions executed along all paths through a procedure or, more strongly, over any path through a procedure.
Reference: [MRW92] <author> Allen D. Malony, Daniel A. Reed, and Harry A. G. Wi-jshoff. </author> <title> Performance measurement instrusion and perturbation analysis. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 3(4) </volume> <pages> 433-450, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Moreover, instrumentation that executes at the beginning or end of a path, outside the measured interval, can also cause cache conflicts that increase a program's cache misses. We do not have a general solution for this difficult problem, which has been explored by others <ref> [MRW92] </ref>. Section 6 contains measurements of the perturbation. 3.3 Overflow The UltraSPARC's hardware counters are only 32 bits wide. A metric, such as cycle counts, can cause a counter to wrap in a few seconds.
Reference: [MW95] <author> F. Mueller and D. B. Whalley. </author> <title> Avoiding conditional branches by code replication. </title> <booktitle> In Proceedings of the SIG-PLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 56-66, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The program paths identified by profiling have close ties to compilation. Many compiler optimizations attempt to reduce the number of instructions executed on paths through a procedure <ref> [MR81, MW95, BGS97] </ref>. In order to ensure profitability, these optimizations must not increase the total instructions executed along all paths through a procedure or, more strongly, over any path through a procedure.
Reference: [PF88] <author> C. Ponder and R. J. Fateman. </author> <title> Inaccuracies in program profilers. </title> <journal> Software-Practice and Experience, </journal> <volume> 18 </volume> <pages> 459-467, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: For example, profiling systems such as gprof [GKM83] or qpt [BL94] apportion the cost of a pro-cedure to its callers in proportion to the relative frequency of calls between each pair of procedures, although this calculation can produce misleading results <ref> [PF88] </ref>. Moreover, context is essential to elucidate hardware measurements. Many hardware events (such as instruction stalls and cache misses) are affected by execution relationships among program components. Performance tools that associate a metric with an isolated component of a program overlook these relationships. <p> Furthermore, the tools also make naive assumptions when propagating timing information in the presence of recursion, which results in further inaccuracy. Abnormalities that result from approximating context sensitive information are well known <ref> [PF88] </ref>. Ponder and Fateman propose several instrumentation schemes to solve these problems. Their preferred solution associates procedure timing with a (caller, callee) pair rather than with a single procedure. This results in one level of context sensitive profiling. Our work generalizes this to complete contexts.
Reference: [RBDL97] <author> T. Reps, T. Ball, M. Das, and J. R. Larus. </author> <title> The use of program profiling for software maintenance with applications to the year 2000 problem. </title> <type> In Technical Report 1335, </type> <institution> Computer Sciences Department, University of Wiscon-sin, Madison, WI, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: Profiles also provide a compact summary of a program's execution, which forms the basis for program coverage testing and other software engineering tasks <ref> [WHH80, RBDL97] </ref>. Although program profiling is widely used, most tools report only rudimentary profiles that apportion execution frequency or time to static, syntactic units, such as procedures or statements. This paper extends profiling techniques in two new directions.
Reference: [Sof93] <institution> Pure Software. </institution> <note> Quantify User's Guide. </note> <year> 1993. </year>
Reference-contexts: Existing profiling systems do not exploit these counters and are limited to a few, simple metrics, such as instruction execution frequency [BL94], time in a procedure <ref> [GKM83, Sof93] </ref>, or cache misses [LW94]. Our second extension increases the usefulness of program profiles by reporting a richer context for measurements, by applying two concepts from static program analysis|flow and context sensitivity. A flow sensitive profile associates a performance metric with an acyclic path through a procedure.
Reference: [SP81] <author> Micha Sharir and Amir Pnueli. </author> <title> Two approaches to inter-procedural data flow analysis. </title> <editor> In Steven S. Muchnick and Neil D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 189-233. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Also, the size of their data structure is unbounded, since each sample is recorded along with its call stack. 7.3 Calling Context Trees CCTs are related to Sharir and Pnueli's call strings, which are sequences of calls used to label values for interprocedural flow analysis <ref> [SP81] </ref>. In interprocedural analysis, the need to bound the size of the representation of recursive programs 11 and to define a distributive meet operator, made call strings impractical. CCTs, because they only need to capture a single execution behavior, rather than all possible behaviors, are a practical data structure.
Reference: [Sun96] <institution> Sun Microelectronics. </institution> <note> UltraSPARC User's Manual, </note> <year> 1996. </year>
Reference-contexts: These processors have complex microarchitectures that dynamically schedule instructions. These machines are difficult to understand and model accurately. Fortunately, these processors also contain readily accessible hardware counters that record a wide range of events. For example, Sun's UltraSPARC processors <ref> [Sun96] </ref> count events such as instructions executed, cycles executed, instruction stalls of various types, and cache misses (collectively, hardware performance metrics). <p> These hardware metrics may record execution time, cache misses, instruction stalls, etc. Although this discussion focuses on the UltraSPARC's hardware counters <ref> [Sun96] </ref>, similar considerations apply to other processors. 3.1 Tracking Metrics Along a Path Associating a hardware metric with a path is straightforward, as shown in Figure 3. At the beginning of a path, set the hardware counter to zero. <p> EEL provides abstractions that allow a tool to analyze and modify binary executables without being concerned with particular instruction sets, executable file formats, or the consequences of deleting existing code and adding foreign code (i.e., instrumentation). 5.1 UltraSPARC Hardware Counters The Sun UltraSPARC processors <ref> [Sun96] </ref> implement sixteen hardware counters, which record events such as instructions executed, cycles executed, instruction stalls, and cache misses. The architecture also provides two program-accessible registers that can be mapped to two hardware counters, so a program can quickly read or set a counter, without operating system intervention.
Reference: [WHH80] <author> M. R. Woodward, D. Hedley, and M. A. Hennell. </author> <title> Experience with path analysis and testing of programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 6(3) </volume> <pages> 278-286, </pages> <month> May </month> <year> 1980. </year> <month> 12 </month>
Reference-contexts: Profiles also provide a compact summary of a program's execution, which forms the basis for program coverage testing and other software engineering tasks <ref> [WHH80, RBDL97] </ref>. Although program profiling is widely used, most tools report only rudimentary profiles that apportion execution frequency or time to static, syntactic units, such as procedures or statements. This paper extends profiling techniques in two new directions.
References-found: 22

