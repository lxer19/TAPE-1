URL: http://www.csd.uu.se/~jakob/publications/erts98.ps
Refering-URL: http://www.csd.uu.se/~jakob/publications.html
Root-URL: 
Phone: Fax: +46-(0)18-550225 2  
Title: Facilitating Worst-Case Execution Times Analysis for Optimized Code  
Author: Jakob Engblom Andreas Ermedahl Peter Altenbernd 
Address: Uppsala University, P.O. Box 325, S-751 05 Uppsala, Sweden,  peter@c-lab.de, C-LAB, D-33094 Paderborn, Germany  
Affiliation: Department of Computer Systems (DoCS),  
Note: 1 fjakob,ebbeg@docs.uu.se,  
Abstract: In this paper we present co-transformation, a novel approach to the mapping of execution information from the source code of a program to the object code for the purpose of worst-case execution time (WCET) analysis. Our approach is designed to handle the problems introduced by optimizing compilers, i.e. that the structure of the object code is very different from the structure of the source code. The co-transformer allows us to keep track of how different compiler transformations, including optimizations, influence the execution time of a program. This allows us to statically calculate the execution time of a program at the object code level, using information about the program execution obtained at the source code level. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.-R. Adl-Tabatabai. </author> <title> Source-Level Debugging of Global Optimized Code. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: In contrast, the co-transformation approach allows us to maintain the full set of information we need for WCET analysis. In the debugging field itself <ref> [1, 7] </ref>, there is a similar need to track what happens to a program when it is compiled. However, the information needed by a debugger only concerns the static aspects of a program; i.e. the mapping of source statements to object code instructions in order to handle breakpoints.
Reference: [2] <author> P. Altenbernd. </author> <title> On the False Path Problem in Hard Real-Time Programs. </title> <booktitle> In Proceedings 8th Euromicro Workshop on Real Time Systems, </booktitle> <year> 1996. </year>
Reference-contexts: The purpose of the co-transformer is to transform program execution information. Such information is usually provided manually (using annotations), but there is some promising research on the automatic analysis of programs to obtain loop bounds [9], and discover infeasible paths <ref> [2, 14] </ref>. On the output end of the co-transformer, we need to perform calculations of execution times given information about the program flow and times for the basic blocks involved. <p> The effects of pipelines and caches are actually handled in the calculator, using the low-level information. The calculator is a portable general component. Examples of calculation methods are found in <ref> [2, 15, 18, 21, 23] </ref>. In the rest of this paper we focus on the co-transformer. A more detailed description than the one below can be found in [8]. 4.
Reference: [3] <author> R. Arnold, F. Muller, D. Whalley, and M. Harmon. </author> <title> Bounding worst-case instruction cache performance. </title> <booktitle> In IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 172181, </pages> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Each function instance contains a complete copy of the basic block structure of the function, with execution information specific to the particular call to the function. A similar scheme is used in <ref> [3] </ref>, where a program is represented as a call graph of loops. Inside each function, we concentrate on the relation between basic blocks and loops.
Reference: [4] <author> M. R. Boyd and D. B. Whalley. </author> <title> Isolation and analysis of optimization errors. </title> <booktitle> In PLDI 1993, volume 28 of ACM SIG-PLAN Notices, pages 2635. ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: Hence, most of the work must be redone when porting a timing tool to other compilers or processors. Our approach allows for easy ports to new compilers, and is independent of target processor. An interesting twist, with some similarities to our ODL, is presented in <ref> [4] </ref>. There they let a compiler output a sequence of messages detailing how a program is modified, with the purpose of visualizing the compiler's transformation of the program. In the MARS project, the compiler for the Modula/R language transforms execution information about a program at compile time [22].
Reference: [5] <author> R. Chapman. </author> <title> Worst-case timing analysis via finding longest paths in SPARK Ada basic-path graphs. </title> <type> Technical Report YCS-94-246, </type> <institution> Department of Computer Science, York University, </institution> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Related Work In the area of WCET research, the problem of managing optimized code and mapping information from the high level to the low level has received comparably little attention. Most research groups concentrate on other issues, even though all are confronted with the problem in some way. In <ref> [5, 19] </ref>, the approach is to perform the mapping from the object code to the source code, and perform timing calculations on the source code level. This makes the analysis less exact, since it can be difficult to accurately ascribe an execution time to a source level statement.
Reference: [6] <author> T. M. Chung and H. G. Dietz. </author> <title> Language constructs and transformation for hard real-time systems. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Workshop on Languages, Compilers, and Tools for Real-Time Systems, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: The basic principle, updating the execution information during compilation, is the same as the co-transformer, but we do not require the program to be well-structured or presentable to a user. In the CHaRTS project <ref> [6] </ref>, timing constraints on a program are maintained and transformed by the compiler during compilation. The approach is similar to our co-transformer, but the purpose is different: they propagate timing constraints in order to guide the compiler, while we want to propagate execution information to obtain timing estimates.
Reference: [7] <author> M. Copperman. </author> <title> Debugging optimized code without being misled. </title> <type> Technical Report UCSC-CRL-92-01, </type> <institution> University of California, Santa Cruz, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: In contrast, the co-transformation approach allows us to maintain the full set of information we need for WCET analysis. In the debugging field itself <ref> [1, 7] </ref>, there is a similar need to track what happens to a program when it is compiled. However, the information needed by a debugger only concerns the static aspects of a program; i.e. the mapping of source statements to object code instructions in order to handle breakpoints.
Reference: [8] <author> J. Engblom. </author> <title> Worst-case execution time analysis for optimized code. </title> <type> Master's thesis, </type> <institution> Department of Computer Systems, Uppsala University, </institution> <month> Sept. </month> <year> 1997. </year> <type> DoCS MSc Thesis 97/94. </type>
Reference-contexts: The calculator is a portable general component. Examples of calculation methods are found in [2, 15, 18, 21, 23]. In the rest of this paper we focus on the co-transformer. A more detailed description than the one below can be found in <ref> [8] </ref>. 4. Co-Transformation The co-transformer helps execution time analysis by transforming information about the execution of a program in parallel with the transformation of the code in a compiler. In the next subsection, we will discuss how program execution information can be represented. <p> In this graph, `2000' would only occur once, with `20' used in all other calls to the function. The volume of data and analysis time needed would be higher, but the result better. 4.2. Our Program Execution Representation In our prototype tool (see <ref> [8] </ref>), a program execution is represented by a worst-case call graph where each node is a specific function call (called function instance). Each function instance contains a complete copy of the basic block structure of the function, with execution information specific to the particular call to the function. <p> The co-transformer is independent of the compiler, since it is enough to give new co-transformation definitions in order to support another compiler. 5. Example We have implemented a prototype co-transformer, which is described in more detail in <ref> [8] </ref>. In the following, we give a simple example to show how co-transformation works. The example given is a loop optimization called loop collapsing, where a nested loop is transformed to a single loop. This is typical for operations over large matrices. <p> A larger example (13 transformation, 600 lines of ODL code) takes less than a minute to run. 6. Results In our prototype <ref> [8] </ref>, we used the ODL and datastructure illustrated by the example in the previous section to handle optimizations which have effect inside a single function. We do not consider transformations which just change the composition of basic blocks, since these do not affect the execution counts or looping structure.
Reference: [9] <author> A. Ermedahl and J. Gustafsson. </author> <title> Deriving annotations for tight calculation of execution time. </title> <booktitle> In Proceedings of Euro-Par 97, LNCS (Lecture Notes in Computer Science) 1300. </booktitle> <publisher> Springer Verlag, </publisher> <month> Aug. </month> <year> 1997. </year>
Reference-contexts: The purpose of the co-transformer is to transform program execution information. Such information is usually provided manually (using annotations), but there is some promising research on the automatic analysis of programs to obtain loop bounds <ref> [9] </ref>, and discover infeasible paths [2, 14]. On the output end of the co-transformer, we need to perform calculations of execution times given information about the program flow and times for the basic blocks involved. <p> The extracted execution information contains information about loop bounds, infeasible paths, function calls, etc. Examples of HLA ap proaches are found in <ref> [9, 11] </ref>. * The low-level analysis (LLA) analyzes the object code created by the compiler. It analyzes straight-line segments of object code (basic blocks), and determine their low-level execution characteristics. All target hardware dependences (processor, memory system, etc.) are localized in the LLA. <p> As a first step towards a complete timing tool, we will create a low-level analyzer and calculator. We will also continue our work on high-level analysis of programs <ref> [9, 11] </ref>. Our long-term goal is to integrate the tool with a compiler targeted to many different platforms, and thus to allow execution time analysis to be carried out for real-time programs on many different systems.
Reference: [10] <author> C. Forsyth. </author> <title> Implementation of the worst-case execution analyser. Technical Report Hard Real-Time Operating System Kernel Study Task 8, Volume E, </title> <institution> York Software Engineering Ltd, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: A common approach is to use debug information to figure out how the source code and object code relates to each other <ref> [10, 16] </ref>. The disadvantage is that it is quite difficult to map the information needed for WCET analysis, since much information about the program structure and execution is discarded by the compiler when generating debug information.
Reference: [11] <author> J. Gustafsson and A. Ermedahl. </author> <title> Automatic derivation of path and loop annotations in object-oriented real-time programs. </title> <booktitle> In Joint Workshop on Parallel and Distributed Real-Time Systems, </booktitle> <address> Geneva, Switzerland, </address> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: The extracted execution information contains information about loop bounds, infeasible paths, function calls, etc. Examples of HLA ap proaches are found in <ref> [9, 11] </ref>. * The low-level analysis (LLA) analyzes the object code created by the compiler. It analyzes straight-line segments of object code (basic blocks), and determine their low-level execution characteristics. All target hardware dependences (processor, memory system, etc.) are localized in the LLA. <p> As a first step towards a complete timing tool, we will create a low-level analyzer and calculator. We will also continue our work on high-level analysis of programs <ref> [9, 11] </ref>. Our long-term goal is to integrate the tool with a compiler targeted to many different platforms, and thus to allow execution time analysis to be carried out for real-time programs on many different systems.
Reference: [12] <author> M. G. Harmon, T. P. Baker, and D. B. Whalley. </author> <title> A retar-getable technique for predicting execution time of code segments. </title> <booktitle> Real-Time Systems, </booktitle> <pages> pages 159182, </pages> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: It analyzes straight-line segments of object code (basic blocks), and determine their low-level execution characteristics. All target hardware dependences (processor, memory system, etc.) are localized in the LLA. Examples of LLA can be found in <ref> [12, 15] </ref>.
Reference: [13] <author> C. A. Healy, D. B. Whalley, and M. G. Harmon. </author> <title> Integrating the timing analysis of pipelining and instruction caching. </title> <booktitle> In Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: Since information about loop bounds etc. is not needed for debugging, it is not suitable for WCET analysis. Another approach is to modify a compiler to output information about program flow, data addresses, and other information needed for WCET analysis <ref> [13, 17, 23] </ref>. The idea is similar in concept to co-transformation, but requires extensive modifications of the compiler. Hence, most of the work must be redone when porting a timing tool to other compilers or processors.
Reference: [14] <author> A. A. Kountouris. </author> <title> Safe and efficient elimination of infeasible execution paths in WCET estimation. </title> <booktitle> In Proceedings of RTCSA'96. </booktitle> <publisher> IEEE, IEEE Computer Society Press, </publisher> <year> 1996. </year>
Reference-contexts: The purpose of the co-transformer is to transform program execution information. Such information is usually provided manually (using annotations), but there is some promising research on the automatic analysis of programs to obtain loop bounds [9], and discover infeasible paths <ref> [2, 14] </ref>. On the output end of the co-transformer, we need to perform calculations of execution times given information about the program flow and times for the basic blocks involved.
Reference: [15] <author> Y.-T. S. Li and S. Malik. </author> <title> Performance analysis of embedded software using implicit path enumeration. </title> <booktitle> In Proceedings of the 32th Design Automation Conference, </booktitle> <pages> pages 456461, </pages> <year> 1995. </year>
Reference-contexts: We consider the most promising approach to WCET calculations to be the use of implicit path enumeration techniques (IPET) based on constraint solving; this technique is used by several research groups <ref> [15, 18, 20] </ref>. 3. Co-Transformation Context We have incorporated the co-transformer in a general framework for WCET tools. The framework divides the problem of WCET estimation into distinct components, and makes it easier to combine different tools. <p> It analyzes straight-line segments of object code (basic blocks), and determine their low-level execution characteristics. All target hardware dependences (processor, memory system, etc.) are localized in the LLA. Examples of LLA can be found in <ref> [12, 15] </ref>. <p> The effects of pipelines and caches are actually handled in the calculator, using the low-level information. The calculator is a portable general component. Examples of calculation methods are found in <ref> [2, 15, 18, 21, 23] </ref>. In the rest of this paper we focus on the co-transformer. A more detailed description than the one below can be found in [8]. 4.
Reference: [16] <author> Y.-T. S. Li, S. Malik, and A. Wolfe. </author> <title> Cache modelling for real-time software: Beyond direct mapped instruction caches. </title> <booktitle> In Proceedings of the 17th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 254263. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: A common approach is to use debug information to figure out how the source code and object code relates to each other <ref> [10, 16] </ref>. The disadvantage is that it is quite difficult to map the information needed for WCET analysis, since much information about the program structure and execution is discarded by the compiler when generating debug information.
Reference: [17] <author> S.-S. Lim, Y. H. Bae, C. T. Jang, B.-D. Rhee, S. L. Min, C. Y. Park, H. Shin, K. Park, and C. S. Ki. </author> <title> An accurate worst-case timing analysis for risc processors. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(7):593604, </volume> <month> July </month> <year> 1995. </year>
Reference-contexts: Since information about loop bounds etc. is not needed for debugging, it is not suitable for WCET analysis. Another approach is to modify a compiler to output information about program flow, data addresses, and other information needed for WCET analysis <ref> [13, 17, 23] </ref>. The idea is similar in concept to co-transformation, but requires extensive modifications of the compiler. Hence, most of the work must be redone when porting a timing tool to other compilers or processors.
Reference: [18] <author> G. Ottosson and M. Sjodin. </author> <title> Worst-Case Execution Time Analysis for Modern Hardware Architectures. </title> <booktitle> In Proc. SIG-PLAN 1997 Workshop on Languages, Compilers and Tools for Real-Time Systems, </booktitle> <month> June </month> <year> 1997. </year> <note> Also avaible as ASTEC Report 97/01 from the Deparment of Computer Systems, </note> <institution> Uppsala University. </institution>
Reference-contexts: We consider the most promising approach to WCET calculations to be the use of implicit path enumeration techniques (IPET) based on constraint solving; this technique is used by several research groups <ref> [15, 18, 20] </ref>. 3. Co-Transformation Context We have incorporated the co-transformer in a general framework for WCET tools. The framework divides the problem of WCET estimation into distinct components, and makes it easier to combine different tools. <p> The effects of pipelines and caches are actually handled in the calculator, using the low-level information. The calculator is a portable general component. Examples of calculation methods are found in <ref> [2, 15, 18, 21, 23] </ref>. In the rest of this paper we focus on the co-transformer. A more detailed description than the one below can be found in [8]. 4.
Reference: [19] <author> C. Y. Park. </author> <title> Predicting program execution times by analyzing static and dynamic program paths. Real-Time Systems, </title> <address> 5(1):3162, </address> <month> Mar. </month> <year> 1993. </year>
Reference-contexts: Related Work In the area of WCET research, the problem of managing optimized code and mapping information from the high level to the low level has received comparably little attention. Most research groups concentrate on other issues, even though all are confronted with the problem in some way. In <ref> [5, 19] </ref>, the approach is to perform the mapping from the object code to the source code, and perform timing calculations on the source code level. This makes the analysis less exact, since it can be difficult to accurately ascribe an execution time to a source level statement.
Reference: [20] <author> P. Puschner and A. Schedl. </author> <title> Computing maximum task execution times with linear programming techniques. </title> <type> Technical report, </type> <institution> Technische Universitat, Institut fur Technische Infor-matik, Wien, </institution> <month> Apr. </month> <year> 1995. </year>
Reference-contexts: We consider the most promising approach to WCET calculations to be the use of implicit path enumeration techniques (IPET) based on constraint solving; this technique is used by several research groups <ref> [15, 18, 20] </ref>. 3. Co-Transformation Context We have incorporated the co-transformer in a general framework for WCET tools. The framework divides the problem of WCET estimation into distinct components, and makes it easier to combine different tools.
Reference: [21] <author> F. Stappert. </author> <title> Predicting pipelining and caching behaviour of hard real-time programs. </title> <booktitle> In EUROMICRO Workshop on Real-Time Systems, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: The effects of pipelines and caches are actually handled in the calculator, using the low-level information. The calculator is a portable general component. Examples of calculation methods are found in <ref> [2, 15, 18, 21, 23] </ref>. In the rest of this paper we focus on the co-transformer. A more detailed description than the one below can be found in [8]. 4.
Reference: [22] <author> A. Vrchoticky. </author> <title> Compilation support for fine-grained execution analysis. </title> <booktitle> In ACM Sigplan Workshop on Language, Compiler and Tool Support for Real-Time Systems, </booktitle> <year> 1994. </year>
Reference-contexts: There they let a compiler output a sequence of messages detailing how a program is modified, with the purpose of visualizing the compiler's transformation of the program. In the MARS project, the compiler for the Modula/R language transforms execution information about a program at compile time <ref> [22] </ref>. Execution information is provided as annotations in the source code. The approach is limited to transformations which keep the program well-structured, and which do not make it too difficult to present an understandable view of the program to the user.
Reference: [23] <author> R. White, F. Muller, C. Healy, D. Whalley, and M. Harmon. </author> <title> Timing analysis for data caches and set-associative caches. </title> <booktitle> In Proceedings of the IEEE Real-Time Technology and Applications Symposium, </booktitle> <pages> pages 192202, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Since information about loop bounds etc. is not needed for debugging, it is not suitable for WCET analysis. Another approach is to modify a compiler to output information about program flow, data addresses, and other information needed for WCET analysis <ref> [13, 17, 23] </ref>. The idea is similar in concept to co-transformation, but requires extensive modifications of the compiler. Hence, most of the work must be redone when porting a timing tool to other compilers or processors. <p> The effects of pipelines and caches are actually handled in the calculator, using the low-level information. The calculator is a portable general component. Examples of calculation methods are found in <ref> [2, 15, 18, 21, 23] </ref>. In the rest of this paper we focus on the co-transformer. A more detailed description than the one below can be found in [8]. 4.
References-found: 23

