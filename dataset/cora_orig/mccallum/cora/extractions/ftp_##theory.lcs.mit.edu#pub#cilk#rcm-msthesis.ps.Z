URL: ftp://theory.lcs.mit.edu/pub/cilk/rcm-msthesis.ps.Z
Refering-URL: http://theory.lcs.mit.edu/~cilk/papers.html
Root-URL: 
Title: A Type-checking Preprocessor for Cilk 2, a Multithreaded C Language  
Author: by Robert C. Miller 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degrees of Bachelor of Science in Computer Science and Engineering and Master of Engineering in Electrical Engineering and Computer Science at the  All rights reserved. Author  Certified by Charles E. Leiserson Thesis Supervisor Accepted by F. R. Morgenthaler Chairman, Department Committee on Graduate Theses  
Note: Copyright 1995  
Date: May 1995  May 12, 1995  
Affiliation: Massachusetts Institute of Technology  Massachusetts Institute of Technology.  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: An abstract syntax tree (AST) represents the syntactic structure of a computer program in a tree data structure <ref> [1] </ref>. Each tree node in an AST represents a declaration, statement, or expression operator. Its children are the operands or syntactic components 17 of the declaration, statement, or expression. Some examples of AST nodes are shown in Abstract syntax trees are an ideal representation for syntax-directed macro preprocessors. <p> C-to-C delegates constant folding to the back-end compiler, where it belongs. 27 28 Chapter 5 Data-flow Analysis in C-to-C This chapter describes C-to-C's data-flow analysis algorithm, which works directly on the high-level abstract syntax tree. C-to-C implements a standard iterative algorithm <ref> [1] </ref>, but with performance improvements enabled by the AST representation, which include depth-first order and testing for convergence only at loops and jumps.
Reference: [2] <author> S. P. Amarasinghe, J. M. Anderson, M. S. Lam, and C. W. Tseng. </author> <title> The SUIF compiler for scalable parallel machines. </title> <booktitle> In Proceedings 7th SIAM Conference on Parallel Processing for Scientific Computing, </booktitle> <month> February </month> <year> 1995. </year>
Reference-contexts: This approach begins with a standard C compiler and extends its front end to recognize the new extensions <ref> [2, 16] </ref>. Compared to a full compiler, however, a translator based on C-to-C is portable and extensible | highly desirable qualities for language research. <p> Next, a translator based on C-to-C is easier to extend than existing public-domain C compilers. Its lexical scanner and parser are automatically generated from lex/yacc specifications, which are easier to change than the hand-coded front-ends of lcc [10] and the SUIF compiler framework <ref> [2] </ref>. C-to-C's type checking and data-flow analysis are table-driven, so that new statements and expressions can be specified by just a few method functions.
Reference: [3] <institution> American National Standards Institute, Inc., NY. American National Standards for Information Systems, Programming Language C ANSI X3.159-1989. </institution> <year> 1990. </year>
Reference-contexts: In particular, we note the following desiderata for a good implementation of C-to-C: * The postsource should be portable. In particular, if the source is a strictly conforming ANSI C program, then the postsource should also be a strictly conforming ANSI C program <ref> [3] </ref>. Thus, C-to-C should not perform transformations that depend on a particular target platform or back-end C compiler. An example of an unacceptable transformation is constant expression folding, which will be discussed further below. <p> As a result, if the behavior of the source program depends on evaluation order, then C-to-C's analysis may be incorrect. Fortunately, programs that depend 30 upon evaluation order are rare and inherently unportable, since the order of evaluation of expressions and side-effects in C has always been undefined <ref> [3, 13] </ref>. Few programmers write code that depends on evaluation order, and those that do deserve what they get. 5.2 Data-flow analysis frameworks This section describes C-to-C's data-flow analysis abstraction.
Reference: [4] <author> Robert D. Blumofe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson, Phil Lisiecki, Rob Miller, Keith H. Randall, Andy Shaw, and Yuli Zhou. </author> <title> Cilk 2.0 Reference Manual. MIT LCS, 545 Technology Square, </title> <address> Cambridge, MA 02139, </address> <month> May </month> <year> 1995. </year> <note> Available via ftp://theory.lcs.mit.edu/pub/cilk/manual-2.0.ps.Z. </note>
Reference-contexts: The discussion below is neither a complete specification of the language nor a detailed description of how Cilk extensions are translated into C. That information is available elsewhere <ref> [4] </ref>. <p> A Cilk procedure's return statement differs from the ordinary C return statement, since the Cilk procedure may need to communicate the return value to a different processor. Cilk includes other features that provide the programmer with greater control over synchronization and scheduling of parallel procedures, which are described elsewhere <ref> [4] </ref>. The remaining sections of this chapter will use the fib example to illustrate the following claims. First, the back-end C compiler's type checking fails to detect some static type errors in Cilk programs and reports unhelpful error messages for others, so the preprocessor must perform Cilk-specific type checking.
Reference: [5] <author> Robert D. Blumofe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson, Keith H. Randall, and Yuli Zhou. Cilk: </author> <title> An efficient multithreaded runtime system. </title> <booktitle> In Proceedings 5th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <address> Santa Barbara, CA, </address> <month> July </month> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: Introduction Cilk (pronounced "silk") is a parallel programming language under development at MIT Laboratory for Computer Science <ref> [5] </ref>. Cilk provides syntax for expressing control parallelism, allowing a programmer to specify that certain procedure calls should be spawned, or run in parallel with the current thread of execution. <p> Cilk is an example of a C extension language | a programming language that extends C with new keywords, syntax, or semantics. C extension languages have lately become popular in parallel and distributed computing research <ref> [5, 7, 8, 9, 15] </ref>, because of the wide portability of ANSI C, the large population of C programmers, and the extensive base of C applications and library software. Like many C extension languages, Cilk is not translated directly into object code.
Reference: [6] <author> Fran~cois Bodin, Peter Beckman, Dennis Gannon, Jacob Gotwais, Srinivas Narayana, Suresh Srinivas, and Beata Winnicka. Sage++: </author> <title> An object-oriented toolkit and class library for building Fortran and C++ restructuring tools. </title> <booktitle> In Proceedings of OONSKI '94, </booktitle> <year> 1994. </year> <note> Also available as ftp://ftp.extreme.indiana.edu/pub/sage/oonski94.ps.gz. </note>
Reference-contexts: C-to-C provides "operational transparency," preserving all high-level C syntax, line numbering, indentation, and constant expressions used in the original program. The readability of C-to-C's output simplifies the process of checking that extension language constructs have been translated correctly. 1.3 Related work The Sage++ preprocessor framework <ref> [6] </ref> is similar to C-to-C in that it provides a rich toolkit for program analysis and transformation, including source transparency and data-flow analysis. Although the Sage++ front-end supports C, C++, and Fortran, it is more difficult to extend to new languages.
Reference: [7] <author> Fran~cois Bodin, Peter Beckman, Dennis Gannon, Srinivas Narayana, and Shelby X. Yang. </author> <title> Distributed pC++: Basic ideas for an object parallel language. </title> <journal> Scientific Programming, </journal> <volume> 2(3), </volume> <month> Fall </month> <year> 1993. </year>
Reference-contexts: Cilk is an example of a C extension language | a programming language that extends C with new keywords, syntax, or semantics. C extension languages have lately become popular in parallel and distributed computing research <ref> [5, 7, 8, 9, 15] </ref>, because of the wide portability of ANSI C, the large population of C programmers, and the extensive base of C applications and library software. Like many C extension languages, Cilk is not translated directly into object code.
Reference: [8] <author> K. Mani Chandy and Carl Kesselman. </author> <title> CC++: A declarative concurrent object oriented programming notation. </title> <type> Technical Report CS-TR-92-01, </type> <institution> California Institute of Technology, Pasadena, </institution> <address> CA, </address> <year> 1992. </year>
Reference-contexts: Cilk is an example of a C extension language | a programming language that extends C with new keywords, syntax, or semantics. C extension languages have lately become popular in parallel and distributed computing research <ref> [5, 7, 8, 9, 15] </ref>, because of the wide portability of ANSI C, the large population of C programmers, and the extensive base of C applications and library software. Like many C extension languages, Cilk is not translated directly into object code.
Reference: [9] <author> David E. Culler, Andrea Dusseau, Seth Copen Goldstein, Arvind Krishnamurthy, Steven Lumetta, Thorsten von Eicken, and Katherine Yelick. </author> <title> Parallel programming in Split-C. </title> <booktitle> In Proceedings of Supercomputing '93, the ACM/IEEE Conference, </booktitle> <address> Portland, OR, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: Cilk is an example of a C extension language | a programming language that extends C with new keywords, syntax, or semantics. C extension languages have lately become popular in parallel and distributed computing research <ref> [5, 7, 8, 9, 15] </ref>, because of the wide portability of ANSI C, the large population of C programmers, and the extensive base of C applications and library software. Like many C extension languages, Cilk is not translated directly into object code.
Reference: [10] <author> Chris Fraser and David Hanson. </author> <title> A Retargetable C Compiler: Design and Implementation. </title> <address> Benjamin/Cummings, </address> <year> 1995. </year> <month> 37 </month>
Reference-contexts: Only the relatively small runtime system must be ported. Next, a translator based on C-to-C is easier to extend than existing public-domain C compilers. Its lexical scanner and parser are automatically generated from lex/yacc specifications, which are easier to change than the hand-coded front-ends of lcc <ref> [10] </ref> and the SUIF compiler framework [2]. C-to-C's type checking and data-flow analysis are table-driven, so that new statements and expressions can be specified by just a few method functions.
Reference: [11] <author> John B. Kam and Jeffrey D. Ullman. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of the ACM, </journal> <volume> 23 </volume> <pages> 158-171, </pages> <year> 1976. </year>
Reference-contexts: Each iteration of C-to-C's data-flow analysis algorithm must propagate information through more nodes. C-to-C offsets this performance hit by taking advantage of properties of the implicit CFG. First, the iterative algorithm converges fastest if the nodes of the CFG are visited in depth-first order on each iteration <ref> [11] </ref>. Since the AST is a depth-first spanning tree of its implicit CFG, we can visit CFG nodes in depth-first order by simply walking the tree, so fast convergence is automatic. <p> C-to-C's algorithm differs from the standard algorithm in two respects: the control flow graph is traversed in depth-first order, and convergence is only tested at loops and jumps. Visiting CFG nodes in depth-first order yields the fastest convergence of the standard iterative algorithm <ref> [11] </ref>.
Reference: [12] <author> John B. Kam and Jeffrey D. Ullman. </author> <title> Monotone data flow analysis frameworks. </title> <journal> Acta Informatica, </journal> <volume> 7 </volume> <pages> 305-318, </pages> <year> 1977. </year>
Reference-contexts: For the sake of extensibility, C-to-C provides a "monotonic data-flow analysis framework" abstraction that is applicable to a wide variety of data-flow problems, including live variables, constant propagation, reaching definitions, and available expressions. Monotonic data-flow analysis frameworks were originally proposed by Kildall [14] and developed by Kam and Ullman <ref> [12] </ref>. C-to-C's implementation follows the treatment of monotonic frameworks in the "Dragon Book" ([1], section 10.11) A monotonic data-flow analysis framework consists of: Data type V : a set of values to be propagated. A value in V represents an assertion about the dynamic state of the program.
Reference: [13] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language, 2nd Edition. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Transform performs tree transformations that convert the annotated source-language AST into a pure C AST. (In C-to-C, this phase does nothing, because the source language and target language are both C.) Unparse unparses the AST into text. 3.2.1 Macro preprocessing (cpp) The cpp phase performs standard C macro preprocessing <ref> [13] </ref>. During this phase, macro definitions are interpreted and expanded, conditional compilation directives are recognized, and comments are removed from the source. <p> As a result, if the behavior of the source program depends on evaluation order, then C-to-C's analysis may be incorrect. Fortunately, programs that depend 30 upon evaluation order are rare and inherently unportable, since the order of evaluation of expressions and side-effects in C has always been undefined <ref> [3, 13] </ref>. Few programmers write code that depends on evaluation order, and those that do deserve what they get. 5.2 Data-flow analysis frameworks This section describes C-to-C's data-flow analysis abstraction.
Reference: [14] <author> Gary Kildall. </author> <title> A unified approach to global program optimization. </title> <booktitle> In Proceedings 1st ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 194-206, </pages> <year> 1973. </year>
Reference-contexts: The iterative algorithm coded in C-to-C applies to a variety of data-flow analysis problems, described in general as monotonic frameworks. Following the suggestions made by Kildall <ref> [14] </ref>, C-to-C defines a monotonic framework abstraction which enables an extension language developer to define a data-flow analysis problem declaratively. <p> For the sake of extensibility, C-to-C provides a "monotonic data-flow analysis framework" abstraction that is applicable to a wide variety of data-flow problems, including live variables, constant propagation, reaching definitions, and available expressions. Monotonic data-flow analysis frameworks were originally proposed by Kildall <ref> [14] </ref> and developed by Kam and Ullman [12]. C-to-C's implementation follows the treatment of monotonic frameworks in the "Dragon Book" ([1], section 10.11) A monotonic data-flow analysis framework consists of: Data type V : a set of values to be propagated.
Reference: [15] <author> J. R. Rose and G. L. Steele Jr. </author> <title> C*: An extended language for data parallel programming. </title> <booktitle> In Proceedings 2nd International Conference on Supercomputing, </booktitle> <volume> volume 2, </volume> <pages> pages 2-16, </pages> <address> San Francisco, CA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: Cilk is an example of a C extension language | a programming language that extends C with new keywords, syntax, or semantics. C extension languages have lately become popular in parallel and distributed computing research <ref> [5, 7, 8, 9, 15] </ref>, because of the wide portability of ANSI C, the large population of C programmers, and the extensive base of C applications and library software. Like many C extension languages, Cilk is not translated directly into object code.
Reference: [16] <author> Richard Stallman et al. </author> <note> GNU C compiler (GCC) version 2. Source code and documentation available from prep.ai.mit.edu via anonymous ftp, in directory /pub/gnu., </note> <year> 1994. </year>
Reference-contexts: This approach begins with a standard C compiler and extends its front end to recognize the new extensions <ref> [2, 16] </ref>. Compared to a full compiler, however, a translator based on C-to-C is portable and extensible | highly desirable qualities for language research. <p> C-to-C's type checking and data-flow analysis are table-driven, so that new statements and expressions can be specified by just a few method functions. Transformations are expressed as operations directly on the high-level abstract syntax tree, which we found easier to manipulate than the intermediate representation of compilers like gcc <ref> [16] </ref>. Also, unlike most compilers, C-to-C provides an abstraction for data-flow analysis which can be extended to solve any monotonic data-flow analysis problem needed for translation or optimization. <p> Expressions can contain conditional operators or short-circuiting Boolean operators which may not evaluate their second operand. Worse, the GNU extensions to C allow arbitrary statements to appear inside expressions, so jumps into and out of the middle of an expression are possible <ref> [16] </ref>. (C-to-C supports this "statement expression" extension, because it is occasionally useful in Cilk programs.) To avoid these complications, C-to-C treats every AST node as a basic block, so its control flow graph (CFG) contains many more nodes than a typical compiler's control flow graph.
References-found: 16

