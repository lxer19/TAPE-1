URL: http://www.merl.com/reports/TR91-01/TR91-01.ps.gz
Refering-URL: http://www.merl.com/reports/TR91-01/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: by  
Author: Richard C. Waters 
Address: Cambridge Massachusetts 02139  
Note: Submitted to ACM TOPLAS,  
Date: 91-01 March 12, 1991  March 1991.  
Affiliation: Mitsubishi Electric Research Laboratories  201 Broadway  
Pubnum: Technical Report  
Abstract: Programs can be constructed and modified more rapidly and reliably if they are built out of standard fragments (cliches) than if they are written from scratch. Three experimental cliche-based program editors have been implemented, exploring the tradeoff between power and simplicity. The Knowledge-Based Editor in Emacs (kbemacs) is the most powerful of the three editors. It supports a wide range of editing operations and can represent a wide range of cliches, because it uses an internal representation called plan diagrams, which combines features of flowcharts and data-flow schemas. Unfortunately, the need to convert back and forth between program text and plan diagrams causes kbemacs to be complex. The Tempest editor is the simplest and fastest of the three editors. Because it uses text as its internal representation, it does not have to do any conversions. Unfortunately, Tempest is not useful for editing programs, because the manipulations required when combining programming cliches are too complex to be performed directly on program text. However, Tempest's capabilities are useful in other, simpler contexts. The Ace editor retains much of the simplicity of Tempest while supporting much of the power of kbemacs. Ace is relatively simple, because it uses parse-trees as its internal representation. It achieves high power by using a specially modified programming-language grammar, which facilitates the representation and easy combination of cliches. This approach could be used to add powerful and efficient cliche-based editing capabilities to any programming environment. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M.A. Ardis, </author> <title> Template-Mode for GNU Emacs, </title> <type> draft documentation, </type> <institution> Wang Institute, </institution> <address> Tyngsboro MA, </address> <month> July </month> <year> 1987. </year>
Reference-contexts: However, Tempest has the advantage that it is simple, flexible, and blindingly fast. It would be a valuable extension to any text editor. An example of an extension of this kind is the gnu Emacs [21] template mode implemented by Ardis <ref> [1] </ref>. 32 R.C. Waters 5 Ace The experiment with Tempest revealed that some amount of representation shift is essential for supporting cliche-based program editing. However, the feeling remained that a full shift to plan diagrams was not required.
Reference: [2] <author> R. Bahlke and G. Snelting, </author> <title> "The PSG System: From Formal Language Definitions to Interactive Programming Environments", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 547-576, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: introduction of support for certain cliched data structures and cliched patterns of control flow. Cliche-based editors. Many program editors are merely text editors and do not capture any knowledge of programming per se. However, some program editors incorporate an understanding of the grammar of a programming language <ref> [2, 4, 6, 11, 20, 18, 25] </ref>. These syntax editors support the manipulation of the few cliches (such as conditional control flow and looping control flow) that correspond to parts of programming language grammars.
Reference: [3] <editor> T.J. Biggerstaff and A.J. Perlis (editors), </editor> <booktitle> Software Reusability, Volumes 1 and 2, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1989. </year>
Reference-contexts: It is important that cliche-based editors include the capabilities of syntax editors and text editors, just as it is important for syntax editors to include the capabilities of text editors [12, 27]. Cliche-based editors can be compared with other approaches to software reuse (see <ref> [3] </ref>) along two primary dimensions: expressiveness (the range of things that can be reused) and tailorability (the extent to which the reused items can be altered to fit the circumstances at hand). Cliche-based editors take an extreme position on each of these dimensions, supporting very high expressiveness and tailorability.
Reference: [4] <author> R. Bilos, </author> <title> "A Token-Based Syntax Sensitive Editor", </title> <institution> Linkoping University Technical report LiTH-IDA-R-87-02, Linkoping Sweden, </institution> <month> February </month> <year> 1987. </year>
Reference-contexts: introduction of support for certain cliched data structures and cliched patterns of control flow. Cliche-based editors. Many program editors are merely text editors and do not capture any knowledge of programming per se. However, some program editors incorporate an understanding of the grammar of a programming language <ref> [2, 4, 6, 11, 20, 18, 25] </ref>. These syntax editors support the manipulation of the few cliches (such as conditional control flow and looping control flow) that correspond to parts of programming language grammars.
Reference: [5] <author> P. Degano, S. Mannucci, and B. Mojana, </author> <title> "Efficient Incremental LR Parsing for Syntax-Directed Editors", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 345-373, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Similarly, implementation of the parser was omitted on the grounds that parsing is a well understood problem. However, it is worthy of note that incremental parsing <ref> [5] </ref> is required to provide efficient combined support for text editing and syntax editing. While unparsing is just as well understood as parsing, an unparser had to be implemented to enable the ready demonstration of Ace's capabilities.
Reference: [6] <author> V. Donzeau-Gouge et.al., </author> <title> "A Structure Oriented Program Editor: a First Step Towards Computer Assisted Programming", </title> <booktitle> Proc. Inter. Computing Symp., </booktitle> <address> Antibes France, </address> <year> 1975. </year>
Reference-contexts: introduction of support for certain cliched data structures and cliched patterns of control flow. Cliche-based editors. Many program editors are merely text editors and do not capture any knowledge of programming per se. However, some program editors incorporate an understanding of the grammar of a programming language <ref> [2, 4, 6, 11, 20, 18, 25] </ref>. These syntax editors support the manipulation of the few cliches (such as conditional control flow and looping control flow) that correspond to parts of programming language grammars. <p> It would be both practical and valuable to add an editor like Ace to any programming environment. Given that syntax editors have existed for fifteen years or more <ref> [6, 11, 20, 25] </ref> and reuse has been lauded as a key goal of software engineering for much longer than that, it is somewhat surprising that there are not already many editors like Ace.
Reference: [7] <author> K. Jensen and N. Wirth, </author> <title> Pascal User Manual and Report third edition, revised for the ISO Pascal Standard, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: Derived Constraints: fwidth limitg = 70-fwidthg. fwidthg = Width (fformatg). fwritesg = GenerateWrites (freportg, fformatg, fitemg). Input roles: freportg, flinenog, fitemg. Primary roles: fformatg, fitemg. Schema type: statements. Role types: freportg, flinenog: identifier. fitemg: expression. fformatg: string. fwritesg: statements. fwidthg, fwidth limitg: number. Ace, an Algol-like language (Pascal <ref> [7] </ref>) was used to emphasize the practical applicability of the system. 5.1 Representing Cliches as Parse-Tree Schemas of the figure depicts a parse tree with the root at the left.
Reference: [8] <author> S. Katz, </author> <title> C.A. Richter, and K.S. The, "Paris: A system for Reusing Partially Interpreted Schemas", </title> <booktitle> in Software Reusability, Volume 1, Concepts and Models, </booktitle> <pages> 257-273, </pages> <editor> T.J. Biggerstaff and A.J. Perlis (editors), </editor> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1989. </year>
Reference-contexts: However, you have to restrict yourself to operate in a predominantly non-cliched manner after the initial insertion of a schema. This approach is taken by the Paris system <ref> [8] </ref>, where the nesting of schemas is mentioned as a theoretical possibility, but not pursued. 28 R.C. <p> In the context of component libraries of various kinds, this issue is being actively pursued by many researchers (see for example <ref> [8, 13] </ref>). Ace's schema library could and should be extended to support browsing, a hierarchical organization of the schemas, and indexing based on keywords or some other kind of descriptors.
Reference: [9] <author> B.W. Kernighan and D.M. Ritchie, </author> <title> The C Programming Language, </title> <publisher> Prentice-Hall Inc., </publisher> <address> Englewood Cliffs NJ, </address> <year> 1978. </year>
Reference-contexts: As a radical first experiment in simplifying kbemacs, a system called Tempest [23] was constructed that eliminates the representation shift altogether. Tempest succeeds in removing almost all of kbemacs' complexity, but at the price of removing most of kbemacs' power. Tempest is a small program implemented in c <ref> [9] </ref> on an ibm pc rather than a large program on a Symbolics Lisp Machine. It executes commands in fractions of seconds rather than minutes. However, Tempest is not powerful enough to provide useful support for program editing. Nevertheless, it is valuable to discuss Tempest for two reasons.
Reference: [10] <author> A. Lomax, </author> <title> "The Suitability of Language Syntaxes for Program Generation", </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 22(3) </volume> <pages> 95-101, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: For instance, these desiderata encourage grammars that lead to deeply nested parse trees. Because the intermediate nodes in these parse trees have little or no significance to human programmers, it has proved useful to use altered grammars that lead to shallow parse trees as the bases for syntax editors <ref> [10] </ref>. The grammar used by Ace is based on three principal desiderata: minimizing the number of non-terminal nodes in parse trees, minimizing the alterations that must be performed when parse-tree schemas are combined, and moving as many syntactic details as possible out of the parse trees and into the unparser. <p> The key impediment that blocks typical syntax editors from usefully supporting algorithmic schemas is the grammars they use as the basis for their operation. It has become generally recognized that syntax editors should not be based on the standard grammar for a programming language <ref> [10] </ref>. However, they typically try to stay as close to the standard grammar as possible. In particular, they typically assume that the grammar should be unambiguous and that the order of the constituents in the parse-tree should be the same as their order in the program text.
Reference: [11] <author> R. Medina-Mora and P. Feiler, </author> <title> "An Incremental Programming Environment", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 7(5) </volume> <pages> 472-482, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: introduction of support for certain cliched data structures and cliched patterns of control flow. Cliche-based editors. Many program editors are merely text editors and do not capture any knowledge of programming per se. However, some program editors incorporate an understanding of the grammar of a programming language <ref> [2, 4, 6, 11, 20, 18, 25] </ref>. These syntax editors support the manipulation of the few cliches (such as conditional control flow and looping control flow) that correspond to parts of programming language grammars. <p> It would be both practical and valuable to add an editor like Ace to any programming environment. Given that syntax editors have existed for fifteen years or more <ref> [6, 11, 20, 25] </ref> and reuse has been lauded as a key goal of software engineering for much longer than that, it is somewhat surprising that there are not already many editors like Ace.
Reference: [12] <author> B. Melese, </author> <title> "Structured Editing|unstructured editing, cooperation and complementarity", </title> <booktitle> Proc. Second Software Engineering Conference, </booktitle> <pages> 48-53, </pages> <address> Nice France, </address> <month> June </month> <year> 1984. </year>
Reference-contexts: It is important that cliche-based editors include the capabilities of syntax editors and text editors, just as it is important for syntax editors to include the capabilities of text editors <ref> [12, 27] </ref>. Cliche-based editors can be compared with other approaches to software reuse (see [3]) along two primary dimensions: expressiveness (the range of things that can be reused) and tailorability (the extent to which the reused items can be altered to fit the circumstances at hand).
Reference: [13] <author> R. Prieto-d iaz, </author> <title> "Classification of Reusable Modules", </title> <booktitle> in Software Reusability, Volume 1, Concepts and Models, </booktitle> <pages> 99-123, </pages> <editor> T.J. Biggerstaff and A.J. Perlis (editors), </editor> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1989. </year>
Reference-contexts: In the context of component libraries of various kinds, this issue is being actively pursued by many researchers (see for example <ref> [8, 13] </ref>). Ace's schema library could and should be extended to support browsing, a hierarchical organization of the schemas, and indexing based on keywords or some other kind of descriptors.
Reference: [14] <author> C. Rich and R.C. Waters, </author> <title> The Programmer's Apprentice: A Program Design Scenario, </title> <institution> MIT Artificial Intelligence Laboratory memo MIT/AIM-933a, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: A more general logical representation is required for representing non-algorithmic cliches. Work is currently underway on the construction of a Design Apprentice that will address the problems above and go beyond kbemacs by automating low-level program design <ref> [14, 34] </ref>. With the Design Apprentice, a programmer/designer will outline the basic high-level design, while the system selects the detailed algorithms to use and puts them together into a program.
Reference: [15] <author> C. Rich and R.C. Waters, </author> <title> "Formalizing Reusable Software Components in the Programmer's Apprentice", </title> <booktitle> in Software Reusability, Volume II, Applications and Experience, </booktitle> <pages> 313-343, </pages> <editor> T. Biggerstaff and A. Perlis (editors), </editor> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1989. </year>
Reference-contexts: The central issue in implementing a cliche-based editor is how cliches are represented. This representation must simultaneously satisfy a number of goals <ref> [15] </ref>. In the current context, three of these goals are particularly important: 1. It must be possible to express a wide variety of cliches. 2. It must be practical to combine cliches as directed by the user. (Cliches are seldom of much use in isolation.) 3. <p> Cliche-Based Program Editing 7 3 KBEmacs This section illustrates the power of cliche-based editing, using the Knowledge-Based Editor in Emacs (kbemacs) as an example. Since kbemacs has already been presented elsewhere (see <ref> [15, 16, 30] </ref>), discussion of the details of kbemacs is kept to a minimum.
Reference: [16] <author> C. Rich and R.C. Waters, </author> <title> The Programmer's Apprentice, </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1990. </year> <note> 50 R.C. Waters </note>
Reference-contexts: Each time a cliche is brought into play, the programmer is free to use the full range of editing operations to adjust it. Representing cliches. The basic feasibility of cliche-based editing was demonstrated some time ago by the Knowledge-Based Editor in Emacs (kbemacs) <ref> [16, 30] </ref>. However, kbemacs is only a demonstration system and would have to be reimplemented with an eye toward efficiency and robustness before it could be used in a commercial setting. <p> Cliche-Based Program Editing 7 3 KBEmacs This section illustrates the power of cliche-based editing, using the Knowledge-Based Editor in Emacs (kbemacs) as an example. Since kbemacs has already been presented elsewhere (see <ref> [15, 16, 30] </ref>), discussion of the details of kbemacs is kept to a minimum. <p> Derived Constraints: fwidth limitg = 70-Width (fformatg). Comment: "prints out fitemg in columns". Described roles: fformatg, fitemg. Input roles: fitemg. Primary roles: fformatg, fitemg. 3.1 Representing Cliches as Plan diagrams (c.f. Figure 2). The top part of Figure 6 is a drawing of a plan diagram (see <ref> [16] </ref>). The bottom part of the figure shows constraints and other auxiliary information that is recorded as annotation on the plan diagram. A plan diagram is a graph in which computation nodes are connected by arcs representing data flow and control flow. <p> This can be appreciated most easily by looking at Figure 7. (Like most of the figures in this section, Figure 7 is based on a figure from <ref> [16] </ref>; however, a few cosmetic changes have been made to facilitate comparison with the figures in Sections 4 and 5.) The Lisp definition in Figure 7 is the external printed form used by kbemacs for the schema in Figure 6. <p> The computations that eventually fill the print headings and print entry roles are expected to correctly update the value recording the number of lines printed. This is signified in Temporal abstraction. Through the process of temporal abstraction <ref> [16, 26] </ref> plan diagrams represent loops as "compositions" of operations on sequences of values. For example, the main computation in the simple report schema in Figure 8 is represented as the composition of the enumerator and a map. <p> of designing the grammar used by the editor with cliches and cliche combination in mind and allow the unparsing process to become somewhat more complex. 6.1 Acknowledgments The concept of cliche-based editing evolved out of the work of the Programmer's Appren Cliche-Based Program Editing 49 tice project as a whole <ref> [16] </ref>. In particular, Charles Rich made important contributions to all of the work described here. Further, under the supervision of the author, Peter J. Sterpe implemented Tempest while Yang Meng Tan implemented Ace.
Reference: [17] <author> C. Rich and L.M. Wills, </author> <title> "Recognizing a Program's Design: A Graph-Parsing Approach", </title> <journal> IEEE Software, </journal> <volume> 7(1) </volume> <pages> 82-89, </pages> <month> January </month> <year> 1990 </year>
Reference-contexts: Waters a special feature|whenever a textual change is confined solely to the contents of a single role, kbemacs recognizes that the change is equivalent to filling the role with the indicated text.) Work is currently underway on methods for automatically supporting complete reverse engineering in the general case, see <ref> [17, 35] </ref>. The weaknesses above notwithstanding, kbemacs demonstrates valuable capabilities. However, the evolution of the system has reached the point where the creation of a full-scale prototype requires complete reimplementation. Unfortunately, kbemacs consists of some 40,000 lines of Lisp code and is comparable in complexity to an optimizing compiler. <p> Further, while it appears that this problem can be fixed in the case of kbemacs (see <ref> [17, 35] </ref>), there is little likelihood that it can be fixed in Ace. As above, the central problem is the syntactic rigidity of parse-tree schemas.
Reference: [18] <author> J.J. Shilling, "Fred: </author> <title> A Program Development Tool", </title> <booktitle> Proc. Second Conference on Software Development Tools, Techniques, and Alternatives, </booktitle> <pages> 172-180, </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Washington DC, </address> <month> December </month> <year> 1985. </year>
Reference-contexts: introduction of support for certain cliched data structures and cliched patterns of control flow. Cliche-based editors. Many program editors are merely text editors and do not capture any knowledge of programming per se. However, some program editors incorporate an understanding of the grammar of a programming language <ref> [2, 4, 6, 11, 20, 18, 25] </ref>. These syntax editors support the manipulation of the few cliches (such as conditional control flow and looping control flow) that correspond to parts of programming language grammars.
Reference: [19] <author> E. Soloway and K. Ehrlich, </author> <title> "Empirical Studies of Programming Knowledge", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(5) </volume> <pages> 595-609, </pages> <month> September </month> <year> 1984. </year>
Reference: [20] <author> R.E. Stallman, </author> <title> "Emacs: the Extensible, Customizable, Self-Documenting Display Editor", </title> <booktitle> Proc. ACM SIGPLAN-SIGOA Symposium on Text Manipulation, ACM SIGPLAN Notices, </booktitle> <volume> 16(6) </volume> <pages> 108-116, </pages> <month> June </month> <year> 1981. </year>
Reference-contexts: introduction of support for certain cliched data structures and cliched patterns of control flow. Cliche-based editors. Many program editors are merely text editors and do not capture any knowledge of programming per se. However, some program editors incorporate an understanding of the grammar of a programming language <ref> [2, 4, 6, 11, 20, 18, 25] </ref>. These syntax editors support the manipulation of the few cliches (such as conditional control flow and looping control flow) that correspond to parts of programming language grammars. <p> The schema library contains a collection of programming cliches represented as plan-diagram schemas. The schema editor can combine schemas chosen from the schema library and manipulate plan diagrams based on their structure in terms of schemas. Since kbemacs is implemented on the Symbolics Lisp Machine [37], the standard Emacs-style <ref> [20] </ref> Lisp Machine program editor is used as the text editor and syntax editor. The schema editor is integrated with the standard editor so that a common interface is presented to the user. <p> It would be both practical and valuable to add an editor like Ace to any programming environment. Given that syntax editors have existed for fifteen years or more <ref> [6, 11, 20, 25] </ref> and reuse has been lauded as a key goal of software engineering for much longer than that, it is somewhat surprising that there are not already many editors like Ace.
Reference: [21] <author> R.E. Stallman, </author> <title> GNU Emacs Manual, Free Software Foundation, </title> <address> Cambridge MA, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: However, Tempest has the advantage that it is simple, flexible, and blindingly fast. It would be a valuable extension to any text editor. An example of an extension of this kind is the gnu Emacs <ref> [21] </ref> template mode implemented by Ardis [1]. 32 R.C. Waters 5 Ace The experiment with Tempest revealed that some amount of representation shift is essential for supporting cliche-based program editing. However, the feeling remained that a full shift to plan diagrams was not required.
Reference: [22] <author> G.L. Steele Jr., </author> <title> Common Lisp: the Language, </title> <publisher> Digital Press, </publisher> <address> Maynard MA, </address> <year> 1984. </year>
Reference: [23] <author> P.J. Sterpe, </author> <title> Tempest: A Template Editor for Structured Text, </title> <institution> MIT Artificial Intelligence Laboratory technical report MIT/AI/TR-843, </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: An obvious way to make conversion between program text and the internal representation used by a cliche-based editor extremely simple is to use program text as the internal representation. This approach was explored by the Tempest system <ref> [23] </ref> described in Section 4. Tempest is much simpler and many orders of magnitude faster than kbemacs. <p> In particular, it became apparent that it should be possible to reduce the magnitude of the representation shift (and therefore the system's complexity) significantly, while still retaining most of the system's power. As a radical first experiment in simplifying kbemacs, a system called Tempest <ref> [23] </ref> was constructed that eliminates the representation shift altogether. Tempest succeeds in removing almost all of kbemacs' complexity, but at the price of removing most of kbemacs' power. <p> A non-cliched address is typed using the general schema address, which has the same roles as Doctor Smith, but no default values. Figures 26-28 show a transcript of Tempest being used to compose a letter. (A much larger transcript appears in <ref> [23] </ref>.) In Figure 26, the user begins by inserting an instance of the simple letter schema.
Reference: [24] <author> Y.M. Tan, </author> <title> Ace: A Cliche-Based Program Structure Editor, </title> <institution> MIT Artificial Intelligence Laboratory working paper MIT/AI/WP-294, </institution> <month> May </month> <year> 1987. </year>
Reference-contexts: Nevertheless, while not useful for program construction, Tempest demonstrates a set of capabilities that could be profitably added to any text editor. The Ace system <ref> [24] </ref> described in Section 5 shows that it is possible to make a compromise between kbemacs and Tempest that comes close to capturing the best features of the two systems. In Ace, cliches are represented as schematic fragments of parse trees. <p> However, the feeling remained that a full shift to plan diagrams was not required. In an attempt to strike a balance between kbemacs and Tempest, a system called Ace <ref> [24] </ref> was constructed that uses specially designed parse trees as its internal representation. Ace has proved to be a very beneficial balance, providing much of the power of kbemacs at only a fraction of the cost. The architecture of Ace is shown in Figure 30. <p> These differences are most easily appreciated by considering Figure 32, which shows the way the parse tree in Figure 31 is displayed by Ace's unparser. (Like most of the figures in this section, Figure 32 is based on a figure from <ref> [24] </ref>; however, a few cosmetic changes have been made to facilitate comparison with the figures in Sections 3 and 4.) (Since a parser module has not yet been implemented, Ace does not support text like easy to do.
Reference: [25] <author> T. Teitelbaum and T. Reps, </author> <title> "The Cornell Program Synthesizer: A Syntax-Directed Programming Environment", </title> <journal> Communications of the ACM, </journal> <volume> 24(9) </volume> <pages> 563-573, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: introduction of support for certain cliched data structures and cliched patterns of control flow. Cliche-based editors. Many program editors are merely text editors and do not capture any knowledge of programming per se. However, some program editors incorporate an understanding of the grammar of a programming language <ref> [2, 4, 6, 11, 20, 18, 25] </ref>. These syntax editors support the manipulation of the few cliches (such as conditional control flow and looping control flow) that correspond to parts of programming language grammars. <p> It would be both practical and valuable to add an editor like Ace to any programming environment. Given that syntax editors have existed for fifteen years or more <ref> [6, 11, 20, 25] </ref> and reuse has been lauded as a key goal of software engineering for much longer than that, it is somewhat surprising that there are not already many editors like Ace.
Reference: [26] <author> R.C. Waters, </author> <title> "A Method for Analyzing Loop Programs", </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 5(3) </volume> <pages> 237-247, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: The computations that eventually fill the print headings and print entry roles are expected to correctly update the value recording the number of lines printed. This is signified in Temporal abstraction. Through the process of temporal abstraction <ref> [16, 26] </ref> plan diagrams represent loops as "compositions" of operations on sequences of values. For example, the main computation in the simple report schema in Figure 8 is represented as the composition of the enumerator and a map.
Reference: [27] <author> R.C. Waters, </author> <title> "Program Editors Should Not Abandon Text Oriented Commands", </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 17(7) </volume> <pages> 39-46, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: It is important that cliche-based editors include the capabilities of syntax editors and text editors, just as it is important for syntax editors to include the capabilities of text editors <ref> [12, 27] </ref>. Cliche-based editors can be compared with other approaches to software reuse (see [3]) along two primary dimensions: expressiveness (the range of things that can be reused) and tailorability (the extent to which the reused items can be altered to fit the circumstances at hand).
Reference: [28] <author> R.C. Waters, </author> <title> "User Format Control in a Lisp Prettyprinter", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(4) </volume> <pages> 513-531, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: While unparsing is just as well understood as parsing, an unparser had to be implemented to enable the ready demonstration of Ace's capabilities. By using the pp Lisp pretty printer [29] (which is an intermediate version of the pretty printers described in <ref> [28] </ref> and [31]) it was possible to implement the unparser in only a few pages of code. As with kbemacs, the concepts underlying Ace are programming-language independent.
Reference: [29] <author> R.C. Waters, </author> <title> PP: A Lisp Pretty Printing System, </title> <institution> MIT Artificial Intelligence Laboratory memo MIT/AIM-816, </institution> <month> December </month> <year> 1984. </year>
Reference-contexts: While unparsing is just as well understood as parsing, an unparser had to be implemented to enable the ready demonstration of Ace's capabilities. By using the pp Lisp pretty printer <ref> [29] </ref> (which is an intermediate version of the pretty printers described in [28] and [31]) it was possible to implement the unparser in only a few pages of code. As with kbemacs, the concepts underlying Ace are programming-language independent.
Reference: [30] <author> R.C. Waters, </author> <title> "The Programmer's Apprentice: A Session With KBEmacs", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(11) </volume> <pages> 1296-1320, </pages> <month> November </month> <year> 1985. </year>
Reference-contexts: Each time a cliche is brought into play, the programmer is free to use the full range of editing operations to adjust it. Representing cliches. The basic feasibility of cliche-based editing was demonstrated some time ago by the Knowledge-Based Editor in Emacs (kbemacs) <ref> [16, 30] </ref>. However, kbemacs is only a demonstration system and would have to be reimplemented with an eye toward efficiency and robustness before it could be used in a commercial setting. <p> Cliche-Based Program Editing 7 3 KBEmacs This section illustrates the power of cliche-based editing, using the Knowledge-Based Editor in Emacs (kbemacs) as an example. Since kbemacs has already been presented elsewhere (see <ref> [15, 16, 30] </ref>), discussion of the details of kbemacs is kept to a minimum. <p> The effect is as if a human assistant were sitting at the standard editor modifying the program text under the direction of the programmer. The examples in this section show kbemacs being used to construct a Lisp program. As illustrated in <ref> [30] </ref>, kbemacs can also be used to construct Ada programs. Lisp examples are used here, because they are briefer than the Ada examples in [30]; they are a good basis for comparison with the examples in Sections 4 and 5; and taken together with the examples in [30], they demonstrate the <p> The examples in this section show kbemacs being used to construct a Lisp program. As illustrated in <ref> [30] </ref>, kbemacs can also be used to construct Ada programs. Lisp examples are used here, because they are briefer than the Ada examples in [30]; they are a good basis for comparison with the examples in Sections 4 and 5; and taken together with the examples in [30], they demonstrate the language independence of kbemacs. schema library * fi ? schema editor syntax editor text editor * Z Z H H H H H Hj <p> As illustrated in <ref> [30] </ref>, kbemacs can also be used to construct Ada programs. Lisp examples are used here, because they are briefer than the Ada examples in [30]; they are a good basis for comparison with the examples in Sections 4 and 5; and taken together with the examples in [30], they demonstrate the language independence of kbemacs. schema library * fi ? schema editor syntax editor text editor * Z Z H H H H H Hj ffi fl plan diagram ? coder analyzer ? * fi program text 8 R.C.
Reference: [31] <author> R.C. Waters, </author> <title> "Pretty Printing", in Common Lisp: </title> <booktitle> the Language, Second Edition, </booktitle> <pages> 748-769, </pages> <editor> G.L. Steele Jr., </editor> <publisher> Digital Press, </publisher> <address> Burlington MA, </address> <year> 1990. </year>
Reference-contexts: While unparsing is just as well understood as parsing, an unparser had to be implemented to enable the ready demonstration of Ace's capabilities. By using the pp Lisp pretty printer [29] (which is an intermediate version of the pretty printers described in [28] and <ref> [31] </ref>) it was possible to implement the unparser in only a few pages of code. As with kbemacs, the concepts underlying Ace are programming-language independent.
Reference: [32] <author> R.C. Waters, </author> <title> "Series", in Common Lisp: </title> <booktitle> the Language, Second Edition, </booktitle> <pages> 923-955, </pages> <editor> G.L. Steele Jr., </editor> <publisher> Digital Press, </publisher> <address> Burlington MA, </address> <year> 1990. </year>
Reference-contexts: By making the manipulation of loops as simple as the manipulation of expressions, it simplifies ever aspect of kbemacs' operation. Conveniently, the concept of temporal abstraction is quite separate from the idea of cliche-based editing and can be supported separately. In particular, a Common Lisp macro package called Series <ref> [32, 33] </ref> has been implemented that makes it possible to represent loops in a functional style, without any loss of efficiency. In addition, a prototype language extension has been implemented for Pascal [33].
Reference: [33] <author> R.C. Waters, </author> <title> "Automatic Transformation of Series Expressions into Loops", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> 13(1), to appear January 1991. </note>
Reference-contexts: By making the manipulation of loops as simple as the manipulation of expressions, it simplifies ever aspect of kbemacs' operation. Conveniently, the concept of temporal abstraction is quite separate from the idea of cliche-based editing and can be supported separately. In particular, a Common Lisp macro package called Series <ref> [32, 33] </ref> has been implemented that makes it possible to represent loops in a functional style, without any loss of efficiency. In addition, a prototype language extension has been implemented for Pascal [33]. <p> In particular, a Common Lisp macro package called Series [32, 33] has been implemented that makes it possible to represent loops in a functional style, without any loss of efficiency. In addition, a prototype language extension has been implemented for Pascal <ref> [33] </ref>. In both cases, the language extensions have proven to be extremely valuable, primarily because they allow a wide range of loop cliches such as vector enumeration to be represented as functions. The other key idea behind kbemacs is the construction of programs by combining schemas representing cliches. <p> In contrast, Ace cannot compose loop schemas and can only insert them in roles specially designed to accept them. (This limitation could be overcome more or less completely by introducing temporal abstraction directly into the programming language being edited, as discussed in <ref> [33] </ref>. There would then be very little need for Ace to manipulate loop cliches.) The various defects of Ace discussed above are best viewed as the price of Ace's simplicity.
Reference: [34] <author> R.C. Waters and Y.M. Tan, </author> <title> "Toward a Design Apprentice: Supporting Reuse and Evolution in Software Design", </title> <booktitle> to appear in ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 16(2), </volume> <month> April </month> <year> 1991. </year>
Reference-contexts: A more general logical representation is required for representing non-algorithmic cliches. Work is currently underway on the construction of a Design Apprentice that will address the problems above and go beyond kbemacs by automating low-level program design <ref> [14, 34] </ref>. With the Design Apprentice, a programmer/designer will outline the basic high-level design, while the system selects the detailed algorithms to use and puts them together into a program.
Reference: [35] <author> L.M. Wills, </author> <title> "Automated Program Recognition: A Feasibility Demonstration", </title> <journal> Artificial Intelligence, </journal> <volume> 45(1-2):113-172, </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: Waters a special feature|whenever a textual change is confined solely to the contents of a single role, kbemacs recognizes that the change is equivalent to filling the role with the indicated text.) Work is currently underway on methods for automatically supporting complete reverse engineering in the general case, see <ref> [17, 35] </ref>. The weaknesses above notwithstanding, kbemacs demonstrates valuable capabilities. However, the evolution of the system has reached the point where the creation of a full-scale prototype requires complete reimplementation. Unfortunately, kbemacs consists of some 40,000 lines of Lisp code and is comparable in complexity to an optimizing compiler. <p> Further, while it appears that this problem can be fixed in the case of kbemacs (see <ref> [17, 35] </ref>), there is little likelihood that it can be fixed in Ace. As above, the central problem is the syntactic rigidity of parse-tree schemas.
Reference: [36] <author> W. Yin, et al, </author> <title> "Software Reusability: a Survey and a Reusability Experiment", </title> <booktitle> Proc. 1987 Fall Joint Computer Conference: Exploring Technology Today and Tomorrow, </booktitle> <pages> 65-72, </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Washington DC, </address> <month> October </month> <year> 1987. </year>
Reference-contexts: Any syntax editor could be trivially extended to support algorithmic schemas that correspond to well-formed syntactic chunks. It appears that this has been tried occasionally (for instance see <ref> [36] </ref>), however, by itself, this is not very useful. The key impediment that blocks typical syntax editors from usefully supporting algorithmic schemas is the grammars they use as the basis for their operation.
Reference: [37] <institution> Lisp Machine documentation (release 4), Symbolics, </institution> <address> Cambridge MA, </address> <year> 1984. </year>
Reference-contexts: The schema library contains a collection of programming cliches represented as plan-diagram schemas. The schema editor can combine schemas chosen from the schema library and manipulate plan diagrams based on their structure in terms of schemas. Since kbemacs is implemented on the Symbolics Lisp Machine <ref> [37] </ref>, the standard Emacs-style [20] Lisp Machine program editor is used as the text editor and syntax editor. The schema editor is integrated with the standard editor so that a common interface is presented to the user.
Reference: [38] <author> Mince, </author> <title> Mark of the Unicorn Inc., </title> <address> Cambridge MA, </address> <year> 1981. </year>
Reference-contexts: The schema editor performs the same kind of simple operations as kbemacs' schema editor|i.e., it can insert and replace instances of schemas in the text being edited and supports simple constraints. Tempest is written as an extension to the commercially available Emacs-style Mince editor <ref> [38] </ref>. The standard facilities of Mince are used to support both text editing and syntax editing.
Reference: [39] <institution> Prograph Technical Specifications, TGS Systems inc., Halifax NS Canada, </institution> <year> 1990. </year>
Reference-contexts: For instance, a graphical programming tool such as Prograph <ref> [39] </ref> could be extended to support cliche-based editing with no more difficulty than Mince was extended to become Tempest.
Reference: [40] <author> Scribe Document Production System, </author> <title> user manual, </title> <publisher> Unilogic Ltd., </publisher> <address> Pittsburgh PA, </address> <year> 1984. </year>
References-found: 40

