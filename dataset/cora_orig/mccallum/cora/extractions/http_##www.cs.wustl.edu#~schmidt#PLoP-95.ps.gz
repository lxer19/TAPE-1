URL: http://www.cs.wustl.edu/~schmidt/PLoP-95.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/TAO-status.html
Root-URL: 
Email: schmidt@cs.wustl.edu and chuck@maria.wustl.edu  
Title: Half-Sync/Half-Async An Architectural Pattern for Efficient and Well-structured Concurrent I/O  
Author: Douglas C. Schmidt and Charles D. Cranor 
Address: St. Louis, MO 63130, (314) 935-7538  
Affiliation: Department of Computer Science Washington University  
Abstract: An earlier version of this paper appeared in a chapter in the book Pattern Languages of Program Design 2 ISBN 0-201-89527-7, edited by John Vlissides, Jim Coplien, and Norm Kerth published by Addison-Wesley, 1996. Abstract This paper describes the Half-Sync/Half-Async pattern, which integrates synchronous and asynchronous I/O models to support both programming simplicity and execution efficiency in complex concurrent software systems. In this pattern, higher-level tasks use a synchronous I/O model, which simplifies concurrent programming. In contrast, lower-level tasks use an asynchronous I/O model, which enhances execution efficiency. This pattern is widely used in operating systems such as UNIX, Mach, Windows NT, and VMS, as well as other complex concurrent systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. J. Leffler, M. McKusick, M. Karels, and J. Quarterman, </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: 1 Intent The Half-Sync/Half-Async pattern decouples synchronous I/O from asynchronous I/O in a system to simplify concurrent programming effort without degrading execution efficiency. 2 Motivation To illustrate the Half-Sync/Half-Async pattern, consider the software architecture of the BSD UNIX <ref> [1] </ref> networking subsystem shown in Figure 1. The BSD UNIX kernel coordinates I/O between asynchronous communication devices (such as network adapters and terminals) and applications running on the OS. Packets arriving on communication devices are delivered to the OS kernel via interrupt handlers initiated asynchronously by hardware interrupts. <p> This approach also provides a buffer management system that allows efficient page remapping and shared memory mechanisms to be used between user processes, the kernel, and its devices. 9 Sample Code This section illustrates examples of the Half-Sync/Half-Async pattern in two different parts of the BSD UNIX operating system <ref> [1] </ref>. These examples illustrate how the Half-Sync/Half-Async pattern is used by the BSD kernel to enable user processes to operate synchronously, while ensuring the kernel operates asynchronously. The first example illustrates how this pattern is used in the networking subsystem to input data through the TCP/IP protocol stack over Ethernet. <p> Micro-kernel operating systems typically use this design. The micro-kernel runs as a separate process that exchanges messages with user processes [11]. 11 Known Uses * The BSD UNIX networking subsystem <ref> [1] </ref> and the original System V UNIX STREAMS communication framework [12] use the Half-Sync/Half-Async pattern to structure the concurrent I/O architecture of user processes and the OS kernel. All I/O in these kernels is asynchronous and triggered by interrupts.
Reference: [2] <author> D. C. Schmidt and T. Suda, </author> <title> Measuring the Performance of Parallel Message-based Process Architectures, </title> <booktitle> in Proceedings of the Conference on Computer Communications (INFO-COM), </booktitle> <address> (Boston, MA), </address> <pages> pp. 624-633, </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1995. </year>
Reference-contexts: Asynchronous I/O enables communication and computation to proceed simultaneously. In addition, context switching overhead is minimized because the amount of information necessary to maintain program state is relatively small <ref> [2] </ref>. Thus, there is a strong incentive to use an asynchronous I/O model to improve run-time performance.
Reference: [3] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-7, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Unlike the Asynchronous layer, tasks in the Synchronous layer are active objects <ref> [3] </ref> that have their own run-time stack and registers. Therefore, they can block while performing synchronous I/O. * Queueing layer (Socket layer) This layer provides a synchronization and buffer ing point between the Synchronous task layer and the Asynchronous task layer. <p> Often, these are long-duration tasks that transfer large streams of data [5] or perform database queries that may block for prolonged periods awaiting responses from servers. Implement these long-duration tasks using an active object model <ref> [3] </ref>. Since active objects have their own run-time stack and registers they can block while performing synchronous I/O. Implementing an active object mechanism requires a method of switching between different threads of control. <p> User processes are synchronous active objects, an Adapter Conduit serves as the Queueing layer, and the Conduit micro-kernel operates asynchronously. 12 Related Patterns * The Synchronous task layer uses the Active Object pat tern <ref> [3] </ref>. * The Asynchronous task layer may use the Reactor pat tern [6] to demultiplex events from multiple sources of events. * The Queueing layer provides a Facade [18] that simpli fies the interface to the Asynchronous task layer of the system. * The Queueing layer is also a Mediator [18]
Reference: [4] <author> N. C. Hutchinson and L. L. Peterson, </author> <title> The x-kernel: An Ar chitecture for Implementing Network Protocols, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, </volume> <pages> pp. 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: A significant performance penalty may be incurred when crossing this boundary. For example, the socket layer in BSD UNIX accounts for a large percentage of the overall TCP/IP networking overhead <ref> [4] </ref>. * Asynchronous I/O for higher-level tasks is lacking. De pending on the design of system interfaces, it may not be possible for higher-level tasks to utilize low-level asynchronous I/O devices.
Reference: [5] <author> D. C. Schmidt, T. H. Harrison, and E. Al-Shaer, </author> <title> Object Oriented Components for High-speed Network Programming, </title> <booktitle> in Proceedings of the 1 st Conference on Object-Oriented Technologies and Systems, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: Often, these are long-duration tasks that transfer large streams of data <ref> [5] </ref> or perform database queries that may block for prolonged periods awaiting responses from servers. Implement these long-duration tasks using an active object model [3]. Since active objects have their own run-time stack and registers they can block while performing synchronous I/O.
Reference: [6] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: To increase efficiency and ensure response-time, these sources of events must be serviced rapidly without blocking. Implement these short-duration tasks using a reactive, passive object model <ref> [6] </ref>. Passive objects borrow their thread of control from elsewhere (such as the caller or a separate interrupt stack). Therefore, these tasks must use asynchronous I/O since they cannot block for long periods of time. <p> The primary motivation for not blocking is to ensure adequate response time for other system tasks (such as high-priority hardware interrupts like clock timers). There are several ways to develop a well-structured framework for asynchronous I/O: * Demultiplex events using the Reactor pattern TheRe- actor pattern <ref> [6] </ref> manages a single-threaded event loop that supports the demultiplexing and dispatching of multiple event handlers, which are triggered concurrently by multiple events. This pattern combines the simplicity of single-threaded event loops with the extensibility 4 offered by object-oriented programming. <p> The Iridium Gateway implements the Half-Sync/Half-Async pattern with the ADAPTIVE Service eXecutive (ASX) framework [15]. The Reactor <ref> [6] </ref> class category from the ASX framework implements an object-oriented demultiplexing and dispatching mechanism that handles events asynchronously. <p> User processes are synchronous active objects, an Adapter Conduit serves as the Queueing layer, and the Conduit micro-kernel operates asynchronously. 12 Related Patterns * The Synchronous task layer uses the Active Object pat tern [3]. * The Asynchronous task layer may use the Reactor pat tern <ref> [6] </ref> to demultiplex events from multiple sources of events. * The Queueing layer provides a Facade [18] that simpli fies the interface to the Asynchronous task layer of the system. * The Queueing layer is also a Mediator [18] that coordi nates the exchange of data between the Asynchronous and Synchronous
Reference: [7] <author> P. Druschel and L. L. Peterson, Fbufs: </author> <title> A High-Bandwidth Cross-Domain Transfer Facility, </title> <booktitle> in Proceedings of the 14 th Symposium on Operating System Principles (SOSP), </booktitle> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: However, this increases system bus and memory load, which may degrade performance significantly when large messages are moved across domains. One way to reduce data copying is to allocate a region of memory that is shared between the Synchronous task layer and the Asynchronous task layer <ref> [7] </ref>. This allows the two layers to exchange data directly, without copying data in the Queueing layer. For example, [8] presents an I/O subsystem that minimizes boundary-crossing penalties by using polled interrupts to improve the handling of continuous media I/O streams.
Reference: [8] <author> C. Cranor and G. Parulkar, </author> <title> Design of Universal Continuous Media I/O, </title> <booktitle> in Proceedings of the 5th International Workshop on Network and Operating Systems Support for Digital Audio and Video (NOSSDAV '95), </booktitle> <address> (Durham, New Hampshire), </address> <pages> pp. 83-86, </pages> <month> Apr. </month> <year> 1995. </year> <month> 10 </month>
Reference-contexts: One way to reduce data copying is to allocate a region of memory that is shared between the Synchronous task layer and the Asynchronous task layer [7]. This allows the two layers to exchange data directly, without copying data in the Queueing layer. For example, <ref> [8] </ref> presents an I/O subsystem that minimizes boundary-crossing penalties by using polled interrupts to improve the handling of continuous media I/O streams. <p> This is useful for implementing polled interrupts, which reduce the amount of context 9 switching for high-performance continuous media systems by dedicating a kernel thread to poll a field in shared memory at regular intervals <ref> [8] </ref>. If the Asynchronous task layer possesses its own thread of control it can run autonomously and use the Queueing layer to pass messages to the Synchronous task layer. Micro-kernel operating systems typically use this design.
Reference: [9] <author> W. R. Stevens, </author> <title> TCP/IP Illustrated, </title> <booktitle> Volume 2. </booktitle> <address> Reading, </address> <publisher> Mas sachusetts: Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Figure 1 illustrates the participants and structure of this pattern in BSD UNIX. For a 5 comprehensive explanation of the BSD UNIX networking subsystem see <ref> [9] </ref>. 9.1.1 Synchronous Invocation Consider a user process that creates a passive-mode TCP stream socket, accepts a connection, and receives TCP data from the connected socket descriptor.
Reference: [10] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: Mi crosoft Press, </address> <year> 1993. </year>
Reference-contexts: This approach is used in the extended signal interface for UNIX System V Release 4. In this case, a buffer pointer is passed along with the signal handler function. Windows NT supports a similar scheme using overlapped I/O and I/O completion ports <ref> [10] </ref>.
Reference: [11] <author> D. L. Black, </author> <title> Scheduling Support for Concurrency and Par allelism in the Mach Operating System, </title> <journal> IEEE Computer, </journal> <volume> vol. 23, </volume> <pages> pp. 23-33, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: If the Asynchronous task layer possesses its own thread of control it can run autonomously and use the Queueing layer to pass messages to the Synchronous task layer. Micro-kernel operating systems typically use this design. The micro-kernel runs as a separate process that exchanges messages with user processes <ref> [11] </ref>. 11 Known Uses * The BSD UNIX networking subsystem [1] and the original System V UNIX STREAMS communication framework [12] use the Half-Sync/Half-Async pattern to structure the concurrent I/O architecture of user processes and the OS kernel. All I/O in these kernels is asynchronous and triggered by interrupts.
Reference: [12] <author> D. Ritchie, </author> <title> A Stream Input-Output System, </title> <journal> AT&T Bell Labs Technical Journal, </journal> <volume> vol. 63, </volume> <pages> pp. 311-324, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: Micro-kernel operating systems typically use this design. The micro-kernel runs as a separate process that exchanges messages with user processes [11]. 11 Known Uses * The BSD UNIX networking subsystem [1] and the original System V UNIX STREAMS communication framework <ref> [12] </ref> use the Half-Sync/Half-Async pattern to structure the concurrent I/O architecture of user processes and the OS kernel. All I/O in these kernels is asynchronous and triggered by interrupts. The Queueing layer is implemented by the Socket layer in BSD and by STREAM heads in System V STREAMS.
Reference: [13] <author> C. Horn, </author> <title> The Orbix Architecture, </title> <type> tech. rep., </type> <institution> IONA Tech nologies, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: This design shields developers from the complexity of asynchronous OS handled by the kernel. There are provisions for notifications (via the SIGIO signal) that asynchronously trigger synchronous I/O. * The multi-threaded version of Orbix 1.3 (MT-Orbix) <ref> [13] </ref> uses several variations of the Half-Sync/Half-Async pattern to dispatch CORBA remote operations in a concurrent server. In the Asynchronous layer of MT-Orbix a separate thread is associated with each HANDLE that is connected to a client. Each thread blocks synchronously reading CORBA requests from the client.
Reference: [14] <author> D. C. Schmidt, </author> <title> A Family of Design Patterns for Application level Gateways, </title> <journal> The Theory and Practice of Object Systems (Special Issue on Patterns and Pattern Languages), </journal> <volume> vol. 2, no. 1, </volume> <year> 1996. </year>
Reference-contexts: active object thread in the Synchronous layer then wakes up, dequeues the request, and processes it to completion by performing an upcall on the CORBA object implementation. * The Motorola Iridium system uses the Half-Sync/Half Async pattern in an application-level Gateway that routes messages between satellites and ground control stations <ref> [14] </ref>. The Iridium Gateway implements the Half-Sync/Half-Async pattern with the ADAPTIVE Service eXecutive (ASX) framework [15]. The Reactor [6] class category from the ASX framework implements an object-oriented demultiplexing and dispatching mechanism that handles events asynchronously.
Reference: [15] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: The Iridium Gateway implements the Half-Sync/Half-Async pattern with the ADAPTIVE Service eXecutive (ASX) framework <ref> [15] </ref>. The Reactor [6] class category from the ASX framework implements an object-oriented demultiplexing and dispatching mechanism that handles events asynchronously.
Reference: [16] <author> J. M. Zweig, </author> <title> The Conduit: a Communication Abstraction in C++, </title> <booktitle> in Proceedings of the 2 nd USENIX C++ Conference, </booktitle> <pages> pp. 191-203, </pages> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: The Reactor [6] class category from the ASX framework implements an object-oriented demultiplexing and dispatching mechanism that handles events asynchronously. The ASX Message Queue class implements the Queueing layer, and the ASX Task class implements active objects in the Synchronous task layer. * The Conduit communication framework <ref> [16] </ref> from the Choices OS project [17] implements an object-oriented version of the Half-Sync/Half-Async pattern.
Reference: [17] <author> R. Campbell, N. Islam, D. Raila, and P. Madany, </author> <title> Designing and Implementing Choices: an Object-Oriented System in C++, </title> <journal> Communications of the ACM, </journal> <volume> vol. 36, </volume> <pages> pp. 117-126, </pages> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: The ASX Message Queue class implements the Queueing layer, and the ASX Task class implements active objects in the Synchronous task layer. * The Conduit communication framework [16] from the Choices OS project <ref> [17] </ref> implements an object-oriented version of the Half-Sync/Half-Async pattern.
Reference: [18] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year> <month> 11 </month>
Reference-contexts: Queueing layer, and the Conduit micro-kernel operates asynchronously. 12 Related Patterns * The Synchronous task layer uses the Active Object pat tern [3]. * The Asynchronous task layer may use the Reactor pat tern [6] to demultiplex events from multiple sources of events. * The Queueing layer provides a Facade <ref> [18] </ref> that simpli fies the interface to the Asynchronous task layer of the system. * The Queueing layer is also a Mediator [18] that coordi nates the exchange of data between the Asynchronous and Synchronous task layers. <p> [3]. * The Asynchronous task layer may use the Reactor pat tern [6] to demultiplex events from multiple sources of events. * The Queueing layer provides a Facade <ref> [18] </ref> that simpli fies the interface to the Asynchronous task layer of the system. * The Queueing layer is also a Mediator [18] that coordi nates the exchange of data between the Asynchronous and Synchronous task layers. Acknowledgements We would like to thank Lorrie Cranor and Paul McKenney for comments and suggestions for improving this paper.
References-found: 18

