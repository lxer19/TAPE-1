URL: http://www-cgi.cs.cmu.edu/afs/cs/project/able/ftp/wright-tosem97.ps
Refering-URL: 
Root-URL: 
Title: A Formal Basis for Architectural Connection  
Author: Robert Allen David Garlan 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: January 1997  
Abstract: This research was sponsored by the National Science Foundation under Grant Number CCR-9357792, by the Wright Laboratory, Aeronautical Systems Center, Air Force Materiel Command, USAF, and the Advanced Research Projects Agency (ARPA) under grant number F33615-93-1-1330, and by Siemens Corporate Research. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of Wright Laboratory, the U.S. Government, or Siemens Corporation. The U.S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation thereon. 
Abstract-found: 1
Intro-found: 1
Reference: [AAG95] <author> Gregory Abowd, Robert Allen, and David Garlan. </author> <title> Formalizing style to understand descriptions of software architecture. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> October </month> <year> 1995. </year>
Reference-contexts: Such sets of design rules are sometimes called architectural styles. In particular, stylistic rules typically determine a vocabulary of component and connector types, topological constraints, and constraints on the nature of the computations that can performed <ref> [AAG95] </ref>. As presented in this paper, Wright goes part way towards defining styles by allowing the definition of component and connector types. But it does not allow one to state topological constraints or other global, semantically-based constraints.
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: First, we have restricted the notation such that our processes will always be finite. (Of course, infinite traces are still possible even though we can't create an infinite number of processes.) This means that we can use tools for exhaustive state exploration (such as model checkers) <ref> [BCM + 90] </ref> to verify properties of the processes and to check relationships between processes. Second, we have expressed our checks as refinement tests on simple functions of the described processes.
Reference: [BR85] <author> S.D. Brookes and A.W. Roscoe. </author> <title> An improved failures model for communicating pro-cesses. </title> <booktitle> In Proceedings NSF-SERC Seminar on Concurrency. Springer Verlag, Lecture notes in Computers Science, </booktitle> <year> 1985. </year>
Reference-contexts: Moreover, to the extent that deadlock provides a good model for what can go wrong when components interact, CSP is provably the right semantic model, since formally, it is fully abstract with respect to deadlock freedom of communicating processes <ref> [BR85] </ref>. Second is the need for a simple but powerful form of composition. Architecture is inherently about putting parts together to make larger systems. CSP's parallel composition operator works particularly well in this regard.
Reference: [C + 86] <author> E. Clarke et al. </author> <title> Automatic verification of finite state concurrent systems using temporal logic specifications. </title> <journal> TOPLAS, </journal> <volume> 8(2), </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: and (2) the need for distinguished connector semantics. 11.1 Why CSP? An obvious question is why use CSP to specify connector protocols? Why not use an alternative, possibly simpler, notation and model of concurrency? We investigated several alternative approaches including several state machines models (I/O Automata [LT88], StateCharts [Har87], SMV <ref> [C + 86] </ref>, and SDL [Hol91]), Petri Nets [Pet77], and regular expressions. While these systems have been used to model protocols and have well-defined mechanisms for composition, we favor the use of CSP for three reasons.
Reference: [Cam89] <author> John Cameron. </author> <title> JSP and JSD: the Jackson Approach to Software Development. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference-contexts: These languages increase their analytic and expressive leverage by specializing to a particular family of systems, thereby trading generality for power. Finally, over the past decade numerous software design languages have been proposed|many of them graphical. These are concerned with the gross decomposition of systems (for example, <ref> [Cam89] </ref>). As with domain-specific approaches to software architecture, such notations often provide 28 strong support for certain classes of systems. But they do not provide general mechanisms for formal description or analysis of architectural connection.
Reference: [DAR90] <institution> Proceedings of the Workshop on Domain-Specific Software Architectures, </institution> <address> Hidden Vallen, PA, </address> <month> July </month> <year> 1990. </year> <institution> Software Engineering Institute. </institution>
Reference-contexts: Other architectural description languages have been proposed for specialized domains <ref> [MG92, DAR90] </ref>. These languages increase their analytic and expressive leverage by specializing to a particular family of systems, thereby trading generality for power. Finally, over the past decade numerous software design languages have been proposed|many of them graphical. These are concerned with the gross decomposition of systems (for example, [Cam89]).
Reference: [EFRV86] <author> Gerald Estrin, Robert S. Fenchell, Rami R. Razouk, and Mary K. Vernon. Sara (sys-tem architects apprentice): </author> <title> Modelling, analysis, and simulation support for design of concurrent systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(2):293-311, </volume> <month> February </month> <year> 1986. </year> <month> 32 </month>
Reference-contexts: However, while UniCon provides placeholders for formal specification of connectors, it does not itself support any particular formal notation. In that sense Wright and UniCon are complementary: our connector specifications could be combined with the overall architectural descriptive notation of UniCon. Another closely related system is the SARA System <ref> [EFRV86] </ref>. It was developed as a method and toolset for design of system architectures for concurrent systems.
Reference: [FDR92] <editor> Failures Divergence Refinement: </editor> <title> User Manual and Tutorial. Formal Systems (Europe) Ltd., </title> <publisher> Oxford, </publisher> <address> England, 1.2fi edition, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: This permits us to apply the emerging technology of automated verification tools to make these checks. To illustrate, we show how we can check the compatibility of DataRead with the role User using FDR <ref> [FDR92] </ref>, a commercial tool that can check refinement conditions for finite CSP processes. First, to use FDR we must translate our notation to fit the variant of CSP used in this tool.
Reference: [Gar95] <editor> David Garlan, editor. </editor> <booktitle> Proceedings of the First International Workshop on Architectures for Software Systems, </booktitle> <address> Seattle, WA, </address> <month> April </month> <year> 1995. </year> <note> Published as CMU Technical Report CMU-CS-95-151, </note> <month> April </month> <year> 1995. </year>
Reference-contexts: Moreover, it is a view that is shared by almost all recent work in architectural representation <ref> [Gar95, IEE95] </ref>. As a simple example, consider a system organized around a client-server relationship. The components consist of a server and a set of clients. The connectors determine the interactions that can take place between the clients and the server. In particular, they specify how each client accesses the server.
Reference: [GG95] <author> Peter Green and Terry Griffin. </author> <title> Specification for the RTIS HLA/RTI implementation. </title> <type> Technical Report RTIS10951, </type> <institution> The Real-Time Intelligent Systems Corporation, </institution> <address> Westborough, MA, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: We'll return to this issue in Section 10.) A more "industrial-strength" example of a connector, which we will not show here, is the U.S. Department of Defense's "High-Level Architecture for Distributed Simulations (HLA)" <ref> [GG95] </ref>. HLA is intended to support the coordination of different simulations. HLA defines a standard for the coordination of simulations through the communication of data object attributes and events.
Reference: [Har87] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> (8), </volume> <year> 1987. </year>
Reference-contexts: underlying semantics; and (2) the need for distinguished connector semantics. 11.1 Why CSP? An obvious question is why use CSP to specify connector protocols? Why not use an alternative, possibly simpler, notation and model of concurrency? We investigated several alternative approaches including several state machines models (I/O Automata [LT88], StateCharts <ref> [Har87] </ref>, SMV [C + 86], and SDL [Hol91]), Petri Nets [Pet77], and regular expressions. While these systems have been used to model protocols and have well-defined mechanisms for composition, we favor the use of CSP for three reasons.
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: Specif- ically, we describe a formal system for specifying architectural connector types. The description of these connector types is based on the idea of characterizing the protocols of interaction between architectural components. The formal underpinnings for protocol definition are provided by CSP <ref> [Hoa85] </ref>. Of course the use of protocols as a mechanism for describing interactions between parts of a system is not new. However, as we will show, there are three important innovations in our application of this general idea to architectural description. <p> But how do we characterize a "behavior," and how do we describe the range of "behaviors" that can occur? Our approach is to describe these behaviors as interacting protocols. We use a process algebra to model traces of communication events. Specifically, we use a subset of CSP <ref> [Hoa85] </ref> to define the protocols of the roles, ports and glue. (Later we will also use CSP as the semantic model to define the semantics of a Wright specification.) While CSP has a rich set of constructs for describing communicating entities, we will use a small, but non-trivial, subset of these, <p> In CSP this informal notion is captured formally by means of a "refinement relationship" between processes. Formally, refinement is based on the characterization of a processes as the triple (A; F ; D) of alphabet, failures and divergences (cf., Section 5.1 or <ref> [Hoa85, chapter 3] </ref>). A process P is refined by process Q, written P v Q, if their alphabets are the same, the failures of P are a subset of the failures of Q, and the divergences of P are a subset of the divergences of Q.
Reference: [Hol91] <author> Gerald J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: distinguished connector semantics. 11.1 Why CSP? An obvious question is why use CSP to specify connector protocols? Why not use an alternative, possibly simpler, notation and model of concurrency? We investigated several alternative approaches including several state machines models (I/O Automata [LT88], StateCharts [Har87], SMV [C + 86], and SDL <ref> [Hol91] </ref>), Petri Nets [Pet77], and regular expressions. While these systems have been used to model protocols and have well-defined mechanisms for composition, we favor the use of CSP for three reasons. First is our concern with being able to capture certain critical properties of architectural connection.
Reference: [IEE95] <institution> Special issue on software architecture. </institution> <note> IEEE Transactions on Software Engineering, 21(4), </note> <month> April </month> <year> 1995. </year>
Reference-contexts: Moreover, it is a view that is shared by almost all recent work in architectural representation <ref> [Gar95, IEE95] </ref>. As a simple example, consider a system organized around a client-server relationship. The components consist of a server and a set of clients. The connectors determine the interactions that can take place between the clients and the server. In particular, they specify how each client accesses the server.
Reference: [IW95] <author> Paola Inverardi and Alex Wolf. </author> <title> Formal specification and analysis of software archi-tectures using the chemical, abstract machine model. </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Software Architecture, </journal> <volume> 21(4) </volume> <pages> 373-386, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Darwin [MDEK95] uses the Pi Calculus [MPW92] as its basis, a formalism specifically designed to handle mobile processes. Architectural dynamism has also been modelled using the Chemical Abstract Machine as the underlying formalism <ref> [IW95] </ref>. Style An important property of many architectural descriptions is that they conform to a set of design rules that allow specialized analyses to be performed.
Reference: [Jac89] <author> Jeremy Jacob. </author> <title> Refinement of shared systems. </title> <editor> In John A. McDermid, editor, </editor> <booktitle> The Theory and Practice of Refinement. </booktitle> <publisher> Butterworths, </publisher> <year> 1989. </year>
Reference-contexts: There has been some work that, like ours, exploits the fact that in a constrained situation the criteria of refinement can be weakened without compromising substitutability (e.g., <ref> [Jac89, LM86] </ref>). That work focusses on how proofs of satisfaction of specifications can be structured through compositional proof techniques. In order to achieve this effect, they consider the question of whether refinement holds in a particular context.
Reference: [Jif90] <author> He Jifeng. </author> <title> Specification and design of the X.25 protocol: A case study in csp. In C.A.R. Hoare, editor, Developments in Concurrency and Communication. </title> <address> AddisonWesley, </address> <year> 1990. </year>
Reference-contexts: The reader should not assume that this indicates an inability of CSP to scale to realistic inter-component protocols. For example, see <ref> [Jif90] </ref> for a representative larger application of CSP to protocol definition. Also see Section 11. 10 the glue). In other words, the server is not allowed to terminate unless the environment in which it is operating "requests" termination.
Reference: [LM86] <author> Kim G. Larsen and Robin Milner. </author> <title> A complete protocol verification using relativized bisumulation. </title> <type> Technical Report ECS-LFCS-86-13, </type> <institution> University of Edinburgh Laboratory for Foundations of Computer Science, </institution> <month> September </month> <year> 1986. </year>
Reference-contexts: There has been some work that, like ours, exploits the fact that in a constrained situation the criteria of refinement can be weakened without compromising substitutability (e.g., <ref> [Jac89, LM86] </ref>). That work focusses on how proofs of satisfaction of specifications can be structured through compositional proof techniques. In order to achieve this effect, they consider the question of whether refinement holds in a particular context.
Reference: [LS94] <author> Simon S. Lam and A. Uday Shankar. </author> <title> A theory of interfaces and modules i|compostion theorem. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(1), </volume> <month> January </month> <year> 1994. </year>
Reference-contexts: Some (such as [Per87]) are also concerned with increasing the semantic content and the checkability of interfaces, and to that extent they share some of our general goals. Recent work by Lam and Shankar <ref> [LS94] </ref> has used protocols to provide higher level guarantees about the correct composition of modules.
Reference: [LT88] <author> Nancy A. Lynch and Mark R. Tuttle. </author> <title> An introduction to input/output automata. </title> <type> Technical Report MIT/LCS/TM-373, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1988. </year>
Reference-contexts: notation and underlying semantics; and (2) the need for distinguished connector semantics. 11.1 Why CSP? An obvious question is why use CSP to specify connector protocols? Why not use an alternative, possibly simpler, notation and model of concurrency? We investigated several alternative approaches including several state machines models (I/O Automata <ref> [LT88] </ref>, StateCharts [Har87], SMV [C + 86], and SDL [Hol91]), Petri Nets [Pet77], and regular expressions. While these systems have been used to model protocols and have well-defined mechanisms for composition, we favor the use of CSP for three reasons.
Reference: [LVB + 92] <author> David C. Luckham, James Vera, Doug Bryan, Larry Augustin, and Frank Belz. </author> <title> Partial orderings of event sets and their application to prototyping concurrent timed systems, </title> <month> March </month> <year> 1992. </year> <month> 33 </month>
Reference-contexts: One might well question the need for both components and connectors: why not instead have only components, with connectors represented as special kinds of components? Other architectural description languages have adopted this latter approach. For example, Rapide <ref> [LVB + 92] </ref> uses events to characterize component interaction, but, unlike Wright, provides a fixed set of connector types to characterize how events flow between components. <p> This asymmetry reflects the definition/use orientation of their work. Finally, they use the distinction between input and output events to capture the assumption/promise dichotomy, while we use the distinction between external and internal choice. Description of Software Architecture A number of other architectural representation languages have been proposed. Rapide <ref> [LVB + 92] </ref> uses Posets as a formal basis for architectural description, and supports certain static interface checks, as well as dynamic checks for satisfaction of predicates over system traces.
Reference: [MDEK95] <author> J. Magee, N. Dulay, S. Eisenbach, and J. Kramer. </author> <title> Specifying distributed software architectures. </title> <booktitle> In Proceedings of the Fifth European Software Engineering Conference, </booktitle> <address> ESEC'95, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Some progress has been made by others. Rapide allows the dynamic creation of components, much as traditional object-oriented system can dynamically create new instances of objects. Darwin <ref> [MDEK95] </ref> uses the Pi Calculus [MPW92] as its basis, a formalism specifically designed to handle mobile processes. Architectural dynamism has also been modelled using the Chemical Abstract Machine as the underlying formalism [IW95].
Reference: [MG92] <author> Erik Mettala and Marc H. Graham. </author> <title> The domain-specific software architecture program. </title> <type> Technical Report CMU/SEI-92-SR-9, </type> <institution> Carnegie Mellon Software Engineering Institute, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Other architectural description languages have been proposed for specialized domains <ref> [MG92, DAR90] </ref>. These languages increase their analytic and expressive leverage by specializing to a particular family of systems, thereby trading generality for power. Finally, over the past decade numerous software design languages have been proposed|many of them graphical. These are concerned with the gross decomposition of systems (for example, [Cam89]).
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes. </title> <journal> Journal of Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: Some progress has been made by others. Rapide allows the dynamic creation of components, much as traditional object-oriented system can dynamically create new instances of objects. Darwin [MDEK95] uses the Pi Calculus <ref> [MPW92] </ref> as its basis, a formalism specifically designed to handle mobile processes. Architectural dynamism has also been modelled using the Chemical Abstract Machine as the underlying formalism [IW95].
Reference: [Nie93] <author> Oscar Nierstrasz. </author> <title> Regular types for active objects. </title> <booktitle> In OOPSLA '93, volume 28 of ACM Sigplan Notices, </booktitle> <pages> pages 1-15, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Thus, the context is constructed from the processes to be compared, rather than being independent of those processes. Another related use of protocols is in work on extending object-oriented systems with protocols over an object's methods. For example, Nierstrasz <ref> [Nie93] </ref> extends object class definitions to include a finite-state process over the methods of the object, and defines a subtyping relation and instantiation rules that are similar to our ideas of compatibility. While the motivation is similar to ours, Nierstrasz considers only one kind of component interaction: method invocation.
Reference: [Nii86] <author> H. Penny Nii. </author> <title> Blackboard systems Parts 1 & 2. </title> <journal> AI Magazine, </journal> <pages> 7 nos 3 (pp. 38-53) and 4 (pp. 62-69), </pages> <year> 1986. </year>
Reference-contexts: Although we have illustrated our points in terms of pipe and filter systems, a similar story could be told for any of the many other architectural idioms and styles that are used to characterize systems: client-server organizations, blackboard systems, interpreters, etc. For example, a blackboard system <ref> [Nii86] </ref>, consisting of a central blackboard repository and a set of knowledge sources, would look quite different in the two views. A definition/use description would typically expose the implementation dependencies between modules representing knowledge sources, and the data structures that characterize the data stored in the blackboard.
Reference: [PDN86] <author> Ruben Prieto-Diaz and James M. Neighbors. </author> <title> Module interconnection languages. </title> <journal> The Journal of Systems and Software, </journal> <volume> 6(4) </volume> <pages> 307-334, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: A key issue in design of a MIL/IDL is the nature of that glue. Currently the predominant form of composition is based on definition/use bindings <ref> [PDN86] </ref>. In this model each module defines or provides a set of facilities that are available to other modules, and uses or requires facilities provided by other modules.
Reference: [Per87] <author> Dewayne E. Perry. </author> <title> Software interconnection models. </title> <booktitle> In Proceedings of the Ninth International Conference on Software Engineering, </booktitle> <pages> pages 61-68, </pages> <address> Monterey, CA, March 1987. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Moreover, the description of these interactions includes specification of dynamic behavior (i.e., protocols). The inclusion of dynamic properties allows more properties to be checked than, say, signature matching alone. Recent research on module interconnection has introduced a number of new mechanisms and richer notions of module interconnection <ref> [Per87, Pur94, Rei90] </ref>. These primarily serve to extend 27 the basic vocabulary of connection, rather than to give ways to define new kinds of connection (as does our work). <p> These primarily serve to extend 27 the basic vocabulary of connection, rather than to give ways to define new kinds of connection (as does our work). Some (such as <ref> [Per87] </ref>) are also concerned with increasing the semantic content and the checkability of interfaces, and to that extent they share some of our general goals. Recent work by Lam and Shankar [LS94] has used protocols to provide higher level guarantees about the correct composition of modules.
Reference: [Pet77] <author> J.L. Peterson. </author> <title> Petri nets. </title> <journal> ACM Computing Surveys, </journal> <volume> 9(3) </volume> <pages> 223-252, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: 11.1 Why CSP? An obvious question is why use CSP to specify connector protocols? Why not use an alternative, possibly simpler, notation and model of concurrency? We investigated several alternative approaches including several state machines models (I/O Automata [LT88], StateCharts [Har87], SMV [C + 86], and SDL [Hol91]), Petri Nets <ref> [Pet77] </ref>, and regular expressions. While these systems have been used to model protocols and have well-defined mechanisms for composition, we favor the use of CSP for three reasons. First is our concern with being able to capture certain critical properties of architectural connection.
Reference: [Pur94] <author> James M. Purtilo. </author> <title> The POLYLITH software bus. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 151-174, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Moreover, the description of these interactions includes specification of dynamic behavior (i.e., protocols). The inclusion of dynamic properties allows more properties to be checked than, say, signature matching alone. Recent research on module interconnection has introduced a number of new mechanisms and richer notions of module interconnection <ref> [Per87, Pur94, Rei90] </ref>. These primarily serve to extend 27 the basic vocabulary of connection, rather than to give ways to define new kinds of connection (as does our work).
Reference: [Rei90] <author> S.P. Reiss. </author> <title> Connecting tools using message passing in the Field Environment. </title> <journal> IEEE Software, </journal> <volume> 7(4) </volume> <pages> 57-66, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Moreover, the description of these interactions includes specification of dynamic behavior (i.e., protocols). The inclusion of dynamic properties allows more properties to be checked than, say, signature matching alone. Recent research on module interconnection has introduced a number of new mechanisms and richer notions of module interconnection <ref> [Per87, Pur94, Rei90] </ref>. These primarily serve to extend 27 the basic vocabulary of connection, rather than to give ways to define new kinds of connection (as does our work).
Reference: [RT89] <author> Tom Reps and Tim Teitelbaum. </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: We have done so with using the a Synthesizer Generator structure editor for Wright as a front end, and implementing the transformations using the attribute grammars provided by the tool <ref> [RT89] </ref>. The only non-trivial part is calculating det (P ) for a process P . 10 Roughly, the construction of det (P ) is carried out by replacing all occurrences of u with as we have shown in our example.
Reference: [SDK + 95] <author> Mary Shaw, Robert DeLine, Daniel V. Klein, Theodore L. Ross, David M. Young, and Gregory Zelesnik. </author> <title> Abstractions for software architecture and tools to support them. </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Software Architecture, </journal> <volume> 21(4) </volume> <pages> 314-335, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: As we have noted, in Rapide connectors are modeled by defining new kinds of components, whereas in Wright connectors function as composition operators. The UniCon language <ref> [SDK + 95] </ref> is similar in spirit to Wright. In particular, UniCon shares the notion that connectors are first class entities defined, in part, by a set of roles. However, while UniCon provides placeholders for formal specification of connectors, it does not itself support any particular formal notation.
Reference: [SG95] <author> Mary Shaw and David Garlan. </author> <title> Formulations and formalisms in software architecture. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Computer Science Today: Recent Trends and Developments, Lecture Notes in Computer Science, </booktitle> <volume> Volume 1000. </volume> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: On the other hand, if the primary function is to provide a vehicle of expression that matches the intuitions and practices of users, then a language should aspire to reflect those intuitions and practices <ref> [SG95] </ref>. 26 We view Wright as fitting the latter mold. Although the ability to reason about an architec-tural specification is key, our first concern has been to provide a good match to the abstractions that are used by practitioners who routinely need to describe software architectures.
Reference: [SG96] <author> Mary Shaw and David Garlan. </author> <title> Software Architecture: Perspectives on an Emerging Discipline. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year> <month> 34 </month>
Reference-contexts: 1 Introduction For complex software systems the overall system structure|or software architecture|emerges as a critical design problem. Design issues at this level include gross organization and control structure, assignment of functionality to computational units, and high-level interactions between these units <ref> [SG96] </ref>. The importance of software architecture for practicing software engineers is highlighted by the ubiquitous use of architectural descriptions in system documentation. Most software systems contain a description of the system in terms such as "client-server organization," "layered system," "blackboard architecture," etc.
Reference: [Sha93] <author> Mary Shaw. </author> <title> Procedure calls are the assembly language of system interconnection: Connectors deserve first-class status. </title> <booktitle> In Proceedings of the Workshop on Studies of Software Design, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Whereas the implementation relationship is concerned with how a component achieves its computation, the 2 interaction relationship determines how that computation is combined with others in the overall system. Thus the abstractions associated with interactions reflect the diverse and potentially complex patterns of communication that characterize architectural descriptions <ref> [Sha93] </ref>. Second, they involve different ways of reasoning about the system. In the case of implementation relationships, reasoning typically proceeds hierarchically: the correctness of one module depends on the correctness of the modules that it uses.
Reference: [YS94] <author> Daniel M. Yellin and Robert E. Strom. </author> <title> Interfaces, protocols, and the semi-automatic construction of software adaptors. </title> <booktitle> Proceedings of OOPSLA'94, </booktitle> <month> October </month> <year> 1994. </year> <month> 35 </month>
Reference-contexts: While the motivation is similar to ours, Nierstrasz considers only one kind of component interaction: method invocation. Moreover, the refinement relations that define subtyping and instantiation differ from our tests in that they are specific to a single class of interaction. Yellin <ref> [YS94] </ref> also defines a model of object composition based on protocols. He provides a more restrictive definition of object compatibility and then increases the flexibility of the model using software adaptors.
References-found: 37

