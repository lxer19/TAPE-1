URL: http://www.cs.bu.edu/techreports/93-017-finite-rank.ps.gz
Refering-URL: http://cs-www.bu.edu/techreports/Home.html
Root-URL: 
Email: kfoury@cs.bu.edu  jbw@cs.bu.edu  
Title: A Direct Algorithm for Type Inference in the Rank 2 Fragment of the Second-Order -Calculus  
Author: A. J. Kfoury J. B. Wells 
Note: This work is partly supported by NSF grant CCR-9113196.  
Date: December 1, 1993  
Address: Boston University  
Affiliation: Dept. of Computer Science Boston University  Dept. of Computer Science  
Abstract: Boston University Computer Science Department Technical Report 93-017 Abstract We study the problem of type inference for a family of polymorphic type disciplines containing the power of Core-ML. This family comprises all levels of the stratification of the second-order lambda-calculus by "rank" of types. We show that typability is an undecidable problem at every rank k 3 of this stratification. While it was already known that typability is decidable at rank 2, no direct and easy-to-implement algorithm was available. To design such an algorithm, we develop a new notion of reduction and show how to use it to reduce the problem of typability at rank 2 to the problem of acyclic semi-unification. A by-product of our analysis is the publication of a simple solution procedure for acyclic semi-unification. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> Relevant documents not cited in the main text are [KMM90, Tiu90, Hen88]. </institution>
Reference: [Dow93] <author> G. Dowek. </author> <title> The undecidability of typability in the -calculus. </title> <booktitle> In TLCA [TLCA93], </booktitle> <pages> pp. 139-145. </pages>
Reference-contexts: Other related systems that are not exactly extensions of ML have also recently been proven to have undecidable typability, i.e. System F which relates to object-oriented languages [Pie92], and the -calculus which relates to extensions of -Prolog <ref> [Dow93] </ref>. Against this recent background, it is desirable to demarcate precisely where the boundary between decidable and undecidable typability lies within various stratifications of System F.
Reference: [Gir72] <institution> J.-Y. Girard. Interpretation Fonctionelle et Elimination des Coupures de l'Arithmetique d'Ordre Superieure. These de Doctorat d'Etat, Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Over the years, this line of research has dealt with various polymorphic type systems for functional languages and -calculi, in particular the powerful type system of the Girard/Reynolds second-order -calculus <ref> [Gir72, Rey74] </ref>, which we will call by its other name, System F. In the long quest to settle the type checking and typability problems for F, researchers have also considered the problem for F modified by various restrictions.
Reference: [GMW79] <author> M. J. Gordon, R. Milner, and C. P. </author> <title> Wadsworth. </title> <journal> Edinburgh LCF, </journal> <volume> vol. </volume> <publisher> 78 of LNCS. Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Polymorphism lets the programmer write polymorphic functions that work uniformly on arguments of different types and avoids the maintenance problem that results from duplicating similar code at different types. The first programming language to use polymorphic type inference was the functional language ML <ref> [GMW79, Mil85] </ref>. Due to its usefulness, many of the aspects of ML have been subsequently incorporated in other languages (e.g. Miranda [Tur85]). ML shares with Algol 68 properties of compile-time type checking, strong typing and higher-order functions while also providing type inference and polymorphism.
Reference: [GRDR91] <author> P. Giannini and S. Ronchi Della Rocca. </author> <title> Type inference in polymorphic type discipline. </title> <journal> In Theoretical Aspects Comput. Softw. : Int'l Conf., </journal> <volume> vol. </volume> <booktitle> 526 of LNCS, </booktitle> <pages> pp. 18-37. </pages> <publisher> Springer-Verlag, </publisher> <month> Sept. </month> <pages> 24-27, </pages> <year> 1991. </year>
Reference-contexts: In the long quest to settle the type checking and typability problems for F, researchers have also considered the problem for F modified by various restrictions. Multiple stratifications of F have been proposed, e.g. by depth of bound type variable from binding quantifier in <ref> [GRDR91] </ref> and by limiting the number of generations of instantiation of quantifiers themselves introduced by instantiation in [Lei91].
Reference: [Hen88] <author> F. Henglein. </author> <title> Type inference and semi-unification. </title> <booktitle> In Proc. 1988 ACM Conf. LISP Funct. Program., </booktitle> <address> Snowbird, Utah, U.S.A., </address> <month> July 25-27, </month> <year> 1988. </year> <note> ACM. </note>
Reference: [KMM90] <author> P. Kanellakis, H. Mairson, and J. C. Mitchell. </author> <title> Unification and ML type reconstruction. </title> <booktitle> In Computational Logic: Essays in Honor of Alan Robinson. </booktitle> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: [KT92] <author> A. J. Kfoury and J. Tiuryn. </author> <title> Type reconstruction in finite-rank fragments of the second-order -calculus. </title> <journal> Inf. Comput., </journal> <volume> 98(2) </volume> <pages> 228-257, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: One natural restriction which we consider in this paper results from stratifying F according to the "rank" of types allowed in the typing of -terms and restricting the rank to various finite values (introduced in [Lei83] and further studied in <ref> [McC84, KT92] </ref>). All of these systems improve on the expressive power of ML. Unfortunately, it is often the case that the more flexible and powerful a particular polymorphic type system is, the more likely that it will be infeasible to implement. <p> type checking at rank 3 can be seen by observing that the proof for the undecidability of type checking in F in [Wel93] requires only rank-3 types. 1 The undecidability of typability at rank 3 results from the fact that the constants c and f defined in section 5 of <ref> [KT92] </ref> can be encoded using the methods of [Wel93] in System fl 3 (the rank-3 fragment of F) and from Theorem 30 of [KT92]. We give this encoding in this paper. Since it was already known from [KT92] that typability is decidable for System fl 2 (the rank-2 fragment of F), <p> requires only rank-3 types. 1 The undecidability of typability at rank 3 results from the fact that the constants c and f defined in section 5 of <ref> [KT92] </ref> can be encoded using the methods of [Wel93] in System fl 3 (the rank-3 fragment of F) and from Theorem 30 of [KT92]. We give this encoding in this paper. Since it was already known from [KT92] that typability is decidable for System fl 2 (the rank-2 fragment of F), we know exactly where the boundary of decidability for typability lies. <p> the fact that the constants c and f defined in section 5 of <ref> [KT92] </ref> can be encoded using the methods of [Wel93] in System fl 3 (the rank-3 fragment of F) and from Theorem 30 of [KT92]. We give this encoding in this paper. Since it was already known from [KT92] that typability is decidable for System fl 2 (the rank-2 fragment of F), we know exactly where the boundary of decidability for typability lies. These circumstances lead us to look for a simple and direct algorithm for type inference within fl 2 . <p> A later extended version of this paper will clarify the relationship between ML-typability and typability in fl 2 and discuss the issues of type checking and principal types in fl 2 . Acknowledgements. A number of definitions used in this paper were lifted from <ref> [KT92, KTU90, KTU93] </ref>. 2 System fl k and System fl In this section, we define first the untyped -calculus, then System F, then the restriction of System F that results in System fl k . <p> Theorem 9 in <ref> [KT92] </ref> shows that fl 2 types the same set of terms as fl 2 with very similar types. Since fl 2 is as powerful as fl 2 and since its restrictions make analysis of type inference easier, we will use it instead of fl 2 in this paper. <p> If K is a type inference system, then the notation A ` K M : t denotes the claim that A ` M : t is derivable in K. 3 System fl k Typability Undecidable for k 3 Section 5 of <ref> [KT92] </ref> introduces System fl k [C k ] for each k 3 and Theorem 30 of the same paper proves that typability is undecidable for fl k [C k ] for k 3. <p> We then define System fl 2 as a restriction of fl 2 that embodies these properties and prove that fl ;fl 2 is equivalent to fl 2 . Definition 4.1 (act) (Taken from <ref> [KT92] </ref>.) Let us define, by induction on -terms M , the se quence act (M ), of active variables in M : 1. act (x) = " (the empty sequence) 2. act (x:M ) = x act (M ) ( x 2 x n if act (M ) = x 1 <p> Lemma 5.8 (From <ref> [KT92] </ref>.) In fl ;fl 2 , if A ` M : is derivable and jact (M )j = n, then = 8~ff: 1 ! : : : ! n !t and ~ 2 S (1) and t 2 S (0). <p> In the latter case, halt with the answer that M is not typable in fl 2 . 5. Compute and output the type ?! !?!(S (ffi T n+1 )) where the number of "?" components is jact (M )j. It was shown in <ref> [KT92] </ref> that fl 2 typability is DEXPTIME-complete (where DEXPTIME means DTIME (2 n O (1) )). We have just developed an algorithm that reduces fl 2 type inference to ASUP in polynomial-time. ASUP was shown to be DEXPTIME-complete in [KTU90]. Therefore, our algorithm is optimal.
Reference: [KTU90] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> An analysis of ML typability. </title> <booktitle> In 15th Colloq. Trees Algebra Program., vol. 431 of LNCS, </booktitle> <pages> pp. 206-220. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: A later extended version of this paper will clarify the relationship between ML-typability and typability in fl 2 and discuss the issues of type checking and principal types in fl 2 . Acknowledgements. A number of definitions used in this paper were lifted from <ref> [KT92, KTU90, KTU93] </ref>. 2 System fl k and System fl In this section, we define first the untyped -calculus, then System F, then the restriction of System F that results in System fl k . <p> It was shown in [KT92] that fl 2 typability is DEXPTIME-complete (where DEXPTIME means DTIME (2 n O (1) )). We have just developed an algorithm that reduces fl 2 type inference to ASUP in polynomial-time. ASUP was shown to be DEXPTIME-complete in <ref> [KTU90] </ref>. Therefore, our algorithm is optimal.
Reference: [KTU93] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> The undecidability of the semi-unification problem. </title> <journal> Inf. Comput., </journal> <volume> 102(1) </volume> <pages> 83-101, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: A later extended version of this paper will clarify the relationship between ML-typability and typability in fl 2 and discuss the issues of type checking and principal types in fl 2 . Acknowledgements. A number of definitions used in this paper were lifted from <ref> [KT92, KTU90, KTU93] </ref>. 2 System fl k and System fl In this section, we define first the untyped -calculus, then System F, then the restriction of System F that results in System fl k . <p> We now define a procedure which constructs a solution for ASUP instance if has a solution and otherwise answers that there is no solution. This procedure is a modification of the procedure defined in <ref> [KTU93] </ref> which consists of repeatedly reducing redexes, which can be of two kinds, and it halts when there are no more redexes or when a conflict is detected that precludes a solution. <p> Although the general case of semi-unification was proven to be undecidable in <ref> [KTU93] </ref>, we have the following result for ASUP: Lemma 6.1 For an instance of ASUP, the redex procedure either constructs a solution S to and halts or correctly answers that has no solution and halts.
Reference: [Lei83] <author> D. Leivant. </author> <title> Polymorphic type inference. </title> <booktitle> In Conf. Rec. 10th Ann. ACM Symp. Princ. Program. Lang., </booktitle> <pages> pp. 88-98. </pages> <publisher> ACM, </publisher> <year> 1983. </year>
Reference-contexts: One natural restriction which we consider in this paper results from stratifying F according to the "rank" of types allowed in the typing of -terms and restricting the rank to various finite values (introduced in <ref> [Lei83] </ref> and further studied in [McC84, KT92]). All of these systems improve on the expressive power of ML. Unfortunately, it is often the case that the more flexible and powerful a particular polymorphic type system is, the more likely that it will be infeasible to implement. <p> Our definition of rank is equivalent to the notion of 3 VAR A ` x : A (x) = A ` M : !t; A ` N : ABS A ` (x:M ) : !t INST A ` M : 8ff: GEN A ` M : 8ff: rank introduced in <ref> [Lei83] </ref>. Since R (k) R (k + 1) it follows that if a type is within rank k, then it is within every rank n k. Observe that performing the substitution [ff:=t ] may not preserve rank.
Reference: [Lei91] <author> D. Leivant. </author> <title> Finitely stratified polymorphism. </title> <journal> Inf. Comput., </journal> <volume> 93(1) </volume> <pages> 93-113, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Multiple stratifications of F have been proposed, e.g. by depth of bound type variable from binding quantifier in [GRDR91] and by limiting the number of generations of instantiation of quantifiers themselves introduced by instantiation in <ref> [Lei91] </ref>. One natural restriction which we consider in this paper results from stratifying F according to the "rank" of types allowed in the typing of -terms and restricting the rank to various finite values (introduced in [Lei83] and further studied in [McC84, KT92]).
Reference: [McC84] <author> N. </author> <title> McCracken. The typechecking of programs with implicit type structure. </title> <booktitle> In Semantics of Data Types : Int'l Symp., vol. 173 of LNCS, </booktitle> <pages> pp. 301-315. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <month> 12 </month>
Reference-contexts: One natural restriction which we consider in this paper results from stratifying F according to the "rank" of types allowed in the typing of -terms and restricting the rank to various finite values (introduced in [Lei83] and further studied in <ref> [McC84, KT92] </ref>). All of these systems improve on the expressive power of ML. Unfortunately, it is often the case that the more flexible and powerful a particular polymorphic type system is, the more likely that it will be infeasible to implement.
Reference: [Mil85] <author> R. Milner. </author> <title> The standard ML core language. </title> <journal> Polymorphism, </journal> <volume> 2(2), </volume> <month> Oct. </month> <year> 1985. </year>
Reference-contexts: Polymorphism lets the programmer write polymorphic functions that work uniformly on arguments of different types and avoids the maintenance problem that results from duplicating similar code at different types. The first programming language to use polymorphic type inference was the functional language ML <ref> [GMW79, Mil85] </ref>. Due to its usefulness, many of the aspects of ML have been subsequently incorporated in other languages (e.g. Miranda [Tur85]). ML shares with Algol 68 properties of compile-time type checking, strong typing and higher-order functions while also providing type inference and polymorphism.
Reference: [Pie92] <author> B. Pierce. </author> <title> Bounded quantification is undecidable. </title> <booktitle> In Conf. Rec. 19th Ann. ACM Symp. Princ. Program. Lang., </booktitle> <pages> pp. 305-315. </pages> <publisher> ACM, </publisher> <year> 1992. </year>
Reference-contexts: Other related systems that are not exactly extensions of ML have also recently been proven to have undecidable typability, i.e. System F which relates to object-oriented languages <ref> [Pie92] </ref>, and the -calculus which relates to extensions of -Prolog [Dow93]. Against this recent background, it is desirable to demarcate precisely where the boundary between decidable and undecidable typability lies within various stratifications of System F.
Reference: [Rey74] <author> J. C. Reynolds. </author> <title> Towards a theory of type structures. </title> <booktitle> In [Proc. 1st Int'l ] Symp. Programming, vol. 19 of LNCS, </booktitle> <pages> pp. 408-425. </pages> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: Over the years, this line of research has dealt with various polymorphic type systems for functional languages and -calculi, in particular the powerful type system of the Girard/Reynolds second-order -calculus <ref> [Gir72, Rey74] </ref>, which we will call by its other name, System F. In the long quest to settle the type checking and typability problems for F, researchers have also considered the problem for F modified by various restrictions.
Reference: [Tiu90] <author> J. Tiuryn. </author> <title> Type inference problems: a survey. </title> <booktitle> In Proc. Int'l Symp. Math. Found. Comput. Sci., vol. 452 of LNCS, </booktitle> <pages> pp. 105-120. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference: [TLCA93] <author> Int'l Conf. </author> <title> Typed Lambda Calculi and Applications, </title> <booktitle> vol. 664 of LNCS, </booktitle> <address> Utrecht, The Netherlands, </address> <month> Mar. </month> <title> 1993. </title> <publisher> Springer-Verlag. </publisher>
Reference: [Tur85] <author> D. A. Turner. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In IFIP Int'l Conf. Funct. Program. Comput. Arch., vol. 201 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The first programming language to use polymorphic type inference was the functional language ML [GMW79, Mil85]. Due to its usefulness, many of the aspects of ML have been subsequently incorporated in other languages (e.g. Miranda <ref> [Tur85] </ref>). ML shares with Algol 68 properties of compile-time type checking, strong typing and higher-order functions while also providing type inference and polymorphism. The usefulness of a particular polymorphic type system depends very much on how feasible the tasks of type checking and type inference are.
Reference: [Urz93] <author> P. Urzyczyn. </author> <title> Type reconstruction in F ! is undecidable. </title> <booktitle> In TLCA [TLCA93], </booktitle> <pages> pp. 418-432. </pages>
Reference-contexts: Type checking and typability were shown to be undecidable for System F (cf. recent results submitted for publication elsewhere in [Wel93]) and for its very powerful extension, System F ! <ref> [Urz93] </ref>. Other related systems that are not exactly extensions of ML have also recently been proven to have undecidable typability, i.e. System F which relates to object-oriented languages [Pie92], and the -calculus which relates to extensions of -Prolog [Dow93].
Reference: [Wel93] <author> J. B. Wells. </author> <title> Typability and type checking in the second-order lambda-calculus are equivalent and undecidable. </title> <type> Tech. Rep. 93-011, </type> <institution> Comput. Sci. Dept., Boston Univ., </institution> <year> 1993. </year>
Reference-contexts: As discouraging examples, 1 the problems of typability and type checking for many of the polymorphic type systems mentioned above have recently been proven undecidable. Type checking and typability were shown to be undecidable for System F (cf. recent results submitted for publication elsewhere in <ref> [Wel93] </ref>) and for its very powerful extension, System F ! [Urz93]. Other related systems that are not exactly extensions of ML have also recently been proven to have undecidable typability, i.e. System F which relates to object-oriented languages [Pie92], and the -calculus which relates to extensions of -Prolog [Dow93]. <p> The two problems are undecidable for every fragment of F of rank 3 and are decidable for rank 2. The undecidability of type checking at rank 3 can be seen by observing that the proof for the undecidability of type checking in F in <ref> [Wel93] </ref> requires only rank-3 types. 1 The undecidability of typability at rank 3 results from the fact that the constants c and f defined in section 5 of [KT92] can be encoded using the methods of [Wel93] in System fl 3 (the rank-3 fragment of F) and from Theorem 30 of <p> by observing that the proof for the undecidability of type checking in F in <ref> [Wel93] </ref> requires only rank-3 types. 1 The undecidability of typability at rank 3 results from the fact that the constants c and f defined in section 5 of [KT92] can be encoded using the methods of [Wel93] in System fl 3 (the rank-3 fragment of F) and from Theorem 30 of [KT92]. We give this encoding in this paper. <p> i :w i w i ) E [ ] (t:r (x 1 (tx 1 (x 1 r)(f x 1 )))(x 2 (tx 2 (x 2 r)(f x 2 )))[ ])(p:q:s:K (p (pq))(p (sp))) C 3 [ ] r:J 1 [J 2 [D [E [G [ ]]]]] Using the methods of <ref> [Wel93] </ref>, it can be seen that this context can be typed in fl 3 and in any typing of this context (with any -term placed in the hole), the variables c and f must be assigned the types c;3 and f;3 .
References-found: 21

