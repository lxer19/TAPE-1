URL: http://www.cs.jhu.edu/~gyn/publications/memorymodels/writeup.ps
Refering-URL: http://www.cs.jhu.edu/~gyn/
Root-URL: http://www.cs.jhu.edu
Title: A Comparison of Memory Models for Multiprocessor Systems  
Author: Grace Ngai 
Keyword: multiprocessor systems, architectures, memory models.  
Address: Baltimore, MD 21218  
Affiliation: Computer Science Department Johns Hopkins University  
Abstract: Multiprocessor systems have become common in recent years, due to the increasing computing demand of applications, and the decrease of processor prices. By combining the power of several processors, execution time is decreased but problems that were not an issue in uniprocessor systems, such as mutual exclusion, data and cache consistency and program ordering are introduced. These problems make it necessary to define architectures which govern a machine's behaviour and inform the programmer of the behaviour that can be expected from the machine. Three classes of models have been developed to provide a formal interface for expressing these rules. This paper explores one of the classes in detail, and looks at three specific models which have been proposed in published papers. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Leslie Lamport, </author> <title> "How to make a Multiprocessor Computer that Correctly Executes Mul-tiprocess Programs", </title> <publisher> IEEE, </publisher> <year> 1979 </year>
Reference-contexts: Therefore this execution is not expressable by the class of models with a global store. 8 3 Specific Models This section of the paper deals with three specific models that have been proposed in other papers. The first one, the sequential consistency <ref> [1] </ref> model, is the easiest to understand but also has the most limitations on performance. <p> Given this definition of a correct execution on a uniprocessor, the most natural assumption made about multiprocessor execution would be to extend the same requirement to a multiprocessor system and define sequential consistency as a system where the result of any execution is the same as if <ref> [1] </ref> * the operations of all the processors had been executed in some sequential order, and * the operations of each processor appear in this total ordering in the same order as was specified in its program. In other words, the multiprocessor should behave like a multiprogrammed uniprocessor.
Reference: [2] <author> Sarita V. Adve and Mark D. Hill, </author> <title> "A Unified Formalization of Four Shared-Memory Models", </title> <publisher> IEEE, </publisher> <year> 1993 </year> <month> 13 </month>
Reference-contexts: The first one, the sequential consistency [1] model, is the easiest to understand but also has the most limitations on performance. The other two, data-race-free-1 <ref> [2] </ref> and entry consistency [3], trade ease of programming for performance. 3.1 Sequential Consistency To increase speed and decrease idle and waiting time, modern high speed processors often execute operations in a different order than which is specified by the program (we shall call this specified order the program order). <p> There are some mechanisms that allow optimizations to be used while still ensuring the program remains sequentially consistent but they require hardware support for prefetching and rollback <ref> [2] </ref>. Since sequential consistency imposes such restrictions on the system, the ease of programming under a sequential consistency model may not be worth the price in performance for some applications where such a tight consistency model is not crucial for achieving the correct result. <p> This difference has been utilized in the design of several memory models, amongst which are weak ordering [5], release consistency [6], the VAX [7], and data-race-free-0 [8]. Although they are very similar, there are small differences in the way they satisfy the requirements <ref> [2] </ref>. In all of the models, mutual exclusion is achieved by the use of critical sections, but there are differences in the way these critical sections are defined and enforced. <p> On the other hand, release consistency is more formal and explicit, but its hardware requirements are more restrictive than necessary. In their 1993 paper "A Unified Formalization of Four Shared Memory Models" <ref> [2] </ref>, Adve and Hill present a model that unifies the four models mentioned earlier. Their model, data-race-free-1, combines the advantages of the four models and also makes possible an implementation which is not allowed by the others.
Reference: [3] <author> Brian Bershad, Matthew Zekuskas and Wayne Sawdon, </author> <title> "The Midway Distributed Shared Memory System", </title> <publisher> IEEE, </publisher> <year> 1993 </year>
Reference-contexts: The first one, the sequential consistency [1] model, is the easiest to understand but also has the most limitations on performance. The other two, data-race-free-1 [2] and entry consistency <ref> [3] </ref>, trade ease of programming for performance. 3.1 Sequential Consistency To increase speed and decrease idle and waiting time, modern high speed processors often execute operations in a different order than which is specified by the program (we shall call this specified order the program order). <p> Furthermore, it has often been observed that most parallel programs already do define their own consistency requirement by using synchronization commands to explicitly impose an order on data access. Using these special commands, a form of sequential consistency can be achieved <ref> [3] </ref>. 3.2 Weaker Models For this reason, a number of weaker models have also been developed. The first basic requirement for a model is that it be easy for the programmer to understand and use. <p> Concurrent consistency [10], on the other hand, explicitly states when sequential consistency can be expected, but the conditions are ambiguous. 11 3.2.2 Entry Consistency Another model that has been proposed is entry consistency, which runs on the Midway distributed shared memory system <ref> [3] </ref>, a medium scale multiprocessor consisting of less than 100 nodes. The system supports processor consistency, release consistency and entry consistency.
Reference: [4] <author> William Collier, </author> <title> Reasoning about Parallel Architectures, </title> <publisher> Prentice Hall Inc, </publisher> <year> 1992 </year>
Reference-contexts: With several processes running at the same time (concurrently) and owning different caches but sharing data, many new problems are introduced, such as mutual exclusion, data and cache consistency and program ordering. Because of all these problems, it has been necessary to define sets of rules, or architectures <ref> [4] </ref> which govern a machine's behaviour. Without these rules, it would be impossible for the programmer to determine what possible results a program running on a particular system would be able to produce. <p> To properly express a possible execution on a multiprocessor system, three classes of models have been introduced. This paper looks at the most general class, described in Collier's book <ref> [4] </ref>, in detail. Then it looks at the two less general classes and seeks to find if the two classes are identical, i.e. can any execution which can be expressed on one also be expressed on the other.
Reference: [5] <author> M. Dubois, C. Scheurich and F.A. Briggs, </author> <title> "Memory access buffering in multiprocessors", </title> <booktitle> Proc. 13th Annual International Symposium on Computer Architecture, </booktitle> <volume> vol 14, no. 2, </volume> <month> June </month> <year> 1986 </year>
Reference-contexts: This difference has been utilized in the design of several memory models, amongst which are weak ordering <ref> [5] </ref>, release consistency [6], the VAX [7], and data-race-free-0 [8]. Although they are very similar, there are small differences in the way they satisfy the requirements [2].
Reference: [6] <author> K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta and J. Henessy, </author> <title> "Memory consistency and event ordering in scalable shared-memory multiprocessors", </title> <booktitle> Proc 17th. Annu. Int. Symp. Comput. Architecture, </booktitle> <month> May </month> <year> 1990 </year>
Reference-contexts: This difference has been utilized in the design of several memory models, amongst which are weak ordering [5], release consistency <ref> [6] </ref>, the VAX [7], and data-race-free-0 [8]. Although they are very similar, there are small differences in the way they satisfy the requirements [2]. <p> Many of the other models, such as the processor consistency <ref> [6] </ref>, [11] or total store ordering models [12], also make it hard to determine when programmers can expect sequential consistency.
Reference: [7] <institution> VAX Architecture Handbook, </institution> <year> 1981 </year>
Reference-contexts: This difference has been utilized in the design of several memory models, amongst which are weak ordering [5], release consistency [6], the VAX <ref> [7] </ref>, and data-race-free-0 [8]. Although they are very similar, there are small differences in the way they satisfy the requirements [2]. In all of the models, mutual exclusion is achieved by the use of critical sections, but there are differences in the way these critical sections are defined and enforced.
Reference: [8] <author> S.V. Adve and M.D. Hill, </author> <title> "Weak Ordering Anew definition", </title> <booktitle> Proc 17th Annu. Int. Symp. Comput. Architecture, </booktitle> <month> May </month> <year> 1990 </year>
Reference-contexts: This difference has been utilized in the design of several memory models, amongst which are weak ordering [5], release consistency [6], the VAX [7], and data-race-free-0 <ref> [8] </ref>. Although they are very similar, there are small differences in the way they satisfy the requirements [2]. In all of the models, mutual exclusion is achieved by the use of critical sections, but there are differences in the way these critical sections are defined and enforced.
Reference: [9] <institution> IBM System/370 Priciples of Operation, </institution> <note> Publication Number CA22-7000-9, File Number S370-01, </note> <month> May </month> <year> 1983 </year>
Reference-contexts: For directory-based, writeback, invalidation, ownership, hardware cache-coherence protocols running on a shared-memory system, the paper also describes a hardware implementation which obeys data-race-free-1 but not the others. Against other models which had been proposed at the time the paper was written, the IBM 370 <ref> [9] </ref> model does not explicitly state when sequential consistency can be expected, but it appears sequentially consistent to data-race-free programs, which obey data-race-free-1 as well.
Reference: [10] <author> C.E. Scheurich, </author> <title> "Access ordering and coherence in shared memory multiprocessors," </title> <type> PhD disseration, </type> <institution> Dep. Comput. Eng., </institution> <type> Tech. Rep. </type> <institution> CENG 89-19, University of Southern Califor-nia, </institution> <month> May </month> <year> 1989 </year>
Reference-contexts: Many of the other models, such as the processor consistency [6], [11] or total store ordering models [12], also make it hard to determine when programmers can expect sequential consistency. Concurrent consistency <ref> [10] </ref>, on the other hand, explicitly states when sequential consistency can be expected, but the conditions are ambiguous. 11 3.2.2 Entry Consistency Another model that has been proposed is entry consistency, which runs on the Midway distributed shared memory system [3], a medium scale multiprocessor consisting of less than 100 nodes.
Reference: [11] <author> J.R. Goodman, </author> <title> "Cache consistency and sequential consistency," </title> <institution> Comput. Sci. </institution> <type> Tech. Rep. #1006, </type> <institution> University of Wisconsin, Madison, </institution> <month> Feb. </month> <year> 1991 </year>
Reference-contexts: Many of the other models, such as the processor consistency [6], <ref> [11] </ref> or total store ordering models [12], also make it hard to determine when programmers can expect sequential consistency.
Reference: [12] <institution> The Sparc Architecture Mannual, Sun Microsystems Inc., </institution> <note> No. 800-199-12, Version 8, </note> <month> Jan </month> <year> 1991 </year>
Reference-contexts: Many of the other models, such as the processor consistency [6], [11] or total store ordering models <ref> [12] </ref>, also make it hard to determine when programmers can expect sequential consistency.
References-found: 12

