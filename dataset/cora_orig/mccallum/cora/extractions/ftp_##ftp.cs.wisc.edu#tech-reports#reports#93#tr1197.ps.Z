URL: ftp://ftp.cs.wisc.edu/tech-reports/reports/93/tr1197.ps.Z
Refering-URL: http://www.cs.wisc.edu/~sodani/paper.html
Root-URL: 
Email: faustin, breach, sohig@cs.wisc.edu  
Title: Efficient Detection of All Pointer and Array Access Errors  
Author: Todd M. Austin Scott E. Breach Gurindar S. Sohi Todd M. Austin, Scott E. Breach, and Gurindar S. Sohi. 
Note: c 1993 by  This work was supported by grants from the National Science Foundation (grant CCR-9303030) and Office of Naval Research (grant N00014-93-1-0465).  
Date: December 1, 1993  
Address: 1210 W. Dayton Street Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Abstract: In this paper, we present a pointer and array access checking technique that provides complete error coverage through a simple set of program transformations. Our technique, based on an extended safe pointer representation, has a number of novel aspects. Foremost, it is the first technique that detects all spatial and temporal access errors. Its use is not limited by the expressiveness of the language; that is, it can be applied successfully to compiled or interpreted languages with subscripted and mutable pointers, local references, and explicit and typeless dynamic storage management, e.g., C. Because it is a source level transformation, it is amenable to both compile- and run-time optimization. Finally, its performance, even without compile-time optimization, is quite good. We implemented a prototype translator for the C language and analyzed the checking overheads of six non-trivial, pointer intensive programs. Execution overheads range from 130% to 540%; with text and data size overheads typically below 100%. 
Abstract-found: 1
Intro-found: 1
Reference: [ASU86] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: This operation can be simply and portably implemented if the local capability space and heap capability space are kept disjoint, and function frame capabilities are allocated using an incrementing counter. The allocation of frame capabilities then becomes a depth-first numbering <ref> [ASU86] </ref> of the dynamic call graph. When a non-local jump occurs, all elided frame capabilities between the source frame and destination frame are deleted by removing all frame capabilities in the capability store that are larger than the frame capability of the destination frame. <p> Our algorithm implements a forward data-flow framework similar to that used by common subexpression elimination <ref> [ASU86] </ref>. However, our algorithm extends previous work to include eliding of temporal error checks, and because of our simplified bounds check, there is no need to split the optimization into upper and lower bounds check elimination. Our optimization algorithm is shown in Figure 9.
Reference: [Asu92] <author> Jonathan M. Asuru. </author> <title> Optimization of array subscript range checks. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(2) </volume> <pages> 109-118, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: This strategy works very well in practice because procedure returns are quite frequent, while the use of local referents is generally infrequent. 5.2 Compile-Time Check Optimization We have also designed (and are currently implementing) a compile-time optimization framework like those proposed by Asuru <ref> [Asu92] </ref> and Gupta [Gup90]. Our algorithm implements a forward data-flow framework similar to that used by common subexpression elimination [ASU86].
Reference: [AWZ88] <author> Bowen Alpern, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Detecting equality of variables in programs. </title> <booktitle> In Conference Record of the 15th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-11, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: In the third phase, the in sets are used to elide redundant checks. Checks may be elided wherever a lexically identical (or equivalent, if value numbering [RWZ88] or equality tests <ref> [AWZ88] </ref> are applied) check is available in the block (i.e., the same check is in the in set of the block). The defining feature for each analysis (spatial and temporal) is the specification of what constitutes a kill.
Reference: [Boe93] <author> Hans-Juergen Boehm. </author> <title> Space efficient conservative garbage collection. </title> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <volume> 28(6) </volume> <pages> 197-204, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Purify supports both spatial and temporal access error checking to heap storage only through the use of a memory state map which is consulted at each load and store the program executes. Purify also provides uninitialized read detection, and storage leak detection through a conservative collector <ref> [Boe93, BW88] </ref>. Spatial access errors are detected by bracketing both ends of any heap allocation with a "red zone". These zones are marked in the memory state map as inaccessible. When a load or store touches a red zone a memory access error is flagged. <p> Without the ability to generate a name to the heap object, it cannot be freed, hence it has "leaked" out of the heap. For languages like C and C++, leak detection is commonly implemented with a conservative collector <ref> [Boe93, BW88] </ref>. A conservative collector sweeps memory looking for unreferenced storage. Because it is difficult to know where all pointers are located, the collector makes the conservative assumption that all program accessible (non-heap) storage contains pointers. It then uses a traditional mark and sweep collection method.
Reference: [BW88] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Purify supports both spatial and temporal access error checking to heap storage only through the use of a memory state map which is consulted at each load and store the program executes. Purify also provides uninitialized read detection, and storage leak detection through a conservative collector <ref> [Boe93, BW88] </ref>. Spatial access errors are detected by bracketing both ends of any heap allocation with a "red zone". These zones are marked in the memory state map as inaccessible. When a load or store touches a red zone a memory access error is flagged. <p> Without the ability to generate a name to the heap object, it cannot be freed, hence it has "leaked" out of the heap. For languages like C and C++, leak detection is commonly implemented with a conservative collector <ref> [Boe93, BW88] </ref>. A conservative collector sweeps memory looking for unreferenced storage. Because it is difficult to know where all pointers are located, the collector makes the conservative assumption that all program accessible (non-heap) storage contains pointers. It then uses a traditional mark and sweep collection method.
Reference: [Cor87] <institution> MIPS Computer Corporation. </institution> <note> MIPS Fortran 77 compiler (f77) user's guide, </note> <year> 1987. </year>
Reference-contexts: The safe subset also requires some checking, but much less than our checking technique requires. Languages which can easily be made totally safe have existed for a long time; for example, many FORTRAN implementations provide complete safety through range checking <ref> [Cor87] </ref>. However, these languages tend to be less expressive than intrinsically unsafe languages such as C or C++. We felt that it was important not to restrict the expressiveness available to the programmer.
Reference: [ED93] <author> John R. Ellis and David L. Detlefs. </author> <title> Safe, efficient garbage collection for C++. </title> <type> Technical Report 102, </type> <institution> DEC Systems Research Center, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Some researchers have recently proposed providing complete program safety through limiting the constructs allowed in the language. The main thrust of this work is the design of languages that support garbage collection reliably and portably. For example, in <ref> [ED93] </ref>, a safe subset of C++ is defined. The safe subset does not permit any invalid pointers to be created; this restriction, for example, precludes the use of any explicit pointer arithmetic.
Reference: [EP91] <author> D. R. Edelson and I. Pohl. </author> <title> Smart pointers: They're smart but they're not pointers. </title> <booktitle> Proceedings of the 1991 Usenix C++ Conference, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: We should be able to achieve the same results for ValidCapability (). 22 23 7 Related Work Our first attempt at creating a safe programming environment for C employed reference chaining. The technique is similar to that used by many "smart pointer" implementations <ref> [EP91, Gin92] </ref>. The idea is to insert any pointer which is generated either through use of explicit storage allocation, e.g., malloc (), the reference operator (`&'), or assignment into a reference chain rooted at the referent.
Reference: [FH88] <author> Anthony J. Field and Peter G. Harrison. </author> <title> Functional Programming. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1988. </year>
Reference-contexts: Spatial checks have no side effects, thus we can employ memoization <ref> [FH88] </ref> (or function caching) to elide their evaluation. We store the operands to the last check in the safe pointer object attributes, which amounts to the effective address of the last dereference.
Reference: [FL80] <author> Charles N. Fischer and Richard J. LeBlanc. </author> <title> The implementation of run-time diagnostics in Pascal. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(4):313-319, </volume> <year> 1980. </year>
Reference-contexts: Integral C C safe yes* no [Ros87] compiler UW-Pascal Pascal safe yes* yes errant free's, <ref> [FL80] </ref> compiler union type checking, arithmetic faults, etc. Table 4: Comparison of memory access checking work. <p> As the user updates code, it is incrementally compiled (at function granularity) to machine code. Like RTCC, Integral C attaches only base and bound attributes to pointer values, thus it can only detect spatial access errors. Fischer and LeBlanc's UW-Pascal compiler <ref> [FL80] </ref> supports both temporal and spatial error checking. However, the lack of mutable pointers and dynamically sized arrays makes access checking much easier. While UW-Pascal detects all spatial access errors, temporal access errors may not be detected if storage is reallocated.
Reference: [Gin92] <author> Andrew Ginter. </author> <title> Design alternatives for a cooperative garbage collector for the C++ programming language. </title> <type> Technical Report 91/417/01, </type> <institution> Department of Computer Science, University of Calgary, </institution> <year> 1992. </year>
Reference-contexts: We should be able to achieve the same results for ValidCapability (). 22 23 7 Related Work Our first attempt at creating a safe programming environment for C employed reference chaining. The technique is similar to that used by many "smart pointer" implementations <ref> [EP91, Gin92] </ref>. The idea is to insert any pointer which is generated either through use of explicit storage allocation, e.g., malloc (), the reference operator (`&'), or assignment into a reference chain rooted at the referent.
Reference: [Gup90] <author> Rajiv Gupta. </author> <title> A fresh look at optimizing array bound checking. </title> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 272-282, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: This strategy works very well in practice because procedure returns are quite frequent, while the use of local referents is generally infrequent. 5.2 Compile-Time Check Optimization We have also designed (and are currently implementing) a compile-time optimization framework like those proposed by Asuru [Asu92] and Gupta <ref> [Gup90] </ref>. Our algorithm implements a forward data-flow framework similar to that used by common subexpression elimination [ASU86].
Reference: [Har77] <author> W. Harrison. </author> <title> Compiler analysis of the value ranges of variables. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 3(3) </volume> <pages> 243-250, </pages> <year> 1977. </year>
Reference-contexts: To increase the effectiveness of our lower bound study, we combined the results of four separate inputs. Our lower bound results are not a strict lower bound. Other static analysis techniques, e.g., range analysis <ref> [Har77] </ref> or program restructuring, could decrease the number of static checks required. However, for our proposed compile-time optimization framework without program restructuring, the lower bound results are a strict lower bound. 6.2 Analyzed Programs We analyzed six programs, selected because each exhibits a high frequency of indirect references.
Reference: [HJ92] <author> Reed Hastings and Bob Joyce. Purify: </author> <title> fast detection of memory leaks and access errors. </title> <booktitle> Proceedings of the Winter Usenix Conference, </booktitle> <year> 1992. </year>
Reference-contexts: The performance is quite good. Instruction execution overheads range from 130% to 540%, and text and data size overheads are typically below 100%. We also benchmarked our prototype system against two commercially available tools that support memory access checking (Purify <ref> [HJ92] </ref> and CodeCenter [KLP88]) and found that our checking technique consistently uses less resources, even while providing better error coverage for memory access errors. This paper is organized as follows. Section 2 introduces our extended safe pointer representation. <p> Table 4 details our work (Safe-C) and five other published systems that support memory access checking. Hastings' and Joyce's Purify <ref> [HJ92] </ref> is a commercially available memory access checking tool. It is particularly easy to use because it does not require program source all semantic changes to the program are applied to the object code. <p> To increase the 24 Name Environment Method Error Model Spatial Checks? Temporal Checks? Extensions Safe-C C/C++ source-to-source yes* yes* errant free's translation Purify object files object code yes yes errant free's, <ref> [HJ92] </ref> translation limited to heap limited to heap uninitialized reads, storage leaks RTCC C safe yes* no [Ste92] compiler CodeCenter C/C++ interpreter yes* yes errant free's, [KLP88] uninitialized reads, type checking, arithmetic errors, etc.
Reference: [KLP88] <author> Stephen Kaufer, Russel Lopez, and Sesha Pratap. Saber-C: </author> <title> an interpreter-based programming environment for the C language. </title> <booktitle> Proceedings of the Summer Usenix Conference, </booktitle> <pages> pages 161-171, </pages> <year> 1988. </year>
Reference-contexts: The performance is quite good. Instruction execution overheads range from 130% to 540%, and text and data size overheads are typically below 100%. We also benchmarked our prototype system against two commercially available tools that support memory access checking (Purify [HJ92] and CodeCenter <ref> [KLP88] </ref>) and found that our checking technique consistently uses less resources, even while providing better error coverage for memory access errors. This paper is organized as follows. Section 2 introduces our extended safe pointer representation. <p> Error Model Spatial Checks? Temporal Checks? Extensions Safe-C C/C++ source-to-source yes* yes* errant free's translation Purify object files object code yes yes errant free's, [HJ92] translation limited to heap limited to heap uninitialized reads, storage leaks RTCC C safe yes* no [Ste92] compiler CodeCenter C/C++ interpreter yes* yes errant free's, <ref> [KLP88] </ref> uninitialized reads, type checking, arithmetic errors, etc. Integral C C safe yes* no [Ros87] compiler UW-Pascal Pascal safe yes* yes errant free's, [FL80] compiler union type checking, arithmetic faults, etc. Table 4: Comparison of memory access checking work. <p> In the implementation of RTCC the issue of interfacing to library and system calls is addressed through encapsulation; Steffen also augmented sdb to provide users with transparent debugging support. CodeCenter <ref> [KLP88] </ref> is an interpreted C language environment.
Reference: [Lar93] <author> James R. Larus. </author> <title> Efficient program tracing. </title> <journal> IEEE Computer, </journal> <volume> 26(5) </volume> <pages> 52-61, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: All programs were compiled and executed on a DECstation 3100 using AT&T USL cfront version 3.0.1. The output of cfront (C code) was compiled using MIPS cc version 2.1 at optimization level `-O2'. All instruction counts were obtained with QPT <ref> [Lar93] </ref>. For all analyses, object attributes were only attached to pointer values. We used a 15 byte safe pointer (275% overhead) in the unoptimized case: 4 byte pointer value, 4 byte base, 4 byte size, a 1 byte storage class specifier, and a 2 byte capability.
Reference: [Lee91] <editor> Peter Lee, editor. </editor> <booktitle> Topics in Advanced Language Implementation. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: Section 7 compares our checking technique to other published techniques. Section 8 concludes the paper. 2 Safe Pointers To enforce access protection, we must extend the notion of a pointer value to include information about the referent. The idea is similar to tagged pointers used in many Lisp implementations <ref> [Lee91] </ref>. Figure 2 shows our safe pointer representation. The definitions of the contained fields follow: value: The value of the safe pointer; it may contain any expressible address. base and size: The base address of the referent and its size in bytes.
Reference: [MFS90] <author> Barton P. Miller, Lars Fredriksen, and Bryan So. </author> <title> An empirical study of the reliability of Unix utilities. </title> <journal> Communications of the ACM, </journal> <volume> 33(12) </volume> <pages> 32-44, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: A typical temporal access error is assigning to a heap allocation after it has been freed. Our own experiences as programmers as well as published evidence lead us to believe that memory access errors are an important class of errors to reliably detect. For example, in <ref> [MFS90] </ref>, Miller et. al. injected random inputs (a.k.a "fuzz") into a number of Unix utilities. On systems from six different vendors, nearly all of the seemingly mature programs could be coaxed into dumping core. The most prevalent errors detected were memory access errors.
Reference: [Ros87] <author> Graham Ross. </author> <title> Integral C a practical environment for C programming. </title> <booktitle> In Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (SIGPLAN Notices), </booktitle> <pages> pages 42-48. </pages> <institution> Association for Computing Machinery, </institution> <month> January </month> <year> 1987. </year>
Reference-contexts: Integral C C safe yes* no <ref> [Ros87] </ref> compiler UW-Pascal Pascal safe yes* yes errant free's, [FL80] compiler union type checking, arithmetic faults, etc. Table 4: Comparison of memory access checking work. <p> Since programs run in an interpreter, the execution overheads may discourage its use, and in the case of long running programs, may preclude its use. Due to our use of compile-time instrumentation, resource requirements are significantly lower. Compile-time instrumentation also allows us to employ static check optimizations. Integral C <ref> [Ros87] </ref> is an integrated programming environment for the C language. The user interface is very similar to CodeCenter, however, internally it does not employ an interpreter. As the user updates code, it is incrementally compiled (at function granularity) to machine code.
Reference: [RWZ88] <author> B. K. Rosen, M. N. Wegman, and F. K. Zadeck. </author> <title> Global value numbers and redundant computations. </title> <booktitle> In Conference Record of the 15th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 12-27, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: In the third phase, the in sets are used to elide redundant checks. Checks may be elided wherever a lexically identical (or equivalent, if value numbering <ref> [RWZ88] </ref> or equality tests [AWZ88] are applied) check is available in the block (i.e., the same check is in the in set of the block). The defining feature for each analysis (spatial and temporal) is the specification of what constitutes a kill.
Reference: [SC91] <author> Mark Sullivan and Ram Chillarege. </author> <title> Software defects and their impact on system availability a study of field failures in operating systems. </title> <booktitle> Digest of the 21st International Symposium on Fault Tolerant Computing, </booktitle> <pages> pages 2-9, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: For example, in [MFS90], Miller et. al. injected random inputs (a.k.a "fuzz") into a number of Unix utilities. On systems from six different vendors, nearly all of the seemingly mature programs could be coaxed into dumping core. The most prevalent errors detected were memory access errors. In <ref> [SC91] </ref>, Sullivan and Chillarege examined IBM MVS software error reports over a four year period. Nearly 50% of all reported software errors examined were due to pointer and array access errors. Furthermore, of these errors, 25% were temporal access errors an error our checking methodology is particularly adept at catching.
Reference: [Ste92] <author> Joseph L. Steffen. </author> <title> Adding run-time checking to the Portable C Compiler. </title> <journal> Software Practice and Experience, </journal> <volume> 22(4) </volume> <pages> 305-316, </pages> <year> 1992. </year>
Reference-contexts: To increase the 24 Name Environment Method Error Model Spatial Checks? Temporal Checks? Extensions Safe-C C/C++ source-to-source yes* yes* errant free's translation Purify object files object code yes yes errant free's, [HJ92] translation limited to heap limited to heap uninitialized reads, storage leaks RTCC C safe yes* no <ref> [Ste92] </ref> compiler CodeCenter C/C++ interpreter yes* yes errant free's, [KLP88] uninitialized reads, type checking, arithmetic errors, etc. Integral C C safe yes* no [Ros87] compiler UW-Pascal Pascal safe yes* yes errant free's, [FL80] compiler union type checking, arithmetic faults, etc. Table 4: Comparison of memory access checking work. <p> However, our technique is quite portable across different platforms, especially if implemented as a source-to-source translator. Although Purify is portable across languages (on a given platform), it is not portable across platforms. Steffen's RTCC <ref> [Ste92] </ref> extends the functionality of the C language compiler PCC to include spatial error checking. RTCC attaches object attributes to pointers in a fashion similar to our technique; it does not, however, detect temporal access errors, nor does it explore the use of check optimization.
Reference: [ZH88] <author> Benjamin Zorn and Paul Hilfinger. </author> <title> A memory allocation profiler for C and Lisp programs. </title> <booktitle> Proceedings of the Summer Usenix Conference, </booktitle> <pages> pages 223-237, </pages> <year> 1988. </year> <month> 29 </month>
Reference-contexts: To summarize, using a conservative collector to detect storage leaks with our safe programming technique makes the process intrinsically more reliable 26 by eliminating false leaks and reducing the possibility of false hits. Zorn and Hilfinger's mprof takes a notably different (and clever) approach to detecting storage leaks <ref> [ZH88] </ref>. During the analyzed program's execution, mprof maintains a table of partial call chains, each with a count of how many malloc ()'s and free ()'s have occurred to storage whose call chains terminated with that sequence.
References-found: 23

