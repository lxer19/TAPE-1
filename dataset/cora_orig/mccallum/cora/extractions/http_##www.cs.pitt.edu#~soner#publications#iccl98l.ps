URL: http://www.cs.pitt.edu/~soner/publications/iccl98l.ps
Refering-URL: http://www.cs.pitt.edu/~soner/
Root-URL: http://www.cs.pitt.edu
Email: fsoner,guptag@cs.pitt.edu  
Title: Automatic Generation of Microarchitecture Simulators  
Author: Soner Onder Rajiv Gupta 
Address: Pittsburgh Pittsburgh PA 15260  
Affiliation: Department of Computer Science University of  
Abstract: In this paper we describe the UPFAST system that automatically generates a cycle level simulator, an assembler and a disassembler from a microarchitec-ture specification written in a domain specific language called the Architecture Description Language (ADL). Using the UPFAST system it is easy to retarget a simulator for an existing architecture to a modified architecture since one has to simply modify the input specification and the new simulator is generated automatically. UPFAST also allows porting of simulators to different platforms with minimal effort. We have been able to develop three simulators ranging from simple pipelined processors to complicated out-of-order issue processors over a short period of three months. While the specifications of the architectures varied from 5000 to 6000 lines of ADL code, the sizes of automatically generated software varied from 20,000 to 30,000 lines of C++ code. The automatically generated simulators are less than 2 times slower than hand coded simulators for similar architectures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.R. Armstrong and F.G. Gray. </author> <title> Structured Logic Design with VHDL. </title> <address> New Jersey: </address> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Automatic generation not only significantly shortens the development cycle, it also allows retargeting since modifications in the architecture can be made at the specification level and the new simulator can then be automatically generated. Although a number of hardware description languages <ref> [1, 7, 9, 13] </ref> are available, these languages are not suitable for developing cycle level simulators. These languages are capable of defining the hardware to the smallest detail and result in simulators that are orders of magnitude slower than cycle level simulators. <p> the of clause, effectively placing the new artifact higher in the hierarchy. shadow register temp 16; # A 16 bit temporary register. register file gpr [32,32] # 32 registers,32 bits each. $zero 0, # $zero is another alias for gpr [0] $at 1, # $at is another alias for gpr <ref> [1] </ref> $v0 2, $sp 29, $ra 31; memory mport0 latency 12 width 64, # 64 bit path to memory. mport1 latency 12 width 64; # 64 bit path to memory. instruction cache icache of mport0 directmapped 64 kb 4 wpl; data cache l2 of mport1 directmapped 64 kb 4 wpl, l1
Reference: [2] <author> M.W. Bailey and J.W. Davidson. </author> <title> A formal model and specification language for procedure calling conventions. </title> <booktitle> In 22nd ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 298-310, </pages> <year> 1995. </year>
Reference-contexts: This approach allows the language user to specify external references of a program and treat them as if they are single instructions. The calling convention specification is based on the formal model and specification language for procedure calling conventions by Bailey and Davidson <ref> [2] </ref>. Their language has been modified so that it fits the general structure of the ADL language. The specification provides a mapping to a register or a memory location, given an argument's position and type in the procedure call.
Reference: [3] <author> D.C. </author> <title> Burger and T.M. Austin. The SimpleScalar Tool Set, V. 2.0. </title> <type> Technical Report 97-1342, </type> <institution> Computer Sci. Dept., Univ. of Wisconsin Madison, </institution> <year> 1997. </year>
Reference-contexts: A commonly used approach for developing simulators is their hand coding in a general purpose language such as C. Examples of some popular simulators which were developed using this approach include the SPIM simulator for the MIPS architecture [6], the SimpleScalar simulator <ref> [3] </ref>, and the SuperDLX simulator [8]. The hand coding of simulators is a substantial task which typically takes between 12 to 24 man months. Once developed, such simulators are difficult to retarget to a modified microarchitecture or an instruction set architecture without a significant amount of effort. <p> The pipelined version executes at an average speed of 200,000 simulator cycles/second on a 200 MHZ Pentium Pro and the Tomasulo's algorithm executes at an average speed of 100,000 cycles/second. The Tomasulo's algorithm is comparable in complexity to the out-of-order Sim-pleScalar simulator <ref> [3] </ref> which reports a simulation speed of 150,000 cycles/second on a 200 MHZ Pentium Pro. Comparing these figures with the SimpleScalar numbers we find that ADL generated simulators are less than 2 times slower than the hand coded counterparts. <p> Comparing these figures with the SimpleScalar numbers we find that ADL generated simulators are less than 2 times slower than the hand coded counterparts. On the other hand, given that the development time for SimpleScalar simulator was 18 man-months <ref> [3] </ref>, it is obvious that the ADL approach is a cost-effective approach.
Reference: [4] <author> T.A. Cook and E.A. Harcourt. </author> <title> A functional specification language for instruction set architectures. </title> <booktitle> In Proc. 1994 International Conference on Computer Languages, </booktitle> <pages> pages 11-19, </pages> <year> 1994. </year>
Reference-contexts: We also need to define which fields make up the instruction (i.e., the instruction format) as well as how their values are computed. Instead of defining separate instruction formats and then mapping instructions to these formats <ref> [4] </ref>, ADL chooses to specify the instruction format as part of the instruction's binary part. The binary part of each instruction is represented as a sequence of field expressions. A field expression is the assignment of a value to a field of the instruction. <p> singleword (int, void *, ...), doubleword (double, ...); map argument.type begin singleword : intregs; doubleword : map argument [1].type begin singleword: intfpregs; doubleword: fpfpregs; end map; prototypes begin reference errno, sys errlist ... double cosh (double); int printf (int,...); end; end calling convention; procedure int p1 () begin int p1=gpr <ref> [4] </ref>; access complete=( has context EX j has context MEM j has context WB)==0; end int p1; associated with a supplier procedure. Supplier procedures are microarchitecture specific procedures that return the value of the argument at the time of the call.
Reference: [5] <author> L. Huffman and D. Graves. </author> <title> MIPSpro Assembly Language Programmers Manual. </title> <institution> Silicon Graphics Corp., Doc. 007-2418-002, </institution> <year> 1996. </year>
Reference-contexts: We have obtained some experience with the system by developing three different simulators based upon the MIPS ISA <ref> [10, 5] </ref>. These simulators range from a simple pipelined design to a complicated superscalar architecture design. The three simulators were developed in a short time period of three months demonstrating the ability for rapid prototyping.
Reference: [6] <author> J.R. Larus. SPIM S20: </author> <title> A MIPS R2000 Simulator. </title> <type> Technical Report 90-966, </type> <institution> Computer Sci. Dept., Univ. of Wisconsin Madison, </institution> <year> 1990. </year>
Reference-contexts: A commonly used approach for developing simulators is their hand coding in a general purpose language such as C. Examples of some popular simulators which were developed using this approach include the SPIM simulator for the MIPS architecture <ref> [6] </ref>, the SimpleScalar simulator [3], and the SuperDLX simulator [8]. The hand coding of simulators is a substantial task which typically takes between 12 to 24 man months.
Reference: [7] <author> J.D. Morison and A.S. Clarke. </author> <title> ELLA2000 A language for Electronic System Design. </title> <publisher> McGraw-Hill, </publisher> <year> 1993. </year>
Reference-contexts: Automatic generation not only significantly shortens the development cycle, it also allows retargeting since modifications in the architecture can be made at the specification level and the new simulator can then be automatically generated. Although a number of hardware description languages <ref> [1, 7, 9, 13] </ref> are available, these languages are not suitable for developing cycle level simulators. These languages are capable of defining the hardware to the smallest detail and result in simulators that are orders of magnitude slower than cycle level simulators.
Reference: [8] <author> C. Moura. </author> <title> SuperDLX a generic superscalar simulator. </title> <type> Technical Report 64, </type> <institution> School of Computer Science, McGill University, </institution> <year> 1993. </year>
Reference-contexts: A commonly used approach for developing simulators is their hand coding in a general purpose language such as C. Examples of some popular simulators which were developed using this approach include the SPIM simulator for the MIPS architecture [6], the SimpleScalar simulator [3], and the SuperDLX simulator <ref> [8] </ref>. The hand coding of simulators is a substantial task which typically takes between 12 to 24 man months. Once developed, such simulators are difficult to retarget to a modified microarchitecture or an instruction set architecture without a significant amount of effort.
Reference: [9] <author> D.L. Perry. </author> <title> VHDL. </title> <publisher> McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: Automatic generation not only significantly shortens the development cycle, it also allows retargeting since modifications in the architecture can be made at the specification level and the new simulator can then be automatically generated. Although a number of hardware description languages <ref> [1, 7, 9, 13] </ref> are available, these languages are not suitable for developing cycle level simulators. These languages are capable of defining the hardware to the smallest detail and result in simulators that are orders of magnitude slower than cycle level simulators.
Reference: [10] <author> C. Price. </author> <title> MIPS IV Instruction Set Revision 3.2. </title> <publisher> MIPS Technologies Inc., </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: We have obtained some experience with the system by developing three different simulators based upon the MIPS ISA <ref> [10, 5] </ref>. These simulators range from a simple pipelined design to a complicated superscalar architecture design. The three simulators were developed in a short time period of three months demonstrating the ability for rapid prototyping.
Reference: [11] <author> N. Ramsey and M.F. Fernandez. </author> <title> The new jersey machine-code toolkit. </title> <booktitle> In Proc. 1995 USENIX Technical Conference, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: Since the rt field appears in the argument list, it gets a register number from the parsed instruction. ADL representation of binary encoding is a concise representation and is more natural than the SLED approach <ref> [11, 12] </ref> since there is no need for separate opcode tables and constructors. Specifying Instruction Semantics: The semantic-part of an instruction specification serves two purposes.
Reference: [12] <author> N. Ramsey and M.F. Fernandez. </author> <title> Specifying representations of machine instructions. </title> <journal> ACM Trans. on Programming Lang. and Systems, </journal> <year> 1997. </year>
Reference-contexts: Since the rt field appears in the argument list, it gets a register number from the parsed instruction. ADL representation of binary encoding is a concise representation and is more natural than the SLED approach <ref> [11, 12] </ref> since there is no need for separate opcode tables and constructors. Specifying Instruction Semantics: The semantic-part of an instruction specification serves two purposes.
Reference: [13] <author> D.E. Thomas and P.R. Moorby. </author> <title> The Verilog Hardware Description Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Automatic generation not only significantly shortens the development cycle, it also allows retargeting since modifications in the architecture can be made at the specification level and the new simulator can then be automatically generated. Although a number of hardware description languages <ref> [1, 7, 9, 13] </ref> are available, these languages are not suitable for developing cycle level simulators. These languages are capable of defining the hardware to the smallest detail and result in simulators that are orders of magnitude slower than cycle level simulators.
Reference: [14] <author> R.M. Tomasulo. </author> <title> An efficient algorithm for exploiting multiple arithmetic units. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 11 </volume> <pages> 25-33, </pages> <year> 1967. </year>
Reference-contexts: Finally in Fig. 4 (c), a structural hazard and its handling is illustrated. The example shows one possible way to implement a unified pool of 64 reservation stations using an array of stages for the Tomasulo's algorithm <ref> [14] </ref>. The ID stage attempts to reserve a unit from the pool of reservation stations.
References-found: 14

