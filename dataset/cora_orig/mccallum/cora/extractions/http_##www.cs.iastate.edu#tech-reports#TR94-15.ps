URL: http://www.cs.iastate.edu/tech-reports/TR94-15.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Introduction to the Literature On Semantics  
Author: Gary T. Leavens 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa Sate University  
Note: c Gary T. Leavens. Permission is granted for you to make copies for educational and scholarly purposes, but not for direct commercial advantage, provided this notice appears on all copies. All other rights reserved.  
Date: August 1994  
Pubnum: TR #94-15  
Abstract: Keywords: programming languages, axiomatic sematics, denotational semantics, operational semantics, type systems, polymorphism, type theory, data abstraction. 1992 CR Categories: D.2.4 [Software Engineering] Program Verification; D.3.1 [Programming Languages] Formal Definitions and Theory; F.3.1 [Logics and Meaning of Programs] Specifying and verifying and reasoning about programs; F.3.2 [Logics and Meaning of Programs] Semantics of Programming Languages; F.3.3 [Logics and Meaning of Programs] Studies of Program Constructs. 
Abstract-found: 1
Intro-found: 1
Reference: [Aba93] <author> Martin Abadi. </author> <title> Baby Modula-3 and a Theory of Objects. </title> <type> Technical Report 95, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> February </month> <year> 1993. </year> <title> Order from src-report@src.dec.com. </title>
Reference-contexts: Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] [AC90] [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] <ref> [Aba93] </ref> [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] [Cha92] [CGL93] [Cas93] [CL94]. 6.4 Type Reconstruction Type reconstruction (or type inference) is
Reference: [AC90] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping Recursive Types. </title> <type> Technical Report 62, </type> <institution> Digital Systems Research Center, </institution> <address> Palo Alto, Ca 94301, </address> <month> August </month> <year> 1990. </year> <note> See also the 1991 POPL proceedings. </note>
Reference-contexts: By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] <ref> [AC90] </ref> [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80]
Reference: [Al91a] <author> Krzysztof R. Apt and Ernst-Rudiger 0lderog. </author> <title> Introduction to Program Verification. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts, IFIP State-of-the-Art Reports, </booktitle> <pages> pages 363-429. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: Verification of concurrent programs may be handled with the Owicki-Gries method [OG76]. Other techniques use temporal logic (e.g., [OL82]) and "transition axioms" [Lam89]. An introduction to Hoare-style verification that discusses concurrent and distributed programs is <ref> [Al91a] </ref>. 3.1.1 Abstract Data Types Hoare also was the first to consider how verification and abstract data types interact [Hoa72].
Reference: [AL91b] <author> Andrea Asperti and Guiseppe Longo. </author> <title> Categories, Types and Structures. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass, </address> <year> 1991. </year>
Reference-contexts: For example, categorical logic and the semantics of the typed lambda calculus are discussed in [LS86]. For me, the best introduction seems to be the first 5 chapters of [Gol84]. There are now several articles [Hoa89] and books [BW90] <ref> [AL91b] </ref> [Pie91] [Wal91] explaining category theory to computer scientists.
Reference: [All86] <author> Lloyd Allison. </author> <title> A Practical Introduction to Denotational Semantics. </title> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1986. </year>
Reference-contexts: A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76]. A recent survey is found in [Mos90]. Introductory texts include [Gor79], <ref> [All86] </ref>, [Wat91], [Sch94]. An excellent new graduate text with more mathematical depth is [Gun92]. Standard works on denotational semantics are the books by Stoy [Sto77] and Schmidt [Sch86], both of which offer a comprehensive and mathematical treatment.
Reference: [Apt81] <author> Krzystof R. Apt. </author> <title> Ten Years of Hoare's Logic: A Survey|Part I. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(4) </volume> <pages> 431-483, </pages> <month> October </month> <year> 1981. </year>
Reference-contexts: This paper sparked a wealth of research in program verification. Some surveys of results of this research are <ref> [Apt81] </ref>, [FB86], and [Cou90], the latter of which also cites other surveys. A technical reference is [LS87, Chapter 9]. A very introductory tutorial on verification from the software engineering perspective is [LG86, chapter 11].
Reference: [ASS85] <author> Harold Abelson, Gerald Jay Sussman, and Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1985. </year>
Reference-contexts: Meta-circular interpreters are still useful for teaching purposes, and for prototyping programming language designs. Several meta-circular interpreters for variants of LISP are discussed in Steele and Sussman's paper The Art of the Interpreter [SS78]. An excellent and more readily accessible discussion is found in Abelson and Sussman's book <ref> [ASS85] </ref>, which uses Scheme. A more detailed treatment of interpreters is found in [Kam90] [FWH92]. See [KdRB91] for an approach using the CLOS meta-object protocol. However, for mathematical convenience, one wants something more abstract than an interpreter or complier.
Reference: [Ast91] <author> Edigio Astesiano. </author> <title> Inductive and Operational Semantics. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts, IFIP State-of-the-Art Reports, </booktitle> <pages> pages 51-136. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: A more systematic style of operational semantics based on rewrite rules is found in Plotkin's terminal transition systems [Plo77] also known as "structural operational semantics" [Plo81] [Hen90] or a "labeled transition system" <ref> [Ast91] </ref>. Hennessy's book is an elementary introduction [Hen90]. This style of semantics has the advantage that it extends naturally to studies of concurrency [Mil90]. A classic reference for the operational semantics of concurrent processes is Milner's book on CCS [Mil80].
Reference: [Bac78] <author> John Backus. </author> <title> Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 613-641, </pages> <month> August </month> <year> 1978. </year> <month> 7 </month>
Reference-contexts: Some recent work in this area can be found in [Mee87] [Bir89a] [Bir89b] [Tal88]. Transformational (or algebraic) techniques also underly the work on Backus's FP <ref> [Bac78] </ref> and Hoare's "Laws of Programming" for CSP [HHJ + 87].
Reference: [Bac89] <author> R. C. Backhouse. </author> <title> Constructive Type Theory An Introduction. </title> <editor> In Manfred Broy, editor, </editor> <booktitle> Constructive Methods in Computing Science, volume F55 of NATO ASI Series, </booktitle> <pages> pages 9-60. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1989. </year>
Reference-contexts: Another motivation is to use type information to capture behavioral specifications, thus allowing one to reason about programs in the programming language [NP83] [Dyb90]. The principal groups working on type theory include deBruijn and others working on AU-TOMATH [dB80b], Martin-Lof's and followers [ML75] [ML82] <ref> [Bac89] </ref>, Constable's group at Cor-nell has been very active in this area. Their language PRL which uses constructive mathematics, is described in the paper "Proofs as Programs" [BC85]. A related language is PL/CV3 [CZ84]. Coquand and Huet's group is responsible for the "calculus of constructions" [CH88].
Reference: [Bal81] <author> Robert Balzer. </author> <title> Transformational Implementation: an Example. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7(1), </volume> <month> January </month> <year> 1981. </year>
Reference-contexts: The idea of formal development of program and proof has found favor in the functional programming community as well. The idea behind transformational programming is to transform the specification of a program into an efficient version [BD77] [MW80] <ref> [Bal81] </ref> [CHT81]; these references are characterized by their work with equational logic (instead of predicate transformers or a Hoare 3 logic), their use of algebraic techniques, and the general focus on functional languages. Some recent work in this area can be found in [Mee87] [Bir89a] [Bir89b] [Tal88].
Reference: [Bar84] <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland Publishing Co., </publisher> <address> New York, N.Y., </address> <year> 1984. </year> <note> Revised Edition. </note>
Reference-contexts: A classic approach, using proof theory and model theory is [End72]. More recent approaches, favoring proof theory (especially predicate logic) at the expense of model theory and mathematical depth and emphasizing calculation, include [DS90] [GS94] [MW93]. 2.1 -Calculus A standard reference on Church's (untyped) -calculus [Chu41] is Barendregt's book <ref> [Bar84] </ref>. This book is at times highly technical, but also has sensible definitions and introductory material. A shorter account, with a reasonable introduction to the -calculus is found in [Bar90]. Other introductions include [Gor88] [Sch94, Sections 6.1-6.2].
Reference: [Bar90] <author> H. P. Barendregt. </author> <title> Functional Programming and Lambda Calculus. </title> <editor> In J. van Leewen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 7, </booktitle> <pages> pages 321-363. </pages> <publisher> The MIT Press, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: This book is at times highly technical, but also has sensible definitions and introductory material. A shorter account, with a reasonable introduction to the -calculus is found in <ref> [Bar90] </ref>. Other introductions include [Gor88] [Sch94, Sections 6.1-6.2]. The use of -calculus for describing programming languages and as the inspiration for programming language design has been investigated by Landin [Lan65] [Lan66] and many others. For the typed -calculus, a standard reference is [GLT89].
Reference: [BC85] <author> Joseph L. Bates and Robert L. Constable. </author> <title> Proofs as Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 113-136, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: The principal groups working on type theory include deBruijn and others working on AU-TOMATH [dB80b], Martin-Lof's and followers [ML75] [ML82] [Bac89], Constable's group at Cor-nell has been very active in this area. Their language PRL which uses constructive mathematics, is described in the paper "Proofs as Programs" <ref> [BC85] </ref>. A related language is PL/CV3 [CZ84]. Coquand and Huet's group is responsible for the "calculus of constructions" [CH88].
Reference: [BCM + 93] <author> Kim B. Bruce, Jon Crabtree, Thomas P. Murtagh, Robert van Gent, Allyn Dimock, and Robert Muller. </author> <title> Safe and decidable type checking in an object-oriented language. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(10) </volume> <pages> 29-46, </pages> <month> October </month> <year> 1993. </year> <booktitle> OOPSLA '93 Proceedings, Andreas Paepcke (editor). </booktitle>
Reference-contexts: By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] [AC90] [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] <ref> [BCM + 93] </ref> [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] [Cha92] [CGL93] [Cas93] [CL94]. 6.4 Type Reconstruction Type
Reference: [BD77] <author> R. M. Burstall and J. L. Darlington. </author> <title> A Transformation System for Developing Recursive Programs. </title> <journal> Journal of the ACM, </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: One formalization of this approach is the refinement calculus [Bv89a][Bv89b] [Mor90] [MG90] [MV94]. The idea of formal development of program and proof has found favor in the functional programming community as well. The idea behind transformational programming is to transform the specification of a program into an efficient version <ref> [BD77] </ref> [MW80] [Bal81] [CHT81]; these references are characterized by their work with equational logic (instead of predicate transformers or a Hoare 3 logic), their use of algebraic techniques, and the general focus on functional languages. Some recent work in this area can be found in [Mee87] [Bir89a] [Bir89b] [Tal88].
Reference: [BDMN73] <author> Graham M. Birtwistle, Ole-Johan Dahl, Bjorn Myhrhaug, and Kristen Nygaard. </author> <title> SIM-ULA Begin. </title> <publisher> Auerbach Publishers, </publisher> <address> Philadelphia, Penn., </address> <year> 1973. </year>
Reference-contexts: This idea has been used to show some representation independence results [Mit86]. For other work along these lines, see for example, [Mac86] [CL90] [Mit90]. The second approach to supporting data abstraction Reynolds called "procedural data abstraction". Today it goes under the more common name of "object-oriented programming" (OOP) [DMN70] <ref> [BDMN73] </ref> [GR83]. Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel [Mey88] [Mey92], both of which have insecure type systems [Coo89]. The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. <p> For other work along these lines, see for example, [Mac86] [CL90] [Mit90]. The second approach to supporting data abstraction Reynolds called "procedural data abstraction". Today it goes under the more common name of "object-oriented programming" (OOP) [DMN70] <ref> [BDMN73] </ref> [GR83]. Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel [Mey88] [Mey92], both of which have insecure type systems [Coo89]. The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94].
Reference: [BG82] <author> R. M. Burstall and J. A. Goguen. </author> <title> Algebras, Theories and Freeness: An Introduction for Computer Scientists. </title> <editor> In Manfred Broy and Gunther Schmidt, editors, </editor> <booktitle> Theoretical Foundations of Programming Methodology: Lecture Notes of an International Summer School directed by F. </booktitle> <editor> L. Bauer, E. W. Dijkstra and C. A. R. </editor> <booktitle> Hoare, volume 91 of series C, </booktitle> <pages> pages 329-348. </pages> <address> D. Ridel, Dordrecht, Holland, </address> <year> 1982. </year>
Reference-contexts: There are now several articles [Hoa89] and books [BW90] [AL91b] [Pie91] [Wal91] explaining category theory to computer scientists. For those familiar with (or needing) background in the semantics of abstract data type specifications, a good introduction is Burstall and Goguen's paper <ref> [BG82] </ref>. 3 Axiomatic Semantics Hoare pointed out, in his seminal paper [Hoa69, Section 6], that one could define a programming language by insisting "that all implementations of the language shall `satisfy' the axioms and rules of inference which underlie proofs of the properties of the programs expressed in the language." (However,
Reference: [BH90a] <author> Henk Barendregt and Kees Hemerik. </author> <title> Types in Lambda Calculi and Programming Languages. </title> <editor> In N. Jones, editor, </editor> <booktitle> ESOP '90 3rd European Symposium on Programming, Copenhagen, Denmark, volume 432 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-35. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> May </month> <year> 1990. </year>
Reference-contexts: Their language PRL which uses constructive mathematics, is described in the paper "Proofs as Programs" [BC85]. A related language is PL/CV3 [CZ84]. Coquand and Huet's group is responsible for the "calculus of constructions" [CH88]. A recent survey with more references is <ref> [BH90a] </ref>. 6.3 Data Abstraction: ADTs and OOP Reynolds [Rey75] [Rey78] (see also [Coo91]) distinguished two ways in which a type system could support data abstraction. The first way is to have the language give an object different types outside and inside a defining module; this Reynolds called "user defined types".
Reference: [BH90b] <author> Andrew P. Black and Norman C. Hutchinson. </author> <title> Typechecking Polymorphism in Emerald. </title> <type> Technical Report TR 90-34, </type> <institution> Department of Computer Science; The University of Arizona, </institution> <address> Tucson, AZ 85721, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel [Mey88] [Mey92], both of which have insecure type systems [Coo89]. The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] <ref> [BH90b] </ref> [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94].
Reference: [BH91] <author> Andrew P. Black and Norman Hutchinson. </author> <title> Typechecking Polymorphism in Emerald. </title> <type> Technical Report CRL 91/1 (Revised), </type> <institution> Digital Equipment Corporation, Cambridge Research Lab, </institution> <address> Cambridge, Mass., </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel [Mey88] [Mey92], both of which have insecure type systems [Coo89]. The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] <ref> [BH91] </ref> and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94].
Reference: [BHJ + 87] <author> Andrew Black, Norman Hutchinson, Eric Jul, Henry Levy, and Larry Carter. </author> <title> Distribution and Abstract Types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(1):65-76, </volume> <month> January </month> <year> 1987. </year> <month> 8 </month>
Reference-contexts: Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel [Mey88] [Mey92], both of which have insecure type systems [Coo89]. The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] <ref> [BHJ + 87] </ref> [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94].
Reference: [BHJL86] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object Structure in the Emerald System. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 78-86, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel [Mey88] [Mey92], both of which have insecure type systems [Coo89]. The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald <ref> [BHJL86] </ref> [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94].
Reference: [Bir89a] <author> R. S. Bird. </author> <title> Algebraic Identities for Program Calculation. </title> <journal> The Computer Journal, </journal> <volume> 32(2) </volume> <pages> 122-126, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Some recent work in this area can be found in [Mee87] <ref> [Bir89a] </ref> [Bir89b] [Tal88]. Transformational (or algebraic) techniques also underly the work on Backus's FP [Bac78] and Hoare's "Laws of Programming" for CSP [HHJ + 87].
Reference: [Bir89b] <author> Richard S. Bird. </author> <title> Lectures on Constructive Functional Programming. </title> <editor> In Manfred Broy, editor, </editor> <booktitle> Constructive Methods in Computing Science, volume F55 of NATO ASI Series, </booktitle> <pages> pages 151-216. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1989. </year>
Reference-contexts: Some recent work in this area can be found in [Mee87] [Bir89a] <ref> [Bir89b] </ref> [Tal88]. Transformational (or algebraic) techniques also underly the work on Backus's FP [Bac78] and Hoare's "Laws of Programming" for CSP [HHJ + 87].
Reference: [BJ82] <author> Dines Bjorner and Cliff B. Jones. </author> <title> Formal Specification and Software Development. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> London, </address> <year> 1982. </year>
Reference-contexts: A practical implementation of these ideas is found in [NHN80]. VDM also uses these techniques [Jon90]. More recent work in this area is found in [Sch90] and [Nip89]. Abstract data types (ADTs) can be specified algebraically [GHM78] [EM85] or by using pre-and post-conditions <ref> [BJ82] </ref> [Jon86] [Win87]. See [LG86, chapter 11] for a tutorial on program verification using abstract data types.
Reference: [BL90] <author> K. Bruce and G. Longo. </author> <title> A modest model of records, inheritance and bounded quantification. </title> <journal> Information and Computation, </journal> 87(1/2):196-240, 1990. 
Reference-contexts: Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] [AC90] [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] <ref> [BL90] </ref> [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] [Cha92] [CGL93] [Cas93] [CL94]. 6.4 Type Reconstruction Type reconstruction (or type
Reference: [BM92] <author> Kim Bruce and John C. Mitchell. </author> <title> PER models of subtyping, recursive types and higher-order polymorphism. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 316-327. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] [AC90] [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] <ref> [BM92] </ref> [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] [Cha92] [CGL93] [Cas93] [CL94]. 6.4 Type Reconstruction Type reconstruction (or type inference)
Reference: [Boe85] <author> Hans-Juergen Boehm. </author> <title> Side Effects and Aliasing Can Have Simple Axiomatic Descriptions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(4) </volume> <pages> 637-655, </pages> <month> Oc-tober </month> <year> 1985. </year>
Reference-contexts: Transformational (or algebraic) techniques also underly the work on Backus's FP [Bac78] and Hoare's "Laws of Programming" for CSP [HHJ + 87]. Contrary to popular belief, it is also possible to reason "equationally" about programs with side-effects and even continuations <ref> [Boe85] </ref> [FF86] [FH89]. 3.2 Axiomatic Semantics of Programming Languages A classic text on the semantics of programming languages which treats axiomatic semantics is [dB80a]. Predicte transformer semantics, using the "weakest precondition" operator were advocated by Dijkstra for the definition of his guarded command language [Dij75].
Reference: [Bru93] <author> K. Bruce. </author> <title> Safe Type Checking in a Statically Typed Object-Oriented Programming Language. </title> <booktitle> In Proc. ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 285-298, </pages> <year> 1993. </year>
Reference-contexts: Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] [AC90] [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] <ref> [Bru93] </ref>. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] [Cha92] [CGL93] [Cas93] [CL94]. 6.4 Type Reconstruction Type reconstruction (or type inference) is the
Reference: [BTGS90] <author> V. Breazu-Tannen, C. A. Gunter, and A. Scedrov. </author> <title> Computing with Coercions. </title> <booktitle> In Proceedings of the 1990 ACM Conference on LISP and Functional Programming, Nice, France, </booktitle> <pages> pages 44-60. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] [AC90] [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] <ref> [BTGS90] </ref> [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] [Cha92] [CGL93] [Cas93] [CL94]. 6.4
Reference: [Bv89a] <author> R. J. R. Back and J. von Wright. </author> <title> Refinement Calculus, Part I: Sequential Nondeterministic Programs. </title> <type> Technical Report Ser. </type> <note> A, No 92, </note> <institution> Abo Akademi University, Department of Computer Science, </institution> <address> Lemminkainengatan 14, 20520 Abo, Finland, </address> <year> 1989. </year> <title> Appears in Stepwise Refinement of Distributed Systems, Models, Formalisms, Correctness, </title> <booktitle> REX Workshop, Mook, </booktitle> <address> The Netherlands, </address> <month> May/June </month> <year> 1989, </year> <note> Spring-Verlag, LNCS 430, </note> <editor> J. W. de Bakker, et al, </editor> <booktitle> (eds.), </booktitle> <pages> pages 42-66. </pages>
Reference: [Bv89b] <author> R. J. R. Back and J. von Wright. </author> <title> Refinement Calculus, Part II: Parallel and Reactive Programs. </title> <type> Technical Report Ser. </type> <note> A, No 93(?), </note> <institution> Abo Akademi University, Department of Computer Science, </institution> <address> Lemminkainengatan 14, 20520 Abo, Finland, </address> <year> 1989. </year> <title> Appears in Stepwise Refinement of Distributed Systems, Models, Formalisms, Correctness, </title> <booktitle> REX Workshop, Mook, </booktitle> <address> The Netherlands, </address> <month> May/June </month> <year> 1989, </year> <note> Spring-Verlag, LNCS 430, </note> <editor> J. W. de Bakker, et al, </editor> <booktitle> (eds.), </booktitle> <pages> pages 67-93. </pages>
Reference: [BW90] <author> Michael Barr and Charles Wells. </author> <booktitle> Category Theory for Computing Science. International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1990. </year> <note> ISBN 0 13-120486-6. </note>
Reference-contexts: For example, categorical logic and the semantics of the typed lambda calculus are discussed in [LS86]. For me, the best introduction seems to be the first 5 chapters of [Gol84]. There are now several articles [Hoa89] and books <ref> [BW90] </ref> [AL91b] [Pie91] [Wal91] explaining category theory to computer scientists.
Reference: [BWP87] <author> Manfred Broy, Martin Wirsing, and Petter Pepper. </author> <title> On the Algebraic Definition of Programming Languages. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 54-99, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Examples include [MA86] <ref> [BWP87] </ref>. 4 Denotational Semantics In contrast to axiomatic semantics, denotational semantics [Str66] [SS71] [MS76] [Sto77] [Sco81] [Sch86] explicitly constructs mathematical models of programming languages. A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76].
Reference: [Car87] <author> Luca Cardelli. </author> <title> Basic Polymorphic Typechecking. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8(2), </volume> <month> April </month> <year> 1987. </year>
Reference-contexts: A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78]. Another exposition of this material, incorporating refinements found in [DM82], is found in <ref> [Car87] </ref>. Milner-style type inference system is used in the programming language ML [GMW79] [Mil84] [Har86] [HMM86]. The ideal model has been used to give a semantics to the ML type system [MPS86].
Reference: [Car88a] <author> Luca Cardelli. </author> <title> A Semantics of Multiple Inheritance. </title> <journal> Information and Computation, </journal> 76(2/3):138-164, February/March 1988. A revised version of the paper that appeared in the 1984 Semantics of Data Types Symposium, LNCS <volume> 173, </volume> pages <pages> 51-66. </pages>
Reference-contexts: The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] <ref> [Car88a] </ref> [CM89] [AC90] [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS),
Reference: [Car88b] <author> Luca Cardelli. </author> <title> Structural Subtyping and the Notion of Power Type. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, Calif., </address> <pages> pages 70-79. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1988. </year>
Reference-contexts: The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following <ref> [Car88b] </ref> [Car88a] [CM89] [AC90] [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in
Reference: [Car91] <author> Luca Cardelli. </author> <title> Typeful Programming. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts, IFIP State-of-the-Art Reports, </booktitle> <pages> pages 431-507. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: It also goes deeply into more advanced topics such as higher-order type systems and predicate-logic typing. 6.1 Polymorphism An introductory survey of modern polymorphic type systems and research results is Cardelli and Wegner's paper "On Understanding Types, Data Abstraction and Polymorphism" [CW85]. See also [Har84] <ref> [Car91] </ref> [DT88]; the latter two have much material related to object-oriented programming. A still more recent survey is [Mit90]. Standard references include Girard's system F! [Gir71] (see also [Gir86] [GLT89]), and Reynolds independent work [Rey74], sometimes called the Girard-Reynolds second order lambda calculus (or SOL). <p> A still more recent survey is [Mit90]. Standard references include Girard's system F! [Gir71] (see also [Gir86] [GLT89]), and Reynolds independent work [Rey74], sometimes called the Girard-Reynolds second order lambda calculus (or SOL). Modern expositions are found in [MP85] [MH88] [Rey85] [Mit90] <ref> [Car91] </ref>. Other kinds of type information may be incorporated into a type system and checked at the same time as types [GL86] [LG88] [OG89]. 5 6.2 Type Theory Type theory, narrowly defined, uses the tools of constructive logic to study polymorphic type systems. <p> Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel [Mey88] [Mey92], both of which have insecure type systems [Coo89]. The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest <ref> [Car91] </ref> feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94].
Reference: [Car93] <author> Luca Cardelli. </author> <title> An Implementation of F &lt;: </title> . <type> Technical Report 97, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, California 94301, </address> <month> February </month> <year> 1993. </year> <title> Order from src-report@src.dec.com. </title>
Reference-contexts: By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] [AC90] [CMMS91] <ref> [Car93] </ref> [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b]
Reference: [Cas93] <author> G. Castagna. </author> <title> A Meta-Language for Typed Object-Oriented Languages. </title> <editor> In R. K. Shyamasundar, editor, </editor> <booktitle> Foundations of Software Technology and Theoretical Computer Science, volume 761 of Lecture Notes in Computer Science, </booktitle> <pages> pages 52-71. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1993. </year>
Reference-contexts: [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] [Cha92] [CGL93] <ref> [Cas93] </ref> [CL94]. 6.4 Type Reconstruction Type reconstruction (or type inference) is the process of reconstructing types for a program that has no type declarations. A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78].
Reference: [CCH + 89] <author> Peter Canning, William Cook, Walter Hill, John Mitchell, and Walter Olthoff. </author> <title> F-Bounded Polymorphism for Object-Oriented Programming. </title> <booktitle> In Fourth International Conference on Functional Programming and Computer Architecture. ACM, </booktitle> <month> September </month> <year> 1989. </year> <note> Also technical report STL-89-5, </note> <institution> from Software Technology Laboratory, Hewlett-Packard Laboratories. </institution>
Reference-contexts: By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] [AC90] [CMMS91] [Car93] <ref> [CCH + 89] </ref> [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92]
Reference: [CGL92] <author> Giuseppe Castagna, Giorgio Ghelli, and Giuseppe Longo. </author> <title> A Calculus for Overloaded Functions with Subtyping. </title> <booktitle> In ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 182-192. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1992. </year> <note> To appear in Information and Computation. </note>
Reference-contexts: [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] <ref> [CGL92] </ref> [Cha92] [CGL93] [Cas93] [CL94]. 6.4 Type Reconstruction Type reconstruction (or type inference) is the process of reconstructing types for a program that has no type declarations. A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78].
Reference: [CGL93] <author> G. Castagna, G. Ghelli, and G. Longo. </author> <title> A semantics for &-early: a calculus with overloading and early binding. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <booktitle> International Conference on Typed Lambda Calculi and Applications, number 664 in Lecture Notes in Computer Science, </booktitle> <pages> pages 107-123, </pages> <address> Utrecht, The Netherlands, March 1993. </address> <publisher> Springer-Verlag. TLCA'93. </publisher>
Reference-contexts: 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] [Cha92] <ref> [CGL93] </ref> [Cas93] [CL94]. 6.4 Type Reconstruction Type reconstruction (or type inference) is the process of reconstructing types for a program that has no type declarations. A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78].
Reference: [CH88] <author> Thierry Coquand and Gerard Huet. </author> <title> The Calculus of Constructions. </title> <journal> Information and Computation, </journal> 76(2/3):95-120, February/March 1988. 
Reference-contexts: Their language PRL which uses constructive mathematics, is described in the paper "Proofs as Programs" [BC85]. A related language is PL/CV3 [CZ84]. Coquand and Huet's group is responsible for the "calculus of constructions" <ref> [CH88] </ref>. A recent survey with more references is [BH90a]. 6.3 Data Abstraction: ADTs and OOP Reynolds [Rey75] [Rey78] (see also [Coo91]) distinguished two ways in which a type system could support data abstraction.
Reference: [Cha92] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <editor> In Ole Lehrmann Madsen, editor, </editor> <booktitle> ECOOP '92, European Conference on Object-Oriented Programming, Utrecht, The Netherlands, volume 615 of Lecture Notes in Computer Science, </booktitle> <pages> pages 33-56. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1992. </year> <month> 10 </month>
Reference-contexts: + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] <ref> [Cha92] </ref> [CGL93] [Cas93] [CL94]. 6.4 Type Reconstruction Type reconstruction (or type inference) is the process of reconstructing types for a program that has no type declarations. A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78].
Reference: [CHC90] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is Not Subtyping. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, California, </address> <pages> pages 125-135, </pages> <month> January </month> <year> 1990. </year> <note> Also STL-89-17, </note> <institution> Software Technology Laboratory, Hewlett-Packard Laboratories, Palo Alto, Calif., </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] [AC90] [CMMS91] [Car93] [CCH + 89] <ref> [CHC90] </ref> [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] [Cha92] [CGL93] [Cas93]
Reference: [CHT81] <author> T. E. Cheatham, G. H. Holloway, and J. A. Townley. </author> <title> Program Refinement by Transformation. </title> <booktitle> In Fifth International Conference on Software Engineering, </booktitle> <pages> pages 430-437. </pages> <publisher> IEEE, </publisher> <year> 1981. </year>
Reference-contexts: The idea of formal development of program and proof has found favor in the functional programming community as well. The idea behind transformational programming is to transform the specification of a program into an efficient version [BD77] [MW80] [Bal81] <ref> [CHT81] </ref>; these references are characterized by their work with equational logic (instead of predicate transformers or a Hoare 3 logic), their use of algebraic techniques, and the general focus on functional languages. Some recent work in this area can be found in [Mee87] [Bir89a] [Bir89b] [Tal88].
Reference: [Chu41] <author> A. Church. </author> <title> The Calculi of Lambda Conversion, </title> <booktitle> volume 6 of Annals of Mathematics Studies. </booktitle> <publisher> Princeton University Press, </publisher> <address> Princeton, N.J., </address> <year> 1941. </year> <title> Reprinted by Klaus Reprint Corp., </title> <address> New York in 1965. </address>
Reference-contexts: Since this is an introduction, only a small fraction of the literature can be mentioned here. References are included because they have intrinsic interest, although some are included simply because they are the original sources and are likely to be referenced by others doing related work (e.g. <ref> [Chu41] </ref>). <p> A classic approach, using proof theory and model theory is [End72]. More recent approaches, favoring proof theory (especially predicate logic) at the expense of model theory and mathematical depth and emphasizing calculation, include [DS90] [GS94] [MW93]. 2.1 -Calculus A standard reference on Church's (untyped) -calculus <ref> [Chu41] </ref> is Barendregt's book [Bar84]. This book is at times highly technical, but also has sensible definitions and introductory material. A shorter account, with a reasonable introduction to the -calculus is found in [Bar90]. Other introductions include [Gor88] [Sch94, Sections 6.1-6.2].
Reference: [CL90] <author> Luca Cardelli and Xavier Leroy. </author> <title> Abstract Types and the Dot Notation. </title> <type> Technical Report 56, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> March </month> <year> 1990. </year> <title> Order from src-report@src.dec.com. </title>
Reference-contexts: Mitchell and Plotkin connected this approach, ADTs, to the second-order lambda calculus [MP85]. This idea has been used to show some representation independence results [Mit86]. For other work along these lines, see for example, [Mac86] <ref> [CL90] </ref> [Mit90]. The second approach to supporting data abstraction Reynolds called "procedural data abstraction". Today it goes under the more common name of "object-oriented programming" (OOP) [DMN70] [BDMN73] [GR83].
Reference: [CL94] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and Modules for Multi-Method. </title> <type> Technical Report 94-03, </type> <institution> Department of Computer Science, Iowa State University, 226 Atanasoff Hall, Ames, Iowa 50011, </institution> <month> March </month> <year> 1994. </year> <institution> Also University of Washington Department of Computer Science and Engineering TR number 94-03-01. </institution> <note> To appear in OOPSLA '94. </note>
Reference-contexts: [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] [Cha92] [CGL93] [Cas93] <ref> [CL94] </ref>. 6.4 Type Reconstruction Type reconstruction (or type inference) is the process of reconstructing types for a program that has no type declarations. A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78].
Reference: [CM89] <author> Luca Cardelli and John C. Mitchell. </author> <title> Operations on Records (Summary). </title> <editor> In M. Main, A. Melton, M. Mislove, and D. Schmidt, editors, </editor> <booktitle> Mathematical Foundations of Programming Semantics, 5th International Conference, Tulane University, volume 442 of Lecture Notes in Computer Science, </booktitle> <pages> pages 22-52. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> March </month> <year> 1989. </year>
Reference-contexts: The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] <ref> [CM89] </ref> [AC90] [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see
Reference: [CMMS91] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An Extension of System F with Subtyping. </title> <type> Technical Report 80, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> December </month> <year> 1991. </year> <note> Extended abstract in Theoretical Aspects of Computer Software, </note> <author> T. Ito and A. R. Meyer (editors), </author> <note> LNCS Vol 526. To appear in Information and Control. </note>
Reference-contexts: By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] [AC90] <ref> [CMMS91] </ref> [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a]
Reference: [Coh90] <author> Edward Cohen. </author> <title> Programming in the 1990s: An Introduction to the Calculation of Programs. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: However, Hoare [Hoa71] and others were soon advocating the development of proofs at the same time as programs. Dijkstra and Gries became prime advocates of this technique [Dij76] [Gri81]. More recent treatments in this style advocate a calculational approach <ref> [Coh90] </ref> [GS94]. One formalization of this approach is the refinement calculus [Bv89a][Bv89b] [Mor90] [MG90] [MV94]. The idea of formal development of program and proof has found favor in the functional programming community as well.
Reference: [Con89] <author> Robert L. Constable. </author> <title> Assigning Meaing to Proofs: a semantic basis for problem solving environments. </title> <editor> In Manfred Broy, editor, </editor> <booktitle> Constructive Methods in Computing Science, volume F55 of NATO ASI Series, </booktitle> <pages> pages 63-91. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1989. </year>
Reference-contexts: A good introduction can be found in [Sch94, Chapters 8-10]. Logical inference systems can often be translated directly into type systems due to the "Formula as Types" notion or the "Curry-Howard isomorphism" [How80] [GLT89, Chapter 3] <ref> [Con89] </ref>. Thus much research in type theory lies on the border of mathematics and computer science. Another motivation is to use type information to capture behavioral specifications, thus allowing one to reason about programs in the programming language [NP83] [Dyb90].
Reference: [Coo89] <author> W. R. Cook. </author> <title> A Proposal for Making Eiffel Type-safe. </title> <journal> The Computer Journal, </journal> <volume> 32(4) </volume> <pages> 305-311, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: The second approach to supporting data abstraction Reynolds called "procedural data abstraction". Today it goes under the more common name of "object-oriented programming" (OOP) [DMN70] [BDMN73] [GR83]. Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel [Mey88] [Mey92], both of which have insecure type systems <ref> [Coo89] </ref>. The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. <p> By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] [AC90] [CMMS91] [Car93] [CCH + 89] [CHC90] <ref> [Coo89] </ref> [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] [Cha92] [CGL93] [Cas93] [CL94].
Reference: [Coo91] <author> William R. Cook. </author> <title> Object-Oriented Programming Versus Abstract Data Types. </title> <editor> In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 151-178. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year> <month> 11 </month>
Reference-contexts: A related language is PL/CV3 [CZ84]. Coquand and Huet's group is responsible for the "calculus of constructions" [CH88]. A recent survey with more references is [BH90a]. 6.3 Data Abstraction: ADTs and OOP Reynolds [Rey75] [Rey78] (see also <ref> [Coo91] </ref>) distinguished two ways in which a type system could support data abstraction. The first way is to have the language give an object different types outside and inside a defining module; this Reynolds called "user defined types".
Reference: [Cou90] <author> Patrick Cousot. </author> <title> Methods and Logics for Proving Programs. </title> <editor> In J. van Leewen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 15, </booktitle> <pages> pages 841-993. </pages> <publisher> The MIT Press, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: However, the term "program verification" is usually implies a syntactic proof in a specially constructed logic. Floyd introduced the inductive assertions and well-founded sets methods for program verification in 1967 [Flo67] (see also [LS87, Chapter 8]). (See <ref> [Cou90] </ref> for historical references to the work of Naur, Von Neumann, and Turing, who anticipated this work.) The term inductive assertions refers to the assertions that are put at every branch point in the program's flow graph; these give rise to verification conditions, which state that along every path, the correctness <p> This paper sparked a wealth of research in program verification. Some surveys of results of this research are [Apt81], [FB86], and <ref> [Cou90] </ref>, the latter of which also cites other surveys. A technical reference is [LS87, Chapter 9]. A very introductory tutorial on verification from the software engineering perspective is [LG86, chapter 11].
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction and Polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: It also goes deeply into more advanced topics such as higher-order type systems and predicate-logic typing. 6.1 Polymorphism An introductory survey of modern polymorphic type systems and research results is Cardelli and Wegner's paper "On Understanding Types, Data Abstraction and Polymorphism" <ref> [CW85] </ref>. See also [Har84] [Car91] [DT88]; the latter two have much material related to object-oriented programming. A still more recent survey is [Mit90]. Standard references include Girard's system F! [Gir71] (see also [Gir86] [GLT89]), and Reynolds independent work [Rey74], sometimes called the Girard-Reynolds second order lambda calculus (or SOL).
Reference: [CZ84] <author> Robert L. Constable and Daniel R. Zlatin. </author> <title> The Type Theory of PL/CV3. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(1) </volume> <pages> 94-117, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: Their language PRL which uses constructive mathematics, is described in the paper "Proofs as Programs" [BC85]. A related language is PL/CV3 <ref> [CZ84] </ref>. Coquand and Huet's group is responsible for the "calculus of constructions" [CH88]. A recent survey with more references is [BH90a]. 6.3 Data Abstraction: ADTs and OOP Reynolds [Rey75] [Rey78] (see also [Coo91]) distinguished two ways in which a type system could support data abstraction.
Reference: [dB80a] <author> Jaco de Bakker. </author> <title> Mathematical Theory of Program Correctness. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1980. </year>
Reference-contexts: Contrary to popular belief, it is also possible to reason "equationally" about programs with side-effects and even continuations [Boe85] [FF86] [FH89]. 3.2 Axiomatic Semantics of Programming Languages A classic text on the semantics of programming languages which treats axiomatic semantics is <ref> [dB80a] </ref>. Predicte transformer semantics, using the "weakest precondition" operator were advocated by Dijkstra for the definition of his guarded command language [Dij75]. A monograph on predicate transformer semantics is [DS90] which goes over notational issues as well as the underlying mathematics. A recent monograph that updates [dB80a] using predicate transformers is <p> treats axiomatic semantics is <ref> [dB80a] </ref>. Predicte transformer semantics, using the "weakest precondition" operator were advocated by Dijkstra for the definition of his guarded command language [Dij75]. A monograph on predicate transformer semantics is [DS90] which goes over notational issues as well as the underlying mathematics. A recent monograph that updates [dB80a] using predicate transformers is [Hes92]. An example of the use of the axiomatic semantics to describe a programming language is Hoare and Wirth's axiomatic definition of Pascal [HW73].
Reference: [dB80b] <author> N. G. de Bruijn. </author> <title> A Survey of the Project AUTOMATH. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <publisher> Academic Press, Inc., </publisher> <address> New York, N.Y., </address> <year> 1980. </year>
Reference-contexts: Another motivation is to use type information to capture behavioral specifications, thus allowing one to reason about programs in the programming language [NP83] [Dyb90]. The principal groups working on type theory include deBruijn and others working on AU-TOMATH <ref> [dB80b] </ref>, Martin-Lof's and followers [ML75] [ML82] [Bac89], Constable's group at Cor-nell has been very active in this area. Their language PRL which uses constructive mathematics, is described in the paper "Proofs as Programs" [BC85]. A related language is PL/CV3 [CZ84].
Reference: [DD85] <author> James Donahue and Alan Demers. </author> <title> Data Types are Values. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(3) </volume> <pages> 426-445, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: There are many papers that have appeared about Russell, but perhaps the best introduction to the language is the paper "Data Types are Values" <ref> [DD85] </ref>, which can be consulted for other references. Russell has separate mechanisms for building types and for information hiding; the same idea is found in Haskell [Hud89, Pages 387-388]. Interesting variations are found in Miranda [Tur85].
Reference: [Dij75] <author> E. W. Dijkstra. </author> <title> Guarded Commands, Nondeterminancy and Formal Derivation of Programs. </title> <journal> Communications of the ACM, </journal> <volume> 18(8) </volume> <pages> 453-457, </pages> <month> August </month> <year> 1975. </year>
Reference-contexts: Predicte transformer semantics, using the "weakest precondition" operator were advocated by Dijkstra for the definition of his guarded command language <ref> [Dij75] </ref>. A monograph on predicate transformer semantics is [DS90] which goes over notational issues as well as the underlying mathematics. A recent monograph that updates [dB80a] using predicate transformers is [Hes92].
Reference: [Dij76] <author> Edsger W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1976. </year>
Reference-contexts: A technical reference is [LS87, Chapter 9]. A very introductory tutorial on verification from the software engineering perspective is [LG86, chapter 11]. The idea of developing a proof of a program at the same time the program is being developed has been eloquently advocated by Dijkstra and Gries <ref> [Dij76] </ref> [Gri81]. See [Gor88] for a more theoretical introduction that treats some aspects of theorem proving. Concurrency has always been a prime application area, because concurrent programs are so difficult to debug. Verification of concurrent programs may be handled with the Owicki-Gries method [OG76]. <p> However, Hoare [Hoa71] and others were soon advocating the development of proofs at the same time as programs. Dijkstra and Gries became prime advocates of this technique <ref> [Dij76] </ref> [Gri81]. More recent treatments in this style advocate a calculational approach [Coh90] [GS94]. One formalization of this approach is the refinement calculus [Bv89a][Bv89b] [Mor90] [MG90] [MV94]. The idea of formal development of program and proof has found favor in the functional programming community as well.
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principal Type-Schemes for Functional Programs. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albuquerque, New Mexico, </address> <pages> pages 207-212. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1982. </year>
Reference-contexts: A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78]. Another exposition of this material, incorporating refinements found in <ref> [DM82] </ref>, is found in [Car87]. Milner-style type inference system is used in the programming language ML [GMW79] [Mil84] [Har86] [HMM86]. The ideal model has been used to give a semantics to the ML type system [MPS86].
Reference: [DMN70] <author> Ole-Johan Dahl, B. Myhraug, and K. Nygaard. </author> <title> The Simula 67 common base language. </title> <institution> Publication S-22, Norwegian Computing Center, Oslo, Norway, </institution> <year> 1970. </year>
Reference-contexts: This idea has been used to show some representation independence results [Mit86]. For other work along these lines, see for example, [Mac86] [CL90] [Mit90]. The second approach to supporting data abstraction Reynolds called "procedural data abstraction". Today it goes under the more common name of "object-oriented programming" (OOP) <ref> [DMN70] </ref> [BDMN73] [GR83]. Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel [Mey88] [Mey92], both of which have insecure type systems [Coo89]. The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping.
Reference: [DS90] <author> Edsger W. Dijkstra and Carel S. Scholten. </author> <title> Predicate Calculus and program semantics. </title> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1990. </year>
Reference-contexts: Another foundation is the area of mathematical logic. A classic approach, using proof theory and model theory is [End72]. More recent approaches, favoring proof theory (especially predicate logic) at the expense of model theory and mathematical depth and emphasizing calculation, include <ref> [DS90] </ref> [GS94] [MW93]. 2.1 -Calculus A standard reference on Church's (untyped) -calculus [Chu41] is Barendregt's book [Bar84]. This book is at times highly technical, but also has sensible definitions and introductory material. A shorter account, with a reasonable introduction to the -calculus is found in [Bar90]. <p> Predicte transformer semantics, using the "weakest precondition" operator were advocated by Dijkstra for the definition of his guarded command language [Dij75]. A monograph on predicate transformer semantics is <ref> [DS90] </ref> which goes over notational issues as well as the underlying mathematics. A recent monograph that updates [dB80a] using predicate transformers is [Hes92]. An example of the use of the axiomatic semantics to describe a programming language is Hoare and Wirth's axiomatic definition of Pascal [HW73].
Reference: [DT88] <author> Scott Danforth and Chris Tomlinson. </author> <title> Type Theories and Object-Oriented Programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 20(1) </volume> <pages> 29-72, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: It also goes deeply into more advanced topics such as higher-order type systems and predicate-logic typing. 6.1 Polymorphism An introductory survey of modern polymorphic type systems and research results is Cardelli and Wegner's paper "On Understanding Types, Data Abstraction and Polymorphism" [CW85]. See also [Har84] [Car91] <ref> [DT88] </ref>; the latter two have much material related to object-oriented programming. A still more recent survey is [Mit90]. Standard references include Girard's system F! [Gir71] (see also [Gir86] [GLT89]), and Reynolds independent work [Rey74], sometimes called the Girard-Reynolds second order lambda calculus (or SOL).
Reference: [Dyb90] <author> Peter Dybjer. </author> <title> Comparing Integrated and External Logics of Functional Programs. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14(1) </volume> <pages> 59-79, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Thus much research in type theory lies on the border of mathematics and computer science. Another motivation is to use type information to capture behavioral specifications, thus allowing one to reason about programs in the programming language [NP83] <ref> [Dyb90] </ref>. The principal groups working on type theory include deBruijn and others working on AU-TOMATH [dB80b], Martin-Lof's and followers [ML75] [ML82] [Bac89], Constable's group at Cor-nell has been very active in this area. Their language PRL which uses constructive mathematics, is described in the paper "Proofs as Programs" [BC85].
Reference: [EM85] <author> Hartmut Ehrig and Bernd Mahr. </author> <title> Fundamentals of Algebraic Specification 1: Equations and Initial Semantics. </title> <booktitle> EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1985. </year>
Reference-contexts: A practical implementation of these ideas is found in [NHN80]. VDM also uses these techniques [Jon90]. More recent work in this area is found in [Sch90] and [Nip89]. Abstract data types (ADTs) can be specified algebraically [GHM78] <ref> [EM85] </ref> or by using pre-and post-conditions [BJ82] [Jon86] [Win87]. See [LG86, chapter 11] for a tutorial on program verification using abstract data types.
Reference: [End72] <author> Herbert B. Enderton. </author> <title> A Mathematical Introduction to Logic. </title> <publisher> Academic Press, Inc., </publisher> <address> Orlando, Florida, </address> <year> 1972. </year>
Reference-contexts: Gratzer's monumental book [Gra79] is a standard reference. A generalized notion of homomorphism that is often used in semantics is Statman's logical relations [Sta85], explained in [Mit90]. Another foundation is the area of mathematical logic. A classic approach, using proof theory and model theory is <ref> [End72] </ref>. More recent approaches, favoring proof theory (especially predicate logic) at the expense of model theory and mathematical depth and emphasizing calculation, include [DS90] [GS94] [MW93]. 2.1 -Calculus A standard reference on Church's (untyped) -calculus [Chu41] is Barendregt's book [Bar84].
Reference: [FB86] <author> Michael Fisher and Howard Barringer. </author> <title> Program Logics A Short Survey. </title> <type> Technical Report UMCS-86-11-1, </type> <institution> Department of Computer Science, University of Manchester, </institution> <address> Manchester M13 9PL, England, </address> <month> November </month> <year> 1986. </year> <note> Revised June 1987. 12 </note>
Reference-contexts: This paper sparked a wealth of research in program verification. Some surveys of results of this research are [Apt81], <ref> [FB86] </ref>, and [Cou90], the latter of which also cites other surveys. A technical reference is [LS87, Chapter 9]. A very introductory tutorial on verification from the software engineering perspective is [LG86, chapter 11].
Reference: [FF86] <author> Matthias Felleisen and Daniel P. Friedman. </author> <title> Control Operators, the SECD-Machine, and the -Calculus. </title> <type> Technical Report 197, </type> <institution> Computer Science Department, Indiana University, </institution> <month> June </month> <year> 1986. </year>
Reference-contexts: Transformational (or algebraic) techniques also underly the work on Backus's FP [Bac78] and Hoare's "Laws of Programming" for CSP [HHJ + 87]. Contrary to popular belief, it is also possible to reason "equationally" about programs with side-effects and even continuations [Boe85] <ref> [FF86] </ref> [FH89]. 3.2 Axiomatic Semantics of Programming Languages A classic text on the semantics of programming languages which treats axiomatic semantics is [dB80a]. Predicte transformer semantics, using the "weakest precondition" operator were advocated by Dijkstra for the definition of his guarded command language [Dij75].
Reference: [FH89] <author> Matthias Felleisen and Robert Hieb. </author> <title> The Revised Report on the Syntactic Theories of Sequential Control and State. </title> <type> Technical Report COMP TR89-100, </type> <institution> Department of Computer Science, Rice University, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: Transformational (or algebraic) techniques also underly the work on Backus's FP [Bac78] and Hoare's "Laws of Programming" for CSP [HHJ + 87]. Contrary to popular belief, it is also possible to reason "equationally" about programs with side-effects and even continuations [Boe85] [FF86] <ref> [FH89] </ref>. 3.2 Axiomatic Semantics of Programming Languages A classic text on the semantics of programming languages which treats axiomatic semantics is [dB80a]. Predicte transformer semantics, using the "weakest precondition" operator were advocated by Dijkstra for the definition of his guarded command language [Dij75].
Reference: [Flo67] <author> R. W. Floyd. </author> <title> Assigning Meanings to Programs. </title> <booktitle> Proceedings Symposium on Applied Mathematics, </booktitle> <volume> 19 </volume> <pages> 19-31, </pages> <year> 1967. </year>
Reference-contexts: in his seminal paper [Hoa69, Section 6], that one could define a programming language by insisting "that all implementations of the language shall `satisfy' the axioms and rules of inference which underlie proofs of the properties of the programs expressed in the language." (However, Hoare attributes this idea to Floyd <ref> [Flo67] </ref>.) Such a semantics is useful because it directly aims to support program verification. Because a logic for program verification can be used to define a programming language, it is difficult to disentangle work on program verification from work on semantics. <p> This may be accomplished in several ways; for example, reasoning from the denotational semantics 2 of the program. However, the term "program verification" is usually implies a syntactic proof in a specially constructed logic. Floyd introduced the inductive assertions and well-founded sets methods for program verification in 1967 <ref> [Flo67] </ref> (see also [LS87, Chapter 8]). (See [Cou90] for historical references to the work of Naur, Von Neumann, and Turing, who anticipated this work.) The term inductive assertions refers to the assertions that are put at every branch point in the program's flow graph; these give rise to verification conditions, which
Reference: [FWH92] <author> Daniel P. Friedman, Mitchell Wand, and Christopher T. Haynes. </author> <title> Essentials of Programming Languages. </title> <publisher> McGraw-Hill Book Co., </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: Several meta-circular interpreters for variants of LISP are discussed in Steele and Sussman's paper The Art of the Interpreter [SS78]. An excellent and more readily accessible discussion is found in Abelson and Sussman's book [ASS85], which uses Scheme. A more detailed treatment of interpreters is found in [Kam90] <ref> [FWH92] </ref>. See [KdRB91] for an approach using the CLOS meta-object protocol. However, for mathematical convenience, one wants something more abstract than an interpreter or complier. Landin overcame the circularity problem by the use of an abstract machine called the "SECD machine" [Lan64] (see also [Hen80]).
Reference: [Ghe91a] <author> Giorgio Ghelli. </author> <title> Modelling Features of Object-Oriented Languages in Second Order Functional Languages with Subtypes. </title> <editor> In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 311-340. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] <ref> [Ghe91a] </ref> [Ghe91b] [CGL92] [Cha92] [CGL93] [Cas93] [CL94]. 6.4 Type Reconstruction Type reconstruction (or type inference) is the process of reconstructing types for a program that has no type declarations. A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78].
Reference: [Ghe91b] <author> Giorgio Ghelli. </author> <title> A Static Type System for Message Passing. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 26(11) </volume> <pages> 129-145, </pages> <month> November </month> <year> 1991. </year> <booktitle> OOPSLA '91 Conference Proceedings, </booktitle> <editor> Andreas Paepcke (editor), </editor> <month> October </month> <year> 1991, </year> <type> Phoenix, </type> <institution> Arizona. </institution>
Reference-contexts: [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] <ref> [Ghe91b] </ref> [CGL92] [Cha92] [CGL93] [Cas93] [CL94]. 6.4 Type Reconstruction Type reconstruction (or type inference) is the process of reconstructing types for a program that has no type declarations. A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78].
Reference: [GHM78] <author> John V. Guttag, Ellis Horowitz, and David R. Musser. </author> <title> Abstract Data Types and Software Validation. </title> <journal> Communications of the ACM, </journal> <volume> 21(12) </volume> <pages> 1048-1064, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: A practical implementation of these ideas is found in [NHN80]. VDM also uses these techniques [Jon90]. More recent work in this area is found in [Sch90] and [Nip89]. Abstract data types (ADTs) can be specified algebraically <ref> [GHM78] </ref> [EM85] or by using pre-and post-conditions [BJ82] [Jon86] [Win87]. See [LG86, chapter 11] for a tutorial on program verification using abstract data types.
Reference: [Gir71] <author> Jean-Yves Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <booktitle> In Proceedings 2nd Scandinavian Logic Symposium, </booktitle> <pages> pages 63-92, </pages> <address> Amsterdam, 1971. </address> <publisher> North-Holland. </publisher>
Reference-contexts: See also [Har84] [Car91] [DT88]; the latter two have much material related to object-oriented programming. A still more recent survey is [Mit90]. Standard references include Girard's system F! <ref> [Gir71] </ref> (see also [Gir86] [GLT89]), and Reynolds independent work [Rey74], sometimes called the Girard-Reynolds second order lambda calculus (or SOL). Modern expositions are found in [MP85] [MH88] [Rey85] [Mit90] [Car91].
Reference: [Gir86] <author> J. Y. Girard. </author> <title> The System F of variable types, fifteen years later. </title> <journal> Theoretical Computer Science, </journal> <volume> 45 </volume> <pages> 159-192, </pages> <year> 1986. </year>
Reference-contexts: See also [Har84] [Car91] [DT88]; the latter two have much material related to object-oriented programming. A still more recent survey is [Mit90]. Standard references include Girard's system F! [Gir71] (see also <ref> [Gir86] </ref> [GLT89]), and Reynolds independent work [Rey74], sometimes called the Girard-Reynolds second order lambda calculus (or SOL). Modern expositions are found in [MP85] [MH88] [Rey85] [Mit90] [Car91].
Reference: [GL86] <author> David K. Gifford and John M. Lucassen. </author> <title> Integrating Functional and Imperative Programming. </title> <booktitle> In ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 28-38. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1986. </year>
Reference-contexts: Modern expositions are found in [MP85] [MH88] [Rey85] [Mit90] [Car91]. Other kinds of type information may be incorporated into a type system and checked at the same time as types <ref> [GL86] </ref> [LG88] [OG89]. 5 6.2 Type Theory Type theory, narrowly defined, uses the tools of constructive logic to study polymorphic type systems. A good introduction can be found in [Sch94, Chapters 8-10].
Reference: [GLT89] <author> Jean-Yves Girard, Yves Lafont, and Paul Taylor. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1989. </year>
Reference-contexts: Other introductions include [Gor88] [Sch94, Sections 6.1-6.2]. The use of -calculus for describing programming languages and as the inspiration for programming language design has been investigated by Landin [Lan65] [Lan66] and many others. For the typed -calculus, a standard reference is <ref> [GLT89] </ref>. A good introduction can be found in [Gun92, Chapter 2] and [Sch94, Sections 6.4]; both of these texts discuss the semantics of the typed lambda calculus in detail. <p> See also [Har84] [Car91] [DT88]; the latter two have much material related to object-oriented programming. A still more recent survey is [Mit90]. Standard references include Girard's system F! [Gir71] (see also [Gir86] <ref> [GLT89] </ref>), and Reynolds independent work [Rey74], sometimes called the Girard-Reynolds second order lambda calculus (or SOL). Modern expositions are found in [MP85] [MH88] [Rey85] [Mit90] [Car91]. <p> A good introduction can be found in [Sch94, Chapters 8-10]. Logical inference systems can often be translated directly into type systems due to the "Formula as Types" notion or the "Curry-Howard isomorphism" [How80] <ref> [GLT89, Chapter 3] </ref> [Con89]. Thus much research in type theory lies on the border of mathematics and computer science. Another motivation is to use type information to capture behavioral specifications, thus allowing one to reason about programs in the programming language [NP83] [Dyb90].
Reference: [GM94] <editor> Carl A. Gunter and John C. Mitchell, editors. </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming. Fondations of Computing. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1994. </year>
Reference-contexts: The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in <ref> [GM94] </ref>.
Reference: [GMP90] <author> David Guaspari, Carla Marceau, and Wolfgang Polak. </author> <title> Formal Verification of Ada Programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 1058-1075, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: See [LG86, chapter 11] for a tutorial on program verification using abstract data types. A related aspect is how the structure of a proof of correctness may help follow the hierarchical (i.e., layered) structure of the implementation design [RL77] <ref> [GMP90] </ref> [Sch82]. 3.1.2 Transformational Programming Hoare's original paper [Hoa69], treated verification as something to be done after a program was written. However, Hoare [Hoa71] and others were soon advocating the development of proofs at the same time as programs. Dijkstra and Gries became prime advocates of this technique [Dij76] [Gri81].
Reference: [GMW79] <author> Michael J. Gordon, Robin Milner, and Christopher P. Wadsworth. </author> <title> Edinburgh LCF, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1979. </year> <note> The second author is listed on the cover as Arthur J. Milner, which is clearly a mistake. 13 </note>
Reference-contexts: A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78]. Another exposition of this material, incorporating refinements found in [DM82], is found in [Car87]. Milner-style type inference system is used in the programming language ML <ref> [GMW79] </ref> [Mil84] [Har86] [HMM86]. The ideal model has been used to give a semantics to the ML type system [MPS86]. The question of whether one can do type inference for more powerful type systems has been an active area of research (e.g., [McC84] [Wan89]).
Reference: [Gol84] <author> R. Goldblatt. </author> <title> Topoi: The Categorial Analysis of Logic (Revised Edition), </title> <booktitle> volume 98 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> New York, N.Y., </address> <year> 1984. </year>
Reference-contexts: For example, categorical logic and the semantics of the typed lambda calculus are discussed in [LS86]. For me, the best introduction seems to be the first 5 chapters of <ref> [Gol84] </ref>. There are now several articles [Hoa89] and books [BW90] [AL91b] [Pie91] [Wal91] explaining category theory to computer scientists.
Reference: [Gor79] <author> Michael J. C. Gordon. </author> <title> The Denotational Description of Programming Languages. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1979. </year>
Reference-contexts: A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76]. A recent survey is found in [Mos90]. Introductory texts include <ref> [Gor79] </ref>, [All86], [Wat91], [Sch94]. An excellent new graduate text with more mathematical depth is [Gun92]. Standard works on denotational semantics are the books by Stoy [Sto77] and Schmidt [Sch86], both of which offer a comprehensive and mathematical treatment.
Reference: [Gor88] <author> Michael J. C. Gordon. </author> <title> Programming Language Theory and its Implementation. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice-Hall, Inc., </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: This book is at times highly technical, but also has sensible definitions and introductory material. A shorter account, with a reasonable introduction to the -calculus is found in [Bar90]. Other introductions include <ref> [Gor88] </ref> [Sch94, Sections 6.1-6.2]. The use of -calculus for describing programming languages and as the inspiration for programming language design has been investigated by Landin [Lan65] [Lan66] and many others. For the typed -calculus, a standard reference is [GLT89]. <p> A very introductory tutorial on verification from the software engineering perspective is [LG86, chapter 11]. The idea of developing a proof of a program at the same time the program is being developed has been eloquently advocated by Dijkstra and Gries [Dij76] [Gri81]. See <ref> [Gor88] </ref> for a more theoretical introduction that treats some aspects of theorem proving. Concurrency has always been a prime application area, because concurrent programs are so difficult to debug. Verification of concurrent programs may be handled with the Owicki-Gries method [OG76].
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80, The Language and its Implementation. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: For other work along these lines, see for example, [Mac86] [CL90] [Mit90]. The second approach to supporting data abstraction Reynolds called "procedural data abstraction". Today it goes under the more common name of "object-oriented programming" (OOP) [DMN70] [BDMN73] <ref> [GR83] </ref>. Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel [Mey88] [Mey92], both of which have insecure type systems [Coo89]. The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping.
Reference: [Gra79] <author> George Gratzer. </author> <title> Universal Algebra. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1979. </year>
Reference-contexts: The above list does not include conferences devoted to software engineering (e.g. TAPSOFT) or particular methods (e.g., category theory) where some important work is also found. 1 2 Mathematical Background The basics of universal algebra underly much of the work in semantics. Gratzer's monumental book <ref> [Gra79] </ref> is a standard reference. A generalized notion of homomorphism that is often used in semantics is Statman's logical relations [Sta85], explained in [Mit90]. Another foundation is the area of mathematical logic. A classic approach, using proof theory and model theory is [End72].
Reference: [Gri81] <editor> David Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1981. </year>
Reference-contexts: A technical reference is [LS87, Chapter 9]. A very introductory tutorial on verification from the software engineering perspective is [LG86, chapter 11]. The idea of developing a proof of a program at the same time the program is being developed has been eloquently advocated by Dijkstra and Gries [Dij76] <ref> [Gri81] </ref>. See [Gor88] for a more theoretical introduction that treats some aspects of theorem proving. Concurrency has always been a prime application area, because concurrent programs are so difficult to debug. Verification of concurrent programs may be handled with the Owicki-Gries method [OG76]. <p> However, Hoare [Hoa71] and others were soon advocating the development of proofs at the same time as programs. Dijkstra and Gries became prime advocates of this technique [Dij76] <ref> [Gri81] </ref>. More recent treatments in this style advocate a calculational approach [Coh90] [GS94]. One formalization of this approach is the refinement calculus [Bv89a][Bv89b] [Mor90] [MG90] [MV94]. The idea of formal development of program and proof has found favor in the functional programming community as well.
Reference: [GS90] <author> C. A. Gunter and D. S. Scott. </author> <title> Semantic Domains. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 8, </booktitle> <pages> pages 633-674. </pages> <publisher> North-Holland, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: An excellent new graduate text with more mathematical depth is [Gun92]. Standard works on denotational semantics are the books by Stoy [Sto77] and Schmidt [Sch86], both of which offer a comprehensive and mathematical treatment. Schmidt's book [Sch86] has an excellent discussion of domain theory (see also <ref> [GS90] </ref>) and can be consulted for references to denotational descriptions of real languages. One can use a typed functional programming language, such as Standard ML, to implement a denotational semantics. Two descriptions of this idea are [Wat86] [MA89].
Reference: [GS94] <author> David Gries and Fred B. Schneider. </author> <title> A Logical Approach to Discrete Math. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference-contexts: Another foundation is the area of mathematical logic. A classic approach, using proof theory and model theory is [End72]. More recent approaches, favoring proof theory (especially predicate logic) at the expense of model theory and mathematical depth and emphasizing calculation, include [DS90] <ref> [GS94] </ref> [MW93]. 2.1 -Calculus A standard reference on Church's (untyped) -calculus [Chu41] is Barendregt's book [Bar84]. This book is at times highly technical, but also has sensible definitions and introductory material. A shorter account, with a reasonable introduction to the -calculus is found in [Bar90]. <p> However, Hoare [Hoa71] and others were soon advocating the development of proofs at the same time as programs. Dijkstra and Gries became prime advocates of this technique [Dij76] [Gri81]. More recent treatments in this style advocate a calculational approach [Coh90] <ref> [GS94] </ref>. One formalization of this approach is the refinement calculus [Bv89a][Bv89b] [Mor90] [MG90] [MV94]. The idea of formal development of program and proof has found favor in the functional programming community as well.
Reference: [Gun92] <author> C. A. Gunter. </author> <title> Semantics of Programming Languages: Structures and Techniques. </title> <booktitle> Foundations of Computing. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: Other introductions include [Gor88] [Sch94, Sections 6.1-6.2]. The use of -calculus for describing programming languages and as the inspiration for programming language design has been investigated by Landin [Lan65] [Lan66] and many others. For the typed -calculus, a standard reference is [GLT89]. A good introduction can be found in <ref> [Gun92, Chapter 2] </ref> and [Sch94, Sections 6.4]; both of these texts discuss the semantics of the typed lambda calculus in detail. <p> A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76]. A recent survey is found in [Mos90]. Introductory texts include [Gor79], [All86], [Wat91], [Sch94]. An excellent new graduate text with more mathematical depth is <ref> [Gun92] </ref>. Standard works on denotational semantics are the books by Stoy [Sto77] and Schmidt [Sch86], both of which offer a comprehensive and mathematical treatment. Schmidt's book [Sch86] has an excellent discussion of domain theory (see also [GS90]) and can be consulted for references to denotational descriptions of real languages.
Reference: [Har84] <author> D. M. Harland. </author> <title> Polymorphic Programming Languages: Design and Implementation. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, N.Y., </address> <year> 1984. </year>
Reference-contexts: It also goes deeply into more advanced topics such as higher-order type systems and predicate-logic typing. 6.1 Polymorphism An introductory survey of modern polymorphic type systems and research results is Cardelli and Wegner's paper "On Understanding Types, Data Abstraction and Polymorphism" [CW85]. See also <ref> [Har84] </ref> [Car91] [DT88]; the latter two have much material related to object-oriented programming. A still more recent survey is [Mit90]. Standard references include Girard's system F! [Gir71] (see also [Gir86] [GLT89]), and Reynolds independent work [Rey74], sometimes called the Girard-Reynolds second order lambda calculus (or SOL).
Reference: [Har85] <author> Robert Harper. </author> <title> Modules and Persistence in Standard ML. In Persistence and Data Types: </title> <booktitle> Papers for the Appin Workshop, </booktitle> <pages> pages 419-430. </pages> <institution> Universities of Glasgow and St. Andrews, Departments of Computer Science, </institution> <month> August </month> <year> 1985. </year> <note> Persistent Programming Research Report 16. </note>
Reference-contexts: Interesting variations are found in Miranda [Tur85]. Much recent work has centered around the language ML and its modern variant Standard ML [Mil84] [MTH90] [MT91]. Besides the type inference in its type system mentioned above, Standard ML has an interesting module system [Mac84] <ref> [Har85] </ref> [HMT87].
Reference: [Har86] <author> Robert Harper. </author> <title> Introduction to Standard ML. </title> <type> Technical Report ECS-LFCS-86-14, </type> <institution> Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh, </institution> <month> November </month> <year> 1986. </year>
Reference-contexts: A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78]. Another exposition of this material, incorporating refinements found in [DM82], is found in [Car87]. Milner-style type inference system is used in the programming language ML [GMW79] [Mil84] <ref> [Har86] </ref> [HMM86]. The ideal model has been used to give a semantics to the ML type system [MPS86]. The question of whether one can do type inference for more powerful type systems has been an active area of research (e.g., [McC84] [Wan89]).
Reference: [Hen80] <author> Peter Henderson. </author> <title> Functional Programming: Application and Implementation. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1980. </year>
Reference-contexts: See [KdRB91] for an approach using the CLOS meta-object protocol. However, for mathematical convenience, one wants something more abstract than an interpreter or complier. Landin overcame the circularity problem by the use of an abstract machine called the "SECD machine" [Lan64] (see also <ref> [Hen80] </ref>). A more systematic style of operational semantics based on rewrite rules is found in Plotkin's terminal transition systems [Plo77] also known as "structural operational semantics" [Plo81] [Hen90] or a "labeled transition system" [Ast91]. Hennessy's book is an elementary introduction [Hen90].
Reference: [Hen88] <author> Matthew Hennessy. </author> <title> Algebraic Theory of Processes. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: Two descriptions of this idea are [Wat86] [MA89]. Action semantics, an offshoot of denotational semantics, is described in [Wat91] and more fully in [Mos92]. Schmidt's book [Sch86] also has a discussion of denotational semantics for concurrent systems. Hennessy's book has a discussion of more recent work in this area <ref> [Hen88] </ref>. However, denotational approaches to concurrency have not been as successful as operational semantics. 4 5 Operational Semantics A compiler or interpreter gives an operational semantics to a programming language. <p> Hennessy's book is an elementary introduction [Hen90]. This style of semantics has the advantage that it extends naturally to studies of concurrency [Mil90]. A classic reference for the operational semantics of concurrent processes is Milner's book on CCS [Mil80]. See <ref> [Hen88] </ref> and [Mil90] for more recent work in this area. 6 Type Systems Much of the modern study of semantics concerns type systems, which describe many aspects of the static semantics of programming languages. In contrast, axiomatic, denotational, and operational semantics describe the dynamic semantics of programming languages.
Reference: [Hen90] <author> Matthew Hennessy. </author> <title> The Semantics of Programming Languages: an Elementary Introduction using Structural Operational Semantics. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: Landin overcame the circularity problem by the use of an abstract machine called the "SECD machine" [Lan64] (see also [Hen80]). A more systematic style of operational semantics based on rewrite rules is found in Plotkin's terminal transition systems [Plo77] also known as "structural operational semantics" [Plo81] <ref> [Hen90] </ref> or a "labeled transition system" [Ast91]. Hennessy's book is an elementary introduction [Hen90]. This style of semantics has the advantage that it extends naturally to studies of concurrency [Mil90]. A classic reference for the operational semantics of concurrent processes is Milner's book on CCS [Mil80]. <p> A more systematic style of operational semantics based on rewrite rules is found in Plotkin's terminal transition systems [Plo77] also known as "structural operational semantics" [Plo81] <ref> [Hen90] </ref> or a "labeled transition system" [Ast91]. Hennessy's book is an elementary introduction [Hen90]. This style of semantics has the advantage that it extends naturally to studies of concurrency [Mil90]. A classic reference for the operational semantics of concurrent processes is Milner's book on CCS [Mil80].
Reference: [Hes92] <author> Wim H. Hesselink. </author> <title> Programs, Recursion, and Unbounded Choice, </title> <booktitle> volume 27 of Cam-bridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: A monograph on predicate transformer semantics is [DS90] which goes over notational issues as well as the underlying mathematics. A recent monograph that updates [dB80a] using predicate transformers is <ref> [Hes92] </ref>. An example of the use of the axiomatic semantics to describe a programming language is Hoare and Wirth's axiomatic definition of Pascal [HW73]. The use of an axiomatic semantics as a metric for the "goodness" of a language led to two language designs in the 1970s.
Reference: [HHJ + 87] <author> C. A. R. Hoare, I. J. Hayes, He Jifeng, C. C. Morgan, A. W. Roscoe, J. W. Sanders, I. H. Sorensen, J. M. Spivey, and B. A. Sufrin. </author> <title> Laws of Programming. </title> <journal> Communications of the ACM, </journal> <volume> 30(8) </volume> <pages> 672-686, </pages> <month> August </month> <year> 1987. </year> <note> See corrections in the September 1987 CACM. </note>
Reference-contexts: Some recent work in this area can be found in [Mee87] [Bir89a] [Bir89b] [Tal88]. Transformational (or algebraic) techniques also underly the work on Backus's FP [Bac78] and Hoare's "Laws of Programming" for CSP <ref> [HHJ + 87] </ref>. Contrary to popular belief, it is also possible to reason "equationally" about programs with side-effects and even continuations [Boe85] [FF86] [FH89]. 3.2 Axiomatic Semantics of Programming Languages A classic text on the semantics of programming languages which treats axiomatic semantics is [dB80a].
Reference: [HMM86] <author> Robert Harper, David MacQueen, and Robin Milner. </author> <title> Standard ML. </title> <type> Technical Report ECS-LFCS-86-2, </type> <institution> Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78]. Another exposition of this material, incorporating refinements found in [DM82], is found in [Car87]. Milner-style type inference system is used in the programming language ML [GMW79] [Mil84] [Har86] <ref> [HMM86] </ref>. The ideal model has been used to give a semantics to the ML type system [MPS86]. The question of whether one can do type inference for more powerful type systems has been an active area of research (e.g., [McC84] [Wan89]).
Reference: [HMT87] <author> Robert Harper, Robin Milner, and Mads Tofte. </author> <title> A Type Discipline for Program Modules. </title> <booktitle> In Proceedings of the International Joint Conference on Theory and Practice of Software Development (TAPSOFT), volume 250 of Lecture Notes in Computer Science, </booktitle> <pages> pages 308-319. </pages> <publisher> Springer-Verlag, </publisher> <month> March </month> <year> 1987. </year>
Reference-contexts: Interesting variations are found in Miranda [Tur85]. Much recent work has centered around the language ML and its modern variant Standard ML [Mil84] [MTH90] [MT91]. Besides the type inference in its type system mentioned above, Standard ML has an interesting module system [Mac84] [Har85] <ref> [HMT87] </ref>.
Reference: [Hoa69] <author> C. A. R. Hoare. </author> <title> An Axiomatic Basis for Computer Programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: For those familiar with (or needing) background in the semantics of abstract data type specifications, a good introduction is Burstall and Goguen's paper [BG82]. 3 Axiomatic Semantics Hoare pointed out, in his seminal paper <ref> [Hoa69, Section 6] </ref>, that one could define a programming language by insisting "that all implementations of the language shall `satisfy' the axioms and rules of inference which underlie proofs of the properties of the programs expressed in the language." (However, Hoare attributes this idea to Floyd [Flo67].) Such a semantics is <p> This shows partial correctness (that the program is correct if it terminates). The well-founded sets method allows proofs of termination. Hoare <ref> [Hoa69] </ref> was the first to present verification in terms of a logic for partial correctness that was compositional, so that program proofs are done by induction on the syntax of programs. This paper sparked a wealth of research in program verification. <p> See [LG86, chapter 11] for a tutorial on program verification using abstract data types. A related aspect is how the structure of a proof of correctness may help follow the hierarchical (i.e., layered) structure of the implementation design [RL77] [GMP90] [Sch82]. 3.1.2 Transformational Programming Hoare's original paper <ref> [Hoa69] </ref>, treated verification as something to be done after a program was written. However, Hoare [Hoa71] and others were soon advocating the development of proofs at the same time as programs. Dijkstra and Gries became prime advocates of this technique [Dij76] [Gri81].
Reference: [Hoa71] <author> C.A.R. Hoare. </author> <title> Proof of a Program: Find. </title> <journal> Communications of the ACM, </journal> <volume> 14(1) </volume> <pages> 39-45, </pages> <month> January </month> <year> 1971. </year>
Reference-contexts: A related aspect is how the structure of a proof of correctness may help follow the hierarchical (i.e., layered) structure of the implementation design [RL77] [GMP90] [Sch82]. 3.1.2 Transformational Programming Hoare's original paper [Hoa69], treated verification as something to be done after a program was written. However, Hoare <ref> [Hoa71] </ref> and others were soon advocating the development of proofs at the same time as programs. Dijkstra and Gries became prime advocates of this technique [Dij76] [Gri81]. More recent treatments in this style advocate a calculational approach [Coh90] [GS94].
Reference: [Hoa72] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: Other techniques use temporal logic (e.g., [OL82]) and "transition axioms" [Lam89]. An introduction to Hoare-style verification that discusses concurrent and distributed programs is [Al91a]. 3.1.1 Abstract Data Types Hoare also was the first to consider how verification and abstract data types interact <ref> [Hoa72] </ref>. His technique allows one to separately verify the correctness of a type's implementation and programs that use that type, and is based on the use of representation invariants and abstraction functions. A practical implementation of these ideas is found in [NHN80]. VDM also uses these techniques [Jon90].
Reference: [Hoa89] <author> C. A. R. Hoare. </author> <title> Notes on an Approach to Category Theory for Computer Scientists. </title> <editor> In Manfred Broy, editor, </editor> <booktitle> Constructive Methods in Computing Science, volume F55 of NATO ASI Series, </booktitle> <pages> pages 245-305. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1989. </year>
Reference-contexts: For example, categorical logic and the semantics of the typed lambda calculus are discussed in [LS86]. For me, the best introduction seems to be the first 5 chapters of [Gol84]. There are now several articles <ref> [Hoa89] </ref> and books [BW90] [AL91b] [Pie91] [Wal91] explaining category theory to computer scientists.
Reference: [How80] <author> W. A. Howard. </author> <title> The Formulae-as-Types notion of Construction. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 479-490. </pages> <publisher> Academic Press, Inc., </publisher> <address> New York, N.Y., </address> <year> 1980. </year>
Reference-contexts: A good introduction can be found in [Sch94, Chapters 8-10]. Logical inference systems can often be translated directly into type systems due to the "Formula as Types" notion or the "Curry-Howard isomorphism" <ref> [How80] </ref> [GLT89, Chapter 3] [Con89]. Thus much research in type theory lies on the border of mathematics and computer science. Another motivation is to use type information to capture behavioral specifications, thus allowing one to reason about programs in the programming language [NP83] [Dyb90].
Reference: [HP90] <author> Robert W. Harper and Benjamin C. Pierce. </author> <title> Extensible Records Without Subtypes. </title> <type> Technical Report CMU-CS-90-102, </type> <institution> School of Computer Science, Carnegie Mellon University, Pittsburgh, Penn., </institution> <month> February </month> <year> 1990. </year> <note> See also the 1991 POPL proceedings. </note>
Reference-contexts: By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] [AC90] [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] <ref> [HP90] </ref> [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] [Cha92] [CGL93] [Cas93] [CL94]. 6.4 Type
Reference: [Hud89] <author> Paul Hudak. </author> <title> Conception, Evolution, and Application of Functional Programming Languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 359-411, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Russell has separate mechanisms for building types and for information hiding; the same idea is found in Haskell <ref> [Hud89, Pages 387-388] </ref>. Interesting variations are found in Miranda [Tur85]. Much recent work has centered around the language ML and its modern variant Standard ML [Mil84] [MTH90] [MT91]. Besides the type inference in its type system mentioned above, Standard ML has an interesting module system [Mac84] [Har85] [HMT87].
Reference: [HW73] <author> C. A. R. Hoare and N. Wirth. </author> <title> An Axiomatic Definition of the Programming Language Pascal. </title> <journal> Acta Informatica, </journal> <volume> 2(4) </volume> <pages> 335-355, </pages> <year> 1973. </year>
Reference-contexts: A recent monograph that updates [dB80a] using predicate transformers is [Hes92]. An example of the use of the axiomatic semantics to describe a programming language is Hoare and Wirth's axiomatic definition of Pascal <ref> [HW73] </ref>. The use of an axiomatic semantics as a metric for the "goodness" of a language led to two language designs in the 1970s. Although never implemented fully, Alphard [SWL77] [Sha81] was interesting, and focused on support for both data abstraction and verification.
Reference: [Jon86] <author> Cliff B. Jones. </author> <title> Program Specification and Verification in VDM. </title> <type> Technical Report UMCS-86-10-5, </type> <institution> Department of Computer Science, University of Manchester, </institution> <address> Manch-ester M13 9PL, England, </address> <month> November </month> <year> 1986. </year>
Reference-contexts: A practical implementation of these ideas is found in [NHN80]. VDM also uses these techniques [Jon90]. More recent work in this area is found in [Sch90] and [Nip89]. Abstract data types (ADTs) can be specified algebraically [GHM78] [EM85] or by using pre-and post-conditions [BJ82] <ref> [Jon86] </ref> [Win87]. See [LG86, chapter 11] for a tutorial on program verification using abstract data types.
Reference: [Jon90] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: His technique allows one to separately verify the correctness of a type's implementation and programs that use that type, and is based on the use of representation invariants and abstraction functions. A practical implementation of these ideas is found in [NHN80]. VDM also uses these techniques <ref> [Jon90] </ref>. More recent work in this area is found in [Sch90] and [Nip89]. Abstract data types (ADTs) can be specified algebraically [GHM78] [EM85] or by using pre-and post-conditions [BJ82] [Jon86] [Win87]. See [LG86, chapter 11] for a tutorial on program verification using abstract data types.
Reference: [Kam90] <author> Samuel N. Kamin. </author> <title> Programming Languages: An Interpreter-Based Approach. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1990. </year>
Reference-contexts: Several meta-circular interpreters for variants of LISP are discussed in Steele and Sussman's paper The Art of the Interpreter [SS78]. An excellent and more readily accessible discussion is found in Abelson and Sussman's book [ASS85], which uses Scheme. A more detailed treatment of interpreters is found in <ref> [Kam90] </ref> [FWH92]. See [KdRB91] for an approach using the CLOS meta-object protocol. However, for mathematical convenience, one wants something more abstract than an interpreter or complier. Landin overcame the circularity problem by the use of an abstract machine called the "SECD machine" [Lan64] (see also [Hen80]).
Reference: [KdRB91] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year> <month> 15 </month>
Reference-contexts: An excellent and more readily accessible discussion is found in Abelson and Sussman's book [ASS85], which uses Scheme. A more detailed treatment of interpreters is found in [Kam90] [FWH92]. See <ref> [KdRB91] </ref> for an approach using the CLOS meta-object protocol. However, for mathematical convenience, one wants something more abstract than an interpreter or complier. Landin overcame the circularity problem by the use of an abstract machine called the "SECD machine" [Lan64] (see also [Hen80]).
Reference: [Kni89] <author> Kevin Knight. </author> <title> Unification: A Multidisciplinary Survey. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(1) </volume> <pages> 93-124, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: The question of whether one can do type inference for more powerful type systems has been an active area of research (e.g., [McC84] [Wan89]). A recent survey of what is known about such problems is found in [Tiu90]. See Knight's survey <ref> [Kni89] </ref> for a discussion of the central role that unification plays in type inference and more details on unification itself. 6.5 Research Languages The language Russell was developed at Cornell to investigate how types can be treated as values.
Reference: [Lam89] <author> Leslie Lamport. </author> <title> A Simple Approach to Specifying Concurrent Systems. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 32-45, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Concurrency has always been a prime application area, because concurrent programs are so difficult to debug. Verification of concurrent programs may be handled with the Owicki-Gries method [OG76]. Other techniques use temporal logic (e.g., [OL82]) and "transition axioms" <ref> [Lam89] </ref>. An introduction to Hoare-style verification that discusses concurrent and distributed programs is [Al91a]. 3.1.1 Abstract Data Types Hoare also was the first to consider how verification and abstract data types interact [Hoa72].
Reference: [Lan64] <author> P. J. Landin. </author> <title> The Mechanical Evaluation of Expressions. </title> <journal> Computer Journal, </journal> <volume> 6 </volume> <pages> 308-320, </pages> <year> 1964. </year> <note> See also Landin's paper "A Lambda-Calculus Approach" in Advances in Programming and Non-Numerical Computation, </note> <editor> L. Fox (ed.), </editor> <publisher> Pergamon Press, Oxford, </publisher> <year> 1966. </year>
Reference-contexts: See [KdRB91] for an approach using the CLOS meta-object protocol. However, for mathematical convenience, one wants something more abstract than an interpreter or complier. Landin overcame the circularity problem by the use of an abstract machine called the "SECD machine" <ref> [Lan64] </ref> (see also [Hen80]). A more systematic style of operational semantics based on rewrite rules is found in Plotkin's terminal transition systems [Plo77] also known as "structural operational semantics" [Plo81] [Hen90] or a "labeled transition system" [Ast91]. Hennessy's book is an elementary introduction [Hen90].
Reference: [Lan65] <author> P. J. Landin. </author> <title> A Correspondence Algol 60 and Church's Lambda Notation. </title> <journal> Communications of the ACM, </journal> <volume> 8 </volume> <pages> 89-101, 158-165, </pages> <year> 1965. </year>
Reference-contexts: A shorter account, with a reasonable introduction to the -calculus is found in [Bar90]. Other introductions include [Gor88] [Sch94, Sections 6.1-6.2]. The use of -calculus for describing programming languages and as the inspiration for programming language design has been investigated by Landin <ref> [Lan65] </ref> [Lan66] and many others. For the typed -calculus, a standard reference is [GLT89]. A good introduction can be found in [Gun92, Chapter 2] and [Sch94, Sections 6.4]; both of these texts discuss the semantics of the typed lambda calculus in detail.
Reference: [Lan66] <author> P. J. Landin. </author> <title> The Next 700 Programming Languages. </title> <journal> Communications of the ACM, </journal> <volume> 9(3) </volume> <pages> 157-166, </pages> <month> March </month> <year> 1966. </year>
Reference-contexts: A shorter account, with a reasonable introduction to the -calculus is found in [Bar90]. Other introductions include [Gor88] [Sch94, Sections 6.1-6.2]. The use of -calculus for describing programming languages and as the inspiration for programming language design has been investigated by Landin [Lan65] <ref> [Lan66] </ref> and many others. For the typed -calculus, a standard reference is [GLT89]. A good introduction can be found in [Gun92, Chapter 2] and [Sch94, Sections 6.4]; both of these texts discuss the semantics of the typed lambda calculus in detail.
Reference: [Lan71] <author> Saunders Mac Lane. </author> <title> Categories for the Working Mathematician, volume 5 of Graduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1971. </year>
Reference-contexts: Schmidt's book [Sch94] is also a good introduction to higher-order typed lambda calculi, and contains references to work on such higher-order extensions. 2.2 Category Theory Increasingly, especially in denotational semantics, category theory <ref> [Lan71] </ref> [LS91] is used in research and for the elegant presentation of results. For example, categorical logic and the semantics of the typed lambda calculus are discussed in [LS86]. For me, the best introduction seems to be the first 5 chapters of [Gol84].
Reference: [LG86] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: This paper sparked a wealth of research in program verification. Some surveys of results of this research are [Apt81], [FB86], and [Cou90], the latter of which also cites other surveys. A technical reference is [LS87, Chapter 9]. A very introductory tutorial on verification from the software engineering perspective is <ref> [LG86, chapter 11] </ref>. The idea of developing a proof of a program at the same time the program is being developed has been eloquently advocated by Dijkstra and Gries [Dij76] [Gri81]. See [Gor88] for a more theoretical introduction that treats some aspects of theorem proving. <p> A practical implementation of these ideas is found in [NHN80]. VDM also uses these techniques [Jon90]. More recent work in this area is found in [Sch90] and [Nip89]. Abstract data types (ADTs) can be specified algebraically [GHM78] [EM85] or by using pre-and post-conditions [BJ82] [Jon86] [Win87]. See <ref> [LG86, chapter 11] </ref> for a tutorial on program verification using abstract data types. <p> User defined types also go by the name of "abstract data types" (ADTs), and their support in a type system is exemplified by the language CLU [LSAS77] <ref> [LG86] </ref>. Mitchell and Plotkin connected this approach, ADTs, to the second-order lambda calculus [MP85]. This idea has been used to show some representation independence results [Mit86]. For other work along these lines, see for example, [Mac86] [CL90] [Mit90]. The second approach to supporting data abstraction Reynolds called "procedural data abstraction".
Reference: [LG88] <author> John M. Lucassen and David K. Gifford. </author> <title> Polymorphic Effect Systems. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, Calif., </address> <pages> pages 47-57. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1988. </year>
Reference-contexts: Modern expositions are found in [MP85] [MH88] [Rey85] [Mit90] [Car91]. Other kinds of type information may be incorporated into a type system and checked at the same time as types [GL86] <ref> [LG88] </ref> [OG89]. 5 6.2 Type Theory Type theory, narrowly defined, uses the tools of constructive logic to study polymorphic type systems. A good introduction can be found in [Sch94, Chapters 8-10].
Reference: [LGH + 78] <author> R. L. London, J. V. Guttag, J. J. Horning, B. W. Lampson, J. G. Mitchell, and G. J. Popek. </author> <title> Proof Rules for the Programming Language Euclid. </title> <journal> Acta Informatica, </journal> <volume> 10(1) </volume> <pages> 1-26, </pages> <year> 1978. </year>
Reference-contexts: The use of an axiomatic semantics as a metric for the "goodness" of a language led to two language designs in the 1970s. Although never implemented fully, Alphard [SWL77] [Sha81] was interesting, and focused on support for both data abstraction and verification. The language Euclid <ref> [LGH + 78] </ref> [PHL + 77] was implemented, and has been used for various large projects. 3.3 Algebraic Semantics While most axiomatic approaches use Hoare logic or variations on Hoare logic, there have been a few attempts to use the techniques of algebra and equational specification to define programming languages.
Reference: [LS86] <author> J. Lambek and P. J. Scott. </author> <title> Introduction to higher order categorical logic, </title> <booktitle> volume 7 of Cambridge Studies in Advanced Mathematics. </booktitle> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1986. </year>
Reference-contexts: For example, categorical logic and the semantics of the typed lambda calculus are discussed in <ref> [LS86] </ref>. For me, the best introduction seems to be the first 5 chapters of [Gol84]. There are now several articles [Hoa89] and books [BW90] [AL91b] [Pie91] [Wal91] explaining category theory to computer scientists.
Reference: [LS87] <author> Jacques Loeckx and Kurt Sieber. </author> <title> The Foundations of Program Verification (Second edition). </title> <publisher> John Wiley and Sons, </publisher> <address> New York, N.Y., </address> <year> 1987. </year>
Reference-contexts: However, the term "program verification" is usually implies a syntactic proof in a specially constructed logic. Floyd introduced the inductive assertions and well-founded sets methods for program verification in 1967 [Flo67] (see also <ref> [LS87, Chapter 8] </ref>). (See [Cou90] for historical references to the work of Naur, Von Neumann, and Turing, who anticipated this work.) The term inductive assertions refers to the assertions that are put at every branch point in the program's flow graph; these give rise to verification conditions, which state that along <p> This paper sparked a wealth of research in program verification. Some surveys of results of this research are [Apt81], [FB86], and [Cou90], the latter of which also cites other surveys. A technical reference is <ref> [LS87, Chapter 9] </ref>. A very introductory tutorial on verification from the software engineering perspective is [LG86, chapter 11]. The idea of developing a proof of a program at the same time the program is being developed has been eloquently advocated by Dijkstra and Gries [Dij76] [Gri81].
Reference: [LS91] <author> F. W. Lawvere and Stephen H. Schanuel. </author> <title> Conceptual Mathematics: a first introduction to categories. </title> <booktitle> Buffalo Workshop Press, </booktitle> <address> Buffalo, NY, </address> <year> 1991. </year>
Reference-contexts: Schmidt's book [Sch94] is also a good introduction to higher-order typed lambda calculi, and contains references to work on such higher-order extensions. 2.2 Category Theory Increasingly, especially in denotational semantics, category theory [Lan71] <ref> [LS91] </ref> is used in research and for the elegant presentation of results. For example, categorical logic and the semantics of the typed lambda calculus are discussed in [LS86]. For me, the best introduction seems to be the first 5 chapters of [Gol84].
Reference: [LSAS77] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and Craig Schaffert. </author> <title> Abstraction Mechanisms in CLU. </title> <journal> Communications of the ACM, </journal> <volume> 20(8) </volume> <pages> 564-576, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: User defined types also go by the name of "abstract data types" (ADTs), and their support in a type system is exemplified by the language CLU <ref> [LSAS77] </ref> [LG86]. Mitchell and Plotkin connected this approach, ADTs, to the second-order lambda calculus [MP85]. This idea has been used to show some representation independence results [Mit86]. For other work along these lines, see for example, [Mac86] [CL90] [Mit90].
Reference: [MA86] <author> Ernest G. Manes and Michael A. Arbib. </author> <title> Algebraic Approaches to Program Semantics. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1986. </year>
Reference-contexts: Examples include <ref> [MA86] </ref> [BWP87]. 4 Denotational Semantics In contrast to axiomatic semantics, denotational semantics [Str66] [SS71] [MS76] [Sto77] [Sco81] [Sch86] explicitly constructs mathematical models of programming languages. A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76].
Reference: [MA89] <author> C. McDonald and L. Allison. </author> <title> Denotational Semantics of a Command Interpreter and their Implementation in Standard ML. </title> <journal> The Computer Journal, </journal> <volume> 32(5) </volume> <pages> 422-431, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Schmidt's book [Sch86] has an excellent discussion of domain theory (see also [GS90]) and can be consulted for references to denotational descriptions of real languages. One can use a typed functional programming language, such as Standard ML, to implement a denotational semantics. Two descriptions of this idea are [Wat86] <ref> [MA89] </ref>. Action semantics, an offshoot of denotational semantics, is described in [Wat91] and more fully in [Mos92]. Schmidt's book [Sch86] also has a discussion of denotational semantics for concurrent systems. Hennessy's book has a discussion of more recent work in this area [Hen88].
Reference: [Mac84] <author> David MacQueen. </author> <title> Modules for Standard ML. </title> <booktitle> In Proceedings of the Symposium on LISP and Functional Programming, </booktitle> <address> Austin, Texas, </address> <pages> pages 198-207. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1984. </year> <month> 16 </month>
Reference-contexts: Interesting variations are found in Miranda [Tur85]. Much recent work has centered around the language ML and its modern variant Standard ML [Mil84] [MTH90] [MT91]. Besides the type inference in its type system mentioned above, Standard ML has an interesting module system <ref> [Mac84] </ref> [Har85] [HMT87].
Reference: [Mac86] <author> David MacQueen. </author> <title> Using Dependent Types to Express Modular Structure. </title> <booktitle> In Confer--ence Record of the Thirteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, Florida, </address> <pages> pages 277-286. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1986. </year>
Reference-contexts: Mitchell and Plotkin connected this approach, ADTs, to the second-order lambda calculus [MP85]. This idea has been used to show some representation independence results [Mit86]. For other work along these lines, see for example, <ref> [Mac86] </ref> [CL90] [Mit90]. The second approach to supporting data abstraction Reynolds called "procedural data abstraction". Today it goes under the more common name of "object-oriented programming" (OOP) [DMN70] [BDMN73] [GR83].
Reference: [McC60] <author> John McCarthy. </author> <title> Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I. </title> <journal> Communications of the ACM, </journal> <volume> 3(4) </volume> <pages> 184-195, </pages> <month> April </month> <year> 1960. </year>
Reference-contexts: This style of semantics dates back to the earliest programming languages, and was first formalized in the idea of a meta-circular interpreter for LISP <ref> [McC60] </ref>. Meta-circular interpreters are still useful for teaching purposes, and for prototyping programming language designs. Several meta-circular interpreters for variants of LISP are discussed in Steele and Sussman's paper The Art of the Interpreter [SS78].
Reference: [McC84] <author> Nancy McCracken. </author> <title> The Typechecking of Programs with Implicit Type Structure. </title> <editor> In D. B. MacQueen G. Kahn and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types: International Symposium, Sophia-Antipolis, France, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 301-315. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> June </month> <year> 1984. </year>
Reference-contexts: The ideal model has been used to give a semantics to the ML type system [MPS86]. The question of whether one can do type inference for more powerful type systems has been an active area of research (e.g., <ref> [McC84] </ref> [Wan89]). A recent survey of what is known about such problems is found in [Tiu90].
Reference: [Mee87] <author> L. G. L. </author> <title> T Meertens, editor. Program Specification and Transformation. </title> <publisher> North-Holland, </publisher> <year> 1987. </year>
Reference-contexts: Some recent work in this area can be found in <ref> [Mee87] </ref> [Bir89a] [Bir89b] [Tal88]. Transformational (or algebraic) techniques also underly the work on Backus's FP [Bac78] and Hoare's "Laws of Programming" for CSP [HHJ + 87].
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: The second approach to supporting data abstraction Reynolds called "procedural data abstraction". Today it goes under the more common name of "object-oriented programming" (OOP) [DMN70] [BDMN73] [GR83]. Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel <ref> [Mey88] </ref> [Mey92], both of which have insecure type systems [Coo89]. The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94].
Reference: [Mey92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. Object-Oriented Series. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: The second approach to supporting data abstraction Reynolds called "procedural data abstraction". Today it goes under the more common name of "object-oriented programming" (OOP) [DMN70] [BDMN73] [GR83]. Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel [Mey88] <ref> [Mey92] </ref>, both of which have insecure type systems [Coo89]. The language Trellis/Owl [SCB + 86] features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94].
Reference: [MG90] <author> Carroll Morgan and P. H . B. Gardiner. </author> <title> Data Refinement by Calculation. </title> <journal> Acta Infor-matica, </journal> <volume> 27(6) </volume> <pages> 481-503, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Dijkstra and Gries became prime advocates of this technique [Dij76] [Gri81]. More recent treatments in this style advocate a calculational approach [Coh90] [GS94]. One formalization of this approach is the refinement calculus [Bv89a][Bv89b] [Mor90] <ref> [MG90] </ref> [MV94]. The idea of formal development of program and proof has found favor in the functional programming community as well.
Reference: [MH88] <author> John C. Mitchell and Robert Harper. </author> <title> The Essence of ML. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, Calif., </address> <pages> pages 28-46. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1988. </year>
Reference-contexts: A still more recent survey is [Mit90]. Standard references include Girard's system F! [Gir71] (see also [Gir86] [GLT89]), and Reynolds independent work [Rey74], sometimes called the Girard-Reynolds second order lambda calculus (or SOL). Modern expositions are found in [MP85] <ref> [MH88] </ref> [Rey85] [Mit90] [Car91]. Other kinds of type information may be incorporated into a type system and checked at the same time as types [GL86] [LG88] [OG89]. 5 6.2 Type Theory Type theory, narrowly defined, uses the tools of constructive logic to study polymorphic type systems.
Reference: [Mil78] <author> Robin Milner. </author> <title> A Theory of Type Polymorphism in Programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17(3) </volume> <pages> 348-375, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" <ref> [Mil78] </ref>. Another exposition of this material, incorporating refinements found in [DM82], is found in [Car87]. Milner-style type inference system is used in the programming language ML [GMW79] [Mil84] [Har86] [HMM86]. The ideal model has been used to give a semantics to the ML type system [MPS86].
Reference: [Mil80] <author> Robin Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 94 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1980. </year>
Reference-contexts: Hennessy's book is an elementary introduction [Hen90]. This style of semantics has the advantage that it extends naturally to studies of concurrency [Mil90]. A classic reference for the operational semantics of concurrent processes is Milner's book on CCS <ref> [Mil80] </ref>. See [Hen88] and [Mil90] for more recent work in this area. 6 Type Systems Much of the modern study of semantics concerns type systems, which describe many aspects of the static semantics of programming languages. In contrast, axiomatic, denotational, and operational semantics describe the dynamic semantics of programming languages.
Reference: [Mil84] <author> Robin Milner. </author> <title> A Proposal for Standard ML. </title> <booktitle> In Conference Record of the ACM Symposium on LISP and Functional Programming, </booktitle> <address> Austin, Texas, </address> <pages> pages 184-197. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1984. </year> <note> Also appeared as Tech. Report CSR-157-83, </note> <institution> University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <year> 1983. </year>
Reference-contexts: A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78]. Another exposition of this material, incorporating refinements found in [DM82], is found in [Car87]. Milner-style type inference system is used in the programming language ML [GMW79] <ref> [Mil84] </ref> [Har86] [HMM86]. The ideal model has been used to give a semantics to the ML type system [MPS86]. The question of whether one can do type inference for more powerful type systems has been an active area of research (e.g., [McC84] [Wan89]). <p> Russell has separate mechanisms for building types and for information hiding; the same idea is found in Haskell [Hud89, Pages 387-388]. Interesting variations are found in Miranda [Tur85]. Much recent work has centered around the language ML and its modern variant Standard ML <ref> [Mil84] </ref> [MTH90] [MT91]. Besides the type inference in its type system mentioned above, Standard ML has an interesting module system [Mac84] [Har85] [HMT87].
Reference: [Mil90] <author> Robin Milner. </author> <title> Operational and Algebraic Semantics of Concurrent Processes. </title> <editor> In J. van Leewen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 19, </booktitle> <pages> pages 1201-1242. </pages> <publisher> The MIT Press, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: Hennessy's book is an elementary introduction [Hen90]. This style of semantics has the advantage that it extends naturally to studies of concurrency <ref> [Mil90] </ref>. A classic reference for the operational semantics of concurrent processes is Milner's book on CCS [Mil80]. See [Hen88] and [Mil90] for more recent work in this area. 6 Type Systems Much of the modern study of semantics concerns type systems, which describe many aspects of the static semantics of programming <p> Hennessy's book is an elementary introduction [Hen90]. This style of semantics has the advantage that it extends naturally to studies of concurrency <ref> [Mil90] </ref>. A classic reference for the operational semantics of concurrent processes is Milner's book on CCS [Mil80]. See [Hen88] and [Mil90] for more recent work in this area. 6 Type Systems Much of the modern study of semantics concerns type systems, which describe many aspects of the static semantics of programming languages. In contrast, axiomatic, denotational, and operational semantics describe the dynamic semantics of programming languages.
Reference: [Mit86] <author> John C. Mitchell. </author> <title> Representation Independence and Data Abstraction (preliminary version). </title> <booktitle> In Conference Record of the Thirteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, Florida, </address> <pages> pages 263-276. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1986. </year>
Reference-contexts: Mitchell and Plotkin connected this approach, ADTs, to the second-order lambda calculus [MP85]. This idea has been used to show some representation independence results <ref> [Mit86] </ref>. For other work along these lines, see for example, [Mac86] [CL90] [Mit90]. The second approach to supporting data abstraction Reynolds called "procedural data abstraction". Today it goes under the more common name of "object-oriented programming" (OOP) [DMN70] [BDMN73] [GR83].
Reference: [Mit90] <author> John C. Mitchell. </author> <title> Type systems for programming languages. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 8, </booktitle> <pages> pages 365-458. </pages> <publisher> North-Holland, </publisher> <address> New York, N.Y., </address> <year> 1990. </year> <month> 17 </month>
Reference-contexts: Gratzer's monumental book [Gra79] is a standard reference. A generalized notion of homomorphism that is often used in semantics is Statman's logical relations [Sta85], explained in <ref> [Mit90] </ref>. Another foundation is the area of mathematical logic. A classic approach, using proof theory and model theory is [End72]. <p> See also [Har84] [Car91] [DT88]; the latter two have much material related to object-oriented programming. A still more recent survey is <ref> [Mit90] </ref>. Standard references include Girard's system F! [Gir71] (see also [Gir86] [GLT89]), and Reynolds independent work [Rey74], sometimes called the Girard-Reynolds second order lambda calculus (or SOL). Modern expositions are found in [MP85] [MH88] [Rey85] [Mit90] [Car91]. <p> A still more recent survey is <ref> [Mit90] </ref>. Standard references include Girard's system F! [Gir71] (see also [Gir86] [GLT89]), and Reynolds independent work [Rey74], sometimes called the Girard-Reynolds second order lambda calculus (or SOL). Modern expositions are found in [MP85] [MH88] [Rey85] [Mit90] [Car91]. Other kinds of type information may be incorporated into a type system and checked at the same time as types [GL86] [LG88] [OG89]. 5 6.2 Type Theory Type theory, narrowly defined, uses the tools of constructive logic to study polymorphic type systems. <p> Mitchell and Plotkin connected this approach, ADTs, to the second-order lambda calculus [MP85]. This idea has been used to show some representation independence results [Mit86]. For other work along these lines, see for example, [Mac86] [CL90] <ref> [Mit90] </ref>. The second approach to supporting data abstraction Reynolds called "procedural data abstraction". Today it goes under the more common name of "object-oriented programming" (OOP) [DMN70] [BDMN73] [GR83]. Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel [Mey88] [Mey92], both of which have insecure type systems [Coo89].
Reference: [ML75] <author> P. Martin-Lof. </author> <title> An Intuitionistic Theory of Types: Predictive Part. </title> <editor> In H. E. Rose and J. C. Sheperdson, editors, </editor> <booktitle> Logic Colloquium '73, volume 80 of Studies in Logic, </booktitle> <pages> pages 73-118. </pages> <publisher> North-Holland Publishing Co., </publisher> <address> New York, N.Y., </address> <year> 1975. </year>
Reference-contexts: Another motivation is to use type information to capture behavioral specifications, thus allowing one to reason about programs in the programming language [NP83] [Dyb90]. The principal groups working on type theory include deBruijn and others working on AU-TOMATH [dB80b], Martin-Lof's and followers <ref> [ML75] </ref> [ML82] [Bac89], Constable's group at Cor-nell has been very active in this area. Their language PRL which uses constructive mathematics, is described in the paper "Proofs as Programs" [BC85]. A related language is PL/CV3 [CZ84]. Coquand and Huet's group is responsible for the "calculus of constructions" [CH88].
Reference: [ML82] <author> Per Martin-Lof. </author> <title> Constructive Mathematics and Computer Programming. </title> <editor> In L. J. Cohen et al., editors, </editor> <booktitle> Logic, Methodology, and Philosophy of Science VI (Proceedings of the Sixth International Congress; Hannover, 1979), volume 104 of Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 153-175. </pages> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1982. </year>
Reference-contexts: Another motivation is to use type information to capture behavioral specifications, thus allowing one to reason about programs in the programming language [NP83] [Dyb90]. The principal groups working on type theory include deBruijn and others working on AU-TOMATH [dB80b], Martin-Lof's and followers [ML75] <ref> [ML82] </ref> [Bac89], Constable's group at Cor-nell has been very active in this area. Their language PRL which uses constructive mathematics, is described in the paper "Proofs as Programs" [BC85]. A related language is PL/CV3 [CZ84]. Coquand and Huet's group is responsible for the "calculus of constructions" [CH88].
Reference: [MMM91] <author> John Mitchell, Sigurd Meldal, and Neel Madhav. </author> <title> An extension of Standard ML modules with subtyping and inheritance. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, Orlando, </booktitle> <pages> pages 270-278. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94]. Recent theoretical work on types for OOP includes the following [Car88b] [Car88a] [CM89] [AC90] [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] <ref> [MMM91] </ref> [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see [Rey80] [Ghe91a] [Ghe91b] [CGL92] [Cha92] [CGL93] [Cas93] [CL94]. 6.4 Type Reconstruction
Reference: [Mor73] <author> James H. Morris, Jr. </author> <title> Protection in Programming Languages. </title> <journal> Communications of the ACM, </journal> <volume> 16(1) </volume> <pages> 15-21, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: In contrast, axiomatic, denotational, and operational semantics describe the dynamic semantics of programming languages. The purpose of type checking is nicely summarized by Morris as a mechanism that allows program modules to protect objects from unwanted discovery, modification, and impersonation <ref> [Mor73] </ref>. Wegbreit's discussion of the extensible language EL1, is also good background [Weg74]. Schmidt's recent book [Sch94] starts treats type systems in the context of programming language semantics.
Reference: [Mor90] <author> Carroll Morgan. </author> <title> Programming from Specifications. </title> <publisher> Prentice Hall International, </publisher> <address> Hemp-stead, UK, </address> <year> 1990. </year>
Reference-contexts: Dijkstra and Gries became prime advocates of this technique [Dij76] [Gri81]. More recent treatments in this style advocate a calculational approach [Coh90] [GS94]. One formalization of this approach is the refinement calculus [Bv89a][Bv89b] <ref> [Mor90] </ref> [MG90] [MV94]. The idea of formal development of program and proof has found favor in the functional programming community as well.
Reference: [Mos90] <author> Peter D. Mosses. </author> <title> Denotational Semantics. </title> <editor> In J. van Leewen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 11, </booktitle> <pages> pages 577-631. </pages> <publisher> The MIT Press, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76]. A recent survey is found in <ref> [Mos90] </ref>. Introductory texts include [Gor79], [All86], [Wat91], [Sch94]. An excellent new graduate text with more mathematical depth is [Gun92]. Standard works on denotational semantics are the books by Stoy [Sto77] and Schmidt [Sch86], both of which offer a comprehensive and mathematical treatment.
Reference: [Mos92] <author> Peter D. Mosses. </author> <title> Action Semantics, </title> <booktitle> volume 26 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: One can use a typed functional programming language, such as Standard ML, to implement a denotational semantics. Two descriptions of this idea are [Wat86] [MA89]. Action semantics, an offshoot of denotational semantics, is described in [Wat91] and more fully in <ref> [Mos92] </ref>. Schmidt's book [Sch86] also has a discussion of denotational semantics for concurrent systems. Hennessy's book has a discussion of more recent work in this area [Hen88].
Reference: [MP85] <author> John C. Mitchell and Gordon D. Plotkin. </author> <title> Abstract Types have Existential Type. </title> <booktitle> In Conference Record of the 12th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> New Orleans, </address> <publisher> Louisana, </publisher> <pages> pages 37-51. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1985. </year>
Reference-contexts: A still more recent survey is [Mit90]. Standard references include Girard's system F! [Gir71] (see also [Gir86] [GLT89]), and Reynolds independent work [Rey74], sometimes called the Girard-Reynolds second order lambda calculus (or SOL). Modern expositions are found in <ref> [MP85] </ref> [MH88] [Rey85] [Mit90] [Car91]. Other kinds of type information may be incorporated into a type system and checked at the same time as types [GL86] [LG88] [OG89]. 5 6.2 Type Theory Type theory, narrowly defined, uses the tools of constructive logic to study polymorphic type systems. <p> User defined types also go by the name of "abstract data types" (ADTs), and their support in a type system is exemplified by the language CLU [LSAS77] [LG86]. Mitchell and Plotkin connected this approach, ADTs, to the second-order lambda calculus <ref> [MP85] </ref>. This idea has been used to show some representation independence results [Mit86]. For other work along these lines, see for example, [Mac86] [CL90] [Mit90]. The second approach to supporting data abstraction Reynolds called "procedural data abstraction".
Reference: [MPS86] <author> David MacQueen, Gordon Plotkin, and Ravi Sethi. </author> <title> An Ideal Model for Recursive Polymorphic Types. </title> <journal> Information and Control, </journal> 71(1/2):95-130, Oct./Nov. 1986. 
Reference-contexts: Another exposition of this material, incorporating refinements found in [DM82], is found in [Car87]. Milner-style type inference system is used in the programming language ML [GMW79] [Mil84] [Har86] [HMM86]. The ideal model has been used to give a semantics to the ML type system <ref> [MPS86] </ref>. The question of whether one can do type inference for more powerful type systems has been an active area of research (e.g., [McC84] [Wan89]). A recent survey of what is known about such problems is found in [Tiu90].
Reference: [MS76] <author> R. E. Milne and C. Strachey. </author> <title> A Theory of Programming Language Semantics (part a, part b). </title> <publisher> Chapman & Hall, </publisher> <address> London, </address> <year> 1976. </year>
Reference-contexts: Examples include [MA86] [BWP87]. 4 Denotational Semantics In contrast to axiomatic semantics, denotational semantics [Str66] [SS71] <ref> [MS76] </ref> [Sto77] [Sco81] [Sch86] explicitly constructs mathematical models of programming languages. A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76]. A recent survey is found in [Mos90]. Introductory texts include [Gor79], [All86], [Wat91], [Sch94].
Reference: [MT91] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1991. </year>
Reference-contexts: Russell has separate mechanisms for building types and for information hiding; the same idea is found in Haskell [Hud89, Pages 387-388]. Interesting variations are found in Miranda [Tur85]. Much recent work has centered around the language ML and its modern variant Standard ML [Mil84] [MTH90] <ref> [MT91] </ref>. Besides the type inference in its type system mentioned above, Standard ML has an interesting module system [Mac84] [Har85] [HMT87].
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: Russell has separate mechanisms for building types and for information hiding; the same idea is found in Haskell [Hud89, Pages 387-388]. Interesting variations are found in Miranda [Tur85]. Much recent work has centered around the language ML and its modern variant Standard ML [Mil84] <ref> [MTH90] </ref> [MT91]. Besides the type inference in its type system mentioned above, Standard ML has an interesting module system [Mac84] [Har85] [HMT87].
Reference: [MV94] <author> Carroll Morgan and Trevor Vickers, </author> <title> editors. </title> <booktitle> On the refinement calculus. Formal approaches of computing and information technology series. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference-contexts: Dijkstra and Gries became prime advocates of this technique [Dij76] [Gri81]. More recent treatments in this style advocate a calculational approach [Coh90] [GS94]. One formalization of this approach is the refinement calculus [Bv89a][Bv89b] [Mor90] [MG90] <ref> [MV94] </ref>. The idea of formal development of program and proof has found favor in the functional programming community as well.
Reference: [MW80] <author> Zohar Manna and Richard Waldinger. </author> <title> A Deductive Approach to Program Synthesis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(1) </volume> <pages> 90-121, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: The idea of formal development of program and proof has found favor in the functional programming community as well. The idea behind transformational programming is to transform the specification of a program into an efficient version [BD77] <ref> [MW80] </ref> [Bal81] [CHT81]; these references are characterized by their work with equational logic (instead of predicate transformers or a Hoare 3 logic), their use of algebraic techniques, and the general focus on functional languages. Some recent work in this area can be found in [Mee87] [Bir89a] [Bir89b] [Tal88].
Reference: [MW93] <author> Zohar Manna and Richard Waldinger. </author> <booktitle> The Deductive Foundations of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> New York, N.Y., </address> <year> 1993. </year> <month> 18 </month>
Reference-contexts: Another foundation is the area of mathematical logic. A classic approach, using proof theory and model theory is [End72]. More recent approaches, favoring proof theory (especially predicate logic) at the expense of model theory and mathematical depth and emphasizing calculation, include [DS90] [GS94] <ref> [MW93] </ref>. 2.1 -Calculus A standard reference on Church's (untyped) -calculus [Chu41] is Barendregt's book [Bar84]. This book is at times highly technical, but also has sensible definitions and introductory material. A shorter account, with a reasonable introduction to the -calculus is found in [Bar90].
Reference: [NHN80] <author> Reiji Nakajima, Michio Honda, and Hayao Nakahara. </author> <title> Hierarchical Program Specifica--tion and Verification | a Many-sorted Logical Approach. </title> <journal> Acta Informatica, </journal> <volume> 14(2) </volume> <pages> 135-155, </pages> <year> 1980. </year>
Reference-contexts: His technique allows one to separately verify the correctness of a type's implementation and programs that use that type, and is based on the use of representation invariants and abstraction functions. A practical implementation of these ideas is found in <ref> [NHN80] </ref>. VDM also uses these techniques [Jon90]. More recent work in this area is found in [Sch90] and [Nip89]. Abstract data types (ADTs) can be specified algebraically [GHM78] [EM85] or by using pre-and post-conditions [BJ82] [Jon86] [Win87].
Reference: [Nip89] <author> T. Nipkow. </author> <title> Formal Verification of Data Type Refinement | Theory and Practice. </title> <editor> In J. W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Stepwise Refinement of Distributed Systems, Models, Formalisms, Correctness, </title> <booktitle> REX Workshop, Mook, The Netherlands, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 561-591. </pages> <address> Spring-Verlag, </address> <month> May/June </month> <year> 1989. </year>
Reference-contexts: A practical implementation of these ideas is found in [NHN80]. VDM also uses these techniques [Jon90]. More recent work in this area is found in [Sch90] and <ref> [Nip89] </ref>. Abstract data types (ADTs) can be specified algebraically [GHM78] [EM85] or by using pre-and post-conditions [BJ82] [Jon86] [Win87]. See [LG86, chapter 11] for a tutorial on program verification using abstract data types.
Reference: [NN92] <author> F. Nielson and H.R. Neilson. </author> <title> Semantics with Applications A Formal Introduction. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: If you wish to probe an area more deeply, you might start with the papers mentioned, follow their references, and also use the Science Citation Index to see what papers have referenced the ones mentioned. 1 General Sources Two recent texts that cover many different approaches to semantics are: <ref> [NN92] </ref> [Win93]. Articles discussing principal topics in semantics, containing many references, appear in volume B of the Handbook of Theoretical Computer Science [vL90].
Reference: [NP83] <author> Bengt Nordstrom and Kent Peterson. </author> <title> Types and Specifications. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing 83, </booktitle> <pages> pages 915-920. </pages> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <month> September </month> <year> 1983. </year> <booktitle> Proceedings of the IFIP 9th World Computer Congress, </booktitle> <address> Paris, France. </address>
Reference-contexts: Thus much research in type theory lies on the border of mathematics and computer science. Another motivation is to use type information to capture behavioral specifications, thus allowing one to reason about programs in the programming language <ref> [NP83] </ref> [Dyb90]. The principal groups working on type theory include deBruijn and others working on AU-TOMATH [dB80b], Martin-Lof's and followers [ML75] [ML82] [Bac89], Constable's group at Cor-nell has been very active in this area. Their language PRL which uses constructive mathematics, is described in the paper "Proofs as Programs" [BC85].
Reference: [OG76] <author> Susan Owicki and David Gries. </author> <title> Verifying Properties of Parallel Programs: An Axiomatic Approach. </title> <journal> Communications of the ACM, </journal> <volume> 19(5) </volume> <pages> 279-285, </pages> <month> May </month> <year> 1976. </year>
Reference-contexts: See [Gor88] for a more theoretical introduction that treats some aspects of theorem proving. Concurrency has always been a prime application area, because concurrent programs are so difficult to debug. Verification of concurrent programs may be handled with the Owicki-Gries method <ref> [OG76] </ref>. Other techniques use temporal logic (e.g., [OL82]) and "transition axioms" [Lam89]. An introduction to Hoare-style verification that discusses concurrent and distributed programs is [Al91a]. 3.1.1 Abstract Data Types Hoare also was the first to consider how verification and abstract data types interact [Hoa72].
Reference: [OG89] <author> James William O'Toole and David K. Gifford. </author> <title> Type Reconstruction with First-Class Polymorphic Values. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(7) </volume> <pages> 207-217, </pages> <month> July </month> <year> 1989. </year> <booktitle> Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <address> Portland, Oregon, </address> <month> June. </month>
Reference-contexts: Modern expositions are found in [MP85] [MH88] [Rey85] [Mit90] [Car91]. Other kinds of type information may be incorporated into a type system and checked at the same time as types [GL86] [LG88] <ref> [OG89] </ref>. 5 6.2 Type Theory Type theory, narrowly defined, uses the tools of constructive logic to study polymorphic type systems. A good introduction can be found in [Sch94, Chapters 8-10].
Reference: [OL82] <author> Susan Owicki and Leslie Lamport. </author> <title> Proving Liveness Properties of Concurrent Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 455-495, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: See [Gor88] for a more theoretical introduction that treats some aspects of theorem proving. Concurrency has always been a prime application area, because concurrent programs are so difficult to debug. Verification of concurrent programs may be handled with the Owicki-Gries method [OG76]. Other techniques use temporal logic (e.g., <ref> [OL82] </ref>) and "transition axioms" [Lam89]. An introduction to Hoare-style verification that discusses concurrent and distributed programs is [Al91a]. 3.1.1 Abstract Data Types Hoare also was the first to consider how verification and abstract data types interact [Hoa72].
Reference: [PHL + 77] <author> G. J. Popek, J. J. Horning, B. W. Lampson, J. G. Mitchell, and R. L. </author> <title> London. Notes on the Design of Euclid. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 12(3) </volume> <pages> 11-18, </pages> <month> March </month> <year> 1977. </year> <booktitle> Proceedings of an ACM Conference on Language Design for Reliable Software, </booktitle> <address> Raliegh, North Carolina, </address> <month> March, </month> <year> 1977. </year>
Reference-contexts: The use of an axiomatic semantics as a metric for the "goodness" of a language led to two language designs in the 1970s. Although never implemented fully, Alphard [SWL77] [Sha81] was interesting, and focused on support for both data abstraction and verification. The language Euclid [LGH + 78] <ref> [PHL + 77] </ref> was implemented, and has been used for various large projects. 3.3 Algebraic Semantics While most axiomatic approaches use Hoare logic or variations on Hoare logic, there have been a few attempts to use the techniques of algebra and equational specification to define programming languages.
Reference: [Pie91] <author> Benjamin C. Pierce. </author> <title> Basic Category Theory for Computer Scientists. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass, </address> <year> 1991. </year>
Reference-contexts: For example, categorical logic and the semantics of the typed lambda calculus are discussed in [LS86]. For me, the best introduction seems to be the first 5 chapters of [Gol84]. There are now several articles [Hoa89] and books [BW90] [AL91b] <ref> [Pie91] </ref> [Wal91] explaining category theory to computer scientists.
Reference: [Plo77] <author> G. D. Plotkin. </author> <title> LCF Considered as a Programming Language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5 </volume> <pages> 223-255, </pages> <year> 1977. </year>
Reference-contexts: Landin overcame the circularity problem by the use of an abstract machine called the "SECD machine" [Lan64] (see also [Hen80]). A more systematic style of operational semantics based on rewrite rules is found in Plotkin's terminal transition systems <ref> [Plo77] </ref> also known as "structural operational semantics" [Plo81] [Hen90] or a "labeled transition system" [Ast91]. Hennessy's book is an elementary introduction [Hen90]. This style of semantics has the advantage that it extends naturally to studies of concurrency [Mil90].
Reference: [Plo81] <author> Gordon Plotkin. </author> <title> A Structural Approach to Operational Semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Aarhus University, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: Landin overcame the circularity problem by the use of an abstract machine called the "SECD machine" [Lan64] (see also [Hen80]). A more systematic style of operational semantics based on rewrite rules is found in Plotkin's terminal transition systems [Plo77] also known as "structural operational semantics" <ref> [Plo81] </ref> [Hen90] or a "labeled transition system" [Ast91]. Hennessy's book is an elementary introduction [Hen90]. This style of semantics has the advantage that it extends naturally to studies of concurrency [Mil90]. A classic reference for the operational semantics of concurrent processes is Milner's book on CCS [Mil80].
Reference: [Rey74] <author> J. C. Reynolds. </author> <title> Towards a Theory of Type Structure. </title> <booktitle> In Programming Symposium, Proceedings, Colloque sur la Programmation, </booktitle> <address> Paris, </address> <month> April </month> <year> 1974, </year> <booktitle> volume 19 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1974. </year>
Reference-contexts: See also [Har84] [Car91] [DT88]; the latter two have much material related to object-oriented programming. A still more recent survey is [Mit90]. Standard references include Girard's system F! [Gir71] (see also [Gir86] [GLT89]), and Reynolds independent work <ref> [Rey74] </ref>, sometimes called the Girard-Reynolds second order lambda calculus (or SOL). Modern expositions are found in [MP85] [MH88] [Rey85] [Mit90] [Car91].
Reference: [Rey75] <author> J. C. Reynolds. </author> <title> User-defined Types and Procedural Data Structures as Complementary Approaches to Type Abstraction. </title> <editor> In S. A. Schuman, editor, </editor> <booktitle> New Directions in Algorithmic Languages, </booktitle> <pages> pages 157-168. IRIA, </pages> <year> 1975. </year> <month> 19 </month>
Reference-contexts: Their language PRL which uses constructive mathematics, is described in the paper "Proofs as Programs" [BC85]. A related language is PL/CV3 [CZ84]. Coquand and Huet's group is responsible for the "calculus of constructions" [CH88]. A recent survey with more references is [BH90a]. 6.3 Data Abstraction: ADTs and OOP Reynolds <ref> [Rey75] </ref> [Rey78] (see also [Coo91]) distinguished two ways in which a type system could support data abstraction. The first way is to have the language give an object different types outside and inside a defining module; this Reynolds called "user defined types".
Reference: [Rey78] <author> John C. Reynolds. </author> <title> User Defined Types and Procedural Data Structures as Complemen--tary Approaches to Data Abstraction. </title> <editor> In David Gries, editor, </editor> <booktitle> Programming Methodology, A Collection of Articles by IFIP WG2.3, </booktitle> <pages> pages 309-317. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1978. </year> <note> Reprinted from S. </note> <editor> A. Schuman (ed.), </editor> <booktitle> New Directions in Algorithmic Languages 1975, </booktitle> <institution> Inst. de Recherche d'Informatique et d'Automatique, Rocquencourt, </institution> <year> 1975, </year> <pages> pages 157-168. </pages>
Reference-contexts: A related language is PL/CV3 [CZ84]. Coquand and Huet's group is responsible for the "calculus of constructions" [CH88]. A recent survey with more references is [BH90a]. 6.3 Data Abstraction: ADTs and OOP Reynolds [Rey75] <ref> [Rey78] </ref> (see also [Coo91]) distinguished two ways in which a type system could support data abstraction. The first way is to have the language give an object different types outside and inside a defining module; this Reynolds called "user defined types".
Reference: [Rey80] <author> John C. Reynolds. </author> <title> Using Category Theory to Design Implicit Conversions and Generic Operators. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Denmark, volume 94 of Lecture Notes in Computer Science, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1980. </year>
Reference-contexts: [AC90] [CMMS91] [Car93] [CCH + 89] [CHC90] [Coo89] [BTGS90] [HP90] [MMM91] [BCM + 93] [BL90] [BM92] [Aba93] [Bru93]. (Cardelli is one of the most active in this area, and most of the literature will cite one of his papers.) For work that directly bears on multimethods (as in CLOS), see <ref> [Rey80] </ref> [Ghe91a] [Ghe91b] [CGL92] [Cha92] [CGL93] [Cas93] [CL94]. 6.4 Type Reconstruction Type reconstruction (or type inference) is the process of reconstructing types for a program that has no type declarations. A practical and sound algorithm is described in Milner's paper "A Theory of Type Polymorphism in Programming" [Mil78].
Reference: [Rey85] <author> John C. Reynolds. </author> <title> Three Approaches to Type Structure. </title> <editor> In Hartmut Ehrig, Chris-tiane Floyd, Maurice Nivat, and James Thatcher, editors, </editor> <booktitle> Mathematical Foundations of Software Development, Proceedings of the International Joint Conference on Theory and Practice of Software Development (TAPSOFT), Berlin. Volume 1: Colloquium on Trees in Algebra and Programming (CAAP '85), volume 185 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-138. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> March </month> <year> 1985. </year>
Reference-contexts: A still more recent survey is [Mit90]. Standard references include Girard's system F! [Gir71] (see also [Gir86] [GLT89]), and Reynolds independent work [Rey74], sometimes called the Girard-Reynolds second order lambda calculus (or SOL). Modern expositions are found in [MP85] [MH88] <ref> [Rey85] </ref> [Mit90] [Car91]. Other kinds of type information may be incorporated into a type system and checked at the same time as types [GL86] [LG88] [OG89]. 5 6.2 Type Theory Type theory, narrowly defined, uses the tools of constructive logic to study polymorphic type systems.
Reference: [RL77] <author> Lawrence Robinson and Karl N. Levitt. </author> <title> Proof Techniques for Hierarchically Structured Programs. </title> <journal> Communications of the ACM, </journal> <volume> 20(4) </volume> <pages> 271-283, </pages> <month> April </month> <year> 1977. </year>
Reference-contexts: See [LG86, chapter 11] for a tutorial on program verification using abstract data types. A related aspect is how the structure of a proof of correctness may help follow the hierarchical (i.e., layered) structure of the implementation design <ref> [RL77] </ref> [GMP90] [Sch82]. 3.1.2 Transformational Programming Hoare's original paper [Hoa69], treated verification as something to be done after a program was written. However, Hoare [Hoa71] and others were soon advocating the development of proofs at the same time as programs.
Reference: [SCB + 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 9-16, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: Today it goes under the more common name of "object-oriented programming" (OOP) [DMN70] [BDMN73] [GR83]. Some languages exemplifying typed support for OOP include SIM-ULA [BDMN73], and Eiffel [Mey88] [Mey92], both of which have insecure type systems [Coo89]. The language Trellis/Owl <ref> [SCB + 86] </ref> features by-name type checking and subtyping. By contrast,Emerald [BHJL86] [BHJ + 87] [BH90b] [BH91] and Quest [Car91] feature structural subtyping. Some seminal references on types and OOP are reprinted in [GM94].
Reference: [Sch82] <author> Oliver Schoett. </author> <title> A Theory of Program Modules, their Specifications and Implementation (Extended Abstract). </title> <type> Internal Report CSR-155-83, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <month> December </month> <year> 1982. </year>
Reference-contexts: See [LG86, chapter 11] for a tutorial on program verification using abstract data types. A related aspect is how the structure of a proof of correctness may help follow the hierarchical (i.e., layered) structure of the implementation design [RL77] [GMP90] <ref> [Sch82] </ref>. 3.1.2 Transformational Programming Hoare's original paper [Hoa69], treated verification as something to be done after a program was written. However, Hoare [Hoa71] and others were soon advocating the development of proofs at the same time as programs. Dijkstra and Gries became prime advocates of this technique [Dij76] [Gri81].
Reference: [Sch86] <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc., </publisher> <address> Boston, Mass., </address> <year> 1986. </year>
Reference-contexts: Examples include [MA86] [BWP87]. 4 Denotational Semantics In contrast to axiomatic semantics, denotational semantics [Str66] [SS71] [MS76] [Sto77] [Sco81] <ref> [Sch86] </ref> explicitly constructs mathematical models of programming languages. A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76]. A recent survey is found in [Mos90]. Introductory texts include [Gor79], [All86], [Wat91], [Sch94]. <p> A recent survey is found in [Mos90]. Introductory texts include [Gor79], [All86], [Wat91], [Sch94]. An excellent new graduate text with more mathematical depth is [Gun92]. Standard works on denotational semantics are the books by Stoy [Sto77] and Schmidt <ref> [Sch86] </ref>, both of which offer a comprehensive and mathematical treatment. Schmidt's book [Sch86] has an excellent discussion of domain theory (see also [GS90]) and can be consulted for references to denotational descriptions of real languages. <p> Introductory texts include [Gor79], [All86], [Wat91], [Sch94]. An excellent new graduate text with more mathematical depth is [Gun92]. Standard works on denotational semantics are the books by Stoy [Sto77] and Schmidt <ref> [Sch86] </ref>, both of which offer a comprehensive and mathematical treatment. Schmidt's book [Sch86] has an excellent discussion of domain theory (see also [GS90]) and can be consulted for references to denotational descriptions of real languages. One can use a typed functional programming language, such as Standard ML, to implement a denotational semantics. Two descriptions of this idea are [Wat86] [MA89]. <p> One can use a typed functional programming language, such as Standard ML, to implement a denotational semantics. Two descriptions of this idea are [Wat86] [MA89]. Action semantics, an offshoot of denotational semantics, is described in [Wat91] and more fully in [Mos92]. Schmidt's book <ref> [Sch86] </ref> also has a discussion of denotational semantics for concurrent systems. Hennessy's book has a discussion of more recent work in this area [Hen88].
Reference: [Sch90] <author> Oliver Schoett. </author> <title> Behavioural Correctness of Data Representations. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14(1) </volume> <pages> 43-57, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: A practical implementation of these ideas is found in [NHN80]. VDM also uses these techniques [Jon90]. More recent work in this area is found in <ref> [Sch90] </ref> and [Nip89]. Abstract data types (ADTs) can be specified algebraically [GHM78] [EM85] or by using pre-and post-conditions [BJ82] [Jon86] [Win87]. See [LG86, chapter 11] for a tutorial on program verification using abstract data types.
Reference: [Sch94] <author> David A. Schmidt. </author> <title> The Structure of Typed Programming Languages. </title> <booktitle> Foundations of Computing Series. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: This book is at times highly technical, but also has sensible definitions and introductory material. A shorter account, with a reasonable introduction to the -calculus is found in [Bar90]. Other introductions include [Gor88] <ref> [Sch94, Sections 6.1-6.2] </ref>. The use of -calculus for describing programming languages and as the inspiration for programming language design has been investigated by Landin [Lan65] [Lan66] and many others. For the typed -calculus, a standard reference is [GLT89]. <p> The use of -calculus for describing programming languages and as the inspiration for programming language design has been investigated by Landin [Lan65] [Lan66] and many others. For the typed -calculus, a standard reference is [GLT89]. A good introduction can be found in [Gun92, Chapter 2] and <ref> [Sch94, Sections 6.4] </ref>; both of these texts discuss the semantics of the typed lambda calculus in detail. <p> For the typed -calculus, a standard reference is [GLT89]. A good introduction can be found in [Gun92, Chapter 2] and [Sch94, Sections 6.4]; both of these texts discuss the semantics of the typed lambda calculus in detail. Schmidt's book <ref> [Sch94] </ref> is also a good introduction to higher-order typed lambda calculi, and contains references to work on such higher-order extensions. 2.2 Category Theory Increasingly, especially in denotational semantics, category theory [Lan71] [LS91] is used in research and for the elegant presentation of results. <p> A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76]. A recent survey is found in [Mos90]. Introductory texts include [Gor79], [All86], [Wat91], <ref> [Sch94] </ref>. An excellent new graduate text with more mathematical depth is [Gun92]. Standard works on denotational semantics are the books by Stoy [Sto77] and Schmidt [Sch86], both of which offer a comprehensive and mathematical treatment. <p> The purpose of type checking is nicely summarized by Morris as a mechanism that allows program modules to protect objects from unwanted discovery, modification, and impersonation [Mor73]. Wegbreit's discussion of the extensible language EL1, is also good background [Weg74]. Schmidt's recent book <ref> [Sch94] </ref> starts treats type systems in the context of programming language semantics. <p> Other kinds of type information may be incorporated into a type system and checked at the same time as types [GL86] [LG88] [OG89]. 5 6.2 Type Theory Type theory, narrowly defined, uses the tools of constructive logic to study polymorphic type systems. A good introduction can be found in <ref> [Sch94, Chapters 8-10] </ref>. Logical inference systems can often be translated directly into type systems due to the "Formula as Types" notion or the "Curry-Howard isomorphism" [How80] [GLT89, Chapter 3] [Con89]. Thus much research in type theory lies on the border of mathematics and computer science.
Reference: [Sco81] <author> Dana Scott. </author> <title> Lectures on a Mathematical Theory of Computation. </title> <type> Technical Monograph PRG-19, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <year> 1981. </year> <booktitle> Appears in Theoretical foundations of programming methodology : lecture notes of an international summer school, directed by F.L. Bauer, E.W. Dijkstra, and C.A.R. Hoare (Ridel, </booktitle> <year> 1982). </year>
Reference-contexts: Examples include [MA86] [BWP87]. 4 Denotational Semantics In contrast to axiomatic semantics, denotational semantics [Str66] [SS71] [MS76] [Sto77] <ref> [Sco81] </ref> [Sch86] explicitly constructs mathematical models of programming languages. A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76]. A recent survey is found in [Mos90]. Introductory texts include [Gor79], [All86], [Wat91], [Sch94].
Reference: [Sha81] <author> Mary Shaw. </author> <title> ALPHARD: Form and Content. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1981. </year>
Reference-contexts: The use of an axiomatic semantics as a metric for the "goodness" of a language led to two language designs in the 1970s. Although never implemented fully, Alphard [SWL77] <ref> [Sha81] </ref> was interesting, and focused on support for both data abstraction and verification.
Reference: [SS71] <author> D. S. Scott and C. Strachey. </author> <title> Toward a mathematical semantics for computer languages. </title> <booktitle> In Proceedings Symposium on Computers and Automata, volume 21 of Microwave Institute Symposia Series, </booktitle> <pages> pages 19-46. </pages> <institution> Polytechnic Institute of Brooklyn, </institution> <year> 1971. </year> <month> 20 </month>
Reference-contexts: Examples include [MA86] [BWP87]. 4 Denotational Semantics In contrast to axiomatic semantics, denotational semantics [Str66] <ref> [SS71] </ref> [MS76] [Sto77] [Sco81] [Sch86] explicitly constructs mathematical models of programming languages. A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76]. A recent survey is found in [Mos90]. Introductory texts include [Gor79], [All86], [Wat91], [Sch94].
Reference: [SS78] <author> Guy Lewis Steele Jr. and Gerald Jay Sussman. </author> <title> The Art of the Interpreter or, The Mod--ularity Complex (Parts Zero, One, and Two). </title> <type> AI Memo 453, </type> <institution> Massachusetts Institute of Technology, Artificial Intelligence Laboratory, </institution> <month> May </month> <year> 1978. </year>
Reference-contexts: Meta-circular interpreters are still useful for teaching purposes, and for prototyping programming language designs. Several meta-circular interpreters for variants of LISP are discussed in Steele and Sussman's paper The Art of the Interpreter <ref> [SS78] </ref>. An excellent and more readily accessible discussion is found in Abelson and Sussman's book [ASS85], which uses Scheme. A more detailed treatment of interpreters is found in [Kam90] [FWH92]. See [KdRB91] for an approach using the CLOS meta-object protocol.
Reference: [Sta85] <author> R. Statman. </author> <title> Logical Relations and the Typed -Calculus. </title> <journal> Information and Control, </journal> 65(2/3):85-97, May/June 1985. 
Reference-contexts: Gratzer's monumental book [Gra79] is a standard reference. A generalized notion of homomorphism that is often used in semantics is Statman's logical relations <ref> [Sta85] </ref>, explained in [Mit90]. Another foundation is the area of mathematical logic. A classic approach, using proof theory and model theory is [End72].
Reference: [Sto77] <author> J. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1977. </year>
Reference-contexts: Examples include [MA86] [BWP87]. 4 Denotational Semantics In contrast to axiomatic semantics, denotational semantics [Str66] [SS71] [MS76] <ref> [Sto77] </ref> [Sco81] [Sch86] explicitly constructs mathematical models of programming languages. A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76]. A recent survey is found in [Mos90]. Introductory texts include [Gor79], [All86], [Wat91], [Sch94]. <p> A recent survey is found in [Mos90]. Introductory texts include [Gor79], [All86], [Wat91], [Sch94]. An excellent new graduate text with more mathematical depth is [Gun92]. Standard works on denotational semantics are the books by Stoy <ref> [Sto77] </ref> and Schmidt [Sch86], both of which offer a comprehensive and mathematical treatment. Schmidt's book [Sch86] has an excellent discussion of domain theory (see also [GS90]) and can be consulted for references to denotational descriptions of real languages.
Reference: [Str66] <author> C. Strachey. </author> <title> Towards a Formal Semantics. </title> <booktitle> In IFIP TC2 Working Conference on Formal Language Description Languages for Computer Programming, </booktitle> <pages> pages 198-220, </pages> <address> Amsterdam, 1966. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Examples include [MA86] [BWP87]. 4 Denotational Semantics In contrast to axiomatic semantics, denotational semantics <ref> [Str66] </ref> [SS71] [MS76] [Sto77] [Sco81] [Sch86] explicitly constructs mathematical models of programming languages. A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76]. A recent survey is found in [Mos90]. Introductory texts include [Gor79], [All86], [Wat91], [Sch94].
Reference: [SWL77] <author> Mary Shaw, William A. Wulf, and R. L. </author> <title> London. Abstraction and Verification in Alphard: Defining and Specifying Iteration and Generators. </title> <journal> Communications of the ACM, </journal> <volume> 20(8) </volume> <pages> 553-564, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: The use of an axiomatic semantics as a metric for the "goodness" of a language led to two language designs in the 1970s. Although never implemented fully, Alphard <ref> [SWL77] </ref> [Sha81] was interesting, and focused on support for both data abstraction and verification.
Reference: [Tal88] <author> C. Talcott. Rum: </author> <title> An intensional theory of function and control abstractions. </title> <editor> In M. Boscarol, L. Carlucci Aiello, and G. Levi, editors, </editor> <booktitle> Foundations of Logic and Functional Programming, Workshop Proceedings, </booktitle> <address> Trento, Italy, </address> <month> (Dec. </month> <year> 1986), </year> <booktitle> volume 306 of Lecture Notes in Computer Science, </booktitle> <pages> pages 3-44. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Some recent work in this area can be found in [Mee87] [Bir89a] [Bir89b] <ref> [Tal88] </ref>. Transformational (or algebraic) techniques also underly the work on Backus's FP [Bac78] and Hoare's "Laws of Programming" for CSP [HHJ + 87].
Reference: [Ten76] <author> R. D. Tennent. </author> <title> The Denotational Semantics of Programming Languages. </title> <journal> Communications of the ACM, </journal> <volume> 19 </volume> <pages> 437-453, </pages> <month> August </month> <year> 1976. </year>
Reference-contexts: Examples include [MA86] [BWP87]. 4 Denotational Semantics In contrast to axiomatic semantics, denotational semantics [Str66] [SS71] [MS76] [Sto77] [Sco81] [Sch86] explicitly constructs mathematical models of programming languages. A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" <ref> [Ten76] </ref>. A recent survey is found in [Mos90]. Introductory texts include [Gor79], [All86], [Wat91], [Sch94]. An excellent new graduate text with more mathematical depth is [Gun92]. Standard works on denotational semantics are the books by Stoy [Sto77] and Schmidt [Sch86], both of which offer a comprehensive and mathematical treatment.
Reference: [Tiu90] <author> Jerzy Tiuryn. </author> <title> Type Inference Probelms: A Survey. </title> <editor> In B. Rovan, editor, </editor> <booktitle> Mathematical Foundations of Computer Science 1990, Banska Bystrica, Czechoslovakia, volume 452 of Lecture Notes in Computer Science, </booktitle> <pages> pages 105-120. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: The question of whether one can do type inference for more powerful type systems has been an active area of research (e.g., [McC84] [Wan89]). A recent survey of what is known about such problems is found in <ref> [Tiu90] </ref>. See Knight's survey [Kni89] for a discussion of the central role that unification plays in type inference and more details on unification itself. 6.5 Research Languages The language Russell was developed at Cornell to investigate how types can be treated as values.
Reference: [Tur85] <author> David A. Turner. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <editor> In J. Jouannaud, editor, </editor> <booktitle> Proceedings IFIP International Conference on Functional Programming Languages and Computer Architectures, Nancy, France, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-16. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> Septem-ber </month> <year> 1985. </year>
Reference-contexts: Russell has separate mechanisms for building types and for information hiding; the same idea is found in Haskell [Hud89, Pages 387-388]. Interesting variations are found in Miranda <ref> [Tur85] </ref>. Much recent work has centered around the language ML and its modern variant Standard ML [Mil84] [MTH90] [MT91]. Besides the type inference in its type system mentioned above, Standard ML has an interesting module system [Mac84] [Har85] [HMT87].
Reference: [vL90] <editor> Jan van Leeuwen. </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics. </booktitle> <publisher> The MIT Press, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: Articles discussing principal topics in semantics, containing many references, appear in volume B of the Handbook of Theoretical Computer Science <ref> [vL90] </ref>. Journals that include a substantial coverage of semantics include ACM Transactions on Programming Languages and Systems (TOPLAS), ACM SIGPLAN Notices, IEEE Transactions on Software Engineering, Information and Computation (formerly Information and Control, Academic Press), and Acta Informatica (Springer-Verlag).
Reference: [Wal91] <author> R. F. C. </author> <title> Walters. </title> <booktitle> Categories and Computer Science, volume 28 of Cambridge Computer Science Texts. </booktitle> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: For example, categorical logic and the semantics of the typed lambda calculus are discussed in [LS86]. For me, the best introduction seems to be the first 5 chapters of [Gol84]. There are now several articles [Hoa89] and books [BW90] [AL91b] [Pie91] <ref> [Wal91] </ref> explaining category theory to computer scientists.
Reference: [Wan89] <author> Mitchell Wand. </author> <title> Type Inference for Record Concatenation and Multiple Inheritance. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <address> Pacific Grove, California, </address> <pages> pages 92-97. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: The ideal model has been used to give a semantics to the ML type system [MPS86]. The question of whether one can do type inference for more powerful type systems has been an active area of research (e.g., [McC84] <ref> [Wan89] </ref>). A recent survey of what is known about such problems is found in [Tiu90].
Reference: [Wat86] <author> D. A. Watt. </author> <title> Executable Denotational Semantics. </title> <journal> Software: Practice and Experience, </journal> <volume> 16(1) </volume> <pages> 13-43, </pages> <year> 1986. </year>
Reference-contexts: Schmidt's book [Sch86] has an excellent discussion of domain theory (see also [GS90]) and can be consulted for references to denotational descriptions of real languages. One can use a typed functional programming language, such as Standard ML, to implement a denotational semantics. Two descriptions of this idea are <ref> [Wat86] </ref> [MA89]. Action semantics, an offshoot of denotational semantics, is described in [Wat91] and more fully in [Mos92]. Schmidt's book [Sch86] also has a discussion of denotational semantics for concurrent systems. Hennessy's book has a discussion of more recent work in this area [Hen88].
Reference: [Wat91] <author> David A. Watt. </author> <title> Programming Language Syntax and Semantics. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice-Hall, </publisher> <address> New York, N.Y., </address> <year> 1991. </year> <month> 21 </month>
Reference-contexts: A short summary of the denotational approach can be found in Tennent's article "The Denotational Semantics of Programming Languages" [Ten76]. A recent survey is found in [Mos90]. Introductory texts include [Gor79], [All86], <ref> [Wat91] </ref>, [Sch94]. An excellent new graduate text with more mathematical depth is [Gun92]. Standard works on denotational semantics are the books by Stoy [Sto77] and Schmidt [Sch86], both of which offer a comprehensive and mathematical treatment. <p> One can use a typed functional programming language, such as Standard ML, to implement a denotational semantics. Two descriptions of this idea are [Wat86] [MA89]. Action semantics, an offshoot of denotational semantics, is described in <ref> [Wat91] </ref> and more fully in [Mos92]. Schmidt's book [Sch86] also has a discussion of denotational semantics for concurrent systems. Hennessy's book has a discussion of more recent work in this area [Hen88].
Reference: [Weg74] <author> Ben Wegbreit. </author> <title> The Treatment of Data Types in EL1. </title> <journal> Communications of the ACM, </journal> <volume> 17(5) </volume> <pages> 251-264, </pages> <month> May </month> <year> 1974. </year>
Reference-contexts: The purpose of type checking is nicely summarized by Morris as a mechanism that allows program modules to protect objects from unwanted discovery, modification, and impersonation [Mor73]. Wegbreit's discussion of the extensible language EL1, is also good background <ref> [Weg74] </ref>. Schmidt's recent book [Sch94] starts treats type systems in the context of programming language semantics.
Reference: [Win87] <author> Jeannette M. Wing. </author> <title> Writing Larch Interface Language Specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: A practical implementation of these ideas is found in [NHN80]. VDM also uses these techniques [Jon90]. More recent work in this area is found in [Sch90] and [Nip89]. Abstract data types (ADTs) can be specified algebraically [GHM78] [EM85] or by using pre-and post-conditions [BJ82] [Jon86] <ref> [Win87] </ref>. See [LG86, chapter 11] for a tutorial on program verification using abstract data types.
Reference: [Win93] <editor> Glynn Winskel. </editor> <booktitle> The Formal Semantics of Programming Languages. Foundations of Computer Science Series. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year> <month> 22 </month>
Reference-contexts: If you wish to probe an area more deeply, you might start with the papers mentioned, follow their references, and also use the Science Citation Index to see what papers have referenced the ones mentioned. 1 General Sources Two recent texts that cover many different approaches to semantics are: [NN92] <ref> [Win93] </ref>. Articles discussing principal topics in semantics, containing many references, appear in volume B of the Handbook of Theoretical Computer Science [vL90].
References-found: 205

