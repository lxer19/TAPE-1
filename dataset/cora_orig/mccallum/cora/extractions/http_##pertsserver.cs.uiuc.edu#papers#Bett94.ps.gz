URL: http://pertsserver.cs.uiuc.edu/papers/Bett94.ps.gz
Refering-URL: http://pertsserver.cs.uiuc.edu/papers/
Root-URL: http://www.cs.uiuc.edu
Title: END-TO-END SCHEDULING TO MEET DEADLINES IN DISTRIBUTED SYSTEMS  
Author: BY RICCARDO BETTATI 
Degree: 1988 THESIS Submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy in Computer Science in the Graduate College of the  
Address: 1994 Urbana, Illinois  
Affiliation: Diploma, Swiss Federal Institute of Technology, Zurich,  University of Illinois at Urbana-Champaign,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. Agrawal, B. Chen, W. Zhao, and S. Davari. </author> <title> Guaranteeing synchronous message deadlines with the timed token protokol. </title> <booktitle> In Proceedings of the 12th Internatioal Conference on Distributed Computing Systems, </booktitle> <pages> pages 468-475, </pages> <address> Yokohama, Japan, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: The encoding and packeting schemes are designed so that the occasional loss of packets has a minimal effect on the quality of the received audio or video. Recently, a considerable amount of effort has been directed toward how to ensure messages with time constraints are delivered over multiple-access networks <ref> [1, 23, 38, 55] </ref> in time. When the underlying network has a point-to-point interconnection structure, such as in wide-area networks [7], it is more complicated to guarantee timely message delivery.
Reference: [2] <author> N. C. Audsley, A. Burns, M. F. Richardson, and A. J. Wellings. </author> <title> Hard real-time scheduling: the deadline-monotonic approach. </title> <booktitle> In Proceedings of the Eighth IEEE Workshop on real-Time Operating Systems and Software, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: This assignment is optimal for job systems in which the relative deadlines of jobs are shorter or equal to their periods, that is D i p i <ref> [2, 30] </ref>. (In the special case when the D i 's are proportional to the periods, this assignment is identical to the rate-monotonic assignment.) In [2] we are given a sufficient, but not necessary, schedulability condition for a job set on one processor with arbitrary deadlines D i p i to <p> is optimal for job systems in which the relative deadlines of jobs are shorter or equal to their periods, that is D i p i [2, 30]. (In the special case when the D i 's are proportional to the periods, this assignment is identical to the rate-monotonic assignment.) In <ref> [2] </ref> we are given a sufficient, but not necessary, schedulability condition for a job set on one processor with arbitrary deadlines D i p i to be schedulable according to the deadline-monotonic priority algorithm. Equation (6.2) is based on this condition.
Reference: [3] <author> T. P. Baker. </author> <title> A stack-based allocation policy for realtime processes. </title> <booktitle> In Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 191-200, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: In the second technique we use results in the scheduling of aperiodic tasks to allow for asynchronous execution of the subtasks. One area that has attracted a lot of attention in the schedulability analysis for single-processor systems are real-time resource access protocols <ref> [3, 42, 47] </ref>. We could show that these protocols can be naturally included in the phase modification technique to analyze systems with end-to-end timing constraints and access to resources, both local and global. <p> Priority inversion occurs when a higher-priority subjob waits while low-priority subjobs are executing. It is uncontrolled, since this condition may last for indefinite lengths of time. Several resource access protocols have been devised to avoid deadlock and to prevent uncontrolled priority inversion <ref> [3, 37, 47] </ref>. By using these protocols, the execution times of the subjobs can be made predictable.
Reference: [4] <author> J. Bruno, J. W. Jones III, and K. </author> <title> So. Deterministic scheduling with pipelined processors. </title> <journal> IEEE Trans. Computers, </journal> <volume> 29 </volume> <pages> 120-139, </pages> <year> 1980. </year>
Reference-contexts: The main objective in traditional pipeline scheduling is the generation of schedules that maximize throughput. Polynomial-time algorithms are known for scheduling pipelines of length two with arbitrary precedence constraints and pipelines of length k with precedence constraints that are trees <ref> [4] </ref>. Most generalizations of these two cases are N P-complete.
Reference: [5] <author> A. Burns, M. Nicholson, K. Tindell, and N. Zhang. </author> <title> Allocating and scheduling hard real-time tasks on a point-to-point distributed system. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Real-Time Systems, </booktitle> <pages> pages 11-20, </pages> <address> Newport Beach, California, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: The worst-case message delays along the links in a channel are computed at channel-establishment time and are used to determine the effective deadlines of message transmissions on each link. 3.4 Task Assignments Burns et al. <ref> [5] </ref> discuss the problem of allocating and scheduling periodic tasks, called transactions, that consist of chains of subtasks (called subtransactions) in DIA (Data Interaction Architecture) [49]. Each transaction consists of a collection of precedence related processes that are modeled as subtasks in our periodic flow-shop model.
Reference: [6] <author> H. Emmons. </author> <title> One-machine sequencing to minimize certain functions of job tardiness. Operation Research, </title> <address> 17-4:701-715, </address> <year> 1969. </year>
Reference-contexts: Nevertheless, EDF schedules for task sets with identical release times have two useful characteristics. First, as long as no task starts after its deadline in an EDF schedule, the total tardiness is minimized <ref> [6] </ref>. Second, in any EDF schedule, the maximum tardiness is minimized [25].
Reference: [7] <author> D. Ferrari. </author> <title> Real-time communication in an internetwork. </title> <type> Technical Report TR-92-001, </type> <institution> International Computer Science Institute, Berkeley, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: Recently, a considerable amount of effort has been directed toward how to ensure messages with time constraints are delivered over multiple-access networks [1, 23, 38, 55] in time. When the underlying network has a point-to-point interconnection structure, such as in wide-area networks <ref> [7] </ref>, it is more complicated to guarantee timely message delivery. Since only the end-to-end delay is constrained to be under some limit, there are more choices in scheduling message transmissions through the multiple links in the network.
Reference: [8] <author> S. </author> <title> French. Sequencing and Scheduling: An Introduction to the Mathematics of the Job-Shop. </title> <publisher> Wiley, </publisher> <year> 1982. </year>
Reference-contexts: Rule C3 takes advantage of the following well-known fact: To minimize the maximum completion time in a flow shop with identical release times and no more than three processors, we only need to consider permutation schedules. French <ref> [8] </ref> and Szwarc [51] describe ways to determine lower bounds on the optimal maximum completion time for three-processor permutation flow shops. We are going to use two of these methods in the following way.
Reference: [9] <author> M. R. Garey and D. S. Johnson. </author> <title> Scheduling tasks with nonuniform deadlines on two processors. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 23 </volume> <pages> 461-467, </pages> <year> 1976. </year>
Reference-contexts: The problem of scheduling non-preemptable tasks with arbitrary job parameters to meet individual deadlines is known to be N P-complete <ref> [9, 10] </ref>. Similarly, when preemption is allowed, we restrict the flow-shop problem to the case of identical deadlines. The preemptive flow-shop problem to meet an overall deadline is known to be N P -complete [14]. 2 Two special cases of the flow-shop scheduling problem are tractable, however. <p> summarize the similarities and differences in the approaches and objectives of our work and earlier work on the related problems. 3.1 Classical Machine-Scheduling Theory Past efforts in flow-shop scheduling have focused on the minimization of completion time, that is, the total time required to complete a given set of tasks <ref> [9, 12, 25, 53] </ref>. Johnson [9] showed that tasks in a two-processor flow shop can be scheduled to minimize completion time in O (n log n) time. Beyond the two-processor flow shop, however, almost every flow-shop scheduling problem is N P-complete. <p> Johnson <ref> [9] </ref> showed that tasks in a two-processor flow shop can be scheduled to minimize completion time in O (n log n) time. Beyond the two-processor flow shop, however, almost every flow-shop scheduling problem is N P-complete. <p> This system can be modeled as a flow shop where the subtasks form an identical-length task set with processing times t . Sometimes, release times and deadlines are multiples of t . In this case, we can simply use the classical earliest-effective-deadline-first (EEDF) algorithm to optimally schedule all tasks <ref> [9] </ref>. Again, an algorithm is optimal if it always produces a feasible schedule whenever such a schedule exists. According to the EEDF algorithm, the subtasks T ij on each processor P j are scheduled nonpreemptively in a priority-driven manner. <p> Suppose that the EEDF algorithm fails to find a feasible schedule of T 11 ; T 21 ; ; T n1 on P 1 . Because of the optimality of the EEDF algorithm for scheduling tasks with identical processing times on one processor <ref> [9, 13] </ref>, we can conclude that there is no feasible schedule of T 11 ; T 21 ; ; T n1 , meeting their effective deadlines d 11 ; d 21 ; ; d n1 .
Reference: [10] <author> M. R. Garey and D. S. Johnson. </author> <title> Two-processor scheduling with start-times and deadlines. </title> <journal> SIAM J. Comput., </journal> <volume> 6 </volume> <pages> 416-426, </pages> <year> 1977. </year> <month> 146 </month>
Reference-contexts: The problem of scheduling non-preemptable tasks with arbitrary job parameters to meet individual deadlines is known to be N P-complete <ref> [9, 10] </ref>. Similarly, when preemption is allowed, we restrict the flow-shop problem to the case of identical deadlines. The preemptive flow-shop problem to meet an overall deadline is known to be N P -complete [14]. 2 Two special cases of the flow-shop scheduling problem are tractable, however. <p> The problem of scheduling no-wait flow shops is reviewed in [15]. The general problem of scheduling to meet deadlines on identical multiprocessor systems is also N P-hard [11, 25]. However, polynomial algorithms for optimally scheduling tasks with identical processing times on one or two processors exist <ref> [10, 13] </ref>. Our algorithms in Chapter 4 and Chapter 5 make use of one of them. 3.2 Pipeline Scheduling Lawler et al. [24] identify three differences between the pipeline-scheduling and the flow-shop scheduling problems: (1) As opposed to flow-shops, no buffering of subtasks is allowed between stages in pipelines. <p> preempt so, that no task can be preempted by a long task. (2) For each T ij 2 T , set the effective release time r i (j+1) of T i (j+1) to the time when T ij completes on P j . formally defined by Garey and Johnson in <ref> [10] </ref>. This definition is used for the special case of unit-length tasks on two processors with dependencies. Garey and Johnson reduce this two-processor scheduling problem to the problem of adjusting the deadlines to make them internally consistent, and then scheduling the tasks in order of increasing adjusted deadlines.
Reference: [11] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of N P-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: The problem of scheduling tasks in a flow shop to meet deadlines is N P -hard, except for a few special cases <ref> [11, 25] </ref>. <p> The problem of scheduling no-wait flow shops is reviewed in [15]. The general problem of scheduling to meet deadlines on identical multiprocessor systems is also N P-hard <ref> [11, 25] </ref>. However, polynomial algorithms for optimally scheduling tasks with identical processing times on one or two processors exist [10, 13]. <p> Specifically, the worst-case completion time c ij has the value w ij if the subjob J ij executes at priority . Theorem 6. The FPA problem with two jobs is N P -complete. Proof. The proof is by reduction from Set-Partition <ref> [11] </ref>: Assume that we have a set A with elements fa 1 ; a 2 ; ; a m g. Each a j has a weight ff j . <p> problem of end-to-end scheduling in such systems, where the schedulers may make incoherent decisions, remains to be investigated. 93 Appendix A Heuristic-Supported Search for Flow-Shop Schedules The problem of scheduling flow shops to meet end-to-end release times and deadlines is an example of the well known Constraint Satisfaction Problem (CSP) <ref> [11] </ref>. Enumerative approaches to solving CSPs rely on heuristic-supported exhaustive search methods. We describe a depth-first backtrack search algorithm to find feasible schedules for flow shops.
Reference: [12] <author> M. R. Garey, D. S. Johnson, and R. Sethi. </author> <title> The complexity of flowshop and jobshop scheduling. </title> <journal> Math. Oper. Res., </journal> <volume> 1 </volume> <pages> 117-129, </pages> <year> 1976. </year>
Reference-contexts: summarize the similarities and differences in the approaches and objectives of our work and earlier work on the related problems. 3.1 Classical Machine-Scheduling Theory Past efforts in flow-shop scheduling have focused on the minimization of completion time, that is, the total time required to complete a given set of tasks <ref> [9, 12, 25, 53] </ref>. Johnson [9] showed that tasks in a two-processor flow shop can be scheduled to minimize completion time in O (n log n) time. Beyond the two-processor flow shop, however, almost every flow-shop scheduling problem is N P-complete. <p> Beyond the two-processor flow shop, however, almost every flow-shop scheduling problem is N P-complete. For example, the general problem of scheduling to minimize completion time on three processors is strictly N P -hard <ref> [12] </ref>. Consequently, most studies of flow-shop problems were concerned with restrictions of the problem that make it tractable. Other efforts focused on heuristic algorithms and enumerative methods that yield optimal and suboptimal schedules in reasonable amounts of time.
Reference: [13] <author> M. R. Garey, D. S. Johnson, B. Simons, and R. E. Tarjan. </author> <title> Scheduling unit-time tasks with arbitrary release times and deadlines. </title> <journal> SIAM J. Comput., </journal> <volume> 10-2:256-269, </volume> <year> 1981. </year>
Reference-contexts: The problem of scheduling no-wait flow shops is reviewed in [15]. The general problem of scheduling to meet deadlines on identical multiprocessor systems is also N P-hard [11, 25]. However, polynomial algorithms for optimally scheduling tasks with identical processing times on one or two processors exist <ref> [10, 13] </ref>. Our algorithms in Chapter 4 and Chapter 5 make use of one of them. 3.2 Pipeline Scheduling Lawler et al. [24] identify three differences between the pipeline-scheduling and the flow-shop scheduling problems: (1) As opposed to flow-shops, no buffering of subtasks is allowed between stages in pipelines. <p> Garey et al. <ref> [13] </ref> introduced the concept of forbidden regions during which tasks are not allowed to start execution. Their algorithm postpones the release times of selected tasks. This is done to adequately insert the necessary idle times to make an EEDF schedule optimal. <p> Suppose that the EEDF algorithm fails to find a feasible schedule of T 11 ; T 21 ; ; T n1 on P 1 . Because of the optimality of the EEDF algorithm for scheduling tasks with identical processing times on one processor <ref> [9, 13] </ref>, we can conclude that there is no feasible schedule of T 11 ; T 21 ; ; T n1 , meeting their effective deadlines d 11 ; d 21 ; ; d n1 . <p> Proof. If the resultant schedule S b on the bottleneck processor P b is not feasible, we can conclude that no feasible schedule of fT ib g exists because of the optimality of the EEDF algorithm <ref> [13] </ref>. On the other hand, if S b is a feasible schedule of fT ib g, the propagation method described in Step 3 can always generate a feasible schedule S of the set T . <p> Garey and Johnson reduce this two-processor scheduling problem to the problem of adjusting the deadlines to make them internally consistent, and then scheduling the tasks in order of increasing adjusted deadlines. Similarly, the use of forbidden regions (defined by Garey et al. in <ref> [13] </ref> and mentioned before in Section 4.1), during which tasks are not allowed to start execution, is a way to resolve inconsistencies of release times. Unfortunately, ways to find consistent timing constraints are only known for systems with unit-length tasks and one or two processors.
Reference: [14] <author> T. Gonzales and S. Sahni. </author> <title> Flowshop and jobshop scheduling: Complexity and approximation. Operation Research, </title> <address> 26-1:37-52, </address> <year> 1978. </year>
Reference-contexts: Similarly, when preemption is allowed, we restrict the flow-shop problem to the case of identical deadlines. The preemptive flow-shop problem to meet an overall deadline is known to be N P -complete <ref> [14] </ref>. 2 Two special cases of the flow-shop scheduling problem are tractable, however. The first is the case of identical-length task sets, where the processing times t ij of all subtasks on all processors are equal to t .
Reference: [15] <author> S. K. Goyal and C. Sriskandarajah. </author> <title> No-wait shop scheduling: computational complexity and approximate algorithms. </title> <journal> Opsearch, </journal> <volume> 25 </volume> <pages> 220-244, </pages> <year> 1988. </year>
Reference-contexts: In no-wait flow shops the tasks are not buffered between processors. In other words, when a task is started in a no-wait flow shop, it has to run through all processors until it terminates. The problem of scheduling no-wait flow shops is reviewed in <ref> [15] </ref>. The general problem of scheduling to meet deadlines on identical multiprocessor systems is also N P-hard [11, 25]. However, polynomial algorithms for optimally scheduling tasks with identical processing times on one or two processors exist [10, 13].
Reference: [16] <author> J. Grabowski. </author> <title> A new algorithm of solving the flow-shop problem. </title> <editor> In G. Feichtinger and P. Kall, editors, </editor> <booktitle> Operations Research in Progress, </booktitle> <pages> pages 57-75. </pages> <publisher> Reidel, </publisher> <address> Dordrecht, </address> <year> 1982. </year>
Reference-contexts: A schedule for which this condition holds is called a permutation schedule. In contrast, in a non-permutation schedule the sequence of tasks executed on different processors may vary. 13 Grabowski et al. [17] extend their enumerative approach described in <ref> [16] </ref> to schedule flow shops with arbitrary release times and deadlines to minimize lateness. In no-wait flow shops the tasks are not buffered between processors. In other words, when a task is started in a no-wait flow shop, it has to run through all processors until it terminates.
Reference: [17] <author> J. Grabowski, E. Skubalska, and C Smutnicki. </author> <title> On flow shop scheduling with release and due dates to minimize maximum lateness. </title> <journal> J. Oper. Res. Soc., </journal> <volume> 34 </volume> <pages> 615-620, </pages> <year> 1983. </year>
Reference-contexts: A schedule for which this condition holds is called a permutation schedule. In contrast, in a non-permutation schedule the sequence of tasks executed on different processors may vary. 13 Grabowski et al. <ref> [17] </ref> extend their enumerative approach described in [16] to schedule flow shops with arbitrary release times and deadlines to minimize lateness. In no-wait flow shops the tasks are not buffered between processors.
Reference: [18] <author> J. N. D. Gupta and S. S. Reddi. </author> <title> Improved dominance conditions for the three-machine flowshop scheduling problem. </title> <journal> Oper. Res., </journal> <volume> 26 </volume> <pages> 200-203, </pages> <year> 1978. </year>
Reference-contexts: [21] use integer-programming techniques and Lagrangian relaxation to schedule tasks with deadlines to minimize the weighted tardiness of tasks in job shops where precedence constraints are simple. (In a job shop, tasks execute on different processors in arbitrary orders.) Much research has focused on enumerative methods for permutation flow shops <ref> [18, 35] </ref>. In a permutation flow shop the tasks execute in the same order on all the processors. In other words, if the execution of a task T i precedes the execution of another task T j on one processor, T i must precede T j on all the processors.
Reference: [19] <author> C. C. Han. </author> <title> Scheduling Real-time computatios with Temporal Distance and Separation Constraints and with Extended Deadlines. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Their pipeline model is generalized to consider inter-instructional latencies. Dependencies can be weighted to represent the minimal delay between the termination of one subtask and the execution of the descendent subtask. Inter-instructional latencies are similar to minimum-distance constraints described by Han in <ref> [19, 20] </ref>. According to the heuristic in [39], the priority assignments are based on weighted path lengths in the dependency graph. <p> All release times and deadlines are met in this schedule. The problem of scheduling the subtasks on the reused processor P v l in Step 1 of Algorithm R is a variation of the problem of scheduling in-trees with separation constraints described by Han in <ref> [19] </ref>. <p> Here, k is called the minimum separation and is a parameter of the problem. Han solves this problem in <ref> [19] </ref> with a vertex labeling approach in the dependency graph.
Reference: [20] <author> C. C. Han and K. J. Lin. </author> <title> Job scheduling with separation constraints. </title> <type> Technical Report UIUCDCS-R-1635, </type> <institution> Department of Computer Science, University of Illinois, </institution> <year> 1990. </year>
Reference-contexts: Their pipeline model is generalized to consider inter-instructional latencies. Dependencies can be weighted to represent the minimal delay between the termination of one subtask and the execution of the descendent subtask. Inter-instructional latencies are similar to minimum-distance constraints described by Han in <ref> [19, 20] </ref>. According to the heuristic in [39], the priority assignments are based on weighted path lengths in the dependency graph.
Reference: [21] <author> D. Hoitomt, P. B. Luh, and K. R. Pattipati. </author> <title> Job shop scheduling with simple precedence constraints. </title> <booktitle> In , pages 1-6, </booktitle> <year> 1991. </year>
Reference-contexts: Consequently, most studies of flow-shop problems were concerned with restrictions of the problem that make it tractable. Other efforts focused on heuristic algorithms and enumerative methods that yield optimal and suboptimal schedules in reasonable amounts of time. Hoitomt et al. <ref> [21] </ref> use integer-programming techniques and Lagrangian relaxation to schedule tasks with deadlines to minimize the weighted tardiness of tasks in job shops where precedence constraints are simple. (In a job shop, tasks execute on different processors in arbitrary orders.) Much research has focused on enumerative methods for permutation flow shops [18,
Reference: [22] <author> D. D. Kandlur, K. G. Shin, and D. Ferrari. </author> <title> Real-time communication in multi-hop networks. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <month> May </month> <year> 1991. </year> <month> 147 </month>
Reference-contexts: Since only the end-to-end delay is constrained to be under some limit, there are more choices in scheduling message transmissions through the multiple links in the network. The increase in the number of choices results in either more complicated algorithms or heuristics with uncertain performance. Kandlur et al. <ref> [22] </ref> describe a method to guarantee time-constrained, sequenced message delivery over unidirectional virtual connections, called (real-time) channels. A channel consists of a sequence of communication links. The communication links in each channel are selected at channel-establishment time.
Reference: [23] <author> J. F. Kurose, M. Schwartz, and Y. Yemini. </author> <title> Multiple access protocols and time-constrained communication. </title> <journal> ACM Computing Surveys, </journal> <volume> 16 </volume> <pages> 43-70, </pages> <month> March </month> <year> 1984. </year>
Reference-contexts: According to the heuristic in [39], the priority assignments are based on weighted path lengths in the dependency graph. Timing constraints are then added in the form of additional such latencies. 3.3 Real-Time Communication In a real-time communication system <ref> [23] </ref>, there is a time constraint on the delay of each message, that is, the length of the time interval between the time instants when the source generates the message and when the destination receives it. The message is discarded when its delay exceeds this constraint. <p> The encoding and packeting schemes are designed so that the occasional loss of packets has a minimal effect on the quality of the received audio or video. Recently, a considerable amount of effort has been directed toward how to ensure messages with time constraints are delivered over multiple-access networks <ref> [1, 23, 38, 55] </ref> in time. When the underlying network has a point-to-point interconnection structure, such as in wide-area networks [7], it is more complicated to guarantee timely message delivery.
Reference: [24] <author> E. Lawler, J. K. Lenstra, C. Martel, B. Simons, and L. Stockmeyer. </author> <title> Pipeline scheduling: A survey. </title> <type> Technical Report RJ 5738, </type> <institution> IBM Research Division, </institution> <address> San Jose, CA, </address> <year> 1987. </year>
Reference-contexts: However, polynomial algorithms for optimally scheduling tasks with identical processing times on one or two processors exist [10, 13]. Our algorithms in Chapter 4 and Chapter 5 make use of one of them. 3.2 Pipeline Scheduling Lawler et al. <ref> [24] </ref> identify three differences between the pipeline-scheduling and the flow-shop scheduling problems: (1) As opposed to flow-shops, no buffering of subtasks is allowed between stages in pipelines. We note that the buffering of subtasks allows for non-permutation schedules on flow shops.
Reference: [25] <author> E. L. Lawler, J. K. Lenstra, A. H. G. Rinnooy Kan, and D. B. Shmoys. </author> <title> Sequencing and scheduling: Algorithms and complexity. </title> <type> Technical report, </type> <institution> Centre for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1989. </year>
Reference-contexts: The problem of scheduling tasks in a flow shop to meet deadlines is N P -hard, except for a few special cases <ref> [11, 25] </ref>. <p> summarize the similarities and differences in the approaches and objectives of our work and earlier work on the related problems. 3.1 Classical Machine-Scheduling Theory Past efforts in flow-shop scheduling have focused on the minimization of completion time, that is, the total time required to complete a given set of tasks <ref> [9, 12, 25, 53] </ref>. Johnson [9] showed that tasks in a two-processor flow shop can be scheduled to minimize completion time in O (n log n) time. Beyond the two-processor flow shop, however, almost every flow-shop scheduling problem is N P-complete. <p> The problem of scheduling no-wait flow shops is reviewed in [15]. The general problem of scheduling to meet deadlines on identical multiprocessor systems is also N P-hard <ref> [11, 25] </ref>. However, polynomial algorithms for optimally scheduling tasks with identical processing times on one or two processors exist [10, 13]. <p> Nevertheless, EDF schedules for task sets with identical release times have two useful characteristics. First, as long as no task starts after its deadline in an EDF schedule, the total tardiness is minimized [6]. Second, in any EDF schedule, the maximum tardiness is minimized <ref> [25] </ref>. These two characteristics are used in the following Rule C2 T : Rule C2 T : Schedule the subtasks in U according to the EEDF algorithm, assuming that all release times are equal to r = maxfe ij ; min T lj 2U fr lj gg.
Reference: [26] <author> J. P. Lehoczky and L. Sha. </author> <title> Performance of real-time bus scheduling algorithms. </title> <journal> ACM Performance Evaluation Review, </journal> <year> 1986. </year>
Reference-contexts: This follows as a corollary from Theorem 1 since the traditional flow shop is a special case of the flow shop with recurrence. 11 2.3 The Periodic Flow Shop The periodic flow-shop model is a generalization of both the traditional flow-shop model and the traditional periodic-job model <ref> [26, 31, 41] </ref>. As in the traditional periodic-job model, the periodic job system J to be scheduled in a flow shop consists of n periodic jobs. Each job consists of a periodic sequence of requests for the same computation. In our previous terms, each request is a task. <p> The resultant schedule is a feasible schedule where all precedence constraints and all deadlines are met. We call this method of transforming dependent subjobs into independent subjobs the phase modification method. In the following sections we describe methods that allow to use existing schedulability criteria <ref> [26, 27, 31] </ref> to determine whether there is a set of fc ij g where P m j=1 c ij D i .
Reference: [27] <author> J. P. Lehoczky, L. Sha, J. K. Strosnider, and H. Tokuda. </author> <title> Fixed priority scheduling theory for hard real-time systems. </title> <editor> In A. M. Tilborg and G. M. Koob, editors, </editor> <title> Foundations of Real-Time Computing, Scheduling and Resource Management, chapter 1. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Hence, a sequence of requests for a periodic computation in a traditional flow shop is represented as a single task in a periodic flow shop. Several analytical techniques exist to determine whether given algorithms can feasibly schedule periodic tasks on a single processor <ref> [27, 31] </ref>. Schedulability analysis is the process of determining whether a given algorithm always generates a feasible schedule for a given system of tasks under all conditions. We extended the techniques for single-processor schedulability analysis to end-to-end schedulability analysis of systems where tasks execute on more than one processor. <p> The resultant schedule is a feasible schedule where all precedence constraints and all deadlines are met. We call this method of transforming dependent subjobs into independent subjobs the phase modification method. In the following sections we describe methods that allow to use existing schedulability criteria <ref> [26, 27, 31] </ref> to determine whether there is a set of fc ij g where P m j=1 c ij D i . <p> highest priority, and J n the lowest. 63 Jobs t i1 t i2 p i c i1 c i2 C i J 1 2 1 8 3.3 3.6 6.9 J 3 1 2 16 6.6 7.2 13.8 Table 6.1: Set of Periodic Jobs on a Two-Processor Flow Shop Equation (6.1) <ref> [27] </ref> gives the so called schedulability bound u max (n; ) on the total utilization u j (n) = i=1 t ij =p i of the subjobs on each processor P j ; a set of subjobs whose total utilization is equal to or less than u max (n; ffi) is <p> and J 3 . 64 Jobs t i1 t i2 p i c i1 c i2 C i J 1 5 5 10 0.553 0.553 1.106 Table 6.2: Unschedulable Set of Periodic Jobs on a Two-Processor Flow Shop Table 6.2 shows an example that is due to Lehoczky et al. <ref> [27] </ref>. The job set in this example cannot always be scheduled so that both jobs meet their deadlines at the end of their respective periods. When the two jobs have the same phase, J 1 is interrupted to let J 2 execute and misses its deadline.
Reference: [28] <author> J. P. Lehoczky, L Sha, and J.K. Strosnider. </author> <title> Enhanced aperiodic scheduling in hard-real-time environments. </title> <booktitle> In Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 261-270, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: 1) ............................................................................................................................................................... .. .. .. .. . . . ... ... .. .. .. . . ............................................................................................................................................................... ... .. .. .. . . ... .. .. .. .. . . . p k (b) Sporadic Server Avoids Deferred Execution Effects The example in Figure 6.5a illustrates the deferred execution effect <ref> [28] </ref>, a problem that appears on all but the first processor in a flow shop where jobs are invoked asynchronously. T ij (k) and T ij (k + 1) in this example are the k th and (k + 1) th invocations of subjob J ij .
Reference: [29] <author> J. Y.-T. Leung, O. Vornberger, and J. Witthoff. </author> <title> On some variants of the bandwidth minimization problem. </title> <journal> SIAM J. Comput., </journal> <volume> 13 </volume> <pages> 650-667, </pages> <year> 1984. </year>
Reference-contexts: Most generalizations of these two cases are N P-complete. For example, the general pipeline-scheduling problem to minimize completion time on a single pipeline of length k for arbitrary dependency graphs is N P-complete <ref> [29] </ref>. 14 Palem and Simons [39] describe a priority-driven heuristic algorithm to schedule pipelines with timing constraints. Their pipeline model is generalized to consider inter-instructional latencies. Dependencies can be weighted to represent the minimal delay between the termination of one subtask and the execution of the descendent subtask. <p> Both the problem of scheduling on a reused processor and Han's problem of scheduling with separation constraints are related to a wide class of multiprocessor and pipeline scheduling problems that can be formulated as separation problems <ref> [29] </ref>. The separation problem, as well as its dual problem, the bandwidth-minimization problem, is defined in the following way: given an arbitrary graph, find a one-to-one labeling of the vertices, so that the difference between the labelings of any two adjacent vertices is at least k.
Reference: [30] <author> J. Y.-T. Leung and J. Whitehead. </author> <title> On the complexity of fixed-priority scheduling of periodic, real-time tasks. Performance Evaluation, </title> <booktitle> 2 </booktitle> <pages> 237-250, </pages> <month> December </month> <year> 1982. </year>
Reference-contexts: This assignment is optimal for job systems in which the relative deadlines of jobs are shorter or equal to their periods, that is D i p i <ref> [2, 30] </ref>. (In the special case when the D i 's are proportional to the periods, this assignment is identical to the rate-monotonic assignment.) In [2] we are given a sufficient, but not necessary, schedulability condition for a job set on one processor with arbitrary deadlines D i p i to
Reference: [31] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard real-time environment. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 20 </volume> <pages> 46-61, </pages> <year> 1973. </year>
Reference-contexts: Hence, a sequence of requests for a periodic computation in a traditional flow shop is represented as a single task in a periodic flow shop. Several analytical techniques exist to determine whether given algorithms can feasibly schedule periodic tasks on a single processor <ref> [27, 31] </ref>. Schedulability analysis is the process of determining whether a given algorithm always generates a feasible schedule for a given system of tasks under all conditions. We extended the techniques for single-processor schedulability analysis to end-to-end schedulability analysis of systems where tasks execute on more than one processor. <p> This follows as a corollary from Theorem 1 since the traditional flow shop is a special case of the flow shop with recurrence. 11 2.3 The Periodic Flow Shop The periodic flow-shop model is a generalization of both the traditional flow-shop model and the traditional periodic-job model <ref> [26, 31, 41] </ref>. As in the traditional periodic-job model, the periodic job system J to be scheduled in a flow shop consists of n periodic jobs. Each job consists of a periodic sequence of requests for the same computation. In our previous terms, each request is a task. <p> The resultant schedule is a feasible schedule where all precedence constraints and all deadlines are met. We call this method of transforming dependent subjobs into independent subjobs the phase modification method. In the following sections we describe methods that allow to use existing schedulability criteria <ref> [26, 27, 31] </ref> to determine whether there is a set of fc ij g where P m j=1 c ij D i . <p> Suppose that the set J 1 of subjobs is scheduled on the first processor P 1 according to the well-known rate-monotone algorithm <ref> [31] </ref>. This algorithm is priority-driven; it assigns priorities statically to jobs (and, hence, to individual tasks in them) on the basis of their periods; the shorter the period of a job, the higher its priority.
Reference: [32] <author> J.W.S. Liu, J.L. Redondo, Z. Deng, T.S. Tia, R. Bettati, A. Silberman, M. Storch, R. Ha, and W.K. Shih. Perts: </author> <title> A prototyping environment for real-time systems. </title> <type> Technical Report UIUCDCS-R-1802, </type> <institution> Department of Computer Science, University of Illinois, </institution> <year> 1993. </year> <month> 148 </month>
Reference-contexts: The process of comparing the supply and the demand of time to determine the schedulability of a system is known as time demand analysis <ref> [32, 43] </ref>. The bounds for the c ij 's can now be used in combination with the phase modification method to determine the schedulability of periodic flow shops with arbitrary priority assignments. <p> scheduling the jobs. 8.2 End-to-End Schedulability Analysis Part of the results in end-to-end scheduling of periodic workloads described in this thesis have been implemented as a part of PERTS, a prototyping environment for real-time systems, which is currently under development in the Real-Time Systems Laboratory at the University of Illinois <ref> [32, 33] </ref>. PERTS will contain schedulers and resource access protocols, in combination with tools and a simulation environment for the analysis and validation of real-time systems. PERTS is designed as a vehicle to evaluate new design approaches and to experiment with alternative scheduling and resource management strategies.
Reference: [33] <author> J.W.S. Liu, J.L. Redondo, Z. Deng, T.S. Tia, R. Bettati, A. Silberman, M. Storch, R. Ha, and W.K. Shih. Perts: </author> <title> A prototyping environment for real-time systems. </title> <booktitle> In Proceedings of the 14th Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: scheduling the jobs. 8.2 End-to-End Schedulability Analysis Part of the results in end-to-end scheduling of periodic workloads described in this thesis have been implemented as a part of PERTS, a prototyping environment for real-time systems, which is currently under development in the Real-Time Systems Laboratory at the University of Illinois <ref> [32, 33] </ref>. PERTS will contain schedulers and resource access protocols, in combination with tools and a simulation environment for the analysis and validation of real-time systems. PERTS is designed as a vehicle to evaluate new design approaches and to experiment with alternative scheduling and resource management strategies.
Reference: [34] <author> J. A. McHugh. </author> <title> Algorithmic Graph Theory. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1990. </year>
Reference-contexts: With this method, the problem of scheduling systems of independent periodic jobs with arbitrary dependency constraints between subjobs in a distributed system is reduced to the simple problem of determining the critical path in a PERT-like graph <ref> [34, 44] </ref>. 6.5 Phase Modification and Loosely Coupled Systems The phase-modification method described in Section 6.1 assumes that all processors in the system have tightly synchronized clocks. This assumption is often not satisfied in distributed 73 systems that are loosely coupled.
Reference: [35] <author> G.B. McMahon. </author> <title> A Study of Algorithms for Industrial Scheduling Problems. </title> <type> PhD thesis, </type> <institution> University of New South Wales, Kensington, </institution> <year> 1971. </year>
Reference-contexts: [21] use integer-programming techniques and Lagrangian relaxation to schedule tasks with deadlines to minimize the weighted tardiness of tasks in job shops where precedence constraints are simple. (In a job shop, tasks execute on different processors in arbitrary orders.) Much research has focused on enumerative methods for permutation flow shops <ref> [18, 35] </ref>. In a permutation flow shop the tasks execute in the same order on all the processors. In other words, if the execution of a task T i precedes the execution of another task T j on one processor, T i must precede T j on all the processors.
Reference: [36] <author> C. B. McNaughton. </author> <title> Scheduling with deadlines and loss functions. </title> <journal> Management Sci., </journal> <volume> 6 </volume> <pages> 1-12, </pages> <year> 1959. </year>
Reference-contexts: Schedulers that make use of the fact that tasks are preemptable are called preemptive schedulers. For many scheduling problems, there are no polynomial-time optimal schedulers when tasks are non-preemptable. But efficient optimal preemptive schedulers are possible (e.g. see McNaughton's rule <ref> [36] </ref>). Unfortunately, with arbitrary task parameters, the traditional flow-shop problem is N P-hard, even where the subtasks are preemptable, as the following theorem shows: Theorem 1. The flow-shop problem on m &gt; 2 processors with arbitrary task parameters is N P-complete. Proof.
Reference: [37] <author> A. K. Mok. </author> <title> Fundamental Design Problems of Distributed Systems for the Hard Real Time Environment. </title> <type> PhD thesis, </type> <institution> M.I.T., </institution> <year> 1993. </year>
Reference-contexts: Priority inversion occurs when a higher-priority subjob waits while low-priority subjobs are executing. It is uncontrolled, since this condition may last for indefinite lengths of time. Several resource access protocols have been devised to avoid deadlock and to prevent uncontrolled priority inversion <ref> [3, 37, 47] </ref>. By using these protocols, the execution times of the subjobs can be made predictable.
Reference: [38] <author> J. K. Y. Ng and J. W.-S. Liu. </author> <title> Performance of local area network protocols for hard real-time applications. </title> <booktitle> In 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 318-326, </pages> <year> 1991. </year>
Reference-contexts: The encoding and packeting schemes are designed so that the occasional loss of packets has a minimal effect on the quality of the received audio or video. Recently, a considerable amount of effort has been directed toward how to ensure messages with time constraints are delivered over multiple-access networks <ref> [1, 23, 38, 55] </ref> in time. When the underlying network has a point-to-point interconnection structure, such as in wide-area networks [7], it is more complicated to guarantee timely message delivery.
Reference: [39] <author> K. V. Palem and B. Simons. </author> <title> Scheduling time-critical instructions on risc machines. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 270-280, </pages> <year> 1990. </year>
Reference-contexts: Most generalizations of these two cases are N P-complete. For example, the general pipeline-scheduling problem to minimize completion time on a single pipeline of length k for arbitrary dependency graphs is N P-complete [29]. 14 Palem and Simons <ref> [39] </ref> describe a priority-driven heuristic algorithm to schedule pipelines with timing constraints. Their pipeline model is generalized to consider inter-instructional latencies. Dependencies can be weighted to represent the minimal delay between the termination of one subtask and the execution of the descendent subtask. <p> Their pipeline model is generalized to consider inter-instructional latencies. Dependencies can be weighted to represent the minimal delay between the termination of one subtask and the execution of the descendent subtask. Inter-instructional latencies are similar to minimum-distance constraints described by Han in [19, 20]. According to the heuristic in <ref> [39] </ref>, the priority assignments are based on weighted path lengths in the dependency graph.
Reference: [40] <author> C. H. Papadimitriou and K. Steiglitz. </author> <title> Combinatorial Optimization, Algorithms and Complexity. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1982. </year>
Reference-contexts: This can be safely assumed since the capacity of each arc from each vertex ~ T i is equal to one or two and all integral network-flow problems are known to have integer solutions. Moreover, virtually all network-flow algorithms generate an integer solution <ref> [40, 52] </ref>. Consequently Step 4 is always possible. To generate the schedule ~ S v l we scan the intervals I 1 ; I 2 ; ; I 2u1 . During any interval I k we look at the incoming arcs 60 to I k which carry a non-zero flow.
Reference: [41] <author> D. T. Peng and K. G. Shin. </author> <title> A new performance measure for scheduling independent real-time tasks. </title> <type> Technical report, </type> <institution> Department of Electrical Engineering and Computer Science, University of Michigan, </institution> <year> 1989. </year>
Reference-contexts: This follows as a corollary from Theorem 1 since the traditional flow shop is a special case of the flow shop with recurrence. 11 2.3 The Periodic Flow Shop The periodic flow-shop model is a generalization of both the traditional flow-shop model and the traditional periodic-job model <ref> [26, 31, 41] </ref>. As in the traditional periodic-job model, the periodic job system J to be scheduled in a flow shop consists of n periodic jobs. Each job consists of a periodic sequence of requests for the same computation. In our previous terms, each request is a task.
Reference: [42] <author> R. Rajkumar, L. Sha, and J. P. Lehoczky. </author> <title> Real-time synchronization of multiprocessors. </title> <booktitle> In Proceedings of the 9th Real-Time Systems Symposium, </booktitle> <pages> pages 259-269, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: This 2 example shows how variations of flow shops can be used to model certain forms of resource access, such as the integrated processor and I/O scheduling described in Sha et al. [46] or the access to global resources in a multiprocessor described by Rajkumar et al. <ref> [42] </ref>. A system may contain many classes of tasks. <p> In the second technique we use results in the scheduling of aperiodic tasks to allow for asynchronous execution of the subtasks. One area that has attracted a lot of attention in the schedulability analysis for single-processor systems are real-time resource access protocols <ref> [3, 42, 47] </ref>. We could show that these protocols can be naturally included in the phase modification technique to analyze systems with end-to-end timing constraints and access to resources, both local and global. <p> We describe how the phase modification technique can be combined with local-resource access protocols to handle systems with global resources and compare this approach against the multiprocessor priority-ceiling protocol <ref> [42] </ref>, a well known real-time multiprocessor-synchronization protocol. Chapter 8 gives a summary and an overview of open questions, and concludes the thesis. 7 Chapter 2 The Flow-Shop Model In this chapter we describe a general model of distributed systems with end-to-end constraints: the flow shop. <p> We call a critical section between the request and release of a global resource a global critical section, while a local resource gives rise to a local critical section. Rajkumar et al. <ref> [42] </ref> have extended PCP to control the access to local and global resources in a multiprocessor environment. <p> Equation (7.2) therefore is valid to determine the worst-case delays of subjobs that access global resources. The worst-case blocking factor B ij is calculated differently, however. The value of B ij is the sum of the following four quantities, which are described in detail in <ref> [42] </ref>.
Reference: [43] <author> J. L. Redondo. </author> <title> Schedulability analyzer tool. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> Feb </month> <year> 1993. </year>
Reference-contexts: The process of comparing the supply and the demand of time to determine the schedulability of a system is known as time demand analysis <ref> [32, 43] </ref>. The bounds for the c ij 's can now be used in combination with the phase modification method to determine the schedulability of periodic flow shops with arbitrary priority assignments.
Reference: [44] <author> J. Riggs. </author> <title> Production Systems Planning. </title> <publisher> Wiley, </publisher> <address> third edition, </address> <year> 1981. </year> <month> 149 </month>
Reference-contexts: With this method, the problem of scheduling systems of independent periodic jobs with arbitrary dependency constraints between subjobs in a distributed system is reduced to the simple problem of determining the critical path in a PERT-like graph <ref> [34, 44] </ref>. 6.5 Phase Modification and Loosely Coupled Systems The phase-modification method described in Section 6.1 assumes that all processors in the system have tightly synchronized clocks. This assumption is often not satisfied in distributed 73 systems that are loosely coupled.
Reference: [45] <author> N. M. Sadeh and M. S. Fox. </author> <title> Variable and value ordering heuristics for hard constraint satisfaction problems: An application to job shop scheduling. </title> <type> Technical Report CMU-RI-TR-91-23, </type> <institution> Carnegie Mellon University, </institution> <year> 1991. </year>
Reference-contexts: The worst-case complexity of this search approach is exponential. However, several heuristics can typically be applied to reduce its average cost <ref> [45, 54] </ref>.
Reference: [46] <author> L. Sha, J. P. Lehoczky, and R. Rajkumar. </author> <title> Solutions for some practical problems in prioritized preemptive scheduling. </title> <booktitle> In Proceedings of Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1986. </year>
Reference-contexts: Such a task can be modeled as a chain of three subtasks with end-to-end timing constraints. This 2 example shows how variations of flow shops can be used to model certain forms of resource access, such as the integrated processor and I/O scheduling described in Sha et al. <ref> [46] </ref> or the access to global resources in a multiprocessor described by Rajkumar et al. [42]. A system may contain many classes of tasks.
Reference: [47] <author> L. Sha, L. Rajkumar, R., and J. P. Lehoczky. </author> <title> Priority inheritance protocols: An approach to real-time synchronization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39 </volume> <pages> 1175-1185, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: In the second technique we use results in the scheduling of aperiodic tasks to allow for asynchronous execution of the subtasks. One area that has attracted a lot of attention in the schedulability analysis for single-processor systems are real-time resource access protocols <ref> [3, 42, 47] </ref>. We could show that these protocols can be naturally included in the phase modification technique to analyze systems with end-to-end timing constraints and access to resources, both local and global. <p> When subjobs access common resources, and a need arises for synchronization between subjobs, two problems must be addressed <ref> [47] </ref>: deadlocks and uncontrolled priority inversion. Priority inversion occurs when a higher-priority subjob waits while low-priority subjobs are executing. It is uncontrolled, since this condition may last for indefinite lengths of time. <p> Priority inversion occurs when a higher-priority subjob waits while low-priority subjobs are executing. It is uncontrolled, since this condition may last for indefinite lengths of time. Several resource access protocols have been devised to avoid deadlock and to prevent uncontrolled priority inversion <ref> [3, 37, 47] </ref>. By using these protocols, the execution times of the subjobs can be made predictable. <p> By using these protocols, the execution times of the subjobs can be made predictable. In the following we call one interval between the request and the release of a resource a critical section. 7.1 Local Resources In this section we focus on the priority ceiling protocol (PCP) <ref> [47] </ref> to control access to local resources and describe how it can be used in distributed systems with end-to-end timing constraints. PCP is an extension of the priority inheritance protocol, according to which a low-priority subjob that blocks a high-priority subjob inherits its priority.
Reference: [48] <author> L. Sha, L. Rajkumar, R., J. P. Lehoczky, and K. Ramamritham. </author> <title> Mode change protocols for priority-driven preemptive scheduling. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 1 </volume> <pages> 243-264, </pages> <year> 1989. </year>
Reference-contexts: In the single-processor case, such a change while the system is alive is called mode change. Protocols 92 have been devised to ensure smooth execution of mode changes <ref> [48] </ref>. In distributed systems mode changes can have a much more severe effect than on a single processor.
Reference: [49] <author> H.R. Simpson. </author> <title> A Data Interactive Architecture (DIA) for real-time embedded multiprocessor systems. </title> <booktitle> In Computing Techniques in Guided Flight RAe Conference, </booktitle> <month> April </month> <year> 1990. </year>
Reference-contexts: are computed at channel-establishment time and are used to determine the effective deadlines of message transmissions on each link. 3.4 Task Assignments Burns et al. [5] discuss the problem of allocating and scheduling periodic tasks, called transactions, that consist of chains of subtasks (called subtransactions) in DIA (Data Interaction Architecture) <ref> [49] </ref>. Each transaction consists of a collection of precedence related processes that are modeled as subtasks in our periodic flow-shop model. The processors in DIA are linked via dual-port memories.
Reference: [50] <author> B. Sprunt, L. Sha, and J.P. Lehoczky. </author> <title> Aperiodic task scheduling for hard real-time systems. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 1 </volume> <pages> 27-60, </pages> <year> 1989. </year>
Reference-contexts: Sporadic jobs differ from their periodic counterparts in that their inter-release time is not constant, but has a statistical distribution. According to the Sporadic Server algorithm <ref> [50] </ref> to schedule sporadic jobs, we introduce a special periodic job, called a server, that is in charge of executing a sporadic job: during the time assigned to the server, the sporadic job served by it executes.
Reference: [51] <author> W. Szwarc. </author> <title> Optimal elimination methods in the m fi n flow-shop scheduling problem. </title> <journal> Operation Research, </journal> <volume> 21 </volume> <pages> 1250-1259, </pages> <year> 1973. </year>
Reference-contexts: Rule C3 takes advantage of the following well-known fact: To minimize the maximum completion time in a flow shop with identical release times and no more than three processors, we only need to consider permutation schedules. French [8] and Szwarc <ref> [51] </ref> describe ways to determine lower bounds on the optimal maximum completion time for three-processor permutation flow shops. We are going to use two of these methods in the following way.
Reference: [52] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms, </title> <booktitle> volume 44 of CBMS-NSF Regional Conference Series in Applied Mathematics. Society for Industrial and Applied Mathematics, </booktitle> <address> Philadelphia, </address> <year> 1983. </year>
Reference-contexts: This can be safely assumed since the capacity of each arc from each vertex ~ T i is equal to one or two and all integral network-flow problems are known to have integer solutions. Moreover, virtually all network-flow algorithms generate an integer solution <ref> [40, 52] </ref>. Consequently Step 4 is always possible. To generate the schedule ~ S v l we scan the intervals I 1 ; I 2 ; ; I 2u1 . During any interval I k we look at the incoming arcs 60 to I k which carry a non-zero flow.
Reference: [53] <author> C. M. Woodside and D. W. Graig. </author> <title> Local non-preemptive scheduling policies for hard real-time distributed systems. </title> <booktitle> In Proceedings of Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1987. </year>
Reference-contexts: summarize the similarities and differences in the approaches and objectives of our work and earlier work on the related problems. 3.1 Classical Machine-Scheduling Theory Past efforts in flow-shop scheduling have focused on the minimization of completion time, that is, the total time required to complete a given set of tasks <ref> [9, 12, 25, 53] </ref>. Johnson [9] showed that tasks in a two-processor flow shop can be scheduled to minimize completion time in O (n log n) time. Beyond the two-processor flow shop, however, almost every flow-shop scheduling problem is N P-complete.
Reference: [54] <author> Y. Xiong, N. Sadeh, and K. Sycara. </author> <title> Intelligent backtracking techniques for job shop scheduling. </title> <booktitle> In Proceedings of the Third Int. Conf. on Principles of Knowledge Repr. and Reasoning, </booktitle> <year> 1992. </year> <month> 150 </month>
Reference-contexts: The worst-case complexity of this search approach is exponential. However, several heuristics can typically be applied to reduce its average cost <ref> [45, 54] </ref>.
Reference: [55] <author> W. Zhao, J. A. Stankovic, and K. Ramamritham. </author> <title> A window protocol for transmission of time constrained messages. </title> <journal> IEEE Trans. Computers, </journal> <volume> 39 </volume> <pages> 1186-1203, </pages> <month> September </month> <year> 1990. </year> <month> 151 </month>
Reference-contexts: The encoding and packeting schemes are designed so that the occasional loss of packets has a minimal effect on the quality of the received audio or video. Recently, a considerable amount of effort has been directed toward how to ensure messages with time constraints are delivered over multiple-access networks <ref> [1, 23, 38, 55] </ref> in time. When the underlying network has a point-to-point interconnection structure, such as in wide-area networks [7], it is more complicated to guarantee timely message delivery.
References-found: 55

