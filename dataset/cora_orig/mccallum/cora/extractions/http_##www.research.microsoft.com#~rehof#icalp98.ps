URL: http://www.research.microsoft.com/~rehof/icalp98.ps
Refering-URL: http://www.research.microsoft.com/~rehof/publications.html
Root-URL: http://www.research.microsoft.com
Email: fhenglein,rehofg@diku.dk  
Phone: Fax: +45 35321401  
Title: Constraint Automata and the Complexity of Recursive Subtype Entailment  
Author: Fritz Henglein and Jakob Rehof 
Note: Electronic mail:  
Address: Universitetsparken 1, DK-2100 Copenhagen Denmark  
Affiliation: DIKU, Department of Computer Science  
Abstract: We study entailment of structural and nonstructural recursive subtyping constraints. Constraints are formal inequalities between type expressions, interpreted over an ordered set of possibly infinite labeled trees. The nonstructural ordering on trees is the one introduced by Amadio and Cardelli for subtyping with recursive types. The structural ordering compares only trees with common shape. A constraint set entails an inequality if every assignment of meanings (trees) to type expressions that satisfies all the constraints also satisfies the inequality. In this paper we prove that nonstructural subtype entailment is PSPACE-hard, both for finite trees (simple types) and infinite trees (recursive types). For the structural ordering we prove that subtype entailment over infinite trees is PSPACE-complete, when the order on trees is generated from a lattice of type constants. Since structural subtype entailment over finite trees has been shown to be coNP-complete these are the first complexity-theoretic separation results that show that, informally, nonstructural subtype entailment is harder than structural entailment, and recursive entailment is harder than nonrecursive entailment. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aiken and E.L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings FPCA '93, Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pages 31-42, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction 1.1 Constraint entailment Notions of entailment for subtype inequality constraints and set inclusion constraints are currently receiving much attention. Recent work in subtyping systems and in set constraints using notions of constraint entailment in the sense of the present paper includes <ref> [1, 5, 15, 22, 6, 2, 8, 13] </ref>. <p> It is therefore interesting to develop entailment algorithms and to know the computational complexity of deciding entailment. Works using entailment based simplification of set constraints include <ref> [1, 6, 2, 8] </ref>.
Reference: 2. <author> A. Aiken, E.L. Wimmers, and J. Palsberg. </author> <title> Optimal representations of polymorphic types with subtyping. </title> <booktitle> In Proceedings TACS '97, Theoretical Aspects of Computer Software, Sendai, Japan, </booktitle> <pages> pages 47-77. </pages> <booktitle> Springer Lecture Notes in Computer Science, </booktitle> <volume> vol. 1281, </volume> <month> September </month> <year> 1997. </year>
Reference-contexts: 1 Introduction 1.1 Constraint entailment Notions of entailment for subtype inequality constraints and set inclusion constraints are currently receiving much attention. Recent work in subtyping systems and in set constraints using notions of constraint entailment in the sense of the present paper includes <ref> [1, 5, 15, 22, 6, 2, 8, 13] </ref>. <p> It is therefore interesting to develop entailment algorithms and to know the computational complexity of deciding entailment. Works using entailment based simplification of set constraints include <ref> [1, 6, 2, 8] </ref>.
Reference: 3. <author> R. Amadio and L. Cardelli. </author> <title> Subtyping recursive types. </title> <booktitle> In Proc. 18th Annual ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <address> Orlando, Florida, </address> <pages> pages 104-118. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: The problem of finding a complete algorithm to decide recursive subtype entailment over nonstructurally ordered trees <ref> [3] </ref> remains open. However, no nontrivial lower bounds on the problem have been given up until now. Structural subtyping was introduced by Mitchell [14] and has been used in many subsequent subtyping systems, both with finite and recursive types.
Reference: 4. <author> R. Amadio and L. Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: The reason is that infinite trees can be approximated in the nonstructurally ordered space of finite trees. In order to prove PSPACE-hardness, we shall need to talk about approximations of infinite trees by finite trees. To this end, recall (from <ref> [4, 12] </ref>) the definition of the level-k truncation of a tree t, denoted td k ; it has domain D (td k ) = fw 2 D (t) j jwj kg and is defined by td k (w) = t (w) if jwj &lt; k This definition is simplified, since we
Reference: 5. <author> W. Charatonik and A. </author> <title> Podelski. The independence property of a class of set constraints. </title> <booktitle> In Conference on Principles and Practice of Constraint Programming, </booktitle> <pages> pages 76-90. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <pages> 1118. </pages>
Reference-contexts: 1 Introduction 1.1 Constraint entailment Notions of entailment for subtype inequality constraints and set inclusion constraints are currently receiving much attention. Recent work in subtyping systems and in set constraints using notions of constraint entailment in the sense of the present paper includes <ref> [1, 5, 15, 22, 6, 2, 8, 13] </ref>.
Reference: 6. <author> M. Fahndrich and A. Aiken. </author> <title> Making set-constraint program analyses scale. In Workshop on Set Constraints, </title> <address> Cambridge MA, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction 1.1 Constraint entailment Notions of entailment for subtype inequality constraints and set inclusion constraints are currently receiving much attention. Recent work in subtyping systems and in set constraints using notions of constraint entailment in the sense of the present paper includes <ref> [1, 5, 15, 22, 6, 2, 8, 13] </ref>. <p> It is therefore interesting to develop entailment algorithms and to know the computational complexity of deciding entailment. Works using entailment based simplification of set constraints include <ref> [1, 6, 2, 8] </ref>.
Reference: 7. <author> C. Flanagan. </author> <type> Personal communication, </type> <month> March </month> <year> 1997. </year>
Reference-contexts: Even though the exact relation between their work and ours remains unclear, we have to some extent been inspired by their methods. Thus, Flanagan <ref> [7] </ref> proves PSPACE-hardness of their entailment predicate by reduction from the NFA containment problem (see [9].) However, the proof relies on a complicated (and impressive), complete axiomatization of entailment, whereas our proof uses nonsyntactic methods and a different reduction from a special form of the NFA universality problem (their reduction appears
Reference: 8. <author> C. Flanagan and M. Felleisen. </author> <title> Componential set-based analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN '97 Conference on Programming Language Design and Implementation. ACM, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: 1 Introduction 1.1 Constraint entailment Notions of entailment for subtype inequality constraints and set inclusion constraints are currently receiving much attention. Recent work in subtyping systems and in set constraints using notions of constraint entailment in the sense of the present paper includes <ref> [1, 5, 15, 22, 6, 2, 8, 13] </ref>. <p> It is therefore interesting to develop entailment algorithms and to know the computational complexity of deciding entailment. Works using entailment based simplification of set constraints include <ref> [1, 6, 2, 8] </ref>. <p> Note that our PSPACE-completeness result settles the complexity of entailment for structural subtyping over lattices of base types, for both finite and infinite types. Interestingly, nonstructural subtyping, adding just ? and &gt;, already makes entailment PSPACE-hard, even for finite types. The study of entailment by Flanagan and Felleisen <ref> [8] </ref> is related to the present study, although they work in a different model of complete infinite trees labeled with sets of constructors, and their notion of entailment is different from ours.
Reference: 9. <author> M. Garey and D. Johnson. </author> <title> Computers and Intractability A Guide to the Theory of NP-Completeness. </title> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: Even though the exact relation between their work and ours remains unclear, we have to some extent been inspired by their methods. Thus, Flanagan [7] proves PSPACE-hardness of their entailment predicate by reduction from the NFA containment problem (see <ref> [9] </ref>.) However, the proof relies on a complicated (and impressive), complete axiomatization of entailment, whereas our proof uses nonsyntactic methods and a different reduction from a special form of the NFA universality problem (their reduction appears not to be directly applicable to our case.) Their axiomatization leads to a complete algorithm <p> computational problem: Given a prefix-closed NFA A over a nontrivial alphabet , is it the case that L (A) = fl ? By a construction due to Vaughan Pratt [16] we can show that CLOSED-UNIV is PSPACE-complete for any nontrivial alphabet, by reduction from the standard universality problem for NFA's <ref> [9] </ref>. Consider the two letter alphabet ff; sg A and let * denote the empty string.
Reference: 10. <author> F. Henglein and J. Rehof. </author> <title> The complexity of subtype entailment for simple types. </title> <booktitle> In Proceedings LICS '97, Twelfth Annual IEEE Symposium on Logic in Computer Science, Warsaw, Poland, </booktitle> <pages> pages 352-361. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: All the PSPACE-results are shown in this paper; the coNP-results have been reported before <ref> [10] </ref>. The results show that, unless NP = PSPACE, adding either recursive types or nonstructural subtyping to a basic setting with structural subtyping over finite types makes entailment strictly harder to solve. <p> sg fl , one has v (ff 0 )(w) fi, whenever v is a solution to C A , thereby showing C A j= ff 0 fi. 4.1 PSPACE-hardness for finite subtyping Entailment over finite, structural trees ordered over a lattice of type constants was shown to be coNP-complete in <ref> [10] </ref>. <p> We can prove the following theorem which characterizes entailment over C-shaped valuations. The theorem is a (nontrivial) generalization of a similar theorem for atomic constraints over L, proved by the authors in <ref> [10] </ref>. A proof can be found in [19, 18]. Theorem 4.
Reference: 11. <author> J. Hopcroft and J. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The state set Q is V ; the alphabet is A; every state is an accept state. The iterated transition relation, denoted b ffi N , is defined in the standard way (see <ref> [11] </ref>). Let C be structural and weakly unifiable. A C-shaped valuation is one which maps every variable ff in C to a tree of shape s C (ff).
Reference: 12. <author> Dexter Kozen, Jens Palsberg, and Michael Schwartzbach. </author> <title> Efficient recursive sub-typing. </title> <booktitle> In Proc. 20th Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 419-428. </pages> <publisher> ACM, ACM Press, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: We consider types as labeled trees in the style of <ref> [12] </ref> to which the reader is referred for full information. A tree over is a partial function t : A fl ! with nonempty, prefix-closed tree domain D (t). <p> Base types (constants) in L are ranged over by b, typical elements of A are ranged over by a, and typical elements of A fl are ranged over by w. (see, e.g., <ref> [12] </ref> for more information.) A tree t is finite (resp. infinite) if and only if D (t) is a finite (resp. infinite) set. <p> We write w as a shorthand for w . The reversal of order in accordance with polarity captures contravariance of the subtype order with respect to the function space constructor ! (see <ref> [12] </ref>.) If is equipped with a partial order , we induce a partial order on T by setting t t 0 if and only if 8w 2 D (t) " D (t 0 ): t (w) w t 0 (w) Let V be a denumerable set of variables, distinct from elements <p> Nonstructural subtyping is obtained by fixing to be the set ffi; !; &gt;; ?g organized as a lattice by the order ? , &gt; for 2 . See <ref> [12] </ref> for further details. This organizes T as a complete lattice under the nonstructural order. <p> The reason is that infinite trees can be approximated in the nonstructurally ordered space of finite trees. In order to prove PSPACE-hardness, we shall need to talk about approximations of infinite trees by finite trees. To this end, recall (from <ref> [4, 12] </ref>) the definition of the level-k truncation of a tree t, denoted td k ; it has domain D (td k ) = fw 2 D (t) j jwj kg and is defined by td k (w) = t (w) if jwj &lt; k This definition is simplified, since we
Reference: 13. <author> S. Marlow and P. Wadler. </author> <title> A practical subtyping system for erlang. </title> <booktitle> In 2nd International Conference on Functional Programming, </booktitle> <address> Amsterdam. </address> <publisher> ACM, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: 1 Introduction 1.1 Constraint entailment Notions of entailment for subtype inequality constraints and set inclusion constraints are currently receiving much attention. Recent work in subtyping systems and in set constraints using notions of constraint entailment in the sense of the present paper includes <ref> [1, 5, 15, 22, 6, 2, 8, 13] </ref>. <p> It is therefore interesting to develop entailment algorithms and to know the computational complexity of deciding entailment. Works using entailment based simplification of set constraints include [1, 6, 2, 8]. In subtyping systems, quite similar problems are currently attacked using entailment for subtyping constraints; recent work includes <ref> [15, 22, 13] </ref>, see also [17] for further references to previous work in subtype simplification. 1.2 Contribution and related work The main objective of this paper is to understand the computational complexity of deciding the entailment problem for recursively constrained subtyping, both in the structural and the nonstructural version: Given a
Reference: 14. <author> J.C. Mitchell. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(3) </volume> <pages> 245-285, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: The problem of finding a complete algorithm to decide recursive subtype entailment over nonstructurally ordered trees [3] remains open. However, no nontrivial lower bounds on the problem have been given up until now. Structural subtyping was introduced by Mitchell <ref> [14] </ref> and has been used in many subsequent subtyping systems, both with finite and recursive types. <p> The order on L defines the subtype ordering on type constants in the standard way (see, e.g., <ref> [14] </ref> for a full introduction.) Let A be the alphabet A = ff; s; d; rg, and let A fl denote the set of finite strings over A; elements of A fl are called addresses. <p> See [20, 21] for more information. In particular, t and t 0 must have the same shape if t t 0 . As a standard consequence (which we will be very brief about here, see, e.g., <ref> [21, 14, 20] </ref> for more details) one has that any constraint set that is satisfiable over structurally ordered trees, must be weakly unifiable. This means that C # is unifiable over T # (V). Let U C be a most general unifier of C # .
Reference: 15. <author> F. Pottier. </author> <title> Simplifying subtyping constraints. </title> <booktitle> In Proceedings ICFP '96, International Conference on Functional Programming, </booktitle> <pages> pages 122-133. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: 1 Introduction 1.1 Constraint entailment Notions of entailment for subtype inequality constraints and set inclusion constraints are currently receiving much attention. Recent work in subtyping systems and in set constraints using notions of constraint entailment in the sense of the present paper includes <ref> [1, 5, 15, 22, 6, 2, 8, 13] </ref>. <p> It is therefore interesting to develop entailment algorithms and to know the computational complexity of deciding entailment. Works using entailment based simplification of set constraints include [1, 6, 2, 8]. In subtyping systems, quite similar problems are currently attacked using entailment for subtyping constraints; recent work includes <ref> [15, 22, 13] </ref>, see also [17] for further references to previous work in subtype simplification. 1.2 Contribution and related work The main objective of this paper is to understand the computational complexity of deciding the entailment problem for recursively constrained subtyping, both in the structural and the nonstructural version: Given a
Reference: 16. <author> V. Pratt. </author> <type> Personal communication, </type> <month> May </month> <year> 1997. </year>
Reference-contexts: Let CLOSED-UNIV denote the computational problem: Given a prefix-closed NFA A over a nontrivial alphabet , is it the case that L (A) = fl ? By a construction due to Vaughan Pratt <ref> [16] </ref> we can show that CLOSED-UNIV is PSPACE-complete for any nontrivial alphabet, by reduction from the standard universality problem for NFA's [9]. Consider the two letter alphabet ff; sg A and let * denote the empty string.
Reference: 17. <author> J. Rehof. </author> <title> Minimal typings in atomic subtyping. </title> <booktitle> In Proceedings POPL '97, 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Paris, France, </booktitle> <pages> pages 278-291. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1997. </year>
Reference-contexts: Works using entailment based simplification of set constraints include [1, 6, 2, 8]. In subtyping systems, quite similar problems are currently attacked using entailment for subtyping constraints; recent work includes [15, 22, 13], see also <ref> [17] </ref> for further references to previous work in subtype simplification. 1.2 Contribution and related work The main objective of this paper is to understand the computational complexity of deciding the entailment problem for recursively constrained subtyping, both in the structural and the nonstructural version: Given a set of subtyping constraints C
Reference: 18. <author> J. Rehof. </author> <title> The complexity of simple subtyping systems. </title> <type> Technical report, </type> <institution> DIKU, Dept. of Computer Science, University of Copenhagen, Denmark. </institution> <note> Available at http://www.diku.dk/research-groups/topps/personal/ rehof/publications.html, April 1998. Thesis submitted for the Ph.D. degree. </note>
Reference-contexts: Due to space limitations, details of some proofs had to be left out. They can be found in <ref> [19, 18] </ref>. 2 Preliminaries Let be the ranked alphabet of constructors, = B [ffi; !g; here L = (B; B ) is a lattice of constants (constructors of arity 0, to be thought of as base types such as, e.g., int, real) and fi; ! are binary constructors. <p> More details can be found in <ref> [19, 18] </ref>. The problem of giving an upper bound on nonstructural entailment remains open. In Section 5.2 we will show that structural recursive subtype entailment is in PSPACE. <p> In addition to the constraints above, we add the constraint (1) to C A . The trees t &gt; and t ? can be defined by regular sets of equations.) One can then show (details in <ref> [19, 18] </ref>) that, if A is a prefix-closed NFA over = ff; sg fl , then L (A) = ff; sg fl if and only if C A j= ff 0 t ? This leads to Theorem 3. <p> We can prove the following theorem which characterizes entailment over C-shaped valuations. The theorem is a (nontrivial) generalization of a similar theorem for atomic constraints over L, proved by the authors in [10]. A proof can be found in <ref> [19, 18] </ref>. Theorem 4. <p> Thus the algorithm requires only space for " w C (ff); # w C (fi); # w which is polynomial in the number of vertices in the constraint graph and thus also in the size of the input. Full details of the algorithm are given in <ref> [19, 18] </ref>. Theorem 5. The problem of structural subtype entailment over infinite trees is PSPACE-complete.
Reference: 19. <author> Jakob Rehof. </author> <title> Report on constraint automata and recursive subtype entailment. </title> <type> Technical report, </type> <institution> DIKU, Dept. of Computer Science, University of Copenhagen, Denmark. </institution> <note> Available at http://www.diku.dk/research-groups/topps/personal/ re-hof/publications.html, </note> <year> 1998. </year>
Reference-contexts: Due to space limitations, details of some proofs had to be left out. They can be found in <ref> [19, 18] </ref>. 2 Preliminaries Let be the ranked alphabet of constructors, = B [ffi; !g; here L = (B; B ) is a lattice of constants (constructors of arity 0, to be thought of as base types such as, e.g., int, real) and fi; ! are binary constructors. <p> The iterated transition relation, denoted b ffi N , is defined in the standard way (see [11]). Let C be structural and weakly unifiable. A C-shaped valuation is one which maps every variable ff in C to a tree of shape s C (ff). One can show (details in <ref> [19] </ref>, left out in this summary) that a structural set C is satisfiable if and only if it is satisfied by a C-shaped valuation. Moreover, one can show that, if C is satisfiable and ff; fi 2 Var (C) satisfy some easily (polynomial time) recognizable conditions (called nontriviality conditions in [19]) <p> <ref> [19] </ref>, left out in this summary) that a structural set C is satisfiable if and only if it is satisfied by a C-shaped valuation. Moreover, one can show that, if C is satisfiable and ff; fi 2 Var (C) satisfy some easily (polynomial time) recognizable conditions (called nontriviality conditions in [19]) in C, then C j= ff fi if and only if it holds for any C-shaped valuation v that v j= ff fi whenever v j= C; and in case the nontriviality conditions are not satisfied, one can easily (in polynomial time) decide entailment. <p> More details can be found in <ref> [19, 18] </ref>. The problem of giving an upper bound on nonstructural entailment remains open. In Section 5.2 we will show that structural recursive subtype entailment is in PSPACE. <p> In addition to the constraints above, we add the constraint (1) to C A . The trees t &gt; and t ? can be defined by regular sets of equations.) One can then show (details in <ref> [19, 18] </ref>) that, if A is a prefix-closed NFA over = ff; sg fl , then L (A) = ff; sg fl if and only if C A j= ff 0 t ? This leads to Theorem 3. <p> We can prove the following theorem which characterizes entailment over C-shaped valuations. The theorem is a (nontrivial) generalization of a similar theorem for atomic constraints over L, proved by the authors in [10]. A proof can be found in <ref> [19, 18] </ref>. Theorem 4. <p> Thus the algorithm requires only space for " w C (ff); # w C (fi); # w which is polynomial in the number of vertices in the constraint graph and thus also in the size of the input. Full details of the algorithm are given in <ref> [19, 18] </ref>. Theorem 5. The problem of structural subtype entailment over infinite trees is PSPACE-complete.
Reference: 20. <author> J. Tiuryn. </author> <title> Subtype inequalities. </title> <booktitle> In Proc. 7th Annual IEEE Symp. on Logic in Computer Science (LICS), </booktitle> <address> Santa Cruz, California, </address> <pages> pages 308-315. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Structural subtyping was introduced by Mitchell [14] and has been used in many subsequent subtyping systems, both with finite and recursive types. We study structural subtyping over a lattice of base types (i.e., type constants such as, e.g., int, real), because it is known <ref> [20] </ref> that even the satisfiability problem is PSPACE-hard for many nonlattices, but in PTIME for large classes of partial order, including lattices of base types, which are of practical interest. <p> This implies that the set of structurally ordered trees is a disjoint union of lattices L s , each lattice L s consisting of the set of trees having the same shape s. See <ref> [20, 21] </ref> for more information. In particular, t and t 0 must have the same shape if t t 0 . <p> See [20, 21] for more information. In particular, t and t 0 must have the same shape if t t 0 . As a standard consequence (which we will be very brief about here, see, e.g., <ref> [21, 14, 20] </ref> for more details) one has that any constraint set that is satisfiable over structurally ordered trees, must be weakly unifiable. This means that C # is unifiable over T # (V). Let U C be a most general unifier of C # .
Reference: 21. <author> J. Tiuryn and M. Wand. </author> <title> Type reconstruction with recursive types and atomic subtyping. </title> <editor> In M.-C. Gaudel and J.-P. Jouannaud, editors, </editor> <booktitle> Proc. Theory and Practice of Software Development (TAPSOFT), Orsay, France, volume 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 686-701. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1993. </year>
Reference-contexts: This implies that the set of structurally ordered trees is a disjoint union of lattices L s , each lattice L s consisting of the set of trees having the same shape s. See <ref> [20, 21] </ref> for more information. In particular, t and t 0 must have the same shape if t t 0 . <p> See [20, 21] for more information. In particular, t and t 0 must have the same shape if t t 0 . As a standard consequence (which we will be very brief about here, see, e.g., <ref> [21, 14, 20] </ref> for more details) one has that any constraint set that is satisfiable over structurally ordered trees, must be weakly unifiable. This means that C # is unifiable over T # (V). Let U C be a most general unifier of C # .
Reference: 22. <author> V. Trifonov and S. Smith. </author> <title> Subtyping constrained types. </title> <booktitle> In Proceedings SAS '96, Static Analysis Symposium, </booktitle> <address> Aachen, Germany, </address> <pages> pages 349-365. </pages> <publisher> Springer, </publisher> <year> 1996. </year> <note> Lecture Notes in Computer Science, vol.1145. </note>
Reference-contexts: 1 Introduction 1.1 Constraint entailment Notions of entailment for subtype inequality constraints and set inclusion constraints are currently receiving much attention. Recent work in subtyping systems and in set constraints using notions of constraint entailment in the sense of the present paper includes <ref> [1, 5, 15, 22, 6, 2, 8, 13] </ref>. <p> It is therefore interesting to develop entailment algorithms and to know the computational complexity of deciding entailment. Works using entailment based simplification of set constraints include [1, 6, 2, 8]. In subtyping systems, quite similar problems are currently attacked using entailment for subtyping constraints; recent work includes <ref> [15, 22, 13] </ref>, see also [17] for further references to previous work in subtype simplification. 1.2 Contribution and related work The main objective of this paper is to understand the computational complexity of deciding the entailment problem for recursively constrained subtyping, both in the structural and the nonstructural version: Given a
References-found: 22

