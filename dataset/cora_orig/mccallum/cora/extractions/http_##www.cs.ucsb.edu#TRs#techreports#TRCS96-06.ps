URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS96-06.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: contact: probert@cs.ucsb.edu  
Title: Efficient Cross-domain Mechanisms for Building Kernel-less Operating Systems  
Author: Dave Probert and John Bruno 
Address: Santa Barbara, California 93106  
Affiliation: Computer Science Department University of California  
Abstract: We describe a set of efficient cross-domain mechanisms that allow operating systems to be implemented as cooperating applications, eliminating the need for a monolithic kernel. Our implementation, called SPACE[1, 2], can achieve higher-performance than kernel-based systems by allowing applications to build customized system services and tailor system interfaces for performance. On the SPARC architecture we have measured minimal application-to-application system service calls that are 5 times faster than Solaris getpid(), and customized thread creation that is 50 times faster than minimal Solaris threads. SPACE unifies exception handling and cross-domain calls into a single mechanism that allows applications to efficiently interface to the underlying hardware. Conventional memory-management hardware is used to provide multiple protection domains within each address space. Cross-domain calls are implemented by portals, which map an exception in one domain to a handler in another. Portals are accessible on a per-domain basis, providing capability-based access to system services. The portals are implemented by synthesizing code according to templates for each portal type. The portal types are designed to minimize state saving and eliminate the dynamic binding overhead of generic cross-domain implementations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Dave Probert, John Bruno, and Murat Karaorman. </author> <title> Space: A new approach to operating system abstraction. </title> <booktitle> In Proceedings of the International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 133137, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The first three of these properties are generally accepted as benefits of the kernel-less approach. One of the primary contributions of this work is to achieve these benefits while also achieving gains in performance. Our kernel-less operating system is based on an approach we call SPACE 1 <ref> [1, 2] </ref>. fl This research is supported in part by a UC MICRO grant and the Xerox Corporation. 1 SPACE is an acronym for Systems Programming using Address-spaces and Capabilities for Extensibility. 1 2 1.1 Operating Systems Approaches Operating system design is generally inseparable from hardware architecture. <p> Originally the Exokernel [17] took a very similar approach to the Cache Kernel, but more recent work indicates that its developers are moving toward the kernel-less model that we have been advocating <ref> [1] </ref>, though with less emphasis on mechanisms realizable in hardware. One of the key differences between the SPACE approach and that taken by Exokernel and Cache Kernel is the viewpoint we have taken about the necessary abstractions. <p> Co-location is one of the advantages that kernel-based systems inherently have. Hardware memory management supports two protection domains within every address space: user and supervisor. Code executing in the supervisor domain can typically access all data in the user domain. We have proposed an alternative implementation of co-location <ref> [1] </ref>, which uses overlapping hardware address spaces to build an arbitrary number of domains within each address space. Services in co-located domains are accessed via cross-domain calls through portals. Services can directly reference any page within the common address space for which they have been granted permission.
Reference: [2] <author> Dave Probert and John Bruno. </author> <title> Building fundamentally extensible application-specific operating systems in space. </title> <type> Technical Report TRCS95-06, </type> <institution> Computer Science Dept., UC Santa Barbara, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: The first three of these properties are generally accepted as benefits of the kernel-less approach. One of the primary contributions of this work is to achieve these benefits while also achieving gains in performance. Our kernel-less operating system is based on an approach we call SPACE 1 <ref> [1, 2] </ref>. fl This research is supported in part by a UC MICRO grant and the Xerox Corporation. 1 SPACE is an acronym for Systems Programming using Address-spaces and Capabilities for Extensibility. 1 2 1.1 Operating Systems Approaches Operating system design is generally inseparable from hardware architecture. <p> On architectures with tagged TLBs and hierarchical page table structures, the cost of this implementation is the additional page tables that must be added to describe the distinct domains, as we show in <ref> [2] </ref>, and the corresponding increase in the size of the TLB working set within the MMU. In our kernel-less implementation, invocation of a null operating system service (co-located or not) takes only the cost of the cross-domain call (1.6S on our SPARC platform).
Reference: [3] <author> Patrick Bridges. </author> <booktitle> Current operating systems projects and os-related research. </booktitle> <address> http://www.cs.arizona.edu/people/bridges/oses.html. </address>
Reference-contexts: In sections 4 and 5 we will present our approach to domain crossing which allows cross-domain invocations to be performed even more efficiently than kernel invocations are today. 2 Related Work Interest in operating systems research has accelerated in recent years, with large numbers of projects underway <ref> [3] </ref>. Increasing application requirements for efficient system services are in conflict with increasing demands for more features and backwards compatibility. One approach to resolving this conflict between functionality and performance. is to allow applications to build custom operating system services.
Reference: [4] <author> David R. Cheriton and Kenneth J. Duda. </author> <title> A caching model of operating system kernel functionality. </title> <booktitle> In Proceedings of the 1st USENIX Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 179193, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: One approach to resolving this conflict between functionality and performance. is to allow applications to build custom operating system services. A common strategy is to allow applications to dynamically load systems code into a central kernel. The Cache Kernel <ref> [4] </ref> defines low-level system objects: address spaces, threads, and kernels. These objects can be loaded into the kernel which will execute the performance critical parts.
Reference: [5] <author> Brian Bershad, Stefan Savage, and et. al. </author> <title> Extensibility, safety and performance in the spin operating system. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: A common strategy is to allow applications to dynamically load systems code into a central kernel. The Cache Kernel [4] defines low-level system objects: address spaces, threads, and kernels. These objects can be loaded into the kernel which will execute the performance critical parts. The SPIN Operating System <ref> [5] </ref> allows application code written in Modula 3 to be linked into the kernel, using language and loader mechanisms to build software protection domains. A similar approach is taken by Bridge [6] using Software Fault Isolation [7] to allow dynamic linking of application code written in standard languages, like C. <p> The first is the cost of the Mach abstractions for communication. Even after extensive tuning, remote procedure calls (RPC) are still four times slower [9] than in systems like Spring [21]. Dynamic loading of services allows RPC to be avoided, as in Bridge/SFI [7] and systems like SPIN <ref> [5] </ref>. The second problem is that services implemented in distinct address space require parameters to be copied between address spaces. Services in the application address space can directly access parameters (given sufficient protection mechanisms). Co-location is one of the advantages that kernel-based systems inherently have. <p> One direction that researchers have looked is embedding application code within the kernel domain, using language and linking techniques to build protection domains in software <ref> [5, 6] </ref>. So far these approaches have had some success, though at the cost of higher run-time overhead, as well as increasing the cost of the the cross-domain calls that the techniques do not eliminate. These techniques are applicable to kernel-less systems just as much as to kernel-based systems.
Reference: [6] <author> Steve Lucco. </author> <title> Adaptable binary programs. </title> <type> Technical Report CMU-CS-94-137, CMU, </type> <year> 1994. </year>
Reference-contexts: The SPIN Operating System [5] allows application code written in Modula 3 to be linked into the kernel, using language and loader mechanisms to build software protection domains. A similar approach is taken by Bridge <ref> [6] </ref> using Software Fault Isolation [7] to allow dynamic linking of application code written in standard languages, like C. The Flexible Mach [8] effort and Mach development at OSF [9] are co-locating operating system services into applications, at user-level and in the kernel, depending on protection requirements. <p> One direction that researchers have looked is embedding application code within the kernel domain, using language and linking techniques to build protection domains in software <ref> [5, 6] </ref>. So far these approaches have had some success, though at the cost of higher run-time overhead, as well as increasing the cost of the the cross-domain calls that the techniques do not eliminate. These techniques are applicable to kernel-less systems just as much as to kernel-based systems.
Reference: [7] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203216, </pages> <month> July </month> <year> 1993. </year> <month> 14 </month>
Reference-contexts: The SPIN Operating System [5] allows application code written in Modula 3 to be linked into the kernel, using language and loader mechanisms to build software protection domains. A similar approach is taken by Bridge [6] using Software Fault Isolation <ref> [7] </ref> to allow dynamic linking of application code written in standard languages, like C. The Flexible Mach [8] effort and Mach development at OSF [9] are co-locating operating system services into applications, at user-level and in the kernel, depending on protection requirements. <p> The first is the cost of the Mach abstractions for communication. Even after extensive tuning, remote procedure calls (RPC) are still four times slower [9] than in systems like Spring [21]. Dynamic loading of services allows RPC to be avoided, as in Bridge/SFI <ref> [7] </ref> and systems like SPIN [5]. The second problem is that services implemented in distinct address space require parameters to be copied between address spaces. Services in the application address space can directly access parameters (given sufficient protection mechanisms). Co-location is one of the advantages that kernel-based systems inherently have.
Reference: [8] <author> In-Kernel Servers on Mach 3.0: Implementation and Performance. Jay lepreau and mike hibler and bryan ford and jeff law. </author> <booktitle> In Proc. of the 3rd Usenix Mach Symposium, </booktitle> <address> Santa Fe, NM, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: A similar approach is taken by Bridge [6] using Software Fault Isolation [7] to allow dynamic linking of application code written in standard languages, like C. The Flexible Mach <ref> [8] </ref> effort and Mach development at OSF [9] are co-locating operating system services into applications, at user-level and in the kernel, depending on protection requirements. The Utah effort has also experimented with dynamically attaching trap vectors.
Reference: [9] <author> Michael Condict, David Mitchell, and Franklin Reynolds. </author> <title> Optimizing performance of mach-based systems by server co-location: A detailed design, </title> <month> August </month> <year> 1993. </year>
Reference-contexts: A similar approach is taken by Bridge [6] using Software Fault Isolation [7] to allow dynamic linking of application code written in standard languages, like C. The Flexible Mach [8] effort and Mach development at OSF <ref> [9] </ref> are co-locating operating system services into applications, at user-level and in the kernel, depending on protection requirements. The Utah effort has also experimented with dynamically attaching trap vectors. <p> There are two problems that co-location solves. The first is the cost of the Mach abstractions for communication. Even after extensive tuning, remote procedure calls (RPC) are still four times slower <ref> [9] </ref> than in systems like Spring [21]. Dynamic loading of services allows RPC to be avoided, as in Bridge/SFI [7] and systems like SPIN [5]. The second problem is that services implemented in distinct address space require parameters to be copied between address spaces.
Reference: [10] <author> G. Muller C. Bryce. </author> <title> Matching micro-kernels to modern applications using fine-grained memory protection. </title> <booktitle> In Seventh IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 272279, </pages> <address> San Antonio (Tx), </address> <month> October </month> <year> 1995. </year>
Reference-contexts: The Utah effort has also experimented with dynamically attaching trap vectors. Bryce & Muller have reported experiments using the hardware MMU to implement protection domains <ref> [10] </ref> that are similar to those in SPACE. They have gained performance improvements over Mach 3.0 using an optimization of LRPC [11, 12].
Reference: [11] <author> B. N. Bershad, T. E. Anderson, E D. Lazowska, and H.E. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1):3755, </volume> <month> February </month> <year> 1990. </year>
Reference-contexts: The Utah effort has also experimented with dynamically attaching trap vectors. Bryce & Muller have reported experiments using the hardware MMU to implement protection domains [10] that are similar to those in SPACE. They have gained performance improvements over Mach 3.0 using an optimization of LRPC <ref> [11, 12] </ref>. A more limited strategy is adopted by Protected Shared Libraries [13], which uses protected memory regions to build co-located domains for implementing operating system services using segmentation features of the RS/6000 architecture.
Reference: [12] <author> Virgil Bourassa and John Zahorjan. </author> <title> Implementing lightweight remote procedure calls in the mach 3.0 operating system. </title> <type> Technical Report UW-CSE-95-02-01, </type> <institution> Dept. of Comp. Sci. and Eng., University of Washington, </institution> <address> Seattle, </address> <year> 1995. </year>
Reference-contexts: The Utah effort has also experimented with dynamically attaching trap vectors. Bryce & Muller have reported experiments using the hardware MMU to implement protection domains [10] that are similar to those in SPACE. They have gained performance improvements over Mach 3.0 using an optimization of LRPC <ref> [11, 12] </ref>. A more limited strategy is adopted by Protected Shared Libraries [13], which uses protected memory regions to build co-located domains for implementing operating system services using segmentation features of the RS/6000 architecture.
Reference: [13] <author> Arindam Banerji and David L. Cohn. </author> <title> Protected shared libraries. </title> <note> To appear in IWOOOS, </note> <month> December </month> <year> 1994. </year>
Reference-contexts: Bryce & Muller have reported experiments using the hardware MMU to implement protection domains [10] that are similar to those in SPACE. They have gained performance improvements over Mach 3.0 using an optimization of LRPC [11, 12]. A more limited strategy is adopted by Protected Shared Libraries <ref> [13] </ref>, which uses protected memory regions to build co-located domains for implementing operating system services using segmentation features of the RS/6000 architecture. An alternative to implementing new system services in the kernel is to streamline the services that are already there through dynamic code synthesis.
Reference: [14] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The synthesis kernel. </title> <booktitle> Computing Systems, </booktitle> <address> 1(1):1132, </address> <month> Winter </month> <year> 1988. </year>
Reference-contexts: An alternative to implementing new system services in the kernel is to streamline the services that are already there through dynamic code synthesis. Synthesis <ref> [14] </ref> and Synthetix [15] takes this approach, as does Scout [16]. All these approaches still maintain a central kernel (or microkernel). One of the primary considerations in their design is minimizing the crossing of hardware protection boundaries. Cross-domain calls have been a critical issue in the performance of previous systems. <p> One has been to write special case code in locore.s for services whose performance is too critical to pass through the abstraction-adaptation layer. Another has been to dynamically synthesize kernel-code at run-time <ref> [14] </ref>. A kernel-less system does not eliminate the abstraction-adaptation layer. To do so would make it infeasible to construct service-rich operating systems. <p> Specialized trap vectors are also useful for implementing dynamically customized services. For example a service that opens a file might establish read/write operations tailored to that file or class of files, as in Synthesis <ref> [14] </ref>. 6 Hardware trap mechanisms for SPACE The low overhead of cross-domain calls in SPACE exposes the underlying cost of crossing hardware domain boundaries. In principle these costs should be low on RISC processors 3 . However designers have had little incentive to trim these costs.
Reference: [15] <author> T. Autrey, A. Black, C. Consel, C. Cowan, J. Inouye, L. Kethana, J. Walpole, and K. Zhang. </author> <title> Optimistic incremental specialization: Streamlining a commercial operating system. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 314324, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: An alternative to implementing new system services in the kernel is to streamline the services that are already there through dynamic code synthesis. Synthesis [14] and Synthetix <ref> [15] </ref> takes this approach, as does Scout [16]. All these approaches still maintain a central kernel (or microkernel). One of the primary considerations in their design is minimizing the crossing of hardware protection boundaries. Cross-domain calls have been a critical issue in the performance of previous systems.
Reference: [16] <author> A. B. Montz and et. al. </author> <title> Scout: A communications-oriented operating system. </title> <type> Technical Report 94-20, </type> <institution> Dept. of Computer Science, Univ. of Arizona, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: An alternative to implementing new system services in the kernel is to streamline the services that are already there through dynamic code synthesis. Synthesis [14] and Synthetix [15] takes this approach, as does Scout <ref> [16] </ref>. All these approaches still maintain a central kernel (or microkernel). One of the primary considerations in their design is minimizing the crossing of hardware protection boundaries. Cross-domain calls have been a critical issue in the performance of previous systems.
Reference: [17] <author> Dawson R. Engler, M. Frans Kaashoek, and James W. O'Toole Jr. Exokernel: </author> <title> an operating system architecture for application-level resource management. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 251266, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Centralized kernels represent centralized abstractions, which become imposed on all system services. The Exokernel approach is being developed to specifically address the problem of burdening applications with a rigid set of abstractions maintained by the kernel. Originally the Exokernel <ref> [17] </ref> took a very similar approach to the Cache Kernel, but more recent work indicates that its developers are moving toward the kernel-less model that we have been advocating [1], though with less emphasis on mechanisms realizable in hardware.
Reference: [18] <author> Berny Goodheart and James Cox. </author> <title> The Magic Garden Explained. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: Because these structures are primarily designed to implement protection domains for processes and to support virtual memory, the details are typically encapsulated in several layers of kernel code which adapt the hardware abstractions to the desired operating system abstractions <ref> [18] </ref>. Performance of virtual memory can be highly dependent on page replacement policies. Some virtual memory abstractions give applications hooks to control or influence these policies [19].
Reference: [19] <author> Richard Rashid, Avadis Tevanian, Jr., Michael Young, David Golub, Robert Baron, David Black, William J. Bolosky, and Jonathan Chew. </author> <title> Machine-independent virtual memory management for paged uniprocessor and multiprocessor architectures. </title> <journal> IEEE Transactions on Computer, </journal> <volume> 37(8):896 908, </volume> <month> August </month> <year> 1988. </year>
Reference-contexts: Performance of virtual memory can be highly dependent on page replacement policies. Some virtual memory abstractions give applications hooks to control or influence these policies <ref> [19] </ref>. These extensions can be used to build new types of virtual memory at the application level, but only allow coarse grain access to the hardware paging mechanisms. 2 An even lighter-weight implementation might build thread create and thread yield as portal types.
Reference: [20] <author> Andrew W. Appel and Kai Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In ASPLOS IV, </booktitle> <pages> pages 96107, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: A second optimization, which is more universal, is to require applications that invoke the lightweight thread services to first save all live registers 7 However virtual memory is not the only interesting use of processor memory management hardware. Appel & Li <ref> [20] </ref> have examined a number of other uses for virtual memory primitives, including concurrent garbage collection and persistent stores. To effectively use the MMU in these applications requires efficient access to these primitives without incurring the overhead of the operating system abstractions.
Reference: [21] <author> J. Mitchell and et. al. </author> <title> An overview of the spring system. </title> <booktitle> In Proceedings of Compcon Spring 1994, </booktitle> <month> February </month> <year> 1994. </year>
Reference-contexts: There are two problems that co-location solves. The first is the cost of the Mach abstractions for communication. Even after extensive tuning, remote procedure calls (RPC) are still four times slower [9] than in systems like Spring <ref> [21] </ref>. Dynamic loading of services allows RPC to be avoided, as in Bridge/SFI [7] and systems like SPIN [5]. The second problem is that services implemented in distinct address space require parameters to be copied between address spaces.
Reference: [22] <author> Jeffrey S. Chase, Henry M. Levy, Edward D. Lazowska, and Miche Baker-Harvey. </author> <title> Lightweight shared objects in a 64-bit operating system. </title> <booktitle> In OOPSLA, </booktitle> <month> October </month> <year> 1992. </year>
Reference: [23] <author> Hewlett Packard. </author> <title> PA-RISC 1.3 Architecture and Instruction Set Reference Manual, Fourth Edition. </title> <institution> Hewlett Packard, </institution> <year> 1995. </year>
Reference-contexts: The SPARC hardware trap mechanism performs an indexed branch into the trap vector, determined by the trap base register (TBR). The trap mechanism also switches to the trap register set, saves the program counters, and changes the processor mode to supervisor (with traps disabled): 3 Some architectures (e.g. PA/Risc <ref> [23] </ref>) already provide lower-overhead paths through the hardware trap architecture for invok ing services. 12 The generalized mechanisms in SPACE implement the following transition (from domain D 0 to D 1 ): The differences from the hardware implementation are the following: * The registers are saved/modified in an exception-dependent way.
References-found: 23

