URL: file://theory.lcs.mit.edu/pub/people/segala/ioa_pa.ps.Z
Refering-URL: http://theory.lcs.mit.edu/~segala/DS92.html
Root-URL: 
Email: denicola@vm.cnuce.cnr.it  segala@theory.lcs.mit.edu  
Title: A Process Algebraic View of Input/Output Automata  
Author: Rocco De Nicola Roberto Segala 
Address: Pisa  
Note: The first author has been partially supported by "Progetto Finalizzato  Par allelo", contract n. 91.00894.69 and by  The second author has been supported by NSF grant CCR-89-15206, by DARPA contracts N00014-89-J 1988 and N00014-92-J-4033, and by ONR contract N00014-91-J-1046.  
Date: February 28, 1994  
Affiliation: Universita di Roma "La Sapienza" Dipartimento di Scienze dell'Informazione  Massachusetts Institute of Technology Laboratory for Computer Science  Sistemi Informatici e Calcolo  Istituto di Elaborazione dell'Informazione of CNR at  
Abstract: Input/Output Automata are a widely used formalism for the specification and verification of concurrent algorithms. Unfortunately, they lack an algebraic characterization, a formalization which has been fundamental for the success of theories like CSP, CCS and ACP. We present a many-sorted algebra for I/O Automata that takes into account notions such as interface, input enabling, and local control. It is sufficiently expressive for representing all finitely branching transition systems, hence all I/O automata with a finitely branching transition relation. Our presentation includes a complete axiomatization of the external trace preorder relation over recursion free processes with input and output. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.C.M. Baeten and W.P Weijland. </author> <title> Process Algebra. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 18, </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Input/Output Automata [14, 20, 11, 12] are a widely used and deeply investigated formalism for specifying and verifying concurrent systems. Unfortunately, they have never been equipped with an algebraic characterization, a formalization that has been fundamental for the success of theories like CSP, CCS and ACP <ref> [10, 15, 8, 1] </ref>. The goal of this paper is to improve our understanding of the intricacies of I/O automata by describing them as a process algebraic theory. This will permit algebraic manipulation and will provide an alternative to the commonly used verification method based on possibilities mappings. <p> Indeed, as we mentioned in the Introduction, similar results to those obtained for the unfair preorder have been obtained also for the quiescent one [18]. 3 Process Algebras Overview The basic idea of Process Algebras <ref> [15, 10, 1] </ref> is the use of a few elementary processes and of some basic operators corresponding to primitive operations such as sequentialization, parallelism, nondeterminism and synchronization to describe concurrent processes. A process is represented as an expression which is built inductively from the elementary processes and the operators.
Reference: [2] <author> B. Bloom, S. Istrail, and A.R. Meyer. </author> <title> Bisimulation can't be traced. </title> <booktitle> In Conference Record of the 15 th ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, 35 California, </address> <pages> pages 229-239, </pages> <year> 1988. </year> <note> Full version appeared as Technical Report TR 90-1150, </note> <institution> Cornell University, Ithaca, </institution> <year> 1990. </year>
Reference-contexts: The quiescent preorder is a close attempt to capture the fair preorder using only finite schedules. It was used by Vaandrager in [21] and is reminiscent of the maximal trace congruence used in <ref> [2] </ref>. In this paper, mainly for the sake of simplicity, we concentrate on the unfair preorder; it corresponds essentially to the language equivalence of classical automata and has been used also for comparing concurrent system [9].
Reference: [3] <author> R. De Nicola. </author> <title> Extensional equivalences for transition systems. </title> <journal> Acta Informatica, </journal> <volume> 24 </volume> <pages> 211-237, </pages> <year> 1987. </year>
Reference-contexts: For an overview and a discussion on the relationships between different behavioral relations, the interested reader is referred to <ref> [3, 7] </ref>. We will study a very simple preorder (and the induced equivalence) over the transition systems associated to the terms representing I/O automata and postpone investigation of more interesting equivalences to further study.
Reference: [4] <editor> R. De Simone. Calculabilite et expressivite dans l'algebra de processus paralleles MEIJE, </editor> <year> 1984. </year> <institution> These de 3 e cycle, Univ. </institution> <address> Paris 7. </address>
Reference-contexts: e 0 e 1 S 1 k S 2 e 2 ! e 0 a 2 acts (S 1 )next (S 2 ) par 3 a 2 a 2 a 2 acts (S 2 )next (S 1 ) Recursion: Recursion within DIOA can be obtained in a De Simone style <ref> [4, 5] </ref>. Existence is assumed of a countable set X S of process variables for each sort S and of a declaration mapping E associating a guarded expression of sort S with each process variable of X S .
Reference: [5] <author> R. De Simone. </author> <title> Higher-level synchronising devices in MEIJE-SCCS. </title> <journal> Theoretical Computer Science, </journal> <volume> 37 </volume> <pages> 245-267, </pages> <year> 1985. </year>
Reference-contexts: e 0 e 1 S 1 k S 2 e 2 ! e 0 a 2 acts (S 1 )next (S 2 ) par 3 a 2 a 2 a 2 acts (S 2 )next (S 1 ) Recursion: Recursion within DIOA can be obtained in a De Simone style <ref> [4, 5] </ref>. Existence is assumed of a countable set X S of process variables for each sort S and of a declaration mapping E associating a guarded expression of sort S with each process variable of X S .
Reference: [6] <author> Nissim Francez. </author> <title> Fairness. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: A fair schedule is the schedule of a fair execution. We denote the set of fair schedules of an I/O automaton A with fscheds (A). 2 The notion of fairness defined above reminds weak fairness of <ref> [6] </ref>, but the two concepts are somewhat different. First, in [6] fairness is considered relatively to all actions, while in I/O automata only locally controlled actions are taken into account. <p> A fair schedule is the schedule of a fair execution. We denote the set of fair schedules of an I/O automaton A with fscheds (A). 2 The notion of fairness defined above reminds weak fairness of <ref> [6] </ref>, but the two concepts are somewhat different. First, in [6] fairness is considered relatively to all actions, while in I/O automata only locally controlled actions are taken into account. Second, and more important, within I/O automata theory, fairness is defined by reasoning about sets of actions rather than about single actions.
Reference: [7] <author> R.J. van Glabbeek. </author> <title> The linear time branching time spectrum. </title> <editor> In J.C.M. Baeten and J.W. Klop, editors, </editor> <booktitle> Proceedings CONCUR 90, Amsterdam, volume 458 of Lecture Notes in Computer Science, </booktitle> <pages> pages 278-297. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: For an overview and a discussion on the relationships between different behavioral relations, the interested reader is referred to <ref> [3, 7] </ref>. We will study a very simple preorder (and the induced equivalence) over the transition systems associated to the terms representing I/O automata and postpone investigation of more interesting equivalences to further study.
Reference: [8] <author> M. Hennessy. </author> <title> Algebraic Theory of Processes. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Input/Output Automata [14, 20, 11, 12] are a widely used and deeply investigated formalism for specifying and verifying concurrent systems. Unfortunately, they have never been equipped with an algebraic characterization, a formalization that has been fundamental for the success of theories like CSP, CCS and ACP <ref> [10, 15, 8, 1] </ref>. The goal of this paper is to improve our understanding of the intricacies of I/O automata by describing them as a process algebraic theory. This will permit algebraic manipulation and will provide an alternative to the commonly used verification method based on possibilities mappings. <p> In case the choice is between performing an output action o 1 and then behaving like e 1 or performing an output action o 2 and then behaving like e 2 , an external choice operator like that of <ref> [10, 8] </ref> would suffice. However, this leads to problems when dealing with input actions. <p> However, as a useful specification tool 14 and as a useful auxiliary operator for our axiomatization, we introduce an additional internal choice operator again based on <ref> [10, 8] </ref>. We will then describe the original combinators of [14]. Internal choice operator: For each sort S we define an operator S that takes two expressions of sort S and yields an expression of sort S. A process e f nondeterministically evolves according to e or f .
Reference: [9] <author> C.A.R. Hoare. </author> <title> A model of communicating systems. </title> <type> Technical report, </type> <institution> Oxford University, </institution> <year> 1981. </year>
Reference-contexts: In this paper, mainly for the sake of simplicity, we concentrate on the unfair preorder; it corresponds essentially to the language equivalence of classical automata and has been used also for comparing concurrent system <ref> [9] </ref>. We see work on this simple preorder as a stepping stone toward modeling the more elaborate ones.
Reference: [10] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Engle-wood Cliffs, </address> <year> 1985. </year>
Reference-contexts: 1 Introduction Input/Output Automata [14, 20, 11, 12] are a widely used and deeply investigated formalism for specifying and verifying concurrent systems. Unfortunately, they have never been equipped with an algebraic characterization, a formalization that has been fundamental for the success of theories like CSP, CCS and ACP <ref> [10, 15, 8, 1] </ref>. The goal of this paper is to improve our understanding of the intricacies of I/O automata by describing them as a process algebraic theory. This will permit algebraic manipulation and will provide an alternative to the commonly used verification method based on possibilities mappings. <p> Due to this basic choice, our calculus will be called the Demonic calculus of I/O Automata (DIOA). This demonic approach has been partially influenced by the Receptive Process Theory (RPT) of Mark Josephs [13]. However, the semantics of RPT is denotational, and like CSP <ref> [10] </ref>, it is described by means of sets of failures, traces and divergencies. <p> Indeed, as we mentioned in the Introduction, similar results to those obtained for the unfair preorder have been obtained also for the quiescent one [18]. 3 Process Algebras Overview The basic idea of Process Algebras <ref> [15, 10, 1] </ref> is the use of a few elementary processes and of some basic operators corresponding to primitive operations such as sequentialization, parallelism, nondeterminism and synchronization to describe concurrent processes. A process is represented as an expression which is built inductively from the elementary processes and the operators. <p> In case the choice is between performing an output action o 1 and then behaving like e 1 or performing an output action o 2 and then behaving like e 2 , an external choice operator like that of <ref> [10, 8] </ref> would suffice. However, this leads to problems when dealing with input actions. <p> However, as a useful specification tool 14 and as a useful auxiliary operator for our axiomatization, we introduce an additional internal choice operator again based on <ref> [10, 8] </ref>. We will then describe the original combinators of [14]. Internal choice operator: For each sort S we define an operator S that takes two expressions of sort S and yields an expression of sort S. A process e f nondeterministically evolves according to e or f .
Reference: [11] <author> B. Jonsson. </author> <title> A model and proof system for asynchronous networks. </title> <booktitle> In Proceedings of the 4 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Minaki, Ontario, Canada, </address> <pages> pages 49-58, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction Input/Output Automata <ref> [14, 20, 11, 12] </ref> are a widely used and deeply investigated formalism for specifying and verifying concurrent systems. Unfortunately, they have never been equipped with an algebraic characterization, a formalization that has been fundamental for the success of theories like CSP, CCS and ACP [10, 15, 8, 1].
Reference: [12] <author> B. Jonsson. </author> <title> Compositional Verification of Distributed Systems. </title> <type> PhD thesis, </type> <institution> Department of Computer Systems, Uppsala University, </institution> <year> 1987. </year> <note> DoCS 87/09. </note>
Reference-contexts: 1 Introduction Input/Output Automata <ref> [14, 20, 11, 12] </ref> are a widely used and deeply investigated formalism for specifying and verifying concurrent systems. Unfortunately, they have never been equipped with an algebraic characterization, a formalization that has been fundamental for the success of theories like CSP, CCS and ACP [10, 15, 8, 1].
Reference: [13] <author> M.B. Josephs. </author> <title> Receptive process theory. </title> <journal> Acta Informatica, </journal> <volume> 29 </volume> <pages> 17-31, </pages> <year> 1992. </year>
Reference-contexts: Due to this basic choice, our calculus will be called the Demonic calculus of I/O Automata (DIOA). This demonic approach has been partially influenced by the Receptive Process Theory (RPT) of Mark Josephs <ref> [13] </ref>. However, the semantics of RPT is denotational, and like CSP [10], it is described by means of sets of failures, traces and divergencies.
Reference: [14] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the 6 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <address> Vancouver, Canada, </address> <month> August </month> <year> 1987. </year> <note> A full version is available as MIT Technical Report MIT/LCS/TR-387. </note>
Reference-contexts: 1 Introduction Input/Output Automata <ref> [14, 20, 11, 12] </ref> are a widely used and deeply investigated formalism for specifying and verifying concurrent systems. Unfortunately, they have never been equipped with an algebraic characterization, a formalization that has been fundamental for the success of theories like CSP, CCS and ACP [10, 15, 8, 1]. <p> This will permit algebraic manipulation and will provide an alternative to the commonly used verification method based on possibilities mappings. We start by designing an algebra that incorporates the fundamental features of I/O automata of Lynch and Tuttle <ref> [14] </ref> and captures the essential role of concurrent composition, hiding and renaming. Our design aims at maintaining minimality of operators and universal expressivity. <p> The main idea behind this relation is that a quiescent trace is a trace which leads to states from which only input actions are enabled. The quiescent preorder is given by external and quiescent trace inclusion; it is a restriction to finite traces of the fair preorder of <ref> [14] </ref>, and it is another stepping stone toward the study of fairness sensitive semantics. <p> Section 7 extends the completeness result to the remaining operators. Section 8 contains some concluding remarks. 2 An Overview of I/O Automata In this section we briefly introduce I/O automata and their basic formal definition. For a complete account, we refer the reader to <ref> [14] </ref>. We will stick as much as possible with the original notation, but some notions, such as execution and schedule modules, will be ignored. Later we will homogenize the notation with that of process algebras; here, on few occasions, we will recall some obvious correspondences. <p> It is called unfair equivalence because in <ref> [14] </ref> it is presented in preparation of a different equivalence relation, namely the fair equivalence. <p> The only difference between the original and the resulting I/O automaton is in the signature. Executions and schedules are exactly the same. It is worth noting that the definition of hiding in <ref> [14] </ref> does not contain the restriction that I " in (A) = ;; it is however immediate to observe that the operator would not be closed for I/O automata if we permit hiding of input actions: part (A) would not be a partition of local (A) any more. <p> Beside the fair preorder, that is the basic relation for comparing and contrasting I/O automata <ref> [14] </ref>, other relations have been considered. These relations ignore fairness issues, but are closer to the classical relations defined for process algebras: * unfair preorder is based on (finite and infinite) schedules inclusion, while * quiescent preorder is based on both finite schedules inclusion and quiescent schedules inclusion. <p> We proceed now by defining the operational semantics of a pair of basic operators (constants) and a set of primitive operators which permit building new I/O automata from existing ones. This set of operators include the operators, renaming, hiding and parallel composition, of <ref> [14] </ref> described in the previous section and other operators which are directly inspired by those used in process algebras. <p> However, as a useful specification tool 14 and as a useful auxiliary operator for our axiomatization, we introduce an additional internal choice operator again based on [10, 8]. We will then describe the original combinators of <ref> [14] </ref>. Internal choice operator: For each sort S we define an operator S that takes two expressions of sort S and yields an expression of sort S. A process e f nondeterministically evolves according to e or f . <p> The transition rule for renaming is the following: rho a S (e) ! S (e 0 ) Parallel operator: Also the parallel operator is defined according to the original definition of <ref> [14] </ref>. In particular, we comply with the restrictions on the sorts of its operands aiming at guaranteeing that each action be under the control of at most one process. Moreover, the transition rules agree with the specification given in Definition 2.9. <p> Our process algebra is directly related to I/O automata of Lynch and Tuttle <ref> [14] </ref>, a model of distributed systems which has been successfully used for the specification and the verification of algorithms for distributed environments. 34 We have presented a set of algebraic laws which are sound with respect to the external trace preorder, a preorder which permits ignoring invisible actions and identifying those
Reference: [15] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction Input/Output Automata [14, 20, 11, 12] are a widely used and deeply investigated formalism for specifying and verifying concurrent systems. Unfortunately, they have never been equipped with an algebraic characterization, a formalization that has been fundamental for the success of theories like CSP, CCS and ACP <ref> [10, 15, 8, 1] </ref>. The goal of this paper is to improve our understanding of the intricacies of I/O automata by describing them as a process algebraic theory. This will permit algebraic manipulation and will provide an alternative to the commonly used verification method based on possibilities mappings. <p> Indeed, as we mentioned in the Introduction, similar results to those obtained for the unfair preorder have been obtained also for the quiescent one [18]. 3 Process Algebras Overview The basic idea of Process Algebras <ref> [15, 10, 1] </ref> is the use of a few elementary processes and of some basic operators corresponding to primitive operations such as sequentialization, parallelism, nondeterminism and synchronization to describe concurrent processes. A process is represented as an expression which is built inductively from the elementary processes and the operators.
Reference: [16] <author> G.D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer science Department, Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: The semantics of our many-sorted language is obtained by associating a labeled transition system with each term by means of a set of inference rules in the usual SOS style <ref> [16] </ref>. This choice paves the way toward a number of possible semantics for I/O automata. <p> Process Algebras are generally recognized as a good formalism for describing and studying properties of distributed concurrent systems. Very often, a process algebra is defined by specifying its syntax and the transitional semantics of its terms by means of Structured Operational Semantics (SOS) <ref> [16] </ref> which associate a labeled transition system (essentially a transition labeled classical automaton) to each term. Although SOS has become a standard tool for specifying basic semantics of process algebras, it was early recognized that it does not yield extensional description of processes.
Reference: [17] <author> R. Segala. </author> <title> Algebre di processi come automi con input e output, 1991. </title> <institution> Tesi di laurea, Universita di Pisa, Italy. </institution> <month> 36 </month>
Reference-contexts: This would imply that a weaker variant of substitutivity has to be introduced that asks for preservation of equivalence within only those contexts in which both equivalent processes can be inserted. The problem of defining a calculus with multiple internal actions is completely addressed in <ref> [17] </ref> where Vaandrager's work [21] is extended to the many-sorted setting. In [17] also the full details of the extended version of an angelic calculus of I/O Automata (called IOA) are completely worked out. 5 A Set of Laws for the External Trace Preorder In this section we study a set <p> The problem of defining a calculus with multiple internal actions is completely addressed in <ref> [17] </ref> where Vaandrager's work [21] is extended to the many-sorted setting. In [17] also the full details of the extended version of an angelic calculus of I/O Automata (called IOA) are completely worked out. 5 A Set of Laws for the External Trace Preorder In this section we study a set of laws for the external trace preorder over DIOA expressions containing only <p> A formal understanding of the notion of implementation would avoid the above problem. Some of the topics mentioned above are addressed in [18, 19] and will be the subject of a forthcoming paper; others are just proposals needing further investigations. Acknowledgments: The paper started as <ref> [17] </ref> and is a simplification of chapters 3 and 4 of [18]; it owes its existence to [21]. Many thanks to Frits Vaandrager for suggesting the pursued lines of investigation. We would also like to thank Nancy Lynch and Albert Meyer for helpful comments and criticisms on draft copies.
Reference: [18] <author> R. Segala. </author> <title> A process algebraic view of I/O automata. </title> <type> Technical Memo MIT/LCS/TR-557, </type> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA 02139, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: We feel that they should be useful also for behavioral relations that are more accurate than external trace preorder. Particularly important for our result is an operator representing internal choice. It does not fit Vaandrager's general format [21] and forces us to prove substitutivity of our preorder explicitly. In <ref> [18] </ref> another behavioral relation is studied: the quiescent preorder of [21]. The main idea behind this relation is that a quiescent trace is a trace which leads to states from which only input actions are enabled. <p> It is worth remarking that the complete axiomatization for the quiescent preorder of <ref> [18] </ref>, is similar to that for our external preorder; the main difference arises for the complex side conditions which are needed for dealing with quiescence of the empty trace. <p> We see work on this simple preorder as a stepping stone toward modeling the more elaborate ones. Indeed, as we mentioned in the Introduction, similar results to those obtained for the unfair preorder have been obtained also for the quiescent one <ref> [18] </ref>. 3 Process Algebras Overview The basic idea of Process Algebras [15, 10, 1] is the use of a few elementary processes and of some basic operators corresponding to primitive operations such as sequentialization, parallelism, nondeterminism and synchronization to describe concurrent processes. <p> In this paper we only give a rule for expressions in prefix normal form. The interested reader is referred to <ref> [18] </ref> for other rules. <p> Its new form is e ' ET ( a2out (S 0 )[in (S) X a : e a ): Finally the completeness rule needs an additional condition as follows: Quiet (e) implies 9jj Quiet (f j ): The complete axiomatization of the quiescent preorder is given in <ref> [18] </ref>. This section just gives an idea of how the axioms should be structured. <p> A formal understanding of the notion of implementation would avoid the above problem. Some of the topics mentioned above are addressed in <ref> [18, 19] </ref> and will be the subject of a forthcoming paper; others are just proposals needing further investigations. Acknowledgments: The paper started as [17] and is a simplification of chapters 3 and 4 of [18]; it owes its existence to [21]. <p> Some of the topics mentioned above are addressed in [18, 19] and will be the subject of a forthcoming paper; others are just proposals needing further investigations. Acknowledgments: The paper started as [17] and is a simplification of chapters 3 and 4 of <ref> [18] </ref>; it owes its existence to [21]. Many thanks to Frits Vaandrager for suggesting the pursued lines of investigation. We would also like to thank Nancy Lynch and Albert Meyer for helpful comments and criticisms on draft copies.
Reference: [19] <author> R. Segala. </author> <title> Quiescence, fairness, testing and the notion of implementation. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings CONCUR 93, Hildesheim, Germany, volume 715 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: A formal understanding of the notion of implementation would avoid the above problem. Some of the topics mentioned above are addressed in <ref> [18, 19] </ref> and will be the subject of a forthcoming paper; others are just proposals needing further investigations. Acknowledgments: The paper started as [17] and is a simplification of chapters 3 and 4 of [18]; it owes its existence to [21].
Reference: [20] <author> E.W. Stark. </author> <title> Foundations of a theory of specification for Distributed Systems. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <month> August </month> <year> 1984. </year> <note> Available as Technical Report MIT/LCS/TR-342. </note>
Reference-contexts: 1 Introduction Input/Output Automata <ref> [14, 20, 11, 12] </ref> are a widely used and deeply investigated formalism for specifying and verifying concurrent systems. Unfortunately, they have never been equipped with an algebraic characterization, a formalization that has been fundamental for the success of theories like CSP, CCS and ACP [10, 15, 8, 1].
Reference: [21] <author> F.W. Vaandrager. </author> <title> On the relationship between process algebra and Input/Output automata. </title> <booktitle> In Proceedings of the Sixth Annual Symposium on Logic in Computer Science, </booktitle> <year> 1991. </year>
Reference-contexts: Demonic: Unexpected inputs are considered as catastrophic. A system, after any unexpected input, moves to a special state from which any behavior is possible. Thus, P = a:e, after any b-action different from a, moves to . The Angelic choice was made by Vaandrager in <ref> [21] </ref>; here, we study the impact of the Demonic approach. In our view, for P = a:e above, the prefixing operator specifies its behavior only for action a and says nothing about input actions different from it. <p> We feel that they should be useful also for behavioral relations that are more accurate than external trace preorder. Particularly important for our result is an operator representing internal choice. It does not fit Vaandrager's general format <ref> [21] </ref> and forces us to prove substitutivity of our preorder explicitly. In [18] another behavioral relation is studied: the quiescent preorder of [21]. The main idea behind this relation is that a quiescent trace is a trace which leads to states from which only input actions are enabled. <p> Particularly important for our result is an operator representing internal choice. It does not fit Vaandrager's general format <ref> [21] </ref> and forces us to prove substitutivity of our preorder explicitly. In [18] another behavioral relation is studied: the quiescent preorder of [21]. The main idea behind this relation is that a quiescent trace is a trace which leads to states from which only input actions are enabled. <p> The quiescent preorder is a close attempt to capture the fair preorder using only finite schedules. It was used by Vaandrager in <ref> [21] </ref> and is reminiscent of the maximal trace congruence used in [2]. In this paper, mainly for the sake of simplicity, we concentrate on the unfair preorder; it corresponds essentially to the language equivalence of classical automata and has been used also for comparing concurrent system [9]. <p> For each sort S and each pair of sets I; J in (S) an operator I + S J is defined which takes two arguments of sort S and yields an expression of sort S. This operator is essentially the sorted version of Vaandrager's choice operator <ref> [21] </ref>. <p> The fact that recursion is given through guarded expressions is crucial. 2 Theorem 4.5 (Substitutivity) External trace preorder and quiescent preorder are substitutive for DIOA. Proof. Since the internal choice operator does not fit Vaandrager's general format of <ref> [21] </ref>, the proof of substitutivity must be given explicitly by considering each DIOA operator. We show as an example the case of the external choice operator for the external trace preorder. <p> This would imply that a weaker variant of substitutivity has to be introduced that asks for preservation of equivalence within only those contexts in which both equivalent processes can be inserted. The problem of defining a calculus with multiple internal actions is completely addressed in [17] where Vaandrager's work <ref> [21] </ref> is extended to the many-sorted setting. <p> Some of the topics mentioned above are addressed in [18, 19] and will be the subject of a forthcoming paper; others are just proposals needing further investigations. Acknowledgments: The paper started as [17] and is a simplification of chapters 3 and 4 of [18]; it owes its existence to <ref> [21] </ref>. Many thanks to Frits Vaandrager for suggesting the pursued lines of investigation. We would also like to thank Nancy Lynch and Albert Meyer for helpful comments and criticisms on draft copies.
References-found: 21

