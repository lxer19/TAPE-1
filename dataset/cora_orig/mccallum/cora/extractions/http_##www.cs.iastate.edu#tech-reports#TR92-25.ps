URL: http://www.cs.iastate.edu/tech-reports/TR92-25.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Issues in the design and implementation of a real-time garbage collection architecture  
Author: TR - William Jon Schmidt 
Address: 226 Atanasoff Ames, IA 50011  
Affiliation: Iowa State University of Science and Technology Department of Computer Science  
Date: August 24, 1992  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. W. Appel. </author> <title> Garbage collection can be faster than stack allocation. </title> <booktitle> Information Processing Letters 25 (1987): </booktitle> <pages> 275-279. </pages>
Reference-contexts: These results validate the long-held consensus that copying collectors should exhibit superior performance in comparison with other well-known storage management schemes. In theory, the family of copying garbage collection algorithms is much more efficient than reference counting, explicit allocation and deallocation (malloc and free), and mark-and-sweep garbage collection <ref> [1, 26] </ref>. This is because the work performed by the garbage collector is proportional to the amount of live data at the time garbage collection takes place. This cost can be made arbitrarily small in relation to total storage throughput by increasing the sizes of to- and from-space appropriately.
Reference: [2] <author> H. G. Baker, Jr. </author> <title> List processing in real time on a serial computer. </title> <booktitle> Communications of the Association for Computer Machinery 21 (1978): </booktitle> <pages> 280-293. </pages>
Reference-contexts: Another multiprocessing algorithm was developed by Dijkstra, Lamport, and others [7, 8, 24, 25], but was reported by Baker <ref> [2] </ref> to be too inefficient for practical use, being designed primarily to support a proof that exactly those cells that are garbage are collected. <p> The first "successful" real-time garbage collection algorithm, providing upper bounds on both allocation latency and required storage (as a function of reachable storage), is the algorithm of Baker <ref> [2] </ref>. Baker's algorithm is based on the copying collection algorithm that was first introduced by Minsky [33]. The basic idea of the algorithm is to divide available memory into two large regions named to- and from-space respectively.
Reference: [3] <author> J. F. Bartlett. </author> <title> Mostly-copying garbage collection picks up generations and C++. </title> <type> Technical Report TN-12, </type> <institution> Digital Western Research Laboratory, </institution> <year> 1989. </year>
Reference-contexts: Optional implementation of garbage collection is still under consideration by the ANSI committee responsible for the C++ standard. A number of researchers have added various types of garbage collection facilities to C++; see for example <ref> [3, 6, 9, 13] </ref>. 48 Choices of target CPUs for this research were limited primarily by the availability of tools. There are very few processors for which both a GNU back-end and an architecture simulator are available in the public domain.
Reference: [4] <author> P. B. Cohen. </author> <title> An introduction to CMOS design styles. </title> <booktitle> VLSI Design (1984): </booktitle> <pages> 88-96. </pages>
Reference-contexts: However, there are a number of CMOS variations that combine low power, high speed, and low transistor counts at the expense of design complexity. Two of these are dynamic CMOS and domino CMOS <ref> [4, 23] </ref>. A typical n-input NMOS gate requires n + 1 transistors to implement, while the same CMOS gate requires 2n transistors. Dynamic and domino CMOS techniques [4, 23] are designed to achieve the low power consumption of CMOS and the low transistor counts of NMOS by using precharging and clocking <p> Two of these are dynamic CMOS and domino CMOS <ref> [4, 23] </ref>. A typical n-input NMOS gate requires n + 1 transistors to implement, while the same CMOS gate requires 2n transistors. Dynamic and domino CMOS techniques [4, 23] are designed to achieve the low power consumption of CMOS and the low transistor counts of NMOS by using precharging and clocking techniques. <p> However, any attempt to write to the slice object will be ignored by the hardware. 180 Table 7.1: Examples of slice declarations Declaration Meaning slice char x <ref> [4] </ref>; Declare x as an array of four pointers to slice objects of element type char slice int *y; Declare y as a pointer to a pointer to a slice object of element type int slice Frame& z; Declare z as a reference to a pointer to a slice object of
Reference: [5] <author> A. L. DeCegama. </author> <title> Parallel Processing Architectures and VLSI Hardware. </title> <publisher> Pren-tice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1989. </year>
Reference-contexts: For instance, consider the creation of an object that spans the boundary between two chip spaces. After the object is created, at least one of the chips must lower its ACK line to inform the client that the service has completed. Arbitration of acknowledgments is handled using wired logic <ref> [5] </ref>. All of the chips along one bus tie their ACK pins to a single common line, using open-collector (no-pullup) drivers. <p> any type, it is necessary for the compiler to detect all assignments not only to union members, but also to members of classes 57 struct ExStruct - float f; char c [10]; -; class ExClass - int i; double d; ExStruct es; -; union ExUnion - ExClass ec; int *arrptrint <ref> [5] </ref>; -; main () - ExUnion *euptr; ... euptr-&gt;ec.es.f = 31.75; ... and structs that are themselves contained in union members. Consider for example the program fragment in Figure 4.4. An idealized syntax tree for the lvalue in the assignment statement in this fragment is shown in Figure 4.5.
Reference: [6] <author> D. L. Detlefs. </author> <title> Concurrent garbage collection in C++. </title> <type> Technical Report CMU-CS-90-119, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: Optional implementation of garbage collection is still under consideration by the ANSI committee responsible for the C++ standard. A number of researchers have added various types of garbage collection facilities to C++; see for example <ref> [3, 6, 9, 13] </ref>. 48 Choices of target CPUs for this research were limited primarily by the availability of tools. There are very few processors for which both a GNU back-end and an architecture simulator are available in the public domain.
Reference: [7] <author> E. W. Dijkstra. </author> <title> After many a sobering experience, </title> <note> 1975. </note> <author> E. W. </author> <note> Dijkstra note EWD500. </note>
Reference-contexts: Another multiprocessing algorithm was developed by Dijkstra, Lamport, and others <ref> [7, 8, 24, 25] </ref>, but was reported by Baker [2] to be too inefficient for practical use, being designed primarily to support a proof that exactly those cells that are garbage are collected.
Reference: [8] <author> E. W. Dijkstra, L. Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. </author> <title> On-the-fly garbage collection: An exercise in cooperation, </title> <note> 1975. </note> <author> E. W. </author> <note> Dijkstra note EWD496. </note>
Reference-contexts: Another multiprocessing algorithm was developed by Dijkstra, Lamport, and others <ref> [7, 8, 24, 25] </ref>, but was reported by Baker [2] to be too inefficient for practical use, being designed primarily to support a proof that exactly those cells that are garbage are collected.
Reference: [9] <author> D. R. Edelson. </author> <title> Dynamic storage reclamation in C++. </title> <type> Technical Report UCSC-CRL-90-19, </type> <institution> Department of Computer and Information Sciences, University of California at Santa Cruz, </institution> <year> 1990. </year>
Reference-contexts: Optional implementation of garbage collection is still under consideration by the ANSI committee responsible for the C++ standard. A number of researchers have added various types of garbage collection facilities to C++; see for example <ref> [3, 6, 9, 13] </ref>. 48 Choices of target CPUs for this research were limited primarily by the availability of tools. There are very few processors for which both a GNU back-end and an architecture simulator are available in the public domain.
Reference: [10] <author> J. R. Ellis, K. Li, and A. W. Appel. </author> <title> Real-time concurrent collection on stock multiprocessors. </title> <booktitle> ACM SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <year> 1988, </year> <pages> 11-20. 194 </pages>
Reference-contexts: In comparison with stop-and-wait garbage collectors, the real-time garbage collectors discussed above generally perform very poorly. Users of the original implementation of Baker's real-time garbage collector found it to be so slow that they disabled it <ref> [10] </ref>. And Nilsen's real-time implementation of Icon runs two to three times slower than the traditional implementation, which uses mark-and-sweep garbage collection with compaction. <p> This conclusion is further corroborated by recent research described by Ellis, Li, and Appel in reference <ref> [10] </ref>. In this research, stock memory management hardware was used to reduce the software costs associated with each memory operation. <p> Certain write operations also require special handling. Whenever the application writes to memory reserved for copying, but not yet copied, the garbage collector redirects the write operation to the appropriate address within the uncopied object still residing in from-space. As mentioned above, the Ellis, Li, Appel garbage collector <ref> [10] </ref> requires approximately 100 msec to perform a flip, and 50 msec to read an unscanned object. This means that a hard real-time scheduler must assume that every object allocation and every read will require at least 100 msec or 50 msec, respectively, to complete. <p> This occurs not only upon the initial allocation of an object, but also whenever it is copied into to-space following a flip. Crossing maps were also used in the page-fault technique developed by Ellis, Li, and Appel <ref> [10] </ref>. Here the crossing map consists of a bitmap where each bit corresponds to a page of virtual memory in the heap address space. A bit is set if an object spans the beginning of the corresponding virtual memory page. <p> Since union members may be of any type, it is necessary for the compiler to detect all assignments not only to union members, but also to members of classes 57 struct ExStruct - float f; char c <ref> [10] </ref>; -; class ExClass - int i; double d; ExStruct es; -; union ExUnion - ExClass ec; int *arrptrint [5]; -; main () - ExUnion *euptr; ... euptr-&gt;ec.es.f = 31.75; ... and structs that are themselves contained in union members. Consider for example the program fragment in Figure 4.4.
Reference: [11] <author> M. A. Ellis and B. Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: A run-time library routine is used to generate PLDs for array objects of nonconstant size. class Baz; void foo (int bar) - Baz *bazptr = new Baz [bar+1]; ... Array objects require one other special consideration. Section 5.7 of the ANSI base C++ language definition <ref> [11] </ref> permits array pointer arithmetic to legally generate a pointer to "the first location beyond the high end of the array." Such arithmetic is common in loops operating on array objects. <p> When a library is specified on the dlxln command line, the linker searches that library for modules that contain any currently unresolved references. Dependencies between modules within a library are all resolved in one pass. The ANSI base C++ language definition <ref> [11] </ref> states that "initialization of nonlocal static objects in a translation unit is done before the first use of any function or object defined in that translation unit." For each computation unit, the GNU C++ compiler outputs a function containing code to initialize all such objects, together with a directive indicating
Reference: [12] <author> E. D. Fabricius. </author> <title> Introduction to VLSI Design. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: unit asserts the CLEARCAR and CLEAROHB signals, which immediately reset the contents of the CAR and OHB registers to zero. 3.4 Analysis 3.4.1 VLSI technologies Advances in VLSI technology have led to a bewildering variety of available design styles. (For an introduction to issues of VLSI design, see for example <ref> [12, 32, 56] </ref>.) Any analysis of chip areas and propagation delays must assume particular technology choices. NMOS is capable of high chip densities, but is subject to power consumption that is prohibitive for an application such as the OSM. <p> It is important, however, to consider the fanout from each gate, since a fanout of M causes approximately M times the delay of a fanout of 1 <ref> [12] </ref>. This analysis assumes that a gate with outdegree 1 experiences a propagation delay of ffi time units. This approach is admittedly crude, but is sufficiently informative for the present analysis. Clearly the critical paths in the OSM chip run through the access tree.
Reference: [13] <author> Andrew Ginter. </author> <title> Design alternatives for a cooperative garbage collector for the C++ programming language. </title> <type> Technical Report 91/417/01, </type> <institution> Department of Computer Science, University of Calgary, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: Optional implementation of garbage collection is still under consideration by the ANSI committee responsible for the C++ standard. A number of researchers have added various types of garbage collection facilities to C++; see for example <ref> [3, 6, 9, 13] </ref>. 48 Choices of target CPUs for this research were limited primarily by the availability of tools. There are very few processors for which both a GNU back-end and an architecture simulator are available in the public domain.
Reference: [14] <author> R. E. Griswold and M. T. Griswold. </author> <title> The Icon Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ. </address> <note> Second edition, </note> <year> 1990. </year>
Reference-contexts: As a first step in this direction, Nilsen [36] extended Baker's algorithm to the general problem of garbage collecting string data, as well as Lisp-like linked data structures, in real time. This algorithm is useful for many languages, such as Icon <ref> [14] </ref> and SNOBOL4 [15], that specifically support a string data type. Strings in such languages are often shared between numerous pointers, which may access different portions of a single string. During processing, it is often the case that only substrings of previously allocated string data remain accessible to user pointers. <p> The length field indicates how many contiguous bytes of slice region data are contained within the slice. Slices are useful in implementing the built-in string and stream data type of languages such as Icon <ref> [14] </ref> and Conicon [37, 38]. They are also useful in any context where a "fragmentable array" data abstraction is pertinent, for instance in editing of audio or video data. Once allocated, a slice object is considered to be read-only. <p> The arbiter supports seventeen mutator services and an additional twelve services for use by the collector. Five of the mutator services are unused by the C++ compiler described in this chapter. Four of these are unused because C++ does not provide slice objects, i.e., objects such as Icon <ref> [14] </ref> strings on which "internal" garbage collection can be performed. 1 The other service, TagRead, is of no use to the present implementation. The services used by the compiler are briefly described below, using C++-style declarations to indicate the arguments and return values of each service. <p> The slice objects discussed briefly in section 2.2 provide a convenient mechanism for implementing arrays of this nature. Slices as a part of a real-time garbage collection system have been studied [36, 38] in the context of the programming language Icon <ref> [14] </ref>. However, this work used only software methods, and consequently programs using this garbage collection scheme ran two to three times slower than the same programs using the original Icon run-time library. Thus it is of interest to know how slices perform using the hardware-assisted garbage collection algorithm.
Reference: [15] <author> R. E. Griswold, J. F. Poage, and I. P. Polonsky. </author> <title> The SNOBOL4 Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ. </address> <note> Second edition, </note> <year> 1971. </year>
Reference-contexts: As a first step in this direction, Nilsen [36] extended Baker's algorithm to the general problem of garbage collecting string data, as well as Lisp-like linked data structures, in real time. This algorithm is useful for many languages, such as Icon [14] and SNOBOL4 <ref> [15] </ref>, that specifically support a string data type. Strings in such languages are often shared between numerous pointers, which may access different portions of a single string. During processing, it is often the case that only substrings of previously allocated string data remain accessible to user pointers.
Reference: [16] <author> J. L. Hennessy and D. A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: Clearly the Return header address command is the one that limits the performance of the chip. The service time of 250 nsec is greater than the cycle time even for a one-megabit DRAM chip, and almost twice the cycle time of a four-megabit DRAM chip <ref> [16] </ref>. Since a 32K-object DRAM chip and a four-megabit DRAM chip are expected to be of the same generation, a Return header address request requires about two memory cycles to service. Other commands can be serviced within one memory cycle. <p> There are very few processors for which both a GNU back-end and an architecture simulator are available in the public domain. This project utilized the hypothetical DLX processor of Hennessy and Patterson <ref> [16] </ref>, which is intended to be representative of contemporary RISC processors. (The DLX instruction set is in fact a subset of that of the MIPS R3000 [21] family of processors.) A processor simulator [17] was also available in the public domain, and was modified in a straightforward fashion to also simulate <p> Additional information on the DLX processor 2 An alternate protocol is discussed in section 6.3.2. 3 In fact, the results presented in chapter 6 indicate that stack objects should be discarded, so the CopyPush service will also disappear. 53 and instruction set may be found in reference <ref> [16] </ref>. Because the algorithm employed by the garbage-collection module is exact rather than conservative, it is not safe 4 for raw data to be stored in a register designated as a tended descriptor. <p> In recent years it has been shown that selection of a varied workload is very important in obtaining unbiased performance figures (see, for example, the relevant discussion in reference <ref> [16] </ref>); hence the architectures have been simulated executing three very different programs on two contrasting input sets each. The workload is described in detail in section 5.3. 82 CPU speed was chosen as a factor because of the continually growing gap between CPU speeds and memory speeds.
Reference: [17] <author> L. B. Hostetler and B. Mirtich. </author> <title> DLXsim|A Simulator for DLX, 1990. User manual. Ordering information may be found in reference [16]. </title>
Reference-contexts: This project utilized the hypothetical DLX processor of Hennessy and Patterson [16], which is intended to be representative of contemporary RISC processors. (The DLX instruction set is in fact a subset of that of the MIPS R3000 [21] family of processors.) A processor simulator <ref> [17] </ref> was also available in the public domain, and was modified in a straightforward fashion to also simulate instruction and data caches, a memory bus, standard memory modules, and the garbage-collected memory module. <p> Kelvin Nilsen, emulates the overall machine architecture under study, including DLX processor, instruction and data caches, memory bus, standard memory module, and the proposed garbage-collected memory module. This simulator is based on the original DLX processor simulator <ref> [17] </ref>, but has been extensively rewritten in C++ to permit simulation of the interactions between the processor and the other architectural components. The simulator is organized in a modular fashion, with each major component in the system defined as a separate object.
Reference: [18] <author> Y. Ishikawa, H. Tokuda, and C. W. Mercer. </author> <title> Object-oriented real-time language design: constructs for timing constraints. </title> <booktitle> Conference on Object-Oriented Programming: Systems, Languages, and Applications/European Conference on Object-Oriented Programming, </booktitle> <month> October </month> <year> 1990, </year> <pages> 289-298, </pages> <address> Ottawa, Canada. </address> <publisher> ACM Press, </publisher> <address> New York. </address>
Reference-contexts: Additionally, C++ is a strongly typed language, which eases the task of providing the garbage collection module with the locations of heap pointers within allocated objects (although special consideration is required for unions). Other researchers <ref> [18] </ref> are investigating extensions to the C++ language to support real-time scheduling. Another strong point in favor of C++ is the existence of a high-quality, retar-getable compiler with source code available for modification.
Reference: [19] <author> R. Jain. </author> <title> The Art of Computer Systems Performance Analysis. </title> <publisher> John Wiley and Sons, Inc., </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: To the right of the trial data in each table is a calculation of the importance of each of the factors and their interactions. These effects are calculated using a standard nonlinear regression model; this discussion of the model summarizes that of Jain <ref> [19] </ref>. 2 For each factor f 2 fA; B; Cg, define a variable x f such that x f = i if factor f is set to level i. For each subset X fA; B; Cg, define q X to be the effect of the combined factors in X.
Reference: [20] <author> S. N. Kamin. </author> <title> Programming Languages: An Interpreter-Based Approach. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: The lisp program, written by Timothy Budd, is a C++ implementation of the basic Lisp interpreter provided as a companion to the programming languages textbook by Kamin <ref> [20] </ref>. The first input test case used with lisp begins by defining the relational database functions given in the textbook, and then uses these functions to create a database and make several queries to it.
Reference: [21] <author> G. Kane. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: This project utilized the hypothetical DLX processor of Hennessy and Patterson [16], which is intended to be representative of contemporary RISC processors. (The DLX instruction set is in fact a subset of that of the MIPS R3000 <ref> [21] </ref> family of processors.) A processor simulator [17] was also available in the public domain, and was modified in a straightforward fashion to also simulate instruction and data caches, a memory bus, standard memory modules, and the garbage-collected memory module. <p> Both architectures use a single hypothetical DLX processor as 79 the CPU. The DLX instruction set is a subset of the MIPS R3000 <ref> [21] </ref> family of processors. The DLX processor uses a five-stage integer pipeline and a scoreboarded floating-point architecture configured with one addition unit, one multiplication unit, and one division unit. Additional information about the DLX configuration may be gleaned from the configuration parameters listed in reference [44].
Reference: [22] <author> D. E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> volume 1. </volume> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1968. </year>
Reference-contexts: function call mechanisms; and (iv) measure the costs and benefits of "slice objects," which permit programmers to define fragmentable arrays in which unused elements are automatically reclaimed. 4 1.2 Previous work in this area The concept of garbage collection in real time dates back at least to 1968, when Knuth <ref> [22] </ref> credited Minsky with the solution to the following exercise: Show that it is possible to use a garbage collection method reliably in a "real time" application, e.g., when a computer is controlling some physical device, even when stringent upper bounds are placed on the maximum execution time required for each
Reference: [23] <author> R. H. Krambeck, C. M. Lee, and H. S. </author> <title> Law. High-speed compact circuits with CMOS. </title> <journal> IEEE Journal of Solid-State Circuits SC-17 (1982): </journal> <pages> 614-619. </pages>
Reference-contexts: However, there are a number of CMOS variations that combine low power, high speed, and low transistor counts at the expense of design complexity. Two of these are dynamic CMOS and domino CMOS <ref> [4, 23] </ref>. A typical n-input NMOS gate requires n + 1 transistors to implement, while the same CMOS gate requires 2n transistors. Dynamic and domino CMOS techniques [4, 23] are designed to achieve the low power consumption of CMOS and the low transistor counts of NMOS by using precharging and clocking <p> Two of these are dynamic CMOS and domino CMOS <ref> [4, 23] </ref>. A typical n-input NMOS gate requires n + 1 transistors to implement, while the same CMOS gate requires 2n transistors. Dynamic and domino CMOS techniques [4, 23] are designed to achieve the low power consumption of CMOS and the low transistor counts of NMOS by using precharging and clocking techniques.
Reference: [24] <author> L. Lamport. </author> <title> On-the-fly garbage collection: Once more with rigor. </title> <type> Technical Report CA-7508-1611, </type> <institution> Massachussetts Computer Associates, Wakefield, Mas-sachussetts, </institution> <year> 1975. </year> <month> 195 </month>
Reference-contexts: Another multiprocessing algorithm was developed by Dijkstra, Lamport, and others <ref> [7, 8, 24, 25] </ref>, but was reported by Baker [2] to be too inefficient for practical use, being designed primarily to support a proof that exactly those cells that are garbage are collected.
Reference: [25] <author> L. Lamport. </author> <title> Garbage collection with multiple processes: An exercise in parallelism. </title> <type> Technical Report CA-7602-2511, </type> <institution> Massachussetts Computer Associates, Wakefield, Massachussetts, </institution> <year> 1976. </year>
Reference-contexts: Another multiprocessing algorithm was developed by Dijkstra, Lamport, and others <ref> [7, 8, 24, 25] </ref>, but was reported by Baker [2] to be too inefficient for practical use, being designed primarily to support a proof that exactly those cells that are garbage are collected.
Reference: [26] <author> R. G. Larson. </author> <title> Minimizing garbage collection as a function of region size. </title> <journal> SIAM Journal on Computing 6 (1977): </journal> <pages> 663-667. </pages>
Reference-contexts: These results validate the long-held consensus that copying collectors should exhibit superior performance in comparison with other well-known storage management schemes. In theory, the family of copying garbage collection algorithms is much more efficient than reference counting, explicit allocation and deallocation (malloc and free), and mark-and-sweep garbage collection <ref> [1, 26] </ref>. This is because the work performed by the garbage collector is proportional to the amount of live data at the time garbage collection takes place. This cost can be made arbitrarily small in relation to total storage throughput by increasing the sizes of to- and from-space appropriately.
Reference: [27] <author> C. E. Leiserson. </author> <title> Area-Efficient VLSI Computation. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1982. </year>
Reference-contexts: Also, the logical structure depicted in Figure 3.3 should not be confused with a physical layout. The access tree would actually be implemented using a "hyper-H" layout such as the one presented by Leiserson <ref> [27] </ref>, in which each bit of the OHB (and the tree-register interface) would be located at some distance from its "neighbors." Control unit. Figure 3.4 shows the interface details of the control unit. The line labeled CREATEOBJ indicates to the tree-register interface that a new object is to be created. <p> A binary tree can be implemented in an area-efficient manner, particularly when the number of connections between nodes decreases as one approaches the leaves <ref> [27, 28] </ref>. The use of a hyper-H layout such as that described by Leiserson [27] also minimizes wire area and wire delays. This section analyzes the size of an object space that can be controlled by a single OSM chip. <p> A binary tree can be implemented in an area-efficient manner, particularly when the number of connections between nodes decreases as one approaches the leaves [27, 28]. The use of a hyper-H layout such as that described by Leiserson <ref> [27] </ref> also minimizes wire area and wire delays. This section analyzes the size of an object space that can be controlled by a single OSM chip.
Reference: [28] <author> C. E. Leiserson. </author> <title> Fat-trees|universal networks for hardware-efficient supercomputing. </title> <journal> IEEE Transactions on Computers 34 (1985): </journal> <pages> 892-901. </pages>
Reference-contexts: A binary tree can be implemented in an area-efficient manner, particularly when the number of connections between nodes decreases as one approaches the leaves <ref> [27, 28] </ref>. The use of a hyper-H layout such as that described by Leiserson [27] also minimizes wire area and wire delays. This section analyzes the size of an object space that can be controlled by a single OSM chip.
Reference: [29] <author> E. Lewis. </author> <title> The design and performance of 1.25 CMOS. </title> <booktitle> VLSI System Design (1987). </booktitle>
Reference-contexts: Section 3.4.2 argued for a particular buffering 6 Recall that 0.5 technology is assumed in this design. The value of ffi decreases proportionally to device size [42], but eventually wire delays dominate gate delays <ref> [29] </ref>. 39 scheme that required little circuitry; this scheme is not the most efficient possible for minimizing delays.
Reference: [30] <author> H. Lieberman and C. Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <booktitle> Communications of the ACM 26 (1983): </booktitle> <pages> 419-429. </pages>
Reference-contexts: Zorn [59] has obtained results showing that mark-and-sweep collectors need not be as comparatively inefficient as previously supposed, particularly when the effect of virtual memory paging on collector performance is observed. However, Wilson [58] has pointed out that modifying copying collectors to use generational scavenging techniques <ref> [30, 54] </ref> negates their poor paging performance. It appears that copying collectors still outperform mark-and-sweep collectors, but not by as much as had previously been supposed. Paging performance is not an issue for the garbage collection system described in this dissertation, since it uses "real" rather than virtual memory addressing. <p> It would seem that permanent "set-aside" memory would only be cost-beneficial if additional long-lived objects were allowed to gravitate there. Thus more measurable gains might be made by modifying the garbage collection algorithm to use generational scavenging <ref> [30, 54] </ref>. 4.1.5 The run-time library The compiler creates code to communicate with the garbage collector by generating calls to a small set of run-time library routines. There are separate routines for each of the collector services described in section 4.1.1, except for the TendDesc and TendingDone primitives.
Reference: [31] <author> D. M. Martin, </author> <type> Jr. </type> <institution> Iowa State University. </institution> <type> Personal communication. </type>
Reference: [32] <author> C. A. Mead and L. A. Conway. </author> <title> Introduction to VLSI Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1980. </year>
Reference-contexts: unit asserts the CLEARCAR and CLEAROHB signals, which immediately reset the contents of the CAR and OHB registers to zero. 3.4 Analysis 3.4.1 VLSI technologies Advances in VLSI technology have led to a bewildering variety of available design styles. (For an introduction to issues of VLSI design, see for example <ref> [12, 32, 56] </ref>.) Any analysis of chip areas and propagation delays must assume particular technology choices. NMOS is capable of high chip densities, but is subject to power consumption that is prohibitive for an application such as the OSM.
Reference: [33] <author> M. L. Minsky. </author> <title> A LISP garbage collection algorithm using serial secondary storage, </title> <month> October </month> <year> 1963. </year> <note> Memo 58, </note> <institution> Artificial Intelligence Laboratory, Massachussetts Institute of Technology, </institution> <address> Cambridge, MA. </address>
Reference-contexts: The first "successful" real-time garbage collection algorithm, providing upper bounds on both allocation latency and required storage (as a function of reachable storage), is the algorithm of Baker [2]. Baker's algorithm is based on the copying collection algorithm that was first introduced by Minsky <ref> [33] </ref>. The basic idea of the algorithm is to divide available memory into two large regions named to- and from-space respectively. Objects are allocated from to-space while previously allocated live objects are incrementally copied into to-space out of from-space.
Reference: [34] <author> Motorola, Inc. </author> <title> MC88200 Cache/Memory Management Unit User's Manual. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: In a real implementation, the mutator would be responsible for invalidating its cache, using methods such as those described in reference <ref> [34] </ref>. The issue of data coherence is treated in more detail in section 6.3.3, where a method employing a write-back cache is introduced. Both architectures employ a standard memory bus with 32-bit-wide address and data channels. <p> This signal, which exists in many standard multiprocessor cache-coherence protocols (see, for example, <ref> [34, 52] </ref>), causes the cache to flush its copy of a cache line to the bus and mark its copy Invalid. The memory arbiter can use this protocol to ensure data coherence, as follows. <p> After broadcasting an invalidate signal for the target address, it may perform the copy. Better performance can be achieved for CopyBlocks if the data cache supports mutator control over cache invalidations. (An example of a cache with this capability is described in reference <ref> [34] </ref>.) In this case the mutator can issue the CopyBlock request and then invalidate the target addresses before reading the GCStatus register to see if the CopyBlock has completed.
Reference: [35] <author> K. G. Muller. </author> <title> On the feasibility of concurrent garbage collection. </title> <type> PhD thesis, Tech. </type> <address> Hogeschool Delft, The Netherlands, </address> <year> 1976. </year>
Reference-contexts: The solution sketched by Knuth was extended to multiprocessing by Steele [49], and the feasibility of this method was analyzed by Muller <ref> [35] </ref> and Wadler [55]. The algorithm described is a mark-and-sweep compacting collector, requiring three passes over heap storage for each collection.
Reference: [36] <author> K. Nilsen. </author> <title> Garbage collection of strings and linked data structures in real time. </title> <booktitle> Software|Practice and Experience 18 (1988): </booktitle> <pages> 613-640. </pages>
Reference-contexts: Baker also sketched how his system could be extended to allocate and collect vectors of raw (i.e., non-pointer) data, using methods he attributes to Steele [50]. However, Baker's algorithm was not yet sufficiently well-developed to be used for type-complete garbage collection. As a first step in this direction, Nilsen <ref> [36] </ref> extended Baker's algorithm to the general problem of garbage collecting string data, as well as Lisp-like linked data structures, in real time. This algorithm is useful for many languages, such as Icon [14] and SNOBOL4 [15], that specifically support a string data type. <p> Kelvin Nilsen. This project is an outgrowth of Professor Nilsen's doctoral investigations into real-time garbage collection of Icon strings and linked data structures <ref> [36] </ref>, described in section 1.2 above. The goal of this effort is to produce a garbage-collection architecture suitable for use in any real-time system, including those with very strict latency requirements, and capable of supporting any modern programming language. A number of students have been involved in this project. <p> Or a stream might embody sample data from chemical processes gathered periodically in real time. The slice objects discussed briefly in section 2.2 provide a convenient mechanism for implementing arrays of this nature. Slices as a part of a real-time garbage collection system have been studied <ref> [36, 38] </ref> in the context of the programming language Icon [14]. However, this work used only software methods, and consequently programs using this garbage collection scheme ran two to three times slower than the same programs using the original Icon run-time library.
Reference: [37] <author> K. Nilsen. </author> <title> High-level goal-directed concurrent processing in Icon. </title> <booktitle> Software| Practice and Experience 20 (1990): </booktitle> <pages> 1273-1290. </pages>
Reference-contexts: The length field indicates how many contiguous bytes of slice region data are contained within the slice. Slices are useful in implementing the built-in string and stream data type of languages such as Icon [14] and Conicon <ref> [37, 38] </ref>. They are also useful in any context where a "fragmentable array" data abstraction is pertinent, for instance in editing of audio or video data. Once allocated, a slice object is considered to be read-only. Only the slice region data referenced by the slice object is writable.
Reference: [38] <author> K. Nilsen. </author> <title> A stream data type that supports goal-directed pattern matching on unbounded sequences of values. </title> <booktitle> Journal of Computer Languages 15 (1990): </booktitle> <pages> 41-54. 196 </pages>
Reference-contexts: The length field indicates how many contiguous bytes of slice region data are contained within the slice. Slices are useful in implementing the built-in string and stream data type of languages such as Icon [14] and Conicon <ref> [37, 38] </ref>. They are also useful in any context where a "fragmentable array" data abstraction is pertinent, for instance in editing of audio or video data. Once allocated, a slice object is considered to be read-only. Only the slice region data referenced by the slice object is writable. <p> Or a stream might embody sample data from chemical processes gathered periodically in real time. The slice objects discussed briefly in section 2.2 provide a convenient mechanism for implementing arrays of this nature. Slices as a part of a real-time garbage collection system have been studied <ref> [36, 38] </ref> in the context of the programming language Icon [14]. However, this work used only software methods, and consequently programs using this garbage collection scheme ran two to three times slower than the same programs using the original Icon run-time library.
Reference: [39] <author> K. Nilsen and W. J. Schmidt. </author> <title> Cost-effective object-space management for hardware-assisted real-time garbage collection. </title> <journal> ACM Letters on Programming Languages and Systems. </journal> <note> Accepted pending revision. </note>
Reference-contexts: The overall architecture is discussed briefly in chapter 2, and at length in references [40, 41]. One design for the object space manager, a critical component of the hardware architecture, is described in chapter 3 of this dissertation. A more cost-effective alternative is outlined in reference <ref> [39] </ref>. Software support for the garbage-collection architecture includes a C++ compiler, linker, librarian, and simulator. The design and implementation of these tools is discussed in chapter 4. Using these tools, a number of experiments have been carried out to determine the efficacy of the proposed garbage-collection architecture. <p> Singh [45] designed an early prototype of the memory arbiter, another important component of the garbage-collection architecture described in section 2.3. These efforts contributed to a better understanding of pertinent design issues. Building upon this work, Nilsen and Schmidt <ref> [39, 40, 41] </ref> have designed a combination of hardware and software to address the problem of real-time garbage collection. The remainder of this chapter contains a brief overview of the garbage-collection algorithm and supporting hardware. <p> Hardwiring of arbiter services permits the worst-case time required to interrupt all background garbage-collection activities to be kept within approximately one memory cycle. 16 2.3.2 Motivation for the object-space manager The object space manager described in chapter 3 and reference <ref> [39] </ref> is needed to find the header information associated with objects. This header must be found and read in the following situations: 1. Each dynamically allocated object must make its internal organization available to the garbage collector so that raw data bits can be distinguished from pointers to other objects. <p> Had the crude analysis produced more positive results, it would have been important to validate those results with a more careful analysis of wire costs. Instead, it appears that efforts will be better spent in pursuing alternative designs, such as the one described in reference <ref> [39] </ref>. 3.4.4 Propagation delays There are many factors that influence the amount of delay through an inverter that are beyond the scope of this analysis. <p> Recently, these lessons have been applied in a preliminary redesign of the OSM that uses existing DRAM technology to greatly reduce the amount of custom circuitry. 46 An overview of the new design appears in reference <ref> [39] </ref>. The results from this latest effort are very encouraging, and demonstrate that the OSM chip can be manufactured at a reasonable cost. 47 4. A PROTOTYPE COMPILER IMPLEMENTATION The remainder of this dissertation focuses on empirical evidence collected to determine the efficacy of the proposed hardware.
Reference: [40] <author> K. Nilsen and W. J. Schmidt. </author> <title> Hardware-assisted general-purpose garbage collection for hard real-time systems. </title> <type> Technical Report 92-15, </type> <institution> Department of Computer Science, Iowa State University, </institution> <year> 1992. </year>
Reference-contexts: The purpose of the research described in this dissertation is to investigate the practicality of providing such "type-complete" garbage collection for use in real-time systems. The basis for this work is the recently-developed algorithm and architecture described in references <ref> [40, 41] </ref> and briefly discussed in chapter 2. The garbage-collection algorithm described in this reference is the first to sufficiently address requirement 3, above, within the context of real-time systems. <p> The following avenues of inquiry are of primary interest: 1. Algorithms must be developed that support garbage collection for objects of any possible type in a type-extensible language. 2. Performance must be significantly enhanced. Recent progress <ref> [40, 48] </ref> has been made towards a solution to item 1. The algorithm described in chapter 2 of this dissertation, and explained in more detail in reference [40], supports objects of any size and type, provided that the locations of all pointers are made known to the collector. <p> Performance must be significantly enhanced. Recent progress [40, 48] has been made towards a solution to item 1. The algorithm described in chapter 2 of this dissertation, and explained in more detail in reference <ref> [40] </ref>, supports objects of any size and type, provided that the locations of all pointers are made known to the collector. To address item 2, a new garbage-collected memory architecture has been proposed. The overall architecture is discussed briefly in chapter 2, and at length in references [40, 41]. <p> To address item 2, a new garbage-collected memory architecture has been proposed. The overall architecture is discussed briefly in chapter 2, and at length in references <ref> [40, 41] </ref>. One design for the object space manager, a critical component of the hardware architecture, is described in chapter 3 of this dissertation. A more cost-effective alternative is outlined in reference [39]. Software support for the garbage-collection architecture includes a C++ compiler, linker, librarian, and simulator. <p> Singh [45] designed an early prototype of the memory arbiter, another important component of the garbage-collection architecture described in section 2.3. These efforts contributed to a better understanding of pertinent design issues. Building upon this work, Nilsen and Schmidt <ref> [39, 40, 41] </ref> have designed a combination of hardware and software to address the problem of real-time garbage collection. The remainder of this chapter contains a brief overview of the garbage-collection algorithm and supporting hardware. <p> This assures programmers of safety-critical real-time applications that their programs are not vulnerable to failure due to lack of memory for new allocations. A thorough description of the algorithm and its analysis is provided in reference <ref> [40] </ref>. Recall that new objects are allocated from to-space while old objects are copied from from-space into to-space, with a flip (exchange of spaces) occurring when to-space has been exhausted. The application program is allowed to maintain only a limited number of pointers (called descriptors) to dynamically allocated objects. <p> Whenever the application attempts to read memory that has been copied but not yet scanned, the garbage collector must 2 The architecture simulator used for the experiments reported in this dissertation actually scans most objects while they are being copied. Scanning of slice data regions (see reference <ref> [40] </ref>) is delayed until copying is completed. To-Space: Newly allocated data new Objects not yet copied reserved Objects both copied and scanned Objects copied but not yet scanned relocated scanned 11 scan the requested data before making it available to the reading process. <p> Rather than interrupt the CPU to handle these requests, the CPU is stalled using traditional bus wait states. The maximum delay for a particular memory operation is approximately six traditional memory cycles (see references <ref> [40, 41] </ref> for details). Within the garbage-collection module, three distinct threads of control run concurrently. Two of the threads run on the arbiter, and the third is executed by the garbage-collection microprocessor. The division of labor between the arbiter and the garbage-collection microprocessor represents tradeoffs between cost and performance. <p> The OSM provides a mapping mechanism between raw addresses and objects. This section concentrates on the description and analysis of the OSM design; other components of the garbage collection architecture are described in <ref> [40, 41, 45] </ref> and in chapter 2 of this dissertation. The following goals were set forth for design of the OSM: * The chip should support a small, but general, set of commands for object manipulation.
Reference: [41] <author> K. Nilsen and W. J. Schmidt. </author> <title> Preferred embodiment of a hardware-assisted garbage-collecting memory module. </title> <type> Technical Report 92-17, </type> <institution> Department of Computer Science, Iowa State University, </institution> <year> 1992. </year>
Reference-contexts: The purpose of the research described in this dissertation is to investigate the practicality of providing such "type-complete" garbage collection for use in real-time systems. The basis for this work is the recently-developed algorithm and architecture described in references <ref> [40, 41] </ref> and briefly discussed in chapter 2. The garbage-collection algorithm described in this reference is the first to sufficiently address requirement 3, above, within the context of real-time systems. <p> To address item 2, a new garbage-collected memory architecture has been proposed. The overall architecture is discussed briefly in chapter 2, and at length in references <ref> [40, 41] </ref>. One design for the object space manager, a critical component of the hardware architecture, is described in chapter 3 of this dissertation. A more cost-effective alternative is outlined in reference [39]. Software support for the garbage-collection architecture includes a C++ compiler, linker, librarian, and simulator. <p> Singh [45] designed an early prototype of the memory arbiter, another important component of the garbage-collection architecture described in section 2.3. These efforts contributed to a better understanding of pertinent design issues. Building upon this work, Nilsen and Schmidt <ref> [39, 40, 41] </ref> have designed a combination of hardware and software to address the problem of real-time garbage collection. The remainder of this chapter contains a brief overview of the garbage-collection algorithm and supporting hardware. <p> Rather than interrupt the CPU to handle these requests, the CPU is stalled using traditional bus wait states. The maximum delay for a particular memory operation is approximately six traditional memory cycles (see references <ref> [40, 41] </ref> for details). Within the garbage-collection module, three distinct threads of control run concurrently. Two of the threads run on the arbiter, and the third is executed by the garbage-collection microprocessor. The division of labor between the arbiter and the garbage-collection microprocessor represents tradeoffs between cost and performance. <p> The OSM provides a mapping mechanism between raw addresses and objects. This section concentrates on the description and analysis of the OSM design; other components of the garbage collection architecture are described in <ref> [40, 41, 45] </ref> and in chapter 2 of this dissertation. The following goals were set forth for design of the OSM: * The chip should support a small, but general, set of commands for object manipulation.
Reference: [42] <author> D. A. Pucknell and K. Eshragian. </author> <title> Basic VLSI Design: Systems and Circuits. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: This is due to special custom processes that are only cost-effective for chips produced in large volume. The OSM chip must be produced with a smaller device size to equal the density of a DRAM. The present analysis assumes availability of 0.5 technology, which will soon be standard <ref> [42] </ref>. 33 Table 3.1: Transistor cost parameters Parameter Circuit element N invert inverter N gate two-input gate N FF D flip-flop with clear N node (k) node of the access tree at level k N slice slice of the tree-register interface N buff buffering of signals to tree-register interface N tree <p> The delay through the HDR critical path depends somewhat on how the buffering of the CLMHDR signal is arranged. Section 3.4.2 argued for a particular buffering 6 Recall that 0.5 technology is assumed in this design. The value of ffi decreases proportionally to device size <ref> [42] </ref>, but eventually wire delays dominate gate delays [29]. 39 scheme that required little circuitry; this scheme is not the most efficient possible for minimizing delays.
Reference: [43] <author> W. J. Schmidt and K. Nilsen. </author> <title> Architectural support for garbage-collected memory in hard real-time systems. </title> <type> Technical Report 91-23, </type> <institution> Department of Computer Science, Iowa State University, </institution> <year> 1991. </year>
Reference: [44] <author> W. J. Schmidt and K. Nilsen. </author> <title> Experimental measurements of a real-time garbage collection architecture. </title> <type> Technical Report 92-26, </type> <institution> Department of Computer Science, Iowa State University, </institution> <year> 1992. </year>
Reference-contexts: Examples of the simulator's statistical output may be found in the raw experimental data collected in reference <ref> [44] </ref>. Following is a short description of the meaning of each reported statistic. <p> The DLX processor uses a five-stage integer pipeline and a scoreboarded floating-point architecture configured with one addition unit, one multiplication unit, and one division unit. Additional information about the DLX configuration may be gleaned from the configuration parameters listed in reference <ref> [44] </ref>. Both processors are configured with on-chip instruction and data caches. Each cache is a 32-kilobyte, two-way associative cache with a line size of one word. The data cache employs a write-through policy to provide a coherent view of memory with the garbage collection architecture. <p> For the garbage-collection architecture only, a garbage-collected memory module, also employing static-column DRAM, is included as well. Configurable parameters of the garbage-collected memory module are not discussed here, but are available in reference <ref> [44] </ref> for the interested reader. The programs executed on each simulated architecture were compiled with the GNU C++ compiler, version 1.37.1, as targeted to the DLX CPU by graduate students at Stanford University and the University of California at Berkeley. <p> The DFT of the last n samples is printed every one thousand iterations. Two sample input files, containing 512 and 2048 samples of raw data, respectively, were used as input test cases. Octal dumps of the input files are listed in reference <ref> [44] </ref>. The sfft program was chosen because it represents a typical real-time task, because it exercises the floating-point units more thoroughly than the other programs, and because it does not make use of dynamically allocated memory, in contrast to the other programs. <p> The other test case implements the alpha-beta pruning method of searching minimax game trees, and tests it on two large multiway trees. These test cases are also included in reference <ref> [44] </ref>. The lisp program is an example of a task having small code size, high instruction and data locality, small average function size (and hence a high rate of function call invocation), and heavy utilization of dynamic memory allocation. <p> This section contains a series of tables analyzing the empirical results of different measured statistics. (The unedited empirical results may be found in reference <ref> [44] </ref>.) For brevity, each of the three non-workload factors has been represented by a letter, as follows: Level 1 Level -1 Factor Description Factor Description A Garbage-collected architecture A Traditional architecture B Large GC memory B Small GC memory C Fast mutator CPU C Slow mutator CPU Each of these factors <p> To do this, the value of n used in the definition of I push and I pop must be estimated. In order to be conservative, the smallest latencies for the StackPush and StackPop operations have been taken from the raw data for these test cases in reference <ref> [44] </ref>. These latencies (in CPU cycles) were then divided by the cycles per instruction (CPI) for these test cases, calculated from the statistics in this section and in section 5.4.1 and shown in the table below. <p> The statistic measures the total number of cycles over all test cases that are wasted because the mutator does not claim the results from the arbiter exactly when they become ready. In the raw data in reference <ref> [44] </ref>, an average cost and an average latency figure are given for each arbiter operation. <p> Again this is not startling; the code generated by the different compilers is identical for floating-point arithmetic. In addition to the analysis presented here, more information can be gathered from the raw data in reference <ref> [44] </ref>. <p> Section 5.5.1 investigates reducing the amount of cache invalidation required by the garbage collector, and section 5.5.2 more closely analyzes the effect of the size of garbage-collected memory on performance. The raw test results from these experiments are contained in reference <ref> [44] </ref>. 5.5.1 Partial cache invalidation It is shown in section 5.4.11 that cache invalidation requests represent a significant component of the total bus utilization. <p> The simulator was exercised on this test case in five sizes of memory ranging from 256 KB up to 4 MB. The raw test results for these experiments may be found in reference <ref> [44] </ref>. It should be noted that the lisp program executed here was produced with a different version of the compiler than was used for the experiments in section 5.4. <p> The following results are extracted from the raw data in reference <ref> [44] </ref>. Total AllocInitRec latencies 1,952,775 cycles Number of AllocInitRecs 46,656 Average AllocInitRec latency 41.85 cycles Average instructions per AllocInitRec 15.82 The average number of instructions listed above is computed by dividing the average latency by the average CPI for lisp of 2.645 (see Table 6.3). <p> Using the SU data from reference <ref> [44] </ref>: Total AllocRec latencies 20,529 cycles Number of AllocRecs 1077 Average AllocRec latency 19.06 cycles Average instructions per AllocRec 7.206 Total InitBlock latencies 27,532 cycles Number of InitBlocks 1165 Average InitBlock latency 23.63 cycles Average instructions per InitBlock 8.934 This gives m = d7:206=8e = 1 and n = d8:934=4e = <p> However, the suspicious reader may verify that increasing the values of m, n, and I has a minimal impact on the results of this analysis. 168 to the ratio of AllocInitRec operations to AllocRec operations taken from the HU data in reference <ref> [44] </ref>. 6 This gives Number of AllocInitRecs = 7; 108; 255 Number of AllocRecs = 175; 431 p small = 0:9759 Thus HC = [9p hit + (1 p hit )(104 65 (0:9759))](7; 426; 251) = (40:57 31:57p hit )(7; 426; 251) Unfortunately, there is no empirical evidence on which to <p> Using the data in reference <ref> [44] </ref>, the percent of SU's arbiter operation latencies due to stack manipulations can be calculated: Total latencies for StackPush/Pop (cycles) 591,601,686 Total latencies for arbiter operations (cycles) 593,603,989 Percent attributable to stack operations 99.66% The number of instructions of function call overhead can then be calculated as follows: Total instructions executed, <p> For comparative purposes, the slice version was run in three different sizes of garbage-collected memory. The empirical data collected from these experiments appears in reference <ref> [44] </ref>, and is summarized in Tables 7.4 and 7.5. Table 7.4 compares the two editors constructed using the public-domain libraries 187 with the version compiled using slices.
Reference: [45] <author> T. P. Singh. </author> <title> Hardware design of a real-time copying garbage collection system. </title> <type> Master's thesis, </type> <institution> Iowa State University, </institution> <year> 1990. </year>
Reference-contexts: A number of students have been involved in this project. Stapleton [48] made the first attempt to extend the Baker/Nilsen garbage-collection algorithm to include descriptor slice objects, 1 and was the first to discover the need for the object space manager investigated in chapter 3 below. Singh <ref> [45] </ref> designed an early prototype of the memory arbiter, another important component of the garbage-collection architecture described in section 2.3. These efforts contributed to a better understanding of pertinent design issues. <p> The memory arbiter (a preliminary version of which has been described in reference <ref> [45] </ref>) snoops on the internal bus and intercepts requests that require additional processing because of ongoing garbage collection activity. If necessary, the BIU provides handshaking signals to stall the CPU until intercepted requests have completed. <p> The OSM provides a mapping mechanism between raw addresses and objects. This section concentrates on the description and analysis of the OSM design; other components of the garbage collection architecture are described in <ref> [40, 41, 45] </ref> and in chapter 2 of this dissertation. The following goals were set forth for design of the OSM: * The chip should support a small, but general, set of commands for object manipulation.
Reference: [46] <author> R. M. Stallman. </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <note> 1990. Version 1.37.1. Available by anonymous ftp from prep.ai.mit.edu. </note>
Reference-contexts: Our compiler is based on version 1.37.1 of the GNU C++ compiler, developed and distributed by the Free Software Foundation <ref> [46, 53] </ref>. There are a number of reasons for selecting C++ as the source language for our experiments. Chief among these is that C++ provides both implementation efficiency and an object-oriented, type-safe programming paradigm.
Reference: [47] <author> J. A. Stankovic. </author> <title> Real-time computing systems: The next generation. </title> <editor> In J. A. Stankovic and K. Ramamritham, editors, </editor> <booktitle> Tutorial: Hard Real-Time Systems, </booktitle> <pages> 14-37. </pages> <publisher> Computer Society Press of the IEEE, </publisher> <year> 1988. </year>
Reference-contexts: As greater demands are placed upon future real-time systems, however, it will no longer be possible to rely upon ad hoc techniques, nor will it be possible to settle for low performance. Stankovic <ref> [47] </ref> has given the following characterization of these "next-generation" real-time systems: The next-generation real-time systems will be in similar application areas as current systems, but will be more complex in that they will be distributed, contain highly dynamic and adaptive behavior, exhibit intelligent behavior, have long lifetimes, and be characterized as <p> There are a number of reasons for selecting C++ as the source language for our experiments. Chief among these is that C++ provides both implementation efficiency and an object-oriented, type-safe programming paradigm. These two features will be necessary for the next generation of real-time systems <ref> [47] </ref>, which will require adequate tools for construction of large, complex, and dynamic systems that execute efficiently. Additionally, C++ is a strongly typed language, which eases the task of providing the garbage collection module with the locations of heap pointers within allocated objects (although special consideration is required for unions).
Reference: [48] <author> S. M. Stapleton. </author> <title> Real-time garbage collection for general-purpose languages. </title> <type> Master's thesis, </type> <institution> Iowa State University, </institution> <year> 1990. </year>
Reference-contexts: The following avenues of inquiry are of primary interest: 1. Algorithms must be developed that support garbage collection for objects of any possible type in a type-extensible language. 2. Performance must be significantly enhanced. Recent progress <ref> [40, 48] </ref> has been made towards a solution to item 1. The algorithm described in chapter 2 of this dissertation, and explained in more detail in reference [40], supports objects of any size and type, provided that the locations of all pointers are made known to the collector. <p> The goal of this effort is to produce a garbage-collection architecture suitable for use in any real-time system, including those with very strict latency requirements, and capable of supporting any modern programming language. A number of students have been involved in this project. Stapleton <ref> [48] </ref> made the first attempt to extend the Baker/Nilsen garbage-collection algorithm to include descriptor slice objects, 1 and was the first to discover the need for the object space manager investigated in chapter 3 below. <p> Either the time required to locate a header, or the time to install a new header into the data base, is proportional to the size of the objects involved. Stapleton <ref> [48] </ref> solved the header lookup problem by using small software "crossing maps," precursors of the OHB and CAR registers described in section 3.3. Stapleton's crossing map consists of two words for every 32 words of garbage-collected memory.
Reference: [49] <author> G. L. Steele, Jr. </author> <title> Multiprocessing compactifying garbage collection. </title> <booktitle> Communications of the ACM 18 (1975): </booktitle> <pages> 495-508. </pages>
Reference-contexts: The solution sketched by Knuth was extended to multiprocessing by Steele <ref> [49] </ref>, and the feasibility of this method was analyzed by Muller [35] and Wadler [55]. The algorithm described is a mark-and-sweep compacting collector, requiring three passes over heap storage for each collection.
Reference: [50] <author> G. L. Steele, Jr. </author> <title> Private communication to H. </title> <editor> G. Baker, Jr., </editor> <month> March </month> <year> 1977. </year>
Reference-contexts: These are, conveniently, all the same size, making it easy to copy objects atomically and guarantee tight upper bounds on performance. Baker also sketched how his system could be extended to allocate and collect vectors of raw (i.e., non-pointer) data, using methods he attributes to Steele <ref> [50] </ref>. However, Baker's algorithm was not yet sufficiently well-developed to be used for type-complete garbage collection. As a first step in this direction, Nilsen [36] extended Baker's algorithm to the general problem of garbage collecting string data, as well as Lisp-like linked data structures, in real time.
Reference: [51] <author> H. Taub and D. Schilling. </author> <title> Digital Integrated Electronics. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1977. </year> <month> 197 </month>
Reference-contexts: The DRAM chip can be implemented using just over 3M = 3 2 20 transistors (see Taub and Schilling <ref> [51] </ref> for details), plus additional routing area. Although the DRAM and the OSM both benefit from very regular layouts, the hyper-H tree layout of the OSM cannot use area quite as efficiently as the grid arrangement of a DRAM.
Reference: [52] <author> S. S. Thakkar. </author> <title> Performance of Symmetry multiprocessor system. </title> <editor> In M. Dubois and S. S. Thakkar, editors, </editor> <title> Cache and Interconnect Architectures in Multiprocessors, </title> <address> 53-82. </address> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1990. </year>
Reference-contexts: This signal, which exists in many standard multiprocessor cache-coherence protocols (see, for example, <ref> [34, 52] </ref>), causes the cache to flush its copy of a cache line to the bus and mark its copy Invalid. The memory arbiter can use this protocol to ensure data coherence, as follows.
Reference: [53] <author> M. D. Tiemann. </author> <title> User's Guide to GNU C++. Free Software Foundation, </title> <note> 1990. Version 1.37.1. Available by anonymous ftp from prep.ai.mit.edu. </note>
Reference-contexts: Our compiler is based on version 1.37.1 of the GNU C++ compiler, developed and distributed by the Free Software Foundation <ref> [46, 53] </ref>. There are a number of reasons for selecting C++ as the source language for our experiments. Chief among these is that C++ provides both implementation efficiency and an object-oriented, type-safe programming paradigm.
Reference: [54] <author> D. M. Ungar. </author> <title> Generation scavenging: A non-disruptive high-performance storage reclamation algorithm. </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <year> 1984, </year> <pages> 157-167. </pages> <note> Also distributed as ACM SIGPLAN Notices 19(5): 157-167, </note> <month> May, </month> <year> 1987. </year>
Reference-contexts: Zorn [59] has obtained results showing that mark-and-sweep collectors need not be as comparatively inefficient as previously supposed, particularly when the effect of virtual memory paging on collector performance is observed. However, Wilson [58] has pointed out that modifying copying collectors to use generational scavenging techniques <ref> [30, 54] </ref> negates their poor paging performance. It appears that copying collectors still outperform mark-and-sweep collectors, but not by as much as had previously been supposed. Paging performance is not an issue for the garbage collection system described in this dissertation, since it uses "real" rather than virtual memory addressing. <p> It would seem that permanent "set-aside" memory would only be cost-beneficial if additional long-lived objects were allowed to gravitate there. Thus more measurable gains might be made by modifying the garbage collection algorithm to use generational scavenging <ref> [30, 54] </ref>. 4.1.5 The run-time library The compiler creates code to communicate with the garbage collector by generating calls to a small set of run-time library routines. There are separate routines for each of the collector services described in section 4.1.1, except for the TendDesc and TendingDone primitives.
Reference: [55] <author> P. L. Wadler. </author> <title> Analysis of an algorithm for real-time garbage collection. </title> <booktitle> Communications of the ACM 19 (1976): </booktitle> <pages> 491-500. </pages>
Reference-contexts: The solution sketched by Knuth was extended to multiprocessing by Steele [49], and the feasibility of this method was analyzed by Muller [35] and Wadler <ref> [55] </ref>. The algorithm described is a mark-and-sweep compacting collector, requiring three passes over heap storage for each collection.
Reference: [56] <author> N. Weste and K. Eshraghian. </author> <title> Principles of CMOS VLSI Design: A Systems Perspective. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1985. </year>
Reference-contexts: unit asserts the CLEARCAR and CLEAROHB signals, which immediately reset the contents of the CAR and OHB registers to zero. 3.4 Analysis 3.4.1 VLSI technologies Advances in VLSI technology have led to a bewildering variety of available design styles. (For an introduction to issues of VLSI design, see for example <ref> [12, 32, 56] </ref>.) Any analysis of chip areas and propagation delays must assume particular technology choices. NMOS is capable of high chip densities, but is subject to power consumption that is prohibitive for an application such as the OSM. <p> To support 64K objects would require twice this amount; for a given technology, this would necessitate a much larger die size and would considerably reduce yields. We therefore conclude that a 32K-object OSM is the largest 5 For example, consider minor modifications to Figure 5.51 (a) of reference <ref> [56] </ref>. 36 that can be economically implemented using the same device density as a one-megabit DRAM. The amount of memory spanned by a single OSM chip depends on how the chip is used.
Reference: [57] <author> J. L. White. </author> <type> Usenet communication, </type> <month> November 18, </month> <year> 1990. </year>
Reference-contexts: Machine dependency is economically undesirable, since the development costs of vendor-specific hardware cannot be shared as widely. One variation on base-offset addressing is a technique sometimes called "Red/Pink register pairs" <ref> [57] </ref>, used originally in PDP10 MacLisp. In this approach, derived pointers are supported by using a "Red" register to store the base of the object and a "Pink" register to hold the derived pointer.
Reference: [58] <author> P. R. Wilson. </author> <title> Caching considerations for generational garbage collection. </title> <booktitle> Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1992, </year> <pages> 32-42. </pages>
Reference-contexts: Zorn [59] has obtained results showing that mark-and-sweep collectors need not be as comparatively inefficient as previously supposed, particularly when the effect of virtual memory paging on collector performance is observed. However, Wilson <ref> [58] </ref> has pointed out that modifying copying collectors to use generational scavenging techniques [30, 54] negates their poor paging performance. It appears that copying collectors still outperform mark-and-sweep collectors, but not by as much as had previously been supposed.
Reference: [59] <author> B. Zorn. </author> <title> Comparing mark-and-sweep and stop-and-copy garbage collection. </title> <booktitle> Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990, </year> <pages> 87-98. </pages>
Reference-contexts: See section 2.1 for more details. 2 The superiority of copying collectors over mark-and-sweep collectors is a topic of recent dispute. Zorn <ref> [59] </ref> has obtained results showing that mark-and-sweep collectors need not be as comparatively inefficient as previously supposed, particularly when the effect of virtual memory paging on collector performance is observed.
References-found: 59

