URL: ftp://ftp.cc.gatech.edu/pub/gvu/tr/1995/95-01.ps.Z
Refering-URL: http://www.cs.gatech.edu/gvu/reports/1995/
Root-URL: 
Email: Email: fazhao,staskog@cc.gatech.edu  
Title: Visualizing the Execution of Threads-based Parallel Programs  
Author: Qiang A. Zhao John T. Stasko 
Date: January 1995  
Address: Atlanta, GA 30332-0280  
Affiliation: Graphics, Visualization and Usability Center College of Computing Georgia Institute of Technology  
Pubnum: Technical Report GIT-GVU-95-01  
Abstract: One popular model of concurrent computing is threads-based parallel programming on a shared memory parallel computer. A variety of different vendors and machines provide such capabilities, and support for threads programming has begun to appear in desktop multiprocessor systems such as the Sun SPARCstation 20. Unfortunately, building parallel programs that use threads is still quite challenging, even for veteran serial programmers. This stems from the difficulty of controlling communication and synchronization between the different processes. We believe that the use of program visualization tools that graphically depict the state of a program's execution can help programmers develop, debug, and understand their code faster and more easily. Most program visualization systems for parallel computation have focused on performance views and views of message passing systems. Here, we introduce a presentation methodology and a set of views particularly appropriate for depicting the execution of threads-based parallel programs. These views were created specifically for the pthreads programming library on a KSR machine, but they could easily be adapted to other threads-based systems. We also describe our techniques for gathering program execution data to drive the views, and we discuss what an ideal program tracing environment should provide to support the views we developed. 
Abstract-found: 1
Intro-found: 1
Reference: [BDGS93] <author> Adam Beguelin, Jack Dongarra, Al Geist, and Vaidy Sunderam. </author> <title> Visualization and debugging in a heterogeneous environment. </title> <journal> Computer, </journal> <volume> 26(6) </volume> <pages> 88-95, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: ParaGraph provides views of processor utilization and message passing using a set of views such as Kiviat and Gantt charts. Other significant work on visualizing the operations of message-based distributed systems includes Seeplex/Seecube [Cou88], HyperView/Tapestry [MR90], Belvedere [CHK92], and Xab <ref> [BDGS93] </ref>. Similarly, systems for visualizing compiler-driven (FORTRAN) parallel programs such as SCHEDULE [DS87] and SHMAP [DBKF90] have been developed. Our work focuses specifically on threads programs and programming primitives, and is pioneering in its rigorous depiction of this paradigm.
Reference: [BS93] <author> Adam Beguelin and Erik Seligman. </author> <title> Causality-preserving timestamps in distributed programs. </title> <type> Technical Report CMU-CS-93-167, </type> <institution> Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Also, the views should provide simple user interface interactions to support these focusing operations. Another important limitation of our approach concerns the simple manner that program event tracing is performed. Since all the threads write their trace events to one particular file, inaccuracies in logical event ordering, so-called tachyons <ref> [BS93] </ref>, can easily occur. For example, a thread can appear to join a second thread before the second thread has properly terminated. <p> Any number of solutions to this problem are possible: The events can be written to separate files based on process-id (this causes other subtle complications in processing and visualizing the events later); The event file can be post-processed to remove logical inaccuracies <ref> [BS93, NMGM95] </ref>; A logical time tracing approach can be used [TC93, TSS94]. Perhaps the easiest of these methods is to post-process one trace file. Even if the logical time errors are corrected, this approach still has another problem.
Reference: [CHK92] <author> Janice E. Cuny, Alfred A. Hough, and Joydip Kundu. </author> <title> Logical time in visualizations produced by parallel programs. In Visualization '92, </title> <address> Boston, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: ParaGraph provides views of processor utilization and message passing using a set of views such as Kiviat and Gantt charts. Other significant work on visualizing the operations of message-based distributed systems includes Seeplex/Seecube [Cou88], HyperView/Tapestry [MR90], Belvedere <ref> [CHK92] </ref>, and Xab [BDGS93]. Similarly, systems for visualizing compiler-driven (FORTRAN) parallel programs such as SCHEDULE [DS87] and SHMAP [DBKF90] have been developed. Our work focuses specifically on threads programs and programming primitives, and is pioneering in its rigorous depiction of this paradigm.
Reference: [Cou88] <author> Alva Couch. </author> <title> Graphical representations of program performance on Hypercube message-passing multiprocessors. </title> <type> Technical Report 88-4, </type> <institution> Tufts University, </institution> <address> Boston, MA, </address> <month> April </month> <year> 1988. </year>
Reference-contexts: ParaGraph provides views of processor utilization and message passing using a set of views such as Kiviat and Gantt charts. Other significant work on visualizing the operations of message-based distributed systems includes Seeplex/Seecube <ref> [Cou88] </ref>, HyperView/Tapestry [MR90], Belvedere [CHK92], and Xab [BDGS93]. Similarly, systems for visualizing compiler-driven (FORTRAN) parallel programs such as SCHEDULE [DS87] and SHMAP [DBKF90] have been developed. Our work focuses specifically on threads programs and programming primitives, and is pioneering in its rigorous depiction of this paradigm.
Reference: [DBKF90] <author> Jack Dongarra, Orlie Brewer, James Arthur Kohl, and Samuel Fineberg. </author> <title> A tool to aid in the design, implementation, and understanding of matrix algorithms for parallel processors. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9(2) </volume> <pages> 185-202, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Other significant work on visualizing the operations of message-based distributed systems includes Seeplex/Seecube [Cou88], HyperView/Tapestry [MR90], Belvedere [CHK92], and Xab [BDGS93]. Similarly, systems for visualizing compiler-driven (FORTRAN) parallel programs such as SCHEDULE [DS87] and SHMAP <ref> [DBKF90] </ref> have been developed. Our work focuses specifically on threads programs and programming primitives, and is pioneering in its rigorous depiction of this paradigm. In the next section we describe the system support and framework for the views we developed.
Reference: [DS87] <author> Jack Dongarra and Danny Sorenson. </author> <title> SCHEDULE: Tools for Developing and Analyzing Parallel Fortran Programs. In L.H. Jamieson, D.B. </title> <editor> Gannon, and R.J. Douglass, editors, </editor> <title> The Characteristics of Parallel Algorithms. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: Other significant work on visualizing the operations of message-based distributed systems includes Seeplex/Seecube [Cou88], HyperView/Tapestry [MR90], Belvedere [CHK92], and Xab [BDGS93]. Similarly, systems for visualizing compiler-driven (FORTRAN) parallel programs such as SCHEDULE <ref> [DS87] </ref> and SHMAP [DBKF90] have been developed. Our work focuses specifically on threads programs and programming primitives, and is pioneering in its rigorous depiction of this paradigm. In the next section we describe the system support and framework for the views we developed.
Reference: [HE91] <author> Michael T. Heath and Jennifer A. Etheridge. </author> <title> Visualizing the performance of parallel programs. </title> <journal> IEEE Software, 8(5):29 -39, </journal> <month> September </month> <year> 1991. </year>
Reference-contexts: Prior work in visualization of concurrent programs has not placed a major focus on depicting the executions of shared memory threads programs [KS93]. Significant work has been done, however, on performance visualization, where the best-known example is the ParaGraph system <ref> [HE91] </ref>. ParaGraph provides views of processor utilization and message passing using a set of views such as Kiviat and Gantt charts. Other significant work on visualizing the operations of message-based distributed systems includes Seeplex/Seecube [Cou88], HyperView/Tapestry [MR90], Belvedere [CHK92], and Xab [BDGS93].
Reference: [IEE90] <author> IEEE. </author> <title> Threads Extension for Portable Operating Systems (P1003.4a), </title> <year> 1990. </year>
Reference-contexts: We used POLKA [SK93], an object-oriented software visualization methodology and library, as the platform to implement the graphical views. 2.1 Parallel Execution Environment | KSR Pthreads and Gthreads The KSR Pthreads interface is based on draft 4 of the proposed POSIX Threads Extension for Portable Operating Systems standard <ref> [IEE90] </ref>. The term pthread refers to a single sequential flow of control within a process, which in turn is a Mach operating system task.
Reference: [Ken92] <institution> Kendall Square Research Corporation, Waltham, MA. KSR C Programming, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: Section 4 discusses the limitations of our approach and the more general environment in which the threads views can operate. Finally, Section 5 describes the status of the project and our future plans. 2 System Foundations The particular threads implementation we chose as a prototype was Pthreads <ref> [Ken92] </ref>, a standard thread library on KSR parallel machines. This platform was available to us locally and provided a good example of a threads implementation. Other similar threads implementations include Solaris threads from Sun and cthreads [Muk91].
Reference: [KS93] <author> Eileen Kraemer and John T. Stasko. </author> <title> The visualization of parallel systems: An overview. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18(2) </volume> <pages> 105-117, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Extensive modifications of the underlying program should be avoided, and elaborate graphical specifications or manipulations should not be required. Prior work in visualization of concurrent programs has not placed a major focus on depicting the executions of shared memory threads programs <ref> [KS93] </ref>. Significant work has been done, however, on performance visualization, where the best-known example is the ParaGraph system [HE91]. ParaGraph provides views of processor utilization and message passing using a set of views such as Kiviat and Gantt charts.
Reference: [KS94] <author> Eileen Kraemer and John T. Stasko. </author> <title> Toward flexible control of the temporal mapping from concurrent program events to animations. </title> <booktitle> In Proceedings of the 8th International Parallel Processing Symposium (IPPS '94), </booktitle> <pages> pages 902-908, </pages> <address> Cancun, Mexico, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: In PARADE a tool called the Animation Choreographer fills this role <ref> [KS94] </ref>. It can take an event log such as a single Gthreads trace file produced by our macros or a set of per-thread trace files, and "re-introduce" the potential concurrency of the logged program events.
Reference: [MR90] <author> Allen D. Malony and Daniel A. Reed. </author> <title> Visualizing parallel computer system performance. </title> <editor> In Margaret Simmons, Rebecca Koskela, and Ingrid Bucher, editors, </editor> <booktitle> Parallel Computer Systems: Performance Instrumentation and Visualization. ACM, </booktitle> <address> New York, </address> <year> 1990. </year>
Reference-contexts: ParaGraph provides views of processor utilization and message passing using a set of views such as Kiviat and Gantt charts. Other significant work on visualizing the operations of message-based distributed systems includes Seeplex/Seecube [Cou88], HyperView/Tapestry <ref> [MR90] </ref>, Belvedere [CHK92], and Xab [BDGS93]. Similarly, systems for visualizing compiler-driven (FORTRAN) parallel programs such as SCHEDULE [DS87] and SHMAP [DBKF90] have been developed. Our work focuses specifically on threads programs and programming primitives, and is pioneering in its rigorous depiction of this paradigm.
Reference: [Muk91] <author> Bodhisattwa Mukherjee. </author> <title> A portable and reconfigurable threads package. </title> <booktitle> In Proceedings of Sun User Group Technical Conference, </booktitle> <pages> pages 101-112, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: This platform was available to us locally and provided a good example of a threads implementation. Other similar threads implementations include Solaris threads from Sun and cthreads <ref> [Muk91] </ref>. We used POLKA [SK93], an object-oriented software visualization methodology and library, as the platform to implement the graphical views. 2.1 Parallel Execution Environment | KSR Pthreads and Gthreads The KSR Pthreads interface is based on draft 4 of the proposed POSIX Threads Extension for Portable Operating Systems standard [IEE90].
Reference: [NMGM95] <author> Gary J. Nutt, James E. Mankovich, Adam J. Griff, and Jeffrey D. McWhirter. </author> <title> Extensible parallel program performance visualization. </title> <booktitle> In Proceedings of the MASCOTS '95 International Workshop on Modeling, Analysis and Simulation of Computer and Telecommunication Systems, </booktitle> <pages> pages ??-??, Durham, </pages> <address> NC, </address> <month> Jan-uary </month> <year> 1995. </year>
Reference-contexts: Any number of solutions to this problem are possible: The events can be written to separate files based on process-id (this causes other subtle complications in processing and visualizing the events later); The event file can be post-processed to remove logical inaccuracies <ref> [BS93, NMGM95] </ref>; A logical time tracing approach can be used [TC93, TSS94]. Perhaps the easiest of these methods is to post-process one trace file. Even if the logical time errors are corrected, this approach still has another problem.
Reference: [SK93] <author> John T. Stasko and Eileen Kraemer. </author> <title> A methodology for building application-specific visualizations of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18(2) </volume> <pages> 258-264, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: This platform was available to us locally and provided a good example of a threads implementation. Other similar threads implementations include Solaris threads from Sun and cthreads [Muk91]. We used POLKA <ref> [SK93] </ref>, an object-oriented software visualization methodology and library, as the platform to implement the graphical views. 2.1 Parallel Execution Environment | KSR Pthreads and Gthreads The KSR Pthreads interface is based on draft 4 of the proposed POSIX Threads Extension for Portable Operating Systems standard [IEE90]. <p> Our methods do illustrate, however, what can be done in a minimal support environment, thus providing a truer lower bound on a visualization environment for threads programs. 2.2 Visualization System | POLKA We developed all the threads visualizations using the Polka animation toolkit <ref> [SK93, Sta94] </ref>. Polka is an animation design methodology and accompanying implementation that is particularly well-suited to building software visualizations. Polka is especially appropriate for developing animations of parallel programs.
Reference: [Sta94] <author> John T. Stasko. </author> <title> POLKA Animation Designer's Package. Unpublished System Documentation. </title> <note> Available via anonymous ftp from ftp.cc.gatech.edu as pub/people/stasko/polka.tar.Z, </note> <year> 1994. </year>
Reference-contexts: Our methods do illustrate, however, what can be done in a minimal support environment, thus providing a truer lower bound on a visualization environment for threads programs. 2.2 Visualization System | POLKA We developed all the threads visualizations using the Polka animation toolkit <ref> [SK93, Sta94] </ref>. Polka is an animation design methodology and accompanying implementation that is particularly well-suited to building software visualizations. Polka is especially appropriate for developing animations of parallel programs.
Reference: [Sta95] <author> John T. Stasko. </author> <title> The PARADE environment for visualizing parallel program executions: A progress report. </title> <type> Technical Report GIT-GVU-95/03, </type> <institution> Graphics, Visualization, and Usability Center, Georgia Institute of Technology, </institution> <address> Atlanta, GA, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: One event is processed, it is animated, and then the next event is processed|The concurrency is effectively removed. Fortunately, we remedy all these tracing and timing problems by using the Gthreads views in a broader context, a comprehensive framework called PARADE (PARallel Animation Development Environment) we are developing <ref> [Sta95] </ref>.
Reference: [TC93] <author> Stephen J. Turner and W. Cai. </author> <title> The `logical clocks' approach to the visualization of parallel programs. </title> <editor> In G. Kotsis and G. Haring, editors, </editor> <booktitle> Performance Measurement and Visualization of Parallel Programs, </booktitle> <pages> pages 45-66. </pages> <publisher> Elsevier, </publisher> <year> 1993. </year>
Reference-contexts: of solutions to this problem are possible: The events can be written to separate files based on process-id (this causes other subtle complications in processing and visualizing the events later); The event file can be post-processed to remove logical inaccuracies [BS93, NMGM95]; A logical time tracing approach can be used <ref> [TC93, TSS94] </ref>. Perhaps the easiest of these methods is to post-process one trace file. Even if the logical time errors are corrected, this approach still has another problem. When the one file is read and visualized by threadview, an essentially serial animation results.
Reference: [TSS94] <author> Brad Topol, John T. Stasko, and Vaidy S. Sunderam. </author> <title> Integrating visualization support into distributed computing systems. </title> <type> Technical Report GIT-GVU-94/38, </type> <institution> Graphics, Visualization, and Usability Center, Georgia Institute of Technology, </institution> <address> Atlanta, GA, </address> <month> October </month> <year> 1994. </year> <month> 17 </month>
Reference-contexts: Obviously, this macro approach is not an ideal solution. A better approach would be to instrument the compiler and/or the run-time environment in order to reduce programmer involvement in the program tracing process. Such an approach has been used successfully by other systems that had access to these capabilities <ref> [TSS94] </ref>. Unfortunately, such support was not available to us. <p> of solutions to this problem are possible: The events can be written to separate files based on process-id (this causes other subtle complications in processing and visualizing the events later); The event file can be post-processed to remove logical inaccuracies [BS93, NMGM95]; A logical time tracing approach can be used <ref> [TC93, TSS94] </ref>. Perhaps the easiest of these methods is to post-process one trace file. Even if the logical time errors are corrected, this approach still has another problem. When the one file is read and visualized by threadview, an essentially serial animation results.
References-found: 19

