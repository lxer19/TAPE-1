URL: http://www.cs.princeton.edu/~ras/TR-534-96.ps
Refering-URL: http://www.cs.princeton.edu/~ras/
Root-URL: http://www.cs.princeton.edu
Email: fras,felteng@cs.princeton.edu  
Title: Mobile Network Objects  
Author: Robert A. Shillner and Edward W. Felten 
Address: Princeton University  
Affiliation: Dept. of Computer Science  
Abstract: We describe extensions to the DEC SRC Modula-3 network objects system which support migration of network objects between address spaces. Unlike other mobile object systems, we use an existing programming language rather than inventing a new language with object mobility primitives, and we require no changes to the compiler, standard runtime library, or operating system. This paper details the design, implementation and performance of our mobile objects system and two sample applications which use the system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Henri E. Bal, Frans Kaashoek, and Andrew S. Tanen-baum. Orca: </author> <title> A language for parallel programming of distributed systems. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 18(3) </volume> <pages> 190-205, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Our implementation is an extension of an existing (non-mobile) network objects package, the DEC SRC Modula-3 network objects system [2]. Our system differs from most mobile-object systems in that we use an existing programming language rather than inventing a new language with object mobility primitives (unlike many other systems <ref> [7, 3, 1, 4, 6] </ref>), and we require no changes in the compiler, standard runtime library, or operating system (unlike Amber [5]). <p> The high availablility of Hermes location techniques works around one of the limitations of the lazy location propagation scheme: its susceptibility to node failures. Orca <ref> [1] </ref> replicates objects on many nodes and uses a reliable, totally-ordered broadcast facility to invoke methods on all replicas simulaneously. All object placement is automatic and transparent to the programmer.
Reference: [2] <author> Andrew Birrell, Greg Nelson, Susan Owicki, and Ed-ward Wobber. </author> <title> Network objects. </title> <booktitle> In Proceedings of the 14th Symposium on Operating System Principles, </booktitle> <pages> pages 217-230, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction The network objects paradigm <ref> [2] </ref> for distributed programming combines object-oriented programming with remote procedure call (RPC). A network object is an object whose methods may be invoked by processes other than the one which contains the object. <p> This paper describes the design, implementation, and performance of a network objects system that supports object mobility. Our implementation is an extension of an existing (non-mobile) network objects package, the DEC SRC Modula-3 network objects system <ref> [2] </ref>. <p> To illustrate some of the benefits of network object mobility, consider the example of a trivial file service <ref> [2] </ref>. Figure 1 shows Modula-3 type declarations for a file service network object and a file network object. A client which remotely invokes the file service's open method receives a remote handle on a file object. The client can then remotely invoke the file's getChar and eof methods. <p> Subsequent sections describe the mobility facilities we added, their performance, two sample applications we implemented with the system, and some limitations we see in our approach. 2 Modula-3 network ob jects Rather than build a mobile network objects system from scratch, we extended the DEC SRC network objects system <ref> [2] </ref>, a network objects implementation for the Modula-3 programming language [8]. Modula-3 is an object-oriented language, with a strong type system, singly-inherited object types, automatic garbage collection and multiple threads of control. The original DEC SRC network objects system supports stationary network objects.
Reference: [3] <author> Andrew P. Black and Yeshayahu Artsy. </author> <title> Implementing location independent invocation. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 107-119, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Our implementation is an extension of an existing (non-mobile) network objects package, the DEC SRC Modula-3 network objects system [2]. Our system differs from most mobile-object systems in that we use an existing programming language rather than inventing a new language with object mobility primitives (unlike many other systems <ref> [7, 3, 1, 4, 6] </ref>), and we require no changes in the compiler, standard runtime library, or operating system (unlike Amber [5]). <p> Both systems support thread migration for active objects. In addition, Emerald allows code to be moved and dynamically linked to running programs. Amber uses a global virtual address space; it lays out memory identically on each node so that the system can locate an object's home node. The Hermes <ref> [3] </ref> distributed system also allows objects to move. Hermes uses temporal address descriptors (tads) to locate objects. A tad acts like a wirerep plus a location hint; a tad is a statement about the location of an object at some time in the past.
Reference: [4] <author> Luca Cardelli. </author> <title> A language with distributed scope. </title> <journal> Computing Systems, </journal> <volume> 8(1) </volume> <pages> 27-59, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Our implementation is an extension of an existing (non-mobile) network objects package, the DEC SRC Modula-3 network objects system [2]. Our system differs from most mobile-object systems in that we use an existing programming language rather than inventing a new language with object mobility primitives (unlike many other systems <ref> [7, 3, 1, 4, 6] </ref>), and we require no changes in the compiler, standard runtime library, or operating system (unlike Amber [5]). <p> Orca [1] replicates objects on many nodes and uses a reliable, totally-ordered broadcast facility to invoke methods on all replicas simulaneously. All object placement is automatic and transparent to the programmer. Interpreted languages like Obliq <ref> [4] </ref> and Phantom [6] offer a language-level implementation of network object mobility, rather than the library-level approach we have taken. Interpreted distributed languages have the advantage of easy code propagation across the network.
Reference: [5] <author> Jeffrey S. Chase, Franz G. Amador, Edward D. La-zowska, Henry M. Levy, and Richard J. Littlefield. </author> <title> The Amber system: Parallel programming on a network of multiprocessors. </title> <booktitle> In Proceedings of the 12th Symposium on Operating System Principles, </booktitle> <pages> pages 147-158, </pages> <year> 1989. </year>
Reference-contexts: Our system differs from most mobile-object systems in that we use an existing programming language rather than inventing a new language with object mobility primitives (unlike many other systems [7, 3, 1, 4, 6]), and we require no changes in the compiler, standard runtime library, or operating system (unlike Amber <ref> [5] </ref>). Despite these constraints, our system maintains the good features of the original DEC SRC network objects system: ease of use, automatic marshalling of complex data structures, reasonable response to failures, and fast execution of local calls. <p> Since there are fewer servers than clients, and servers are generally less likely to go down than clients, this approach is more robust. 7 Related work A number of distributed programming systems have used mobility. Emerald [7] and Amber <ref> [5] </ref> offer object mobility and remote method calls. Mobile objects in both systems have object descriptors, which play a role similar to that of a proxy object.
Reference: [6] <author> Antony Courtney. Phantom: </author> <title> An interpreted language for distributed programming. </title> <booktitle> In USENIX Conference on Object-Oriented Technologies, </booktitle> <year> 1995. </year>
Reference-contexts: Our implementation is an extension of an existing (non-mobile) network objects package, the DEC SRC Modula-3 network objects system [2]. Our system differs from most mobile-object systems in that we use an existing programming language rather than inventing a new language with object mobility primitives (unlike many other systems <ref> [7, 3, 1, 4, 6] </ref>), and we require no changes in the compiler, standard runtime library, or operating system (unlike Amber [5]). <p> Orca [1] replicates objects on many nodes and uses a reliable, totally-ordered broadcast facility to invoke methods on all replicas simulaneously. All object placement is automatic and transparent to the programmer. Interpreted languages like Obliq [4] and Phantom <ref> [6] </ref> offer a language-level implementation of network object mobility, rather than the library-level approach we have taken. Interpreted distributed languages have the advantage of easy code propagation across the network.
Reference: [7] <author> Eric Jul, Henry Levy, Norman Hutchinson, and An-drew Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Our implementation is an extension of an existing (non-mobile) network objects package, the DEC SRC Modula-3 network objects system [2]. Our system differs from most mobile-object systems in that we use an existing programming language rather than inventing a new language with object mobility primitives (unlike many other systems <ref> [7, 3, 1, 4, 6] </ref>), and we require no changes in the compiler, standard runtime library, or operating system (unlike Amber [5]). <p> There are many reasons to migrate objects <ref> [7] </ref>: * to exploit locality by migrating objects to the sites where they are used most often; * to balance load between machines by migrating objects from heavily loaded machines to lightly loaded machines; * to improve scalability by migrating work from a heavily loaded server to its clients; * to <p> Since there are fewer servers than clients, and servers are generally less likely to go down than clients, this approach is more robust. 7 Related work A number of distributed programming systems have used mobility. Emerald <ref> [7] </ref> and Amber [5] offer object mobility and remote method calls. Mobile objects in both systems have object descriptors, which play a role similar to that of a proxy object.
Reference: [8] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: performance, two sample applications we implemented with the system, and some limitations we see in our approach. 2 Modula-3 network ob jects Rather than build a mobile network objects system from scratch, we extended the DEC SRC network objects system [2], a network objects implementation for the Modula-3 programming language <ref> [8] </ref>. Modula-3 is an object-oriented language, with a strong type system, singly-inherited object types, automatic garbage collection and multiple threads of control. The original DEC SRC network objects system supports stationary network objects. <p> This section reviews the original DEC SRC network objects system. Section 3 describes how we modified this system to support mobility. 2.1 Abstract and concrete network objects A Modula-3 object is a data record paired with a method suite <ref> [8] </ref>. Each method has a signature (names and types of its arguments plus a return type) and a body which contains the method's code. A new object type A 0 may be declared as a subtype of an existing object type A.
Reference: [9] <author> Marc Shapiro. </author> <title> Structure and encapsulation in distributed systems: The proxy principle. </title> <booktitle> In IEEE International Conference on Distributed Computing Systems, </booktitle> <year> 1986. </year>
Reference-contexts: The original Modula-3 network objects system does not contain any facility for "repointing" surrogates. Adding such 1 We use the term "proxy" in a different sense than does Shapiro <ref> [9] </ref>. Shapiro's proxies are more like our surrogates. surrogate concrete proxy objtbl proxy an operation would involve extensive changes to the runtime library and stub generator to make the "repoint" operation safe for multithreaded programs.
Reference: [10] <author> Leendert van Doorn, Martin Abadi, Mike Burrows, and Edward Wobber. </author> <title> Secure network objects. </title> <type> Technical Report IR-385, </type> <institution> Vrije Universiteit, </institution> <address> Amsterdam, </address> <month> July </month> <year> 1995. </year> <pages> Page 13 </pages>
Reference-contexts: Because of the idleness requirement, these objects can never move. 6.2 Security We made no attempt to make our system secure. We feel that network objects system security is a separate topic beyond the scope of this work. Van Doorn et. al. <ref> [10] </ref> discuss one security strategy for the Modula-3 network objects system. We believe our system could be adapted to coexist with their security mechanisms. 6.3 Compatibility The addition of the location hint to the wirerep makes our system incompatible with the original DEC SRC network objects system.
References-found: 10

