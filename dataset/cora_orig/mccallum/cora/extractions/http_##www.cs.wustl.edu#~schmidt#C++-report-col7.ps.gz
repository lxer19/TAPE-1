URL: http://www.cs.wustl.edu/~schmidt/C++-report-col7.ps.gz
Refering-URL: http://www.acl.lanl.gov/CORBA/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: schmidt@cs.wustl.edu vinoski@ch.hp.com  
Title: Object Interconnections Comparing Alternative Programming Techniques for Multi-threaded CORBA Servers (Column 7)  
Author: Douglas C. Schmidt Steve Vinoski 
Note: This column appeared in the July/August 1996 issue of the SIGS C++ Report magazine.  
Address: St. Louis, MO 63130 Chelmsford, MA 01824  
Affiliation: Department of Computer Science Hewlett-Packard Company Washington University,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalingiah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedingsof the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Note how the strengths and weaknesses of the solution will change as the assumptions change. 3 The C Thread-per-Session Solution 3.1 Implementing Thread-per-Session in C The following example shows a thread-per-session solution written using C, sockets, and Solaris threads <ref> [1] </ref>. 1 As in 1 Porting our implementation to POSIX pthreads or Win32 threads is straightforward. 1 previous columns, we use the following set of C utility func-tions: /* WIN32 already defines this. */ #if defined (unix) typedef int HANDLE; #endif /* unix */ // Factory function that allocates a // <p> Our server main is almost identical to the one we presented for the thread-per-request C solution in our February column: const int DEFAULT_PORT = 12345; int main (int argc, char *argv []) - /* Port to listen for connections. */ u_short port = argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : DEFAULT_PORT; /* Create a passive-mode listener endpoint. */ HANDLE listener = create_server_endpoint (port); /* The event loop for the main server thread. */ svc_run (listener); /* NOTREACHED */ - The key difference is that unlike the thread-per-request model, we don't dynamically spawn a thread for each new client quote <p> 4.1.3 The main () Server Function The C++ server main is responsible for initializing the Quote Acceptor and running the main event loop, as follows: // Default constants. const int DEFAULT_PORT = 12345; int main (int argc, char *argv []) - u_short port = argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : DEFAULT_PORT; // Server address. INET_Addr server_addr (port); // Factory that produces connected Quote_Handlers.
Reference: [2] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: we changed the format of stock quote requests and replies, we'd have to reimplement most of the utility code that we reused in this example. 2 Stock Quote Server 4 The C++ Thread-per-Session Solu tion 4.1 Implementing Thread-per-Session in C++ This section illustrates a C++ thread-per-session implementation based on ACE <ref> [2] </ref>.
Reference: [3] <author> D. C. Schmidt, </author> <title> Design Patterns for Initializing Network Services: Introducing the Acceptor and Connector Patterns, </title> <journal> C++ Report, </journal> <volume> vol. 7, </volume> <month> November/December </month> <year> 1995. </year>
Reference-contexts: between the C and C++ session thread functions is that the C++ 3 version must deallocate itself before the thread exits since the Quoter Acceptor factory dynamically allocated the memory for the Quote Handler. 4.1.2 The Quote Acceptor Class The Quote Acceptor class is an implementation of the Acceptor pattern <ref> [3] </ref> that creates Quote Handlers to process quote requests from clients. Its implementation is identical to the one shown in our previous column: typedef Acceptor &lt; Quote_Handler &lt;SOCK_Stream&gt;, // Quote service. SOCK_Acceptor&gt; // Passive conn. mech.
Reference: [4] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: Handler creation which dynamically creates a Quote Handler. 2. Handler connection acceptance which accepts the connection into the handler using the SOCK Acceptor (this is a C++ wrapper for passive-mode sockets that creates connected SOCK Streams <ref> [4] </ref>). 3. Handler activation which invokes the Quote Handler::open method.
Reference: [5] <institution> Object Management Group, </institution> <month> CORBAServices: </month> <title> Common Object Services Specification, </title> <note> Revised Edition, </note> <editor> 95-3-31 ed., </editor> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: // !!! Narrow to Quoter_Factory // interface and away we go! Quoter_Factory_var qf = Quoter_Factory::_narrow (obj); // !!! Select name of desired quoter. const char *quoter_name = "My Quoter"; 3 The bind service function hides the details of initializing the ORB and locating object references with the CORBA Naming service <ref> [5] </ref>. // !!! Ask factory to produce a new Quoter. <p> &lt;< service_name &lt;< " is not a Quoter_Factory!"; catch (Invalid_Stock &) - cerr &lt;< stock_name &lt;< " is not a valid stock name!"n"; - return result; // !!! Destructor of qf releases object reference. - Incidentally, the notion of customized object creation is supported by the OMG Lifecycle Service Specification <ref> [5] </ref>. It specifies a GenericFactory interface intended to allow clients to create a wide variety of objects. One of the arguments to the GenericFactory::create object operation is a sequence of named any values. <p> However, when using CORBA, a common practice is to have the object reference obtained from a factory be made available to multiple applications. For example, an application may invoke a factory operation to create a COSS Event Channel and advertise it in the COSS Naming Service <ref> [5] </ref>. Other applications can then obtain the event channel's object reference from the Naming Service and attach themselves to it as producers or consumers of events.
Reference: [6] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> (Reading, MA), </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year> <month> 10 </month>
Reference-contexts: Although we've omitted the COSS Lifecycle services in our example to save space, future columns will address this topic in depth. 5.3 Implementing Thread-per-Session in MT Orbix The MT-Orbix implementation of thread-per-session is a classic example of the Active Object pattern <ref> [6] </ref>. Each active object is responsible for servicing a different client session. Our thread-per-session implementation uses the thread-safe Message Queue class defined in the thread-pool implementation from our previous column.
Reference: [7] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Pat--terns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Thread::spawn (&My_Quoter::session_thread, // Get the Quoter instance. DEREF (quoter), THR_DETACHED | THR_NEW_LWP); return quoter; - DEF_TIE_Quoter_Factory (My_Quoter_Factory) The create quoter operation is a Factory Method <ref> [7] </ref> that's called by the Object Adapter when a client initiates a session. It uses the name of the quoter service passed in by the client to help select an appropriate Quoter implemen tation. 7 Our client in Section 5.2 specified the My Quoter im-plementation.
Reference: [8] <author> M. Shapiro, </author> <title> Flexible Bindings for Fine-Grain, Distributed Objects, </title> <type> Tech. Rep. </type> <institution> Rapport de recherche INRIA 2007, INRIA, </institution> <month> Aug. </month> <year> 1993. </year> <month> 11 </month>
Reference-contexts: In this case, a 1 is returned to tell Orbix to continue dispatching the request normally in the main thread. This causes Orbix to invoke 4 Orbix filters are an implementation of Shapiro's Stub-Scion Pair (SSP) Chains; see <ref> [8] </ref> for more details. 8 the create quoter upcall on the My Quoter Factory implementation. If the narrow succeeds, we use C++ RTTI to determine the actual type of the quoter object.
References-found: 8

