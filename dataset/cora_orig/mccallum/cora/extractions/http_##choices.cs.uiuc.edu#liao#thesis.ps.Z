URL: http://choices.cs.uiuc.edu/liao/thesis.ps.Z
Refering-URL: http://choices.cs.uiuc.edu/liao/home.html
Root-URL: http://www.cs.uiuc.edu
Title: c  
Author: flCopyright by Willy Shih-yang Liao 
Date: 1995  
Abstract-found: 0
Intro-found: 1
Reference: [CIM92] <author> Roy H. Campbell, Nayeem Islam, and Peter Madany. </author> <title> Choices, Frameworks and Refinement Revisited. </title> <type> Technical Report UIUCDCS-R-92-1769, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: Software reuse is enhanced by the careful design of object-oriented frameworks. For example, the design of the Choices operating system makes aggressive use of many sub-frameworks which are specialized for particular hardware or software situations <ref> [CIM92] </ref>. This considerably enhances the portability of Choices since the basic frameworks and software architecture are unchanged across different versions. 2.1.2 The Choices Operating System Choices [CIMR93] is an object-oriented operating system for multiprocessor machines written in C++. <p> All classes in Choices are descended 6 from a base class called Object. The core framework for Choices consists of three abstract classes: MemoryObject, Process, and Domain <ref> [CIM92] </ref>. A MemoryObject represents objects in memory such as program code or data, or objects such as disk files. A Process is a thread of execution that possesses its own stack and exists in some Domain.
Reference: [CIMR93] <author> Roy Campbell, Nayeem Islam, Peter Madany, and David Raila. </author> <title> Designing and Implementing Choices: an Object-Oriented System in C++. </title> <journal> Communications of the ACM, </journal> <month> September </month> <year> 1993. </year>
Reference-contexts: Easy embedding also encourages modular design of the protocols themselves, since they can be put in and tested as individual components, rather than merely being portions of a monolithic networking subsystem. The software architecture described in this thesis was implemented in the Choices operating system <ref> [CIMR93] </ref>, a portable object-oriented operating system for multiprocessor systems. The ideas are, however, system-independent; the NIF does not rely on any particular operating system services, and the x -kernel is system-independent by design. <p> This considerably enhances the portability of Choices since the basic frameworks and software architecture are unchanged across different versions. 2.1.2 The Choices Operating System Choices <ref> [CIMR93] </ref> is an object-oriented operating system for multiprocessor machines written in C++. It was originally implemented for the Encore Multimax, but has since been ported to various other machines, among them the Macintosh IIx [Hel91], the IBM PC family [Lee92], the Intel Hypercube, and the SPARCStation 1 family [Rai92].
Reference: [Cur89] <author> David A. Curry. </author> <title> Using C on the UNIX System|A Guide to System Programming. </title> <publisher> O'Reilly and Associates, Inc., </publisher> <address> Sebastopol, CA, </address> <year> 1989. </year>
Reference-contexts: The examples in this chapter also illustrate the flexibility of the NIF in accommodating optimizations without sacrificing generality. 40 Chapter 5 An Implementation of Sockets in the x-kernel This chapter describes an implementation of the sockets interprocess communication facility for user-level programs found in BSD UNIX <ref> [LMKQ89, Cur89] </ref>. The target platform is the Choices operating system using the NIF implementation described in the previous chapter. The sockets implementation is a good example of the ability to embed protocols into the network software architecture presented in this thesis.
Reference: [Deu89] <author> L. Peter Deutsch. </author> <title> Design Reuse and Frameworks in the Smalltalk-80 Programming System. </title> <editor> In Ted J. Biggerstaff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <volume> volume II, </volume> <pages> pages 55-71. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: More precisely, it is the specification of the interactions that are permitted between components and their relationships to each other <ref> [Deu89] </ref>. One well-known example is the Model-View-Controller framework [KP88] of the SmallTalk-80 programming environment. An object-oriented framework benefits from object-oriented programming features such as inheritance and inclusion polymorphism since a framework can be specialized and refined by subclassing of component subclasses.
Reference: [DP92] <author> Peter Druschel and Larry L. Peterson. </author> <title> Beyond micro-kernel design: Decou-pling modularity and protection in lipto. </title> <booktitle> In Proceedings of 12th International Conference on Distributed Computing Systems, </booktitle> <year> 1992. </year>
Reference-contexts: The authors of x -kernel argue that domains should not necessarily correspond to protocol layers for reasons of efficiency. They feel that modularity and protection are orthogonal issues and systems can be designed to reflect this <ref> [DP92] </ref>.
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: It also covers some techniques used in object-oriented design. The terminology and examples used come from the SmallTalk-80 <ref> [GR83] </ref> and C++ [Str86] programming languages. 2.1.1.1 Objects An object is the fundamental unit of an object-oriented program. An object encapsulates data and the code which manipulates that data. This is similar to a module in a traditional imperative programming language, which can encapsulate both code and data.
Reference: [Hel91] <author> Bjorn Andrew Helgaas. </author> <title> Porting the Choices Object-oriented Operating System to the Motorola 68030. </title> <type> Master's thesis, </type> <institution> The University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: It was originally implemented for the Encore Multimax, but has since been ported to various other machines, among them the Macintosh IIx <ref> [Hel91] </ref>, the IBM PC family [Lee92], the Intel Hypercube, and the SPARCStation 1 family [Rai92]. There also exists a version of Choices called Virtual Choices which runs as a user process under SunOS 4.1 and uses memory-mapping and UNIX signals to simulate virtual memory and hardware interrupts.
Reference: [HP91] <author> Norman Hutchinson and Larry Peterson. </author> <title> The x-kernel: An archtecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-75, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The lower-level portion of this architecture is an object-oriented framework for interactions between the lowest level network protocols and the network interface hardware. This framework is called the Network Interface Framework (NIF). Above the NIF is embedded an object-based network protocol framework (the x -kernel <ref> [HP91] </ref>) that permits multiple higher-level protocols to be composed arbitrarily. Easy embedding of protocols in an operating system is desirable from a design viewpoint. It permits easy customization and extension of the networking facilities. <p> There is no well-defined notion of a networking "session," and each protocol handles the specification of a connection in its own particular way. 2.3 Overview of the x -kernel The x -kernel is an object-based architecture for network protocols <ref> [HP91] </ref>. It allows great flexibility in the configuration and composition of protocols and has a very modular design which allows for easy implementation of new protocols without necessarily sacrificing performance. 2.3.1 x -kernel Objects The x -kernel provides three basic communication objects: protocols, sessions, and messages.
Reference: [ISO84] <author> ISO. </author> <title> Open Systems Interconnection|Basic Reference Model. </title> <type> Technical Report ISO 7498, </type> <institution> International Organization for Standardization, </institution> <year> 1984. </year>
Reference-contexts: A layer at level n provides services to the layer n + 1 above it, and in turn it uses the services provided by layer n 1 [Tan88]. For example, in the Open Systems Interconnection (OSI) reference model <ref> [ISO84] </ref>, there are seven layers which range from the actual physical medium used to transmit and receive data, through the layers of protocol processing generally performed by the operating system, all the way up to the application level.
Reference: [KP88] <author> Glen E. Krasner and Stephen T. Pope. </author> <title> A Cookbook for Using the Model-View-Controller Paradigm in Smalltalk-80. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 26-49, </pages> <year> 1988. </year> <month> 57 </month>
Reference-contexts: More precisely, it is the specification of the interactions that are permitted between components and their relationships to each other [Deu89]. One well-known example is the Model-View-Controller framework <ref> [KP88] </ref> of the SmallTalk-80 programming environment. An object-oriented framework benefits from object-oriented programming features such as inheritance and inclusion polymorphism since a framework can be specialized and refined by subclassing of component subclasses. Software reuse is enhanced by the careful design of object-oriented frameworks.
Reference: [KR78] <author> B. W. Kernighan and D. M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice--Hall, Inc., </publisher> <year> 1978. </year>
Reference-contexts: a file descriptor to reference a socket, and naive programs that use file routines such as read and write will still work. 5.2 The UNIX Emulation Framework It is necessary to provide limited UNIX compatibility in Choices at the system call level, as x -kernel uses the C stdio library <ref> [KR78] </ref> quite heavily, and there is currently no implementation of this library available that uses Choices object proxies instead of UNIX system calls. The framework which provides emulation of UNIX system calls in Choices is the UNIX Emulation Framework (UEF).
Reference: [Lee92] <author> Lup Lee. </author> <title> PC-Choices Object-oriented Operating System. </title> <type> Master's thesis, </type> <institution> The University of Illinois at Urbana-Champaign, </institution> <month> Aug </month> <year> 1992. </year>
Reference-contexts: It was originally implemented for the Encore Multimax, but has since been ported to various other machines, among them the Macintosh IIx [Hel91], the IBM PC family <ref> [Lee92] </ref>, the Intel Hypercube, and the SPARCStation 1 family [Rai92]. There also exists a version of Choices called Virtual Choices which runs as a user process under SunOS 4.1 and uses memory-mapping and UNIX signals to simulate virtual memory and hardware interrupts.
Reference: [Li86] <author> K. Li. </author> <title> Shared Virtual Memory on Loosely Coupled Multiprocessors. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <year> 1986. </year>
Reference-contexts: It would be unacceptable to force all 35 applications using the network to use x -kernel, as some of them may not wish to block for an arbitrary period of time waiting for the master lock. An example of such a low-latency application would be distributed virtual memory <ref> [Li86] </ref>. The NIF's support for multiple clients permits use of the network without x -kernel. 4.2.1 Operating System Dependencies in x -kernel There are some aspects of embedding x -kernel into an operating system that do not involve the NIF.
Reference: [LMKQ89] <author> Samuel J. Leffer, Marshall Kirk McKusick, Michale J. Karels, and John S. Quarterman. </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, Reading, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: Latency for the processing 11 of any one message can be lower since there is no waiting for synchronization between processes. The x -kernel uses the process-per-message model. 2.2.4 BSD UNIX Network Protocol Processing Networking in 4.3BSD UNIX <ref> [LMKQ89] </ref> is an example of how a popular operating system structures its network protocol software. The hardware interrupts from the network controller are handled by interrupt handlers that run on a special kernel stack and do not rely on having any process context which is currently active. <p> The examples in this chapter also illustrate the flexibility of the NIF in accommodating optimizations without sacrificing generality. 40 Chapter 5 An Implementation of Sockets in the x-kernel This chapter describes an implementation of the sockets interprocess communication facility for user-level programs found in BSD UNIX <ref> [LMKQ89, Cur89] </ref>. The target platform is the Choices operating system using the NIF implementation described in the previous chapter. The sockets implementation is a good example of the ability to embed protocols into the network software architecture presented in this thesis.
Reference: [MJLF84] <author> M. K. McKusick, W. N. Joy, S. J. Le*er, and R. S. Fabry. </author> <title> A Fast File System for UNIX. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 181-197, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: how the network interface framework is implemented in Choices and how this in turn is used to embed the x -kernel into Choices to produce an OS that supports arbitrary embedding of network protocols. * Implementation of a sockets API: This chapter describes how the sockets interface from BSD UNIX <ref> [MJLF84] </ref> is implemented as an application programmer interface to the x -kernel to permit application use of the x -kernel TCP and UDP implemen tations.
Reference: [Rai92] <author> David Raila. </author> <title> The Choices Object-oriented Operating System on the Sparc Architecture. </title> <type> Master's thesis, </type> <institution> The University of Illinois at Urbana-Champaign, </institution> <month> Aug </month> <year> 1992. </year>
Reference-contexts: It was originally implemented for the Encore Multimax, but has since been ported to various other machines, among them the Macintosh IIx [Hel91], the IBM PC family [Lee92], the Intel Hypercube, and the SPARCStation 1 family <ref> [Rai92] </ref>. There also exists a version of Choices called Virtual Choices which runs as a user process under SunOS 4.1 and uses memory-mapping and UNIX signals to simulate virtual memory and hardware interrupts.
Reference: [Rus90] <author> V. F. Russo. </author> <title> An Object-Oriented Operating System. </title> <type> PhD thesis, </type> <institution> University of Illinois, Urbana-Champaign, </institution> <year> 1990. </year>
Reference-contexts: Processes in the preemptable queue are in addition subject to time-slicing preemption. Therefore Ap-plicationProcesses and PreemptableSystemProcesses, both of which are time-sliced, have lesser priority than InterruptProcesses and SystemProcesses. 2.1.2.3 Application Interface to the Kernel An application may access kernel services through an ObjectProxy <ref> [Rus90] </ref> for a kernel object. An ObjectProxy is a dummy object that resides in a read-only portion of the 8 application's Domain. Proxies for common system objects are created for an application when it first starts up. An example is a NameServer proxy for looking up objects in the system.
Reference: [San94] <author> Aamod Sane. </author> <type> Personal Communication, </type> <year> 1994. </year>
Reference-contexts: The major issue that arises is the specification of the semantics involving the source and the disposition of the NetworkBuffer. It is the solution to this problem that is a primary feature of the NetworkClient class. The ideas described below are based on ideas about buffer swapping from <ref> [San94] </ref>. 3.1.2.1 Specifying the Receive Buffer Policy A NetworkDriver will never give away a NetworkBuffer containing data unless it obtains another NetworkBuffer in return.
Reference: [Str86] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: It also covers some techniques used in object-oriented design. The terminology and examples used come from the SmallTalk-80 [GR83] and C++ <ref> [Str86] </ref> programming languages. 2.1.1.1 Objects An object is the fundamental unit of an object-oriented program. An object encapsulates data and the code which manipulates that data. This is similar to a module in a traditional imperative programming language, which can encapsulate both code and data.
Reference: [sys90] <institution> UNIX SYSTEM V Release 4 Programmer's Guide: STREAMS. </institution> <address> Englewood Cliffs, New Jersey, </address> <year> 1990. </year>
Reference-contexts: By composing across protection domains we could allow composition of arbitrary user-level protocol programs, each running as a separate process. An operating system that uses a microkernel approach might employ this strategy. One non-microkernel OS that uses this approach is System V, which has a streams facility <ref> [sys90] </ref>. The other obvious approach to process decomposition in protocols is process-per-message, in which each message that is received or sent is handled by a single process. When a message is received, a process can be pulled from a waiting pool of processes.
Reference: [Tan88] <author> A. S. Tannenbaum. </author> <title> Computer Networks. </title> <publisher> Prentice-Hall Inc., </publisher> <address> second edition, </address> <year> 1988. </year>
Reference-contexts: A layer at level n provides services to the layer n + 1 above it, and in turn it uses the services provided by layer n 1 <ref> [Tan88] </ref>. For example, in the Open Systems Interconnection (OSI) reference model [ISO84], there are seven layers which range from the actual physical medium used to transmit and receive data, through the layers of protocol processing generally performed by the operating system, all the way up to the application level.
References-found: 21

