URL: ftp://ftp.cis.ohio-state.edu/pub/anish/papers/Byzantine.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~anish/pub.html
Root-URL: 
Title: Compositional Design of Multitolerant Repetitive Byzantine Agreement  
Author: Sandeep S. Kulkarni Anish Arora 
Address: Columbus, OH 43210 USA  
Affiliation: Department of Computer and Information Science The Ohio State University  
Abstract: We illustrate in this paper a compositional and stepwise method for designing programs that offer a potentially unique tolerance to each of their fault-classes. More specifically, our illustration is a design of a repetitive agreement program that offers two tolerances: (a) it masks the effects of Byzantine failures and (b) it is stabilizing in the presence of transient and Byzantine failures.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Arora and S. S. Kulkarni. </author> <title> Component-based design of multitolerance. </title> <type> Technical Report OSU-CISRC TR37, </type> <institution> Ohio State University, </institution> <year> 1996. </year>
Reference-contexts: Analogous to the compositional design of large correctors, large detectors can be designed in a stepwise and hierarchical fashion, by parallel and/or sequential composition of small detectors. The interested reader is referred to a companion paper <ref> [1] </ref> for an in-depth study of detectors and correctors. Self-tolerances of components. <p> While our proofs of interference-freedom were presented in informal terms, they are readily formalized, e.g., in the temporal logic framework of <ref> [1] </ref>. The formalization builds upon previous work on compositionality, e.g. [9, 10, 11]. We observed that a similar design is possible where we first add stabilizing tolerance and then masking tolerance.
Reference: [2] <author> Z. Liu and M. Joseph. </author> <title> Transformation of programs for fault-tolerance. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4(5) </volume> <pages> 442-469, </pages> <year> 1992. </year>
Reference: [3] <author> K. P. Birman and R. van Renesse. </author> <title> Reliable distributed computing using the Isis Toolkit. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference: [4] <author> L. Lamport, R. Shostak, and M. Pease. </author> <title> The Byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <year> 1982. </year>
Reference-contexts: of the d values at the non-general processes.) In other words, C (j) itself contains a repetitive agreement program ! With this insight, we are now ready to generalize program SMR to handle the multiple Byzantine faults, based on an idea that is essentially due to Lamport, Shostak, and Pease <ref> [4] </ref>. (Our generalization, of course, is distinguished by being multitolerant.) Let g denote the general process, X denote the set of non-general processes, t denote the maximum number of Byzantine processes. <p> The proof of masking tolerance is similar to the one in <ref> [4] </ref>. 7 Refining the Atomicity While Preserving Multitolerance Our design thus far has assumed read-and-write atomicity, whereby each action of a process can atomically read the variables of the other processes and update the variables of that process.
Reference: [5] <author> A. Arora and S. S. Kulkarni. </author> <title> Designing masking fault-tolerance via nonmasking fault-tolerance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <note> 1997, to appear. </note>
Reference-contexts: In fact, in general, the same multitolerant program can be designed by adding the tolerance components in different orders. For the special case of adding both detector and corrector components for masking tolerance, the design may be simplified by using a stepwise approach <ref> [5] </ref>: For instance, we may first augment the program with detectors and then augment the resulting fail-safe tolerant program with correctors. Alternatively, we may first augment the program with correctors and then augment the resulting nonmasking tolerant program with detectors.
Reference: [6] <author> Y. Zhao and F. B. Bastani. </author> <title> A self-adjusting algorithm for Byzantine agreement. </title> <journal> Distributed Computing, </journal> <volume> 5 </volume> <pages> 219-226, </pages> <year> 1992. </year>
Reference-contexts: Alternative tolerances to Byzantine failures. In the presence of Byzantine failures alone, SM R satisfies the specification of repetitive agreement in each round. The reader may wonder whether this strong guarantee is true of every repetitive agreement program that tolerates Byzantine failures. The answer is negative: Zhao and Bastani <ref> [6] </ref> have presented a program that is nonmasking tolerant to Byzantine failures, i.e., that could violate the specification in some finite number of rounds only. Moreover, we present here a program that is stabilizing tolerant |but not masking tolerant| to Byzantine failure.
Reference: [7] <author> S. S. Kulkarni and A. Arora. </author> <title> Compositional design of multitolerant repetitive Byzantine agreement (preliminary version). </title> <booktitle> Third Workshop on Self-Stabilizing Systems (WSS 97), </booktitle> <institution> University of California, Santa Barbara, </institution> <year> 1997. </year>
Reference-contexts: Starting from a state satisfying S, at most one round is executed incorrectly. For reasons of space, we omit the proof here and refer the interested reader to <ref> [7] </ref>. (2) Observe that, in the absence of faults, S continues to be preserved, and hence the stabilizing component is never executed.
Reference: [8] <author> A. Arora and M. G. Gouda. </author> <title> Distributed reset. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 43(9) </volume> <pages> 1026-1038, </pages> <year> 1994. </year>
Reference-contexts: In this section, we show that our design can be refined into read-or-write atomicity, whereby each action of a process can either atomically read the variables of some other process or atomically write its variables but not both. We choose a standard refinement <ref> [8] </ref>: In each process j a copy of every variable that j reads from another process is introduced. For each of these variables, an action is added to j that asynchronously reads that variable into the copy. <p> the set of possible sequence numbers has to be increased to f0::K 1g where K 4. (This claim follows from the fact that between g and j there are four sequence numbers, namely, sn:g, sn:j, and the copies of sn:g and sn:j at j and g respectively; for details, see <ref> [8] </ref>.) Moreover, a deadlock has to be avoided in the states of refined version of R where sn:j 6= sn:g and sn:j 6= sn:g 1. (These states do not exist in SM R since its sequence numbers are either 0 or 1.) Therefore, to preserve stabilization, we need to add actions
Reference: [9] <author> K. Apt, N. Francez, and W.-P. de Roever. </author> <title> A proof system for communicating sequential processes. </title> <journal> ACM transactions on Programming Languages and Systems, </journal> <pages> pages 359-385, </pages> <year> 1980. </year>
Reference-contexts: While our proofs of interference-freedom were presented in informal terms, they are readily formalized, e.g., in the temporal logic framework of [1]. The formalization builds upon previous work on compositionality, e.g. <ref> [9, 10, 11] </ref>. We observed that a similar design is possible where we first add stabilizing tolerance and then masking tolerance.
Reference: [10] <author> H. Schepers. </author> <title> Fault Tolerance and Timing of Distributed Systems: Compositional specification and verification. </title> <type> PhD thesis, </type> <institution> Eindhoven University, </institution> <year> 1994. </year>
Reference-contexts: While our proofs of interference-freedom were presented in informal terms, they are readily formalized, e.g., in the temporal logic framework of [1]. The formalization builds upon previous work on compositionality, e.g. <ref> [9, 10, 11] </ref>. We observed that a similar design is possible where we first add stabilizing tolerance and then masking tolerance.
Reference: [11] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: While our proofs of interference-freedom were presented in informal terms, they are readily formalized, e.g., in the temporal logic framework of [1]. The formalization builds upon previous work on compositionality, e.g. <ref> [9, 10, 11] </ref>. We observed that a similar design is possible where we first add stabilizing tolerance and then masking tolerance.
Reference: [12] <author> J. Goldberg, I. Greenberg, and T. Lawrence. </author> <title> Adaptive fault-tolerance. </title> <booktitle> Proceedings of the IEEE Workshop on Advances in Parallel and Distributed Systems, </booktitle> <pages> pages 127-138, </pages> <year> 1993. </year>
Reference-contexts: Moreover, as discussed in Section 7, our initial design which assumed read-and-write atomicity is readily refined within the context of our design method into read-or-write atomicity or message-passing. A reviewer of this paper correctly observed that our design method could benefit from using the principles of adaptive fault-tolerance <ref> [12] </ref>. Indeed, one way of simplifying the interference-freedom obligation between tolerance components is to choose only one of the tolerance components for execution at a time and to adapt this choice as the (fault) environment and internal state of the system changes.
References-found: 12

