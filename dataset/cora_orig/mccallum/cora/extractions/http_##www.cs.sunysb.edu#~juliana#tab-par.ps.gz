URL: http://www.cs.sunysb.edu/~juliana/tab-par.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~juliana/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: fjuliana,ruihu,tswift,warreng@cs.sunysb.edu  
Phone: Phone: (516) 632-8470  
Title: Parallelizing Tabled Evaluations Extended Abstract  
Author: Juliana Freire Rui Hu Terrance Swift, David S. Warren 
Keyword: Parallel Logic Programming, Tabling, Table-parallelism, SLG, XSB.  
Address: NY 11794-4400  
Affiliation: Department of Computer Science State University of New York at Stony Brook Stony Brook,  
Abstract: SLG is a table-oriented resolution method that extends SLD evaluation in two ways. It computes the well-founded model for logic programs with negation with polynomial data complexity, and it terminates for programs with the bounded-term-size property. Furthermore SLG has an efficient sequential implementation for modularly stratified programs in the SLG-WAM of XSB. This paper addresses general issues involved in parallelizing tabled evaluations by introducing a model of shared-memory parallelism which we call table parallelism and by comparing it to traditional models of parallelizing SLD. A basic architecture for supporting table parallelism in the framework of the SLG-WAM is also presented, along with an algorithm for detecting termination of subcomputations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K.M. Ali and R. Karlsson. </author> <title> The Muse or-parallel Prolog model and its performance. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pages 757-776. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Aside from that, 4 An optimization is available for completed subgoals. ILPS'94: Design and Implementation of Parallel Logic Programming Systems 5 support for full Prolog can be provided by using standard techniques adopted by current or-parallel systems such as Muse <ref> [1] </ref> and Aurora [11]. A major advantage of parallel SLG over other parallel Prolog systems is the avoidance of redundant computation. In Figure 3, for instance, any or-parallel Prolog would have to compute the relation q (2; Y ) twice.
Reference: [2] <author> Krzysztof R. Apt. </author> <title> Correctness proofs of distributed termination algorithms. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(3):388 - 405, </volume> <month> July </month> <year> 1986. </year>
Reference: [3] <author> F. Banchilhon and R. Ramakrishnan. </author> <title> An amateur's introdution to recursive query processing strategies. </title> <booktitle> In Proc. of SIGMOD 1986 Conf., </booktitle> <pages> pages 16-52. </pages> <publisher> ACM, </publisher> <year> 1986. </year>
Reference: [4] <author> A.D. Birrel. </author> <title> An introduction to programming with threads. </title> <type> Technical report, </type> <institution> Digital Systems Research Center, Palo Alto, California, </institution> <year> 1989. </year>
Reference-contexts: For programs with high degree of table-parallelism, the number of active threads can be much larger than the number of actual processors. This would probably lead to a "slow down" if compared to the sequential execution, as most thread schedulers are slow at making general re-scheduling decisions <ref> [4] </ref>. In addition, most systems impose a limit on the number of threads that can be executing at a time. As a first approach, we will require the user to decide which predicates to execute in parallel. Future research, will investigate scheduling strategies to distribute work among threads.
Reference: [5] <author> R. Bol and L. Degerstedt. </author> <title> Tabulated resolution for the well-founded semantics. </title> <booktitle> In Proc. ILPS'93 Workshop on Programming with Logic Databases. </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Substantiation for this claim stems both from the asymptotic results of [14] and the experimental results of [17]. Tabling also appears to be relevant for computing the well-founded semantics: besides SLG, well-founded ordered search [15] and the tabulated resolution of <ref> [5] </ref> are two recent proposals which also use tabling. Due to the power of tabling, many approaches have been formulated for its implementation | indeed [12] cites dozens. Nearly all of these approaches are sequential, however. We propose an abstract model, called table-parallelism for parallelizing tabled evaluations.
Reference: [6] <author> W. Chen, T. Swift, and D.S. Warren. </author> <title> Efficient implementation of general logical queries. </title> <journal> J. Logic Programming. </journal> <note> To Appear. </note> <editor> ILPS'94: </editor> <booktitle> Design and Implementation of Parallel Logic Programming Systems 11 </booktitle>
Reference-contexts: The latter deficiency, that of repeating subcomputa-tions has given rise to many systems which table sub-computations: OLDT [18], and SLG-AL [19], and SLG fl Partially supported by CAPES-Brazil. y Supported by NSF grant CCR-9123200. z Partially supported by grants NSF CDA-9303181 and NSF CCR- 9102159. <ref> [7, 6] </ref> are three tabling methods which have been implemented. At an abstract level, systems which use magic evaluation can be thought of tabling systems as well. Substantiation for this claim stems both from the asymptotic results of [14] and the experimental results of [17]. <p> Whenever the system fails 3 The SLG-WAM described in [16] avoids the reunification of answer clauses in certain, but not all cases. over the root of an SCC, it is provable that each subgoal inside the component is completed and all answers have been generated (Details can be found in <ref> [6] </ref>). The strategy outlined above is unsuitable for parallel SLG, since active nodes for a particular tabled predicated might be in different threads. <p> To prevent improper completion, information about the P osLink values for these subgoals must be propagated to A before it can be completed. The characteristics of this propagation vary from the sequential to the parallel model (See <ref> [6] </ref> for the sequential case). We let P osM in (A) stand for the minimum P osLink value of all subgoals younger than A | information which is available from the completion stack. <p> The engine iterates steps 1 and 2 while there is work to do. 4. When there is no more work left, the thread sets StateF lag to done (AnswerF lag has been effec tively set to done) and sleeps. Under the formalism of <ref> [6] </ref> or [16], the following proposition can easily be proven. Proposition 4.1 (Parallel Completion) Let E be a computation in which Invariants 4.1 and 4.2 hold. Let DF N (S) = P osLink (S) = min (P osLink (A)) for all A younger than S on the completion stack.
Reference: [7] <author> W. Chen and D. S. Warren. </author> <title> Query evaluation under the well-founded semantics. </title> <booktitle> In Proc. of 12th PODS, </booktitle> <year> 1993. </year>
Reference-contexts: The latter deficiency, that of repeating subcomputa-tions has given rise to many systems which table sub-computations: OLDT [18], and SLG-AL [19], and SLG fl Partially supported by CAPES-Brazil. y Supported by NSF grant CCR-9123200. z Partially supported by grants NSF CDA-9303181 and NSF CCR- 9102159. <ref> [7, 6] </ref> are three tabling methods which have been implemented. At an abstract level, systems which use magic evaluation can be thought of tabling systems as well. Substantiation for this claim stems both from the asymptotic results of [14] and the experimental results of [17].
Reference: [8] <author> E.W. Dijks tra, W.H.J Feijen, and A.J.M. van Gasteren. </author> <title> Derivation of a termination detection algorithm for distributed computations. </title> <journal> Information Processing Letters, </journal> <pages> pages 217 - 219, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: While various approaches to this problem are possible, implementation of a workable engine requires a minimum of synchronization: accordingly we base our approach on distributed termination detection algorithms as in <ref> [8] </ref>. Section 2 introduced the shared completion stack, used to detect completion of an SCC. The completion stack consists of frames for each incomplete tabled subgoal. The frames are pushed onto the stack when the subgoals are called, and consist of the following elements. <p> The root will wrongly assume that r k is done, and it will incorrectly complete. Following the model of <ref> [8] </ref>, we address this problem by introducing another flag, the ColorF lag, for each tabled subgoal. Definition 4.1 (ColorFlag) The ColorF lag indicates that a node in the SCC may have generated new answers after another node was checked as completed by the root.
Reference: [9] <author> Nissim Francez. </author> <title> Program Verification. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference: [10] <author> Gupta,G., Ali,K.M., Carlsson,M., and M. Herme-negildo. </author> <title> Parallel Logic Programming: A Survey. </title> <type> Unpublished manuscript, </type> <pages> 55 pages. </pages> <note> Available by anonymous ftp at ftp.cs.nmsu.edu. </note>
Reference-contexts: Available threads would then steal work from this queue. Trailing and scheduling mechanisms of the SLG-WAM already support the context switching required for this method. One of the main goals of the parallel logic programming community is to exploit parallelism implicitly | including full Prolog with standard semantics <ref> [11, 10] </ref>. Prolog's implementation of SLD generates answer substitutions in textual order, but this notion does not exist in SLG, where the order of answer substitutions produced through clause resolution for generator nodes may not resemble the order produced by answer clause resolution with active (consuming) nodes.
Reference: [11] <author> E. Lusk, R. Butler, T. Disz, R. Olson, R. Over-beek, D.H.D. Warren, A. Calderwood, P. Szeredi, S. Haridi, P. Brand, M. Carlsson, A. Ciepielewski, and B. Hausman. </author> <title> The Aurora or-parallel Prolog system. </title> <journal> New Generation Computing, </journal> (7):243-271, 1990. 
Reference-contexts: Available threads would then steal work from this queue. Trailing and scheduling mechanisms of the SLG-WAM already support the context switching required for this method. One of the main goals of the parallel logic programming community is to exploit parallelism implicitly | including full Prolog with standard semantics <ref> [11, 10] </ref>. Prolog's implementation of SLD generates answer substitutions in textual order, but this notion does not exist in SLG, where the order of answer substitutions produced through clause resolution for generator nodes may not resemble the order produced by answer clause resolution with active (consuming) nodes. <p> Aside from that, 4 An optimization is available for completed subgoals. ILPS'94: Design and Implementation of Parallel Logic Programming Systems 5 support for full Prolog can be provided by using standard techniques adopted by current or-parallel systems such as Muse [1] and Aurora <ref> [11] </ref>. A major advantage of parallel SLG over other parallel Prolog systems is the avoidance of redundant computation. In Figure 3, for instance, any or-parallel Prolog would have to compute the relation q (2; Y ) twice.
Reference: [12] <author> R. Ramakrishnan and J. Ullman. </author> <title> A survey of research on deductive database systems. </title> <journal> Journal of Logic Programming, </journal> <note> 1994. To appear. </note>
Reference-contexts: Tabling also appears to be relevant for computing the well-founded semantics: besides SLG, well-founded ordered search [15] and the tabulated resolution of [5] are two recent proposals which also use tabling. Due to the power of tabling, many approaches have been formulated for its implementation | indeed <ref> [12] </ref> cites dozens. Nearly all of these approaches are sequential, however. We propose an abstract model, called table-parallelism for parallelizing tabled evaluations.
Reference: [13] <author> P. Rao, I.V. Ramakrishnan, T. Swift, and D.S. Warren. </author> <title> Dynamic argument reduction for in-memory queries. </title> <booktitle> In 2nd ICLP Workshop on Logic Programming and Deductive Databases, </booktitle> <year> 1994. </year>
Reference: [14] <author> H. Seki. </author> <title> On the power of alexandrer templates. </title> <booktitle> In Proc. of 8th PODS, </booktitle> <pages> pages 150-159. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: At an abstract level, systems which use magic evaluation can be thought of tabling systems as well. Substantiation for this claim stems both from the asymptotic results of <ref> [14] </ref> and the experimental results of [17]. Tabling also appears to be relevant for computing the well-founded semantics: besides SLG, well-founded ordered search [15] and the tabulated resolution of [5] are two recent proposals which also use tabling.
Reference: [15] <author> P. Stuckey and S. Sudarshan. </author> <title> Well-founded ordered search. </title> <booktitle> In 13th conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 161-172, </pages> <year> 1993. </year>
Reference-contexts: Substantiation for this claim stems both from the asymptotic results of [14] and the experimental results of [17]. Tabling also appears to be relevant for computing the well-founded semantics: besides SLG, well-founded ordered search <ref> [15] </ref> and the tabulated resolution of [5] are two recent proposals which also use tabling. Due to the power of tabling, many approaches have been formulated for its implementation | indeed [12] cites dozens. Nearly all of these approaches are sequential, however.
Reference: [16] <author> T. Swift and D. S. Warren. </author> <title> An abstract machine for SLG resolution: definite programs. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <year> 1994. </year> <note> To Appear. </note>
Reference-contexts: The table space will be kept in shared-memory, as will the completion stack, kept for determining when to complete an SLG-subgoal. At a broad level, the parallel SLG-WAM differs from its sequential counterpart <ref> [16] </ref> in that it decouples the return of answers from the scheduling of their resolution, and in its use of a more complicated completion algorithm 1 . <p> For in-memory queries, the SLG-WAM appears to be the fastest sequential tabling implementation currently available ([17]), and we believe its speed is due to its use of WAM-style Prolog compilation technology. This paper sketches a basic architecture for a shared-memory 1 The SLG-WAM as described in <ref> [16] </ref> uses a tuple-at-a-time strategy for resolving answers with subgoals. While this strategy is efficient for logic programming, an alternate semi-naive strategy, has also been implemented for executing calls to disk. parallel SLG-WAM for definite programs | an architecture whose implementation is currently under development. <p> Properties of a depth-first evaluation are also used to detect of completion of an SCC. The first subgoal of an SCC visited by a sequential evaluation is called the root of the SCC. Whenever the system fails 3 The SLG-WAM described in <ref> [16] </ref> avoids the reunification of answer clauses in certain, but not all cases. over the root of an SCC, it is provable that each subgoal inside the component is completed and all answers have been generated (Details can be found in [6]). <p> The engine iterates steps 1 and 2 while there is work to do. 4. When there is no more work left, the thread sets StateF lag to done (AnswerF lag has been effec tively set to done) and sleeps. Under the formalism of [6] or <ref> [16] </ref>, the following proposition can easily be proven. Proposition 4.1 (Parallel Completion) Let E be a computation in which Invariants 4.1 and 4.2 hold. Let DF N (S) = P osLink (S) = min (P osLink (A)) for all A younger than S on the completion stack. <p> While SLG-WAM instructions for definite programs have been presented in <ref> [16] </ref>, a detailed knowledge of these instructions is not needed to for understanding this section, since the changes mainly involve adding concurrency features to tabling operations. The changes are as follows: * When calling a tabled subgoal | in the new ac tive instruction. <p> For adding answers to the table, however, no locking will be necessary as there is a single generating thread for each subgoal (although possibly multiple consuming threads). The issue of returning new answers to existing sub-goals differs from the tuple-at-a-time method described in <ref> [16] </ref>, but resembles that of a sequential semi-naive implementation (to be described fully in a forthcoming paper). In the semi-naive implementation, an iteration consists of all work that occurs between failures back to the completion instruction for the root of an SCC.
Reference: [17] <author> T. Swift and D. S. Warren. </author> <title> Analysis of sequential SLG evaluation. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <year> 1994. </year> <note> To Appear. </note>
Reference-contexts: At an abstract level, systems which use magic evaluation can be thought of tabling systems as well. Substantiation for this claim stems both from the asymptotic results of [14] and the experimental results of <ref> [17] </ref>. Tabling also appears to be relevant for computing the well-founded semantics: besides SLG, well-founded ordered search [15] and the tabulated resolution of [5] are two recent proposals which also use tabling.
Reference: [18] <author> H. Tamaki and T. Sato. </author> <title> OLDT resolution with tabulation. </title> <booktitle> In Third Int'l Conf. on Logic Programming, </booktitle> <pages> pages 84-98, </pages> <year> 1986. </year>
Reference-contexts: Even without negation, SLD is susceptible to infinite loops and redundant subcomputations, making it unacceptable for deductive databases. The latter deficiency, that of repeating subcomputa-tions has given rise to many systems which table sub-computations: OLDT <ref> [18] </ref>, and SLG-AL [19], and SLG fl Partially supported by CAPES-Brazil. y Supported by NSF grant CCR-9123200. z Partially supported by grants NSF CDA-9303181 and NSF CCR- 9102159. [7, 6] are three tabling methods which have been implemented.
Reference: [19] <author> L. Vieille. </author> <title> Recursive query processing: The power of logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: Even without negation, SLD is susceptible to infinite loops and redundant subcomputations, making it unacceptable for deductive databases. The latter deficiency, that of repeating subcomputa-tions has given rise to many systems which table sub-computations: OLDT [18], and SLG-AL <ref> [19] </ref>, and SLG fl Partially supported by CAPES-Brazil. y Supported by NSF grant CCR-9123200. z Partially supported by grants NSF CDA-9303181 and NSF CCR- 9102159. [7, 6] are three tabling methods which have been implemented.
Reference: [20] <author> D.H.D. Warren. </author> <title> Or-parallel models of Prolog. </title> <booktitle> In Proceedings of the International Conference on Theory and Practice of Software Development. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: This avoidance of redundant computation has long been recognized as necessary for data-oriented queries. No less important is that SLG terminates for programs of bounded term size. The copying of a subgoal each time a thread is created was a drawback of the Abstract Model <ref> [20] </ref>. Tabling systems, however, require copying of subgoals whether they are sequential or not 5 . When used judiciously, tabling may greatly improve performance over SLD ([3, 17]), and copying does not add a particular overhead for the parallel version.
References-found: 20

