URL: http://www.icsi.berkeley.edu/PET/expcode.ps
Refering-URL: http://www.icsi.berkeley.edu/PET/nsf-index.html
Root-URL: http://www.icsi.berkeley.edu
Title: A Linear Time Erasure-Resilient Code With Nearly Optimal Recovery  
Author: Noga Alon Michael Luby 
Abstract: We develop an efficient scheme that produces an encoding of a given message such that the message can be decoded from any portion of the encoding that is approximately equal to the length of the message. More precisely, an (n; c; `; r)-erasure-resilient code consists of an encoding algorithm and a decoding algorithm with the following properties. The encoding algorithm produces a set of `-bit packets of total length cn from an n-bit message. The decoding algorithm is able to recover the message from any set of packets whose total length is r, i.e., from any set of r=` packets. We describe erasure-resilient codes where both the encoding and decoding algorithms run in linear time and where r is only slightly larger than n.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ajtai, J. Komlos, E. Szemeredi, </author> <title> "Deterministic Simulation in Logspace", </title> <booktitle> Proc. of the 19 th ACM Symp. on the Theory of Computing, </booktitle> <year> 1987, </year> <pages> pp. 132-140. </pages>
Reference-contexts: However, it is unlikely that using these methods in places where we use quadratic time MDS codes will be as efficient in practice. The construction in Section 4 can be improved by using walks in expanders instead of edges, using the methods of <ref> [1] </ref>. The relevance of this method to the case of expander based error correcting codes has been observed by us (cf. [15]), and a similar remark holds here also.
Reference: [2] <author> A. Albanese, J. Blomer, J. Edmonds, M. Luby, M. Sudan, </author> <title> "Priority Encoding Transmission", </title> <booktitle> Proc. of the 35 th Annual Symp. on Foundations of Computer Science, </booktitle> <year> 1994, </year> <pages> 604-612, </pages> <note> final version submitted to this issue. 11 </note>
Reference-contexts: Thus, it makes sense to protect real-time traffic sent through such networks against losses by adding a moderate level of redundancy using erasure-resilient codes. Algorithms based on this approach have been developed for applications such as multicasting real-time high-volume video information over lossy packet based networks <ref> [3, 2, 9] </ref> and other high volume real-time applications [14]. The two most important properties of erasure-resilient codes in these applications are the running times of the encoding and decoding algorithms and the amount of encoding sufficient to recover the message. <p> Standard Reed-Solomon codes can be used to implement quadratic time MDS codes. These methods have been customized to run in real-time for medium quality video transmission on existing workstations <ref> [3, 2] </ref>, i.e., at the rate of a few megabits per second, but high quality video sent at the rate of hundreds of megabits per second will require either better algorithms or custom designed hardware.
Reference: [3] <author> A. Albanese, J. Blomer, J. Edmonds, M. Luby, </author> <title> "Priority Encoding Transmission", </title> <type> ICSI Technical Report No. </type> <institution> TR-94-039, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: Thus, it makes sense to protect real-time traffic sent through such networks against losses by adding a moderate level of redundancy using erasure-resilient codes. Algorithms based on this approach have been developed for applications such as multicasting real-time high-volume video information over lossy packet based networks <ref> [3, 2, 9] </ref> and other high volume real-time applications [14]. The two most important properties of erasure-resilient codes in these applications are the running times of the encoding and decoding algorithms and the amount of encoding sufficient to recover the message. <p> Standard Reed-Solomon codes can be used to implement quadratic time MDS codes. These methods have been customized to run in real-time for medium quality video transmission on existing workstations <ref> [3, 2] </ref>, i.e., at the rate of a few megabits per second, but high quality video sent at the rate of hundreds of megabits per second will require either better algorithms or custom designed hardware.
Reference: [4] <author> N. Alon, J. Edmonds, M. Luby, </author> <title> "Linear Time Erasure Codes With Nearly Optimal Recovery", </title> <booktitle> Proc. of the 36 th Annual Symp. on Foundations of Computer Science, </booktitle> <year> 1995, </year> <pages> pp. 512-519. </pages>
Reference-contexts: This paper describes a new erasure-resilient code obtained by a deterministic scheme. A preliminary description of this scheme, together with descriptions of probabilistic schemes that are more efficient based on this scheme can be found in <ref> [4] </ref>. The scheme has the property that, on inputs n, c, and *, the run time of the (n; c)-code is O (n=* 4 ), it is (1 + *)-MDS, and the packet size is O ((1=* 4 ) log (1=*)).
Reference: [5] <author> N. Alon, J. Bruck, J. Naor, M. Naor, R. Roth, </author> <title> "Construction of asymptotically good, low-rate error-correcting codes through pseudo-random graphs", </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> Vol. 38, </volume> <year> 1992, </year> <pages> pp. 509-516. </pages>
Reference-contexts: Our scheme is based on the properties of expanders which are explicit 3 graphs with pseudo-random properties. The relevance of these graphs to error correcting codes has been observed in <ref> [5] </ref>, and indeed we apply some of the ideas of that paper. Erasure-resilient codes are related to error correcting codes, and are typically easier to design.
Reference: [6] <author> N. Alon, F. R. K. Chung, </author> <title> "Explicit construction of linear sized tolerant networks", </title> <journal> Discrete Math., </journal> <volume> Vol. 72, </volume> <year> 1988, </year> <pages> pp. </pages> <booktitle> 15-19; (Proc. of the First Japan Conference on Graph Theory and Applications, </booktitle> <address> Hakone, Japan, </address> <year> 1986.) </year>
Reference-contexts: It is not difficult to show that this assumption can be omitted. By [11], [12] the sequence of integers m for which there is a (d; 2 p expander on m nodes is a dense sequence. We need the following from <ref> [6] </ref>. Proposition 1 [6] The number of edges induced by any set of x nodes in a (d; )-graph on m nodes does not exceed 1 x (d m x )): Proof of Lemma 1: Fix an integer d, where 64 fl 02 &lt; d 128 = 2 d 1. <p> It is not difficult to show that this assumption can be omitted. By [11], [12] the sequence of integers m for which there is a (d; 2 p expander on m nodes is a dense sequence. We need the following from <ref> [6] </ref>. Proposition 1 [6] The number of edges induced by any set of x nodes in a (d; )-graph on m nodes does not exceed 1 x (d m x )): Proof of Lemma 1: Fix an integer d, where 64 fl 02 &lt; d 128 = 2 d 1. <p> Let I be any subset of V with jIj = (1+*)n c 0 ` . For each i 2 V , let d i denote the number of letters of E i that are in the packets indexed by I. By a lemma in <ref> [6] </ref> (see also [7], page 122), X (d i jIjc 0 ` 2 =N ) 2 2 jIj (1 jIj`=N ) 4c 0 `jIj 8n: (1) Note that jIjc 0 ` 2 N (1 + *)n` = 1 + fl Let M be the set of i 2 V for which
Reference: [7] <author> N. Alon, J. H. Spencer, </author> <title> The Probabilistic Method, </title> <publisher> Wiley, </publisher> <year> 1991. </year>
Reference-contexts: Let I be any subset of V with jIj = (1+*)n c 0 ` . For each i 2 V , let d i denote the number of letters of E i that are in the packets indexed by I. By a lemma in [6] (see also <ref> [7] </ref>, page 122), X (d i jIjc 0 ` 2 =N ) 2 2 jIj (1 jIj`=N ) 4c 0 `jIj 8n: (1) Note that jIjc 0 ` 2 N (1 + *)n` = 1 + fl Let M be the set of i 2 V for which the packets indexed
Reference: [8] <author> L. A. Bassalygo, V. V. Zyablov, M. S. Pinsker, </author> <title> "Problems in complexity in the theory of correcting codes", </title> <journal> Problems of information transmission, </journal> <volume> 13, Vol. 3, </volume> <year> 1977, </year> <pages> pp. 166-175. </pages>
Reference-contexts: Moreover, if the corresponding error correcting code has efficient encoding and decoding algorithms, then so does the resulting erasure-resilient code. The recent breakthrough result of Spielman [16] on error correcting codes is directly relevant to our scheme. Spielman applies the techniques in [15] and <ref> [8] </ref>, and constructs linear time error correcting codes with linear rate and linear minimum distance. This error correcting code stretches an n-bit message to a cn-bit message and can recover the message when up to bn of the encoding bits are flipped.
Reference: [9] <author> E. Biersack, </author> <title> "Performance evaluation of forward error correction in ATM networks", </title> <booktitle> Proc. of SIGCOMM '92, </booktitle> <address> Baltimore, </address> <year> 1992. </year>
Reference-contexts: Thus, it makes sense to protect real-time traffic sent through such networks against losses by adding a moderate level of redundancy using erasure-resilient codes. Algorithms based on this approach have been developed for applications such as multicasting real-time high-volume video information over lossy packet based networks <ref> [3, 2, 9] </ref> and other high volume real-time applications [14]. The two most important properties of erasure-resilient codes in these applications are the running times of the encoding and decoding algorithms and the amount of encoding sufficient to recover the message.
Reference: [10] <author> R. E. Blahut, </author> <title> Theory and Practice of Error Control Codes, </title> <publisher> Ad-dison Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: can be constructed based on evaluating and interpolating polynomials over specially chosen finite fields using Discrete Fourier Transform, but these methods are not competitive in practice with the simpler quadratic methods except for extremely large messages, and even then, their time complexity is at least (n log n), see, e.g., <ref> [10] </ref>, Chapter 11.7 and [13], p. 369. Thus, the design of highly efficient algorithms for implementing erasure-resilient codes is interesting theoretically and important for practical applications.
Reference: [11] <author> A. Lubotzky, R. Phillips, P. Sarnak, </author> <title> "Explicit expanders and the Ra-manujan conjectures", </title> <booktitle> Proc. of the 18 th ACM Symp. on the Theory of Computing, </booktitle> <year> 1986, </year> <pages> pp. </pages> <note> 240-246; (See also: </note> <author> A. Lubotzky, R. Phillips, P. Sarnak, </author> <title> "Ramanujan graphs", </title> <journal> Combinatorica, </journal> <volume> Vol. 8, </volume> <year> 1988, </year> <pages> pp. 261-277). </pages>
Reference-contexts: To simplify the presentation we assume here that there are sufficiently many expanders in these families whose number of nodes is divisible by any desired constant. It is not difficult to show that this assumption can be omitted. By <ref> [11] </ref>, [12] the sequence of integers m for which there is a (d; 2 p expander on m nodes is a dense sequence. We need the following from [6].
Reference: [12] <author> G. A. Margulis, </author> <title> "Explicit group-theoretical constructions of combinatorial schemes and their application to the design of expanders and su-perconcentrators" Problemy Peredachi Informatsii, </title> <journal> Vol. </journal> <volume> 24, </volume> <year> 1988, </year> <pages> pp. </pages> <booktitle> 51-60 (in Russian). (English translation in Problems of Information Transmission, </booktitle> <volume> Vol. 24, </volume> <year> 1988, </year> <pages> pp. 39-46). </pages>
Reference-contexts: To simplify the presentation we assume here that there are sufficiently many expanders in these families whose number of nodes is divisible by any desired constant. It is not difficult to show that this assumption can be omitted. By [11], <ref> [12] </ref> the sequence of integers m for which there is a (d; 2 p expander on m nodes is a dense sequence. We need the following from [6].
Reference: [13] <author> F. J. Macwilliams and N. J. A. Sloane, </author> <title> The Theory of Error-Correcting Codes, </title> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1977. </year> <month> 12 </month>
Reference-contexts: on evaluating and interpolating polynomials over specially chosen finite fields using Discrete Fourier Transform, but these methods are not competitive in practice with the simpler quadratic methods except for extremely large messages, and even then, their time complexity is at least (n log n), see, e.g., [10], Chapter 11.7 and <ref> [13] </ref>, p. 369. Thus, the design of highly efficient algorithms for implementing erasure-resilient codes is interesting theoretically and important for practical applications. Our scheme has the property that the code can be constructed for any message length n and encoded message length cn, where c &gt; 1.
Reference: [14] <author> M. Rabin, </author> <title> "Efficient Dispersal of Information for Security, Load Bal--ancing, and Fault Tolerance", </title> <journal> J. ACM, </journal> <volume> Vol. 36, No. 2, </volume> <month> April </month> <year> 1989, </year> <pages> pp. 335-348. </pages>
Reference-contexts: Algorithms based on this approach have been developed for applications such as multicasting real-time high-volume video information over lossy packet based networks [3, 2, 9] and other high volume real-time applications <ref> [14] </ref>. The two most important properties of erasure-resilient codes in these applications are the running times of the encoding and decoding algorithms and the amount of encoding sufficient to recover the message.
Reference: [15] <author> M. Sipser and D. Spielman, </author> <title> "Expander codes", </title> <booktitle> Proc. of the 35 th Annual Symp. on Foundations of Computer Science, </booktitle> <year> 1994, </year> <pages> 566-576. </pages>
Reference-contexts: Moreover, if the corresponding error correcting code has efficient encoding and decoding algorithms, then so does the resulting erasure-resilient code. The recent breakthrough result of Spielman [16] on error correcting codes is directly relevant to our scheme. Spielman applies the techniques in <ref> [15] </ref> and [8], and constructs linear time error correcting codes with linear rate and linear minimum distance. This error correcting code stretches an n-bit message to a cn-bit message and can recover the message when up to bn of the encoding bits are flipped. <p> The construction used in the proof of the above is similar to the one in <ref> [15] </ref>, and is based on properties of expanders. Definition (Expanders): A graph is called a (d; )-expander if it is d-regular and the absolute value of each of its nontrivial eigenvalues is at most . <p> The construction in Section 4 can be improved by using walks in expanders instead of edges, using the methods of [1]. The relevance of this method to the case of expander based error correcting codes has been observed by us (cf. <ref> [15] </ref>), and a similar remark holds here also.
Reference: [16] <author> D. </author> <title> Spielman, </title> <booktitle> "Linear-Time Encodable and Decodable Error-Correcting Codes" Proc. of the 27 th ACM Symp. on the Theory of Computing 1995, </booktitle> <publisher> ACM Press, </publisher> <pages> 388-397. 13 </pages>
Reference-contexts: Moreover, if the corresponding error correcting code has efficient encoding and decoding algorithms, then so does the resulting erasure-resilient code. The recent breakthrough result of Spielman <ref> [16] </ref> on error correcting codes is directly relevant to our scheme. Spielman applies the techniques in [15] and [8], and constructs linear time error correcting codes with linear rate and linear minimum distance. <p> This error correcting code stretches an n-bit message to a cn-bit message and can recover the message when up to bn of the encoding bits are flipped. Here, b &lt;< 1 and c 4 are absolute constants. A direct application of <ref> [16] </ref> to the design of an erasure-resilient code yields a linear time code that at best is (42b)-MDS. Thus, [16] cannot be used directly to yield an (1 + *)-MDS code for an arbitrary value of *. Nevertheless, [16] is a crucial ingredient in our construction. 2 Overview The input parameters <p> Here, b &lt;< 1 and c 4 are absolute constants. A direct application of <ref> [16] </ref> to the design of an erasure-resilient code yields a linear time code that at best is (42b)-MDS. Thus, [16] cannot be used directly to yield an (1 + *)-MDS code for an arbitrary value of *. Nevertheless, [16] is a crucial ingredient in our construction. 2 Overview The input parameters for the encoding and decoding algorithms are (n; c; *), where n is the number of letters in the <p> A direct application of <ref> [16] </ref> to the design of an erasure-resilient code yields a linear time code that at best is (42b)-MDS. Thus, [16] cannot be used directly to yield an (1 + *)-MDS code for an arbitrary value of *. Nevertheless, [16] is a crucial ingredient in our construction. 2 Overview The input parameters for the encoding and decoding algorithms are (n; c; *), where n is the number of letters in the message to be encoded (q = O (log (1=*)) is sufficient for the length of a letter). <p> This is done using expander graphs, as described in the next section. Next we apply the construction of <ref> [16] </ref> to stretch S 1 ; : : : ; S fl 0 n to S 1 ; : : : ; S fln , in a way that enables one to recover all of S 1 ; : : : ; S fl 0 n from any fln fin portion <p> The property of the first stage is that the entire message can be recovered from any n fin portion of the message given all of S 1 ; : : : ; S fl 0 n . The second stage directly uses the 5 constructions of Spielman <ref> [16] </ref> to stretch S 1 ; : : : ; S fl 0 n to S 1 ; : : : ; S fln . <p> This completes the proof. 3.2 Stage 2: A Spielman-like Construction We need the following result, which is an easy consequence of the main result of Spielman described in Theorem 12 in <ref> [16] </ref>. Proposition 2 [16] There is an absolute positive constant b so that for all m there is an explicit construction that maps messages of m letters into 4m letters so that: (i) The encoding time is O (m). (ii) If at most bm letters are missing then the original m <p> This completes the proof. 3.2 Stage 2: A Spielman-like Construction We need the following result, which is an easy consequence of the main result of Spielman described in Theorem 12 in <ref> [16] </ref>. Proposition 2 [16] There is an absolute positive constant b so that for all m there is an explicit construction that maps messages of m letters into 4m letters so that: (i) The encoding time is O (m). (ii) If at most bm letters are missing then the original m letters can be <p> The relevance of this method to the case of expander based error correcting codes has been observed by us (cf. [15]), and a similar remark holds here also. Combining our technique here with the methods of Spielman in <ref> [16] </ref> we can obtain explicit, linear time encodable and decodable error correcting codes over a large alphabet, whose rate and minimum distance in the range close to the MDS bound are close to optimal.
References-found: 16

