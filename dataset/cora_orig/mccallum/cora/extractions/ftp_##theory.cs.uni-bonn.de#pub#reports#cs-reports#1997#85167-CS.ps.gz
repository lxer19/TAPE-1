URL: ftp://theory.cs.uni-bonn.de/pub/reports/cs-reports/1997/85167-CS.ps.gz
Refering-URL: http://cs.uni-bonn.de/info5/publications/CS-1997-en.html
Root-URL: http://cs.uni-bonn.de
Email: e-mail: richter@cs.uni-bonn.de  
Title: A New Algorithm for the Ordered Tree Inclusion Problem  
Author: Thorsten Richter 
Date: May 31, 1997  
Address: Roemerstr. 164, 53117 Bonn, Germany  
Affiliation: Department of Computer Science IV, University of Bonn  
Abstract: In the problem of ordered tree inclusion two ordered labeled trees P and T are given, and the pattern tree P matches the target tree T at a node x, if there exists a one-to-one map f from the nodes of P to the nodes of T which preserves the labels, the ancestor relation and the left-to-right ordering of the nodes. In [12] Kilpelainen and Mannila give an algorithm that solves the problem of ordered tree inclusion in time and space fi(jP j jT j). In this paper we present a new algorithm for the ordered tree inclusion problem with time complexity O(j P jjT j+#matchesdepth(T )), where P is the alphabet of the labels of the pattern tree and #matches is the number of pairs (v; w) 2 P fi T with label(v) = label(w). The space complexity of our algorithm is O(j P j jT j + #matches). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Apostolico and C. Guerra, </author> <title> The Longest Common Subsequence Problem Revisited, </title> <journal> Algorithmica 2 (1987), pp. </journal> <volume> 315 - 336. </volume> <pages> 42 </pages>
Reference-contexts: The latter problem is an extension of the well known longest common subsequence problem (see [4], [5], <ref> [1] </ref> and [16], for example) to trees. Here one seeks for the largest common substructure of two ordered labeled trees T 1 and T 2 that can be obtained by deleting nodes from T 1 and T 2 in the sense of the tree editing problem.
Reference: [2] <author> M. Dubiner, Z. Galil and E. Magen, </author> <title> Faster Tree Pattern Matching, </title> <booktitle> Proc. 31st FOCS (1990), </booktitle> <pages> pp. 145 - 150. </pages>
Reference-contexts: 1 Introduction and Motivation The problem of ordered tree inclusion [11] can be seen as an extension of the classic problem of tree pattern matching [6], [14], <ref> [2] </ref>.
Reference: [3] <author> G. H. Gonnet and F. W. Tompa, </author> <title> Mind your Grammar aNew Approach to Text Databases, </title> <booktitle> Proc. of the Conf. on Very Large Databases 1987 (VLDB'87), </booktitle> <pages> pp. 339 - 346. </pages>
Reference-contexts: In Figure 1 an example of a parse tree of the sentence The professor feeds the well-behaved dog with fresh meat is given. Hence a structured text database can be realized as a collection of parse trees (see <ref> [3] </ref>, [9]). Then one can use tree inclusion as a means of retrieving information from documents stored in such a database [10]. Figure 2 gives an example of a query tree which can be used to retrieve information on what professors do with dogs.
Reference: [4] <author> D. S. Hirschberg, </author> <title> A Linear Space Algorithm for Computing Maximal Common Subsequences, </title> <booktitle> CACM 18 (1975), </booktitle> <pages> pp. 341 - 343. </pages>
Reference-contexts: The latter problem is an extension of the well known longest common subsequence problem (see <ref> [4] </ref>, [5], [1] and [16], for example) to trees. Here one seeks for the largest common substructure of two ordered labeled trees T 1 and T 2 that can be obtained by deleting nodes from T 1 and T 2 in the sense of the tree editing problem.
Reference: [5] <author> D. S. Hirschberg, </author> <title> Algorithms for the Longest Common Subsequence Problem, </title> <booktitle> JACM 24 (1977), </booktitle> <pages> pp. 664 - 675. </pages>
Reference-contexts: The latter problem is an extension of the well known longest common subsequence problem (see [4], <ref> [5] </ref>, [1] and [16], for example) to trees. Here one seeks for the largest common substructure of two ordered labeled trees T 1 and T 2 that can be obtained by deleting nodes from T 1 and T 2 in the sense of the tree editing problem.
Reference: [6] <author> C. M. Hoffman and M. J. O'Donnell, </author> <title> Pattern Matching in Trees, </title> <booktitle> JACM 29 (1982), </booktitle> <pages> pp. 68 - 95. </pages>
Reference-contexts: 1 Introduction and Motivation The problem of ordered tree inclusion [11] can be seen as an extension of the classic problem of tree pattern matching <ref> [6] </ref>, [14], [2].
Reference: [7] <author> J. E. Hopcroft and J. D. Ullman, </author> <title> Introduction to Automata Theory, Languages, and Computation, Chapter 4, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1979, </year> <pages> pp. 77 - 106. </pages>
Reference-contexts: Another formulation of this problem is given by Knuth in [13], Exercise 2.3.2-22. One motivation for considering the ordered tree inclusion problem and other tree inclusion problems comes from the concept of structured text databases. One can use context-free grammars (see <ref> [7] </ref>, for example) to describe the structure of natural language sentences in terms of their parse trees (see [19] for example). In Figure 1 an example of a parse tree of the sentence The professor feeds the well-behaved dog with fresh meat is given.
Reference: [8] <author> D. S. Johnson, </author> <title> The NP-completeness Column: An Ongoing Guide, </title> <editor> J. </editor> <booktitle> Algorithms 8 (1987), </booktitle> <pages> pp. 285 - 303. </pages>
Reference-contexts: Up to now, no better specialized algorithm for this problem is known. 3.4 The Minor Containment Problem The tree inclusion problem can be seen as a special case of the minor containment problem for graphs (see [17], <ref> [8] </ref>). In this problem two graph G and H are given, and the question is whether G contains H as a minor, i. e. whether G can be converted to H by a sequence of contractions of two adjacent nodes into a single new node.
Reference: [9] <author> P. Kilpelainen, G. Linden, H. Mannila and E. Nikunen, </author> <title> A Structured Document Database System, </title> <editor> in R. Furuta (ed.), </editor> <booktitle> EP'90 Proc. of the Int. Conf. on Electronic Publishing, Document Manipulation & Typography, The Cambridge Series on Electronic Publishing, </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: In Figure 1 an example of a parse tree of the sentence The professor feeds the well-behaved dog with fresh meat is given. Hence a structured text database can be realized as a collection of parse trees (see [3], <ref> [9] </ref>). Then one can use tree inclusion as a means of retrieving information from documents stored in such a database [10]. Figure 2 gives an example of a query tree which can be used to retrieve information on what professors do with dogs.
Reference: [10] <author> P. Kilpelainen and H. Mannila, </author> <title> Retrieval from Hierarchical Texts by Partial Patterns, </title> <editor> in R. Korfhage, E. Rasmussen and P. Willet (eds.), </editor> <booktitle> SIGIR '93 Proc. of the 16th Ann. Int. ACM SIGIR Conf. on Research and Development in Informational Retrieval 1993, </booktitle> <pages> pp. 214 - 222. </pages>
Reference-contexts: Hence a structured text database can be realized as a collection of parse trees (see [3], [9]). Then one can use tree inclusion as a means of retrieving information from documents stored in such a database <ref> [10] </ref>. Figure 2 gives an example of a query tree which can be used to retrieve information on what professors do with dogs. In reality the parse tree as well as the query tree could be augmented with some more linguistic information.
Reference: [11] <author> P. Kilpelainen and H. Mannila, </author> <title> Query Primitives for Tree-Structured Data, </title> <booktitle> Proc. 5th CPM (1994), </booktitle> <pages> pp. 213 - 225. </pages>
Reference-contexts: 1 Introduction and Motivation The problem of ordered tree inclusion <ref> [11] </ref> can be seen as an extension of the classic problem of tree pattern matching [6], [14], [2]. <p> In the ordered region inclusion problem the order condition is tightened by the sibling condition: v 1 is a sibling of v 2 () f (v 1 ) is a sibling of f (v 2 ). Both problems can be solved in time O (jP j jT j) <ref> [11] </ref>. Obviously we have: a solution of tree pattern matching is also a solution of ordered region inclusion; a solution of ordered region inclusion is also a solution of ordered path inclusion; and a solution of ordered path inclusion is also a solution of ordered tree inclusion. <p> Note that the reverse does not hold. There may be a solution of ordered tree inclusion even if there is no solution of tree pattern matching. In <ref> [11] </ref> a uniform treatment of tree inclusion problems is given. 3.2 The Tree Editing Problem The problem of ordered tree inclusion can also be seen as a special case of the tree editing problem [18], [20].
Reference: [12] <author> P. Kilpelainen and H. Mannila, </author> <title> Ordered and Unordered Tree Inclusion, </title> <journal> SIAM J. Com-put. </journal> <volume> 24 (1995), </volume> <pages> pp. 340 - 356. </pages>
Reference-contexts: S Q Q Q NP A A Det Noun The professor VP X X X X X X X X X X Verb feeds NP j Q Q Q Det Adj Noun the well-behaved dog PP @ @ Prep with NP A A Adj Noun fresh meat In <ref> [12] </ref> Kilpelainen and Mannila give an algorithm that solves the problem of ordered tree inclusion in time and space fi (jP j jT j). In that paper it is also shown that the tree inclusion problem becomes N P-complete when considering unordered trees. <p> This complexity beats the complexity of the algorithm of <ref> [12] </ref> if the number of matches is relatively small, i. e. #matches = o (jP j jT j = depth (T )). Furthermore, the time bound of our algorithm is not a tight one, but an upper bound. <p> This implies that minor containment is N P-complete also for rooted trees. In other words, tree inclu sion is N P-complete for unordered tree. In [15] a proof for the N P-completeness of the unordered tree inclusion is given which is independent of that in <ref> [12] </ref>. 4 The New Algorithm for the Ordered Tree Inclusion The input to our new algorithm OrderedTreeInclusion for the ordered tree inclusion problem consists of two ordered labeled trees, the pattern tree P = (V P ; E P ) and the target tree T = (V T ; E T
Reference: [13] <author> D. E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol. 1, </volume> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1969, </year> <note> p. 347. </note>
Reference-contexts: Another formulation of this problem is given by Knuth in <ref> [13] </ref>, Exercise 2.3.2-22. One motivation for considering the ordered tree inclusion problem and other tree inclusion problems comes from the concept of structured text databases.
Reference: [14] <author> S. R. Kosaraju, </author> <title> Efficient Tree Pattern Matching, </title> <booktitle> Proc. 30th FOCS (1989), </booktitle> <pages> pp. 178 - 183. </pages>
Reference-contexts: 1 Introduction and Motivation The problem of ordered tree inclusion [11] can be seen as an extension of the classic problem of tree pattern matching [6], <ref> [14] </ref>, [2].
Reference: [15] <author> J. Matousek and R. Thomas, </author> <title> On the Complexity of Finding Iso- and Other Morphisms for Partial k-Trees, </title> <booktitle> Discrete Mathematics 108 (1992), </booktitle> <pages> pp. 343 - 364. </pages>
Reference-contexts: This problem is known to be N P-complete even when restricted to trees. This implies that minor containment is N P-complete also for rooted trees. In other words, tree inclu sion is N P-complete for unordered tree. In <ref> [15] </ref> a proof for the N P-completeness of the unordered tree inclusion is given which is independent of that in [12]. 4 The New Algorithm for the Ordered Tree Inclusion The input to our new algorithm OrderedTreeInclusion for the ordered tree inclusion problem consists of two ordered labeled trees, the pattern
Reference: [16] <author> C. Rick, </author> <title> A New Flexible Algorithm for the Longest Common Subsequence Problem, </title> <journal> Nordic J. Comput. </journal> <volume> 2 (1995), </volume> <pages> pp. 444 - 461. </pages>
Reference-contexts: The latter problem is an extension of the well known longest common subsequence problem (see [4], [5], [1] and <ref> [16] </ref>, for example) to trees. Here one seeks for the largest common substructure of two ordered labeled trees T 1 and T 2 that can be obtained by deleting nodes from T 1 and T 2 in the sense of the tree editing problem.
Reference: [17] <author> N. Robertson and P. D. Seymor, </author> <title> Graph Minors. II. Algorithmic Aspects of Tree-Width, </title> <editor> J. </editor> <booktitle> Algorithms 7 (1986), </booktitle> <pages> pp. 309 - 322. </pages>
Reference-contexts: Up to now, no better specialized algorithm for this problem is known. 3.4 The Minor Containment Problem The tree inclusion problem can be seen as a special case of the minor containment problem for graphs (see <ref> [17] </ref>, [8]). In this problem two graph G and H are given, and the question is whether G contains H as a minor, i. e. whether G can be converted to H by a sequence of contractions of two adjacent nodes into a single new node.
Reference: [18] <author> K.-C. Tai, </author> <title> The Tree-to-Tree Correction Problem, </title> <journal> JACM 26 (1979), pp. </journal> <volume> 422 - 433. </volume> <pages> 43 </pages>
Reference-contexts: In [11] a uniform treatment of tree inclusion problems is given. 3.2 The Tree Editing Problem The problem of ordered tree inclusion can also be seen as a special case of the tree editing problem <ref> [18] </ref>, [20].
Reference: [19] <author> T. Winograd, </author> <title> Language as a Cognitive Process, Vol. 1: Syntax, Chapter 3, </title> <publisher> Addison--Wesley, </publisher> <address> Reading, MA, </address> <year> 1983, </year> <pages> pp. 72 - 132. </pages>
Reference-contexts: One motivation for considering the ordered tree inclusion problem and other tree inclusion problems comes from the concept of structured text databases. One can use context-free grammars (see [7], for example) to describe the structure of natural language sentences in terms of their parse trees (see <ref> [19] </ref> for example). In Figure 1 an example of a parse tree of the sentence The professor feeds the well-behaved dog with fresh meat is given. Hence a structured text database can be realized as a collection of parse trees (see [3], [9]).
Reference: [20] <author> K. Zhang and D. Shasha, </author> <title> Simple Fast Algorithms for the Editing Distance between Trees and Related Problems, </title> <journal> SIAM J. Comput. </journal> <volume> 18 (1989), </volume> <pages> pp. 1245 - 1262. 44 </pages>
Reference-contexts: In [11] a uniform treatment of tree inclusion problems is given. 3.2 The Tree Editing Problem The problem of ordered tree inclusion can also be seen as a special case of the tree editing problem [18], <ref> [20] </ref>. <p> With the algorithm of Zhang and Shasha <ref> [20] </ref> for the tree editing problem we have an algorithm for ordered tree inclusion with time complexity O (jP j jT j minfdepth (P ); leaves (P )g minfdepth (T ); leaves (P )g). <p> Finally we would like to attack the largest common substructure problem in order to beat the complexity resulting from the application of the algorithm of <ref> [20] </ref> for the tree editing problem to this problem. Acknowledgement. I would like to thank Prof. Dr. N. Blum for helpful discussions on this work.
References-found: 20

