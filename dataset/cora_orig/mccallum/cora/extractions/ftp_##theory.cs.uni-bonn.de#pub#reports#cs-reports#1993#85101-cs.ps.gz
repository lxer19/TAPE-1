URL: ftp://theory.cs.uni-bonn.de/pub/reports/cs-reports/1993/85101-cs.ps.gz
Refering-URL: http://cs.uni-bonn.de/info5/publications/CS-1993-en.html
Root-URL: http://cs.uni-bonn.de
Title: Alphabet-Independent Optimal Parallel Search for Three Dimensional Patterns approach is simplicity of dealing with three
Author: Marek Karpinski Wojciech Rytter 
Note: However the basic advantage of the DBF  
Affiliation: Department of Computer Science, University of Bonn  Institute of Informatics, Warsaw University  
Abstract: We give an alphabet-independent optimal parallel algorithm for the searching phase of three-dimensional pattern-matching. All occurrences of a three dimensional pattern P of shape mfimfim in a text T of shape n fi n fi n are to be found. Our algorithm works in log m time with O(N= log(m)) processors of a CREW PRAM, where N = n 3 . The ideas from [3] are used. Surprisingly, the extension of the two dimensional matching to the three dimensional one is not a trivial modification. The searching phase in three dimensions explores classification of two-dimensional periodicities of the cubic pattern. Some projection techniques are developed to deal with three dimensions. The periodicites of the patern with respect to its faces are investigated. The nonperiodicities imply some sparseness properties, while periodicities imply other special useful properties (i.e. monotonicity) of the set of occurrences. Both types of properties are useful in deriving an efficient algorithm. The search phase is preceeded by the preprocessing phase (computation of the witness table). Our main results concern the searching phase, however we present shortly a new approach to the second phase also. Usefullness of the dictionaries of basic factors (DBF 's), see [7], in the computation of the three dimensional witness table is presented. The DBF approach gains simplicity at the expense of a small increase in time. It gives a (nonoptimal) O(log(m)) time algorithm using m processors of a CRCW PRAM. The alphabet-independent optimal preprocessing is very complex even in the case of two dimensions, see [9]. For large alphabets the DBF 's give assymptotically the same complexity as the (alphabet-dependent) suffix trees approach (but avoids suffix trees and is simpler). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Amir, G. Benson. </author> <title> Two dimensional periodicity in rectangular arrays. </title> <booktitle> SODA'92, </booktitle> <pages> 440-452 </pages>
Reference-contexts: Proof: Define to be row-monotonic if the weights of points in are increasing in each row or are decreasing in each row of H. Analogously define column-monotonicity of . If the two-dimensional pattern is line- or radiant-periodc then it is known, see <ref> [1] </ref>, that any set of consitent candidates in the 2D-text is monotonic in an unweighted-sense. this means that one of the coordinates is a monotonic function of the second one. Such property holds for all faces orthogonal to H. The successive points are at agrowing or decreasing distance from H.
Reference: [2] <author> A. Amir, G. Benson, M. Farach. </author> <title> Alphabet independent two dimensional matching. </title> <booktitle> STOC'92, </booktitle> <pages> 59-68. </pages>
Reference-contexts: The main role of the preprocessing is the computation of the so called witness table (defined later). Let be the underlying alphabet. In two dimensions there are two approaches to compute this table efficiently: use the suffix trees (see <ref> [2] </ref>), which is a factor log jj slower than linear time, and the linear time alphabet independent algorithms of [9] and [6]. The alphabet independent algorithms are extremely complicated. They would be even more complicated in three dimensions. <p> In the three dimensional case the DBF works in much simpler way as the suffix trees approach. In the paper we concentrate mostly on the first phase of the pattern-matching: the searching phase. Amir, Benson and Farah were the first to give alphabet-independent linear time searching phase, see <ref> [2] </ref>. They have also given in [3] an alphabet-independent searching in logM time with O (M= log (M )) processors of a CREW PRAM. We refer to the latter algorithm as the algorithm ABF . The algorithm ABF needs only the witness table from the preprocessing phase. <p> We say also that P has a given (one of four) periodicity type w.r.t. face H. We emphasize that we consider global periods, so the period w.r.t. H is parallel to H but works globally in the cube P . We refer to <ref> [2] </ref> for definitions of periodicity types. Our three dimensional matching uses in essential way the classification of 2 (two-dimensional) periodicities of the pattern cube P with respect to its faces. 2 An alphabet-independent optimal parallel algorithm for the searching phase. <p> It has to be done in each window independently. The reduction to the unary case works in three dimensions essentially in the same way as in two dimensions, see <ref> [2] </ref>. Each position in the text "finds" any element of CAN D which "covers" this position. The important point is that any covering position represents all such positions due to consistency. <p> The witness table is used. If ff is a period then we know that x and y are consistent. We refer the reader to <ref> [2] </ref> for the details about the duelling. The rough idea how to construct CAN D is: start with C = W , then use more and more duels to reduce the size of C, if no duel kills any element of C then C is the required set CAN D.
Reference: [3] <author> A. Amir, G. Benson, M. Farach. </author> <title> Parallel two dimensional matching in logarithmic time. </title> <booktitle> SPAA'93, </booktitle> <pages> 79-85. </pages>
Reference-contexts: In the paper we concentrate mostly on the first phase of the pattern-matching: the searching phase. Amir, Benson and Farah were the first to give alphabet-independent linear time searching phase, see [2]. They have also given in <ref> [3] </ref> an alphabet-independent searching in logM time with O (M= log (M )) processors of a CREW PRAM. We refer to the latter algorithm as the algorithm ABF . The algorithm ABF needs only the witness table from the preprocessing phase.
Reference: [4] <author> T .J. Baker. </author> <title> A technique for extending rapid exact-match string matching to arrays of more than one dimension. </title> <journal> SIAM J. Comp. </journal> <month> 7 </month> <year> (1978) </year> <month> 533-541. </month>
Reference: [5] <author> R. S. Bird. </author> <title> Two dimensional pattern matching. </title> <journal> Inf. </journal> <note> Proc. letters 6, (1977) 168-170. 8 </note>
Reference: [6] <author> R. Cole, M. Crochemore, Z. Galil, L. Gasieniec, R. Hariharan, S. Muthukrishnan, K. Park, W. Rytter. </author> <title> Optimally fast parallel algorithms for preprocessing and pattern matching in one and two dimensions. </title> <publisher> FOCS'93. </publisher>
Reference-contexts: Let be the underlying alphabet. In two dimensions there are two approaches to compute this table efficiently: use the suffix trees (see [2]), which is a factor log jj slower than linear time, and the linear time alphabet independent algorithms of [9] and <ref> [6] </ref>. The alphabet independent algorithms are extremely complicated. They would be even more complicated in three dimensions. On the other hand if is large then we can replace log jj by log m. We show a simple approach through the dictionary of basic factors (DBF, in short). <p> We refer to the latter algorithm as the algorithm ABF . The algorithm ABF needs only the witness table from the preprocessing phase. An O (1) time optimal algorithm was given recently in <ref> [6] </ref>, however it needs additional data structure from the preprocessing phase: so called deterministic sample. The basic precomputed data structure needed in our algorithm is (similarly as in the algorithm ABF) the witness table W IT . The entries of W IT correspond to vectors (potential periods).
Reference: [7] <author> M. Crochemore, W. Rytter. </author> <title> Usefullness of the Karp-Miller-Rosenberg algorithm in parallel computations on strings and arrays. </title> <note> Theoretical Computer Science 88 (1991) 59-62. </note>
Reference-contexts: We show a simple approach through the dictionary of basic factors (DBF, in short). This is a useful data structure introduced in [12]. It has received the name DBF and its usefulness in string algorithms was shown in <ref> [7] </ref>. The advantage of the DBF is that it can be very easily extended to the three dimensional situation. For large alphabets the complexity of the DBF approach is not inferior to that of the sufix trees. <p> The names are integers in the range 1 : : : jSj and two words of the same length are equal (as strings) if and only if their names are the same. The following fact was shown in <ref> [7] </ref>. Lemma 3.1 DBF (S) can be computed in log jSj time with O (jSj) processors of a CRCW PRAM.
Reference: [8] <author> Z. Galil. </author> <title> Optimal parallel algorithms for string matching. </title> <note> Information and Control 67 (1985) 144-157. </note>
Reference-contexts: Proof: We can decompose the cube P into smaller subcubes if P is 1D-periodic. These smaller subcubes will be 1D-nonperiodic. The same argument as reducing periodic to nonperiodic case in one dimensional matching can be applied, see <ref> [8] </ref>. We omit the details. 2 Recall that by short vectors we mean vectors whose size is at most c m. Let us partition the whole text array T into cubic windows, each of the same shape c m fi c m fi c m.
Reference: [9] <author> Z. Galil, K. Park. </author> <title> Truly alphabet independent two dimensional matching. </title> <booktitle> FOCS'92, </booktitle> <year> (1992) </year> <month> 247-256. </month>
Reference-contexts: Let be the underlying alphabet. In two dimensions there are two approaches to compute this table efficiently: use the suffix trees (see [2]), which is a factor log jj slower than linear time, and the linear time alphabet independent algorithms of <ref> [9] </ref> and [6]. The alphabet independent algorithms are extremely complicated. They would be even more complicated in three dimensions. On the other hand if is large then we can replace log jj by log m. We show a simple approach through the dictionary of basic factors (DBF, in short).
Reference: [10] <author> Z. Kedem, G. Landau, K. Palem. </author> <title> Optimal parallel prefix-suffix matching algorithm and application. </title> <month> SPAA'89 </month> <year> (1989) </year> <month> 388-398. </month>
Reference: [11] <author> R. Karp, R. Miller, A. Rosenberg. </author> <title> Rapid identification of repeated patterns in strings, trees and arrays. </title> <month> STOC'72 </month> <year> (1972) </year> <month> 125-136. </month>
Reference: [12] <author> R. Karp, M. O. Rabin. </author> <title> Efficient randomized pattern matching algorithms. </title> <journal> IBM Journal of Res. and Dev. </journal> <month> 31 </month> <year> (1987) </year> <month> 249-260. </month>
Reference-contexts: They would be even more complicated in three dimensions. On the other hand if is large then we can replace log jj by log m. We show a simple approach through the dictionary of basic factors (DBF, in short). This is a useful data structure introduced in <ref> [12] </ref>. It has received the name DBF and its usefulness in string algorithms was shown in [7]. The advantage of the DBF is that it can be very easily extended to the three dimensional situation.

References-found: 12

