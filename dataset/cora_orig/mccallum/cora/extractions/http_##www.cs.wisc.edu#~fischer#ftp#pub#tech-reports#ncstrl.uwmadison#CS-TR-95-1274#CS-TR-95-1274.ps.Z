URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1274/CS-TR-95-1274.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1274/
Root-URL: http://www.cs.wisc.edu
Email: fhellers, naughtong@cs.wisc.edu, avi@cs.berkeley.edu  
Title: Generalized Search Trees for Database Systems  
Author: Joseph M. Hellerstein, Jeffrey F. Naughton, Avi Pfeffer 
Date: June, 1995  
Abstract: This paper introduces the Generalized Search Tree (GiST), an index structure supporting an extensible set of queries and data types. The GiST allows new data types to be indexed in a manner supporting queries natural to the types; this is in contrast to previous work on tree extensibility which only supported the traditional set of equality and range predicates. In a single data structure, the GiST provides all the basic search tree logic required by a database system, thereby unifying disparate structures such as B+-trees and R-trees in a single piece of code, and opening the application of search trees to general extensibility. To illustrate the flexibility of the GiST, we provide simple method implementations that allow it to behave like a B+-tree, an R-tree, and an RD-tree, a new index for data with set-valued attributes. We also present a preliminary performance analysis of RD-trees, which leads to discussion on the nature of tree indices and how they behave for various datasets.
Abstract-found: 1
Intro-found: 1
Reference: [Aok91] <author> P. M. Aoki. </author> <title> Implementation of Extended Indexes in POSTGRES. </title> <journal> SIGIR Forum, </journal> <volume> 25(1) </volume> <pages> 2-9, </pages> <year> 1991. </year>
Reference-contexts: Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data. Extensible-key indices were introduced in POSTGRES <ref> [Sto86, Aok91] </ref>, and are included in Illustra [Sto93], both of which have distinct extensible B+-tree and R-tree implementations. These extensible indices allow many types of data to be indexed, but only support a fixed set of query predicates.
Reference: [Ben79] <author> J. L. Bentley. </author> <title> Multidimensional Binary Search Trees in Database Applications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(4):339-353, </volume> <month> July </month> <year> 1979. </year>
Reference-contexts: More efficient schemes may be used for particular domains. For example, in ordered domains the appropriate entries on a node may be found via binary search. Another example is the hB-tree, in which the entries on a node are themselves indexed via a k-d tree <ref> [Ben79] </ref>, which is used for finding the appropriate entries on the node. Many alternative optimizations may exist, depending on the domain of the key predicates. To facilitate these techniques, additional extensibility in the GiST may optionally be leveraged for high performance.
Reference: [BKS94] <author> Douglas Banks, Marcel Kornacker, and Michael Stonebraker. </author> <title> High Concurrency Locking in R-Trees. </title> <type> Technical Report Sequoia 2000 94/56, </type> <institution> University of California, Berkeley, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: Fortunately, recent work extends Lehman and Yao's sideways pointer techniques, along with recovery techniques, to R-trees. Ng and Kameda [NK94] do so by generating a pending update list at each node of the tree, and applying Lomet and Salzberg's results on -trees to this context. Banks, Kornacker and Stonebraker <ref> [BKS94, KB95] </ref> have a simpler solution that marks keys and nodes with sequence numbers, and uses the sequence numbers to determine order among the nodes. Both approaches provide solutions for degree-3 consistency | Ng and Kameda via aborting transactions that read phantoms, and Banks, et al. via predicate locking.
Reference: [BKSS90] <author> Norbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, and Bernhard Seeger. </author> <title> The R*-tree: An Efficient and Robust Access Method For Points and Rectangles. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Atlantic City, </address> <month> May </month> <year> 1990, </year> <pages> pages 322-331. </pages>
Reference-contexts: There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*-trees <ref> [BKSS90] </ref> and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data. <p> This metric of "change in area" is the one proposed by Guttman [Gut84]. * PickSplit (P ) A variety of algorithms have been proposed for R-tree splitting. We thus omit this method implementation from our discussion here, and refer the interested reader to [Gut84] and <ref> [BKSS90] </ref>. The above implementations, along with the GiST algorithms described in the previous chapters, give behavior identical to that of Guttman's R-tree. A series of variations on R-trees have been proposed, notably the R*-tree [BKSS90] and the R+-tree [SRF87]. <p> omit this method implementation from our discussion here, and refer the interested reader to [Gut84] and <ref> [BKSS90] </ref>. The above implementations, along with the GiST algorithms described in the previous chapters, give behavior identical to that of Guttman's R-tree. A series of variations on R-trees have been proposed, notably the R*-tree [BKSS90] and the R+-tree [SRF87]. The R*-tree differs from the basic R-tree in three ways: in its PickSplit algorithm, which has a variety of small changes, in its ChooseSubtree algorithm, which varies only slightly, and in its policy of reinserting a number of keys during node split. <p> The old key may be unacceptably general though, and it is advisable to search for a more specific key that is small enough to fit. The first solution has the advantage of being flexible, and potentially improving the performance of the tree through refined data placement <ref> [BKSS90] </ref>. It may require some modifications to the concurrency control techniques described in the previous section. The second solution, while simpler, presents the problem of finding a good key that requires sufficiently little storage.
Reference: [BKSS94] <author> Thomas Brinkhoff, Hans-Peter Kriegel, Ralf Schneider, and Bernhard Seeger. </author> <title> Multi-Step Processing of Spatial Joins. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Minneapolis, </address> <month> May </month> <year> 1994, </year> <pages> pages 197-208. </pages>
Reference-contexts: For example, consider a 3-d R-tree index over the dataset corresponding to a plate of spaghetti: although no single spaghetto intersects any other in three dimensions, their bounding boxes will likely all intersect! 3 Better approximations than bounding boxes have been considered for doing spatial joins <ref> [BKSS94] </ref>. However, this work proposes using bounding boxes in an R*-tree, and only using the more accurate approximations in main memory during post-processing steps. 15 The two performance issues described above are displayed as a graph in Figure 2.
Reference: [CDF + 94] <author> Michael J. Carey, David J. DeWitt, Michael J. Franklin, Nancy E. Hall, Mark L. McAuliffe, Jeffrey F. Naughton, Daniel T. Schuh, Marvin H. Solomon, C. K. Tan, Odysseas G. Tsatalos, Seth J. White, and Michael J. Zwilling. </author> <title> Shoring Up Persistent Applications. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Minneapolis, </address> <month> May </month> <year> 1994, </year> <pages> pages 383-394. </pages>
Reference-contexts: Implementing a new set of methods for the GiST is a significantly easier task than implementing a new tree package from scratch: for example, the POSTGRES [Gro94] and SHORE <ref> [CDF + 94] </ref> implementations of R-trees and B+-trees are on the order of 3000 lines of C or C++ code each, while our method implementations for the GiST are on the order of 500 lines of C code each.
Reference: [CDG + 90] <author> M.J. Carey, D.J. DeWitt, G. Graefe, D.M. Haight, J.E. Richardson, D.H. Schuh, E.J. Shekita, </author> <title> and S.L. Vandenberg. The EXODUS Extensible DBMS Project: An Overview. </title> <editor> In Stan Zdonik and David Maier, editors, </editor> <booktitle> Readings In Object-Oriented Database Systems. </booktitle> <publisher> Morgan-Kaufmann Publishers, Inc., </publisher> <year> 1990. </year>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees [WE80], k-D-B-trees [Rob81], Ch-trees [KKD89], Exodus large objects <ref> [CDG + 90] </ref>, hB-trees [LS90], V-trees [MCD94], TV-trees [LJF94], etc.
Reference: [Com79] <author> Douglas Comer. </author> <title> The Ubiquitous B-Tree. </title> <journal> Computing Surveys, </journal> <volume> 11(2) </volume> <pages> 121-137, </pages> <month> June </month> <year> 1979. </year>
Reference-contexts: 1 Introduction An efficient implementation of search trees is crucial for any database system. In traditional relational systems, B+-trees <ref> [Com79] </ref> were sufficient for the sorts of queries posed on the usual set of alphanumeric data types. Today, database systems are increasingly being deployed to support new applications such as geographic information systems, multimedia systems, CAD tools, document libraries, sequence databases, fingerprint identification systems, biochemical databases, etc. <p> Section 7 concludes with a discussion of the significance of the work, and directions for further research. 1.2 Related Work A good survey of search trees is provided by Knuth [Knu73], though B-trees and their variants are covered in more detail by Comer <ref> [Com79] </ref>. There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*-trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. <p> This is the technique used in SHORE's R-trees, for example, which upon insertion take a polygon and compress it to its bounding box, which is itself a valid polygon. It is also used in prefix B+-trees <ref> [Com79] </ref>, which truncate split keys to an initial substring. More involved implementations might use complex methods for both Compress and Decompress. 3.4 Tree Methods The key methods in the previous section must be provided by the designer of the key class.
Reference: [FB74] <author> R. A. Finkel and J. L. Bentley. Quad-Trees: </author> <title> A Data Structure For Retrieval On Composite Keys. </title> <journal> ACTA Informatica, </journal> <volume> 4(1) </volume> <pages> 1-9, </pages> <year> 1974. </year>
Reference-contexts: There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*-trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees <ref> [FB74] </ref>, k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data.
Reference: [FK94] <author> Christos Faloutsos and Ibrahim Kamel. </author> <title> Beyond Uniformity and Independence: Analysis of R-trees Using the Concept of Fractal Dimension. </title> <booktitle> In Proc. 13th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 4-13, </pages> <address> Minneapolis, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Predicate Trees are used to generate hash keys. A even more limited notion is that of the Interval Hierarchy [WE77], which can be used to index a file of simple conjunctive ordering predicates. Analyses of R-tree performance have appeared in <ref> [FK94] </ref> and [PSTW93]. This work is dependent on the spatial nature of typical R-tree data, and thus is not generally applicable to the GiST. <p> Currently such estimates are reasonably accurate for B+-trees, and less so for R-trees. Recently, some work on R-tree cost estimation has been done <ref> [FK94] </ref>, but more work is required to bring this to bear on GiSTs in general. As an additional problem, the user-defined GiST methods may be time-consuming operations, and their CPU cost should be registered with the optimizer [HS93].
Reference: [Gro94] <institution> The POSTGRES Group. </institution> <note> POSTGRES Reference Manual, Version 4.2. Technical Report M92/85, </note> <institution> Electronics Research Laboratory, University of California, Berkeley, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: Implementing a new set of methods for the GiST is a significantly easier task than implementing a new tree package from scratch: for example, the POSTGRES <ref> [Gro94] </ref> and SHORE [CDF + 94] implementations of R-trees and B+-trees are on the order of 3000 lines of C or C++ code each, while our method implementations for the GiST are on the order of 500 lines of C code each. <p> For example, POSTGRES B+-trees support the usual ordering predicates (&lt;; ; =; ; &gt;), while POSTGRES R-trees support only the predicates Left, Right, OverLeft, Overlap, OverRight, Right, Contains, Contained and Equal <ref> [Gro94] </ref>. Extensible R-trees actually provide a sizable subset of the GiST's functionality. To our knowledge this paper represents the first demonstration that R-trees can index data that has not been mapped into a spatial domain.
Reference: [Gut84] <author> Antonin Guttman. R-Trees: </author> <title> A Dynamic Index Structure For Spatial Searching. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Boston, </address> <month> June </month> <year> 1984, </year> <pages> pages 47-57. 21 </pages>
Reference-contexts: This requirement has motivated two major research approaches in extending search tree technology: 1. Specialized Search Trees: A large variety of search trees has been developed to solve specific problems. Among the best known of these trees are spatial search trees such as R-trees <ref> [Gut84] </ref>. While some of this work has had significant impact in particular domains, the approach of developing domain-specific search trees is problematic. The effort required to implement and maintain such data structures is high. <p> There are a variety of multidimensional search trees, such as R-trees <ref> [Gut84] </ref> and their variants: R*-trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data. <p> For example, Penalty for keys from R 2 can be defined as area (Union (E 1 ; E 2 )) area (E 1 :p 1 ) <ref> [Gut84] </ref>. 5 * PickSplit (P ): given a set P of M + 1 entries (p; ptr), splits P into two sets of entries P 1 ; P 2 , each of size at least kM . The choice of the minimum fill factor for a tree is controlled here. <p> This metric of "change in area" is the one proposed by Guttman <ref> [Gut84] </ref>. * PickSplit (P ) A variety of algorithms have been proposed for R-tree splitting. We thus omit this method implementation from our discussion here, and refer the interested reader to [Gut84] and [BKSS90]. <p> This metric of "change in area" is the one proposed by Guttman <ref> [Gut84] </ref>. * PickSplit (P ) A variety of algorithms have been proposed for R-tree splitting. We thus omit this method implementation from our discussion here, and refer the interested reader to [Gut84] and [BKSS90]. The above implementations, along with the GiST algorithms described in the previous chapters, give behavior identical to that of Guttman's R-tree. A series of variations on R-trees have been proposed, notably the R*-tree [BKSS90] and the R+-tree [SRF87]. <p> Alternatively, return the change in a weighted cardinality, where each element of Z has a weight, and jSj is the sum of the weights of the elements in S. 14 * PickSplit (P ) Guttman's quadratic algorithm for R-tree split works naturally here. The reader is referred to <ref> [Gut84] </ref> for details. This GiST supports the usual R-tree query predicates, has containment keys, and uses a traditional R-tree algorithm for PickSplit. As a result, we were able to implement these methods in Illustra's extensible R-trees, and get behavior identical to what the GiST behavior would be.
Reference: [HP94] <author> Joseph M. Hellerstein and Avi Pfeffer. </author> <title> The RD-Tree: An Index Structure for Sets. </title> <type> Technical Report #1252, </type> <institution> University of Wisconsin at Madison, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: Union (E 1 = (S 1 ; ptr 1 ); : : : ; E n = (S n ; ptr n )) Return S 1 [ : : : [ S n . * Compress (E = (S; ptr)) A variety of compression techniques for sets are given in <ref> [HP94] </ref>. We briefly describe one of them here. <p> It can be shown that this algorithm produces a rangeset of n items with minimal addition of elements not in S <ref> [HP94] </ref>. * Decompress (E = (rangeset; ptr)) Rangesets are easily converted back to sets by enumerating the elements in the ranges. * Penalty (E 1 = (S 1 ; ptr 1 ); E 2 = (S 2 ; ptr 2 ) Return jE 1 :S 1 [ E 2 :S 2
Reference: [HS93] <author> Joseph M. Hellerstein and Michael Stonebraker. </author> <title> Predicate Migration: Optimizing Queries With Expensive Predicates. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Washington, D.C., </address> <month> May </month> <year> 1993, </year> <pages> pages 267-276. </pages>
Reference-contexts: Recently, some work on R-tree cost estimation has been done [FK94], but more work is required to bring this to bear on GiSTs in general. As an additional problem, the user-defined GiST methods may be time-consuming operations, and their CPU cost should be registered with the optimizer <ref> [HS93] </ref>.
Reference: [Jag90] <author> H. V. Jagadish. </author> <title> Linear Clustering of Objects With Multiple Attributes. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Atlantic City, </address> <month> May </month> <year> 1990, </year> <pages> pages 332-342. </pages>
Reference-contexts: There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*-trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve <ref> [Jag90] </ref>; after transformation, a B+-tree can be used to index the resulting unidimensional data. Extensible-key indices were introduced in POSTGRES [Sto86, Aok91], and are included in Illustra [Sto93], both of which have distinct extensible B+-tree and R-tree implementations. <p> A good sort order and partitioning results in a relatively full tree with low overlap at the keys. Various sort orders have been developed for R-trees (e.g. [KF93], <ref> [Jag90] </ref>, etc.), but these solutions are specific to the spatial domain and thus not generally applicable for an extensible structure like the GiST. Extending this work to new domains should prove interesting.
Reference: [JS93] <author> T. Johnson and D. Shasha. </author> <title> Inserts and Deletes on B-trees: Why Free-At-Empty is Better Than Merge-At-Half. </title> <journal> Journal of Computer Sciences and Systems, </journal> <volume> 47(1) </volume> <pages> 45-76, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: In some implementations, it is considered preferable to leave a node under-full after a delete, in the expectation that it will fill up soon thereafter <ref> [JS93] </ref>.
Reference: [KB95] <author> Marcel Kornacker and Douglas Banks. </author> <note> High-Concurrency Locking in R-Trees. Submitted for publication, </note> <year> 1995. </year>
Reference-contexts: Fortunately, recent work extends Lehman and Yao's sideways pointer techniques, along with recovery techniques, to R-trees. Ng and Kameda [NK94] do so by generating a pending update list at each node of the tree, and applying Lomet and Salzberg's results on -trees to this context. Banks, Kornacker and Stonebraker <ref> [BKS94, KB95] </ref> have a simpler solution that marks keys and nodes with sequence numbers, and uses the sequence numbers to determine order among the nodes. Both approaches provide solutions for degree-3 consistency | Ng and Kameda via aborting transactions that read phantoms, and Banks, et al. via predicate locking.
Reference: [KF93] <author> Ibrahim Kamel and Christos Faloutsos. </author> <title> On Packing R-Trees. </title> <booktitle> Second International Conference on Information and Knowledge Management (CIKM), </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: A good sort order and partitioning results in a relatively full tree with low overlap at the keys. Various sort orders have been developed for R-trees (e.g. <ref> [KF93] </ref>, [Jag90], etc.), but these solutions are specific to the spatial domain and thus not generally applicable for an extensible structure like the GiST. Extending this work to new domains should prove interesting.
Reference: [KG94] <author> Won Kim and Jorge Garza. </author> <title> Requirements For a Performance Benchmark For Object-Oriented Systems. </title> <editor> In Won Kim, editor, </editor> <title> Modern Database Systems: The Object Model, Interoperability and Beyond. </title> <publisher> ACM Press, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: In this section, we demonstrate that the GiST can provide support for a new search tree that indexes set-valued data. The problem of handling set-valued data is attracting increasing attention in the Object-Oriented database community <ref> [KG94] </ref>, and is fairly natural even for traditional relational database applications. For example, one might have a university database with a table of students, and for each student an attribute courses passed of type setof (integer).
Reference: [KKD89] <author> Won Kim, Kyung-Chang Kim, and Alfred Dale. </author> <title> Indexing Techniques for Object-Oriented Databases. </title> <editor> In Won Kim and Fred Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Databases, and Applications, </booktitle> <pages> pages 371-394. </pages> <publisher> ACM Press and Addison-Wesley Publishing Co., </publisher> <year> 1989. </year>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees [WE80], k-D-B-trees [Rob81], Ch-trees <ref> [KKD89] </ref>, Exodus large objects [CDG + 90], hB-trees [LS90], V-trees [MCD94], TV-trees [LJF94], etc.
Reference: [Knu73] <author> Donald Ervin Knuth. </author> <title> Sorting and Searching, </title> <booktitle> volume 3 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley Publishing Co., </publisher> <year> 1973. </year>
Reference-contexts: Section 6 examines some details that need to be considered when implementing GiSTs in a full-fledged DBMS. Section 7 concludes with a discussion of the significance of the work, and directions for further research. 1.2 Related Work A good survey of search trees is provided by Knuth <ref> [Knu73] </ref>, though B-trees and their variants are covered in more detail by Comer [Com79]. There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*-trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90].
Reference: [LJF94] <author> King-Ip Lin, H. V. Jagadish, and Christos Faloutsos. </author> <title> The TV-Tree: An Index Structure for High-Dimensional Data. </title> <journal> VLDB Journal, </journal> <volume> 3 </volume> <pages> 517-542, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees [WE80], k-D-B-trees [Rob81], Ch-trees [KKD89], Exodus large objects [CDG + 90], hB-trees [LS90], V-trees [MCD94], TV-trees <ref> [LJF94] </ref>, etc.
Reference: [LS90] <author> David B. Lomet and Betty Salzberg. </author> <title> The hB-Tree: A Multiattribute Indexing Method. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(4), </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees [WE80], k-D-B-trees [Rob81], Ch-trees [KKD89], Exodus large objects [CDG + 90], hB-trees <ref> [LS90] </ref>, V-trees [MCD94], TV-trees [LJF94], etc. <p> There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*-trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees <ref> [LS90] </ref>. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data.
Reference: [LS92] <author> David Lomet and Betty Salzberg. </author> <title> Access Method Concurrency with Recovery. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 351-360, </pages> <address> San Diego, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Concurrency control for B+-trees is a well-understood problem, with Lehman and Yao's B-link variant [LY81] being a typical way of implementing high-concurrency B+-trees. Recovery for B-link trees has been explored by Lomet and Salzberg <ref> [LS92] </ref>, who show that a -tree, which generalizes the B-link tree, can be reconstructed gradually from any interim state. Until recently, no analogous results existed for R-trees.
Reference: [LY81] <author> P. L. Lehman and S. B. Yao. </author> <title> Efficient Locking For Concurrent Operations on B-trees. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(4) </volume> <pages> 650-670, </pages> <year> 1981. </year>
Reference-contexts: N2: [next on neighboring node] If E is the righmost entry on its node, let P be the next node to the right of R on the same level of the tree (this can be found via tree traversal, or via sideways pointers in the tree, when available <ref> [LY81] </ref>.) If P is non-existent, return NULL. Otherwise, let N be the leftmost entry on P . If Consistent (N; q), then return N , else return NULL. 3.4.3 Insert The insertion routines guarantee that the GiST remains balanced. <p> This is discussed in more detail in Section 6.6. 6.2 Concurrency Control, Recovery and Consistency High concurrency, recoverability, and degree-3 consistency are critical factors in a full-fledged database system. Concurrency control for B+-trees is a well-understood problem, with Lehman and Yao's B-link variant <ref> [LY81] </ref> being a typical way of implementing high-concurrency B+-trees. Recovery for B-link trees has been explored by Lomet and Salzberg [LS92], who show that a -tree, which generalizes the B-link tree, can be reconstructed gradually from any interim state. Until recently, no analogous results existed for R-trees.
Reference: [MCD94] <author> Maurcio R. Mediano, Marco A. Casanova, and Marcelo Dreux. </author> <title> V-Trees | A Storage Method For Long Vector Data. </title> <booktitle> In Proc. 20th International Conference on Very Large Data Bases, </booktitle> <pages> pages 321-330, </pages> <address> Santiago, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees [WE80], k-D-B-trees [Rob81], Ch-trees [KKD89], Exodus large objects [CDG + 90], hB-trees [LS90], V-trees <ref> [MCD94] </ref>, TV-trees [LJF94], etc.
Reference: [NK94] <author> Vincent Ng and Tiko Kameda. </author> <title> The R-Link Tree: A Recoverable Index Structure for Spatial Data. </title> <booktitle> In Proc. Fifth International Conference on Database and Expert Systems Applications (DEXA '94), </booktitle> <pages> pages 163-172, </pages> <address> Athens, </address> <year> 1994. </year>
Reference-contexts: R-tree data has no such natural ordering, and imposing an artificial ordering upsets the balancing techniques for the tree. Fortunately, recent work extends Lehman and Yao's sideways pointer techniques, along with recovery techniques, to R-trees. Ng and Kameda <ref> [NK94] </ref> do so by generating a pending update list at each node of the tree, and applying Lomet and Salzberg's results on -trees to this context.
Reference: [PSTW93] <author> Bernd-Uwe Pagel, Hans-Werner Six, Heinrich Toben, and Peter Widmayer. </author> <title> Towards an Analysis of Range Query Performance in Spatial Data Structures. </title> <booktitle> In Proc. 12th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 214-221, </pages> <address> Washington, D. C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Predicate Trees are used to generate hash keys. A even more limited notion is that of the Interval Hierarchy [WE77], which can be used to index a file of simple conjunctive ordering predicates. Analyses of R-tree performance have appeared in [FK94] and <ref> [PSTW93] </ref>. This work is dependent on the spatial nature of typical R-tree data, and thus is not generally applicable to the GiST.
Reference: [Qui93] <author> J. Ross Quinlan. C4.5: </author> <title> Programs for Machine Learning. </title> <publisher> Morgan-Kaufmann Publishers, Inc., </publisher> <year> 1993. </year>
Reference-contexts: Despite these limitations, extensible R-trees are close enough to GiSTs to allow for the initial method implementations and performance experiments we describe in Section 5. Classification trees such as ID3 and C4.5 <ref> [Qui93] </ref> are similar in spirit to the GiST, but have some major differences. Most significantly, classification trees are not intended as search structures, and are not suited for indexing large amounts of data.
Reference: [Rob81] <author> J. T. Robinson. </author> <title> The k-D-B-Tree: A Search Structure for Large Multidimensional Dynamic Indexes. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 10-18, </pages> <address> Ann Arbor, </address> <month> April/May </month> <year> 1981. </year>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees [WE80], k-D-B-trees <ref> [Rob81] </ref>, Ch-trees [KKD89], Exodus large objects [CDG + 90], hB-trees [LS90], V-trees [MCD94], TV-trees [LJF94], etc. <p> There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*-trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees <ref> [Rob81] </ref>, and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data.
Reference: [SAC + 79] <author> Patricia G. Selinger, M. Astrahan, D. Chamberlin, Raymond Lorie, and T. Price. </author> <title> Access Path Selection in a Relational Database Management System. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Boston, </address> <month> June </month> <year> 1979. </year>
Reference-contexts: For trees with IsOrdered = TRUE, one can additionally specify to the optimizer those predicates that can be evaluated using the FindMin/Next technique. When planning a query, if the optimizer sees a Boolean Factor <ref> [SAC + 79] </ref> based on one of the registered predicates, then it knows it should consider probing the GiST as one of its potential access paths.
Reference: [SRF87] <author> Timos Sellis, Nick Roussopoulos, and Christos Faloutsos. </author> <title> The R+-Tree: A Dynamic Index For Multi-Dimensional Objects. </title> <booktitle> In Proc. 13th International Conference on Very Large Data Bases, </booktitle> <pages> pages 507-518, </pages> <address> Brighton, </address> <month> September </month> <year> 1987. </year>
Reference-contexts: There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*-trees [BKSS90] and R+-trees <ref> [SRF87] </ref>. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data. <p> The above implementations, along with the GiST algorithms described in the previous chapters, give behavior identical to that of Guttman's R-tree. A series of variations on R-trees have been proposed, notably the R*-tree [BKSS90] and the R+-tree <ref> [SRF87] </ref>. The R*-tree differs from the basic R-tree in three ways: in its PickSplit algorithm, which has a variety of small changes, in its ChooseSubtree algorithm, which varies only slightly, and in its policy of reinserting a number of keys during node split.
Reference: [Sto86] <author> Michael Stonebraker. </author> <title> Inclusion of New Types in Relational Database Systems. </title> <booktitle> In Proceedings of the IEEE Fourth International Conference on Data Engineering, </booktitle> <pages> pages 262-269, </pages> <address> Washington, D.C., </address> <month> February </month> <year> 1986. </year>
Reference-contexts: Search Trees For Extensible Data Types: As an alternative to developing new data structures, existing data structures such as B+-trees and R-trees can be made extensible in the data types they support <ref> [Sto86] </ref>. For example, B+-trees can be used to index any data with a linear ordering, supporting equality or linear range queries over that data. While this provides extensibility in the data that can be indexed, it does not extend the set of queries which can be supported by the tree. <p> Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data. Extensible-key indices were introduced in POSTGRES <ref> [Sto86, Aok91] </ref>, and are included in Illustra [Sto93], both of which have distinct extensible B+-tree and R-tree implementations. These extensible indices allow many types of data to be indexed, but only support a fixed set of query predicates.
Reference: [Sto93] <author> Michael Stonebraker. </author> <title> The Miro DBMS. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Washington, D.C., </address> <month> May </month> <year> 1993, </year> <pages> page 439. </pages>
Reference-contexts: Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data. Extensible-key indices were introduced in POSTGRES [Sto86, Aok91], and are included in Illustra <ref> [Sto93] </ref>, both of which have distinct extensible B+-tree and R-tree implementations. These extensible indices allow many types of data to be indexed, but only support a fixed set of query predicates.
Reference: [VV84] <author> Patrick Valduriez and Yann Viemont. </author> <title> A Multikey Hashing Scheme Using Predicate Trees. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Boston, </address> <month> June </month> <year> 1984, </year> <pages> pages 107-114. </pages>
Reference-contexts: be able to leverage some of the lessons learned in the development of classification trees, particularly in implementing methods for picking a way to split nodes (the PickSplit method described below) and for choosing good keys (the Union and Compress methods described below.) The Predicate Trees of Valduriez and Viemont <ref> [VV84] </ref> are similar to classification trees, in that they are not used to index data sets, and can be defined only on traditional alphanumeric predicates. Predicate Trees are used to generate hash keys.
Reference: [WE77] <author> Kai C. Wong and Murray Edelberg. </author> <title> Interval hierarchies and their application to predicate files. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 2(3) </volume> <pages> 223-232, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: Predicate Trees are used to generate hash keys. A even more limited notion is that of the Interval Hierarchy <ref> [WE77] </ref>, which can be used to index a file of simple conjunctive ordering predicates. Analyses of R-tree performance have appeared in [FK94] and [PSTW93]. This work is dependent on the spatial nature of typical R-tree data, and thus is not generally applicable to the GiST.
Reference: [WE80] <author> C. K. Wong and M. C. Easton. </author> <title> An Efficient Method for Weighted Sampling Without Replacement. </title> <journal> SIAM Journal on Computing, </journal> <volume> 9(1) </volume> <pages> 111-113, </pages> <month> February </month> <year> 1980. </year> <month> 23 </month>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees <ref> [WE80] </ref>, k-D-B-trees [Rob81], Ch-trees [KKD89], Exodus large objects [CDG + 90], hB-trees [LS90], V-trees [MCD94], TV-trees [LJF94], etc. <p> Finally, observe that one could fairly easily support more complex predicates, including disjunctions of intervals in query predicates, or ranked intervals in key predicates for supporting efficient sampling <ref> [WE80] </ref>. 4.2 GiSTs Over Polygons in R 2 (R-trees) In this example, our data are 2-dimensional polygons on the Cartesian plane. Before compression, the keys in this tree are 4-tuples of reals, representing the upper-left and lower-right corners of rectilinear bounding rectangles for 2d-polygons.
References-found: 37

