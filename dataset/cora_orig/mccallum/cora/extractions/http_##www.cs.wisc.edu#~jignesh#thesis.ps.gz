URL: http://www.cs.wisc.edu/~jignesh/thesis.ps.gz
Refering-URL: http://www.cs.wisc.edu/~jignesh/jignesh.html
Root-URL: 
Title: EFFICIENT DATABASE SUPPORT FOR SPATIAL APPLICATIONS  
Author: By Jignesh M. Patel 
Degree: A DISSERTATION SUBMITTED IN PARTIAL FULFILLMENT OF THE REQUIREMENTS FOR THE DEGREE OF DOCTOR OF PHILOSOPHY (COMPUTER SCIENCE) at the  
Date: 1998  
Address: WISCONSIN MADISON  
Affiliation: UNIVERSITY OF  
Abstract-found: 0
Intro-found: 1
Reference: [Arc95] <author> ESRI, Redlands, </author> <title> CA. ARC/INFO: The World's GIS. An ESRI White Paper, </title> <month> March </month> <year> 1995. </year>
Reference-contexts: To the best of our knowledge, most commercial spatial database systems do not transform the approximations of spatial objects into another domain (for example, ARC/INFO <ref> [Arc95] </ref>, and Illustra [Ube94]). The remainder of this section is organized as follows. First the index nested-loops and the R-tree-based join algorithms are described.
Reference: [Ben75] <author> J. L. Bentley. </author> <title> Multidimensional Binary Search Trees Used for Associative Searching. </title> <journal> In Communication of the ACM, </journal> <volume> volume 18(9), </volume> <month> September </month> <year> 1975. </year>
Reference-contexts: The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. Grid files [NHS84] and kd-trees <ref> [Ben75, Ben79] </ref> have also been employed for 7 evaluating multi-attribute joins in the relational domain [KHT89, HNKT90, BHF93]. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93].
Reference: [Ben79] <author> J. L. Bentley. </author> <title> Multidimensional Binary Search Trees in Database Applications. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> volume 5(4), </volume> <year> 1979. </year>
Reference-contexts: The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. Grid files [NHS84] and kd-trees <ref> [Ben75, Ben79] </ref> have also been employed for 7 evaluating multi-attribute joins in the relational domain [KHT89, HNKT90, BHF93]. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93].
Reference: [BHF93] <author> L. Becker, K. Hinrichs, and U. Finke. </author> <title> A New Algorithm for Computing Joins With Grid Files. </title> <journal> In IEEE Transactions on Knowledge and Data Engineering, </journal> <year> 1993. </year>
Reference-contexts: The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. Grid files [NHS84] and kd-trees [Ben75, Ben79] have also been employed for 7 evaluating multi-attribute joins in the relational domain <ref> [KHT89, HNKT90, BHF93] </ref>. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. <p> Grid files [NHS84] and kd-trees [Ben75, Ben79] have also been employed for 7 evaluating multi-attribute joins in the relational domain [KHT89, HNKT90, BHF93]. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension <ref> [BHF93] </ref>. Recently, spatial index structures such as R-trees [Gut84], R+-trees [CFR87], R*-trees [BKSS90], and PMR quad trees [NS86] have been used to speed up the evaluation of the spatial join. <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use Operate without of an Index an Index * Z-values [OM84] Transform the * Join Indices [Rot91] approximation into * Grid Files <ref> [HNKT90, BHF93] </ref> * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the [BKS93, G un93, HS95, HJR97, KS97] * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before
Reference: [BKS93] <author> T. Brinkhoff, H.-P. Kriegel, and B. Seeger. </author> <title> Efficient Processing of Spatial Joins Using R-trees. </title> <booktitle> In Proceedings of the 1993 ACM-SIGMOD Conference, </booktitle> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: This study concludes that for low join selectivities, join indices usually provide the best join performance, but for higher join selectivities generalization trees are more efficient. The proposed join algorithm, using the generalization trees, is similar to the join algorithm on R-trees proposed by Brinkhoff, Kriegel and Seeger <ref> [BKS93] </ref>. This algorithm can be used only if an R-tree index exists on both the join inputs, and can be described as a synchronized depth-first search of both indices, with the two depth-first searches being guided by hints from each other. <p> The two indices are then joined using the tree join algorithm described by Brinkhoff, Kriegel and Seeger <ref> [BKS93] </ref>. Lo and Ravishankar [LR95] have extended this work to handle the case when neither of the inputs have an index. In their approach, spatial sampling techniques are used for constructing seeded trees on both inputs, and the seeded trees are joined using the tree join algorithm of [BKS93]. <p> and Seeger <ref> [BKS93] </ref>. Lo and Ravishankar [LR95] have extended this work to handle the case when neither of the inputs have an index. In their approach, spatial sampling techniques are used for constructing seeded trees on both inputs, and the seeded trees are joined using the tree join algorithm of [BKS93]. Similar to the seeded tree approach, Koudas and Sevcik [KS97] propose building a filter tree on the inputs and joining the two filter trees. A filter tree, like a Quad Tree, is based on a regular decomposition of space. <p> Require Use Operate without of an Index an Index * Z-values [OM84] Transform the * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the <ref> [BKS93, G un93, HS95, HJR97, KS97] </ref> * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before joining [LR94, LR95] Table 1: Classification of Various Spatial Join Algorithms 2.3 Partition-Based Spatial-Merge Join This section describes a new algorithm, called the Partition-Based Spatial-Merge (PBSM) join, <p> This technique, which was also used by Brinkhoff, Kriegel and Seeger <ref> [BKS93] </ref> for joining the entries of two R*-tree nodes, can be thought of as the spatial equivalent of the sort-merge algorithm. The details of the algorithm for merging the partitions R kp kp i are as follows. <p> The first algorithm is based on the traditional indexed nested-loops algorithm and the other is based on the R-tree join algorithm <ref> [BKS93] </ref>. These algorithms use spatial indices, and were chosen because most spatial databases support some form of spatial indexing (for example, R-trees in Illustra [Ube94]). Such systems can easily use these index-based join algorithms. <p> The two indices are then joined using the R-tree join algorithm proposed by Brinkhoff, Kriegel and Seeger <ref> [BKS93] </ref>. The R-tree join algorithm performs a synchronous depth-first traversal of the two trees. The traversal starts with the roots of the two R-trees, and moves down the levels of the two trees in tandem until the leaf nodes are reached. <p> Joining two nodes requires finding all bounding boxes in the first node that intersect with some bounding box in the other node. The child pointers corresponding to such matching bounding boxes are then traversed (resulting in a depth-first traversal). The R-tree join algorithm proposed by Brinkhoff, Kriegel and Seeger <ref> [BKS93] </ref> only performs the filter step of the spatial join, and produces a set of candidate OID pairs corresponding to the objects whose MBRs intersect. The objects corresponding to these OIDs then have to be fetched and checked to determine if the join predicate is actually satisfied. <p> In the join phase, each operator looks at the fragment of the declustered relation residing on its local disks and joins them using any of the centralized join algorithms <ref> [Ore86, BKS93, G un93, HJR97, GS87, LR94, HS95, LR96, PD96] </ref>. In this chapter, the local processing is done using the PBSM join algorithm [PD96] (described in Section 2.3). The final refinement phase is required for two reasons.
Reference: [BKSS90] <author> N. Beckmann, H. P. Kriegel, R. Schneider, and B. Seeger. </author> <title> The R*-tree: An Efficient and Robust Access Method for Points and Rectangles. </title> <booktitle> In Proceedings of the 1990 ACM-SIGMOD Conference, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. Recently, spatial index structures such as R-trees [Gut84], R+-trees [CFR87], R*-trees <ref> [BKSS90] </ref>, and PMR quad trees [NS86] have been used to speed up the evaluation of the spatial join.
Reference: [BKSS94] <author> T. Brinkhoff, H.-P. Kriegel, R. Schneider, and B. Seeger. </author> <title> Multistep Processing of Spatial Joins. </title> <booktitle> In Proceedings of the 1994 ACM-SIGMOD Conference, </booktitle> <address> Minneapolis, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Relatively little attention has been given to the refinement step. Various techniques for improvement of the refinement step are proposed and evaluated by Brinkhoff, Kriegel, Schneider and Seeger in <ref> [BKSS94] </ref>. In this section, we classify the various algorithms for evaluating the filter step of the spatial join. For convenience, throughout this section the term spatial join is used to refer to the filter step of the spatial join. <p> are a number of techniques for reducing the 3 For the Indexed Nested-Loops join the refinement step cost is part of the index probe cost. 23 gons with Islands Nested-Loops Algorithm, Se-quoia Data: Join Polygons with Islands Sequoia Data: Join Polygons with Islands cost of this part of the join <ref> [BKSS94] </ref> (by an order of magnitude in many cases). These techniques rely on using as a filter in the refinement step, extra information that is precomputed and stored along with each spatial feature. <p> A similar problem occurs in centralized spatial join algorithms, since many centralized spatial join algorithms first join using the minimum bounding rectangle of the spatial attribute. It is shown 61 in <ref> [BKSS94] </ref> that approximating the spatial attributes by a closer approximation (like the multiple fragment boxes here) enhances the performance of the centralized spatial join algorithm. We now perform a simple experiment to examine the effect of multiple finer approximations on the Shadow join and the Clone join.
Reference: [Bur86] <author> P. A. Burrough. </author> <title> Principles of Geographic Information Systems for Land Resources Assessment. </title> <publisher> Oxford University Press, </publisher> <year> 1986. </year>
Reference-contexts: Spatial database users frequently need to combine two spatial inputs based on some spatial relationship between the objects in the two inputs. For example, map overlap, which requires combining two maps to produce a third, is an important operation in a spatial database <ref> [Bur86, MGR91] </ref>. This operation of combining two inputs based on an element-wise spatial relationship is called a spatial join. Spatial joins, just like their counterparts in a relational system, are an expensive operation. Consequently, efficient spatial join algorithms are a critical component of any spatial database system.
Reference: [CDF + 94] <author> M. J. Carey, D. J. DeWitt, M. J. Franklin, N. E. Hall, M. McAuliffe, J. F. Naughton, D. T. Schuh, M. H. Solomon, C. K. Tan, O. Tsatalos, S. White, and M. J. Zwilling. </author> <title> Shoring up Persistent Applications. </title> <booktitle> In Proceedings of the 1994 ACM-SIGMOD Conference, </booktitle> <address> Minneapo-lis, Minnesota, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Paradise is a database system that handles geo-spatial types of applications. Paradise supports storing, browsing, and querying of geographic data sets. It uses an extended-relational data model and supports an extension of SQL as its query language. Paradise uses SHORE <ref> [CDF + 94] </ref> as its storage manager for persistent objects. The machine used for the study was a Sun SPARC-10/51 with 64 MBytes of memory, running SunOS Release 4.1.3. One Seagate 2GByte disk (3.5 SCSI, model # ST 12400N) was used as a raw device to hold the database.
Reference: [CFR87] <author> T. Sellis C. Faloutsos and N. Roussopoulos. </author> <title> Analysis of Object Oriented Spatial Access Methods. </title> <booktitle> In Proceedings of the 1987 ACM-SIGMOD Conference, </booktitle> <address> San Francisco, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. Recently, spatial index structures such as R-trees [Gut84], R+-trees <ref> [CFR87] </ref>, R*-trees [BKSS90], and PMR quad trees [NS86] have been used to speed up the evaluation of the spatial join.
Reference: [DCW92] <institution> VPFView 1.0 Users Manual for the Digital Chart of the World. Defense Mapping Agency, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: The maximum process size we observed during benchmark execution was about 95 MBytes. Thus, no swapping occurred. 34 The data set used in this study is the drainage and the cities data set from the Digital Chart of the World <ref> [DCW92] </ref>. The characteristics of the data is shown in Table 10. Each Drainage tuple has a polyline attribute that describes the drainage feature, and each Cities tuple has a point attribute that describes the geo-location of the city. <p> To quantify these tradeoff, we ran some experiments using the drainage data set from the data provided by DCW <ref> [DCW92] </ref>. This data set describes drainage features, like rivers, streams, canals, etc., for the entire world. This relation has 1.7 million tuples, and the size of the relation is about 300 MB. <p> In the following analytical experiments, we vary each of the parameters above one at a time. The default values for these parameters are: replication probability = 0.07, fertility ratio = 0.2, and join selectivity = 1e 6. These values were chosen based on actual experiments with the DCW <ref> [DCW92] </ref> data sets. The cardinality of each input relation is set to 1 million. 5.4.1 Effect of Join Selectivity probability = 0:07, fertility ratio = = 0:2. join selectivity is small (compare Shadow0.1e-6 with Clone0.1e-6), Shadow join outperforms Clone join. <p> These algorithms were implemented inside Paradise, a scalable geo-spatial database system [PYK + 97]. 5.5.1 Data Sets The data sets that are used in this benchmark come from the DCW data product <ref> [DCW92] </ref>. We used the drainage, road and rail data sets. The drainage data set describes, using polylines, drainage features, such rivers, streams, canals, etc., for the entire world. Similarly, the road and the rail data set describe, using polylines, roads and railway lines for the entire world. <p> The data set used in this study is the drainage and the 66 cities data set from DCW <ref> [DCW92] </ref>. The definition of these two relations in Paradise is as given below.
Reference: [DG92] <author> D. J. DeWitt and Jim Gray. </author> <title> Parallel Database Systems: The Future of Database Processing or a Passing Fad?. </title> <journal> Communication of the ACM, </journal> <month> June, </month> <year> 1992. </year>
Reference-contexts: Beginning with this chapter, the second part of this thesis explores the use of parallelism to store and query spatial data, with an emphasis on the use of a shared-nothing database system. In a parallel shared-nothing system, the main source of parallelism is partitioned parallelism <ref> [DG92] </ref>. Partitioned parallelism is achieved by declustering the data across multiple nodes in the system, and then running operators at each of these nodes. There are two main requirements for achieving effective parallelism.
Reference: [DG99] <author> D. J. DeWitt and J. Gray. </author> <title> Parallel Database Systems: The Future of Database Processing or a Passing Fad?. </title> <booktitle> In SIGMOD Record, </booktitle> <volume> volume 19, </volume> <pages> pages 104112, </pages> <year> 1999. </year>
Reference-contexts: In a parallel database system, speedup is defined as the ability of the system to perform a task in half the elapsed time if the system has twice as much hardware <ref> [DG99] </ref>. For this experiment, the result relation has 0.7 M tuples and is 300 MB in size. The data characteristics are: Replication Probability = 0.07, Fertility Rate = 0.20, and Join Selectivity = 0:53e6. As shown in the figure, both algorithms have close to linear speedup.
Reference: [DKL + 94] <author> D. J. DeWitt, N. Kabra, J. Luo, J. M. Patel, and J. Yu. </author> <title> ClientServer Paradise. </title> <booktitle> In Proceedings of the 20th VLDB Conf., </booktitle> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Attributes of tuples in traditional relational systems are limited to simple types like numeric, dates and character strings, but the new model, called the objectrelational model, allows the extension of these basic types to include types like images, videos, points, polygons, circles, polylines, etc <ref> [SK91, DKL + 94] </ref>. The objectrelational model also allows functions to be defined on these types, and allows these functions to appear in queries that are posed to the system. Such a database system can both store and manipulate complex types inside the database system, making them easier to use. <p> This sorting step brings together key-pointer pairs whose joining attributes are spatially close. The spatial index, which in our case is a R*-tree, is then built in a bottom up fashion <ref> [DKL + 94] </ref>. After building the index on the join attribute of R, a scan is started on S. Each tuple of S is used to probe the index on R. The result of the probe is a set of (possibly empty) OIDs of R. <p> For this step, we use the same refinement strategy that was used by the PBSM join algorithm (refer to Section 2.3.2). 17 2.4.3 Methodology For the performance comparison, we implemented each of these algorithms, namely, indexed nested-loops join, R-tree-based join and the PBSM join in Paradise <ref> [DKL + 94] </ref>. Paradise is a database system that handles geo-spatial types of applications. Paradise supports storing, browsing, and querying of geographic data sets. It uses an extended-relational data model and supports an extension of SQL as its query language. <p> The operator tree for this is shown in Figure 24. 3.5 Performance Evaluation This section contains the results of implementing the spatial aggregate algorithm described in the previous section in the Paradise <ref> [DKL + 94, PYK + 97] </ref> geo-spatial database system. The hardware platform for this performance evaluation was a Solaris 2.5 machine with dual 133 MHz Pentium processors, and 128 MBytes of memory.
Reference: [DKO + 84] <author> D. J. DeWitt, R. H Katz, F. Ohlken, L. D. Shapiro, M. R. Stonebraker, and D. Wood. </author> <title> Implementation techniques for main memory databases. </title> <booktitle> In ACM SIGMOD, </booktitle> <month> July </month> <year> 1984. </year> <note> Also published in/as: UCB, Elec.Res.Lab, Memo No.84-5, Jan.1984. 71 </note>
Reference-contexts: Consequently, with the Tiger data set, there are very few road segments that overlap multiple tiles, which in turn causes the replication overhead to be low. 2.3.5 Handling Partition Skew Similar to the partition skew problem for Grace Join <ref> [KTM83, DKO + 84, Sha86, KNT89] </ref>, it is possible for the PBSM algorithm to end up with partition pairs that do not fit entirely in memory (for example, if most of the data is concentrated in a very small cluster).
Reference: [DNSS92] <author> D. J. DeWitt, J. F. Naughton, D. A. Schneider, and S. Seshadri. </author> <title> Practical Skew Handling in Parallel Joins. </title> <booktitle> In Proceedings of the 19th VLDB Conf., </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: Consequently, the key-pointer element for the object shown in Figure 5, will be inserted into partitions 0, 1 and 2. The spatial partitioning function just described is the spatial analog of virtual processor round robin partitioning for handling skews in parallel relational joins <ref> [DNSS92] </ref>. A similar partitioning function has been independently proposed for redundancy-based declustering of spatial objects in a parallel spatial database [TY95], but in that proposal the number of tiles always equals the number of partitions.
Reference: [FBF77] <author> J. H. Friedman, J. L. Bentley, and R. A. Finkel. </author> <title> An algorithm for finding the best matches in logarithmic expected time. </title> <journal> ACM Trans. Math. Software, </journal> <volume> 3:209226, </volume> <month> September </month> <year> 1977. </year>
Reference-contexts: Then, it backtracks the path that it just traversed, and uses a heuristic to search the subtrees that potentially contain the n nearest-neighbors. An algorithm for solving the nearest-neighbor problem with k-d trees [Rob81] was proposed by Friedman, Bentley and Finkel <ref> [FBF77] </ref>. This algorithm was later refined by Sproull [Spr91]. Roussopoulos, Kelley and Vincent [RKV95] have proposed a branch-and-bound search algorithm for finding the nearest neighbors using R-trees [Gut84].
Reference: [GS87] <author> R. H. G uting and W. Shilling. </author> <title> A Practical DivideandConquer Algorithm for the Rectangle Intersection Problem. </title> <journal> In Information Sciences, </journal> <volume> volume 42, </volume> <year> 1987. </year>
Reference-contexts: The problem of finding pairwise intersection between two sets of rectangles has been extensively studied in the VLSI domain [MC80], and numerous solutions exist for the case when both the input set of rectangles fit in memory [PS88]. In <ref> [GS87] </ref>, G uting and Shilling examine the rectangle intersection problem when the inputs are too large to fit in memory, and analyze the time and space complexity 8 of two algorithms that are based on external computational geometry algorithms. <p> Require Use Operate without of an Index an Index * Z-values [OM84] Transform the * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo <ref> [GS87] </ref> directly in the [BKS93, G un93, HS95, HJR97, KS97] * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before joining [LR94, LR95] Table 1: Classification of Various Spatial Join Algorithms 2.3 Partition-Based Spatial-Merge Join This section describes a new algorithm, called the <p> In the join phase, each operator looks at the fragment of the declustered relation residing on its local disks and joins them using any of the centralized join algorithms <ref> [Ore86, BKS93, G un93, HJR97, GS87, LR94, HS95, LR96, PD96] </ref>. In this chapter, the local processing is done using the PBSM join algorithm [PD96] (described in Section 2.3). The final refinement phase is required for two reasons.
Reference: [G un93] <author> O. G unther. </author> <title> Efficient Computation of Spatial Joins. </title> <journal> In IEEE Transactions on Knowledge and Data Engineering, </journal> <year> 1993. </year>
Reference-contexts: Using analytical models, G unther compares join algorithms that use generalization trees (which is a class of tree structures that includes the R-tree, R*-tree and R+tree) with the nested-loops join and join indices <ref> [G un93] </ref>. This study concludes that for low join selectivities, join indices usually provide the best join performance, but for higher join selectivities generalization trees are more efficient. <p> Require Use Operate without of an Index an Index * Z-values [OM84] Transform the * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the <ref> [BKS93, G un93, HS95, HJR97, KS97] </ref> * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before joining [LR94, LR95] Table 1: Classification of Various Spatial Join Algorithms 2.3 Partition-Based Spatial-Merge Join This section describes a new algorithm, called the Partition-Based Spatial-Merge (PBSM) join, <p> In the join phase, each operator looks at the fragment of the declustered relation residing on its local disks and joins them using any of the centralized join algorithms <ref> [Ore86, BKS93, G un93, HJR97, GS87, LR94, HS95, LR96, PD96] </ref>. In this chapter, the local processing is done using the PBSM join algorithm [PD96] (described in Section 2.3). The final refinement phase is required for two reasons.
Reference: [Gut84] <author> A. Gutman. R-trees: </author> <title> A Dynamic Index Structure for Spatial Searching. </title> <booktitle> In Proceedings of the 1984 ACM-SIGMOD Conference, </booktitle> <address> Boston, Mass, </address> <month> June </month> <year> 1984. </year>
Reference-contexts: These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. Recently, spatial index structures such as R-trees <ref> [Gut84] </ref>, R+-trees [CFR87], R*-trees [BKSS90], and PMR quad trees [NS86] have been used to speed up the evaluation of the spatial join. <p> An algorithm for solving the nearest-neighbor problem with k-d trees [Rob81] was proposed by Friedman, Bentley and Finkel [FBF77]. This algorithm was later refined by Sproull [Spr91]. Roussopoulos, Kelley and Vincent [RKV95] have proposed a branch-and-bound search algorithm for finding the nearest neighbors using R-trees <ref> [Gut84] </ref>. This algorithm traverses down the R-tree following all the branches that 1 If multiple rivers have the same distance to the city, one of them is randomly selected by this operation. 31 might contain one of the n-neighbors. <p> Consequently, data distribution skew is not considered at all. Kamel and Faloutsos [KF92] have examined the use of parallelism to accelerate the performance of spatial selections. They examined techniques to distribute the leaves of an R-tree <ref> [Gut84] </ref> across multiple disks in a system, and evaluated various placement policies for the leaf pages.
Reference: [Hil91] <author> D. </author> <title> Hilbert. Uber die stetige abbildung einer linie auf flachenst uck. </title> <journal> Math Annln., </journal> <volume> 38(4):459 460, </volume> <pages> 1891. </pages>
Reference: [HJR97] <author> Y.-W. Huang, N. Jing, and E. A. Rundensteiner. </author> <title> Spatial Joins Using R-trees: Breadth-First Traversal with Global Optimizations. </title> <booktitle> In Proceedings of the 23st VLDB Conf., </booktitle> <pages> pages 396405, </pages> <address> Athens, Greece, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: This algorithm can be used only if an R-tree index exists on both the join inputs, and can be described as a synchronized depth-first search of both indices, with the two depth-first searches being guided by hints from each other. This algorithm was modified by Huang, Jing and Rundensteiner <ref> [HJR97] </ref> to achieve better memory utilization by changing the depth-first traversal to a breadth-first traversal of the two trees. Similar tree joins have been proposed for other data structures. <p> Require Use Operate without of an Index an Index * Z-values [OM84] Transform the * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the <ref> [BKS93, G un93, HS95, HJR97, KS97] </ref> * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before joining [LR94, LR95] Table 1: Classification of Various Spatial Join Algorithms 2.3 Partition-Based Spatial-Merge Join This section describes a new algorithm, called the Partition-Based Spatial-Merge (PBSM) join, <p> In the join phase, each operator looks at the fragment of the declustered relation residing on its local disks and joins them using any of the centralized join algorithms <ref> [Ore86, BKS93, G un93, HJR97, GS87, LR94, HS95, LR96, PD96] </ref>. In this chapter, the local processing is done using the PBSM join algorithm [PD96] (described in Section 2.3). The final refinement phase is required for two reasons.
Reference: [HNKT90] <author> L. Harada, M. Nakano, M. Kitsuregawa, and M. Takagi. </author> <title> Query Processing Methods for MultiAttribute Clustered Relations. </title> <booktitle> In Proceedings of the 16th VLDB Conf., </booktitle> <address> Brisbane, Aus-tralia, </address> <year> 1990. </year>
Reference-contexts: The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. Grid files [NHS84] and kd-trees [Ben75, Ben79] have also been employed for 7 evaluating multi-attribute joins in the relational domain <ref> [KHT89, HNKT90, BHF93] </ref>. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use Operate without of an Index an Index * Z-values [OM84] Transform the * Join Indices [Rot91] approximation into * Grid Files <ref> [HNKT90, BHF93] </ref> * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the [BKS93, G un93, HS95, HJR97, KS97] * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use Operate without of an Index an Index * Z-values [OM84] Transform the * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees <ref> [KHT89, HNKT90] </ref> Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the [BKS93, G un93, HS95, HJR97, KS97] * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before joining [LR94, LR95] Table 1: Classification of Various Spatial Join
Reference: [HS95] <author> E. G. Hoel and H. Samet. </author> <title> Benchmarking Spatial Join Operations with Spatial Output. </title> <booktitle> In Proceedings of the 21st VLDB Conf., </booktitle> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: This algorithm was modified by Huang, Jing and Rundensteiner [HJR97] to achieve better memory utilization by changing the depth-first traversal to a breadth-first traversal of the two trees. Similar tree joins have been proposed for other data structures. Hoel and Samet <ref> [HS95] </ref> propose a tree join algorithm for the PMR quad tree, and compare the efficiency of variants of the PMR quad tree with variants of the R-tree [HS95]. <p> Similar tree joins have been proposed for other data structures. Hoel and Samet <ref> [HS95] </ref> propose a tree join algorithm for the PMR quad tree, and compare the efficiency of variants of the PMR quad tree with variants of the R-tree [HS95]. When one of the inputs to the spatial join does not have a spatial index, Lo and Ravishankar [LR94] propose building a seeded tree index on that input. A seeded tree is a R-tree that is allowed to be height unbalanced. <p> Require Use Operate without of an Index an Index * Z-values [OM84] Transform the * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the <ref> [BKS93, G un93, HS95, HJR97, KS97] </ref> * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before joining [LR94, LR95] Table 1: Classification of Various Spatial Join Algorithms 2.3 Partition-Based Spatial-Merge Join This section describes a new algorithm, called the Partition-Based Spatial-Merge (PBSM) join, <p> In the join phase, each operator looks at the fragment of the declustered relation residing on its local disks and joins them using any of the centralized join algorithms <ref> [Ore86, BKS93, G un93, HJR97, GS87, LR94, HS95, LR96, PD96] </ref>. In this chapter, the local processing is done using the PBSM join algorithm [PD96] (described in Section 2.3). The final refinement phase is required for two reasons.
Reference: [KF92] <author> I. Kamel and C. Faloutsos. </author> <title> Parallel RTrees. </title> <booktitle> In Proceedings of the 1992 ACM-SIGMOD Conference, </booktitle> <address> San Diego, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: The data used in the study is synthetically generated, and is uniformly distributed in the space. Consequently, data distribution skew is not considered at all. Kamel and Faloutsos <ref> [KF92] </ref> have examined the use of parallelism to accelerate the performance of spatial selections. They examined techniques to distribute the leaves of an R-tree [Gut84] across multiple disks in a system, and evaluated various placement policies for the leaf pages.
Reference: [KFK96] <author> N. Koudas, C. Faloutsos, and I. Kamel. </author> <title> Declustering Spatial Databases on a Multi Computer Architecture. </title> <booktitle> In EDBT, </booktitle> <pages> pages 592614, </pages> <year> 1996. </year>
Reference-contexts: The parallel architecture that was targeted has one processor with multiple disks attached to it, and the effectiveness of the declustering strategy is examined only for a simple environment where the queries consist only of simple spatial selections. This idea was later extended by Koudas, Faloutsos and Kamel <ref> [KFK96] </ref> to decluster spatial data on a shared-nothing architecture. One node in the system was dedicated for performing the bookkeeping associated with mapping the leaves of the R-tree to the other nodes in the system. Again, the focus was on an environment with spatial selection queries.
Reference: [KHT89] <author> M. Kitsuregawa, L. Harada, and M. Takagi. </author> <title> Join Strategies on KD-Tree Indexed Relations. </title> <journal> In IEEE Transactions on Knowledge and Data Engineering, </journal> <year> 1989. </year>
Reference-contexts: The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. Grid files [NHS84] and kd-trees [Ben75, Ben79] have also been employed for 7 evaluating multi-attribute joins in the relational domain <ref> [KHT89, HNKT90, BHF93] </ref>. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use Operate without of an Index an Index * Z-values [OM84] Transform the * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees <ref> [KHT89, HNKT90] </ref> Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the [BKS93, G un93, HS95, HJR97, KS97] * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before joining [LR94, LR95] Table 1: Classification of Various Spatial Join
Reference: [KNT89] <author> M. Kitsuregawa, M. Nakayama, and M. Takagi. </author> <title> The Effect of Bucket Size Tuning in the Dynamic Hybrid GRACE Hash Join Method. </title> <booktitle> In Proceedings of the 15th VLDB Conf., </booktitle> <pages> pages 257266, </pages> <year> 1989. </year>
Reference-contexts: Consequently, with the Tiger data set, there are very few road segments that overlap multiple tiles, which in turn causes the replication overhead to be low. 2.3.5 Handling Partition Skew Similar to the partition skew problem for Grace Join <ref> [KTM83, DKO + 84, Sha86, KNT89] </ref>, it is possible for the PBSM algorithm to end up with partition pairs that do not fit entirely in memory (for example, if most of the data is concentrated in a very small cluster).
Reference: [KS97] <author> N. Koudas and K. C. Sevcik. </author> <title> Size Separation Spatial Join. </title> <booktitle> In Proceedings of the 1997 ACM-SIGMOD Conference, </booktitle> <pages> pages 324335, </pages> <address> Tucson, Arizona, USA, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: In their approach, spatial sampling techniques are used for constructing seeded trees on both inputs, and the seeded trees are joined using the tree join algorithm of [BKS93]. Similar to the seeded tree approach, Koudas and Sevcik <ref> [KS97] </ref> propose building a filter tree on the inputs and joining the two filter trees. A filter tree, like a Quad Tree, is based on a regular decomposition of space. However, unlike other spatial indices, a filter tree can have objects at the non-leaf nodes. <p> Require Use Operate without of an Index an Index * Z-values [OM84] Transform the * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the <ref> [BKS93, G un93, HS95, HJR97, KS97] </ref> * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before joining [LR94, LR95] Table 1: Classification of Various Spatial Join Algorithms 2.3 Partition-Based Spatial-Merge Join This section describes a new algorithm, called the Partition-Based Spatial-Merge (PBSM) join,
Reference: [KTM83] <author> M. Kitsuregawa, H. Tanaka, and T. MotoOka. </author> <title> Application of hash to database machine and its architecture. New Generation Computing, </title> <publisher> Springer Verlag (Heidelberg, </publisher> <address> FRG and NewYork NY, USA)-Verlag, (1), </address> <year> 1983. </year>
Reference-contexts: Consequently, with the Tiger data set, there are very few road segments that overlap multiple tiles, which in turn causes the replication overhead to be low. 2.3.5 Handling Partition Skew Similar to the partition skew problem for Grace Join <ref> [KTM83, DKO + 84, Sha86, KNT89] </ref>, it is possible for the PBSM algorithm to end up with partition pairs that do not fit entirely in memory (for example, if most of the data is concentrated in a very small cluster).
Reference: [LR94] <author> M. L. Lo and C. V. Ravishankar. </author> <title> Spatial Joins Using Seeded Trees. </title> <booktitle> In Proceedings of the 1994 ACM-SIGMOD Conference, </booktitle> <address> Minneapolis, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Hoel and Samet [HS95] propose a tree join algorithm for the PMR quad tree, and compare the efficiency of variants of the PMR quad tree with variants of the R-tree [HS95]. When one of the inputs to the spatial join does not have a spatial index, Lo and Ravishankar <ref> [LR94] </ref> propose building a seeded tree index on that input. A seeded tree is a R-tree that is allowed to be height unbalanced. <p> * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the [BKS93, G un93, HS95, HJR97, KS97] * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before joining <ref> [LR94, LR95] </ref> Table 1: Classification of Various Spatial Join Algorithms 2.3 Partition-Based Spatial-Merge Join This section describes a new algorithm, called the Partition-Based Spatial-Merge (PBSM) join, for evaluating a spatial join. <p> In the join phase, each operator looks at the fragment of the declustered relation residing on its local disks and joins them using any of the centralized join algorithms <ref> [Ore86, BKS93, G un93, HJR97, GS87, LR94, HS95, LR96, PD96] </ref>. In this chapter, the local processing is done using the PBSM join algorithm [PD96] (described in Section 2.3). The final refinement phase is required for two reasons.
Reference: [LR95] <author> M. L. Lo and C. V. Ravishankar. </author> <title> Generating Seeded Trees From Data Sets. </title> <booktitle> In Proceedings of the Fourth International Symposium on Large Spatial Databases, </booktitle> <address> Portland, ME, </address> <month> August </month> <year> 1995. </year> <month> 72 </month>
Reference-contexts: The two indices are then joined using the tree join algorithm described by Brinkhoff, Kriegel and Seeger [BKS93]. Lo and Ravishankar <ref> [LR95] </ref> have extended this work to handle the case when neither of the inputs have an index. In their approach, spatial sampling techniques are used for constructing seeded trees on both inputs, and the seeded trees are joined using the tree join algorithm of [BKS93]. <p> * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the [BKS93, G un93, HS95, HJR97, KS97] * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before joining <ref> [LR94, LR95] </ref> Table 1: Classification of Various Spatial Join Algorithms 2.3 Partition-Based Spatial-Merge Join This section describes a new algorithm, called the Partition-Based Spatial-Merge (PBSM) join, for evaluating a spatial join.
Reference: [LR96] <author> M. L. Lo and C. V. Ravishankar. </author> <title> Spatial HashJoins. </title> <booktitle> In Proceedings of the 1996 ACM-SIGMOD Conference, </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: However, these algorithms are not very efficient with respect to the number of disk I/Os, and in some cases require logarithmic number of passes over the input. Concurrent with our work on PBSM, Lo and Ravishankar have proposed a spatial hash join algorithm <ref> [LR96] </ref> that is, in many aspects, similar to PBSM. The spatial hash algorithm first partitions both the inputs, and then joins each of the partitions. Upper levels of a seeded tree are used for the partition function, and a filtering technique is employed during the partitioning phase. <p> Upper levels of a seeded tree are used for the partition function, and a filtering technique is employed during the partitioning phase. A performance study, based on counting the number of disk I/Os, is also presented by Lo and Ravishankar <ref> [LR96] </ref>, but that study ignores the very expensive refinement step. To summarize, we can classify all these algorithms as shown in Table 1. <p> Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the [BKS93, G un93, HS95, HJR97, KS97] * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join <ref> [LR96] </ref> space before joining [LR94, LR95] Table 1: Classification of Various Spatial Join Algorithms 2.3 Partition-Based Spatial-Merge Join This section describes a new algorithm, called the Partition-Based Spatial-Merge (PBSM) join, for evaluating a spatial join. <p> In the join phase, each operator looks at the fragment of the declustered relation residing on its local disks and joins them using any of the centralized join algorithms <ref> [Ore86, BKS93, G un93, HJR97, GS87, LR94, HS95, LR96, PD96] </ref>. In this chapter, the local processing is done using the PBSM join algorithm [PD96] (described in Section 2.3). The final refinement phase is required for two reasons.
Reference: [MC80] <author> C. Mead and L. Conway. </author> <title> Introduction to VLSI Systems. </title> <address> AddisonWesley, Reading, Mass., </address> <year> 1980. </year>
Reference-contexts: The merge algorithm closely resembles the z-values merge algorithm of Orenstein [Ore89]. The problem of finding pairwise intersection between two sets of rectangles has been extensively studied in the VLSI domain <ref> [MC80] </ref>, and numerous solutions exist for the case when both the input set of rectangles fit in memory [PS88].
Reference: [MGR91] <author> D. J. Maguire, M. F. Goodchild, and D. W. </author> <title> Rhind. </title> <journal> Geographic Information Systems, </journal> <volume> volume 1. </volume> <publisher> Longman Scientific & Technical, copublished in the US with John Wiley & Sons, Inc. </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Spatial database users frequently need to combine two spatial inputs based on some spatial relationship between the objects in the two inputs. For example, map overlap, which requires combining two maps to produce a third, is an important operation in a spatial database <ref> [Bur86, MGR91] </ref>. This operation of combining two inputs based on an element-wise spatial relationship is called a spatial join. Spatial joins, just like their counterparts in a relational system, are an expensive operation. Consequently, efficient spatial join algorithms are a critical component of any spatial database system.
Reference: [MJFS96] <author> B. Moon, H. Jagadish, C. Faloutsos, and J. Saltz. </author> <title> Analysis of the Clustering Properties of Hilbert Space-filling Curve. </title> . <institution> University of Maryland Institute for Advanced Computer Studies Dept. of Computer Science, Univ. of Maryland, </institution> <month> March </month> <year> 1996. </year>
Reference-contexts: The key-pointer information is then spatially sorted based on the M BR. Spatial sorting is accomplished by transforming the center point of the M BR into a one dimensional Hilbert value ([Hil91] as referred to in <ref> [MJFS96] </ref>) , and using this value for ordering the key-pointer information. This sorting step brings together key-pointer pairs whose joining attributes are spatially close. The spatial index, which in our case is a R*-tree, is then built in a bottom up fashion [DKL + 94].
Reference: [NHS84] <author> J. Nievergelt, H. Hinterberger, and K. C. Sevcik. </author> <title> The Grid File: An Adaptable, Symmetric Multikey File Structure. </title> <journal> ACM Transactions on Database Systems, </journal> <month> March </month> <year> 1984. </year>
Reference-contexts: The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. Grid files <ref> [NHS84] </ref> and kd-trees [Ben75, Ben79] have also been employed for 7 evaluating multi-attribute joins in the relational domain [KHT89, HNKT90, BHF93]. These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93].
Reference: [NS86] <author> R. C. Nelson and H. Samet. </author> <title> A Consistent Hierarchical Representation for Vector Data. </title> <journal> In Computer Graphics, </journal> <volume> volume 20(4), </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: These methods can also be used for evaluating the filter step by storing the bounding box of the spatial objects as points in a higher dimension [BHF93]. Recently, spatial index structures such as R-trees [Gut84], R+-trees [CFR87], R*-trees [BKSS90], and PMR quad trees <ref> [NS86] </ref> have been used to speed up the evaluation of the spatial join. Using analytical models, G unther compares join algorithms that use generalization trees (which is a class of tree structures that includes the R-tree, R*-tree and R+tree) with the nested-loops join and join indices [G un93].
Reference: [OM84] <author> J. A. Orenstein and T. H. Merrett. </author> <title> A Class of Data Structures for Associative Searching. </title> <booktitle> In Proceedings of the 3rd ACM SIGACTSIGMOD Symposium on Principles of Database Systems, </booktitle> <year> 1984. </year>
Reference-contexts: The transformed values, which are called z-values, are then used in a spatial join algorithm that merges two sequences of z-values. The z-values, being 1-dimensional values, can be stored in a traditional indexing structure such as a B-tree <ref> [OM84] </ref>. The performance of the spatial join algorithm using z-values was found to be sensitive to the choice of the grid [Ore89]. <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use Operate without of an Index an Index * Z-values <ref> [OM84] </ref> Transform the * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the [BKS93, G un93, HS95, HJR97, KS97] * PBSM [PD96] two dimensional *
Reference: [OM88] <author> J. A. Orenstein and F. A. Manola. </author> <title> PROBE Spatial Data Modeling and Query Processing in an Image Database Application. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> volume 14(5), </volume> <month> May </month> <year> 1988. </year>
Reference-contexts: One of the earliest solutions to the spatial join is based on using approximate geometry, wherein the universe of the spatial data is regularly decomposed by superimposing a grid on it <ref> [Ore86, OM88] </ref>. Each element of the grid is called a pixel, and spatial objects are approximated by pixels that overlap them. Each pixel, which is described by its spatial location, is transformed into a 1-dimensional domain by applying a mapping called the z-order. <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use Operate without of an Index an Index * Z-values [OM84] Transform the * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values <ref> [Ore86, OM88] </ref> another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the [BKS93, G un93, HS95, HJR97, KS97] * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before joining [LR94, LR95] Table
Reference: [OR93] <author> F. Olken and D. Rotem. </author> <title> Sampling from Spatial Databases. </title> <booktitle> pages 199208, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: This strategy is referred to as decluster creating spatial surrogates (D-PSS). Both D-W and D-PSS require a large number of 44 Surrogates tiles (few thousands for a few tens of nodes) to get a good data distribution. Spatial sampling techniques <ref> [OR93] </ref> can also be used to estimate the appropriate number of tiles. Note that both replicating whole tuples and creating partial spatial surrogates has an associated update overhead.
Reference: [Ore86] <author> J. A. Orenstein. </author> <title> Spatial Query Processing in an ObjectOriented Database System. </title> <booktitle> In Proceedings of the 1986 ACM-SIGMOD Conference, </booktitle> <year> 1986. </year>
Reference-contexts: One of the earliest solutions to the spatial join is based on using approximate geometry, wherein the universe of the spatial data is regularly decomposed by superimposing a grid on it <ref> [Ore86, OM88] </ref>. Each element of the grid is called a pixel, and spatial objects are approximated by pixels that overlap them. Each pixel, which is described by its spatial location, is transformed into a 1-dimensional domain by applying a mapping called the z-order. <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use Operate without of an Index an Index * Z-values [OM84] Transform the * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values <ref> [Ore86, OM88] </ref> another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the [BKS93, G un93, HS95, HJR97, KS97] * PBSM [PD96] two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before joining [LR94, LR95] Table <p> In the join phase, each operator looks at the fragment of the declustered relation residing on its local disks and joins them using any of the centralized join algorithms <ref> [Ore86, BKS93, G un93, HJR97, GS87, LR94, HS95, LR96, PD96] </ref>. In this chapter, the local processing is done using the PBSM join algorithm [PD96] (described in Section 2.3). The final refinement phase is required for two reasons.
Reference: [Ore89] <author> J. A. Orenstein. </author> <title> Redundancy in Spatial Databases. </title> <booktitle> In Proceedings of the 1989 ACM-SIGMOD Conference, </booktitle> <year> 1989. </year>
Reference-contexts: The z-values, being 1-dimensional values, can be stored in a traditional indexing structure such as a B-tree [OM84]. The performance of the spatial join algorithm using z-values was found to be sensitive to the choice of the grid <ref> [Ore89] </ref>. Choosing a fine grid increases the efficiency of the filtering technique, but it also increases the space requirement, since a larger number of z-values are required to approximate an object. <p> However, unlike other spatial indices, a filter tree can have objects at the non-leaf nodes. The join algorithm first constructs the two filter trees and joins the two filter trees using an n-way merge algorithm. The merge algorithm closely resembles the z-values merge algorithm of Orenstein <ref> [Ore89] </ref>. The problem of finding pairwise intersection between two sets of rectangles has been extensively studied in the VLSI domain [MC80], and numerous solutions exist for the case when both the input set of rectangles fit in memory [PS88].
Reference: [Ore90] <author> J. A. Orenstein. </author> <title> A Comparison of Spatial Query Processing Techniques for Native and Parameter Spaces. </title> <booktitle> In Proceedings of the 1990 ACM-SIGMOD Conference, </booktitle> <year> 1990. </year>
Reference-contexts: of any fault line. 6 2.2 Previous Work Since the representation of a spatial object can be very large (for example, a spatial object representing a city boundary might require thousands of points to represent the exact geometric shape), spatial operations, including the spatial join, typically operate in two steps <ref> [Ore90] </ref>: * Filter Step: In this step, an approximation of each spatial object, such as its minimum bounding rectangle, is used to perform an element-wise pairing between the tuples from the two input data sets. This step produces candidates that are a superset of the actual result.
Reference: [PD96] <author> J. M. Patel and D. J. DeWitt. </author> <title> Partition based spatialmerge join. </title> <booktitle> In Proceedings of ACM SIGMOD 1996, </booktitle> <pages> pages 259270, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Index * Z-values [OM84] Transform the * Join Indices [Rot91] approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the [BKS93, G un93, HS95, HJR97, KS97] * PBSM <ref> [PD96] </ref> two dimensional * Build 1 or 2 indices * Spatial Hash Join [LR96] space before joining [LR94, LR95] Table 1: Classification of Various Spatial Join Algorithms 2.3 Partition-Based Spatial-Merge Join This section describes a new algorithm, called the Partition-Based Spatial-Merge (PBSM) join, for evaluating a spatial join. <p> Again, the focus was on an environment with spatial selection queries. Recently, Zhou, Abel and Truffet [ZAT97], have examined data partitioning mechanism for parallel spatial join processing. Similar to the spatial partitioning function used in <ref> [PD96] </ref> (see Section 2.3.4), the data is partitioned by first dividing the space into cells, and then the cells are mapped to partitions. In this partitioning scheme, a single object may be mapped to multiple partitions. <p> In the join phase, each operator looks at the fragment of the declustered relation residing on its local disks and joins them using any of the centralized join algorithms <ref> [Ore86, BKS93, G un93, HJR97, GS87, LR94, HS95, LR96, PD96] </ref>. In this chapter, the local processing is done using the PBSM join algorithm [PD96] (described in Section 2.3). The final refinement phase is required for two reasons. <p> In this chapter, the local processing is done using the PBSM join algorithm <ref> [PD96] </ref> (described in Section 2.3). The final refinement phase is required for two reasons. First, if one of the inputs in the partitioning is redeclustered using D-PSS (see Section 4.3.2), then the join phase will use the fragment box for joining 46 the two relations. <p> is: C DW (R) = jRj fi C I=O (Cost of reading the input) + jjRjj fi C F ragBox (Cost of f ragmenting tuples) + jRj fi F Repl fi C Net (Send tuples to the next operator) The next operator, the local spatial join, uses the PBSM algorithm <ref> [PD96] </ref>. This executes in two steps, the filter step and the refinement step. The filter step of the spatial join first extracts the MBR and the OID of the input tuples, and stores this information internally in a relation.
Reference: [PS88] <author> F. P. Preparata and M. I. Shamos, </author> <title> editors. Computational Geometry. </title> <publisher> Springer, </publisher> <year> 1988. </year>
Reference-contexts: The merge algorithm closely resembles the z-values merge algorithm of Orenstein [Ore89]. The problem of finding pairwise intersection between two sets of rectangles has been extensively studied in the VLSI domain [MC80], and numerous solutions exist for the case when both the input set of rectangles fit in memory <ref> [PS88] </ref>. In [GS87], G uting and Shilling examine the rectangle intersection problem when the inputs are too large to fit in memory, and analyze the time and space complexity 8 of two algorithms that are based on external computational geometry algorithms. <p> The problem then simplifies to finding all M BRs in R kp that intersect with some M BR in S kp . Rectangle intersection (the M BRs are rectangles) has been extensively studied in the computational geometry field <ref> [PS88] </ref>. Given two sets of rectangles, such that both the sets fit entirely in main memory, efficient computational geometry algorithms, based on plane-sweeping techniques, exist for reporting all pairs of intersecting rectangles between the two sets. <p> For example, the key-pointer element for the object shown in Figure 2, will be inserted into partitions 0 and 2. After both the inputs R and S have been partitioned, the algorithm joins the partitions using a computational geometry based plane-sweeping technique <ref> [PS88] </ref> which simulates a sweep line that sweeps through the space from left to right detecting overlapping rectangle pairs. <p> The S tuples are then read sequentially into memory, and the join attributes of the R and the S tuple are checked to determine if the join condition is satisfied. interval-tree <ref> [PS88] </ref>. 12 2.3.3 Determining the Number of Partitions The number of partitions for the PBSM algorithm can be estimated as follow. Let jjRjj represent the cardinality of the input R, and jjSjj represent the cardinality of the input S.
Reference: [PYK + 97] <author> J. M. Patel, J. Yu, N. Kabra, K. Tufte, B. Nag, J. Burger, N. E. Hall, K. Ramasamy, R. Lueder, C. Ellman, J. Kupsch, S. Guo, D. J. DeWitt, and J. F. Naughton. </author> <title> Building a Scaleable Geo Spatial DBMS: </title> <booktitle> Technology, Implementation, and Evaluation.. In Proceedings of the 1997 ACM-SIGMOD Conference, </booktitle> <pages> pages 336347, </pages> <address> Tucson, Arizona, USA, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: The operator tree for this is shown in Figure 24. 3.5 Performance Evaluation This section contains the results of implementing the spatial aggregate algorithm described in the previous section in the Paradise <ref> [DKL + 94, PYK + 97] </ref> geo-spatial database system. The hardware platform for this performance evaluation was a Solaris 2.5 machine with dual 133 MHz Pentium processors, and 128 MBytes of memory. <p> These algorithms were implemented inside Paradise, a scalable geo-spatial database system <ref> [PYK + 97] </ref>. 5.5.1 Data Sets The data sets that are used in this benchmark come from the DCW data product [DCW92]. We used the drainage, road and rail data sets. The drainage data set describes, using polylines, drainage features, such rivers, streams, canals, etc., for the entire world.
Reference: [Qua97] <institution> Quantify User's Guide. Pure Software Inc., 1309 Spouth Mary Avenue, </institution> <address> Sunnyvale CA 94087, </address> <year> 1997. </year>
Reference-contexts: The system parameters for the model are shown in Table 11, and the parameters that characterize the data sets are shown in Table 12. The system parameters are measured in terms of the CPU cycles using a performance measuring tool quantify <ref> [Qua97] </ref>.
Reference: [RKV95] <author> N. Roussopoulos, S. Kelley, and F. Vincent. </author> <title> Nearest Neighbor Queries. </title> <booktitle> In Proceedings of the 1995 ACM-SIGMOD Conference, </booktitle> <pages> pages 7179, </pages> <address> San Jose, </address> <month> May </month> <year> 1995. </year> <month> 73 </month>
Reference-contexts: An algorithm for solving the nearest-neighbor problem with k-d trees [Rob81] was proposed by Friedman, Bentley and Finkel [FBF77]. This algorithm was later refined by Sproull [Spr91]. Roussopoulos, Kelley and Vincent <ref> [RKV95] </ref> have proposed a branch-and-bound search algorithm for finding the nearest neighbors using R-trees [Gut84].
Reference: [Rob81] <author> J. T. Robinson. </author> <title> The K-D-B Tree: A Search Structure for Large Multidimensional Dynamic Indexes. </title> <booktitle> In Proceedings of the 1981 ACM-SIGMOD Conference, </booktitle> <month> April </month> <year> 1981. </year>
Reference-contexts: Then, it backtracks the path that it just traversed, and uses a heuristic to search the subtrees that potentially contain the n nearest-neighbors. An algorithm for solving the nearest-neighbor problem with k-d trees <ref> [Rob81] </ref> was proposed by Friedman, Bentley and Finkel [FBF77]. This algorithm was later refined by Sproull [Spr91]. Roussopoulos, Kelley and Vincent [RKV95] have proposed a branch-and-bound search algorithm for finding the nearest neighbors using R-trees [Gut84].
Reference: [Rot91] <author> D. Rotem. </author> <title> Spatial Join Indices. </title> <journal> In IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> Kobe, </volume> <month> April </month> <year> 1991. </year>
Reference-contexts: In the relational domain, Valduriez proposed the use of join indices [Val87] to improve the performance of the relational join operator. Drawing an analogy from the join indices, Rotem <ref> [Rot91] </ref> proposed a spatial join index that partially precomputes the results of a spatial join. The algorithm for building the spatial join index requires grid files for indexing the spatial data, and uses these grid files to compute the spatial join index. <p> To summarize, we can classify all these algorithms as shown in Table 1. Require Use Operate without of an Index an Index * Z-values [OM84] Transform the * Join Indices <ref> [Rot91] </ref> approximation into * Grid Files [HNKT90, BHF93] * Z-values [Ore86, OM88] another dimension * kd-trees [KHT89, HNKT90] Use the approximation * Synchronized Tree Traversal * External VLSI algo [GS87] directly in the [BKS93, G un93, HS95, HJR97, KS97] * PBSM [PD96] two dimensional * Build 1 or 2 indices *
Reference: [Sam90] <author> H. Samet. </author> <title> Applications of Spatial Data Structures, Computer Graphics, Image Processing and GIS. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Many algorithms have been proposed for finding the n nearest-neighbors. Most of these algorithms make use of a spatial index to speed up evaluation of this operation. Samet <ref> [Sam90] </ref> proposed an algorithm to find the n nearest-neighbors using a PM Quad Tree index [Tam81]. This algorithm first traverses the quadtree from the root to find the leaf that contains the query point.
Reference: [SFGM93] <author> M. Stonebraker, J. Frew, K. Gardels, and J. Meredith. </author> <title> The SEQUOIA 2000 Storage Benchmark. </title> <booktitle> In Proceedings of the 1993 ACM-SIGMOD Conference, </booktitle> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The first data set is derived from the TIGER/Line files [Tig], and represents roads in the state of Wisconsin. This data set is 62.4MB in size, and contains 456,613 tuples. The second data set contains the polygon data from the Sequoia benchmark <ref> [SFGM93] </ref>. This data set contains 58,115 polygons and is 21.9MB in size. First, we explore the design space of the spatial partitioning function using the Tiger data. Figure 6 shows the effect of increasing the number of tiles, and choosing different tile-to-partition mapping schemes. <p> collection. 18 Data # of Total R*-tree Type Objects Size Size Road 456,613 62.4 MB 24.0 MB Hydrography 122,149 25.2 MB 6.5 MB Rail 16,844 2.4 MB 1.0 MB Table 2: Wisconsin TIGER Data For the third collection, the islands and polygon data sets from the Sequoia 2000 Storage Benchmark <ref> [SFGM93] </ref> were used. The polygon data set represents regions of homogeneous landuse characteristics in the State of California and Nevada, while the island data set represents holes in the polygon data (example, a lake in a park). <p> As shown in the figure, the replication overhead is quite small for this data set. However, the replication overhead could change dramatically if the data set has different characteristics. For example, consider the landuse data set from the Sequoia benchmark <ref> [SFGM93] </ref>. This data set is 32 MB in size and contains 60K landuse polygons for the state of California and Nevada. First, examine Figure 32 which shows the data distribution skew for this data set.
Reference: [Sha86] <author> L. D. Shapiro. </author> <title> Join processing in database systems with large main memories. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 11(3), </volume> <month> October </month> <year> 1986. </year>
Reference-contexts: Consequently, with the Tiger data set, there are very few road segments that overlap multiple tiles, which in turn causes the replication overhead to be low. 2.3.5 Handling Partition Skew Similar to the partition skew problem for Grace Join <ref> [KTM83, DKO + 84, Sha86, KNT89] </ref>, it is possible for the PBSM algorithm to end up with partition pairs that do not fit entirely in memory (for example, if most of the data is concentrated in a very small cluster).
Reference: [Sha96] <author> A. Shatdal. </author> <title> The Interaction Between Software and Hardware Architecture in Parallel Relational Database Query Processing. </title> <type> PhD Thesis, </type> <institution> Computer Sciences Department, UW-Madison, </institution> <year> 1996. </year>
Reference-contexts: Starting only one instance of the global aggregate operator might be more efficient than starting an instance of the global aggregate at every node in the the system <ref> [Sha96] </ref>. Approach: Operator Tree Approach: Operator Tree Instance 6.1.2 Spatial Semi-Join The approach above benefits only marginally from parallelism. Every node evaluates the closest aggregate for every selected city tuple.
Reference: [SK91] <author> M. Stonebraker and G. Kemnitz. </author> <title> The POSTGRES next-generation database management system. </title> <journal> Comm. of the ACM, Special Section on Next-Generation Database Systems, </journal> <volume> 34(10):78, </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: Attributes of tuples in traditional relational systems are limited to simple types like numeric, dates and character strings, but the new model, called the objectrelational model, allows the extension of these basic types to include types like images, videos, points, polygons, circles, polylines, etc <ref> [SK91, DKL + 94] </ref>. The objectrelational model also allows functions to be defined on these types, and allows these functions to appear in queries that are posed to the system. Such a database system can both store and manipulate complex types inside the database system, making them easier to use.
Reference: [Spr91] <author> R. F. Sproull. </author> <title> Refinements to nearestneighbor searching in kdimensional trees. </title> <address> Algorith-mica, 6(4):579589, </address> <year> 1991. </year>
Reference-contexts: Then, it backtracks the path that it just traversed, and uses a heuristic to search the subtrees that potentially contain the n nearest-neighbors. An algorithm for solving the nearest-neighbor problem with k-d trees [Rob81] was proposed by Friedman, Bentley and Finkel [FBF77]. This algorithm was later refined by Sproull <ref> [Spr91] </ref>. Roussopoulos, Kelley and Vincent [RKV95] have proposed a branch-and-bound search algorithm for finding the nearest neighbors using R-trees [Gut84].
Reference: [Tam81] <author> M. Tamminen. </author> <title> The EXCELL Method for Efficient Geometric Access to Data. </title> <booktitle> In Acta Polytechnica Scandinavica, 1981. (Mathematics and Computer Science Series No. </booktitle> <pages> 34). </pages>
Reference-contexts: Many algorithms have been proposed for finding the n nearest-neighbors. Most of these algorithms make use of a spatial index to speed up evaluation of this operation. Samet [Sam90] proposed an algorithm to find the n nearest-neighbors using a PM Quad Tree index <ref> [Tam81] </ref>. This algorithm first traverses the quadtree from the root to find the leaf that contains the query point. Then, it backtracks the path that it just traversed, and uses a heuristic to search the subtrees that potentially contain the n nearest-neighbors.
Reference: [Tig] <author> U. S. </author> <title> Bureau of the Census, </title> <address> Washington, DC. TIGER/Line Files(TM), </address> <note> 1992 Technical Documentation. </note>
Reference-contexts: For the tile-to-partition mapping scheme, one could use either round robin or hashing on the tile number. To explore these alternatives, we have chosen two data sets. The first data set is derived from the TIGER/Line files <ref> [Tig] </ref>, and represents roads in the state of Wisconsin. This data set is 62.4MB in size, and contains 456,613 tuples. The second data set contains the polygon data from the Sequoia benchmark [SFGM93]. This data set contains 58,115 polygons and is 21.9MB in size. <p> Both parts of the study used three collections of data sets. The first collection was derived from the TIGER/Line files <ref> [Tig] </ref> for the State of Wisconsin. The TIGER data is developed and distributed by the U.S. Bureau of the Census, and contains detailed geographic and cartographic information for the United States. From the TIGER files, three data sets were extracted (see Table 2).
Reference: [TY95] <author> K.-L. Tan and J. X. Yu. </author> <title> A Performance Study of Declustering Strategies for Parallel Spatial Databases. </title> <booktitle> In The 6th International Conference on Database and Expert Systems Applications (DEXA), </booktitle> <pages> pages 157166, </pages> <address> London, United Kingdom, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: The spatial partitioning function just described is the spatial analog of virtual processor round robin partitioning for handling skews in parallel relational joins [DNSS92]. A similar partitioning function has been independently proposed for redundancy-based declustering of spatial objects in a parallel spatial database <ref> [TY95] </ref>, but in that proposal the number of tiles always equals the number of partitions. The design space for choosing the spatial partitioning function has two axes: the number of tiles used in the partitioning function, and the tile-to-partition mapping scheme. <p> This section reviews the related work in declustering spatial data. Tan and Yu <ref> [TY95] </ref> have proposed a few techniques for declustering spatial data, and have evaluated the effect of these declustering techniques on spatial selections. The data used in the study is synthetically generated, and is uniformly distributed in the space. Consequently, data distribution skew is not considered at all.
Reference: [Ube94] <author> M. Ubell. </author> <title> The Montage Extensible DataBlade Architecture. </title> <booktitle> In Proceedings of the 1994 ACM-SIGMOD Conference, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: The first algorithm is based on the traditional indexed nested-loops algorithm and the other is based on the R-tree join algorithm [BKS93]. These algorithms use spatial indices, and were chosen because most spatial databases support some form of spatial indexing (for example, R-trees in Illustra <ref> [Ube94] </ref>). Such systems can easily use these index-based join algorithms. This study is not a meant to be a comprehensive performance study of all possible spatial join algorithms (refer to Table 1 for a classification of spatial join algorithms). <p> To the best of our knowledge, most commercial spatial database systems do not transform the approximations of spatial objects into another domain (for example, ARC/INFO [Arc95], and Illustra <ref> [Ube94] </ref>). The remainder of this section is organized as follows. First the index nested-loops and the R-tree-based join algorithms are described.
Reference: [Val87] <author> P. Valduriez. </author> <title> Join Indices. </title> <journal> In ACM TODS, </journal> <volume> volume 12(2), </volume> <year> 1987. </year>
Reference-contexts: Choosing a fine grid increases the efficiency of the filtering technique, but it also increases the space requirement, since a larger number of z-values are required to approximate an object. In the relational domain, Valduriez proposed the use of join indices <ref> [Val87] </ref> to improve the performance of the relational join operator. Drawing an analogy from the join indices, Rotem [Rot91] proposed a spatial join index that partially precomputes the results of a spatial join. <p> The refinement step eliminates these duplicates, and examines the actual R and S tuples to determine if the attributes actually satisfy the join condition. To avoid random seeks in fetching the R and S tuples, a strategy similar to that used by Valduriez <ref> [Val87] </ref> is employed. First, the OID pairs are sorted using OID R as the primary sort key and OID S as the secondary sort key. Duplicates entries are eliminated during this sort.
Reference: [WDJ91] <author> C. B. Walton, A. G. Dale, and R.M. Jenevein. </author> <title> A Taxonomy and Performance Model of Data Skew Effects in Parallel Joins. </title> <booktitle> In Proceedings of the 17th VLDB Conf., </booktitle> <pages> pages 537548, </pages> <address> Barcelona, Spain, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: Since very few tuples get mapped to the other nodes, the resulting declustering of tuples is highly skewed. In a parallel system, such skew can cause severe performance problems <ref> [WDJ91] </ref>. To mitigate this problem, we divide the universe into many small regions called tiles. Then, the tiles are assigned unique tile numbers by walking through the tiles in a row major or column major order.
Reference: [ZAT97] <author> X. Zhou, D. J. Abel, and D. Truffet. </author> <title> Data Partitioning For Parallel Spatial Join Processing. </title> <booktitle> In Proceedings of 5th Intl. Symp. On Large Spatial Databases, </booktitle> <pages> pages 178196, </pages> <address> Berlin, Germany, </address> <month> July </month> <year> 1997. </year>
Reference-contexts: One node in the system was dedicated for performing the bookkeeping associated with mapping the leaves of the R-tree to the other nodes in the system. Again, the focus was on an environment with spatial selection queries. Recently, Zhou, Abel and Truffet <ref> [ZAT97] </ref>, have examined data partitioning mechanism for parallel spatial join processing. Similar to the spatial partitioning function used in [PD96] (see Section 2.3.4), the data is partitioned by first dividing the space into cells, and then the cells are mapped to partitions. <p> One way of ensuring this is to replicate the polygon A at both the nodes (as proposed by Zhou, Abel and Truffet <ref> [ZAT97] </ref>). The problem with this declustering strategy is that it might produce a skewed distribution of data. As an example, consider declustering a relation in a four-node system where most of the declustering spatial attributes are located in the upper left corner (see Figure 28). <p> Algorithm B replicates entire tuples during the redeclustering process, essentially creating clones. Subsequently, we refer to this algorithm as the Clone Join. The Shadow join algorithm just described is similar to the parallel spatial join proposed by Zhou, Abel and Truffet <ref> [ZAT97] </ref>. The declustering strategy employed that algorithm is a form of D-PSS. In D-PSS, when a spatial attribute overlaps tiles that are mapped to multiple nodes, the MBR of the spatial attribute is broken up into fragment boxes (refer to Section 4.3.2). <p> The fragment boxes are then sent to the appropriate node. This step ensures that a node only sees the portion of the spatial attribute that is relevant to the space covered at that node. In <ref> [ZAT97] </ref>, when a spatial attribute overlaps tiles that are mapped to multiple nodes, the entire MBR is replicated.
Reference: [ZG90] <author> H. Zeller and J. Gray. </author> <title> An Adaptive Hash Join Algorithm for Multiuser Environments. </title> <booktitle> In Proceedings of the 16th VLDB Conf., </booktitle> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: One possible way to handle this problem would be to dynamically repartition the overflown partition pair. Another alternative is to increase the number of partitions (limited to the number of available main memory buffer pages) and using schemes similar to those used by the Adaptive Hash join algorithm <ref> [ZG90] </ref>. However, the current implementation of PBSM does not incorporate any of these techniques. 2.4 Performance Evaluation In this section, we compare the PBSM join algorithm with two other spatial join algorithms. <p> However, with both these techniques the replication overhead, which is the increase in the number of tuples due to replication, increases. We note that over-partitioning (dividing the input into many more partitions than required) has been used in the Adaptive hash join algorithm for dealing with partition skew <ref> [ZG90] </ref>. For the numbers presented in this section, the buffer pool size is fixed at 8MB. <p> The distinct operator uses the an adaptive hashing algorithm <ref> [ZG90] </ref> to remove the duplicates. If required, the input is broken into partitions such that each partition fits in memory.
References-found: 65

