URL: ftp://ftp.cs.umd.edu/pub/papers/papers/2469/2469.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Title: THE POLYLITH SOFTWARE BUS  
Author: James M. Purtilo 
Note: Classification: D.2.2, D.3.3.  
Address: College Park, MD 20742  
Affiliation: Computer Science Department and Institute for Advanced Computer Studies University of Maryland  
Abstract: We describe a system called Polylith that helps programmers prepare and interconnect mixed-language software components for execution in heterogeneous environments. Polylith's principal benefit is that programmers are free to implement functional requirements separately from their treatment of interfacing requirements; this means that once an application has been developed for use in one execution environment (such as a distributed network) it can be adapted for reuse in other environments (such as a shared-memory multiprocessor) by automatic techniques. This flexibility is provided without loss of performance. We accomplish this by creating a new run-time organization for software. An abstract decoupling agent, called the software bus, is introduced between the system components. Heterogeneity in language and architecture is accommodated since program units are prepared to interface directly to the bus, not to other program units. Programmers specify application structure in terms of a module interconnection language (MIL); Polylith uses this specification to guide packaging (static interfacing activities such as stub generation, source program adaptation, compilation and linking). At run time, an implementation of the bus abstraction may assist in message delivery, name service or system reconfiguration. 
Abstract-found: 1
Intro-found: 1
Reference: [BDWW89] <author> Barbacci, M., D. Doubleday, C. Weinstock and J. Wing. </author> <title> Developing applications for heterogeneous machine networks: The Durra environment. </title> <booktitle> Usenix Computing Systems, </booktitle> <volume> vol. 2, </volume> <year> (1989), </year> <pages> pp. 7-35. </pages>
Reference-contexts: Most recently, there appears to be a trend towards even stronger use of MIL-like languages for control of distributed applications, with the emergence of Conic's environment and toolset [MaKS89], and of Durra <ref> [BDWW89] </ref>. The Mercury system supports heterogeneity in applications by managing a networked object repository [LiSh88].
Reference: [BALL88] <author> Bershad, B., T. Anderson, E. Lazowska and H. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 8, no. 1, </volume> <month> (February </month> <year> 1990), </year> <pages> pp. 37-55. </pages>
Reference: [Bloc89] <author> Bloch, J. </author> <title> The Camelot library: C language extension for programming general purpose distributed transaction system. </title> <booktitle> Proc of 9th Conf on Distributed Computing Systems, </booktitle> <month> (June </month> <year> 1989), </year> <pages> pp. 172-180. </pages>
Reference-contexts: Especially appropriate for multiprocessor configurations are Camelot <ref> [Bloc89] </ref> (a transaction facility built on top of Mach) and Avalon (a language resource constructed using Camelot.) The V Kernel [Cher88] implements a distributed- and parallel-programming resource appropriate for a homogeneous set of hosts.
Reference: [Cher88] <author> Cheriton, D. </author> <title> The V distributed system. </title> <journal> CACM, </journal> <volume> vol. 31, </volume> <year> (1988), </year> <pages> pp. 314-333. </pages>
Reference-contexts: Especially appropriate for multiprocessor configurations are Camelot [Bloc89] (a transaction facility built on top of Mach) and Avalon (a language resource constructed using Camelot.) The V Kernel <ref> [Cher88] </ref> implements a distributed- and parallel-programming resource appropriate for a homogeneous set of hosts. The HCS project [NoBL88] shows one way for providing a heterogeneous RPC capability in a distributed environment; more recently, a `lightweight' remote procedure call was demonstrated [BALL90].
Reference: [DeKr76] <author> DeRemer, F. and H. Kron. </author> <title> Programming-in-the-Large Versus Programming-in-the-Small. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 2, no. 2, </volume> <month> (June </month> <year> 1976), </year> <pages> pp. 80-86. </pages>
Reference: [Essi87] <author> Essick, R. </author> <title> The cross-architecture procedure call. </title> <type> Doctoral dissertation. </type> <institution> UIUC Dept of Computer Science UIUC-R-87-1340, </institution> <year> (1987). </year>
Reference-contexts: Concert [YGSW89] and Marionette [SuAn89] are more variations on a theme. Several early projects emphasized a network filesystem approach (such as Locus [PWCE81].) An interesting approach to cross-architecture procedure call using a common backing-store is given by Essick <ref> [Essi87] </ref>. The ISO OSI framework for network interconnections appears similar to our approach [OSI81], but is more oriented to encapsulating decisions related to network concerns, as opposed to our focus on data and control integration.
Reference: [Feld78] <author> Feldman, S. I. </author> <title> Make A program for maintaining computer programs. </title> <institution> Bell Laboratories Report, </institution> <month> (August </month> <year> 1978). </year>
Reference-contexts: The Polylith packaging process is straightforward adaptation of such tools as the makefile system <ref> [Feld78] </ref>. Its only embellishment is that it is parameterized to accept the name of the bus for the target execution environment.
Reference: [FSAC89] <author> Finkel, R., M. Scott, et al. </author> <title> Experience with Charlotte: simplicity and function in a distributed operating system. </title> <journal> IEEE Trans Software Engineering, </journal> <volume> vol. 15, </volume> <month> (June </month> <year> 1989), </year> <pages> pp. 676-685. </pages>
Reference: [Gibb87] <author> Gibbons, P. </author> <title> A stub generator for multilanguage RPC in heterogeneous environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 13, no. 1, </volume> <month> (January </month> <year> 1987), </year> <month> pp.77-87. </month>
Reference-contexts: Inscape addresses many of the same sorts of packaging issues as Polylith. The AdaPIC tool set also focuses on stronger analysis of how interfaces are used, an activity blended with support for other development activities [WoCW89]. Our approach to simple stub generation is very similar to that of Gibbons <ref> [Gibb87] </ref>, although we can generate stubs from automatically extracted interface information, whereas Gibbons' Horus system requires users to explicitly declare interface structure. 16 Structure-oriented languages (containing some MIL features) were used to control a distributed program-ming environment in several earlier projects, notably CLU [LiAt81] and MESA [Swee85].
Reference: [HaMS88] <author> Hayes, R., S. Manweiler, and R. Schlichting. </author> <title> A simple system for constructing distributed, mixed-language programs. </title> <journal> Software Practice and Experience, </journal> <volume> vol. 18, no. 7, </volume> <month> (July </month> <year> 1988), </year> <pages> pp. 641-600. </pages>
Reference-contexts: Much work has been done in primitive data representation in the presence of heterogeneity. The Polylith approach benefited from review of previous experiences with Courier [Xero81]. Sun Microsystem's XDR [SunM88] is a similar approach, as is UTS, a `universal type system' internal to the MLP (Mixed Language Programming) system <ref> [HaMS88] </ref>. More abstractly, transmission of abstract data types (ADTs) is presented in [HeLi82]. Two new interface accessors, transmit and receive, are added to the ADT's signature, and the developer provides a suitable implementation of these routines for each host.
Reference: [HaNo86] <author> Habermann, N., D. Notkin. </author> <title> Gandalf: Software Development Environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 12, no. 12, </volume> <month> (December </month> <year> 1986), </year> <pages> pp. 1117-1127. </pages>
Reference-contexts: Early work on MILs was performed by DeRemer and Kron [DeKr75]. Shortly after, project Gandalf focused on the software development environment itself <ref> [HaNo86, Notk85] </ref>, implementing a MIL known as Intercol for describing the structure of an application [Tich80], and permitting mixed language programming (subject to the restriction that the language processors be created to conform to Gandalf interfacing structures.) Most recently, environments and languages such as Inscape and SLI are appearing [Perr89, WWRT91],
Reference: [HeLi82] <author> Herlihy, M., and B. Liskov. </author> <title> A value transmission method for abstract data types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 2, no. 4, </volume> <month> (October </month> <year> 1982), </year> <pages> pp. 527-551. </pages>
Reference-contexts: The Polylith approach benefited from review of previous experiences with Courier [Xero81]. Sun Microsystem's XDR [SunM88] is a similar approach, as is UTS, a `universal type system' internal to the MLP (Mixed Language Programming) system [HaMS88]. More abstractly, transmission of abstract data types (ADTs) is presented in <ref> [HeLi82] </ref>. Two new interface accessors, transmit and receive, are added to the ADT's signature, and the developer provides a suitable implementation of these routines for each host.
Reference: [JLHB88] <author> Jul, E., H. Levy, N. Hutchinson and A. Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> Transactions on Computer Systems, </journal> <volume> vol. 6, no. 1, </volume> <month> (February </month> <year> 1988), </year> <pages> pp. 109-133. </pages>
Reference-contexts: (and hence can be packaged in its own process space in appropriate environments); the MIL would bind the instance's accessors into those modules using it, and thereafter those modules would transact capability to that instance (rather than `flattening' it for transmission.) This approach is very similar to that shown in <ref> [JLHB88] </ref>, where a call by object-reference method is described in detail. Early work on MILs was performed by DeRemer and Kron [DeKr75].
Reference: [JoRT85] <author> Jones, M., R. Rashid and M. Thompson. Matchmaker: </author> <title> An Interface Specification Language for Distributed Processing. </title> <booktitle> Proce of 12th ACM Symposium of Principles of Programming Languages, </booktitle> <year> (1985). </year>
Reference-contexts: Both support distributed programming by coupling their notation with their supporting systems (Argus [Lisk88] and Pilot, respectively). Each of these systems represent a significant step forward in the area's ability to realize the vast potential of distributing a computation. Subsequently, Matchmaker <ref> [JoRT85] </ref> provided a transformational approach to the problem of integrating distributed components: an application would be written in a synthesis of, say, Pascal and a higher-level `specification language.' This source would be transformed into ordinary Pascal code having accessors to the host communication system inserted explicitly.
Reference: [Lamb87] <author> Lamb, D. A. </author> <title> IDL: Sharing intermediate representations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 9, no. 3, </volume> <month> (July </month> <year> 1987), </year> <pages> pp. 297-318. </pages>
Reference-contexts: Another alternative for strengthing Polylith's interface type system is IDL, the interface definition language. IDL provides a rich method for expressing the semantics of shared data structures <ref> [Lamb87, Snod89] </ref>; the code for accessing data on common interfaces is then generated automatically, thereby guaranteeing consistent treatment by all parts of the system. Recently, a mapping activity involving IDL (and very similar to the decisions given a site manager as discussed in Section 3.3) was presented in [ShSn89].
Reference: [LiAt81] <author> Liskov, B. and R. Atkinson. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag LNCS 114, </publisher> <year> (1981). </year>
Reference-contexts: is very similar to that of Gibbons [Gibb87], although we can generate stubs from automatically extracted interface information, whereas Gibbons' Horus system requires users to explicitly declare interface structure. 16 Structure-oriented languages (containing some MIL features) were used to control a distributed program-ming environment in several earlier projects, notably CLU <ref> [LiAt81] </ref> and MESA [Swee85]. Both support distributed programming by coupling their notation with their supporting systems (Argus [Lisk88] and Pilot, respectively). Each of these systems represent a significant step forward in the area's ability to realize the vast potential of distributing a computation.
Reference: [LiSh88] <author> Liskov, B., and L. Shira. </author> <title> Promises: linguistic support for efficient asynchronous procedure calls in distributed systems. </title> <booktitle> Proc of SIGPLAN Language Design and Implementation, </booktitle> <month> (June </month> <year> 1988). </year>
Reference-contexts: Most recently, there appears to be a trend towards even stronger use of MIL-like languages for control of distributed applications, with the emergence of Conic's environment and toolset [MaKS89], and of Durra [BDWW89]. The Mercury system supports heterogeneity in applications by managing a networked object repository <ref> [LiSh88] </ref>. All of these systems focus only on distributed execution environments. 17 5 CONCLUSION A fundamental `divide and conquer' principle in software is that an application's structure can be designed separately from the construction of its components.
Reference: [Lisk88] <author> Liskov, B. </author> <title> Distributed programming in Argus. </title> <journal> CACM, </journal> <volume> vol. 31, </volume> <year> (1988), </year> <pages> pp. 300-313. </pages>
Reference-contexts: Both support distributed programming by coupling their notation with their supporting systems (Argus <ref> [Lisk88] </ref> and Pilot, respectively). Each of these systems represent a significant step forward in the area's ability to realize the vast potential of distributing a computation.
Reference: [LuHa86] <author> Lubars, M. and M. Harandi. </author> <title> Intelligent support for software specification and design. </title> <journal> IEEE Expert, </journal> <volume> vol. 1, no. 4, </volume> <year> (1986), </year> <pages> pp. 33-41. </pages>
Reference-contexts: Initially, most users to date were drawn to Polylith for help in scientific computing applications: they use the MIL as a language for coarse-grained parallel programming, such as originally described in [PuRG88]. But the system serves software engineering activities as well <ref> [LuHa86] </ref>. Flexibility in how the MIL itself can be manipulated is demonstrated in [PuJa90]. This project makes simple extensions to the MIL in order to support software fault tolerance.
Reference: [MaKS89] <author> Magee, J., J. Kramer and M. Sloman. </author> <title> Constructing distributed systems in Conic. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 15, </volume> <month> (June </month> <year> 1989), </year> <pages> pp. 663-675. </pages>
Reference-contexts: Most recently, there appears to be a trend towards even stronger use of MIL-like languages for control of distributed applications, with the emergence of Conic's environment and toolset <ref> [MaKS89] </ref>, and of Durra [BDWW89]. The Mercury system supports heterogeneity in applications by managing a networked object repository [LiSh88].
Reference: [NoBL88] <author> Notkin, D., A. Black, E. Lazowska, et al. </author> <title> Interconnecting heterogeneous computer systems. </title> <journal> CACM, </journal> <volume> vol. 31, </volume> <year> (1988), </year> <pages> pp. 258-273. </pages>
Reference-contexts: Especially appropriate for multiprocessor configurations are Camelot [Bloc89] (a transaction facility built on top of Mach) and Avalon (a language resource constructed using Camelot.) The V Kernel [Cher88] implements a distributed- and parallel-programming resource appropriate for a homogeneous set of hosts. The HCS project <ref> [NoBL88] </ref> shows one way for providing a heterogeneous RPC capability in a distributed environment; more recently, a `lightweight' remote procedure call was demonstrated [BALL90]. Concert [YGSW89] and Marionette [SuAn89] are more variations on a theme.
Reference: [Notk85] <author> Notkin, David. </author> <title> The GANDALF Project. </title> <journal> Journal of Systems and Software, </journal> <volume> vol. 5, no. 2, </volume> <month> (May </month> <year> 1985), </year> <pages> pp. 91-104. 19 </pages>
Reference-contexts: Early work on MILs was performed by DeRemer and Kron [DeKr75]. Shortly after, project Gandalf focused on the software development environment itself <ref> [HaNo86, Notk85] </ref>, implementing a MIL known as Intercol for describing the structure of an application [Tich80], and permitting mixed language programming (subject to the restriction that the language processors be created to conform to Gandalf interfacing structures.) Most recently, environments and languages such as Inscape and SLI are appearing [Perr89, WWRT91],
Reference: [OSI81] <institution> ISO Open Systems interconnection Basic Reference Model. ISO/TC 97/SC 16 N 719, International Organiza--tion for Standardization, </institution> <month> (August </month> <year> 1981). </year>
Reference-contexts: Several early projects emphasized a network filesystem approach (such as Locus [PWCE81].) An interesting approach to cross-architecture procedure call using a common backing-store is given by Essick [Essi87]. The ISO OSI framework for network interconnections appears similar to our approach <ref> [OSI81] </ref>, but is more oriented to encapsulating decisions related to network concerns, as opposed to our focus on data and control integration.
Reference: [Perr89] <author> Perry, Dewayne. </author> <title> The Inscape Environment. </title> <booktitle> Proceedings of 11th International Conference on Software Engineering, </booktitle> <year> (1989), </year> <pages> pp. 2-12. </pages>
Reference-contexts: itself [HaNo86, Notk85], implementing a MIL known as Intercol for describing the structure of an application [Tich80], and permitting mixed language programming (subject to the restriction that the language processors be created to conform to Gandalf interfacing structures.) Most recently, environments and languages such as Inscape and SLI are appearing <ref> [Perr89, WWRT91] </ref>, in which developers can express not only the desired structure, but also assertions to guide use and interconnection of the configuration items. Inscape addresses many of the same sorts of packaging issues as Polylith.
Reference: [PuJa90] <author> Purtilo, J., and P. Jalote. </author> <title> An environment for developing fault tolerant software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, </volume> <year> (1991), </year> <pages> pp. 153-159. </pages>
Reference-contexts: But the system serves software engineering activities as well [LuHa86]. Flexibility in how the MIL itself can be manipulated is demonstrated in <ref> [PuJa90] </ref>. This project makes simple extensions to the MIL in order to support software fault tolerance. An application's structure is decorated with information concerning multiple implementations, voting programs and recovery blocks; the specification is then transformed into a standard Polylith interconnection graph for execution in a network environment.
Reference: [PuJa89] <author> Purtilo, J., and P. Jalote. </author> <title> An environment for prototyping distributed applications. </title> <booktitle> Proceedings of the Ninth International Conference on Distributed Computing Systems, </booktitle> <month> (June </month> <year> 1989), </year> <pages> pp. 588-594. </pages>
Reference-contexts: Whereas our initial implementation of the bus focussed on binding transparency at the source code level, an experimental use of a different presentation | one exposing the network in ways that are intended to be useful to C programmers in distributed applications | is described in <ref> [PuJa89] </ref>. This project created a different map of control and data representations between C and the abstract bus. The most novel bus implementation to date is Minion, a visual bus [Purt89]. At run-time, this bus exposes the communication protocol to outside display and debugging tools.
Reference: [PuLC91] <author> Purtilo, J., A. Larson and J. Clark. </author> <title> A methodology for prototyping in the large. </title> <booktitle> IEEE 13 th International Conference on Software Engineering, </booktitle> <month> (May </month> <year> 1991), </year> <pages> pp. 2-12. </pages>
Reference-contexts: Most recently, the heaviest use of Polylith is found within the DARPA prototyping community; the simplicity of interconnecting diverse program units expands the range of existing programs from which developers can draw easily and quickly when fabricating a prototype for experiments <ref> [PuLC91] </ref>. Based upon these experiences such as these, the remainder of this section addresses issues raised most frequently concerning Polylith. 4.1 PERFORMANCE The flexibility of polylithic organization can be obtained without loss of execution performance.
Reference: [PuRG88] <author> Purtilo, J., D. Reed and D. Grunwald. </author> <title> Environments for prototyping parallel algorithms. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> vol. 5, </volume> <year> (1988), </year> <pages> pp. 421-437. </pages>
Reference-contexts: Users direct the initiation of multiple control threads by assigning appropriate values to attributes at the design level <ref> [PuRG88] </ref>. The third major aspect to packaging is for site managers to decide how data correspond between Polylith's standard representation and that of a particular language and architecture. <p> Initially, most users to date were drawn to Polylith for help in scientific computing applications: they use the MIL as a language for coarse-grained parallel programming, such as originally described in <ref> [PuRG88] </ref>. But the system serves software engineering activities as well [LuHa86]. Flexibility in how the MIL itself can be manipulated is demonstrated in [PuJa90]. This project makes simple extensions to the MIL in order to support software fault tolerance.
Reference: [Purt86] <author> Purtilo, J. </author> <title> A software interconnection technology to support specification of computational environments. </title> <type> Doctoral dissertation. </type> <institution> UIUC Dept of Computer Science UIUC-R-86-1269, </institution> <year> (1986). </year>
Reference-contexts: Nonetheless, our experience has been that this is a surprisingly useful notation. In general, the way this coercion activity is guided by the MIL declarations is described in detail in <ref> [Purt86] </ref>. The final aspect of packaging is to determine how modules are assigned to processes. In the absence of any other guidance, this assignment is largely up to each packager, which will build executables by straightforward techniques.
Reference: [PuSW91] <author> Purtilo, J., R. Snodgrass and A. Wolf. </author> <title> Software bus organization: reference model and comparison of existing systems. </title> <type> MIFWG Technical Report 8, </type> <institution> University of Arizona Computer Science Department, </institution> <year> (1991). </year>
Reference-contexts: For the purposes of clarity, we will present the remainder of this section as if there is only one abstract bus, but in fact the methodology by which various abstract busses are established is the topic of a separate work <ref> [PuSW91] </ref>. An abstract bus can be implemented in many ways.
Reference: [Purt89] <author> Purtilo, J. MINION: </author> <title> An environment to organize mathematical problem solving. </title> <booktitle> Proceedings of the 1989 International Symposium on Symbolic and Algebraic Computation, </booktitle> <month> (July </month> <year> 1989), </year> <pages> pp. 147-154. </pages>
Reference-contexts: This project created a different map of control and data representations between C and the abstract bus. The most novel bus implementation to date is Minion, a visual bus <ref> [Purt89] </ref>. At run-time, this bus exposes the communication protocol to outside display and debugging tools. As with any bus, these interfacing details are encapsulated, and hence transparent to the application program, except for timing constraints. We are using this framework to control reconfiguration of running applications.
Reference: [PWCE81] <author> Popek, G., B. Walker, J. Chow, et al. </author> <title> LOCUS: A network transparent, high reliability distributed system. </title> <booktitle> Proc of 9th Symp on Operating Systems Principles, </booktitle> <month> (December </month> <year> 1981), </year> <pages> pp. 169-177. </pages>
Reference-contexts: The HCS project [NoBL88] shows one way for providing a heterogeneous RPC capability in a distributed environment; more recently, a `lightweight' remote procedure call was demonstrated [BALL90]. Concert [YGSW89] and Marionette [SuAn89] are more variations on a theme. Several early projects emphasized a network filesystem approach (such as Locus <ref> [PWCE81] </ref>.) An interesting approach to cross-architecture procedure call using a common backing-store is given by Essick [Essi87].
Reference: [ShSn89] <author> Shannon, K., and R. Snodgrass. </author> <title> Mapping the Interface Description Language Type Model into C. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 16, no. 11, </volume> <month> (November </month> <year> 1989), </year> <pages> pp. 1333-1346. </pages>
Reference-contexts: Recently, a mapping activity involving IDL (and very similar to the decisions given a site manager as discussed in Section 3.3) was presented in <ref> [ShSn89] </ref>. It would be natural to encapsulate IDL-generated source into a standard Polylith module, and then use the MIL to bind interfaces appropriately.
Reference: [Snod89] <author> Snodgrass, R. </author> <title> The Interface Description Language: Definition and Use. </title> <publisher> Computer Science Press, </publisher> <year> (1989). </year>
Reference-contexts: Another alternative for strengthing Polylith's interface type system is IDL, the interface definition language. IDL provides a rich method for expressing the semantics of shared data structures <ref> [Lamb87, Snod89] </ref>; the code for accessing data on common interfaces is then generated automatically, thereby guaranteeing consistent treatment by all parts of the system. Recently, a mapping activity involving IDL (and very similar to the decisions given a site manager as discussed in Section 3.3) was presented in [ShSn89].
Reference: [SuAn89] <author> Sullivan, M., and D. Anderson. Marionette: </author> <title> A system for parallel distributed programming using a master/slave model. </title> <booktitle> Proc of 9th Conf on Distributed Computing Systems, </booktitle> <month> (June </month> <year> 1989), </year> <pages> pp. 181-189. </pages>
Reference-contexts: The HCS project [NoBL88] shows one way for providing a heterogeneous RPC capability in a distributed environment; more recently, a `lightweight' remote procedure call was demonstrated [BALL90]. Concert [YGSW89] and Marionette <ref> [SuAn89] </ref> are more variations on a theme. Several early projects emphasized a network filesystem approach (such as Locus [PWCE81].) An interesting approach to cross-architecture procedure call using a common backing-store is given by Essick [Essi87].
Reference: [SunM88] <author> XDR: </author> <title> External Data Representation Standard. Sun Microsystems Reference Manual, </title> <year> (1988). </year>
Reference-contexts: The contributing areas range from data representation and distributed languages to configuration management systems. Much work has been done in primitive data representation in the presence of heterogeneity. The Polylith approach benefited from review of previous experiences with Courier [Xero81]. Sun Microsystem's XDR <ref> [SunM88] </ref> is a similar approach, as is UTS, a `universal type system' internal to the MLP (Mixed Language Programming) system [HaMS88]. More abstractly, transmission of abstract data types (ADTs) is presented in [HeLi82].
Reference: [Swee85] <author> Sweet, Richard E. </author> <title> The Mesa Programming Environment. </title> <booktitle> Proceedings of the ACM SIGPLAN Symposium on Programming Issues in Programming Environments, </booktitle> <month> (June </month> <year> 1985), </year> <pages> pp. 216-229. </pages>
Reference-contexts: to that of Gibbons [Gibb87], although we can generate stubs from automatically extracted interface information, whereas Gibbons' Horus system requires users to explicitly declare interface structure. 16 Structure-oriented languages (containing some MIL features) were used to control a distributed program-ming environment in several earlier projects, notably CLU [LiAt81] and MESA <ref> [Swee85] </ref>. Both support distributed programming by coupling their notation with their supporting systems (Argus [Lisk88] and Pilot, respectively). Each of these systems represent a significant step forward in the area's ability to realize the vast potential of distributing a computation.
Reference: [Tich80] <author> Tichy, Walter F. </author> <title> Software Development Control Based on System Structure Description. </title> <institution> Carnegie-Mellon University Dept. of Computer Science Report CMU-CS-80-120, </institution> <month> (January </month> <year> 1980). </year>
Reference-contexts: Early work on MILs was performed by DeRemer and Kron [DeKr75]. Shortly after, project Gandalf focused on the software development environment itself [HaNo86, Notk85], implementing a MIL known as Intercol for describing the structure of an application <ref> [Tich80] </ref>, and permitting mixed language programming (subject to the restriction that the language processors be created to conform to Gandalf interfacing structures.) Most recently, environments and languages such as Inscape and SLI are appearing [Perr89, WWRT91], in which developers can express not only the desired structure, but also assertions to guide
Reference: [WoCW89] <author> Wolf, A., L. Clark and J. Wileden. </author> <title> The AdaPIC Tool Set: Supporting Interface Control and Analysis Throughout the Software Development Process. </title> <journal> IEEE TSE, </journal> <volume> vol. 15, </volume> <year> (1989), </year> <pages> pp. 250-263. </pages>
Reference-contexts: Inscape addresses many of the same sorts of packaging issues as Polylith. The AdaPIC tool set also focuses on stronger analysis of how interfaces are used, an activity blended with support for other development activities <ref> [WoCW89] </ref>.
Reference: [WWRT91] <author> Wileden, J., A. Wolf, W. Rosenblatt and P. Tarr. </author> <title> Specification Level Interoperability, </title> <journal> CACM, </journal> <month> (May </month> <year> 1991), </year> <pages> pp. 72-87. </pages>
Reference-contexts: itself [HaNo86, Notk85], implementing a MIL known as Intercol for describing the structure of an application [Tich80], and permitting mixed language programming (subject to the restriction that the language processors be created to conform to Gandalf interfacing structures.) Most recently, environments and languages such as Inscape and SLI are appearing <ref> [Perr89, WWRT91] </ref>, in which developers can express not only the desired structure, but also assertions to guide use and interconnection of the configuration items. Inscape addresses many of the same sorts of packaging issues as Polylith.
Reference: [Xero81] <author> Courier: </author> <title> the remote procedure call protocol. Xerox Corporation Xerox System Integration Standard XSIS 038112, </title> <month> (December </month> <year> 1981). </year>
Reference-contexts: The contributing areas range from data representation and distributed languages to configuration management systems. Much work has been done in primitive data representation in the presence of heterogeneity. The Polylith approach benefited from review of previous experiences with Courier <ref> [Xero81] </ref>. Sun Microsystem's XDR [SunM88] is a similar approach, as is UTS, a `universal type system' internal to the MLP (Mixed Language Programming) system [HaMS88]. More abstractly, transmission of abstract data types (ADTs) is presented in [HeLi82].

References-found: 41

