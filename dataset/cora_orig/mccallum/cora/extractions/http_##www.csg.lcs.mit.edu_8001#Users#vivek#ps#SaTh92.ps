URL: http://www.csg.lcs.mit.edu:8001/Users/vivek/ps/SaTh92.ps
Refering-URL: http://www.cag.lcs.mit.edu/compiler/topics.march.10.html
Root-URL: 
Email: (vivek@paloalto.vnet.ibm.com (radhika@cs.washington.edu)  
Title: A General Framework for Iteration-Reordering Loop Transformations (Technical Summary)  
Author: Vivek Sarkar Radhika Thekkath 
Address: FR-35 1530 Page Mill Road  Palo Alto, CA 94304 Seattle, WA 98195  
Affiliation: IBM Palo Alto Scientific Center Dept. of Comp. Science and Eng.  University of Washington  
Abstract: This paper describes a general framework for representing iteration-reordering transformations. These transformations can be both matrix-based and non-matrix-based. Transformations are defined by rules for mapping dependence vectors, rules for mapping loop bound expressions, and rules for creating new initialization statements. The framework is extensible, and can be used to represent any iteration-reordering transformation. Mapping rules for several common transformations are included in the paper. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> John R. Allen. </author> <title> Dependence Analysis for Subscripted Variables and its Application to Program Transformation. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <year> 1983. </year>
Reference-contexts: Output loop nest size: n 0 = n loop perm <ref> [1] </ref> x perm [1] = l 0 1 , u 0 1 loop perm [n] x perm [n] = l 0 n , u 0 n where, for 1 k n, l 0 k ; s 0 l perm [k] ; u perm [k] ; s perm [k] rev [k] = <p> Output loop nest size: n 0 = n loop perm <ref> [1] </ref> x perm [1] = l 0 1 , u 0 1 loop perm [n] x perm [n] = l 0 n , u 0 n where, for 1 k n, l 0 k ; s 0 l perm [k] ; u perm [k] ; s perm [k] rev [k] = F U perm <p> Allen and Kennedy <ref> [1, 2] </ref> introduced the notion of loop-carried and loop-independent dependences, and defined legality tests for parallelization and interchange based on the idea of the level of a loop-carried dependence. They also coined the term, reordering transformation; we instead use the term, iteration-reordering transformation, so as to be more specific. <p> They also coined the term, reordering transformation; we instead use the term, iteration-reordering transformation, so as to be more specific. Our work can be viewed as a generalization of the results in <ref> [1, 2] </ref> that relate to iteration-reordering (reordering) transformations, since our legality test accommodates many other transformations apart from parallelization and interchange, and since we also base our legality test on the nature of the loop bounds expressions.
Reference: [2] <author> Randy Allen and Ken Kennedy. </author> <title> Automatic translation of fortran programs to vector form. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(4) </volume> <pages> 491-592, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: Allen and Kennedy <ref> [1, 2] </ref> introduced the notion of loop-carried and loop-independent dependences, and defined legality tests for parallelization and interchange based on the idea of the level of a loop-carried dependence. They also coined the term, reordering transformation; we instead use the term, iteration-reordering transformation, so as to be more specific. <p> They also coined the term, reordering transformation; we instead use the term, iteration-reordering transformation, so as to be more specific. Our work can be viewed as a generalization of the results in <ref> [1, 2] </ref> that relate to iteration-reordering (reordering) transformations, since our legality test accommodates many other transformations apart from parallelization and interchange, and since we also base our legality test on the nature of the loop bounds expressions.
Reference: [3] <author> Corinne Ancourt and Francois Irigoin. </author> <title> Scanning polyhedra with DO loops. </title> <booktitle> Third ACM Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 39-50, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: The blocking scheme proposed in [15] requires that all block sizes be equal for the algorithm to only create tiles with some work. A more general code generation algorithm is given in <ref> [3] </ref>, based on scanning polyhedra (e.g. it can be used to generate code for non-rectangular tiling); however, this algorithm can also create more tiles than necessary. 4.3 Representation of Loop Bound Expres sions To efficiently transform the loop bound expressions through each template instantiation in a transformation sequence, we use a
Reference: [4] <author> Utpal Banerjee. </author> <title> Dependence Analysis for Super computing. </title> <publisher> Kluwer Academic Publishers, Norwell, </publisher> <address> Massachusetts, </address> <year> 1988. </year>
Reference-contexts: M is the n fi n unimodular transformation matrix specifying the desired transformation <ref> [4] </ref>. ReversePermute (n; rev; perm) rev is a reverse mask such that rev [i] = true implies loop i should be reversed, and perm is a permutation map indicating that loop i should be moved to position perm [i] after all reversals have been done. <p> This fact forms the basis of the data dependence legality test discussed in subsection 3.2. The original set of dependence vectors for a perfect loop nest is computed using standard data dependence analysis techniques <ref> [4, 15, 10, 6, 12] </ref>.
Reference: [5] <author> Utpal Banerjee. </author> <title> Unimodular transformations of double loops. </title> <booktitle> Proceedings of the Third Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: Our framework is also more practical, because it is based on dependence vectors rather than dependence cones, and because it incurs the overhead of general linear (unimodular) transformations only when strictly necessary. Recently, unimodular transformations have begun gaining popularity as a practical framework for iteration-reordering transformations. Banerjee <ref> [5] </ref> shows how transformations like loop interchange, loop reversal, and loop skewing, can be represented by a unimodular transformation matrix; however, the results in the paper are proved only for loop nests of size = 2, and containing constant loop bounds. <p> They also incorporate the tiling (blocking) transformation into their framework by proposing a two-step approach, where a unimodular transformation is followed by a tiling transformation. The unifying aspect of the unimodular frameworks in <ref> [5, 14] </ref> is similar in scope to the unifying approach of Irigoin and Triolet. However, the unimodular frameworks are more practical since they are based on dependence vectors (as in [9]), rather than dependence cones.
Reference: [6] <author> Gina Goff, Ken Kennedy, and Chau-Wen Tseng. </author> <title> Practical dependence testing. </title> <booktitle> Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <volume> 26(6) </volume> <pages> 15-29, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: This fact forms the basis of the data dependence legality test discussed in subsection 3.2. The original set of dependence vectors for a perfect loop nest is computed using standard data dependence analysis techniques <ref> [4, 15, 10, 6, 12] </ref>.
Reference: [7] <author> Francois Irgoin. </author> <title> Code generation for the hyperplane method and for loop interchange. </title> <type> Technical report, </type> <institution> Ecole Nationale Superieure des Mines de Paris, </institution> <month> October </month> <year> 1988. </year> <note> Report ENSMP-CAI-88-E102/CAI/I. </note>
Reference-contexts: A use of loop 0 k indicates a loop in the output loop nest. The rules for the Unimodular transformation have been studied in detail in the literature <ref> [7, 14] </ref> and are omitted here. The preconditions and mapping rules for the ReversePermute transformation template are shown in Table 3; this template partially overlaps with the Unimodular template. <p> v linear 2. type (u j ; x i ) v linear 3. type (s j ; x i ) v const Output loop nest size: n 0 = n The transformation of loop bounds expressions and the creation of initialization statements have been studied in detail for this case <ref> [7, 14] </ref>. If the (constant) step value is 6= 1, then the bounds are normalized to step = 1 before applying the unimodular transformation. <p> In this framework, data dependences are 10 represented by dependence cones rather than dependence vectors. They also provide a general code generation algorithm for any linear transformation that corresponds to a unimodular change of basis <ref> [7] </ref>. Their framework incorporates loop interchange, hyperplane partitioning, and loop tiling (blocking) in a unified way, for loop nests with linear bounds expressions.
Reference: [8] <author> Francois Irigoin and Remi Triolet. </author> <title> Supernode par titioning. </title> <booktitle> Conference Record of Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 319-329, </pages> <year> 1988. </year>
Reference-contexts: Irigoin and Triolet <ref> [8] </ref> describe a framework for iteration-reordering transformations based on supernode partitioning, an aggregation technique achieved by hyperplane partitioning, followed by iteration space tiling across hyperplane boundaries. In this framework, data dependences are 10 represented by dependence cones rather than dependence vectors.
Reference: [9] <author> L. Lamport. </author> <title> The parallel execution of do loops. </title> <journal> Communications of the ACM, </journal> <pages> pages 83-93, </pages> <month> February </month> <year> 1974. </year>
Reference-contexts: In practice, there are two kinds of values for d k that are of interest <ref> [9] </ref>: 1. Distance d k is an integer value, d k = y 2 Z. 2. <p> However, the preconditions for the ReversePermute transformation 5 Transformation template Dependence vector mapping rule Unimodular (n; M ) D 0 = n o where M fi ~ d is a matrix-vector product, appropriately extended for direction values <ref> [9, 14] </ref>. <p> We focus on discussing prior work in the area of frameworks for iteration-reordering transformations, rather than other (orthogonal) topics like data dependence analysis techniques, or optimization algorithms that use iteration-reordering transformations, or loop transformations that reorder statements as well as iterations. Lamport <ref> [9] </ref> introduced the hyperplane method and the coordinate method for parallel execution of iterations in a loop nest. Both methods are special forms of iteration-reordering transformations. The framework used in [9] included dependence vectors that contain distance or direction values, and iteration-reordering transformations that can be represented by Z n 7! <p> Lamport <ref> [9] </ref> introduced the hyperplane method and the coordinate method for parallel execution of iterations in a loop nest. Both methods are special forms of iteration-reordering transformations. The framework used in [9] included dependence vectors that contain distance or direction values, and iteration-reordering transformations that can be represented by Z n 7! Z n linear mappings. Further, the legality test for a linear mapping was based on the existence of a lexicographically negative tuple in the set of transformed dependence vectors. <p> The unifying aspect of the unimodular frameworks in [5, 14] is similar in scope to the unifying approach of Irigoin and Triolet. However, the unimodular frameworks are more practical since they are based on dependence vectors (as in <ref> [9] </ref>), rather than dependence cones.
Reference: [10] <author> Dror E. Maydan, John L. Hennessy, and Monica S. Lam. </author> <title> Efficient and exact data dependence analysis. </title> <booktitle> Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <volume> 26(6) </volume> <pages> 1-14, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: This fact forms the basis of the data dependence legality test discussed in subsection 3.2. The original set of dependence vectors for a perfect loop nest is computed using standard data dependence analysis techniques <ref> [4, 15, 10, 6, 12] </ref>.
Reference: [11] <author> Constantine D. Polychronopoulos and David J. Kuck. </author> <title> Guided self-scheduling: A practical scheduling scheme for parallel supercomputers. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(12):1425-1439, </volume> <month> December </month> <year> 1987. </year>
Reference-contexts: Blocking can be viewed as a combination of strip mining and interchanging [15]. Coalesce (n; i; j) The range i : : : j specifies a set of contiguous loops to be coalesced (or collapsed) into a single loop <ref> [11] </ref>. Interleave (n; i; j; isize) The contiguous range i : : : j specifies all loops to be interleaved. The value isize [k] defines the interleave factor for loop k. This is similar to Block. <p> For cases in which ReversePermute and Unimodular can achieve the same result, it is preferable to use ReversePermute because a) step expressions are not normalized to +1, b) index variable names are reused without creating initialization statements, and c) matrix computations are avoided on dependence vectors. The Coalesce transformation <ref> [11] </ref> includes normalization of the lower bound and the step expression as part of the transformation mapping.
Reference: [12] <author> William Pugh. </author> <title> The omega test: a fast and practical integer programming algorithm for dependence analysis. </title> <booktitle> Proceedings of Supercomputing '91, </booktitle> <pages> pages 4-13, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: This fact forms the basis of the data dependence legality test discussed in subsection 3.2. The original set of dependence vectors for a perfect loop nest is computed using standard data dependence analysis techniques <ref> [4, 15, 10, 6, 12] </ref>.
Reference: [13] <author> Deborah Whitfield and Mary Lou Soffa. </author> <title> Automatic generation of global optimizers. </title> <booktitle> ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 120-129, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Whitfield and Soffa <ref> [13] </ref> define a specification language (called GOSpeL) for global optimizations, in which an optimization is specified by preconditions and actions. An optimization can only be enabled when all its preconditions are satisfied; if enabled, the actions specify how the program representation should be updated to materialize the optimization.
Reference: [14] <author> Michael E. Wolf and Monica S. Lam. </author> <title> A loop transformation theory and an algorithm to maximize parallelism. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 2(4) </volume> <pages> 452-471, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: However, the preconditions for the ReversePermute transformation 5 Transformation template Dependence vector mapping rule Unimodular (n; M ) D 0 = n o where M fi ~ d is a matrix-vector product, appropriately extended for direction values <ref> [9, 14] </ref>. <p> Specifically, if the step is positive and the lower bound expression is a max function of linear terms and/or the upper bound expression is a min function of linear terms, then each term of the max or min function can be treated as a separate linear inequality <ref> [14] </ref> (if the step is negative, then the special case occurs when the lower bound is a min function and the upper bound is a max function). <p> A use of loop 0 k indicates a loop in the output loop nest. The rules for the Unimodular transformation have been studied in detail in the literature <ref> [7, 14] </ref> and are omitted here. The preconditions and mapping rules for the ReversePermute transformation template are shown in Table 3; this template partially overlaps with the Unimodular template. <p> v linear 2. type (u j ; x i ) v linear 3. type (s j ; x i ) v const Output loop nest size: n 0 = n The transformation of loop bounds expressions and the creation of initialization statements have been studied in detail for this case <ref> [7, 14] </ref>. If the (constant) step value is 6= 1, then the bounds are normalized to step = 1 before applying the unimodular transformation. <p> This is unlike the solution in <ref> [14] </ref> that creates a rectangular boundary around a trapezoidal iteration space, and hence may create many tiles with no work. The blocking scheme proposed in [15] requires that all block sizes be equal for the algorithm to only create tiles with some work. <p> Banerjee [5] shows how transformations like loop interchange, loop reversal, and loop skewing, can be represented by a unimodular transformation matrix; however, the results in the paper are proved only for loop nests of size = 2, and containing constant loop bounds. Wolf and Lam <ref> [14] </ref> also show how unimodular transformations can be used to unify loop interchange, loop reversal, and loop skewing; the results in their paper are applicable to loop nests of arbitrary size and with linear bounds constraints. <p> They also incorporate the tiling (blocking) transformation into their framework by proposing a two-step approach, where a unimodular transformation is followed by a tiling transformation. The unifying aspect of the unimodular frameworks in <ref> [5, 14] </ref> is similar in scope to the unifying approach of Irigoin and Triolet. However, the unimodular frameworks are more practical since they are based on dependence vectors (as in [9]), rather than dependence cones.
Reference: [15] <author> Michael J. Wolfe. </author> <title> Optimizing Supercompilers for Supercomputers. </title> <publisher> Pitman, London and The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1989. </year> <title> In the series, </title> <note> Research Monographs in Parallel and Distributed Computing This monograph is a revised version of the author's Ph.D. dissertation published as Technical Report UIUCDCS-R-82-1105, </note> <institution> U. Illinois at Urbana-Champaign, </institution> <year> 1982. </year>
Reference-contexts: Blocking can be viewed as a combination of strip mining and interchanging <ref> [15] </ref>. Coalesce (n; i; j) The range i : : : j specifies a set of contiguous loops to be coalesced (or collapsed) into a single loop [11]. Interleave (n; i; j; isize) The contiguous range i : : : j specifies all loops to be interleaved. <p> loop nest, D, enforces a partial order on the execution instances of the loop nest; for any two distinct execution instances ~a and ~ b, if their 3 An alternate notation for the six direction values is to use the relational operators, `&lt;', `&gt;', `', `', `6=', and `fl' respectively <ref> [15] </ref>. We do not represent an `=' direction in our framework because it is equivalent to a zero distance. difference ~ b ~a belongs to Tuples (D), then instance ~ b must be executed after instance ~a. This partial order summarizes all the iteration-reordering constraints imposed by data dependences. <p> This fact forms the basis of the data dependence legality test discussed in subsection 3.2. The original set of dependence vectors for a perfect loop nest is computed using standard data dependence analysis techniques <ref> [4, 15, 10, 6, 12] </ref>. <p> This is unlike the solution in [14] that creates a rectangular boundary around a trapezoidal iteration space, and hence may create many tiles with no work. The blocking scheme proposed in <ref> [15] </ref> requires that all block sizes be equal for the algorithm to only create tiles with some work. <p> The framework in our paper is much more generalwe support linear and non-linear transformations, allow input and output loop nest sizes to be different, and permit all iteration-reordering transformations to be composed together in a general way. Wolfe <ref> [15] </ref> introduced a comprehensive data dependence graph, with edges labeled by direction vectors, as the basis for a loop transformation framework. Several iteration-reordering transformations were supported by this framework e.g. loop interchanging, iteration space tiling (blocking), loop skewing, vectorization, and concurrenti-zation.
References-found: 15

