URL: http://www.cs.cornell.edu/home/caldwell/papers/TCS_search.ps
Refering-URL: http://www.cs.cornell.edu/home/caldwell/papers.html
Root-URL: 
Title: Search Algorithms in Type Theory  
Author: James L. Caldwell Ian P. Gent Judith Underwood 
Keyword: Search Algorithms, Proofs-as-programs, Conflict-directed Backjump Search, Nonlocal Control (call/cc), Nuprl, Hamiltonian Circuit  
Address: Mail Stop 269-1, Moffett Field, CA, 94035-1000, USA.  G1 1XH, United Kingdom.  13 Atholl Crescent, Edinburgh, United Kingdom.  
Affiliation: NASA Ames Research Center, Computational Sciences Division,  Department of Computer Science, Cornell University, Ithaca, NY. Department of Computer Science University of Strathclyde, Glasgow  Quality Systems and Software Ltd.,  the Department of Computing Science, University of Glasgow.  
Note: Revised submission to Theoretical Computer Science: Special Issue on Proof Search in Type-theoretic Languages  This work was performed while the author was visiting the  Judith Underwood was supported by epsrc award gr/l/15685 while at  
Email: ipg@cs.strath.ac.uk  judith@qss.co.uk.  
Date: May 1998  
Abstract: In this paper, we take an abstract view of search by describing search procedures via particular kinds of proofs in type theory. We rely on the proofs-as-programs interpretation to extract programs from our proofs. Using these techniques we explore, in depth, a large family of search problems by parameterizing the specification of the problem. A constructive proof is presented which has as its computational content a correct search procedure for these problems. We show how a classical extension to an otherwise constructive system can be used to describe a typical use of the nonlocal control operator call/cc. Using the classical typing of nonlocal control we extend our purely constructive proof to incorporate a sophisticated backtracking technique known as `conflict-directed backjumping' (CBJ). A variant of this proof is formalized in Nuprl yielding a correct-by-construction implementation of CBJ. The extracted program has been translated into Scheme and serves as the basis for an implementation of a new solution to the Hamiltonian circuit problem. This paper demonstrates a non-trivial application of the proofs-as-programs paradigm by applying the technique to the derivation of a sophisticated search algorithm; also, it shows the generality of the resulting implementation by demonstrating its application in a new problem domain for CBJ. fl Authors are named in alphabetical order although Judith Underwood is principal author. We thank members of APES for their help and reviewers of this journal for their comments. Ian Gent and Judith Underwood especially thank Mr Denis Magnus for his invaluable contributions to their research. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.B. Baker. </author> <title> Intelligent backtracking on constraint satisfaction problems: Experimental and theoretical results. </title> <type> Technical report CIS-TR-95-08, </type> <institution> Computer and Information Sciences, University of Oregon, </institution> <year> 1995. </year>
Reference-contexts: Informal proofs of correctness of CBJ have been presented by Ginsberg [22] and Kondrak and van Beek [29], but until now it has not been proved correct in a formal framework. The value of CBJ as a search reduction technique has been shown 5 experimentally <ref> [43, 23, 1, 5] </ref> and theoretically [29], and we show for the first time that the technique can reduce search in the Hamiltonian circuit problem. We have given a very general logical description of how some theorems can be proved in such a way as to generate search procedures. <p> If however other clauses were present which ruled out c = F without involving variable b, we could backjump over b to try 14 a = F . The success of backjumping techniques is not limited to such contrived examples, and has been shown in larger problems <ref> [40, 43, 1, 5] </ref>. To get this computational behavior from the proof, we use the fact that call/cc can be given the type ((ff ! fi) ! ff) ! ff for any types ff and fi [24, 26].
Reference: [2] <author> F. Barbanera and S. Berardi. </author> <title> Witness extraction in classical logic through normalization. </title> <editor> In G. Huet and G. Plotkin, editors, </editor> <booktitle> Logical Environments. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Since the original discovery that Felleisen's control operator C could be given a type corresponding to the law of double negation elimination, a great deal of work has been done on the computational meaning of classical proof <ref> [2, 3, 6, 24, 33, 36] </ref>. However, these ideas have not been exploited in the context of program development or verification. To this end, we have shown how a limited use of classical reasoning in a proof can produce a program extraction which includes a nonlocal control operator.
Reference: [3] <author> F. Barbanera and S. Berardi. </author> <title> A symmetric lambda calculus for classical program extraction. </title> <journal> Information and Computation, </journal> <volume> 125 </volume> <pages> 103-117, </pages> <year> 1996. </year>
Reference-contexts: Since the original discovery that Felleisen's control operator C could be given a type corresponding to the law of double negation elimination, a great deal of work has been done on the computational meaning of classical proof <ref> [2, 3, 6, 24, 33, 36] </ref>. However, these ideas have not been exploited in the context of program development or verification. To this end, we have shown how a limited use of classical reasoning in a proof can produce a program extraction which includes a nonlocal control operator.
Reference: [4] <author> R.J. Bayardo Jr. </author> <title> and R.C. Schrag. Using CSP look-back techniques to solve exceptionally hard SAT instances. In E.C. </title> <editor> Freuder, editor, </editor> <booktitle> Principles and Practice of Constraint Programming - CP96, </booktitle> <pages> pages 46-60. </pages> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1996. </year>
Reference-contexts: For example, conflict-directed backjumping was described for constraint satisfaction problems [40, 22] some years before being applied successfully to propositional satisfia-bility <ref> [4, 5] </ref> and it has not previously been presented as generally as we do so here. Our approach separates the properties of the search algorithm from the problem specific functions, permitting the core search algorithm to be applied to many different domains by varying the predicate P .
Reference: [5] <author> R.J. Bayardo Jr. </author> <title> and R.C. Schrag. Using CSP look-back techniques to solve real-world SAT instances. </title> <booktitle> In Proceedings of the Fourteenth National Conference on Artificial Intelligence, </booktitle> <pages> pages 203-208, </pages> <address> Menlo Park, CA, 1997. </address> <publisher> AAAI Press. </publisher> <pages> 32 </pages>
Reference-contexts: Informal proofs of correctness of CBJ have been presented by Ginsberg [22] and Kondrak and van Beek [29], but until now it has not been proved correct in a formal framework. The value of CBJ as a search reduction technique has been shown 5 experimentally <ref> [43, 23, 1, 5] </ref> and theoretically [29], and we show for the first time that the technique can reduce search in the Hamiltonian circuit problem. We have given a very general logical description of how some theorems can be proved in such a way as to generate search procedures. <p> For example, conflict-directed backjumping was described for constraint satisfaction problems [40, 22] some years before being applied successfully to propositional satisfia-bility <ref> [4, 5] </ref> and it has not previously been presented as generally as we do so here. Our approach separates the properties of the search algorithm from the problem specific functions, permitting the core search algorithm to be applied to many different domains by varying the predicate P . <p> If however other clauses were present which ruled out c = F without involving variable b, we could backjump over b to try 14 a = F . The success of backjumping techniques is not limited to such contrived examples, and has been shown in larger problems <ref> [40, 43, 1, 5] </ref>. To get this computational behavior from the proof, we use the fact that call/cc can be given the type ((ff ! fi) ! ff) ! ff for any types ff and fi [24, 26].
Reference: [6] <author> U. Berger and H. Schwichtenberg. </author> <title> Program extraction from classical proofs. </title> <editor> In D. Leivant, editor, </editor> <booktitle> Logic and Computational Complexity, </booktitle> <pages> pages 77-97, </pages> <address> Berlin, 1994. </address> <publisher> Springer. </publisher>
Reference-contexts: Since the original discovery that Felleisen's control operator C could be given a type corresponding to the law of double negation elimination, a great deal of work has been done on the computational meaning of classical proof <ref> [2, 3, 6, 24, 33, 36] </ref>. However, these ideas have not been exploited in the context of program development or verification. To this end, we have shown how a limited use of classical reasoning in a proof can produce a program extraction which includes a nonlocal control operator.
Reference: [7] <author> M. B. Burstein and D. R. Smith. Itas: </author> <title> A portable interactive transportation scheduling tool using a search engine generated from formal specifications. </title> <booktitle> In Proceedings of the Third International Conference on Artificial Intelligence Planning Systems (AIPS-96), </booktitle> <year> 1996. </year>
Reference-contexts: Our results are very general because they apply to a wide variety of search algorithms, and a wide variety of problem classes, all obtainable from the Scheme code we have presented by implementing suitable service functions. Related work on formal development of search algorithms by Smith et. al. <ref> [7, 37, 44] </ref> has concentrated on techniques for transforming search problem specifications into executable search procedures. These techniques make use of a deep 29 analysis of the structure of the problem specification to produce very efficient code tuned to the particular constraints involved.
Reference: [8] <author> J. L. Caldwell. </author> <title> Moving proofs-as-programs into practice. </title> <booktitle> In 12th IEEE International Conference on Automated Software Engineering. IEEE Computer Society, </booktitle> <year> 1997. </year>
Reference-contexts: This is the goal of much research in type theoretic theorem proving; however, comparatively little effort has been made to connect proof terms with programs recognizable to ordinary functional programmers. Recently, progress has been made in obtaining general recursive program (as opposed to strictly primitive recursive) as proof extracts <ref> [8] </ref>. Our work shows that these techniques can be applied to the development of a more substantial program with little difficulty. <p> In this paper we tighten the link between the proof and the code by formalizing the proof in the Nuprl system [14]. We take advantage of recent advances in the extraction of programs from Nuprl proofs <ref> [8, 9] </ref> to extract a program that is virtually indistinguishable from a functional program written in an ordinary programming language such as Scheme or Lisp. To take advantage of the efficiencies offered by modern compiler technology, we translate the extracted program into Scheme in a natural way. <p> This constraint leads to technical complications on the proof side which are addressed by methods described in <ref> [8, 9, 10] </ref>. The second aspect of Nuprl that is of interest to our efforts is that its computation system is untyped. <p> This method is useful for generating readable and efficient extracts. Additionally, theorems stating induction principles can be proved so that the computational content of their proofs are efficient recursion schemes. The typing ensures that the recursion is well-founded. In <ref> [8] </ref> a letrec form is introduced in terms of the Y combinator, so that extracts need not display the recursion mechanism explicitly. 22 The third aspect of Nuprl that makes it amenable to our purposes is our ability to extend the system to allow for reasoning about call/cc.
Reference: [9] <author> J.L. Caldwell. </author> <title> Classical propositional decidability via Nuprl proof extraction. </title> <booktitle> In TPHOLs'98 The 11th International Conference on Theorem Proving in Higher Order Logics. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1998. </year> <note> To Appear. </note>
Reference-contexts: In this paper we tighten the link between the proof and the code by formalizing the proof in the Nuprl system [14]. We take advantage of recent advances in the extraction of programs from Nuprl proofs <ref> [8, 9] </ref> to extract a program that is virtually indistinguishable from a functional program written in an ordinary programming language such as Scheme or Lisp. To take advantage of the efficiencies offered by modern compiler technology, we translate the extracted program into Scheme in a natural way. <p> This constraint leads to technical complications on the proof side which are addressed by methods described in <ref> [8, 9, 10] </ref>. The second aspect of Nuprl that is of interest to our efforts is that its computation system is untyped.
Reference: [10] <author> J.L. Caldwell. </author> <title> Decidability Extracted: extracting tableau procedures for classical and intuitionistic propositional logic from formal proofs. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: The computational content of that proof then constitutes a correct search procedure. This approach has been used to develop verified decision procedures, namely tableau proof search algorithms for classical and constructive propositional logic <ref> [10, 47] </ref>. In this paper, we extend the idea to a large class of problems involving search, to produce a general template for development of search procedures. There are three main motivations of this work. <p> This constraint leads to technical complications on the proof side which are addressed by methods described in <ref> [8, 9, 10] </ref>. The second aspect of Nuprl that is of interest to our efforts is that its computation system is untyped.
Reference: [11] <author> P. Cheeseman, B. Kanefsky, and W.M. Taylor. </author> <title> Where the really hard problems are. </title> <editor> In J. Mylopoulos and R. Reiter, editors, </editor> <booktitle> Proceedings of the Twelfth International Conference on Artificial Intelligence, </booktitle> <pages> pages 331-337, </pages> <address> San Mateo, CA, 1991. </address> <publisher> Morgan Kauffman. </publisher>
Reference-contexts: Of our graphs, 78 had circuits while 22 did not. Such data sets from a `phase transition region', with a mixture of soluble and insoluble problems, are often used for benchmarking algorithms <ref> [11] </ref>. It is interesting to compare the number of branches searched with and without backjumping.
Reference: [12] <author> W. Clinger and J.A. Rees. </author> <title> The revised 4 report on the algorithmic language scheme. </title> <journal> ACM LISP Pointers, </journal> <volume> 4(3), </volume> <year> 1991. </year>
Reference-contexts: However, in this development we use a different technique, that of explicit management of the continuation through use of call/cc. The call/cc (or call-with-current-continuation) operator was introduced to the Scheme programming language <ref> [12] </ref> to permit direct manipulation of program control. When call/cc ((k) : : :) is evaluated, k becomes bound to the current continuation; in other words, k represents the rest of the computation, apart from that remaining in the body of the call/cc. <p> We do not know of any previous use of CBJ or any other intelligent backtracking technique having been reported in this domain. We chose to use the language Scheme <ref> [12] </ref>. We include the code corresponding to the proof extract in an appendix, and brief notes on the correspondence between the code and the Nuprl extract. There were two reasons for not using the execution facilities in Nuprl.
Reference: [13] <author> R. L. Constable and D. J. Howe. </author> <title> Implementing metamathematics as an approach to automatic theorem proving. </title> <editor> In R.B. Banerji, editor, </editor> <booktitle> Formal Techniques in Artificial Intelligence: A Source Book, </booktitle> <pages> pages 45-76. </pages> <publisher> Elsevier Science Publishers (North-Holland), </publisher> <year> 1990. </year>
Reference-contexts: Structure: P (s)) _ (9R : Reason: R ! 8s : Structure: :P (s)) Note that in the context of proof search, if R is a model in some sound model theory for the logic, then a proof of this theorem is, in fact, a completeness proof for the logic <ref> [13, 46] </ref>. We will see (in section 4.2) that we may be able to exploit R to prune the search space and thus generate more efficient search algorithms. We now consider further the design of the proof and the algorithm we expect to derive from it.
Reference: [14] <author> R.L. Constable, S.F. Allen, W.R. Cleveland, J.F. Cremer, R.W. Harper, D.J. Howe, T.B. Knoblock, N.P. Mendler, P. Panangaden, J.T. Sasaki, and S.F. Smith. </author> <title> Implementing Mathematics with The Nuprl Development System. </title> <publisher> Prentice-Hall, </publisher> <address> New Jersey, </address> <year> 1986. </year>
Reference-contexts: However, the process of translation leaves considerable room for errors. Nevertheless, profiling execution of concrete code provides a means to determine whether the algorithm behaves as expected. In this paper we tighten the link between the proof and the code by formalizing the proof in the Nuprl system <ref> [14] </ref>. We take advantage of recent advances in the extraction of programs from Nuprl proofs [8, 9] to extract a program that is virtually indistinguishable from a functional program written in an ordinary programming language such as Scheme or Lisp. <p> Nuprl is an implementation of an extended Martin-Lof type theory [32]. The Nuprl type system is extremely rich. For the purposes of this paper we use it with little explanation but hope interested readers will seek further information elsewhere. The Nuprl book <ref> [14] </ref> offers a detailed description of the type theory. Also see [28]. As in other constructive type theories, in Nuprl we can extract a program (i.e. something which is meant to be interpreted computationally) from proofs in the logic.
Reference: [15] <author> T. Coquand and G. Huet. </author> <title> The Calculus of Constructions. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 95-120, </pages> <year> 1988. </year>
Reference-contexts: Finally, the Nuprl proof could be generalized to more abstract types for sets and assignments. In earlier work [21], two of the authors formalized the core of this work in Lego [30, 38], an implementation of type theory based on an extension of the calculus of constructions <ref> [15] </ref>. Lego does not have Nuprl's sophisticated program extraction mechanisms, so the result was not so closely connected to Scheme code. However, the approach taken included a very abstract approach to the underlying data types, which essentially entailed a specification of abstract data types for sets and assignments.
Reference: [16] <author> O. Danvy and A. Filinski. </author> <title> Abstracting control. </title> <booktitle> In Lisp and Functional Programming, </booktitle> <pages> pages 151-160. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Thus, call/cc is essentially a functional goto; it allows control to jump immediately to another part of the program. Typical uses of call/cc include error handling and implementation of coroutines <ref> [18, 17, 16] </ref>. We can view the use of call/cc to implement backjumping as a form of error handling, allowing immediate return to the point at which a decision was made to explore a branch now known not to contain a solution.
Reference: [17] <author> R.K. Dybvig and R. Hieb. </author> <title> Continuations and concurrency. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 128-136, </pages> <year> 1990. </year> <note> Also Indiana University Computer Science Department Technical Report #256. 33 </note>
Reference-contexts: Thus, call/cc is essentially a functional goto; it allows control to jump immediately to another part of the program. Typical uses of call/cc include error handling and implementation of coroutines <ref> [18, 17, 16] </ref>. We can view the use of call/cc to implement backjumping as a form of error handling, allowing immediate return to the point at which a decision was made to explore a branch now known not to contain a solution.
Reference: [18] <author> D.P. Friedman, </author> <title> C.T. Haynes, and E.E. Kohlbecker. Programming with con-tinuations. </title> <editor> In P. Pepper, editor, </editor> <booktitle> Program Transformation and Programming Environments, </booktitle> <pages> pages 263-274. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Thus, call/cc is essentially a functional goto; it allows control to jump immediately to another part of the program. Typical uses of call/cc include error handling and implementation of coroutines <ref> [18, 17, 16] </ref>. We can view the use of call/cc to implement backjumping as a form of error handling, allowing immediate return to the point at which a decision was made to explore a branch now known not to contain a solution.
Reference: [19] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and intractability : a guide to the theory of NP-completeness. W H Freeman, </title> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Among examples of such problems are all NP-complete problems <ref> [19] </ref>, although we make no assumptions which limit us to NP problems. Informal proofs of correctness of CBJ have been presented by Ginsberg [22] and Kondrak and van Beek [29], but until now it has not been proved correct in a formal framework.
Reference: [20] <author> J. Gaschnig. </author> <title> Performance measurement and analysis of certain search algorithms. </title> <type> Technical report CMU-CS-79-124, </type> <institution> Carnegie-Mellon University, </institution> <year> 1979. </year>
Reference-contexts: Then, instead of backtracking one step from ps, we may wish to backjump to the point where ps 0 was constructed, which may be much earlier in the search. Backjumping as a search reduction technique was first described by Gaschnig <ref> [20] </ref>, but his presentation was very limited in the amount of backjumping performed. Conflict-directed backjumping (CBJ), a more extensive form of back-jumping, was first described by Prosser in the context of a scheduling problem [39].
Reference: [21] <author> I.P. Gent and J. Underwood. </author> <title> The logic of search algorithms: Theory and applications. </title> <editor> In G. Smolka, editor, </editor> <booktitle> Principles and Practice of Constraint Programming - CP97, </booktitle> <pages> pages 77-91, </pages> <address> Berlin, 1997. </address> <publisher> Springer. </publisher>
Reference-contexts: One approach to solving these problems is to base application code on an informal proof such as the one presented above in Section 5. This is the approach 21 taken by Gent and Underwood in <ref> [21] </ref>. However, the process of translation leaves considerable room for errors. Nevertheless, profiling execution of concrete code provides a means to determine whether the algorithm behaves as expected. In this paper we tighten the link between the proof and the code by formalizing the proof in the Nuprl system [14]. <p> Indeed, call/cc in Scheme is so suitable for implementing backtracking algorithms that code based on it is likely to be faster than Scheme code implemented differently. In a previous study, code developed formally was marginally faster than the original implementation of CBJ in Scheme for constraint satisfaction problems <ref> [21] </ref>. In the case of Hamiltonian Circuit, no such comparison is possible since CBJ has not previously been implemented for it. To give some idea of relative efficiency, we compared run times of our code with a Common Lisp implementation of Martello's algorithm. <p> Indeed, in an earlier paper the second and third authors reported on the implementation of the equivalent of FC+CBJ for propositional satisfiability <ref> [21] </ref> in a framework similar to that of this paper. However, our framework is not the best for implementation of lookahead techniques in general. It would be better to capture the general nature of lookahead search, just as we have done for back-jumping search in this paper. <p> Finally, the Nuprl proof could be generalized to more abstract types for sets and assignments. In earlier work <ref> [21] </ref>, two of the authors formalized the core of this work in Lego [30, 38], an implementation of type theory based on an extension of the calculus of constructions [15]. Lego does not have Nuprl's sophisticated program extraction mechanisms, so the result was not so closely connected to Scheme code.
Reference: [22] <author> M.L. Ginsberg. </author> <title> Dynamic backtracking. </title> <journal> Journal of Artificial Intelligence Research, </journal> <volume> 1 </volume> <pages> 25-46, </pages> <year> 1993. </year>
Reference-contexts: Conflict-directed backjumping (CBJ), a more extensive form of back-jumping, was first described by Prosser in the context of a scheduling problem [39]. Later, it was generalized to binary constraint satisfaction problems [40], and arbitrary constraint satisfaction problems <ref> [22] </ref>. Here, we have generalized it further and view it as a general search reduction technique rather than as an algorithm for a particular problem. <p> Among examples of such problems are all NP-complete problems [19], although we make no assumptions which limit us to NP problems. Informal proofs of correctness of CBJ have been presented by Ginsberg <ref> [22] </ref> and Kondrak and van Beek [29], but until now it has not been proved correct in a formal framework. <p> However, improvements to general search algorithms are rarely presented as such in the literature; instead, a method is often introduced in one problem area (e.g. constraint satisfaction) and later applied to other areas. For example, conflict-directed backjumping was described for constraint satisfaction problems <ref> [40, 22] </ref> some years before being applied successfully to propositional satisfia-bility [4, 5] and it has not previously been presented as generally as we do so here. <p> Our implementation achieved significant reductions in search compared to a backtracking algorithm. While our code did run slower than a previously described algorithm, there is nothing essential to our methodology which makes this necessary. 8 Related and future work Following Prosser's introduction of conflict-directed backjumping (CBJ) [40], Ginsberg <ref> [22] </ref> and Kondrak and van Beek [29] have given proofs of the correctness of CBJ and also related the numbers of nodes searched by different algorithms. The significant advance of our work is in its underlying basis in formal semantics and in its generality.
Reference: [23] <author> S.A. Grant and B.M. Smith. </author> <title> The phase transition behaviour of maintaining arc consistency. </title> <editor> In W. Wahlster, editor, </editor> <booktitle> 12th European Conference on Artificial Intelligence, </booktitle> <pages> pages 175-179, </pages> <address> Chichester, 1996. </address> <publisher> John Wiley & Sons. </publisher>
Reference-contexts: Informal proofs of correctness of CBJ have been presented by Ginsberg [22] and Kondrak and van Beek [29], but until now it has not been proved correct in a formal framework. The value of CBJ as a search reduction technique has been shown 5 experimentally <ref> [43, 23, 1, 5] </ref> and theoretically [29], and we show for the first time that the technique can reduce search in the Hamiltonian circuit problem. We have given a very general logical description of how some theorems can be proved in such a way as to generate search procedures. <p> Doing this, search may terminate earlier than in a more straightforward implementation. Indeed, some other sophisticated search algorithms do exactly this: examples are Forward Checking (FC) [25] and Maintaining Arc Consistency (MAC) [42] both of which can be merged with CBJ <ref> [40, 23] </ref>. These techniques could be implemented directly in our framework. In particular, just as assignments can be generalized to cache computations (as described in section 7), so information about impossible values and conflict sets for future variables could be stored in generalized assignments.
Reference: [24] <author> T. Griffin. </author> <title> A formulas-as-types notion of control. </title> <booktitle> In Proc. of the Seventeeth Annual Symp. on Principles of Programming Languages, </booktitle> <pages> pages 47-58, </pages> <address> New York, </address> <year> 1990. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: Since the original discovery that Felleisen's control operator C could be given a type corresponding to the law of double negation elimination, a great deal of work has been done on the computational meaning of classical proof <ref> [2, 3, 6, 24, 33, 36] </ref>. However, these ideas have not been exploited in the context of program development or verification. To this end, we have shown how a limited use of classical reasoning in a proof can produce a program extraction which includes a nonlocal control operator. <p> To get this computational behavior from the proof, we use the fact that call/cc can be given the type ((ff ! fi) ! ff) ! ff for any types ff and fi <ref> [24, 26] </ref>. This is a classical axiom which corresponds to a form of proof by contradiction, particularly when we take fi to be ?, or falsity. If, from the assumption that ff implies false, we can prove ff, then we have a contradiction so ff must be true. <p> The observation that nonlocal control operators could be given classical types is due to Griffin <ref> [24] </ref>; Murthy [33, 34] developed this idea to describe in more detail the connection between continuation passing style program transformations and translations of classical logic into constructive logic. There are limits of program extraction from classical proof [33]; however, our use of this connection is justifiable using this work.
Reference: [25] <author> R.M. Haralick and G.L. Elliott. </author> <title> Increasing tree search efficiency for constraint satisfaction problems. </title> <journal> Artificial Intelligence, </journal> <volume> 14 </volume> <pages> 263-313, </pages> <year> 1980. </year>
Reference-contexts: Doing this, search may terminate earlier than in a more straightforward implementation. Indeed, some other sophisticated search algorithms do exactly this: examples are Forward Checking (FC) <ref> [25] </ref> and Maintaining Arc Consistency (MAC) [42] both of which can be merged with CBJ [40, 23]. These techniques could be implemented directly in our framework.
Reference: [26] <author> R. Harper, B.F. Duba, and D. MacQueen. </author> <title> Typing first-class continuations in ML. </title> <journal> Journal of Functional Programming, </journal> <volume> 3 </volume> <pages> 465-484, </pages> <year> 1993. </year>
Reference-contexts: To get this computational behavior from the proof, we use the fact that call/cc can be given the type ((ff ! fi) ! ff) ! ff for any types ff and fi <ref> [24, 26] </ref>. This is a classical axiom which corresponds to a form of proof by contradiction, particularly when we take fi to be ?, or falsity. If, from the assumption that ff implies false, we can prove ff, then we have a contradiction so ff must be true.
Reference: [27] <author> D.J. Howe. </author> <title> Reasoning about functional programs in Nuprl. </title> <editor> In P.F. Lauer, editor, </editor> <booktitle> Functional Programming, Concurrency, Simulation and Automated Reasoning, </booktitle> <pages> pages 145-164. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The typing rules describe when a term inhabits a type, and are expressive enough to permit typing judgements about terms without always having to assign types to every subterm. In particular, general recursive functions can be defined using Curry's Y combinator <ref> [27] </ref>. This method is useful for generating readable and efficient extracts. Additionally, theorems stating induction principles can be proved so that the computational content of their proofs are efficient recursion schemes. The typing ensures that the recursion is well-founded.
Reference: [28] <author> Paul Jackson. </author> <title> The Nuprl proof developemnt system, version 4.2 reference manual and user's guide. </title> <institution> Computer Science Department, Cornell University, Ithaca, N.Y. </institution> <note> Manuscript available at http://www.cs.cornell.edu/Info/Projects/NuPrl/, July 1995. </note>
Reference-contexts: The Nuprl type system is extremely rich. For the purposes of this paper we use it with little explanation but hope interested readers will seek further information elsewhere. The Nuprl book [14] offers a detailed description of the type theory. Also see <ref> [28] </ref>. As in other constructive type theories, in Nuprl we can extract a program (i.e. something which is meant to be interpreted computationally) from proofs in the logic. Three aspects of Nuprl are of particular interest for the purposes of this paper.
Reference: [29] <author> G. Kondrak and P. van Beek. </author> <title> A theoretical evaluation of selected backtracking algorithms. </title> <journal> Artificial Intelligence, </journal> <volume> 89 </volume> <pages> 365-387, </pages> <year> 1997. </year>
Reference-contexts: Among examples of such problems are all NP-complete problems [19], although we make no assumptions which limit us to NP problems. Informal proofs of correctness of CBJ have been presented by Ginsberg [22] and Kondrak and van Beek <ref> [29] </ref>, but until now it has not been proved correct in a formal framework. The value of CBJ as a search reduction technique has been shown 5 experimentally [43, 23, 1, 5] and theoretically [29], and we show for the first time that the technique can reduce search in the Hamiltonian <p> proofs of correctness of CBJ have been presented by Ginsberg [22] and Kondrak and van Beek <ref> [29] </ref>, but until now it has not been proved correct in a formal framework. The value of CBJ as a search reduction technique has been shown 5 experimentally [43, 23, 1, 5] and theoretically [29], and we show for the first time that the technique can reduce search in the Hamiltonian circuit problem. We have given a very general logical description of how some theorems can be proved in such a way as to generate search procedures. <p> Such data sets from a `phase transition region', with a mixture of soluble and insoluble problems, are often used for benchmarking algorithms [11]. It is interesting to compare the number of branches searched with and without backjumping. Assuming Kondrak and van Beek's results for binary constraint satisfaction problems <ref> [29] </ref> extend to the general case of CBJ, the use of backjumping while using the same heuristics and checking mechanism should never increase the number of branches searched, while possibly decreasing it, compared to simple backtracking. <p> While our code did run slower than a previously described algorithm, there is nothing essential to our methodology which makes this necessary. 8 Related and future work Following Prosser's introduction of conflict-directed backjumping (CBJ) [40], Ginsberg [22] and Kondrak and van Beek <ref> [29] </ref> have given proofs of the correctness of CBJ and also related the numbers of nodes searched by different algorithms. The significant advance of our work is in its underlying basis in formal semantics and in its generality. <p> Choosing an appropriate search algorithm is often the key step in solving combinatorial problems. Kondrak and van Beek have classified a variety of constraint satisfaction algorithms and related the numbers of nodes searched by different algorithms <ref> [29] </ref>. It would be interesting to generalize this work within our framework, relating algorithms formally proven correct and very generally applicable. This would go some way to the problem of distinguishing between algorithms.
Reference: [30] <author> Zhaohui Luo. </author> <title> Computation and Reasoning: A Type Theory for Computer Science. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: Finally, the Nuprl proof could be generalized to more abstract types for sets and assignments. In earlier work [21], two of the authors formalized the core of this work in Lego <ref> [30, 38] </ref>, an implementation of type theory based on an extension of the calculus of constructions [15]. Lego does not have Nuprl's sophisticated program extraction mechanisms, so the result was not so closely connected to Scheme code.
Reference: [31] <author> S. Martello. </author> <title> An enumerative algorithm for finding Hamiltonian circuits in a directed graph. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 9 </volume> <pages> 131-138, </pages> <year> 1983. </year>
Reference-contexts: Our results suggest that conflict-directed backjumping is a worthwhile technique for the Hamiltonian circuit problem. We tested the same graphs with an implementation of Martello's algorithm <ref> [31] </ref>: on each of the 100 problems this reported the same status as our implementation, suggesting correctness of our implementation of the functions for Hamiltonian circuit. Martello's algorithm includes two features not present in 27 our implementation of CBJ: an effective dynamic variable ordering heuristic, and propagation techniques.
Reference: [32] <author> P. Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In Sixth International Congress for Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pages 153-75. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1982. </year>
Reference-contexts: To take advantage of the efficiencies offered by modern compiler technology, we translate the extracted program into Scheme in a natural way. The Appendix includes a discussion of the translation and the texts of both programs. Nuprl is an implementation of an extended Martin-Lof type theory <ref> [32] </ref>. The Nuprl type system is extremely rich. For the purposes of this paper we use it with little explanation but hope interested readers will seek further information elsewhere. The Nuprl book [14] offers a detailed description of the type theory. Also see [28].
Reference: [33] <author> C.R. Murthy. </author> <title> Extracting Constructive Content from Classical Proofs. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1990. </year> <note> Also Department of Computer Science technical report TR90-1151. </note>
Reference-contexts: Since the original discovery that Felleisen's control operator C could be given a type corresponding to the law of double negation elimination, a great deal of work has been done on the computational meaning of classical proof <ref> [2, 3, 6, 24, 33, 36] </ref>. However, these ideas have not been exploited in the context of program development or verification. To this end, we have shown how a limited use of classical reasoning in a proof can produce a program extraction which includes a nonlocal control operator. <p> The observation that nonlocal control operators could be given classical types is due to Griffin [24]; Murthy <ref> [33, 34] </ref> developed this idea to describe in more detail the connection between continuation passing style program transformations and translations of classical logic into constructive logic. There are limits of program extraction from classical proof [33]; however, our use of this connection is justifiable using this work. <p> There are limits of program extraction from classical proof <ref> [33] </ref>; however, our use of this connection is justifiable using this work. To accommodate these ideas, we must modify the statement and proof of the theorem. <p> This was accomplished by making a classical extension to the system. We added a rule corresponding to double negation elimination and specified the extract of invocations of the rule to be the term call/cc. The extension is semantically justified by <ref> [33, 34] </ref>.
Reference: [34] <author> C.R. Murthy. </author> <title> An evaluation semantics for classical proofs. </title> <booktitle> In Proceedings 6th Annual IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 96-107. </pages> <publisher> IEEE, Los Alamitos, </publisher> <address> CA, </address> <year> 1991. </year>
Reference-contexts: The observation that nonlocal control operators could be given classical types is due to Griffin [24]; Murthy <ref> [33, 34] </ref> developed this idea to describe in more detail the connection between continuation passing style program transformations and translations of classical logic into constructive logic. There are limits of program extraction from classical proof [33]; however, our use of this connection is justifiable using this work. <p> This was accomplished by making a classical extension to the system. We added a rule corresponding to double negation elimination and specified the extract of invocations of the rule to be the term call/cc. The extension is semantically justified by <ref> [33, 34] </ref>.
Reference: [35] <author> P. Norvig. </author> <title> Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp. </title> <publisher> Morgan Kauffman, </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: As dialects of Lisp, the translation between these languages is mostly straightforward, except that call/cc is not available in Common Lisp. Fortunately, Norvig has described a simple implementation of call/cc in Common Lisp when (as here) the created continuation only has dynamic extent <ref> [35] </ref>. Our translated code produced identical results to that of our Scheme code. On our 100 graphs Martello's algorithm required a mean of 0.0850 cpu seconds per instance on a DEC Alpha 3000-300LX 125MHz running Gnu Common Lisp.
Reference: [36] <author> M. Parigot. </author> <title> -calculus: An algorithmic interpretation of classical natural deduction. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Proceedings International Conference on Logic Programming and Automated Reasoning, LPAR'92, </booktitle> <pages> pages 190-201. </pages> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Since the original discovery that Felleisen's control operator C could be given a type corresponding to the law of double negation elimination, a great deal of work has been done on the computational meaning of classical proof <ref> [2, 3, 6, 24, 33, 36] </ref>. However, these ideas have not been exploited in the context of program development or verification. To this end, we have shown how a limited use of classical reasoning in a proof can produce a program extraction which includes a nonlocal control operator.
Reference: [37] <author> P. Pepper and D. R. Smith. </author> <title> A high-level derivation of global search algorithms (with constraint propagation. </title> <journal> Science of Computer Programming, Special Issue on FMTA (Formal Methods: Theory and Applications, </journal> <year> 1996. </year>
Reference-contexts: Our results are very general because they apply to a wide variety of search algorithms, and a wide variety of problem classes, all obtainable from the Scheme code we have presented by implementing suitable service functions. Related work on formal development of search algorithms by Smith et. al. <ref> [7, 37, 44] </ref> has concentrated on techniques for transforming search problem specifications into executable search procedures. These techniques make use of a deep 29 analysis of the structure of the problem specification to produce very efficient code tuned to the particular constraints involved.
Reference: [38] <author> R. Pollack. </author> <title> The Theory of Lego. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1995. </year> <note> Available as report ECS-LFCS-95-323. </note>
Reference-contexts: Finally, the Nuprl proof could be generalized to more abstract types for sets and assignments. In earlier work [21], two of the authors formalized the core of this work in Lego <ref> [30, 38] </ref>, an implementation of type theory based on an extension of the calculus of constructions [15]. Lego does not have Nuprl's sophisticated program extraction mechanisms, so the result was not so closely connected to Scheme code.
Reference: [39] <author> P. Prosser. </author> <title> Distributed Asynchronous Scheduling. </title> <type> PhD thesis, </type> <institution> Strathclyde University, </institution> <year> 1990. </year>
Reference-contexts: Backjumping as a search reduction technique was first described by Gaschnig [20], but his presentation was very limited in the amount of backjumping performed. Conflict-directed backjumping (CBJ), a more extensive form of back-jumping, was first described by Prosser in the context of a scheduling problem <ref> [39] </ref>. Later, it was generalized to binary constraint satisfaction problems [40], and arbitrary constraint satisfaction problems [22]. Here, we have generalized it further and view it as a general search reduction technique rather than as an algorithm for a particular problem.
Reference: [40] <author> P. Prosser. </author> <title> Hybrid algorithms for the constraint satisfaction problem. </title> <journal> Computational Intelligence, </journal> <volume> 9 </volume> <pages> 268-299, </pages> <year> 1993. </year>
Reference-contexts: There are three main motivations of this work. First, we wished to create a framework which separates the search algorithm from domain specific information. This enables certain search techniques developed for specific problems to be applied in many more situations. For example, conflict-directed backjump-ing (CBJ) <ref> [40] </ref> was invented for solving scheduling problems, but can be applied to reduce search in a very wide range of problems. The original presentation of CBJ did not reflect its generality, which is revealed by our more abstract approach to search. <p> Conflict-directed backjumping (CBJ), a more extensive form of back-jumping, was first described by Prosser in the context of a scheduling problem [39]. Later, it was generalized to binary constraint satisfaction problems <ref> [40] </ref>, and arbitrary constraint satisfaction problems [22]. Here, we have generalized it further and view it as a general search reduction technique rather than as an algorithm for a particular problem. <p> However, improvements to general search algorithms are rarely presented as such in the literature; instead, a method is often introduced in one problem area (e.g. constraint satisfaction) and later applied to other areas. For example, conflict-directed backjumping was described for constraint satisfaction problems <ref> [40, 22] </ref> some years before being applied successfully to propositional satisfia-bility [4, 5] and it has not previously been presented as generally as we do so here. <p> Other search optimization techniques can be incorporated by modifications to the proof. In this section, we describe two of these optimization techniques in detail. The first technique is a simple check on the consistency of a partial assignment. Second, we describe conflict-directed backjumping <ref> [40] </ref> and how it may be implemented by a modification to the proof. <p> If however other clauses were present which ruled out c = F without involving variable b, we could backjump over b to try 14 a = F . The success of backjumping techniques is not limited to such contrived examples, and has been shown in larger problems <ref> [40, 43, 1, 5] </ref>. To get this computational behavior from the proof, we use the fact that call/cc can be given the type ((ff ! fi) ! ff) ! ff for any types ff and fi [24, 26]. <p> Our implementation achieved significant reductions in search compared to a backtracking algorithm. While our code did run slower than a previously described algorithm, there is nothing essential to our methodology which makes this necessary. 8 Related and future work Following Prosser's introduction of conflict-directed backjumping (CBJ) <ref> [40] </ref>, Ginsberg [22] and Kondrak and van Beek [29] have given proofs of the correctness of CBJ and also related the numbers of nodes searched by different algorithms. The significant advance of our work is in its underlying basis in formal semantics and in its generality. <p> Doing this, search may terminate earlier than in a more straightforward implementation. Indeed, some other sophisticated search algorithms do exactly this: examples are Forward Checking (FC) [25] and Maintaining Arc Consistency (MAC) [42] both of which can be merged with CBJ <ref> [40, 23] </ref>. These techniques could be implemented directly in our framework. In particular, just as assignments can be generalized to cache computations (as described in section 7), so information about impossible values and conflict sets for future variables could be stored in generalized assignments.
Reference: [41] <author> J.-F. Puget. </author> <title> Applications of constraint programming. </title> <editor> In U. Montanari and F. Rossi, editors, </editor> <booktitle> Principles and Practice of Constraint Programming - CP95, </booktitle> <pages> pages 647-650, </pages> <address> Berlin, 1995. </address> <publisher> Springer. </publisher>
Reference-contexts: Powerful toolkits have been built, for example ILOG Solver, which has been applied to problems such as airport gate scheduling, timetabling, staff rostering, and manufacturing process scheduling <ref> [41] </ref>. Despite this success, there has been little recognition of the generality of most search techniques. Furthermore, many algorithms have been introduced without proof and only proved correct later, and typically with respect to, at best, pseudo-code. Some important algorithms have yet to be proved sound and complete.
Reference: [42] <author> D. Sabin and E.C. Freuder. </author> <title> Contradicting conventional wisdom in constraint satisfaction. </title> <booktitle> In Proceedings of ECAI-94, </booktitle> <pages> pages 125-129, </pages> <address> Chichester, </address> <year> 1994. </year>
Reference-contexts: Doing this, search may terminate earlier than in a more straightforward implementation. Indeed, some other sophisticated search algorithms do exactly this: examples are Forward Checking (FC) [25] and Maintaining Arc Consistency (MAC) <ref> [42] </ref> both of which can be merged with CBJ [40, 23]. These techniques could be implemented directly in our framework.
Reference: [43] <author> B.M. Smith and S.A. Grant. </author> <title> Sparse constraint graphs and exceptionally hard problems. In C.S. </title> <editor> Mellish, editor, </editor> <booktitle> Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 646-651, </pages> <address> San Mateo, CA, 1995. </address> <publisher> Morgan Kauffman. </publisher>
Reference-contexts: Informal proofs of correctness of CBJ have been presented by Ginsberg [22] and Kondrak and van Beek [29], but until now it has not been proved correct in a formal framework. The value of CBJ as a search reduction technique has been shown 5 experimentally <ref> [43, 23, 1, 5] </ref> and theoretically [29], and we show for the first time that the technique can reduce search in the Hamiltonian circuit problem. We have given a very general logical description of how some theorems can be proved in such a way as to generate search procedures. <p> If however other clauses were present which ruled out c = F without involving variable b, we could backjump over b to try 14 a = F . The success of backjumping techniques is not limited to such contrived examples, and has been shown in larger problems <ref> [40, 43, 1, 5] </ref>. To get this computational behavior from the proof, we use the fact that call/cc can be given the type ((ff ! fi) ! ff) ! ff for any types ff and fi [24, 26].
Reference: [44] <author> D. R. Smith, E. A. Parra, and S. J. Westfold. </author> <title> Synthesis of planning and scheduling software. </title> <editor> In A. Tate, editor, </editor> <title> Advanced Planning Technology. </title> <publisher> AAAI Press, </publisher> <year> 1996. </year> <month> 35 </month>
Reference-contexts: Our results are very general because they apply to a wide variety of search algorithms, and a wide variety of problem classes, all obtainable from the Scheme code we have presented by implementing suitable service functions. Related work on formal development of search algorithms by Smith et. al. <ref> [7, 37, 44] </ref> has concentrated on techniques for transforming search problem specifications into executable search procedures. These techniques make use of a deep 29 analysis of the structure of the problem specification to produce very efficient code tuned to the particular constraints involved.
Reference: [45] <author> R.M. Smullyan. </author> <title> First Order Logic. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1968. </year>
Reference-contexts: But there are many examples of proof search where we are not interested in the proof object as such, merely that one exists and thus that the given conjecture is a theorem. For example, proof systems based on semantic tableaux <ref> [45] </ref> typically search for a counter-model: if a counter-model is found, it is produced as evidence that the conjecture is false, while if none is found the constructed tableau is often discarded.
Reference: [46] <author> J.L. Underwood. </author> <title> The tableau algorithm for intuitionistic propositional calculus as a constructive completeness proof. </title> <booktitle> In Proceedings of the Workshop on Theorem Proving with Analytic Tableaux, Marseille, France, </booktitle> <pages> pages 245-248, </pages> <year> 1993. </year> <note> Available as Technical Report MPI-I-93-213 Max-Planck-Institut fur Informatik, Saarbrucken, Germany. </note>
Reference-contexts: Structure: P (s)) _ (9R : Reason: R ! 8s : Structure: :P (s)) Note that in the context of proof search, if R is a model in some sound model theory for the logic, then a proof of this theorem is, in fact, a completeness proof for the logic <ref> [13, 46] </ref>. We will see (in section 4.2) that we may be able to exploit R to prune the search space and thus generate more efficient search algorithms. We now consider further the design of the proof and the algorithm we expect to derive from it. <p> Another area yet to be explored fully is the application of these ideas to backtracking proof search procedures like tableaux. When tableau search is constructed as a search in parallel for a proof and a counter-model <ref> [46] </ref>, it has the same logical structure as the search described in section 2.
Reference: [47] <author> J.L. Underwood. </author> <title> Aspects of the Computational Content of Proofs. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1994. </year> <note> Also Department of Computer Science technical report TR94-1460. 36 </note>
Reference-contexts: The computational content of that proof then constitutes a correct search procedure. This approach has been used to develop verified decision procedures, namely tableau proof search algorithms for classical and constructive propositional logic <ref> [10, 47] </ref>. In this paper, we extend the idea to a large class of problems involving search, to produce a general template for development of search procedures. There are three main motivations of this work.
References-found: 47

