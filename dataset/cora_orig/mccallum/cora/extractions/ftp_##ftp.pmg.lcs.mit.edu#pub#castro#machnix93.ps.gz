URL: ftp://ftp.pmg.lcs.mit.edu/pub/castro/machnix93.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/~castro/pubs.html
Root-URL: 
Email: email: (miguel,nuno,pedro,pms)@sabrina.inesc.pt  
Title: MIKE A distributed object-oriented programming platform on top of the Mach micro-kernel offer a single
Author: Miguel Castro, Nuno Neves, Pedro Trancoso and Pedro Sousa INESC R. Alves Redol n o Lisboa PORTUGAL 
Note: MIKE's primary goal is to  
Abstract: This paper describes the architecture and implementation of MIKE aversion of the IK distributed persistent object-oriented programming platform built on top of the Mach microkernel. The platform supports fine grained objects which can be invoked in a location transparent way and whose references can be exchanged freely as invocation parameters. These objects are potentially persistent. MIKE supports the abstraction of one-level store, persistent objects are transparently loaded on demand when first invoked and saved to disk when the application terminates. Class objects are special persistent objects which are dynamically linked when needed. The platform also offers distributed garbage collection of non-persistent objects. This paper discusses how MIKE makes use of Mach's features to offer the functionality described above and the techniques used to achieve good performance. MIKE is compared with the Unix versions of IK to evaluate the benefits of using Mach abstractions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mike Accetta, Robert Baron, William Bolosky, David Golub, Richard Rashid, Avadis Teva-nian, and Michael Young. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> In Proceedings of Summer Usenix, </booktitle> <month> July </month> <year> 1986. </year>
Reference-contexts: All these problems tend to separate the application into static sets of co-located objects that communicate with remote ones using Remote Procedure Call (RPC) based client-server interfaces. MIKE, Mach IK Environment, is a redesigned version of the INESC Kernel (IK [9, 13]) that takes advantage of Mach's <ref> [1] </ref> features. IK's primary goal is to offer a single object-oriented programming paradigm for writing distributed applications. In the current versions, applications are written in EC++, a language with the same syntax as C++ but with some restrictions and semantic extensions [11].
Reference: [2] <author> P. Amaral, C. Jacquemot, P. Jensen, R. Lea, and A. Mirowksi. </author> <title> Transparent Object Migration in COOL-2. </title> <booktitle> In Proceedings of Workshop on Dynamic Object Placement and Load-Balancing in Parallel and Distributed Systems, </booktitle> <address> ECOOP'92, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Namely COOL <ref> [2] </ref>, the multi-server [6] and Casper [15]. The first one exploits the Chorus [10] functionality and the last two exploit the facilities offered by Mach. MIKE's distributed object sharing support is similar to the one in the multi-server.
Reference: [3] <author> Richard P. Draves. </author> <title> A Revised IPC Interface. </title> <booktitle> In Proceedings of the USENIX Mach Conference, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: MIKE associates a Mach port with objects known remotely and remote contexts use send rights to reference them. This scheme has several advantages location transparency, notifications of port destruction, port reference counting and protection by capabilities <ref> [3] </ref>; but it does not solve all problems. 3.2.1 Referencing potentially persistent distributed objects On the one hand persistent objects survive the death of all contexts referencing them and, on the other hand, ports are volatile entities a port is destroyed along with its associated rights when the task holding the
Reference: [4] <author> Michael Feeley and Henry Levy. </author> <title> Distributed Shared Memory with Versioned Objects. </title> <booktitle> In Proceedings of OOPSLA'92, </booktitle> <pages> pages 247-262, </pages> <address> Vancouver, Canada, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: In fact, our average object size, 48 bytes, is much smaller than the unit of sharing, the 4 Kbytes page. We believe the unit of sharing must be the language level object or even fragments of it <ref> [4] </ref>. Casper and COOL use object clustering techniques to minimize the false sharing problem. Another problem with Casper and COOL's distributed shared memory implementation is that they offer a sequentially consistent memory, using page invalidation to detect and classify memory accesses.
Reference: [5] <author> Paulo Ferreira. </author> <title> Reclaiming Storage in an Object Oriented Platform Supporting Extended C++ and Objective-C Applications. </title> <booktitle> In Proceedings of the International Workshop on Object Orientation in Operating Systems IEEE, </booktitle> <address> Palo-Alto, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Objects are represented by Run Time Headers (RTH). The RTH hold all relevant per-object information. Local object references are pointers to these headers. The data field in the RTH points to the object's instance data. This indirection simplifies object mobility. IK's conservative copying garbage collector <ref> [5] </ref> relies on this indirection. It also simplifies the implementation of lazy evaluation techniques like on demand dynamic linking and delayed pointer swizzling. On the other hand, accesses to the instance data are penalized. <p> Since the port set only contains object ports it is guaranteed that the obtained reference always points to a valid object. 3.4 Garbage collection MIKE uses a slightly modified version of IK's garbage collector <ref> [5] </ref>. Small objects are recycled using an algorithm similar to generation scavenging. Garbage collection of large objects and run time headers is based on an incremental mark-and-sweep algorithm. Only volatile objects are recycled.
Reference: [6] <author> Paulo Guedes and Daniel Julin. </author> <title> Writing a Client-Server Application in C++. </title> <booktitle> In Proceedings of the USENIX C++ conference, </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: For example, references to the server "object" can be freely exchanged in invocations. In spite of this advantage, MiG stubs are large. The use of a dynamic marshalling and unmarshalling mechanism similar to the one used in <ref> [6] </ref> would halve proxy class sizes. 3.3.3 Inheritance in remote invocation Inheritance in remote invocation is supported by the addition of two shadow replicas of the original class hierarchy, one for the server proxy classes and another for the client proxy's. <p> Namely COOL [2], the multi-server <ref> [6] </ref> and Casper [15]. The first one exploits the Chorus [10] functionality and the last two exploit the facilities offered by Mach. MIKE's distributed object sharing support is similar to the one in the multi-server. The two systems use a function shipping model implemented using Mach inter-process communication.
Reference: [7] <author> K. Li and P. Hudak. </author> <title> Memory Coherence in Shared Virtual Memory Systems. </title> <journal> ACM Transac--tions on Computer Systems, </journal> <volume> 17(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: MIKE's distributed object sharing support is similar to the one in the multi-server. The two systems use a function shipping model implemented using Mach inter-process communication. Casper and COOL use data-shipping to share objects between contexts. Both systems use a page-based distributed shared memory similar to Li's <ref> [7] </ref>, implemented with external pagers. COOL also supports an RPC based object sharing mechanism. MIKE does not use a page-based distributed shared memory because of the well known false sharing problem.
Reference: [8] <author> Keith Loepere. </author> <title> Mach 3 Server Writer's Guide. Open Software Foundation, </title> <month> January </month> <year> 1992. </year>
Reference-contexts: The first three components are the "on-the-wire" reference representation and pType is the port type. pType is needed because object ports are declared polymorphic on the sender's side <ref> [8] </ref>. The proxy classes call XRef for each exported reference. XRef tests the object's status. If the object does not have an associated server proxy, XRef associates an LLI, a port and an instance of the corresponding server proxy class with the object. <p> When this happens the send right is destroyed. If it is the last client proxy the context where the object is mapped will receive a no-more-senders notification. The notification handler compares the current receive right make send count with the one in the notification message <ref> [8] </ref>. This comparison is made under the protection of the object lock to ensure that no references are exported during the process. If the make send counts differ a new notification is requested.
Reference: [9] <author> Jose Alves Marques and Paulo Guedes. </author> <title> Extending the Operating System to Support an Object-Oriented Environment. </title> <booktitle> In Proceedings of OOPSLA '89, </booktitle> <pages> pages 113-122, </pages> <address> New Orleans, Louisiana, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: All these problems tend to separate the application into static sets of co-located objects that communicate with remote ones using Remote Procedure Call (RPC) based client-server interfaces. MIKE, Mach IK Environment, is a redesigned version of the INESC Kernel (IK <ref> [9, 13] </ref>) that takes advantage of Mach's [1] features. IK's primary goal is to offer a single object-oriented programming paradigm for writing distributed applications. In the current versions, applications are written in EC++, a language with the same syntax as C++ but with some restrictions and semantic extensions [11].
Reference: [10] <author> Mark Rozier, Vadim Abrozimov, Francois Armand, Ivan Boule, Frede Hermann, Michel Gien, Mark Guillemont, Claude Kaiser, Pierre Leonard, Sylvain Langlois, and Willi Neuhauser. </author> <title> Chorus Distributed Operating System. </title> <booktitle> In Computing Systems, </booktitle> <volume> volume 1, </volume> <pages> pages 304-370, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Namely COOL [2], the multi-server [6] and Casper [15]. The first one exploits the Chorus <ref> [10] </ref> functionality and the last two exploit the facilities offered by Mach. MIKE's distributed object sharing support is similar to the one in the multi-server. The two systems use a function shipping model implemented using Mach inter-process communication. Casper and COOL use data-shipping to share objects between contexts.
Reference: [11] <author> Manuel Sequeira and Jose Alves Marques. </author> <title> Can C++ be Used for Programming Distributed and Persistent Objects? In Proceedings of the International Workshop on Object Orientation in Operating Systems IEEE, </title> <address> Palo Alto, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: IK's primary goal is to offer a single object-oriented programming paradigm for writing distributed applications. In the current versions, applications are written in EC++, a language with the same syntax as C++ but with some restrictions and semantic extensions <ref> [11] </ref>. It supports fine grained objects which can be invoked in a location transparent way across the distributed system and whose references can be freely exchanged as invocation parameters.
Reference: [12] <author> Marc Shapiro. </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <booktitle> In The 6th International Conference on Distributed Computer Systems, </booktitle> <pages> pages 198-204, </pages> <address> Cam-bridge, Mass., 1986. </address> <publisher> IEEE. </publisher>
Reference-contexts: Therefore, the macro locates the server proxy object using the port name and retrieves the object's reference from the server proxy's RTH. One advantage of interposing proxy classes in remote invocations is that the programmer can change the default implementation to meet specific application needs <ref> [12] </ref> (e.g. introduce caching for efficiency, encapsulate shared memory access and manage replica-tion). Furthermore, different client proxy classes can be used to access the same remote object. The layering of the proxy classes on top of MiG stubs eases the interconnection of MIKE's applications with existing servers.
Reference: [13] <author> Pedro Sousa, Manuel Sequeira, Andre Zuquete, Paulo Guedes, and Jose Alves Marques. </author> <title> The IK Distributed and Persistent Platform | Overview and Evaluation. </title> <type> Technical report, </type> <institution> IN-ESC, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: All these problems tend to separate the application into static sets of co-located objects that communicate with remote ones using Remote Procedure Call (RPC) based client-server interfaces. MIKE, Mach IK Environment, is a redesigned version of the INESC Kernel (IK <ref> [9, 13] </ref>) that takes advantage of Mach's [1] features. IK's primary goal is to offer a single object-oriented programming paradigm for writing distributed applications. In the current versions, applications are written in EC++, a language with the same syntax as C++ but with some restrictions and semantic extensions [11]. <p> These objects are distributed through several nodes to achieve true parallelism and speed-up image rendering. 2 Overview MIKE uses an object-oriented approach, all entities are objects conforming to a simple conceptual model. This model was inherited from IK and it is fully described in <ref> [13] </ref>. 2.1 Basic abstractions The platform offers the following set of basic abstractions: Object An object is a passive data structure which exports a set of methods defined by its class (or by its class superclasses). Objects can be volatile or persistent. Persistent objects survive application termination. <p> It is responsible for 30% of the total cost of an inter-node remote invocation between a Sparc 10/20 and a Sparc 10/30, where the SunOS 4.1.3 LWP thread package is used <ref> [13] </ref>. Furthermore, when a thread blocks in a page fault requiring I/O, the entire context blocks. On the other hand, MIKE uses Cthreads supported by multiple kernel threads. These threads can handle blocking operations more efficiently, including page faults. <p> The main reasons for this are the more efficient IPC and threads implementation on Mach. In particular, MIKE's intra-node remote invocation is ten times faster than IK's SunOS version on top of a Sparc 10/30 <ref> [13] </ref> and the inter-node remote invocation is 30% faster than in IK (in the same test configuration as described in the previous paragraphs). On the other hand, inter-node remote invocation supported by the netmessage server is very slow.
Reference: [14] <author> Avadis Tevanian, Richard F. Rashid, David B. Golub, David L. Black, Eric Cooper, and Michael Young. </author> <title> Mach Threads and the Unix Kernel: The Battle for Control. </title> <type> Technical Report CMU-CS-87-149, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: It compares MIKE with the versions of IK that only use traditional Unix abstractions. In IK threads are implemented by user level code without kernel support, which has the usual advantages and disadvantages <ref> [14] </ref>. Since IK controls the thread scheduling, preemption can only occur in well known points. This renders synchronization unnecessary in most accesses to shared data structures. In particular, there is no need to synchronize accesses to the method's cache, which makes IK's intra-context invocation faster than MIKE's.
Reference: [15] <author> F. Vaughan, T. Basso, A. Dearle, C. Marlin, and C. Barter. Casper: </author> <title> a Cached Architecture Supporting Persistence. </title> <journal> Computing Systems, </journal> <volume> 5(3) </volume> <pages> 337-359, </pages> <year> 1992. </year>
Reference-contexts: Namely COOL [2], the multi-server [6] and Casper <ref> [15] </ref>. The first one exploits the Chorus [10] functionality and the last two exploit the facilities offered by Mach. MIKE's distributed object sharing support is similar to the one in the multi-server. The two systems use a function shipping model implemented using Mach inter-process communication.
References-found: 15

