URL: ftp://ftp.cs.pitt.edu/panos/WMPM/srds_95.ps.gz
Refering-URL: http://www.cs.pitt.edu/admt/Projects/mobile_computing.html
Root-URL: 
Title: Supporting Semantics-Based Transaction Processing in Mobile Database Applications  
Author: Gary D. Walborn and Panos K. Chrysanthis 
Address: Pittsburgh Pittsburgh, PA 15260  
Affiliation: Department of Computer Science University of  
Abstract: Advances in computer and telecommunication technologies have made mobile computing a reality. However, greater mobility implies a more tenuous network connection and a higher rate of disconnection. In order to tolerate disconnections as well as to reduce the delays and cost of wireless communication, it is necessary to support autonomous mobile operations on data shared by stationary hosts. This would allow the part of a computation executing on a mobile host to continue executing while the mobile host is not connected to the network. In this paper, we examine whether object semantics can be exploited to facilitate autonomous and disconnected operation in mobile database applications. We define the class of fragmentable objects which may be split among a number of sites, operated upon independently at each site, and then recombined in a semantically consistent fashion. A number of objects with such characteristics are presented and an implementation of fragmentable stacks is shown and discussed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alonso R., D. Barbara, and H. Garcia-Molina. </author> <title> Data Caching Issues in an Information Retrieval Systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(3) </volume> <pages> 359-384, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: As opposed to serializability, these methods typically view data consistency and transaction correctness independently [26]. Data consistency captures correctness from the perspective of objects in the database. Data consistency requirements range from strict consistency (as defined by serializability) to eventual consistency <ref> [1, 28] </ref>. Eventual consistency denotes a temporal or spatial divergence from strict consistency the extend of which can be expressed in terms of degrees of inconsistency. <p> For example, a degree may require consistency "at a specific real-time," "within some time" or "after a certain amount of change to some data," or enforcing consistency "after a certain value of the data is reached," etc. Divergence control protocols such as those for quasi-copies <ref> [1] </ref> and for epsilon-serializability [25] allow for the applications to specify their currency requirements and the inconsistency with which they can cope. These protocols can also facilitate the tuning of cache management on mobile hosts according to the available bandwidth and monetary cost of wireless communication [6].
Reference: [2] <author> Alonso R., and H. Korth. </author> <booktitle> Database Issues in Nomadic Computing. Proc. of ACM SIGMOD Conf., </booktitle> <pages> pp. 388-392, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Application-specific criteria have been mainly proposed in database environments with characteristics similar to those of mobile database applications. As discussed above, ensuring serializability and maintaining strict consistency among data stored on both mobile and stationary hosts is very constraining as well as expensive <ref> [2, 15, 30] </ref>. For this reason, current approaches that aim to support transactions which perform updates on cached objects at the mobile hosts advocate application-specific criteria. For example, an open-nested transaction model has been proposed in [11] for modeling mobile transactions as a set of sub-transactions.
Reference: [3] <author> Archarya A. and B. Badrinath. </author> <title> Checkpointing distributed applications on mobile computers. </title> <booktitle> Proc. of Int'l Conf. on Parallel and Distributed Information systems, </booktitle> <pages> pp. 73-80, </pages> <year> 1994. </year>
Reference-contexts: As transactions are processed, their effects are logged on the mobile host where the transaction executes to facilitate recovery from failed or aborted transactions. Mobile host logs are checkpointed periodically on an appropriate mobility-support station <ref> [18, 3] </ref>. Merging of Fragments When a mobile host reconnects or the stack partition is no longer needed at the mobile host, any stack fragments remaining in the stack partition must be reconciled with master stack on the database server.
Reference: [4] <author> Badrinath B. R. and K. Ramamritham. </author> <title> Semantics based Concurrency Control: Beyond Com-mutativity. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(1) </volume> <pages> 163-199, </pages> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: The output values in conjunction with the inputs of the operations have been used for new definitions of conflicting operations (i.e., operations that cannot execute concurrently) which are weaker than commu-tativity and yet ensure serializability. Although these definitions, such as serial dependency [14] and recover-ability <ref> [4] </ref>, permit a higher degree of concurrency than commutativity and can be used within a traditional replicated database environment, they are associated with more complex recovery and involve more complex transaction management than commutativity.
Reference: [5] <author> Barbara D. and H. Garcia-Molina. </author> <title> The Demarcation Protocol: A Technique for Maintaining Constraints in Distributed Database Systems. </title> <booktitle> Proc. of the Int'l Conf. on Extending Data Base Technology, </booktitle> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: Thus, by assuming that the worst case of pending operations will not violate boundary conditions, the database server can incorporate the effects of committed mobile transactions in an arbitrary order that preserves serializ-ability. Whereas escrow methods ensure serializability of global executions, the demarcation protocol <ref> [5] </ref>, which was also designed to support autonomous updates on aggregate items, ensures only that local executions are serializable. The demarcation protocol does not rely on the commutativity of operations but it does exploit the object organization and integrity constraints.
Reference: [6] <author> Barbara D. and H. Garcia-Molina. </author> <title> Replicated Data Management in Mobile Environments: Anything New Under the Sun? Proc. </title> <booktitle> of the IFIP Conf. on Applications in Parallel and Distributed Computing, </booktitle> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: These protocols can also facilitate the tuning of cache management on mobile hosts according to the available bandwidth and monetary cost of wireless communication <ref> [6] </ref>. Transaction correctness requirements capture correctness from the perspective of the structure and behavior of transactions [12, 13].
Reference: [7] <author> Barbara D. and T. Imielinski. Sleepers and Workaholics: </author> <title> Caching Strategies in Mobile Environment. </title> <booktitle> Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pp. 1-12, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: A number of cache coherence schemes have been studied (in the context of mobility and disconnections) that exploit the broadcast characteristics of wireless communication to reduce the communication cost without exploiting any object semantics <ref> [7] </ref>. Commutativity of operations can be exploited in caching methods that employ a concurrency control protocol to ensure cache coherence.
Reference: [8] <author> Barghouti, N. and G. Kaiser. </author> <title> Concurrency Control in Advanced Database Applications. </title> <journal> ACM Computing Surveys, </journal> <volume> 23(3) </volume> <pages> 269-317, </pages> <year> 1991. </year>
Reference-contexts: The most permissive concurrency control schemes are those which exploit the semantics of the objects and the operations defined on them, the structure of the database, the structural and behavioral properties of the activities in the database, and the correctness requirements of the applications <ref> [8, 26] </ref>. We refer to these techniques as semantics-based transaction processing techniques.
Reference: [9] <author> Bernstein P. A., V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: The first three object characteristics have primarily been used to define various forms of commutativity which determine semantically whether two operations can be allowed to execute concurrently without compromising serializability, the traditional database correctness criterion <ref> [9] </ref>. The last characteristic, object usage, has been exploited to define application-specific correctness criteria which transcend commutativity and serializability to allow even more operations to execute concurrently and asynchronously. <p> Strict-read and strict-write operations have the same semantics as the read and write operations invoked by traditional ACID transactions <ref> [9] </ref>. A weak-read returns the value of a locally cached object written by a strict-write or a weak-write. A weak-write operation updates a locally cached object which might become permanent on cluster merging if the weak-write does not conflict with any strict-read or strict-write operation. <p> Conventional concurrency control and recovery techniques may be used to provide controlled access to the stack partition and to ensure serializability <ref> [9] </ref>. Assuming two-phase locking, uncommitted data is not made available to mobile transactions other than the transaction that pushed them and items pushed by a single transaction are contiguous in the stack partition. When a transaction on the mobile host commits, its pushed items are followed by a marker.
Reference: [10] <author> Chrysanthis P. K., S. Raghuram, and K. Ramam-ritham. </author> <title> Extracting Concurrency from Objects: A Methodology. </title> <booktitle> Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pp. 108-117, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Broadly speaking, the concurrency semantics of an object depend on the following object characteristics <ref> [10] </ref>: 1. semantics of the operations which is related to the effects of an operation on the state of an ob ject, 2. operation input/output values which refers to both the direction of information flow to and from an object and the interpretation of the in put/output values, 3. organization of
Reference: [11] <author> Chrysanthis P. K. </author> <title> Transaction Processing in a Mobile Computing Environment. </title> <booktitle> Proc. of IEEE Workshop on Advances in Parallel and Distributed Systems, </booktitle> <pages> pp. 77-82, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: For this reason, current approaches that aim to support transactions which perform updates on cached objects at the mobile hosts advocate application-specific criteria. For example, an open-nested transaction model has been proposed in <ref> [11] </ref> for modeling mobile transactions as a set of sub-transactions. The model allows for disconnected operation by supporting unilateral commitment of sub-transactions and compensating transactions. Further, it can be customized based on the application by varying the degree of isolation and autonomy of the sub-transactions of a mobile transaction.
Reference: [12] <author> Chrysanthis P. K., and K. Ramamritham. </author> <title> Synthesis of Extended Transaction Models Using ACTA. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(3) </volume> <pages> 450-491, </pages> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: These protocols can also facilitate the tuning of cache management on mobile hosts according to the available bandwidth and monetary cost of wireless communication [6]. Transaction correctness requirements capture correctness from the perspective of the structure and behavior of transactions <ref> [12, 13] </ref>.
Reference: [13] <editor> Elmagarmid A. K., editor. </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan Kauf-mann, </publisher> <year> 1992. </year>
Reference-contexts: These protocols can also facilitate the tuning of cache management on mobile hosts according to the available bandwidth and monetary cost of wireless communication [6]. Transaction correctness requirements capture correctness from the perspective of the structure and behavior of transactions <ref> [12, 13] </ref>.
Reference: [14] <author> Herlihy M. </author> <title> Apologizing Versus Asking Permission: Optimistic Concurrency Control for Abstract Data Types. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(1) </volume> <pages> 96-124, </pages> <month> Mar. </month> <year> 1990. </year>
Reference-contexts: The output values in conjunction with the inputs of the operations have been used for new definitions of conflicting operations (i.e., operations that cannot execute concurrently) which are weaker than commu-tativity and yet ensure serializability. Although these definitions, such as serial dependency <ref> [14] </ref> and recover-ability [4], permit a higher degree of concurrency than commutativity and can be used within a traditional replicated database environment, they are associated with more complex recovery and involve more complex transaction management than commutativity. <p> Reordering an ob ject is equivalent to reordering the operations on the object (and the resultant history), thus increasing the number of allowable interleavings of operations. In this light, reorderability can be seen as an instance of serial dependency <ref> [14] </ref>. 4 Implementation of Fragmentable Stacks Although splitting an object into suitable fragments and merging them back in a consistent manner is type dependent, in this section we will show a fragmentable stack implementation in order to indicate the overhead and the complexity required to manage and cache frag-mentable objects.
Reference: [15] <author> Imielinski T and B. Badrinath, </author> <title> Mobile Wireless Computing: Challenges in Data Management. </title> <journal> Communication of ACM, </journal> <volume> 37(10) </volume> <pages> 18-28, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: It is based upon work supported by N.S.F. under the grant IRI-9210588. Author's Email: fgwalborn,panosg@cs.pitt.edu In a mobile computing environment, the network is made up of stationary and mobile hosts <ref> [16, 15] </ref>. Unlike stationary hosts, mobile hosts change location and network connections while computations are being processed. While in motion, mobile hosts retain their network connection through the support of specialized stationary hosts with wireless telecommunication ability, called mobility-support stations (Figure 1). <p> Application-specific criteria have been mainly proposed in database environments with characteristics similar to those of mobile database applications. As discussed above, ensuring serializability and maintaining strict consistency among data stored on both mobile and stationary hosts is very constraining as well as expensive <ref> [2, 15, 30] </ref>. For this reason, current approaches that aim to support transactions which perform updates on cached objects at the mobile hosts advocate application-specific criteria. For example, an open-nested transaction model has been proposed in [11] for modeling mobile transactions as a set of sub-transactions.
Reference: [16] <author> Ioannidis J., D. Duchamp and G. Q. Maguire. </author> <title> Ip-Based protocols for mobile internetworking. </title> <booktitle> Proc. of ACM Symposium on Communication, Architectures and Protocols, </booktitle> <pages> pp. 235-245, </pages> <year> 1991. </year>
Reference-contexts: It is based upon work supported by N.S.F. under the grant IRI-9210588. Author's Email: fgwalborn,panosg@cs.pitt.edu In a mobile computing environment, the network is made up of stationary and mobile hosts <ref> [16, 15] </ref>. Unlike stationary hosts, mobile hosts change location and network connections while computations are being processed. While in motion, mobile hosts retain their network connection through the support of specialized stationary hosts with wireless telecommunication ability, called mobility-support stations (Figure 1).
Reference: [17] <author> Kisler J. and M. Satyanarayanan. </author> <title> Disconnected operation in the Coda file system. </title> <journal> ACM Tran-sanctions on Computer Systems, </journal> <volume> 10(1), </volume> <year> 1992. </year>
Reference-contexts: For example, in an optimistic concurrency control based scheme, cached objects on mobile hosts can be updated without any coordination (an attractive feature for disconnected operation) but the updates need to be propagated and validated at the database server in order for the invoking transaction to be committed <ref> [17] </ref>. Unless conflicts between concurrent updates are rare, this scheme will lead to more abortions of mobile transactions (which are expected to be long-lived due to disconnections and long network delays) when compared to transactions executing on stationary hosts.
Reference: [18] <author> Krishnan P., N. Vaidya and D. Pradham. </author> <title> Recovery in Distributed Mobile Environments. </title> <booktitle> In Proc. of IEEE Workshop on Advances in Parallel and Distributed Systems, </booktitle> <pages> pp. 83-88, </pages> <year> 1993. </year>
Reference-contexts: As transactions are processed, their effects are logged on the mobile host where the transaction executes to facilitate recovery from failed or aborted transactions. Mobile host logs are checkpointed periodically on an appropriate mobility-support station <ref> [18, 3] </ref>. Merging of Fragments When a mobile host reconnects or the stack partition is no longer needed at the mobile host, any stack fragments remaining in the stack partition must be reconciled with master stack on the database server.
Reference: [19] <author> Krishnakumar N. and A. Bernstein. </author> <title> High Throughput Escrow Algorithms for Replicated Databases. </title> <booktitle> Proc. of the 18th Conf. on Very Large Databases, </booktitle> <pages> pp. 175-186, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: Here the semantics of the object organization can be helpful in fragmenting large objects into smaller components that can be cached independently while maintaining consistency. The escrow transactional method <ref> [22, 21, 29, 19] </ref> is a perfect application of this principle. The escrow transactional method is designed specifically to improve concurrent access to aggregate items by exploiting object structure, state-based commuta-tivity, and integrity constraints.
Reference: [20] <author> Krishnakumar N. and R. Jain. </author> <title> Protocols for maintaining inventory databases and user service profiles in mobile sales applications. </title> <booktitle> Proc. of the Mobidata Workshop, </booktitle> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Since all of the items are interchange-able, the quantity can be divided among a number of mobile hosts based on their data requirements <ref> [20, 31] </ref>. Data consistency is ensured by limiting the operations on the cached quantity to increments and decrements that commute provided that certain boundary conditions derived from integrity constraints (e.g., a negative physical inventory) are not violated.
Reference: [21] <author> Kumar A. and M. Stonebraker. </author> <title> Semantics-based Transaction Management Techniques for Replicated Data. </title> <booktitle> Proc. of the ACM SIGMOD Conf., </booktitle> <month> May </month> <year> 1988. </year>
Reference-contexts: Here the semantics of the object organization can be helpful in fragmenting large objects into smaller components that can be cached independently while maintaining consistency. The escrow transactional method <ref> [22, 21, 29, 19] </ref> is a perfect application of this principle. The escrow transactional method is designed specifically to improve concurrent access to aggregate items by exploiting object structure, state-based commuta-tivity, and integrity constraints.
Reference: [22] <author> O'Neil P. E. </author> <title> The Escrow Transactional Method. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 11(4) </volume> <pages> 405-430, </pages> <month> Dec. </month> <year> 1986. </year>
Reference-contexts: Here the semantics of the object organization can be helpful in fragmenting large objects into smaller components that can be cached independently while maintaining consistency. The escrow transactional method <ref> [22, 21, 29, 19] </ref> is a perfect application of this principle. The escrow transactional method is designed specifically to improve concurrent access to aggregate items by exploiting object structure, state-based commuta-tivity, and integrity constraints.
Reference: [23] <author> Pitoura E. and B. Bhargava. </author> <title> Building Information Systems for Mobile Environments. </title> <booktitle> Proc. of the 3rd Int'l Conf. on Information and Knowledge Management, </booktitle> <pages> pp. 371-378, </pages> <year> 1994. </year>
Reference-contexts: In order to support mobile transactions that can accommodate spatial inconsistencies, dynamic object clustering has been proposed based on objects' degree of inconsistency and two types of read and write operations: weak-read, weak-write, strict-read and strict-write <ref> [23, 24] </ref>. Strict-read and strict-write operations have the same semantics as the read and write operations invoked by traditional ACID transactions [9]. A weak-read returns the value of a locally cached object written by a strict-write or a weak-write.
Reference: [24] <author> Pitoura E. and B. Bhargava. </author> <title> Maintaining Consistency of Data in Mobile Distributed Environments. </title> <booktitle> Proc. of the 15th Int'l Conf. on Distributed Computing Systems, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: In order to support mobile transactions that can accommodate spatial inconsistencies, dynamic object clustering has been proposed based on objects' degree of inconsistency and two types of read and write operations: weak-read, weak-write, strict-read and strict-write <ref> [23, 24] </ref>. Strict-read and strict-write operations have the same semantics as the read and write operations invoked by traditional ACID transactions [9]. A weak-read returns the value of a locally cached object written by a strict-write or a weak-write.
Reference: [25] <author> Pu C. and A. Leff. </author> <title> Replica Control in Distributed Systems: An Asynchronous Approach. </title> <booktitle> Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pp. 377-386, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: For example, a degree may require consistency "at a specific real-time," "within some time" or "after a certain amount of change to some data," or enforcing consistency "after a certain value of the data is reached," etc. Divergence control protocols such as those for quasi-copies [1] and for epsilon-serializability <ref> [25] </ref> allow for the applications to specify their currency requirements and the inconsistency with which they can cope. These protocols can also facilitate the tuning of cache management on mobile hosts according to the available bandwidth and monetary cost of wireless communication [6].
Reference: [26] <author> Ramamritham K. and P. K. Chrysanthis. </author> <title> A Taxonomy of Correctness Criteria in Database Applications. (To appear) Journal of Very Large Databases, </title> <type> 4(1), </type> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: The most permissive concurrency control schemes are those which exploit the semantics of the objects and the operations defined on them, the structure of the database, the structural and behavioral properties of the activities in the database, and the correctness requirements of the applications <ref> [8, 26] </ref>. We refer to these techniques as semantics-based transaction processing techniques. <p> As opposed to serializability, these methods typically view data consistency and transaction correctness independently <ref> [26] </ref>. Data consistency captures correctness from the perspective of objects in the database. Data consistency requirements range from strict consistency (as defined by serializability) to eventual consistency [1, 28].
Reference: [27] <author> Schwarz P. M, and A. Z. Spector. </author> <title> Synchronizing Shared Abstract Data Types. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 223-250, </pages> <month> Aug. </month> <year> 1984. </year>
Reference-contexts: Queue fragments in which the original items have been completely consumed can be merged back in a fashion similar to stacks while maintaining strict consistency. However, the behavior of a fragmented queue more closely approximates that of "weak queues" as proposed by <ref> [27] </ref> if items of the original fragment are merged back into the master queue. 3.2 Formal Definitions Below we will formally define fragmentable objects and reorderable objects.
Reference: [28] <author> Sheth A. and M. Rusinkiewicz. </author> <title> Management of Interdependent Data: Specifying Dependency and Consistency Requirements. </title> <booktitle> Proc. of the Workshop on Management of Replicated Data, </booktitle> <pages> pp. 133-136, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: As opposed to serializability, these methods typically view data consistency and transaction correctness independently [26]. Data consistency captures correctness from the perspective of objects in the database. Data consistency requirements range from strict consistency (as defined by serializability) to eventual consistency <ref> [1, 28] </ref>. Eventual consistency denotes a temporal or spatial divergence from strict consistency the extend of which can be expressed in terms of degrees of inconsistency.
Reference: [29] <author> Soparkar N. and A. Silberschatz. </author> <title> Data-value Partitioning and Virtual Messages. </title> <booktitle> Proc. of the 9th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 357-367, </pages> <year> 1990. </year>
Reference-contexts: Here the semantics of the object organization can be helpful in fragmenting large objects into smaller components that can be cached independently while maintaining consistency. The escrow transactional method <ref> [22, 21, 29, 19] </ref> is a perfect application of this principle. The escrow transactional method is designed specifically to improve concurrent access to aggregate items by exploiting object structure, state-based commuta-tivity, and integrity constraints.
Reference: [30] <author> Tait D. C. and D. Duchamp. </author> <title> Service Interface and Replica Management Algorithm for Mobile File System Clients. </title> <booktitle> Proc. of the 1st Int'l Conf. on Parallel and Distributed Information Systems, </booktitle> <pages> pp. 190-197, </pages> <year> 1991. </year>
Reference-contexts: Application-specific criteria have been mainly proposed in database environments with characteristics similar to those of mobile database applications. As discussed above, ensuring serializability and maintaining strict consistency among data stored on both mobile and stationary hosts is very constraining as well as expensive <ref> [2, 15, 30] </ref>. For this reason, current approaches that aim to support transactions which perform updates on cached objects at the mobile hosts advocate application-specific criteria. For example, an open-nested transaction model has been proposed in [11] for modeling mobile transactions as a set of sub-transactions.
Reference: [31] <author> Walborn G. and P. K. Chrysanthis. </author> <title> "Using the Escrow Transactional Method to Manage Replicated Data in Disconnected Mobile Operations" CS Technical Report 94-32, </title> <institution> University of Pitts-burgh, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: Since all of the items are interchange-able, the quantity can be divided among a number of mobile hosts based on their data requirements <ref> [20, 31] </ref>. Data consistency is ensured by limiting the operations on the cached quantity to increments and decrements that commute provided that certain boundary conditions derived from integrity constraints (e.g., a negative physical inventory) are not violated.
Reference: [32] <author> Weihl W. and B. Liskov. </author> <title> Implementation of Resilient, Atomic Data Types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 244-269, </pages> <month> Apr. </month> <year> 1985. </year>
References-found: 32

