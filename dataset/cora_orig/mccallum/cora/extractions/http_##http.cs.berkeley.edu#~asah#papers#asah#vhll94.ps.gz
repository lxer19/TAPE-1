URL: http://http.cs.berkeley.edu/~asah/papers/asah/vhll94.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/asah/
Root-URL: 
Email: fasah, blojog@cs.Berkeley.EDU  
Title: A New Architecture for the Implementation of Scripting Languages  
Author: Adam Sah and Jon Blow 
Date: September 12, 1994  
Address: Berkeley, CA 94720  
Affiliation: Computer Science Division Electrical Engineering and Computer Sciences University of California  
Abstract: Nearly all scripting languages today are implemented as interpreters written in C. We propose an alternate architecture where the language is translated into the dynamic language Scheme [R4RS]. The plethora of high quality, public domain Scheme implementations give the developer a wide selection of interpreters, byte compilers, and machine code compilers to use as targets for her VHLL. Our VHLL, Rush, provides high-level features such as automatic type conversion and production rules [SHH86][Ston93]. Performance benchmarks show that our system runs with acceptable speed; in fact, Rush programs run much more quickly than their equivalents in languages such as Tcl and Perl4. Whereas those languages are coded in C, Rush takes advantage of Scheme's existing high-level features, saving development time. Since the features provided by Scheme are among those most VHLLs share, we expect this approach to be widely applicable. 
Abstract-found: 1
Intro-found: 1
Reference: [App92] <author> Andrew Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: A careful selection of the IR can make analysis and optimization easier; this is widely believed to be the case with three-address codes like Single Static Assignment [RZ88] [CFRWZ91] (for Pascal-like languages) and Continuation-Passing Style [Shiv88] <ref> [App92] </ref> for Lisp-like languages. As we discuss in sections 3 and 4, analysis can be very important when designing and implementing VHLLs; it is a fallacy to assume that perforance doesn't matter.
Reference: [ASU86] <author> Alfred Aho, Ravi Sethi, and Jeffrey Ullman. </author> <title> Compilers: Principles, Techniques and Tools. pp.422-423 introduce the issues in implementing dynamic scoping, although their text predates the acceptance of RISC architectures and the new importance on storing local variables in registers, as opposed to their maintenance in memory locations. </title>
Reference-contexts: Lexical scoping is generally fast (compared to dynamic scoping, which is used in languages like Tcl and some older versions of Lisp) <ref> [ASU86] </ref>. 2.5.2 First-class Procedures We described first-class procedures in a previous section introducing Scheme. In Rush first class functions are used to provide many important features.
Reference: [Bart89] <author> Joel Bartlett. Scheme!C: </author> <title> a portable Scheme-to-C compiler. </title> <type> DEC WRL Technical Report #89/1, </type> <month> Jan, </month> <year> 1989. </year>
Reference-contexts: For example, translating Scheme into C is frustrating because of the need to support call-with-current-continuation (call/cc) and tail-recursion elimination, both of which have unpleasant interactions with memory allocation and C's stack-based procedure frame model, as implemented in virtually every C compiler today <ref> [Bart89] </ref>. If the IR you select has already been implemented, you save the implementation time for the back end.
Reference: [BT93] <author> Bill Triggs. AVCALL 0.1 Documentation. ftp.robots.ox.ac.uk: </author> <month> /pub/gnu/avcall0.1.tar.gz </month>
Reference-contexts: An object-level facility has been written for C to make varargs easier; it's called AVCALL, but it isn't universally available <ref> [BT93] </ref>. Also, it is nearly impossible to use C's native varargs facility to provide varargs as a feature for a VHLL, so the programmer coding the interpreter in C must come up with her own facility. 2.5.6 Garbage Collection Every Scheme implementation contains a garbage collector.
Reference: [BW88] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage Collection in an Uncooperative Environment. </title> <journal> Software- Practice and Experience, </journal> <volume> Vol 18(9), </volume> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: The second problem is that this approach requires the C programmer to maintain strange invariants during callouts from the VHLL. The same problem arises when using a garbage collector, although the selection of a C-compatible garbage collector such as Boehm-Weiser <ref> [BW88] </ref> might eliminate this need. 2.5.7 Smarter Arithmetic Scheme makes a tradeoff of speed-for-features in its arithmetic library, but the features provided are very useful. First, Scheme provides integers of unbounded size (bignums), so arithmetic overflow simply does not happen. <p> It must run atomically; this can cause hiccups when used on a large heap. Boehm and Weiser suggest some ways around this, but the common solution of using an incremental collector is difficult to implement in this environment, since it requires significant cooperation from user code <ref> [BW88] </ref>. One can use virtual memory support instead, but this tends to be slow and less portable. 3.5 Lack of Sophisticated Optimizers Machine-generated code that is not optimized typically contains many redundancies, common subexpressions, dead code, unnecessary typechecks, and so on.
Reference: [CFRWZ91] <author> Ron Cytron, Jeanne Ferrante, Barry Rosen, Mark Wegman, and Kenneth Zadeck. </author> <title> Efficiently Computing Static Single Assignment Form and the Control Dependence Graph. </title> <journal> ACM Trans. on Prog. Lang. and Systems, </journal> <volume> 13:4, </volume> <month> October, </month> <year> 1991. </year>
Reference-contexts: A careful selection of the IR can make analysis and optimization easier; this is widely believed to be the case with three-address codes like Single Static Assignment [RZ88] <ref> [CFRWZ91] </ref> (for Pascal-like languages) and Continuation-Passing Style [Shiv88] [App92] for Lisp-like languages. As we discuss in sections 3 and 4, analysis can be very important when designing and implementing VHLLs; it is a fallacy to assume that perforance doesn't matter.
Reference: [DFH86] <author> R. Kent Dybvig, Daniel P. Friedman and Christopher T. Haynes. </author> <title> Expansion-Passing style: Beyond Conventional Macros. </title> <booktitle> ACM Conf. on Lisp and Functional Prog. </booktitle> <year> 1986. </year>
Reference-contexts: Cooperative multithreading becomes trivial with use of continuations; a context-switch is just a call/cc to the next thread on the run queue. 2.5.4 Powerful Macros One commonly available Scheme macro system is Expansion Passing Style (XPS) <ref> [DFH86] </ref>. XPS is Turing-complete; it is more expressively powerful than the C preprocessor or even the m4 macro expander. This power gives the user an increased choice of where to compile a language construct.
Reference: [Ous89] <author> John Ousterhout. </author> <title> The Sprite Engineering Manual. </title> <type> UC Berkeley Technical Report #89/512, </type> <year> 1989. </year>
Reference-contexts: In some sense, this comparison is inaccurate since in almost every case we're comparing apples to oranges: the features provided by these languages are fairly different from each other. Both Rush and Tcl conform rigorously to the Sprite coding conventions <ref> [Ous89] </ref>, which include a fair volume of comments. Of the other two columns, Perl v4 is a byte-compiling interpreter by Larry Wall and SCM is a public domain Scheme interpreter that we've ported Rush to.
Reference: [R4RS] <editor> William Clinger and Jonathan Rees, ed. </editor> <title> The Revised 4 Report on the Algorithmic Language Scheme. Lisp Pointers IV (July-Sept 1991). </title>
Reference-contexts: 1 Introduction We propose that VHLLs be implemented as source-to-source translators emitting a high-level language such as Scheme <ref> [R4RS] </ref> and which use publicly available implementations of the target language to execute the program. In other words, we advocate implementing VHLLs that use Scheme as their assembly language.
Reference: [RZ88] <author> Barry Rosen and Kenneth Zadeck. </author> <title> Global Value Numbers and Redundant Computations. </title> <booktitle> ACM Princ. of Prog. Languages, </booktitle> <month> January, </month> <year> 1988. </year>
Reference-contexts: A careful selection of the IR can make analysis and optimization easier; this is widely believed to be the case with three-address codes like Single Static Assignment <ref> [RZ88] </ref> [CFRWZ91] (for Pascal-like languages) and Continuation-Passing Style [Shiv88] [App92] for Lisp-like languages. As we discuss in sections 3 and 4, analysis can be very important when designing and implementing VHLLs; it is a fallacy to assume that perforance doesn't matter.
Reference: [Sah94] <author> Adam Sah. </author> <title> An Efficient Implementation of the Tcl Language. </title> <type> Master's Thesis, </type> <institution> Univ. of Cal. at Berkeley tech report #UCB-CSD-94-812. </institution> <month> May, </month> <year> 1994. </year>
Reference-contexts: In terms of Rush, we measured speed relative to C, deciding that Rush programs should run no more slowly than 10x-50x their C counterparts. In contrast, Tcl is a factor of 1000x-10000x away from C, and pathologic cases (such as array references) even have different computational complexities <ref> [Sah94] </ref>.
Reference: [SBD94] <author> Adam Sah, Jon Blow and Brian Dennis. </author> <title> An Introduction to the Rush Language. </title> <booktitle> Proc. </booktitle> <address> Tcl'94. </address> <month> June, </month> <year> 1994. </year>
Reference-contexts: For a more in-depth description of how these rules work and why they're useful, see <ref> [SBD94] </ref>. The most intuitive way to implement rules is to monitor the changes in relevant variables. For this we chose a boxing mechanism. Rush boxes are pairs of functions, a getter and a setter, which are called to retrieve values from and store values to a memory location. <p> Such assignments (eg. to update the next generation's board) incur high overhead because they interact unpleasantly with Scheme!C's garbage collector. These comparisons are highly Tcl-centric because we developed Rush as a descendant of Tcl. Additional benchmarks can be found in <ref> [SBD94] </ref>.
Reference: [SF89] <author> George Springer and Daniel P. Friedman. </author> <title> Scheme and the Art of Computer Programming MIT Press, </title> <address> Cambridge, MA 1989. </address>
Reference-contexts: We cannot provide here a full description of Scheme; for that we refer the reader to [SICP] and <ref> [SF89] </ref>. However, to give a taste of the way Scheme works, we present a short description of the behavior of Scheme's procedures in comparison to C's. Those familiar with Scheme may skip this section with impunity.
Reference: [SG90] <author> James W. Stamos and David K. Gifford. </author> <title> Remote Evaluation. </title> <journal> ACM Trans. on Prog. Lang. and Systems, </journal> <volume> Vol 12, No. 4, </volume> <month> October, </month> <year> 1990. </year>
Reference-contexts: incurs a tremendous performance penalty. (For Tcl 7.3 this is not a problem since all Tcl data is in string form; Tcl has already accepted the performance hit.) This string-passing method only works well for simple data structures; for example, creating a string representation of a closure is very hard <ref> [SG90] </ref>. In the current version of Rush, we have implemented a string-based callout mechanism, but it does not support closures. 3.2 'goto' Considered Useful Whereas 'goto' has often been considered harmful, programmers typically demand it in limited forms; the most popular are constructs like break, return, continue, and exception handlers.
Reference: [SHH86] <author> Michael Stonebraker, Eric Hanson, and Chin-Heng Hong. </author> <title> "The Design of the Postgres Rules System." </title> <institution> UC Berkeley tech report #UCB/ERL M86/80. </institution>
Reference: [Shiv88] <author> Olin Shivers. </author> <title> Control Flow Analysis in Scheme. </title> <journal> ACM Prg Lang Des. and Impl. </journal> <month> June, </month> <year> 1988. </year>
Reference-contexts: A careful selection of the IR can make analysis and optimization easier; this is widely believed to be the case with three-address codes like Single Static Assignment [RZ88] [CFRWZ91] (for Pascal-like languages) and Continuation-Passing Style <ref> [Shiv88] </ref> [App92] for Lisp-like languages. As we discuss in sections 3 and 4, analysis can be very important when designing and implementing VHLLs; it is a fallacy to assume that perforance doesn't matter. <p> To do otherwise can be a hassle since complex optimizations are notoriously difficult to implement and test. While the Scheme literature discusses many algorithms for optimizing Scheme code, and proofs have shown ways to apply many standard optimization algorithms to Scheme code <ref> [Shiv88] </ref>, such facilities are far from common in Scheme implementations. Indeed, many Scheme implementations perform no optimizations at all, implying that the Scheme code presented to the compiler is literally what is output from that compiler, translated into machine code.
Reference: [SICP] <author> Harold Abelson, Gerald Jay Sussman and Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs MIT Press, </title> <address> Cambridge, MA 1985. </address>
Reference-contexts: We cannot provide here a full description of Scheme; for that we refer the reader to <ref> [SICP] </ref> and [SF89]. However, to give a taste of the way Scheme works, we present a short description of the behavior of Scheme's procedures in comparison to C's. Those familiar with Scheme may skip this section with impunity.
Reference: [Ston93] <author> Michael Stonebraker. </author> <title> The Integration of Rule Systems and Databases. </title> <institution> UC Berkeley tech report #UCB/ERL M93/25. </institution> <year> 1993. </year>
Reference: [TT94] <author> Mads Tofte and Jean-Pierre Talpin. </author> <title> Implementation of the Typed Call-by-Value Lambda Calculus using a Stack of Regions. </title> <booktitle> Conf. Proc. of ACM Princ. of Prog. </booktitle> <address> Lang., Portland OR, </address> <year> 1994. </year>
Reference-contexts: The second is that can allocate memory from a garbage collected heap. Actually, current research suggests a third alternative where analysis is used to eliminate the need for garbage collection, but this analyzer will be even more complicated to write than a collector, and is still unproven in practice <ref> [TT94] </ref>. The first (and worst) approach is used by most VHLLs being written in C; these VHLLs are generally seeking some form of memory management, but do not try to implement completely automatic management, since that is more difficult.
Reference: [VP89] <author> Steven Vegdahl, Uwe Pleban. </author> <title> The Runtime Environment for Screme, a Scheme Implementation on the 88000. </title> <booktitle> 3rd Int'l Conf. ASPLOS. SIGPLAN Notices 24, </booktitle> <month> April </month> <year> 1989. </year>
Reference-contexts: SCM, Scheme!C, Bigloo, MIT-Scheme, schemelib, etc.). More importantly, these are not weekend hacks or student projects; they are well-documented, portable systems. This provides a wide selection of targets to choose from. 2.4.1 Scheme Speed Scheme can be implemented efficiently <ref> [VP89] </ref> and this is proven in practice by the above systems. By comparison, using other high-level languages (such as, say, Tcl) might be a bad idea since such languages' semantics guarantee that they will be untowardly difficult to optimize.
Reference: [Wil92] <author> Paul R. Wilson. </author> <title> Uniprocessor Garbage Collection Techniques. </title> <booktitle> Intl. Workshop on Memory Management. </booktitle> <address> St. Milo, FR. </address> <month> Sept, </month> <year> 1992. </year>
Reference: [WL73] <author> Donald Woods and James Lyon. </author> <title> The INTERCAL Programming Language Reference Manual. </title> <type> Technical report. </type> <institution> Stanford University, </institution> <year> 1973. </year>
Reference-contexts: As an example of this, it has become common practice to write compilers that emit C code which is then compiled into an executable, rather than emitting machine code directly. (The INTERCAL-C Compiler <ref> [WL73] </ref> is such a program.) At the very least this approach saves the language implementor from having to write register allocation algorithms, some of the most complex code in modern optimizing compilers. 2.2 An Introduction to Scheme Throughout this paper we will discuss the Scheme output code of our compiler system.
References-found: 22

