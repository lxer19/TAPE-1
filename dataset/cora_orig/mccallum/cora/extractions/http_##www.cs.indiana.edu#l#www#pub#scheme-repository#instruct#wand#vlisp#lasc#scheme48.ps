URL: http://www.cs.indiana.edu/l/www/pub/scheme-repository/instruct/wand/vlisp/lasc/scheme48.ps
Refering-URL: http://www.cs.indiana.edu/l/www/pub/scheme-repository/instruct/wand/vlisp/lasc/
Root-URL: http://www.cs.indiana.edu
Email: (kelsey@ccs.neu.edu)  (jar@cs.cornell.edu)  
Title: A Tractable Scheme Implementation  
Author: RICHARD A. KELSEY JONATHAN A. REES 
Affiliation: Northeastern University  MIT and Cornell University  
Note: LISP AND SYMBOLIC COMPUTATION: An International Journal, 1993 c 1993 Kluwer Academic Publishers Manufactured in The Netherlands  
Abstract: Scheme 48 is an implementation of the Scheme programming language constructed with tractability and reliability as its primary design goals. It has the structural properties of large, compiler-based Lisp implementations: it is written entirely in Scheme, is bootstrapped via its compiler, and provides numerous language extensions. It controls the complexity that ordinarily attends such large Lisp implementations through clear articulation of internal modularity and by the exclusion of features, optimizations, and generalizations that are of only marginal value. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <editor> IEEE Std 1178-1990. </editor> <title> IEEE Standard for the Scheme Programming Language. </title> <publisher> Institute of Electrical and Electronic Engineers, Inc., </publisher> <address> New York, NY (1991). </address>
Reference-contexts: in this context, by a small Lisp system we generally mean one that is less than about 15,000 lines of source code, is based on an interpreter or simple translator not written in Lisp, and provides few, if any, features beyond a small core language such as IEEE standard Scheme <ref> [1] </ref>. By a large Lisp system we mean one that is more than about 15,000 lines and implements a large language such as Common Lisp [10] or a substantially extended dialect of Scheme.
Reference: 2. <author> Clinger, William. </author> <title> The scheme 311 compiler: An exercise in denotational Draft of October 1, 1993 24 KELSEY AND REES semantics. </title> <booktitle> In Proc. 1984 ACM Symposium on Lisp and Functional Programming (August 1984) 356-364. </booktitle>
Reference-contexts: The module system bears some similarity to Common Lisp's package system [10], although it controls the mapping of names to denotations instead of the mapping of strings to symbols. 3. The Virtual Machine The Scheme 48 virtual machine is a stack based machine similar to that described in <ref> [2] </ref>. It is written in Pre-Scheme, a Scheme subset that is described in section 4. The implementation of the virtual machine is organized according to the internal interfaces listed in Table 2. The following sections describe the interfaces and their implementations. 3.1.
Reference: 3. <author> Clinger, William and Rees, Jonathan. </author> <title> Macros that work. </title> <booktitle> In Conf. Rec. 18 ACM Symposium on Principles of Programming Languages (1991). </booktitle>
Reference-contexts: For a variable bound to a primitive operator the compilation method is a procedure for generating code for the operator. If the variable is bound to a macro, the compilation method is a code transformation procedure. The macro facility is based on the system described in <ref> [3] </ref>. Many of the special forms in Scheme are implemented using macros. The compiler itself is quite simple. Each procedure is compiled into a separate template. The code for each checks the number of arguments, makes a new environment and then executes the body.
Reference: 4. <author> Curtis, Pavel and Rauen, James. </author> <title> A module system for scheme. </title> <booktitle> In Proc. 1990 ACM Symposium on Lisp and Functional Programming (1990) 13-19. </booktitle>
Reference-contexts: Scheme 48's module system is designed to support both static linking and rapid turnaround during program development. The design was influenced by Standard ML modules [8] and the module system for Scheme Xerox <ref> [4] </ref>. Each module has its own isolated namespace, with visibility of bindings controlled by module descriptions written in a module configuration language.
Reference: 5. <author> Kelsey, Richard. </author> <title> Tail-Recursive Stack Disciplines for an Interpreter. </title> <type> Technical Report NU-CCS-93-03, </type> <institution> Northeastern University College of Computer Science, </institution> <address> Boston, MA (1992). </address>
Reference-contexts: The storage allocation interface has been implemented both with and without stack allocation of environments and continuations. Using stack allocation is faster than using the heap, with some cost in increased complexity of the stack and environment modules. For more information see <ref> [5] </ref>. Another method of implementing proper tail recursion is to ensure that at every procedure call the arguments to the call are on the stack directly above the continuation for the call. For tail-recursive calls this requires moving the arguments just before jumping to the code for the called procedure. <p> However, the stack copying logic is still required for implementing call-with-current-continuation, so the argument copying instruction is not used. For more details see <ref> [5] </ref>. 3.4. Interpreter The section describes the more important virtual machine instructions. These instructions make use of the interpreter's registers, which are listed in Table 3.
Reference: 6. <author> Kelsey, Richard and Hudak, Paul. </author> <title> Realistic compilation by program transformation. </title> <booktitle> In Conf. Rec. 16 ACM Symposium on Principles of Programming Languages (1989) 281-292. </booktitle>
Reference-contexts: At one point a hand translation of the VM into C was done by Bob Brown, an MIT graduate student. Except for modification and debugging, the virtual machine is compiled from Pre-Scheme into C, using a compiler based on the transformational compiler described in <ref> [6] </ref>. The Pre-Scheme compiler evaluates top-level forms, performs static type checking and a great deal of partial evaluation, and translates the resulting program into C. The result is a C version of the VM which is as efficient and as portable as a hand-coded C version would be.
Reference: 7. <author> Lee, Peter. </author> <title> Topics in Advanced Language Implementation. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA (1991). </address>
Reference-contexts: The virtual machine makes use of this in a number of ways. There are number of alternatives to this particular data layout, some of which have been used in other implementations <ref> [7] </ref>. Headers can use either a fixnum or an immediate tag, freeing up one tag value. This tag can be used to denote a pointer to a commonly used stored object type, typically pairs, eliminating the need for headers on objects of that type.
Reference: 8. <author> MacQueen, David B. </author> <title> Modules for standard ML. </title> <booktitle> In Proc. 1984 ACM Symposium on Lisp and Functional Programming (1984) 198-207. </booktitle>
Reference-contexts: The virtual machine, compiler, and linker can be (and are) run using Scheme implementations other than Scheme 48. Scheme 48's module system is designed to support both static linking and rapid turnaround during program development. The design was influenced by Standard ML modules <ref> [8] </ref> and the module system for Scheme Xerox [4]. Each module has its own isolated namespace, with visibility of bindings controlled by module descriptions written in a module configuration language.
Reference: 9. <author> Rees, Jonathan and Donald, Bruce. </author> <title> Program mobile robots in scheme. </title> <booktitle> In Proceedings of the 1992 IEEE International Conference on Robotics and Automation (1992) 2681-2688. </booktitle>
Reference-contexts: Because of its virtual machine architecture, Scheme 48's memory usage patterns are similar to those of more complex systems, and is easier to modify and experiment with. Scheme 48 is currently being used to program mobile robots <ref> [9] </ref>. Multi-threaded user programs are executed by the virtual machine on an embedded processor on board the robot, while the byte-code compiler and development environment run on a work station using a Scheme implementation built on top of Common Lisp.
Reference: 10. <author> Steele, Guy L. </author> <title> Common Lisp: the Language. </title> <publisher> Digital Press, </publisher> <address> Burlington MA, </address> <note> second edition (1990). </note>
Reference-contexts: By a large Lisp system we mean one that is more than about 15,000 lines and implements a large language such as Common Lisp <ref> [10] </ref> or a substantially extended dialect of Scheme. Draft of October 1, 1993 2 KELSEY AND REES We arrived at the number 15,000 by examining the source code for a collection of Lisp implementations. <p> The design was influenced by Standard ML modules [8] and the module system for Scheme Xerox [4]. Each module has its own isolated namespace, with visibility of bindings controlled by module descriptions written in a module configuration language. The module system bears some similarity to Common Lisp's package system <ref> [10] </ref>, although it controls the mapping of names to denotations instead of the mapping of strings to symbols. 3. The Virtual Machine The Scheme 48 virtual machine is a stack based machine similar to that described in [2].
Reference: 11. <author> Tarditi, D., Acharya, A., and Lee., P. </author> <title> No Assembly Required: Compiling Standard ML to C. </title> <type> Technical Report, </type> <institution> School of Computer Science, Carnegie Mellon University (1991). </institution>
Reference-contexts: The compiler uses upper-case letters for the characters that are legal in identifiers in Scheme but not in C; for example *val* becomes SvalS. The compiler also introduces local variables to shadow global variables to improve register usage (similar to <ref> [11] </ref>). These introduced variables begin with R; thus RSvalS is a local variable shadowing the global variable SvalS.) This code is not what we would have written if we had used C in the first place, but it is at least as efficient.
Reference: 12. <author> Wilson, Paul R. and Moher, Thomas G. </author> <title> Design of the opportunistic garbage collector. </title> <booktitle> In Proceedings of the Sigplan 1989 Conference on Object-Oriented Programming: Systems, Languages, and Applications (1989). </booktitle>
Reference-contexts: Scheme 48 was chosen as the platform for these projects because of its internal tractability and flexibility. Paul Wilson has done extensive research on memory management techniques using an early version of Scheme 48 <ref> [12, 13] </ref>. Because of its virtual machine architecture, Scheme 48's memory usage patterns are similar to those of more complex systems, and is easier to modify and experiment with. Scheme 48 is currently being used to program mobile robots [9].
Reference: 13. <author> Wilson, Paul R., Lam, Micheal S, and Moher, Thomas G. </author> <title> Effective "static-graph" reorganization to improve locality in garbage collected systems. </title> <booktitle> In Proceedings of the Sigplan 1988 Conference on Programming Language Design and Implementation (1991). Draft of October 1, </booktitle> <year> 1993 </year>
Reference-contexts: Most objects are allocated from a heap. Heap storage is reclaimed using a simple two-space copying garbage collector. The design of the virtual machine puts few restrictions on the garbage collector and an early version of the VM has been used for extensive experiments in this area <ref> [13] </ref>. The contents of the heap may be written to and read from files. Heap image files contain a pointer to a distinguished entry procedure in that heap. <p> Scheme 48 was chosen as the platform for these projects because of its internal tractability and flexibility. Paul Wilson has done extensive research on memory management techniques using an early version of Scheme 48 <ref> [12, 13] </ref>. Because of its virtual machine architecture, Scheme 48's memory usage patterns are similar to those of more complex systems, and is easier to modify and experiment with. Scheme 48 is currently being used to program mobile robots [9].
References-found: 13

