URL: http://www.cs.cornell.edu/Info/People/crary/papers/regions.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/crary/papers/
Root-URL: http://www.cs.brown.edu/
Title: Typed Memory Management in a Calculus of Capabilities  
Author: Karl Crary David Walker Greg Morrisett 
Date: July 23, 1998  
Abstract: An increasing number of systems rely on programming language technology to ensure safety and security of low-level code. Unfortunately, these systems typically prevent manual management of memory, even by their resulting executable programs, and instead rely crucially on a complex but trusted garbage collector. Static memory management using regions provides a safe alternative to garbage collection by making memory allocation and deallocation explicit. However, it has not been clear how to use regions in low-level type-safe code. We present a compiler intermediate language, called the Capability Calculus, that supports static memory management, enjoys a provably safe type system, and is straightforward to compile to a typed assembly language. Source languages may be compiled to our language using known region inference algorithms. Unlike previous work, our language both does not require that region lifetimes be lexically scoped, and may be checked for safety without complex analyses. Furthermore, our safety proof is relatively simple, employing only standard techniques. The central novelty is the use of static capabilities to specify the permissibility of various operations, such as memory access and deallocation. In order to ensure capabilities are relinquished properly, the type system tracks aliasing information using a form of bounded quantification. These capability mechanisms may also be used in a variety of other applications in which some operations are not always permissible, such as mutually exclusive data access in concurrent systems.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken, M. Fahndrich, and R. Levien. </author> <title> Better static memory management: Improving region-based analysis of higher-order languages. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 174-185, </pages> <address> La Jolla, California, </address> <year> 1995. </year>
Reference-contexts: Memory for the region is allocated when control enters the scope of the letregion construct and is deallocated when control leaves the scope. This mechanism results in a strictly LIFO (last-in, first-out) ordering of region lifetimes. Both Birkedal et al. [4] and Aiken et al. <ref> [1] </ref> realized that a completely LIFO [de]allocation of regions would make poor use of memory in many cases. They proposed a series of optimizations that usually alleviate efficiency concerns and even improve upon traditional tracing garbage collection in some cases. <p> In contrast, Tofte and Talpin formulate the soundness of their system using a more complicated greatest fixed point argument [24], and the soundness of Aiken et al.'s optimizations <ref> [1] </ref> depend upon this argument. We have a formal translation of a variant of the Tofte-Talpin language into our calculus [5], which we describe here via example. <p> Just as our region scheme ensured we could not terminate without first collecting all our garbage, no thread will exit without first returning all its locks. 13 4 Directions for Future Research Aiken et al. <ref> [1] </ref> allow regions to be independently deallocated. Furthermore, their system separates the naming of a region from its allocation. Our language, as presented, does not make such a distinction, but it is straightforward to add one.
Reference: [2] <author> B. Bershad, S. Savage, P. Pardyak, E. Sirer, M. Fiuczynski, D. Becker, C. Chambers, and S. Eggers. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 267-284, </pages> <address> Copper Mountain, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: 1 Motivation and Background A current trend in systems software is to allow untrusted extensions to be installed in protected services, relying upon language technology to protect the integrity of the service instead of hardware-based protection mechanisms <ref> [13, 29, 2, 17, 16, 12, 11] </ref>. For example, the SPIN project [2] relies upon the Modula-3 type system to protect an operating system kernel from erroneous extensions. Similarly, web browsers rely upon the Java Virtual Machine byte-code verifier [13] to protect users from malicious applets. <p> 1 Motivation and Background A current trend in systems software is to allow untrusted extensions to be installed in protected services, relying upon language technology to protect the integrity of the service instead of hardware-based protection mechanisms [13, 29, 2, 17, 16, 12, 11]. For example, the SPIN project <ref> [2] </ref> relies upon the Modula-3 type system to protect an operating system kernel from erroneous extensions. Similarly, web browsers rely upon the Java Virtual Machine byte-code verifier [13] to protect users from malicious applets. <p> translation using the the following simple example: 10 letrgn 1 , x 1 in letrec count [ 2 :Rgn](f 1 ; 2 g, x 2 : 2 handle, x:hinti at 2 ) at x 1 = let n = 0 x in % (1) if0 n then x else count <ref> [ 2 ] </ref>(x 2 ; hn 1i at x 2 ) % (2) in end % letrec end % region scope and deallocate The count function above takes a boxed integer as its argument as well as the handle for its argument's region. <p> count [ 2 :Rgn; 3 :Rgn; *:Cap; * 0 * f 1 ; 3 g] (* 0 f 2 fl g; x 2 : 2 handle; x:hinti at 2 ; c:t cont ) at x 1 = % Note cap: * 0 f 2 fl g if0 n then c <ref> [ 2 ] </ref>(x) else let freergn x 2 in let n 0 = n 1 in let allocrgn 6 ; x 6 in let x 0 = hn 0 i at x 6 in count [ 6 ; 3 ; * 0 ](x 6 ; x 0 ; c) in where
Reference: [3] <author> L. Birkedal, N. Rothwell, M. Tofte, and D. N. Turner. </author> <title> The ML Kit (version 1). </title> <type> Technical Report 93/14, </type> <institution> Department of Computer Science, University of Copenhagen, </institution> <year> 1993. </year>
Reference-contexts: In later work, Tofte and others show how to infer automatically region types and insert allocation and deallocation points into ML source code [22] as well as implement their theory <ref> [3, 4] </ref>. There are several advantages to region-based memory management; from our point of view, the two most important are: 1. Deallocation is explicit but provably safe. 2. The runtime routines necessary for region-based memory management are relatively simple constant-time operations and, in principle, could be formally verified.
Reference: [4] <author> L. Birkedal, M. Tofte, and M. Vejlstrup. </author> <title> From region inference to von Neumann machines via region representation inference. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 171-183, </pages> <address> St. Petersburg, </address> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: In later work, Tofte and others show how to infer automatically region types and insert allocation and deallocation points into ML source code [22] as well as implement their theory <ref> [3, 4] </ref>. There are several advantages to region-based memory management; from our point of view, the two most important are: 1. Deallocation is explicit but provably safe. 2. The runtime routines necessary for region-based memory management are relatively simple constant-time operations and, in principle, could be formally verified. <p> Memory for the region is allocated when control enters the scope of the letregion construct and is deallocated when control leaves the scope. This mechanism results in a strictly LIFO (last-in, first-out) ordering of region lifetimes. Both Birkedal et al. <ref> [4] </ref> and Aiken et al. [1] realized that a completely LIFO [de]allocation of regions would make poor use of memory in many cases. They proposed a series of optimizations that usually alleviate efficiency concerns and even improve upon traditional tracing garbage collection in some cases. <p> With such a mechanism in place, we conjecture, based on the soundness proof for Aiken et al.'s analyses, that those analyses may be used to produce type correct code in the Capability Calculus. In practice, Birkedal et al. <ref> [4] </ref> found that allocation often occurs in two different contexts: one context in which no live object remains in the region and a second context in which there may be live objects remaining in the region.
Reference: [5] <author> K. Crary, D. Walker, and G. Morrisett. </author> <title> Typed memory management in a calculus of capabilities. </title> <type> Technical report, </type> <institution> Cornell University, </institution> <year> 1998. </year> <month> Forthcoming. </month>
Reference-contexts: In contrast, Tofte and Talpin formulate the soundness of their system using a more complicated greatest fixed point argument [24], and the soundness of Aiken et al.'s optimizations [1] depend upon this argument. We have a formal translation of a variant of the Tofte-Talpin language into our calculus <ref> [5] </ref>, which we describe here via example. We also illustrate how some region-based optimizations may be coded in our language, taking advantage of our extra freedom to place allocation and deallocation points. <p> As the typing constructs at the intermediate and assembly levels are so similar, we concentrate here on an intermediate language and refer the reader interested in the TAL details to the companion technical report <ref> [5] </ref>. Finally, we have found that the typing mechanisms in the language can serve in other settings where there is a need to revoke access to objects. <p> This property follows straightforwardly from the decidability of capability equality and subcapability judgements. 2.5 Expressiveness In order to begin to demonstrate the expressiveness of our type system, we have defined an embedding of an explicitly-typed variant of the original Tofte-Talpin system into our calculus <ref> [5] </ref>. By composing Tofte's region inference algorithm with this translation, we have a way to compile high-level languages into our Capability Calculus.
Reference: [6] <author> K. Crary, S. Weirich, and G. Morrisett. </author> <title> Intensional polymorphism in type-erasure semantics. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <address> Baltimore, </address> <month> Sept. </month> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: Second, after we dynamically check which of the two contexts above we are in, we must refine the type of our capability. Harper and Morrisett's typecase [10] mechanism developed for the TIL compiler and further refined by Crary, Weirich, and Morrisett <ref> [6] </ref> allows the sort of type refinement required here. We plan to explore extensions of the Capability Calculus which include these features.
Reference: [7] <author> O. Danvy and A. Filinski. </author> <title> Representing control: a study of the CPS transformation. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 361-391, </pages> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: In this setting, there is no need to distinguish between read and write effects and thus we let the union of the regions 1 and 2 be the total effect of the function. The translation into the Capability Calculus is a type-directed, type-preserving CPS transform <ref> [19, 7, 9] </ref> during which we transform effects into capabilities.
Reference: [8] <author> J.-Y. Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: One possibility is a linear type system <ref> [8, 27, 28] </ref>. In a linear type system, aliasing would be trivially controlled; any use of a region name would consume that name, ensuring that it could not be used elsewhere. Thus, in a linear type system, the naive rules for allocating and deallocating regions would be sound.
Reference: [9] <author> R. Harper and M. Lillibridge. </author> <title> Explicit polymorphism and CPS conversion. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 206-219, </pages> <address> Charleston, </address> <month> Jan. </month> <year> 1993. </year> <month> 14 </month>
Reference-contexts: In this setting, there is no need to distinguish between read and write effects and thus we let the union of the regions 1 and 2 be the total effect of the function. The translation into the Capability Calculus is a type-directed, type-preserving CPS transform <ref> [19, 7, 9] </ref> during which we transform effects into capabilities.
Reference: [10] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty--Second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: This optimization demands finer-grained aliasing specifications that declare a region does not alias some particular region 0 but may alias other regions. Second, after we dynamically check which of the two contexts above we are in, we must refine the type of our capability. Harper and Morrisett's typecase <ref> [10] </ref> mechanism developed for the TIL compiler and further refined by Crary, Weirich, and Morrisett [6] allows the sort of type refinement required here. We plan to explore extensions of the Capability Calculus which include these features.
Reference: [11] <author> C. Hawblitzel, C.-C. Chang, G. Czajkowski, D. Hu, and T. von Eicken. </author> <title> Implementing multiple protection domains in Java. </title> <booktitle> In 1998 USENIX Annual Technical Conference, </booktitle> <address> New Orleans, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: 1 Motivation and Background A current trend in systems software is to allow untrusted extensions to be installed in protected services, relying upon language technology to protect the integrity of the service instead of hardware-based protection mechanisms <ref> [13, 29, 2, 17, 16, 12, 11] </ref>. For example, the SPIN project [2] relies upon the Modula-3 type system to protect an operating system kernel from erroneous extensions. Similarly, web browsers rely upon the Java Virtual Machine byte-code verifier [13] to protect users from malicious applets.
Reference: [12] <author> D. Kozen. </author> <title> Efficient code certification. </title> <type> Technical Report 98-1661, </type> <institution> Cornell University, </institution> <month> Jan. </month> <year> 1998. </year>
Reference-contexts: 1 Motivation and Background A current trend in systems software is to allow untrusted extensions to be installed in protected services, relying upon language technology to protect the integrity of the service instead of hardware-based protection mechanisms <ref> [13, 29, 2, 17, 16, 12, 11] </ref>. For example, the SPIN project [2] relies upon the Modula-3 type system to protect an operating system kernel from erroneous extensions. Similarly, web browsers rely upon the Java Virtual Machine byte-code verifier [13] to protect users from malicious applets.
Reference: [13] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: 1 Motivation and Background A current trend in systems software is to allow untrusted extensions to be installed in protected services, relying upon language technology to protect the integrity of the service instead of hardware-based protection mechanisms <ref> [13, 29, 2, 17, 16, 12, 11] </ref>. For example, the SPIN project [2] relies upon the Modula-3 type system to protect an operating system kernel from erroneous extensions. Similarly, web browsers rely upon the Java Virtual Machine byte-code verifier [13] to protect users from malicious applets. <p> For example, the SPIN project [2] relies upon the Modula-3 type system to protect an operating system kernel from erroneous extensions. Similarly, web browsers rely upon the Java Virtual Machine byte-code verifier <ref> [13] </ref> to protect users from malicious applets. In both situations, the goal is to eliminate expensive communications or boundary crossings by allowing extensions to directly access the resources they require.
Reference: [14] <author> G. Morrisett, M. Felleisen, and R. Harper. </author> <title> Abstract models of memory management. </title> <booktitle> In ACM Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 66-77, </pages> <address> La Jolla, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: In the remainder of this section, we assume familiarity with CPS as we explain and motivate the calculus's constructs and typing rules. 2.1 Preliminaries We specify the operational behavior of the capability calculus using an allocation semantics <ref> [14, 15, 16] </ref>, which makes the allocation of data in memory explicit. The semantics is given by a deterministic rewriting system P 7! P 0 mapping machine states to new machine states. A machine state consists of a pair (M; e) of a memory and a term being executed.
Reference: [15] <author> G. Morrisett and R. Harper. </author> <title> Semantics of memory management for polymorphic languages. </title> <editor> In A. Gor-don and A. Pitts, editors, </editor> <title> Higher Order Operational Techniques in Semantics, </title> <publisher> Publications of the Newton Institute. Cambridge University Press, </publisher> <year> 1997. </year>
Reference-contexts: In the remainder of this section, we assume familiarity with CPS as we explain and motivate the calculus's constructs and typing rules. 2.1 Preliminaries We specify the operational behavior of the capability calculus using an allocation semantics <ref> [14, 15, 16] </ref>, which makes the allocation of data in memory explicit. The semantics is given by a deterministic rewriting system P 7! P 0 mapping machine states to new machine states. A machine state consists of a pair (M; e) of a memory and a term being executed.
Reference: [16] <author> G. Morrisett, D. Walker, K. Crary, and N. Glew. </author> <title> From System F to typed assembly language. </title> <booktitle> In Twenty-Fifth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <month> Jan. </month> <year> 1998. </year>
Reference-contexts: 1 Motivation and Background A current trend in systems software is to allow untrusted extensions to be installed in protected services, relying upon language technology to protect the integrity of the service instead of hardware-based protection mechanisms <ref> [13, 29, 2, 17, 16, 12, 11] </ref>. For example, the SPIN project [2] relies upon the Modula-3 type system to protect an operating system kernel from erroneous extensions. Similarly, web browsers rely upon the Java Virtual Machine byte-code verifier [13] to protect users from malicious applets. <p> In both situations, the goal is to eliminate expensive communications or boundary crossings by allowing extensions to directly access the resources they require. Recently, Necula and Lee [18, 17] have proposed Proof-Carrying Code (PCC) and Morrisett et al. <ref> [16] </ref> have suggested Typed Assembly Language (TAL) as language technologies that provide the security advantages of high-level languages, but without the overheads of interpretation or just-in-time compilation. <p> In the remainder of this section, we assume familiarity with CPS as we explain and motivate the calculus's constructs and typing rules. 2.1 Preliminaries We specify the operational behavior of the capability calculus using an allocation semantics <ref> [14, 15, 16] </ref>, which makes the allocation of data in memory explicit. The semantics is given by a deterministic rewriting system P 7! P 0 mapping machine states to new machine states. A machine state consists of a pair (M; e) of a memory and a term being executed. <p> The language that we describe here is relatively high-level as it includes abstract closures and high-level operations 12 such as the atomic allocation and initialization of data. Nevertheless, the essential typing constructs can be modified for use in a typed assembly language in the style of Morrisett et al. <ref> [16] </ref>.
Reference: [17] <author> G. Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Twenty-Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 106-119, </pages> <address> Paris, </address> <year> 1997. </year>
Reference-contexts: 1 Motivation and Background A current trend in systems software is to allow untrusted extensions to be installed in protected services, relying upon language technology to protect the integrity of the service instead of hardware-based protection mechanisms <ref> [13, 29, 2, 17, 16, 12, 11] </ref>. For example, the SPIN project [2] relies upon the Modula-3 type system to protect an operating system kernel from erroneous extensions. Similarly, web browsers rely upon the Java Virtual Machine byte-code verifier [13] to protect users from malicious applets. <p> Similarly, web browsers rely upon the Java Virtual Machine byte-code verifier [13] to protect users from malicious applets. In both situations, the goal is to eliminate expensive communications or boundary crossings by allowing extensions to directly access the resources they require. Recently, Necula and Lee <ref> [18, 17] </ref> have proposed Proof-Carrying Code (PCC) and Morrisett et al. [16] have suggested Typed Assembly Language (TAL) as language technologies that provide the security advantages of high-level languages, but without the overheads of interpretation or just-in-time compilation.
Reference: [18] <author> G. Necula and P. Lee. </author> <title> Safe kernel extensions without run-time checking. </title> <booktitle> In Proceedings of Operating System Design and Implementation, </booktitle> <pages> pages 229-243, </pages> <address> Seattle, </address> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: Similarly, web browsers rely upon the Java Virtual Machine byte-code verifier [13] to protect users from malicious applets. In both situations, the goal is to eliminate expensive communications or boundary crossings by allowing extensions to directly access the resources they require. Recently, Necula and Lee <ref> [18, 17] </ref> have proposed Proof-Carrying Code (PCC) and Morrisett et al. [16] have suggested Typed Assembly Language (TAL) as language technologies that provide the security advantages of high-level languages, but without the overheads of interpretation or just-in-time compilation.
Reference: [19] <author> G. D. Plotkin. </author> <title> Call-by-name, call-by-value, and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: In this setting, there is no need to distinguish between read and write effects and thus we let the union of the regions 1 and 2 be the total effect of the function. The translation into the Capability Calculus is a type-directed, type-preserving CPS transform <ref> [19, 7, 9] </ref> during which we transform effects into capabilities.
Reference: [20] <author> J. C. Reynolds. </author> <title> Syntactic control of interference. </title> <booktitle> In Fifth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 39-46, </pages> <address> Tucson, Arizona, </address> <year> 1978. </year>
Reference-contexts: More generally, one could not type any function that takes two arguments that might or might not be allocated in the same region. Approaches based on syntactic control of interference <ref> [20, 21] </ref> are more permissive than a linear type system, but are still too restrictive for our purposes; it is still impossible to instantiate multiple arguments with the same region. Uniqueness Our approach, instead of trying to prevent aliasing, is to use the type system to track aliasing.
Reference: [21] <author> J. C. Reynolds. </author> <title> Syntactic control of interference, </title> <booktitle> part 2. In Sixteenth International Colloquium on Automata, Languages, and Programming, </booktitle> <month> July </month> <year> 1989. </year>
Reference-contexts: More generally, one could not type any function that takes two arguments that might or might not be allocated in the same region. Approaches based on syntactic control of interference <ref> [20, 21] </ref> are more permissive than a linear type system, but are still too restrictive for our purposes; it is still impossible to instantiate multiple arguments with the same region. Uniqueness Our approach, instead of trying to prevent aliasing, is to use the type system to track aliasing.
Reference: [22] <author> M. Tofte and L. Birkedal. </author> <title> A region inference algorithm. </title> <journal> Transactions on Programming Languages and Systems, </journal> <month> Nov. </month> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: In later work, Tofte and others show how to infer automatically region types and insert allocation and deallocation points into ML source code <ref> [22] </ref> as well as implement their theory [3, 4]. There are several advantages to region-based memory management; from our point of view, the two most important are: 1. Deallocation is explicit but provably safe. 2.
Reference: [23] <author> M. Tofte and J.-P. Talpin. </author> <title> Implementation of the typed call-by-value -calculus using a stack of regions. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 188-201, </pages> <address> Portland, Oregon, </address> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: The goal of this work is to provide a high degree of control over memory management for programmers and compilers, but as in the PCC and TAL frameworks, make verification of the safety of programs a straightforward task. 1.1 Regions Tofte and Talpin <ref> [23, 24] </ref> suggest a type and effects system for verifying the soundness of region-based memory management. In later work, Tofte and others show how to infer automatically region types and insert allocation and deallocation points into ML source code [22] as well as implement their theory [3, 4].
Reference: [24] <author> M. Tofte and J.-P. Talpin. </author> <title> Region-based memory management. </title> <journal> Information and Computation, </journal> <volume> 132(2) </volume> <pages> 109-176, </pages> <year> 1997. </year>
Reference-contexts: The goal of this work is to provide a high degree of control over memory management for programmers and compilers, but as in the PCC and TAL frameworks, make verification of the safety of programs a straightforward task. 1.1 Regions Tofte and Talpin <ref> [23, 24] </ref> suggest a type and effects system for verifying the soundness of region-based memory management. In later work, Tofte and others show how to infer automatically region types and insert allocation and deallocation points into ML source code [22] as well as implement their theory [3, 4]. <p> We have a purely syntactic argument, based on Subject Reduction and Progress lemmas in the style of Felleisen and Wright, that the type system of the Capability Calculus is sound. In contrast, Tofte and Talpin formulate the soundness of their system using a more complicated greatest fixed point argument <ref> [24] </ref>, and the soundness of Aiken et al.'s optimizations [1] depend upon this argument. We have a formal translation of a variant of the Tofte-Talpin language into our calculus [5], which we describe here via example.
Reference: [25] <author> A. Tolmach. </author> <title> Debugging Standard ML. </title> <type> PhD thesis, </type> <institution> Princeton University, 1992. Published as Princeton University Dept. of Computer Science Techical Report CS-TR-378-92. </institution>
Reference-contexts: Programmers must ensure that threads acquire and release locks appropriately lest they violate the mutual exclusion principle which the lock attempts to enforce. In their work on debugging Standard ML, Tolmach and Appel <ref> [26, 25] </ref> implemented an ML threads library which associates every shared reference with a lock and dynamically checks for possession of the lock at every reference access. With a few minor changes to the Capability Calculus, we can statically check that programmers obey a similar locking discipline.
Reference: [26] <author> A. Tolmach and A. Appel. </author> <title> Debuggable concurrency extensions for Standard ML. </title> <booktitle> In Proceedings of ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 120-131, </pages> <month> May </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(12), </note> <month> December </month> <year> 1991. </year>
Reference-contexts: Programmers must ensure that threads acquire and release locks appropriately lest they violate the mutual exclusion principle which the lock attempts to enforce. In their work on debugging Standard ML, Tolmach and Appel <ref> [26, 25] </ref> implemented an ML threads library which associates every shared reference with a lock and dynamically checks for possession of the lock at every reference access. With a few minor changes to the Capability Calculus, we can statically check that programmers obey a similar locking discipline.
Reference: [27] <author> P. Wadler. </author> <title> Linear types can change the world! In M. </title> <editor> Broy and C. Jones, editors, </editor> <booktitle> Programming Concepts and Methods, Sea of Galilee, </booktitle> <address> Israel, </address> <month> Apr. </month> <year> 1990. </year> <title> North Holland. </title> <booktitle> IFIP TC 2 Working Conference. </booktitle>
Reference-contexts: One possibility is a linear type system <ref> [8, 27, 28] </ref>. In a linear type system, aliasing would be trivially controlled; any use of a region name would consume that name, ensuring that it could not be used elsewhere. Thus, in a linear type system, the naive rules for allocating and deallocating regions would be sound.
Reference: [28] <author> P. Wadler. </author> <title> A taste of linear logic. </title> <booktitle> In Mathematical Foundations of Computer Science, volume 711 of LNCS, </booktitle> <address> Gdansk, Poland, Aug. 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: One possibility is a linear type system <ref> [8, 27, 28] </ref>. In a linear type system, aliasing would be trivially controlled; any use of a region name would consume that name, ensuring that it could not be used elsewhere. Thus, in a linear type system, the naive rules for allocating and deallocating regions would be sound.
Reference: [29] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <address> Asheville, </address> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: 1 Motivation and Background A current trend in systems software is to allow untrusted extensions to be installed in protected services, relying upon language technology to protect the integrity of the service instead of hardware-based protection mechanisms <ref> [13, 29, 2, 17, 16, 12, 11] </ref>. For example, the SPIN project [2] relies upon the Modula-3 type system to protect an operating system kernel from erroneous extensions. Similarly, web browsers rely upon the Java Virtual Machine byte-code verifier [13] to protect users from malicious applets.
Reference: [30] <author> W. A. Wulf, R. Levin, and S. P. Harbison. Hydra/C.mmp: </author> <title> An Experimental Computer System. </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1981. </year> <month> 15 </month>
Reference-contexts: Operating systems such as Hydra <ref> [30] </ref> have solved the access control problem before by associating an un-forgeable key or capability with every object and requiring that the user present this capability to gain access to the object.
References-found: 30

