URL: http://www.isse.gmu.edu:80/~csis/publications/esorics96.ps
Refering-URL: http://www.isse.gmu.edu:80/~csis/publication.html
Root-URL: 
Email: mancini@disi.unige.it  iray@isse.gmu.edu  
Phone: 2  
Title: Secure Concurrency Control in MLS Databases with Two Versions of Data  
Author: Luigi V. Mancini and Indrajit Ray 
Address: Genova, Genova, Italy  Fairfax, VA 22030  
Affiliation: 1 Dipartimento di Informatica e Scienze dell'Informazione Universita di  Center for Secure Information Systems and Department of Information and Software Systems Engineering George Mason University,  
Abstract: In multilevel secure database systems, higher level transactions are either delayed or aborted when they read lower level data, due to lock conflicts with updating lower level transactions. Multiversion data has been suggested in the literature as a way to prevent lower reading transaction from getting delayed or aborted. In these multiversion protocols transactions that read lower level data are provided older versions of the data and thus low reading and writing operations are allowed to proceed concurrently. However almost all of these algorithms suffer from shortcomings either they require a potentially unbounded number of versions to be maintained in the system, or they enforce a time limit in which higher level transactions have to complete. Maintaining multiple committed versions adds additional overhead to the system. Moreover, these algorithms always provide older copies of data for reading by higher level transactions which may not be acceptable for certain applications. We propose a secure concurrency control algorithm that is based on a locking strategy and that requires only two versions one committed and one non-committed version of data. All read operations, high or low, are performed on the previous committed version while the write operation proceeds on the uncommitted version. Thus no read operation is ever given an outdated copy. Moreover, extra overhead for version management is lesser than the other protocols because almost all transaction management systems maintains a before-image of data for recovery pur poses and our scheme takes advantage of this before-image value. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> P. Ammann, F. Jaeckle, and S. Jajodia. </author> <title> Concurrency Control in Secure MultiLevel Databases Via a Two-Snapshot Algorithm. </title> <journal> Journal of Computer Security, </journal> <volume> 3(3) </volume> <pages> 87-113, </pages> <year> 1995. </year>
Reference-contexts: Moreover maintaining multiple versions of data and accessing them involves additional costs, more so because this method may require a potentially unbounded number of versions. A second work by Ammann, Jaeckle and Jajodia <ref> [1] </ref> proposes a concurrency control protocol using two snapshots of the database in addition to the most recently committed version - i.e. three copies of the database. This protocol represents a significant improvement over [11] as it requires a fixed number of versions. <p> Thus using these two versions of data for concurrency control does not entail any additional cost to data management and hence seems to be useful. Version management is thus cheaper than that in [11] or <ref> [1] </ref>. Moreover unlike [1] or [14] we do not impose any deadline within which transactions must complete if they read data at dominated levels. <p> Thus using these two versions of data for concurrency control does not entail any additional cost to data management and hence seems to be useful. Version management is thus cheaper than that in [11] or <ref> [1] </ref>. Moreover unlike [1] or [14] we do not impose any deadline within which transactions must complete if they read data at dominated levels.
Reference: 2. <author> P. Ammann and S. Jajodia. </author> <title> A Timestamp Ordering Algorithm for Secure, Single--Version Multilevel Databases. </title> <editor> In C. E. Landwehr, editor, </editor> <title> Database Security, V: </title> <booktitle> Status and Prospects, </booktitle> <pages> pages 191-202. </pages> <publisher> Elsevier Science Publishers B. V. (North-Holland), </publisher> <year> 1992. </year>
Reference-contexts: The drawback of these protocols is that transactions that read down may be subject to starvation. Other works have been proposed that employ time stamp ordering for concurrency control. Amman and Jajodia <ref> [2] </ref> give two time stamp based algorithms on single version data that yield serializable schedules; however both of them suffer from indefinite delays of higher level transactions. Some secure versions of commercial database management systems have provided secure concurrency control algorithms; however the algorithms are not always completely satisfactory.
Reference: 3. <author> D.E. Bell and L.J. LaPadula. </author> <title> Secure computer systems: Unified exposition and multics interpretation,. </title> <type> Technical Report MTR-2997, </type> <institution> The Mitre Corp., </institution> <address> Burlington Road, Bedford, MA 01730, USA, </address> <month> March </month> <year> 1976. </year>
Reference-contexts: In these systems, the data and user processes are classified into different (possibly hierarchical) security levels. Access to a data item by a process is allowed only if the access satisfies the following two mandatory access control rules (cf. <ref> [3] </ref>): 1. a process P can read data item x only if security level of x is lower than or equal to that of P and 2. P can write into x only if x is at the same security level as x. <p> That is, the transaction must be at the same security level as the data item x, if it has to write to x. Note that the second constraint is the restricted version of the ?-property which allows transactions to write to higher levels <ref> [3, 6] </ref>; the constrained version is desirable for integrity reasons. 3 Overview of the Locking Protocol We use two versions of the data for transaction processing. Initially all data items in the system has only one version.
Reference: 4. <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: In the following we prove that a multilevel two-version data history consisting of well-formed transactions is serializable. To do this we follow the approach of <ref> [4] </ref> i.e., show that the serialization graph for the two-version data history is acyclic. The interleaving of a set of transactions when they execute concurrently is modeled by a history [4]. A history consisting of transactions at different security levels is called a multilevel history. <p> To do this we follow the approach of <ref> [4] </ref> i.e., show that the serialization graph for the two-version data history is acyclic. The interleaving of a set of transactions when they execute concurrently is modeled by a history [4]. A history consisting of transactions at different security levels is called a multilevel history. In the following discussions we will be using the term history to refer to a multilevel history. <p> With the above definitions of a version order and 2V serialization graph, it can be readily shown as in <ref> [4] </ref> that Theorem 10. If R (H ), the rollback free projection of a 2V history, H over a set of transaction T , has an acyclic 2V serialization graph 2VSG (R (H)), then R (H ) is one-copy serializable and so is H.
Reference: 5. <author> E. Bertino, S. Jajodia, L. V. Mancini, and I. Ray. </author> <title> Advanced Transaction Processing in Multilevel Secure File Stores. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <note> 1996. To appear. </note>
Reference-contexts: P can write into x only if x is at the same security level as x. These restrictions together with the need to avoid covert timing channels prevent the lock based concurrency control protocols of classical transaction processing from being used without modification in the MLS environment <ref> [5, 15] </ref>. A number of secure concurrency control techniques have been proposed in the literature which address the problem of covert timing channels. <p> Our locking protocol uses two additional lock modes besides the conventional read and write locks on data items. The current protocol is based on the ideas presented in one of our earlier works <ref> [5] </ref>. We propose new language primitives which can be used by the sophisticated programmer to support advanced programming paradigms like exception handling, forward recovery and partial rollback within a transaction. Our locking protocol together with these primitives provide secure yet flexible transaction processing in a multilevel secure database system. <p> To prevent the lock conversion from waiting on high transactions, we adopt the notion of signals proposed in <ref> [5] </ref>.
Reference: 6. <author> D. E. Denning. </author> <title> Cryptography and Data Security. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1982. </year>
Reference-contexts: That is, the transaction must be at the same security level as the data item x, if it has to write to x. Note that the second constraint is the restricted version of the ?-property which allows transactions to write to higher levels <ref> [3, 6] </ref>; the constrained version is desirable for integrity reasons. 3 Overview of the Locking Protocol We use two versions of the data for transaction processing. Initially all data items in the system has only one version.
Reference: 7. <author> A.R. Downing, I.B. Greenberg, and T.F. Lunt. </author> <title> Issues in Distributed Database Security. </title> <booktitle> In Proceedings of the Fifth Annual Computer Security Applications Conference, </booktitle> <pages> pages 196-203, </pages> <address> Tucson, AZ., </address> <month> December </month> <year> 1989. </year>
Reference-contexts: A number of secure concurrency control techniques have been proposed in the literature which address the problem of covert timing channels. Some of these works <ref> [12, 7] </ref> that employ a lock based protocol on single version data, abort a higher level transaction T i that is reading down, when a lower level updating transaction T j conflicts with T i .
Reference: 8. <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Tecniques. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Francisco, CA, </address> <year> 1993. </year>
Reference-contexts: They are: sl = SaveWork (); Rollback (sl); Certify; GetSignal [sl 1 ! handler 1 ] ... [sl n ! handler n ]; Among these newly introduced primitives, the first two or their equivalent are available in quite a few sophisticated transactional systems <ref> [8] </ref>; however their semantics are not exactly the same. All of these primitives can be invoked by the programmer from within a transaction. In addition the programmer has access to the system variable, rollbackCount, that is associated with each instance of a transaction in execution. <p> The Abort primitive on the other hand aborts the transaction T i and TM discards all of T i changes to the database. The Read and Write primitives perform the main database item access operation. The SaveWork () system primitive establishes a savepoint <ref> [8] </ref> which causes the system to record the current state of processing. Each transaction manager writes a savepoint record on the transaction log, while the run-time support of the programming language saves the current values of any local variables on the volatile memory.
Reference: 9. <institution> Informix Software, Inc., </institution> <address> Menlo Park, CA. </address> <note> Informix-Online/Secure Administrator's Guide, </note> <month> April </month> <year> 1993. </year>
Reference-contexts: For example the algorithm of the Trusted Oracle DBMS [13], based on a combination of two phase locking, timestamp ordering and multiversioning, generate histories that are not always one-copy serializable. As an additional example, Informix-OnLine/Secure DBMS <ref> [9, 10] </ref> uses an approach in which a low level transaction is granted a write lock on a data item even if a higher level transaction holds a read lock on the same data item.
Reference: 10. <institution> Informix Software, Inc., </institution> <address> Menlo Park, CA. </address> <note> Informix-Online/Secure Security Features User's Guide, </note> <month> April </month> <year> 1993. </year>
Reference-contexts: For example the algorithm of the Trusted Oracle DBMS [13], based on a combination of two phase locking, timestamp ordering and multiversioning, generate histories that are not always one-copy serializable. As an additional example, Informix-OnLine/Secure DBMS <ref> [9, 10] </ref> uses an approach in which a low level transaction is granted a write lock on a data item even if a higher level transaction holds a read lock on the same data item.
Reference: 11. <author> T. F. Keefe and W. T. Tsai. </author> <title> Multiversion Concurrency Control for Multilevel Secure Database Systems. </title> <booktitle> In Proceedings of the IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 369-383, </pages> <address> Oakland, California, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: Researchers have also looked into using multiple versions of data for secure concurrency control. In all these works, higher level transactions are given older versions of the data for reading down. Keefe and Tsai <ref> [11] </ref> propose a scheduler based on multiple versions of data and a priority queue of transactions according to their access classes. This approach is secure and starvation free. <p> A second work by Ammann, Jaeckle and Jajodia [1] proposes a concurrency control protocol using two snapshots of the database in addition to the most recently committed version - i.e. three copies of the database. This protocol represents a significant improvement over <ref> [11] </ref> as it requires a fixed number of versions. The protocol can be naturally implemented using timestamp ordering, although other scheduling algorithms can be used to control the transactions executing at a given security level. <p> Thus using these two versions of data for concurrency control does not entail any additional cost to data management and hence seems to be useful. Version management is thus cheaper than that in <ref> [11] </ref> or [1]. Moreover unlike [1] or [14] we do not impose any deadline within which transactions must complete if they read data at dominated levels.
Reference: 12. <author> J. McDermott and S. Jajodia. </author> <title> Orange Locking: Channel-Free Database Concur-rency Control Via Locking. </title> <editor> In B.M. Thuraisingham and C.E. Landwehr, editors, </editor> <booktitle> Database Security, VI: Status and Prospects, </booktitle> <pages> pages 267-284. </pages> <publisher> Elsevier Science Publishers B.V. (North Holland), </publisher> <address> Amsterdam, </address> <year> 1993. </year>
Reference-contexts: A number of secure concurrency control techniques have been proposed in the literature which address the problem of covert timing channels. Some of these works <ref> [12, 7] </ref> that employ a lock based protocol on single version data, abort a higher level transaction T i that is reading down, when a lower level updating transaction T j conflicts with T i .
Reference: 13. <institution> Oracle Corp., </institution> <address> Redwood City, CA. </address> <note> Trusted Oracle Administrator's Guide, </note> <year> 1992. </year>
Reference-contexts: Some secure versions of commercial database management systems have provided secure concurrency control algorithms; however the algorithms are not always completely satisfactory. For example the algorithm of the Trusted Oracle DBMS <ref> [13] </ref>, based on a combination of two phase locking, timestamp ordering and multiversioning, generate histories that are not always one-copy serializable.
Reference: 14. <author> S. Pal. </author> <title> A Locking Protocol for Multilevel Secure Databases using Two Committed Versions. </title> <booktitle> In Proceedings of the 10th. Annual Conference on Computer Assurance, COMPASS 95, </booktitle> <pages> pages 197-210, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: However, the algorithm ensures serializabil-ity only by enforcing a fixed time limit on each transaction during which the transaction must complete or get aborted. A more recent work <ref> [14] </ref> has proposed a locking protocol using two committed versions of data which produces one-copy serializable and strict schedules. In this protocol, higher level transactions read down on an earlier committed version of the data while transactions accessing data at their own level execute on the later committed version. <p> Moreover, higher level transactions are always given older versions of the data to read, and this may not be acceptable always. In this work we propose a lock based secure concurrency control protocol on two versions of data. Unlike <ref> [14] </ref> we use one committed version of the data and one uncommitted version. Whenever a transaction T i writes a data item x, it creates a new version of the data. <p> Thus using these two versions of data for concurrency control does not entail any additional cost to data management and hence seems to be useful. Version management is thus cheaper than that in [11] or [1]. Moreover unlike [1] or <ref> [14] </ref> we do not impose any deadline within which transactions must complete if they read data at dominated levels.
Reference: 15. <author> I. Ray, E. Bertino, S. Jajodia, and L. V. Mancini. </author> <title> An Advanced Commit Protocol for MLS Distributed Database Systems. </title> <booktitle> In Proceedings of 3rd ACM Conference on Computer and Communications Security, </booktitle> <address> New Delhi, India, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: P can write into x only if x is at the same security level as x. These restrictions together with the need to avoid covert timing channels prevent the lock based concurrency control protocols of classical transaction processing from being used without modification in the MLS environment <ref> [5, 15] </ref>. A number of secure concurrency control techniques have been proposed in the literature which address the problem of covert timing channels.
Reference: 16. <author> A.Z. Spector. </author> <title> Distributed Transaction Processing Facilities. </title> <editor> In Sape Mullender, editor, </editor> <booktitle> Distributed Systems, </booktitle> <pages> pages 191-214. </pages> <publisher> ACM Press Frontier Series, Addison-Wesley Publishing Company, </publisher> <year> 1989. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: 1 Introduction Transactions are an important programming paradigm for simplifying the development of applications that require concurrent access to shared mutable data. A transaction can be informally defined to be a collection of operations (a program) bracketed by two markers: Begin Transaction and End transaction <ref> [16] </ref>. Transactions provide the ACID properties in a program, which allow the programmer to pay lesser attention to concurrency and failure issues during program development. While transaction management techniques and algorithms are fairly well un-derstood for traditional database systems, they are much less well understood for multilevel secure (MLS) systems.
References-found: 16

