URL: ftp://ftp.research.microsoft.com/users/lomet/pub/growpost.ps
Refering-URL: http://www.research.microsoft.com/users/lomet/pub/default.htm
Root-URL: http://www.research.microsoft.com
Title: Grow and Post Index Trees: Role, Techniques and Future Potential  
Author: David B. Lomet 
Address: One Kendall Sq., Cambridge, MA  
Affiliation: Digital Equipment Corp. Cambridge Research Lab  
Abstract: Grow and post (GP) access methods, e.g., B+trees, are the dominant form of index tree access method because of properties not strictly related to search performance. GP methods fit well with the rest of a database system, and indeed profit from their inclusion, e.g, search performance is improved by caching index nodes. Enhancements to GP methods have increased their utility. GP methods solve the multi-attribute point search problem and, more speculatively, the spatial search problem. Their simplicity and flexibility make GP methods applicable in several interesting new areas. This paper examines these topics from the author's personal perspective. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Baez-Yates, R. and Larson, P. </author> <title> Performance of B+trees with partial expansions. </title> <journal> IEEE Trans. on Knowledge and Data Engineering 1,2 (June 1989) 248-257. </journal>
Reference-contexts: No shu*ing of data between nodes is necessary. The results are quite good, and cheaply achieved. An expansion sequence of small node, larger node, two small nodes, etc. achieves a utilization of 83% <ref> [27, 1] </ref>. Further, in [1], it is shown that little utilization is lost by the need to cope with more than one node size. <p> No shu*ing of data between nodes is necessary. The results are quite good, and cheaply achieved. An expansion sequence of small node, larger node, two small nodes, etc. achieves a utilization of 83% [27, 1]. Further, in <ref> [1] </ref>, it is shown that little utilization is lost by the need to cope with more than one node size.
Reference: [2] <author> Bayer, R. and McCreight, E. </author> <title> Organization and maintenance of large ordered indices. </title> <journal> Acta Inf. </journal> <volume> 1,3(1972), </volume> <pages> 173-189. </pages>
Reference-contexts: B-trees <ref> [2, 18] </ref> represent both the genesis and the archetype for the class of GP methods. Despite the fact that they were invented twenty years ago, B-trees, usually enhanced in some way, remain the indexing method of choice.
Reference: [3] <author> Bayer, R. and Unterauer, K. </author> <title> Prefix B-trees. </title> <journal> ACM Trans. on Database Systems 2,1 (Mar. </journal> <year> 1977), </year> <pages> 11-26. </pages>
Reference-contexts: There are many potential key compression techniques, but only a few that permit an index node to be searched with high performance. One key compression technique that permits binary search is the head and tail compression described in prefix B-trees <ref> [3] </ref>. * A common prefix is removed from all keys in a node. When this common prefix is also removed from the search argument, the choice of search technique used within an index node is unaffected. <p> A clumsy variable length entry binary search technique was described in <ref> [3] </ref> but there are better ones. These require a little extra space because they represent the data with a vector of indirections so as to have fixed size entries for the variable length separators.
Reference: [4] <author> Bentley, J. </author> <title> Multidimensional binary search trees for associative searching. </title> <journal> Comm. ACM 18,9(Sept. </journal> <year> 1975) </year> <month> 509-517. </month>
Reference-contexts: The BANG file splits a node by successively partitioning the attribute SPACE until the data entries are divided. Both will eventually split a data node into two nodes with data items in a ratio of no worse than 2:1. One can characterize the hB-tree as k-d tree <ref> [4] </ref> based and the BANG file as k-d trie based. The index terms used in both represent paths in these trees (tries). I do not know how the BANG file solves the problem of splitting index nodes, since the index terms are not explicitly represented as trie paths.
Reference: [5] <author> Bentley, J. </author> <title> Writing efficient programs. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ (1982) </address>
Reference-contexts: Assume that there are 256 index entries per node, which is typical when nodes are 4K bytes. Assume that the cost per probe is 10 cycles for linear search and 20 cycles for binary search. (I know binary search techniques where these costs are equal <ref> [5] </ref>. For both, Cost = probes fi probecost.
Reference: [6] <author> Carter, J. and Wegman, M. </author> <title> Universal classes of hash functions. </title> <journal> J. </journal> <note> Computer and System Sciences 18,2 (April 1979) 143-154. </note>
Reference-contexts: Hashing has the best performance of all for exact match random probes. Robust classes of hash functions <ref> [6] </ref> ensure that, with very high probability, a uniform hashed key distribution will be achieved. Extensible hashing [9, 21, 24] provides for hashing the kind of incremental growth that GP methods possess. A number of database systems support hashing [17, 33].
Reference: [7] <author> Comer, D. </author> <title> The ubiquitous B-tree. </title> <booktitle> ACM Comp. Surv. 11,2(June 1979), </booktitle> <pages> 121-138. </pages>
Reference-contexts: Despite the fact that they were invented twenty years ago, B-trees, usually enhanced in some way, remain the indexing method of choice. They were "ubiquitous" in general purpose database systems when Comer wrote his survey article in 1979 <ref> [7] </ref>, and they remain so today. The historical fact is that GP methods, like two phase locking and the four cycle Otto internal combustion engine, are robust mechanisms that have been substantially refined through years of evolutionary development. Robust early entrants benefit by climbing the learning curve via incremental enhancements. <p> I plead guilty to a bias toward my own work, which has long been guided by those considerations. I hope readers will forgive me for this. 3.1 Separation of Index and Data All database systems of which I am aware use a variant of B-trees called B+trees <ref> [7] </ref>. B+trees store all data in leaves of the trees. Internal nodes of the tree contain only index terms which serve solely to direct the search. B+trees have a number of advantages over B-trees, which use data as index entries. 1.
Reference: [8] <author> DeWitt, D., Katz, R., Olken, F., Shapiro, L., Stonebraker, M., and Wood, D. </author> <title> Implementation techniques for main memory database systems. </title> <booktitle> Proc. ACM SIGMOD Conf. </booktitle> <address> (Boston, Mass. </address> <year> 1984) </year> <month> 1-8. </month>
Reference-contexts: In many cases, all or most of a database may be present in the main memory buffer. The question here is, does this change the kind of index tree access method that is most appropriate. This question was addressed in <ref> [8] </ref>, where B+trees were compared in effectiveness to AVL-trees. Their conclusion was that unless 80% to 90% of a file is memory resident, that B+trees provided better search performance, both random and sequential. The reason is that B+trees clustered data better on the disk.
Reference: [9] <author> Fagin, R. Nievergelt, J., Pippenger, N. and Strong, R. </author> <title> Extendible hashing: a fast access method for dynamic files. </title> <journal> ACM Trans. on Database Systems 4,3 (Sept. </journal> <year> 1979) </year> <month> 315-344. </month>
Reference-contexts: Hashing has the best performance of all for exact match random probes. Robust classes of hash functions [6] ensure that, with very high probability, a uniform hashed key distribution will be achieved. Extensible hashing <ref> [9, 21, 24] </ref> provides for hashing the kind of incremental growth that GP methods possess. A number of database systems support hashing [17, 33]. However, unlike index trees, hashing methods fail, in general, to support range queries because hashing structures cluster data by hashed key value, not by key value. <p> However, unlike index trees, hashing methods fail, in general, to support range queries because hashing structures cluster data by hashed key value, not by key value. There have been attempts to use hashing methods for range queries as well as exact match random probes, as suggested in <ref> [9] </ref>. These efforts all rely on what has been called "order preserving hashing", and, in my view, are fundamentally flawed. Hashing methods require approximately uniform key distributions.
Reference: [10] <author> Faloutsos, C. </author> <title> Multiattribute hashing using gray codes. </title> <booktitle> Proc. ACM SIGMOD Conf. </booktitle> <address> (Washington, DC 1986) 227-238. </address>
Reference-contexts: Z-ordering occassionally makes adjacent in the resulting single attribute space, data that is rather far apart in the multi-attribute space. While all walks through the space do this, the goal has been to minimize the problem. This has prompted the definition of walks other than z-ordering <ref> [10, 16] </ref>. The mapping approach reduces the number of indexes for multi-attribute search to one. Thus, it solves the problem of costly index updating during insertion. And it is sometimes effective in the way that it clusters the multi-attribute data.
Reference: [11] <author> Freeston, M. </author> <title> The BANG file: a new kind of grid file. </title> <booktitle> Proc. ACM SIGMOD Conf. </booktitle> <address> (San Francisco, </address> <institution> Cal. </institution> <year> 1987) </year> <month> 260-269. </month>
Reference-contexts: If these subspaces are hyper-rectangles, they can be transformed into points in a space with double the dimensions. But, this also doubles the size of index terms for every level of the tree. Let me illustrate explicit multi-attribute methods with two examples, the hB-tree [30] and the BANG file <ref> [11] </ref>. They differ in how the data entries are divided when a node splits and on how the index terms are represented and searched. The hB-tree splits a data node by successively dividing the data entries based on MEDIAN values of attributes. <p> Then, this rectangle is mapped to a point using any of several techniques, end point boundaries, end point and extents, mid-point and half-extents, etc. I like mapping subspaces to points because it exploits GP methods to index the multi-attribute point data <ref> [36, 11, 30] </ref> that results. These methods deal well with essentially all data distributions by keeping the tree balanced and maintaining adequate storage utilization. With spatial data, there are a multiplicity of range searches possible. These include not only the traditional range search for point data.
Reference: [12] <author> Guenther, O. </author> <title> The design of the cell tree: an object oriented index structure for geometric databases. </title> <booktitle> Proc. IEEE Data Engineering Conf. </booktitle> <address> (Los Angeles, </address> <institution> Cal. </institution> <year> 1989), </year> <pages> 598-605. </pages>
Reference-contexts: Replicate Data: Use some simple discriminator such as a hyperplane, to split a node, and then replicate the data items whose subspaces span the hyperplane boundary. This is called clipping. Both the cell tree <ref> [12] </ref> and the R+tree [41] exploit clipping. Replication can be wasteful of space if it occurs often. And the problem worsens as database size increases, leading to additonal index term space partitioning, and hence further clipping. <p> Indexing may become completely ineffective when, for example, a collection of maps includes a map of the world as well as maps of various parts of the world. The world map halts the splitting process as it overlaps all other maps. The cell tree <ref> [12] </ref> will not split a node if replication of entries (see above) does not succeed, which is a less frequent case than the inability to cleanly partition the indexed subspace. 16 containing, contained in, and intersection queries.
Reference: [13] <author> Guenther, O. and Buchmann, A. </author> <title> Research issues in spatial databases. </title> <booktitle> SIGMOD Record 19,4 (Dec. </booktitle> <year> 1990), </year> <pages> 61-68. 23 </pages>
Reference-contexts: An important part of that work is the need for acceptable access methods. I want to emphasize that 2 1. the number of methods must be small. I heartily concur with the authors of <ref> [13] </ref> that "it is more important ...to develop a sound understanding of the behavior of a few robust access methods under varying conditions" than to invent "ever more specialized access methods". 2. users should not be expected to supply their own access methods to "extensible" systems.
Reference: [14] <author> Guttman, A. R-trees: </author> <title> a dynamic index structure for spatial searching, </title> <booktitle> Proc. ACM SIGMOD Conf. </booktitle> <address> (Boston, Mass. </address> <year> 1984) </year>
Reference-contexts: We describe first the three that seem most limited, elaborating on the fourth in the next subsection. Index Overlapping Subspaces: Permit index terms to describe overlapping sub-spaces. Then, one can always split the subspace of a node and index the resulting subspaces. This is what R-trees do <ref> [14] </ref>. A cottage industry has grown up around effective ways to do the R-tree splits. But splitting algorithms need to be simple and perform well when insertions are frequent. One cannot afford to solve a complex optimization problem in order to split a node.
Reference: [15] <author> IBM, </author> <title> Introduction to IBM/360 direct access storage devices and organization methods. </title> <address> C20-1649, IBM Corp.(White Plains, N.Y. </address> <year> 1966) </year>
Reference-contexts: Providing this is decidedly non-trivial. Other index trees have not been nearly as successful. For example, IBM's ISAM <ref> [15] </ref> requires periodic re-organizations in order to deal with the performance degradation that arises as ISAM files grow. DB-trees [26] suffer degraded storage utilization when faced with skewed key distributions.
Reference: [16] <author> Jagadish, H. </author> <title> Linear clustering of objects with multiple attributes. </title> <booktitle> Proc. ACM SIG-MOD Conf. </booktitle> <address> (Atlantic City, N.J. </address> <year> 1990) </year> <month> 332-342. </month>
Reference-contexts: Z-ordering occassionally makes adjacent in the resulting single attribute space, data that is rather far apart in the multi-attribute space. While all walks through the space do this, the goal has been to minimize the problem. This has prompted the definition of walks other than z-ordering <ref> [10, 16] </ref>. The mapping approach reduces the number of indexes for multi-attribute search to one. Thus, it solves the problem of costly index updating during insertion. And it is sometimes effective in the way that it clusters the multi-attribute data.
Reference: [17] <author> Joshi, A. and Rodwell, K. </author> <title> A relational database management system for production applications. </title> <journal> Digital Technical Journal no. </journal> <month> 8 (Feb. </month> <year> 1989) </year> <month> 99-109. </month>
Reference-contexts: Robust classes of hash functions [6] ensure that, with very high probability, a uniform hashed key distribution will be achieved. Extensible hashing [9, 21, 24] provides for hashing the kind of incremental growth that GP methods possess. A number of database systems support hashing <ref> [17, 33] </ref>. However, unlike index trees, hashing methods fail, in general, to support range queries because hashing structures cluster data by hashed key value, not by key value. There have been attempts to use hashing methods for range queries as well as exact match random probes, as suggested in [9].
Reference: [18] <author> Keehn, D. and Lacy, J. </author> <title> VSAM data set design parameters. </title> <journal> IBM Systems Journal 13,3 (1974) 186-212. </journal>
Reference-contexts: B-trees <ref> [2, 18] </ref> represent both the genesis and the archetype for the class of GP methods. Despite the fact that they were invented twenty years ago, B-trees, usually enhanced in some way, remain the indexing method of choice. <p> This paper also included the use of elastic bucket partial expansion to boost storage utilization. The storage utilization results have been confirmed recently [37]. 3.5 Multi-Node Clustering VSAM <ref> [18] </ref> has long taken pains to cluster nodes of a range together on the disk so as to optimize index traversal and sequential performance. Such clustering may avoid disk seeks in going from one node to another.
Reference: [19] <author> Knuth, D. </author> <booktitle> The art of computer programming, </booktitle> <volume> Vol. </volume> <month> 3: </month> <title> sorting and searching. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass.(1973) </address>
Reference-contexts: The best order preserving hash is, I believe, order preserving key compression. Key compression works by driving the bit probabilities toward p = :5. I experimented with names from a phonebook, using the Hu-Tucker optimal order preserving key compression technique <ref> [19] </ref>. The results were dismal. Order preserving key compression did not come close to producing a uniform distribution. This should not be surprising. <p> B-tree node splitting is an example of a full expansion. Partial expansions involve more than one increase in space prior to the local space being doubled. The B*tree <ref> [19] </ref> is the first example of a partial expansion technique. Partial expansions were first given their name, and exploited effectively for linear hashing by Larson [22]. The problem with B*trees is that to achieve increased utilization requires a substantial insertion cost penalty.
Reference: [20] <author> Lampson, B. </author> <title> Hints for computer system design. </title> <journal> IEEE Software 1,1 (Jan. </journal> <year> 1984) </year> <month> 11-28. </month>
Reference-contexts: This is often under-appreciated. Complex methods are rarely justifiable based on modest performance improvements. Even simple algorithms lead to complex implementations. Some local complexity may be tolerable, but global complexity should be regarded with suspicion. The KISS ("Keep It Simple, Stupid") doctrine <ref> [20] </ref> should be heeded. GP methods have acceptable performance and functionality: search and update performance is guaranteed to be logarithmic in the number of keys being indexed because GP trees are balanced. range search performance is furthered because of the clustering of closely spaced keys within a node.
Reference: [21] <author> Larson, P. </author> <title> Dynamic hashing. </title> <note> BIT 18 (1978) 184-201. </note>
Reference-contexts: Hashing has the best performance of all for exact match random probes. Robust classes of hash functions [6] ensure that, with very high probability, a uniform hashed key distribution will be achieved. Extensible hashing <ref> [9, 21, 24] </ref> provides for hashing the kind of incremental growth that GP methods possess. A number of database systems support hashing [17, 33]. However, unlike index trees, hashing methods fail, in general, to support range queries because hashing structures cluster data by hashed key value, not by key value.
Reference: [22] <author> Larson, P. </author> <title> Linear hashing with partial expansions. </title> <booktitle> Proc. VLDB Conf. </booktitle> <address> (Montreal, Canada 1980), </address> <pages> 224-232. </pages>
Reference-contexts: Partial expansions involve more than one increase in space prior to the local space being doubled. The B*tree [19] is the first example of a partial expansion technique. Partial expansions were first given their name, and exploited effectively for linear hashing by Larson <ref> [22] </ref>. The problem with B*trees is that to achieve increased utilization requires a substantial insertion cost penalty. When a node overflows in a B*tree, one divides the node's entries with a neighbor. Only when both an overflowing node and its neighbor are full is another node added to the tree.
Reference: [23] <author> Lehman, P. and Yao, S. </author> <title> Efficient locking for concurrent operations on B-trees. </title> <journal> ACM Trans. </journal> <note> on Database Systems 6,4 (Dec. </note> <year> 1981) </year> <month> 650-670. </month>
Reference-contexts: While many schemes have been suggested, my favorite uses the B link tree <ref> [23] </ref>, and locks only one node at a time while posting an index term [38]. This is an elegant concurrency control scheme. Node deletion is also handled, though with somewhat more locks. Recovery is not treated in [23, 38]. <p> This is an elegant concurrency control scheme. Node deletion is also handled, though with somewhat more locks. Recovery is not treated in <ref> [23, 38] </ref>. Each node of a B link tree, index nodes and data nodes (leaves) alike, contains a pointer (link) to the node on the same level that contains the entries for the next higher valued keys in the key space.
Reference: [24] <author> Litwin, W. </author> <title> Linear hashing: a new tool for file and table addressing. </title> <booktitle> Proc. VLDB Conf. </booktitle> <address> (Montreal, Canada 1980), </address> <pages> 212-223. </pages>
Reference-contexts: Hashing has the best performance of all for exact match random probes. Robust classes of hash functions [6] ensure that, with very high probability, a uniform hashed key distribution will be achieved. Extensible hashing <ref> [9, 21, 24] </ref> provides for hashing the kind of incremental growth that GP methods possess. A number of database systems support hashing [17, 33]. However, unlike index trees, hashing methods fail, in general, to support range queries because hashing structures cluster data by hashed key value, not by key value.
Reference: [25] <author> Litwin, W. and Lomet, D. </author> <title> A new method for fast data searches with keys. </title> <booktitle> IEEE Software 4,2 (Mar. </booktitle> <year> 1987), </year> <pages> 16-24. </pages>
Reference-contexts: This appears to require an index. 9 Several years ago, I experimented with using an address computation based on the binary representation of keys [26]. Subsequently, Litwin and I <ref> [25] </ref> introduced the bounded disorder access method which used hashing as a way of indexing multi-bucket nodes. Hashing permits nodes to achieve adequate storage utilization while their buckets can be accessed directly, without an index. <p> Hence, I conclude that for exact match point searches, multi-attribute GP-tree performance is adequate. Comparative range search assessments should be based primarily on the relative numbers of data nodes that need to be accessed, though one cannot neglect the merge needed for bounded disorder nodes <ref> [25] </ref>. Storage utilization in the data nodes is a good way of assessing single attribute range search performance. Utilization determines the number of nodes that hold the interior of the range. Single attribute ranges have only two nodes at the boundary, and hence boundaries are not a major factor.
Reference: [26] <author> Lomet, D. </author> <title> Digital B-trees. </title> <booktitle> Proc. VLDB Conf. </booktitle> <address> (Cannes, France 1981) 333-344. </address>
Reference-contexts: Providing this is decidedly non-trivial. Other index trees have not been nearly as successful. For example, IBM's ISAM [15] requires periodic re-organizations in order to deal with the performance degradation that arises as ISAM files grow. DB-trees <ref> [26] </ref> suffer degraded storage utilization when faced with skewed key distributions. <p> The problems of large nodes can be alleviated by breaking up a large node into multiple buckets, and only accessing the needed buckets. This appears to require an index. 9 Several years ago, I experimented with using an address computation based on the binary representation of keys <ref> [26] </ref>. Subsequently, Litwin and I [25] introduced the bounded disorder access method which used hashing as a way of indexing multi-bucket nodes. Hashing permits nodes to achieve adequate storage utilization while their buckets can be accessed directly, without an index. <p> When s is the fraction of the entries (or their space) going to one of the resulting nodes, then u = s fl ln (1=s) + (1 s) fl ln (1=(1 s)) <ref> [26] </ref>. Utilization of better than 63% is achieved when s &gt;= 1=3.
Reference: [27] <author> Lomet, D. </author> <title> Partial expansions for file organizations with an index. </title> <journal> ACM Trans. on Database Systems 12,1 (Mar. </journal> <year> 1987), </year> <pages> 65-84. </pages>
Reference-contexts: Only when both an overflowing node and its neighbor are full is another node added to the tree. But, just before this growth, there can be many insertions that require re-juggling of data between neighboring nodes. Elastic bucket partial expansion <ref> [27] </ref> avoids this re-shu*ing of data between nodes. An elastic bucket grows by first increasing the size of the node. Then, when the node (bucket) is of some maximum size, a split occurs that produces two small size nodes. No shu*ing of data between nodes is necessary. <p> No shu*ing of data between nodes is necessary. The results are quite good, and cheaply achieved. An expansion sequence of small node, larger node, two small nodes, etc. achieves a utilization of 83% <ref> [27, 1] </ref>. Further, in [1], it is shown that little utilization is lost by the need to cope with more than one node size. <p> The reason is that B+trees clustered data better on the disk. The AVL-tree advantage in storage utilization can be reduced by using partial expansions with the B+tree <ref> [27] </ref>. This increases the fraction of the file that must be main memory resident before AVL trees show any advantage. It is not clear that any AVL-tree advantage survives. There are additional reasons for preferring the disk block oriented grow and post methods.
Reference: [28] <author> Lomet, D. </author> <title> A simple bounded disorder file organization with good performance. </title> <journal> ACM Trans. </journal> <note> on Database Systems 13,4 (Dec. </note> <year> 1988) </year> <month> 525-551. </month>
Reference-contexts: And not all range searches require key sequential delivery of results. For these, the merge is unnecessary. A subsequent paper <ref> [28] </ref> showed a simple way of treating overflow by adding a single extra overflow bucket per node.
Reference: [29] <author> Lomet, D. and Salzberg, B. </author> <title> Access methods for multiversion data. </title> <booktitle> Proc. ACM SIG-MOD Conf. </booktitle> <address> (Portland, Ore. </address> <year> 1989) </year> <month> 315-324. </month>
Reference-contexts: However, all are non-traditional and suggestive of how useful index trees are in general, and GP methods are in particular. 6.1 Multi-version Data GP methods can be applied to the problem of indexing multiversion data. One example is the indexing of historical data provided by the time-split B-tree <ref> [29] </ref>. When time is used to split nodes in the time-split B-tree, clippling is used, i.e. the historical versions that cross a time boundary are replicated.
Reference: [30] <author> Lomet, D. and Salzberg, B. </author> <title> The hB-tree: a multiattribute indexing method with good guaranteed performance. </title> <journal> ACM Trans. </journal> <note> on Database Systems 15,4 (Dec. </note> <year> 1990) </year> <month> 625-658. </month>
Reference-contexts: If these subspaces are hyper-rectangles, they can be transformed into points in a space with double the dimensions. But, this also doubles the size of index terms for every level of the tree. Let me illustrate explicit multi-attribute methods with two examples, the hB-tree <ref> [30] </ref> and the BANG file [11]. They differ in how the data entries are divided when a node splits and on how the index terms are represented and searched. The hB-tree splits a data node by successively dividing the data entries based on MEDIAN values of attributes. <p> Then, this rectangle is mapped to a point using any of several techniques, end point boundaries, end point and extents, mid-point and half-extents, etc. I like mapping subspaces to points because it exploits GP methods to index the multi-attribute point data <ref> [36, 11, 30] </ref> that results. These methods deal well with essentially all data distributions by keeping the tree balanced and maintaining adequate storage utilization. With spatial data, there are a multiplicity of range searches possible. These include not only the traditional range search for point data.
Reference: [31] <author> Lomet, D. and Salzberg, B. </author> <title> Concurrency and recovery for index trees. </title> <institution> Digital Equipment Corp. </institution> <type> Technical Report, </type> <institution> Cambridge Research Lab, </institution> <address> Cambridge, Mass. </address> <note> (to appear, </note> <month> summer, </month> <year> 1991) </year> <month> 24 </month>
Reference-contexts: An access method uses these services to supply the expected transactional semantics. There is a long history of papers that have attacked facets of this problem, mostly concurrency control. In fact, there is a serious 7 shortcoming of the scientific literature. I know of only two access method papers <ref> [35, 31] </ref> that deal with recovery and surviving system failures. Clearly, database systems provide transactional semantics. And strict two phase locking, including locking index nodes, where locks are held until end of transaction, works. The problem is that concurrency is then seriously impeded. <p> Thus, locks on split nodes can be dropped before a new index term is posted. A recent performance study [42] suggests that this method provides the best concurrency. The tree concurrency control and recovery method that Betty Salzberg and I have developed <ref> [31] </ref> works with a generalization of the B link tree. It avoids dependence on any one recovery method. Concurrency is handled by organizing tree restructuring as a sequence of atomic actions.
Reference: [32] <author> Lynch, C. and Stonebraker, M. </author> <title> Extended user-defined indexing with application to textual databases. </title> <booktitle> Proc. VLDB Conf. </booktitle> <address> (Los Angeles, </address> <institution> Cal. </institution> <year> 1988) </year> <month> 306-317. </month>
Reference-contexts: But there are other opportunities for indexing on derived values. An important one is indexing for text retrieval <ref> [32] </ref>. Text is usually stored in tuples as a large field. Such a large field (sometimes called a "BLOB") is usually not permitted as an indexing field, nor are comparisons normally directly supported. <p> The attributes of a tuple containing a BLOB normally include formatted descriptive attributes for the BLOB, e.g. author, source, publisher, etc., and these can serve as indexing attributes. What one cannot normally do is build a keyword index on the text in the BLOB itself. As discussed in <ref> [32] </ref>, one needs a set-valued function to generate the key words, together with an ability to build an efficient index on the separate elements of this set. 6.5 Non-comparison Based Index Searching One can consider an index tree solely as a data structure, not necessarily with pre-builtin operations.
Reference: [33] <author> McGee, W. </author> <title> The information management system IMS/VS; part II: data base facilities. </title> <journal> IBM Systems Journal 16,2 (1977) 96-122. </journal>
Reference-contexts: Robust classes of hash functions [6] ensure that, with very high probability, a uniform hashed key distribution will be achieved. Extensible hashing [9, 21, 24] provides for hashing the kind of incremental growth that GP methods possess. A number of database systems support hashing <ref> [17, 33] </ref>. However, unlike index trees, hashing methods fail, in general, to support range queries because hashing structures cluster data by hashed key value, not by key value. There have been attempts to use hashing methods for range queries as well as exact match random probes, as suggested in [9].
Reference: [34] <author> Mohan, C., Haderle, D., Lindsay, B., Pirahesh, H., and Schwarz, P. </author> <title> ARIES: a transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. </title> <institution> IBM Research Report RJ 6649, IBM Almaden Research Center (Jan. </institution> <note> 1989) and ACM Trans. on Database Systems (to appear). </note>
Reference-contexts: The higher level undo permits successful abort (undo) even when records or index entries have moved because of tree restructuring. This is a very powerful technique. Two cautions are worth mentioning. First, ARIES/IM intrinsically utilizes the ARIES <ref> [34] </ref> recovery method. They come as a package. To use ARIES/IM technology, one must use ARIES as the recovery method. Second, the synchronization techniques exploited in ARIES/IM are diverse, with complicated and subtle interactions.
Reference: [35] <author> Mohan, C. and Levine, F. ARIES/IM: </author> <title> an efficient and high concurrency index management method using write ahead logging. </title> <institution> IBM Research Report RJ6846, IBM Al-maden Research Center (August 1989). </institution>
Reference-contexts: An access method uses these services to supply the expected transactional semantics. There is a long history of papers that have attacked facets of this problem, mostly concurrency control. In fact, there is a serious 7 shortcoming of the scientific literature. I know of only two access method papers <ref> [35, 31] </ref> that deal with recovery and surviving system failures. Clearly, database systems provide transactional semantics. And strict two phase locking, including locking index nodes, where locks are held until end of transaction, works. The problem is that concurrency is then seriously impeded. <p> This is not as effective as supporting large nodes because of the multiple I/Os that must be scheduled and the potential intervening disk arm movement possible in a multi-user system. However, it can reduce the response time of large scans, and so is important. 3.6 ARIES/IM ARIES/IM <ref> [35] </ref> is an index tree concurrency and recovery method that exploits the ARIES recovery method so as to provide low level (physical) redo recovery while providing somewhat higher level "logical" undo recovery.
Reference: [36] <author> Orenstein, J. and Merrett, T. </author> <title> A class of data structures for associative searching. </title> <booktitle> Proc. ACM PODS Conf. </booktitle> <address> (Waterloo, Canada, </address> <year> 1984) </year> <month> 181-190. </month>
Reference-contexts: The simplest way to do this is to merge the bit representations of the separate attributes, constructing the single attribute by first choosing a bit from the representation for one attribute, then from another. Strictly alternating among the bits of the multiple attributes representations is called z-ordering <ref> [36] </ref>. Mapping multiple attributes to one defines a "walk" through the multi-attribute space, effectively linearizing it. A one dimensional GP method clusters data based on the attribute resulting from the mapping. <p> Then, this rectangle is mapped to a point using any of several techniques, end point boundaries, end point and extents, mid-point and half-extents, etc. I like mapping subspaces to points because it exploits GP methods to index the multi-attribute point data <ref> [36, 11, 30] </ref> that results. These methods deal well with essentially all data distributions by keeping the tree balanced and maintaining adequate storage utilization. With spatial data, there are a multiplicity of range searches possible. These include not only the traditional range search for point data.
Reference: [37] <author> Ramakrishna, M. and Mukhopadhyay, P. </author> <title> Analysis of bounded disorder file organization. </title> <booktitle> Proc. ACM PODS Conf. </booktitle> <address> (San Francisco, </address> <institution> Cal. </institution> <year> 1988) </year> <month> 117-125. </month>
Reference-contexts: This paper also included the use of elastic bucket partial expansion to boost storage utilization. The storage utilization results have been confirmed recently <ref> [37] </ref>. 3.5 Multi-Node Clustering VSAM [18] has long taken pains to cluster nodes of a range together on the disk so as to optimize index traversal and sequential performance. Such clustering may avoid disk seeks in going from one node to another.
Reference: [38] <author> Sagiv, Y. </author> <title> Concurrent operations on B-trees with overtaking. </title> <booktitle> Proc. ACM PODS Conf. </booktitle> <address> (Portland, Ore., </address> <year> 1985) </year> <month> 28-37. </month>
Reference-contexts: While many schemes have been suggested, my favorite uses the B link tree [23], and locks only one node at a time while posting an index term <ref> [38] </ref>. This is an elegant concurrency control scheme. Node deletion is also handled, though with somewhat more locks. Recovery is not treated in [23, 38]. <p> This is an elegant concurrency control scheme. Node deletion is also handled, though with somewhat more locks. Recovery is not treated in <ref> [23, 38] </ref>. Each node of a B link tree, index nodes and data nodes (leaves) alike, contains a pointer (link) to the node on the same level that contains the entries for the next higher valued keys in the key space.
Reference: [39] <author> Salzberg, B. </author> <title> File structures: an analytic approach. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ (1988) </address>
Reference-contexts: Notice that tree height plays very little role in this analysis. Rather, performance is more closely related to index size. This is not a new observation <ref> [39] </ref>. When an index tree grows in height by one via the splitting of the root, exactly two new nodes are added to the index, increasing cache requirements by 8KB.
Reference: [40] <author> Salzberg, B. </author> <title> Practical spatial database access methods. </title> <booktitle> Proc. Symposium on Applied Computing (Kansas City, Kan. </booktitle> <year> 1991) </year> <month> 82-90. </month>
Reference-contexts: This paper has benefitted from 22 my reading of her paper on the practicality of spatial access methods <ref> [40] </ref>. Mark Tuttle of CRL generously took time from his own research to help me cope with the intricacies of Latex. Michelle Gillespie translated my crude hand drawings into polished figures.
Reference: [41] <author> Sellis, T., Roussopoulos, N., and Faloutsos, C. </author> <title> The R+-tree: a dynamic index for multi-dimensional objects. </title> <booktitle> Proc. VLDB Conf. </booktitle> <address> (Brighton, England 1987) </address>
Reference-contexts: Replicate Data: Use some simple discriminator such as a hyperplane, to split a node, and then replicate the data items whose subspaces span the hyperplane boundary. This is called clipping. Both the cell tree [12] and the R+tree <ref> [41] </ref> exploit clipping. Replication can be wasteful of space if it occurs often. And the problem worsens as database size increases, leading to additonal index term space partitioning, and hence further clipping.
Reference: [42] <author> Srinivasan, V. and Carey, M. </author> <title> Performance of B-tree concurrency control algorithms. </title> <booktitle> Proc. ACM SIGMOD Conf. </booktitle> <address> (Denver, Col. </address> <year> 1991) </year> <month> 416-425. </month>
Reference-contexts: This permits data to be found even before an index entry for the new node has been posted. Thus, locks on split nodes can be dropped before a new index term is posted. A recent performance study <ref> [42] </ref> suggests that this method provides the best concurrency. The tree concurrency control and recovery method that Betty Salzberg and I have developed [31] works with a generalization of the B link tree. It avoids dependence on any one recovery method.
References-found: 42

