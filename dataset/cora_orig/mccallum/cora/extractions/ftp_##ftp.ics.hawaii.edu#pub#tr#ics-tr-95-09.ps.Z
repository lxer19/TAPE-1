URL: ftp://ftp.ics.hawaii.edu/pub/tr/ics-tr-95-09.ps.Z
Refering-URL: ftp://ftp.ics.hawaii.edu/pub/tr/INDEX.html
Root-URL: 
Title: Evaluating Deadlock Detection Methods for Concurrent Software  
Author: James C. Corbett 
Keyword: concurrency analysis, empirical evaluation, state space reduction, symbolic model checking, inequality necessary conditions, Ada tasking.  
Date: 3, MARCH 1996 1  
Note: IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 22, NO.  
Abstract: Static analysis of concurrent programs has been hindered by the well known state explosion problem. Although many different techniques have been proposed to combat this state explosion, there is little empirical data comparing the performance of the methods. This information is essential for assessing the practical value of a technique and for choosing the best method for a particular problem. In this paper, we carry out an evaluation of three techniques for combating the state explosion problem in deadlock detection: reachability search with a partial order state space reduction, symbolic model checking, and inequality necessary conditions. We justify the method used for the comparison, and carefully analyze several sources of potential bias. The results of our evaluation provide valuable data on the kinds of programs to which each technique might best be applied. Furthermore, we believe that the methodological issues we discuss are of general significance in comparison of analysis techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. S. Avrunin, U. A. Buy, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Integer programming has been used in the analysis of certain kinds of deadlocks [34] and in a conservative analysis for general safety and liveness properties <ref> [1, 12] </ref>. These techniques reduce the verification of a property to a question about the integral solutions of linear systems. B. Selecting Methods to Evaluate Of all the techniques available, we selected a partial order state space reduction [20], symbolic model checking [4], and inequality necessary conditions [1] to evaluate. <p> These techniques reduce the verification of a property to a question about the integral solutions of linear systems. B. Selecting Methods to Evaluate Of all the techniques available, we selected a partial order state space reduction [20], symbolic model checking [4], and inequality necessary conditions <ref> [1] </ref> to evaluate. We selected these three techniques for several reasons. First, they represent three very different approaches to the state explosion problem and might be expected to perform best on different kinds of systems. <p> Finally, we selected these three techniques because an implementation of each was available to us, as discussed in Section IV-C. In the worst case, the time complexity of all of these techniques is exponential in the size of the system <ref> [1, 4, 20] </ref>. In practice, the techniques may have a much lower complexity on certain kinds of systems. In the remainder of this section, we provide a brief overview of the three techniques selected for evaluation. C. <p> Inequality System Necessary conditions in the form of linear inequalities have been used to verify a variety of different properties of concurrent system, including freedom from deadlock <ref> [1] </ref>, general safety and liveness properties [8], and real-time properties [2, 11]. The basic idea is to view each FSA M i as a flowgraph and find a flow from the start state to some final state. <p> Notice that the inequalities have no integral solution, proving that deadlock is impossible. See <ref> [1, 12] </ref> for details. IV. <p> Unfortunately, the Inequality Necessary Condition Analyzer (INCA), like many research tools, has none of these desirable properties, but since we constructed most of the components that are currently in use, this was not a problem. INCA is descended from the constrained expression toolset <ref> [1] </ref>, but it supports more powerful analysis techniques [11, 12] and is more efficient. D. Specifying the Examples Given our decision to use existing implementations of the techniques, we are faced with a problem: each analysis tool has its own unique specification language. We see two solutions to this problem. <p> Dartes Program (DARTES) The communication skele ton of a fairly complex Ada program with 32 tasks [30]. Dining Philosophers (DP, DPH, DPD, DPFM) Although not a very realistic problem, it does contain a nontrivial deadlock and is probably the most commonly analyzed example <ref> [1, 14, 28, 42, 46] </ref>. We model each of the m philosophers and m forks with a task. These tasks synchronize to model forks being acquired and released. In addition to the standard version (DP), which can deadlock, we also analyzed several versions of the problem where deadlock is prevented. <p> The size m version has 2m + 6 tasks. Gas Station (GASNQ, GASQ) This example, which models a self-service gas station, originated in [23] and has been analyzed in <ref> [1, 14, 28, 40] </ref>. Customers arrive and pay the operator for gas. The operator activates a pump, at which the customer then pumps gas. When the customer is finished, the pump reports the amount of gas actually pumped to the operator, who then gives the customer her change. <p> We analyzed versions with one operator task, two pump tasks, and m customer tasks. We analyzed two different versions of this example. In the original version (GASQ) from <ref> [1, 23] </ref>, the operator task queues customer requests and must keep track of which customers are waiting for each pump and in what order. <p> Each of the m reader tasks and m writer tasks must synchronize with a controller task before accessing and when finished accessing the database. This system has been analyzed in <ref> [1, 14, 28] </ref>. Sensor Test Program (SENTEST) The communication skeleton of an Ada program analyzed in [30] that starts up m tasks to test sensors. The size m version has m + 4 tasks.
Reference: [2] <author> G. S. Avrunin, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automatic derivation of time bounds in uniprocessor concurrent systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 20(9) </volume> <pages> 708-719, </pages> <year> 1994. </year>
Reference-contexts: Inequality System Necessary conditions in the form of linear inequalities have been used to verify a variety of different properties of concurrent system, including freedom from deadlock [1], general safety and liveness properties [8], and real-time properties <ref> [2, 11] </ref>. The basic idea is to view each FSA M i as a flowgraph and find a flow from the start state to some final state. This flow represents the path M i takes in the trace being sought (i.e., the trace violating P ). <p> Cyclic scheduler (CYCLIC) Milner's cyclic scheduler [7, 33] uses m scheduler tasks to keep m customer tasks loosely synchronized. Divide and Conquer (DAC) A program modeling a di vide and conquer computation by forking up to m solver tasks that proceed in parallel <ref> [2, 11] </ref>. Dartes Program (DARTES) The communication skele ton of a fairly complex Ada program with 32 tasks [30]. Dining Philosophers (DP, DPH, DPD, DPFM) Although not a very realistic problem, it does contain a nontrivial deadlock and is probably the most commonly analyzed example [1, 14, 28, 42, 46].
Reference: [3] <author> R. E. Bryant. </author> <title> Symbolic boolean manipulation with ordered binary-decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <year> 1992. </year>
Reference-contexts: One way to represent symbolically is to encode the relation as a boolean function represented by an Ordered Binary Decision Diagram (OBDD) <ref> [3] </ref>. OBDDs represent many frequently occurring boolean functions very compactly (e.g., symmetric functions, addition).
Reference: [4] <author> J. Burch, E. Clarke, K. McMillan, D. Dill, and L. Hwang. </author> <title> Sym bolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: They range from virtual coarsening techniques [29,40], which coalesce internal actions into adjacent external actions, to partial order techniques [20, 42], which alleviate the effects of representing concurrency with interleaving, to symmetry techniques [31, 37] which take advantage of symmetries in the state space. Symbolic model checking <ref> [4, 32] </ref> uses a symbolic repre sentation of a system's states, which is sometimes much more compact than an explicit enumeration. These techniques have proven especially successful in verifying hardware. <p> These techniques reduce the verification of a property to a question about the integral solutions of linear systems. B. Selecting Methods to Evaluate Of all the techniques available, we selected a partial order state space reduction [20], symbolic model checking <ref> [4] </ref>, and inequality necessary conditions [1] to evaluate. We selected these three techniques for several reasons. First, they represent three very different approaches to the state explosion problem and might be expected to perform best on different kinds of systems. <p> Finally, we selected these three techniques because an implementation of each was available to us, as discussed in Section IV-C. In the worst case, the time complexity of all of these techniques is exponential in the size of the system <ref> [1, 4, 20] </ref>. In practice, the techniques may have a much lower complexity on certain kinds of systems. In the remainder of this section, we provide a brief overview of the three techniques selected for evaluation. C. <p> The OBDD for R can be used to check for reachable states with certain properties (e.g., deadlock). In fact, model checking of temporal logic formulas can be performed in this framework without ever constructing an explicit representation of M . See <ref> [4, 32] </ref> for details. E. Inequality Necessary Conditions Yet another approach to making deadlock detection more tractable is to forgo any representation of the state space.
Reference: [5] <author> S. C. Cheung and J. Kramer. </author> <title> Enhancing compositional reach ability analysis using context constraints. </title> <booktitle> In Proceedings of the first ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 115-125, </pages> <month> Dec. </month> <year> 1993. </year>
Reference: [6] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 16(5) </volume> <pages> 1512-1542, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Compositional techniques [5,7,43] exploit modularity in a system by dividing it into smaller subsystems, verifying each subsystem, and then combining the results of these analyses to verify the full system. If the subsystems have simple interfaces, such a hierarchical analysis can be quite effective. Abstraction <ref> [6] </ref> reduces the number of states by ignoring some state information. For example, static analysis of software often considers the state of a process to consist only of its control location and ignores the values of its variables.
Reference: [7] <author> R. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The Concurrency Workbench: A semantics based tool for the verification of concurrent systems. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 15(1) </volume> <pages> 36-72, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: We obtained the communication skeleton from the Concurrent Systems Software Laboratory at the University of Illinois at Chicago (as indicated in Table I, the skeleton is only 247 lines). The example has 15 tasks, but the skeleton of each is relatively simple. Cyclic scheduler (CYCLIC) Milner's cyclic scheduler <ref> [7, 33] </ref> uses m scheduler tasks to keep m customer tasks loosely synchronized. Divide and Conquer (DAC) A program modeling a di vide and conquer computation by forking up to m solver tasks that proceed in parallel [2, 11].
Reference: [8] <author> J. C. Corbett. </author> <title> Verifying general safety and liveness properties with integer programming. </title> <booktitle> In v. Bochmann and Probst [41], </booktitle> <pages> pages 357-369. </pages>
Reference-contexts: Inequality System Necessary conditions in the form of linear inequalities have been used to verify a variety of different properties of concurrent system, including freedom from deadlock [1], general safety and liveness properties <ref> [8] </ref>, and real-time properties [2, 11]. The basic idea is to view each FSA M i as a flowgraph and find a flow from the start state to some final state. This flow represents the path M i takes in the trace being sought (i.e., the trace violating P ).
Reference: [9] <author> J. C. Corbett. </author> <title> An SEDL translator. </title> <type> Technical Report ICS-TR 93-03, </type> <institution> Information and Computer Science Department, University of Hawaii at Manoa, </institution> <year> 1993. </year>
Reference-contexts: The real issue is whether our choice of canonical form introduces a bias; we discuss this issue in Section IV-E. A description of the algorithm used by the front end of INCA to translate our Ada-like specification language into communicating FSAs is given in <ref> [9] </ref>. Since the details of this translation are extensive and probably beyond the scope of this paper, here we give only an example of a sample specification and the FSAs generated from it.
Reference: [10] <author> J. C. Corbett. </author> <title> An empirical evaluation of three methods for deadlock analysis of Ada tasking programs. </title> <editor> In T. Ostrand, editor, </editor> <booktitle> Proceedings of the 1994 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 204-215. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1994. </year>
Reference-contexts: For such examples, we chose to use larger sizes to minimize the number of small measurements, which are dominated by fixed overhead. Rather than finding the largest size each tool can handle given certain resource constraints, as we did in the preliminary version of this paper <ref> [10] </ref>, we simply measure the growth in the resources consumed as the example is scaled up (the calculation of these growth rates is described in Section V-E). We believe these growth rates are more meaningful than the maximum sizes gathered in [10] for several reasons. <p> we did in the preliminary version of this paper <ref> [10] </ref>, we simply measure the growth in the resources consumed as the example is scaled up (the calculation of these growth rates is described in Section V-E). We believe these growth rates are more meaningful than the maximum sizes gathered in [10] for several reasons. First, various kinds of constant overhead in the implementations are factored out. Second, for some of the examples, the use of translated input, not the tool itself, imposes the maximum size (see the discussion of the difficulty in scaling HARTSTONE and SENTEST in Section V-D). <p> Third, the resource constraints, although reasonable, are somewhat arbitrary, especially the limit on CPU time. In <ref> [10] </ref> we used three hours, though one could argue for a higher or lower limit. In Section V-E, we will investigate the relationship between the size of the concurrent system and the resources consumed by the tools to perform the analysis. <p> Note that SPIN was able to complete the analysis of these systems by finding a deadlock state before generating the entire state space. Those comparing these numbers with those in <ref> [10] </ref>, which used INCA version 3.1, may notice slight differences for some of the examples. The front end of INCA has been extensively modified in version 3.2 to support the EFSAs described in Section VI-B. E. <p> In other words, the measured growth rate may not be an accurate characterization of the scalability of a tool. We validate our scalability measure by comparing the growth rates calculated here with the maximum sizes determined in <ref> [10] </ref> on a couple of examples. First we consider DP, an example on which most of the tools can be scaled to much larger sizes than those shown in Table III. For this example, SPIN, SPIN+PO, and INCA all exhausted the 64 MB limit imposed in [10], while SMV exceeded the <p> maximum sizes determined in <ref> [10] </ref> on a couple of examples. First we consider DP, an example on which most of the tools can be scaled to much larger sizes than those shown in Table III. For this example, SPIN, SPIN+PO, and INCA all exhausted the 64 MB limit imposed in [10], while SMV exceeded the three hour time limit instead. The memory growth rate was 5.9 for SPIN, 2.7 for SPIN+PO, 0.5 for SMV, and 1.0 for INCA. <p> Note that, while it would be difficult to predict the maximum sizes without additional information, they are roughly consistent with the growth rates. We also consider the data intensive example GASNQ. In <ref> [10] </ref>, SPIN and SPIN+PO exhausted the memory limit, while SMV and INCA exhausted the time limit. The memory growth rate is 9.1 for SPIN and 7.6 for SPIN+PO. From these rates, we might expect SPIN+PO to be able to scale a bit farther than SPIN. <p> The story behind our selection of this example is interesting. We sent a draft of the predecessor to this paper <ref> [10] </ref> to Gerard Holzmann, the author of SPIN, to solicit comments on our use of his tool. At his request, we also supplied the generated Promela inputs.
Reference: [11] <author> J. C. Corbett and G. S. Avrunin. </author> <title> A practical method for bound ing the time between events in concurrent real-time systems. </title> <booktitle> In Ostrand and Weyuker [36], </booktitle> <pages> pages 110-116. </pages>
Reference-contexts: Inequality System Necessary conditions in the form of linear inequalities have been used to verify a variety of different properties of concurrent system, including freedom from deadlock [1], general safety and liveness properties [8], and real-time properties <ref> [2, 11] </ref>. The basic idea is to view each FSA M i as a flowgraph and find a flow from the start state to some final state. This flow represents the path M i takes in the trace being sought (i.e., the trace violating P ). <p> INCA is descended from the constrained expression toolset [1], but it supports more powerful analysis techniques <ref> [11, 12] </ref> and is more efficient. D. Specifying the Examples Given our decision to use existing implementations of the techniques, we are faced with a problem: each analysis tool has its own unique specification language. We see two solutions to this problem. <p> Cyclic scheduler (CYCLIC) Milner's cyclic scheduler [7, 33] uses m scheduler tasks to keep m customer tasks loosely synchronized. Divide and Conquer (DAC) A program modeling a di vide and conquer computation by forking up to m solver tasks that proceed in parallel <ref> [2, 11] </ref>. Dartes Program (DARTES) The communication skele ton of a fairly complex Ada program with 32 tasks [30]. Dining Philosophers (DP, DPH, DPD, DPFM) Although not a very realistic problem, it does contain a nontrivial deadlock and is probably the most commonly analyzed example [1, 14, 28, 42, 46].
Reference: [12] <author> J. C. Corbett and G. S. Avrunin. </author> <title> Using integer programming to verify general safety and liveness properties. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 6 </volume> <pages> 97-123, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Integer programming has been used in the analysis of certain kinds of deadlocks [34] and in a conservative analysis for general safety and liveness properties <ref> [1, 12] </ref>. These techniques reduce the verification of a property to a question about the integral solutions of linear systems. B. Selecting Methods to Evaluate Of all the techniques available, we selected a partial order state space reduction [20], symbolic model checking [4], and inequality necessary conditions [1] to evaluate. <p> Notice that the inequalities have no integral solution, proving that deadlock is impossible. See <ref> [1, 12] </ref> for details. IV. <p> INCA is descended from the constrained expression toolset [1], but it supports more powerful analysis techniques <ref> [11, 12] </ref> and is more efficient. D. Specifying the Examples Given our decision to use existing implementations of the techniques, we are faced with a problem: each analysis tool has its own unique specification language. We see two solutions to this problem.
Reference: [13] <editor> C. Courcoubetis, editor. </editor> <booktitle> Computer Aided Verification, 5th In ternational Conference Proceedings, </booktitle> <address> Elounda, Greece, </address> <year> 1993. </year>
Reference: [14] <author> S. Duri, U. Buy, R. Devarapalli, and S. M. Shatz. </author> <title> Using state space reduction methods for deadlock analysis in Ada tasking. </title> <booktitle> In Ostrand and Weyuker [36], </booktitle> <pages> pages 51-60. </pages>
Reference-contexts: Dartes Program (DARTES) The communication skele ton of a fairly complex Ada program with 32 tasks [30]. Dining Philosophers (DP, DPH, DPD, DPFM) Although not a very realistic problem, it does contain a nontrivial deadlock and is probably the most commonly analyzed example <ref> [1, 14, 28, 42, 46] </ref>. We model each of the m philosophers and m forks with a task. These tasks synchronize to model forks being acquired and released. In addition to the standard version (DP), which can deadlock, we also analyzed several versions of the problem where deadlock is prevented. <p> The size m version has 2m + 6 tasks. Gas Station (GASNQ, GASQ) This example, which models a self-service gas station, originated in [23] and has been analyzed in <ref> [1, 14, 28, 40] </ref>. Customers arrive and pay the operator for gas. The operator activates a pump, at which the customer then pumps gas. When the customer is finished, the pump reports the amount of gas actually pumped to the operator, who then gives the customer her change. <p> We analyzed two different versions of this example. In the original version (GASQ) from [1, 23], the operator task queues customer requests and must keep track of which customers are waiting for each pump and in what order. In the non-queuing version (GASNQ) from <ref> [14] </ref>, the operator does not enforce a first-come-first-serve order on the customers and must only record the number of customers waiting for each pump in order to activate the pump when any waiting customers remain. <p> Each of the m reader tasks and m writer tasks must synchronize with a controller task before accessing and when finished accessing the database. This system has been analyzed in <ref> [1, 14, 28] </ref>. Sensor Test Program (SENTEST) The communication skeleton of an Ada program analyzed in [30] that starts up m tasks to test sensors. The size m version has m + 4 tasks.
Reference: [15] <author> M. B. Dwyer. </author> <title> Data Flow Analysis for Verifying Correctness Properties of Concurrent Programs. </title> <type> PhD thesis, </type> <institution> University of Massachusetts at Amherst, </institution> <year> 1995. </year>
Reference-contexts: Data flow analysis can be employed to yield a conserva tive analysis of a program's properties, from potential cyclic deadlocks [30] to general safety properties <ref> [15, 16] </ref>. Although these techniques do not really analyze the flow of data in a program, they employ the same algorithms to find the fixed point of a set of flow equations.
Reference: [16] <author> M. B. Dwyer and L. A. Clarke. </author> <title> Data flow analysis for verify ing properties of concurrent programs. </title> <editor> In D. Wile, editor, </editor> <booktitle> Pro ceedings of the Second Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 62-75, </pages> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Data flow analysis can be employed to yield a conserva tive analysis of a program's properties, from potential cyclic deadlocks [30] to general safety properties <ref> [15, 16] </ref>. Although these techniques do not really analyze the flow of data in a program, they employ the same algorithms to find the fixed point of a set of flow equations.
Reference: [17] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Although it may seem that we are using the input language for INCA as the canonical form, we view the front end of INCA only as a tool for constructing the canonical form. INCA constructs the FSA for each task using standard techniques for constructing control flow graphs <ref> [17] </ref>; these automata are very similar to those produced (internally) by SPIN or any other tool that constructs a finite-state representation of the control flow of imperative code.
Reference: [18] <author> R. Ford. </author> <title> Concurrent algorithms for real-time memory manage ment. </title> <journal> IEEE Software, </journal> <pages> pages 10-23, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: We scaled the program by making the number of customer tasks a parameter (m). The size m version has m + 5 tasks. Distributed Memory Manager (MMGT) The communi cation skeleton of an Ada program implementing the memory management scheme from <ref> [18] </ref> with m users. The size m version has m + 4 tasks. Overtake Protocol (OVER) An Ada version of an auto mated highway system overtake protocol in [22] for m cars comprising 2m + 1 tasks.
Reference: [19] <author> P. Godefroid. </author> <title> Partial Order Methods for the Verification of Con current Systems: An Approach to the State Explosion Problem. </title> <type> PhD thesis, </type> <institution> Universite de Liege, </institution> <year> 1994. </year>
Reference-contexts: By firing only one of these transitions, we represent only one possible order of the two events, reducing the number of states generated. See <ref> [19, 20] </ref> for details. D. Symbolic Model Checking Another approach to making deadlock detection more tractable is to use a different representation for M . State-space searches typically generate the states of M explicitly and store them in a hash table.
Reference: [20] <author> P. Godefroid and D. Pirottin. </author> <title> Refining dependencies improves partial-order verification methods. </title> <booktitle> In Courcoubetis [13], </booktitle> <pages> pages 438-449. </pages>
Reference-contexts: Among them: State-space reductions make a standard reachability analysis more efficient by reducing the number of states that must be explored to verify a property. They range from virtual coarsening techniques [29,40], which coalesce internal actions into adjacent external actions, to partial order techniques <ref> [20, 42] </ref>, which alleviate the effects of representing concurrency with interleaving, to symmetry techniques [31, 37] which take advantage of symmetries in the state space. Symbolic model checking [4, 32] uses a symbolic repre sentation of a system's states, which is sometimes much more compact than an explicit enumeration. <p> These techniques reduce the verification of a property to a question about the integral solutions of linear systems. B. Selecting Methods to Evaluate Of all the techniques available, we selected a partial order state space reduction <ref> [20] </ref>, symbolic model checking [4], and inequality necessary conditions [1] to evaluate. We selected these three techniques for several reasons. First, they represent three very different approaches to the state explosion problem and might be expected to perform best on different kinds of systems. <p> Finally, we selected these three techniques because an implementation of each was available to us, as discussed in Section IV-C. In the worst case, the time complexity of all of these techniques is exponential in the size of the system <ref> [1, 4, 20] </ref>. In practice, the techniques may have a much lower complexity on certain kinds of systems. In the remainder of this section, we provide a brief overview of the three techniques selected for evaluation. C. <p> By firing only one of these transitions, we represent only one possible order of the two events, reducing the number of states generated. See <ref> [19, 20] </ref> for details. D. Symbolic Model Checking Another approach to making deadlock detection more tractable is to use a different representation for M . State-space searches typically generate the states of M explicitly and store them in a hash table. <p> Besides requiring much more effort, this approach would likely have produced implementations significantly inferior to those crafted by experts with years of experience with a particular technique. Patrice Godefroid, Didier Pirottin and Pierre Wolper of the University of Liege have implemented a partial order technique <ref> [20] </ref> as an extension to a very fast protocol analyzer called SPIN, which was written by Gerard Holzmann at AT&T Bell Labs [25]. We refer to SPIN with the Partial Order package installed as SPIN+PO.
Reference: [21] <author> P. Godefroid and P. Wolper. </author> <title> Using partial orders for the effi cient verification of deadlock freedom and safety properties. </title> <editor> In K. G. Larsen and A. Skou, editors, </editor> <booktitle> Computer Aided Verification, 3rd International Workshop Proceedings, volume 575 of Lecture Notes in Computer Science, </booktitle> <pages> pages 332-242, </pages> <address> Aalborg, Denmark, July 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: As with the restriction to one class of systems, our restriction to one particular property limits the scope of our results. We note, however, that the verification of any safety property can be reduced to a check for deadlock <ref> [21] </ref>. C. Implementation The implementation of a technique can greatly affect its performance. The developer of a technique has a strong incentive to implement the technique as efficiently as possible in order to demonstrate the technique's effectiveness.
Reference: [22] <author> S. Graf and C. Loiseaux. </author> <title> A tool for symbolic program verification and abstraction. </title> <booktitle> In Courcoubetis [13], </booktitle> <pages> pages 71-84. </pages>
Reference-contexts: Distributed Memory Manager (MMGT) The communi cation skeleton of an Ada program implementing the memory management scheme from [18] with m users. The size m version has m + 4 tasks. Overtake Protocol (OVER) An Ada version of an auto mated highway system overtake protocol in <ref> [22] </ref> for m cars comprising 2m + 1 tasks. Q User Interface (Q) The Ada skeleton of an RPC client/server-based user interface with 18 tasks that is used by several real applications.
Reference: [23] <author> D. Helmbold and D. Luckham. </author> <title> Debugging Ada tasking pro grams. </title> <journal> IEEE Software, </journal> <volume> 2(2) </volume> <pages> 47-57, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: The size m version has 2m + 6 tasks. Gas Station (GASNQ, GASQ) This example, which models a self-service gas station, originated in <ref> [23] </ref> and has been analyzed in [1, 14, 28, 40]. Customers arrive and pay the operator for gas. The operator activates a pump, at which the customer then pumps gas. <p> We analyzed versions with one operator task, two pump tasks, and m customer tasks. We analyzed two different versions of this example. In the original version (GASQ) from <ref> [1, 23] </ref>, the operator task queues customer requests and must keep track of which customers are waiting for each pump and in what order.
Reference: [24] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall International, </publisher> <year> 1985. </year>
Reference-contexts: In Section VI, we explore the extent of the bias by considering different models. F. SPIN Translator Here, we describe the how the communicating FSAs representing a concurrent system were translated into Promela, the input language for SPIN. Promela is a guarded command language like CSP <ref> [24] </ref>, with a C-like syntax. It directly supports communicating processes, thus the translation is relatively straightforward. Each FSA is represented by a process created using the proctype declaration. Each state of the FSA is represented by a statement labeled with the name of the state.
Reference: [25] <author> G. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: Patrice Godefroid, Didier Pirottin and Pierre Wolper of the University of Liege have implemented a partial order technique [20] as an extension to a very fast protocol analyzer called SPIN, which was written by Gerard Holzmann at AT&T Bell Labs <ref> [25] </ref>. We refer to SPIN with the Partial Order package installed as SPIN+PO.
Reference: [26] <author> A. J. Hu and D. L. Dill. </author> <title> Efficient verification with BDDs using implicitly conjoined invariants. </title> <booktitle> In Courcoubetis [13], </booktitle> <pages> pages 3-14. </pages>
Reference-contexts: Second, even for data intensive examples, it is not clear that representing a task's state symbolically with OBDDs, as is done in the EFSA model, will produce better performance than explicitly enumerating the task's states, as in done in the FSA model. Hu and Dill <ref> [26] </ref> report that state enumeration is more efficient than their OBDD-based techniques on most of the real-life protocols they have tried. Finally, we have tried to avoid the use of special purpose techniques for specific kinds of problems in favor of techniques that are generally applicable.
Reference: [27] <author> A. J. Hu, D. L. Dill, A. J. Drexler, and C. H. Yang. </author> <title> Higher-level specification and verification with BDDs. </title> <booktitle> In v. Bochmann and Probst [41], </booktitle> <pages> pages 84-96. </pages>
Reference-contexts: After some experience with the EFSA translators, we were disappointed to find that they produced uniformly worse performance than the FSA translators. We believe it is possible that an improved EFSA translator might produce comparable or better performance for SMV. Hu et al <ref> [27] </ref> have explored the verification of higher-level specifications with OBDDs and use techniques that we have not attempted, such as interleaving the bits of memory cells that are functionally related and partitioning the transition relation. We have decided not to pursue this matter further at this time for several reasons.
Reference: [28] <author> G. M. Karam and R. J. Buhr. </author> <title> Starvation and critical race ana lyzers for Ada. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 16(8) </volume> <pages> 829-843, </pages> <year> 1990. </year>
Reference-contexts: Dartes Program (DARTES) The communication skele ton of a fairly complex Ada program with 32 tasks [30]. Dining Philosophers (DP, DPH, DPD, DPFM) Although not a very realistic problem, it does contain a nontrivial deadlock and is probably the most commonly analyzed example <ref> [1, 14, 28, 42, 46] </ref>. We model each of the m philosophers and m forks with a task. These tasks synchronize to model forks being acquired and released. In addition to the standard version (DP), which can deadlock, we also analyzed several versions of the problem where deadlock is prevented. <p> The size m version has 2m + 6 tasks. Gas Station (GASNQ, GASQ) This example, which models a self-service gas station, originated in [23] and has been analyzed in <ref> [1, 14, 28, 40] </ref>. Customers arrive and pay the operator for gas. The operator activates a pump, at which the customer then pumps gas. When the customer is finished, the pump reports the amount of gas actually pumped to the operator, who then gives the customer her change. <p> Each of the m reader tasks and m writer tasks must synchronize with a controller task before accessing and when finished accessing the database. This system has been analyzed in <ref> [1, 14, 28] </ref>. Sensor Test Program (SENTEST) The communication skeleton of an Ada program analyzed in [30] that starts up m tasks to test sensors. The size m version has m + 4 tasks.
Reference: [29] <author> D. L. Long and L. A. Clarke. </author> <title> Task interaction graphs for con currency analysis. </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 44-52, </pages> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1989. </year>
Reference: [30] <author> S. P. Masticola and B. G. Ryder. </author> <title> Static infinite wait anomaly detection in polynomial time. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing, </booktitle> <volume> volume II, </volume> <pages> pages 78-87, </pages> <year> 1990. </year>
Reference-contexts: Thus an important issue for any conservative analysis is its accuracy : how closely do the behaviors of the model match the behaviors of the program. Data flow analysis can be employed to yield a conserva tive analysis of a program's properties, from potential cyclic deadlocks <ref> [30] </ref> to general safety properties [15, 16]. Although these techniques do not really analyze the flow of data in a program, they employ the same algorithms to find the fixed point of a set of flow equations. <p> Unlike the previous two techniques, however, this kind of technique can yield an inconclusive result (of course, for any technique, an intractable analysis is inconclusive). Different kinds of necessary conditions have been used for deadlock analysis in Ada tasking. Masticola and Ryder <ref> [30] </ref> used dataflow techniques to search for potential cyclic waits. Here, we consider a more general technique that uses linear inequalities. <p> Divide and Conquer (DAC) A program modeling a di vide and conquer computation by forking up to m solver tasks that proceed in parallel [2, 11]. Dartes Program (DARTES) The communication skele ton of a fairly complex Ada program with 32 tasks <ref> [30] </ref>. Dining Philosophers (DP, DPH, DPD, DPFM) Although not a very realistic problem, it does contain a nontrivial deadlock and is probably the most commonly analyzed example [1, 14, 28, 42, 46]. We model each of the m philosophers and m forks with a task. <p> Hartstone Program (HARTSTONE) The communica tion skeleton of an Ada program analyzed in <ref> [30] </ref> in which one task starts and then stops m worker tasks. Keyboard Program (KEY) The communication skeleton of an Ada program analyzed in [30] that manages key-board/screen interaction in a window manager. We scaled the program by making the number of customer tasks a parameter (m). <p> Hartstone Program (HARTSTONE) The communica tion skeleton of an Ada program analyzed in <ref> [30] </ref> in which one task starts and then stops m worker tasks. Keyboard Program (KEY) The communication skeleton of an Ada program analyzed in [30] that manages key-board/screen interaction in a window manager. We scaled the program by making the number of customer tasks a parameter (m). The size m version has m + 5 tasks. <p> Each of the m reader tasks and m writer tasks must synchronize with a controller task before accessing and when finished accessing the database. This system has been analyzed in [1, 14, 28]. Sensor Test Program (SENTEST) The communication skeleton of an Ada program analyzed in <ref> [30] </ref> that starts up m tasks to test sensors. The size m version has m + 4 tasks. Speed Regulation Program (SPEED) The com munication skeleton of an Ada program analyzed in [30] with 10 tasks that monitor and regulate the speed of a car. B. <p> Sensor Test Program (SENTEST) The communication skeleton of an Ada program analyzed in <ref> [30] </ref> that starts up m tasks to test sensors. The size m version has m + 4 tasks. Speed Regulation Program (SPEED) The com munication skeleton of an Ada program analyzed in [30] with 10 tasks that monitor and regulate the speed of a car. B.
Reference: [31] <author> C. E. McDowell. </author> <title> A practical algorithm for static analysis of par allel programs. </title> <journal> Journal of Parallel and Distributed Processing, </journal> <volume> 6(3) </volume> <pages> 515-536, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: They range from virtual coarsening techniques [29,40], which coalesce internal actions into adjacent external actions, to partial order techniques [20, 42], which alleviate the effects of representing concurrency with interleaving, to symmetry techniques <ref> [31, 37] </ref> which take advantage of symmetries in the state space. Symbolic model checking [4, 32] uses a symbolic repre sentation of a system's states, which is sometimes much more compact than an explicit enumeration. These techniques have proven especially successful in verifying hardware.
Reference: [32] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1993. </year>
Reference-contexts: They range from virtual coarsening techniques [29,40], which coalesce internal actions into adjacent external actions, to partial order techniques [20, 42], which alleviate the effects of representing concurrency with interleaving, to symmetry techniques [31, 37] which take advantage of symmetries in the state space. Symbolic model checking <ref> [4, 32] </ref> uses a symbolic repre sentation of a system's states, which is sometimes much more compact than an explicit enumeration. These techniques have proven especially successful in verifying hardware. <p> The OBDD for R can be used to check for reachable states with certain properties (e.g., deadlock). In fact, model checking of temporal logic formulas can be performed in this framework without ever constructing an explicit representation of M . See <ref> [4, 32] </ref> for details. E. Inequality Necessary Conditions Yet another approach to making deadlock detection more tractable is to forgo any representation of the state space. <p> Kenneth McMillan of Cadence Systems has implemented the Symbolic Model Verifier (SMV) <ref> [32] </ref>. Both of these tools are publicly available, stable, and reasonably robust. Unfortunately, the Inequality Necessary Condition Analyzer (INCA), like many research tools, has none of these desirable properties, but since we constructed most of the components that are currently in use, this was not a problem. <p> First, we use an interleaving model of concurrency rather than a simultaneous model (in which multiple actions can occur simultaneously). OBDD-based techniques generally perform better on simultaneous models, although this depends on the communication structure of the system <ref> [32] </ref>. Second, the encoding of task variable values within a monolithic task state may increase the size of the OBDDs needed to represent the transition relation of the task's FSA. We elaborate on this second effect. <p> If this function returns true for a pair of states (s; s 0 ), then there is a transition from state s to state s 0 . Finally, the SPEC part is a temporal logic formula in the logic CTL <ref> [32] </ref> specifying a property that the system must satisfy. We represent a set of communicating FSAs as follows. For each M i , we declare a state variable x i to hold its current state. <p> In an interleaving model, events are totally ordered, thus exactly one event occurs at each step. In a simultaneous model, many events may occur simultaneously. OBDD-based techniques tend to perform better on simultaneous models <ref> [32] </ref>, especially when the number of asynchronous processes is large.
Reference: [33] <author> R. Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: We obtained the communication skeleton from the Concurrent Systems Software Laboratory at the University of Illinois at Chicago (as indicated in Table I, the skeleton is only 247 lines). The example has 15 tasks, but the skeleton of each is relatively simple. Cyclic scheduler (CYCLIC) Milner's cyclic scheduler <ref> [7, 33] </ref> uses m scheduler tasks to keep m customer tasks loosely synchronized. Divide and Conquer (DAC) A program modeling a di vide and conquer computation by forking up to m solver tasks that proceed in parallel [2, 11].
Reference: [34] <author> T. Murata, B. Shenker, and S. M. Shatz. </author> <title> Detection of Ada static deadlocks using Petri net invariants. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 15(3) </volume> <pages> 314-326, </pages> <year> 1989. </year>
Reference-contexts: Although these techniques do not really analyze the flow of data in a program, they employ the same algorithms to find the fixed point of a set of flow equations. Integer programming has been used in the analysis of certain kinds of deadlocks <ref> [34] </ref> and in a conservative analysis for general safety and liveness properties [1, 12]. These techniques reduce the verification of a property to a question about the integral solutions of linear systems. B.
Reference: [35] <author> L. Osterweil and L. Clarke. </author> <title> A proposed testing and analysis research initiative. </title> <journal> IEEE Software, </journal> <pages> pages 89-96, </pages> <month> Sept. </month> <year> 1992. </year>
Reference: [36] <editor> T. Ostrand and E. Weyuker, editors. </editor> <booktitle> Proceedings of the 1993 International Symposium on Software Testing and Analysis (IS-STA), </booktitle> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference: [37] <author> P. H. Starke. </author> <title> Reachability analysis of Petri nets using symme tries. Systems Analysis, </title> <booktitle> Modeling, and Simulation, </booktitle> <volume> 8 </volume> <pages> 293-303, </pages> <year> 1991. </year>
Reference-contexts: They range from virtual coarsening techniques [29,40], which coalesce internal actions into adjacent external actions, to partial order techniques [20, 42], which alleviate the effects of representing concurrency with interleaving, to symmetry techniques <ref> [31, 37] </ref> which take advantage of symmetries in the state space. Symbolic model checking [4, 32] uses a symbolic repre sentation of a system's states, which is sometimes much more compact than an explicit enumeration. These techniques have proven especially successful in verifying hardware.
Reference: [38] <author> L. J. Stockmeyer and A. R. Meyer. </author> <title> Word problems requiring exponential time. </title> <booktitle> In Proceedings of the Fifth ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 1-9, </pages> <year> 1973. </year>
Reference: [39] <author> W. Tichy, N. Habermann, and L. </author> <title> Prechelt. </title> <booktitle> Summary of the Dagstuhl workshop on future directions in software engineering. ACM Sigsoft, </booktitle> <month> Jan. </month> <year> 1993. </year>
Reference: [40] <author> S. Tu, S. M. Shatz, and T. Murata. </author> <title> Theory and application of Petri net reduction for Ada-tasking deadlock analysis. </title> <type> Technical Report 91-15, </type> <institution> EECS Department, University of Illinois, Chicago, </institution> <year> 1991. </year>
Reference-contexts: The size m version has 2m + 6 tasks. Gas Station (GASNQ, GASQ) This example, which models a self-service gas station, originated in [23] and has been analyzed in <ref> [1, 14, 28, 40] </ref>. Customers arrive and pay the operator for gas. The operator activates a pump, at which the customer then pumps gas. When the customer is finished, the pump reports the amount of gas actually pumped to the operator, who then gives the customer her change.
Reference: [41] <editor> G. v. Bochmann and D. K. Probst, editors. </editor> <booktitle> Computer Aided Verification, 4th International Workshop Proceedings, volume 663 of Lecture Notes in Computer Science, </booktitle> <address> Montreal, Canada, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference: [42] <author> A. Valmari. </author> <title> A stubborn attack on state explosion. </title> <editor> In E. M. Clarke and R. P. Kurshan, editors, </editor> <title> Computer-Aided Verification '90, </title> <journal> number 3 in DIMACS Series in Discrete Mathematics 22 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, </journal> <volume> VOL. 22, NO. 3, </volume> <booktitle> MARCH 1996 and Theoretical Computer Science, </booktitle> <pages> pages 25-41, </pages> <address> Providence, RI, 1991. </address> <publisher> American Mathematical Society. </publisher>
Reference-contexts: Among them: State-space reductions make a standard reachability analysis more efficient by reducing the number of states that must be explored to verify a property. They range from virtual coarsening techniques [29,40], which coalesce internal actions into adjacent external actions, to partial order techniques <ref> [20, 42] </ref>, which alleviate the effects of representing concurrency with interleaving, to symmetry techniques [31, 37] which take advantage of symmetries in the state space. Symbolic model checking [4, 32] uses a symbolic repre sentation of a system's states, which is sometimes much more compact than an explicit enumeration. <p> Dartes Program (DARTES) The communication skele ton of a fairly complex Ada program with 32 tasks [30]. Dining Philosophers (DP, DPH, DPD, DPFM) Although not a very realistic problem, it does contain a nontrivial deadlock and is probably the most commonly analyzed example <ref> [1, 14, 28, 42, 46] </ref>. We model each of the m philosophers and m forks with a task. These tasks synchronize to model forks being acquired and released. In addition to the standard version (DP), which can deadlock, we also analyzed several versions of the problem where deadlock is prevented.
Reference: [43] <author> W. J. Yeh and M. Young. </author> <title> Compositional reachability analy sis using process algebra. </title> <booktitle> In Proceedings of the Symposium on Testing, Analysis, and Verification (TAV4), </booktitle> <pages> pages 178-187, </pages> <address> New York, </address> <month> Oct. </month> <year> 1991. </year> <institution> ACM SIGSOFT, Association for Computing Machinery. </institution>
Reference: [44] <author> W. J. Yeh and M. Young. </author> <title> Compositional analysis of Ada pro grams using process algebra. </title> <type> Technical report, </type> <institution> Software Engineering Research Center, Department of Computer Science, Purdue University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: This can be expressed as: accept CHARGE ( P : PUMP) do assume WAITING (P) &gt; 0; ... end CHARGE; The assume statement is modeled after the assuming clause used by Yeh and Young in <ref> [44] </ref>. Although we believe all of our examples except the standard dining philosophers (DP) are free of deadlocks, our models of the Ada programs DARTES, KEY, and SPEED contain spurious deadlocks due to the presence of a global variable used for synchronizing task termination.
Reference: [45] <author> W. J. Yeh and M. Young. </author> <title> Redesigning tasking structures of Ada programs for analysis: A case study. Journal of Software Testing, Verification, and Reliability, </title> <month> December </month> <year> 1994. </year>
Reference-contexts: Our version is an abstraction of the original program, which was too complex to analyze. The size m version has m + 8 tasks. Remote Furnace Program (FURNACE) This program manages temperature data collection for m furnaces. We analyze the original design presented in <ref> [45] </ref> abstracted slightly (e.g., we do not model the temperature data using the furnace identifier since we are only verifying freedom from deadlock, not proper transmission of data). The size m version has 2m + 6 tasks.

References-found: 45

