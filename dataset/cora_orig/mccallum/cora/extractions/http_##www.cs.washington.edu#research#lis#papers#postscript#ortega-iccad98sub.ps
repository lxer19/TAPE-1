URL: http://www.cs.washington.edu/research/lis/papers/postscript/ortega-iccad98sub.ps
Refering-URL: http://www.cs.washington.edu/research/projects/lis/chinook/www/publications.html
Root-URL: 
Email: -ortega,gaetano-@cs.washington.edu  
Title: Communication Synthesis for Distributed Embedded Systems Designers of distributed embedded systems face many challenges in
Author: Ross B. Ortega and Gaetano Borriello 
Date: Abstract  
Address: Box 352350  Seattle, WA 98195-2350 USA  
Affiliation: Department of Computer Science and Engineering,  University of Washington,  
Note: submitted to the 1998 International Conference on Computer-Aided Design  
Abstract-found: 0
Intro-found: 1
Reference: [1] <institution> SAE 81C90/91 Stand Alone Full CAN Controller, Preliminary Data. Siemens, </institution> <year> 1996. </year>
Reference-contexts: If the processor has built-in support for a bus protocol, then the given interface to this internal peripheral only requires software instructions to access the particular control registers. However, it may be necessary to use an external communications chip such as the SAE 81C90 <ref> [1] </ref>. In [3] and [2] it was shown how to automatically connect peripheral devices to a microprocessor by synthesizing any necessary glue logic and reflecting the new hardware interface to the device in the low-level device-driver.
Reference: [2] <author> P. Chou, R. Ortega, and G. Borriello. </author> <booktitle> Synthesis of the hardware/software interface in microcontroller-based systems. In Proceedings of the International Conference on Computer Aided Design , November 1992. </booktitle>
Reference-contexts: If the processor has built-in support for a bus protocol, then the given interface to this internal peripheral only requires software instructions to access the particular control registers. However, it may be necessary to use an external communications chip such as the SAE 81C90 [1]. In [3] and <ref> [2] </ref> it was shown how to automatically connect peripheral devices to a microprocessor by synthesizing any necessary glue logic and reflecting the new hardware interface to the device in the low-level device-driver.
Reference: [3] <author> P.H. Chou, R.B. Ortega, and G. Borriello. </author> <title> Interface co-synthesis techniques for embedded systems. </title> <booktitle> In Proceedings of the International Conference on Computer Aided Design , November 1995. </booktitle>
Reference-contexts: If the processor has built-in support for a bus protocol, then the given interface to this internal peripheral only requires software instructions to access the particular control registers. However, it may be necessary to use an external communications chip such as the SAE 81C90 [1]. In <ref> [3] </ref> and [2] it was shown how to automatically connect peripheral devices to a microprocessor by synthesizing any necessary glue logic and reflecting the new hardware interface to the device in the low-level device-driver.
Reference: [4] <author> J-M. Daveau, G.F. Marchioro, T.Ben-Ismail, and A.A. Jerraya. </author> <title> Protocol selection and interface generation for hw-sw codesign. </title> <booktitle> IEEE Trans. on Very Large Scale Integration </booktitle> (5)1:136-144, March 1997. 
Reference-contexts: Vahid and Tauro [18] and Ernst and Benner [5] both proposed using a communication library with a standard API (Application Program Interface). However, protocols based on message priorities require a unique allocation of all the priorities on the bus in addition to providing an API. Daveau . <ref> [4] </ref> take a behavioral description and automatically select a protocol from a library to implement the communication. They use nonstandard low-level protocols such as bidirectional handshake and dual fifo.
Reference: [5] <author> R. Ernst and T. Benner. </author> <title> Communication, constraints, and user-directives in COSYMA. </title> <type> Technical Report TM CY-94-2, </type> <institution> Technical University of Braunschweig, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: These efforts either do not consider the global properties of the communication links or consider the global properties but map to one nonstandard protocol. Vahid and Tauro [18] and Ernst and Benner <ref> [5] </ref> both proposed using a communication library with a standard API (Application Program Interface). However, protocols based on message priorities require a unique allocation of all the priorities on the bus in addition to providing an API.
Reference: [6] <author> D. Gajski, F. Vahid, S. Narayan, and J. Gong. </author> <title> Specification and Design of Embedded Systems . Prentice-Hall, </title> <address> Englewood Cliffs, NJ, </address> <year> 1994. </year>
Reference-contexts: Daveau . [4] take a behavioral description and automatically select a protocol from a library to implement the communication. They use nonstandard low-level protocols such as bidirectional handshake and dual fifo. Gajski . <ref> [6] </ref> consider all of the events on the bus, but they implement a simple low-level bus protocol and do not address real-time kernel synthesis. Yen and Wolf [19] address the problem of heterogeneous processors connected via arbitrary bus topologies.
Reference: [7] <author> M. Gasteier and M. Glesner. </author> <title> Bus-based communication synthesis on system-level. </title> <booktitle> In Proceedings of the International Symposium on System Synthesis vember, </booktitle> <year> 1996. </year>
Reference-contexts: Yen and Wolf [19] address the problem of heterogeneous processors connected via arbitrary bus topologies. However, they discount standard protocols as uncommon in embedded systems and assume an abstract protocol based on processor priorities. Gasteier and Glesner <ref> [7] </ref> attempt to synthesize busses that do not require arbitration. This approach is more suitable for data-flow oriented systems that have more predictable communication patterns than for control-dominated systems. All of these approaches attempt to synthesize the bus topology.
Reference: [8] <author> K. Hines and G. Borriello. </author> <title> Dynamic communication model in embedded system co-simulation. </title> <booktitle> In Proceedings of the 34th Design Automation Conference 395-400, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: All of the remaining details of system communication are automatically synthesized. The effect is that an application-specific real-time operating system is generated for each processor in the system. The communication synthesis tool has been fully integrated with a system co-simulator <ref> [8] </ref> to quickly provide designers with performance information for a given mapping. Throughout this paper we will use the example of the robot control system shown in Figure 4. The robot has two fundamental modes of operation.
Reference: [9] <author> D.D. Kandlur, K.G. Shin, and D. Ferrari. </author> <title> Real-time communication in multihop networks. </title> <journal> IEEE Trans. on Parallel and Distributed Systems October, </journal> <year> 1994. </year>
Reference-contexts: All of these approaches attempt to synthesize the bus topology. There has also been work done in the area of scheduling messages in a multiprocessor environment to meet real-time and quality of service constraints <ref> [9] </ref>. Message scheduling globally analyzes the communication requirements of the system in order to create an effective scheduler. However it is assumed that there is a simple API providing access to the bus. <p> In the robot, all command messages have an overwrite policy without notification. Only the logger process has a queuing policy with notification. This particular notification routine simply records that data was lost. Similar to <ref> [9] </ref> various message attributes must be specified to enable global analysis. These attributes include the maximum size of any message generated on an outport, the maximum frequency at which the messages may be generated, and a required response-time constraint.
Reference: [10] <author> H. Kopetz et al. </author> <title> Distributed fault-tolerant real-time systems: the Mars approach. </title> <note> IEEE Micro February 1989 </note>
Reference-contexts: The model is based on a set of processes that communicate by exchanging non-blocking messages. A non-blocking protocol is more appropriate for distributed real-time systems than a blocking protocol <ref> [10] </ref> partly because it decouples computation from communication. When a process executes a message send it returns immediately after passing the message to the real-time kernel. Messages from other processors are received asynchronously via an interrupt indicating a message arrival.
Reference: [11] <author> A.H. Mebane IV, J.R. Schmedake, I-S Chen, </author> <title> and A.P. Kadonaga. Electronic and firmware design of the HP LaserJet Drafting Plotter. </title> <journal> Hewlett-Packard Journal 43(6) </journal> <pages> 16-23, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: These systems are characterized by having heterogeneous processors connected by heterogeneous busses. For instance, an HP LaserJet design has three different processors and 2 different busses connecting the processors as well as many point to point connections <ref> [11] </ref>. The designers selected the most appropriate connections between the processors based upon the communication requirements of the functions mapped to each processor. Designers of distributed systems are faced with many choices in connecting the various processors together.
Reference: [12] <author> R.B. Ortega and G. Borriello. </author> <title> Communication synthesis for embedded systems with global considerations. </title> <booktitle> In Proceedings of the 5th International Workshop on Hardware/Software Codesign , March 1997. </booktitle>
Reference: [13] <institution> I 2 C Peripherals for Microcontrollers. Philips Semiconductors, </institution> <year> 1992. </year>
Reference: [14] <author> R. Rajkumar, L. Sha. and J.P. Lehoczky. </author> <title> Real-time synchronization protocols for multiprocessors. </title> <booktitle> In Pro ceedings of the Real-Time Systems Symposium , Dec. </booktitle> <year> 1988. </year>
Reference-contexts: A handler is a subroutine invoked to perform a service on behalf of a message. The typical handler consumes the triggering message, modifies state variables, generates outgoing messages and terminates. A handler may only run for a bounded amount of time and executes with completion semantics <ref> [14] </ref>. That is, once a handler begins executing it has the illusion of running without preemption. No other handlers from the same process may begin until the currently running handler terminates. <p> The actual communication flow automatically generated is show by the solid lines. submitted to the 1998 International Conference on Computer-Aided Design ties are broken arbitrarily but consecutively allocated. Because of priority inversion <ref> [14] </ref>, processor-based priorities are problematic for real-time systems and give the least flexibility to the synthesis tool. For example, consider a process that generates an infrequent and short deadline message M , but normally generates long deadline message M .
Reference: [15] <author> B. Selic, G. Gullekson, and P.T. </author> <title> Ward. </title> <publisher> Real-Time Ob ject-Oriented Modeling . John Wiley & Sons, </publisher> <year> 1994. </year>
Reference: [16] <author> K. Tindell and A. Burns. </author> <title> Guaranteed message latencies for distributed safety-critical hard real-time control networks. </title> <type> Technical Report YCS-94-229, </type> <institution> University of York, </institution> <year> 1994. </year>
Reference-contexts: The communication synthesis tool must distribute this deadline along the messages path so that the protocol parameters for all messages can be effectively determined. Previous work in determining the worst-case delay for transmitting a message such as <ref> [16] </ref> require restrictions which are incompatible with our communication model. For example, the assumption that a messages timing constraint must be less than the period of the sending process implies that a message can only have a send queue depth of one.
Reference: [17] <author> B.P. Upender and P.J. Koopman Jr. </author> <title> Communication protocols for embedded systems. </title> <booktitle> Embedded Systems Programming , 7(11) </booktitle> <pages> 46-58, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: The designers selected the most appropriate connections between the processors based upon the communication requirements of the functions mapped to each processor. Designers of distributed systems are faced with many choices in connecting the various processors together. Upender and Koopman <ref> [17] </ref> list many standard bus protocols commonly used in embedded systems. It is increasingly attractive for designers to choose a known protocol instead of creating an arbitrary or proprietary one. Microprocessors targeted toward the embedded market incorporate support for the most popular protocols directly on chip. <p> The first step groups all of the messages that will be sent on a particular bus. Protocol attributes are assigned to the messages and processors based on the arbitration scheme of the bus. We have modified the taxonomy in <ref> [17] </ref> to focus on the attributes which are required for protocol synthesis. Our taxonomy considers protocols that base arbitration on message priority, processor priority, master/ slave, time, time/processor priority hybrid, and non-priority schemes.
Reference: [18] <author> F. Vahid and L. Tauro. </author> <title> An object-oriented communi cation library for hardware-software codesign. </title> <booktitle> In Proceedings of the 5th International Workshop on Hardware/Software Codesign , March 1997. </booktitle>
Reference-contexts: Recently there has been much attention focused on the problem of communication synthesis for distributed real-time embedded systems. These efforts either do not consider the global properties of the communication links or consider the global properties but map to one nonstandard protocol. Vahid and Tauro <ref> [18] </ref> and Ernst and Benner [5] both proposed using a communication library with a standard API (Application Program Interface). However, protocols based on message priorities require a unique allocation of all the priorities on the bus in addition to providing an API.
Reference: [19] <author> T.-Y. Yen and W. Wolf. </author> <title> Communication synthesis for distributed systems. </title> <booktitle> In Proceedings of the Internation al Conference on Computer Aided Design , November 1995. </booktitle>
Reference-contexts: They use nonstandard low-level protocols such as bidirectional handshake and dual fifo. Gajski . [6] consider all of the events on the bus, but they implement a simple low-level bus protocol and do not address real-time kernel synthesis. Yen and Wolf <ref> [19] </ref> address the problem of heterogeneous processors connected via arbitrary bus topologies. However, they discount standard protocols as uncommon in embedded systems and assume an abstract protocol based on processor priorities. Gasteier and Glesner [7] attempt to synthesize busses that do not require arbitration.
Reference: [20] <author> H. Zeltwanger. </author> <title> An inside look at the fundamentals of CAN. </title> <booktitle> Control Engineering , 42(1), </booktitle> <month> January </month> <year> 1995. </year>
References-found: 20

