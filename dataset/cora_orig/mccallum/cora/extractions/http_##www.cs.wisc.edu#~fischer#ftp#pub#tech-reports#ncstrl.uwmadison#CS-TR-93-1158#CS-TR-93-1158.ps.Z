URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-93-1158/CS-TR-93-1158.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-93-1158/
Root-URL: http://www.cs.wisc.edu
Email: adams@cs.wisc.edu  solomon@cs.wisc.edu  
Title: POL: Persistent Objects with Logic  
Author: Paul Adams and Marvin Solomon 
Abstract: POL is a combination of elements from three domains: object-oriented programming, logic programming, and database. POL integrates these domains using a shared data model and a close coupling of an existing object-oriented language, C++, with a logic-programming language called Congress. We describe the components of POL, with particular emphasis on the interaction between the object-oriented features of C++ and the logic-based features of Congress. We then illustrate the power of POL with three sample applications: a C++ program database, a bibliographic database, and a Unix-compatible file system for software configuration. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. At-Kaci and R. Nasr, </author> <title> LOGIN: A Logic Programming Language with Built-In Inheritance, </title> <journal> Journal of Logic Programming, </journal> <month> Mar. </month> <year> 1986, </year> <pages> 181-215. </pages>
Reference-contexts: POL derives its object-oriented features from C++ [9] (2.2), persistence from the Exodus database toolkit [5] (2.3), and logic-based features from Congressa new language derived from Prolog [6] and LOGIN <ref> [1] </ref> (2.4). <p> Since Congress is implemented as a library of classes, any C++ program can use Congress as a higher level alternative to or enhancement of the raw C++ term interface. As a logic-programming language, Congress is a dialect of LOGIN <ref> [1] </ref>, an extension of Prolog supporting cyclic terms. It provides transparent persistence, and extends the valued-based semantics of Prolog with the ability to manipulate the identity of (data) nodes. <p> The heart of this process is the definition of matching between terms, called unification. 4 Congress uses a variant of unification that supports cyclic terms <ref> [1] </ref>. The goal of unification is to determine if two terms are isomorphic, or can be made isomorphic by substituting terms for variables. Two terms unify if their roots match (have the same functor) and corresponding successors (recursively) unify. <p> Each language can be viewed as an embedded sublanguage of the other. Section 3.1 describes C++ access to the data and control structures of Congress. Access hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 3 It also has a rather subtle effect on the definition of unification. See the LOGIN paper <ref> [1] </ref> for details. 4 Background material on unification can be found in many logic programming texts and in an excellent survey by Knight [15]. 5 Copies are used to preserve the meaning of clauses as universally quantified formul. This copying is called renaming the variables apart in logic-programming literature.
Reference: [2] <author> P. Adams and M. Solomon, </author> <title> An Overview of the CAPITL Software Development Environment, </title> <booktitle> Fourth International Workshop on Software Configuration Management, </booktitle> <address> Baltimore, MD, </address> <year> 1993. </year> <note> Also available as University of WisconsinMadison Computer Sciences Technical Report 1143, </note> <month> April </month> <year> 1993. </year>
Reference-contexts: These two applications have been designed but not actually implemented. The third example is an actual working system, the attributed filesystem used in the CAPITL software development environ ment. It is outlined here and described in considerably more detail elsewhere <ref> [2] </ref>. 4.1. C++ Design Constraints The first example is inspired by a system called Clear++ [8]. <p> The CAPITL Object-base We have used POL to build a database of objects or object-base as part of the CAPITL (Computer Aided Programming In The Large) <ref> [2] </ref> project. The CAPITL object-base can be considered an enhanced version of the Unix file system: More types of objects are supported, the set of attributes of an object is extensible, complex relationships among objects can be represented directly, and versioning of the entire database is efficiently supported.
Reference: [3] <author> M. P. Atkinson and O. P. Buneman, </author> <title> Type and Persistence in Database Programming Languages, </title> <journal> Computing Surveys 19, </journal> <month> 2 (June </month> <year> 1987), </year> <pages> 105-190. </pages>
Reference-contexts: Simpler approaches use a relational database as a repository for facts and couple that repository with an existing Prolog implementation [13]. Our approach is closest to that of Moffat and Gray [19] who implement Pro-log in the persistent language PS-ALGOL <ref> [3] </ref>. We differ from them by giving external predicates the possibility of backtracking. 6. Status and Future Work A prototype of POL is working and has been tested extensively during the construction of CAPITL.
Reference: [4] <author> T. A. Budd, </author> <title> Blending Imperative and Relational Programming, </title> <booktitle> IEEE Software 8, </booktitle> <month> 1 (Jan. </month> <year> 1991), </year> <pages> 58-65. </pages>
Reference-contexts: An alternative is to add logic programming features to an object-oriented language by extending the behavior of the object-oriented language 9 with Horn clause predicates <ref> [4, 12, 14] </ref>. This extension allows a tighter integration of the languages in which class methods may be written in a logic style. A third alternative is to take two existing languages and create a bridge between them. The power of this approach is constrained by the bridge.
Reference: [5] <author> M. Carey, D. DeWitt, G. Graefe, D. Haight, J. Richardson, D. Schuh, E. Shekita and S. Vandenberg, </author> <title> The EXODUS Extensible DBMS Project: An Overview, in Readings in Object-Oriented Databases, </title> <editor> S. Zdonik and D. Maier (ed.), Morgan-Kaufman, </editor> <year> 1990. </year>
Reference-contexts: By combining features from all three domains, POL provides an environment in which application programmers can take advantage of the particular style that best suits the problem at hand. POL derives its object-oriented features from C++ [9] (2.2), persistence from the Exodus database toolkit <ref> [5] </ref> (2.3), and logic-based features from Congressa new language derived from Prolog [6] and LOGIN [1] (2.4). <p> C++ subclass derivation is used to add additional behavior and restrictions to classes of internal nodes. We shall return to this point in Sections 3 and 4. 2.3. Exodus Exodus <ref> [5] </ref> is a toolkit for creating custom database systems. POL uses two components of Exodus, a low-level storage subsystem called the Exodus Storage Manager and a persistent dialect of C++ called E.
Reference: [6] <author> W. F. Clocksin and C. S. Mellish, </author> <title> Programming in Prolog, </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1984. </year>
Reference-contexts: POL derives its object-oriented features from C++ [9] (2.2), persistence from the Exodus database toolkit [5] (2.3), and logic-based features from Congressa new language derived from Prolog <ref> [6] </ref> and LOGIN [1] (2.4).
Reference: [7] <author> J. R. Driscol, N. Sarnak, D. D. Sleator and R. E. Tarjan, </author> <title> Making Data Structures Persistent, </title> <journal> Journal of Computer and System Sciences 38, </journal> <month> 1 (Feb. </month> <year> 1989), </year> <pages> 86-124. </pages>
Reference-contexts: The program subspace is read-only from Congress. All terms in the term space are persistent. POL assists with managing changes to the term space by supporting multiple versions of the term space called worlds using an algorithm devised by Driscol et. al. <ref> [7] </ref>. POL has operations to save the current term space as a world, and to reset its state to any previously saved world.
Reference: [8] <author> C. K. Duby, S. Meyers and S. P. Reiss, CCEL: </author> <title> A Metalanguage for C++, </title> <booktitle> USENIX C++ Workshop, </booktitle> <year> 1992. </year>
Reference-contexts: The third example is an actual working system, the attributed filesystem used in the CAPITL software development environ ment. It is outlined here and described in considerably more detail elsewhere [2]. 4.1. C++ Design Constraints The first example is inspired by a system called Clear++ <ref> [8] </ref>. In the authors' words, C++ is an expressive language, but it does not allow software developers to say all the things about their systems that Adams and Solomon POL Page 14 they need to be able to say.
Reference: [9] <author> M. Ellis and B. Stroustrup, </author> <title> The Annotated C++ Reference Manual, </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <year> 1990. </year>
Reference-contexts: By combining features from all three domains, POL provides an environment in which application programmers can take advantage of the particular style that best suits the problem at hand. POL derives its object-oriented features from C++ <ref> [9] </ref> (2.2), persistence from the Exodus database toolkit [5] (2.3), and logic-based features from Congressa new language derived from Prolog [6] and LOGIN [1] (2.4).
Reference: [10] <author> K. Fukunaga and S. Hirose, </author> <title> An Experience with a Prolog-based Object-Oriented Language, </title> <booktitle> OOPSLA '86 Proceedings, </booktitle> <month> Sep. </month> <year> 1986, </year> <pages> 224-231. </pages>
Reference-contexts: One approach to combining logic and object-oriented programming is to add object-oriented features to a logic programming language. For example, Prolog might be extended with built-in operators for declaring classes and inheritance and explicit send and receive predicates for method invocation <ref> [10, 28] </ref>. An advantage of this approach is that it uses Prolog implementations, but it is unable to blend the procedural mechanisms of traditional object-oriented languages with the backtracking search of Prolog.
Reference: [11] <editor> H. Gallaire, J. Minker and J. Nicolas, </editor> <title> Logic and Databases: A Deductive Approach, </title> <journal> Computing Surveys 16, </journal> <month> 2 (June </month> <year> 1984), </year> <pages> 153-185. </pages>
Reference-contexts: One approach focuses on the logic capabilities of the language and usually restricts the data types to avoid function symbols. Here the key idea is to extend relational databases with inferencing. A good survey of this approach can be found in Gallaire et al <ref> [11] </ref>. Simpler approaches use a relational database as a repository for facts and couple that repository with an existing Prolog implementation [13]. Our approach is closest to that of Moffat and Gray [19] who implement Pro-log in the persistent language PS-ALGOL [3].
Reference: [12] <author> M. H. Ibrahim and F. A. Cummins, KSL/Logic: </author> <title> Integration of Logic with Objects, </title> <booktitle> IEEE International Conference on Computer Languages, </booktitle> <month> Mar. </month> <year> 1990, </year> <pages> 228-235. </pages>
Reference-contexts: An alternative is to add logic programming features to an object-oriented language by extending the behavior of the object-oriented language 9 with Horn clause predicates <ref> [4, 12, 14] </ref>. This extension allows a tighter integration of the languages in which class methods may be written in a logic style. A third alternative is to take two existing languages and create a bridge between them. The power of this approach is constrained by the bridge.
Reference: [13] <author> Y. E. Ioannidis and M. M. Tsangaris, </author> <title> The Design, Implementation, and Performance Evaluation of Ber-muda, </title> <institution> University of Wisconsin-Madison Tech Report #973, </institution> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: Here the key idea is to extend relational databases with inferencing. A good survey of this approach can be found in Gallaire et al [11]. Simpler approaches use a relational database as a repository for facts and couple that repository with an existing Prolog implementation <ref> [13] </ref>. Our approach is closest to that of Moffat and Gray [19] who implement Pro-log in the persistent language PS-ALGOL [3]. We differ from them by giving external predicates the possibility of backtracking. 6.
Reference: [14] <author> Y. Ishikawa and M. Tokoro, </author> <title> A Concurrent Object-Oriented Knowledge Representation Language Orient84/K: Its Features and Implementation, </title> <booktitle> OOPSLA '86 Proceedings, </booktitle> <month> Sep. </month> <year> 1986, </year> <pages> 232-241. </pages>
Reference-contexts: An alternative is to add logic programming features to an object-oriented language by extending the behavior of the object-oriented language 9 with Horn clause predicates <ref> [4, 12, 14] </ref>. This extension allows a tighter integration of the languages in which class methods may be written in a logic style. A third alternative is to take two existing languages and create a bridge between them. The power of this approach is constrained by the bridge.
Reference: [15] <author> K. Knight, </author> <title> Unification: A Multidisciplinary Survey, </title> <journal> ACM Computing Surveys 21, </journal> <month> 1 (Mar. </month> <year> 1989), </year> <pages> 93-124. </pages>
Reference-contexts: Access hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 3 It also has a rather subtle effect on the definition of unification. See the LOGIN paper [1] for details. 4 Background material on unification can be found in many logic programming texts and in an excellent survey by Knight <ref> [15] </ref>. 5 Copies are used to preserve the meaning of clauses as universally quantified formul. This copying is called renaming the variables apart in logic-programming literature. Adams and Solomon POL Page 6 to the data and control structures of C++ from Congress is described in Sections 3.2 and 3.3, respectively.
Reference: [16] <author> T. Koschmann and M. W. Evens, </author> <title> Bridging the Gap between Object-Oriented and Logic Programming, </title> <booktitle> IEEE Software 5, </booktitle> <month> 4 (July </month> <year> 1988), </year> <pages> 36-42. </pages> <note> Adams and Solomon POL Page 21 </note>
Reference-contexts: A third alternative is to take two existing languages and create a bridge between them. The power of this approach is constrained by the bridge. For instance, the bridge described by Koschmann and Evans <ref> [16] </ref> implements function calls between LOOPS and Prolog, so LOOPS programmers can write methods in Prolog and Prolog programmers can access LOOPS objects. However, their bridge does not permit backtracking between the two languages and relies on the special hardware of a Lisp/Prolog machine.
Reference: [17] <author> S. B. Lippman, </author> <title> C++ Primer, Second Edition, </title> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: We assume the reader has a basic reading knowledge of C++. Our examples will avoid the more exotic features of the language. Excellent texts on C++ have been written by Stroustrup [25] and Lippman <ref> [17] </ref>. C++ classes are used in POL to provide a concrete realization of term space nodes and arcs. All classes are derived from the abstract base class Term which represents a node and its outgoing arcs. Subclasses are Atomic and InternalNode. Atomic nodes have no outgoing arcs.
Reference: [18] <author> S. Manchanda and D. S. Warren, </author> <title> A Logic-based Language for Database Updates, in Foundations of Deductive Databases, </title> <editor> J. Minker (ed.), </editor> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1987, </year> <pages> 363-394. </pages>
Reference-contexts: We are investigating a semantics that is more denotational and less bound to implementation details through introduction of an explicit sequential operator similar to that of Warren and Manchanda <ref> [18] </ref> or by delaying the visibility of updates using the versioning mechanism of POL. 3.5.
Reference: [19] <author> D. S. Moffat and P. M. D. Gray, </author> <title> Interfacing Prolog to a Persistent Data Store, </title> <booktitle> in Proceedings of the Third International Conference on Logic Programming, Lecture Notes in Computer Science, </booktitle> <volume> vol. 225, </volume> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1986, </year> <pages> 577-584. </pages>
Reference-contexts: A good survey of this approach can be found in Gallaire et al [11]. Simpler approaches use a relational database as a repository for facts and couple that repository with an existing Prolog implementation [13]. Our approach is closest to that of Moffat and Gray <ref> [19] </ref> who implement Pro-log in the persistent language PS-ALGOL [3]. We differ from them by giving external predicates the possibility of backtracking. 6. Status and Future Work A prototype of POL is working and has been tested extensively during the construction of CAPITL.
Reference: [20] <author> D. J. Musliner, J. W. Dolter and K. G. Shin, BibDb: </author> <title> A Bibliographic Database for Collaboration, </title> <booktitle> CWSC '92 Proceedings, </booktitle> <month> Oct. </month> <year> 1992, </year> <pages> 386-393. </pages>
Reference-contexts: Citations are replaced by annotations such as superscripts or bracketed numbers, and the cited references are collected and listed in a bibliography at the end of the paper. The bibliographic database is intended to be shared by many papers, perhaps written by different authors. Musliner et. al. <ref> [20] </ref> have pointed out problems with these systems. First, the bibliographic database is not a true database. It lacks such database facilities as concurrency control, recovery, and distributed access. Second, references can become stale over time.
Reference: [21] <institution> Quintus Prolog, Release 3.1, Quintus Corporation, An Intergraph Company, Palo Alto, California, </institution> <note> Revised July 1991. </note>
Reference-contexts: However, their bridge does not permit backtracking between the two languages and relies on the special hardware of a Lisp/Prolog machine. Quintus Prolog <ref> [21] </ref> provides a software bridge to other programming languages, including C, Fortran, and Pascal. In Quintus Prolog programmers can call foreign language procedures (or FLPs) and pass terms as both in and out parameters. Library functions are used in the FLP to access terms and build new terms.
Reference: [22] <author> J. Richardson, M. Carey and D. Schuh, </author> <title> The Design of the E Programming Language, </title> <journal> ACM Trans. Prog. Lang. </journal> <note> and Systems , to appear. </note>
Reference-contexts: The Exodus Storage Manager provides efficient access to arbitrary-sized untyped persistent arrays of bytes called storage objects, which are identified by unique object identifiers (OIDs). The Storage Manager supports concurrency control with two-phase locking, and serializable transactions with full recovery from hardware and software failures. The E programming language <ref> [22] </ref> is an extension of C++ that supports persistent datadata that retains its state between runs of a program. E syntax extends C++ with a db version of each primitive type and type constructor (dbint, dbclass - ... -, etc.).
Reference: [23] <author> R. Sandberg, D. Goldberg, S. Kleiman, D. Walsh and B. Lyon, </author> <title> Design and implementation of the Sun Network filesystem, </title> <booktitle> Proceedings of the Summer 1985 USENIX Conference, </booktitle> <address> Portland, OR, </address> <month> June </month> <year> 1985, </year> <pages> 119-130. </pages>
Reference-contexts: Thus each file has a unique name and a unique containing directory. Adams and Solomon POL Page 18 EFS allows programs to access CAPITL objects as if they were Unix files. It is based on the Network File System (NFS) facility <ref> [23] </ref>, which is included in most versions of Unix.
Reference: [24] <author> M. Solomon, EFS: </author> <title> The Extensible File System, </title> <institution> University of Wisconsin Technical Report, </institution> <note> In preparation. </note>
Reference-contexts: There are mechanisms to choose a current world, commit a world, and spawn a new world as a child of an existing committed world. There are two means to access the CAPITL object-base: an X-based browser and a Unix compatibility interface called Emulated File System (EFS) <ref> [24] </ref>. The X-based browser uses the C++ interface of terms to display CAP-ITL objects and to navigate the object-base.
Reference: [25] <author> B. Stroustrup, </author> <title> The C++ Programming Language, Second Edition, </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <year> 1991. </year>
Reference-contexts: Subclasses can override methods of their super-class as well as add new data fields and operations. We assume the reader has a basic reading knowledge of C++. Our examples will avoid the more exotic features of the language. Excellent texts on C++ have been written by Stroustrup <ref> [25] </ref> and Lippman [17]. C++ classes are used in POL to provide a concrete realization of term space nodes and arcs. All classes are derived from the abstract base class Term which represents a node and its outgoing arcs. Subclasses are Atomic and InternalNode. Atomic nodes have no outgoing arcs.
Reference: [26] <author> W. F. Tichy, RCS: </author> <title> A System for Version Control, </title> <journal> SoftwarePractice and Experience 15, </journal> <month> 7 (July </month> <year> 1985), </year> <pages> 637-654. </pages>
Reference-contexts: It has exactly the same semantics as a Unix plain file (see 3.2). Delta files have additional operations to compress and uncompress their contents. Delta files represent consecutive versions of their contents as delta lists using an algorithm similar to RCS <ref> [26] </ref>. The contents of a term file is an arbitrary Congress term. A composite file, like a directory, contains a list of references to other objects, but it does not emulate all the behavior of a Unix directory, nor is it constrained to be part of a strict tree structure.
Reference: [27] <author> D. S. Warren, </author> <title> Database Updates in Pure Prolog, </title> <booktitle> Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <year> 1984, </year> <pages> 244-253. </pages>
Reference-contexts: Changes made by assignments can be frozen by preventing backtracking, either by accepting the result at the top level call of the interpreter or by use of the cut predicate <ref> [27] </ref>. Because assignment changes the (data) term space immediately, the semantics of a program that contains an assignment depends on the depth first search order followed by the interpreter.
Reference: [28] <author> C. Zaniolo, </author> <title> Object-Oriented Programming in Prolog, </title> <booktitle> 1984 International Symposium on Logic Programming, </booktitle> <month> Feb. </month> <year> 1984, </year> <pages> 265-270. </pages>
Reference-contexts: One approach to combining logic and object-oriented programming is to add object-oriented features to a logic programming language. For example, Prolog might be extended with built-in operators for declaring classes and inheritance and explicit send and receive predicates for method invocation <ref> [10, 28] </ref>. An advantage of this approach is that it uses Prolog implementations, but it is unable to blend the procedural mechanisms of traditional object-oriented languages with the backtracking search of Prolog.
References-found: 28

