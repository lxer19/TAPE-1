URL: http://www.cs.toronto.edu/~chechik/pubs/tse.ps
Refering-URL: http://www.cs.toronto.edu/~chechik/publications.html
Root-URL: 
Email: chechik@cs.toronto.edu gannon@cs.umd.edu  
Title: Automatic Analysis of Consistency between Requirements and Designs  
Author: Marsha Chechik John Gannon 
Keyword: Index Terms: SCR requirements, static analysis, formal specification, finite-state abstraction, data-flow analysis.  
Note: This work was supported by the Air Force Office of Scientific Research under contract F49620-93-1 0034 and UTRS Connaught Fund award 72008220.  
Address: Toronto, ON M5S 3G4 College Park, MD 20774  
Affiliation: Department of Computer Science Computer Science Department University of Toronto University of Maryland  
Abstract: Writing requirements in a formal notation permits automatic assessment of such properties as ambiguity, consistency, and completeness. However, verifying that the properties expressed in requirements are preserved in other software life cycle artifacts remains difficult. Most of the proposed techniques suffer from exponential explosion of the number of states in the generated state spaces. One way to cope with this explosion is to develop and apply "light-weight" formal methods that will attempt to achieve scalability by checking an abstraction of the system for only some non-trivial properties. This paper describes methods and tools for automatically analyzing the consistency of software requirements and detailed designs in low-degree polynomial time. Requirements describe systems as state machines with event-driven transitions using a specification language that is easy to read and scalable to large systems. We define requirements and detailed designs to be consistent if they contain exactly the same transitions. We have developed a language for specifying detailed designs, an analysis technique to create a model of a design through data-flow analysis of the language constructs, and a method to automatically generate and check properties derived from requirements to ensure a design's consistency with them. These ideas are implemented in a tool named CORD, which we used to uncover errors in designs of existing systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools, Chapter 10. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Our computation of states at each node of the DFG is similar to that of constant propagation a compiler technique whose goal is to discover values that are constant for all possible executions of a program and to propagate these constant values as far forward through the program as possible <ref> [50, 1] </ref>.
Reference: [2] <author> T. Alspaugh, S. Faulk, K. Britton, R. Parker, D. Parnas, and J. Shore. </author> <title> "Software Requirements for the A-7E Aircraft". </title> <type> Technical report, </type> <institution> Naval Research Laboratory, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Finally, Section 8 discusses limitations of our approach and compares it to related work. 3 2 Requirements Notation The SCR requirements notation was developed by a research group at the Naval Research Laboratory as part of the Software Cost Reduction project <ref> [2, 25] </ref>. The project resulted in SCR requirements and design standards, as well as guidelines for software development using SCR. A complete SCR requirements specification contains behavioral, functional, precision, and timing requirements of a software system, as well as assumptions about the environment in which the system will operate.
Reference: [3] <author> J. Atlee. </author> <title> "Automated Analysis of Software Requirements". </title> <type> PhD thesis, </type> <institution> University of Mary-land, College Park, Maryland, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: The specification language is precise, can be understood by engineers and software developers, and is easy to use and modify. The initial language lacked an underlying formal semantics. A number of semantics have been proposed <ref> [3, 23, 18, 42, 49] </ref>, some of which [23, 43] became bases of tools automating consistency and completeness checks [22] and simulations [15, 44] of requirements. <p> For example, the water in a container cannot be too high and too low at the same time, and buttons can be either pressed or released but not both. Many environmental assumptions can be expressed by declaring relationships between conditions <ref> [3] </ref>. Some sample relationships are discussed below. implication (a&gt; b). The state space in which a is true is a subset of the state space in which b is true. strict implication (a&gt;> b).
Reference: [4] <author> J.M. Atlee and J. Gannon. </author> <title> "State-Based Model Checking of Event-Driven System Requirements". </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 22-40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: However, the size of the state-space grows exponentially to the number of variables in the problem. Software problems are typically too large to be analyzed using model-checking. The first attempt to model-check requirements was made by Atlee and Gannon <ref> [4] </ref>. Since then, model-checking has been often used in requirements engineering. Programs, however, cannot usually be verified directly, and various researchers have been proposing checking abstractions of programs [51, 33, 26]. Coming up with useful abstractions and interpreting counter-examples remains difficult.
Reference: [5] <author> Ramesh Bharadwaj and Connie Heitmeyer. </author> <title> "Verifying SCR Requirements Specifications Using State Exploration". </title> <booktitle> In Proceedings of 1st ACM SIGPLAN Workshop on the Automated Analysis of Software, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: Both approaches have been used to formally verify communication protocols and circuit designs, as well as other hardware and software systems. A group of researchers at Naval Research Lab recently undertook a verification effort very similar to ours <ref> [5] </ref>. The goal of this work was to use a linear-time model-checker SPIN to check consistency of SCR requirements. Promela (an input language for SPIN) is a C-like language with non-deterministic guarded IF statements.
Reference: [6] <author> Frederick P. Brooks. </author> <title> "No Silver Bullet: Essence and Accidents of Software Engineering". </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 10-19, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: Our PDL was motivated by the following factors: * Designs should look like real programs, i.e. specify control flow via programming language constructs for sequence, selection, and iteration. * Designs should capture the essence of what is happening in the code, rather than details <ref> [6] </ref>. When writing designs, we want to reason about requirements-level vari ables rather than implementation-level structures. * Finally, designs should be able to deal with sensors and actuators of the system, i.e., with IN and OUT relations (see Section 2 and [43]).
Reference: [7] <author> S.H. Caine and E.K. Gordon. </author> <title> "PDL: A Tool for Software Design". </title> <booktitle> In Proceedings of the National Computer Conference, </booktitle> <volume> volume 44, </volume> <pages> pages 271-276, </pages> <year> 1975. </year>
Reference-contexts: After a detailed design is complete and verified, it can be further refined into an implementation. 3.1 Design Constructs Typically, control-flow-based PDLs <ref> [7] </ref> are defined by an outer syntax of control structures and inner syntax of other statements. Our PDL's outer syntax is a set of C-like control structures. Our PDL's inner syntax consists of annotations special statements describing values of requirements variables.
Reference: [8] <author> M. Chechik. </author> <title> "Automatic Analysis of Consistency between Requirements and Designs". </title> <type> PhD thesis, </type> <institution> University of Maryland, College Park, Maryland, </institution> <month> December </month> <year> 1996. </year>
Reference-contexts: We do not process statements other than annotations and control flow constructs since they do not reflect changes of values of requirements variables. To differentiate between statements and annotations, the latter start with @@. For complete syntax of PDL, see <ref> [8] </ref>. Consider the following design fragment: READ_DEVICE (); @@ Read PumpFail; if (PUMP_FAIL ()) - @@ Assert PumpFail=true; break; - @@ Assert PumpFail=false; ... In this fragment, the function READ DEVICE () is called to determine the status of a pump. <p> Errors are considered violations of the ENV property. Details of this processing are presented in <ref> [8] </ref>. The system state for each DFG node is the value we compute for its out set. We initialize in and out sets of every node to EMPTY, and propagate information throughout 19 the DFG until a least fixed point is reached. <p> These transitions are shown in 27 6.3 Checking Automatically-Generated Properties Once the FSM has been created, ALT and OLT properties are checked in a single traversal of the FSM. Proofs of correctness of algorithms shown below appear in <ref> [8] </ref>. <p> The resulting design was about 300 lines long, with 45 Update, 22 Read, and 56 Assert annotations. Out of 54 functions in the original program, only eight had state changes and thus were included into the design. The complete design can be found in <ref> [8] </ref>. For this design, the DFG and the FSM contained 216 and 64 states, respectively. We ran the analysis on a SPARC 5 with 110 MHz microSPARC II CPU and 64 megabytes of memory.
Reference: [9] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Verification of Requirements Implementations". </title> <booktitle> In Proceedings of the 1994 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 1-14, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: In this paper, we define a notation which can be used as a PDL and describe a prototype tool, called CORD <ref> [9, 10] </ref>, which automatically determines if a design written in this notation is consistent with its requirements. The inputs to our tool are a tabular requirements specification and a detailed design 2 written in the PDL.
Reference: [10] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Analysis of Consistency Between Implementations and Requirements: A Case Study". </title> <booktitle> In Proceedings of 10th Annual Conference on Computer Assurance, </booktitle> <pages> pages 123-131, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: In this paper, we define a notation which can be used as a PDL and describe a prototype tool, called CORD <ref> [9, 10] </ref>, which automatically determines if a design written in this notation is consistent with its requirements. The inputs to our tool are a tabular requirements specification and a detailed design 2 written in the PDL.
Reference: [11] <author> M. </author> <title> Chechik and V.S. Sudha. "Using SCR to Comment and Verify Code for Event-Driven Systems". </title> <type> Technical report, </type> <institution> University of Toronto, </institution> <month> November </month> <year> 1997. </year>
Reference-contexts: Annotations and source code may also "diverge" as modifications to the program are being made. Simple automatic tests, checking consistency between annotations and source code, can be performed <ref> [11] </ref>. 4 Consistency with SCR Requirements Definition 4.1 Let a set of SCR requirements R = hB; Ei be given. A program artifact A constrained by environmental assumptions E (called A E ) is consistent with its requirements R if 1.
Reference: [12] <author> Edmund M. Clarke, Orna Grumberg, and David E. </author> <title> Long. "Model Checking and Abstraction". </title> <booktitle> In Proceedings of the Ninth Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Aspect's [30, 31, 32] specification notation permits users to write pre- and postconditions about the data dependencies of an operation. Dataflow analysis is used to compute an upper bound on the data dependencies of the implementation. If an asserted dependency is missing, an error is reported. Clarke et al. <ref> [12] </ref> also create abstract, finite state models of programs, and use model checking techniques to verify formulas. Programs written in a special finite-state programming language are translated into relational expressions characterizing the program's initial state and transition relation.
Reference: [13] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. "Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: To overcome this problem, researches suggested verifying some properties. Theorem-proving [41] allows to check that a property is implied by the program. This approach is very effective, although requires considerable skill and time investment. Another approach is to check properties via state exploration (model-checking <ref> [13] </ref>). This approach is very effective for verifying hardware and distributed systems, like protocols. However, the size of the state-space grows exponentially to the number of variables in the problem. Software problems are typically too large to be analyzed using model-checking. <p> The algorithm for computing out sets ensures that the effects of Assert annotations are preserved in system states, even though Assert nodes themselves are removed. 6 Verifying Properties Our method for constructing finite-state abstractions produces sets of values for each program variable. Model checkers <ref> [13] </ref> process states whose variables have scalar values. Transforming our FSM to correspond to an acceptable input for an existing model-checker would have resulted in an exponential increase in the number of nodes in the FSM. So, we developed our own technique to verify properties.
Reference: [14] <author> Rance Cleaveland, Joachim Parrow, and Bernhard Steffen. </author> <title> "The Concurrency Workbench: </title>
Reference-contexts: On the other hand, our analysis makes sure that the design implements exactly the same transitions as specified. A number of approaches are similar to ours by 36 nature. Equivalence checking in process algebras, e.g., as implemented in the Concurrency Workbench <ref> [14] </ref>, checks that two levels of specifications (or a specification and an implementation) exhibit exactly the same behavior. COSPAN [35, 34] uses L-automata to check two levels of specifications (or a specification and an implementation) for language containment properties.
References-found: 14

