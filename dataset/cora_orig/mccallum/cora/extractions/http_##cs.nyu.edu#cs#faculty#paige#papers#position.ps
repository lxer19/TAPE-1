URL: http://cs.nyu.edu/cs/faculty/paige/papers/position.ps
Refering-URL: http://cs.nyu.edu/cs/faculty/paige/research.html
Root-URL: http://www.cs.nyu.edu
Title: Future Directions In Program Transformations of transformational programming for practical software development is a formidable
Author: R. Paige 
Note: Testing the viability  has been gathered over the last 20 years has been based on experiments deriving implementations of combinatorial algorithms (see [Paige et al. 1985; Paige et al. 1993; National Science Foundation grant CCR-9616993.  
Affiliation: New York University  
Abstract: As the emphasis of Programming Languages has evolved from computing on numbers to computing on programs, the area of program transformations has naturally gained in importance. This paper briefly surveys what transformational programming is about, and how to make progress in the field. A program transformation is a meaning-preserving mapping defined on a programming language. Transformational programming is a program development methodology in which an implementation I is obtained from a specification S by applying a sequence T k :::T 1 of transformations to S. If S and each transformation T i applied to successive implementations T i1 :::T 1 S of S are proved correct for i = 1; :::; k, then I = T k :::T 1 S must also be correct. If we assume that program development requires a proof obligation, then it is easier to develop a program by transformation than by conventional crafting if the labor involved in constructing and verifying S, and of deriving I by transformation is less than the cost of constructing and verifying I from scratch. In an ideal transformational approach software is maintained at the specification level, and specifications are synthesized and verified by composition, integration, and enhancement; implementations are obtained by re-derivation. The cost of program development and maintenance drops if verified specifications, transformations, and derivations can be reused conveniently. Of central importance to this approach, a transformational programming system is envisioned to reduce labor costs and increase reliability by mechanizing much of the tedious pencil-and-paper calculations involved in constructing derivations. The long range goal of transformational programming is to improve reliability, productivity, maintenance, and analysis of software without sacrificing performance. The benefits are expected to be greatest for complex algorithmic software, whose demand has been increasing for real time applications, design automation, operations research, genetic engineering, optimizing compilers, complex tools for workstations, etc. The inability of program development by conventional crafting to meet this demand has created an intensive interest in a more formal transformational approach. And the community of researchers contributing to program transformations has been steadily growing. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Andersson, A. </author> <year> 1995. </year> <title> Sublogarithmic searching without multiplications. </title> <booktitle> In 36th Annual Symposium on Foundations of Computer Science (Milwaukee, </booktitle> <address> Wisconsin, </address> <year> 1995), </year> <pages> pp. 655-663. </pages> <publisher> IEEE. </publisher>
Reference: <author> Borras, P., Clement, D., Despeyroux, T., Incerpi, J., Kahn, G., Lang, B., and Pascual, V. </author> <year> 1987. </year> <title> Centaur: the system. </title> <institution> Rapports de Recherche 777, INRIA. </institution>
Reference: <author> Brodal, G. and Okasaki, C. </author> <year> 1996. </year> <title> Optimal purely functional priority queues. Journal of Functional Programming 6, 6 (Dec.). Program Transformations 5 Cai, </title> <journal> J., </journal> <note> Facon, </note> <author> P., Henglein, F., Paige, R., and Schonberg, E. </author> <year> 1991. </year> <title> Type transformation and data structure choice. </title> <editor> In B. Moeller Ed., </editor> <booktitle> Constructing Programs From Specifications, </booktitle> <pages> pp. 126-164. </pages> <address> Amsterdam: </address> <publisher> North-Holland. </publisher>
Reference: <author> Cai, J. and Paige, R. </author> <year> 1995. </year> <title> Using multiset discrimination to solve language processing problems without hashing. </title> <booktitle> Theoretical Computer Science 145, </booktitle> <month> 1-2 (July), </month> <pages> 189-228. </pages> <address> URL http://cs.nyu.edu/cs/faculty/paige/papers/hash.ps. </address>
Reference: <author> Cai, J. and Paige, R. </author> <month> Dec. </month> <year> 1993. </year> <title> Towards increased productivity of algorithm implementation. </title> <booktitle> In Proc. ACM SIGSOFT (Dec. </booktitle> <year> 1993), </year> <pages> pp. 71-78. </pages>
Reference: <author> Cocke, J. and Kennedy, K. </author> <year> 1977. </year> <title> An algorithm for reduction of operator strength. </title> <journal> CACM 20, </journal> <volume> 11 (Nov.), </volume> <pages> 850-856. </pages>
Reference: <author> Cousot, P. and Cousot, R. </author> <year> 1977. </year> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixed points. </title> <booktitle> In Proc. 4th ACM Symp. on Principles of Programming Languages (1977), </booktitle> <pages> pp. 238-252. </pages>
Reference: <author> Driscoll, J., Sarnak, N., Sleator, D., and Tarjan, R. </author> <year> 1986. </year> <title> Making data structures persistent. </title> <booktitle> In Proc. 8th ACM STOC (May 1986), </booktitle> <pages> pp. 109-121. </pages>
Reference: <author> Ferrante, J. and Ottenstein, K. J. </author> <year> 1983. </year> <title> A program form based on data dependency in predicate regions (Austin, Tex., </title> <month> Jan. </month> <year> 1983). </year> <pages> pp. 217-236. </pages>
Reference: <author> Fong, A. and Ullman, J. </author> <year> 1976. </year> <title> Induction variables in very high level languages. </title> <booktitle> In Proc. Third ACM Symp. on Principles of Programming Languages (Jan. </booktitle> <year> 1976), </year> <pages> pp. 104-112. </pages>
Reference: <author> Fredman, M. and Willard, D. </author> <year> 1994. </year> <title> Surpassing the information theoretic barrier with fusion trees. </title> <journal> J. Comput. Sys. Sci. </journal> <volume> 48, </volume> <pages> 533-551. </pages>
Reference: <author> Goyal, D. and Paige, R. </author> <year> 1997. </year> <title> The formal reconstruction and improvement of the linear time fragment of Willard's relational calculus subset. </title> <booktitle> In IFIP TC2 Working Conf. on Algorithmic Languages and Calculi (1997). </booktitle>
Reference: <author> Jeuring, J. </author> <year> 1994. </year> <title> The derivation of on-line algorithms, with an application to finding palindromes. </title> <journal> Algorithmica 11, </journal> <volume> 2 (Feb.), </volume> <pages> 146-184. </pages>
Reference: <author> Jones, N., Gomard, C., and Sestoft, P. </author> <year> 1993. </year> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice-Hall. </publisher>
Reference: <author> Keller, J. and Paige, R. </author> <year> 1995. </year> <title> Program derivation with verified transformations a case study. </title> <type> CPAM 48, </type> <pages> 9-10, 1053-1113. </pages>
Reference: <author> Koenig, S. and Paige, R. </author> <year> 1981. </year> <title> A transformational framework for the automatic control of derived data. </title> <booktitle> In Proc. 7th Intl. Conf. on VLDB (Sep 1981), </booktitle> <pages> pp. 306-318. </pages>
Reference: <author> Paige, R. </author> <year> 1986. </year> <title> Programming with invariants. </title> <journal> J IEEE Software 3, </journal> <volume> 1 (Jan), </volume> <pages> 56-69. </pages>
Reference: <author> Paige, R. </author> <year> 1989. </year> <title> Real-time simulation of a set machine on a ram. </title> <editor> In N. Janicki and W. Koczkodaj Eds., </editor> <booktitle> Computing and Information, </booktitle> <volume> Volume II, </volume> <pages> pp. 69-73. </pages> <address> Toronto: </address> <publisher> Cana-dian Scholars' Press. </publisher>
Reference: <author> Paige, R. and Koenig, S. </author> <year> 1982. </year> <title> Finite differencing of computable expressions. </title> <journal> ACM Trans. on Programming Languages and Systems 4, </journal> <volume> 3, </volume> <pages> 401-454. </pages>
Reference: <author> Paige, R., Reif, J., and Wachter, R. Eds. </author> <year> 1993. </year> <title> Parallel Algorithm Derivation and Program Transformation. </title> <publisher> Kluwer. </publisher>
Reference: <author> Paige, R., Tarjan, R., and Bonic, R. </author> <year> 1985. </year> <title> A linear time solution to the single function coarsest partition problem. </title> <booktitle> Theoretical Computer Science 40, 1 (Sep.), </booktitle> <pages> 67-84. </pages>
Reference: <author> Pepper, P. and Wirsing, M. </author> <year> 1994. </year> <title> Korso: A methodology for the development of correct software. </title> <type> Technical Report 93-36 (Nov.), </type> <institution> TU Berlin. </institution>
Reference: <author> Reps, T. and Teitelbaum, T. </author> <year> 1989. </year> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors. </title> <publisher> Springer-Verlag, </publisher> <address> New York. </address>
Reference: <author> Snyder, K. </author> <year> 1990. </year> <title> The SETL2 programming language. </title> <type> Technical Report 490, </type> <institution> Courant In-sititute, New York University. </institution>
Reference: <author> Watson, B. </author> <year> 1993. </year> <title> A taxonomy of finite automata minimization algorithms. </title> <note> Computing Science Note 93/44 (Dec.), </note> <institution> Eindhoven University of Technology, Department of Mathematics and Computing Science, Eindhoven, The Netherlands. </institution>
References-found: 25

