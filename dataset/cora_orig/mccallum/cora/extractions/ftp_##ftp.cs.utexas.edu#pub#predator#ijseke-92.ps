URL: ftp://ftp.cs.utexas.edu/pub/predator/ijseke-92.ps
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Title: Implementing a Domain Model for Data Structures characteristically accompanies new areas of research, domain modelers
Author: , Don Batory, Vivek Singhal, and Marty Sirkin questionable. 
Keyword: software building-blocks, domain modeling, software reuse, data structures.  
Note: 1.0 Introduction Domain modeling is presently an immature discipline [Pri91]. Besides the general skepticism that  
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas  
Abstract: We present a model of the data structure domain that is expressed in terms of the GenVoca domain modeling concepts [Bat91]. We show how familiar data structures can be encapsulated as realms of plug-compatible, symmetric, and reusable components, and we show how complex data structures can be formed from their composition. The target application of our research is a precompiler for specifying and generating customized data structures. A fundamental goal of software engineering is to understand how software components fit together to form complex systems. Domain modeling is a means to achieve this goal; it is the study of a domain of similar software systems to identify the primitive and reusable components of that domain and to show how compositions of components not only explain existing systems but also predict families of yet unbuilt systems that have interesting and novel properties. In essence, domain models can be blue-prints for the as-yet-to-be-achieved software building-block technologies. In this paper, we attempt to cross all three barriers (or alternatively, we show why each is hard to cross!). First, we review the GenVoca domain modeling concepts, which have been validated on the com 
Abstract-found: 1
Intro-found: 1
Reference: [ACM91] <editor> ACM, </editor> <title> Next Generation Database Systems, </title> <journal> Communications of the ACM, </journal> <month> October </month> <year> 1991. </year>
Reference-contexts: In Section 3.4 we outline extensions to our domain model that account for data structures that dont implement containers. 3.1 The Container Abstraction As mentioned earlier, a container is a collection (set) of objects. Our container abstraction has been strongly inuenced by work on relational and object-oriented databases <ref> [ACM91, Kor91, Coh85] </ref>. In these systems, users declare the relations/classes of their applications and write programs that update and query these relations/classes without ever knowing how tuples/instances are stored and retrieved. We take this idea one step further. <p> Containers are first-class objects and may themselves be stored in containers. Recalling the example of Figure 4, the container Directory is a binary tree container of list containers: binary_tree_container&lt;list_container<T&gt;> Directory; A run-time mechanism called an iterator or cursor <ref> [Ghe82, Kor91, ACM91] </ref> is used to enumerate subsets of objects in a container.. Cursors for the above containers are declared by: cursor&lt;list_container<T&gt;> c1 (C1), c2 (C2); cursor&lt;binary_tree_container<list_container<T&gt;>> c3 (Directory); That is, cursors c1 and c2 are of the same type; both traverse containers of type list_contain-er&lt;T&gt;.
Reference: [Aho88] <author> A.V. Aho, R. Sethi, and J.D. Ullman, </author> <booktitle> Compilers: Principles, Techniques, and Tools, </booktitle> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: The figure below illustrates a DLIST mapping. 5. In general, macro expansion is not always sufficient to produce optimal code. That further optimization is sometimes necessary is not surprising when component composition is viewed as a compiler technology <ref> [Aho88] </ref>. o1 o5 abstract representation concrete representation o1 o5 a2: address 16 Note that there are many other ways objects could be linked together on lists; each could be encapsulated as a distinct DS component. 3.2.5.3 INDEX [data, indx : DS] : DS INDEX is the component that maps a nonindexed
Reference: [Bat79] <author> D.S. Batory, </author> <title> On Searching Transposed Files, </title> <journal> ACM Transactions on Database Systems, </journal> <month> 4 #4 (December </month> <year> 1979). </year>
Reference: [Bat85] <author> D.S. Batory, </author> <title> Modeling the Storage Architectures of Commercial Database Systems, </title> <journal> ACM Trans. Database Syst., </journal> <volume> 10 #4 (Dec. </volume> <year> 1985), </year> <pages> 463-528. </pages>
Reference-contexts: Traditional parameterized types (TPTs) do not have this capability and appear to have a rather restricted subset of the capabilities offered by NPTs <ref> [Bat85] </ref>. The NPT concept is the basis of our domain model for data structures. 3.0 The Domain of Data Structures We explain in this section the steps that we followed in developing a domain model for data structures using the GenVoca concepts.
Reference: [Bat86] <author> D.S. Batory, J.R. Barnett, J.F. Garza, K.P. Smith, K. Tsukuda, B.C. Twichell, and T.E. Wise, </author> <title> GENESIS: An Extensible Database Management System, </title> <journal> IEEE Trans. on Soft. </journal> <volume> Engr., </volume> <month> November </month> <year> 1988. </year>
Reference: [Bat88] <author> D.S. Batory, </author> <title> Concepts for a DBMS Synthesizer, </title> <booktitle> in [Pri91] and ACM PODS, </booktitle> <year> 1988. </year>
Reference: [Bat91] <author> D.S. Batory and S.W. OMalley, </author> <title> The Design and Implementation of Hierarchical Software Systems Using Reusable Components, </title> <institution> University of Texas TR-91-22, </institution> <note> submitted for publica tion. </note>
Reference-contexts: This research was supported in part by grants from Texas Instruments and Digital Equipment Corporation. 2. This paper also appeared in International Journal of Software Engineering and Knowledge Engineering, 2 (3):375-402, Septermber 1992. 2 plex and disparate domains of database and network software <ref> [Bat91] </ref> 3 Next, we apply these concepts to develop a model of data structures, a domain that should be familiar to all readers. Finally, we explain how we are validating our domain model by explaining the mechanics of a precompiler for data structures. <p> These relationships, such as inheritance and link relationships, do not fit the DS abstractions we have presented so far, and not surprisingly, nor do their implementations. In this section we outline extensions to our domain model. A more complete survey of possible extensions is given in <ref> [Bat91] </ref>. A link is (the classical database) relationship between two (typically distinct) containers. One container of a link is called the parent, the other is the child. Typically, each parent object is associated with zero or more child objects.
Reference: [Boo87] <author> G. Booch, </author> <title> Software Components with Ada, </title> <publisher> Benjamin Cummings, </publisher> <year> 1987. </year>
Reference-contexts: These concepts are domain-independent as they have been shown to be applicable to a wide-variety of problems in very different domains <ref> [Rum91, Boo87, Teo86] </ref>. The ER model is a common graphical representation of object-oriented concepts [Che76, Kor91]. We will use the ER model as the vehicle for discussing OO concepts in this paper.
Reference: [Coh85] <author> D. Cohen and N. Goldman, </author> <title> AP5 Manual, </title> <institution> Information Science Institute, University of South ern California, </institution> <year> 1985. </year>
Reference-contexts: In Section 3.4 we outline extensions to our domain model that account for data structures that dont implement containers. 3.1 The Container Abstraction As mentioned earlier, a container is a collection (set) of objects. Our container abstraction has been strongly inuenced by work on relational and object-oriented databases <ref> [ACM91, Kor91, Coh85] </ref>. In these systems, users declare the relations/classes of their applications and write programs that update and query these relations/classes without ever knowing how tuples/instances are stored and retrieved. We take this idea one step further.
Reference: [Che76] <author> P.P. Chen, </author> <title> The Entity-Relationship Model: Toward a Unified View of Data, </title> <booktitle> ACM Transac tions on Database Systems, </booktitle> <month> 1 #1 (January </month> <year> 1976). </year>
Reference-contexts: These concepts are domain-independent as they have been shown to be applicable to a wide-variety of problems in very different domains [Rum91, Boo87, Teo86]. The ER model is a common graphical representation of object-oriented concepts <ref> [Che76, Kor91] </ref>. We will use the ER model as the vehicle for discussing OO concepts in this paper. The concepts of the ER model are necessary, but not sufficient, to explain important kinds of software components and to express hierarchical software systems as compositions of these components.
Reference: [Dij68] <author> E.W. Dijkstra, </author> <title> The Structure of THE Multiprogramming System, </title> <journal> Comm. ACM, </journal> <month> 11 #5 (May </month> <year> 1968). </year>
Reference-contexts: All operations on level i+1 are expressed in terms of operations of level i. A layer is the mapping of operations between levels. The idea is to localize or encapsulate specific complexities of a system within layers, thereby simplifying overall system design <ref> [Dij68, Hab76] </ref>. Object-oriented programming languages and design methodologies have shown that interface specifications should encompass both objects and operations, rather than operations alone. An object model or object-oriented virtual machine (OOVM) is, in general, a set of classes and their interrelationships.
Reference: [Ghe82] <author> C. Ghezzi and M. Jazayeri, </author> <title> Programming Language Concepts, </title> <publisher> John Wiley & Sons, </publisher> <year> 1982. </year>
Reference-contexts: However, the semantics of the components that we examine in this paper are very different than traditional constructs (e.g., templates in C++ [Str91], ADA generics <ref> [Ghe82] </ref>, OBJ sorts [Gog86]). Common to all parameterized types (both ours and traditional) is the concept of a container, i.e., a set of generic objects. <p> Containers are first-class objects and may themselves be stored in containers. Recalling the example of Figure 4, the container Directory is a binary tree container of list containers: binary_tree_container&lt;list_container<T&gt;> Directory; A run-time mechanism called an iterator or cursor <ref> [Ghe82, Kor91, ACM91] </ref> is used to enumerate subsets of objects in a container.. Cursors for the above containers are declared by: cursor&lt;list_container<T&gt;> c1 (C1), c2 (C2); cursor&lt;binary_tree_container<list_container<T&gt;>> c3 (Directory); That is, cursors c1 and c2 are of the same type; both traverse containers of type list_contain-er&lt;T&gt;.
Reference: [Gog84] <author> J. Goguen, </author> <title> Parameterized Programming, </title> <journal> IEEE Trans. Soft. </journal> <volume> Engr., </volume> <month> SE-10 #5 (September </month> <year> 1984). </year>
Reference-contexts: The following three systems present OOVM R as their interface: system1 = f [r] system2 = f [t] system3 = g [t] The above syntax was borrowed from the parameterized type notation in <ref> [Gog84, Gog86] </ref>. While the syntax is similar, we will show in Section 2.3 that the semantics of our components are rather different. Second, component reuse corresponds to common subexpressions. Whenever different systems (different expressions) reference a common subsystem (subexpression), then that subsystem (and its components) is being reused. <p> As this paper develops, we will show that the domain of data structures has a similar organization. 2.3 On the Relationship of Components to Parameterized Types Our type expression notation was borrowed from research on parameterized types <ref> [Gog84] </ref>. However, the semantics of the components that we examine in this paper are very different than traditional constructs (e.g., templates in C++ [Str91], ADA generics [Ghe82], OBJ sorts [Gog86]).
Reference: [Gog86] <author> J.Goguen, </author> <title> Reusing and Interconnecting Software Components, </title> <journal> IEEE Computer, </journal> <note> 19 #2 (Feb ruary 1986). Also in [Pri91]. 24 </note>
Reference-contexts: The following three systems present OOVM R as their interface: system1 = f [r] system2 = f [t] system3 = g [t] The above syntax was borrowed from the parameterized type notation in <ref> [Gog84, Gog86] </ref>. While the syntax is similar, we will show in Section 2.3 that the semantics of our components are rather different. Second, component reuse corresponds to common subexpressions. Whenever different systems (different expressions) reference a common subsystem (subexpression), then that subsystem (and its components) is being reused. <p> However, the semantics of the components that we examine in this paper are very different than traditional constructs (e.g., templates in C++ [Str91], ADA generics [Ghe82], OBJ sorts <ref> [Gog86] </ref>). Common to all parameterized types (both ours and traditional) is the concept of a container, i.e., a set of generic objects. Stacks, lists, binary trees, queues, etc. are specialized containers whose algorithms are defined independently of the types of objects that are to be stored. 5 Traditional.
Reference: [Hab76] <author> A.N. Habermann, L. Flon, and L. Cooprider, </author> <title> Modularization and Hierarchy in a Family of Operating Systems, </title> <journal> Communications of the ACM, </journal> <month> 19 #5 (May </month> <year> 1976). </year>
Reference-contexts: All operations on level i+1 are expressed in terms of operations of level i. A layer is the mapping of operations between levels. The idea is to localize or encapsulate specific complexities of a system within layers, thereby simplifying overall system design <ref> [Dij68, Hab76] </ref>. Object-oriented programming languages and design methodologies have shown that interface specifications should encompass both objects and operations, rather than operations alone. An object model or object-oriented virtual machine (OOVM) is, in general, a set of classes and their interrelationships.
Reference: [Hil91] <author> D.K. Hildebrand, </author> <title> Building Relational Client-Server DBMSs from Components, M.Sc. The sis, </title> <institution> Dept. of Computer Sciences, University of Texas, </institution> <year> 1991. </year>
Reference-contexts: Concepts for distributed systems can be encapsulated as DS components. Users may request objects that are not stored locally; client-server components hide the fact that objects are stored at remote sites <ref> [Hil91] </ref>. There are many other possibilities. 3.3 DS Expressions In a typical application, software designers will have particular data structures in mind that they want to use. The problem is how to express this request as a composition of available DS components.
Reference: [Hut91] <author> N.C. Hutchinson and L.L. Peterson, </author> <title> The x-Kernel: An Architecture for Implementing Net work Protocols, </title> <journal> IEEE Trans. on Soft. </journal> <note> Engr., 17 #1 (January 1991). </note>
Reference-contexts: The concepts of type expressions and realms of plug-compatible and parameterized components are not part of the ER/OO models. These concepts are domain-independent extensions to these models and have been validated in two rather different domains: databases and network software <ref> [Bat85-91, Oma90, Hut91] </ref>. The domain models for both databases and networks had their own sets of realms of interchangeable components.
Reference: [Kor91] <author> H.F. Korth and A. Silberschatz, </author> <title> Database System Concepts, </title> <publisher> McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: These concepts are domain-independent as they have been shown to be applicable to a wide-variety of problems in very different domains [Rum91, Boo87, Teo86]. The ER model is a common graphical representation of object-oriented concepts <ref> [Che76, Kor91] </ref>. We will use the ER model as the vehicle for discussing OO concepts in this paper. The concepts of the ER model are necessary, but not sufficient, to explain important kinds of software components and to express hierarchical software systems as compositions of these components. <p> In Section 3.4 we outline extensions to our domain model that account for data structures that dont implement containers. 3.1 The Container Abstraction As mentioned earlier, a container is a collection (set) of objects. Our container abstraction has been strongly inuenced by work on relational and object-oriented databases <ref> [ACM91, Kor91, Coh85] </ref>. In these systems, users declare the relations/classes of their applications and write programs that update and query these relations/classes without ever knowing how tuples/instances are stored and retrieved. We take this idea one step further. <p> Containers are first-class objects and may themselves be stored in containers. Recalling the example of Figure 4, the container Directory is a binary tree container of list containers: binary_tree_container&lt;list_container<T&gt;> Directory; A run-time mechanism called an iterator or cursor <ref> [Ghe82, Kor91, ACM91] </ref> is used to enumerate subsets of objects in a container.. Cursors for the above containers are declared by: cursor&lt;list_container<T&gt;> c1 (C1), c2 (C2); cursor&lt;binary_tree_container<list_container<T&gt;>> c3 (Directory); That is, cursors c1 and c2 are of the same type; both traverse containers of type list_contain-er&lt;T&gt;.
Reference: [Mor89] <author> E. Mora, </author> <title> Design and Implementation of Link Layers for the Genesis Database Management System, M.Sc. </title> <type> Thesis, </type> <institution> Dept. Computer Sciences, University of Texas, </institution> <year> 1989. </year>
Reference-contexts: What this means is that ring-list simultaneously specializes objects in both the parent and child containers by adding pointer attributes to each <ref> [Mor89, New89] </ref>. Transformations are even more complicated in the case of inheritance. Subclass-superclass (or actually, subcontainer-supercontainer) relationships simultaneously hold for many different containers. Components that augment an attribute to objects in one container must also augment that same attribute to all objects in subcontainers of that container.
Reference: [Mos88] <author> J.E.B. Moss and S. Sinofsky, </author> <title> Managing Persistent Data with MNEME: Designing a Reliable Shared Object Interface, </title> <booktitle> Second International Workshop on Object-Oriented Database Sys tems, </booktitle> <year> 1988. </year>
Reference-contexts: They are parameterized in that their mappings do not depend on how their concrete objects are stored. There are other broad classes of mappings which are not normally recognized as data structures. Perhaps the most important of these are components that realize persistent storage (e.g. <ref> [Mos88] </ref>).
Reference: [New89] <author> D. Newman, </author> <title> Link Implementations as Software Building Blocks, M.Sc. </title> <type> Thesis, </type> <institution> Dept. Com puter Sciences, University of Texas, </institution> <year> 1989. </year>
Reference-contexts: What this means is that ring-list simultaneously specializes objects in both the parent and child containers by adding pointer attributes to each <ref> [Mor89, New89] </ref>. Transformations are even more complicated in the case of inheritance. Subclass-superclass (or actually, subcontainer-supercontainer) relationships simultaneously hold for many different containers. Components that augment an attribute to objects in one container must also augment that same attribute to all objects in subcontainers of that container.
Reference: [OMa90] <author> S.W. OMalley and L. Peterson, </author> <title> A New Methodology for Designing Network Software, </title> <note> Uni versity of Arizona TR 90-29 (Sept. 1990). Submitted for publication. </note>
Reference-contexts: The concepts of type expressions and realms of plug-compatible and parameterized components are not part of the ER/OO models. These concepts are domain-independent extensions to these models and have been validated in two rather different domains: databases and network software <ref> [Bat85-91, Oma90, Hut91] </ref>. The domain models for both databases and networks had their own sets of realms of interchangeable components.
Reference: [Pet90] <author> L. Peterson, N. Hutchinson, and H. Rao, and S.W. OMalley, </author> <title> The x-kernel: A Platform for Accessing Internet Resources. </title> <journal> IEEE Computer (Special Issue on Operating Systems), </journal> <month> 23 #5 (May </month> <year> 1990), </year> <pages> 23-33. </pages>
Reference: [Pri91] <author> R. Prieto-Diaz and G. Arango, </author> <title> Domain Analysis and Software Systems Modeling, </title> <publisher> IEEE Com puter Society Press, </publisher> <year> 1991. </year>
Reference-contexts: In essence, domain models can be blue-prints for the as-yet-to-be-achieved software building-block technologies. Domain modeling is presently an immature discipline <ref> [Pri91] </ref>. Besides the general skepticism that characteristically accompanies new areas of research, domain modelers face three difficult barriers to the development and popularization of their ideas: Domain models must be expressed in terms of constructs and software organization principles that are domain-independent.
Reference: [Roy91] <author> J. Roy, </author> <title> Design and Use of the Jupiter File Management System, M.Sc. </title> <type> Thesis, </type> <institution> Dept. of Com puter Sciences, University of Texas, </institution> <year> 1991. </year>
Reference-contexts: Since the length of a BUFFER instance is greater than the size of a page, this alignment can only be guaranteed if the page-buffer attribute is stored separately from buffer header attributes. SEGMENT hides the ugly details of this partitioning, thereby simplifying the development of user programs <ref> [Roy91] </ref>. 3.2.5.5 More Components Hopefully by now, it should be evident that the cardinality of the DS realm is very large. Every DS component maps a container of abstract objects to one or more concrete containers of concrete objects.
Reference: [Rum91] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen, </author> <title> Object-Oriented Modeling and Design, </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: These concepts are domain-independent as they have been shown to be applicable to a wide-variety of problems in very different domains <ref> [Rum91, Boo87, Teo86] </ref>. The ER model is a common graphical representation of object-oriented concepts [Che76, Kor91]. We will use the ER model as the vehicle for discussing OO concepts in this paper.
Reference: [Str91] <author> B. Stroustrup, </author> <title> The C++ Programming Language, 2nd edition, </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: However, the semantics of the components that we examine in this paper are very different than traditional constructs (e.g., templates in C++ <ref> [Str91] </ref>, ADA generics [Ghe82], OBJ sorts [Gog86]). Common to all parameterized types (both ours and traditional) is the concept of a container, i.e., a set of generic objects. <p> public functions, including a constructor function (T) and a destructor function (~T). t1 t3 list (,t1,,) (,t2,,) t2 t3 binary_tree (a) BINARY_TREE [LIST [T]] Mapping (b) Resulting Container of Interlinked Objects 7 Two different containers C1 and C2 of T objects would be declared as instances of a C++ template <ref> [Str91] </ref>: list_container&lt;T&gt; C1, C2; That is, the objects of both C1 and C2 are stored in list_container data structures, which are parameterized by the type T of objects that they store. Containers are first-class objects and may themselves be stored in containers.
Reference: [Teo86] <author> T.J. Teorey, D. Yang, and J.P. Fry, </author> <title> A Logical Design Methodology for Relational Databases Using the Extended Entity-Relationship Model, </title> <journal> Computing Surveys, </journal> <month> 18 #2 (June </month> <year> 1986). </year>
Reference-contexts: These concepts are domain-independent as they have been shown to be applicable to a wide-variety of problems in very different domains <ref> [Rum91, Boo87, Teo86] </ref>. The ER model is a common graphical representation of object-oriented concepts [Che76, Kor91]. We will use the ER model as the vehicle for discussing OO concepts in this paper.
Reference: [Vas91] <author> D. Vasavada, </author> <title> Design and Implementation of Structural Inheritance for the Genesis Database Management System, M.Sc. </title> <type> Thesis, </type> <institution> Department Computer Sciences, University of Texas, </institution> <year> 1991. </year>
Reference-contexts: Subclass-superclass (or actually, subcontainer-supercontainer) relationships simultaneously hold for many different containers. Components that augment an attribute to objects in one container must also augment that same attribute to all objects in subcontainers of that container. Implementations of these ideas are presented in <ref> [Vas91] </ref>. 4.0 Conclusions The underlying premise of the GenVoca framework is that well-understood domains of hierarchical software systems can be standardized in terms of realms of plug-compatible and reusable components, and that complex systems are compositions of these components.
References-found: 29

