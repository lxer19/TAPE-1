URL: http://www.eecs.umich.edu/~zuberi/research/rtas97.ps
Refering-URL: http://www.eecs.umich.edu/~zuberi/research/
Root-URL: http://www.cs.umich.edu
Email: fzuberi,kgshing@eecs.umich.edu  
Title: An Efficient Semaphore Implementation Scheme for Small-Memory Embedded Systems  
Author: Khawar M. Zuberi and Kang G. Shin 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Real-Time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: In object-oriented programming, updates to the state variables of objects (by the methods of the object) have to be protected through semaphores to ensure mutual exclusion. Semaphore operations are invoked each time an object is accessed, and this represents significant run-time overhead. This is of special concern in cost-conscious, small-size embedded systems | such as those used in automotive applications | where costs must be kept to an absolute minimum. Object-oriented programming can be feasible in such applications only if the OS provides efficient, low-overhead semaphores. We present a new semaphore implementation scheme which saves one context switch per semaphore lock operation in most circumstances and gives performance improvements of 18-25% over traditional semaphore implementation schemes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. G. Shin and P. Ramanathan, </author> <title> "Real-time computing: a new discipline of computer science and engineering," </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> vol. 82, no. 1, </volume> <pages> pp. 6-24, </pages> <month> January </month> <year> 1994. </year>
Reference: [2] <author> K. Ramamritham and J. A. Stankovic, </author> <title> "Scheduling algorithms and operating systems support for real-time systems," </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> vol. 82, no. 1, </volume> <pages> pp. 55-67, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: These microcon-trollers have relatively slow processing cores (typically running at 10-30 MHz), small, on-chip RAMs (about 32-64 kBytes, hence the name "small-memory" embedded systems), and all applications are in-memory (there are no disks/file systems in our target applications). This necessitates that any real-time operating system (RTOS) <ref> [2] </ref> used in these applications must be both time-efficient and memory-efficient. In this paper, we focus on OS support for object-oriented (OO) programming in embedded systems. OO design gives benefits such as reduced software design time and software re-use [3].
Reference: [3] <author> B. Meyer, </author> <title> Object-Oriented Software Construction, </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: This necessitates that any real-time operating system (RTOS) [2] used in these applications must be both time-efficient and memory-efficient. In this paper, we focus on OS support for object-oriented (OO) programming in embedded systems. OO design gives benefits such as reduced software design time and software re-use <ref> [3] </ref>. But with these benefits comes the extra cost of ensuring mutual exclusion when an object's internal state is updated. Semaphores 1 [4, 5] are typically used to provide this mutual exclusion.
Reference: [4] <author> E. W. Dijkstra, </author> <title> "Cooperating sequential processes," </title> <type> Technical Report EWD-123, </type> <institution> Technical University, Eindhoven, </institution> <address> the Netherlands, </address> <year> 1965. </year>
Reference-contexts: OO design gives benefits such as reduced software design time and software re-use [3]. But with these benefits comes the extra cost of ensuring mutual exclusion when an object's internal state is updated. Semaphores 1 <ref> [4, 5] </ref> are typically used to provide this mutual exclusion. <p> Moreover, each object invocation requires a context switch from the client thread to the server thread, so this model is time-inefficient as well. With the passive object model, multiple threads can be inside the same object at one time, so they must synchronize their activities. Semaphores <ref> [4, 5] </ref> are commonly used for this purpose (e.g., to provide the monitor construct [14]).
Reference: [5] <author> A. N. Habermann, </author> <title> "Synchronization of communicating processes," </title> <journal> Communications of the ACM, </journal> <volume> vol. 15, no. 3, </volume> <pages> pp. 171-176, </pages> <month> March </month> <year> 1972. </year>
Reference-contexts: OO design gives benefits such as reduced software design time and software re-use [3]. But with these benefits comes the extra cost of ensuring mutual exclusion when an object's internal state is updated. Semaphores 1 <ref> [4, 5] </ref> are typically used to provide this mutual exclusion. <p> Moreover, each object invocation requires a context switch from the client thread to the server thread, so this model is time-inefficient as well. With the passive object model, multiple threads can be inside the same object at one time, so they must synchronize their activities. Semaphores <ref> [4, 5] </ref> are commonly used for this purpose (e.g., to provide the monitor construct [14]).
Reference: [6] <author> J. Mellor-Crummey and M. Scott, </author> <title> "Algorithms for scalable synchronization on shared-memory multiprocessors," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 9, no. 1, </volume> <pages> pp. 21-65, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: However, for simplicity, we concern ourselves only with semaphores in this paper. Most research in the area of reducing task syn-chronization overhead has focused on multiprocessors <ref> [6, 7] </ref>. But our target architectures are either uniprocessor (as in home appliances) or very loosely-coupled distributed systems (as in automotive applications). Even with the latter, threads typically do not need to access remote objects, so our concern is only with improving task synchronization performance for a single processor.
Reference: [7] <author> C.-D. Wang, H. Takada, and K. Sakamura, </author> <title> "Priority inheritance spin locks for multiprocessor real-time systems," </title> <booktitle> in 2nd International Symposium on Parallel Architectures, Algorithms, and Networks, </booktitle> <pages> pp. 70-76, </pages> <year> 1996. </year>
Reference-contexts: However, for simplicity, we concern ourselves only with semaphores in this paper. Most research in the area of reducing task syn-chronization overhead has focused on multiprocessors <ref> [6, 7] </ref>. But our target architectures are either uniprocessor (as in home appliances) or very loosely-coupled distributed systems (as in automotive applications). Even with the latter, threads typically do not need to access remote objects, so our concern is only with improving task synchronization performance for a single processor.
Reference: [8] <author> H. Takada and K. Sakamura, </author> <title> "Experimental implementations of priority inheritance semaphore on ITRON-specification kernel," </title> <booktitle> in 11th TRON Project International Symposium, </booktitle> <pages> pp. 106-113, </pages> <year> 1994. </year>
Reference-contexts: Even with the latter, threads typically do not need to access remote objects, so our concern is only with improving task synchronization performance for a single processor. Previous work in this area has focused on either relaxing the semaphore semantics to get better performance <ref> [8] </ref> or coming up with new semantics and new synchronization policies [9]. The problem with this approach is that these new/modified semantics may be suitable for some particular applications but usually they do not have wide applicability.
Reference: [9] <author> H. Tokuda and T. Nakajima, </author> <title> "Evaluation of real-time synchronization in Real-Time Mach," </title> <booktitle> in Second Mach Symposium, </booktitle> <pages> pp. 213-221. </pages> <publisher> Usenix, </publisher> <year> 1991. </year>
Reference-contexts: Previous work in this area has focused on either relaxing the semaphore semantics to get better performance [8] or coming up with new semantics and new synchronization policies <ref> [9] </ref>. The problem with this approach is that these new/modified semantics may be suitable for some particular applications but usually they do not have wide applicability. <p> It is unblocked as part of the semaphore release operation and it then proceeds to reserve the semaphore for itself. If the caller is to block, priority inheritance <ref> [9, 10] </ref> also takes place under which the current lock holder thread's priority is increased to that of the caller thread (if the former is less than the latter). This is needed to avoid unbounded priority inversion [10].
Reference: [10] <author> L. Sha, R. Rajkumar, and J. Lehoczky, </author> <title> "Priority inheritance protocols: an approach to real-time synchronization," </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. 39, no. 3, </volume> <pages> pp. 1175-1198, </pages> <year> 1990. </year>
Reference-contexts: The problem with this approach is that these new/modified semantics may be suitable for some particular applications but usually they do not have wide applicability. We took the approach of providing full semaphore semantics (with priority inheritance <ref> [10] </ref>), but optimizing the implementation of these semaphores by exploiting certain features of embedded applications. As a result, our semaphore scheme has wide applicability within the domain of embedded applications, while significantly improving performance over standard implementation methods for semaphores. <p> It is unblocked as part of the semaphore release operation and it then proceeds to reserve the semaphore for itself. If the caller is to block, priority inheritance <ref> [9, 10] </ref> also takes place under which the current lock holder thread's priority is increased to that of the caller thread (if the former is less than the latter). This is needed to avoid unbounded priority inversion [10]. <p> If the caller is to block, priority inheritance [9, 10] also takes place under which the current lock holder thread's priority is increased to that of the caller thread (if the former is less than the latter). This is needed to avoid unbounded priority inversion <ref> [10] </ref>. If a high-priority thread T h calls acquire sem () on a semaphore already locked by a low-priority thread T l , the latter's priority is temporarily increased to that of the former.
Reference: [11] <author> K. M. Zuberi and K. G. Shin, "EMERALDS: </author> <title> A microkernel for embedded real-time systems," </title> <booktitle> in Proc. Real-Time Technology and Applications Symposium, </booktitle> <pages> pp. 241-249, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: As a result, our semaphore scheme has wide applicability within the domain of embedded applications, while significantly improving performance over standard implementation methods for semaphores. We have implemented this new semaphore scheme in the EMERALDS (Extensible Microkernel for Embedded, ReAL-time, Distributed Systems) RTOS <ref> [11] </ref> which is being developed in the Real-Time Computing Laboratory at the University of Michigan to satisfy the specific memory and performance requirements of small-size embedded systems. <p> The worst-case execution time for acquire sem () occurs when the semaphore is already locked when 2 This is especially true in EMERALDS where system call overhead is comparable to subroutine call overhead even with full memory protection between processes <ref> [11] </ref>. scheme. Context switch C 2 is eliminated. the system call is made. This means that the context switches C 2 and C 3 shown in Figure 1 must be included when calculating worst-case task execution times. Any scheme to make semaphores more efficient must target this worst-case scenario.
Reference: [12] <author> Y. Ishikawa, H. Tokuda, and C. W. Mercer, </author> <title> "An object-oriented real-time programming language," </title> <journal> IEEE Computer, </journal> <volume> vol. 25, no. 10, </volume> <pages> pp. 66-73, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: These notions of encapsulation and modularity greatly help the software design process because various system components such as sensors, actuators, and controllers can be modeled by objects. Then, under the OO paradigm, real-time software is just a collection of threads of execution, each invoking various methods of various objects <ref> [12] </ref>. Conceptually, this OO paradigm is very appealing and gives benefits such as reduced software design time and software re-use. But practically speaking, these benefits come at a cost. The methods of an object must synchronize their access to the object's data to ensure mutual exclusion.
Reference: [13] <author> R. S. Chin and S. T. Chanson, </author> <title> "Distributed object-based programming systems," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 23, no. 1, </volume> <pages> pp. 91-124, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: Under the active object model <ref> [13] </ref>, one or more server threads are permanently bound to an object. When a client thread invokes a method, a server thread executes the method on behalf of the client. With the passive object model [13], objects do not have threads of their own. <p> Under the active object model <ref> [13] </ref>, one or more server threads are permanently bound to an object. When a client thread invokes a method, a server thread executes the method on behalf of the client. With the passive object model [13], objects do not have threads of their own. To invoke a method, a thread will enter the object, execute the method, and then exit the object. From the point of view of synchronization, the active object model has an advantage if only one thread is assigned per object.
Reference: [14] <author> C. A. R. Hoare, </author> <title> "Monitors: An operating system structuring concept," </title> <journal> Communications of the ACM, </journal> <volume> vol. 17, no. 10, </volume> <pages> pp. 549-557, </pages> <month> October </month> <year> 1974. </year>
Reference-contexts: With the passive object model, multiple threads can be inside the same object at one time, so they must synchronize their activities. Semaphores [4, 5] are commonly used for this purpose (e.g., to provide the monitor construct <ref> [14] </ref>). Even though locking based on semaphores incurs time overhead, it is decidedly much more memory-efficient than the active object model. 2.2 OO Design Under EMERALDS For the above stated reasons, we advocate the passive object model for embedded software design.
Reference: [15] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling algorithms for multiprogramming in a hard real-time environment," </title> <journal> Journal of the ACM, </journal> <volume> vol. 20, no. 1, </volume> <pages> pp. 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference: [16] <author> A. C. Audsley, A. Burns, and A. J. Wellings, </author> <title> "Deadline monotonic scheduling theory and application," </title> <journal> Control Engineering Practice, </journal> <volume> vol. 1, no. 1, </volume> <pages> pp. 71-78, </pages> <year> 1993. </year>
Reference: [17] <author> Q. Zheng and K. G. Shin, </author> <title> "On the ability of establishing real-time channels in point-to-point packet-switched networks," </title> <journal> IEEE Trans. Communications, </journal> <pages> pp. 1096-1105, </pages> <month> Febru-ary/March/April </month> <year> 1994. </year>
Reference: [18] <author> J. Stankovic and K. Ramamritham, </author> <title> "The Spring Kernel: a new paradigm for real-time operating systems," </title> <journal> ACM Operating Systems Review, </journal> <volume> vol. 23, no. 3, </volume> <pages> pp. 54-71, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: for (;;) - obj_1.method // protected by sem S1 obj_2.method // protected by sem S2 ... obj_n.method // protected by sem Sn block (..., S1, S2, ..., Sn); - This is somewhat similar to the Spring kernel's notion of reserving all resources a task needs before letting the task execute <ref> [18] </ref>, but with an important difference: the Spring kernel executes tasks non-preemptively while under our proposal, threads execute preemptively.
Reference: [19] <author> M68040 User's Manual, Motorola Inc., </author> <year> 1992. </year>
Reference-contexts: behave just like standard implementation semaphores, but we do not believe this will be needed very often, if at all. 5 Performance Evaluation To measure the improvement in performance resulting from our new semaphore scheme, we implemented it under EMERALDS and measured performance on a 25 MHz Motorola 68040 processor <ref> [19] </ref>. When a thread enters an object, it first acquires the semaphore protecting the object, and when it exits the object, it releases the semaphore. The cumulative time spent in these two operations represents the overhead associated with synchronizing thread access to objects.
References-found: 19

