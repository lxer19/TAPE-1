URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1995/UM-CS-1995-077.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/95-077.html
Root-URL: 
Title: Preconditions, Postconditions, and Provisional Execution in Software Processes  
Author: Stanley M. Sutton, Jr. 
Note: This work was supported by the Advanced Research Projects Agency under grant F30602-94-C-0137.  
Address: Amherst, Massachusetts 01003  
Affiliation: Laboratory for Advanced Software Engineering Research Computer Science Department University of Massachusetts  
Abstract: CMPSCI Technical Report 95-77 July 1995 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Robert Balzer. </author> <title> Tolerating inconsistency. </title> <booktitle> In Proc. of the 13th International Conference on Software Engineering, </booktitle> <pages> pages 158 - 165, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: It has been argued that inconsistency of software data is unavoidable during software development and so mechanisms should be offered to allow work to proceed in the face of inconsistency <ref> [23, 1] </ref>. The corresponding point is made here that indeterminacy is unavoidable, although the reasons and response are different. The AdaPIC analysis tool-set [26] accommodates incompleteness of module specifications in the analysis of inter-module provide/request relationships.
Reference: [2] <author> Sergio Bandinelli, Alfonso Fuggetta, and Sandro Grigolli. </author> <title> Process modeling in-the-large with SLANG. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 75-83, </pages> <year> 1993. </year>
Reference-contexts: As preconditions these constraints can serve guards, as postconditions they can serve as constraints, and in either case they may serve to trigger operations that are supplemental to the invoked operation. APPL/A [22, 24] has predicates that can be enforced as constraining postconditions on relation operations. SLANG <ref> [2] </ref> and Melmac [8] have what might be called selecting preconditions; these are guards on alternative execution paths which are used to control branching execution.
Reference: [3] <author> N. Barghouti. </author> <title> Concurrency Control in Rule-Based Software Development Environments. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <year> 1992. </year>
Reference-contexts: The transaction model proposed in [16] addresses this situation by providing both optimistic concurrency-control for transaction that may be more readily aborted and pessimistic concurrency-control for transactions that should be protected against aborts. This may be viewed as a special case of semantics-based concurrency control <ref> [3] </ref>, which can be applied at least to resolve concurrency conflicts in favor of more expensive transactions. Yet another approach is to attempt to reduce the incidence of conflicts by serialization of process tasks and condition evaluations. Serialization is used, for example, in AP5 [6]. <p> This model can further be viewed as a high-level application of the ideas of semantic and programmable concurrency control <ref> [3] </ref>, in which information about the semantics of activities is used to resolve conflicts between them.
Reference: [4] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Concurrency control in advanced database applications. </title> <journal> ACM Computing Surveys, </journal> <volume> 23(3):269 - 317, </volume> <month> September </month> <year> 1991. </year>
Reference-contexts: in the control of process execution (including, for example, the abort of tasks that should be committed, or the initiation of tasks that should not be started). 2.3 Long Transactions Some of the relevant properties of software processes give rise to the well-known problem of long transactions in software processes <ref> [4] </ref>. The problems of long transactions and conditional execution are similar in that both involve concurrency-control issues and both may entail costly transaction aborts. However, these problems are different in several respects.
Reference: [5] <author> Noureddine Belkhatir, Jacky Estublier, and Melo L. Walcelio. ADELE-TEMPO: </author> <title> An environment to support process modeling and enaction. </title> <editor> In Anthony Finkelstein, Jeff Kramer, and Bashar Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, </booktitle> <pages> pages 187 - 222. </pages> <publisher> John Wiley & Sons Inc., </publisher> <year> 1994. </year>
Reference-contexts: A related strategy is to make less use of condition-based execution. Alternatives would be, for example, to make more use of imperative or event-triggered (as opposed to condition-triggered) control models. These execution models certainly seem to have a place in software processes <ref> [24, 5] </ref>. However, they do not, in and of themselves, address the persistent need for conditional execution, consistency management, and so on. <p> Another variant is the use of segregated workspaces for process tasks. Workspaces are used in a number of systems (including some that do not support automatic evaluation of preconditions or postconditions) <ref> [5, 7, 16, 10] </ref>. Conditions on product state can be evaluated in a central repository while updates proceed in parallel on local copies of the product. Condition evaluations within a workspace can be coordinated with the local task without holding up tasks in other workspaces.
Reference: [6] <author> Don Cohen. </author> <title> AP5 Manual. </title> <institution> Univ. of Southern California, Information Sciences Institute, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Preconditions and postconditions are widely used in execution models for software processes <ref> [17, 6, 24, 25, 16, 15] </ref>. These conditions typically characterize process or product state and allow process execution to be controlled accordingly. <p> These property lists act as guarding preconditions on user-invoked rules and as triggering preconditions on automation rule chains. Marvel also has consistency rule chains that act like constraining postconditions on rule results (i.e., failure to assert the postcondition effect of an action leads to rollback of the action). AP5 <ref> [6] </ref> has automation rules that are fired by triggering preconditions and consistency rules that are fired by constraining postconditions. <p> Yet another approach is to attempt to reduce the incidence of conflicts by serialization of process tasks and condition evaluations. Serialization is used, for example, in AP5 <ref> [6] </ref>. User tasks are subject to consistency rules that are enforced as postconditions. When a user task completes, consistency rules are evaluated and repair actions are taken, before another user task is allowed. This ensures that condition evaluation occurs free from interference by ongoing application activities.
Reference: [7] <author> R. Conradi, M. Hagaseth, J.-O. Larsen, M. N. Nguy^en, B. P. Munch, P. H. Westby, W. Zhu, M. L. Jaccheri, and C. Liu. EPOS: </author> <title> Object-oriented cooperative process mod-elling. </title> <editor> In Anthony Finkelstein, Jeff Kramer, and Bashar Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, </booktitle> <pages> pages 33 - 70. </pages> <publisher> John Wiley & Sons Inc., </publisher> <year> 1994. </year>
Reference-contexts: Violation of the condition for a consistency rule can lead first to the firing of a repair action, but failure to satisfy the condition ultimately leads to rollback of the original action. EPOS <ref> [7] </ref> has both static and dynamic preconditions and postconditions. The static conditions are used for planning, the dynamic conditions are used for triggering actions or reactions. Pleiades [25] provides a constraint construct that may be evaluated as a precondition or postcondition to operations on instances of abstract data types. <p> Another variant is the use of segregated workspaces for process tasks. Workspaces are used in a number of systems (including some that do not support automatic evaluation of preconditions or postconditions) <ref> [5, 7, 16, 10] </ref>. Conditions on product state can be evaluated in a central repository while updates proceed in parallel on local copies of the product. Condition evaluations within a workspace can be coordinated with the local task without holding up tasks in other workspaces.
Reference: [8] <author> Wolfgang Deiters and Volker Gruhn. </author> <title> Managing software processes in the environment melmac. </title> <booktitle> In Proc. of the Fourth ACM SIGSOFT Symposium on Practical Software Development Environments, </booktitle> <pages> pages 193-205, </pages> <address> 1990. Irvine, California. </address>
Reference-contexts: APPL/A [22, 24] has predicates that can be enforced as constraining postconditions on relation operations. SLANG [2] and Melmac <ref> [8] </ref> have what might be called selecting preconditions; these are guards on alternative execution paths which are used to control branching execution.
Reference: [9] <author> Ahmed K. Elmagarmid and Y. Leu. </author> <title> An optimistic concurrency control algorithm for heterogeneous distributed databse systems. </title> <journal> IEEE Data Engineering, </journal> <pages> pages 26 - 32, </pages> <year> 1987. </year>
Reference-contexts: Optimism The idea that a task can proceed in the face of potential abort, which is essential to provisional execution, is also represented in optimistic concurrency-control for database transactions <ref> [9] </ref>. Optimistic concurrency control allows a transaction to run to completion and only then checks for possible concurrency conflicts with other transactions (at which point the completed transaction may be aborted).
Reference: [10] <author> Christer Fernstrom. </author> <title> PROCESS WEAVER: Adding process support to UNIX. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 12 - 26, </pages> <year> 1993. </year>
Reference-contexts: Another variant is the use of segregated workspaces for process tasks. Workspaces are used in a number of systems (including some that do not support automatic evaluation of preconditions or postconditions) <ref> [5, 7, 16, 10] </ref>. Conditions on product state can be evaluated in a central repository while updates proceed in parallel on local copies of the product. Condition evaluations within a workspace can be coordinated with the local task without holding up tasks in other workspaces.
Reference: [11] <author> Hector Garcia-Molina and Kenneth Salem. </author> <title> Sagas. </title> <editor> In Umeshwar Dayal and Irv Traiger, editors, </editor> <booktitle> Proceedings of the 1987 SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 249-259. </pages> <publisher> ACM, </publisher> <month> May </month> <year> 1987. </year> <month> 19 </month>
Reference-contexts: This may be reasonable if the condition is expected to be satisfied soon or if it is deemed non-essential in a particular case. Another generalization is based on the database concept of compensating transactions as a technique for recovery from transaction failure <ref> [11] </ref>.
Reference: [12] <author> Narain Gehani, Krithi Ramamritham, and Oded Shmueli. </author> <title> Accessing extra database information: Concurrency control and correctness. </title> <type> Technical Report CMPSCI Technical Report 93-81, </type> <institution> Computer Science Department, University of Massachusetts, Amherst, Massachusetts, </institution> <month> 01003, August </month> <year> 1993. </year>
Reference-contexts: System-Application Conflicts The idea that conflicts may occur between application and system processes is also present in databases in the form of extra-data transactions <ref> [12] </ref>. In extra-data transactions, application transactions access some sort of data that are not among the application data managed by a database. These "extra" data may be outside the database system entirely (e.g., transient local variables) or part of the internals of the database-management system (e.g., transaction serialization graphs).
Reference: [13] <author> Dennis Heimbigner. </author> <title> The process modeling example problem and its solutions. </title> <booktitle> In Proc. of the First International Conference on the Software Process, </booktitle> <pages> page 174, </pages> <address> 1991. Redondo Beach, California, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: Here, data are shared again by the two categories of process, but the data lie in the application domain rather than the system domain. These two cases are illustrated in Figure 2. 15 State Models of Task Execution State models have been widely used to represent process-task execution (e.g., <ref> [13] </ref>). The approach is perhaps epitomized by the Process-Wall [14], a language- and process-independent server for process state. Task states that are currently represented by the ProcessWall include specified, initiated, scheduled, enabled, running, suspended, done, and aborted. Provisional execution can be accommodated in this model at several points.
Reference: [14] <author> Dennis Heimbigner. </author> <title> The ProcessWall: A Process State Server Approach to Process Programming. </title> <booktitle> In Proc. Fifth ACM SIGSOFT/SIGPLAN Symposium on Software Development Environments, </booktitle> <address> Washington, D.C., </address> <month> 9-11 December </month> <year> 1992. </year>
Reference-contexts: These two cases are illustrated in Figure 2. 15 State Models of Task Execution State models have been widely used to represent process-task execution (e.g., [13]). The approach is perhaps epitomized by the Process-Wall <ref> [14] </ref>, a language- and process-independent server for process state. Task states that are currently represented by the ProcessWall include specified, initiated, scheduled, enabled, running, suspended, done, and aborted. Provisional execution can be accommodated in this model at several points.
Reference: [15] <author> Karen E. Huff and Victor Lesser. </author> <title> A plan-based intelligent assistent that supports the software development process. </title> <booktitle> In ACM Symposium on Practical Software Development Environments, </booktitle> <pages> pages 97 - 106, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Preconditions and postconditions are widely used in execution models for software processes <ref> [17, 6, 24, 25, 16, 15] </ref>. These conditions typically characterize process or product state and allow process execution to be controlled accordingly. <p> APPL/A [22, 24] has predicates that can be enforced as constraining postconditions on relation operations. SLANG [2] and Melmac [8] have what might be called selecting preconditions; these are guards on alternative execution paths which are used to control branching execution. Grapple <ref> [15] </ref> makes use of postcondition goals in process planning and recognition. 4 In these systems (and others) the most common use of preconditions and postconditions is to control or otherwise affect process execution.
Reference: [16] <author> G. Junkermann, B. Peuschel, W. Schafer, and S Wolf. MERLIN: </author> <title> Supporting coop eration in software development through a knowledge-based environment. </title> <editor> In Anthony Finkelstein, Jeff Kramer, and Bashar Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, </booktitle> <pages> pages 103 - 129. </pages> <publisher> John Wiley & Sons Inc., </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Preconditions and postconditions are widely used in execution models for software processes <ref> [17, 6, 24, 25, 16, 15] </ref>. These conditions typically characterize process or product state and allow process execution to be controlled accordingly. <p> Execution models that incorporate preconditions and postconditions may be called condition-based. A large variety of condition-based execution model have been developed. Merlin <ref> [16] </ref> has consistency conditions and automation conditions. Both assert changes to object state (i.e., status) as a postcondition effect for completed action, but either kind of condition can lead to the triggering of a corresponding kind of transaction (for which the condition serves as a precondition). <p> However, the scale of large software projects, the computational complexity of many development activities, and the inherent need for manual support, imply that long transactions cannot be entirely avoided. The transaction model proposed in <ref> [16] </ref> addresses this situation by providing both optimistic concurrency-control for transaction that may be more readily aborted and pessimistic concurrency-control for transactions that should be protected against aborts. <p> A different approach to reducing the incidence of conflicts is to partition the data spaces in which condition evaluations and process tasks are conducted. One variant on this is the segregation of product state from product attributes, as practiced, for example, in Marvel [17] and Merlin <ref> [16] </ref>. <p> Another variant is the use of segregated workspaces for process tasks. Workspaces are used in a number of systems (including some that do not support automatic evaluation of preconditions or postconditions) <ref> [5, 7, 16, 10] </ref>. Conditions on product state can be evaluated in a central repository while updates proceed in parallel on local copies of the product. Condition evaluations within a workspace can be coordinated with the local task without holding up tasks in other workspaces. <p> Provisional execution does not require that process tasks run to completion before their viability is determined. However, it shares an optimistic outlook in that it presumes that conflicts will not usually stand in the way of the completion of the task. The transaction model defined in <ref> [16] </ref> makes use of both optimistic and pessimistic concurrency control for cooperation in software processes (where pessimistic concurrency control is based on locking). Semantics-based Control The transaction model defined in [16] is also relevant to the case for provisional execution because it accepts that some activities may be allowed to run <p> The transaction model defined in <ref> [16] </ref> makes use of both optimistic and pessimistic concurrency control for cooperation in software processes (where pessimistic concurrency control is based on locking). Semantics-based Control The transaction model defined in [16] is also relevant to the case for provisional execution because it accepts that some activities may be allowed to run a greater risk of abort than others and that the process engineer or even process participant should be able to make judgements in this regard.
Reference: [17] <author> Gail E. Kaiser, Naser S. Barghouti, and Michael H. Sokolsky. </author> <title> Experience with process modeling in the marvel software development environment kernel. </title> <editor> In Bruce Shriver, editor, </editor> <booktitle> 23rd Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 131-140, </pages> <address> Kona HI, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Preconditions and postconditions are widely used in execution models for software processes <ref> [17, 6, 24, 25, 16, 15] </ref>. These conditions typically characterize process or product state and allow process execution to be controlled accordingly. <p> A different approach to reducing the incidence of conflicts is to partition the data spaces in which condition evaluations and process tasks are conducted. One variant on this is the segregation of product state from product attributes, as practiced, for example, in Marvel <ref> [17] </ref> and Merlin [16].
Reference: [18] <author> Takuya Katayama and Sumio Motizuki. </author> <title> What has been learned from applying a formal process model to a real process. </title> <booktitle> In Proc. 7th International Software Process Workshop, 1991. </booktitle> <address> Yountville, California. </address>
Reference-contexts: For example, it may not always be cost effective or technologically feasible to break tasks down into the finest possible subunits of conditional control. At that level of granularity, the process models may become too cumbersome or rigid (see, for example, <ref> [18] </ref>), or the costs of condition evaluation may become too burdensome. It may further be difficult to break down especially creative and contingent tasks into discreet subtasks and to anticipate the conditions that may affect their internal control.
Reference: [19] <institution> Programming Systems Laboratory. Marvel 3.0 administrator's manual. </institution> <type> Technical Re port TR CUCS-032-91, </type> <institution> Columbia University, </institution> <address> New York, New York 10027, </address> <year> 1991. </year>
Reference-contexts: Merlin [16] has consistency conditions and automation conditions. Both assert changes to object state (i.e., status) as a postcondition effect for completed action, but either kind of condition can lead to the triggering of a corresponding kind of transaction (for which the condition serves as a precondition). Marvel <ref> [19] </ref> rules have a property list that must be satisfied by the given arguments before the rule can be fired. These property lists act as guarding preconditions on user-invoked rules and as triggering preconditions on automation rule chains.
Reference: [20] <author> Victor R. Lesser. </author> <title> Multiagent systems: An emerging subdiscipline of AI. </title> <journal> ACM Comput ing Surveys, </journal> <note> 1995. to appear. </note>
Reference-contexts: The incomplete parts have a formal representation and semantics, which are important in accommodating inconsistency and indeterminacy, as well. Uncertainty Coping with uncertainty is a central problem in multi-agent systems, an emerging sub-discipline of artificial intelligence <ref> [20] </ref>. In these systems, individual agents must interact in the solution of interdependent subproblems. However, the interactions are generally imperfect due to limited communication bandwidth, heterogeneity among the agents, and dynamism in the environment.
Reference: [21] <author> Barbara Liskov and Liuba Shrira. </author> <title> Promises: Linguistic support for efficient asyn chronous procedure calls in distributed systems. </title> <type> Technical Report Programming Methodology Group Memo 60-1, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA 02139, </address> <month> March </month> <year> 1988. </year> <month> 20 </month>
Reference-contexts: Delayed Results The idea that the evaluation of a needed result may be delayed is embodied in promises in the Argus system <ref> [21] </ref>. A promise is a placeholder for a result that will be computed and returned via asynchronous remote procedure call. One of the advantages of promises, as for provisional execution, is that the computation of the value can proceed in parallel with the program that needs the value.
Reference: [22] <author> Stanley M. Sutton, Jr. FCM: </author> <title> A flexible consistency model for software processes. </title> <type> Tech nical Report CU-CS-462-90, </type> <institution> University of Colorado, Department of Computer Science, Boulder, Colorado 80309, </institution> <year> 1990. </year>
Reference-contexts: As preconditions these constraints can serve guards, as postconditions they can serve as constraints, and in either case they may serve to trigger operations that are supplemental to the invoked operation. APPL/A <ref> [22, 24] </ref> has predicates that can be enforced as constraining postconditions on relation operations. SLANG [2] and Melmac [8] have what might be called selecting preconditions; these are guards on alternative execution paths which are used to control branching execution.
Reference: [23] <author> Stanley M. Sutton, Jr. </author> <title> A flexible consistency model for persistent data in software process programming languages. </title> <editor> In Alan Dearle, Gail M. Shaw, and Stanley B. Zdonik, editors, </editor> <booktitle> Implementing Persistent Object Bases Principles and Practice, </booktitle> <pages> pages 305-318. </pages> <publisher> Morgan Kaufman, </publisher> <year> 1991. </year>
Reference-contexts: It has been argued that inconsistency of software data is unavoidable during software development and so mechanisms should be offered to allow work to proceed in the face of inconsistency <ref> [23, 1] </ref>. The corresponding point is made here that indeterminacy is unavoidable, although the reasons and response are different. The AdaPIC analysis tool-set [26] accommodates incompleteness of module specifications in the analysis of inter-module provide/request relationships.
Reference: [24] <author> Stanley M. Sutton, Jr., Dennis Heimbigner, and Leon J. Osterweil. APPL/A: </author> <title> A lan guage for software-process programming. </title> <journal> ACM Trans. on Software Engineering and Methodology, </journal> <volume> 4(3), </volume> <month> July </month> <year> 1995. </year> <note> to appear. </note>
Reference-contexts: 1 Introduction Preconditions and postconditions are widely used in execution models for software processes <ref> [17, 6, 24, 25, 16, 15] </ref>. These conditions typically characterize process or product state and allow process execution to be controlled accordingly. <p> As preconditions these constraints can serve guards, as postconditions they can serve as constraints, and in either case they may serve to trigger operations that are supplemental to the invoked operation. APPL/A <ref> [22, 24] </ref> has predicates that can be enforced as constraining postconditions on relation operations. SLANG [2] and Melmac [8] have what might be called selecting preconditions; these are guards on alternative execution paths which are used to control branching execution. <p> A related strategy is to make less use of condition-based execution. Alternatives would be, for example, to make more use of imperative or event-triggered (as opposed to condition-triggered) control models. These execution models certainly seem to have a place in software processes <ref> [24, 5] </ref>. However, they do not, in and of themselves, address the persistent need for conditional execution, consistency management, and so on.
Reference: [25] <author> Peri L. Tarr and Lori A. Clarke. PLEIADES: </author> <title> An Object Management System for Soft ware Engineering Environments. </title> <booktitle> In Proceedings of the First ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 56-70, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Preconditions and postconditions are widely used in execution models for software processes <ref> [17, 6, 24, 25, 16, 15] </ref>. These conditions typically characterize process or product state and allow process execution to be controlled accordingly. <p> EPOS [7] has both static and dynamic preconditions and postconditions. The static conditions are used for planning, the dynamic conditions are used for triggering actions or reactions. Pleiades <ref> [25] </ref> provides a constraint construct that may be evaluated as a precondition or postcondition to operations on instances of abstract data types.
Reference: [26] <author> Alexander L. Wolf, Lori A. Clarke, and Jack C. Wileden. </author> <title> The adapic toolset: Support ing interface control and analysis throughout the software development process. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 15(3) </volume> <pages> 250-263, </pages> <month> March </month> <year> 1989. </year> <month> 21 </month>
Reference-contexts: The corresponding point is made here that indeterminacy is unavoidable, although the reasons and response are different. The AdaPIC analysis tool-set <ref> [26] </ref> accommodates incompleteness of module specifications in the analysis of inter-module provide/request relationships. The incomplete parts have a formal representation and semantics, which are important in accommodating inconsistency and indeterminacy, as well. Uncertainty Coping with uncertainty is a central problem in multi-agent systems, an emerging sub-discipline of artificial intelligence [20].
References-found: 26

