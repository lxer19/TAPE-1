URL: http://www-icparc.doc.ic.ac.uk/papers/new_structures_of_symbolic_constraint_ob.ps
Refering-URL: http://www-icparc.doc.ic.ac.uk/papers.html
Root-URL: 
Email: email: carmen@ecrc.de  
Title: New structures of symbolic constraint objects: sets and graphs Extended abstract  
Author: Carmen Gervet 
Date: March 17, 1993  
Address: Arabellastr. 17, D-8000 Munich 81, Germany  
Affiliation: European Computer-Industry Research Centre  
Abstract: 1 Abstract 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. L. Lauriere. </author> <title> Resolution de problemes par l'homme et la machine. </title>
Reference-contexts: Our constraint handler for sets and graphs provides efficient constraint propagation under the control of the system. So, defining sets and graphs as constraint fl WCLP'93, Marseille 1 object contributes, without consequential loss of efficiency, to enhance the lan-guage expressiveness. Our approach is then much closer to ALICE <ref> [1] </ref> and CLPS [3] than to SETL [7]. Our approach is also economical because the semantics of sets and graphs is built into our representation. This reduces the number of variables to represent particular constraints. Let us take an example coming from J.L. Lauriere which illustrates our point.
Reference: [2] <author> J. L. Lauriere. </author> <title> A language and a program for stating and solving combinatorial problems. </title> <journal> Artificial Intelligence, </journal> <volume> 10 </volume> <pages> 29-127, </pages> <year> 1978. </year>
Reference-contexts: A single image for each element belonging to I means that only one x ij is set to 1. This representation enforcement is very costly as soon as the number of variables increases <ref> [2] </ref>. Our representation, on the contrary, uses only two variables in each constraint: card (successor (j))=1. 3 The semantic aspect Let us now describe what are the theorical foundations of set and graph constraints. The principal idea is the one of invariant handling.
Reference: [3] <author> B. Legeard and E. Legros. </author> <title> Test de satisfaisabilite dans le langage de pro-grammation en logique avec contraintes ensemblistes: </title> <booktitle> CLPS. </booktitle> <pages> pages pp 18-34. </pages> <institution> Actes des JFPL, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: So, defining sets and graphs as constraint fl WCLP'93, Marseille 1 object contributes, without consequential loss of efficiency, to enhance the lan-guage expressiveness. Our approach is then much closer to ALICE [1] and CLPS <ref> [3] </ref> than to SETL [7]. Our approach is also economical because the semantics of sets and graphs is built into our representation. This reduces the number of variables to represent particular constraints. Let us take an example coming from J.L. Lauriere which illustrates our point.
Reference: [4] <author> T. Munakata. </author> <title> Notes on implementing sets in prolog. </title> <journal> Communications of ACM, </journal> <month> Mars </month> <year> 1992. </year>
Reference-contexts: natural, concise, declarative, expressive and efficient manner real Operations Research problems which are based on set and graph theory. 2 A constraint object is more suitable than a variable Usually the addition of new variables denoting sets to logic programs extends the unification algorithms to the involvment of these formulas <ref> [4] </ref>. As any added value to a language, it proves to be detrimental to the initial language performances. Moreover set unification is NP-complete [5]. Our constraint handler for sets and graphs provides efficient constraint propagation under the control of the system.
Reference: [5] <author> Kenneth J. Perry, Krishna V. Palem, Ken MacAloon, and Gabriel M. Kuper. </author> <title> The complexity of logic programming with sets. </title> <institution> Computer Science, 1986. IBM research report. </institution>
Reference-contexts: As any added value to a language, it proves to be detrimental to the initial language performances. Moreover set unification is NP-complete <ref> [5] </ref>. Our constraint handler for sets and graphs provides efficient constraint propagation under the control of the system. So, defining sets and graphs as constraint fl WCLP'93, Marseille 1 object contributes, without consequential loss of efficiency, to enhance the lan-guage expressiveness.
Reference: [6] <author> M. Sakarovitch. </author> <title> Optimisation combinatoire: </title> <editor> graphes et programmation lineaire. </editor> <publisher> Hermann, </publisher> <year> 1984. </year>
Reference-contexts: In addition to the relational constraints, some particular constraints have been defined as symmetrical, con-nexity, completude, transitivity, path ... in parallel with operators hamiltonian cycle, transitive closure,... These descriptive and dynamic definitions should free the programmer from having to choose a representation to suit the applied constraints <ref> [6] </ref>. 2 5 Conclusion The definition of set and relational constraints has been conducted by the following arguments: the use of graphs is not rare in the Operations Research environment. Furthermore, the programmer should not encounter difficulties in defining his problem.
Reference: [7] <author> J. T. Schwartz, R. B. Dewar, E. Dubinsky, and E. Schonberg. </author> <title> Programming with sets An introduction to SETL. </title> <publisher> Springer-Verlag Ed., </publisher> <address> Berlin, </address> <year> 1986. </year> <month> 3 </month>
Reference-contexts: So, defining sets and graphs as constraint fl WCLP'93, Marseille 1 object contributes, without consequential loss of efficiency, to enhance the lan-guage expressiveness. Our approach is then much closer to ALICE [1] and CLPS [3] than to SETL <ref> [7] </ref>. Our approach is also economical because the semantics of sets and graphs is built into our representation. This reduces the number of variables to represent particular constraints. Let us take an example coming from J.L. Lauriere which illustrates our point.
References-found: 7

