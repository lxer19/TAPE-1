URL: http://www.cs.ucsd.edu/~calder/papers/wrl-95_6.ps.Z
Refering-URL: http://www.cs.ucsd.edu/~calder/papers.html
Root-URL: http://www.cs.ucsd.edu
Title: The Predictability of Branches in Libraries  
Phone: 1 9 9 5  
Author: Brad Calder Dirk Grunwald Amitabh Srivastava 
Date: 95/6  
Note: O C T O B E R  
Pubnum: Research Report  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Thomas Ball and James R. Larus. </author> <title> Branch prediction for free. </title> <booktitle> In Proceedings of the SIGPLAN'93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 300-313, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: However, many researchers believe that collecting profile information is too costly or time-consuming, and that many programmers may not collect such information. Thus, there has been considerable interest in heuristic prediction, or predicting the behavior of a program from the program's structure <ref> [1, 4, 16, 14] </ref>. These methods use heuristics or statistical information to predict a programs behavior. <p> Ball and Larus proposed several heuristics for predicting a program's behavior at compile time <ref> [1] </ref>. In a later study [4], we found their heuristics to be reasonably accurate, resulting in a 25% mispredict rate at compile time without profile information. By comparison, perfect profile prediction had a 8% miss rate for the same collection of programs. <p> The column labeled BTFNT represents the conditional branch miss rates using the backwards-taken, forwards-not-taken static branch prediction technique. The next column, labeled B&L, shows the miss rates due to the heuristics as defined by Ball and Larus <ref> [1] </ref>. We use the same implementation for the B&L heuristics in this study as was used in the previous ESP study [4]. Table 6 describes the heuristics in detail. <p> The pre-determined order is shown in Table 6, going from top to bottom, starting with the Loop-Branch heuristic ending with the Guard heuristic. This order was found to be one of the most effective orderings in the Ball and Larus study <ref> [1] </ref>. The Weight column in Table 5 represents the static profile-based miss rates using the weighted cross-validation profile, and Norm represents the miss rates using the normalized cross-validation profile. <p> Beside the obvious implications for improvements in shared libraries, the fact that library routines can be accurately predicted by profiles from different applications implies that static branch prediction methods, such as those of Ball and Larus <ref> [1] </ref>, our own method [4] and related methods [14, 16], can be improved.
Reference: [2] <author> M. Berry. </author> <title> The Perfect Club Benchmarks: Effective performance evaluation of supercomputers. </title> <journal> The International Journal of Supercomputer Applications, </journal> <volume> 3(3) </volume> <pages> 5-40, </pages> <month> Fall </month> <year> 1989. </year>
Reference-contexts: We instrumented the programs from the SPEC92 benchmark suite and other programs, including many from the Perfect Club <ref> [2] </ref> suite and a large number of applications for the X window system. We used ATOM to instrument the programs [13]. The programs were compiled on a variety of DEC Alpha workstations using the Alpha AXP-21064 processor with either the DEC C, C++ or FORTRAN compilers.
Reference: [3] <author> Brad Calder and Dirk Grunwald. </author> <title> Reducing branch costs via branch alignment. </title> <booktitle> In Six International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 242-251. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Profile-guided code optimizations have been shown to be effective by several researchers. Among these optimizations are basic block and procedure layout optimizations to improve cache and branch behavior <ref> [3, 10, 12] </ref>, register allocation, and trace scheduling [5, 6, 11, 7]. The technique that all these optimizations have in common is that they use profiles from a previous run of a given program to predict the behavior of a future run of the same program. <p> Pettis and Hansen [12] and Hwu and Chang [10] both examined profile optimizations to improve instruction locality. They found both basic block reordering algorithms and procedure layout algorithms effective at reducing the instruction cache miss rate. In a similar study <ref> [3] </ref>, we showed that profile-based basic block reordering (Branch Alignment) improved dynamic branch prediction and eliminated misfetch penalties. Furthermore, Young and Smith [17] have examined static correlated branch prediction techniques that rely on correlated profile information.
Reference: [4] <author> Brad Calder, Dirk Grunwald, Donald Lindsay, James Martin, Michael Mozer, and Benjamin Zorn. </author> <title> Corpus-based static branch prediction. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 79-92. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: However, many researchers believe that collecting profile information is too costly or time-consuming, and that many programmers may not collect such information. Thus, there has been considerable interest in heuristic prediction, or predicting the behavior of a program from the program's structure <ref> [1, 4, 16, 14] </ref>. These methods use heuristics or statistical information to predict a programs behavior. <p> Ball and Larus proposed several heuristics for predicting a program's behavior at compile time [1]. In a later study <ref> [4] </ref>, we found their heuristics to be reasonably accurate, resulting in a 25% mispredict rate at compile time without profile information. By comparison, perfect profile prediction had a 8% miss rate for the same collection of programs. <p> We collected a feature vector describing an individual conditional branch, and then used various machine-learning techniques to determine what combination of features, if any, accurately predicted the branches. We have considered two techniques; the first, described in <ref> [4] </ref>, uses a neural network to combine the information from the feature vectors, and the second technique uses decision trees to accomplish the same goal. We found that we could create heuristics to be used at compile time for a specific compiler, language and architecture. <p> The next column, labeled B&L, shows the miss rates due to the heuristics as defined by Ball and Larus [1]. We use the same implementation for the B&L heuristics in this study as was used in the previous ESP study <ref> [4] </ref>. Table 6 describes the heuristics in detail. The heuristics were applied one by one in a pre-determined 10 order, and branches not being predicted by a heuristic are predicted using a uniform random distribution. <p> Beside the obvious implications for improvements in shared libraries, the fact that library routines can be accurately predicted by profiles from different applications implies that static branch prediction methods, such as those of Ball and Larus [1], our own method <ref> [4] </ref> and related methods [14, 16], can be improved. <p> BTFNT represents the miss rate when all branches are predicted using BTFNT, B&L shows the miss rates when the Ball and Larus heuristics are used to predict all conditional branches, and ESP shows the average Evidence-based Static Prediction miss rate <ref> [4] </ref>. Norm shows the miss rate when the normalized cross-validation profile is used to predict branches in the library, and all non-profiled branches and the branches in the main program module use B&L heuristic prediction.
Reference: [5] <author> P. P. Chang and W. W. Hwu. </author> <title> Profile-guided automatic inline expansion for C programs. </title> <journal> Software Practice and Experience, </journal> <volume> 22(5) </volume> <pages> 349-376, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Profile-guided code optimizations have been shown to be effective by several researchers. Among these optimizations are basic block and procedure layout optimizations to improve cache and branch behavior [3, 10, 12], register allocation, and trace scheduling <ref> [5, 6, 11, 7] </ref>. The technique that all these optimizations have in common is that they use profiles from a previous run of a given program to predict the behavior of a future run of the same program.
Reference: [6] <author> P. P. Chang, S. A. Mahlke, and W. W. Hwu. </author> <title> Using profile information to assist classic compiler code optimizations. </title> <journal> Software Practice and Experience, </journal> <volume> 21(12) </volume> <pages> 1301-1321, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Profile-guided code optimizations have been shown to be effective by several researchers. Among these optimizations are basic block and procedure layout optimizations to improve cache and branch behavior [3, 10, 12], register allocation, and trace scheduling <ref> [5, 6, 11, 7] </ref>. The technique that all these optimizations have in common is that they use profiles from a previous run of a given program to predict the behavior of a future run of the same program.
Reference: [7] <author> Pohua P. Chang, Daniel M. Lavery, Scott A. Mahlke, William Y. Chen, and Wen mei W. Hwu. </author> <title> The importance of prepass code scheduling for superscalar and superpipelined processors. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 44(3) </volume> <pages> 353-370, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction Profile-guided code optimizations have been shown to be effective by several researchers. Among these optimizations are basic block and procedure layout optimizations to improve cache and branch behavior [3, 10, 12], register allocation, and trace scheduling <ref> [5, 6, 11, 7] </ref>. The technique that all these optimizations have in common is that they use profiles from a previous run of a given program to predict the behavior of a future run of the same program.
Reference: [8] <author> J. A. Fisher and S. M. Freudenberger. </author> <title> Predicting conditional branch directions from previous runs of a program. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <pages> pages 85-95, </pages> <address> Boston, Mass., </address> <month> October </month> <year> 1992. </year> <journal> ACM. </journal> <volume> 24 </volume>
Reference-contexts: The results showed that using profiles from a different run of the application achieved results close to that of a perfect profile from the same run. Fisher and Freudenberger confirmed this observation applied to static branch prediction <ref> [8] </ref>. They used traces from one execution of a program to predict the outcome of conditional branches for the same and different inputs. <p> This mispredict rate is comparable to the results Fisher and Freundenberger observed when using different runs of a program to predict the outcome of the same program <ref> [8] </ref>. They found for their C/Integer benchmarks that using different profiles gave them a prediction accuracy between 75% to 95% of perfect branch prediction.
Reference: [9] <author> Richard Hank, Scott Mahlke, Roger Bringmann, John Gyllenhaal, and Wen mei Hwu. </author> <title> Superblock formation using static program analysis. </title> <booktitle> In 26th International Symposium on Microarchitecture, </booktitle> <pages> pages 247-256. </pages> <publisher> IEEE, </publisher> <year> 1993. </year>
Reference-contexts: More recently, other studies have been performed using compile time heuristics to estimate profile information. These studies address a number of issues. First, it may be possible to use simple heuristics to estimate profiles, implying that profile-based optimizations can be performed using heuristics <ref> [9] </ref>.
Reference: [10] <author> Wen-mei W. Hwu and Pohua P. Chang. </author> <title> Achieving high instruction cache performance with an optimizing compiler. </title> <booktitle> In 16th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 242-251. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Profile-guided code optimizations have been shown to be effective by several researchers. Among these optimizations are basic block and procedure layout optimizations to improve cache and branch behavior <ref> [3, 10, 12] </ref>, register allocation, and trace scheduling [5, 6, 11, 7]. The technique that all these optimizations have in common is that they use profiles from a previous run of a given program to predict the behavior of a future run of the same program. <p> Certainly, dynamic branch prediction methods result in smaller mispredict rates, but statically predictable execution can be used for a number of optimizations. Pettis and Hansen [12] and Hwu and Chang <ref> [10] </ref> both examined profile optimizations to improve instruction locality. They found both basic block reordering algorithms and procedure layout algorithms effective at reducing the instruction cache miss rate. In a similar study [3], we showed that profile-based basic block reordering (Branch Alignment) improved dynamic branch prediction and eliminated misfetch penalties.
Reference: [11] <author> P.Geoffrey Lowney, Sefan M. Freudenberger, Thomas J. Karzes, W.D. Lichtenstein, Robert P. Nix, John S. O'Donnell, and John C. Ruttenberg. </author> <title> The multiflow trace scheduling compiler. </title> <journal> Journal of Supercomputing, </journal> <volume> 7 </volume> <pages> 51-142, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Profile-guided code optimizations have been shown to be effective by several researchers. Among these optimizations are basic block and procedure layout optimizations to improve cache and branch behavior [3, 10, 12], register allocation, and trace scheduling <ref> [5, 6, 11, 7] </ref>. The technique that all these optimizations have in common is that they use profiles from a previous run of a given program to predict the behavior of a future run of the same program.
Reference: [12] <author> Karl Pettis and Robert C. Hansen. </author> <title> Profile guided code positioning. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 16-27. </pages> <publisher> ACM, ACM, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Profile-guided code optimizations have been shown to be effective by several researchers. Among these optimizations are basic block and procedure layout optimizations to improve cache and branch behavior <ref> [3, 10, 12] </ref>, register allocation, and trace scheduling [5, 6, 11, 7]. The technique that all these optimizations have in common is that they use profiles from a previous run of a given program to predict the behavior of a future run of the same program. <p> Certainly, dynamic branch prediction methods result in smaller mispredict rates, but statically predictable execution can be used for a number of optimizations. Pettis and Hansen <ref> [12] </ref> and Hwu and Chang [10] both examined profile optimizations to improve instruction locality. They found both basic block reordering algorithms and procedure layout algorithms effective at reducing the instruction cache miss rate.
Reference: [13] <author> Amitabh Srivastava and Alan Eustace. </author> <title> ATOM: A system for building customized program analysis tools. </title> <booktitle> In Proceedings of the SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 196-205. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: We instrumented the programs from the SPEC92 benchmark suite and other programs, including many from the Perfect Club [2] suite and a large number of applications for the X window system. We used ATOM to instrument the programs <ref> [13] </ref>. The programs were compiled on a variety of DEC Alpha workstations using the Alpha AXP-21064 processor with either the DEC C, C++ or FORTRAN compilers.
Reference: [14] <author> Tim A. Wagner, Vance Maverick, Susan Graham, and Michael Harrison. </author> <title> Accurate static estimators for program optimization. </title> <booktitle> In Proceedings of the SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 85-96, </pages> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: However, many researchers believe that collecting profile information is too costly or time-consuming, and that many programmers may not collect such information. Thus, there has been considerable interest in heuristic prediction, or predicting the behavior of a program from the program's structure <ref> [1, 4, 16, 14] </ref>. These methods use heuristics or statistical information to predict a programs behavior. <p> In a later study [4], we found their heuristics to be reasonably accurate, resulting in a 25% mispredict rate at compile time without profile information. By comparison, perfect profile prediction had a 8% miss rate for the same collection of programs. Other studies by Wagner et. al. <ref> [14] </ref> and Wu and Larus [16] have focused on using these heuristics and other techniques to fully estimate a programs behavior at compile time. In a recent study, we examined an alternative technique for predicting program behavior by combining profile information gathered from a number of applications. <p> Beside the obvious implications for improvements in shared libraries, the fact that library routines can be accurately predicted by profiles from different applications implies that static branch prediction methods, such as those of Ball and Larus [1], our own method [4] and related methods <ref> [14, 16] </ref>, can be improved.
Reference: [15] <author> David W. Wall. </author> <title> Predicting program behavior using real or estimated profiles. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 59-70, </pages> <address> Toronto, Ontario, Canada, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: David Wall provided an early study on predicting the future behavior of a program using profiles <ref> [15] </ref>. The results showed that using profiles from a different run of the application achieved results close to that of a perfect profile from the same run. Fisher and Freudenberger confirmed this observation applied to static branch prediction [8].
Reference: [16] <author> Youfeng Wu and James R. Larus. </author> <title> Static branch frequency and program profile analysis. </title> <booktitle> In 27th International Symposium on Microarchitecture, </booktitle> <pages> pages 1-11, </pages> <address> San Jose, Ca, </address> <month> November </month> <year> 1994. </year> <note> IEEE. </note>
Reference-contexts: However, many researchers believe that collecting profile information is too costly or time-consuming, and that many programmers may not collect such information. Thus, there has been considerable interest in heuristic prediction, or predicting the behavior of a program from the program's structure <ref> [1, 4, 16, 14] </ref>. These methods use heuristics or statistical information to predict a programs behavior. <p> By comparison, perfect profile prediction had a 8% miss rate for the same collection of programs. Other studies by Wagner et. al. [14] and Wu and Larus <ref> [16] </ref> have focused on using these heuristics and other techniques to fully estimate a programs behavior at compile time. In a recent study, we examined an alternative technique for predicting program behavior by combining profile information gathered from a number of applications. <p> Beside the obvious implications for improvements in shared libraries, the fact that library routines can be accurately predicted by profiles from different applications implies that static branch prediction methods, such as those of Ball and Larus [1], our own method [4] and related methods <ref> [14, 16] </ref>, can be improved.

References-found: 16

