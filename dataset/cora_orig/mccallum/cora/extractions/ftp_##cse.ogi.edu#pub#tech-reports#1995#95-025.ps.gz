URL: ftp://cse.ogi.edu/pub/tech-reports/1995/95-025.ps.gz
Refering-URL: http://www.cse.ogi.edu/PacSoft/publications/bibliograph.html
Root-URL: http://www.cse.ogi.edu
Email: fegaras@cse.ogi.edu apt@cs.pdx.edu  
Title: Using Compact Data Representations for Languages Based on  
Author: Catamorphisms Leonidas Fegaras Andrew Tolmach 
Keyword: program transformation, compilation methods, data representations, catamor phisms.  
Address: Tech-report #95-025  
Affiliation: OGI,  Department of Computer Science Department of Computer Science Oregon Graduate Institute Portland State University  
Abstract: We describe a new method for improving the performance of functional programs based on catamorphisms. The method relies on using a compact vector representation for the recursive structure over which the catamorphism operates. This saves space and allows catamorphisms to be implemented in tail-recursive fashion even in cases where the standard linked structure representation requires non-tail-recursive evaluation. Preliminary experimental measurements show substantial improvements are possible with our approach. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Bird and O. de Moor. </author> <title> Solving Optimisation Problems with Catamorphisms. </title> <booktitle> In Mathematics of Program Construction, </booktitle> <pages> pp 45-66. </pages> <publisher> Springer-Verlag, LNCS 669, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: While catamorphisms can easily be expressed in terms of ordinary recursive functions, there has been much recent interest in exploiting a "higher-level" view of catamorphisms to improve program performance, in particular by performing program fusion <ref> [13, 3, 7, 1] </ref>. In this paper, we explore a new method for improving the performance of program with cata-morphisms over recursive structures. We optimize the representation of the structures, taking advantage of the fact that catamorphisms act on an entire structure as a unit in a highly stereotyped manner. <p> Our work on compact data representation is complementary to program fusion [2] and deforestation (the elimination of intermediate data structures) [14]. Catamorphisms have already been used as a good intermediate representation of programs that supports fusion and deforestation <ref> [13, 3, 7, 1] </ref>. Even though these methods do a good job on eliminating the unnecessary intermediate structures, some data structures do serve a true computational role and cannot be eliminated. In that case, a compact representation of these structures should improve system performance.
Reference: [2] <author> W. Chin. </author> <title> Safe Fusion of Functional Expressions. </title> <booktitle> Proceedings of the ACM Symposium on Lisp and Functional Programming, </booktitle> <address> San Francisco, California, </address> <pages> pp 11-20, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Her system assigns local constraints on list structures, in the form of selector fields attached to the list type, that are propagated using a Hindley-Milner type system. Our work on compact data representation is complementary to program fusion <ref> [2] </ref> and deforestation (the elimination of intermediate data structures) [14]. Catamorphisms have already been used as a good intermediate representation of programs that supports fusion and deforestation [13, 3, 7, 1].
Reference: [3] <author> L. Fegaras, T. Sheard, and T. Zhou. </author> <title> Improving Programs which Recurse over Multiple Inductive Structures. </title> <booktitle> In ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> Orlando, Florida, </address> <pages> pp 21-32, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: While catamorphisms can easily be expressed in terms of ordinary recursive functions, there has been much recent interest in exploiting a "higher-level" view of catamorphisms to improve program performance, in particular by performing program fusion <ref> [13, 3, 7, 1] </ref>. In this paper, we explore a new method for improving the performance of program with cata-morphisms over recursive structures. We optimize the representation of the structures, taking advantage of the fact that catamorphisms act on an entire structure as a unit in a highly stereotyped manner. <p> Our work on compact data representation is complementary to program fusion [2] and deforestation (the elimination of intermediate data structures) [14]. Catamorphisms have already been used as a good intermediate representation of programs that supports fusion and deforestation <ref> [13, 3, 7, 1] </ref>. Even though these methods do a good job on eliminating the unnecessary intermediate structures, some data structures do serve a true computational role and cannot be eliminated. In that case, a compact representation of these structures should improve system performance.
Reference: [4] <author> C. Hall. </author> <title> Using Hindley-Milner Type Inference to Optimize List Representation. </title> <booktitle> ACM conference on Lisp and Functional Programming, </booktitle> <address> Orlando, Florida, </address> <pages> pp 162-172, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: In particular, any recursive functions acting on linked list representations should be able to avoid wrapping and unwrapping around recursive calls. Other authors have attacked the problem of static dispatch from the other direction; they propose extended type systems (e.g., refinement types [12] or 2nd-order polymorphic -calculus <ref> [4] </ref>) that allow many checks to be performed statically, but fall back on runtime checks when necessary. We plan to consider these schemes in relation to ours more carefully. The vectorization condition is evaluated by means of an abstract interpretation on expressions. <p> The first list elements are stored in a vector that includes coding bits (captured in their system by k different value constructors). Thus, the only run-time overhead is when reading the first list elements. Some of these tests too can be eliminated statically. A similar approach is by Hall <ref> [4] </ref>. Even though her list representation requires the same run-time overhead as cdr-coding, she describes a system in which both linked and compact representations can be used in the same system.
Reference: [5] <author> W. J. Hansen. </author> <title> Compact List Representation: Definition, Garbage Collection, and System Implementation. </title> <journal> Communications of ACM, </journal> <volume> 12(9) </volume> <pages> 499-507, </pages> <month> September </month> <year> 1969. </year>
Reference-contexts: It can be traced back to the cdr-coding schemes for Lisp <ref> [5, 8, 6] </ref>. Under these schemes, lists are represented as linked vectors of fixed size. Consing an element to a list is done by filling in the first vector in the vector list, if there is space to do so, or by allocating a new vector to fill.
Reference: [6] <author> L. Harrison and D. Padua. </author> <title> PARCEL: Project for the Automatic Restructuring and Concurrent Evaluation of Lisp. </title> <booktitle> In ACM International Conference on Supercomputing, </booktitle> <pages> pp 527-538, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: It can be traced back to the cdr-coding schemes for Lisp <ref> [5, 8, 6] </ref>. Under these schemes, lists are represented as linked vectors of fixed size. Consing an element to a list is done by filling in the first vector in the vector list, if there is space to do so, or by allocating a new vector to fill.


Reference: [] <institution> Cons(a; r) ) e 3 </institution>
Reference: [8] <author> K. Li and P. Hudak. </author> <title> A New List Compaction Method. </title> <journal> Software Practice and Experience, </journal> <volume> 16(2) </volume> <pages> 145-163, </pages> <month> February </month> <year> 1986. </year>
Reference-contexts: It can be traced back to the cdr-coding schemes for Lisp <ref> [5, 8, 6] </ref>. Under these schemes, lists are represented as linked vectors of fixed size. Consing an element to a list is done by filling in the first vector in the vector list, if there is space to do so, or by allocating a new vector to fill.
Reference: [9] <author> E. Meijer, M. Fokkinga, and R. Paterson. </author> <title> Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire. </title> <booktitle> In Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, Massachusetts, </address> <pages> pp 124-144. </pages> <publisher> Springer-Verlag, LNCS 523, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: in reading efficiency (though, unlike for lists, some read operations are more expensive on the compact form); the analysis of writing is more complex. 2 2 Background The List data type may be defined as datatype List (ff) = Nil j Cons of ff fi List (ff) The list catamorphism <ref> [9, 13] </ref> captures functions with regular recursion over lists.
Reference: [10] <author> L. Paulson. </author> <title> ML for the working programmer. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: We describe a translation algorithm that converts list-processing programs into selectively vec-torized form. Our source language is a pure strict functional language with list constructors (essentially as in SML <ref> [10] </ref>), extended with catamorphisms viewed as primitive forms. The target language adds arrays and imperative update operations. Our analysis and translation works at the level of individual list-building expressions. We use abstract interpretation to identify which expressions that can be profitably modified to produce vector representations.
Reference: [11] <author> S. Peyton Jones and J. Launchbury. </author> <title> Unboxed Values as First Class Citizens in a Non-strict Functional Language. </title> <booktitle> Fifth Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, MA, </address> <pages> pp 636-665, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: A practical system should support both linked and compact representations in the same program. We suggest a simple solution based on "wrapping" lists with headers that allow vectorized and linked representations to be distinguished at runtime <ref> [11] </ref>. Wrapping and unwrapping are expensive operations, but are required only when passing lists to and from functions. Moreover, partial evaluation can be used to remove pairs of complementary wrap and unwrap operations for known functions.
Reference: [12] <author> Z. Shao, J. Reppy, and A. Appel. </author> <title> Unrolling Lists. </title> <booktitle> ACM conference on Lisp and Functional Programming, </booktitle> <address> Orlando, Florida, </address> <pages> pp 185-195, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: In particular, any recursive functions acting on linked list representations should be able to avoid wrapping and unwrapping around recursive calls. Other authors have attacked the problem of static dispatch from the other direction; they propose extended type systems (e.g., refinement types <ref> [12] </ref> or 2nd-order polymorphic -calculus [4]) that allow many checks to be performed statically, but fall back on runtime checks when necessary. We plan to consider these schemes in relation to ours more carefully. The vectorization condition is evaluated by means of an abstract interpretation on expressions. <p> All these methods rely on extra cdr-coding bits to identify how data are organized in each vector. These bits need to be checked at each node at run-time, which is quite expensive. Shao, Reppy, and Appel <ref> [12] </ref> propose a system that exploits compile-time analysis to eliminate most run-time checks. Their representation of a list of length n uses filled vectors of size k with no coding bits for all but the first (n mod k) list elements.
Reference: [13] <author> T. Sheard and L. Fegaras. </author> <title> A Fold for All Seasons. </title> <booktitle> Sixth Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pp 233-242, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: For lists, this operator is known as fold in ML and foldr in Haskell. Catamorphisms are quite powerful: for example, any primitive recursive function can be written as a catamorphism <ref> [13] </ref>. Catamorphisms may be specified by the user or, under some conditions, generated from ordinary recursive function code [7]. <p> While catamorphisms can easily be expressed in terms of ordinary recursive functions, there has been much recent interest in exploiting a "higher-level" view of catamorphisms to improve program performance, in particular by performing program fusion <ref> [13, 3, 7, 1] </ref>. In this paper, we explore a new method for improving the performance of program with cata-morphisms over recursive structures. We optimize the representation of the structures, taking advantage of the fact that catamorphisms act on an entire structure as a unit in a highly stereotyped manner. <p> in reading efficiency (though, unlike for lists, some read operations are more expensive on the compact form); the analysis of writing is more complex. 2 2 Background The List data type may be defined as datatype List (ff) = Nil j Cons of ff fi List (ff) The list catamorphism <ref> [9, 13] </ref> captures functions with regular recursion over lists. <p> Our work on compact data representation is complementary to program fusion [2] and deforestation (the elimination of intermediate data structures) [14]. Catamorphisms have already been used as a good intermediate representation of programs that supports fusion and deforestation <ref> [13, 3, 7, 1] </ref>. Even though these methods do a good job on eliminating the unnecessary intermediate structures, some data structures do serve a true computational role and cannot be eliminated. In that case, a compact representation of these structures should improve system performance.
Reference: [14] <author> P. Wadler. </author> <title> Deforestation: Transforming Programs to Eliminate Trees. </title> <booktitle> Proceedings of the 2nd European Symposium on Programming, Nancy, France, </booktitle> <pages> pp 344-358, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Her system assigns local constraints on list structures, in the form of selector fields attached to the list type, that are propagated using a Hindley-Milner type system. Our work on compact data representation is complementary to program fusion [2] and deforestation (the elimination of intermediate data structures) <ref> [14] </ref>. Catamorphisms have already been used as a good intermediate representation of programs that supports fusion and deforestation [13, 3, 7, 1]. Even though these methods do a good job on eliminating the unnecessary intermediate structures, some data structures do serve a true computational role and cannot be eliminated.
References-found: 14

