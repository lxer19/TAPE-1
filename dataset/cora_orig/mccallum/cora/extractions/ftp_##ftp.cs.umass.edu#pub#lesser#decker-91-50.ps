URL: ftp://ftp.cs.umass.edu/pub/lesser/decker-91-50.ps
Refering-URL: http://www-ccs.cs.umass.edu/~humphrey/home.html
Root-URL: 
Title: A Real-Time Control Architecture for an Approximate Processing Blackboard System a satisficing solution to a
Author: Keith Decker Alan Garvey Marty Humphrey Victor Lesser 
Note: An example is given that illustrates how these components work together to construct  Authors are listed in alphabetical order. This work was partly supported by the Office of Naval Research under a University Research Initiative grant number N00014-86-K-0764, NSF contract CDA 8922572, and ONR contract N00014-89-J-1877. The content of the information does not necessarily reflect the position or the policy of the Government, and no official endorsement should be inferred.  
Date: April 21, 1994  
Abstract: Approximate processing is an approach to real-time AI problem solving in domains in which compromise is possible between the resources required to generate a solution and the quality of that solution. It is a satisficing approach in which the goal is to produce acceptable solutions within the available time and computational resource constraints. Previous work has shown how to integrate approximate processing knowledge sources within the blackboard architecture[17]. However, in order to solve real-time problems with hard deadlines using a blackboard system, we need to have: (1) a predictable blackboard execution loop, (2) a representation of the set of current and future tasks and their estimated durations, and (3) a model of how to modify those tasks when their deadlines are projected to be missed, and how the modifications will affect the task durations and results. This paper describes four components for achieving this goal in an approximate processing blackboard system. A parameterized low-level control loop allows predictable knowledge source execution, multiple execution channels allow dynamic control over the computation involved in each task, a meta-controller allows a representation of the set of current and future tasks and their estimated durations and results, and a real-time blackboard scheduler monitors and modifies tasks during execution so that deadlines are met. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anne Collinot and Barbara Hayes-Roth. </author> <title> Real-time control of reasoning: Experiments with two control models. </title> <booktitle> In Proceedings of the Workshop on Innovative Approaches to Planning, Scheduling and Control, </booktitle> <pages> pages 263-270, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: We extend the ideas in BB1 by allowing a richer set of parameters (filters, mappings, and mergings, as well as heuristics) to be dynamically adjusted. Recent work by B. Hayes-Roth <ref> [1, 14] </ref> has also gone to a more complex low-level control loop that has additional parameters. The idea of dynamically adapting filters on input data for real-time systems has also been discussed in [18]; we tie this filtering into the problem of balancing predictability and opportunism. <p> In this work we have not concerned ourselves with making the low-level control loop predictable. This has been the focus of recent work by B. Hayes-Roth. Her work has extended the BB1 architecture to use a satisficing control loop that replaces the previous exhaustive control loop <ref> [1, 14] </ref>. The satisficing loop considers a limited number of events in best-first order and for each event attempts to trigger a limited set of operation types again in best-first order.
Reference: [2] <author> Daniel D. Corkill, Victor R. Lesser, and Eva Hudlick a. </author> <title> Unifying data-directed and goal-directed control: An example and experiments. </title> <booktitle> In Proceedings of the National Conference on Artificial Intelligence, </booktitle> <pages> pages 143-147, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> August </month> <year> 1982. </year>
Reference-contexts: Control in blackboard architectures that integrate multiple reasoning methods has traditionally been accomplished through the implicit or explicit construction of an agenda rating function that allows the scheduler to choose the best knowledge source instance (KSI) to execute <ref> [2, 13, 15] </ref>. A significant amount of work has been published advocating the use of explicit (non-procedural) control because it is conceptually clearer and more easily modified, as well as easier to explain [10, 11, 13].
Reference: [3] <author> David S. Day. </author> <title> Blackboard-based control in the PLASTYC agent architecture. </title> <booktitle> In Proceedings of the Fifth Workshop on Blackboard Systems, </booktitle> <address> Anaheim, CA, </address> <month> July </month> <year> 1991. </year> <month> 16 </month>
Reference-contexts: A single queue holds runnable KSIs from every active channel. We are investigating alternatives to this architectural decision, including maintaining a separate queue for every channel and either associating a processor with each queue or multiplexing among the queues <ref> [3, 9] </ref>, giving each channel a percentage of the total resources. Note that these alternatives may also help us to more easily bound control overhead by associating control with channels.
Reference: [4] <author> T. Dean and M. Boddy. </author> <title> An analysis of time-dependent planning. </title> <booktitle> In Proceedings of the Seventh National Conference on Artificial Intelligence, </booktitle> <pages> pages 49-54, </pages> <address> St. Paul, Minnesota, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Design-to-time scheduling is described in detail in Garvey and Lesser [12]. An alternative to the approximate processing approach to real-time AI problems is the class of algorithms called anytime algorithms <ref> [4] </ref>. Anytime algorithms are a subclass of approximate processing algorithms that can be terminated anytime and produce answers that improve 1 monotonically as the given time increases. In contrast, approximate processing algorithms produce an answer anytime after a given deadline.
Reference: [5] <author> Keith Decker, Alan Garvey, Marty Humphrey, and Victor Lesser. </author> <title> Effects of parallelism on blackboard system scheduling. </title> <booktitle> In Proceedings of the Twelfth International Joint Conference on Artificial Intelligence, </booktitle> <address> Sydney, Australia, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: The second component of our architecture is channels, which allow different processing strategies to be used simultaneously. A channel is a replication of the low-level control loop for a concurrent task. Having multiple channels allows multiple processing strategies to occur simultaneously, and potentially asynchronously or in parallel <ref> [5] </ref>, while still providing predictable execution. The RT-1 real-time blackboard architecture [9] used a fixed set of priority channels to partition problem-solving by event priority; in contrast, we dynamically create task channels to partition problem-solving by task.
Reference: [6] <author> Keith S. Decker, Alan J. Garvey, Victor R. Lesser, and Marty A. Humphrey. </author> <title> An approach to modeling environment and task characteristics for coordination. </title> <editor> In Charles J. Petrie, Jr., editor, </editor> <title> Enterprise Integration Modeling: </title> <booktitle> Proceedings of the First International Conference. </booktitle> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Another current area of investigation is the bounding of control overhead. While in the DVMT application the control overhead is acceptable, we need to address the issue of making the control overhead bounded and predictable. Additionally we are investigating real-time scheduling issues in a simulator <ref> [6] </ref>. In these experiments a parameterized simulation environment is used to generate sets of tasks for a design-to-time scheduler. These experiments will help us to understand how various aspects of the environment affect the performance of our scheduler.
Reference: [7] <author> Keith S. Decker and Victor R. Lesser. </author> <title> Analyzing a quantitative coordination relationship. </title> <type> COINS Technical Report 91-83, </type> <institution> University of Massachusetts, </institution> <month> November </month> <year> 1991. </year> <note> To appear in the journal Group Decision and Negotiation, </note> <year> 1993. </year>
Reference-contexts: This section describes an example problem in the domain of the DVMT. The particular DVMT environment we will work with is shown in Figure 2. (This is a single agent version of the DVMT. In the future we plan to extend this work to multiple distributed agents <ref> [7] </ref>.) This environment contains three objects: one fish, one duck, and one pigeon. The large dots along the lines represent the location of the object at the sensor time given by the adjoining number.
Reference: [8] <author> Keith S. Decker, Victor R. Lesser, and Robert C. Whitehair. </author> <title> Extending a blackboard architecture for approximate processing. </title> <journal> The Journal of Real-Time Systems, </journal> 2(1/2):47-79, 1990. 
Reference-contexts: 1 Introduction For the last several years we have been working on incorporating hard real-time deadlines into blackboard systems <ref> [8, 17] </ref>. <p> The focus of this paper is on the extensions to the blackboard framework that we made to support approximate processing. The design of predictable, useful approximations is discussed later in this section, and in detail in Decker, et al <ref> [8] </ref>. Design-to-time scheduling is described in detail in Garvey and Lesser [12]. An alternative to the approximate processing approach to real-time AI problems is the class of algorithms called anytime algorithms [4]. <p> With minimal overhead, the problem solver should dynamically respond to the current situation by altering its operators and state space abstraction to produce a range of acceptable answers <ref> [8, 17] </ref>. <p> The problem solver should be able to exploit existing partial results, rather than throw results away and start from scratch in some new representation. The three general classes of approximation that a problem solver can use are search approximation, data approximation, and knowledge approximation <ref> [8] </ref>. Examples of search approximation include eliminating the processing of corroborating support of existing partial results, and eliminating inferior competing alternatives. Data approximations aggregate data into abstract units that are then processed as a whole. <p> This reduces runtime to near zero, but has disastrous effects on certainty and precision. Usually this technique is used only when we intend to work on the data in more detail during a future sensor cycle. Other techniques are described in <ref> [8] </ref>. Consistent representations of approximate data allow the system to switch processing strategies without losing any partial results previously obtained [8]. One example of the usefulness of channels is that they allow different vehicles to be tracked using different approximate processing techniques concurrently. <p> Usually this technique is used only when we intend to work on the data in more detail during a future sensor cycle. Other techniques are described in <ref> [8] </ref>. Consistent representations of approximate data allow the system to switch processing strategies without losing any partial results previously obtained [8]. One example of the usefulness of channels is that they allow different vehicles to be tracked using different approximate processing techniques concurrently. For example, we might have two vehicles in our domain that have different degrees of threat or another measure of differing priority.
Reference: [9] <author> Rajendra T. Dodhiawala, N. S. Sridharan, and Cynthia Pickering. </author> <title> A real-time blackboard architecture. </title> <editor> In V. Jagannathan, Rajendra Dodhiawala, and Lawrence S. Baum, editors, </editor> <booktitle> Blackboard Architectures and Applications, </booktitle> <pages> pages 219-237. </pages> <publisher> Academic Press, Inc., </publisher> <year> 1989. </year>
Reference-contexts: A channel is a replication of the low-level control loop for a concurrent task. Having multiple channels allows multiple processing strategies to occur simultaneously, and potentially asynchronously or in parallel [5], while still providing predictable execution. The RT-1 real-time blackboard architecture <ref> [9] </ref> used a fixed set of priority channels to partition problem-solving by event priority; in contrast, we dynamically create task channels to partition problem-solving by task. This allows us to clearly decide which problem-solving resources to devote to each task 2 . Section 3.2 describes channels in more detail. <p> A single queue holds runnable KSIs from every active channel. We are investigating alternatives to this architectural decision, including maintaining a separate queue for every channel and either associating a processor with each queue or multiplexing among the queues <ref> [3, 9] </ref>, giving each channel a percentage of the total resources. Note that these alternatives may also help us to more easily bound control overhead by associating control with channels.
Reference: [10] <author> Edmund H. Durfee and Victor R. Lesser. </author> <title> Incremental planning to control a time-constrained, blackboard-based problem solver. </title> <journal> IEEE Transactions on Aerospace and Electronic Systems, </journal> <volume> 24(5), </volume> <month> September </month> <year> 1988. </year>
Reference-contexts: A significant amount of work has been published advocating the use of explicit (non-procedural) control because it is conceptually clearer and more easily modified, as well as easier to explain <ref> [10, 11, 13] </ref>. We modified the traditional BB1-style meta-controller to operate using hierarchically organized, explicit control goals that describe the current and predicted future behaviors of the system. Unlike BB1, future control goals are expanded to create future control plan elements, which predict future tasks.
Reference: [11] <author> Alan Garvey and Barbara Hayes-Roth. </author> <title> An empirical analysis of explicit vs. implicit control architectures. </title> <editor> In V. Jagannathan, Rajendra Dodhiawala, and Lawrence S. Baum, editors, </editor> <booktitle> Blackboard Architectures and Applications, </booktitle> <pages> pages 43-56. </pages> <publisher> Academic Press, Inc., </publisher> <year> 1989. </year>
Reference-contexts: A significant amount of work has been published advocating the use of explicit (non-procedural) control because it is conceptually clearer and more easily modified, as well as easier to explain <ref> [10, 11, 13] </ref>. We modified the traditional BB1-style meta-controller to operate using hierarchically organized, explicit control goals that describe the current and predicted future behaviors of the system. Unlike BB1, future control goals are expanded to create future control plan elements, which predict future tasks.
Reference: [12] <author> Alan Garvey and Victor Lesser. </author> <title> Design-to-time real-time scheduling. </title> <type> COINS Technical Report 91-72, </type> <institution> University of Massachusetts, </institution> <year> 1991. </year> <title> To appear, </title> <journal> IEEE Transactions on Systems, Man and Cybernetics, </journal> <year> 1993. </year>
Reference-contexts: The design of predictable, useful approximations is discussed later in this section, and in detail in Decker, et al [8]. Design-to-time scheduling is described in detail in Garvey and Lesser <ref> [12] </ref>. An alternative to the approximate processing approach to real-time AI problems is the class of algorithms called anytime algorithms [4]. Anytime algorithms are a subclass of approximate processing algorithms that can be terminated anytime and produce answers that improve 1 monotonically as the given time increases. <p> Current work is ongoing to extend these results in several ways. We have begun to look in detail at the design-to-time scheduling problem <ref> [12] </ref> and plan to continue in this direction by building more complex schedulers that take more of the available information into account.
Reference: [13] <author> Barbara Hayes-Roth. </author> <title> A blackboard architecture for control. </title> <journal> Artificial Intelligence, </journal> <volume> 26 </volume> <pages> 251-321, </pages> <year> 1985. </year>
Reference-contexts: The ability to dynamically modify the low-level control loop is an extension of ideas developed originally in BB1 for dynamically specifying the predicates used to evaluate activities on the agenda in order to impose different high-level strategies <ref> [13] </ref>. We extend the ideas in BB1 by allowing a richer set of parameters (filters, mappings, and mergings, as well as heuristics) to be dynamically adjusted. Recent work by B. Hayes-Roth [1, 14] has also gone to a more complex low-level control loop that has additional parameters. <p> Control in blackboard architectures that integrate multiple reasoning methods has traditionally been accomplished through the implicit or explicit construction of an agenda rating function that allows the scheduler to choose the best knowledge source instance (KSI) to execute <ref> [2, 13, 15] </ref>. A significant amount of work has been published advocating the use of explicit (non-procedural) control because it is conceptually clearer and more easily modified, as well as easier to explain [10, 11, 13]. <p> A significant amount of work has been published advocating the use of explicit (non-procedural) control because it is conceptually clearer and more easily modified, as well as easier to explain <ref> [10, 11, 13] </ref>. We modified the traditional BB1-style meta-controller to operate using hierarchically organized, explicit control goals that describe the current and predicted future behaviors of the system. Unlike BB1, future control goals are expanded to create future control plan elements, which predict future tasks.
Reference: [14] <author> Barbara Hayes-Roth and Anne Collinot. </author> <title> Scalability of real-time reasoning in intelligent agents. </title> <type> Technical Report KSL 91-08, </type> <institution> Knowledge Systems Laboratory, Stanford University, </institution> <year> 1991. </year>
Reference-contexts: We extend the ideas in BB1 by allowing a richer set of parameters (filters, mappings, and mergings, as well as heuristics) to be dynamically adjusted. Recent work by B. Hayes-Roth <ref> [1, 14] </ref> has also gone to a more complex low-level control loop that has additional parameters. The idea of dynamically adapting filters on input data for real-time systems has also been discussed in [18]; we tie this filtering into the problem of balancing predictability and opportunism. <p> In this work we have not concerned ourselves with making the low-level control loop predictable. This has been the focus of recent work by B. Hayes-Roth. Her work has extended the BB1 architecture to use a satisficing control loop that replaces the previous exhaustive control loop <ref> [1, 14] </ref>. The satisficing loop considers a limited number of events in best-first order and for each event attempts to trigger a limited set of operation types again in best-first order.
Reference: [15] <author> Frederick Hayes-Roth and Victor R. Lesser. </author> <title> Focus of attention in the Hearsay-II speech understanding system. </title> <booktitle> In Proceedings of the Fifth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 27-35, </pages> <month> August </month> <year> 1977. </year> <month> 17 </month>
Reference-contexts: Control in blackboard architectures that integrate multiple reasoning methods has traditionally been accomplished through the implicit or explicit construction of an agenda rating function that allows the scheduler to choose the best knowledge source instance (KSI) to execute <ref> [2, 13, 15] </ref>. A significant amount of work has been published advocating the use of explicit (non-procedural) control because it is conceptually clearer and more easily modified, as well as easier to explain [10, 11, 13].
Reference: [16] <author> Victor R. Lesser and Daniel D. Corkill. </author> <title> The distributed vehicle monitoring testbed. </title> <journal> AI Magazine, </journal> <volume> 4(3) </volume> <pages> 63-109, </pages> <month> Fall </month> <year> 1983. </year>
Reference: [17] <author> Victor R. Lesser, Jasmina Pavlin, and Edmund Durfee. </author> <title> Approximate processing in real-time problem solving. </title> <journal> AI Magazine, </journal> <volume> 9(1) </volume> <pages> 49-61, </pages> <month> Spring </month> <year> 1988. </year>
Reference-contexts: 1 Introduction For the last several years we have been working on incorporating hard real-time deadlines into blackboard systems <ref> [8, 17] </ref>. <p> With minimal overhead, the problem solver should dynamically respond to the current situation by altering its operators and state space abstraction to produce a range of acceptable answers <ref> [8, 17] </ref>.
Reference: [18] <author> Richard Washington and Barbara Hayes-Roth. </author> <title> Input data management in real-time AI systems. </title> <booktitle> In Proceedings of the Eleventh International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, MI, </address> <month> August </month> <year> 1989. </year> <month> 18 </month>
Reference-contexts: Recent work by B. Hayes-Roth [1, 14] has also gone to a more complex low-level control loop that has additional parameters. The idea of dynamically adapting filters on input data for real-time systems has also been discussed in <ref> [18] </ref>; we tie this filtering into the problem of balancing predictability and opportunism. The low-level control loop is discussed in detail in Section 3.1. The second component of our architecture is channels, which allow different processing strategies to be used simultaneously.
References-found: 18

