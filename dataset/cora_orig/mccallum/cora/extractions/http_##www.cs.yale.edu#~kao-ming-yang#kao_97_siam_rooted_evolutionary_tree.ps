URL: http://www.cs.yale.edu/~kao-ming-yang/kao_97_siam_rooted_evolutionary_tree.ps
Refering-URL: http://www.cs.yale.edu/~kao-ming-yang/papers.html
Root-URL: http://www.cs.yale.edu
Title: TREE CONTRACTIONS AND EVOLUTIONARY TREES  
Author: MING-YANG KAO 
Keyword: Key words. minimal condensed forms, tree contractions, evolutionary trees, computational biology  
Note: AMS(MOS) subject classifications. 05C05, 05C85, 05C90, 68Q25, 92B05  
Abstract: An evolutionary tree is a rooted tree where each internal vertex has at least two children and where the leaves are labeled with distinct symbols representing species. Evolutionary trees are useful for modeling the evolutionary history of species. An agreement subtree of two evolutionary trees is an evolutionary tree which is also a topological subtree of the two given trees. We give an algorithm to determine the largest possible number of leaves in any agreement subtree of two trees T 1 and T 2 with n leaves each. If the maximum degree d of these trees is bounded by a constant, the time complexity is O(n log 2 n) and is within a log n factor of optimal. For general d, this algorithm runs in O(nd 2 log d log 2 n) time or alternately in O(nd p d log 3 n) time. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Abrahamson, N. Dadoun, D. G. Kirkpatrick, and T. Przytycka, </author> <title> A simple tree contraction algorithm, </title> <journal> Journal of Algorithms, </journal> <volume> 10 (1989), </volume> <pages> pp. 287-302. </pages>
Reference-contexts: For general d, this algorithm runs in O (nd 2 log d log 2 n) time or alternately in O (nd p 3 n) time. This algorithm employs new tree contraction techniques <ref> [1, 22, 38, 40, 41] </ref>. With tree contraction, we can immediately obtain an O (n log 5 n)-time algorithm for d bounded by a constant. Reducing the time bound to O (n log 2 n) requires additional techniques. <p> brevity, from here onwards, radix sort refers to both integer and radix sorts.) For this reason, we make the following integer indexing assumptions: * An integer array of size O (n) is allocated to each algorithm. * The vertices of T 1 and T 2 are indexed by integers from <ref> [1; O (n)] </ref>. * The leaf labels are indexed by integers from [1; O (n)]. We call Zero-Zero only once to compare two given trees. Consequently, we may reasonably assume that the tree vertices are indexed with integers from [1; O (n)]. <p> sorts.) For this reason, we make the following integer indexing assumptions: * An integer array of size O (n) is allocated to each algorithm. * The vertices of T 1 and T 2 are indexed by integers from <ref> [1; O (n)] </ref>. * The leaf labels are indexed by integers from [1; O (n)]. We call Zero-Zero only once to compare two given trees. Consequently, we may reasonably assume that the tree vertices are indexed with integers from [1; O (n)]. When we call Zero-Zero, we simply allocate an array of size O (n). <p> of T 1 and T 2 are indexed by integers from <ref> [1; O (n)] </ref>. * The leaf labels are indexed by integers from [1; O (n)]. We call Zero-Zero only once to compare two given trees. Consequently, we may reasonably assume that the tree vertices are indexed with integers from [1; O (n)]. When we call Zero-Zero, we simply allocate an array of size O (n). As for indexing the leaf labels, this paper considers only evolutionary trees whose leaf labels are drawn tree contractions and evolutionary trees 9 from a total order. <p> As for indexing the leaf labels, this paper considers only evolutionary trees whose leaf labels are drawn tree contractions and evolutionary trees 9 from a total order. Before we call Zero-Zero, we can sort the leaf labels and index them with integers from <ref> [1; O (n)] </ref>. This preprocessing takes O (n log n) time, which is well within our desired time complexity for Zero-Zero. The other four algorithms are called more than once, and their integer indexing assumptions are maintained in slightly different situations from that for Zero-Zero. <p> The upper and lower halves of an even length tree contractions and evolutionary trees 13 [k 1 ; k 2 ] are [k 1 ; k 1 +k 2 1 2 ; k 2 ], respectively. The regular integer intervals are defined recursively. For all integers ff 0, <ref> [1; 2 ff ] </ref> is regular. The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. <p> The regular integer intervals are defined recursively. For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, <ref> [1; 8] </ref> is regular. Its regular subintervals are [1; 4], [5; 8], [1; 2], [3; 4], [5; 6], [7; 8], and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. <p> The regular integer intervals are defined recursively. For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are <ref> [1; 4] </ref>, [5; 8], [1; 2], [3; 4], [5; 6], [7; 8], and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. <p> The regular integer intervals are defined recursively. For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are [1; 4], [5; 8], <ref> [1; 2] </ref>, [3; 4], [5; 6], [7; 8], and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. A normal sequence is nontrivial if it has at least one nonzero term. <p> The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are [1; 4], [5; 8], [1; 2], [3; 4], [5; 6], [7; 8], and the singletons <ref> [1; 1] </ref>; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. A normal sequence is nontrivial if it has at least one nonzero term. <p> Let f 1 ; ; f k be k normal sequences of length l. An interval query for f 1 ; ; f k is a pair ([k 1 ; k 2 ]; j) where [k 1 ; k 2 ] <ref> [1; k] </ref> and j 2 [1; l]. If k 1 = k 2 , ([k 1 ; k 2 ]; j) is also called a point query. The value of a query ([k 1 ; k 2 ]; j) is max k 1 ik 2 f i (j). <p> Let f 1 ; ; f k be k normal sequences of length l. An interval query for f 1 ; ; f k is a pair ([k 1 ; k 2 ]; j) where [k 1 ; k 2 ] [1; k] and j 2 <ref> [1; l] </ref>. If k 1 = k 2 , ([k 1 ; k 2 ]; j) is also called a point query. The value of a query ([k 1 ; k 2 ]; j) is max k 1 ik 2 f i (j). <p> To prove Statement 2, we assume without loss of generality that k is a power of two. The input queries can be evaluated by the following three stages within the desired time bound. Stage 1. For each regular interval [k 1 ; k 2 ] <ref> [1; k] </ref>, let f [k 1 ; k 2 ] be the joint of f k 1 ; ; f k 2 . We use Lemma 5.1 O (log (k+1)) times to compute the minimal condensed forms of all f [k 1 ; k 2 ]. <p> A regular Q [j; j 0 ] is similarly defined. We now construct a tree over pairs of regular paths; this tree is slightly different from that of [15]. The root of is (P <ref> [1; p 0 1] </ref>; Q [1; q 0 1]). <p> A regular Q [j; j 0 ] is similarly defined. We now construct a tree over pairs of regular paths; this tree is slightly different from that of [15]. The root of is (P [1; p 0 1]; Q <ref> [1; q 0 1] </ref>). A pair (P [i; i 0 ]; Q [j; j 0 ]) 2 is a leaf if and only if either (1) i = i 0 , j = j 0 and (x i ; y j ) is intersecting, or (2) this pair is nonintersecting. <p> Let E be the set of all ceilings, diagonals, floors of the leaves of . Let B = f (x i ; y q 0 ) j i 2 <ref> [1; p 0 ] </ref>g [ f (x p 0 ; y j ) j j 2 [1; q 0 ]g. <p> Let E be the set of all ceilings, diagonals, floors of the leaves of . Let B = f (x i ; y q 0 ) j i 2 [1; p 0 ]g [ f (x p 0 ; y j ) j j 2 <ref> [1; q 0 ] </ref>g. <p> Each nonintersecting (x i ; y 1 ) 2 G P B has a P -predecessor (x i+1 ; y 1 ) and a Q-predecessor (x i ; y j ). Moreover, (x i ; Q <ref> [1; j 1] </ref>) is nonintersecting. 4. Each nonintersecting (x 1 ; y j ) 2 G Q B has a P -predecessor (x i ; y j ) and a Q-predecessor (x 1 ; y j+1 ). Moreover, (P [1; i 1]; y j ) is nonintersecting. Proof. <p> Moreover, (x i ; Q [1; j 1]) is nonintersecting. 4. Each nonintersecting (x 1 ; y j ) 2 G Q B has a P -predecessor (x i ; y j ) and a Q-predecessor (x 1 ; y j+1 ). Moreover, (P <ref> [1; i 1] </ref>; y j ) is nonintersecting. Proof. Statement 1 follows from the definitions of and E. The proofs of Statements 3 and 4 are similar to Case 3 in the proof of Statement 2 below. <p> Lemma 5.5. tree contractions and evolutionary trees 17 1. jI (P <ref> [1; p 0 1] </ref>; Q [1; q 0 1])j n. 2. has O (n log (q + 1)) leaves of the form (P [i 1 ; i 2 ]; Q [j 1 ; j 2 ]) where j 1 &lt; j 2 . 3. has O (n log (q + 1)) <p> Lemma 5.5. tree contractions and evolutionary trees 17 1. jI (P [1; p 0 1]; Q <ref> [1; q 0 1] </ref>)j n. 2. has O (n log (q + 1)) leaves of the form (P [i 1 ; i 2 ]; Q [j 1 ; j 2 ]) where j 1 &lt; j 2 . 3. has O (n log (q + 1)) pairs of the form (P <p> Thus, each level has at most jI (P <ref> [1; p 0 1] </ref>; Q [1; q 0 1])j nonleaf pairs. Consequently, from the second level downwards, each level has at most 4 jI (P [1; p 0 1]; Q [1; q 0 1])j pairs. <p> Thus, each level has at most jI (P [1; p 0 1]; Q <ref> [1; q 0 1] </ref>)j nonleaf pairs. Consequently, from the second level downwards, each level has at most 4 jI (P [1; p 0 1]; Q [1; q 0 1])j pairs. <p> Thus, each level has at most jI (P <ref> [1; p 0 1] </ref>; Q [1; q 0 1])j nonleaf pairs. Consequently, from the second level downwards, each level has at most 4 jI (P [1; p 0 1]; Q [1; q 0 1])j pairs. These two statements then follows from Statement 1 and the fact that the pairs specified in these two statements are within the top 1 + log (q 0 1) levels of . <p> Thus, each level has at most jI (P [1; p 0 1]; Q <ref> [1; q 0 1] </ref>)j nonleaf pairs. Consequently, from the second level downwards, each level has at most 4 jI (P [1; p 0 1]; Q [1; q 0 1])j pairs. These two statements then follows from Statement 1 and the fact that the pairs specified in these two statements are within the top 1 + log (q 0 1) levels of . <p> Compute G [ E [ B, B, I (P <ref> [1; p 0 1] </ref>; Q [1; q 0 1]) B, the set of all nonintersecting pairs in E B, and the sets of nonintersecting pairs in G P B and G Q B, respectively; 3. <p> Compute G [ E [ B, B, I (P [1; p 0 1]; Q <ref> [1; q 0 1] </ref>) B, the set of all nonintersecting pairs in E B, and the sets of nonintersecting pairs in G P B and G Q B, respectively; 3. <p> Compute the following predecessors: * the P -predecessor, Q-predecessor and P Q-predecessor of each pair in I (P <ref> [1; p 0 1] </ref>; Q [1; q 0 1]) B; * the P -predecessor and Q-predecessor of each nonintersecting pair in E B; * the Q-predecessor of each nonintersecting pair in G P B and the P - predecessor of each nonintersecting pair in G Q B; 4. <p> Compute the following predecessors: * the P -predecessor, Q-predecessor and P Q-predecessor of each pair in I (P [1; p 0 1]; Q <ref> [1; q 0 1] </ref>) B; * the P -predecessor and Q-predecessor of each nonintersecting pair in E B; * the Q-predecessor of each nonintersecting pair in G P B and the P - predecessor of each nonintersecting pair in G Q B; 4. <p> For all pairs in G [ E [ B, compute the non-rr terms in the appropriate recurrence formulas of x5.5: * Lemma 5.7 for B; * Lemma 5.8 for (I (P <ref> [1; p 0 1] </ref>; Q [1; q 0 1]) B; * Lemma 5.9 for the nonintersecting pairs in E B; * Lemma 5.10 for the nonintersecting pairs in G P B and its symmetric statement for the nonintersecting pairs in G Q B; 5. <p> For all pairs in G [ E [ B, compute the non-rr terms in the appropriate recurrence formulas of x5.5: * Lemma 5.7 for B; * Lemma 5.8 for (I (P [1; p 0 1]; Q <ref> [1; q 0 1] </ref>) B; * Lemma 5.9 for the nonintersecting pairs in E B; * Lemma 5.10 for the nonintersecting pairs in G P B and its symmetric statement for the nonintersecting pairs in G Q B; 5. <p> The correctness proof of this algorithm has three cases. Case 1: Q u is nonempty. Let y j 1 ; y j 2 ; ; y j k = Q u . Let j 0 = 0. Then, for all k 0 2 <ref> [1; k] </ref> and all j 2 [j k 0 1 + 1; j k 0 ], S 2 jjS u y k 0 2;u and by Lemma 3.1, A u (j) = rp (S u 1 ; S 2 ; Q 0 )(y k 0 ). <p> The correctness of One-One follows from Lemma 5.3 and x5.3-x5.5. As for the time complexity, Step 1 is obvious and takes O (n) time. By computing , we can compute the sets E and I (P <ref> [1; p 0 1] </ref>; Q [1; q 0 1]). Since the leaf labels of S 1 and S 2 are from [1; O (n)], each level of can be computed in O (n) time. Since has O (log (p+1)) levels, E and I (P [1; p 0 1]; Q [1; q <p> The correctness of One-One follows from Lemma 5.3 and x5.3-x5.5. As for the time complexity, Step 1 is obvious and takes O (n) time. By computing , we can compute the sets E and I (P [1; p 0 1]; Q <ref> [1; q 0 1] </ref>). Since the leaf labels of S 1 and S 2 are from [1; O (n)], each level of can be computed in O (n) time. Since has O (log (p+1)) levels, E and I (P [1; p 0 1]; Q [1; q 0 1]) can be computed <p> As for the time complexity, Step 1 is obvious and takes O (n) time. By computing , we can compute the sets E and I (P [1; p 0 1]; Q [1; q 0 1]). Since the leaf labels of S 1 and S 2 are from <ref> [1; O (n)] </ref>, each level of can be computed in O (n) time. Since has O (log (p+1)) levels, E and I (P [1; p 0 1]; Q [1; q 0 1]) can be computed in O (n log (p+1)) time. <p> the sets E and I (P <ref> [1; p 0 1] </ref>; Q [1; q 0 1]). Since the leaf labels of S 1 and S 2 are from [1; O (n)], each level of can be computed in O (n) time. Since has O (log (p+1)) levels, E and I (P [1; p 0 1]; Q [1; q 0 1]) can be computed in O (n log (p+1)) time. With these two sets obtained, we can compute all the desired sets in O (n log (p + 1)) time. Thus, Step 2 takes O (n log (p + 1)) time. <p> (P [1; p 0 1]; Q <ref> [1; q 0 1] </ref>). Since the leaf labels of S 1 and S 2 are from [1; O (n)], each level of can be computed in O (n) time. Since has O (log (p+1)) levels, E and I (P [1; p 0 1]; Q [1; q 0 1]) can be computed in O (n log (p+1)) time. With these two sets obtained, we can compute all the desired sets in O (n log (p + 1)) time. Thus, Step 2 takes O (n log (p + 1)) time.
Reference: [2] <author> R. Agarwala and D. Fern andez-Baca, </author> <title> A polynomial-time algorithm for the perfect phylogeny problem when the number of character states is fixed, </title> <journal> SIAM Journal on Computing, </journal> <volume> 23 (1994), </volume> <pages> pp. 1216-1224. </pages>
Reference-contexts: The regular integer intervals are defined recursively. For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are [1; 4], [5; 8], <ref> [1; 2] </ref>, [3; 4], [5; 6], [7; 8], and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. A normal sequence is nontrivial if it has at least one nonzero term. <p> The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are [1; 4], [5; 8], [1; 2], [3; 4], [5; 6], [7; 8], and the singletons [1; 1]; <ref> [2; 2] </ref>; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. A normal sequence is nontrivial if it has at least one nonzero term.
Reference: [3] <author> A. V. Aho, D. S. Hirschberg, and J. D. Ullman, </author> <title> Bounds on the complexity of the longest common subsequence problem, </title> <journal> Journal of the ACM, </journal> <volume> 23 (1976), </volume> <pages> pp. 1-12. </pages>
Reference-contexts: The regular integer intervals are defined recursively. For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are [1; 4], [5; 8], [1; 2], <ref> [3; 4] </ref>, [5; 6], [7; 8], and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. A normal sequence is nontrivial if it has at least one nonzero term. <p> We can use Lemma 6.2 to derive lower complexity bounds for computing a maximum agreement subtree from known bounds for the longest common subsequence problem in various models of computation <ref> [3, 6, 23, 29, 30, 32, 50] </ref>. This paper assumes a comparison model where two labels x and y can be compared to determine whether x is smaller than y or x = y or x is greater than y.
Reference: [4] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman, </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: Proof. The ideas are to preprocess T for answering queries of lowest common ancestors [25, 45] and to reconstruct subtrees from appropriate tree traversal num-berings <ref> [4, 9] </ref>. Given T 1 and T 2 , our main goal is to evaluate rr (T 1 ; T 2 ) efficiently. <p> We give One-One in x5 and the other four in x4.1-4.4. These five algorithms assume that the input trees T 1 and T 2 have n leaves each and d is the maximum degree. We use integer sort and radix sort <ref> [4, 9] </ref> extensively to help achieve the desired time complexity. (For brevity, from here onwards, radix sort refers to both integer and radix sorts.) For this reason, we make the following integer indexing assumptions: * An integer array of size O (n) is allocated to each algorithm. * The vertices of <p> The regular integer intervals are defined recursively. For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are <ref> [1; 4] </ref>, [5; 8], [1; 2], [3; 4], [5; 6], [7; 8], and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. <p> The regular integer intervals are defined recursively. For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are [1; 4], [5; 8], [1; 2], <ref> [3; 4] </ref>, [5; 6], [7; 8], and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. A normal sequence is nontrivial if it has at least one nonzero term.
Reference: [5] <author> A. V. Aho, Y. Savig, T. G. Szymanski, and J. D. Ullman, </author> <title> Inferring a tree from the lowest common ancestors with an application to the optimization of relational expressions, </title> <journal> SIAM Journal on Computing, </journal> <volume> 10 (1981), </volume> <pages> pp. 405-421. </pages>
Reference-contexts: The regular integer intervals are defined recursively. For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are [1; 4], <ref> [5; 8] </ref>, [1; 2], [3; 4], [5; 6], [7; 8], and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. A normal sequence is nontrivial if it has at least one nonzero term. <p> For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are [1; 4], [5; 8], [1; 2], [3; 4], <ref> [5; 6] </ref>, [7; 8], and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. A normal sequence is nontrivial if it has at least one nonzero term.
Reference: [6] <author> A. Apostolico and C. Guerra, </author> <title> The longest common subsequence problem revisited, </title> <journal> Algo-rithmica, </journal> <volume> 2 (1987), </volume> <pages> pp. 315-336. </pages>
Reference-contexts: Proof. The proof is similar to that of Theorem 4.3. The time bounds follow from Theorems 2.1 and 4.4. 5. The one-one case. Our algorithm for Problem 1 makes extensive use of bisection-based dynamic programming and implicit computation in compressed formats. This problem generalizes the longest common subsequence problem <ref> [6, 23, 29, 30, 32] </ref>, which has efficient dynamic programming solutions. A direct dynamic programming approach to our problem would recursively solve the problem with T x 1 and y 2 in place of T 1 and T 2 for all vertices x 2 P and y 2 Q. <p> For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are [1; 4], [5; 8], [1; 2], [3; 4], <ref> [5; 6] </ref>, [7; 8], and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. A normal sequence is nontrivial if it has at least one nonzero term. <p> We can use Lemma 6.2 to derive lower complexity bounds for computing a maximum agreement subtree from known bounds for the longest common subsequence problem in various models of computation <ref> [3, 6, 23, 29, 30, 32, 50] </ref>. This paper assumes a comparison model where two labels x and y can be compared to determine whether x is smaller than y or x = y or x is greater than y.
Reference: [7] <author> H. L. Bodlaender, M. R. Fellows, and T. J. Warnow, </author> <title> Two strikes against perfect phylogeny, </title> <booktitle> in Lecture Notes in Computer Science 623: Proceedings of the 19th International Colloquium on Automata, Languages, and Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1992, </year> <pages> pp. 273-283. </pages>
Reference-contexts: For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are [1; 4], [5; 8], [1; 2], [3; 4], [5; 6], <ref> [7; 8] </ref>, and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. A normal sequence is nontrivial if it has at least one nonzero term.
Reference: [8] <author> R. Cole and R. Hariharan, </author> <title> An O(n log n) algorithm for the maximum agreement subtree problem for binary trees, </title> <booktitle> in Proceedings of the 7th Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1996, </year> <pages> pp. 323-332. </pages>
Reference-contexts: The regular integer intervals are defined recursively. For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, <ref> [1; 8] </ref> is regular. Its regular subintervals are [1; 4], [5; 8], [1; 2], [3; 4], [5; 6], [7; 8], and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. <p> The regular integer intervals are defined recursively. For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are [1; 4], <ref> [5; 8] </ref>, [1; 2], [3; 4], [5; 6], [7; 8], and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. A normal sequence is nontrivial if it has at least one nonzero term. <p> For all integers ff 0, [1; 2 ff ] is regular. The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are [1; 4], [5; 8], [1; 2], [3; 4], [5; 6], <ref> [7; 8] </ref>, and the singletons [1; 1]; [2; 2]; : : : ; [8; 8]. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. A normal sequence is nontrivial if it has at least one nonzero term. <p> The upper and lower halves of an even length regular interval are also regular. For example, [1; 8] is regular. Its regular subintervals are [1; 4], [5; 8], [1; 2], [3; 4], [5; 6], [7; 8], and the singletons [1; 1]; [2; 2]; : : : ; <ref> [8; 8] </ref>. A normal sequence is a nonincreasing sequence ff (j)g l j=1 of nonnegative numbers. A normal sequence is nontrivial if it has at least one nonzero term. For example, 5; 4; 4; 0 is a nontrivial normal sequence, whereas 0; 0; 0 is a trivial one. <p> Recently, Farach, Przytycka and Thorup [13] independently developed an algorithm that runs in O (n p d log 3 n) time. Cole and Hariharan <ref> [8] </ref> gave an O (n log n)-time algorithm for binary trees. It may be possible to close the gap by incorporating ideas used in those two results and this paper. Acknowledgments. The author is deeply appreciative for the extremely thorough and useful suggestions given by the anonymous referee.
Reference: [9] <author> T. H. Cormen, C. L. Leiserson, and R. L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: Proof. The ideas are to preprocess T for answering queries of lowest common ancestors [25, 45] and to reconstruct subtrees from appropriate tree traversal num-berings <ref> [4, 9] </ref>. Given T 1 and T 2 , our main goal is to evaluate rr (T 1 ; T 2 ) efficiently. <p> We give One-One in x5 and the other four in x4.1-4.4. These five algorithms assume that the input trees T 1 and T 2 have n leaves each and d is the maximum degree. We use integer sort and radix sort <ref> [4, 9] </ref> extensively to help achieve the desired time complexity. (For brevity, from here onwards, radix sort refers to both integer and radix sorts.) For this reason, we make the following integer indexing assumptions: * An integer array of size O (n) is allocated to each algorithm. * The vertices of
Reference: [10] <author> W. H. E. Day and D. Sankoff, </author> <title> Computational complexity of inferring phylogenies from chromosome inversion data, </title> <journal> Journal of Theoretical Biology, </journal> <volume> 124 (1987), </volume> <pages> pp. 213-218. </pages> <note> 24 m. y. kao </note>
Reference: [11] <author> S. Dress and M. Steel, </author> <title> Convex tree realizations of partitions, </title> <journal> Applied Mathematics Letters, </journal> <volume> 5 (1992), </volume> <pages> pp. 3-6. </pages>
Reference: [12] <author> M. Farach, S. Kannan, and T. Warnow, </author> <title> A robust model for finding optimal evolutionary trees, </title> <journal> Algorithmica, </journal> <volume> 13 (1995), </volume> <pages> pp. 155-179. </pages>
Reference: [13] <author> M. Farach, T. M. Przytycka, and M. </author> <title> Thorup, Computing the agreement of trees with bounded degrees, </title> <booktitle> in Lecture Notes in Computer Science 979: Proceedings of the Third Annual European Symposium on Algorithms, </booktitle> <editor> P. Spirakis, ed., </editor> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1995, </year> <pages> pp. 381-393. </pages>
Reference-contexts: It would be significant to close the gap between this lower bound and the upper bound of O (n log 2 n) stated in Theorem 6.1. Recently, Farach, Przytycka and Thorup <ref> [13] </ref> independently developed an algorithm that runs in O (n p d log 3 n) time. Cole and Hariharan [8] gave an O (n log n)-time algorithm for binary trees. It may be possible to close the gap by incorporating ideas used in those two results and this paper. Acknowledgments.
Reference: [14] <author> M. Farach and M. </author> <title> Thorup, Fast comparison of evolutionary trees (extended abstract), </title> <booktitle> in Proceedings of the 5th Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1994, </year> <pages> pp. </pages> <month> 481-488. </month> <title> [15] , Optimal evolutionary tree comparison by sparse dynamic programming (extended abstract), </title> <booktitle> in Proceedings of the 35th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1994, </year> <pages> pp. 770-779. </pages>
Reference-contexts: Steel and Warnow [47] gave the first polynomial-time algorithm. Their algorithm runs in O (minfd!n 2 ; d 2:5 n 2 log ng) time if d is bounded by a constant and in O (n 4:5 log n) time for general trees. Farach and Tho-rup <ref> [14] </ref> later reduced the time complexity of this algorithm to O (n 2 ) for general trees. More recently, they gave an algorithm [15] that runs in O (n 1:5 log n) time for general trees. <p> We develop new results that are useful for bounding the time complexity of tree fl Department of Computer Science, Duke University, Durham, NC 27708. Supported in part by NSF Grant CCR-9101385. 1 2 m. y. kao contraction algorithms. As in <ref> [14, 15, 47] </ref>, we also explore the dynamic programming structure of the problem. We obtain some highly regular structural properties and combine these properties with the tree contraction techniques to reduce the time bound by a factor of log 2 n. <p> We use rr to replace the notation mast of previous work <ref> [14, 15, 47] </ref> for the sake of notational uniformity.) Lemma 3.1.
Reference: [16] <author> J. Felsenstein, </author> <title> Numerical methods for inferring evolutionary trees, </title> <journal> The Quarterly Review of Biology, </journal> <volume> 57 (1982), </volume> <pages> pp. </pages> <month> 379-404. </month> <title> [17] , Inferring evolutionary trees from DNA sequences, in Statistical Analysis of DNA Sequence Data, </title> <editor> B. Weir, ed., Dekker, </editor> <year> 1983, </year> <pages> pp. </pages> <month> 133-150. </month> <title> [18] , Phylogenies from molecular sequences: Inference and reliability, Annual Review of Genetics, </title> <booktitle> 22 (1988), </booktitle> <pages> pp. 521-565. </pages>
Reference: [19] <author> C. R. Finden and A. D. Gordon, </author> <title> Obtaining common pruned trees, </title> <journal> Journal of Classification, </journal> <volume> 2 (1985), </volume> <pages> pp. 255-276. </pages>
Reference-contexts: A fundamental problem in computational biology is to determine how much two theories have in common. To a certain extent, this problem can be answered by computing a maximum agreement subtree of two given evolutionary trees <ref> [19] </ref>. Let T 1 and T 2 be two evolutionary trees with n leaves each. Let d be the maximum degree of these trees.
Reference: [20] <author> A. Friday, </author> <title> Quantitative aspects of the estimation of evolutionary trees, </title> <journal> Folia Primatologica, </journal> <volume> 53 (1989), </volume> <pages> pp. 221-234. </pages>
Reference: [21] <author> H. N. Gabow and R. E. Tarjan, </author> <title> Faster scaling algorithms for network problems, </title> <journal> SIAM Journal on Computing, </journal> <volume> 18 (1989), </volume> <pages> pp. 1013-1036. </pages>
Reference-contexts: Since an edge weighs at most n, we can compute m (X i ; Y j ) in O (n i;j m i;j + n 2 i;j log n i;j ) and alternately in 22 m. y. kao p n i;j log (nn i;j )) time <ref> [21, 42] </ref>. Statement 1 then follows from the fact that n i;j 2d 0 , n i;j 2m i;j , and by Lemma 5.5 (1) the sum of all m i;j is at most n.
Reference: [22] <author> H. Gazit, G. L. Miller, and S. H. Teng, </author> <title> Optimal tree contraction in the EREW model, in Concurrent Computations: Algorithms, Architecture, and Technology, </title> <editor> S. T. amd B.W. Dickinson and S. Schwartz, eds., </editor> <publisher> Plenum, </publisher> <address> New York, </address> <year> 1988, </year> <pages> pp. 139-156. </pages>
Reference-contexts: For general d, this algorithm runs in O (nd 2 log d log 2 n) time or alternately in O (nd p 3 n) time. This algorithm employs new tree contraction techniques <ref> [1, 22, 38, 40, 41] </ref>. With tree contraction, we can immediately obtain an O (n log 5 n)-time algorithm for d bounded by a constant. Reducing the time bound to O (n log 2 n) requires additional techniques.
Reference: [23] <author> R. N. Goldberg, </author> <title> Minimal string difference encodings, </title> <journal> Journal of Algorithms, </journal> <volume> 3 (1982), </volume> <pages> pp. 147-156. </pages>
Reference-contexts: Proof. The proof is similar to that of Theorem 4.3. The time bounds follow from Theorems 2.1 and 4.4. 5. The one-one case. Our algorithm for Problem 1 makes extensive use of bisection-based dynamic programming and implicit computation in compressed formats. This problem generalizes the longest common subsequence problem <ref> [6, 23, 29, 30, 32] </ref>, which has efficient dynamic programming solutions. A direct dynamic programming approach to our problem would recursively solve the problem with T x 1 and y 2 in place of T 1 and T 2 for all vertices x 2 P and y 2 Q. <p> We can use Lemma 6.2 to derive lower complexity bounds for computing a maximum agreement subtree from known bounds for the longest common subsequence problem in various models of computation <ref> [3, 6, 23, 29, 30, 32, 50] </ref>. This paper assumes a comparison model where two labels x and y can be compared to determine whether x is smaller than y or x = y or x is greater than y.
Reference: [24] <author> D. Gusfield, </author> <title> Efficient algorithms for inferring evolutionary trees, Networks, </title> <booktitle> 21 (1991), </booktitle> <pages> pp. 19-28. </pages>
Reference: [25] <author> D. Harel and R. E. Tarjan, </author> <title> Fast algorithms for finding nearest common ancestors, </title> <journal> SIAM Journal on Computing, </journal> <volume> 13 (1984), </volume> <pages> pp. 338-355. </pages>
Reference-contexts: Proof. The ideas are to preprocess T for answering queries of lowest common ancestors <ref> [25, 45] </ref> and to reconstruct subtrees from appropriate tree traversal num-berings [4, 9]. Given T 1 and T 2 , our main goal is to evaluate rr (T 1 ; T 2 ) efficiently.
Reference: [26] <author> J. J. Hein, </author> <title> An optimal algorithm to reconstruct trees from additive distance data, </title> <journal> Bulletin of Mathematical Biology, </journal> <volume> 51 (1989), </volume> <pages> pp. 597-603. </pages>
Reference: [27] <author> M. D. Hendy, </author> <title> The relationship between between simple evolutionary tree models and observable sequence data, Systematic Zoology, </title> <booktitle> 38 (1989), </booktitle> <pages> pp. 310-321. </pages>
Reference: [28] <author> M. D. Hendy and D. Penny, </author> <title> Branch and bound algorithms to determine minimal evolutionary trees, </title> <journal> Mathematical Biosciences, </journal> <volume> 59 (1982), </volume> <pages> pp. 277-290. </pages>
Reference: [29] <author> D. S. Hirschberg, </author> <title> A linear space algorithm for computing maximal common subsequences, </title> <journal> Communications of the ACM, </journal> <volume> 18 (1975), </volume> <pages> pp. </pages> <month> 341-343. </month> <title> [30] , Algorithms for the longest common subsequence problem, </title> <journal> Journal of the ACM, </journal> <volume> 24 (1977), </volume> <pages> pp. </pages> <month> 664-675. </month> <title> [31] , An information theoretic lower bound for the longest common subsequence problem, </title> <journal> Information Processing Letters, </journal> <volume> 7 (1978), </volume> <pages> pp. 40-41. </pages>
Reference-contexts: Proof. The proof is similar to that of Theorem 4.3. The time bounds follow from Theorems 2.1 and 4.4. 5. The one-one case. Our algorithm for Problem 1 makes extensive use of bisection-based dynamic programming and implicit computation in compressed formats. This problem generalizes the longest common subsequence problem <ref> [6, 23, 29, 30, 32] </ref>, which has efficient dynamic programming solutions. A direct dynamic programming approach to our problem would recursively solve the problem with T x 1 and y 2 in place of T 1 and T 2 for all vertices x 2 P and y 2 Q. <p> We can use Lemma 6.2 to derive lower complexity bounds for computing a maximum agreement subtree from known bounds for the longest common subsequence problem in various models of computation <ref> [3, 6, 23, 29, 30, 32, 50] </ref>. This paper assumes a comparison model where two labels x and y can be compared to determine whether x is smaller than y or x = y or x is greater than y.
Reference: [32] <author> J. W. Hunt and T. G. Szymanski, </author> <title> A fast algorithm for computing longest common subsequences, </title> <journal> Communications of the ACM, </journal> <volume> 20 (1977), </volume> <pages> pp. 350-353. </pages>
Reference-contexts: Proof. The proof is similar to that of Theorem 4.3. The time bounds follow from Theorems 2.1 and 4.4. 5. The one-one case. Our algorithm for Problem 1 makes extensive use of bisection-based dynamic programming and implicit computation in compressed formats. This problem generalizes the longest common subsequence problem <ref> [6, 23, 29, 30, 32] </ref>, which has efficient dynamic programming solutions. A direct dynamic programming approach to our problem would recursively solve the problem with T x 1 and y 2 in place of T 1 and T 2 for all vertices x 2 P and y 2 Q. <p> We can use Lemma 6.2 to derive lower complexity bounds for computing a maximum agreement subtree from known bounds for the longest common subsequence problem in various models of computation <ref> [3, 6, 23, 29, 30, 32, 50] </ref>. This paper assumes a comparison model where two labels x and y can be compared to determine whether x is smaller than y or x = y or x is greater than y.
Reference: [33] <author> T. Jiang, E. L. Lawler, and L. Wang, </author> <title> Aligning sequences via an evolutionary tree: complexity and approximation, </title> <booktitle> in Proceedings of the 26th Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1994, </year> <pages> pp. 760-769. </pages>
Reference: [34] <author> S. Kannan, E. Lawler, and T. Warnow, </author> <title> Determining the evolutionary tree, </title> <booktitle> in Proceedings of the 1st Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1990, </year> <pages> pp. 475-484. </pages> <note> To appear in Journal of Algorithms. </note>
Reference: [35] <author> S. K. Kannan and T. J. Warnow, </author> <title> Inferring evolutionary history from DNA sequences, </title> <journal> SIAM Journal on Computing, </journal> <volume> 23 (1994), </volume> <pages> pp. 713-737. </pages>
Reference: [36] <author> D. Keselman and A. Amir, </author> <title> Maximum agreement subtree in a set of evolutionary trees - metrics and efficient algorithms, </title> <booktitle> in Proceedings of the 35th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1994, </year> <pages> pp. 758-769. </pages> <note> To appear in SIAM Journal on Computing. </note>
Reference: [37] <author> L. C. Klotz and R. L. Blanken, </author> <title> A practical method for calculating evolutionary trees from tree contractions and evolutionary trees 25 sequence data, </title> <journal> Journal of Theoretical Biology, </journal> <volume> 91 (1981), </volume> <pages> pp. 261-272. </pages>
Reference: [38] <author> S. R. Kosaraju and A. L. Delcher, </author> <title> Optimal parallel evaluation of tree-structured computations by raking, </title> <booktitle> in Lecture Notes in Computer Science 319: VLSI Algorithms and Architectures, the 3rd Aegean Workshop on Computing, </booktitle> <editor> J. H. Reif, ed., </editor> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1988, </year> <pages> pp. 101-110. </pages>
Reference-contexts: For general d, this algorithm runs in O (nd 2 log d log 2 n) time or alternately in O (nd p 3 n) time. This algorithm employs new tree contraction techniques <ref> [1, 22, 38, 40, 41] </ref>. With tree contraction, we can immediately obtain an O (n log 5 n)-time algorithm for d bounded by a constant. Reducing the time bound to O (n log 2 n) requires additional techniques.
Reference: [39] <author> E. Kubicka, G. Kubicki, and F. McMorris, </author> <title> An algorithm to find agreement subtrees, </title> <journal> Journal of Classification, </journal> <volume> 12 (1995), </volume> <pages> pp. 91-99. </pages>
Reference-contexts: To a certain extent, this problem can be answered by computing a maximum agreement subtree of two given evolutionary trees [19]. Let T 1 and T 2 be two evolutionary trees with n leaves each. Let d be the maximum degree of these trees. Previously, Kubicka, Kubicki and McMorris <ref> [39] </ref> gave an algorithm that can compute the number of leaves in a maximum agreement subtree of T 1 and T 2 in O (n ( 1 2 +*) log n ) time for d = 2. Steel and Warnow [47] gave the first polynomial-time algorithm.
Reference: [40] <author> G. L. Miller and J. H. Reif, </author> <title> Parallel tree contraction, </title> <booktitle> part 1: Fundamentals, in Advances in Computing Research: Randomness and Computation, </booktitle> <editor> S. Micali, ed., </editor> <volume> vol. 5, </volume> <publisher> JAI Press, </publisher> <address> Greenwich, CT, </address> <year> 1989, </year> <pages> pp. </pages> <month> 47-72. </month> <title> [41] , Parallel tree contraction part 2: Further applications, </title> <journal> SIAM Journal on Computing, </journal> <volume> 20 (1991), </volume> <pages> pp. 1128-1147. </pages>
Reference-contexts: For general d, this algorithm runs in O (nd 2 log d log 2 n) time or alternately in O (nd p 3 n) time. This algorithm employs new tree contraction techniques <ref> [1, 22, 38, 40, 41] </ref>. With tree contraction, we can immediately obtain an O (n log 5 n)-time algorithm for d bounded by a constant. Reducing the time bound to O (n log 2 n) requires additional techniques.
Reference: [42] <author> J. B. Orlin and R. K. Ahuja, </author> <title> New scaling algorithms for the assignment and minimum mean cycle problems, </title> <journal> Mathematical Programming, </journal> <volume> 54 (1992), </volume> <pages> pp. 41-56. </pages>
Reference-contexts: Since an edge weighs at most n, we can compute m (X i ; Y j ) in O (n i;j m i;j + n 2 i;j log n i;j ) and alternately in 22 m. y. kao p n i;j log (nn i;j )) time <ref> [21, 42] </ref>. Statement 1 then follows from the fact that n i;j 2d 0 , n i;j 2m i;j , and by Lemma 5.5 (1) the sum of all m i;j is at most n.
Reference: [43] <author> D. Penny and M. Hendy, </author> <title> Estimating the reliability of evolutionary trees, Molecular Biology and Evolution, </title> <booktitle> 3 (1986), </booktitle> <pages> pp. 403-417. </pages>
Reference: [44] <author> A. Rzhetsky and M. Nei, </author> <title> A simple method for estimating and testing minimum-evolution trees, Molecular Biology and Evolution, </title> <booktitle> 9 (1992), </booktitle> <pages> pp. 945-967. </pages>
Reference: [45] <author> B. Schieber and U. Vishkin, </author> <title> On finding lowest common ancestors: Simplification and paral-lelization, </title> <journal> SIAM Journal on Computing, </journal> <volume> 17 (1988), </volume> <pages> pp. 1253-1262. </pages>
Reference-contexts: Proof. The ideas are to preprocess T for answering queries of lowest common ancestors <ref> [25, 45] </ref> and to reconstruct subtrees from appropriate tree traversal num-berings [4, 9]. Given T 1 and T 2 , our main goal is to evaluate rr (T 1 ; T 2 ) efficiently.
Reference: [46] <author> M. Steel, </author> <title> The complexity of reconstructing trees from qualitative characters and subtrees, </title> <journal> Journal of Classification, </journal> <volume> 9 (1992), </volume> <pages> pp. 91-116. </pages>
Reference: [47] <author> M. Steel and T. Warnow, </author> <title> Kaikoura tree theorems: Computing the maximum agreement subtree, </title> <journal> Information Processing Letters, </journal> <volume> 48 (1993), </volume> <pages> pp. 77-82. </pages>
Reference-contexts: Previously, Kubicka, Kubicki and McMorris [39] gave an algorithm that can compute the number of leaves in a maximum agreement subtree of T 1 and T 2 in O (n ( 1 2 +*) log n ) time for d = 2. Steel and Warnow <ref> [47] </ref> gave the first polynomial-time algorithm. Their algorithm runs in O (minfd!n 2 ; d 2:5 n 2 log ng) time if d is bounded by a constant and in O (n 4:5 log n) time for general trees. <p> We develop new results that are useful for bounding the time complexity of tree fl Department of Computer Science, Duke University, Durham, NC 27708. Supported in part by NSF Grant CCR-9101385. 1 2 m. y. kao contraction algorithms. As in <ref> [14, 15, 47] </ref>, we also explore the dynamic programming structure of the problem. We obtain some highly regular structural properties and combine these properties with the tree contraction techniques to reduce the time bound by a factor of log 2 n. <p> We use rr to replace the notation mast of previous work <ref> [14, 15, 47] </ref> for the sake of notational uniformity.) Lemma 3.1.
Reference: [48] <author> L. Wang, T. Jiang, and E. Lawler, </author> <title> Approximation algorithms for tree alignment with a given phylogeny, </title> <journal> Algorithmica, </journal> <note> (1996). In press. </note>
Reference: [49] <author> T. J. Warnow, </author> <title> Tree compatibility and inferring evolutionary history, </title> <journal> Journal of Algorithms, </journal> <volume> 16 (1994), </volume> <pages> pp. 388-407. </pages>
Reference: [50] <author> C. K. Wong and A. K. Chandra, </author> <title> Bounds for the string editing problem, </title> <journal> Journal of the ACM, </journal> <volume> 23 (1976), </volume> <pages> pp. 13-16. </pages>
Reference-contexts: We can use Lemma 6.2 to derive lower complexity bounds for computing a maximum agreement subtree from known bounds for the longest common subsequence problem in various models of computation <ref> [3, 6, 23, 29, 30, 32, 50] </ref>. This paper assumes a comparison model where two labels x and y can be compared to determine whether x is smaller than y or x = y or x is greater than y.
References-found: 44

