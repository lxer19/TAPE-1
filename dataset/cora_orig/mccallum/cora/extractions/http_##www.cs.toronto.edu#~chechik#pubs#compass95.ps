URL: http://www.cs.toronto.edu/~chechik/pubs/compass95.ps
Refering-URL: http://www.cs.toronto.edu/~chechik/publications.html
Root-URL: 
Email: fchechik, gannong@cs.umd.edu  
Title: Automatic Analysis of Consistency between Implementations and Requirements: A Case Study  
Author: Marsha Chechik John Gannon 
Address: College Park, Maryland 20742  
Affiliation: Computer Science Department University of Maryland  
Abstract: Formal methods like model checking can be used to demonstrate that safety properties of event-based systems are enforced by the system's requirements. Unfortunately, proving these properties provides no guarantee that they will be preserved in an implementation of the system. This paper describes a tool, called Analyzer, which discovers instances of inconsistency and incompleteness in implementations, and a case study of its use. Analyzer uses requirements information to check that all state transitions implemented in the code are exactly those specified in the requirements. If programmers annotate their implementations with comments describing changes of values of requirements variables, our tool checks it against the requirements. Analyzer can also verify that the implementation is a model of user-specified safety properties. The tool can perform interprocedural analysis and verify properties which involve multiple state machines. In our case study, we analyzed the requirements and the implementation of a water-level monitoring system and discovered instances of inconsistency (testing incorrect conditions) and incompleteness (missing timing constraints) in the implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, R. Sethi, and J. Ulman. </author> <booktitle> Compilers: Principles, Techniques, and Tools, Chapter 10. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference: [2] <author> T. Alspaugh, S. Faulk, K. Britton, R. Parker, D. Par-nas, and J. Shore. </author> <title> "Software Requirements for the A-7E Aircraft". </title> <type> Technical report, </type> <institution> Naval Research Laboratory, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Two push buttons, SelfTst and Reset, permit the operator to test the system and return it to normal operation. 2.1 WLMS Requirements Our analysis tool uses a slightly restricted version of SCR specifications <ref> [2, 9, 8] </ref> represented in the ASCII format [4]. A system is modeled as a set of concurrently executing state machines, where each machine interacts with its environment's state variables.
Reference: [3] <author> J.M. Atlee and J. Gannon. </author> <title> "State-Based Model Checking of Event-Driven System Requirements". </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 22-40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Four safety properties, same as used in <ref> [3] </ref>, were verified in this study. They are shown in Table 4. If the SelfTest button has been pressed for 500ms or more, the system is either in mode Test or will be in mode Test after its next transition.
Reference: [4] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Verification of Requirements Implementations". </title> <booktitle> In Proceedings of the 1994 ISSTA, </booktitle> <pages> pages 1-14, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: We have developed a prototype tool, called Analyzer <ref> [4] </ref> which discovers instances of inconsistency and incompleteness in implementations by automatically establishing and verifying global properties from local annotations. The inputs to the tool are a requirements specification and a C source program annotated with comments describing the values of variables which appear in the requirements (see Figure 1). <p> Two push buttons, SelfTst and Reset, permit the operator to test the system and return it to normal operation. 2.1 WLMS Requirements Our analysis tool uses a slightly restricted version of SCR specifications [2, 9, 8] represented in the ASCII format <ref> [4] </ref>. A system is modeled as a set of concurrently executing state machines, where each machine interacts with its environment's state variables. Changes to its monitored state variables may cause the system to change its state or to alter the values of its controlled state variables (see Figure 1). <p> This regular pattern of annotation placement gave us an idea to insert annotations automatically, using user-specified templates. This work is still in progress. 2.3 Improvements to Analyzer During this case study, we found out that we need a richer annotation language and better analysis techniques than were implemented in <ref> [4] </ref> to deal with multiple mode classes. The following code fragment controls the WLMS audio alarm. When the If test fails, all we know about the state of the system is that it cannot be in one of the current modes.
Reference: [5] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Analysis of Consistency between Implementations and Requirements". </title> <type> Technical report CS-TR-3394, </type> <institution> Dept. of CS, University of Maryland, College Park, </institution> <month> January </month> <year> 1995. </year> <note> (in preparation). </note>
Reference-contexts: Monitored and controlled variables have boolean values; mode class variables have values which form enumerated types whose constant values are the modes of the mode class. Annotations specify an abstraction between the implementation and the requirements. We identified three types of annotations described in detail in <ref> [5] </ref>. An Initial annotation indicates the starting state of the program. It unconditionally assigns values to variables and corresponds to initialization information specified in the requirements. An Update annotation assigns values to controlled, monitored or mode class variables. This annotation identifies points at which the program changes its state. <p> For more detail, please refer to <ref> [5] </ref>. Analyzer builds a control flow graph CFG of the implementation and uses data-flow analysis ([1]). Figure 2 outlines the basic analysis steps. The reaching definition RD of a variable at a node is a set of values that the variable could attain if the control reaches this node. <p> We verify each copy of a function once with its own set of reaching definitions and conditions. Our algorithm is described in detail in <ref> [5] </ref>.
Reference: [6] <author> Keith D. Cooper, Mary W. Hall, and Ken Kennedy. </author> <title> "Procedure Cloning". </title> <booktitle> In Proceedings of IEEE International Conference on Computer Languages, </booktitle> <pages> pages 96-105, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: In this example, the When condition is fM=fM1g, A=True, B=TorF, C=TorFg. Mode transitions in the requirements are marked as implemented if their When and Triggering conditions are subsets of the computed When and Triggering conditions. 4 Processing Functions We process functions using a technique called cloning <ref> [6] </ref> which we adapted for our analysis. A similar algorithm was described in [15]. This technique enables Analyzer to process programs with cycles in their call graphs (recursion), to analyze each called function only a constant number of times, and to achieve reasonable precision in the analysis.
Reference: [7] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Static Determination of Dynamic Properties of Programs". </title> <booktitle> In Proceedings of the "Colloque sur la Programmation", </booktitle> <month> April </month> <year> 1976. </year>
Reference-contexts: Cond information permits programmers to indicate the conditions under which paths are executable and reduces the number of values in the set of reaching definitions. To understand how Conds restrict RDs, we need to consider an abstract interpretation framework <ref> [7] </ref>. In this framework, values of controlled and monitored variables and those of mode class variables each form lattices (Figure 3). Thus the states of the program also form a lattice. The lattice in Figure 3a is used to compute RDs for boolean-valued variables.
Reference: [8] <author> C. Heitmeyer and B. Labaw. </author> <title> "Consistency Checks for SCR-Style Requirements Specifications". </title> <type> Technical Report NRL Report 93-9586, </type> <institution> Naval Research Laboratory, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Two push buttons, SelfTst and Reset, permit the operator to test the system and return it to normal operation. 2.1 WLMS Requirements Our analysis tool uses a slightly restricted version of SCR specifications <ref> [2, 9, 8] </ref> represented in the ASCII format [4]. A system is modeled as a set of concurrently executing state machines, where each machine interacts with its environment's state variables.
Reference: [9] <author> K. Heninger. </author> <title> "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-12, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Two push buttons, SelfTst and Reset, permit the operator to test the system and return it to normal operation. 2.1 WLMS Requirements Our analysis tool uses a slightly restricted version of SCR specifications <ref> [2, 9, 8] </ref> represented in the ASCII format [4]. A system is modeled as a set of concurrently executing state machines, where each machine interacts with its environment's state variables.
Reference: [10] <author> W.E. Howden and B. Wieand. </author> <title> "QDA A Method for Systematic Informal Program Analysis". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(6) </volume> <pages> 445-462, </pages> <month> June </month> <year> 1994. </year>
Reference: [11] <author> Kurt M. Olender and Leon J. Osterweil. </author> <title> "Cesar: A Static Sequencing Constraint Analyzer". </title> <booktitle> In Proceedings of the ACM SIGSOFT '89 Third Symposium on Software Testing, Analysis, and Verification (TAV3), </booktitle> <pages> pages 66-74, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: It amortizes the cost of creating requirements and safety properties by using them to analyze implementations. We have demonstrated that Analyzer can detect inconsistencies in implementations which were de veloped to conform to SCR requirements. Analyzer uses concepts from Quick Defect Analysis (QDA)[10] and Cesar/Cecil <ref> [11, 12, 13] </ref>. In QDA, implementations are annotated with two types of comments: assertions that an object has one of a finite number of values, and assumptions about the object's values at particular control points.
Reference: [12] <author> Kurt M. Olender and Leon J. Osterweil. "Cecil: </author> <title> A Sequencing Constraint Language for Automatic Static Analysis Generation". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 268-280, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: It amortizes the cost of creating requirements and safety properties by using them to analyze implementations. We have demonstrated that Analyzer can detect inconsistencies in implementations which were de veloped to conform to SCR requirements. Analyzer uses concepts from Quick Defect Analysis (QDA)[10] and Cesar/Cecil <ref> [11, 12, 13] </ref>. In QDA, implementations are annotated with two types of comments: assertions that an object has one of a finite number of values, and assumptions about the object's values at particular control points.
Reference: [13] <author> Kurt M. Olender and Leon K. Osterweil. </author> <title> "In-terprocedural Static Analysis of Sequencing Constraints". </title> <journal> ACM Transactions of Software Engineering and Methodology, </journal> <volume> 1(1) </volume> <pages> 21-52, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: It amortizes the cost of creating requirements and safety properties by using them to analyze implementations. We have demonstrated that Analyzer can detect inconsistencies in implementations which were de veloped to conform to SCR requirements. Analyzer uses concepts from Quick Defect Analysis (QDA)[10] and Cesar/Cecil <ref> [11, 12, 13] </ref>. In QDA, implementations are annotated with two types of comments: assertions that an object has one of a finite number of values, and assumptions about the object's values at particular control points.
Reference: [14] <author> J. van Schouwen. </author> <title> "The A-7 Requirements Model: Reexamination for Real-Time Systems and an Application to Monitoring Systems". </title> <type> Technical Report TR-90-276, </type> <institution> Queen's University, Kingston, </institution> <address> Ontario, </address> <month> May </month> <year> 1990. </year>
Reference: [15] <author> Ben Wegbreit. </author> <title> "Property Extraction in Well-Founded Property Sets". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(3) </volume> <pages> 270-285, </pages> <month> September </month> <year> 1975. </year>
Reference-contexts: Mode transitions in the requirements are marked as implemented if their When and Triggering conditions are subsets of the computed When and Triggering conditions. 4 Processing Functions We process functions using a technique called cloning [6] which we adapted for our analysis. A similar algorithm was described in <ref> [15] </ref>. This technique enables Analyzer to process programs with cycles in their call graphs (recursion), to analyze each called function only a constant number of times, and to achieve reasonable precision in the analysis.
References-found: 15

