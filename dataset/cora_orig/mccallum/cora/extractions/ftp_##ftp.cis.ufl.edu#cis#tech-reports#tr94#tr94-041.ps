URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr94/tr94-041.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr94-abstracts.html
Root-URL: http://www.cis.ufl.edu
Email: ted@cis.ufl.edu  
Title: Two Approaches for High Concurrency in Multicast-Based Object Replication  
Author: by Theodore Johnson and Lionnel Maugis 
Address: Gainesville, Fl 32611-2024  Building  Gainesville, Florida 32611  
Affiliation: University of Florida Computer and Information Sciences  Dept. of CIS, University of Florida  Department of Computer and Information Sciences Computer Science Engineering  University of Florida  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. El Abbadi, D. Skeen, and F. Cristian. </author> <title> An efficient fault-tolerant algorithm for replicated data management. </title> <booktitle> In Proceedings of the 4th ACM SIGACT-SIGMOD Symposium on Principles of Database Systems, </booktitle> <pages> pages 215-229, </pages> <address> Portland, OR, </address> <month> March </month> <year> 1985. </year>
Reference-contexts: In the virtual partition method of El Abbadi, Skeen and Cristian <ref> [1] </ref>, each site maintains a view of all operating sites it can communicate with and applies a rowa strategy within this view. <p> by the following: Definition 16 Hierarchical delivery predicate H G ( i ) , R G ( i ) ^ 8j 1 j &lt; i; 8m 2 M G ; nvt (m) + u j (1) Hierarchical Total Ordering Protocol: delivery rule (H-Top) 1) (early delivery rule) if 9i 2 <ref> [1; k] </ref>; H G ( i ) Then deliver S G ( i ) 2) (default delivery rule) Else, if ntail (G) = n, Then deliver M G . Theorem 3 the H-Top protocol is correct.
Reference: [2] <author> D. Agrawal and A. El Abbadi. </author> <title> The generalized tree quorum protocol: An efficient approach for managing replicated data. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(4) </volume> <pages> 689-717, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: These ghosts are used to to detect that a copy is unavailable due to a node crash, not due to a network partition. Kumar [53], and Agrawal and Abadi <ref> [2] </ref> introduced hierarchical quorums to limit the size of the quorums 8 as the number of processors increases. In [45] the notion of coteries 4 is proposed as an alternative to quorums. A coterie is a collections of intersecting minimal subsets of sites.
Reference: [3] <author> D. Agrawal, A. El Abbadi, and A. K. Singh. </author> <title> Consistency and orderability: Semantics-based correctness criteria for databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 18(3):460, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: Initial work on concurrency control left the data uninterpreted, or viewed operations as simple reads and writes. Recently, several researchers have considered placing more structure on the data to increase concurrency <ref> [50, 49, 3] </ref>. Such techniques can be used in databases to deal with "hot spots," or frequently accessed data. One approach is to use the specifications of abstract data types to design type-specific concurrency control algorithms.
Reference: [4] <author> M. Ahamad and M. Ammar. </author> <title> Performance characterization of quorum-consensus algorithms for replicated data. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(4) </volume> <pages> 492-501, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: The development of group communication protocols make available an alternative paradigm to building reliable distributed applications. Indeed, communication plays a central role in the management of replicated data and early replica control protocols underestimated total communication costs <ref> [4] </ref>. Process group primitives provide several notions of order for the occurrence of particular events: message delivery, failure notification, process joining, leaving, as well as the reliable sending and receiving of messages to a group. These orders are more and more being used to understand, model and design distributed software. <p> A coterie is a collections of intersecting minimal subsets of sites. Interestingly, if the system has six or more nodes, there exist several coteries that do not have equivalent quorum assignments. A logical structure based on grids is also presented in Cheung, Ammar and Ahamad [26]. Ahamad and Ammar <ref> [4, 25] </ref> evaluated the performance of quorum based protocols when data becomes unavailable. Barbara and Garcia-Molina [9, 10] studied the vulnerability of voting assignment in the presence of failures. Kumar and Segev [54] proposed heuristics to minimize communication costs under availability constraints.
Reference: [5] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. </author> <title> Membership algorithms for multicast communication groups. </title> <booktitle> In 6th International Workshop on Distributed Algorithms, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pages 292-312, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Virtually synchronous process groups (Crash failure). The failure of a process, the joining of a node has to be carefully monitored to ensure that configuration changes are logically synchronized with all the regular messages. We use the group membership protocol of Amir et al. <ref> [5] </ref> for its adequacy to the Transis protocol. It operates on top of the causal order and does not block the regular flow of messages while membership changes are handled. 3. Atomic multicast and total ordering. The atomic multicast primitive delivers messages in a linear order. <p> Regular messages from processors not in the current group view are discarded and ignored. 2. Between two configuration changes, each working member of the primary partition delivers the same set of messages. To provide the above services, we used the group membership service of Amir, Dolev, Kramer, and Malki <ref> [5] </ref> for its adequacy to the Transis environment. It operates on top of the causal ordering, and is genuinely distributed.
Reference: [6] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. Transis: </author> <title> A communication sub-system for high availability. </title> <booktitle> In Proceedings of the 22nd Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 76-84, </pages> <address> Los Alamitos, CA, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: Several protocols are used for this facility, and have the property of being all fully distributed. 1. Reliable causal multicast. Networks are quite reliable, but messages can get lost or discarded (Omission failure). We use the reliable multicast engine of Trans [61]/Transis <ref> [6] </ref> to overcome this problem. It incorporates available hardware multicast primitive as part of the system model. In a failure-free environment, a broadcast requires only one single message. It uses unreliable datagrams and performs recovery by piggybacking positive and negative acknowledgments on messages. <p> Dolev and al. refined this approach in the Transis system <ref> [6] </ref>. If i is in ack (m p ) then p has received i, all j in ack (i), and so on. <p> The programmer views the system as if it was synchronous: message delivery and configuration changes are reported in the same order at all sites. This execution model, "virtual synchrony", is based on several properties. Even though variations among systems exist, we can identify core principles <ref> [15, 6, 32, 7] </ref>. 1. Reliable atomic ordered delivery. A message is eventually received by all or no working process. Messages are efficiently disseminated in the network, recovered if they get lost, and delivered in the same order at all sites. 2. Group membership. <p> A history h is legal if each object sub-history hjx lies within the serial specification for x. 3.2 Reliable Communication At the transport level, we used the reliable causal multicast service of Trans [61] / Transis <ref> [6] </ref>. It ensures that 1. every message broadcast or received by a working processor is received by any working processors 2. message delivery preserve causality. Intuitively, a response is never delivered before the corresponding request. This ordering is much like FIFO guarantees for point to point communications. <p> Transitively, all messages n 2 ack fl (m i;j ) were already present at site k before k delivered m i;j . Positive and negative acknowledgments are used to propagate broadcast messages efficiently and reliably. We refer the reader to <ref> [61, 6] </ref> for details on how message recovery and delivery is done.
Reference: [7] <author> Y. Amir, L. E. Moser, P.M. Melliar-Smith, V. Agrawala, and P. Ciarfella. </author> <title> Fast message ordering and membership using a logical token passing ring. </title> <booktitle> In International Conference on Distributed Computing Systems, </booktitle> <address> Pittsburg, PA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Although synchronous systems are usually slower, it is possible to find problems for which an asynchronous system is provably slower than a synchronous one. 10 network supports broadcast, and messages are in some linear order [17]. Amir and al. <ref> [7] </ref> proposed in Totem a logical token passing scheme for broadcast channels. It achieves good performance as the token coordinates the transmission and flow control of broadcast messages. <p> The programmer views the system as if it was synchronous: message delivery and configuration changes are reported in the same order at all sites. This execution model, "virtual synchrony", is based on several properties. Even though variations among systems exist, we can identify core principles <ref> [15, 6, 32, 7] </ref>. 1. Reliable atomic ordered delivery. A message is eventually received by all or no working process. Messages are efficiently disseminated in the network, recovered if they get lost, and delivered in the same order at all sites. 2. Group membership.
Reference: [8] <author> E. Arjomandi, M. J. Fischer, and N. A. Lynch. </author> <title> Efficiency of synchronous versus asynchronous distributed systems. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 30(3) </volume> <pages> 449-456, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: Indeed, simulating reliable point to point links over a broadcast network severely limits performance. A simple implementation of a two-phase commit for n processes using tcp/ip generates as much as 10 fl n packets instead of one, provided that the 6 Arjomandi, Fischer and Lynch discuss <ref> [8] </ref> the relative performance of synchronous and asynchronous systems. Although synchronous systems are usually slower, it is possible to find problems for which an asynchronous system is provably slower than a synchronous one. 10 network supports broadcast, and messages are in some linear order [17].
Reference: [9] <author> D. Barbara and H. Garcia-Molina. </author> <title> The vulnerability of vote assignments. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 4(3):187, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: A logical structure based on grids is also presented in Cheung, Ammar and Ahamad [26]. Ahamad and Ammar [4, 25] evaluated the performance of quorum based protocols when data becomes unavailable. Barbara and Garcia-Molina <ref> [9, 10] </ref> studied the vulnerability of voting assignment in the presence of failures. Kumar and Segev [54] proposed heuristics to minimize communication costs under availability constraints. Spasojevic and Berman [84] designed an algorithm for computing optimal static pessimistic vote assignments when relative frequencies of read and write operations are known.
Reference: [10] <author> D. Barbara and H. Garcia-Molina. </author> <title> The reliability of voting mechanisms. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 36(10) </volume> <pages> 1197-1208, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: A logical structure based on grids is also presented in Cheung, Ammar and Ahamad [26]. Ahamad and Ammar [4, 25] evaluated the performance of quorum based protocols when data becomes unavailable. Barbara and Garcia-Molina <ref> [9, 10] </ref> studied the vulnerability of voting assignment in the presence of failures. Kumar and Segev [54] proposed heuristics to minimize communication costs under availability constraints. Spasojevic and Berman [84] designed an algorithm for computing optimal static pessimistic vote assignments when relative frequencies of read and write operations are known.
Reference: [11] <author> D. Barbara, H. Garcia-Molina, and Spauster. </author> <title> Protocols for dynamic vote reassignment. </title> <booktitle> In Proceedings of the 5th ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 195-205, </pages> <address> New York, </address> <year> 1986. </year>
Reference-contexts: Other dynamic quorum based methods of this type are the vote reassignment of Garcia-Molina, Barbara and Spauster <ref> [11] </ref>, the quorum adjustment of Herlihy [47], and the dynamic voting of Jajodia and Mutch-ler [51]. In the vote reassignment and the quorum adjustment methods, sites that are up can change their votes on detecting failures of other sites by following a particular protocol.
Reference: [12] <author> P. Bernstein and N. Goodman. </author> <title> Concurrency control in distributed database systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 13(2), </volume> <month> June </month> <year> 1981. </year>
Reference-contexts: Such executions are called one-copy serializable. Many concurrency control protocols have been proposed to guarantee one-copy serializability. Most of them fall into three categories: locking, timestamp, and optimistic (certification) algorithms. We refer the reader to the texts by Bernstein, Hadzilacos, and Goodman <ref> [14, 12] </ref> for a good survey of the algorithms, and Lynch, Merrit, Weihl and Fekete [60] for a general theory of atomic transactions. Initial work on concurrency control left the data uninterpreted, or viewed operations as simple reads and writes.
Reference: [13] <author> P. A. Bernstein and N. Goodman. </author> <title> An algorithm for concurrency control and recovery in replicated distributed databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(4):596, </volume> <month> December </month> <year> 1984. </year>
Reference-contexts: The dynamic voting method stores additional information regarding the number of sites at which the most recent update is performed. Another dynamic algorithm is the available copies of Bernstein and Goodman <ref> [13] </ref>. In this method, query transactions can read any single site, while update transactions must write at all sites that are up. To guarantee correctness, each transaction must perform two additional steps called missing writes and access validation.
Reference: [14] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: Such executions are called one-copy serializable. Many concurrency control protocols have been proposed to guarantee one-copy serializability. Most of them fall into three categories: locking, timestamp, and optimistic (certification) algorithms. We refer the reader to the texts by Bernstein, Hadzilacos, and Goodman <ref> [14, 12] </ref> for a good survey of the algorithms, and Lynch, Merrit, Weihl and Fekete [60] for a general theory of atomic transactions. Initial work on concurrency control left the data uninterpreted, or viewed operations as simple reads and writes. <p> However for most replicated data structures, correctness is maintained only if the schedule of operations applied to each copy is equivalent to one that would result in a system without concurrency. The equivalence relation is based on the commutativity of operations, usually for reads and writes <ref> [14] </ref>. To implement a replicated object, we propose a multicast primitive with delivery semantics based on the commutativity of operations, the object's state and the communication pattern. All sites agree on the construction of a linear order for operation processing, but relax this order to enhance response time.
Reference: [15] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: If the sequencer goes down, the invitation algorithm of Garcia-Molina [44] is invoked to elect a new sequencer. Positive and negative acknowledgments are used to ensure that broadcast updates are received by all group members. In Isis, Birman and al. <ref> [15] </ref> developed a family of multicast primitives with different order semantics. The CBCAST primitive uses vector timestamps to order messages according to their causal dependencies. This primitive is used by the ABCAST protocol to extend the causal order and deliver messages in the same order at all sites. <p> The programmer views the system as if it was synchronous: message delivery and configuration changes are reported in the same order at all sites. This execution model, "virtual synchrony", is based on several properties. Even though variations among systems exist, we can identify core principles <ref> [15, 6, 32, 7] </ref>. 1. Reliable atomic ordered delivery. A message is eventually received by all or no working process. Messages are efficiently disseminated in the network, recovered if they get lost, and delivered in the same order at all sites. 2. Group membership.
Reference: [16] <author> K. P. Birman. </author> <title> The process group approach to reliable distributed computing. </title> <type> Technical report, </type> <institution> Cornell University, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: Introduced by Birman <ref> [16] </ref>, virtual synchrony is an execution model with a collection of properties that allow processes to cooperate and appear logically synchronized. Each process of a group has an associated group view of the working processors.
Reference: [17] <author> R. Braden. </author> <title> Extending fTCPg for transactions. </title> <type> Technical Report RFC 1379, </type> <institution> University of Southern California, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: Although synchronous systems are usually slower, it is possible to find problems for which an asynchronous system is provably slower than a synchronous one. 10 network supports broadcast, and messages are in some linear order <ref> [17] </ref>. Amir and al. [7] proposed in Totem a logical token passing scheme for broadcast channels. It achieves good performance as the token coordinates the transmission and flow control of broadcast messages.
Reference: [18] <author> Steven J. Brams and Peter C. Fishburn. </author> <title> Approval Voting. </title> <address> Birkauser, Boston, </address> <year> 1983. </year> <month> 54 </month>
Reference-contexts: We also review fundamentals results of the theory of voting. Indeed, an impressive body of mathematical results have been gathered in the past few decades in the theory of social choice, and are important for the design of decision making procedures <ref> [86, 18] </ref>. Voting has many applications for computer science: it can be used for the allocation of resources, or like in distributed systems, to ensure that only one group of processes is allowed to perform some restricted operations. <p> This led us to our voting method, approval voting, for which the preference profiles are restricted to a particular domain. 7.4 Properties Of Approval Voting Like plurality voting, approval voting <ref> [18] </ref> is a non-ranked voting system.
Reference: [19] <author> A. Burger and V. Kumar. </author> <title> Performance measurement of main memory database recovery algorithms based on update-in-place and shadow approaches. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 4(6) </volume> <pages> 567-571, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Processing should continue at other sites and s should recover fast. Incremental recovery algorithms [57] have been developed for the centralized case, but could change with when multiple copies are available. 4. Kumar and Burger have evaluated in <ref> [19] </ref> the performance of main memory recovery algorithms based on update in place and shadow approaches, but not for deferred update. However, this recovery strategy seems to place fewer restraints on concurrency and might be more adequate when a database is replicated. 53
Reference: [20] <author> T. D. Chandra and S. Toueg. </author> <title> Unreliable failure detectors for reliable distributed systems. </title> <booktitle> In Proceedings of the 10th Annual Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 325-340. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: Even if it is impossible to solve the consensus problem in a true asynchronous system [42], due to the inability to distinguish between communication delays and crash failures, we can use unreliable failure detectors (like timeouts) to emit suspicions of processor failures <ref> [20] </ref>. If a processor is suspected to have failed, it is removed from the group. The notion of failure in this model is weak in the sense that a process has failed if it is not a member of the group.
Reference: [21] <author> M. Chandy and L. Lamport. </author> <title> Distributed snapshots: determining global states of distributed systems. </title> <journal> Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <year> 1985. </year>
Reference-contexts: We give below a summary of definitions to solve the membership problem. A formal and extended version of the problem statement appears in [81]. Definition 6 Given a consistent cut c of the system, as defined by Chandy and Lamport in <ref> [21] </ref>, a set S of processes are in membership consent on c if all working processes of S have identical local views of the group. Definition 7 A membership protocol should have the following properties: 1. Triviality. A group view eventually exist. 2. Validity. <p> This (small) digression is based on the premise that not just one, but several approaches are possible to solve problems in distributed computing. Current formalisms promote reasoning about events (Lam-port <ref> [56, 21] </ref>), states (Chandy and Misra [22]), or knowledge (Halpern [70]). However, we have shown that recent results in social choice theory (Moulin [72, 71]) can also prove to be useful, as they provide a better understanding about voting procedures.
Reference: [22] <author> M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: This (small) digression is based on the premise that not just one, but several approaches are possible to solve problems in distributed computing. Current formalisms promote reasoning about events (Lam-port [56, 21]), states (Chandy and Misra <ref> [22] </ref>), or knowledge (Halpern [70]). However, we have shown that recent results in social choice theory (Moulin [72, 71]) can also prove to be useful, as they provide a better understanding about voting procedures.
Reference: [23] <author> J. M. Chang and N. F. Maxemchuk. </author> <title> Reliable broadcast protocols. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 251-273, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Current extensions of the IP layer provide similar services [34]. As in most early solutions, the communication topology is assumed to be fully connected and point to point. The channels are also reliable (eventual, exactly once delivery of uncorrupted messages) and first-in first-out. Chang and al. <ref> [23] </ref> proposed a family of atomic broadcast protocols using a token revolving in a token list. One site, the token holder, defines a unique order for all messages. When a message is sent, the token site sends an acknowledgment containing a timestamp.
Reference: [24] <author> D. R. Cheriton and W. Zwaenepoel. </author> <title> Distributed process groups in the V kernel. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(2):77, </volume> <month> May </month> <year> 1985. </year>
Reference-contexts: Fault-tolerance is achieved through server group replication on independent redundant hardware. Server replication is supported by underlying synchronous services like group communication [32, 28], membership changes [30] and clock synchronization [31]. The V system <ref> [24] </ref> first introduced the notion of group communication, but without guaranteeing the delivery or order of messages. Current extensions of the IP layer provide similar services [34]. As in most early solutions, the communication topology is assumed to be fully connected and point to point.
Reference: [25] <author> S. Y. Cheung, M. Ahamad, and M. H. Ammar. </author> <title> Optimizing vote and quorum assignments for reading and writing replicated data. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(3):387, </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: A coterie is a collections of intersecting minimal subsets of sites. Interestingly, if the system has six or more nodes, there exist several coteries that do not have equivalent quorum assignments. A logical structure based on grids is also presented in Cheung, Ammar and Ahamad [26]. Ahamad and Ammar <ref> [4, 25] </ref> evaluated the performance of quorum based protocols when data becomes unavailable. Barbara and Garcia-Molina [9, 10] studied the vulnerability of voting assignment in the presence of failures. Kumar and Segev [54] proposed heuristics to minimize communication costs under availability constraints.
Reference: [26] <author> S. Y. Cheung, M. H. Ammar, and M. Ahamad. </author> <title> The grid protocol: A high performance scheme for maintaining replicated data. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 4(6) </volume> <pages> 582-59, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: A coterie is a collections of intersecting minimal subsets of sites. Interestingly, if the system has six or more nodes, there exist several coteries that do not have equivalent quorum assignments. A logical structure based on grids is also presented in Cheung, Ammar and Ahamad <ref> [26] </ref>. Ahamad and Ammar [4, 25] evaluated the performance of quorum based protocols when data becomes unavailable. Barbara and Garcia-Molina [9, 10] studied the vulnerability of voting assignment in the presence of failures. Kumar and Segev [54] proposed heuristics to minimize communication costs under availability constraints.
Reference: [27] <author> J. H. Conway. </author> <title> On Numbers and Games. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1976. </year>
Reference-contexts: However, we have shown that recent results in social choice theory (Moulin [72, 71]) can also prove to be useful, as they provide a better understanding about voting procedures. Similarly, advances in game theory (Conway <ref> [27] </ref>) might also be adequate for distributed applications where decisions are made in a non-cooperative (competitive) manner, for the allocation of resources for example. We left these issues as future research. 8 Conclusion Technological progress in computing systems generates new challenging demands.
Reference: [28] <author> F. Cristian. </author> <title> Synchronous atomic broadcast for redundant broadcast channels. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 2(1) </volume> <pages> 57-94, </pages> <year> 1990. </year>
Reference-contexts: Fault-tolerance is achieved through server group replication on independent redundant hardware. Server replication is supported by underlying synchronous services like group communication <ref> [32, 28] </ref>, membership changes [30] and clock synchronization [31]. The V system [24] first introduced the notion of group communication, but without guaranteeing the delivery or order of messages. Current extensions of the IP layer provide similar services [34]. <p> These issues are left to the developer who is unable to cope with uncertainties due to random communication delays and component failures. These problems prevent processes from having the knowledge of global system states that shared storage (like shared variable) provides in a centralized system <ref> [28] </ref>. Process group communication is an attractive abstraction to structure fault-tolerant distributed applications: it supports primitives to send and receive messages from 1 to n destinations. The semantics of these multicast primitives are simple, powerful, and easy to understand.
Reference: [29] <author> F. Cristian. </author> <title> Fault-tolerance in the advanced automation system. </title> <booktitle> ACM SIGOPS Operating Systems Review, </booktitle> <address> 25(2):117, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: In this work, we do not consider synchronous systems in which upper bounds are placed on communication and processing delays. They are designed with strong assumptions to cope with the worst possible situation, but may not take advantage of the average case. 6 The Advanced Automation System <ref> [29] </ref> of the Federal Aviation Administration is an example of these systems. Fault-tolerance is achieved through server group replication on independent redundant hardware. Server replication is supported by underlying synchronous services like group communication [32, 28], membership changes [30] and clock synchronization [31].
Reference: [30] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4(4) </volume> <pages> 175-188, </pages> <year> 1991. </year>
Reference-contexts: Fault-tolerance is achieved through server group replication on independent redundant hardware. Server replication is supported by underlying synchronous services like group communication [32, 28], membership changes <ref> [30] </ref> and clock synchronization [31]. The V system [24] first introduced the notion of group communication, but without guaranteeing the delivery or order of messages. Current extensions of the IP layer provide similar services [34].
Reference: [31] <author> F. Cristian, H. Aghili, and R. </author> <title> Strong. Clock synchronization in the presence of omission and performance failures, and processor joins. </title> <type> Technical report, </type> <institution> IBM Almaden Research Center, </institution> <year> 1992. </year>
Reference-contexts: Fault-tolerance is achieved through server group replication on independent redundant hardware. Server replication is supported by underlying synchronous services like group communication [32, 28], membership changes [30] and clock synchronization <ref> [31] </ref>. The V system [24] first introduced the notion of group communication, but without guaranteeing the delivery or order of messages. Current extensions of the IP layer provide similar services [34]. As in most early solutions, the communication topology is assumed to be fully connected and point to point.
Reference: [32] <author> F. Cristian, H. Aghili, R. Strong, and D. Dolev. </author> <title> Atomic broadcast: From simple message diffusion to byzantine agreement. </title> <type> Research Report RJ 4540, </type> <institution> IBM Research Laboratory, </institution> <address> San Jose, CA, </address> <month> December </month> <year> 1984. </year>
Reference-contexts: Broadcast messages are received by all processors in the network, while multicast messages explicitly select the set of destinations. In this paper, we often interchange the use those terms. 9 processors and systems in which malicious processors try to prevent the protocol from reaching consensus <ref> [32] </ref>. We present below protocols for more realistic systems models. In this work, we do not consider synchronous systems in which upper bounds are placed on communication and processing delays. <p> Fault-tolerance is achieved through server group replication on independent redundant hardware. Server replication is supported by underlying synchronous services like group communication <ref> [32, 28] </ref>, membership changes [30] and clock synchronization [31]. The V system [24] first introduced the notion of group communication, but without guaranteeing the delivery or order of messages. Current extensions of the IP layer provide similar services [34]. <p> The programmer views the system as if it was synchronous: message delivery and configuration changes are reported in the same order at all sites. This execution model, "virtual synchrony", is based on several properties. Even though variations among systems exist, we can identify core principles <ref> [15, 6, 32, 7] </ref>. 1. Reliable atomic ordered delivery. A message is eventually received by all or no working process. Messages are efficiently disseminated in the network, recovered if they get lost, and delivered in the same order at all sites. 2. Group membership.
Reference: [33] <author> S. B. Davidson, H. Garcia-Molina, and D. Skeen. </author> <title> Consistency in partitioned networks. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(3):341, </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: Popular techniques for providing high availability are based on voting or primary copy <ref> [33] </ref>. Thomas proposed majority voting [87], extended by Gifford for quorum consensus protocols [46]. Each site is assigned a vote and, in order to perform a read (write) operation, a number of votes, or quorum, need to be acquired.
Reference: [34] <author> S. Deering. </author> <title> Host extensions for IP multicasting. </title> <type> Technical Report RFC 1112, </type> <institution> Stanford University, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: Server replication is supported by underlying synchronous services like group communication [32, 28], membership changes [30] and clock synchronization [31]. The V system [24] first introduced the notion of group communication, but without guaranteeing the delivery or order of messages. Current extensions of the IP layer provide similar services <ref> [34] </ref>. As in most early solutions, the communication topology is assumed to be fully connected and point to point. The channels are also reliable (eventual, exactly once delivery of uncorrupted messages) and first-in first-out.
Reference: [35] <author> A. Demers, D. Greene, C. Hauser, W. I., J. Larson, S. Shenker, H. Sturgis, D. Swinehart, and D. Terry. </author> <title> Epidemic algorithms for replicated database maintenance. </title> <booktitle> In Proceedings of the 6th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 1-12. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1987. </year>
Reference-contexts: Flooding is an another classic diffusion technique: when a site receives an update, it propagates this update to its neighbors and so on. More recently, epidemiologic algorithms based on rumors or viruses were also proposed for the management of replicated data <ref> [35, 40] </ref>. Lazy replication, proposed by Landin and al. [55] for the Gossip system, enhances response time and availability, provided that the user has specified the potential causal dependencies among requests. Unrelated requests do not incur any latency due to communication delays.
Reference: [36] <author> D. Dolev, S. Kramer, and D. Malki. </author> <title> Total ordering of messages in broadcast domains. </title> <type> Technical report, </type> <institution> The Hebrew University of Jerusalem, </institution> <month> November </month> <year> 1992. </year> <month> 55 </month>
Reference-contexts: B; F; I; Jg roots of the dag m i A B F I J nvt (m i ) jfAgj = 1 jfB; C; D; E; Ggj = 5 jfC; D; E; F gj = 4 jfH; Igj = 1 jfJ gj = 1 10 Neither Total [61] nor ToTo <ref> [36] </ref> are able to elect messages with such DAG, as they require a candidate set to receive more than n=2 votes to be elected. 27 votes (row; col) A B F I J A jfAgj = 1 1 1 1 B jfB; C; D; E; Ggj = 5 jfB; Ggj =
Reference: [37] <author> D. Dolev, S. Kramer, and D. Malki. </author> <title> Early delivery totally ordered broadcast in asynchronous environ-ments. </title> <booktitle> In Proceedings of the 23rd Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 544-553, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Then, apply Lemma 4 inductively to G fl . 2 4.3 A Refinement Of The ToTo Delivery Rule In this section, we present a simplification and improvement of the ToTo early delivery algorithm of Dolev, Kramer, and Malki <ref> [37] </ref>. We generally follow their terminology, but modify it where convenient to simplify the presentation. In the following discussion, we define some functions that the early delivery protocol uses. The functions are evaluated on the current causality DAG G at processor p.
Reference: [38] <author> D. Dolev, L. Lamport, M. Pease, and R. Shostak. </author> <title> The Byzantine generals. In `Concurrency Control and Reliability in Distributed Systems', </title> <publisher> Bhargava(ed). Van Nostrand Reinhold, </publisher> <address> New York, NY, </address> <year> 1987. </year>
Reference-contexts: With such services, processes appear to be virtually synchronous. Distributed agreement, say on a particular order or group membership, has been addressed within the Byzantine Generals framework <ref> [38] </ref>. Typical models within this framework have assumed synchronized 4 Webster's definition: "a coterie is a close circle of friends who share a common interest." 5 Group communication refers to the abstraction of a group of processes cooperating by exchanging messages.
Reference: [39] <author> D. Dolev, D. Malki, and Ray Strong. </author> <title> An asynchronous membership protocol that tolerates partitions. </title> <type> Technical Report CS TR94-6, </type> <institution> The Hebrew University of Jerusalem, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Progress is guaranteed as it operates on top of the membership protocol. The latter has also the unusual capability of supporting more than one network partition <ref> [39] </ref>.
Reference: [40] <author> A. R. Downing, I. G. Greenberg, and J. M. Peha. OSCAR: </author> <title> A system for weak-consistency replication. </title> <booktitle> In IEEE Workshop on Management of Replicated Data, </booktitle> <address> Houston, TX, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: Flooding is an another classic diffusion technique: when a site receives an update, it propagates this update to its neighbors and so on. More recently, epidemiologic algorithms based on rumors or viruses were also proposed for the management of replicated data <ref> [35, 40] </ref>. Lazy replication, proposed by Landin and al. [55] for the Gossip system, enhances response time and availability, provided that the user has specified the potential causal dependencies among requests. Unrelated requests do not incur any latency due to communication delays.
Reference: [41] <author> D. L. Eager and K. C. Sevcik. </author> <title> Achieving robustness in distributed database systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 8(3), </volume> <month> September </month> <year> 1983. </year>
Reference-contexts: Dynamic protocols adjust as sites fail and recover. Voting protocols adjust votes assignment and quorum sizes, while other algorithms use network information to reconfigure and do additional work. In the missing writes method of Eager and Sevcivk <ref> [41] </ref>, a read-one, write-all (rowa) strategy is used when all sites are up; however if a sites goes down, the size of the read quorum is increased and that of the write quorum is decreased.
Reference: [42] <author> M. J. Fischer, N. A. Lynch, and M. S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Even if it is impossible to solve the consensus problem in a true asynchronous system <ref> [42] </ref>, due to the inability to distinguish between communication delays and crash failures, we can use unreliable failure detectors (like timeouts) to emit suspicions of processor failures [20]. If a processor is suspected to have failed, it is removed from the group.
Reference: [43] <author> P.A. Fishwick. </author> <title> Simulation Model Design and Execution: Building Digital Worlds. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year> <note> Simpack is available via anonymous ftp at ftp.cis.ufl.edu:pub/simdigest/tools/simpack-2.23.tar.Z. </note>
Reference-contexts: For the LG-Top protocol, we record also the number of messages delivered by: * Lexicographic order rule (L-Delivery ()) * Early delivery rule (R ()) * Default delivery rule (ntail (G) = n) 6.8 Simulation Performance evaluation was conducted using simpack++, a discrete event simulation package by P. Fishwick <ref> [43] </ref> . We introduced two system parameters, n, the number of sites in P and nm the number of messages for each simulation. We defined some standard numerical values for the simulations.
Reference: [44] <author> H. Garcia-Molina. </author> <title> Elections in a distributed computing system. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 31(1) </volume> <pages> 12-46, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: As all updates have to go through the master, the primary site may exhibit performance bottlenecks. It may also become unavailable if a failure occurs. At that time, an election algorithm is initiated to decide on a new leading copy <ref> [44] </ref>. A similar type of centralized scheme is based on the passing of a token. The holder of the token is given the privilege of updating the replica and propagating updates. When the token is lost, the system has to reconfigure to regenerate it. <p> A unique broadcast server, the sequencer, imposes a total ordering on all updates originating from all broadcast servers. Their protocol differs from Chang in that the sequencer is fixed. If the sequencer goes down, the invitation algorithm of Garcia-Molina <ref> [44] </ref> is invoked to elect a new sequencer. Positive and negative acknowledgments are used to ensure that broadcast updates are received by all group members. In Isis, Birman and al. [15] developed a family of multicast primitives with different order semantics.
Reference: [45] <author> H. Garcia-Molina and D. Barbara. </author> <title> How to assign votes in a distributed system. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 34(4) </volume> <pages> 841-860, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: These ghosts are used to to detect that a copy is unavailable due to a node crash, not due to a network partition. Kumar [53], and Agrawal and Abadi [2] introduced hierarchical quorums to limit the size of the quorums 8 as the number of processors increases. In <ref> [45] </ref> the notion of coteries 4 is proposed as an alternative to quorums. A coterie is a collections of intersecting minimal subsets of sites. Interestingly, if the system has six or more nodes, there exist several coteries that do not have equivalent quorum assignments.
Reference: [46] <author> D. K. Gifford. </author> <title> Weighted voting for replicated data. </title> <booktitle> In Proceeding of the 7th ACM Symposium on Operating Systems Principles, </booktitle> <address> Pacific Grove CA, </address> <month> December </month> <year> 1979. </year>
Reference-contexts: Popular techniques for providing high availability are based on voting or primary copy [33]. Thomas proposed majority voting [87], extended by Gifford for quorum consensus protocols <ref> [46] </ref>. Each site is assigned a vote and, in order to perform a read (write) operation, a number of votes, or quorum, need to be acquired.
Reference: [47] <author> M. Herlihy. </author> <title> A quorum-consensus replication method for abstract data types. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 4(1):32, </volume> <month> February </month> <year> 1986. </year>
Reference-contexts: Other dynamic quorum based methods of this type are the vote reassignment of Garcia-Molina, Barbara and Spauster [11], the quorum adjustment of Herlihy <ref> [47] </ref>, and the dynamic voting of Jajodia and Mutch-ler [51]. In the vote reassignment and the quorum adjustment methods, sites that are up can change their votes on detecting failures of other sites by following a particular protocol.
Reference: [48] <author> M. Herlihy. </author> <title> Dynamic quorum adjustment for partitioned data. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 170-175, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Thomas proposed majority voting [87], extended by Gifford for quorum consensus protocols [46]. Each site is assigned a vote and, in order to perform a read (write) operation, a number of votes, or quorum, need to be acquired. Herlihy defined quorums for abstract data types <ref> [48] </ref>, in which each operation of an object is assigned a set of quorums or set of sites whose cooperation is needed to execute that operation. As the votes assignment is fixed a priori, these schemes are classified as static voting. Dynamic protocols adjust as sites fail and recover.
Reference: [49] <author> M. Herlihy and J. Wing. </author> <title> Linearizability: a correctness condition for concurrent objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Initial work on concurrency control left the data uninterpreted, or viewed operations as simple reads and writes. Recently, several researchers have considered placing more structure on the data to increase concurrency <ref> [50, 49, 3] </ref>. Such techniques can be used in databases to deal with "hot spots," or frequently accessed data. One approach is to use the specifications of abstract data types to design type-specific concurrency control algorithms.
Reference: [50] <author> M. Herlihy, L. Zahn, T. Dineen, P. Leach, E. Martin, N. Mishkin, J. Pato, and G. Wyant. </author> <title> Concurrency and availability as dual properties of replicated atomic data network computing architecture. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 37(2) </volume> <pages> 257-278, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Initial work on concurrency control left the data uninterpreted, or viewed operations as simple reads and writes. Recently, several researchers have considered placing more structure on the data to increase concurrency <ref> [50, 49, 3] </ref>. Such techniques can be used in databases to deal with "hot spots," or frequently accessed data. One approach is to use the specifications of abstract data types to design type-specific concurrency control algorithms.
Reference: [51] <author> S. Jajodia and D. Mutchler. </author> <title> Dynamic voting algorithms for maintaining the consistency of a replicated database. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(2) </volume> <pages> 230-253, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Other dynamic quorum based methods of this type are the vote reassignment of Garcia-Molina, Barbara and Spauster [11], the quorum adjustment of Herlihy [47], and the dynamic voting of Jajodia and Mutch-ler <ref> [51] </ref>. In the vote reassignment and the quorum adjustment methods, sites that are up can change their votes on detecting failures of other sites by following a particular protocol. The dynamic voting method stores additional information regarding the number of sites at which the most recent update is performed.
Reference: [52] <author> M. F. Kaashoek and A. S. Tanenbaum. </author> <title> Efficient reliable group communication for distributed systems. </title> <note> submitted for publication, </note> <year> 1994. </year>
Reference-contexts: This scheme introduces a very long delay before a message can be delivered. It requires also between two and three broadcast messages per atomic broadcast. Kaashoek and al. <ref> [52] </ref> proposed another type of sequencer based protocol for the Amoeba operating system. A unique broadcast server, the sequencer, imposes a total ordering on all updates originating from all broadcast servers. Their protocol differs from Chang in that the sequencer is fixed.
Reference: [53] <author> A. Kumar. </author> <title> Hierarchical quorum consensus: A new algorithm for managing replicated data. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(9) </volume> <pages> 996-1004, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Van Renesse and Tanenbaum presented a similar scheme, voting with ghosts [80], in which some sites do not even keep the state of the replica. These ghosts are used to to detect that a copy is unavailable due to a node crash, not due to a network partition. Kumar <ref> [53] </ref>, and Agrawal and Abadi [2] introduced hierarchical quorums to limit the size of the quorums 8 as the number of processors increases. In [45] the notion of coteries 4 is proposed as an alternative to quorums. A coterie is a collections of intersecting minimal subsets of sites.
Reference: [54] <author> A. Kumar and A. Segev. </author> <title> Cost and availability tradeoffs in replicated data concurrency control. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 18(1) </volume> <pages> 102-131, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Ahamad and Ammar [4, 25] evaluated the performance of quorum based protocols when data becomes unavailable. Barbara and Garcia-Molina [9, 10] studied the vulnerability of voting assignment in the presence of failures. Kumar and Segev <ref> [54] </ref> proposed heuristics to minimize communication costs under availability constraints. Spasojevic and Berman [84] designed an algorithm for computing optimal static pessimistic vote assignments when relative frequencies of read and write operations are known.
Reference: [55] <author> R. Ladin, B. Liskov, L. Shrira, and S. Ghemawat. </author> <title> Providing high availability using lazy replication. </title> <journal> ACM Transaction on Computer Systems, </journal> <volume> 10(4):360, </volume> <month> November </month> <year> 1992. </year>
Reference-contexts: More recently, epidemiologic algorithms based on rumors or viruses were also proposed for the management of replicated data [35, 40]. Lazy replication, proposed by Landin and al. <ref> [55] </ref> for the Gossip system, enhances response time and availability, provided that the user has specified the potential causal dependencies among requests. Unrelated requests do not incur any latency due to communication delays. It relies on gossip, or lazy propagation of updates.
Reference: [56] <author> L. Lamport. </author> <title> Time, clocks and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7), </volume> <month> July </month> <year> 1978. </year> <month> 56 </month>
Reference-contexts: Atomic multicast and total ordering. The atomic multicast primitive delivers messages in a linear order. We designed a set of rules to deliver concurrent messages early as soon as their position in the total order is decided. Another solution would be to deliver message using logical clocks and timestamps <ref> [56] </ref>, but this approach makes the system run at the speed of the slowest processor. 4. Semantic based ordering for replicated abstract data types. The total ordering can be relaxed by using the commutativity property of operations. We used Weihl's notion of forward commutativity [88] to better exploit concurrency. <p> Intuitively, a response is never delivered before the corresponding request. This ordering is much like FIFO guarantees for point to point communications. The notion of causality was formalized by Lamport in his seminal paper <ref> [56] </ref>. The set of events in a distributed system is structured by "happened before" relation, which is also termed causality. This relation, " !," is the smallest relation satisfying the three following properties: 1. <p> This approach is very similar to putting a timestamp on messages and delivering messages in timestamp order <ref> [56] </ref>. While this algorithm provides total ordering at no additional cost in messages or acknowledgments, it delays delivery until every processor has sent a message. The latency can be large, and it forces the system to operate at the speed of the slowest processor. <p> This (small) digression is based on the premise that not just one, but several approaches are possible to solve problems in distributed computing. Current formalisms promote reasoning about events (Lam-port <ref> [56, 21] </ref>), states (Chandy and Misra [22]), or knowledge (Halpern [70]). However, we have shown that recent results in social choice theory (Moulin [72, 71]) can also prove to be useful, as they provide a better understanding about voting procedures.
Reference: [57] <author> E. Levy and A. Silberschatz. </author> <title> Incremental recovery in main memory database systems. </title> <journal> IEEE Transac--tions on Knowledge and Data Engineering, </journal> <volume> 4(6) </volume> <pages> 529-540, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Other aspects of a replicated main memory database (MMDB) need further research: when a site s recovers, state information has to be transferred to bring the database of s up-to-date. Processing should continue at other sites and s should recover fast. Incremental recovery algorithms <ref> [57] </ref> have been developed for the centralized case, but could change with when multiple copies are available. 4. Kumar and Burger have evaluated in [19] the performance of main memory recovery algorithms based on update in place and shadow approaches, but not for deferred update.
Reference: [58] <author> B. Liskov, S. Ghemawat, R. Gruber, P. Johnson, L. Shrira, and M. Williams. </author> <title> Replication in the Harp file system. </title> <booktitle> In Proceedings of 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 226-38. </pages> <institution> Association for Computing Machinery SIGOPS, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: The holder of the token is given the privilege of updating the replica and propagating updates. When the token is lost, the system has to reconfigure to regenerate it. The primary copy method has been used in high available file systems <ref> [58] </ref> or main-memory databases [82]. Another tactic to enhance availability is to use system semantics, or application dependent information. Probabilistic algorithms and lazy-replication are two examples of this approach. Probabilistic algorithms were proposed for applications with weaker consistency requirements. If copies are allowed to diverge temporarily, diffusion techniques become applicable.
Reference: [59] <author> S. Luan and V. Gligor. </author> <title> A fault-tolerant protocol for atomic broadcast. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(3) </volume> <pages> 271-285, </pages> <year> 1990. </year>
Reference-contexts: It supports also a semantic ordering, delivering messages early by giving a priority to read operations. Failure notifications are causally ordered, but the membership protocol does not guarantee that all group members view the same sequence of configuration changes (virtual synchrony). Luan and Gligor <ref> [59] </ref> derived an atomic broadcast from the three phase commit protocol. In the first phase, a process initiates a voting round. When enough acknowledgments have been collected, the initiator enters a notification phase to specify which messages need to be ordered.
Reference: [60] <author> N. A. Lynch, M. Merritt, W. Weihl, and A. Fekete. </author> <title> Atomic Transactions. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1994. </year>
Reference-contexts: Most of them fall into three categories: locking, timestamp, and optimistic (certification) algorithms. We refer the reader to the texts by Bernstein, Hadzilacos, and Goodman [14, 12] for a good survey of the algorithms, and Lynch, Merrit, Weihl and Fekete <ref> [60] </ref> for a general theory of atomic transactions. Initial work on concurrency control left the data uninterpreted, or viewed operations as simple reads and writes. Recently, several researchers have considered placing more structure on the data to increase concurrency [50, 49, 3]. <p> A formal definition of these two notions and their impact on recovery is beyond the scope of this paper. The curious reader may consult <ref> [60] </ref> for further details. This idea of commutativity can be applied in general distributed systems to increase concurrency. We will use it to allow different sites to invoke operations on objects in different orders.
Reference: [61] <author> P. M. Melliar-Smith, L. Moser, and V. Agrawala. </author> <title> Broadcast protocols for distributed systems. </title> <journal> IEEE transactions on parallel and distributed systems, </journal> <volume> 1(1), </volume> <year> 1990. </year>
Reference-contexts: In their broadcast model, if a message is delivered, it is delivered immediately and in order but not necessarily to all processes. In the Trans system <ref> [62, 61] </ref>, they designed a reliable broadcast primitive for unreliable datagrams. It avoids the several rounds of message of most consensus agreement by placing a total order on messages only with a high probability. Messages contain piggyback information to perform recovery and decide which process has received a particular message. <p> Each object has a serial specification, which defines a set of legal histories for that object. A history h is legal if each object sub-history hjx lies within the serial specification for x. 3.2 Reliable Communication At the transport level, we used the reliable causal multicast service of Trans <ref> [61] </ref> / Transis [6]. It ensures that 1. every message broadcast or received by a working processor is received by any working processors 2. message delivery preserve causality. Intuitively, a response is never delivered before the corresponding request. This ordering is much like FIFO guarantees for point to point communications. <p> Transitively, all messages n 2 ack fl (m i;j ) were already present at site k before k delivered m i;j . Positive and negative acknowledgments are used to propagate broadcast messages efficiently and reliably. We refer the reader to <ref> [61, 6] </ref> for details on how message recovery and delivery is done. <p> G = fA; B; F; I; Jg roots of the dag m i A B F I J nvt (m i ) jfAgj = 1 jfB; C; D; E; Ggj = 5 jfC; D; E; F gj = 4 jfH; Igj = 1 jfJ gj = 1 10 Neither Total <ref> [61] </ref> nor ToTo [36] are able to elect messages with such DAG, as they require a candidate set to receive more than n=2 votes to be elected. 27 votes (row; col) A B F I J A jfAgj = 1 1 1 1 B jfB; C; D; E; Ggj = 5
Reference: [62] <author> P. M. Melliar-Smith and L. E. Moser. </author> <title> Fault-tolerant distributed systems based on broadcast communication. </title> <booktitle> In Proceedings of the 9th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 129-135, </pages> <address> Newport Beach, CA, 1989. </address> <publisher> IEEE Computer Society , Washington, </publisher> <address> DC. </address>
Reference-contexts: In their broadcast model, if a message is delivered, it is delivered immediately and in order but not necessarily to all processes. In the Trans system <ref> [62, 61] </ref>, they designed a reliable broadcast primitive for unreliable datagrams. It avoids the several rounds of message of most consensus agreement by placing a total order on messages only with a high probability. Messages contain piggyback information to perform recovery and decide which process has received a particular message.
Reference: [63] <author> P. M. Melliar-Smith and L. E. Moser. </author> <title> Analyzing the performance of complex systems. </title> <booktitle> In Proceedings of the 1991 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems - Performance Evaluation Review, </booktitle> <pages> pages 1-10, </pages> <address> San Diego, CA, </address> <month> May </month> <year> 1991. </year> <institution> University of California at Santa Barbara. </institution>
Reference-contexts: Two classes of message ordering are supported: linear and semantic order. To study the performance of our primitives, we opted for an approach based on discrete event simulation. Previous work on broadcast protocols relied on several different analytical models, making comparative evaluation difficult <ref> [63] </ref>. Simulation and experimental results with our implementation of the protocols are encouraging.
Reference: [64] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> Implementing fault-tolerant replicated objects using psync. </title> <booktitle> In Proceedings of the 8th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 42-52, </pages> <address> Seattle, WA, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: When Top is unable to deliver messages, they use additional heuristics, informations about the causality graph and the operations carried by the messages, to improve concurrency. 5.1 Commutativity Based Consistency Mishra, Peterson, and Schlichting have proposed a semantic based ordering multicast primitive for Psync <ref> [64, 65, 66] </ref>. It optimizes delivery by using the commutativity property of read operations. Their algorithm works as follows. Operations are sent to all sites using a reliable causal multicast 29 primitive. Each site arranges the operations it receives in a causality graph and executes them in waves.
Reference: [65] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> Consul: A communication substrate for fault-tolerant distributed programs. </title> <type> Technical Report TR 91-32, </type> <institution> University of Arizona, </institution> <year> 1991. </year>
Reference-contexts: When Top is unable to deliver messages, they use additional heuristics, informations about the causality graph and the operations carried by the messages, to improve concurrency. 5.1 Commutativity Based Consistency Mishra, Peterson, and Schlichting have proposed a semantic based ordering multicast primitive for Psync <ref> [64, 65, 66] </ref>. It optimizes delivery by using the commutativity property of read operations. Their algorithm works as follows. Operations are sent to all sites using a reliable causal multicast 29 primitive. Each site arranges the operations it receives in a causality graph and executes them in waves.
Reference: [66] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> A membership protocol based on a partial order. </title> <booktitle> In Proceedings of the International Working Conference on Dependable Computing for Critical Applications, </booktitle> <address> New York, NY, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: When Top is unable to deliver messages, they use additional heuristics, informations about the causality graph and the operations carried by the messages, to improve concurrency. 5.1 Commutativity Based Consistency Mishra, Peterson, and Schlichting have proposed a semantic based ordering multicast primitive for Psync <ref> [64, 65, 66] </ref>. It optimizes delivery by using the commutativity property of read operations. Their algorithm works as follows. Operations are sent to all sites using a reliable causal multicast 29 primitive. Each site arranges the operations it receives in a causality graph and executes them in waves.
Reference: [67] <author> L. E. Moser, P. M. Melliar-Smith, and V. Agrawala. </author> <title> Membership algorithms for asynchronous distributed systems. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 480-489, </pages> <address> Arlington, TX USA, 1991. </address> <publisher> IEEE Computer Society , Washington, </publisher> <address> DC. </address>
Reference-contexts: Using the transitive closure of these acknowledgments, they derived a partial order which can in turn be converted into a total order [68]. For a group of 10 processors, a message can be delivered on average after receiving 7.5 messages. They also designed a membership algorithm <ref> [67] </ref> that operates on top of the total ordering, but suffers from its inherent problems. A majority of the processors need to be operational and there is a small chance that messages cannot be totally ordered if failures occur.
Reference: [68] <author> L. E. Moser, P. M. Melliar-Smith, and V. Agrawala. </author> <title> Asynchronous fault-tolerant total ordering algorithms. </title> <journal> SIAM Journal on Computing, </journal> <volume> 22(4) </volume> <pages> 727-750, </pages> <year> 1993. </year>
Reference-contexts: Using the transitive closure of these acknowledgments, they derived a partial order which can in turn be converted into a total order <ref> [68] </ref>. For a group of 10 processors, a message can be delivered on average after receiving 7.5 messages. They also designed a membership algorithm [67] that operates on top of the total ordering, but suffers from its inherent problems.
Reference: [69] <author> L. E. Moser, P. M. Melliar-Smith, and V. Agrawala. </author> <title> Necessary and sufficient conditions for broadcast consensus protocols. </title> <journal> Journal of Distributed Computing, </journal> <volume> 7(2) </volume> <pages> 12-27, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: However, as with all token schemes, the algorithm is not fully distributed and the system has to reconfigure when the token is lost. From a theoretical standpoint, the requirements for distributed agreement in a broadcast domain are given by Moser, Melliar-Smith and Agrawala <ref> [69] </ref>. They proved that a necessary and sufficient condition for the existence of a deterministic consensus protocol is delivery of each broadcast message to at least d (n + k + 1)=2e process in an n-process system subject to k crash failures. <p> We believe that our protocols are very close to the maximum level of concurrency achievable. However with clever optimizations, it might be possible to develop algorithms that provide a higher level of concurrency. Although some theoretical work exist on broadcast consensus protocols <ref> [69, 73] </ref>, we do not have a characterization of an optimal algorithm. 2. The above remark is especially true for the semantic ordering protocol: sites can relax a total order if their sequence of operations invocations is equivalent to the one defined by the total order.
Reference: [70] <author> Y. Moses, D. Dolev, and J. H. Halpern. </author> <title> Cheating husbands and other stories: A case study of knowledge, action, and communication (preliminary version). </title> <booktitle> In Proceedings of the Fourth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 215-223, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: This (small) digression is based on the premise that not just one, but several approaches are possible to solve problems in distributed computing. Current formalisms promote reasoning about events (Lam-port [56, 21]), states (Chandy and Misra [22]), or knowledge (Halpern <ref> [70] </ref>). However, we have shown that recent results in social choice theory (Moulin [72, 71]) can also prove to be useful, as they provide a better understanding about voting procedures.
Reference: [71] <author> Herve Moulin. </author> <title> Fairness and strategy in voting. </title> <booktitle> In Proceedings of the 33th Symposia in Applied Mathematics on Fair Allocation, </booktitle> <address> Cambridge, MA, 1985. </address> <publisher> American Mathematical Society. </publisher>
Reference-contexts: Current formalisms promote reasoning about events (Lam-port [56, 21]), states (Chandy and Misra [22]), or knowledge (Halpern [70]). However, we have shown that recent results in social choice theory (Moulin <ref> [72, 71] </ref>) can also prove to be useful, as they provide a better understanding about voting procedures. Similarly, advances in game theory (Conway [27]) might also be adequate for distributed applications where decisions are made in a non-cooperative (competitive) manner, for the allocation of resources for example.
Reference: [72] <author> Herve Moulin. </author> <title> Axioms of Cooperative Decision Making. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year>
Reference-contexts: Current formalisms promote reasoning about events (Lam-port [56, 21]), states (Chandy and Misra [22]), or knowledge (Halpern [70]). However, we have shown that recent results in social choice theory (Moulin <ref> [72, 71] </ref>) can also prove to be useful, as they provide a better understanding about voting procedures. Similarly, advances in game theory (Conway [27]) might also be adequate for distributed applications where decisions are made in a non-cooperative (competitive) manner, for the allocation of resources for example.
Reference: [73] <author> Sape Mullender. </author> <title> Distributed Systems. </title> <publisher> ACM, </publisher> <address> New York, </address> <year> 1993. </year> <month> 57 </month>
Reference-contexts: If a failure is reported to any processes, all processes see the same event. Between two configuration changes, all working processes receive the same set of messages. Also, if the network partitions, only one partition is allowed to make progress. The state machine approach <ref> [83, 73] </ref> is a general method for implementing a fault-tolerant service by replicating servers and coordinating clients interactions with server replica. A state machine is a program that cyclically reads input from its sensors, performs a deterministic computation based on this data, and writes output to an external activator. <p> The idea of regenerating replica has also been employed by Pu, Noe and Proudfoot [78] to restore the level of replication when the system recovers, provided that at least one copy has survived. In the primary copy method <ref> [74, 73] </ref>, one replica is designated as master and the others as backups or slaves. The master sites orders the sequence of operations and propagates these updates to all sites. As all updates have to go through the master, the primary site may exhibit performance bottlenecks. <p> We believe that our protocols are very close to the maximum level of concurrency achievable. However with clever optimizations, it might be possible to develop algorithms that provide a higher level of concurrency. Although some theoretical work exist on broadcast consensus protocols <ref> [69, 73] </ref>, we do not have a characterization of an optimal algorithm. 2. The above remark is especially true for the semantic ordering protocol: sites can relax a total order if their sequence of operations invocations is equivalent to the one defined by the total order.
Reference: [74] <author> B. M. Oki and B. Liskov. </author> <title> Viewstamped replication: A general primary copy method to support highly--available distributed systems. </title> <booktitle> In Proceedings of the 7th ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <address> Toronto, Ontario, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: The idea of regenerating replica has also been employed by Pu, Noe and Proudfoot [78] to restore the level of replication when the system recovers, provided that at least one copy has survived. In the primary copy method <ref> [74, 73] </ref>, one replica is designated as master and the others as backups or slaves. The master sites orders the sequence of operations and propagates these updates to all sites. As all updates have to go through the master, the primary site may exhibit performance bottlenecks.
Reference: [75] <author> J.-F. Paris. </author> <title> Voting with witnesses: A consistency scheme for replicated files. </title> <booktitle> In Proceedings of the 6th International Conference on Distributed Computing Systems, </booktitle> <pages> page 36, </pages> <address> Cambridge, MA, 1986. </address> <publisher> IEEE Computer Society, </publisher> <address> Washington, DC. </address>
Reference-contexts: In this method, query transactions can read any single site, while update transactions must write at all sites that are up. To guarantee correctness, each transaction must perform two additional steps called missing writes and access validation. Voting with witnesses, proposed by Paris <ref> [75, 76] </ref>, is an interesting idea that can be applied to all of the vote reassignment algorithms. Certain sites are witnesses; they have full voting rights but do not maintain a physical copy of the replica, only its last version number.
Reference: [76] <author> J.-F. Paris and D. E. </author> <title> Long. Efficient dynamic voting algorithms. </title> <booktitle> In Proceedings of the IEEE International Conference on Data Engineering, </booktitle> <pages> page 268, </pages> <address> Los Angeles, CA, </address> <month> February </month> <year> 1988. </year>
Reference-contexts: In this method, query transactions can read any single site, while update transactions must write at all sites that are up. To guarantee correctness, each transaction must perform two additional steps called missing writes and access validation. Voting with witnesses, proposed by Paris <ref> [75, 76] </ref>, is an interesting idea that can be applied to all of the vote reassignment algorithms. Certain sites are witnesses; they have full voting rights but do not maintain a physical copy of the replica, only its last version number.
Reference: [77] <author> L. L. Peterson, N. C. Buchholz, and R. D. Schlichting. </author> <title> Preserving and using context information in interprocess communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(3) </volume> <pages> 217-246, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: This set-order message causes all other receivers to sort their local buffers and deliver the messages from the top of the queue. A reimplementation of Isis, called Horus [79], achieves very high performance by using IP-multicast and packing multiple messages in a single network packet. Psync <ref> [77] </ref> is a multicast facility based on causal messages. The primitive is implemented using a single message, but group members wait before delivering it. At most, one message from each member must be received before the total order can be established.
Reference: [78] <author> C. Pu, J. D. Noe, and A. Proudfoot. </author> <title> Regeneration of replicated objects: a technique and its eden implementation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(7) </volume> <pages> 936-945, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Spasojevic and Berman [84] designed an algorithm for computing optimal static pessimistic vote assignments when relative frequencies of read and write operations are known. The idea of regenerating replica has also been employed by Pu, Noe and Proudfoot <ref> [78] </ref> to restore the level of replication when the system recovers, provided that at least one copy has survived. In the primary copy method [74, 73], one replica is designated as master and the others as backups or slaves.
Reference: [79] <author> R. Van Renesse, K. Birman, R. Cooper, B. Glade, and P. Stephenson. </author> <title> Reliable multicast between micro-kernels. </title> <booktitle> In USENIX Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 269-284, </pages> <address> Seattle, WA, April 27-28 1992. </address> <publisher> USENIX. </publisher>
Reference-contexts: This set-order message causes all other receivers to sort their local buffers and deliver the messages from the top of the queue. A reimplementation of Isis, called Horus <ref> [79] </ref>, achieves very high performance by using IP-multicast and packing multiple messages in a single network packet. Psync [77] is a multicast facility based on causal messages. The primitive is implemented using a single message, but group members wait before delivering it.
Reference: [80] <author> R. Van Renesse and A. S. Tanenbaum. </author> <title> Voting with ghosts. </title> <booktitle> In The 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 456-462. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: Such inexpensive entities can enhance the performance of the protocol as they attest to the state of the replicated data object. Van Renesse and Tanenbaum presented a similar scheme, voting with ghosts <ref> [80] </ref>, in which some sites do not even keep the state of the replica. These ghosts are used to to detect that a copy is unavailable due to a node crash, not due to a network partition.
Reference: [81] <author> A. Ricciardi. </author> <title> The group membership problem in asynchronous distributed systems. </title> <note> submitted for publication, </note> <year> 1994. </year>
Reference-contexts: The role of the membership service is to provide the illusion of a fail-stop environment via membership changes given by a single, non-faulty process <ref> [81] </ref>. If the network partitions, it needs to track a primary partition which is the only partition where progress is allowed. Members of the primary partitions take actions on behalf of the system as a whole. <p> We give below a summary of definitions to solve the membership problem. A formal and extended version of the problem statement appears in <ref> [81] </ref>. Definition 6 Given a consistent cut c of the system, as defined by Chandy and Lamport in [21], a set S of processes are in membership consent on c if all working processes of S have identical local views of the group.
Reference: [82] <author> K. Salem and H. Garcia-Molina. </author> <title> System M: A transaction procressing testbed for memory resident data. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 161-172, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: The holder of the token is given the privilege of updating the replica and propagating updates. When the token is lost, the system has to reconfigure to regenerate it. The primary copy method has been used in high available file systems [58] or main-memory databases <ref> [82] </ref>. Another tactic to enhance availability is to use system semantics, or application dependent information. Probabilistic algorithms and lazy-replication are two examples of this approach. Probabilistic algorithms were proposed for applications with weaker consistency requirements. If copies are allowed to diverge temporarily, diffusion techniques become applicable.
Reference: [83] <author> F. B. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(3):299, </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: If a failure is reported to any processes, all processes see the same event. Between two configuration changes, all working processes receive the same set of messages. Also, if the network partitions, only one partition is allowed to make progress. The state machine approach <ref> [83, 73] </ref> is a general method for implementing a fault-tolerant service by replicating servers and coordinating clients interactions with server replica. A state machine is a program that cyclically reads input from its sensors, performs a deterministic computation based on this data, and writes output to an external activator. <p> As a result, future platforms will easily sustain the workload of most database applications, and popular systems will be required to offer non-stop (7x24) operations, that is, to be available and fault-tolerant. Services can be made fault-tolerant by using replication. One approach, based on state machines <ref> [83] </ref>, ensures that every update is propagated to all sites, and that all sites process updates in unique order. This can be achieved using a reliable and totally ordered communication primitive. Our protocols implement such primitive, and provide a consistent order for operation processing on replicated objects.
Reference: [84] <author> M. Spasojevic and P. Berman. </author> <title> Voting as the optimal static pessimistic scheme for managing replicated data. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 5(1) </volume> <pages> 64-73, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Ahamad and Ammar [4, 25] evaluated the performance of quorum based protocols when data becomes unavailable. Barbara and Garcia-Molina [9, 10] studied the vulnerability of voting assignment in the presence of failures. Kumar and Segev [54] proposed heuristics to minimize communication costs under availability constraints. Spasojevic and Berman <ref> [84] </ref> designed an algorithm for computing optimal static pessimistic vote assignments when relative frequencies of read and write operations are known.
Reference: [85] <author> M. Stonebraker. </author> <title> Readings in Database Systems, 2nd ed. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: The data items are individually read and written by the operations of programs called transactions. Consistency is supported by making the transactions atomic. Atomic transaction are characterized informally by two properties: serializability and recoverabil-ity <ref> [85] </ref>. Serializability means that the concurrent executions of a group of transactions is equivalent to some serial execution of the same transactions. Recoverability means that each transaction appears all-or-nothing. <p> In some situations, the synchronization constraints are reduced by 20%. 13 Surprisingly, most of the research results in voting theory have been gathered during the past fifty years. 14 Consider a 200,00$ platform of 1995, as planned by Dec, Intel, Hp or Sun. In <ref> [85] </ref>, it is suggested that one of them is likely to offer a four way shared memory multiprocessor with 700 MIPS, 1 GBytes of main memory and a disk array (RAID) of 500 GBytes. Under these assumptions, such configuration is capable of performing about 3,500 TP1 benchmarks per second.
Reference: [86] <author> Philip D. Straffin. </author> <title> Topics in the Theory of Voting. </title> <publisher> Birkhauser, </publisher> <address> Boston, </address> <year> 1980. </year>
Reference-contexts: We also review fundamentals results of the theory of voting. Indeed, an impressive body of mathematical results have been gathered in the past few decades in the theory of social choice, and are important for the design of decision making procedures <ref> [86, 18] </ref>. Voting has many applications for computer science: it can be used for the allocation of resources, or like in distributed systems, to ensure that only one group of processes is allowed to perform some restricted operations.
Reference: [87] <author> R. H. Thomas. </author> <title> A majority consensus approach to concurrency control for multiple copy databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(2) </volume> <pages> 180-209, </pages> <month> June </month> <year> 1979. </year>
Reference-contexts: Popular techniques for providing high availability are based on voting or primary copy [33]. Thomas proposed majority voting <ref> [87] </ref>, extended by Gifford for quorum consensus protocols [46]. Each site is assigned a vote and, in order to perform a read (write) operation, a number of votes, or quorum, need to be acquired.
Reference: [88] <author> W. E. Weihl. </author> <title> Commutativity-based concurrency control for abstract data types. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(12) </volume> <pages> 1488-1505, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Semantic based ordering for replicated abstract data types. The total ordering can be relaxed by using the commutativity property of operations. We used Weihl's notion of forward commutativity <ref> [88] </ref> to better exploit concurrency. It is a local dynamic property that ensures the serializability of transactions. 3 Some families of protocols supports weaker delivery semantics. <p> Objects that provide appropriate synchronization and recovery are called atomic objects, and are accessible only through a set of primitive operations. Weihl presented such concurrency control algorithms for abstract data types <ref> [88, 89, 91] </ref>. The algorithms ensure the serializability of transactions by using conflict relations based on the commutativity of operations (if certain operations of a type commute, less synchronization is required to maintain correctness).
Reference: [89] <author> W. E. Weihl. </author> <title> The impact of recovery on concurrency control. </title> <booktitle> In Proceedings of the 8th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 259-269. </pages> <publisher> ACM Press , Philadelphia, </publisher> <address> PA, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: Objects that provide appropriate synchronization and recovery are called atomic objects, and are accessible only through a set of primitive operations. Weihl presented such concurrency control algorithms for abstract data types <ref> [88, 89, 91] </ref>. The algorithms ensure the serializability of transactions by using conflict relations based on the commutativity of operations (if certain operations of a type commute, less synchronization is required to maintain correctness).
Reference: [90] <author> W. E. Weihl. </author> <title> Local atomicity properties: Modular concurrency control for abstract data types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(2) </volume> <pages> 249-282, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: The algorithms ensure a local atomicity property called dynamic atomicity 7 , which means that if every object in a system is dynamic atomic, transactions will be atomic <ref> [90] </ref>. The algorithms are based on a simple intuition: two operations conflict if they do not commute. For reads and writes, two operations conflict if one of them is a write. For abstract data types, the commutativity definitions are somewhat more subtle. <p> In other words, the level of synchronization should be lower than what is required with an early delivery scheme like the one presented in previous sections. This is the goal of our semantic based multicast primitive. Weihl showed <ref> [90] </ref> also that concurrency can be increased for abstract data types when the notion of commutativity depends on the state of the data. Informally, two operations commute if they can be done in either order and produce the same result. <p> If i commutes forward with j for all i and j, 1 i &lt; j n, then ff 1 2 : : : n is legal and ff i 1 i 2 : : : i n ff 1 2 : : : n . Proof: in <ref> [90] </ref>. 2 The idea with our semantic ordering protocol is to allow different schedules of operations as long as they are equivalent to an agreed linear sequence of operations. Equivalence is specified with respect to the forward commutativity relation. <p> In other words, it is always advantageous to use the semantic ordering protocol for replicated abstract data types. * Furthermore, we used a notion of commutativity, termed forward commutativity, that depends on the state of objects. It was proposed by Weihl in <ref> [90] </ref> to reduce the constraints imposed by concurrency control protocols. He describes also a protocol to implement atomic actions with this type of com-mutativity. If concurrency control is based forward commutativity, then a deferred update recovery strategy (no-undo/redo) is required.
Reference: [91] <author> W. E. Weihl. </author> <title> Linguistic support for atomic data types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(2) </volume> <pages> 178-202, </pages> <month> April </month> <year> 1990. </year> <month> 58 </month>
Reference-contexts: Objects that provide appropriate synchronization and recovery are called atomic objects, and are accessible only through a set of primitive operations. Weihl presented such concurrency control algorithms for abstract data types <ref> [88, 89, 91] </ref>. The algorithms ensure the serializability of transactions by using conflict relations based on the commutativity of operations (if certain operations of a type commute, less synchronization is required to maintain correctness).
References-found: 91

