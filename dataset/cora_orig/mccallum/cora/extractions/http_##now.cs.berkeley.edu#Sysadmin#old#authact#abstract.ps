URL: http://now.cs.berkeley.edu/Sysadmin/old/authact/abstract.ps
Refering-URL: http://now.cs.berkeley.edu/Sysadmin/old/authact/
Root-URL: http://www.cs.berkeley.edu
Title: Authenticated Actions cryptographic authentication, Allow fine-grained, exible access control, Allow delegation without requiring updates to
Author: Eric Anderson and Dave Patterson, 
Address: Berkeley  
Affiliation: U.C.  
Date: May 17, 1996 1  
Note: Authenticated Actions  Submitted for publication in the Tenth System Administration Conference (LISA 96)  1.0 Introduction Use  2.0 Overview of Implementation Choices  
Abstract: Authenticated actions provides fine grained remote function execution in a distributed system that crosses organizational boundaries and includes mobile hosts. Two principals can mutually authenticate even if they are disconnected from the rest of the system. Authenticated actions provides an excellent infrastructure for developing secure system administration tools. We are developing a single infrastructure to support users performing and delegating restricted actions in a system that includes mobile machines and crosses organizational boundaries. Given this infrastructure, we plan to use it for secure remote execution allowing us to give external users access to our machines, updating and keeping software consistent between disconnected machines, gathering statistics and executing tests on our machines, and allowing users to make restricted updates to system files. To achieve these goals, our infrastructure will need to: The remainder of our paper will explain our implementation choices and our proposed implementation. We have built a simple prototype of the system described in this paper. However we are still waiting to get permission to use internal parts of the RSAREF library[RSA93], and so expect to rewrite our system to use the Crypto++ library[Dai95] to enable distribution. This paper describes the revised system. which we expect to have working before the final paper deadline. Our first requirement is remote execution, which is provided by rsh [rsh], lsrun [Plat95], or glu-run [Glun95]. Unfortunately, these systems are insecure. Kerberized rsh [Kerb4], Sysctl [DeS93], Exu [Ramm95], improve security by using Kerberos authentication for remote execution. Sysctl, and Exu in addition execute procedures instead of a shell, increasing exibil-ity. However, these solutions do not easily work across organizational boundaries because some sites dont run Kerberos or are unwilling to share secret keys. Furthermore, portables would not be able to mutually authenticate when they are disconnected. Given the need for security, and these problems with secret key systems like Kerberos, we are using RSA public key cryptography [Riv78]. Very fine-grained, exible access control requires procedural access control, which means we need run-time function evaluation (eval). We could implement our own language, or compile C programs on the y and execute them, but using a language like Perl[Wall96], Tcl[Oust90], or Scheme[Clin91] which already supports eval is a better solution. We chose Perl because of its portability and its support for structured types, restricted evaluation, and dynamic loading. To eliminate the need to keep access control lists (ACL) on the servers or in the procedures that perform access control, we use public key cryptography to build capabilities. A capability is an unforgeable ticket that can be used to access a resource. Normally, capabilities can be freely transferred, but we limit transfers by putting the users public key in the capability, and forcing them to create a transfer slip to give away a capability. Finally, to support portables, we use queued messages which are similar to the queued remote procedure calls (RPCs) found in the Rover [Jos95] toolkit. Queued messages allow message delivery to be delayed while a host is down. We support authentication in our messages so that message are only readable by the recipient, and the recipient can verify the sender. We also allow messages to be transferred by writing and reading them from 
Abstract-found: 1
Intro-found: 0
Reference: [Clin91] <editor> Revised 4 Report on the Algorithmic Language Scheme. William Clinger and Jonathan Rees (Editors), et. </editor> <address> al. </address> <note> Available as ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/standards/r4rs.ps.gz </note>
Reference-contexts: Very fine-grained, exible access control requires procedural access control, which means we need run-time function evaluation (eval). We could implement our own language, or compile C programs on the y and execute them, but using a language like Perl [Wall96], Tcl [Oust90], or Scheme <ref> [Clin91] </ref> which already supports eval is a better solution. We chose Perl because of its portability and its support for structured types, restricted evaluation, and dynamic loading.
Reference: [Dai95] <author> Crypto++: </author> <title> A C++ Class Library of Cryptographic Primitives, </title> <note> Version 1.1 10/27/1995 Wei Dai. Available from ftp://ftp.funet.fi/pub/crypt/cryptography/ libs/crypto11.zip </note>
Reference-contexts: We have built a simple prototype of the system described in this paper. However we are still waiting to get permission to use internal parts of the RSAREF library [RSA93], and so expect to rewrite our system to use the Crypto++ library <ref> [Dai95] </ref> to enable distribution. This paper describes the revised system. which we expect to have working before the final paper deadline. 2.0 Overview of Implementation Choices Our first requirement is remote execution, which is provided by rsh [rsh], lsrun [Plat95], or glu-run [Glun95]. Unfortunately, these systems are insecure.
Reference: [DeS93] <author> Sysctl: </author> <title> A Distributed System Control Package Salvatore DeSimone and Christine Lombardi. </title> <booktitle> Proceedings of the 7th USENIX Systems Administration (LISA VII) Conference. </booktitle>
Reference-contexts: This paper describes the revised system. which we expect to have working before the final paper deadline. 2.0 Overview of Implementation Choices Our first requirement is remote execution, which is provided by rsh [rsh], lsrun [Plat95], or glu-run [Glun95]. Unfortunately, these systems are insecure. Kerberized rsh [Kerb4], Sysctl <ref> [DeS93] </ref>, Exu [Ramm95], improve security by using Kerberos authentication for remote execution. Sysctl, and Exu in addition execute procedures instead of a shell, increasing exibil-ity. However, these solutions do not easily work across organizational boundaries because some sites dont run Kerberos or are unwilling to share secret keys.
Reference: [Jos95] <author> Rover: </author> <title> A Toolkit for Mobile Information Access. A.D. </title> <editor> Joseph, A.F. deLespinasse, J.A. Tauber, D.K. Gifford, M.F. Kaashoek. </editor> <booktitle> Proceedings of the 15th ACM Symposium on Operating Systems Principles. </booktitle>
Reference-contexts: Finally, to support portables, we use queued messages which are similar to the queued remote procedure calls (RPCs) found in the Rover <ref> [Jos95] </ref> toolkit. Queued messages allow message delivery to be delayed while a host is down. We support authentication in our messages so that message are only readable by the recipient, and the recipient can verify the sender.
Reference: [Kerb4] <author> Kerberized rsh, </author> <title> part of the Kerberos IV distribution available from ftp://athena-dist.mit.edu/pub/ATH-ENA/kerberos [Glun95] glurun - run a program remotely using GLUnix Part of the GLUnix development at U.C. </title> <journal> Ber-keley. </journal> <note> See http://now.cs.berkeley.edu/man/html1/glu-run.html </note>
Reference-contexts: This paper describes the revised system. which we expect to have working before the final paper deadline. 2.0 Overview of Implementation Choices Our first requirement is remote execution, which is provided by rsh [rsh], lsrun [Plat95], or glu-run [Glun95]. Unfortunately, these systems are insecure. Kerberized rsh <ref> [Kerb4] </ref>, Sysctl [DeS93], Exu [Ramm95], improve security by using Kerberos authentication for remote execution. Sysctl, and Exu in addition execute procedures instead of a shell, increasing exibil-ity. However, these solutions do not easily work across organizational boundaries because some sites dont run Kerberos or are unwilling to share secret keys.
Reference: [Lai91] <institution> Detailed Description and a Software Implementation of the IPES Cipher Xuejia Lai. Institute for Signal and Information Processing, ETH-Zentrum, </institution> <address> Zurich, Switzerland. </address>
Reference-contexts: The private data is split into three parts as shown in the private header in an effort to take advantage of the extra space present in public key encrypted blocks. All encryption is in CBC mode, and encrypted data is padded to IDEAs <ref> [Lai91] </ref> 16 byte blocks. It is easy to strip the padding off since the length of each part is known. The version value for this format using RSA, MD5 and IDEA is 1.
Reference: [Oust90] <author> Tcl: </author> <title> An Embeddable Command Language, </title> <editor> John Ousterhout. </editor> <booktitle> Proceedings of the 1990 Winter USENIX Technical Conference. Available from ftp:// </booktitle> <editor> ftp.smli.com/pub/tcl/ [Plat95] lsrun: </editor> <title> run an application on the best remote host transparently. Part of the Load Sharing Facility toolkit available from Platform Computing. </title> <note> See http:// www.platform.com/products/demo.html </note>
Reference-contexts: Very fine-grained, exible access control requires procedural access control, which means we need run-time function evaluation (eval). We could implement our own language, or compile C programs on the y and execute them, but using a language like Perl [Wall96], Tcl <ref> [Oust90] </ref>, or Scheme [Clin91] which already supports eval is a better solution. We chose Perl because of its portability and its support for structured types, restricted evaluation, and dynamic loading.
Reference: [Ramm95] <editor> Exu A System for Secure Delegation of Authority on an Insecure Network Karl Ramm and Michael Grubb. </editor> <booktitle> Proceedings of the 9th USENIX Systems Administration (LISA 95) Conference. </booktitle>
Reference-contexts: Unfortunately, these systems are insecure. Kerberized rsh [Kerb4], Sysctl [DeS93], Exu <ref> [Ramm95] </ref>, improve security by using Kerberos authentication for remote execution. Sysctl, and Exu in addition execute procedures instead of a shell, increasing exibil-ity. However, these solutions do not easily work across organizational boundaries because some sites dont run Kerberos or are unwilling to share secret keys.
Reference: [Riv78] <editor> A Method for Obtaining Digital Signatures and Public-Key Cryptosystems R. L. Rivest, A. Shamir, and L. </editor> <booktitle> Adleman Communications of the ACM, February 1978, </booktitle> <volume> Volume 21, Number 2 </volume>
Reference-contexts: Furthermore, portables would not be able to mutually authenticate when they are disconnected. Given the need for security, and these problems with secret key systems like Kerberos, we are using RSA public key cryptography <ref> [Riv78] </ref>. Very fine-grained, exible access control requires procedural access control, which means we need run-time function evaluation (eval).
Reference: [Riv92] <institution> The MD5 Message-Digest Algorithm R. </institution> <note> Rivest. Available as RFC 1321 from http://www.inter-nic.net/ds/dspg1intdoc.html </note>
Reference-contexts: Using D, we can build a digital signature of a message M by calculating Sig = D (M). Everyone can verify the sender of the message by computing E (Sig) = M. Public key cryptography is computationally expensive, so an easier-to-compute cryptographic hash such as MD5 <ref> [Riv92] </ref> of M is computed, which is signed by encrypting it with D. Digital signatures are also useful for associating principals users and servers with their public keys.
Reference: [RSA93] <author> RSAREF(TM): </author> <title> A Cryptographic Toolkit for Privacy-Enhanced Mail version 1 RSA Laboratories, a division of RSA Data Security, </title> <institution> Inc. </institution> <note> Available as part of the PGP distribution from http://www.ifi.uio.no/ ~staalesc/PGP/ </note>
Reference-contexts: The remainder of our paper will explain our implementation choices and our proposed implementation. We have built a simple prototype of the system described in this paper. However we are still waiting to get permission to use internal parts of the RSAREF library <ref> [RSA93] </ref>, and so expect to rewrite our system to use the Crypto++ library [Dai95] to enable distribution.
Reference: [rsh] <author> Remote Shell. </author> <title> Originally part of the BSD4.2 distribution, now in most UNIX implementations. </title> <journal> Try man rsh </journal>
Reference-contexts: This paper describes the revised system. which we expect to have working before the final paper deadline. 2.0 Overview of Implementation Choices Our first requirement is remote execution, which is provided by rsh <ref> [rsh] </ref>, lsrun [Plat95], or glu-run [Glun95]. Unfortunately, these systems are insecure. Kerberized rsh [Kerb4], Sysctl [DeS93], Exu [Ramm95], improve security by using Kerberos authentication for remote execution. Sysctl, and Exu in addition execute procedures instead of a shell, increasing exibil-ity.
Reference: [Wall96] <author> Perl 5: </author> <title> Practical Extraction and Report Language Larry Wall, </title> <note> et. al. Available from ftp:// ftp.funet.fi/pub/languages/perl/CPAN/ </note>
Reference-contexts: Very fine-grained, exible access control requires procedural access control, which means we need run-time function evaluation (eval). We could implement our own language, or compile C programs on the y and execute them, but using a language like Perl <ref> [Wall96] </ref>, Tcl [Oust90], or Scheme [Clin91] which already supports eval is a better solution. We chose Perl because of its portability and its support for structured types, restricted evaluation, and dynamic loading.
Reference: [Zim94] <author> Pretty Good Privacy(PGP): </author> <title> Users Guide Volume I: Essential Topics Philip Zimmermann, </title> <note> et. al. Available from http://www.ifi.uio.no/~staalesc/PGP </note>
Reference-contexts: In addition, P can just keep the certificate D A (E,P) and provide it to people on demand to verify Ps identity. This idea naturally extends to having more than one signing authority and in the limit to something like PGPs <ref> [Zim94] </ref> web of trust. We use Perl objects for public and private keys. These objects support the Encrypt and Decrypt methods in addition to methods that return machine independent representations of the object. 3.2 Safe Perl SafePerl provides compartments for evaluating arbitrary Perl expressions in a restricted environment.
References-found: 14

