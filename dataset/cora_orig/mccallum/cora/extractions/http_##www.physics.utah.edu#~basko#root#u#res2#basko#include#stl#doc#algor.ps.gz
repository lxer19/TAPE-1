URL: http://www.physics.utah.edu/~basko/root/u/res2/basko/include/stl/doc/algor.ps.gz
Refering-URL: 
Root-URL: 
Title: Algorithm-Oriented Generic Libraries  
Author: David R. Musser Alexander A. Stepanov 
Note: Hewlett-Packard Laboratories, Parallel Algorithms Program, 1501 Page  
Address: Troy, New York 12180  Mill Road, Palo Alto, California 94303  
Affiliation: Rensselaer Polytechnic Institute, Computer Science Department,  
Date: September 1993  
Abstract: We outline an approach to construction of software libraries in which generic algorithms (algorithmic abstractions) play a more central role than in conventional software library technology or in the object-oriented programming paradigm. Our approach is to consider algorithms first, decide what types and access operations they need for efficient execution, and regard the types and operations as formal parameters that can be instantiated in many different ways, as long as the actual parameters satisfy the assumptions on which the correctness and efficiency of the algorithms are based. The means by which instantiation is carried out is language dependent; in the C++ examples in this paper, we instantiate generic algorithms by constructing classes that define the needed types and access operations. By use of such compile time techniques and careful attention to algorithmic issues, it is possible to construct software components of broad utility with no sacrifice of efficiency. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Booch, </author> <title> Software Components with Ada, </title> <address> Benjamin/Cummings, </address> <year> 1987. </year>
Reference-contexts: Parameterization is done using compile time mechanisms such as generics or templates (e.g., Booch's Ada and C++ libraries <ref> [1, 2] </ref>) or preprocessing mechanisms (e.g., Lea's GNU C++ library [6]), achieving greater run-time efficiency than was possible with older methods (for example, passing at run-time the size of data elements and a comparison function to C library routines such as qsort or bsearch).
Reference: [2] <author> G. Booch and M. Vilot, </author> <title> "The Design of the C++ Booch Components," </title> <journal> Proc. OOPSLA/ECOOP '90, SIGPLAN Notices, </journal> <volume> Vol. 25, No. 10, </volume> <month> October </month> <year> 1990. </year>
Reference-contexts: Parameterization is done using compile time mechanisms such as generics or templates (e.g., Booch's Ada and C++ libraries <ref> [1, 2] </ref>) or preprocessing mechanisms (e.g., Lea's GNU C++ library [6]), achieving greater run-time efficiency than was possible with older methods (for example, passing at run-time the size of data elements and a comparison function to C library routines such as qsort or bsearch).
Reference: [3] <author> T. H. Cormen, C. E. Leiserson, R. L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: It is used in implementing quickSort (as is insertionSort) and other components. 4 Concrete versions of these algorithms may be found in standard references, e.g., <ref> [3, 5] </ref>, and the research literature, e.g., [11]. In constructing generic algorithms, one can often benefit from this prior work, but one must be careful to ensure that optimizations can still be done in a general setting and, if so, that they remain optimizations in most, if not all, settings.
Reference: [4] <author> M. Ellis and B. Stroustrup, </author> <title> The Annotated C++ Reference Manual, </title> <publisher> Addison Wesley, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Since C++ allows different definitions to be given for either prefix or postfix applications of these operators <ref> [4] </ref>, we define the requirements on both: 1. <p> to examine this layer first, then progress to the more general descriptions. 27 While we have opted for run-time efficiency by using strictly compile time mechanisms for instantiating parameters, one could instead emphasize run-time flexibility and reduction of code size by defining some of the access operations as virtual functions <ref> [4, p. 208] </ref> that are implemented in derived classes. Such a choice fits within our framework because it does not require any textual changes to the source code of the algorithms, only to the container classes.
Reference: [5] <author> D. E. Knuth, </author> <title> The Art of Computer Programming, Volume 3: Sorting and Search ing, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1973. </year>
Reference-contexts: It is used in implementing quickSort (as is insertionSort) and other components. 4 Concrete versions of these algorithms may be found in standard references, e.g., <ref> [3, 5] </ref>, and the research literature, e.g., [11]. In constructing generic algorithms, one can often benefit from this prior work, but one must be careful to ensure that optimizations can still be done in a general setting and, if so, that they remain optimizations in most, if not all, settings.
Reference: [6] <author> D. Lea, </author> <title> The GNU C++ Library, software and documentation, The Free Software Foundation, </title> <address> 675 Mass Ave, Cambridge, MA, </address> <month> Feb </month> <year> 1988. </year>
Reference-contexts: Parameterization is done using compile time mechanisms such as generics or templates (e.g., Booch's Ada and C++ libraries [1, 2]) or preprocessing mechanisms (e.g., Lea's GNU C++ library <ref> [6] </ref>), achieving greater run-time efficiency than was possible with older methods (for example, passing at run-time the size of data elements and a comparison function to C library routines such as qsort or bsearch).
Reference: [7] <author> D. R. Musser and A. A. Stepanov, </author> <title> "A Library of Generic Algorithms in Ada," </title> <booktitle> Proc. of 1987 ACM SIGAda International Conference, </booktitle> <address> Boston, </address> <month> December, </month> <year> 1987. </year>
Reference-contexts: design of the algorithms and their recommended uses, and because the container representations and algorithms can be combined without the overhead of subprogram calls (by using inline declarations and templates and/or macros). 1.2 The algorithm-oriented approach in C++ We demonstrated an earlier version of the algorithm-oriented approach in Ada in <ref> [7, 8, 9] </ref>. In this paper, we illustrate the approach with a number of generic algorithms implemented in C++. These algorithms are part of a library of operations on sequences of values, using array, linked-list, or hybrid array/linked representations of sequences, including partitioning, merging, and sorting operations.
Reference: [8] <author> D. R. Musser and A. A. Stepanov, </author> <title> "Generic Programming," invited paper, </title> <editor> in P. Gianni, Ed., </editor> <booktitle> ISSAC '88 Symbolic and Algebraic Computation Proceedings, Lecture Notes in Computer Science 358, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: design of the algorithms and their recommended uses, and because the container representations and algorithms can be combined without the overhead of subprogram calls (by using inline declarations and templates and/or macros). 1.2 The algorithm-oriented approach in C++ We demonstrated an earlier version of the algorithm-oriented approach in Ada in <ref> [7, 8, 9] </ref>. In this paper, we illustrate the approach with a number of generic algorithms implemented in C++. These algorithms are part of a library of operations on sequences of values, using array, linked-list, or hybrid array/linked representations of sequences, including partitioning, merging, and sorting operations.
Reference: [9] <author> D. R. Musser and A. A. Stepanov, </author> <title> The Ada Generic Library: Linear List Pro cessing Packages, </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <month> 28 </month>
Reference-contexts: design of the algorithms and their recommended uses, and because the container representations and algorithms can be combined without the overhead of subprogram calls (by using inline declarations and templates and/or macros). 1.2 The algorithm-oriented approach in C++ We demonstrated an earlier version of the algorithm-oriented approach in Ada in <ref> [7, 8, 9] </ref>. In this paper, we illustrate the approach with a number of generic algorithms implemented in C++. These algorithms are part of a library of operations on sequences of values, using array, linked-list, or hybrid array/linked representations of sequences, including partitioning, merging, and sorting operations.
Reference: [10] <author> D. R. Musser and A. A. Stepanov, </author> <title> Algorithm-Oriented Generic Software Library Development, </title> <institution> Rensselaer Polytechnic Institute Computer Science Department Technical Report 92-13, </institution> <month> April </month> <year> 1992. </year>
Reference: [11] <author> R. Sedgewick, </author> <title> "Implementing quicksort programs," </title> <journal> Communications of the ACM, </journal> <volume> 21(10) </volume> <pages> 847-857, </pages> <year> 1978. </year> <month> 29 </month>
Reference-contexts: It is used in implementing quickSort (as is insertionSort) and other components. 4 Concrete versions of these algorithms may be found in standard references, e.g., [3, 5], and the research literature, e.g., <ref> [11] </ref>. In constructing generic algorithms, one can often benefit from this prior work, but one must be careful to ensure that optimizations can still be done in a general setting and, if so, that they remain optimizations in most, if not all, settings.
References-found: 11

