URL: http://www.cs.ucsb.edu/~kienle/osuif.ps
Refering-URL: http://www.cs.ucsb.edu/~kienle/prj/prj.html
Root-URL: http://www.cs.ucsb.edu
Title: Introduction to the OSUIF Library  
Author: Holger Kienle and Urs Holzle 
Date: August 10, 1998  
Web: http://www.cs.ucsb.edu/~osuif  
Address: Santa Barbara, CA 93106  
Affiliation: Department of Computer Science University of California  
Abstract: Note: This paper does not necessarily reflect the precise implementation status of the current OSUIF release. 
Abstract-found: 1
Intro-found: 1
Reference: [AH95] <author> Ole Agesen and Urs Holzle. </author> <title> Type feedback vs. concrete type analysis: A comparison of optimization techniques for object-oriented languages. </title> <booktitle> OOPSLA '95, </booktitle> <pages> pages 91-107, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Thus, high-level information is lost that could have been used for code optimization (e.g., class hierarchy analysis [DGC95] [DMM96] or type inference [CU90] [PC94] <ref> [AH95] </ref>). OSUIF overcomes this problem by introducing a new, high-level IR constructs that model dynamic method calls, classes, class hierarchies, etc.
Reference: [Cha95] <author> David Chase. </author> <title> Implementation of exception handling | I. </title> <type> Unpublished, </type> <month> November </month> <year> 1995. </year>
Reference-contexts: Exception handling can be implemented with a number of different techniques. For instance, a portable albeit slow technique is based on the use of the C Library setjump () and longjump () functions [Rob89]. More efficient, PC-based techniques use in-code markers or PC range tables <ref> [Cha95] </ref>. In keeping with the design philosophy outlined before, OSUIF aims to provide a framework for expressing the essential and common behavior of exceptions. 9 Clients of OSUIF may use standard OSUIF lowering passes or implement their own passes that lower these constructs to OSUIF or SUIF. <p> Typically, a back end would use a more efficient scheme that preserves the control flow, but does not introduce exception handling code that is executed during "normal" control flow <ref> [Cha95] </ref> [Cha96]. 10 Enhanced Type System OSUIF provides type equivalence tests for (qualified) method types and method symbols with the binary method is equivalent ().
Reference: [Cha96] <author> David Chase. </author> <title> Implementation of exception handling | II. </title> <type> Unpublished, </type> <month> September </month> <year> 1996. </year>
Reference-contexts: Typically, a back end would use a more efficient scheme that preserves the control flow, but does not introduce exception handling code that is executed during "normal" control flow [Cha95] <ref> [Cha96] </ref>. 10 Enhanced Type System OSUIF provides type equivalence tests for (qualified) method types and method symbols with the binary method is equivalent ().
Reference: [CU90] <author> Craig Chambers and David Ungar. </author> <title> Iterative type analysis and extended message splitting: Optimizing dynamically-typed object-oriented languages. </title> <booktitle> PLDI '90, </booktitle> <pages> pages 150-164, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Thus, high-level information is lost that could have been used for code optimization (e.g., class hierarchy analysis [DGC95] [DMM96] or type inference <ref> [CU90] </ref> [PC94] [AH95]). OSUIF overcomes this problem by introducing a new, high-level IR constructs that model dynamic method calls, classes, class hierarchies, etc. <p> The set of real types (i.e., the types that a variable symbol actually holds during a program execution) is a subset of the set of potential types. OSUIF's type system is similar to the ones that have been designed for type inference in Vortex [DDG + 96], Self-90 <ref> [CU90] </ref>, and Typed Smalltalk [Joh96] [JGZ88]. 11 Lowering Passes Let's consider a SUIF pass that translates a high-level SUIF construct (e.g., switch or for statement) to a semantically equivalent sequence of low-level statements (or instructions). 13 This transformation is usually straightforward and does not allow a broad variety of different implementation
Reference: [DCI + 97] <author> A. Duncan, B. Cocosel, C. Iancu, H. Kienle, R. Rugina, U. Holzle, and M. Rinard. OSUIF: </author> <title> SUIF with objects. </title> <booktitle> Second SUIF Compiler Workshop, </booktitle> <pages> pages 1-7, </pages> <month> August </month> <year> 1997. </year> <title> 16 Work is in progress to simplify parts of the extensibility mechanism. </title> <type> 17 </type>
Reference-contexts: 16 List of Figures 1 OSUIF class hierarchy (generic classes omitted) . . . . . . . . . . 6 2 OSUIF class symbol table interface . . . . . . . . . . . . . . . . . 8 2 Object SUIF (OSUIF) <ref> [DCI + 97] </ref> 1 is an extension to SUIF 2.0 [KH97], which provides support for the representation of object-oriented languages.
Reference: [DDG + 96] <author> Jeffrey Dean, Greg DeFouw, David Grove, Vassily Litvinov, and Craig Chambers. </author> <title> Vortex: An optimizing compiler for object-oriented languages. </title> <booktitle> OOPSLA '96, </booktitle> <pages> pages 83-100, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: The set of real types (i.e., the types that a variable symbol actually holds during a program execution) is a subset of the set of potential types. OSUIF's type system is similar to the ones that have been designed for type inference in Vortex <ref> [DDG + 96] </ref>, Self-90 [CU90], and Typed Smalltalk [Joh96] [JGZ88]. 11 Lowering Passes Let's consider a SUIF pass that translates a high-level SUIF construct (e.g., switch or for statement) to a semantically equivalent sequence of low-level statements (or instructions). 13 This transformation is usually straightforward and does not allow a broad <p> None of these extensions are trivial to implement. 16 OSUIF and Vortex <ref> [DDG + 96] </ref> share the same goals. Both are systems for object-oriented compiler research. Both systems define an IR, which incorporates object-oriented constructs, and provide (generic) optimization passes. Vortex implements object-oriented and traditional optimizations, selective recompilation, and exceptions.
Reference: [DGC95] <author> Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Optimization of object-oriented programms using static class hierarchy analysis. </title> <booktitle> ECOOP '95, </booktitle> <pages> pages 77-101, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: For example, if one wants to express a dynamic method call in SUIF, a concrete implementation technique has to be chosen and implemented with the available SUIF instructions. Thus, high-level information is lost that could have been used for code optimization (e.g., class hierarchy analysis <ref> [DGC95] </ref> [DMM96] or type inference [CU90] [PC94] [AH95]). OSUIF overcomes this problem by introducing a new, high-level IR constructs that model dynamic method calls, classes, class hierarchies, etc.
Reference: [DHV95] <author> Karel Driesen, Urs Holzle, and Jan Vitek. </author> <title> Message dispatch on piplined processors. </title> <booktitle> ECOOP '95, </booktitle> <pages> pages 253-282, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: A compiler may have considerable latitude in how to implement it <ref> [DHV95] </ref>. For this reason, OSUIF provides an instruction to express message sends at a high level. <p> For example|without going into detail|the encoding of an OSUIF method call instruction in SUIF can be realized with various different implementation techniques, ranging from virtual function tables to polymorphic inline caches <ref> [DHV95] </ref>. Part of OSUIF are several lowering passes, which takes care of this problem.
Reference: [DMM96] <author> Amer Diwan, J. Eliot B. Moss, and Kathryn S. McKinley. </author> <title> Simple and effective analysis of statically-typed object-oriented programs. </title> <booktitle> OOPSLA '96, </booktitle> <pages> pages 292-305, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: For example, if one wants to express a dynamic method call in SUIF, a concrete implementation technique has to be chosen and implemented with the available SUIF instructions. Thus, high-level information is lost that could have been used for code optimization (e.g., class hierarchy analysis [DGC95] <ref> [DMM96] </ref> or type inference [CU90] [PC94] [AH95]). OSUIF overcomes this problem by introducing a new, high-level IR constructs that model dynamic method calls, classes, class hierarchies, etc.
Reference: [JGZ88] <author> Ralph E. Johnson, Justin O. Graver, and Lawrence W. Zurawski. </author> <title> TS: An optimizing compiler for Smalltalk. </title> <booktitle> OOPSLA '88, </booktitle> <pages> pages 18-26, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: OSUIF's type system is similar to the ones that have been designed for type inference in Vortex [DDG + 96], Self-90 [CU90], and Typed Smalltalk [Joh96] <ref> [JGZ88] </ref>. 11 Lowering Passes Let's consider a SUIF pass that translates a high-level SUIF construct (e.g., switch or for statement) to a semantically equivalent sequence of low-level statements (or instructions). 13 This transformation is usually straightforward and does not allow a broad variety of different implementation strategies.
Reference: [Joh96] <author> Raph E. Johnson. </author> <title> Type-checking Smalltalk. </title> <booktitle> OOPSLA '86, </booktitle> <pages> pages 315-321, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: OSUIF's type system is similar to the ones that have been designed for type inference in Vortex [DDG + 96], Self-90 [CU90], and Typed Smalltalk <ref> [Joh96] </ref> [JGZ88]. 11 Lowering Passes Let's consider a SUIF pass that translates a high-level SUIF construct (e.g., switch or for statement) to a semantically equivalent sequence of low-level statements (or instructions). 13 This transformation is usually straightforward and does not allow a broad variety of different implementation strategies.
Reference: [KH97] <author> Holger Kienle and Urs Holzle. </author> <title> Introduction to the SUIF 2.0 compiler system. </title> <type> Technical Report TRCS97-22, </type> <institution> Department of Computer Science, University of California Santa Barbara, </institution> <month> December </month> <year> 1997. </year>
Reference-contexts: omitted) . . . . . . . . . . 6 2 OSUIF class symbol table interface . . . . . . . . . . . . . . . . . 8 2 Object SUIF (OSUIF) [DCI + 97] 1 is an extension to SUIF 2.0 <ref> [KH97] </ref>, which provides support for the representation of object-oriented languages. <p> graph. 15 Recall that before the lowering a class type usually contains only the instance fields that the class defines. 16 class, a builder class, and methods for tags, the zot interface, and cloning must be implemented to provide the full functionality that SUIF demands from all of its classes <ref> [KH97] </ref>. None of these extensions are trivial to implement. 16 OSUIF and Vortex [DDG + 96] share the same goals. Both are systems for object-oriented compiler research. Both systems define an IR, which incorporates object-oriented constructs, and provide (generic) optimization passes.
Reference: [PC94] <author> John Plevyak and Andrew A. Chien. </author> <title> Precise concrete type inference for object-oriented languages. </title> <booktitle> OOPSLA '94, </booktitle> <pages> pages 324-340, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Thus, high-level information is lost that could have been used for code optimization (e.g., class hierarchy analysis [DGC95] [DMM96] or type inference [CU90] <ref> [PC94] </ref> [AH95]). OSUIF overcomes this problem by introducing a new, high-level IR constructs that model dynamic method calls, classes, class hierarchies, etc.
Reference: [Rob89] <author> Eric S. Roberts. </author> <title> Implementing exceptions in C. </title> <type> Technical Report 40, </type> <institution> DEC Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> March </month> <year> 1989. </year> <month> 18 </month>
Reference-contexts: Exception handling can be implemented with a number of different techniques. For instance, a portable albeit slow technique is based on the use of the C Library setjump () and longjump () functions <ref> [Rob89] </ref>. More efficient, PC-based techniques use in-code markers or PC range tables [Cha95].
References-found: 14

