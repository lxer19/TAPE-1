URL: http://www.cs.nmsu.edu/lldap/download/jicslp/lopes.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/jicslp/lopes.html
Root-URL: http://www.cs.nmsu.edu
Email: frslopes,vscg@ncc.up.pt  
Title: The YAIL: An Intermediate Language for the Native Compilation of Prolog Programs  
Author: Ricardo Lopes, Vitor Santos Costa 
Date: September 9, 1996  
Address: 823, 4150 Porto, Portugal  
Affiliation: LIACC, Universidade do Porto, Rua do Campo Alegre,  
Abstract: A major goal for any Prolog implementor is to achieve the best performance for applications. Advanced compilation is essential for high performance. The last few years have seen improvements in Prolog compilation technology resulting in a return to the idea of native code execution. We present work on designing a novel native code compiler for Prolog. The compiler uses an intermediate language optimised for novel architectures, such as the ALPHA and performs several optimisations to obtain good quality code. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mats Carlsson. </author> <title> Internals of Sicstus Prolog version 0.6. </title> <type> Internal Report, </type> <institution> Gigalips Project, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: The search for portability and simplicity in the implementation in Prolog systems lead to a different approach, where compilers generate code for abstract machines that are then are emulated at run-time. Examples include Quintus Prolog [8], YAP [5], or SICStus Prolog <ref> [1] </ref>, among many others. Most of these systems implement variants of David H. D. Warren's WAM [12] as their abstract machine. The last few years have seen improvements in Prolog compilation technology resulting in a return to the idea of native code execution [11].
Reference: [2] <author> Takashi Chikayama, Tetsuro Fujise, and Hiroshi Yashiro. </author> <title> A portable and reasonably efficient implementation of KL1. </title> <editor> In David S. Warren, editor, </editor> <booktitle> Proceedings of the Tenth International Conference on Logic Programming, </booktitle> <pages> page 833, </pages> <address> Budapest, Hungary, 1993. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Last, we tried to support novel features in modern architectures that can be emulated in previous architectures, such as conditional move operations. 2.2. Compiling the Intermediate Languages A second question was whether to use C or an assembly language compiler. Notwithstanding the good results obtained with KLIC <ref> [2] </ref> or Mercury [4], study of Prolog implementations indicates that the best results for native code Prolog systems so far have been obtained with assembly based implementations. Performance of C based implementations is not yet to par with what one can obtain from careful generation of native code.
Reference: [3] <author> Philippe Codognet and Daniel Diaz. wamcc: </author> <title> Compiling Prolog to C. </title> <booktitle> In 12th International Conference on Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: A different alternative is to generate code for a high-level language, such as C, and trust the abilities of modern optimising compilers. 2.1. Intermediate Languages There are several approaches to the problem of intermediate languages for native code systems. In the WAMCC <ref> [3] </ref>, the WAM is used as an intermediate language and compiled code is generated directly from here. This results in a clean implementation, but makes it difficult to obtain the best performance.
Reference: [4] <author> Thomas Conway, Ferugus Henderson, and Zoltan Somgyi. </author> <title> Code generation for Mercury. </title> <booktitle> In ILPS95, </booktitle> <pages> pages 245-256, </pages> <year> 1995. </year>
Reference-contexts: Compiling the Intermediate Languages A second question was whether to use C or an assembly language compiler. Notwithstanding the good results obtained with KLIC [2] or Mercury <ref> [4] </ref>, study of Prolog implementations indicates that the best results for native code Prolog systems so far have been obtained with assembly based implementations. Performance of C based implementations is not yet to par with what one can obtain from careful generation of native code.
Reference: [5] <author> L. Damas, V. Santos Costa, R Reis, and R. Azevedo. </author> <title> YAP User's Guide and Reference Manual, </title> <year> 1989. </year>
Reference-contexts: The search for portability and simplicity in the implementation in Prolog systems lead to a different approach, where compilers generate code for abstract machines that are then are emulated at run-time. Examples include Quintus Prolog [8], YAP <ref> [5] </ref>, or SICStus Prolog [1], among many others. Most of these systems implement variants of David H. D. Warren's WAM [12] as their abstract machine. The last few years have seen improvements in Prolog compilation technology resulting in a return to the idea of native code execution [11].
Reference: [6] <author> Michel Ferreira. </author> <title> Um Compilador de Prolog com Expans~ao de Codigo. </title> <type> Technical note, </type> <institution> LIACC, Universidade do Porto, </institution> <year> 1996. </year>
Reference-contexts: We next plan to support full procedure code, and to refine the YAIL instruction set through performance evaluation and perform further optimisations. We also plan to the use YAIL as target for sophisticated Prolog compilers, such as the optimisations being developed within the Proloppe project <ref> [6] </ref>. This might require changes to the YAIL architecture, such as the introduction of prag-mas [11]. 14 1996 Compulog Net Meeting on Parallelism and Implementation Technology Acknowledgments The authors would like to acknowledge and thank for the contribution and support that Fernando Silva and Luis Damas gave to this work.
Reference: [7] <author> R. C. Haygood. </author> <title> Native code compilation in SICStus Prolog. </title> <editor> In Pascal Van Hentenryck, editor, </editor> <booktitle> Proceedings of the Eleventh International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: We aim at this work becoming freely available to the logic programming community As in the case of Prolog by BIM or of SICStus Prolog <ref> [7] </ref> by we decided to start from a preexisting system. YAP already provides access to a large library of built-in predicates and a compiler, which we would need to rewrite for a novel system. <p> This results in a clean implementation, but makes it difficult to obtain the best performance. In Aquarius [10] or PARMA [9] the WAM is avoided and code is used for an intermediate representation directly. Last, in SICStus Prolog <ref> [7] </ref> a WAM-like abstract machine is used in the first step, and a lower-level intermediate representation is used for native code generation. The advantages of using this extra step is that the original system already performs several optimi-sations for generating the WAM-like code.
Reference: [8] <institution> Quintus Prolog User's Guide and Reference Manual|Version 6, </institution> <month> April </month> <year> 1986. </year>
Reference-contexts: The search for portability and simplicity in the implementation in Prolog systems lead to a different approach, where compilers generate code for abstract machines that are then are emulated at run-time. Examples include Quintus Prolog <ref> [8] </ref>, YAP [5], or SICStus Prolog [1], among many others. Most of these systems implement variants of David H. D. Warren's WAM [12] as their abstract machine. The last few years have seen improvements in Prolog compilation technology resulting in a return to the idea of native code execution [11].
Reference: [9] <author> A. Taylor. </author> <title> LIPS on a MIPS: Results from a Prolog Compiler for a RISC. </title> <booktitle> In Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <pages> pages 174-185. </pages> <publisher> MIT Press, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: In the WAMCC [3], the WAM is used as an intermediate language and compiled code is generated directly from here. This results in a clean implementation, but makes it difficult to obtain the best performance. In Aquarius [10] or PARMA <ref> [9] </ref> the WAM is avoided and code is used for an intermediate representation directly. Last, in SICStus Prolog [7] a WAM-like abstract machine is used in the first step, and a lower-level intermediate representation is used for native code generation.
Reference: [10] <author> P. Van Roy. </author> <title> Can Logic Programming Execute as Fast as Imperative Programming? PhD thesis, </title> <institution> University of California at Berkeley, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: In the WAMCC [3], the WAM is used as an intermediate language and compiled code is generated directly from here. This results in a clean implementation, but makes it difficult to obtain the best performance. In Aquarius <ref> [10] </ref> or PARMA [9] the WAM is avoided and code is used for an intermediate representation directly. Last, in SICStus Prolog [7] a WAM-like abstract machine is used in the first step, and a lower-level intermediate representation is used for native code generation.
Reference: [11] <author> P. Van Roy. </author> <year> 1983-1993: </year> <title> The Wonder Years of Sequential Prolog Implementation. </title> <journal> The Journal of Logic Programming, </journal> <month> 19/20, May/July </month> <year> 1994. </year>
Reference-contexts: Most of these systems implement variants of David H. D. Warren's WAM [12] as their abstract machine. The last few years have seen improvements in Prolog compilation technology resulting in a return to the idea of native code execution <ref> [11] </ref>. <p> We also plan to the use YAIL as target for sophisticated Prolog compilers, such as the optimisations being developed within the Proloppe project [6]. This might require changes to the YAIL architecture, such as the introduction of prag-mas <ref> [11] </ref>. 14 1996 Compulog Net Meeting on Parallelism and Implementation Technology Acknowledgments The authors would like to acknowledge and thank for the contribution and support that Fernando Silva and Luis Damas gave to this work. This work has been partly supported by JNICT under the PROLOPPE project (contract Praxis/3/3.1/TIT/24/94).
Reference: [12] <author> David H. D. Warren. </author> <title> An Abstract Prolog Instruction Set. </title> <type> Technical Note 309, </type> <institution> SRI International, </institution> <year> 1983. </year>
Reference-contexts: Examples include Quintus Prolog [8], YAP [5], or SICStus Prolog [1], among many others. Most of these systems implement variants of David H. D. Warren's WAM <ref> [12] </ref> as their abstract machine. The last few years have seen improvements in Prolog compilation technology resulting in a return to the idea of native code execution [11].
References-found: 12

