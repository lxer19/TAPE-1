URL: http://www.eecis.udel.edu:80/~stoa/papers/PaCT97.ps
Refering-URL: http://www.eecis.udel.edu:80/~stoa/PROJECTS/projects.html
Root-URL: http://www.cis.udel.edu
Title: An Integer Linear Programming Model of Software Pipelining for the MIPS R8000 Processor  
Author: Artour Stoutchinin 
Address: USA  
Affiliation: EE Department, University of Delaware,  
Abstract: In parallelizing the code for high-performance processors, software pipelining of innermost loops is of fundamental importance. In order to benefit from software pipelining, two separate tasks need to be performed: (i) software pipelining proper (find the rate-optimal legal schedule), and (ii) register allocation (allocate registers to the found schedule). Software pipelining and register allocation can be formulated as an integer linear programming (ILP) problem, aiming to produce optimal schedules. In this paper, we discuss the application of the integer linear programming to software pipelining on the MIPS R8000 superscalar microprocessor. Some of the results were presented in the PLDI96 [14], where they were compared to the MIPSpro software pipeliner. In this paper we further extend the ILP model for the MIPS R8000 by including memory optimization and present the entire model in detail.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Erik R. Altman. </author> <title> Optimal Software Pipelining with Function Unit and Register Constraints. </title> <type> PhD thesis, </type> <institution> McGill University, </institution> <address> Montreal, Quebec, </address> <year> 1995. </year>
Reference-contexts: A number of interesting results of using the linear and integer linear programming approach for software pipelining have been published recently <ref> [10, 7, 2, 1, 5] </ref>. This paper concentrates on the development of the integer linear programming software pipeliner for the MIPS R8000 microprocessor based on the previous work by E. Altman [1]. <p> This paper concentrates on the development of the integer linear programming software pipeliner for the MIPS R8000 microprocessor based on the previous work by E. Altman <ref> [1] </ref>. In developing such software pipeliner our main interests were to study how well the ILP approach would work when targeted to a real processor. <p> Substituting (5) into (3) we obtain the matrix form of a periodic schedule : II K + <ref> [0; 1; ; II 1] </ref> fi A = T (6) Because each operation is allowed to execute only once within the repetitive pattern, the following condition applies: II1 X a t;i = 1; 0 a t;i 1 are integers; 8x i 2 [x 1 ; x 2 ; ; x N <p> Precedence constraints: t = II K + A T ranspose fi <ref> [0; 1; :::; II 1] </ref> Transpose II1 X a t;i = 1; 8i 2 [1; N ] 2. Resource constraints: R s 2ISA x i 2 l=0 [l]; 8t 2 [0; II 1]; 8s R s is the number of available units of resource s. 3. <p> Precedence constraints: t = II K + A T ranspose fi [0; 1; :::; II 1] Transpose II1 X a t;i = 1; 8i 2 <ref> [1; N ] </ref> 2. Resource constraints: R s 2ISA x i 2 l=0 [l]; 8t 2 [0; II 1]; 8s R s is the number of available units of resource s. 3.
Reference: 2. <author> Erik R. Altman, R. Govindarajan, and Guang R. Gao. </author> <title> Scheduling and mapping: Software pipelining in presence of structural hazards. </title> <booktitle> In Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 139 - 150, </pages> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year> <journal> ACM SIGPLAN. </journal>
Reference-contexts: A number of interesting results of using the linear and integer linear programming approach for software pipelining have been published recently <ref> [10, 7, 2, 1, 5] </ref>. This paper concentrates on the development of the integer linear programming software pipeliner for the MIPS R8000 microprocessor based on the previous work by E. Altman [1]. <p> to execute only once within the repetitive pattern, the following condition applies: II1 X a t;i = 1; 0 a t;i 1 are integers; 8x i 2 [x 1 ; x 2 ; ; x N ] (7) 2.3 Precedence Constraints is legal if it satisfies linear precedence constraints (see <ref> [2] </ref>): t j t i d ij II ij ; 8 (i; j) 2 E: Stage/Time 0 1 2 3 4 5 Stage 1 x x x x Stage 2 x Stage 3 x (a) Stage/Time 0 1 2 Stage 1 2 1 1 Stage 2 1 Stage 3 1 (b)
Reference: 3. <author> R. Bixby, Ken Kennedy, and Uwe Kremer. </author> <title> Automatic data layout using 0-1 integer linear programming. </title> <booktitle> In Conference on Parallel Architectures and Compilation Techniques, </booktitle> <pages> pages 111 - 122, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Future work should focus on reducing the ILP solution time. Careful investigation showed that exploitation of the problem structure must be the foundation of such an improvement. The ILP framework has been effective in solving other computationally difficult problems <ref> [3, 6] </ref>. In these problems, formulating a "good" model is of crucial importance to solving that model [9]. For example, it is well known that there are efficient methods of solving integer linear programming problems formulated in terms of 0-1 variables.
Reference: 4. <author> James C. Dehnert and Ross A. Towle. </author> <title> Compiling for cydra 5. </title> <journal> The Journal of Supercomputing (Special Issue on Instruction-Level Parallelism), </journal> <volume> 7(1/2), </volume> <month> July </month> <year> 1993. </year>
Reference-contexts: Exact Modulo Scheduling Approach The subject of this paper, software pipelining, and more precisely modulo scheduling, is a compiler parallelization technique which has recently received a lot of ? important part of this work was done while in McGill University in Montreal attention and is successfully implemented in production compilers <ref> [4, 14] </ref>. Be--cause of its computational complexity, heuristic algorithms are used for modulo scheduling. One question that heuristic approaches leave unanswered is "How well do these methods do their job?".
Reference: 5. <author> Alexandre E. Eichenberger, David S. Davidson, and Santosh G. Abraham. </author> <title> Optimum modulo schedules for minimum register requirements. </title> <booktitle> In International Conference on Supercomputing, </booktitle> <pages> pages 31 - 40, </pages> <address> Barcelona, Spain, </address> <month> July </month> <year> 1995. </year> <note> ACM SIGARCH. </note>
Reference-contexts: A number of interesting results of using the linear and integer linear programming approach for software pipelining have been published recently <ref> [10, 7, 2, 1, 5] </ref>. This paper concentrates on the development of the integer linear programming software pipeliner for the MIPS R8000 microprocessor based on the previous work by E. Altman [1].
Reference: 6. <author> David W. Goodwin and Kent D. Wilken. </author> <title> Optimal and near-optimal global register allocation using 0-1 integer programming. </title> <journal> Software Practice and Experience, </journal> <year> 1996. </year>
Reference-contexts: Future work should focus on reducing the ILP solution time. Careful investigation showed that exploitation of the problem structure must be the foundation of such an improvement. The ILP framework has been effective in solving other computationally difficult problems <ref> [3, 6] </ref>. In these problems, formulating a "good" model is of crucial importance to solving that model [9]. For example, it is well known that there are efficient methods of solving integer linear programming problems formulated in terms of 0-1 variables.
Reference: 7. <author> R. Govindarajan, Erik R. Altman, and Guang R. Gao. </author> <title> Minimizing register requirements under resource-constrained rate-optimal software pipelining. </title> <booktitle> In 27th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 85 - 94, </pages> <address> San Jose, CA, </address> <month> November - December </month> <year> 1994. </year>
Reference-contexts: A number of interesting results of using the linear and integer linear programming approach for software pipelining have been published recently <ref> [10, 7, 2, 1, 5] </ref>. This paper concentrates on the development of the integer linear programming software pipeliner for the MIPS R8000 microprocessor based on the previous work by E. Altman [1].
Reference: 8. <author> P. M. Kogge. </author> <title> The Architecture of Pipelined Computers. </title> <publisher> McGraw Hill, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: In classical pipeline theory, reservation tables represent resource usage of different operations <ref> [8, 13] </ref>.
Reference: 9. <author> G. L. Nemhauser and L. A. Wolsey. </author> <title> Handbooks in Operation Research and Management Science: </title> <journal> Optimization, </journal> <volume> volume 1. </volume> <publisher> Elsevier Science, </publisher> <address> New York, </address> <year> 1989. </year> <month> ch.6. </month>
Reference-contexts: Careful investigation showed that exploitation of the problem structure must be the foundation of such an improvement. The ILP framework has been effective in solving other computationally difficult problems [3, 6]. In these problems, formulating a "good" model is of crucial importance to solving that model <ref> [9] </ref>. For example, it is well known that there are efficient methods of solving integer linear programming problems formulated in terms of 0-1 variables. Therefore, reformulating modulo scheduling as such offers potentially significant improvement in solution efficiency. There is also room for improvement in the usage of machine's memory system.
Reference: 10. <author> Qi Ning and Guang R. Gao. </author> <title> A novel framework of register allocation for software pipelining. </title> <booktitle> In 20th Annual International Symposium on Principles of Programming Languages, </booktitle> <pages> pages 29 - 42, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: A number of interesting results of using the linear and integer linear programming approach for software pipelining have been published recently <ref> [10, 7, 2, 1, 5] </ref>. This paper concentrates on the development of the integer linear programming software pipeliner for the MIPS R8000 microprocessor based on the previous work by E. Altman [1]. <p> for a particular resource s are: R s = x i 2 l=0 [l]; 8t 2 [0; II 1] (8) 2.5 Objective Function The upper bound on the number of registers required by a schedule is given by the sum of the buffer sizes of all values kept in registers <ref> [10] </ref>. <p> It also should be noticed that registers can be shared by different values when their lifetimes do not overlap, which is not reflected by the buffers. Buffer minimizing objective function is: min x i and buffer sizes are approximated by the following constraints <ref> [10] </ref>: II b i + t i t j II ( ij + 1) 1; 8 (i; j) 2 E; b i are integers (11) 2.6 ILP Formulation for Modulo Scheduling minimize X b i subject to: 1.
Reference: 11. <author> Charles Price. </author> <title> MIPS IV Instruction Set. </title> <institution> Silicon Graphics Computer Systems, </institution> <month> January </month> <year> 1995. </year> <note> Revision 3.1. </note>
Reference-contexts: A collection of processor resources. Instructions in the MIPS IV instruction set <ref> [11] </ref> are classified into twenty-one type according to their resource usage patterns. Resource usage of each instruction type is modeled using reserva tion tables. 2. A collection of latencies associated with each instruction type.
Reference: 12. <author> B. R. Rau and Joseph A. Fisher. </author> <title> Instruction-level parallel processing: History, overview, and prospective. </title> <journal> The Journal of Supercomputing (Special Issue on Instruction-Level Parallelism), </journal> <volume> 7(1/2):9 - 50, </volume> <year> 1993. </year>
Reference-contexts: Instruction-level parallel processors take advantage of the parallelism in programs by performing multiple machine level operations simultaneously. A typical such processor (a superscalar or VLIW processor), provides multiple pipelined functional units in parallel, thus allowing the simultaneous issue of multiple operations per clock cycle <ref> [12] </ref>.
Reference: 13. <author> B. R. Rau and Joseph A. Fisher. </author> <title> Some scheduling techniques and a easily schedu-lable horizontal architecture for high-performance scientific programming. </title> <booktitle> In IEEE/ACM 14th Annual Microprogramming Workshop, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: In classical pipeline theory, reservation tables represent resource usage of different operations <ref> [8, 13] </ref>.
Reference: 14. <author> John C. Ruttenberg, Guang R. Gao, Artour Stoutchinin, and Woody Lichtenstein. </author> <title> Software pipelining showdown: Optimal vs heuristic methods in a production compiler. </title> <booktitle> In Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1 - 11, </pages> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year> <title> ACM SIGPLAN. This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Exact Modulo Scheduling Approach The subject of this paper, software pipelining, and more precisely modulo scheduling, is a compiler parallelization technique which has recently received a lot of ? important part of this work was done while in McGill University in Montreal attention and is successfully implemented in production compilers <ref> [4, 14] </ref>. Be--cause of its computational complexity, heuristic algorithms are used for modulo scheduling. One question that heuristic approaches leave unanswered is "How well do these methods do their job?". <p> Altman [1]. In developing such software pipeliner our main interests were to study how well the ILP approach would work when targeted to a real processor. After the publication of the first measurement of runtime performance for ILP-based generation for software pipelines <ref> [14] </ref>, one of the important questions left unanswered was how much uncertainty have been introduced by the memory system in our experiments ? In this paper we analyze this question and present a new set of experimental results with the memory effects taken care of by an improved ILP model. 1.2 <p> In order to measure its performance, the ILP software pipeliner was embedded in the Silicon Graphics' MIPSpro compiler (see <ref> [14] </ref> for details). The SGI pipeliner has also served as a backup for our pipeliner in the case it could not schedule a loop within a reasonable time instead of falling back to the single block scheduler. <p> A new set of results is reported here after the memory system optimization was included in the ILP formulation. 4.2 Highlights of Main Results In our experiment reported in <ref> [14] </ref> the ILP pipeliner and the SGI pipeliner were used in turn for compiling the SPEC92 benchmark suite, consisting of 14 benchmark programs. The SGI pipeliner scheduled 798 loops in total in this benchmark suite and the ILP pipeliner scheduled 753 loops. <p> The new data shows the SGI pipeliner only slightly outperformes the ILP pipeliner in 6 of the benchmarks, down from 8 reported in <ref> [14] </ref>, and that geometric mean of a suite as a whole is now equal for both schedulers (previously we reported the MIPSpro geometric mean to be 8% better than the geometric mean of our scheduler). <p> CPLEX is a very powerful and flexible tool, but it does not allow us to fully exploit the problem's structure. Making the integer solver aware of such structure increases the effectiveness of integer problem solving. The SGI pipeliner uses multiple scheduling orders to facilitate register allocation <ref> [14] </ref>. The idea behind it is that at least one of the different scheduling orders should produce a schedule which fits into the available allocation registers. <p> However, soon we discovered that traversing the branch-and-bound tree in a "good" order significantly reduces the time spent searching for the optimal solution. The four orders that were used by the ILP pipeliner were the ones used by the MIPSpro <ref> [14] </ref>: 1. Folded depth-first ordering with the final memory sort, 2. Data precedence graph heights with the final memory sort, 3. Reversed heights with the final memory sort, 4. Folded depth first ordering without final memory sort.
References-found: 14

