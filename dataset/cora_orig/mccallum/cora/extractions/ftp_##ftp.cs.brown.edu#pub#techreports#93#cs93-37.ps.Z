URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-37.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-37.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1990. </year>
Reference-contexts: The syntax and semantics of the regular expression are identical to the ones used for the UNIX utility grep [17]. Any class name that fails to match this regular expression will violate the constraint and will thus trigger a violation message. Example: Restriction on Variable Names The C++ standard <ref> [1] </ref> specifies that identifiers containing two consecutive underscore characters (_ _ ) are reserved for compiler implementations. For this reason, it is wise to avoid using _ _ in variable names. This leads to the constraint: No variable may contain _ _ in its name. <p> This is, in fact, what Sakkinen advocates. Following Sakkinens advice, however, often introduces additional overhead because of the way C++ compilers typically implement virtual base classes <ref> [1] </ref>. A preferable constraint may therefore be: if there are multiple public inheritance paths from a derived class to one of its base classes, all these paths must be virtual.
Reference: [2] <author> Keith E. Gorlen, Sanford M. Orlow, and Perry S. Plexico. </author> <title> Data Abstraction and Object-Oriented Programming in C++. </title> <publisher> John Wiley & Sons, </publisher> <year> 1990. </year>
Reference-contexts: A design constraint: The member function M in class C must be overridden in all classes derived from C. Design constraints are specific to a particular application or library. This particular constraint is common in general-purpose class libraries. For example, the NIH class library <ref> [2] </ref> contains many functions which must always be overridden if the library is to function correctly. A company can mandate corporate-wide stylistic constraints and even some implementation constraints on its programmers. <p> Maintaining a library and extending it involves knowledge of the commonality of its components. One way to enforce consistency and compatibility among the classes is to encapsulate all the commonality into a root class from which all the other classes inherit. The NIH Class Library <ref> [2] </ref> defines such a root class called Object and makes every class a descendant of it. 1 Class Object declares virtual functions that apply to all classes functions for copying, printing, storing, reading and comparing objects, for example.
Reference: [3] <author> Scott Meyers. </author> <title> Effective C++: 50 Ways to Improve Your Programs and Designs. </title> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: An implementation constraint: If a class declares a pointer data member, it must also declare an assignment operator and a copy constructor. Failure to adhere to this constraint frequently leads to incorrect program behavior <ref> [3] </ref>. A design constraint: The member function M in class C must be overridden in all classes derived from C. Design constraints are specific to a particular application or library. This particular constraint is common in general-purpose class libraries. <p> At the same time, these design-specific constraints are often the most important to enforce. Scores of articles, books and informal guidelines have been published on design issues <ref> [3, 4, 6, 10] </ref>; comp.lang.c++ and similar Usenet newsgroups host hundreds of gripes from real programmers around the globe on the inability of C++ to specify constraints that would make software design and implementation more of an intellectual activity by cutting down the amount of busywork. <p> In general, a constraint violation is reported if there exists a combination of CCEL variable bindings that causes the assertion to evaluate to false. Consider the constraint that every base class must have a virtual destructor <ref> [3] </ref>. <p> Example: Return Type of Assignment Operator C++ experts agree on the usefulness of the assignment operator. However, they do not agree on the return type of that operator. For example, Meyers argues <ref> [3] </ref> that the return type should be a reference to the class so that assignment chaining is possible, since this is a supported feature of built-in types: a = b = c // this is not possible with return type void SuperBase Base1 Base2 Derived Unambiguous only one copy of SuperBase <p> A library of CCEL constraints inspired by the plethora of stylistic, implementation and design constraints <ref> [3, 4, 6, 10, 14] </ref> is currently being compiled. CCEL currently supports the expression of constraints on C++ declarations only. Our plan is to extend CCEL into the next-generation CCEL-II, which will add the ability to express constraints on C++ definitions also.
Reference: [4] <author> Thomas Plum and Dan Saks. </author> <title> C++ Programming Guidelines. </title> <publisher> Plum Hall Inc., </publisher> <year> 1991. </year>
Reference-contexts: At the same time, these design-specific constraints are often the most important to enforce. Scores of articles, books and informal guidelines have been published on design issues <ref> [3, 4, 6, 10] </ref>; comp.lang.c++ and similar Usenet newsgroups host hundreds of gripes from real programmers around the globe on the inability of C++ to specify constraints that would make software design and implementation more of an intellectual activity by cutting down the amount of busywork. <p> The unique identifier and the assertion are the only two required parts of a CCEL constraint. If any of the other three parts is left out, its default value is assumed. 3 Example Constraints Readability, reliability and maintainability all require that the meaning of the code be intuitively graspable <ref> [4] </ref>. C++ is 3 a language full of subtleties. Its programmers impose restrictions on the usage of the language in order to work within the subset known to them to build projects that give predictable and reliable results. CCEL is particularly suitable for expressing these constraints. <p> A library of CCEL constraints inspired by the plethora of stylistic, implementation and design constraints <ref> [3, 4, 6, 10, 14] </ref> is currently being compiled. CCEL currently supports the expression of constraints on C++ declarations only. Our plan is to extend CCEL into the next-generation CCEL-II, which will add the ability to express constraints on C++ definitions also.
Reference: [5] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language, Second Edition. </title> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1991. </year>
Reference: [6] <author> James O. Coplien. </author> <title> Advanced C++ Programming Styles and Idioms. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1992. </year>
Reference-contexts: At the same time, these design-specific constraints are often the most important to enforce. Scores of articles, books and informal guidelines have been published on design issues <ref> [3, 4, 6, 10] </ref>; comp.lang.c++ and similar Usenet newsgroups host hundreds of gripes from real programmers around the globe on the inability of C++ to specify constraints that would make software design and implementation more of an intellectual activity by cutting down the amount of busywork. <p> A library of CCEL constraints inspired by the plethora of stylistic, implementation and design constraints <ref> [3, 4, 6, 10, 14] </ref> is currently being compiled. CCEL currently supports the expression of constraints on C++ declarations only. Our plan is to extend CCEL into the next-generation CCEL-II, which will add the ability to express constraints on C++ definitions also.
Reference: [7] <author> Scott Meyers and Moises Lejter. </author> <title> Automatic Detection of C++ Programming Errors: Initial Thoughts on a lint++. </title> <booktitle> Usenix C++ Conference Proceedings, </booktitle> <month> Spring </month> <year> 1991. </year>
Reference-contexts: this situation are almost unavoidable the common but mistaken notion that we are dealing with copies of the original and the invalidation of the pointed-to object when one of the container objects goes out of scope (its destructor thus deleting what the data member was pointing to) are two examples <ref> [7] </ref>. For the sake of correct program behavior, it is essential that any class with a pointer data member declare a copy constructor and an assignment operator. CCEL can express this constraint: // All classes declaring a pointer member must declare a copy // constructor and an assignment operator.
Reference: [8] <author> Yeuh-hong Lin and Scott Meyers. CCEL: </author> <title> The C++ Constraint Expression Language. </title> <type> Technical report 93-23, </type> <institution> Brown University Department of Computer Science, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: We do not discuss the implementation architecture of CCEL in this paper, nor do we provide a comprehensive description of the language. A detailed description of the architecture can be found in [9]. A formal language specification is in <ref> [8] </ref>. <p> In the last example, the UNIX wildcard characters ^ and $ are used to indicate the beginning and end of a string representing the class name. Similarly, an Enable feature exists to enable a constraint for a given scope. Details can be found in <ref> [8] </ref>. It is possible to attain an arbitrary level of nested applicability of several constraints by using the scope, enable and disable features of CCEL constraints. 5 Application to Other Languages The details of CCEL are clearly specific to C++.
Reference: [9] <author> Scott Meyers, Carolyn K. Duby, and Steven P. Reiss. </author> <title> Constraining the Structure and Style of Object-Oriented Programs. </title> <booktitle> Proceedings of the Workshop on Principles and Practice of Constraint Programming, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: We do not discuss the implementation architecture of CCEL in this paper, nor do we provide a comprehensive description of the language. A detailed description of the architecture can be found in <ref> [9] </ref>. A formal language specification is in [8]. <p> CCEL offers a way to formally express many naming conventions, and the CCEL constraint enforcement mechanism <ref> [9] </ref> ags any violations of these conventions. In the event of a change in naming conventions, all that needs to be changed is the rule specifying a constraint, and everybody is instantly made up-to-date with the changes in the standards. <p> The software engineering considerations that allow CCEL constraints to be bundled into constraint classes, to be explicitly disabled, and to have user-specified scopes and violation messages are as important for Object Pascal programmers as they are for C++ software developers. Furthermore, the software architecture behind a CCEL implementation <ref> [9] </ref> contains nothing that tailors it to the idiosyncrasies of C++.
Reference: [10] <author> Mats Henricson and Erik Nyquist. </author> <title> Programming in C++: Rules and Recommendations. </title> <institution> Ellemtel Telecommunications Systems Laboratories, </institution> <year> 1990. </year>
Reference-contexts: At the same time, these design-specific constraints are often the most important to enforce. Scores of articles, books and informal guidelines have been published on design issues <ref> [3, 4, 6, 10] </ref>; comp.lang.c++ and similar Usenet newsgroups host hundreds of gripes from real programmers around the globe on the inability of C++ to specify constraints that would make software design and implementation more of an intellectual activity by cutting down the amount of busywork. <p> A library of CCEL constraints inspired by the plethora of stylistic, implementation and design constraints <ref> [3, 4, 6, 10, 14] </ref> is currently being compiled. CCEL currently supports the expression of constraints on C++ declarations only. Our plan is to extend CCEL into the next-generation CCEL-II, which will add the ability to express constraints on C++ definitions also.
Reference: [11] <author> Markku Sakkinen. </author> <title> A Critique of the Inheritance Principles of C++. </title> <journal> Computing Systems, </journal> <volume> Vol. 5 No. 1, </volume> <month> Winter </month> <year> 1992. </year>
Reference-contexts: There are work-arounds to ambiguities, but adopting them is usually error-prone and confusing. This almost always leads to incorrect semantics and unpredictable program behavior. Markku Sakkinen argues <ref> [11] </ref> that public inheritance is basically an IsA relationship if class D is derived from class B, D is a B. The important point is that D is a B only once; it does not make sense to say that D is B more than once.
Reference: [12] <author> Robert Murray. </author> <title> The C++ Puzzle. </title> <journal> The C++ Report, </journal> <volume> Vol. 2 No. 10, </volume> <month> November/December </month> <year> 1990. </year>
Reference-contexts: Rob Murray sees a problem with the above convention. His argument is based on the questionable utility of the following statement <ref> [12] </ref>: (a = b) = c which, he argues, is an unintuitive and confusing assignment. He proposes a more strict constraint by saying that the return type should be a const reference to the class.
Reference: [13] <author> Doug Lea, </author> <type> personal communication, </type> <year> 1993. </year>
Reference-contexts: operator=; Assert (mf.is_const () && mf.is_reference () && mf.type ().basic_type () == C); ); On the other hand, Doug Lea points out that subtle interactions between the strong static typing of C++ and its support for polymorphism can sometimes lead to unanticipated resolution of calls to overloaded functions, including operator= <ref> [13] </ref>. These problems, the details of which are unimportant here, can be avoided by having operator= return void. CCEL can be used to express this constraint as well: // The return type of operator= must be void.
Reference: [14] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year> <title> [15] libg++ documentation. Gnu Library. Free Software Foundation, </title> <month> June </month> <year> 1991. </year>
Reference-contexts: The above rule issues violation messages whenever there is a non-type parameter to a template class. CCEL can also be used with templates to approximate Meyers notion of constrained genericity <ref> [14] </ref>, i.e. the ability to restrict template type arguments to those supporting a specific set of functions. 3.3 Design Constraints So far we have shown constraints that are difficult to remember without an automated violation checker. <p> A library of CCEL constraints inspired by the plethora of stylistic, implementation and design constraints <ref> [3, 4, 6, 10, 14] </ref> is currently being compiled. CCEL currently supports the expression of constraints on C++ declarations only. Our plan is to extend CCEL into the next-generation CCEL-II, which will add the ability to express constraints on C++ definitions also.
Reference: [16] <author> Gregor Kiczales and John Lamping. </author> <title> Issues in the Design and Implementation of Class Libraries. </title> <booktitle> Proceedings of the 1992 Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA 92) (Andreas Paepcke, </booktitle> <editor> ed.), </editor> <month> October </month> <year> 1992. </year>
Reference-contexts: The fundamental design principles behind CCEL, however, apply equally well to other languages. The kinds of constraints described in this paper exist for languages like Smalltalk and CLOS as much as they do for C++ <ref> [16] </ref>. The desirability of choosing a syntax, semantics, and conceptual model that is familiar to programmers is as important for an Eiffel constraint language as it is for CCEL.
Reference: [17] <author> Brian W. Kernighan and Rob Pike. </author> <title> The UNIX Programming Environment. </title> <publisher> Prentice-Hall, </publisher> <year> 1984. </year>
Reference-contexts: The syntax and semantics of the regular expression are identical to the ones used for the UNIX utility grep <ref> [17] </ref>. Any class name that fails to match this regular expression will violate the constraint and will thus trigger a violation message. Example: Restriction on Variable Names The C++ standard [1] specifies that identifiers containing two consecutive underscore characters (_ _ ) are reserved for compiler implementations. <p> Class ^lowercaseClass$ : NoCapClassName ( Disable CapitalizeClassName; ); Note that file scopes are specified using UNIX shell wildcard expressions, but the function and class scopes are specified using UNIX regular expressions <ref> [17] </ref>. In the last example, the UNIX wildcard characters ^ and $ are used to indicate the beginning and end of a string representing the class name. Similarly, an Enable feature exists to enable a constraint for a given scope. Details can be found in [8].
Reference: [18] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language, Second Edition. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: It had to be relatively easy to learn and use. In particular, the syntax and semantics of the language had to mesh well with the syntax and semantics of C++. We chose as our point of departure C++ itself and the well-known assert macro <ref> [18] </ref> from the standard C library. In this paper, we demonstrate why CCEL is a powerful tool for building and maintaining complex software systems by expressing a diverse selection of stylistic, implementation and design constraints.
Reference: [19] <author> Bertrand Meyer, </author> <title> Eiffel: The Language, </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: the language itself and in terms of the implementation of that language are divorced from the specifics of C++ and can be directly applied to constraint languages for other programming languages. 6 Related Work Support for formal design constraints in the form of assertions or annotations was designed into Eiffel <ref> [19] </ref>, has been grafted onto Ada in the language Anna [20], and has been proposed for C++ in the form of A++ [21, 22].
Reference: [20] <author> D. Luckham, F. von Henke, B. Krieg-Bruckner, and O. Owe, Anna, </author> <title> A Language for Annotating Ada Programs: Reference Manual, </title> <booktitle> Lecture Notes in Computer Science 260, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: that language are divorced from the specifics of C++ and can be directly applied to constraint languages for other programming languages. 6 Related Work Support for formal design constraints in the form of assertions or annotations was designed into Eiffel [19], has been grafted onto Ada in the language Anna <ref> [20] </ref>, and has been proposed for C++ in the form of A++ [21, 22].
Reference: [21] <author> Marshall P. Cline and Doug Lea, </author> <title> Using Annotated C++, </title> <booktitle> Proceedings of C++ at Work - 90, </booktitle> <month> September </month> <year> 1990. </year>
Reference-contexts: directly applied to constraint languages for other programming languages. 6 Related Work Support for formal design constraints in the form of assertions or annotations was designed into Eiffel [19], has been grafted onto Ada in the language Anna [20], and has been proposed for C++ in the form of A++ <ref> [21, 22] </ref>. This work, however, has grown out of the theory of abstract data types [23], and has tended to limit itself to formally specifying the semantics of individual functions and/or collections of functions (e.g., how the member functions within a class relate to one another).
Reference: [22] <author> Marshall P. Cline and Doug Lea, </author> <title> The Behavior of C++ Classes, </title> <booktitle> Proceedings of the Symposium on Object-Oriented Programming Emphasizing Practical Applications (SOOPPA), </booktitle> <month> September </month> <year> 1990. </year>
Reference-contexts: directly applied to constraint languages for other programming languages. 6 Related Work Support for formal design constraints in the form of assertions or annotations was designed into Eiffel [19], has been grafted onto Ada in the language Anna [20], and has been proposed for C++ in the form of A++ <ref> [21, 22] </ref>. This work, however, has grown out of the theory of abstract data types [23], and has tended to limit itself to formally specifying the semantics of individual functions and/or collections of functions (e.g., how the member functions within a class relate to one another).
Reference: [23] <author> Barbara Liskov and John Guttag, </author> <title> Abstraction and Specification in Program Development, </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: This work, however, has grown out of the theory of abstract data types <ref> [23] </ref>, and has tended to limit itself to formally specifying the semantics of individual functions and/or collections of functions (e.g., how the member functions within a class relate to one another). In general, violations of these kinds of constraints can only be detected at runtime.
Reference: [24] <author> Loren Cobb, </author> <title> C Code Analysis Using Codecheck, </title> <booktitle> Abraxas Software, </booktitle> <year> 1992. </year>
Reference-contexts: CCEL can also express constraints on the concrete syntax of C++ source code (e.g., CCEL class-specific naming conventions); this is also outside the purview of semantics-based constraint systems. The commercial product CodeCheck <ref> [24] </ref> allows for the specification of user-defined constraints in a similar spirit as CCEL, but the model behind CodeCheck is procedural, not object-oriented; this is a reection of the fact that CodeCheck was originally designed to express constraints on C programs.
Reference: [25] <author> VDM 90: </author> <title> VDM and Z: </title> <booktitle> Formal Methods in Software Development: Third International Symposium of VDM Europe, </booktitle> <address> Kiel, Germany, </address> <month> April 17-21, </month> <year> 1990. </year>
Reference-contexts: In addition, CodeCheck constraints are primarily procedural (if-then-else constructs), whereas CCEL constraints are primarily declarative. Formal specification languages such as Z <ref> [25] </ref>, VDM [25], and Larch [26] are designed to allow developers to specify the behavior of software systems independent of the language (s) used to implement the systems. <p> In addition, CodeCheck constraints are primarily procedural (if-then-else constructs), whereas CCEL constraints are primarily declarative. Formal specification languages such as Z <ref> [25] </ref>, VDM [25], and Larch [26] are designed to allow developers to specify the behavior of software systems independent of the language (s) used to implement the systems.

References-found: 24

