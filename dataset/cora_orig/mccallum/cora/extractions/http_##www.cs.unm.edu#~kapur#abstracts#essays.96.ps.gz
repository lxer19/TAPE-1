URL: http://www.cs.unm.edu/~kapur/abstracts/essays.96.ps.gz
Refering-URL: http://www.cs.unm.edu/~kapur/abstracts/essays.96.html
Root-URL: http://www.cs.unm.edu
Title: 8 Constructors Can Be Partial, Too  
Author: Deepak Kapur 
Address: 8.1 Introduction  
Affiliation: State University of New York at Albany  
Abstract: The behavior of regular aggregate data structures (for example, square matrices, complete binary trees, and powerlists [20]), as well as semantic data structures (for example, sorted lists and priority lists), cannot be captured elegantly by using existing specification techniques and languages such as Larch, Z, OBJ, VDM, or LOTOS. Typically such a data structure is defined as a subsort of a larger data structure. For instance, complete binary trees can be defined as a subsort of binary trees, and powerlists as well as sorted lists can be defined as subsorts of lists. For reasoning about algorithmic descriptions using such data structures, it then becomes necessary to explicitly carry subsort conditions. As shown in [14], this approach makes reasoning about them cumbersome, and the resulting proofs get complex. It is argued in this article that regularity should be exploited while reasoning about specifications based on regular data structures (see also [20]). That does not seem to be possible if regular data structures are modeled using subsorts, perhaps because of incompatibility between regularity and subsorts. Instead of being a benefit, regularity becomes a burden. This situation is somewhat similar to an experience one would have in expressing a specification involving many data types in an unsorted (single-sorted) notation. Different types would have to be characterized by different unary predicates, and conditions expressed using these unary predicates would have to be carried around wherever terms of particular data types are used. A multisorted notation and logic are instead preferred. The main idea of this article is to propose a simple extension to the algebraic specification method that allows constructors of a data structure to be partial in the sense that their behavior may be meaningful only on a subset of the syntactically specified input domain. An applicability condition is associated with every operation, including a constructor, of a data type. An operation is intended to be invoked only if the associated applicability condition is satisfied. As will be shown below, with applicability conditions, regular data structures such as complete binary trees 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. Adams. </author> <title> Verifying Adder Circuits Using Powerlists. </title> <type> Technical Report CS-TR-94-02, </type> <institution> Computer Science Department, University of Texas at Austin, </institution> <year> 1994. </year>
Reference-contexts: Pow-erlists have been used to specify many data-parallel algorithms in [20], employing the divide-and-conquer strategy and recursion. They include Batcher's merge sort and fast Fourier transform, parallel prefix computation, and hardware architectures, as well as hardware circuits, including carry look-ahead and ripple carry adders <ref> [1] </ref>. <p> Interestingly, these mechanically generated proofs turn out to be similar to carefully handcrafted proofs reported in <ref> [20, 1] </ref>; for details, see [14, 15]. 8.1.2 An Example of a "Semantic" Data Structure As an example of a "semantic" data structure, consider specifying sorted lists of items, where the items admit a total ordering. <p> Proofs generated from specifications expressed using applicability conditions are easier to generate, understand, and present, in contrast to proofs generated from specifications using other methods. Many of the mechanically generated proofs of properties of algorithms on powerlists, for instance, are similar to the well-handcrafted proofs reported in <ref> [20, 1] </ref>. 8.1.4 Related Work The applicability condition of an operation can also be thought of as a precondition a la Floyd and Hoare's axiomatic method. <p> Mechanical proofs generated by RRL are compact and simple and|surprisingly|closely mimic the handcrafted proofs reported in <ref> [20, 1] </ref>. Many issues related to specification with applicability condition still need to be further investigated. Identifying (speculating) lemmas that would be useful for establishing that rules are context preserving is an interesting challenge.
Reference: [2] <author> J. A. Bergstra, J. Heering, and P. Klint. </author> <title> Algebraic Specification. </title> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: All operations are assumed to be total functions. This approach is well studied, and several books explain the approach with numerous examples <ref> [2, 8] </ref>. For simplicity, it is assumed below that a specification defines a single abstract data type, called D, in a bottom-up hierarchical manner, using other data types already defined elsewhere.
Reference: [3] <author> N. Dershowitz. </author> <title> Termination of rewriting. </title> <journal> J. Symbolic Computation, </journal> <volume> 3 </volume> <pages> 69-116, </pages> <year> 1987. </year> <title> Constructors Can Be Partial, </title> <type> Too 209 </type>
Reference-contexts: Axiomatization of partial functions and mechanically reasoning about them have been a source of considerable technical difficulty [21, 22]. 8.3.1 Context-Preserving Rules Unconditional equations can be manipulated as rewrite rules whenever it is possible to orient them using termination orderings <ref> [3] </ref>. This is the way reasoning about equations is automated in RRL. Conditional equations can also be handled using conditional rewrite rules, but the rewriting process is expensive because at every rewrite, the condition of a conditional rewrite rule must be satisfied before it can be applied.
Reference: [4] <author> J. A. Goguen, J. W. Thatcher, E. G. Wegner, and J. B. Wright. </author> <title> Abstract data types as initial algebras and correctness of data representations. </title> <booktitle> In Proceedings of the Conference on Computer Graphics, Pattern Recognition, & Data Structures, </booktitle> <pages> pp. 89-93, </pages> <month> May </month> <year> 1975. </year>
Reference-contexts: Under these assumptions, reasoning about partial functions is as simple and elegant as reasoning about total functions. 8.2 Specifications with Applicability Conditions The algebraic specification method for abstract data types as introduced in <ref> [5, 25, 4] </ref> involves giving the syntactic specification (signature) of operations (function symbols) of the data type and a finite set of equations (or conditional equations) relating different sequences of operations to express the semantics of the operations. All operations are assumed to be total functions.
Reference: [5] <author> J. V. Guttag. </author> <title> The Specification and Application to Programming of Abstract Data Types, </title> <type> Ph.D. thesis, </type> <institution> CSRG-59, Department of Computer Science, University of Toronto, Toronto, Canada, </institution> <year> 1975. </year>
Reference-contexts: Under these assumptions, reasoning about partial functions is as simple and elegant as reasoning about total functions. 8.2 Specifications with Applicability Conditions The algebraic specification method for abstract data types as introduced in <ref> [5, 25, 4] </ref> involves giving the syntactic specification (signature) of operations (function symbols) of the data type and a finite set of equations (or conditional equations) relating different sequences of operations to express the semantics of the operations. All operations are assumed to be total functions.
Reference: [6] <author> J. V. Guttag. </author> <title> Notes on type abstractions. </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> SE-6(1):13-23, </volume> <year> 1980. </year>
Reference-contexts: In [9], an approach for showing 186 Chapter 8 correctness of implementations with respect to such specifications is discussed based on partial algebras and partial homomorphism. The approach appears to be quite complicated and not easy to automate. In <ref> [6] </ref> and [10], preconditions on nonconstructors are used to specify their exceptional behavior. In this article we have proposed the use of an applicability condition to characterize the subdomain of inputs on which the function behavior is of interest.
Reference: [7] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 4 </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: A data structure can be specified by using the so-called abstract model approach proposed in <ref> [7] </ref>, in which constructors and nonconstructors can have nontrivial preconditions. It is unclear how preconditions can be used to efficiently and mechanically reason about the interaction among the operations of the data structure when they are used for defining algorithms such as Batcher's merge sort (the function pbm).
Reference: [8] <author> I. V. Horebeek and J. Lewi. </author> <title> Algebraic Specifications in Software Engineering. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: All operations are assumed to be total functions. This approach is well studied, and several books explain the approach with numerous examples <ref> [2, 8] </ref>. For simplicity, it is assumed below that a specification defines a single abstract data type, called D, in a bottom-up hierarchical manner, using other data types already defined elsewhere.
Reference: [9] <author> S. Kamin and M. Archer. </author> <title> Partial implementation of abstract data types: A dissenting view on errors. </title> <editor> In G. Kahn, D. B. MacQueen, and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types, </booktitle> <pages> pp. 317-336, </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 173, </volume> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: It is unclear how preconditions can be used to efficiently and mechanically reason about the interaction among the operations of the data structure when they are used for defining algorithms such as Batcher's merge sort (the function pbm). In <ref> [9] </ref>, an approach for showing 186 Chapter 8 correctness of implementations with respect to such specifications is discussed based on partial algebras and partial homomorphism. The approach appears to be quite complicated and not easy to automate.
Reference: [10] <author> D. Kapur. </author> <title> Towards a Theory for Data Abstractions. </title> <type> Technical Report TR-237, </type> <institution> MIT LCS, </institution> <year> 1980. </year>
Reference-contexts: In [9], an approach for showing 186 Chapter 8 correctness of implementations with respect to such specifications is discussed based on partial algebras and partial homomorphism. The approach appears to be quite complicated and not easy to automate. In [6] and <ref> [10] </ref>, preconditions on nonconstructors are used to specify their exceptional behavior. In this article we have proposed the use of an applicability condition to characterize the subdomain of inputs on which the function behavior is of interest.
Reference: [11] <author> D. Kapur. </author> <title> An automatic tool for analyzing completeness of equational specifications. </title> <booktitle> In Proceedings of ISSTA 94, </booktitle> <address> Seattle, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: Because of the recursive call to zip on the right side of Equation 4, x and u must have the same length. Hence, Equation 4 indeed covers the case of powerlists of equal length &gt; 1. In <ref> [11] </ref>, a method for checking completeness of function definitions with applicability conditions is discussed. Using this method, one can distinguish intentional incompleteness (as is the case here) from omissions of cases due to mistakes and/or oversight. One can prove that all the definitions in the specifications given here are complete.
Reference: [12] <author> D. Kapur. </author> <title> Mechanizing induction. </title> <booktitle> In Proceedings of the National Seminar on Theoretical Computer Science (NSTCS), </booktitle> <pages> pp. 214-242, </pages> <address> Bombay, India, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: The method works for constructor-based definitions also. Below, an informal overview of the cover set method is given, focusing on how it can be extended to consider definitions given using context-preserving terminating rewrite rules. More details about the cover set method can be found in <ref> [24, 17, 16, 12] </ref>. A cover set C for a function symbol f with a complete definition D, consisting of a finite set of terminating rewrite rules, is a finite set of triples. Each triple in C is derived from a rewrite rule in D. <p> To prove a simple property leq (minp (x; y); maxp (x; y)); the heuristics in RRL would pick a cover set generated from the definition of minp (or maxp, since they are the same). 6 The definition of an induction scheme generated from a cover set given in <ref> [16, 12] </ref> is more general; it includes the position of the subterm f (x 1 ; ; x k ) in C as well as replacements for the subterm in the induction conclusion and the induction hypotheses.
Reference: [13] <author> D. Kapur. </author> <title> Partial data types. Manuscript in preparation, </title> <institution> Department of Computer Science, State University of New York, Albany. </institution>
Reference-contexts: In a companion paper, semantical considerations of the proposed approach will be discussed <ref> [13] </ref>. Treatment of partial function symbols in the framework of algebraic specification methods has been a source of considerable technical difficulty. <p> We do not include a discussion of semantical issues|particularly, proof theoretic and model theoretic semantics of specifications with applicability conditions; they will be considered in <ref> [13] </ref>. In the next subsection, we briefly review how specifications developed with the proposed approach have been used for reasoning about data-parallel algorithms and hardware descriptions. <p> The denotation of a function symbol in the model is a minimally defined function (that is, a function is undefined on an input unless the specification requires it to be defined). A detailed semantics will be given in <ref> [13] </ref>. Most important, it is demonstrated in [14, 15] how rewrite-rule-based provers such as RRL developed for total algebras can be extended to reason about partial algebras efficiently if axioms can be oriented into context-preserving rewrite rules. <p> Constructors Can Be Partial, Too 191 8.3 Equational Reasoning Using Rewrite Rules Below, we briefly review an equational calculus with implicit contexts; more details will be given in <ref> [13] </ref>. Most of the inference rules are the same as in the classical equational calculus, except that for transitivity, one needs to be careful, as explained below. <p> The model (s) of interest is the minimal model generated using the constructors of the data type. Even in the presence of nontrivial applicability conditions, such a model can be incrementally constructed insofar as the applicability conditions are expressed acyclically. A detailed construction will be given in <ref> [13] </ref>. Here we briefly illustrate the construction for flat powerlists. Powerlists are constructed incrementally using s and tie, but since tie uses length in its applicability condition, a model is constructed by successively approximating the denotations of s, tie, and length. The denotation of length is defined on singleton powerlists.
Reference: [14] <author> D. Kapur and M. Subramaniam. </author> <title> Automated reasoning about parallel algorithms using pow-erlists. </title> <editor> In V. S. Alagar, editor, </editor> <booktitle> Proceedings of AMAST, </booktitle> <pages> pp. 416-430, </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 936, </volume> <publisher> Springer-Verlag, </publisher> <year> 1995, </year>
Reference-contexts: For instance, complete binary trees can be defined as a subsort of binary trees, and powerlists as well as sorted lists can be defined as subsorts of lists. For reasoning about algorithmic descriptions using such data structures, it then becomes necessary to explicitly carry subsort conditions. As shown in <ref> [14] </ref>, this approach makes reasoning about them cumbersome, and the resulting proofs get complex. It is argued in this article that regularity should be exploited while reasoning about specifications based on regular data structures (see also [20]). <p> Interestingly, these mechanically generated proofs turn out to be similar to carefully handcrafted proofs reported in [20, 1]; for details, see <ref> [14, 15] </ref>. 8.1.2 An Example of a "Semantic" Data Structure As an example of a "semantic" data structure, consider specifying sorted lists of items, where the items admit a total ordering. <p> In <ref> [14, 15] </ref>, it is shown how reasoning by using context-preserving rewrite rules can be supported in RRL. Mechanically generated proofs using RRL about properties of algorithmic and hardware descriptions of powerlists are discussed. <p> In [14, 15], it is shown how reasoning by using context-preserving rewrite rules can be supported in RRL. Mechanically generated proofs using RRL about properties of algorithmic and hardware descriptions of powerlists are discussed. In <ref> [14] </ref>, two different approaches for specifying powerlists 2 are contrasted with the proposed approach from the perspective of the nature of mechanically generated proofs (i.e., 2 These specifications of flat powerlists are included in Appendix B. <p> The denotation of a function symbol in the model is a minimally defined function (that is, a function is undefined on an input unless the specification requires it to be defined). A detailed semantics will be given in [13]. Most important, it is demonstrated in <ref> [14, 15] </ref> how rewrite-rule-based provers such as RRL developed for total algebras can be extended to reason about partial algebras efficiently if axioms can be oriented into context-preserving rewrite rules. Automated induction methods and heuristics Constructors Can Be Partial, Too 187 generalize to work on partial algebras. <p> Constructors Can Be Partial, Too 189 rules. In proofs by induction also, fewer cases need to be considered when functions are defined using terminating unconditional rewrite rules <ref> [24, 17, 14] </ref>. In the next section, we discuss a rewrite-rule-based approach for reasoning using equations with implicit contexts. If a data type such as powerlists is modeled as a subsort, conditional equations have to be used. <p> In <ref> [14, 15] </ref>, many such examples are discussed. Several properties of recursively defined functions on powerlists are proved using rewriting and the cover set induction method. These properties are then used to prove the correctness of Batcher's merge sort algorithm (the function pbm in the above specification). <p> These properties are then used to prove the correctness of Batcher's merge sort algorithm (the function pbm in the above specification). Using the specification of nested powerlists given in Appendix C for modeling multidimensional arrays, we discussed in <ref> [14] </ref> the design and verification of a transformation to embed a multidimensional array into a hypercube such that the embedding function preserves the adjacency of elements in the array in the hypercube. <p> The approach has been implemented in our theorem prover RRL for equational and inductive reasoning, and it has been used effectively to reason about the properties of many data parallel programs including FFT and Batcher's merge sort <ref> [14] </ref>, as well as hardware descriptions including adders [15]. Mechanical proofs generated by RRL are compact and simple and|surprisingly|closely mimic the handcrafted proofs reported in [20, 1]. Many issues related to specification with applicability condition still need to be further investigated. <p> Nevertheless, these extra conditions lead to long and tedious proofs with many cases. Proofs by induction are done using the 206 Chapter 8 constructors of lists, instead of those of powerlists. See <ref> [14] </ref> for more details about proofs done using this specification. A simple order-sorted specification [23] of powerlists would perhaps be similar to the above specification. Another possible way is to define infinitely many subsorts of lists by parameterizing subsorts by the length of lists. <p> The reader will again notice the use of conditions expressed using length for defining zip, minp, etc., on nonsingleton powerlists. This was our second attempt at axiomatization of powerlists before we developed the approach discussed in this paper. In <ref> [14] </ref>, different proofs of the property of the rev function on powerlists are discussed for an illustrative comparison using each of the above three formalizations on RRL. The first formalization using applicability conditions leads to a simple proof on RRL involving two cases. <p> Such reductions in proof lengths are typical. The factor of reduction in cases to be considered goes up for nontrivial function definitions given in terms of other function definitions. Using the proofs of the correctness of the pbm function as well, it is shown in <ref> [14] </ref> that elegant and compact proofs, very similar to carefully hand-crafted proofs reported in [20], can be generated using RRL from specifications expressed using applicability conditions and implicit contexts. <p> At every level, it must be stated that all elements in the list are similar, that is, they are of the same depth d and same length 2 k , for some d and k. In <ref> [14] </ref>, we discuss a mechanically generated proof, using RRL, of the property that the embedding transformation defined in [20, 19] from a multidimensional array of dimensions that are powers of 2 to a hypercube preserves adjacency of neighbors in the array.
Reference: [15] <author> D. Kapur and M. Subramaniam. </author> <title> Mechanical verification of adder circuits using powerlists. </title> <journal> J. </journal> <note> Formal Methods in System Design (to appear). </note>
Reference-contexts: Interestingly, these mechanically generated proofs turn out to be similar to carefully handcrafted proofs reported in [20, 1]; for details, see <ref> [14, 15] </ref>. 8.1.2 An Example of a "Semantic" Data Structure As an example of a "semantic" data structure, consider specifying sorted lists of items, where the items admit a total ordering. <p> In <ref> [14, 15] </ref>, it is shown how reasoning by using context-preserving rewrite rules can be supported in RRL. Mechanically generated proofs using RRL about properties of algorithmic and hardware descriptions of powerlists are discussed. <p> The denotation of a function symbol in the model is a minimally defined function (that is, a function is undefined on an input unless the specification requires it to be defined). A detailed semantics will be given in [13]. Most important, it is demonstrated in <ref> [14, 15] </ref> how rewrite-rule-based provers such as RRL developed for total algebras can be extended to reason about partial algebras efficiently if axioms can be oriented into context-preserving rewrite rules. Automated induction methods and heuristics Constructors Can Be Partial, Too 187 generalize to work on partial algebras. <p> In <ref> [14, 15] </ref>, many such examples are discussed. Several properties of recursively defined functions on powerlists are proved using rewriting and the cover set induction method. These properties are then used to prove the correctness of Batcher's merge sort algorithm (the function pbm in the above specification). <p> In <ref> [15] </ref>, carry look-ahead adders and ripple carry adders on bit vectors of size 2 k are described using powerlists; their behavior correctness (i.e., they indeed compute addition on numbers) is mechanically established using RRL. <p> The approach has been implemented in our theorem prover RRL for equational and inductive reasoning, and it has been used effectively to reason about the properties of many data parallel programs including FFT and Batcher's merge sort [14], as well as hardware descriptions including adders <ref> [15] </ref>. Mechanical proofs generated by RRL are compact and simple and|surprisingly|closely mimic the handcrafted proofs reported in [20, 1]. Many issues related to specification with applicability condition still need to be further investigated.
Reference: [16] <author> D. Kapur and M. Subramaniam. </author> <title> New Uses of Linear Arithmetic in Automated Theorem Proving for Induction. </title> <journal> J. Automated Reasoning, </journal> <volume> 16(1-2):39-78, </volume> <year> 1996. </year>
Reference-contexts: The method works for constructor-based definitions also. Below, an informal overview of the cover set method is given, focusing on how it can be extended to consider definitions given using context-preserving terminating rewrite rules. More details about the cover set method can be found in <ref> [24, 17, 16, 12] </ref>. A cover set C for a function symbol f with a complete definition D, consisting of a finite set of terminating rewrite rules, is a finite set of triples. Each triple in C is derived from a rewrite rule in D. <p> To prove a simple property leq (minp (x; y); maxp (x; y)); the heuristics in RRL would pick a cover set generated from the definition of minp (or maxp, since they are the same). 6 The definition of an induction scheme generated from a cover set given in <ref> [16, 12] </ref> is more general; it includes the position of the subterm f (x 1 ; ; x k ) in C as well as replacements for the subterm in the induction conclusion and the induction hypotheses.
Reference: [17] <author> D. Kapur and H. Zhang. </author> <title> An overview of Rewrite Rule Laboratory (RRL). </title> <journal> Computers and Math. with Applications, </journal> <volume> 29(2) </volume> <pages> 91-114, </pages> <year> 1995. </year>
Reference-contexts: A proof of the above conjecture can be done by induction under its context. Using the cover set method for automating induction <ref> [24, 17] </ref>, one can generate an induction scheme from the definition of minp. The basis case occurs when x = s (i1), y = s (j1),, which one can reduce to true using the rewrite rules in the definitions of leq and minp. <p> Many such proofs of properties of function definitions used in defining pbm as well as properties of pbm and other algorithms can be mechanically generated by RRL, Rewrite Rule Laboratory, a theorem prover mechanizing induction and equational reasoning using rewriting techniques <ref> [17] </ref>. <p> Constructors Can Be Partial, Too 189 rules. In proofs by induction also, fewer cases need to be considered when functions are defined using terminating unconditional rewrite rules <ref> [24, 17, 14] </ref>. In the next section, we discuss a rewrite-rule-based approach for reasoning using equations with implicit contexts. If a data type such as powerlists is modeled as a subsort, conditional equations have to be used. <p> Transitivity is required to use equations as rewrite rules. The concept of context-preserving rewrite rules is introduced. With context-preserving rewrite rules, it is possible to use term-rewriting-based methods, particularly, normalization and the cover set induction method, supported in RRL <ref> [17, 24] </ref>). Except for ensuring that a given goal has a consistent context, no additional overhead is involved while simplifying the goal by rewriting, since contexts of intermediate terms do not have to be stored, and 192 Chapter 8 intermediate contexts need not be checked for consistency. <p> RRL supports the cover set method for mechanizing inductive reasoning about functions defined on data structures <ref> [17, 24] </ref>. This method generalizes the structural induction method by allowing a well-founded termination ordering used for generating induction schemes. The method works for constructor-based definitions also. <p> The method works for constructor-based definitions also. Below, an informal overview of the cover set method is given, focusing on how it can be extended to consider definitions given using context-preserving terminating rewrite rules. More details about the cover set method can be found in <ref> [24, 17, 16, 12] </ref>. A cover set C for a function symbol f with a complete definition D, consisting of a finite set of terminating rewrite rules, is a finite set of triples. Each triple in C is derived from a rewrite rule in D.
Reference: [18] <author> D. Knuth. </author> <title> The Art of Computer Programming: Sorting and Searching, </title> <journal> vol. </journal> <volume> 3. </volume> <publisher> Addison Wesley, </publisher> <year> 1973. </year>
Reference: [19] <author> F. T. Leighton. </author> <title> Introduction to Parallel Algorithms and Architectures: Arrays. Trees. </title> <publisher> Hy-percubes. Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: Batcher's merge sort algorithm (the function pbm above) and a nontrivial transformation for embedding a multidimensional array into a hypercube such that adjacency among elements in the multidimensional array is preserved <ref> [20, 19] </ref> are used for illustration and comparison. An adjacency-preserving embedding transformation can be used to transform normal parallel algorithms operating on multidimensional arrays into equivalent parallel algorithms on a hypercube and other related architectures [19]. <p> An adjacency-preserving embedding transformation can be used to transform normal parallel algorithms operating on multidimensional arrays into equivalent parallel algorithms on a hypercube and other related architectures <ref> [19] </ref>. The use of applicability conditions and the ability to mechanical generate contexts result in elegant and compact specifications. <p> In [14], we discuss a mechanically generated proof, using RRL, of the property that the embedding transformation defined in <ref> [20, 19] </ref> from a multidimensional array of dimensions that are powers of 2 to a hypercube preserves adjacency of neighbors in the array. This property is useful in establishing a transformation from algorithms running on a multidimensional array of processors to a hypercube.
Reference: [20] <author> J. Misra, Powerlist: </author> <title> A structure for parallel recursion. In A Classical Mind: </title> <booktitle> Essays in Honor of C. </booktitle> <editor> A. R. Hoare, </editor> <publisher> Prentice-Hall, </publisher> <year> 1994. </year> <note> A revised version appeared in TOPLAS, </note> <month> 16(6) </month> <pages> 1737-1767, </pages> <year> 1994. </year>
Reference-contexts: 8.1 Introduction The behavior of regular aggregate data structures (for example, square matrices, complete binary trees, and powerlists <ref> [20] </ref>), as well as semantic data structures (for example, sorted lists and priority lists), cannot be captured elegantly by using existing specification techniques and languages such as Larch, Z, OBJ, VDM, or LOTOS. Typically such a data structure is defined as a subsort of a larger data structure. <p> As shown in [14], this approach makes reasoning about them cumbersome, and the resulting proofs get complex. It is argued in this article that regularity should be exploited while reasoning about specifications based on regular data structures (see also <ref> [20] </ref>). That does not seem to be possible if regular data structures are modeled using subsorts, perhaps because of incompatibility between regularity and subsorts. Instead of being a benefit, regularity becomes a burden. <p> Modeling regular data structures using subsorts leads to carrying conditions about the regular structure of the values of the data structure, resulting in complicated proofs and intricate reasoning. Constructors Can Be Partial, Too 179 8.1.1 Informal Overview of the Approach Using Powerlists Powerlists, a data structure introduced in <ref> [20] </ref>, will be used for illustration. Pow-erlists have been used to specify many data-parallel algorithms in [20], employing the divide-and-conquer strategy and recursion. <p> Constructors Can Be Partial, Too 179 8.1.1 Informal Overview of the Approach Using Powerlists Powerlists, a data structure introduced in <ref> [20] </ref>, will be used for illustration. Pow-erlists have been used to specify many data-parallel algorithms in [20], employing the divide-and-conquer strategy and recursion. They include Batcher's merge sort and fast Fourier transform, parallel prefix computation, and hardware architectures, as well as hardware circuits, including carry look-ahead and ripple carry adders [1]. <p> Such a rewrite rule is called context preserving. Below, we reproduce more function definitions on powerlists from <ref> [20] </ref>; they are needed to define Batcher's merge sort pbm recursively. As the definition of pbm below illustrates, the use of powerlists results in concise and elegant specifications. <p> Interestingly, these mechanically generated proofs turn out to be similar to carefully handcrafted proofs reported in <ref> [20, 1] </ref>; for details, see [14, 15]. 8.1.2 An Example of a "Semantic" Data Structure As an example of a "semantic" data structure, consider specifying sorted lists of items, where the items admit a total ordering. <p> Batcher's merge sort algorithm (the function pbm above) and a nontrivial transformation for embedding a multidimensional array into a hypercube such that adjacency among elements in the multidimensional array is preserved <ref> [20, 19] </ref> are used for illustration and comparison. An adjacency-preserving embedding transformation can be used to transform normal parallel algorithms operating on multidimensional arrays into equivalent parallel algorithms on a hypercube and other related architectures [19]. <p> Proofs generated from specifications expressed using applicability conditions are easier to generate, understand, and present, in contrast to proofs generated from specifications using other methods. Many of the mechanically generated proofs of properties of algorithms on powerlists, for instance, are similar to the well-handcrafted proofs reported in <ref> [20, 1] </ref>. 8.1.4 Related Work The applicability condition of an operation can also be thought of as a precondition a la Floyd and Hoare's axiomatic method. <p> Mechanical proofs generated by RRL are compact and simple and|surprisingly|closely mimic the handcrafted proofs reported in <ref> [20, 1] </ref>. Many issues related to specification with applicability condition still need to be further investigated. Identifying (speculating) lemmas that would be useful for establishing that rules are context preserving is an interesting challenge. <p> Using the proofs of the correctness of the pbm function as well, it is shown in [14] that elegant and compact proofs, very similar to carefully hand-crafted proofs reported in <ref> [20] </ref>, can be generated using RRL from specifications expressed using applicability conditions and implicit contexts. Doing these proofs about the properties of pbm using the above two axiomatization instead leads to complicated and long proofs with many cases that can be avoided using implicit contexts. <p> Appendix C: A Specification of Nested Powerlists To exhibit the expressive power and elegance of our specification method, we extend the specification of flat powerlists using applicability conditions to axiomatize nested powerlists. Nested powerlists are used in <ref> [20] </ref> to model multidimensional arrays. An additional constructor, n, stands for nesting. The applicability condition is changed from length (u) = length (v) to similar (u, v). <p> In [14], we discuss a mechanically generated proof, using RRL, of the property that the embedding transformation defined in <ref> [20, 19] </ref> from a multidimensional array of dimensions that are powers of 2 to a hypercube preserves adjacency of neighbors in the array. This property is useful in establishing a transformation from algorithms running on a multidimensional array of processors to a hypercube.
Reference: [21] <author> P. D. Mosses. </author> <title> The use of sorts in algebraic specifications. </title> <editor> In M. Bidoit and C. Choppy, editors, </editor> <booktitle> Recent Trends in Data Type Specifications, </booktitle> <pages> pp. 66-91, </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 655, </volume> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In a companion paper, semantical considerations of the proposed approach will be discussed [13]. Treatment of partial function symbols in the framework of algebraic specification methods has been a source of considerable technical difficulty. Many different approaches have been proposed in the literature (see <ref> [21] </ref> for a survey as well as the subsection on related work below), in which the focus has been mostly on theoretical issues such as initiality and uniqueness of models, consistency of implementations with respect to a specification, and capturing the exceptional behavioral of operations as supported in a programming language. <p> We have not considered the specification of exceptional behavior; the proposed approach can be extended to specify exceptional behavior also by associating a precondition with a function for specifying exceptional behavior, and an applicability condition for specifying intentional partiality. Mosses <ref> [21] </ref> surveyed numerous extensions to the algebraic specification approach for handling sorts and subsorts, exceptions, partial operations, etc.; notable among these extensions are error algebras, exceptional algebras, partial algebras, hierarchical specifications, and order-sorted specifications. <p> This approach also gives a nice way to reason about partial functions using standard term rewriting methods without extensive modifications to the theorem prover RRL. Axiomatization of partial functions and mechanically reasoning about them have been a source of considerable technical difficulty <ref> [21, 22] </ref>. 8.3.1 Context-Preserving Rules Unconditional equations can be manipulated as rewrite rules whenever it is possible to orient them using termination orderings [3]. This is the way reasoning about equations is automated in RRL.
Reference: [22] <author> H. Reichel. </author> <title> Initial Computability, Algebraic Specifications and Partial Algebras. </title> <publisher> Oxford Univ. Press, </publisher> <year> 1987. </year>
Reference-contexts: In doing proofs of properties of algorithms on sorted lists, conditions about sortedness would have to be explicitly included. Many other examples of data structures exist for which it is meaningful for constructors to be partial, for instance, matrices in linear algebra and geometric constructions. See <ref> [22] </ref> for additional examples. In the rest of the article, we formalize the concepts of applicability conditions, contexts, and context-preserving rewrite rules, and we propose a reasoning calculus for equations with implicit contexts and its mechanization. <p> None of these extensions appears to model, elegantly and adequately, regular data structures such as pow-erlists and complete binary trees because such structural information needs to be specified semantically. Methods for reasoning about specifications expressed using these approaches have yet to be explored and automated. The approach discussed in <ref> [22] </ref> based on partial algebras appears to be the most closely related to our proposed approach. However, Reichel's approach seems to be complicated because of its attempts to develop a theory analogous to the initial algebra semantics for total algebras. <p> This approach also gives a nice way to reason about partial functions using standard term rewriting methods without extensive modifications to the theorem prover RRL. Axiomatization of partial functions and mechanically reasoning about them have been a source of considerable technical difficulty <ref> [21, 22] </ref>. 8.3.1 Context-Preserving Rules Unconditional equations can be manipulated as rewrite rules whenever it is possible to orient them using termination orderings [3]. This is the way reasoning about equations is automated in RRL.
Reference: [23] <author> G. Smolka, W. Nutt, J. A. Goguen, and J. Mesaguer. </author> <title> Order-sorted equational computation. </title> <editor> In H. Ait-Kaci and M. Nivat, editors, </editor> <booktitle> Resolution of Equations in Algebraic Structures 2, </booktitle> <pages> pp. 299-367, </pages> <publisher> Academic Press, </publisher> <year> 1989. </year> <note> 210 Chapter 8 </note>
Reference-contexts: Nevertheless, these extra conditions lead to long and tedious proofs with many cases. Proofs by induction are done using the 206 Chapter 8 constructors of lists, instead of those of powerlists. See [14] for more details about proofs done using this specification. A simple order-sorted specification <ref> [23] </ref> of powerlists would perhaps be similar to the above specification. Another possible way is to define infinitely many subsorts of lists by parameterizing subsorts by the length of lists.
Reference: [24] <author> H. Zhang, D. Kapur, and M. S. Krishnamoorthy. </author> <title> A mechanizable induction principle for equational specifications. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proceedings of the 9th International Conference on Automated Deduction, </booktitle> <pages> pp. 250-265, </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 310, </volume> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: A proof of the above conjecture can be done by induction under its context. Using the cover set method for automating induction <ref> [24, 17] </ref>, one can generate an induction scheme from the definition of minp. The basis case occurs when x = s (i1), y = s (j1),, which one can reduce to true using the rewrite rules in the definitions of leq and minp. <p> Constructors Can Be Partial, Too 189 rules. In proofs by induction also, fewer cases need to be considered when functions are defined using terminating unconditional rewrite rules <ref> [24, 17, 14] </ref>. In the next section, we discuss a rewrite-rule-based approach for reasoning using equations with implicit contexts. If a data type such as powerlists is modeled as a subsort, conditional equations have to be used. <p> Transitivity is required to use equations as rewrite rules. The concept of context-preserving rewrite rules is introduced. With context-preserving rewrite rules, it is possible to use term-rewriting-based methods, particularly, normalization and the cover set induction method, supported in RRL <ref> [17, 24] </ref>). Except for ensuring that a given goal has a consistent context, no additional overhead is involved while simplifying the goal by rewriting, since contexts of intermediate terms do not have to be stored, and 192 Chapter 8 intermediate contexts need not be checked for consistency. <p> RRL supports the cover set method for mechanizing inductive reasoning about functions defined on data structures <ref> [17, 24] </ref>. This method generalizes the structural induction method by allowing a well-founded termination ordering used for generating induction schemes. The method works for constructor-based definitions also. <p> The method works for constructor-based definitions also. Below, an informal overview of the cover set method is given, focusing on how it can be extended to consider definitions given using context-preserving terminating rewrite rules. More details about the cover set method can be found in <ref> [24, 17, 16, 12] </ref>. A cover set C for a function symbol f with a complete definition D, consisting of a finite set of terminating rewrite rules, is a finite set of triples. Each triple in C is derived from a rewrite rule in D. <p> The cover set method has been successfully used to prove many nontrivial theorems by induction on numbers, lists, sequences, arrays, and other recursive data structures <ref> [24] </ref>. The cover set method can be extended to be applicable to function definitions given using context-preserving rewrite rules (with implicit contexts).

References-found: 24

