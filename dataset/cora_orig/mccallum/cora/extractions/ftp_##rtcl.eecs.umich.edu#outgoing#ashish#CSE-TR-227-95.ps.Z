URL: ftp://rtcl.eecs.umich.edu/outgoing/ashish/CSE-TR-227-95.ps.Z
Refering-URL: http://www.eecs.umich.edu/~ashish/
Root-URL: http://www.cs.umich.edu
Email: E-mail: fashish, jrexford, anghs, farnamg@eecs.umich.edu  
Title: Design and Evaluation of a Window-Consistent Replication Service  
Author: Ashish Mehra, Jennifer Rexford, Hock-Siong Ang and Farnam Jahanian 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Real-Time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: Real-time applications typically operate under strict timing and dependability constraints. Although traditional data replication protocols provide fault tolerance, real-time guarantees require bounded overhead for managing this redundancy. When time is scarce and the overhead for managing redundancy is too high, alternative approaches must balance the trade-off between timing predictability and fault tolerance. This paper presents the design and evaluation of a window-consistent primary-backup replication service that provides timely availability of the repository by relaxing the consistency of the replicated data. A client application registers an object with the service by declaring the consistency requirements for the data, in terms of a time window. The primary ensures that each backup site maintains a version of the object that was valid on the primary within the preceding time window. The primary delivers timely service to clients by decoupling the transmission of updates to the backup from the processing of client requests. Real-time scheduling of update messages can guarantee controlled inconsistency between the primary and backup repositories. This ensures that client applications interact with a window-consistent repository when the backup must supplant a failed primary. Our prototype implementation demonstrates the utility of the window-consistent replication model. Experimental results show that the service handles a range of client loads while maintaining bounds on objects' temporal inconsistency.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Rexford, A. Mehra, J. Dolter, and F. Jahanian, </author> <title> "Window-consistent replication for real-time applications," </title> <booktitle> in Proc. Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pp. 107-111, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: This paper presents the design and implementation of a data replication service that combines fault-tolerant protocols, real-time scheduling, and temporal consistency semantics to accommodate such system requirements <ref> [1] </ref>. A client application registers a data object with the service by declaring the consistency requirements for the data, in terms of a time window.
Reference: [2] <author> F. B. Schneider, </author> <title> "Implementing fault-tolerant services using the state machine approach: A tutorial," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 22, no. 4, </volume> <pages> pp. 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: The two main approaches for structuring fault-tolerant servers are active and passive replication. In active (state-machine) replication schemes <ref> [2, 3] </ref>, a collection of identical servers maintains copies of the system state. Client updates are applied atomically to all of the replicas so that after detecting a server failure, the remaining servers continue the service.
Reference: [3] <author> K. P. Birman and T. A. Joseph, </author> <title> "Reliable communication in the presence of failures," </title> <journal> ACM Trans. Computer Systems, </journal> <volume> vol. 5, no. 1, </volume> <pages> pp. 47-76, </pages> <year> 1987. </year> <month> 17 </month>
Reference-contexts: The two main approaches for structuring fault-tolerant servers are active and passive replication. In active (state-machine) replication schemes <ref> [2, 3] </ref>, a collection of identical servers maintains copies of the system state. Client updates are applied atomically to all of the replicas so that after detecting a server failure, the remaining servers continue the service.
Reference: [4] <author> P. Alsberg and J. Day, </author> <title> "A principle for resilient sharing of distributed resources," </title> <booktitle> in Proc. IEEE Int'l Conf. on Software Engineering, </booktitle> <address> Los Angeles, </address> <year> 1976. </year>
Reference-contexts: In active (state-machine) replication schemes [2, 3], a collection of identical servers maintains copies of the system state. Client updates are applied atomically to all of the replicas so that after detecting a server failure, the remaining servers continue the service. Passive (primary-backup) replication <ref> [4, 5] </ref>, on the other hand, distinguishes one replica as the primary server, which handles all client requests. A modify operation at the primary invokes the transmission of an update message to the backup servers.
Reference: [5] <author> N. Budhiraja, K. Marzullo, F. B. Schneider, and S. Toueg, </author> <title> "Primary-backup protocols: Lower bounds and optimal implementations," </title> <booktitle> in Proc. IFIP Working Conference on Dependable Computing, </booktitle> <pages> pp. 187-198, </pages> <year> 1992. </year>
Reference-contexts: In active (state-machine) replication schemes [2, 3], a collection of identical servers maintains copies of the system state. Client updates are applied atomically to all of the replicas so that after detecting a server failure, the remaining servers continue the service. Passive (primary-backup) replication <ref> [4, 5] </ref>, on the other hand, distinguishes one replica as the primary server, which handles all client requests. A modify operation at the primary invokes the transmission of an update message to the backup servers.
Reference: [6] <author> F. Cristian, B. Dancy, and J. Dehn, </author> <title> "Fault-tolerance in the advanced automation system," </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 6-17, </pages> <month> June </month> <year> 1990. </year>
Reference: [7] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting, </author> <title> "Consul: A communication substrate for fault-tolerant distributed programs," </title> <type> Technical Report 91-32, </type> <institution> University of Arizona, </institution> <month> November </month> <year> 1991. </year>
Reference: [8] <author> K. P. Birman, </author> <title> "The process group approach to reliable distributed computing," </title> <journal> Communications of the ACM, </journal> <volume> vol. 36, no. 12, </volume> <pages> pp. 37-53, </pages> <month> December </month> <year> 1993. </year>
Reference: [9] <author> J. F. Bartlett, </author> <title> "A NonStop kernel," </title> <booktitle> in Proc. ACM Symp. on Operating Systems Principles, </booktitle> <year> 1981. </year>
Reference-contexts: A modify operation at the primary invokes the transmission of an update message to the backup servers. If the primary fails, a failover occurs and one of the backups becomes the new primary. In recent years, several fault-tolerant distributed systems have employed state-machine [6-8] or primary-backup <ref> [9, 10] </ref> replication. In general, passive replication schemes have longer recovery delays since a backup must invoke an explicit recovery algorithm to replace a failed primary.
Reference: [10] <author> A. Bhide, E. N. Elnozahy, and S. P. Morgan, </author> <title> "A highly available network file server," </title> <booktitle> in Winter USENIX Conference, </booktitle> <pages> pp. 199-205, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: A modify operation at the primary invokes the transmission of an update message to the backup servers. If the primary fails, a failover occurs and one of the backups becomes the new primary. In recent years, several fault-tolerant distributed systems have employed state-machine [6-8] or primary-backup <ref> [9, 10] </ref> replication. In general, passive replication schemes have longer recovery delays since a backup must invoke an explicit recovery algorithm to replace a failed primary.
Reference: [11] <author> H. Kopetz, A. Damm, C. Koza, M. Mulazzani, W. Schwabl, C. Senft, and R. Zainlinger, </author> <title> "Distributed fault-tolerant real-time systems: The MARS approach," </title> <booktitle> IEEE Micro, </booktitle> <pages> pp. 25-40, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: The overhead associated with managing redundancy must be quantified precisely for the system to satisfy real-time constraints. Several recent experimental projects have begun to address replication in distributed hard real-time systems, most notably the MARS <ref> [11] </ref> and Delta-4 XPA [12] projects. A fault-tolerant unit in a MARS system consists of a collection of replicated components operating in active redundancy.
Reference: [12] <author> P. Verissimo, P. Barrett, P. Bond, A. Hilborne, L. Rodrigues, and D. Seaton, </author> <title> "The extra performance architecture (XPA)," in Delta-4 A Generic Architecture for Dependable Distributed Computing, </title> <editor> D. Powell, editor, </editor> <year> 1991. </year>
Reference-contexts: The overhead associated with managing redundancy must be quantified precisely for the system to satisfy real-time constraints. Several recent experimental projects have begun to address replication in distributed hard real-time systems, most notably the MARS [11] and Delta-4 XPA <ref> [12] </ref> projects. A fault-tolerant unit in a MARS system consists of a collection of replicated components operating in active redundancy. Each 3 component, consisting of a node and its application software, relies on a number of hardware and soft-ware mechanisms for error detection to ensure fail-silent behavior.
Reference: [13] <author> C. Pu and A. Leff, </author> <title> "Replica control in distributed systems: An asynchronous approach," </title> <booktitle> in Proc. ACM SIGMOD, </booktitle> <pages> pp. 377-386, </pages> <month> May </month> <year> 1991. </year>
Reference: [14] <author> T.-W. Kuo and A. K. Mok, </author> <title> "Ssp: a semantics-based protocol for real-time data access," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 76-86, </pages> <month> December </month> <year> 1993. </year>
Reference: [15] <author> K.-J. Lin, F. Jahanian, A. Jhingran, and C. D. Locke, </author> <title> "A model of hard real-time transaction systems," </title> <type> Technical Report RC 17515, </type> <institution> IBM T.J. Watson Reseach Center, </institution> <month> January </month> <year> 1992. </year>
Reference: [16] <author> H. F. Korth, N. Soparkar, and A. Silberschatz, </author> <title> "Triggered real time databases with consistency constraints," </title> <booktitle> in Proc. Int'l Conf. on Very Large Data Bases, </booktitle> <month> August </month> <year> 1990. </year>
Reference: [17] <author> S. B. Davidson and A. Watters, </author> <title> "Partial computation in real-time database systems," </title> <booktitle> in Proc. Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pp. 117-121, </pages> <month> May </month> <year> 1988. </year>
Reference: [18] <author> J. W. S. Liu, W.-K. Shih, and K.-J. Lin, </author> <title> "Imprecise computations," </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> vol. 82, no. 1, </volume> <pages> pp. 83-94, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: These relaxed criteria facilitate higher concurrency by permitting a limited amount of inconsistency in how a transaction views the database state. The idea of imprecise computation is an interesting related approach that sacrifices accuracy for timeliness in real-time computations <ref> [18] </ref>. This is particularly useful in real-time applications that use discrete samples of continuous-time variables. These values can be approximated or estimated when there is not sufficient time to compute an exact value. Imprecise computation supports a less accurate calculation to ensure that a real-time computation meets its timing constraints.
Reference: [19] <author> R. Alonso, D. Barbara, and H. Garcia-Molina, </author> <title> "Data caching issues in an information retrieval system," </title> <journal> ACM Trans. Database Systems, </journal> <volume> vol. 15, no. 3, </volume> <pages> pp. 359-384, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Similarly, the window-consistent replication service relaxes the temporal consistency among replicated objects to limit the overhead associated with replica management. Exploiting weak consistency to obtain better performance has also been considered in other non-real-time applications. For instance, the quasi-copy model <ref> [19] </ref> permits weak consistency between the central data and its cached copies at remote sites. This allows a cached copy to deviate from the central copy to give the scheduler more flexibility in propagating updates.
Reference: [20] <author> F. Cristian, </author> <title> "Understanding fault tolerant distributed systems," </title> <journal> Communications of the ACM, </journal> <volume> vol. 34, no. 2, </volume> <pages> pp. 56-78, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: In the absence of link (performance or crash) failures <ref> [20] </ref>, we assume a bound ` on the end-to-end communication latency within the service.
Reference: [21] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling algorithms for multiprogramming in a hard real-time environment," </title> <journal> Journal of the ACM, </journal> <volume> vol. 20, no. 1, </volume> <pages> pp. 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: In order to bound the temporal inconsistency within the service, it suffices that the primary send O i to the backups at least once every ffi i ` time units. While several task models can accommodate window-consistent scheduling, we initially consider the periodic task model <ref> [21, 22] </ref>. 6 4.1 Periodic Scheduling of Updates The transmissions of updates can be cast as "tasks" that run periodically with deadlines derived from the window-consistency requirements of the corresponding objects. <p> The scheduler always runs the ready task with the highest priority, preempting execution if a higher-priority task arrives. For example, rate-monotonic scheduling statically assigns higher priority to tasks with shorter periods <ref> [21, 22] </ref>, while earliest-due-date scheduling favors tasks with earlier deadlines [21]. The scheduling algorithm, coupled with the object parameters e i and ffi i , determines a schedulability criterion based on the total processor and network utilization. The schedulability criterion governs object admission into the replication service. <p> The scheduler always runs the ready task with the highest priority, preempting execution if a higher-priority task arrives. For example, rate-monotonic scheduling statically assigns higher priority to tasks with shorter periods [21, 22], while earliest-due-date scheduling favors tasks with earlier deadlines <ref> [21] </ref>. The scheduling algorithm, coupled with the object parameters e i and ffi i , determines a schedulability criterion based on the total processor and network utilization. The schedulability criterion governs object admission into the replication service. <p> The scheduling algorithm maintains window consistency for all objects as long as the the collection of tasks does not exceed a certain bound on resource utilization (e.g., 0:69 for rate-monotonic and 1 for earliest-due-date) <ref> [21] </ref>. 4.2 Compressing the Periodic Schedule While the periodic model can guarantee sufficient updates for each object, the schedule updates O i only once per period p i , even if computation and network resources permit more frequent transmissions.
Reference: [22] <author> J. Lehoczky, L. Sha, and Y. Ding, </author> <title> "The rate monotonic scheduling algorithm: Exact characterization and average case behavior," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 166-171. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: In order to bound the temporal inconsistency within the service, it suffices that the primary send O i to the backups at least once every ffi i ` time units. While several task models can accommodate window-consistent scheduling, we initially consider the periodic task model <ref> [21, 22] </ref>. 6 4.1 Periodic Scheduling of Updates The transmissions of updates can be cast as "tasks" that run periodically with deadlines derived from the window-consistency requirements of the corresponding objects. <p> The scheduler always runs the ready task with the highest priority, preempting execution if a higher-priority task arrives. For example, rate-monotonic scheduling statically assigns higher priority to tasks with shorter periods <ref> [21, 22] </ref>, while earliest-due-date scheduling favors tasks with earlier deadlines [21]. The scheduling algorithm, coupled with the object parameters e i and ffi i , determines a schedulability criterion based on the total processor and network utilization. The schedulability criterion governs object admission into the replication service.
Reference: [23] <author> C. W. Mercer, J. Zelenka, and R. Rajkumar, </author> <title> "On predictable operating system protocol processing," </title> <type> Technical Report CMU-CS-94-165, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: Note that the schedule shown is only for processing and transmission of updates to the backups and does not include the processing of client read and write requests. We assume that the primary can reserve sufficient processing capacity for client requests through resource reservation <ref> [23] </ref>. While each update is sent as required in the major cycle of length 15, the schedule has 4 units of slack time. The replication service can capitalize on this slack time to improve the average temporal consistency of the backup objects.
Reference: [24] <author> J.-F. Paris, </author> <title> "Using volatile witnesses to extend the applicability of available copy protocols," </title> <booktitle> in Proc. Workshop on the Management of Replicated Data, </booktitle> <pages> pp. 30-33, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: When the system has multiple backups, the sites vote to select the valid primary. However, when the service includes only two sites, communication failures may cause each server to assume the other has failed. In this situation, the service may include a third-party "witness" <ref> [24] </ref> to select the primary site. This witness does not act as a primary or backup server, but casts the deciding vote in failure diagnosis.
Reference: [25] <author> G. Swaminathan, </author> <title> C++ Socket Classes, </title> <institution> University of Virginia, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Any client read/write requests and update acknowledgements are processed next, with priority given to client requests. Each server is currently a Sun SPARCstation running Solaris 1.1. The sites communicate over an Ethernet through UDP datagrams using the Socket++ library <ref> [25] </ref>, with extensions to the UNIX select call for priority-based access to the active sockets. At initialization, sockets are registered at the appropriate priority such that the socket for receiving client requests has a higher priority over that for receiving update acknowledgements from the backup.
Reference: [26] <author> C.-C. Han and K.-J. Lin, </author> <title> "Scheduling distance-constrained real-time tasks," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 300-308, </pages> <year> 1992. </year> <month> 18 </month>
Reference-contexts: We are exploring other scheduling algorithms, such as the distance-constrained task model <ref> [26] </ref> which assigns task priorities based on separation constraints, in terms of their implementation complexity and ability to accommodate dynamic creation/deletion of objects.
References-found: 26

