URL: http://charm.cs.uiuc.edu/version2/papers/CheckPointINTL95.ps
Refering-URL: http://charm.cs.uiuc.edu/version2/papers/CheckPointINTL95.html
Root-URL: http://www.cs.uiuc.edu
Email: email sanjeev@cs.uiuc.edu  email kale@cs.uiuc.edu  
Phone: Phone (217) 333-5827  Phone (217) 244-0094  
Title: Efficient, Language-Based Checkpointing for Massively Parallel Programs  
Author: Sanjeev Krishnan Laxmikant V. Kale 
Affiliation: Department of Computer Science, University of Illinois, Urbana-Champaign.  Department of Computer Science, University of Illinois, Urbana-Champaign.  
Abstract: Checkpointing and restart is an approach to ensuring forward progress of a program in spite of system failures or planned interruptions. We investigate issues in checkpointing and restart of programs running on massively parallel computers. We identify a new set of issues that have to be considered for the MPP platform, based on which we have designed an approach based on the language and run-time system. Hence our checkpointing facility can be used on virtually any parallel machine in a portable manner, irrespective of whether the operating system supports checkpointing. We present methods to make checkpointing and restart space- and time-efficient, including object-specific functions that save the state of an object. We present techniques to automatically generate checkpointing code for parallel objects, without programmer intervention. We also present mechanisms to allow the programmer to easily incorporate application specific knowledge selectively to make the checkpointing more efficient. The techniques developed here have been implemented in the Charm++ parallel object-oriented programming language and run-time system. Performance results are presented for the checkpointing overhead of programs 
Abstract-found: 1
Intro-found: 1
Reference: [AGKR94] <author> Joshua S. Auerbach, Ajei S. Gopal, Mark T. Kennedy, and James R. Russell. Concert/c: </author> <title> Supporting distributed programming with language extensions and a portable multiprotocol runtime. </title> <booktitle> In Proceedings of the International Conference on Distributed Computer Systems, </booktitle> <year> 1994. </year>
Reference-contexts: The C++ iostream library allows the programmer to define the "&lt;<" operator for saving and the "&gt;>" operator for restoring the object. Pack functions have also been used to transfer pointer-linked structures across processors in a private address space architecture. The Concert/C <ref> [AGKR94] </ref> system marshals pointer-linked structures by following pointers before sending them as remote procedure call parameters. However, 16 there seem to be few implementations which automatically generate the pack- and unpack-functions. Our compiler automatically generates these functions for all objects.
Reference: [BP93] <author> N. Bowen and D. Pradhan. </author> <title> Processor- and memory-based checkpoint and rollback recovery. </title> <booktitle> Computer, </booktitle> <month> February </month> <year> 1993. </year>
Reference-contexts: be checkpointed on one machine and then restarted on another, thereby making the resources of the second machine available to the program. 1.1 Checkpointing for massively parallel systems Although there has been extensive research into checkpointing and rollback recovery in the past few years in the context of distributed systems <ref> [KT87, BP93, Joh93] </ref>, some new issues have to be considered in the context of massively parallel systems : 1. Most massively parallel systems do not support checkpointing at the operating system or hardware level, leading application programmers to implement checkpointing in their appli cation, using existing OS mechanisms. 2.
Reference: [CL85] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots : Determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <month> February </month> <year> 1985. </year>
Reference-contexts: Moreover, a fault on one processor usually makes the whole system unusable. Hence it is sufficient to coordinate all the processors to attain a consistent parallel program state. We employ a coordination strategy having the same high level steps as in <ref> [CL85] </ref>. However, our algorithm is more general in that it does not assume that messages are received in the order in which they are sent. in a coordinated checkpoint are : 1. <p> Both these techniques are orthogonal to our techniques : all of them can be profitably combined to increase efficiency. There has been a lot of work on consistent or coordinated checkpointing algorithms, starting from Chandy and Lamport's algorithm <ref> [CL85] </ref>. Our coordination scheme is similar to theirs in requiring O (N 2 ) coordination messages in the worst case. However it can handle message order reversal.
Reference: [EJZ92] <author> E. Elzonahy, D. Johnson, and W. Zwaenepoel. </author> <title> The performance of consistent check-pointing. </title> <booktitle> In Proceedings of the 11th Symposium on Reliable Distributed Systems, Octo-ber 1992. </booktitle> <pages> 19 </pages>
Reference-contexts: Finally, there has been no previous work on the use of pack and unpack functions in the context of program state reduction for checkpointing. Performance studies of consistent checkpointing on a distributed system have shown the overhead to be low. In <ref> [EJZ92] </ref> two techniques that decrease checkpointing overhead are explored. Incremental checkpointing involves checkpointing only modified pages in memory.
Reference: [FRS + 91] <author> W. Fenton, B. Ramkumar, V.A. Saletore, A.B. Sinha, and L.V. Kale. </author> <title> Supporting machine independent programming on diverse parallel architectures. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <month> August </month> <year> 1991. </year>
Reference-contexts: There can be hundreds or thousands of chares on every processor. A chare type is like a C++ class, and contains data, functions and entry points, which are special functions where messages can be received. The Charm and Charm++ languages are supported by the Chare Kernel run-time system <ref> [FRS + 91] </ref>. Charm and Charm++ programs run without change on shared as well as private address space parallel computers. Currently, the platforms supported include the TMC CM-5, Intel Paragon, IBM SP-1, nCUBE/2, workstation networks, Sequent Symmetry and Encore Multimax.
Reference: [Joh93] <author> D. B. Johnson. </author> <title> Efficient transparent optimistic rollback recovery for distributed application programs. </title> <booktitle> In Proceedings of the 12th Symposium on Reliable Distributed Systems, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: be checkpointed on one machine and then restarted on another, thereby making the resources of the second machine available to the program. 1.1 Checkpointing for massively parallel systems Although there has been extensive research into checkpointing and rollback recovery in the past few years in the context of distributed systems <ref> [KT87, BP93, Joh93] </ref>, some new issues have to be considered in the context of massively parallel systems : 1. Most massively parallel systems do not support checkpointing at the operating system or hardware level, leading application programmers to implement checkpointing in their appli cation, using existing OS mechanisms. 2.
Reference: [Kal90] <author> L.V. Kale. </author> <title> The Chare Kernel parallel programming language and system. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <month> August </month> <year> 1990. </year>
Reference: [KK93] <author> L.V. Kale and Sanjeev Krishnan. </author> <title> Charm++ : A portable concurrent object oriented system based on C++. </title> <booktitle> In Proceedings of the Conference on Object Oriented Programmi ng Systems, Languages and Applications, </booktitle> <month> September </month> <year> 1993. </year> <note> (Also: Technical Report UIUCDCS-R-93-1796, </note> <month> March </month> <year> 1993, </year> <institution> University of Illinois, Urbana, IL. </institution>
Reference: [KK94] <author> Sanjeev Krishnan and L. V. Kale. </author> <title> Efficient, machine-independent checkpoint and restart for parallel programs. </title> <type> Technical Report 94-2, </type> <institution> Parallel Programming Laboratory, Department of Computer Science , University of Illinois, Urbana-Champaign, </institution> <year> 1994. </year>
Reference-contexts: For these experiments we used simple Unix blocking I/O with no optimizations, since our emphasis in this work was on reducing file size. 6 Previous work Plank and Li [PL94] have developed one of the only implementations of checkpointing on a mul-ticomputer. An earlier version of our work <ref> [KK94] </ref> was completed around the same time as their work. Their work is restricted to the Intel i860 platform; in contrast our checkpointing facility is completely portable. They have demonstrated that consistent or coordinated checkpointing is a viable strategy for multicomputers because I/O overhead dominates the coordination overhead.
Reference: [KT87] <author> R. Koo and S. Toueg. </author> <title> Checkpointing and rollback-recovery for distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> January </month> <year> 1987. </year>
Reference-contexts: be checkpointed on one machine and then restarted on another, thereby making the resources of the second machine available to the program. 1.1 Checkpointing for massively parallel systems Although there has been extensive research into checkpointing and rollback recovery in the past few years in the context of distributed systems <ref> [KT87, BP93, Joh93] </ref>, some new issues have to be considered in the context of massively parallel systems : 1. Most massively parallel systems do not support checkpointing at the operating system or hardware level, leading application programmers to implement checkpointing in their appli cation, using existing OS mechanisms. 2.
Reference: [LF90] <author> C. Jim Li and W. K. Fuchs. </author> <title> Catch: Compiler assisted techniques for checkpointing. </title> <booktitle> In Proceedings of the 20th International Symposium on Fault Tolerant Computing, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: There is no previous work in issues related to language-based checkpointing that we know 17 of. Also, little attention has been devoted to issues in using application information to make checkpointing efficient and easy to use. In <ref> [LF90] </ref> an adaptive checkpointing scheme is used where the position of the checkpoint can be set by the compiler depending on the size of the program state, in an attempt to decrease the size of the checkpoint file.
Reference: [LNP91] <author> K. Li, J. Naughton, and J. Plank. </author> <title> Checkpointing multicomputer applications. </title> <booktitle> In Proceedings of the 10th Symposium on Reliable Distributed Systems, </booktitle> <month> October </month> <year> 1991. </year> <month> 20 </month>
Reference-contexts: Moreover, they operate at the level of operating system pages. In our scheme, we checkpoint typed objects in the application, which allows more efficient techniques to be used. Incremental checkpointing ideas can also be incorporated at an object level, thus combining the benefits of both. In <ref> [LNP91] </ref> some issues in checkpointing multicomputer applications are surveyed. An efficient coordination algorithm is proposed for finding a consistent global state in which all messages are distinguished as being pre-checkpoint or post-checkpoint. For this the algorithm uses either tags in messages or checkpoint demarcation messages.
Reference: [PL94] <author> J. Plank and K. Li. </author> <title> Performance results of ickp a consistent checkpointer on the iPSC/860. </title> <booktitle> In Proceedings of the Scalable High Performance Computing Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: The I/O time was observed to be greater than 95% of the overhead for most runs. For these experiments we used simple Unix blocking I/O with no optimizations, since our emphasis in this work was on reducing file size. 6 Previous work Plank and Li <ref> [PL94] </ref> have developed one of the only implementations of checkpointing on a mul-ticomputer. An earlier version of our work [KK94] was completed around the same time as their work. Their work is restricted to the Intel i860 platform; in contrast our checkpointing facility is completely portable.
Reference: [SKR93] <author> Amitabh B. Sinha, L. V. Kale, and B. Ramkumar. </author> <title> A dynamic and adaptive quiescence detection algorithm. </title> <type> Technical Report 93-11, </type> <institution> Parallel Programming Laboratory, Department of Computer Science , University of Illinois, Urbana-Champaign, </institution> <year> 1993. </year> <month> 21 </month>
Reference-contexts: In the absence of low level support for clearing the network and if machine independence is desired, the processors need to wait till all messages in transit are received. A scalable quiescence detection algorithm <ref> [SKR93] </ref> is used to detect this. Since message-order reversal is possible, marker messages cannot be used to indicate that a channel is cleared. Hence the quiescence algorithm is based on counting the total number of messages sent and received over all processors.
References-found: 14

