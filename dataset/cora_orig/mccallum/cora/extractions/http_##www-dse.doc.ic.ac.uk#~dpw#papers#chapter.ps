URL: http://www-dse.doc.ic.ac.uk/~dpw/papers/chapter.ps
Refering-URL: http://outoften.doc.ic.ac.uk/projects/slurp/papers.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Towards an Operational Semantics and Proof of Type Soundness for Java  
Author: Sophia Drossopoulou and Susan Eisenbach 
Affiliation: Department of Computing Imperial College of Science, Technology and Medicine  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> M. Abadi and L. Cardelli. </author> <title> A Semantics of Object Types. </title> <booktitle> In LICS'94 Proceedings, </booktitle> <year> 1994. </year>
Reference-contexts: Java adopts the Smalltalk [14] approach whereby all object variables are implicitly pointers. Furthermore, although there are a large number of studies of the semantics of isolated programming language features or of minimal programming languages <ref> [1, 30, 32] </ref>, there have not been many studies of the formal semantics of actual programming languages. In addition, the interplay of features which are very well understood in isolation, might introduce unexpected effects. Experience confirms the importance of formal studies of type systems early on during language development. <p> Objects carry their classes (similar to the Smalltalk abstract machine [18]), thus we do not need store types <ref> [1] </ref>, or location typings [17]. Objects are labelled tuples, where each label contains the class in which it was declared. Array values are tuples too, and they are annotated by their type and their dimension. There are strong links between our work and that described in chapters 4 and 5.
Reference: 2. <author> Ole Ageson, Stephen Freunds, and John C. Mitchell. </author> <title> Adding Parameterization to Java. </title> <booktitle> In OOPSLA'97 Proceedings, </booktitle> <year> 1997. </year>
Reference-contexts: We aim to extend the language subset to describe a larger part of Java, and we also hope that our approach may serve as the basis for other studies on the language and its possible extensions <ref> [24, 3, 2] </ref>. We are also looking at further language properties such as an abstraction property and binary compatibility [31].
Reference: 3. <author> Joseph A. Bank, Barbara Liskov, and Andrew C. Myers. </author> <title> Parameterized Types and Java. </title> <booktitle> In POPL'97 Proceedings, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: Examples of enriching method calls, instance variable access and of object creation can be seen in section 4.1. The Java s array creation new int <ref> [3] </ref> is represented in Java se as new int [3][[0]]. <p> Array access as described here adheres to the rules in ch. 15.12 of [16], which require full evaluation of the expression to the left of the brackets. Thus, with our operational semantics, the term a [(a := b)<ref> [3] </ref>] corresponds to the term a [b [3]]; a := b. hid; i; p h (id); i h i :[C]f; i; p h ( i ; f; C); i hv [e]; i; p hv 0 [e]; 0 i he; i; p he 0 ; 0 i hnull [e]; i; p hnull [e 0 ]; 0 i k is <p> is a one dimensional array of Phil, then the assignment z <ref> [3] </ref>:=aPhil is type-correct. However, if at run-time z happens to contain a reference to an array of FrPhil, i.e. (z) = i and ( i ) = [[:::]] FrPhil [] , then z [3]:=aPhil will be rewritten to i [3] := aPhil. Should this term be considered type-correct? A term y [3] := aPhil would be type-incorrect if y were declared as an array of FrPhil. On the other hand, evaluation of the term i [3] := aPhil will not stop here. <p> However, if at run-time z happens to contain a reference to an array of FrPhil, i.e. (z) = i and ( i ) = [[:::]] FrPhil [] , then z <ref> [3] </ref>:=aPhil will be rewritten to i [3] := aPhil. Should this term be considered type-correct? A term y [3] := aPhil would be type-incorrect if y were declared as an array of FrPhil. On the other hand, evaluation of the term i [3] := aPhil will not stop here. <p> ) = [[:::]] FrPhil [] , then z <ref> [3] </ref>:=aPhil will be rewritten to i [3] := aPhil. Should this term be considered type-correct? A term y [3] := aPhil would be type-incorrect if y were declared as an array of FrPhil. On the other hand, evaluation of the term i [3] := aPhil will not stop here. The right hand side, in that case aPhil, will be evaluated, and if it returns a value which is of a subclass of FrPhil, then the assignment will be performed, otherwise an exception will be thrown. <p> Therefore, in order to be able to prove subject reduction, the intermediate term i <ref> [3] </ref> := aPhil has to be considered type-correct in Java r . Interestingly, such a distinction between types for array assignments and other assignments is not necessary when using large steps operational semantics [23]. Finally, the last two rules in figure 20 deal with exceptions that have actually been thrown. <p> We aim to extend the language subset to describe a larger part of Java, and we also hope that our approach may serve as the basis for other studies on the language and its possible extensions <ref> [24, 3, 2] </ref>. We are also looking at further language properties such as an abstraction property and binary compatibility [31].
Reference: 4. <author> Gerald Baumgartner and Vincent F. Russo. </author> <title> Signatures: A language extension for improving type abstraction and subtype polymorphism in C++. </title> <journal> Software-Practice & Experience, </journal> <volume> 25(8) </volume> <pages> 863-889, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Nevertheless, we feel that the introduction of some new features in Java, as well as the specific combination of features, justifies a study of the Java formal semantics. The use of interfaces, reminiscent of [9, 6] is a simplification of the signatures extension for C++ <ref> [4] </ref> and is to the best of our knowledge novel. The mechanism for dynamic method binding is that of C++, but we know of no formal definition. Java adopts the Smalltalk [14] approach whereby all object variables are implicitly pointers.
Reference: 5. <author> John Boyland and Giuseppe Castagna. </author> <title> Type-Safe Compilation of Covariant Specialization: A Practical Case. </title> <booktitle> In ECOOP'96 Proceedings, </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: Furthermore, we chose an imperative subset right from the start, because the extension of type systems to the imperative case has sometimes uncovered new problems, (e.g. multi-methods for functional languages [7], and for imperative languages in <ref> [5] </ref>, the Damas and Milner polymorphic type systems for functional languages [10], and for the imperative extension [29]). We considered arrays, because of the known requirement for run-time type checking. <p> Truth 0 ( 3 ) = t... Food Arrays carry their dimension and type information, and they consist of a sequence of values for the first dimension. For example, <ref> [[3; 5; 8; 11] </ref>] int [] dimensional array of integers.
Reference: 6. <author> P. Canning, William Cook, and William Olthoff. </author> <title> Interfaces for object-oriented programming. </title> <booktitle> In OOPLSA'89 Proceedings, </booktitle> <pages> pages 457-467, </pages> <year> 1989. </year>
Reference-contexts: Java combines features from C++, Smalltalk, Clos and other object oriented languages. Nevertheless, we feel that the introduction of some new features in Java, as well as the specific combination of features, justifies a study of the Java formal semantics. The use of interfaces, reminiscent of <ref> [9, 6] </ref> is a simplification of the signatures extension for C++ [4] and is to the best of our knowledge novel. The mechanism for dynamic method binding is that of C++, but we know of no formal definition.
Reference: 7. <author> Giuseppe Castagna, Giorgio Ghelli, and Giuseppe Longo. </author> <title> A calculus for overloaded functions with subtyping. </title> <journal> Information and Computation, </journal> <volume> 117(1) </volume> <pages> 115-135, </pages> <month> 15 February </month> <year> 1995. </year>
Reference-contexts: Furthermore, we chose an imperative subset right from the start, because the extension of type systems to the imperative case has sometimes uncovered new problems, (e.g. multi-methods for functional languages <ref> [7] </ref>, and for imperative languages in [5], the Damas and Milner polymorphic type systems for functional languages [10], and for the imperative extension [29]). We considered arrays, because of the known requirement for run-time type checking.
Reference: 8. <author> William Cook. </author> <title> A Proposal for making Eiffel Type-safe. </title> <editor> In S. Cook, editor, </editor> <booktitle> ECOOP'87 Proceedings, </booktitle> <pages> pages 57-70. </pages> <publisher> Cambridge University Press, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: Experience confirms the importance of formal studies of type systems early on during language development. Eiffel, a language first introduced in 1985, was discovered to have a loophole in its type system in 1990 <ref> [8, 22] </ref>. Given the growing usage of Java, it seems important that if there are loopholes in the type system they be discovered early on. <p> Truth 0 ( 3 ) = t... Food Arrays carry their dimension and type information, and they consist of a sequence of values for the first dimension. For example, <ref> [[3; 5; 8; 11] </ref>] int [] dimensional array of integers.
Reference: 9. <author> William Cook, Walter Hill, and Peter Canning. </author> <title> Inheritance is not Subtyping. </title> <booktitle> In POPL'90 Proceedings, </booktitle> <month> January </month> <year> 1990. </year>
Reference-contexts: Java combines features from C++, Smalltalk, Clos and other object oriented languages. Nevertheless, we feel that the introduction of some new features in Java, as well as the specific combination of features, justifies a study of the Java formal semantics. The use of interfaces, reminiscent of <ref> [9, 6] </ref> is a simplification of the signatures extension for C++ [4] and is to the best of our knowledge novel. The mechanism for dynamic method binding is that of C++, but we know of no formal definition.
Reference: 10. <author> Luis Damas and Robin Milner. </author> <title> Principal Type Schemes for Functional Languages. </title> <booktitle> In POPL'82 Proceedings, </booktitle> <year> 1982. </year>
Reference-contexts: Furthermore, we chose an imperative subset right from the start, because the extension of type systems to the imperative case has sometimes uncovered new problems, (e.g. multi-methods for functional languages [7], and for imperative languages in [5], the Damas and Milner polymorphic type systems for functional languages <ref> [10] </ref>, and for the imperative extension [29]). We considered arrays, because of the known requirement for run-time type checking.
Reference: 11. <author> Sophia Drossopoulou and Susan Eisenbach. </author> <title> Is the Java type system sound? In Fourth International Workshop on Foundations of Object-Oriented Languages, </title> <month> January </month> <year> 1997. </year>
Reference-contexts: We considered arrays, because of the known requirement for run-time type checking. In contrast with our previous work <ref> [11, 12, 13] </ref>, we follow the language description in [16] rather than the more general approach outlined in older versions of the language description. 1.2 Our approach We define Java s , a provably safe subset of Java containing the features listed previously, a term rewrite system to describe the operational <p> During execution, these terms may be rewritten to terms which are not expressible in Java se . We therefore extend Java se , obtaining Java r , which describes run-time terms. Java r corresponds to Java R from chapter 4. In previous work <ref> [11, 12, 13] </ref> we did not distinguish between Java se and Java r ; instead, we only considered one language with both the enrichments and the extensions. However, as Don Syme has pointed out, the two different reasons for language modifications should naturally lead to distinct languages. <p> Truth 0 ( 3 ) = t... Food Arrays carry their dimension and type information, and they consist of a sequence of values for the first dimension. For example, <ref> [[3; 5; 8; 11] </ref>] int [] dimensional array of integers.
Reference: 12. <author> Sophia Drossopoulou and Susan Eisenbach. </author> <title> Java is type safe | probably. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: We considered arrays, because of the known requirement for run-time type checking. In contrast with our previous work <ref> [11, 12, 13] </ref>, we follow the language description in [16] rather than the more general approach outlined in older versions of the language description. 1.2 Our approach We define Java s , a provably safe subset of Java containing the features listed previously, a term rewrite system to describe the operational <p> During execution, these terms may be rewritten to terms which are not expressible in Java se . We therefore extend Java se , obtaining Java r , which describes run-time terms. Java r corresponds to Java R from chapter 4. In previous work <ref> [11, 12, 13] </ref> we did not distinguish between Java se and Java r ; instead, we only considered one language with both the enrichments and the extensions. However, as Don Syme has pointed out, the two different reasons for language modifications should naturally lead to distinct languages.
Reference: 13. <author> Sophia Drossopoulou, Susan Eisenbach, and Sarfraz Khurshid. </author> <title> Is Java Sound? Theory and Practice of Object Systems, </title> <note> 1998. to appear, available at http://www-dse.doc.ic.ac.uk/projects/slurp/. </note>
Reference-contexts: We considered arrays, because of the known requirement for run-time type checking. In contrast with our previous work <ref> [11, 12, 13] </ref>, we follow the language description in [16] rather than the more general approach outlined in older versions of the language description. 1.2 Our approach We define Java s , a provably safe subset of Java containing the features listed previously, a term rewrite system to describe the operational <p> During execution, these terms may be rewritten to terms which are not expressible in Java se . We therefore extend Java se , obtaining Java r , which describes run-time terms. Java r corresponds to Java R from chapter 4. In previous work <ref> [11, 12, 13] </ref> we did not distinguish between Java se and Java r ; instead, we only considered one language with both the enrichments and the extensions. However, as Don Syme has pointed out, the two different reasons for language modifications should naturally lead to distinct languages.
Reference: 14. <author> A. Goldberg and D. Robson. </author> <title> SmallTalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: The use of interfaces, reminiscent of [9, 6] is a simplification of the signatures extension for C++ [4] and is to the best of our knowledge novel. The mechanism for dynamic method binding is that of C++, but we know of no formal definition. Java adopts the Smalltalk <ref> [14] </ref> approach whereby all object variables are implicitly pointers. Furthermore, although there are a large number of studies of the semantics of isolated programming language features or of minimal programming languages [1, 30, 32], there have not been many studies of the formal semantics of actual programming languages.
Reference: 15. <editor> M. Gordon and T.F. Melhams, editors. </editor> <title> Introduction to HOL: A Theorem Proving Environment for Higher Order Logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Another proof of the soundness of the Java type system, using Isabelle in a large step semantics is described in [23] and in the next chapter of this book. Applications of theorem provers for programming language properties are also described in <ref> [15, 26, 30] </ref>. We aim to extend the language subset to describe a larger part of Java, and we also hope that our approach may serve as the basis for other studies on the language and its possible extensions [24, 3, 2].
Reference: 16. <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: We were initially attracted to Java because of its elegant combination of several tried language features. For this work we were guided by the language description in <ref> [16] </ref> which answered unambiguously all questions relating to the language subset we considered. However, we discovered some rules to be more restrictive than necessary, and the reasons for some design decisions were not obvious. <p> We considered arrays, because of the known requirement for run-time type checking. In contrast with our previous work [11, 12, 13], we follow the language description in <ref> [16] </ref> rather than the more general approach outlined in older versions of the language description. 1.2 Our approach We define Java s , a provably safe subset of Java containing the features listed previously, a term rewrite system to describe the operational semantics and a type inference system to describe compile-time <p> Contrary to Java, Java s statements have a type and thus we can type check the return values of method bodies. The execution of Java programs requires some type information at run-time (e.g. method descriptors as in chapter 15.11 in <ref> [16] </ref>). For this reason, we define Java se , an enriched version of Java s containing compile-time type information to be used for method call and field access. Java se corresponds to Java A from chapter 4, and to Java light from chapter 5. <p> It also contains the type definitions of all variables and methods of a class and its interface. StandardEnv should include all the predefined classes, and all the classes described in chapters 20-22 of <ref> [16] </ref>, e.g. the exception classes Exception, NullPE, ArrStoreE, IndOutBndE, NegSzeE and others we do not need to distinguish between checked and unchecked exceptions. Declarations may be class declarations, interface declarations or identifier declarations. Env ::= StandardEnv j Env ; Decl StandardEnv ::= Exception ext Object ...NullPE ext Exception ...; ... <p> For this we shall need several auxiliary concepts. The following auxiliary definition allows the extraction of the argument types and the result type from a method type and helps us describe restrictions imposed on variable and method definitions for classes or interfaces, given in chapters 8.2 and 9 in <ref> [16] </ref>. <p> j ) 6= Args (MT 00 ) g - MSigs (; C; m) = f MT j 9C 00 with (C 00 ; MT) 2 MDecs (; C; m) g The sets FDecs (; Object; v) and MDecs (; Object; m) should contain the entities described in chapter 20.1 of <ref> [16] </ref>. We defined them as empty sets for simplic ity. <p> = C 0 :::f:::v : T:::g and ` C v C 0 and 8T 0 ; C 00 6= C 0 with ` C v C 00 ; ` C 00 v C 0 : (C 00 ) 6= C 00 ext :::impl:::f:::v : T 00 g The language description <ref> [16] </ref> imposes the following requirements, when a new class C is declared as C ext C 0 impl I 1 ; :::I n fv 1 : T 1 ; :::v k : T k ; m 1 : MT 1 ; :::m l : MT l g there can be sequences <p> These requirements are formalized in the fourth rule in figure 7. Similar requirements for interfaces are given in <ref> [16] </ref>, and their formalization is also given in the fifth rule in figure 7. 3.6 Properties of well-formed environments It is straightforward to state and prove the following properties of well-formed environments: Two types that are in the subclass relationship are classes, v is reflexive, transitive and antisymmetric, and the subclass <p> Array and object creation expressions are enriched with initialization information that determine the values for component initialization. Initial values are defined in ch. 4.5.5. of <ref> [16] </ref>, and here in the following definition: Definition 6 The initial value of a simple type is: - 0 is the initial value of int - 0 0 is the initial value of char false is the initial value of bool null is the initial value of classes, interfaces or nil <p> A message expression is type-correct if this set contains exactly one pair. The argument types of the signature of this pair is stored as the method descriptor, c.f. ch.15.11 in <ref> [16] </ref>, and the result type of the signature is the type of the message expression. rule describes the type of a method body with parameters x 1 , ..., x n , consisting of the statements stmts. <p> An object is annotated by its class, and it consists of a sequence of labels and values. Each label also carries the class in which it was defined; this is needed for labels shadowing labels from superclasses, c.f. <ref> [16] </ref> ch. 9.5. For the philosophers example, t like Phil: 2 , like FrPhil: null FrPhil is an object of class FrPhil. It inherits the field like from Phil, and has the field like from FrPhil. <p> This is because there is no explicit dereferencing operator in Java. Objects are passed as references, and they are dereferenced only implicitly, when their fields are accessed. Array access as described here adheres to the rules in ch. 15.12 of <ref> [16] </ref>, which require full evaluation of the expression to the left of the brackets. <p> :::; j n 1 1 ]] h new T [n 1 ]:::[n k ][] 1 :::[] m [[v]]; i; p h j n 1 ; 0 i Fig. 15. expression execution The last six rules in figure 15 describe the creation of new objects or arrays, c.f. ch. 15.8-15.9 of <ref> [16] </ref>. Essentially, a new value of the appropriate array or class type is created, and its address is returned. The fields of the array and the components of the object are assigned initial values (calculated at compile-time, cf definition 6) of the type to which they belong. <p> By applying some simplifications we obtained a straightforward system, which, we think, does not diminish the application of our results. Close scrutiny of the language description showed that the semantic issues related to the scope of our investigation are unambiguously answered by <ref> [16] </ref>. However, we found areas that could have been defined more generally (e.g. the return types of methods override those from superclasses and superinterfaces) and others that could have been defined more concisely (e.g. the descriptions of widening and of exceptions).
Reference: 17. <author> R. Harper. </author> <title> A simplified account of polymorphic references. </title> <type> Technical Report CMU-CS-93-169, </type> <institution> Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: Objects carry their classes (similar to the Smalltalk abstract machine [18]), thus we do not need store types [1], or location typings <ref> [17] </ref>. Objects are labelled tuples, where each label contains the class in which it was declared. Array values are tuples too, and they are annotated by their type and their dimension. There are strong links between our work and that described in chapters 4 and 5.
Reference: 18. <author> Daniel Ingalls. </author> <title> The Smalltalk-76 programming system design and implementation. </title> <booktitle> In POPL'78 Proceedings, </booktitle> <pages> pages 9-15, </pages> <month> January </month> <year> 1978. </year>
Reference-contexts: The Java s simplifications of eliminating block structure and local variables allow the definition of the state as a flat structure, where addresses are mapped to objects and global variables are mapped to primitive values or addresses. Objects carry their classes (similar to the Smalltalk abstract machine <ref> [18] </ref>), thus we do not need store types [1], or location typings [17]. Objects are labelled tuples, where each label contains the class in which it was declared. Array values are tuples too, and they are annotated by their type and their dimension.
Reference: 19. <institution> The Java Language Specification, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: This is defined in chapter 5.1.4 <ref> [19] </ref>; chapter 5.1.2 in [19] defines widening of primitive types, but here we shall only be concerned with widening of references. <p> This is defined in chapter 5.1.4 <ref> [19] </ref>; chapter 5.1.2 in [19] defines widening of primitive types, but here we shall only be concerned with widening of references. <p> Cf (; v:f)g = Cf (; v)g:[C]f. in ch. 15.11, <ref> [19] </ref>: A method is applicable if the actual parameter types can be widened to the corresponding formal parameter types.
Reference: 20. <author> John Boyland and Giuseppe Castagna. </author> <title> Parasitic Methods: Implementation of Multimethods for Java. </title> <type> Technical report, </type> <institution> C.N.R.S, </institution> <month> November </month> <year> 1997. </year>
Reference-contexts: For instance, the type of aPhil.like is Phil, but the type of pascal.like is Food, though 0 ` aPhil : Phil, 0 ` pascal : FrPhil, and 0 ` FrPhil wdn Phil. In fact, the introduction of the subsumption rule would make this type system non-deterministic although <ref> [20] </ref> develops a system for Java which has a subsumption rule, and in which the types of method call and field access are determined by using the minimal types of the expressions. ` se v : T FDec (; C; f) = ( C; T 0 ) ` se v:[C]f :
Reference: 21. <author> Sarfraz Khurshid. </author> <title> Some Aspects of Type Soundness for Java, 1997. </title> <type> BSc thesis. </type>
Reference-contexts: The additional Java requirements, that no class E i should appear more than once, and that no class should appear preceded by a subclass are expressed in <ref> [21] </ref> but are omitted here, since they do not affect the subject reduction property. ` e : E; e 6= i ` E v Exception ` throw e : void Cf (; throw e)g = throw Cf (; e)g n 0; v i ; z i new in i 2 f1:::ng <p> Interestingly, it turns out that large step semantics allow for a simpler proof of subject reduction, and in particular, do not require different type rules for Java r assignment to array components and the other assignments statements [23]. On the other hand, small steps allow the description of co-routines <ref> [21] </ref>. In figure 15 we describe the evaluation of variables, field and array access, and the creation of new objects or arrays. Variables (i.e. identifiers, instance variable access or array access) are evaluated from left to right. <p> However, we found areas that could have been defined more generally (e.g. the return types of methods override those from superclasses and superinterfaces) and others that could have been defined more concisely (e.g. the descriptions of widening and of exceptions). Furthermore, in <ref> [21, 31] </ref> we describe problems related to the definition of binary compatibility, and attempt a formalization of this concept. We believe that the formal system we have developed is very near to Java and to programmers' intuitive ideas about program execution.
Reference: 22. <author> Bertrand Meyer. </author> <title> Static typing and other mysteries of life, </title> <note> http://www.eiffel.com 1995. </note>
Reference-contexts: Experience confirms the importance of formal studies of type systems early on during language development. Eiffel, a language first introduced in 1985, was discovered to have a loophole in its type system in 1990 <ref> [8, 22] </ref>. Given the growing usage of Java, it seems important that if there are loopholes in the type system they be discovered early on.
Reference: 23. <author> Tobias Nipkow and David von Oheimb. </author> <title> Java `ight is type-safe | definitely. </title> <type> Tech--nical report, </type> <institution> Technische Universitaet Muenchen, </institution> <year> 1997. </year> <note> Submitted for publication. </note>
Reference-contexts: We chose small step semantics because we found this more intuitive. Interestingly, it turns out that large step semantics allow for a simpler proof of subject reduction, and in particular, do not require different type rules for Java r assignment to array components and the other assignments statements <ref> [23] </ref>. On the other hand, small steps allow the description of co-routines [21]. In figure 15 we describe the evaluation of variables, field and array access, and the creation of new objects or arrays. Variables (i.e. identifiers, instance variable access or array access) are evaluated from left to right. <p> Therefore, in order to be able to prove subject reduction, the intermediate term i [3] := aPhil has to be considered type-correct in Java r . Interestingly, such a distinction between types for array assignments and other assignments is not necessary when using large steps operational semantics <ref> [23] </ref>. Finally, the last two rules in figure 20 deal with exceptions that have actually been thrown. The term throw new Et indicates potential throwing of an exception, and would be rewritten to the term throw i , where i is the address of an object of class E. <p> This gives us greater confidence in our results, but it also underlines the importance of the use of theorem checkers for such, rather large systems. Another proof of the soundness of the Java type system, using Isabelle in a large step semantics is described in <ref> [23] </ref> and in the next chapter of this book. Applications of theorem provers for programming language properties are also described in [15, 26, 30].
Reference: 24. <author> Martin Odersky and Philip Wadler. </author> <title> Pizza into Java: Translating theory into practice. </title> <booktitle> In POPL'97 Proceedings, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: We aim to extend the language subset to describe a larger part of Java, and we also hope that our approach may serve as the basis for other studies on the language and its possible extensions <ref> [24, 3, 2] </ref>. We are also looking at further language properties such as an abstraction property and binary compatibility [31].
Reference: 25. <author> Peter Sellinger. </author> <title> private communication, </title> <month> October </month> <year> 1996. </year>
Reference-contexts: The renaming of variables in the method body, namely stmts [z 1 =x 1 ; :::; z n =x n ], is necessary in order to avoid name clashes and, also, in order for lemma 8 to hold aspointed out in <ref> [25] </ref>. It is worth noticing that the rules describing method bodies do not determine T instead, the expected return type of the method, T, is taken from the environment when applying the next rule of the figure, which describes class bodies.
Reference: 26. <author> Donald Syme. DECLARE: </author> <title> A Prototype Declarative Proof System for Higher Order Logic. </title> <type> Technical Report 416, </type> <institution> Cambridge University, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: From now on, we implicitly expect to have unique declarations and the relations v and to be acyclic up to reflexivity. Thus the functions FDec, FDecs, MDecs and MSigs are well-defined, c.f. <ref> [26] </ref>. <p> Another proof of the soundness of the Java type system, using Isabelle in a large step semantics is described in [23] and in the next chapter of this book. Applications of theorem provers for programming language properties are also described in <ref> [15, 26, 30] </ref>. We aim to extend the language subset to describe a larger part of Java, and we also hope that our approach may serve as the basis for other studies on the language and its possible extensions [24, 3, 2].
Reference: 27. <author> Donald Syme. </author> <title> Private Communication, </title> <year> 1997. </year>
Reference-contexts: The effect of this rule is, that Java r terms do not have unique types. The fourth and fifth rules describe assignments. The Java r array assignment rule, suggested to us by Don Syme <ref> [27, 28] </ref>, only requires the left hand side and the right hand side to be type-correct. <p> Don Syme pointed out to us <ref> [27, 28] </ref> that a lemma stating that program execution preserves types up to widening, is necessary for the proof of subject reduction. Interestingly, it turned out that a stronger lemma, than that originally suggested and used in the subject reduction theorem is possible.
Reference: 28. <author> Donald Syme. </author> <title> Proving Java Type Sound. </title> <type> Technical Report 427, </type> <institution> Cambridge University, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: The effect of this rule is, that Java r terms do not have unique types. The fourth and fifth rules describe assignments. The Java r array assignment rule, suggested to us by Don Syme <ref> [27, 28] </ref>, only requires the left hand side and the right hand side to be type-correct. <p> Don Syme pointed out to us <ref> [27, 28] </ref> that a lemma stating that program execution preserves types up to widening, is necessary for the proof of subject reduction. Interestingly, it turned out that a stronger lemma, than that originally suggested and used in the subject reduction theorem is possible.
Reference: 29. <author> Mads Tofte. </author> <title> Type Inference for Polymorphic References. </title> <booktitle> In Information and Computation'80 Conference Proceedings, </booktitle> <pages> pages 1-34, </pages> <month> November </month> <year> 1980. </year>
Reference-contexts: an imperative subset right from the start, because the extension of type systems to the imperative case has sometimes uncovered new problems, (e.g. multi-methods for functional languages [7], and for imperative languages in [5], the Damas and Milner polymorphic type systems for functional languages [10], and for the imperative extension <ref> [29] </ref>). We considered arrays, because of the known requirement for run-time type checking.
Reference: 30. <author> Myra VanInwegen. </author> <title> Towards Type Preservation in Core SML. </title> <type> Technical report, </type> <institution> Cambridge University, </institution> <year> 1997. </year>
Reference-contexts: Java adopts the Smalltalk [14] approach whereby all object variables are implicitly pointers. Furthermore, although there are a large number of studies of the semantics of isolated programming language features or of minimal programming languages <ref> [1, 30, 32] </ref>, there have not been many studies of the formal semantics of actual programming languages. In addition, the interplay of features which are very well understood in isolation, might introduce unexpected effects. Experience confirms the importance of formal studies of type systems early on during language development. <p> Another proof of the soundness of the Java type system, using Isabelle in a large step semantics is described in [23] and in the next chapter of this book. Applications of theorem provers for programming language properties are also described in <ref> [15, 26, 30] </ref>. We aim to extend the language subset to describe a larger part of Java, and we also hope that our approach may serve as the basis for other studies on the language and its possible extensions [24, 3, 2].
Reference: 31. <author> David Wragg, Sophia Drossopoulou, and Susan Eisenbach. </author> <title> Java Binary Compatibility is Almost Correct. </title> <type> Technical Report 3/98, </type> <institution> Imperial College, </institution> <year> 1998. </year> <note> http://www-dse/projects/SLURP/bc. </note>
Reference-contexts: However, as Don Syme has pointed out, the two different reasons for language modifications should naturally lead to distinct languages. Also, such a distinction allows a clearer description of the concepts. Last but not least, this distinction is necessary for the formalization of the notions around binary compatibility <ref> [31] </ref>. The operational semantics is defined as a ternary rewrite relationship between configurations, programs and configurations. Configurations are tuples of Java r terms and states. The terms represent the part of the original program remaining to be executed. We describe method calls through textual substitution. <p> However, we found areas that could have been defined more generally (e.g. the return types of methods override those from superclasses and superinterfaces) and others that could have been defined more concisely (e.g. the descriptions of widening and of exceptions). Furthermore, in <ref> [21, 31] </ref> we describe problems related to the definition of binary compatibility, and attempt a formalization of this concept. We believe that the formal system we have developed is very near to Java and to programmers' intuitive ideas about program execution. <p> We are also looking at further language properties such as an abstraction property and binary compatibility <ref> [31] </ref>. Acknowledgments We would like to acknowledge encouragement from our colleagues in the Department of Computing during the formulation of these ideas and financial support from the EPSRC (Grant Refs:GR/L 76709 and GR/K 73282).
Reference: 32. <author> Andrew Wright and Matthias Felleisen. </author> <title> A Syntactic Approach to Type Soundness. </title> <journal> Information and Computation, </journal> <volume> 115(1), </volume> <year> 1994. </year>
Reference-contexts: Java adopts the Smalltalk [14] approach whereby all object variables are implicitly pointers. Furthermore, although there are a large number of studies of the semantics of isolated programming language features or of minimal programming languages <ref> [1, 30, 32] </ref>, there have not been many studies of the formal semantics of actual programming languages. In addition, the interplay of features which are very well understood in isolation, might introduce unexpected effects. Experience confirms the importance of formal studies of type systems early on during language development.
References-found: 32

