URL: ftp://ftp.cs.utexas.edu/pub/boyer/diss/akers.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/boyer/students.html
Root-URL: http://www.cs.utexas.edu
Title: Strong Static Type Checking for Functional Common Lisp  
Phone: (512) 322-9951  
Author: Robert L. Akers 
Note: This work was supported in part at Computational Logic, Inc., by the Defense Advanced Research Projects Agency, ARPA Order 7406. The views and conclusions contained in this document are those of the author(s) and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency or the U.S. Government.  
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic Inc.  
Abstract: Technical Report 96 December 30, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [Abadi 89] <author> M. Abadi, L. Cardelli, B. Pierce, G. Plotkin. </author> <title> Dynamic Typing in a Statically Typed Language. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 213-227. </pages> <institution> Association for Computing Machinery, Austin, Texas, </institution> <month> January, </month> <year> 1989. </year>
Reference-contexts: In this paper, he also formulated a different type inference algorithm which accommodated coercion and overloading and yet another which handled abstraction and general type quantification. The author knows of no instance where Leivant's work has been incorporated into any programming language or environment. Abadi, Cardelli, Pierce and Plotkin <ref> [Abadi 89] </ref> developed a system which supports a type called dynamic, whose purpose is to deal with persistent objects existing outside the program being type checked.
Reference: [Aho 86] <author> A. Aho, R. Sethi, J. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference: [Aiken 92] <author> A. Aikin, E. Wimmers. </author> <title> Solving Systems of Set Constraints. </title> <booktitle> In Proceedings of the 1992 IEEE Symposium on Logic in Computer Science. IEEE Computer Society, </booktitle> <year> 1992. </year>
Reference-contexts: He did this by canonicalizing the structures prior to unification, then tailoring the algorithm to consider the most inherently expensive cases only after other methods had been exhausted. Unfortunately, his canonicalization would not be possible on recursive forms containing disjunction. Aiken and Wimmers <ref> [Aiken 92] </ref> place the problem of merging forms containing variables, conjunction, disjunction, and negation in a different setting, that of solving system of set constraints, and exhibit an algorithm for doing so. 9 The unification algorithm cited is credited to Boyer and Moore [Boyer 72], who showed how unification could be
Reference: [Akers 86] <author> Robert L. Akers. </author> <title> Using the Exception Suppression VC Mechanism. Internal Note 7, Computational Logic, </title> <publisher> Inc., </publisher> <month> December, </month> <year> 1986. </year>
Reference-contexts: Unfortunately, the Gypsy Verification Environment no longer supports a compiler, although the generation of verification conditions for proving the absence of type errors has been re-implemented and preserved <ref> [Akers 86] </ref>. Boyer and Moore's work with Acl2, previously mentioned, falls squarely into this realm as well. They use the mechanical assistance of their theorem prover to validate conformance to domain restrictions expressed as guards.
Reference: [Appel 89] <author> Andrew W. Appel. </author> <title> Runtime Tags Aren't Necessary. </title> <booktitle> Lisp and Symbolic Computation 2(2) </booktitle> <pages> 153-162, </pages> <month> June, </month> <year> 1989. </year>
Reference-contexts: Consequently, the family of functions which can be computed (the primitive recursive functions) is too restricted, especially compared to those definable in 7 This calculus was invented independently by Jean-Yves Girard [Girard 72]. 8 Moreover, Appel <ref> [Appel 89] </ref> asserts that run-time tags are not necessary for statically-typed polymorphic languages at all. Aside from type checking, he asserts that tags are needed only for garbage collection, and he proposes a garbage collection algorithm which makes use of type information which the compiler can provide.
Reference: [Backus 78] <author> John Backus. </author> <title> Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs. </title> <journal> Communications of the ACM 21(8) </journal> <pages> 613-641, </pages> <month> August, </month> <year> 1978. </year>
Reference-contexts: Moreover, the flexibility of the type system has been alleged to defeat the goals of strong static type checking [Giannini 85]. John Backus' landmark 1978 Turing Award Lecture <ref> [Backus 78] </ref> provided much of the impetus for the development of functional programming.
Reference: [Baker 90] <author> Henry Baker. </author> <title> The Nimble Type Inferencer for Common Lisp 84. </title> <type> Technical Report, </type> <institution> Nimble Computer Corporation, </institution> <year> 1990. </year>
Reference-contexts: Thus, list-processing operations and general CONS structures are largely ignored in favor of accurate assignments of various types, like the numerics, likely to be specifically supported at the machine level. Kaplan and Ullman's work is also the basis of the Nimble type inference system for Common Lisp <ref> [Baker 90] </ref>. As with TICL, the type lattices it employs are primarily focused on numeric types, and the system does not appear to deal with structured types in any direct sense. Both the Nimble and the TICL systems achieve their pragmatic goals of improving run-time performance of compiled Lisp code. <p> The improvement of run-time speed of code generated with prolific type declarations is the apparent raison d'etre for the TICL type inference system [Ma 90] and the Nimble Type Inferencer <ref> [Baker 90] </ref>. 9.3.1 Assisting a Compiler The system described in this report could be easily modified to generate declarations in this style. A simple mapping could be maintained in the database associating descriptors with their recognizer functions.
Reference: [Baker 92] <institution> Henry Baker. </institution>
Reference-contexts: Both the Nimble and the TICL systems achieve their pragmatic goals of improving run-time performance of compiled Lisp code. Baker has also developed a decision procedure for the Common Lisp SUBTYPEP predicate <ref> [Baker 92] </ref>, utilizing a specific lattice structure suitable for performing type inference. A complete implementation of SUBTYPEP can assist a compiler in making optimal storage allocation decisions and in removing some type-checking code. A problem limits the effectiveness of the lattice-theoretic models when confronting ad hoc polymorphic functions.
References-found: 8

