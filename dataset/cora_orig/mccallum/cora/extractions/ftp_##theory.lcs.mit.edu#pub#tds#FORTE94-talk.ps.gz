URL: ftp://theory.lcs.mit.edu/pub/tds/FORTE94-talk.ps.gz
Refering-URL: http://theory.lcs.mit.edu/tds/reflist.html
Root-URL: 
Email: lynch@theory.lcs.mit.edu  
Title: Proving Performance Properties (even Probabilistic Ones)  
Author: Nancy Lynch 
Date: September 2, 1994  
Address: Cambridge, MA 02139, USA  
Affiliation: MIT Laboratory for Computer Science  
Abstract: This paper surveys some new tools and methods for formally verifying time performance properties of systems that satisfy timing assumptions. The techniques are potentially of practical benefit in the validation of real-time process control and communication systems. The tools and methods include nondeterministic timed automaton models, invariant assertion and simulation techniques for proving worst-case time bounds, probabilistic timed automaton models, and Markov-style techniques for proving probabilistic time bounds. All of these techniques are well suited for (partial) mechanization. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Sudhanshu Aggarwal. </author> <title> Time optimal self-stabilizing spanning tree algorithms. </title> <type> Master's thesis, </type> <institution> MIT Electrical Engineering and Computer Science, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: In order to avoid this bad interleaving, we introduce time restrictions: for each process, the time for setting x, once x has been seen equal to 0, is in the range [0; a], while the time to check x after it has been set is in the range <ref> [b; 1] </ref>, for some constants a, b, where a &lt; b. <p> This algorithm is a randomized distributed algorithm of typical difficulty; the state of the art in the distributed algorithms area has till now not permitted careful proofs of such algorithms. Nevertheless, in <ref> [1] </ref> this bound is proved, using Markov rule and coin lemma methods. There are two interesting points to be noted about the proof.
Reference: [2] <author> Sudhanshu Aggarwal and Shay Kutten. </author> <title> Time optimal self stabilizing spanning tree algorithms. In R.K. Shyamasundar, editor, </title> <booktitle> 13th International Conference on Foundations of Software Technology and Theoretical Computer Science, volume 761 of Lecture Notes in Computer Science, </booktitle> <pages> pages 400-410, </pages> <address> Bombay, India., </address> <month> December </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: Thus in this case, i + 1 must have both its forks and again we are done. Aggarwal-Kutten spanning tree algorithm. A larger and more complex example is the Aggarwal-Kutten randomized algorithm for finding a spanning tree in a network based on an unknown undirected graph G <ref> [2] </ref>. Processes are assumed to be identical (e.g., they do not have unique identifiers), and so the only way to break symmetry in the construction of the tree is using randomness.
Reference: [3] <author> Ernest Chang and Rosemary Roberts. </author> <title> An improved algorithm for decentralized extrema-finding in circular configurations of processes. </title> <journal> Communications of the ACM, </journal> <volume> 22(5) </volume> <pages> 281-283, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: Using I, we can provide two stylized simulations to show the needed time bound. LeLann-Chang-Roberts leader election algorithm. The LeLann-Chang-Roberts leader election algorithm for ring networks <ref> [10, 3] </ref> works as follows: LCR: Every process sends its process identifier clockwise. Smaller identifiers that encounter larger identifiers are discarded. If a node receives its own identifier in a message, it elects itself as leader.
Reference: [4] <author> E.W. Dijkstra. </author> <title> Solution of a problem in concurrent programming control. </title> <journal> Communications of the ACM, </journal> <volume> 8(9):569, </volume> <month> September </month> <year> 1965. </year>
Reference-contexts: Theorem 2.5 Every admissible timed trace of the Fischer system is an admissible timed trace of the Mutex system. Again, the proof can be checked mechanically [12]. Dijkstra mutual exclusion algorithm. Dijkstra's asynchronous algorithm <ref> [4] </ref> for mu-tual exclusion using read/write shared memory is one of the earliest published distributed algorithms.
Reference: [5] <author> Michael Fischer. Re: </author> <title> Where are you? E-mail message to Leslie Lamport. Arpanet message number 8506252257.AA07636@YALE-BULLDOG.YALE.ARPA (47 lines), </title> <address> June 25, </address> <year> 1985 </year> <month> 18:56:29EDT. </month>
Reference-contexts: The Count algorithm is trivial; in the rest of this section, we sketch more interesting time bound results that can be proved using the same strategy. Without such a stylized method, proving such time bounds would be a difficult task. Fischer mutual exclusion algorithm. The Fischer mutual exclusion algorithm <ref> [5] </ref> is a popular test case for formal methods for verifying real-time algorithms. In this algorithm, a collection of user processes compete for control of a resource, using a single shared variable x that they can only access using read and write operations.
Reference: [6] <author> Stephen J. Garland and John V. Guttag. </author> <title> A guide to LP, the Larch Prover. </title> <type> Technical report, </type> <institution> Digital Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, California 94301, </address> <month> December </month> <year> 1991. </year> <note> Research Report 82. </note>
Reference-contexts: It is possible to use an equational theorem prover to verify proofs of simulations such as this one, as well as proofs of the needed invariants. In fact, such a theorem prover can fill in some of the proof steps. Work along these lines, using the Larch theorem prover <ref> [6] </ref>, is described in [12]. The Count algorithm is trivial; in the rest of this section, we sketch more interesting time bound results that can be proved using the same strategy. Without such a stylized method, proving such time bounds would be a difficult task. Fischer mutual exclusion algorithm.
Reference: [7] <author> C. L. Heitmeyer, R. D. Jeffords, and B. G. Labaw. </author> <title> A benchmark for comparing different approaches for specifying and verifying real-time systems. </title> <booktitle> In Proc., Tenth Intern. Workshop on Real-Time Operating Systems and Software, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: The simulation and invariant methods are still used in much the same way as before. 3.2 Applications We discuss one example: the Generalized Railroad Crossing (GRC) problem <ref> [7] </ref>. Generalized railroad crossing. The problem involves real world trains and gates, interacting with a computer system via sensors and actuators. There are several parallel tracks on which trains travel through a road intersection I.
Reference: [8] <author> Constance Heitmeyer and Nancy Lynch. </author> <title> The generalized railroad crossing: A case study in formal verification of real-time systems. </title> <booktitle> In Proceedings of the 15th IEEE Real-Time Systems Symposium., </booktitle> <address> San Juan, Puerto Rico, </address> <month> December </month> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: The problem is to formalize these requirements and to design and verify a computer system that satisfies them. This problem was originally proposed as a challenge problem for comparing the effectiveness of various formal methods for handling such problems. We present the approach from <ref> [8, 9] </ref>. We begin by defining separate timed automata for the trains and gate components, plus a placeholder automaton to represent the interface between the real world components and the computer system.
Reference: [9] <author> Constance Heitmeyer and Nancy Lynch. </author> <title> The generalized railroad crossing: A case study in formal verification of real-time systems. </title> <type> Technical Memo MIT/LCS/TM-511, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: The problem is to formalize these requirements and to design and verify a computer system that satisfies them. This problem was originally proposed as a challenge problem for comparing the effectiveness of various formal methods for handling such problems. We present the approach from <ref> [8, 9] </ref>. We begin by defining separate timed automata for the trains and gate components, plus a placeholder automaton to represent the interface between the real world components and the computer system.
Reference: [10] <author> G. LeLann. </author> <title> Distributed systems, towards a formal approach. </title> <booktitle> In IFIP Congress, </booktitle> <pages> pages 155-160, </pages> <address> Toronto, </address> <year> 1977. </year>
Reference-contexts: Using I, we can provide two stylized simulations to show the needed time bound. LeLann-Chang-Roberts leader election algorithm. The LeLann-Chang-Roberts leader election algorithm for ring networks <ref> [10, 3] </ref> works as follows: LCR: Every process sends its process identifier clockwise. Smaller identifiers that encounter larger identifiers are discarded. If a node receives its own identifier in a message, it elects itself as leader.
Reference: [11] <author> Victor Luchangco. </author> <title> Using simulation techiniques to prove timing properties. </title> <type> Master's thesis, </type> <institution> MIT Electrical Engineering and Computer Science, </institution> <year> 1994. </year> <note> In progress. </note>
Reference-contexts: The MMT model is sufficient to describe all of these. The examples are summarized from <ref> [14, 15, 11] </ref>. Counting Process. The first and simplest example involves an automaton that counts down from some fixed positive integer k and then reports its completion. The time between successive steps is assumed to be in the range [c 1 ; c 2 ].
Reference: [12] <author> Victor Luchangco, Ekrem Soylemez, Stephen Garland, and Nancy Lynch. </author> <title> Verifying timing properties of concurrent algorithms. </title> <booktitle> In Proceedings of the Seventh International Conference on Formal Description Techniques for Distributed Systems and Communications Protocols (FORTE'94), IFIP Transactions, Berne, </booktitle> <address> Switzerland, </address> <month> October </month> <year> 1994. </year> <booktitle> IFIP WG6.1, </booktitle> <publisher> Elsevier Science Publishers B. V. (North Holland). </publisher>
Reference-contexts: Another paper in this proceedings, by Luchangco, Soylemez, Garland and Lynch <ref> [12] </ref>, shows how proofs using the methods in the first group can be verified mechanically. 1 2 Time Bounds for Asynchronous and Timing-Based Algorithms 2.1 Theory The basic model that we use for modelling asynchronous and timing-based systems is the nondeterministic timed automaton model of Lynch and Vaandrager [18, 17, 14]. <p> In fact, such a theorem prover can fill in some of the proof steps. Work along these lines, using the Larch theorem prover [6], is described in <ref> [12] </ref>. The Count algorithm is trivial; in the rest of this section, we sketch more interesting time bound results that can be proved using the same strategy. Without such a stylized method, proving such time bounds would be a difficult task. Fischer mutual exclusion algorithm. <p> Theorem 2.5 Every admissible timed trace of the Fischer system is an admissible timed trace of the Mutex system. Again, the proof can be checked mechanically <ref> [12] </ref>. Dijkstra mutual exclusion algorithm. Dijkstra's asynchronous algorithm [4] for mu-tual exclusion using read/write shared memory is one of the earliest published distributed algorithms.
Reference: [13] <author> N. Lynch and M. Tuttle. </author> <title> An introduction to Input/Output automata. </title> <journal> CWI-Quarterly, </journal> <volume> 2(3) </volume> <pages> 219-246, </pages> <month> September </month> <year> 1989. </year> <institution> Centrum voor Wiskunde en Informatica, </institution> <address> Amsterdam, The Netherlands. </address>
Reference-contexts: MMT automata. An important special case of the timed automaton model, describable in a particularly simple way, is the MMT timed automaton model [20], developed by Merritt, Modugno and Tuttle. We use a special case of their definition from [19, 14]. An MMT automaton is an I/O automaton <ref> [13] </ref> together with upper and lower bounds on time.
Reference: [14] <author> Nancy Lynch. </author> <title> Simulation techniques for proving properties of real-time systems. In A Decade of Concurrency: Reflections and Perspectives, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <pages> pages 375-424, </pages> <address> REX School/Symposium, Noordwijkerhout, the Netherlands, June 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: and Lynch [12], shows how proofs using the methods in the first group can be verified mechanically. 1 2 Time Bounds for Asynchronous and Timing-Based Algorithms 2.1 Theory The basic model that we use for modelling asynchronous and timing-based systems is the nondeterministic timed automaton model of Lynch and Vaandrager <ref> [18, 17, 14] </ref>. We base our work on an automaton model rather than any particular specification language, programming language or proof system in order to obtain the greatest flexibility in choice of specification and proof methods. Timed automata. <p> MMT automata. An important special case of the timed automaton model, describable in a particularly simple way, is the MMT timed automaton model [20], developed by Merritt, Modugno and Tuttle. We use a special case of their definition from <ref> [19, 14] </ref>. An MMT automaton is an I/O automaton [13] together with upper and lower bounds on time. <p> The resulting timed automaton A 0 has exactly the same admissible timed traces as the MMT automaton A. Invariants and simulations. We define an invariant of a timed automaton to be any property that is true of all reachable states. The definition of a simulation is paraphrased from <ref> [18, 17, 14] </ref>. We use the notation f [s], where f is a binary relation, to denote fu : (s; u) 2 f g. Suppose A and B are timed automata and I A and I B are invariants of A and B, respectively. <p> The MMT model is sufficient to describe all of these. The examples are summarized from <ref> [14, 15, 11] </ref>. Counting Process. The first and simplest example involves an automaton that counts down from some fixed positive integer k and then reports its completion. The time between successive steps is assumed to be in the range [c 1 ; c 2 ].
Reference: [15] <author> Nancy Lynch. </author> <title> Simulation techniques for proving properties of real-time systems. </title> <editor> In Sang H. Son, editor, </editor> <booktitle> Principles of Real-Time Systems. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: The MMT model is sufficient to describe all of these. The examples are summarized from <ref> [14, 15, 11] </ref>. Counting Process. The first and simplest example involves an automaton that counts down from some fixed positive integer k and then reports its completion. The time between successive steps is assumed to be in the range [c 1 ; c 2 ].
Reference: [16] <author> Nancy Lynch, Isaac Saias, and Roberto Segala. </author> <title> Proving time bounds for randomized distributed algorithms. </title> <booktitle> In Thirteenth Annual ACM Symposium on the Principles of Distributed Computing, </booktitle> <address> Los Angeles, CA, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: However, the development of these methods represents work in progress; eventually, the methods used for probabilistic algorithms ought to be better unified with those used for non-probabilistic algorithms. 4.1 Theory The theory we used is taken from <ref> [22, 16, 21] </ref>. Probabilistic timed automata. We modify the timed automaton model to incorporate probabilistic state transitions; specifically, we allow non-time-passage steps to be of the form (s; ; ), where is a probability distribution whose domain is a subset of the states of the algorithm. <p> This property is proved in <ref> [16] </ref> using Markov rules and coin lemmas. We use a chain of five Markov rules marking progress from T to C, each with its own time and probability bounds, and combine them using Lemma 4.1. <p> These can be proved by using the coin lemmas to reduce the problem to one involving non-probabilistic timed automata, then using methods for proving time bounds for non-probabilistic timed automata. In <ref> [16] </ref>, operational arguments are used to prove the claims for non-probabilistic timed automata, but it is clear in principle that the arguments could be redone more systematically using simulations.
Reference: [17] <author> Nancy Lynch and Frits Vaandrager. </author> <title> Forward and backward simulations Part II: </title> <journal> Timing-based systems. </journal> <note> Submitted for publication. </note>
Reference-contexts: and Lynch [12], shows how proofs using the methods in the first group can be verified mechanically. 1 2 Time Bounds for Asynchronous and Timing-Based Algorithms 2.1 Theory The basic model that we use for modelling asynchronous and timing-based systems is the nondeterministic timed automaton model of Lynch and Vaandrager <ref> [18, 17, 14] </ref>. We base our work on an automaton model rather than any particular specification language, programming language or proof system in order to obtain the greatest flexibility in choice of specification and proof methods. Timed automata. <p> The resulting timed automaton A 0 has exactly the same admissible timed traces as the MMT automaton A. Invariants and simulations. We define an invariant of a timed automaton to be any property that is true of all reachable states. The definition of a simulation is paraphrased from <ref> [18, 17, 14] </ref>. We use the notation f [s], where f is a binary relation, to denote fu : (s; u) 2 f g. Suppose A and B are timed automata and I A and I B are invariants of A and B, respectively.
Reference: [18] <author> Nancy Lynch and Frits Vaandrager. </author> <title> Forward and backward simulations for timing-based systems. </title> <booktitle> In Proceedings of REX Workshop "Real-Time: Theory in Practice", volume 600 of Lecture Notes in Computer Science, </booktitle> <pages> pages 397-446, </pages> <address> Mook, The Netherlands, June 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: and Lynch [12], shows how proofs using the methods in the first group can be verified mechanically. 1 2 Time Bounds for Asynchronous and Timing-Based Algorithms 2.1 Theory The basic model that we use for modelling asynchronous and timing-based systems is the nondeterministic timed automaton model of Lynch and Vaandrager <ref> [18, 17, 14] </ref>. We base our work on an automaton model rather than any particular specification language, programming language or proof system in order to obtain the greatest flexibility in choice of specification and proof methods. Timed automata. <p> The resulting timed automaton A 0 has exactly the same admissible timed traces as the MMT automaton A. Invariants and simulations. We define an invariant of a timed automaton to be any property that is true of all reachable states. The definition of a simulation is paraphrased from <ref> [18, 17, 14] </ref>. We use the notation f [s], where f is a binary relation, to denote fu : (s; u) 2 f g. Suppose A and B are timed automata and I A and I B are invariants of A and B, respectively.
Reference: [19] <author> Nancy A. Lynch and Hagit Attiya. </author> <title> Using mappings to prove timing properties. Distrib. </title> <journal> Comput., </journal> <volume> 6 </volume> <pages> 121-139, </pages> <year> 1992. </year>
Reference-contexts: MMT automata. An important special case of the timed automaton model, describable in a particularly simple way, is the MMT timed automaton model [20], developed by Merritt, Modugno and Tuttle. We use a special case of their definition from <ref> [19, 14] </ref>. An MMT automaton is an I/O automaton [13] together with upper and lower bounds on time. <p> In practice, the simulations often have an interesting form: a system of inequalities <ref> [19] </ref>. 2.2 Applications We sketch several examples of time bounds for asynchronous and timing-based concurrent algorithms, proved using the tools and methods described above. The MMT model is sufficient to describe all of these. The examples are summarized from [14, 15, 11]. Counting Process. <p> In every case, an important part of the simulation is a set of inequalities involving calculated upper and/or lower bounds. These calculated bounds can usually be expressed as "progress functions" that measure the time until the specification-level goals are reached. If progress functions satisfy certain properties (as detailed in <ref> [19] </ref>), then a relation derived from them in a systematic way is guaranteed to be a simulation.
Reference: [20] <author> Michael Merritt, Francemary Modugno, and Mark R. Tuttle. </author> <title> Time constrained automata. </title> <editor> In J. C. M. Baeten and J. F. Goote, editors, CONCUR'91: </editor> <booktitle> 2nd International Conference on Concur-rency Theory, volume 527 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-423, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: MMT automata. An important special case of the timed automaton model, describable in a particularly simple way, is the MMT timed automaton model <ref> [20] </ref>, developed by Merritt, Modugno and Tuttle. We use a special case of their definition from [19, 14]. An MMT automaton is an I/O automaton [13] together with upper and lower bounds on time.
Reference: [21] <author> Roberto Segala. </author> <type> PhD thesis, </type> <institution> MIT Dept. of Electrical Engineering and Computer Science, </institution> <year> 1993. </year> <note> In progress. </note>
Reference-contexts: However, the development of these methods represents work in progress; eventually, the methods used for probabilistic algorithms ought to be better unified with those used for non-probabilistic algorithms. 4.1 Theory The theory we used is taken from <ref> [22, 16, 21] </ref>. Probabilistic timed automata. We modify the timed automaton model to incorporate probabilistic state transitions; specifically, we allow non-time-passage steps to be of the form (s; ; ), where is a probability distribution whose domain is a subset of the states of the algorithm. <p> This gives rise to an ordinary (non-probabilistic) timed automaton A. Proving that the desired time bound holds with certainty for A implies that it holds with probability p in the original pta. The soundness of this strategy is justified by a series of coin lemmas in <ref> [21] </ref>. 4.2 Applications We have so far carried out two significant proofs of probabilistic time bound properties for randomized distributed algorithms. Lehmann-Rabin Dining Philosophers algorithm. The randomized Dining Philoso phers algorithm of Lehmann and Rabin works as follows.
Reference: [22] <author> Roberto Segala and Nancy Lynch. </author> <title> Probabilistic simulations for probabilistic processes. </title> <booktitle> In Proceedings of the 5th International Conference on Concurrency Theory - CONCUR'94, Lecture Notes in Computer Science, </booktitle> <institution> Uppsala, Sweden, </institution> <month> August </month> <year> 1994. </year> <note> Springer-Verlag. </note>
Reference-contexts: However, the development of these methods represents work in progress; eventually, the methods used for probabilistic algorithms ought to be better unified with those used for non-probabilistic algorithms. 4.1 Theory The theory we used is taken from <ref> [22, 16, 21] </ref>. Probabilistic timed automata. We modify the timed automaton model to incorporate probabilistic state transitions; specifically, we allow non-time-passage steps to be of the form (s; ; ), where is a probability distribution whose domain is a subset of the states of the algorithm.
References-found: 22

