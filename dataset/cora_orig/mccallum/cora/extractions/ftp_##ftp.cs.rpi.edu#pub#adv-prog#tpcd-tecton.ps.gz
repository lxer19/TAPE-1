URL: ftp://ftp.cs.rpi.edu/pub/adv-prog/tpcd-tecton.ps.gz
Refering-URL: http://www.cs.rpi.edu/~musser/Tecton/
Root-URL: http://www.cs.rpi.edu
Title: Tecton: a framework for specifying and verifying generic system components  
Author: Deepak Kapur David R. Musser 
Date: July, 1992  
Address: Albany, New York 12222  Troy, New York 12180  
Affiliation: The University at Albany  Rensselaer Polytechnic Institute  
Abstract: This paper presents the syntax and semantics of a small language for describing and using abstract concepts in formal software development and hardware design. The language provides definition, abbreviation, extension, and lemma constructs, which have general mathematical descriptive power, plus a computation-specific realization construct. The semantics, which is denotational, includes specification of the requirements ("legality conditions") that must be met when using each construct. The syntax and semantics are such that a corresponding proof theory requires only first order and inductive proof methods, rather than general higher order techniques as required in some frameworks. The language and some of the main proof issues are illustrated with an extended example of a behavioral and structural description of a carry-lookahead adder circuit, with the circuit realization given in terms of a generic parallel-prefix circuit. fl Partially supported by NSF Grant Number CCR-8906678. A preliminary version of this paper was presented at TPCD Conference 1992 (Theorem Provers in Circuit Design), University of Nijmegen, The Netherlands, June 22-24, 1992. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. S. Boyer, D. M. Goldschlag, M. Kaufman, and J S. Moore. </author> <title> "Functional Instantiation in First-Order Logic," </title> <booktitle> in Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, edited by Vladimir Lifschitz, </booktitle> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: However, a CONSTRAIN command has recently been added <ref> [1] </ref> which allows adding function symbols that are constrained by a set of axioms; the function symbols may be instantiated later, proof obligations then being generated to show that the axioms are satisfied.
Reference: [2] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: of proof trees and how the system constructs and displays such proof trees in a graphical format. (See also [24] for a general discussion of improving interfaces to theorem provers.) With regard to automation of theorem proving, one of the most successful approaches is the Boyer-Moore logic and theorem prover <ref> [2, 3] </ref>. Its well-developed heuristic approach to automation of induction proofs has achieved numerous impressive proofs, including many difficult examples of software and hardware verification. However, while many of these examples involve uses of abstraction, they are almost all instances of structural, data, or temporal abstraction. <p> Behavioral abstraction can be done by axiomatizing uninterpreted function symbols, as has been done in HOL and Ehdm, by using an AXIOM construct, but in the prover described in <ref> [2, 3] </ref> there is no specific mechanism to set up proof obligations showing the axioms are satisfied when the abstraction is later instantiated.
Reference: [3] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: of proof trees and how the system constructs and displays such proof trees in a graphical format. (See also [24] for a general discussion of improving interfaces to theorem provers.) With regard to automation of theorem proving, one of the most successful approaches is the Boyer-Moore logic and theorem prover <ref> [2, 3] </ref>. Its well-developed heuristic approach to automation of induction proofs has achieved numerous impressive proofs, including many difficult examples of software and hardware verification. However, while many of these examples involve uses of abstraction, they are almost all instances of structural, data, or temporal abstraction. <p> Behavioral abstraction can be done by axiomatizing uninterpreted function symbols, as has been done in HOL and Ehdm, by using an AXIOM construct, but in the prover described in <ref> [2, 3] </ref> there is no specific mechanism to set up proof obligations showing the axioms are satisfied when the abstraction is later instantiated.
Reference: [4] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The terminology and organization used in the example closely follows the discussion in <ref> [4, Ch. 29] </ref>. Figures 1, 2, and 3 are based on figures in [4]. <p> The terminology and organization used in the example closely follows the discussion in [4, Ch. 29]. Figures 1, 2, and 3 are based on figures in <ref> [4] </ref>. Some of the concepts used in the example are defined in the previous section. 4.1 Basic circuit elements Definition: State refines Set [with states as domain] introduces low -&gt; states, high -&gt; states; obeys not (low = high).
Reference: [5] <author> W. M. Farmer, J. D. Guttman, F. J. Thayer, </author> <title> "Little Theories," </title> <editor> in D. Kapur, ed., </editor> <booktitle> Proc. of 11th International Conference on Automated Deduction, Lecture Notes in Artificial Intelligence 607, </booktitle> <month> June </month> <year> 1992, </year> <pages> 567-581. REFERENCES 35 </pages>
Reference-contexts: The Boyer-Moore logic does not allow quantifiers (universal quantification is implicit) and thus requires a witness to be supplied wherever one might ordinarily express a specification using existential quantification (or universal quantification over a limited scope). The recently developed lutins logic and imps theorem prover <ref> [5] </ref> are oriented toward de 4 1 INTRODUCTION velopment of "little theories," supporting theory inclusions and theory interpretations, both of which aid in structuring the formalization of mathematical concepts. imps provides a greater degree of automation of proofs than the HOL, OBJ, Larch, or Ehdm provers, though it does not have
Reference: [6] <author> S. J. Garland, J. V. Guttag, and J. J. Horning, </author> <title> "Debugging Larch Shared Language Specifications," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> Vol 16, No. 9, </volume> <month> September </month> <year> 1990, </year> <pages> 1044-1057. </pages>
Reference-contexts: semantics presented here are based in part on a much earlier but incomplete description of a high-level specification language (with the same name and goals) [16, 17] and on other specification and programming languages with similar goals, including principally the OBJ series of languages [9] and the Larch Shared Language <ref> [6, 12] </ref>.
Reference: [7] <author> M. Gordon, </author> <title> "A proof generating system for Higher-Order Logic," </title> <editor> in: G. Birtwistle and P. Subrahmanyam, eds., </editor> <title> VLSI Specification, Verification and Synthesis, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1988, </year> <pages> pp. 73-128. </pages>
Reference-contexts: Third, the language limits opportunities for abstraction and instantiation (in comparison with OBJ and with the Tecton language as described here). The Higher Order Logic (HOL) language and theorem prover <ref> [7] </ref> supports use of abstraction in a fundamental way, since higher order functions and predicates are abstractions of concrete functions and predicates.
Reference: [8] <author> J. A. Goguen and R. Burstall, </author> <title> "Putting theories together to make specifications," </title> <editor> in Raj Reddy, editor, </editor> <booktitle> Proceedings, Fifth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 1045-1058. </pages>
Reference: [9] <author> J. A. Goguen, T. Winker, J. Meseguer, K. Futatsugi, and J.-P. Jouannaud, </author> <note> "Introducing OBJ," to appear in J.A. Goguen, </note> <editor> D. Coleman, and R. Gallimore (editors). </editor> <title> Applications of Algebraic Specification using OBJ, </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: The syntax and semantics presented here are based in part on a much earlier but incomplete description of a high-level specification language (with the same name and goals) [16, 17] and on other specification and programming languages with similar goals, including principally the OBJ series of languages <ref> [9] </ref> and the Larch Shared Language [6, 12]. <p> Melham [21] illustrates how four different kinds of abstraction that are 3 useful in specifying and verifying hardware can be expressed in higher order logic: behavioral, structural, data and temporal abstraction. However, higher order specifications can be difficult to understand (see <ref> [9] </ref> for one critique). While definitions of higher order functions can be used to set up generic specifications in HOL (see, for example, [14, Ch. 4.1]), this is a fairly low-level approach compared to the direct support found in Larch and OBJ for creating and combining behavioral abstractions.
Reference: [10] <author> J. A. </author> <title> Goguen "OBJ as a theorem prover, with application to hardware verification." </title> <editor> In P. Subrahmanyam and Graham Birtwistle, editors, </editor> <booktitle> Current Trends in Hardware Verification and Automated Theorem Proving, </booktitle> <pages> pp. 218-267, </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference: [11] <author> J. A. Goguen and Jose Meseguer. </author> <title> Order sorted algebra I: Equational deduction for multiple inheritance, overloading, exceptions and partial operations. </title> <type> Technical Report SRI-CSL-89-10, </type> <institution> SRI International, Computer Science Lab, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: 2.2, may specify a renaming of the function and/or its sorts; it is the renamed description which is available in that statement. 3 One use of subsorts is to allow specification of functions as total functions on the subsort which otherwise would be partial functions on the larger sort. (See <ref> [11] </ref>, which also discusses other uses.) 8 2 CONCEPTS AND CONCEPT DESCRIPTIONS | expression function-identifier expression | quantifiers expression | if expression then expression else expression | expression where variable-identifier = expression | ( expression ) Example: Definition: Associative introduces domain; +(domain, domain) -&gt; domain; obeys (for x, y, z: domain)
Reference: [12] <author> J. V. Guttag and J. J. Horning, </author> <title> "Report on the Larch Shared Language," </title> <journal> Sci. Comput. Program., </journal> <volume> vol. 6, no. 2, </volume> <pages> pp. 103-134, </pages> <month> Mar. </month> <year> 1986. </year>
Reference-contexts: semantics presented here are based in part on a much earlier but incomplete description of a high-level specification language (with the same name and goals) [16, 17] and on other specification and programming languages with similar goals, including principally the OBJ series of languages [9] and the Larch Shared Language <ref> [6, 12] </ref>.
Reference: [13] <author> J. V. Guttag, E. Horowitz, and D. R. Musser, </author> <title> "Abstract Data Types and Software Validation," </title> <journal> Comm. ACM, </journal> <volume> 21, </volume> <month> December </month> <year> 1978, </year> <pages> 1049-1064. </pages>
Reference-contexts: For assistance with this proof obligation, one may obtain from the induction principle for A a corresponding induction principle that applies to terms built with a representation function such as rep in the above example, as discussed for example in <ref> [13, Section 4] </ref>. 3 Simple examples of concept descriptions 3.1 Boolean and Natural concepts Definition: Boolean introduces bool, 3.1 Boolean and Natural concepts 21 true -&gt; bool, false -&gt; bool; generates bool freely using true, false. Remark: the above concept is actually predefined by the semantics.
Reference: [14] <author> J. Joyce. </author> <title> Multi-Level Verification of Microprocessor-Based Systems. </title> <type> PhD Thesis, </type> <institution> University of Cambridge, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: However, higher order specifications can be difficult to understand (see [9] for one critique). While definitions of higher order functions can be used to set up generic specifications in HOL (see, for example, <ref> [14, Ch. 4.1] </ref>), this is a fairly low-level approach compared to the direct support found in Larch and OBJ for creating and combining behavioral abstractions. The Ehdm language and verification environment [25] provide higher order functions and predicates, but also have a parameterized module construct.
Reference: [15] <author> D. Kapur and D. R. Musser, </author> <title> Examples of Tecton concept descriptions, </title> <note> working paper, </note> <month> May, </month> <year> 1992. </year>
Reference-contexts: In this paper we define the syntax and semantics for concept descriptions and develop a number of small examples and one extended example, a behavioral and structural description of a carry-lookahead adder circuit. A separate working paper <ref> [15] </ref> contains additional examples of concept descriptions, including an extended example of software specification (sorting algorithms based on a generic parallel-reduction operator).
Reference: [16] <author> D. Kapur, D. R. Musser, and Alexander A. Stepanov, </author> <title> "Operators and algebraic structures," </title> <booktitle> Proc. of Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Portsmouth, New Hampshire, </address> <month> October </month> <year> 1981. </year>
Reference-contexts: The syntax and semantics presented here are based in part on a much earlier but incomplete description of a high-level specification language (with the same name and goals) <ref> [16, 17] </ref> and on other specification and programming languages with similar goals, including principally the OBJ series of languages [9] and the Larch Shared Language [6, 12].
Reference: [17] <author> D. Kapur, D. R. Musser, and A. A. Stepanov, "Tecton: </author> <title> a language for manipulating generic objects," </title> <booktitle> Proc. of Program Specification Workshop, </booktitle> <institution> University of Aarhus, Denmark, </institution> <month> August </month> <year> 1981, </year> <note> Lecture Notes in Computer Science, Springer-Verlag, Vol. 134, 1982. 36 REFERENCES </note>
Reference-contexts: The syntax and semantics presented here are based in part on a much earlier but incomplete description of a high-level specification language (with the same name and goals) <ref> [16, 17] </ref> and on other specification and programming languages with similar goals, including principally the OBJ series of languages [9] and the Larch Shared Language [6, 12]. <p> The essential idea is to express "what" a computation is supposed to do, without getting into details of "how." But often we would also like to describe computations without specifying fully what they do; i.e., to abstract at the behavioral level also. As stated in <ref> [17] </ref>, We need to be able to use abstraction and specialization of concepts for the purpose of organization and understanding, irrespective of the implementation question. The intention is to capture the general properties of an abstract notion without having to specify too much detail.
Reference: [18] <author> D. Kapur, D. R. Musser, and X. Nie, </author> <title> "An overview of the Tecton Proof System," </title> <booktitle> Proc. of a Workshop on Formal Methods in Databases and Software Engineering, </booktitle> <institution> Concordia University, Montreal, </institution> <month> May 15-16, </month> <year> 1992. </year>
Reference-contexts: In Tecton abstraction and specialization are expressed using "concept descriptions." It is planned that concept descriptions will be supported by syntactic and semantic checking in an extension to the current Tecton Proof System <ref> [18] </ref>. In this paper we define the syntax and semantics for concept descriptions and develop a number of small examples and one extended example, a behavioral and structural description of a carry-lookahead adder circuit. <p> There must continue to be strong research efforts to develop theorem proving support for the above mentioned languages and others, including packaging it in a way that non-experts can use it productively. This is a goal for the Tecton Proof System <ref> [18] </ref>, in which, for example, considerable attention is being devoted to development of a good human interface. [18] contains a discussion of the Tecton notion of proofs as forests of proof trees and how the system constructs and displays such proof trees in a graphical format. (See also [24] for a <p> This is a goal for the Tecton Proof System <ref> [18] </ref>, in which, for example, considerable attention is being devoted to development of a good human interface. [18] contains a discussion of the Tecton notion of proofs as forests of proof trees and how the system constructs and displays such proof trees in a graphical format. (See also [24] for a general discussion of improving interfaces to theorem provers.) With regard to automation of theorem proving, one of <p> The lemma given at the end of Section 3.2, Lemma: Natural-mult-monoid is Monoid. which justifies the extension of Natural to have an exponentiation operator, can be proved by induction in the Tecton Proof System <ref> [18] </ref> (or in RRL [20], on which Tecton's proof capabilities are based) using the cover set method or test set method. In such proofs much of the work is done as applications of equations as rewrite rules.
Reference: [19] <author> D. Kapur and P. Narendran, </author> <title> "An equational approach to theorem proving in first-order predicate calculus," </title> <booktitle> Proc. of 8th IJCAI, </booktitle> <address> Los Angeles, Calif, </address> <year> 1985. </year>
Reference: [20] <author> D. Kapur and H. Zhang, "RRL: </author> <title> Rewrite Rule Laboratory," </title> <booktitle> Proc. of Ninth International Conference on Automated Deduction (CADE-9), </booktitle> <address> Argonne, IL, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: The lemma given at the end of Section 3.2, Lemma: Natural-mult-monoid is Monoid. which justifies the extension of Natural to have an exponentiation operator, can be proved by induction in the Tecton Proof System [18] (or in RRL <ref> [20] </ref>, on which Tecton's proof capabilities are based) using the cover set method or test set method. In such proofs much of the work is done as applications of equations as rewrite rules.
Reference: [21] <author> T. F. Melham, </author> <title> "Abstraction mechanisms for hardware verification," </title> <editor> in: G. Birtwistle and P. Subrahmanyam, eds., </editor> <title> VLSI Specification, Verification and Synthesis, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1988, </year> <pages> pp. 267-291. </pages>
Reference-contexts: The Higher Order Logic (HOL) language and theorem prover [7] supports use of abstraction in a fundamental way, since higher order functions and predicates are abstractions of concrete functions and predicates. Melham <ref> [21] </ref> illustrates how four different kinds of abstraction that are 3 useful in specifying and verifying hardware can be expressed in higher order logic: behavioral, structural, data and temporal abstraction. However, higher order specifications can be difficult to understand (see [9] for one critique).
Reference: [22] <author> J. Palsberg and M. Schwartzbach, </author> <title> "Type substitution for object-oriented programming," </title> <booktitle> OOPSLA ECOOP '90 Proceedings, </booktitle> <address> Ottawa, Canada, </address> <month> October, </month> <year> 1990, </year> <pages> 151-168. </pages>
Reference-contexts: Syntactically, the language is relatively streamlined. First, there are no explicit parameters; instead instantiations are written using a replacement notation similar to that used in Larch (and to that recently advocated for object-oriented programming languages in <ref> [22] </ref>). Unlike Larch, there are some restrictions on which symbols may be substituted for, but these restrictions follow naturally from the denotational semantics.
Reference: [23] <author> J. Rushby and F. W. von Henke. </author> <title> Formal verification of the interactive convergence clock synchronization algorithm using Ehdm. </title> <type> Technical Report SRI-CSL-89-3, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1989. </year>
Reference-contexts: Ehdm's theorem prover contains decision procedures for arithmetic and other ground theories, permitting some proofs to be done with much less user interaction than in HOL. Ehdm has been used in some very difficult formal verifications of fault-tolerance, e.g., <ref> [23] </ref>. It is, however, not as easy in Ehdm as in Larch or OBJ to build up specifications as compositions of fundamental behavioral abstractions. Another major obstacle to making the use of abstraction more common is the difficulty of constructing formal proofs.
Reference: [24] <author> L. Thery, Y. Bertot, and G. Kahn, </author> <title> "Real theorem provers deserve real user-interfaces," </title> <institution> University of Cambridge report, </institution> <month> May, </month> <year> 1992. </year>
Reference-contexts: Proof System [18], in which, for example, considerable attention is being devoted to development of a good human interface. [18] contains a discussion of the Tecton notion of proofs as forests of proof trees and how the system constructs and displays such proof trees in a graphical format. (See also <ref> [24] </ref> for a general discussion of improving interfaces to theorem provers.) With regard to automation of theorem proving, one of the most successful approaches is the Boyer-Moore logic and theorem prover [2, 3].
Reference: [25] <author> F. W. von Henke, J. S. Crowe, R. Lee, J. M. Rushby, and R. A. Whitehurst, </author> <title> "Ehdm Verification Environment: An Overview," </title> <booktitle> in 11th National Computer Security Conference, </booktitle> <address> Baltimore, Maryland, </address> <year> 1988. </year>
Reference-contexts: The Ehdm language and verification environment <ref> [25] </ref> provide higher order functions and predicates, but also have a parameterized module construct. Ehdm's theorem prover contains decision procedures for arithmetic and other ground theories, permitting some proofs to be done with much less user interaction than in HOL.
References-found: 25

