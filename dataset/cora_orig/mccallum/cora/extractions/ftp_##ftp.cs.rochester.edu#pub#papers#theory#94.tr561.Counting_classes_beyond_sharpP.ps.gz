URL: ftp://ftp.cs.rochester.edu/pub/papers/theory/94.tr561.Counting_classes_beyond_sharpP.ps.gz
Refering-URL: http://www.cs.rochester.edu/trs/theory-trs.html
Root-URL: 
Title: The Satanic Notations: Counting Classes Beyond #P and Other Definitional Adventures  
Author: Lane A. Hemaspaandra Heribert Vollmer 
Date: December 20, 1994  
Address: Rochester, NY 14627  Santa Barbara, CA 93106  
Affiliation: Department of Computer Science University of Rochester  Department of Mathematics University of California,  
Abstract: We explore the potentially "off-by-one" nature of the definitions of counting (#P versus #NP), difference (DP versus DNP), and unambiguous (UP versus UNP; FewP versus FewNP) classes, and make suggestions as to logical approaches in each case. We discuss the strangely differing representations that oracle and predicate models give for counting classes, and we survey the properties of counting classes beyond #P. We ask whether subtracting a #P function from a P function it is no greater than necessarily yields a #P function. 
Abstract-found: 1
Intro-found: 1
Reference: [AJ93] <author> C. Alvarez and B. Jenner. </author> <title> A very hard log-space counting class. </title> <journal> Theoretical Computer Science, </journal> <volume> 107 </volume> <pages> 3-30, </pages> <year> 1993. </year>
Reference-contexts: Thus, Wagner's claim mentioned earlier becomes Few = P (# few P)[1] . Counting in Log-space Let us briefly touch upon the topic of how to define a # operator for logspace classes. Logspace counting classes were first considered by Alvarez and Jenner <ref> [AJ93] </ref>. <p> Alvarez and Jenner <ref> [AJ93] </ref> showed that both # L and spanL are contained in the class # P. <p> (analogously to the remarks for # NP following Theorem 1.5) # coNL FL# NL, which directly implies # coNL FL = # NL FL = # NL # NL, that is, # P # P = # P FP = # NL FL = # NL # NL; 3 In <ref> [AJ93] </ref> it was shown that spanL = # P even implies that NL = NP. 11 or, using the equivalences we've discussed, GapP = spanL FL: This is a very nice formalization of the fact that spanL is a very hard logspace counting class. 3 Further Adventures in Notation Difference and
Reference: [All86] <author> E. Allender. </author> <title> The complexity of sparse sets in P. </title> <booktitle> In Proceedings of the 1st Structure in Complexity Theory Conference, </booktitle> <pages> pages 1-11. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #223, </note> <month> June </month> <year> 1986. </year>
Reference-contexts: What notation should one use to describe, for example, the number of accepting paths of the base level of an NP NP machine? Even more to the point, what notation can one use to describe the number of accepting computations of a FewP <ref> [All86, AR88] </ref> machine|NP machines that are required to have a global polynomial bound on their number of accepting paths? For the latter, it would be tempting to use the notation #FewP, and in fact Wagner informally did so to describe his observation that the class Few [CH90] was exactly equal to <p> Consider the subset of NP consisting of those NP sets accepted by some nondeterministic polynomial-time Turing machine that on each input has a polynomially bounded number of accepting paths (the polynomial depending on the machine, but uniform over all inputs). Allender <ref> [All86] </ref> defined this class, and called it FewNP. But in time, probably driven by the example of Valiant's notation UP (note: not UNP) for the unambiguous version of NP, the standard notation for this "fewness version of NP" has become (both in papers by Allender and by others) FewP.
Reference: [AO94] <author> E. Allender and M. Ogihara. </author> <title> Relationships among PL, #L, and the determinant. </title> <booktitle> In Proceedings of the 9th Structure in Complexity Theory Conference, </booktitle> <pages> pages 267-278. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: In the meantime, it has been observed in a number of papers (see the excellent survey by Allender and Ogihara <ref> [AO94] </ref>), that counting accepting paths of nondeterministic logspace-bounded machines characterizes the complexity of the determinant. This is an additional motivation for studying this naturally arising complexity class.
Reference: [AR88] <author> E. Allender and R. Rubinstein. </author> <title> P-printable sets. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17(6) </volume> <pages> 1193-1202, </pages> <year> 1988. </year>
Reference-contexts: What notation should one use to describe, for example, the number of accepting paths of the base level of an NP NP machine? Even more to the point, what notation can one use to describe the number of accepting computations of a FewP <ref> [All86, AR88] </ref> machine|NP machines that are required to have a global polynomial bound on their number of accepting paths? For the latter, it would be tempting to use the notation #FewP, and in fact Wagner informally did so to describe his observation that the class Few [CH90] was exactly equal to
Reference: [BGH90] <author> R. Beigel, J. Gill, and U. Hertrampf. </author> <title> Counting classes: Thresholds, parity, </title> <booktitle> mods, and fewness. In Proceedings of the 7th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 49-57. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #415, February 1990. 14 </note>
Reference-contexts: Don't worry if you don't know the technical details of the definition of apc's; what is important here is only that P, NP, all the other classes from the polynomial hierarchy, PP, P (and its generalizations to MOD k P for k prime, see <ref> [BGH90] </ref>) are all apc's; thus most counting classes beyond # P that we probably will ever deal with have the properties familiar to those who know about # P.
Reference: [BRS91] <author> R. Beigel, N. Reingold, and D. Spielman. </author> <title> PP is closed under intersection. </title> <booktitle> In Proceedings of the 23nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 1-9. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Moreover, a very abstract approach may sometimes allow one to explore the limitations of one's proof techniques. This point deserves a bit more explanation: We already mentioned Toda's result [Tod91b]. It can be shown [VW] that this result, as well as the closure of PP under intersection <ref> [BRS91] </ref>, the inclusion of BPP in the polynomial hierarchy [Sip83, Lau83], and a large number of other results also about classes definable by some quantifiers applied to the class P do in fact not only hold for P but also for any apc C (that in some cases must also be
Reference: [Bur92] <editor> H.-J. Burtschick. Dokumentation der Ergebnisse des Arbeitsteffens Komplexitatstheorie in Georgenthal/Thur. vom 24.2.1991-1.3.1991, </editor> <month> September </month> <year> 1992. </year> <note> Unpublished notes. </note>
Reference-contexts: Toran has studied the variant of Valiant's definition in which a certain "positive" requirement is added [Tor88, Chapter 2]. Valiant's above approach to counting is heavily machine-based, rather than predicate-based. In contrast, Toda ([Tod91a], see also the independent <ref> [Bur92] </ref>) proposed a predicate-based definition of a counting hierarchy, and this line has been followed in a number of recent papers [WT92,VW93,Vol94b,Vol94a]. One motivation for such a predicate-based approach is that counting is most natural in terms of predicates, and this definition allows one greater precision in specifying counting classes. <p> This is the reason why we will use the same notation "# " without becoming inconsistent. 10 Now, it can be shown <ref> [Bur92] </ref> that # L = # L and indeed that # NL = spanL: Of course, one can now again take other operators, apply them to # L (or spanL) and see what classes one obtains. <p> This is simply because in their proofs it is essential that the whole input can be read several times. Thus, it is not known whether # NL = # coNL, and the following surprising result from <ref> [Bur92] </ref> shows that this is very unlikely. Theorem 2.3 # coNL = # P.
Reference: [Bur94] <author> H.-J. Burtschick. </author> <title> Comparing counting-classes for logspace, one-way logspace, logtime, and first-order. </title> <type> Technical Report 94-39, </type> <institution> Forschungsberichte des Fachbereichs Informatik, Technische Universitat Berlin, </institution> <address> Berlin, Germany, </address> <year> 1994. </year>
Reference: [CGH + 88] <author> J. Cai, T. Gundermann, J. Hartmanis, L. Hemachandra, V. Sewelson, K. Wagner, and G. Wechsung. </author> <title> The boolean hierarchy I: Structural properties. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17(6) </volume> <pages> 1232-1252, </pages> <year> 1988. </year>
Reference: [CGH + 89] <author> J. Cai, T. Gundermann, J. Hartmanis, L. Hemachandra, V. Sewelson, K. Wagner, and G. Wechsung. </author> <title> The boolean hierarchy II: </title> <journal> Applications. SIAM Journal on Computing, </journal> <volume> 18(1) </volume> <pages> 95-111, </pages> <year> 1989. </year>
Reference: [CH90] <author> J. Cai and L. Hemachandra. </author> <title> On the power of parity polynomial time. </title> <journal> Mathematical Systems Theory, </journal> <volume> 23(2) </volume> <pages> 95-106, </pages> <year> 1990. </year>
Reference-contexts: computations of a FewP [All86, AR88] machine|NP machines that are required to have a global polynomial bound on their number of accepting paths? For the latter, it would be tempting to use the notation #FewP, and in fact Wagner informally did so to describe his observation that the class Few <ref> [CH90] </ref> was exactly equal to P #FewP [1] .
Reference: [FFK94] <author> S. Fenner, L. Fortnow, and S. Kurtz. </author> <title> Gap-definable counting classes. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 48(1) </volume> <pages> 116-148, </pages> <year> 1994. </year>
Reference-contexts: The just-mentioned fact can be stated as # C FP # coC, and we have # NP FP = # coNP FP = # P NP FP: Fenner, Fortnow, and Kurtz <ref> [FFK94] </ref> introduced the class GapP, which is the class of all functions computing the difference between the numbers of accepting and rejecting paths of nondeterministic polynomial-time Turing machines. <p> GapP is also known to have many closure properties <ref> [FFK94] </ref>.
Reference: [GP86] <author> L. Goldschlager and I. Parberry. </author> <title> On the construction of parallel computers from various bases of boolean functions. </title> <journal> Theoretical Computer Science, </journal> <volume> 43 </volume> <pages> 43-58, </pages> <year> 1986. </year>
Reference: [Hem89] <author> L. Hemachandra. </author> <title> The strong exponential hierarchy collapses. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 39(3) </volume> <pages> 299-322, </pages> <year> 1989. </year>
Reference: [HO93] <author> L. Hemachandra and M. Ogiwara. </author> <title> Is #P closed under subtraction? In G. </title> <editor> Rozenberg and A. Salomaa, editors, </editor> <booktitle> Current Trends in Theoretical Computer Science: Essays and Tutorials, </booktitle> <pages> pages 523-536. </pages> <publisher> World Scientific Press, </publisher> <year> 1993. </year>
Reference: [Imm88] <author> N. Immerman. </author> <title> Nondeterministic space is closed under complementation. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17 </volume> <pages> 935-938, </pages> <year> 1988. </year>
Reference: [Jun85] <author> H. Jung. </author> <title> On probabilistic time and space. </title> <booktitle> In Proceedings of the 12th International Colloquium on Automata, Languages, and Programming, </booktitle> <pages> pages 281-291. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #194, </note> <year> 1985. </year>
Reference-contexts: Jung <ref> [Jun85] </ref> showed that the class of problems decidable in probabilistic logspace is the same as the class of problems decidable by probabilistic logspace machines that in addition run in polynomial time.
Reference: [KST89] <author> J. Kobler, U. Schoning, and J. Toran. </author> <title> On counting and approximation. </title> <journal> Acta Informatica, </journal> <volume> 26 </volume> <pages> 363-379, </pages> <year> 1989. </year> <month> 15 </month>
Reference-contexts: Kobler, Schoning, and Toran <ref> [KST89] </ref> defined the class spanP of all functions counting the number of different outputs of nondeterministic polynomial-time transducers (i.e., Turing machines that output a value on every accepting path).
Reference: [Lan86] <author> K.-J. Lange. </author> <title> Two characterizations of the logarithmic alternation hierarchy. </title> <booktitle> In Proceedings of the 12th Symposium on Mathematical Foundations of Computer Science, </booktitle> <pages> pages 518-526. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #233, </note> <month> August </month> <year> 1986. </year>
Reference-contexts: The question we want to address here is: Can we find a natural operator such that, similar to the above result for polynomial time, spanL = # NL? It turns out that we can, using the following form of logspace-bounded machines. A 2-1-Turing machine (or, one-way protocol machine <ref> [Lan86] </ref>) is a Turing machine with two input tapes: first a (regular) input tape that can be read as often as necessary, and second, an additional (protocol) tape that can be read only once (from left to right). <p> # coNL = # NL implies # NL = # P, and this in turn yields (applying the operator U to both sides of the equation) NL = UP, contradicting our beliefs. 3 Sketch of the proof of Theorem 2.3: (This proof is essentially Lange's proof of a related result <ref> [Lan86, Theorem 3.1] </ref>.) Take #3SAT (the number of satisfying assignments of a propositional formula in conjunctive normal form with at most 3 literals per clause). This problem is # P-complete. We will sketch a logspace 2-1-TM M that solves this problem.
Reference: [Lau83] <author> C. Lautemann. </author> <title> BPP and the polynomial hierarchy. </title> <journal> Information Processing Letters, </journal> <volume> 14 </volume> <pages> 215-217, </pages> <year> 1983. </year>
Reference-contexts: observation that C P languages can be realized via machines that on rejection alway have fewer than the (polynomial-time computable) number of paths they have for acceptance, it is clear that we can also in the case discussed conclude that coNP = C P (and thus, by Sipser's and Lautemann's <ref> [Sip83, Lau83] </ref> result on simulating BPP with quantifiers and Toda and Ogihara's [TO92] result that the polynomial hierarchy is in BP C P, in this case we can conclude, for example, that the polynomial hierarchy collapses), and that UP = SPP (which is stronger than the UP = coUP conclusion mentioned <p> This point deserves a bit more explanation: We already mentioned Toda's result [Tod91b]. It can be shown [VW] that this result, as well as the closure of PP under intersection [BRS91], the inclusion of BPP in the polynomial hierarchy <ref> [Sip83, Lau83] </ref>, and a large number of other results also about classes definable by some quantifiers applied to the class P do in fact not only hold for P but also for any apc C (that in some cases must also be closed under complementation).
Reference: [Lon85] <author> T. </author> <title> Long. On restricting the size of oracles compared with restricting access to oracles. </title> <journal> SIAM Journal on Computing, </journal> <volume> 14(3) </volume> <pages> 585-597, </pages> <year> 1985. </year> <note> Erratum appears in the same journal, 17(3):628. </note>
Reference: [OH93] <author> M. Ogiwara and L. Hemachandra. </author> <title> A complexity theory for closure properties. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 46 </volume> <pages> 295-325, </pages> <year> 1993. </year>
Reference-contexts: Of course, the reasoning is correct, in light of the comments above on subtraction, if #P is closed under subtraction. However, as the closure of #P under subtraction has recently been shown <ref> [OH93] </ref> to imply that the polynomial hierarchy (and even P #P ) collapses to UP, the whole issue is trivialized in this case anyway. 2 2 Lovers of closure properties of #P ([HO93] might be helpful if you don't belong to this odd group and yet would like to wade through <p> to doubly digress, though this will lead us to an interesting research topic) for #P to have the property that if f (x) is a polynomial-time computable function and g (x) is a #P 6 The literature contains theories both of those closure properties that #P is likely to lack <ref> [OH93] </ref> and those that it is likely to possess [Reg85,CGH + 89,BGH90]. GapP is also known to have many closure properties [FFK94]. <p> That is, are all non-negative functions in FP#P themselves in #P? Though it is known that #P is exactly as unlikely to be closed under subtraction by P functions as it is to be closed under subtraction by #P functions <ref> [OH93] </ref>, the issue here is not one of subtracting P functions from #P functions but rather is one of subtracting #P functions from P functions that they are no greater than, and as far as the authors know, this has not been studied. <p> Of course, clearly if it were the case that subtracting a #P function from a P function it was no greater than would always yield a #P function, then UP = coUP. In fact, due to Simon's ([Sim75], see, e.g., <ref> [OH93] </ref> for a formal statement) implicit observation that C P languages can be realized via machines that on rejection alway have fewer than the (polynomial-time computable) number of paths they have for acceptance, it is clear that we can also in the case discussed conclude that coNP = C P (and <p> We commend to the reader the question of finding a statement about complexity classes that completely characterizes this issue. In particular, does UP = P #P completely characterize this issue (of course, from <ref> [OH93] </ref> we know that this is a sufficient condition)? We may state our question more formally as follows.
Reference: [OTTW] <author> M. Ogiwara, T. Thierauf, S. Toda, and O. Watanabe. </author> <title> On closure properties of #P in the context of PFffi#P. </title> <journal> Journal of Computer and System Sciences. </journal> <note> To appear. </note>
Reference: [PY84] <author> C. Papadimitriou and M. Yannakakis. </author> <title> The complexity of facets (and some facets of complexity). </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 28(2) </volume> <pages> 244-259, </pages> <year> 1984. </year>
Reference-contexts: that spanL is a very hard logspace counting class. 3 Further Adventures in Notation Difference and Unambiguous Classes The class DP is defined as fL fi (Historical note: the original notation was D P , but DP is now the common usage.) This class was defined by Papadimitriou and Yannakakis <ref> [PY84] </ref>, and forms the second level of the boolean hierarchy over NP [CGH + 88,CGH + 89].
Reference: [PZ83] <author> C. Papadimitriou and S. Zachos. </author> <title> Two remarks on the power of counting. </title> <booktitle> In Proceedings 6th GI Conference on Theoretical Computer Science, </booktitle> <pages> pages 269-276. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #145, </note> <year> 1983. </year>
Reference: [Reg85] <author> K. Regan. </author> <title> Enumeration problems. </title> <type> Manuscript, </type> <note> 1982; revised 1985. </note>
Reference: [Sim75] <author> J. Simon. </author> <title> On Some Central Problems in Computational Complexity. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <address> Ithaca, N.Y., </address> <month> January </month> <year> 1975. </year> <note> Available as Cornell Department of Computer Science Technical Report TR75-224. </note>
Reference-contexts: A 2 X C if the characteristic function of A can be written as the difference of two # C functions. It is well-known that the above operators capture, as special cases, the "standard" complexity classes NP, PP <ref> [Sim75] </ref>, C P [Sim75,Wag86], P [PZ83,GP86], UP [Val76], and SPP [OH93,FFK94], respectively, via 9 P = NP, C P = PP, C P = C P, P = P, U P = UP, and X P = SPP.
Reference: [Sip83] <author> M. Sipser. </author> <title> A complexity theoretic approach to randomness. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 330-335, </pages> <year> 1983. </year>
Reference-contexts: observation that C P languages can be realized via machines that on rejection alway have fewer than the (polynomial-time computable) number of paths they have for acceptance, it is clear that we can also in the case discussed conclude that coNP = C P (and thus, by Sipser's and Lautemann's <ref> [Sip83, Lau83] </ref> result on simulating BPP with quantifiers and Toda and Ogihara's [TO92] result that the polynomial hierarchy is in BP C P, in this case we can conclude, for example, that the polynomial hierarchy collapses), and that UP = SPP (which is stronger than the UP = coUP conclusion mentioned <p> This point deserves a bit more explanation: We already mentioned Toda's result [Tod91b]. It can be shown [VW] that this result, as well as the closure of PP under intersection [BRS91], the inclusion of BPP in the polynomial hierarchy <ref> [Sip83, Lau83] </ref>, and a large number of other results also about classes definable by some quantifiers applied to the class P do in fact not only hold for P but also for any apc C (that in some cases must also be closed under complementation).
Reference: [Sto77] <author> L. Stockmeyer. </author> <title> The polynomial-time hierarchy. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 1-22, </pages> <year> 1977. </year>
Reference: [Sze88] <author> R. Szelepcsenyi. </author> <title> The method of forced enumeration for nondeterministic automata. </title> <journal> Acta Informatica, </journal> <volume> 26 </volume> <pages> 279-284, </pages> <year> 1988. </year>
Reference: [TO92] <author> S. Toda and M. Ogiwara. </author> <title> Counting classes are at least as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21(2) </volume> <pages> 316-328, </pages> <year> 1992. </year>
Reference-contexts: rejection alway have fewer than the (polynomial-time computable) number of paths they have for acceptance, it is clear that we can also in the case discussed conclude that coNP = C P (and thus, by Sipser's and Lautemann's [Sip83, Lau83] result on simulating BPP with quantifiers and Toda and Ogihara's <ref> [TO92] </ref> result that the polynomial hierarchy is in BP C P, in this case we can conclude, for example, that the polynomial hierarchy collapses), and that UP = SPP (which is stronger than the UP = coUP conclusion mentioned above), where SPP is the exact counting class defined in [OH93,FFK94]. <p> It is known for example, that Toda's famous result that the polynomial hierarchy is Turing reducible to # P [Tod91b] holds in a far more general setting <ref> [TO92] </ref>. (An extensive treatment of questions of this kind can be found in [VW].) Thus, we feel that introducing general concepts (such as operators and apc's) should not be viewed as increasing the already huge number of complexity classes, but rather should be viewed as useful in gaining a more unified
Reference: [Tod91a] <author> S. </author> <title> Toda. Computational Complexity of Counting Complexity Classes. </title> <type> PhD thesis, </type> <institution> Tokyo Institute of Technology, Department of Computer Science, </institution> <address> Tokyo, Japan, </address> <year> 1991. </year> <month> 16 </month>
Reference: [Tod91b] <author> S. </author> <title> Toda. PP is as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(5) </volume> <pages> 865-877, </pages> <year> 1991. </year>
Reference-contexts: It is known for example, that Toda's famous result that the polynomial hierarchy is Turing reducible to # P <ref> [Tod91b] </ref> holds in a far more general setting [TO92]. (An extensive treatment of questions of this kind can be found in [VW].) Thus, we feel that introducing general concepts (such as operators and apc's) should not be viewed as increasing the already huge number of complexity classes, but rather should be <p> Moreover, a very abstract approach may sometimes allow one to explore the limitations of one's proof techniques. This point deserves a bit more explanation: We already mentioned Toda's result <ref> [Tod91b] </ref>.
Reference: [Tor88] <author> J. Toran. </author> <title> Structural Properties of the Counting Hierarchies. </title> <type> PhD thesis, </type> <institution> Universitat Politecnica de Catalunya, </institution> <address> Barcelona, Spain, </address> <year> 1988. </year>
Reference-contexts: Toran has studied the variant of Valiant's definition in which a certain "positive" requirement is added <ref> [Tor88, Chapter 2] </ref>. Valiant's above approach to counting is heavily machine-based, rather than predicate-based. In contrast, Toda ([Tod91a], see also the independent [Bur92]) proposed a predicate-based definition of a counting hierarchy, and this line has been followed in a number of recent papers [WT92,VW93,Vol94b,Vol94a].
Reference: [Val76] <author> L. Valiant. </author> <title> The relative complexity of checking and evaluating. </title> <journal> Information Processing Letters, </journal> <volume> 5 </volume> <pages> 20-23, </pages> <year> 1976. </year>
Reference-contexts: A 2 X C if the characteristic function of A can be written as the difference of two # C functions. It is well-known that the above operators capture, as special cases, the "standard" complexity classes NP, PP [Sim75], C P [Sim75,Wag86], P [PZ83,GP86], UP <ref> [Val76] </ref>, and SPP [OH93,FFK94], respectively, via 9 P = NP, C P = PP, C P = C P, P = P, U P = UP, and X P = SPP.
Reference: [Val79] <author> L. Valiant. </author> <title> The complexity of computing the permanent. </title> <journal> Theoretical Computer Science, </journal> <volume> 8 </volume> <pages> 189-201, </pages> <year> 1979. </year>
Reference-contexts: 1 Counting Classes Beyond #P: #NP vs. #P NP vs. #NP NP Valiant <ref> [Val79] </ref> defined #P to be the class of functions counting the number of accepting paths of NP machines. <p> The first approach we'll discuss is that presented in Valiant's seminal paper on #P. In this paper, he does define what he feels #C should mean. His definition is (slightly simplified, but capturing the definition as it applies to all the classes we'll discuss): Definition 1.1 <ref> [Val79] </ref> For any class C, define #C = [ A2C (#P) A , where by (#P) A we mean the functions counting the accepting paths of nondeterministic polynomial-time Turing machines having A as their oracle. Note that this definition has some interesting properties. <p> Though Valiant's article <ref> [Val79] </ref> defines #NP as described in Definition 1.1, in his article he claims a certain set "can be easily shown to be" Turing-complete for #NP.
Reference: [Vol94a] <author> H. Vollmer. </author> <title> Komplexitatsklassen von Funktionen. </title> <type> PhD thesis, </type> <institution> Universitat Wurzburg, Institut fur Informatik, Wurzburg, Germany, </institution> <year> 1994. </year>
Reference-contexts: To adopt the nice # notation but to ensure that this hierarchy and Valiant's won't be notationally confused, we'll follow the suggestion from <ref> [Vol94a] </ref> of using a "#" to define the new classes, e.g., # C. <p> A careful look at the definitions and a little thought (or a 3 look at <ref> [Vol94a] </ref>) reveal that for classes C and C 0 that fulfill some innocuous requirements (they have to include the class P and be closed downwards under many-one reductions) we have C U C 9 C (thus, U C = C if C is closed under existential quantification), and # C = <p> If f 2 # P, then h 2 # P (and if f 2 GapP, then h 2 GapP). It was shown in <ref> [Vol94a] </ref> that if C is a so called abstract polynomial-time complexity class (apc for short, see [VW], i.e., C contains the class P and is closed under join and conjunctive and disjunctive reductions), then # C has all three pleasant properties just described.
Reference: [Vol94b] <author> H. Vollmer. </author> <title> On different reducibility notions for function classes. </title> <booktitle> In Proceedings of the 11th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 449-460. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #775, </note> <month> February </month> <year> 1994. </year>
Reference: [VW] <author> H. Vollmer and K. Wagner. </author> <title> Complexity classes of optimization functions Information and Computation. </title> <note> To appear. </note>
Reference-contexts: If f 2 # P, then h 2 # P (and if f 2 GapP, then h 2 GapP). It was shown in [Vol94a] that if C is a so called abstract polynomial-time complexity class (apc for short, see <ref> [VW] </ref>, i.e., C contains the class P and is closed under join and conjunctive and disjunctive reductions), then # C has all three pleasant properties just described. <p> It is known for example, that Toda's famous result that the polynomial hierarchy is Turing reducible to # P [Tod91b] holds in a far more general setting [TO92]. (An extensive treatment of questions of this kind can be found in <ref> [VW] </ref>.) Thus, we feel that introducing general concepts (such as operators and apc's) should not be viewed as increasing the already huge number of complexity classes, but rather should be viewed as useful in gaining a more unified view of the huge number of currently studied classes. <p> Moreover, a very abstract approach may sometimes allow one to explore the limitations of one's proof techniques. This point deserves a bit more explanation: We already mentioned Toda's result [Tod91b]. It can be shown <ref> [VW] </ref> that this result, as well as the closure of PP under intersection [BRS91], the inclusion of BPP in the polynomial hierarchy [Sip83, Lau83], and a large number of other results also about classes definable by some quantifiers applied to the class P do in fact not only hold for P <p> We feel that FP is slightly more natural for two reasons. In the light of <ref> [VW] </ref>, where an operator F is introduced that transforms set classes into function classes and has the pleasant property that F P = FP, the first alternative seems attractive.
Reference: [VW93] <author> H. Vollmer and K. Wagner. </author> <title> The complexity of finding middle elements. </title> <journal> International Journal of Foundations of Computer Science, </journal> <volume> 4 </volume> <pages> 293-307, </pages> <year> 1993. </year>
Reference: [Wag86] <author> K. Wagner. </author> <title> Some observations on the connection between counting and recursion. </title> <journal> Theoretical Computer Science, </journal> <volume> 47 </volume> <pages> 131-147, </pages> <year> 1986. </year>
Reference: [Wag90] <author> K. Wagner. </author> <title> Bounded query classes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 19(5) </volume> <pages> 833-846, </pages> <year> 1990. </year>
Reference-contexts: that the polynomial hierarchy collapses? (b) Does UP=NP imply that the polynomial hierarchy collapses? (c) Does P=FewP imply that the polynomial hierarchy collapses? (d) Does FewP=NP imply that the polynomial hierarchy collapses? Bounded Queries Regarding bounded queries to an oracle, what is the "right" notation? For example, is the 2 <ref> [Wag90] </ref> level of the polynomial hierarchy|those sets that can be computed by P machines given O (log n) queries to an NP oracle|best denoted by P NP [O (logn)] , or by P NP [O (log n)]? Some authors prefer the latter, feeling that the restriction applies to the base machine,
Reference: [Wra77] <author> C. Wrathall. </author> <title> Complete sets and the polynomial-time hierarchy. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 23-33, </pages> <year> 1977. </year>
Reference: [WT92] <author> O. Watanabe and S. </author> <title> Toda. Polynomial time 1-Turing reductions from #PH to #P. </title> <journal> Theoretical Computer Science, </journal> <volume> 100 </volume> <pages> 205-221, </pages> <year> 1992. </year> <month> 17 </month>
References-found: 44

