URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-92-12-1.ps.Z
Refering-URL: http://www.cs.man.ac.uk/cstechrep/Abstracts/UMCS-92-12-1.html
Root-URL: http://www.cs.man.ac.uk
Title: An Object-Based Design Method for Concurrent Programs  
Author: C. B. Jones 
Address: Manchester M13 9PL, England  
Affiliation: Department of Computer Science University of Manchester  
Pubnum: Technical Report Series UMCS-92-12-1  
Abstract-found: 0
Intro-found: 1
Reference: [AdB90] <author> P. America and F. de Boer. </author> <title> A proof system for process creation. </title> <booktitle> In [BJ90], </booktitle> <pages> pages 303-332, </pages> <year> 1990. </year>
Reference-contexts: Its justification has been used in the literature to illustrate several ways of reasoning about concurrency. The implementation developed in this section is in the spirit of various programs shown in the POOL literature (versions exist in different dialects in <ref> [Ame86, AdB90] </ref>) but a test function has been added here since, without some `observer', the POOL specifications were forced to talk about internal states rather than behaviours (an alternative observer would be to add a way of listing the primes).
Reference: [Ame86] <author> Pierre America. </author> <title> A proof theory for a sequential version of POOL. </title> <type> Technical Report 0188, </type> <institution> Philips Research Laboratories, Philips Research Laboratories, Nederlandse Philips Bedrijven, B.V., </institution> <month> September </month> <year> 1986. </year>
Reference-contexts: Its justification has been used in the literature to illustrate several ways of reasoning about concurrency. The implementation developed in this section is in the spirit of various programs shown in the POOL literature (versions exist in different dialects in <ref> [Ame86, AdB90] </ref>) but a test function has been added here since, without some `observer', the POOL specifications were forced to talk about internal states rather than behaviours (an alternative observer would be to add a way of listing the primes).
Reference: [Ame89] <author> Pierre America. </author> <title> Issues in the design of a parallel object-oriented language. </title> <journal> Formal Aspects of Computing, </journal> <volume> 1(4), </volume> <year> 1989. </year>
Reference-contexts: Specification The example of building a simple symbol table is used in <ref> [Ame89] </ref>; its specification is very simple. 9 Symtab class vars st: (Key m ! Data) f g insert (k: Key, d: Data) method post st = ( search (k: Key) method res: Data pre k dom st post res = st (k) Reification The first design idea is to represent the
Reference: [Ame91a] <editor> P. America, editor. ECOOP'91, </editor> <booktitle> volume 512 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [Ame91b] <author> P. </author> <title> America. Formal techniques for parallel object-oriented languages. </title> <booktitle> In [BG91], </booktitle> <pages> pages 1-17, </pages> <year> 1991. </year>
Reference: [AR89] <author> Pierre America and Jan Rutten. </author> <title> A Parallel Object-Oriented Language: Design and Se--mantic Foundations. </title> <type> PhD thesis, </type> <institution> Free University of Amsterdam, </institution> <year> 1989. </year>
Reference-contexts: Section 6 discusses the logic used. There are at least two options for giving the semantics: a resumption semantics which fits the way methods work here (cf. <ref> [AR89, pp111] </ref>; see also [Wol88, AR92]) or mapping to Milner's Polyadic p - calculus [Mil92].
Reference: [AR92] <author> Pierre America and Jan Rutten. </author> <title> A layered semantics for a parallel object-oriented language. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4(4) </volume> <pages> 376-408, </pages> <year> 1992. </year>
Reference-contexts: Section 6 discusses the logic used. There are at least two options for giving the semantics: a resumption semantics which fits the way methods work here (cf. [AR89, pp111]; see also <ref> [Wol88, AR92] </ref>) or mapping to Milner's Polyadic p - calculus [Mil92].
Reference: [Bae90] <author> J. C. M. Baeten, </author> <title> editor. Applications of Process Algebra. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference: [BF91] <author> J. A. Bergstra and L. M. G. Feijs, </author> <title> editors. Algebraic Methods II: </title> <booktitle> Theory Tools and Applications, volume 490 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [BG91] <editor> J. C. M. Baeten and J. F. Groote, editors. </editor> <booktitle> CONCUR'91 Proceedings of the 2nd International Conference on Concurrency Theory, volume 527 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [BJ90] <editor> M. Broy and C. B. Jones, editors. </editor> <booktitle> Programming Concepts and Methods. </booktitle> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference: [BJM88] <editor> R. Bloomfield, R. B. Jones, and L. S. Marshall, editors. VDM'88: VDM TheWay Ahead, </editor> <booktitle> volume 328 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference: [BK84] <author> H. Barringer and R. Kuiper. </author> <title> Hierachical development of concurrent systems in a temporal logic framework. </title> <booktitle> In Proceedings of NSF/SERC Seminar on Concurrency, </booktitle> <address> CMU, Pittsburgh, </address> <year> 1984. </year>
Reference-contexts: The attempt to find compositional development methods for parallel programs has influenced others including some work on temporal logic (see [BKP84, dR85]) and the VVSL specification language [Mid90]; related references include <ref> [BK84, Sta85, Sti86, Sti88, Sta88, BM88, Ded89, Bro89, SW91] </ref>.
Reference: [BKP84] <author> H. Barringer, R. Kuiper, and A. Pnueli. </author> <title> Now you can compose temporal logic specification. </title> <booktitle> In Proceedings of 16th ACM STOC, </booktitle> <address> Washington, </address> <month> May </month> <year> 1984. </year>
Reference-contexts: The attempt to find compositional development methods for parallel programs has influenced others including some work on temporal logic (see <ref> [BKP84, dR85] </ref>) and the VVSL specification language [Mid90]; related references include [BK84, Sta85, Sti86, Sti88, Sta88, BM88, Ded89, Bro89, SW91].
Reference: [BM88] <author> J. Bruijning and C.A. Middelburg. </author> <title> Esprit project 1283: VIP VDM extensions: </title> <type> Final report. Technical Report 2.0, </type> <institution> PTT Research, Neher Laboratories, </institution> <address> The Netherlands, </address> <year> 1988. </year>
Reference-contexts: The attempt to find compositional development methods for parallel programs has influenced others including some work on temporal logic (see [BKP84, dR85]) and the VVSL specification language [Mid90]; related references include <ref> [BK84, Sta85, Sti86, Sti88, Sta88, BM88, Ded89, Bro89, SW91] </ref>.
Reference: [Bro89] <author> Manfred Broy. </author> <title> On bounded buffers: Modularity, robustness, and reliability in reactive systems. </title> <type> Technical Report MIP-8920, </type> <institution> Universitat Passau, Fakultat fur mathematik und Informatik, </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: The attempt to find compositional development methods for parallel programs has influenced others including some work on temporal logic (see [BKP84, dR85]) and the VVSL specification language [Mid90]; related references include <ref> [BK84, Sta85, Sti86, Sti88, Sta88, BM88, Ded89, Bro89, SW91] </ref>.
Reference: [BSI92] <author> BSI. </author> <title> VDM specification language protostandard. </title> <type> Technical Report N-231, </type> <institution> BSI IST/5/19, </institution> <year> 1992. </year>
Reference-contexts: from VDM are barely necessary in the context of a class but there are places where one really ought note that some variables are read-only.) Values of type bag etc. and operators like are part of the specification language. 2 The classes here can be compared with modules in VDM-SL <ref> [BSI92, Daw91] </ref>. 4 Priq class vars b: N-bag f g add (e: N) method post b = ( rem () method r: N pre b f g post r = min ( ( ( Just as in VDM, `satisfiability' proof obligations can be generated for each method specification.
Reference: [CLW79] <author> K. M. Chung, F. Luccio, and C. K. Wong. </author> <title> A new permutation algorithm for bubble memories. </title> <type> Technical Report RC 7633, </type> <institution> IBM Research Division, </institution> <year> 1979. </year>
Reference-contexts: The final code behaves in much the same way as BUBLAT (cf. <ref> [CLW79] </ref>) did in earlier work on `interference' proofs (e.g. [St90]) but there is much less `mechanism' visible here further steps of development could bring in the extra variables of the earlier code if so desired. Alternatives A couple of general observations can be made even after this simple example.
Reference: [CM88] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: This will be the basis on which the proof obligations are to be justified. Examples of liveness proofs have been undertaken but need polishing. Influences on choice of logical operators include UNITY <ref> [CM88] </ref> (and Misra's more recent work), as well as Lamport's TLA [Lam90, Lam91] (it might be worth defining the operators of Section 6 on top of TLA.
Reference: [Daw91] <author> J. Dawes. </author> <title> The VDM-SL Reference Guide. </title> <publisher> Pitman, </publisher> <year> 1991. </year>
Reference-contexts: from VDM are barely necessary in the context of a class but there are places where one really ought note that some variables are read-only.) Values of type bag etc. and operators like are part of the specification language. 2 The classes here can be compared with modules in VDM-SL <ref> [BSI92, Daw91] </ref>. 4 Priq class vars b: N-bag f g add (e: N) method post b = ( rem () method r: N pre b f g post r = min ( ( ( Just as in VDM, `satisfiability' proof obligations can be generated for each method specification.
Reference: [dB91] <author> Frank S. de Boer. </author> <title> Reasoning about Dynamically Evolving Process Structure. </title> <type> PhD thesis, </type> <institution> Free University of Amsterdam, </institution> <year> 1991. </year>
Reference: [Ded89] <author> Frank Dederichs. Zur strukturierung von spezifikationen verteilter systeme, </author> <month> March </month> <year> 1989. </year> <month> 23 </month>
Reference-contexts: The attempt to find compositional development methods for parallel programs has influenced others including some work on temporal logic (see [BKP84, dR85]) and the VVSL specification language [Mid90]; related references include <ref> [BK84, Sta85, Sti86, Sti88, Sta88, BM88, Ded89, Bro89, SW91] </ref>.
Reference: [dR85] <author> W. P. de Roever. </author> <title> The quest for compositionality: A survey of assertion-based proof sys-tems for concurrent programs: Part I: Concurrency based on shared variables. </title> <editor> In E. J. Neuhold and G. Chroust, editors, </editor> <booktitle> Formal Models in Programming. </booktitle> <publisher> North-Holland, </publisher> <year> 1985. </year>
Reference-contexts: The attempt to find compositional development methods for parallel programs has influenced others including some work on temporal logic (see <ref> [BKP84, dR85] </ref>) and the VVSL specification language [Mid90]; related references include [BK84, Sta85, Sti86, Sti88, Sta88, BM88, Ded89, Bro89, SW91].
Reference: [D ur92] <author> E. H. H. D urr. </author> <title> Syntactic description of the VDM++ language. </title> <type> Technical report, </type> <institution> Rijksuni-veriteit Utrecht, </institution> <year> 1992. </year>
Reference: [FP78] <author> N. Francez and A. Pnueli. </author> <title> A proof method for cyclic programs. </title> <journal> Acta Informatica, </journal> <volume> 9 </volume> <pages> 133-157, </pages> <year> 1978. </year>
Reference-contexts: It might appear that interference completely rules out the possibility of compositional development but a number of authors have attempted to tame this dragon by recording facts about interference in specifications. An early attempt is presented in <ref> [FP78] </ref> but this does not offer compositionality. The interference approach in [Jon81, Jon83a, Jon83b] suggested a compositional approach related to the Owicki/Gries method [Owi75, OG76]: rely and guarantee conditions were used to record acceptable and promised interference; proof obligations were given for operation decomposition including parallel statements.
Reference: [GH93] <author> J. V. Guttag and J. J. Horning. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Specification As in a Larch <ref> [GHW85, GH93] </ref> `interface language', the design notation is used here to provide a framework for the specification which is given as a class definition.
Reference: [GHW85] <author> J. V. Guttag, J. J. Horning, and J. M. Wing. </author> <title> Larch in five easy pieces. </title> <type> Technical Report 5, </type> <institution> DEC, SRC, </institution> <month> July </month> <year> 1985. </year>
Reference-contexts: Specification As in a Larch <ref> [GHW85, GH93] </ref> `interface language', the design notation is used here to provide a framework for the specification which is given as a class definition.
Reference: [GR89] <author> David Grosvenor and Andy Robinson. </author> <title> An evaluation of rely-guarantee, </title> <month> March </month> <year> 1989. </year> <note> Submitted to Formal Aspects of Computer Science. </note>
Reference-contexts: It was always clear that [Jon81] presented only an existence proof of ways of recording and reasoning about interference and that more research was required to make the 12 ideas useful in practice (but <ref> [WD88, GR89] </ref>, for example, show the method has been used on industrial applications).
Reference: [HHJ + 87] <author> C. A. R. Hoare, I. J. Hayes, He Jifeng, C. C. Morgan, A. W. Roscoe, J. W. Sanders, I. H. Srensen, J. M. Spivey, and B. A. Sufrin. </author> <title> The laws of programming. </title> <journal> Communications of the ACM, </journal> <volume> 30(8) </volume> <pages> 672-687, </pages> <month> August </month> <year> 1987. </year> <note> see Corrigenda in Communications of the ACM, 30(9): 770. </note>
Reference: [HT91a] <author> K. Honda and M. Tokoro. </author> <title> An object calculus for asynchronous communication. </title> <booktitle> In [Ame91a], </booktitle> <pages> pages 133-147, </pages> <year> 1991. </year>
Reference: [HT91b] <author> K. Honda and M. Tokoro. </author> <title> A small calculus for concurrent objects. </title> <journal> ACM, OOPS Messenger, </journal> <volume> 2(2) </volume> <pages> 50-54, </pages> <year> 1991. </year>
Reference: [IM91] <editor> T. Ito and A. R. Meyer, editors. </editor> <booktitle> TACS'91 Proceedings of the International Conference on Theoretical Aspects of Computer Science, Sendai, Japan, volume 526 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [JJLM91] <author> C. B. Jones, K. D. Jones, P. A. Lindsay, and R. Moore. </author> <title> mural: A Formal Development Support System. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The current approach uses concepts of object-oriented languages in order to constrain interference and fix a level of granularity. (The idea to use object-oriented languages was made more tempting by the positive experience of building a theorem proving assistant <ref> [JJLM91] </ref> in Smalltalk and more recent discussions about exploiting parallel hardware and tackling a multi-user version of mural .) It is not, however, the aim to add yet one more language to those claiming to be object-oriented; the development method envisaged here ought be used for programs in languages such as <p> As in Priq, objects (instances of classes) are created by activating new for a class name; in p obl explicit methods for new can be written. The language has no inheritance yet (it is tempting to try something like `theory morphisms' - cf. <ref> [JJLM91] </ref> because inheritance is often used to solve too many problems at once). 1 It can be useful to think of classes as blocks which can be multiply instantiated; each instance has local (instance) variables and procedures (methods); the instance variables can only be accessed or changed by the methods; methods
Reference: [Jon81] <author> C. B. Jones. </author> <title> Development Methods for Computer Programs including a Notion of Interference. </title> <type> PhD thesis, </type> <institution> Oxford University, </institution> <month> June </month> <year> 1981. </year> <note> Printed as: Programming Research Group Technical Monograph 25. </note>
Reference-contexts: It might appear that interference completely rules out the possibility of compositional development but a number of authors have attempted to tame this dragon by recording facts about interference in specifications. An early attempt is presented in [FP78] but this does not offer compositionality. The interference approach in <ref> [Jon81, Jon83a, Jon83b] </ref> suggested a compositional approach related to the Owicki/Gries method [Owi75, OG76]: rely and guarantee conditions were used to record acceptable and promised interference; proof obligations were given for operation decomposition including parallel statements. <p> The original rely/guarantee method did not cope with liveness issues but there has recently been a flurry of activity and both Stlen [St90, St91a, St91b] and Xu [XH91, Xu92] have proposed extensions to cover liveness. It was always clear that <ref> [Jon81] </ref> presented only an existence proof of ways of recording and reasoning about interference and that more research was required to make the 12 ideas useful in practice (but [WD88, GR89], for example, show the method has been used on industrial applications).
Reference: [Jon83a] <author> C. B. Jones. </author> <title> Specification and design of (parallel) programs. </title> <booktitle> In Proceedings of IFIP'83, </booktitle> <pages> pages 321-332. </pages> <publisher> North-Holland, </publisher> <year> 1983. </year>
Reference-contexts: Compositionality can be defined as follows (adapted from [Zwi88]) A development method is compositional if the fact that a design step satisfies a given specification can be justified on the basis of the specifications of any constituent components without knowledge of their interior construction Earlier work on shared-variable concurrency (see <ref> [Jon83a] </ref> which is significantly extended in [St90, St91a, St91b]) used rely and guarantee conditions both to describe and to reason about interference. <p> It might appear that interference completely rules out the possibility of compositional development but a number of authors have attempted to tame this dragon by recording facts about interference in specifications. An early attempt is presented in [FP78] but this does not offer compositionality. The interference approach in <ref> [Jon81, Jon83a, Jon83b] </ref> suggested a compositional approach related to the Owicki/Gries method [Owi75, OG76]: rely and guarantee conditions were used to record acceptable and promised interference; proof obligations were given for operation decomposition including parallel statements. <p> A program is developed which employs concurrency in much the same way as <ref> [Jon83a] </ref> implements the prime sieve here, of course, the program is built from multiple instances of classes. The development in this section is based on the initial specification of Section 5.
Reference: [Jon83b] <author> C. B. Jones. </author> <title> Tentative steps toward a development method for interfering programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(4) </volume> <pages> 596-619, </pages> <year> 1983. </year>
Reference-contexts: It might appear that interference completely rules out the possibility of compositional development but a number of authors have attempted to tame this dragon by recording facts about interference in specifications. An early attempt is presented in [FP78] but this does not offer compositionality. The interference approach in <ref> [Jon81, Jon83a, Jon83b] </ref> suggested a compositional approach related to the Owicki/Gries method [Owi75, OG76]: rely and guarantee conditions were used to record acceptable and promised interference; proof obligations were given for operation decomposition including parallel statements.
Reference: [Jon90] <author> C. B. Jones. </author> <title> Systematic Software Development using VDM. </title> <publisher> Prentice Hall International, </publisher> <address> second edition, </address> <year> 1990. </year>
Reference-contexts: Specification As in a Larch [GHW85, GH93] `interface language', the design notation is used here to provide a framework for the specification which is given as a class definition. The methods are specified by pre- and post-conditions in a style similar to that used in VDM <ref> [Jon90] </ref>. 2 In post-conditions, hooked identifiers refer to the value of the instance variables before execution of the method and undecorated identifiers refer to the values after execution of the method. <p> inds b b (i) = e del (b, i) = ( rem () method r: N pre b [ ] post r = hd ( ( del (t, i) 4 t (1, , i - 1) c t (i + 1, , len t) 3 Throughout this paper, VDM notation <ref> [Jon90] </ref> is used for sequences, maps etc. 5 The correctness of such a step can be justified by further rules (operation domain/result) of [Jon90]. <p> hd ( ( del (t, i) 4 t (1, , i - 1) c t (i + 1, , len t) 3 Throughout this paper, VDM notation <ref> [Jon90] </ref> is used for sequences, maps etc. 5 The correctness of such a step can be justified by further rules (operation domain/result) of [Jon90]. It is worth taking this opportunity to reflect on where the invariant must hold: a user would presumably accept an implementation of add which put new elements at the end of a list and then sorted it. <p> in this linear list represent the sieve value in the specification of Primes can be formalized by a retrieve function retr : Ref fi S fi N-set retr (p)(s ) 4 elems extract-seq (p, l, m)(s ) Now, still following the general pattern of development steps by data reification in <ref> [Jon90] </ref>, the methods of Primes can be specified on this representation as follows. <p> In a fully 14 formal operation decomposition one would need inference rules about the specifically object-oriented statements which supplement those (e.g. in <ref> [Jon90] </ref>) for iterative statements etc. In the code which follows, an outline proof is adumbrated by assertions.
Reference: [Jon91a] <editor> C. B. Jones. Interference resumed. In P. Bailes, editor, </editor> <booktitle> Engineering Safe Software, </booktitle> <pages> pages 31-56. </pages> <publisher> Australian Computer Society, </publisher> <year> 1991. </year> <month> 24 </month>
Reference-contexts: The fixed format of these specifications was rejected in <ref> [Jon91a] </ref> in favour of a logic with operators which use predicates of pairs of states (there are similarities with Lamport's TLA [Lam90, Lam91]). But the proofs remain long-winded and the earlier work has been dogged by issues like atomicity (granularity) and questions about where invariants etc. are supposed to hold. <p> But by the time the ideas were being recognised, it had become clear that it was possible to improve on the rather heavy proof rules for rely/guarantee conditions and to replace them by a logic with a more pleasing algebra <ref> [Jon91b, Jon91a] </ref>. 5 Sieve of Eratosthenes The `Sieve of Eratosthenes' can be used to determine prime numbers up to some stated maximum. Its justification has been used in the literature to illustrate several ways of reasoning about concurrency. <p> Where, as in Section 7, sharing of references occurs this is not an appropriate development method. 6 Global safety assertions The arguments used in Section 7 use global assertions about the evolution of computations. These assertions are written in a logic which is a development of that presented in <ref> [Jon91a] </ref>. In addition to predicates of one state p: S fi B and relations on states r: S S fi B, various modal operators are allowed. <p> It is easy to see from the types of the variables containing references that no cycles can be present. It is then, now essential to face the problem of interference. Fortunately the notation and rules of <ref> [Jon91a] </ref> cover the needs here with little modification. The designer of Primes might choose to make a step in which the new method is designed and justified in terms of a specification for Rem (postponing its implementation).
Reference: [Jon91b] <author> C. B. Jones. </author> <title> Interference revisited. </title> <editor> In J. E. Nicholls, editor, </editor> <booktitle> Z User Workshop, </booktitle> <pages> pages 58-73. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: But by the time the ideas were being recognised, it had become clear that it was possible to improve on the rather heavy proof rules for rely/guarantee conditions and to replace them by a logic with a more pleasing algebra <ref> [Jon91b, Jon91a] </ref>. 5 Sieve of Eratosthenes The `Sieve of Eratosthenes' can be used to determine prime numbers up to some stated maximum. Its justification has been used in the literature to illustrate several ways of reasoning about concurrency.
Reference: [JPZ91] <author> W. Janssen, M. Poel, and J. Zwiers. </author> <title> Action systems and action refinement in the development of parallel systems. </title> <booktitle> In [BG91], </booktitle> <pages> pages 298-316, </pages> <year> 1991. </year>
Reference: [KMMN91] <author> B. B. Kristensen, O. L. Madsen, B. Mller-Pedersen, and K. Nygaard. </author> <title> Object oriented programming in the Beta programming language. </title> <type> Technical report, </type> <institution> University of Oslo and others, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: discussions about exploiting parallel hardware and tackling a multi-user version of mural .) It is not, however, the aim to add yet one more language to those claiming to be object-oriented; the development method envisaged here ought be used for programs in languages such as ABCL [Yon90], Modula-3 [Nel91], Beta <ref> [KMMN91] </ref> or UFO [Sar92]. The claim is that some carefully chosen subset of object-oriented concepts makes the design of concurrent programs more tractable than in arbitrary shared-variable languages (or even languages like CSP).
Reference: [Lam90] <author> L. Lamport. </author> <title> A temporal logic of actions. </title> <type> Technical Report 57, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1990. </year>
Reference-contexts: The fixed format of these specifications was rejected in [Jon91a] in favour of a logic with operators which use predicates of pairs of states (there are similarities with Lamport's TLA <ref> [Lam90, Lam91] </ref>). But the proofs remain long-winded and the earlier work has been dogged by issues like atomicity (granularity) and questions about where invariants etc. are supposed to hold. <p> This will be the basis on which the proof obligations are to be justified. Examples of liveness proofs have been undertaken but need polishing. Influences on choice of logical operators include UNITY [CM88] (and Misra's more recent work), as well as Lamport's TLA <ref> [Lam90, Lam91] </ref> (it might be worth defining the operators of Section 6 on top of TLA.
Reference: [Lam91] <author> L. Lamport. </author> <title> The temporal logic of actions. </title> <type> Technical Report 79, </type> <institution> Digital, SRC, </institution> <year> 1991. </year>
Reference-contexts: The fixed format of these specifications was rejected in [Jon91a] in favour of a logic with operators which use predicates of pairs of states (there are similarities with Lamport's TLA <ref> [Lam90, Lam91] </ref>). But the proofs remain long-winded and the earlier work has been dogged by issues like atomicity (granularity) and questions about where invariants etc. are supposed to hold. <p> This will be the basis on which the proof obligations are to be justified. Examples of liveness proofs have been undertaken but need polishing. Influences on choice of logical operators include UNITY [CM88] (and Misra's more recent work), as well as Lamport's TLA <ref> [Lam90, Lam91] </ref> (it might be worth defining the operators of Section 6 on top of TLA.
Reference: [Lan66] <author> P. J. Landin. </author> <title> The next 700 programming languages. </title> <journal> Communications of the ACM, </journal> <volume> 9 </volume> <pages> 157-166, </pages> <year> 1966. </year>
Reference: [Len82] <author> C. Lengauer. </author> <title> A Methodology for Programming with Concurrency. </title> <type> PhD thesis, </type> <institution> Computer Systems Research Group, University of Toronto, </institution> <year> 1982. </year>
Reference: [Mid90] <author> C.A. Middelburg. </author> <title> Syntax and Semantics of VVSL A Language for Structured VDM Specifications. </title> <type> PhD thesis, </type> <institution> PTT Research, Department of Applied Computer Science, </institution> <month> Septem-ber </month> <year> 1990. </year>
Reference-contexts: The attempt to find compositional development methods for parallel programs has influenced others including some work on temporal logic (see [BKP84, dR85]) and the VVSL specification language <ref> [Mid90] </ref>; related references include [BK84, Sta85, Sti86, Sti88, Sta88, BM88, Ded89, Bro89, SW91].
Reference: [Mil89] <author> R. Milner. </author> <title> Functions as processes. </title> <note> In MSCS, 1989. (submitted to). </note>
Reference: [Mil92] <author> R. Milner. </author> <title> The polyadic p -calculus: A tutorial. In Logic and Algebra of Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Section 6 discusses the logic used. There are at least two options for giving the semantics: a resumption semantics which fits the way methods work here (cf. [AR89, pp111]; see also [Wol88, AR92]) or mapping to Milner's Polyadic p - calculus <ref> [Mil92] </ref>. Since the mapping to the p -calculus is quite far advanced, the working name for the design notation is p obl. (see Appendix C). 2 Linked-lists of objects The first example illustrates the object-based nature of the programming language and the role that this plays in developing programs.
Reference: [MPW91] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> Modal logics for mobile processes. </title> <booktitle> In [BG91], </booktitle> <pages> pages 45-60, </pages> <year> 1991. </year>
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes. </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference: [Nel91] <author> G. Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: more recent discussions about exploiting parallel hardware and tackling a multi-user version of mural .) It is not, however, the aim to add yet one more language to those claiming to be object-oriented; the development method envisaged here ought be used for programs in languages such as ABCL [Yon90], Modula-3 <ref> [Nel91] </ref>, Beta [KMMN91] or UFO [Sar92]. The claim is that some carefully chosen subset of object-oriented concepts makes the design of concurrent programs more tractable than in arbitrary shared-variable languages (or even languages like CSP).
Reference: [OA91] <author> E.-R. Olderog and K. R. Apt. </author> <title> Using transformations to verify parallel programs. </title> <booktitle> In [BF91], </booktitle> <pages> pages 55-82, </pages> <year> 1991. </year>
Reference: [OG76] <author> S. S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs I. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: An early attempt is presented in [FP78] but this does not offer compositionality. The interference approach in [Jon81, Jon83a, Jon83b] suggested a compositional approach related to the Owicki/Gries method <ref> [Owi75, OG76] </ref>: rely and guarantee conditions were used to record acceptable and promised interference; proof obligations were given for operation decomposition including parallel statements.
Reference: [Owi75] <author> S. Owicki. </author> <title> Axiomatic Proof Techniques for Parallel Programs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1975. </year> <pages> 75-251. </pages>
Reference-contexts: An early attempt is presented in [FP78] but this does not offer compositionality. The interference approach in [Jon81, Jon83a, Jon83b] suggested a compositional approach related to the Owicki/Gries method <ref> [Owi75, OG76] </ref>: rely and guarantee conditions were used to record acceptable and promised interference; proof obligations were given for operation decomposition including parallel statements.
Reference: [PT91] <editor> S. Prehn and W. J. Toetenel, editors. </editor> <booktitle> VDM'91 Formal Software Development Methods. Proceedings of the 4th International Symposium of VDM Europe, </booktitle> <address> Noordwijkerhout, The Netherlands, </address> <month> October </month> <year> 1991. </year> <title> Vol.1: </title> <booktitle> Conference Contributions, volume 551 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <month> 25 </month>
Reference: [RH86] <author> A.W. </author> <title> Roscoe and C.A.R. Hoare. Laws of occam programming. </title> <institution> Monograph PRG-53, Oxford University Computing Laboratory, Programming Research Group, </institution> <month> February </month> <year> 1986. </year>
Reference: [Sar92] <author> J. Sargeant. </author> <title> UFO united functions and objects draft language description. </title> <type> Technical Report UMCS-92-4-3, </type> <institution> Manchester University, </institution> <year> 1992. </year>
Reference-contexts: parallel hardware and tackling a multi-user version of mural .) It is not, however, the aim to add yet one more language to those claiming to be object-oriented; the development method envisaged here ought be used for programs in languages such as ABCL [Yon90], Modula-3 [Nel91], Beta [KMMN91] or UFO <ref> [Sar92] </ref>. The claim is that some carefully chosen subset of object-oriented concepts makes the design of concurrent programs more tractable than in arbitrary shared-variable languages (or even languages like CSP).
Reference: [Sta85] <author> Eugene W Stark. </author> <title> A proof technique for rely/guarantee properties, </title> <month> August </month> <year> 1985. </year>
Reference-contexts: The attempt to find compositional development methods for parallel programs has influenced others including some work on temporal logic (see [BKP84, dR85]) and the VVSL specification language [Mid90]; related references include <ref> [BK84, Sta85, Sti86, Sti88, Sta88, BM88, Ded89, Bro89, SW91] </ref>.
Reference: [Sta88] <author> Eugene W Stark. </author> <title> Proving entailment between conceptual state specifications. </title> <journal> Theoretical Computer Science, </journal> <volume> 56 </volume> <pages> 135-154, </pages> <year> 1988. </year>
Reference-contexts: The attempt to find compositional development methods for parallel programs has influenced others including some work on temporal logic (see [BKP84, dR85]) and the VVSL specification language [Mid90]; related references include <ref> [BK84, Sta85, Sti86, Sti88, Sta88, BM88, Ded89, Bro89, SW91] </ref>.
Reference: [Sti86] <author> C. Stirling. </author> <title> A compositional reformulation of Owicki-Gries' partial correctness logic for a concurrent while language. In ICALP'86. </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> LNCS 226. </note>
Reference-contexts: The attempt to find compositional development methods for parallel programs has influenced others including some work on temporal logic (see [BKP84, dR85]) and the VVSL specification language [Mid90]; related references include <ref> [BK84, Sta85, Sti86, Sti88, Sta88, BM88, Ded89, Bro89, SW91] </ref>.
Reference: [Sti88] <author> C. Stirling. </author> <title> A generalisation of Owicki-Gries's Hoare logic for a concurrent while language. </title> <journal> TCS, </journal> <volume> 58 </volume> <pages> 347-359, </pages> <year> 1988. </year>
Reference-contexts: The attempt to find compositional development methods for parallel programs has influenced others including some work on temporal logic (see [BKP84, dR85]) and the VVSL specification language [Mid90]; related references include <ref> [BK84, Sta85, Sti86, Sti88, Sta88, BM88, Ded89, Bro89, SW91] </ref>.
Reference: [St90] <author> K. Stlen. </author> <title> Development of Parallel Programs on Shared Data-Structures. </title> <type> PhD thesis, </type> <institution> Manchester University, </institution> <year> 1990. </year> <note> available as UMCS-91-1-1. </note>
Reference-contexts: (adapted from [Zwi88]) A development method is compositional if the fact that a design step satisfies a given specification can be justified on the basis of the specifications of any constituent components without knowledge of their interior construction Earlier work on shared-variable concurrency (see [Jon83a] which is significantly extended in <ref> [St90, St91a, St91b] </ref>) used rely and guarantee conditions both to describe and to reason about interference. The fixed format of these specifications was rejected in [Jon91a] in favour of a logic with operators which use predicates of pairs of states (there are similarities with Lamport's TLA [Lam90, Lam91]). <p> The final code behaves in much the same way as BUBLAT (cf. [CLW79]) did in earlier work on `interference' proofs (e.g. <ref> [St90] </ref>) but there is much less `mechanism' visible here further steps of development could bring in the extra variables of the earlier code if so desired. Alternatives A couple of general observations can be made even after this simple example. <p> The original rely/guarantee method did not cope with liveness issues but there has recently been a flurry of activity and both Stlen <ref> [St90, St91a, St91b] </ref> and Xu [XH91, Xu92] have proposed extensions to cover liveness.
Reference: [St91a] <author> K. Stlen. </author> <title> A Method for the Development of Totally Correct Shared-State Parallel Programs. </title> <booktitle> In [BG91], </booktitle> <pages> pages 510-525, </pages> <year> 1991. </year>
Reference-contexts: (adapted from [Zwi88]) A development method is compositional if the fact that a design step satisfies a given specification can be justified on the basis of the specifications of any constituent components without knowledge of their interior construction Earlier work on shared-variable concurrency (see [Jon83a] which is significantly extended in <ref> [St90, St91a, St91b] </ref>) used rely and guarantee conditions both to describe and to reason about interference. The fixed format of these specifications was rejected in [Jon91a] in favour of a logic with operators which use predicates of pairs of states (there are similarities with Lamport's TLA [Lam90, Lam91]). <p> The original rely/guarantee method did not cope with liveness issues but there has recently been a flurry of activity and both Stlen <ref> [St90, St91a, St91b] </ref> and Xu [XH91, Xu92] have proposed extensions to cover liveness.
Reference: [St91b] <author> K. Stlen. </author> <title> An Attempt to Reason About Shared-State Concurrency in the Style of VDM. </title> <booktitle> In [PT91], </booktitle> <pages> pages 324-342, </pages> <year> 1991. </year>
Reference-contexts: (adapted from [Zwi88]) A development method is compositional if the fact that a design step satisfies a given specification can be justified on the basis of the specifications of any constituent components without knowledge of their interior construction Earlier work on shared-variable concurrency (see [Jon83a] which is significantly extended in <ref> [St90, St91a, St91b] </ref>) used rely and guarantee conditions both to describe and to reason about interference. The fixed format of these specifications was rejected in [Jon91a] in favour of a logic with operators which use predicates of pairs of states (there are similarities with Lamport's TLA [Lam90, Lam91]). <p> The original rely/guarantee method did not cope with liveness issues but there has recently been a flurry of activity and both Stlen <ref> [St90, St91a, St91b] </ref> and Xu [XH91, Xu92] have proposed extensions to cover liveness.
Reference: [SW91] <author> J. Sa and B. C. Warboys. </author> <title> Specifying concurrent object-based systems using combined specification notations. </title> <type> Technical Report UMCS-91-7-2, </type> <institution> Manchester University, </institution> <year> 1991. </year>
Reference-contexts: The attempt to find compositional development methods for parallel programs has influenced others including some work on temporal logic (see [BKP84, dR85]) and the VVSL specification language [Mid90]; related references include <ref> [BK84, Sta85, Sti86, Sti88, Sta88, BM88, Ded89, Bro89, SW91] </ref>.
Reference: [Vaa90] <author> F. W. Vaandrager. </author> <title> Process algebra semantics of POOL. </title> <booktitle> In [Bae90], </booktitle> <pages> pages 173-236. </pages> <year> 1990. </year>
Reference: [Wal91] <author> D. Walker. </author> <title> p -Calculus semantics of object-oriented programming languages. </title> <booktitle> In [IM91], </booktitle> <pages> pages 532-547, </pages> <year> 1991. </year>
Reference: [Wal93] <author> D. Walker. </author> <title> Objects in the p -calculus. </title> <journal> Information and Computation, </journal> <note> 1993. (to appear). </note>
Reference: [WD88] <author> J. C. P. Woodcock and B. Dickinson. </author> <title> Using VDM with rely and guarantee-conditions: Experiences of a real project. </title> <booktitle> In [BJM88], </booktitle> <pages> pages 434-458, </pages> <year> 1988. </year>
Reference-contexts: It was always clear that [Jon81] presented only an existence proof of ways of recording and reasoning about interference and that more research was required to make the 12 ideas useful in practice (but <ref> [WD88, GR89] </ref>, for example, show the method has been used on industrial applications).
Reference: [Wol88] <author> Mario I. Wolczko. </author> <title> Semantics of Object-Oriented Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Manchester, </institution> <month> January </month> <year> 1988. </year>
Reference-contexts: Section 6 discusses the logic used. There are at least two options for giving the semantics: a resumption semantics which fits the way methods work here (cf. [AR89, pp111]; see also <ref> [Wol88, AR92] </ref>) or mapping to Milner's Polyadic p - calculus [Mil92].
Reference: [XH91] <author> Qiwen Xu and Jifeng He. </author> <title> A theory of state-based parallel programming by refinement: Part I. </title> <editor> In J. Morris, editor, </editor> <booktitle> Proceedings of The Fourth BCS-FACS Refinement Workshop. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The original rely/guarantee method did not cope with liveness issues but there has recently been a flurry of activity and both Stlen [St90, St91a, St91b] and Xu <ref> [XH91, Xu92] </ref> have proposed extensions to cover liveness.
Reference: [Xu92] <author> Qiwen Xu. </author> <title> A Theory of State-based Parallel Programming. </title> <type> PhD thesis, </type> <institution> Oxford University, </institution> <year> 1992. </year>
Reference-contexts: The original rely/guarantee method did not cope with liveness issues but there has recently been a flurry of activity and both Stlen [St90, St91a, St91b] and Xu <ref> [XH91, Xu92] </ref> have proposed extensions to cover liveness.
Reference: [Yon90] <editor> Akinori Yonezawa, editor. </editor> <title> ABCL: An Object-Oriented Concurrent System. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Smalltalk and more recent discussions about exploiting parallel hardware and tackling a multi-user version of mural .) It is not, however, the aim to add yet one more language to those claiming to be object-oriented; the development method envisaged here ought be used for programs in languages such as ABCL <ref> [Yon90] </ref>, Modula-3 [Nel91], Beta [KMMN91] or UFO [Sar92]. The claim is that some carefully chosen subset of object-oriented concepts makes the design of concurrent programs more tractable than in arbitrary shared-variable languages (or even languages like CSP).

References-found: 73

