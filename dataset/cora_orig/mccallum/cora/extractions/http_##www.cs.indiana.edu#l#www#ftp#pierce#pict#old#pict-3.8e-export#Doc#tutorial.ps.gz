URL: http://www.cs.indiana.edu/l/www/ftp/pierce/pict/old/pict-3.8e-export/Doc/tutorial.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/pict/old/pict-3.8e-export/Doc/
Root-URL: http://www.cs.indiana.edu
Email: benjamin.pierce@cl.cam.ac.uk  
Title: Programming in the Pi-Calculus A Tutorial Introduction to Pict (Pict Version 3.8d completely up to
Author: Benjamin C. Pierce 
Note: This version of the Tutorial corresponds to an interim release of Pict. It is not  Chapters 1 to 7 are in fairly good shape.  
Date: July 10, 1996  
Address: New Museums Site Pembroke Street Cambridge CB2 3QG United Kingdom  
Affiliation: Computer Laboratory  
Abstract-found: 0
Intro-found: 0
Reference: [AC93] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year> <note> A preliminary version appeared in POPL '91 (pp. 104-118), and as DEC Systems Research Center Research Report number 62, </note> <month> August </month> <year> 1990. </year>
Reference-contexts: Such recursive types have received considerable attention in the literature (e.g. <ref> [CC91, AC93, Car89, BM92, Ghe93, MPS86, Wan87, TW93, AP90, KPS93] </ref>), and many different technical treatments have been proposed. <p> However, this kind of automatic unfolding can have serious consequences for the efficiency of typechecking. 1 Moreover, the theoretical foundations of type systems combining this automatic unfolding with the other features present in Pict (e.g. subtyping and polymorphism) are only beginning to receive satisfactory treatment (cf. <ref> [AC93] </ref>). We have therefore chosen the second alternative for Pict. Actually, both unfolding and folding annotations are needed.
Reference: [Agh86] <author> Gul A. Agha. </author> <title> Actors: a Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference: [AP90] <author> M Abadi and G. D. Plotkin. </author> <title> A PER model of polymorphism and recursive types. </title> <booktitle> In Proc. IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 355-365, </pages> <year> 1990. </year>
Reference-contexts: Such recursive types have received considerable attention in the literature (e.g. <ref> [CC91, AC93, Car89, BM92, Ghe93, MPS86, Wan87, TW93, AP90, KPS93] </ref>), and many different technical treatments have been proposed.
Reference: [BM92] <author> Kim Bruce and John Mitchell. </author> <title> PER models of subtyping, recursive types and higher-order poly-morphism. </title> <booktitle> In Proceedings of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albequerque, NM, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Such recursive types have received considerable attention in the literature (e.g. <ref> [CC91, AC93, Car89, BM92, Ghe93, MPS86, Wan87, TW93, AP90, KPS93] </ref>), and many different technical treatments have been proposed.
Reference: [Bou92] <author> Gerard Boudol. </author> <title> Asynchrony and the -calculus (note). </title> <institution> Rapporte de Recherche 1702, INRIA Sofia-Antipolis, </institution> <month> May </month> <year> 1992. </year>
Reference: [Bru94] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2), </volume> <month> April </month> <year> 1994. </year> <title> A preliminary version appeared in POPL 1993 under the title "Safe Type Checking in a Statically Typed Object-Oriented Programming Language". </title>
Reference: [Car84] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In G. Kahn, D. MacQueen, and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <note> Full version in Information and Computation </note> 76(2/3):138-164, 1988. 
Reference: [Car86] <author> Luca Cardelli. </author> <title> Amber. </title> <editor> In Guy Cousineau, Pierre-Louis Curien, and Bernard Robinet, editors, </editor> <booktitle> Combinators and Functional Programming Languages, </booktitle> <pages> pages 21-47. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> Lecture Notes in Computer Science No. 242. </note>
Reference: [Car89] <author> Felice Cardone. </author> <title> Relational semantics for recursive types and bounded quantification. </title> <booktitle> In Proceedings of the Sixteenth International Colloquium on Automata, Languages, and Programming, volume 372 of Lecture Notes in Computer Science, </booktitle> <pages> pages 164-178, </pages> <address> Stresa, Italy, July 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Such recursive types have received considerable attention in the literature (e.g. <ref> [CC91, AC93, Car89, BM92, Ghe93, MPS86, Wan87, TW93, AP90, KPS93] </ref>), and many different technical treatments have been proposed.
Reference: [Car90] <author> Luca Cardelli. </author> <title> Notes about F ! &lt;: </title> . <type> Unpublished manuscript, </type> <month> October </month> <year> 1990. </year>
Reference-contexts: The treatment here is intended only to illustrate the use of higher-order polymorphism in programming, not to discuss all aspects of the type system in detail or to do justice to the theoretical issues involved. Background reading can be found in <ref> [Car91, PDM89, Car90, PS96, HP95, Com94] </ref>. 13.1 Overview If we are going to do "typechecking of type expressions," then clearly we need to introduce a language of "types of type expressions." To keep the terminology from getting out of hand, it helps to give a different name to this level of
Reference: [Car91] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> An earlier version appeared as DEC Systems Research Center Research Report #45, </note> <month> February </month> <year> 1989. </year>
Reference-contexts: The treatment here is intended only to illustrate the use of higher-order polymorphism in programming, not to discuss all aspects of the type system in detail or to do justice to the theoretical issues involved. Background reading can be found in <ref> [Car91, PDM89, Car90, PS96, HP95, Com94] </ref>. 13.1 Overview If we are going to do "typechecking of type expressions," then clearly we need to introduce a language of "types of type expressions." To keep the terminology from getting out of hand, it helps to give a different name to this level of <p> Figure 14.1 (adapted from <ref> [Car91] </ref>) should help to see the relation between the levels of values, types, and kinds. The level of values contains familiar entities like 5, true, ref [5], the tuple [5,5], and the channel c.
Reference: [Car93] <author> Luca Cardelli. </author> <title> An implementation of F &lt;: </title> . <type> Research report 97, </type> <institution> DEC Systems Research Center, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Similar ideas have been used in a number of programming languages and theorem provers; our implementation is based on one used by Cardelli <ref> [Car93] </ref> in his implementation of System F . 1 We begin by introducing unification variables, which stand for "unknown types." A unification variable can be introduced explicitly in a program by writing Any in place of a type expression. 1 Technically, our algorithm differs from Cardelli's mainly in the places where
Reference: [CC91] <author> Felice Cardone and Mario Coppo. </author> <title> Type inference with recursive types. Syntax and semantics. </title> <journal> Information and Computation, </journal> <volume> 92(1) </volume> <pages> 48-80, </pages> <year> 1991. </year> <month> 100 </month>
Reference-contexts: Such recursive types have received considerable attention in the literature (e.g. <ref> [CC91, AC93, Car89, BM92, Ghe93, MPS86, Wan87, TW93, AP90, KPS93] </ref>), and many different technical treatments have been proposed.
Reference: [CCH + 89] <author> Peter Canning, William Cook, Walter Hill, Walter Olthoff, and John Mitchell. </author> <title> F-bounded quan-tification for object-oriented programming. </title> <booktitle> In Fourth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <month> September </month> <year> 1989. </year>
Reference: [CG92] <author> Pierre-Louis Curien and Giorgio Ghelli. </author> <title> Coherence of subsumption: Minimum typing and type-checking in F . Mathematical Structures in Computer Science, </title> <booktitle> 2 </booktitle> <pages> 55-91, </pages> <year> 1992. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference: [CHC90] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference: [Chu41] <author> Alonzo Church. </author> <title> The Calculi of Lambda Conversion. </title> <publisher> Princeton University Press, </publisher> <year> 1941. </year>
Reference: [CM91] <author> Luca Cardelli and John Mitchell. </author> <title> Operations on records. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 1 </volume> <pages> 3-48, </pages> <year> 1991. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design (MIT Press, </title> <note> 1994); available as DEC Systems Research Center Research Report #48, </note> <month> August, </month> <year> 1989, </year> <booktitle> and in the proceedings of MFPS '89, </booktitle> <publisher> Springer LNCS volume 442. </publisher>
Reference: [CMMS94] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An extension of system F with subtyping. </title> <journal> Information and Computation, </journal> <note> 109(1-2):4-56, 1994. A preliminary version appeared in TACS '91 (Sendai, Japan, pp. 750-770). </note>
Reference: [Com94] <author> Adriana B. Compagnoni. </author> <title> Decidability of higher-order subtyping with intersection types. </title> <booktitle> In Computer Science Logic, </booktitle> <month> September </month> <year> 1994. </year> <title> Kazimierz, </title> <booktitle> Poland. Springer Lecture Notes in Computer Science 933, </booktitle> <month> June </month> <year> 1995. </year> <note> Also available as University of Edinburgh, LFCS technical report ECS-LFCS-94-281, titled "Subtyping in F ! ^ is decidable". </note>
Reference-contexts: The treatment here is intended only to illustrate the use of higher-order polymorphism in programming, not to discuss all aspects of the type system in detail or to do justice to the theoretical issues involved. Background reading can be found in <ref> [Car91, PDM89, Car90, PS96, HP95, Com94] </ref>. 13.1 Overview If we are going to do "typechecking of type expressions," then clearly we need to introduce a language of "types of type expressions." To keep the terminology from getting out of hand, it helps to give a different name to this level of <p> C.f. <ref> [PS96, Com94] </ref>.) Conversion, written = fi&gt; , is the transitive, reflexive, and symmetric closure of ! fi&gt; .
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: introduction and elimination rules for existential types (e.g. <ref> [CW85, MP88] </ref>).
Reference: [dB72] <author> Nicolas G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5):381 392, </volume> <year> 1972. </year>
Reference: [DM82] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <year> 1982. </year>
Reference-contexts: In the best case (as in ML, for example <ref> [Mil78, DM82] </ref>), it can be shown that the type inference method is complete, in the sense that it accepts any program whose explicitly typed form (with all type annotations explicitly included in the text) is well typed.
Reference: [FM94] <author> Kathleen Fisher and John Mitchell. </author> <booktitle> Notes on typed object-oriented programming. In Proceedings of Theoretical Aspects of Computer Software, Sendai, Japan, </booktitle> <pages> pages 844-885. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1994. </year> <note> LNCS 789. </note>
Reference: [Gay93] <author> Simon J. Gay. </author> <title> A sort inference algorithm for the polyadic -calculus. </title> <booktitle> In Proceedings of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference: [Ghe93] <author> Giorgio Ghelli. </author> <title> Recursive types are not conservative over F . In Typed Lambda Calculus and Applications, </title> <month> March </month> <year> 1993. </year>
Reference-contexts: Such recursive types have received considerable attention in the literature (e.g. <ref> [CC91, AC93, Car89, BM92, Ghe93, MPS86, Wan87, TW93, AP90, KPS93] </ref>), and many different technical treatments have been proposed.
Reference: [Ghe95] <author> Giorgio Ghelli. </author> <title> Divergence of F type checking. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 139(1,2):131-162, </address> <year> 1995. </year>
Reference: [GMW79] <author> Michael J. Gordon, Robin Milner, and Christopher P. </author> <title> Wadsworth. </title> <publisher> Edinburgh LCF. Springer Verlag LNCS 78, </publisher> <year> 1979. </year>
Reference: [GP96] <author> Giorgio Ghelli and Benjamin Pierce. </author> <title> Bounded existentials and minimal typing. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1996. </year> <note> To appear. 101 </note>
Reference: [Hew77] <author> C. Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Artificial Intelligence, </journal> <volume> 8 </volume> <pages> 323-364, </pages> <year> 1977. </year>
Reference: [HP95] <author> Martin Hofmann and Benjamin Pierce. </author> <title> A unifying type-theoretic framework for objects. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(4) </volume> <pages> 593-635, </pages> <month> October </month> <year> 1995. </year> <note> Previous versions appeared in the Symposium on Theoretical Aspects of Computer Science, </note> <year> 1994, </year> <title> (pages 251-262) and, under the title "An Abstract View of Objects and Subtyping (Preliminary Report)," as University of Edinburgh, </title> <type> LFCS technical report ECS-LFCS-92-226, </type> <year> 1992. </year>
Reference-contexts: The treatment here is intended only to illustrate the use of higher-order polymorphism in programming, not to discuss all aspects of the type system in detail or to do justice to the theoretical issues involved. Background reading can be found in <ref> [Car91, PDM89, Car90, PS96, HP95, Com94] </ref>. 13.1 Overview If we are going to do "typechecking of type expressions," then clearly we need to introduce a language of "types of type expressions." To keep the terminology from getting out of hand, it helps to give a different name to this level of
Reference: [HT91] <author> Kohei Honda and Mario Tokoro. </author> <title> An object calculus for asynchronous communication. </title> <editor> In Pierre America, editor, </editor> <booktitle> Proceedings of the European Conference on Object-Oriented Programming (ECOOP), volume 512 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, Tokyo, </address> <year> 1991. </year>
Reference: [Jon93] <author> Cliff B. Jones. </author> <title> A pi-calculus semantics for an object-based design notation. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings of CONCUR'93, </booktitle> <volume> LNCS 715, </volume> <pages> pages 158-172. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: a fresh copy of processRequest (passing the clients new value v' as the new current value in the case of set). 10.3 Example: Priority Queues One simple concurrent data structure, illustrating some common Pictish programming idioms, is the priority queue, a standard example from the concurrent object-oriented programming literature (e.g. <ref> [Jon93, Wal94] </ref>). A priority queue represents a collection of elements of some ordered set | say, for simplicity, the integers.
Reference: [KPS93] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient recursive subtyping. </title> <booktitle> In Proceedings POPL '93, </booktitle> <pages> pages 419-428, </pages> <year> 1993. </year>
Reference-contexts: Such recursive types have received considerable attention in the literature (e.g. <ref> [CC91, AC93, Car89, BM92, Ghe93, MPS86, Wan87, TW93, AP90, KPS93] </ref>), and many different technical treatments have been proposed.
Reference: [Lan66] <author> P. J. Landin. </author> <title> The next 700 programming languages. </title> <journal> Communications of the ACM, </journal> <volume> 9(3) </volume> <pages> 157-166, </pages> <month> March </month> <year> 1966. </year>
Reference: [McC78] <author> John McCarthy. </author> <title> History of Lisp. </title> <booktitle> In Proceedings of the first ACM conference on History of Programming Languages, </booktitle> <pages> pages 217-223, </pages> <year> 1978. </year> <journal> ACM Sigplan Notices, </journal> <volume> Vol. 13, No 8, </volume> <month> August </month> <year> 1978. </year>
Reference: [Mil78] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: In the best case (as in ML, for example <ref> [Mil78, DM82] </ref>), it can be shown that the type inference method is complete, in the sense that it accepts any program whose explicitly typed form (with all type annotations explicitly included in the text) is well typed.
Reference: [Mil80] <author> Robin Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1980. </year>
Reference: [Mil89] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference: [Mil90] <author> Robin Milner. </author> <title> Functions as processes. </title> <type> Research Report 1154, </type> <institution> INRIA, Sofia Antipolis, </institution> <year> 1990. </year> <note> Final version in Journal of Mathematical Structures in Computer Science 2(2) 119-141, </note> <year> 1992. </year>
Reference: [Mil91] <author> Robin Milner. </author> <title> The polyadic -calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edin-burgh, UK, </institution> <month> October </month> <year> 1991. </year> <booktitle> Proceedings of the International Summer School on Logic and Algebra of Specification, Marktoberdorf, </booktitle> <month> August </month> <year> 1991. </year> <title> Reprinted in Logic and Algebra of Specification, </title> <editor> ed. F. L. Bauer, W. Brauer, and H. Schwichtenberg, </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [Mil92] <author> Robin Milner. </author> <title> Action structures. </title> <type> Technical Report ECS-LFCS-92-249, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> December </month> <year> 1992. </year>
Reference: [Mil95] <author> Robin Milner. </author> <title> Calculi for interaction. </title> <journal> Acta Informatica, </journal> <note> 1995. To appear. </note>
Reference: [Mit90] <author> John C. Mitchell. </author> <title> Toward a typed foundation for method specialization and inheritance. </title> <booktitle> In Proceedings of the 17th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-124, </pages> <month> January </month> <year> 1990. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference: [MP88] <author> John Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: introduction and elimination rules for existential types (e.g. <ref> [CW85, MP88] </ref>).
Reference: [MPS86] <author> David MacQueen, Gordon Plotkin, and Ravi Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> <volume> 71 </volume> <pages> 95-130, </pages> <year> 1986. </year>
Reference-contexts: Such recursive types have received considerable attention in the literature (e.g. <ref> [CC91, AC93, Car89, BM92, Ghe93, MPS86, Wan87, TW93, AP90, KPS93] </ref>), and many different technical treatments have been proposed.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes (Parts I and II). </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year> <month> 102 </month>
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference: [Nie92] <author> Oscar Nierstrasz. </author> <title> Towards an object calculus. </title> <editor> In M. Tokoro, O. Nierstrasz, and P. Wegner, editors, </editor> <booktitle> Proceedings of the ECOOP '91 Workshop on Object-Based Concurrent Computing, Lecture Notes in Computer Science number 612, </booktitle> <pages> pages 1-20. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [NM88] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Robert A. Kowalski and Ken-neth A. Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <volume> Volume 1, </volume> <pages> pages 810-827, </pages> <address> Cambridge, Massachusetts, August 1988. </address> <publisher> MIT Press. </publisher>
Reference: [NP96] <author> Uwe Nestmann and Benjamin C. Pierce. </author> <title> Decoding choice encodings. </title> <booktitle> In Proceedings of CONCUR '96, </booktitle> <month> August </month> <year> 1996. </year>
Reference: [NSL96] <author> Oscar Nierstrasz, Jean-Guy Schneider, and Markus Lumpe. </author> <title> Formalizing composable software systems | a research agenda. In Formal Methods in Open, </title> <booktitle> Object-Based Distributed Systems (FMOODS '96), </booktitle> <month> February </month> <year> 1996. </year>
Reference: [Pap91] <author> M. Papathomas. </author> <title> A unifying framework for process calculus semantics of concurrent object-based languages and features. </title> <editor> In Dennis Tsichritzis, editor, </editor> <booktitle> Object composition Composition d'objets, </booktitle> <pages> pages 205-224. </pages> <institution> Centre Universitaire d'Informatique, Universite de Geneve, </institution> <month> [6] </month> <year> 1991. </year>
Reference: [PDM89] <author> Benjamin Pierce, Scott Dietzen, and Spiro Michaylov. </author> <title> Programming in higher-order typed lambda-calculi. </title> <type> Technical Report CMU-CS-89-111, </type> <institution> Carnegie Mellon University, </institution> <month> March </month> <year> 1989. </year> <note> Available through http://www.cl.cam.ac.uk/users/bcp1000/ftp. </note>
Reference-contexts: The treatment here is intended only to illustrate the use of higher-order polymorphism in programming, not to discuss all aspects of the type system in detail or to do justice to the theoretical issues involved. Background reading can be found in <ref> [Car91, PDM89, Car90, PS96, HP95, Com94] </ref>. 13.1 Overview If we are going to do "typechecking of type expressions," then clearly we need to introduce a language of "types of type expressions." To keep the terminology from getting out of hand, it helps to give a different name to this level of
Reference: [Pie94] <author> Benjamin C. Pierce. </author> <title> Bounded quantification is undecidable. </title> <journal> Information and Computation, </journal> <volume> 112(1) </volume> <pages> 131-165, </pages> <month> July </month> <year> 1994. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year> <note> A preliminary version appeared in POPL '92. </note>
Reference: [Pie96] <author> Benjamin C. Pierce. </author> <title> Programming in the pi-calculus: A tutorial introduction to pict. </title> <note> Available electronically, </note> <year> 1996. </year>
Reference: [Pol90] <author> Robert Pollack. </author> <title> Implicit syntax. </title> <booktitle> Informal Proceedings of First Workshop on Logical Frameworks, Antibes, </booktitle> <month> May </month> <year> 1990. </year>
Reference: [PRT93] <author> Benjamin C. Pierce, Didier Remy, and David N. Turner. </author> <title> A typed higher-order programming language based on the pi-calculus. In Workshop on Type Theory and its Application to Computer Systems, </title> <publisher> Kyoto University, </publisher> <month> July </month> <year> 1993. </year>
Reference: [PS93] <author> Benjamin Pierce and Davide Sangiorgi. </author> <title> Typing and subtyping for mobile processes. </title> <booktitle> In Logic in Computer Science, </booktitle> <year> 1993. </year> <note> Full version to appear in Mathematical Structures in Computer Science, </note> <year> 1996. </year>
Reference: [PS96] <author> Benjamin Pierce and Martin Steffen. </author> <title> Higher-order subtyping. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1996. </year> <note> To appear. A preliminary version appeared in IFIP Working Conference on Programming Concepts, Methods and Calculi (PROCOMET), June 1994, and as University of Edinburgh technical report ECS-LFCS-94-280 and Universitat Erlangen-Nurnberg Interner Bericht IMMD7-01/94, </note> <month> January </month> <year> 1994. </year>
Reference-contexts: The treatment here is intended only to illustrate the use of higher-order polymorphism in programming, not to discuss all aspects of the type system in detail or to do justice to the theoretical issues involved. Background reading can be found in <ref> [Car91, PDM89, Car90, PS96, HP95, Com94] </ref>. 13.1 Overview If we are going to do "typechecking of type expressions," then clearly we need to introduce a language of "types of type expressions." To keep the terminology from getting out of hand, it helps to give a different name to this level of <p> C.f. <ref> [PS96, Com94] </ref>.) Conversion, written = fi&gt; , is the transitive, reflexive, and symmetric closure of ! fi&gt; .
Reference: [PT94] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> April </month> <year> 1994. </year> <note> A preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title "Object-Oriented Programming Without Recursive Types". </title>
Reference: [PT95] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Concurrent objects in a process calculus. </title> <editor> In Takay-asu Ito and Akinori Yonezawa, editors, </editor> <booktitle> Theory and Practice of Parallel Programming (TPPP), Sendai, </booktitle> <address> Japan (Nov. </address> <year> 1994), </year> <booktitle> number 907 in Lecture Notes in Computer Science, </booktitle> <pages> pages 187-215. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1995. </year> <month> 103 </month>
Reference: [PT96a] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict: A programming language based on the pi-calculus. </title> <note> To appear, </note> <year> 1996. </year>
Reference: [PT96b] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict language definition. </title> <note> Draft report; available electronically through http://www.cl.cam.ac.uk/users/bcp1000/draft, 1996. </note>
Reference: [PT96c] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict standard libraries manual. </title> <note> Available electronically, </note> <year> 1996. </year>
Reference: [Rep88] <author> John Reppy. </author> <title> Synchronous operations as first-class values. </title> <booktitle> In Programming Language Design and Implementation, </booktitle> <pages> pages 250-259. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <year> 1988. </year>
Reference-contexts: ^Signal type Number = ^[AckReq Signal] def zero [n:Number] -- Create a proc representing 0 located at n -- def succ [m:Number n:Number] -- Create a proc representing m+1 at n -- def plus [m:Number n:Number o:Number] -- etc. -- [Solution on page 100.] 10.4 Programming with Events John Reppy <ref> [Rep92, Rep90, Rep88, Rep91, Rep95] </ref> has argued that the programming facilities offered by the pure pi-calculus and many related concurrent programming languages are inadequate in an important way: they provide insufficient support for abstraction in concurrent code.
Reference: [Rep90] <author> John Reppy. </author> <title> Concurrent Programming with Events. </title> <institution> Cornell University, </institution> <month> November </month> <year> 1990. </year> <note> the Concurrent ML Manual (Version 0.9). </note>
Reference-contexts: ^Signal type Number = ^[AckReq Signal] def zero [n:Number] -- Create a proc representing 0 located at n -- def succ [m:Number n:Number] -- Create a proc representing m+1 at n -- def plus [m:Number n:Number o:Number] -- etc. -- [Solution on page 100.] 10.4 Programming with Events John Reppy <ref> [Rep92, Rep90, Rep88, Rep91, Rep95] </ref> has argued that the programming facilities offered by the pure pi-calculus and many related concurrent programming languages are inadequate in an important way: they provide insufficient support for abstraction in concurrent code.
Reference: [Rep91] <author> John Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In Programming Language Design and Implementation, </booktitle> <pages> pages 293-259. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: ^Signal type Number = ^[AckReq Signal] def zero [n:Number] -- Create a proc representing 0 located at n -- def succ [m:Number n:Number] -- Create a proc representing m+1 at n -- def plus [m:Number n:Number o:Number] -- etc. -- [Solution on page 100.] 10.4 Programming with Events John Reppy <ref> [Rep92, Rep90, Rep88, Rep91, Rep95] </ref> has argued that the programming facilities offered by the pure pi-calculus and many related concurrent programming languages are inadequate in an important way: they provide insufficient support for abstraction in concurrent code.
Reference: [Rep92] <author> John Reppy. </author> <title> Higher-Order Concurrency. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> June </month> <year> 1992. </year> <type> Technical Report TR 92-1285. </type>
Reference-contexts: ^Signal type Number = ^[AckReq Signal] def zero [n:Number] -- Create a proc representing 0 located at n -- def succ [m:Number n:Number] -- Create a proc representing m+1 at n -- def plus [m:Number n:Number o:Number] -- etc. -- [Solution on page 100.] 10.4 Programming with Events John Reppy <ref> [Rep92, Rep90, Rep88, Rep91, Rep95] </ref> has argued that the programming facilities offered by the pure pi-calculus and many related concurrent programming languages are inadequate in an important way: they provide insufficient support for abstraction in concurrent code.
Reference: [Rep95] <author> John H. Reppy. </author> <title> First-class synchronous operations. </title> <editor> In Takayasu Ito and Akinori Yonezawa, editors, </editor> <booktitle> Theory and Practice of Parallel Programming (TPPP), Sendai, </booktitle> <address> Japan (Nov. </address> <year> 1994), </year> <booktitle> number 907 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1995. </year>
Reference-contexts: ^Signal type Number = ^[AckReq Signal] def zero [n:Number] -- Create a proc representing 0 located at n -- def succ [m:Number n:Number] -- Create a proc representing m+1 at n -- def plus [m:Number n:Number o:Number] -- etc. -- [Solution on page 100.] 10.4 Programming with Events John Reppy <ref> [Rep92, Rep90, Rep88, Rep91, Rep95] </ref> has argued that the programming facilities offered by the pure pi-calculus and many related concurrent programming languages are inadequate in an important way: they provide insufficient support for abstraction in concurrent code. <p> To actually perform the communication, we synchronize on ev using the operation sync: sync!ev 1 Another difference is that Reppy's events are fully integrated with the basic mechanisms of channel creation and I/O on channels. All channels in CML are event channels. See <ref> [Rep95] </ref> for further discussion of this point. 76 The choice construct of -calculus is generalized to events using the operation $.
Reference: [SL96] <author> Jean-Guy Schneider and Markus Lumpe. </author> <title> Modelling objects in Pict. </title> <type> Technical Report IAM-96-004, </type> <institution> Universitaet Bern, Institut fuer Informatik und Angewandte Mathematik, </institution> <month> January </month> <year> 1996. </year>
Reference: [Tur96] <author> David N. Turner. </author> <title> The Polymorphic Pi-calulus: Theory and Implementation. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1996. </year>
Reference: [TW93] <author> Jerzy Tiuryn and Mitchell Wand. </author> <title> Type reconstruction with recursive types and atomic subtyping. </title> <booktitle> In Proceedings of TAPSOFT '93, </booktitle> <pages> pages 686-701, </pages> <year> 1993. </year>
Reference-contexts: Such recursive types have received considerable attention in the literature (e.g. <ref> [CC91, AC93, Car89, BM92, Ghe93, MPS86, Wan87, TW93, AP90, KPS93] </ref>), and many different technical treatments have been proposed.
Reference: [Var96] <author> Patrick Varone. </author> <title> Implementation of "generic synchronization policies" in Pict. </title> <type> Technical Report IAM-96-005, </type> <institution> Universitaet Bern, Institut fuer Informatik und Angewandte Mathematik, </institution> <month> April </month> <year> 1996. </year>
Reference: [Vas94] <author> Vasco T. Vasconcelos. </author> <title> Typed concurrent objects. </title> <booktitle> In Proceedings of the Eighth European Conference on Object-Oriented Programming (ECOOP), volume 821 of Lecture Notes in Computer Science, </booktitle> <pages> pages 100-117. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1994. </year>
Reference: [WAL + 89] <author> Pierre Weis, Mara-Virginia Aponte, Alain Laville, Michel Mauny, and Ascander Suarez. </author> <title> The CAML reference manual, Version 2.6. </title> <type> Technical report, </type> <institution> Projet Formel, INRIA-ENS, </institution> <year> 1989. </year>
Reference: [Wal94] <author> David Walker. </author> <title> Algebraic proofs of properties of objects. </title> <booktitle> In Proceedings of European Symposium on Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: a fresh copy of processRequest (passing the clients new value v' as the new current value in the case of set). 10.3 Example: Priority Queues One simple concurrent data structure, illustrating some common Pictish programming idioms, is the priority queue, a standard example from the concurrent object-oriented programming literature (e.g. <ref> [Jon93, Wal94] </ref>). A priority queue represents a collection of elements of some ordered set | say, for simplicity, the integers.

References-found: 77

