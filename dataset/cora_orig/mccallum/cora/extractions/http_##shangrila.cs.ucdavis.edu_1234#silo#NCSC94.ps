URL: http://shangrila.cs.ucdavis.edu:1234/silo/NCSC94.ps
Refering-URL: http://shangrila.cs.ucdavis.edu:1234/silo/
Root-URL: http://www.cs.ucdavis.edu
Email: Email: Last-Name@cs.ucdavis.edu  
Title: TOWARDS A FORMAL VERIFICATION OF A SECURE AND DISTRIBUTED SYSTEM AND ITS APPLICATIONS 1  
Author: Cui Zhang, Rob Shaw, Mark R. Heckman, Gregory D. Benson, Myla Archer, Karl Levitt, and Ronald A. Olsson 
Keyword: verification, distributed operating systems, security servers, distributed program ming languages.  
Address: CA 95616  
Affiliation: Department of Computer Science University of California, Davis,  
Abstract: This paper presents research towards the formal specification and verification of a secure distributed system and secure application programs that run on it. We refer to the whole system | from hardware to application programs written in a concurrent programming language | as the Silo, and to a simplified view of the Silo as the miniSilo. Both miniSilo and Silo consist of a collection of microprocessors interconnected by a network, a distributed operating system and a compiler for a distributed programming language. Our goal is to verify the full Silo by mechanized layered formal proof using the higher order logic theorem proving system HOL. This paper describes our current results for verifying the miniSilo and our incremental approach for evolving the verification of the miniSilo into the verification of the full Silo. Scalability is addressed in part by extending the distributed operating system with additional servers which in turn provide services that extend the programming language. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G.R. Andrews, R.A. Olsson, M. Coffin, I.J.P. Elshoff, K. Nilsen, T. Purdin, and G. Townsend, </author> <title> An Overview of the SR Language and Implementation, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <month> 10 </month> <year> (1988) </year> <month> 51-86. </month>
Reference-contexts: Our layered system includes a set of microprocessors, a network model, the operating system kernel and servers (some in support of security) running on each microprocessor (hence, a secure distributed operating system), the concurrent programming language microSR (a derivative of SR <ref> [1] </ref>), and a Hoare-like programming logic. Each layer will be formally modeled as an interpreter that interacts with the other layers. Our layered approach will allow us to verify that secure and distributed applications run correctly on the entire system.
Reference: [2] <author> G.R. Andrews, </author> <title> Concurrent Programming: </title> <booktitle> Principles and Practice, </booktitle> <publisher> The Benjamin/Cummings Publishing Company, Inc. </publisher> <address> Redwood City, CA, </address> <year> 1991. </year>
Reference-contexts: In its final form, the Silo will be somewhat limited when compared to "real" computer systems; however, we hope it will be the most comprehensive distributed computer system that is verified and demonstrates a methodology for "full system verification" of distributed systems. The CLI stack <ref> [2] </ref> has shown the feasibility of full system verification for a sequential system using a layered proof technique, but their model does not allow for concurrency and distributed programming, nor have they fully integrated the operating system into their "stack". <p> We use semantic relations, rather than functions, in our formal specification for microSR constructs; doing so obviates the possible need for powerdomains in the state abstraction for microSR programs due to the inherent non-determinism. To handle the interference problem arising from concurrent execution, We introduced atomicity and global invariants <ref> [2] </ref> into our logic system. This logic has been formally proven to be sound within HOL, i.e., axioms and inference rules are all mechanically derived in HOL as the logical implication of the same microSR semantic specification against which the mi-croSR implementation is verified. <p> Those axioms and rules for microSR sequential constructs, such as the Skip Axioms, Assignment Axiom, If Rule, Do Rule, Sequencing Rule, Precondition Strengthening Rule, and Post-condition Weakening Rule, are not listed below, because their appearance is similar to that in <ref> [2, 7] </ref>, though the way to formally specify and derive them for microSR is actually more complex. All axioms and inference rules are theorems of our language semantics. The "sent-set" and "received-set" denote all messages ever sent and received on that channel.
Reference: [3] <author> W.R. Bevier, W.A. Hunt, J.S. Moore, and W.D. Young, </author> <title> An approach to systems verification, </title> <journal> Journal of Automated Reasoning, </journal> <month> 5 </month> <year> (1989) </year> <month> 411-428. </month>
Reference: [4] <author> W.R. Bevier, and J. Sogaard-Andersen, </author> <title> Mechanically Checked Proofs of Kernel Specifications, </title> <booktitle> in CAV '91, number 575 in Lecture Notes in Computer Science, </booktitle> <address> pp.70-82, </address> <publisher> Springer Verlag, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: Similarly, the language interpreted by an mpmachine is an N -tuple of lists of instructions. The set of instructions contains all the operations executable on a vmachine, plus communication primitives. Similar to earlier efforts <ref> [4, 10] </ref>, the actual operation of the mpmachine is modelled with 2 Initially, we chose this term as an abbreviation of "virtual machine". Presently, however, "vanilla machine" is perhaps more appropriate transition relations. Each kind of transition allows a single component of the N -tuple to advance a single step.
Reference: [5] <author> R. Cardell-Oliver, </author> <title> Using Higher Order Logic for Modelling Real-time Protocols, </title> <booktitle> in TAPSOFT '91, number 494 in Lecture Notes in Computer Science, </booktitle> <pages> pp. 259-282, </pages> <publisher> Springer Verlag, </publisher> <month> April </month> <year> 1991. </year>
Reference-contexts: Later, if desired, one could develop an implementation of the abstract network specification. The next logical layer is the protocol layer. There has been considerable work on the verification of network protocols <ref> [5, 12] </ref>, which could be used to implement the abstract specification presented. For "complete" verification the protocol layer must ultimately be specified in terms of the underlying hardware. Protocol and network hardware verification are beyond the scope of this project.
Reference: [6] <author> P. Curzon, </author> <title> Of What Use is a Verified Compiler Specification, </title> <type> Technical Report No.274, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: To handle security, processes and objects are assigned security levels, and transitions are allowed if they satisfy the standard multilevel security policy. 4.2 Compiler Correctness Like the previous successful efforts to prove compiler correctness for sequential languages <ref> [6, 9] </ref>, to claim that a compiler is correct is to claim that the target code behavior achieve the source code semantics. Yet, as we have seen, the mpmachine behaviors and the microSR semantics are distinct enough that no canonical equivalence exists between them.
Reference: [7] <author> M. J. C. Gordon, </author> <title> Mechanizing Programming Logics in Higher Order Logic, </title> <editor> in G. Birtwistle and P.A. Sub-rahmanyam, Eds., </editor> <title> Current Trends in Hardware Verification and Automated Theorem Proving, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Our effort to formally derive, using HOL, a sound Hoare logic from microSR semantics is a generalization of similar work by Gordon for a small sequential language <ref> [7, 13] </ref>. We use semantic relations, rather than functions, in our formal specification for microSR constructs; doing so obviates the possible need for powerdomains in the state abstraction for microSR programs due to the inherent non-determinism. <p> Those axioms and rules for microSR sequential constructs, such as the Skip Axioms, Assignment Axiom, If Rule, Do Rule, Sequencing Rule, Precondition Strengthening Rule, and Post-condition Weakening Rule, are not listed below, because their appearance is similar to that in <ref> [2, 7] </ref>, though the way to formally specify and derive them for microSR is actually more complex. All axioms and inference rules are theorems of our language semantics. The "sent-set" and "received-set" denote all messages ever sent and received on that channel.
Reference: [8] <author> M. J. C. Gordon and T. F. Melham, </author> <title> Introduction to HOL: A theorem proving environment for higher order logic, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1993. </year>
Reference-contexts: Our specification, verification, and augmentation process is being carried out using the Cambridge HOL theorem prover <ref> [8] </ref>, because it allows the definition of embedded theories, such as we are using for a programming logic of concurrency and a generic model of a layer.
Reference: [9] <author> J.J. Joyce, </author> <title> Totally Verified Systems: Linking verified software to verified hardware. </title> <editor> In M. Leeser and G. Brown, Eds., </editor> <title> Specification, Verification and synthesis: Mathematical Aspects, </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: To handle security, processes and objects are assigned security levels, and transitions are allowed if they satisfy the standard multilevel security policy. 4.2 Compiler Correctness Like the previous successful efforts to prove compiler correctness for sequential languages <ref> [6, 9] </ref>, to claim that a compiler is correct is to claim that the target code behavior achieve the source code semantics. Yet, as we have seen, the mpmachine behaviors and the microSR semantics are distinct enough that no canonical equivalence exists between them.
Reference: [10] <author> Z. Manna and A. Pnueli, </author> <title> Verification of Concurrent Programs: A Temporal Proof System, </title> <booktitle> Proc. of the Fourth School of Advanced Programming, </booktitle> <address> Amsterdam, </address> <year> 1982. </year>
Reference-contexts: Similarly, the language interpreted by an mpmachine is an N -tuple of lists of instructions. The set of instructions contains all the operations executable on a vmachine, plus communication primitives. Similar to earlier efforts <ref> [4, 10] </ref>, the actual operation of the mpmachine is modelled with 2 Initially, we chose this term as an abbreviation of "virtual machine". Presently, however, "vanilla machine" is perhaps more appropriate transition relations. Each kind of transition allows a single component of the N -tuple to advance a single step.
Reference: [11] <author> L. C. Paulson, </author> <title> Logic and Computation: Interactive Proof with Cambridge LCF, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, New York, </address> <year> 1987. </year>
Reference-contexts: The preliminary attempts at manual proof of microSR programs have motivated us to establish a systematic method for creating annotated microSR programs. Another challenging task is to develop, using HOL as well, an interactive prover of LCF <ref> [11] </ref> style for microSR. 6 Conclusion Our research on miniSilo has shown how to structure proofs according to vertical layers, how to formally model different layers, how to model the interactions between layers, how to express the proof obligations between layers, and how to compose all the proved layers together.
Reference: [12] <author> V. Yodaiken and K. Ramamritham, </author> <title> Verification of a Reliable Net Protocol, </title> <booktitle> Proc. of the Second International Symposium on Formal Techniques in Real-Time and Fault-Tolerent Systems, number 571 in Lecture Notes in Computer Science, </booktitle> <pages> pp. 193-215, </pages> <publisher> Springer Verlag, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: Later, if desired, one could develop an implementation of the abstract network specification. The next logical layer is the protocol layer. There has been considerable work on the verification of network protocols <ref> [5, 12] </ref>, which could be used to implement the abstract specification presented. For "complete" verification the protocol layer must ultimately be specified in terms of the underlying hardware. Protocol and network hardware verification are beyond the scope of this project.
Reference: [13] <author> C. Zhang, R. Shaw, R. Olsson, K. Levitt, M. Archer, M.Heckman, and G. Benson, </author> <title> Mechanizing a Programming Logic for the Concurrent Programming Language microSR in HOL, </title> <editor> in J.J. Gordon and C.H. Seger, Eds., </editor> <title> Higher Order Logic Theorem Proving and Its Applications, </title> <booktitle> The 6th International Workshop, HUG'93, number 780 in Lecture Notes in Computer Science, </booktitle> <address> pp31-44, </address> <publisher> Springer-Verlag, </publisher> <month> March </month> <year> 1994. </year>
Reference-contexts: Our effort to formally derive, using HOL, a sound Hoare logic from microSR semantics is a generalization of similar work by Gordon for a small sequential language <ref> [7, 13] </ref>. We use semantic relations, rather than functions, in our formal specification for microSR constructs; doing so obviates the possible need for powerdomains in the state abstraction for microSR programs due to the inherent non-determinism.
Reference: [14] <institution> MACH 3 Kernel Principles, Open Software Foundation and Carnegie Mellon University, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: The operating system design is based on the kernel and server model used, for example, in Mach <ref> [14] </ref> and in Synergy [15]. The kernel provides a multi-programmed, message passing environment for the server processes and user processes on a particular processor. The abstraction of a distributed system is maintained by the servers.
Reference: [15] <institution> USA INFOSEC Research and Technology, Synergy: A Distributed, Microkernel-based Security Archi tecture, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: The operating system design is based on the kernel and server model used, for example, in Mach [14] and in Synergy <ref> [15] </ref>. The kernel provides a multi-programmed, message passing environment for the server processes and user processes on a particular processor. The abstraction of a distributed system is maintained by the servers.
References-found: 15

