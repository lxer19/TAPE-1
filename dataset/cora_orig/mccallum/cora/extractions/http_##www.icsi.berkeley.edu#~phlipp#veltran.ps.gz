URL: http://www.icsi.berkeley.edu/~phlipp/veltran.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/~phlipp/phlipp.publ.html
Root-URL: http://www.icsi.berkeley.edu
Email: [jacob|phlipp]@ira.uka.de  martin.karrenbach@physik.uni-karlsruhe.de  
Title: Large-Scale Parallel Geophysical Algorithms in Java: A Feasibility Study  
Author: Matthias Jacob and Michael Philippsen Martin Karrenbach 
Address: Germany  Germany  
Affiliation: Computer Science Department University of Karlsruhe,  Geophysical Institute University of Karlsruhe,  
Abstract: Java is often accused of being too slow for serious programming, especially for scientific problem solving. However, we found that for a large-scale geophysical application, Java code compiled with current just-in-time compilers runs slower than Fortran by a factor of at most four, on both a shared-memory parallel machine (SGI Origin2000) and a distributed-memory parallel machine (IBM SP/2). The moderate slowdown is easily offset by the following advantages: (a) object-oriented Java code is easier to maintain and reuse than Fortran code, (b) Java code is fully portable, even among parallel computers with different memory models. Furthermore, better compiler technology is on the horizon, which will narrow the performance gap even more. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Clearbout and B. Biondi. </author> <title> Geophysics in object-oriented numerics (GOON). In Stanford Exploration Project Report No. </title> <booktitle> 93, </booktitle> <pages> pages 241-252. </pages> <month> October </month> <year> 1996. </year> <title> http://sepwww.stanford.edu/sep. work. The HPJ compiler revealed a general speed up of 1.6 compared to just-in-time Java performance, but unfortunately HPJ's communication through RMI turned out to be slower by a factor of between 20 and 35. </title>
Reference-contexts: They don't in fl Part of this work has been supported by a diploma thesis grant of the Prof. Dr.-Ing. Erich Muller-Stiftung, Essen, Germany. volve an intrinsic hierarchy of operators, needed for a compound framework of seismic methods. With the main focus on object-oriented languages the GOON/CLOP architecture <ref> [1, 12] </ref> for implementing seismic methods in C++ has been developed within the Stanford Exploration Project.
Reference: [2] <author> R. Eigenmann and S. </author> <title> Hassanzadeh. Benchmarking with real industrial applications: The SPEC high-performance group. </title> <journal> IEEE Computational Science and Engineering, Spring issue, </journal> <volume> 3(1) </volume> <pages> 18-23, </pages> <year> 1996. </year>
Reference-contexts: Future Work Since stable versions of JavaParty and Veltran are established on parallel computers, work continues towards cluster computing and other geophysical algorithms. For these purposes a workload model will be defined and standard benchmarks <ref> [2] </ref> will be used to determine the specific performance parameters of each computer that are then used in an optimization phase. Acknowledgements We would like to thank the JavaParty group, especially Matthias Zenger, for their support of the Java-Party environment.
Reference: [3] <author> Gene Golub and Charles van Loan. </author> <title> Matrix Computations. </title> <publisher> John Hopkins, </publisher> <address> Third edition, </address> <year> 1996. </year>
Reference-contexts: These typically involve iterative linear and non-linear solvers such as the conjugate gradient method. For more details see <ref> [3, 15] </ref>. For reconstructing the a 2D image of the earth's interior, measurements for more than just one source location are necessary.
Reference: [4] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: The resulting program code is not only error-prone but cannot easily be ported from one machine architecture to another. In this situation, the Java programming language <ref> [4, 5] </ref> has been introduced. Java is object-oriented and offers language elements to express thread-based parallelism and synchronization without additional system libraries. In combination with the integrated Remote Method Invocation (RMI) of Java, data exchange between processors is easy.
Reference: [5] <author> Siamak Hassanzadeh and Charles C. </author> <title> Mosher. Java: Object-Oriented programming for the cyber age. </title> <journal> The Leading Edge, </journal> <volume> 15(12) </volume> <pages> 1379-1381, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: The resulting program code is not only error-prone but cannot easily be ported from one machine architecture to another. In this situation, the Java programming language <ref> [4, 5] </ref> has been introduced. Java is object-oriented and offers language elements to express thread-based parallelism and synchronization without additional system libraries. In combination with the integrated Remote Method Invocation (RMI) of Java, data exchange between processors is easy.
Reference: [6] <author> Siamak Hassanzadeh, Charles C. Mosher, and Calvin L. Joyner. </author> <title> Scalable parallel seismic processing. </title> <journal> The Leading Edge, </journal> <volume> 15(12) </volume> <pages> 1363-1366, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: In combination with the integrated Remote Method Invocation (RMI) of Java, data exchange between processors is easy. This allows parallel processing on application level, i.e., in the Java environment itself, as Hassanzadeh et al. discuss for geophysics <ref> [6] </ref>. There is no further need for Message Passing or virtual shared memory within the application. Additionally, this parallelism is hardware independent, i.e., programs run on any major platform.
Reference: [7] <author> C. Holt, J. P. Singh, and J. Hennessy. </author> <title> Application and architectural bottlenecks in large-scale distributed shared memory machines. </title> <booktitle> In 23th Int. Symp. on Computer Architecture, </booktitle> <pages> pages 134-145, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: They induce a significant extra amount of implementation work and render the programs more difficult to understand and maintain. * Although the source code of message passing programs with hard-wired data and thread distribution is often portable between architectures, porting frequently causes significant performance losses <ref> [7, 11] </ref>. Moreover, it is often difficult to adapt programs with explicit communication for varying numbers of nodes, for different architec tures, or for changing network topologies. JavaParty transparently adds remote objects to Java purely by declaration and avoids exposing the programmer to sockets, RMI, and message passing libraries.
Reference: [8] <author> High Performance Fortran Forum (HPFF). </author> <title> High Performance Fortran Language Specification. </title> <type> Technical report, </type> <institution> Rice University, </institution> <month> November </month> <year> 1994. </year> <note> http://www.crpc.rice.edu/HPFF/hpf1. </note>
Reference-contexts: On the IBM SP/2, version 2.2 of the Portland Group High Performance Fortran (HPF) <ref> [8] </ref> compiler was used. 6 Results time on the IBM SP/2. HPF code on the IBM SP/2. The JavaParty version of parallel Veltran outperforms HPF when one plane is computed on four nodes.
Reference: [9] <author> IBM. </author> <title> High performance compiler for Java. </title> <address> http://www.alphaWorks.ibm.com. </address>
Reference-contexts: Future releases (JDK 1.2) are announced to speed up the JVM and the handling of native threads. Second, compilers producing optimized native code like IBM's High Performance Java Compiler <ref> [9] </ref> are on the horizon. 5 These compilers will approach Fortran 5 Although the IBM SP/2 already offers an alpha version of a High Performance Java Compiler that compiles to native and statically linked code, it is not yet stable enough for serious 6 performance because they can apply much more
Reference: [10] <author> JavaParty. </author> <note> http://wwwipd.ira.uka.de/JavaParty. </note>
Reference-contexts: This is done by concatenating the lines of the area to a straight one. Therefore, only the lengths of the sand v-axis increase. 3 JavaParty the distributed runtime environment for Java JavaParty <ref> [10, 13] </ref> is a programming layer on top of Java and RMI. JavaParty inherits the advantages of both, but it is designed to avoid their disadvantages. Java's threads and synchronization mechanisms offer appropriate means for parallel programming of shared memory parallel computers. <p> Moreover, the programmer can even implement application-specific object distributors and migration managers. The implementation of the Veltran operator, shown below, uses JavaParty's standard object distributor. The JavaParty preprocessor and the rest of the JavaParty environment are 100% pure Java and freely available <ref> [10] </ref>. 4 Parallelizing the Veltran Operator An efficient parallelization of Veltran is needed since Veltran runs long and consumes a vast amount of memory.
Reference: [11] <author> D. Jiang, H. Shan, and J. P. Singh. </author> <title> Application restructuring and performance portability on shared virtual memory and hardware-coherent multiprocessors. </title> <booktitle> In 6th ACM SIGPLAN Symp. on Principles and Practice of Parallel Programming, PPoPP, </booktitle> <pages> pages 217-229, </pages> <address> Las Vegas, NV, </address> <month> July 18-21 </month> <year> 1997. </year>
Reference-contexts: They induce a significant extra amount of implementation work and render the programs more difficult to understand and maintain. * Although the source code of message passing programs with hard-wired data and thread distribution is often portable between architectures, porting frequently causes significant performance losses <ref> [7, 11] </ref>. Moreover, it is often difficult to adapt programs with explicit communication for varying numbers of nodes, for different architec tures, or for changing network topologies. JavaParty transparently adds remote objects to Java purely by declaration and avoids exposing the programmer to sockets, RMI, and message passing libraries.
Reference: [12] <author> D. Nichols, H. Urdaneta, H. I. Oh, J. Clearbout, L. Laane, M. Karrenbach, and M. Schwab. </author> <title> Programming geophysics in C++. In Stanford Exploration Project Report No. </title> <booktitle> 79, </booktitle> <pages> pages 313-471. </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: They don't in fl Part of this work has been supported by a diploma thesis grant of the Prof. Dr.-Ing. Erich Muller-Stiftung, Essen, Germany. volve an intrinsic hierarchy of operators, needed for a compound framework of seismic methods. With the main focus on object-oriented languages the GOON/CLOP architecture <ref> [1, 12] </ref> for implementing seismic methods in C++ has been developed within the Stanford Exploration Project.
Reference: [13] <author> Michael Philippsen and Matthias Zenger. </author> <title> JavaParty transparent remote objects in Java. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 9(11) </volume> <pages> 1125-1242, </pages> <month> November </month> <year> 1997. </year>
Reference-contexts: This is done by concatenating the lines of the area to a straight one. Therefore, only the lengths of the sand v-axis increase. 3 JavaParty the distributed runtime environment for Java JavaParty <ref> [10, 13] </ref> is a programming layer on top of Java and RMI. JavaParty inherits the advantages of both, but it is designed to avoid their disadvantages. Java's threads and synchronization mechanisms offer appropriate means for parallel programming of shared memory parallel computers. <p> been reflected twice. 3 error-prone programs, which have similar disadvan-tages as programming with message passing in gen eral: * Depending on communication requirements, multi-threaded Java programs often grow by about 70% when being ported from a shared memory environment to a distributed memory platform by means of sockets or RMI <ref> [13] </ref>. Both the socket and RMI mechanisms are complicated.
Reference: [14] <author> Matthias Schwab and Joel Schroeder. </author> <title> A seismic inversion library in Java. In Stanford Exploration Project Report No. </title> <booktitle> 94, </booktitle> <pages> pages 363-381. </pages> <month> May </month> <year> 1997. </year> <note> http://sepwww.stanford.edu/sep/jag. </note>
Reference-contexts: For this study we picked an operator according to the specific area of velocity analysis, namely the Vel-tran operator. The Veltran operator is a basic method in seismic processing. Efforts are underway at the Stanford Exploration Project to produce a seismic operator framework (JAG <ref> [14] </ref>) in Java. We base our implementation of a parallel geophysical operator on a preliminary version of JAG. After a short introduction into this geophysical operator in section 2, the architecture of the underlying distributed runtime environment, JavaParty, is discussed in section 3.
Reference: [15] <author> J.R. Skewchuck. </author> <title> An introduction to the conjugate gradient method without the agonizing pain. </title> <type> Technical report, </type> <institution> Carnegie-Mellon University, Pittsburgh, </institution> <month> March </month> <year> 1994. </year> <note> CS-94-125. 7 </note>
Reference-contexts: These typically involve iterative linear and non-linear solvers such as the conjugate gradient method. For more details see <ref> [3, 15] </ref>. For reconstructing the a 2D image of the earth's interior, measurements for more than just one source location are necessary.
References-found: 15

