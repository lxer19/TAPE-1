URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-273.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Title: Linear-C: A Data-Parallel Extension to C  
Author: Chung-Hsing Hsu and Donald Smith and Saul Levy 
Date: September 9, 1996  
Address: LCSR-TR-273  
Affiliation: Department of Computer Science Rutgers University  
Abstract: Linear-C is a data-parallel extension to C. It extends C by treating arrays (or more precisely, aggregate value) as first-class citizens. It provides activity association and segment association to control aggregate values in a computation. It also supplies new operators for aggregate values. Linear-C is designed to be intuitively simple to learn, to use, yet powerful enough to express many kinds of data parallelism. In this report we show that (1) the rationale behind our decision to choose a particular manipulation rule, and (2) the whole picture of the language in a systematic way. In the first part, we identify the trade-offs between the simplicity, the expressiveness, and the implementability of Linear-C. After that, the entire language is introduced systematically, to show the simplicity of the language model and the consistency of the manipulation rules. Finally, we conclude the report in terms of possible future research directions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Hall, J.S. </author> <year> (1994). </year> <title> Associative Processing: Architectures, Algorithms, and Applications, </title> <type> Ph.D. Dissertation, </type> <institution> Computer Science Department, Rutgers University. </institution>
Reference-contexts: A pseudo vector, [m i : n i ], is an array of activity-controlled scalar values. And a vector [[m i : n i ] j ] is an array of pseudo vectors. Therefore, for example, <ref> [1; 2; 3] </ref> and [1; (2); 3] are pseudo vectors, but [[1]; [2; 3]] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. <p> A pseudo vector, [m i : n i ], is an array of activity-controlled scalar values. And a vector [[m i : n i ] j ] is an array of pseudo vectors. Therefore, for example, [1; 2; 3] and <ref> [1; (2); 3] </ref> are pseudo vectors, but [[1]; [2; 3]] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. <p> And a vector [[m i : n i ] j ] is an array of pseudo vectors. Therefore, for example, [1; 2; 3] and <ref> [1; (2); 3] </ref> are pseudo vectors, but [[1]; [2; 3]] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. In the vector [[1]; [2; 3]], two segments [1] and [2; 3] are in this vector. <p> example, [1; 2; 3] and [1; (2); 3] are pseudo vectors, but [<ref> [1] </ref>; [2; 3]] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. In the vector [[1]; [2; 3]], two segments [1] and [2; 3] are in this vector. From time to time we need to talk about pseudo vectors and vectors as a whole, usually for the simplicity of the semantics, we use notations [a i ]; [b i ]; [c i ] to refer them. <p> A subclass of collective operators is called reduction operators which summarize a pseudo vector into a scalar value, or a vector into a pseudo vector. For example, operator /" denotes the minimum-finding operator. Therefore, we will have /"[1; 2; 3] = 1 and /"[[1]; [2; 3]] = <ref> [1; 2] </ref>. The minimum operator finds out from [1; 2; 3] the smallest scalar value, which is 1. When it applies to a vector, it finds the smallest scalar value for each segment of the vector, which turns out to be 1 and 2 for each segment. <p> For example, operator /" denotes the minimum-finding operator. Therefore, we will have /"<ref> [1; 2; 3] </ref> = 1 and /"[[1]; [2; 3]] = [1; 2]. The minimum operator finds out from [1; 2; 3] the smallest scalar value, which is 1. When it applies to a vector, it finds the smallest scalar value for each segment of the vector, which turns out to be 1 and 2 for each segment. Symbol ? is used to indicate an unknown value, usually implementation-dependent. <p> It is pseudo because its arithmetic rule is context-dependent. In some contexts it is treated as a scalar, and in other cases it is considered as a vector. The following paragraph gives a description of what a pseudo vector behaves <ref> [1] </ref>. [A pseudo vector] is a multiple-value object, with one value for each segment, but syntactically (and semantically) it is treated as a scalar, with its values being automatically broadcast over the corresponding segments in vector operations. <p> The reason is due to the difficulty introduced by the size of the promoted scalar. On one hand, setting the size context-independently, say one, does not satisfy our expectation of how a scalar behaves. Linear-C: A Data-Parallel Extension to C 8 expression evaluation result [1,2,3] + 1 [1,2,3] + <ref> [1] </ref> reject (different size) Even though the rule is relaxed for operands of different sizes, the result may not be the one expected. <p> The following example should give a clearer picture about the difference between shift-into semantics and skip-over semantics. Linear-C: A Data-Parallel Extension to C 12 &gt;+[1,(2),(3),4] evaluation result shift-into [1,1+(2),1+(2)+(3),1+(2)+(3)+4] [1,1,1,5] skip-over [1,(2),(3),1+4] [1,(2),(3),5] Suppose we want to do sum-scan on pseudo vector <ref> [1; (2); (3); 4] </ref>. In shift-into semantics, even though elements (2) and (3) are inactive, they are involved in the scan process, and they are replaced by 1's and turned on after the scan process. Note that, both their values and activity indicators are modified. <p> The importance of this equation is that it gives us more opportunity to perform optimization. The following example shows that while shift-into semantics preserves the equation, skip-over semantics does not. Therefore, skip-over semantics of scan operation is not used by Linear-C. in shift-into semantics: &gt;>(&gt;+ IS <ref> [1; 2; (3)] </ref> + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; <p> The following example shows that while shift-into semantics preserves the equation, skip-over semantics does not. Therefore, skip-over semantics of scan operation is not used by Linear-C. in shift-into semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS <ref> [1; (2); 3] </ref>) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); <p> The following example shows that while shift-into semantics preserves the equation, skip-over semantics does not. Therefore, skip-over semantics of scan operation is not used by Linear-C. in shift-into semantics: &gt;>(&gt;+ IS <ref> [1; 2; (3)] </ref> + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; <p> The following example shows that while shift-into semantics preserves the equation, skip-over semantics does not. Therefore, skip-over semantics of scan operation is not used by Linear-C. in shift-into semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS <ref> [1; (2); 3] </ref>) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); <p> Therefore, skip-over semantics of scan operation is not used by Linear-C. in shift-into semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + <ref> [1; 1; 4] </ref>) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); <p> Therefore, skip-over semantics of scan operation is not used by Linear-C. in shift-into semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = <ref> [(?); 1; 3] </ref> + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; <p> Therefore, skip-over semantics of scan operation is not used by Linear-C. in shift-into semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + <ref> [(?); 1; 1] </ref> = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; (3)] + [(?); (2); <p> IS <ref> [1; 2; (3)] </ref> + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; (3)] + [(?); (2); 1] = &gt;>([2; 3; 4]) = [(?); 1; 1] There may be some other ways for <p> IS <ref> [1; (2); 3] </ref>) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; (3)] + [(?); (2); 1] = &gt;>([2; 3; 4]) = [(?); 1; 1] There may be some other ways for doing shift-into. <p> ES <ref> [1; 2; (3)] </ref> + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; (3)] + [(?); (2); 1] = &gt;>([2; 3; 4]) = [(?); 1; 1] There may be some other ways for doing shift-into. <p> ES <ref> [1; (2); 3] </ref> = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; (3)] + [(?); (2); 1] = &gt;>([2; 3; 4]) = [(?); 1; 1] There may be some other ways for doing shift-into. <p> + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + <ref> [1; (2); 4] </ref>) = [(?); 1; (3)] + [(?); (2); 1] = &gt;>([2; 3; 4]) = [(?); 1; 1] There may be some other ways for doing shift-into. For example, scan can be done by temporarily ignoring activity control and then attaching the bits back to the resulting value. <p> = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = <ref> [(?); 1; (3)] </ref> + [(?); (2); 1] = &gt;>([2; 3; 4]) = [(?); 1; 1] There may be some other ways for doing shift-into. For example, scan can be done by temporarily ignoring activity control and then attaching the bits back to the resulting value. <p> + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; (3)] + <ref> [(?); (2); 1] </ref> = &gt;>([2; 3; 4]) = [(?); 1; 1] There may be some other ways for doing shift-into. For example, scan can be done by temporarily ignoring activity control and then attaching the bits back to the resulting value. <p> = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; (3)] + [(?); (2); 1] = &gt;>([2; 3; 4]) = <ref> [(?); 1; 1] </ref> There may be some other ways for doing shift-into. For example, scan can be done by temporarily ignoring activity control and then attaching the bits back to the resulting value. <p> The point will be made more clear in Section 4.2 when the operational semantics of pseudo vector is discussed. Linear-C: A Data-Parallel Extension to C 14 expression evaluation result /" [1,2,3] (minimum-finding) 1 /" [[1,2,3]] [/"[1,2,3]] <ref> [1] </ref> [1,2,3] + 1 [1+1,2+1,3+1] [2,3,4] 4.2 The Operational Semantics of Values The operational semantics of Linear-C values over binary operation is quite simple: scalar values perform for-all semantics while aggregate values perform for-each semantics.
Reference: [2] <author> Hsu, C.H., Smith, D.E., and Levy, S. </author> <year> (1996). </year> <title> A Linear-C Implementation of Dijkstra's Algorithm, </title> <institution> LCSR-TR-274, Computer Science Department, Rutgers University. </institution>
Reference-contexts: A pseudo vector, [m i : n i ], is an array of activity-controlled scalar values. And a vector [[m i : n i ] j ] is an array of pseudo vectors. Therefore, for example, <ref> [1; 2; 3] </ref> and [1; (2); 3] are pseudo vectors, but [[1]; [2; 3]] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. <p> A pseudo vector, [m i : n i ], is an array of activity-controlled scalar values. And a vector [[m i : n i ] j ] is an array of pseudo vectors. Therefore, for example, [1; 2; 3] and [1; (2); 3] are pseudo vectors, but [[1]; <ref> [2; 3] </ref>] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. In the vector [[1]; [2; 3]], two segments [1] and [2; 3] are in this vector. <p> Therefore, for example, [1; 2; 3] and [1; (2); 3] are pseudo vectors, but [[1]; <ref> [2; 3] </ref>] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. In the vector [[1]; [2; 3]], two segments [1] and [2; 3] are in this vector. From time to time we need to talk about pseudo vectors and vectors as a whole, usually for the simplicity of the semantics, we use notations [a i ]; [b i ]; [c i ] to refer them. <p> 2; 3] and [1; (2); 3] are pseudo vectors, but [[1]; <ref> [2; 3] </ref>] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. In the vector [[1]; [2; 3]], two segments [1] and [2; 3] are in this vector. From time to time we need to talk about pseudo vectors and vectors as a whole, usually for the simplicity of the semantics, we use notations [a i ]; [b i ]; [c i ] to refer them. <p> A subclass of collective operators is called reduction operators which summarize a pseudo vector into a scalar value, or a vector into a pseudo vector. For example, operator /" denotes the minimum-finding operator. Therefore, we will have /"[1; 2; 3] = 1 and /"[[1]; <ref> [2; 3] </ref>] = [1; 2]. The minimum operator finds out from [1; 2; 3] the smallest scalar value, which is 1. When it applies to a vector, it finds the smallest scalar value for each segment of the vector, which turns out to be 1 and 2 for each segment. <p> A subclass of collective operators is called reduction operators which summarize a pseudo vector into a scalar value, or a vector into a pseudo vector. For example, operator /" denotes the minimum-finding operator. Therefore, we will have /"[1; 2; 3] = 1 and /"[[1]; [2; 3]] = <ref> [1; 2] </ref>. The minimum operator finds out from [1; 2; 3] the smallest scalar value, which is 1. When it applies to a vector, it finds the smallest scalar value for each segment of the vector, which turns out to be 1 and 2 for each segment. <p> For example, operator /" denotes the minimum-finding operator. Therefore, we will have /"<ref> [1; 2; 3] </ref> = 1 and /"[[1]; [2; 3]] = [1; 2]. The minimum operator finds out from [1; 2; 3] the smallest scalar value, which is 1. When it applies to a vector, it finds the smallest scalar value for each segment of the vector, which turns out to be 1 and 2 for each segment. Symbol ? is used to indicate an unknown value, usually implementation-dependent. <p> associate activity indicator ff with [b i ] [0,1,(2)] ? [1,(2),3] minimum-finding operator /"[a i ] find the smallest scalar value of [a i ] /"[1,2,3] = 1 size function size ([a i ]) the number of elements in [a i ] size ([1; 2; 3]) = 3 size ([[1]; <ref> [2; 3] </ref>]) = 2 p an allowed entry fi a forbidden entry 3 Rationale behind the Language Linear-C is designed to be intuitively simple for its language model, concise and consistent for its manipulation rules, and powerful enough to express many kinds of data parallelism. <p> Unfortunately, such a definition violates (rule 2) in the following example. expression evaluate result expectation [(1)] ? [(2)] &lt;-,(0),(1)&gt; ? &lt;-,(0),(2)&gt; &lt;-,(1),(2)&gt; = <ref> [2] </ref> [(2)] In the above example, we expect (1) have no effect on the inactiveness of (2) according to (rule 2). However, it re-activates (2) by the field composition scheme. <p> The importance of this equation is that it gives us more opportunity to perform optimization. The following example shows that while shift-into semantics preserves the equation, skip-over semantics does not. Therefore, skip-over semantics of scan operation is not used by Linear-C. in shift-into semantics: &gt;>(&gt;+ IS <ref> [1; 2; (3)] </ref> + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; <p> The following example shows that while shift-into semantics preserves the equation, skip-over semantics does not. Therefore, skip-over semantics of scan operation is not used by Linear-C. in shift-into semantics: &gt;>(&gt;+ IS <ref> [1; 2; (3)] </ref> + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; <p> not used by Linear-C. in shift-into semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = <ref> [(?); 2; 4] </ref> in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; (3)] + [(?); (2); 1] = &gt;>([2; 3; 4]) = [(?); 1; <p> IS <ref> [1; 2; (3)] </ref> + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; (3)] + [(?); (2); 1] = &gt;>([2; 3; 4]) = [(?); 1; 1] There may be some other ways for <p> ES <ref> [1; 2; (3)] </ref> + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; (3)] + [(?); (2); 1] = &gt;>([2; 3; 4]) = [(?); 1; 1] There may be some other ways for doing shift-into. <p> Therefore, for example, <ref> [(1); 2; 3] </ref> has the leftmost active element 2 and rightmost active element 3. And the equations /&lt;[(1); 2; 3] = 2 and /&gt;[(1); 2; 3] = 3 are true. As usual, reduction on a scalar value is not allowed.
Reference: [3] <author> Smith, D.E., Hall, J.S., and Miyake, K. </author> <year> (1993). </year> <institution> Rutgers' CAM 2000 Chip Architecture, LCSR-TR-196, Computer Science Department, Rutgers University. </institution>
Reference-contexts: A pseudo vector, [m i : n i ], is an array of activity-controlled scalar values. And a vector [[m i : n i ] j ] is an array of pseudo vectors. Therefore, for example, <ref> [1; 2; 3] </ref> and [1; (2); 3] are pseudo vectors, but [[1]; [2; 3]] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. <p> A pseudo vector, [m i : n i ], is an array of activity-controlled scalar values. And a vector [[m i : n i ] j ] is an array of pseudo vectors. Therefore, for example, [1; 2; 3] and <ref> [1; (2); 3] </ref> are pseudo vectors, but [[1]; [2; 3]] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. <p> A pseudo vector, [m i : n i ], is an array of activity-controlled scalar values. And a vector [[m i : n i ] j ] is an array of pseudo vectors. Therefore, for example, [1; 2; 3] and [1; (2); 3] are pseudo vectors, but [[1]; <ref> [2; 3] </ref>] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. In the vector [[1]; [2; 3]], two segments [1] and [2; 3] are in this vector. <p> And a vector [[m i : n i ] j ] is an array of pseudo vectors. Therefore, for example, [1; 2; 3] and [1; (2); 3] are pseudo vectors, but [[1]; [2; 3]] and [[1; (2)]; <ref> [3] </ref>] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. In the vector [[1]; [2; 3]], two segments [1] and [2; 3] are in this vector. <p> And a vector [[m i : n i ] j ] is an array of pseudo vectors. Therefore, for example, [1; 2; 3] and <ref> [1; (2); 3] </ref> are pseudo vectors, but [[1]; [2; 3]] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. In the vector [[1]; [2; 3]], two segments [1] and [2; 3] are in this vector. <p> Therefore, for example, [1; 2; 3] and [1; (2); 3] are pseudo vectors, but [[1]; <ref> [2; 3] </ref>] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. In the vector [[1]; [2; 3]], two segments [1] and [2; 3] are in this vector. From time to time we need to talk about pseudo vectors and vectors as a whole, usually for the simplicity of the semantics, we use notations [a i ]; [b i ]; [c i ] to refer them. <p> 2; 3] and [1; (2); 3] are pseudo vectors, but [[1]; <ref> [2; 3] </ref>] and [[1; (2)]; [3]] are vectors. In the pseudo vector [1; (2); 3], both scalar values 1 and 3 are active while scalar value 2 is inactive. In the vector [[1]; [2; 3]], two segments [1] and [2; 3] are in this vector. From time to time we need to talk about pseudo vectors and vectors as a whole, usually for the simplicity of the semantics, we use notations [a i ]; [b i ]; [c i ] to refer them. <p> A subclass of collective operators is called reduction operators which summarize a pseudo vector into a scalar value, or a vector into a pseudo vector. For example, operator /" denotes the minimum-finding operator. Therefore, we will have /"[1; 2; 3] = 1 and /"[[1]; <ref> [2; 3] </ref>] = [1; 2]. The minimum operator finds out from [1; 2; 3] the smallest scalar value, which is 1. When it applies to a vector, it finds the smallest scalar value for each segment of the vector, which turns out to be 1 and 2 for each segment. <p> For example, operator /" denotes the minimum-finding operator. Therefore, we will have /"<ref> [1; 2; 3] </ref> = 1 and /"[[1]; [2; 3]] = [1; 2]. The minimum operator finds out from [1; 2; 3] the smallest scalar value, which is 1. When it applies to a vector, it finds the smallest scalar value for each segment of the vector, which turns out to be 1 and 2 for each segment. Symbol ? is used to indicate an unknown value, usually implementation-dependent. <p> associate activity indicator ff with [b i ] [0,1,(2)] ? [1,(2),3] minimum-finding operator /"[a i ] find the smallest scalar value of [a i ] /"[1,2,3] = 1 size function size ([a i ]) the number of elements in [a i ] size ([1; 2; 3]) = 3 size ([[1]; <ref> [2; 3] </ref>]) = 2 p an allowed entry fi a forbidden entry 3 Rationale behind the Language Linear-C is designed to be intuitively simple for its language model, concise and consistent for its manipulation rules, and powerful enough to express many kinds of data parallelism. <p> The following example shows that while shift-into semantics preserves the equation, skip-over semantics does not. Therefore, skip-over semantics of scan operation is not used by Linear-C. in shift-into semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS <ref> [1; (2); 3] </ref>) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); <p> The following example shows that while shift-into semantics preserves the equation, skip-over semantics does not. Therefore, skip-over semantics of scan operation is not used by Linear-C. in shift-into semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS <ref> [1; (2); 3] </ref>) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); <p> Therefore, skip-over semantics of scan operation is not used by Linear-C. in shift-into semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = <ref> [(?); 1; 3] </ref> + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; <p> IS <ref> [1; (2); 3] </ref>) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; (3)] + [(?); (2); 1] = &gt;>([2; 3; 4]) = [(?); 1; 1] There may be some other ways for doing shift-into. <p> ES <ref> [1; (2); 3] </ref> = &gt;>([1; 3; 3] + [1; 1; 4]) = [(?); 1; 3] + [(?); 1; 1] = &gt;>([2; 4; 7]) = [(?); 2; 4] in skip-over semantics: &gt;>(&gt;+ IS [1; 2; (3)] + &gt;+ IS [1; (2); 3]) &gt;+ ES [1; 2; (3)] + &gt;+ ES [1; (2); 3] = &gt;>([1; 3; (3)] + [1; (2); 4]) = [(?); 1; (3)] + [(?); (2); 1] = &gt;>([2; 3; 4]) = [(?); 1; 1] There may be some other ways for doing shift-into. <p> Therefore, for example, <ref> [(1); 2; 3] </ref> has the leftmost active element 2 and rightmost active element 3. And the equations /&lt;[(1); 2; 3] = 2 and /&gt;[(1); 2; 3] = 3 are true. As usual, reduction on a scalar value is not allowed. <p> Therefore, the result for &gt;&lt;[(1); 2; 3] should be <ref> [(?); (?); 3] </ref> since 2 is the leftmost active element. 5 The correct term should be shift-broadcast since the broadcasted element itself will be destroyed as (?). This unnatural interpretation is due to the exclusive form semantics.
References-found: 3

