URL: http://www.cs.umn.edu/Research/softeng/paper/rea.ps
Refering-URL: http://www.cs.umn.edu/Research/softeng/
Root-URL: http://www.cs.umn.edu
Title: Ripple Effect Analysis, Program Slicing, and Dependence Analysis  
Author: J. K. Joiner and W. T. Tsai 
Address: Minneapolis, MN 55455  
Affiliation: Department of Computer Science University of Minnesota  
Abstract: This paper distinguishes between ripple effect analysis (REA), program slicing, and dependence analysis. We find that rather than being equivalent to REA, program slicing is a technique with a narrower purpose than that of REA, but that it can be used to assist in portions of REA. Although program slicing can be automated and will produce the same result each time it is given the same input, REA is at best only semiautomatic and nondeterministic due to considerable programmer involvement. REA can be conducted at several levels of granularity on all types of software artifacts, but program slicing has primarily been defined at the statement level on program artifacts. One feature they have in common is dependence analysis, but we find that not all of the dependence relations used in supercompilers can cause ripple effects, and thus these extra dependence relations are not of concern for REA or program slicing. 
Abstract-found: 1
Intro-found: 1
Reference: [Aho 85] <author> A . V . A h o , R . S e t h i a n d J . D . U l l m a n , CompilersPrinciples, </author> <title> Techniques, and Tools, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1985. </year>
Reference: [Beck 93] <author> J. Beck and D. Eichmann, </author> <title> Program and Interface Slicing for Reverse Engineering, </title> <booktitle> IEEE Proc. 15th International Conference on Software Engineering, </booktitle> <year> 1993, </year> <pages> pp. 509518. </pages>
Reference-contexts: Slicing is a technique for decomposing an artifact and we can envision wanting to decompose artifacts other than programs. One use of decomposition slicing is in the area of enhancing reuse from a repository <ref> [Beck 93] </ref>. In many cases, we would like to 7 Ripple propagation rules are defined in [Zualkernan 92]. 15 reuse some a portion of a previous artifact instead of the entire thing.
Reference: [Beizer 90] <author> B . B e i z e r, </author> <title> Software Testing Techniques, S e c on d E d i t i o n , Va n Nostrand Reinhold, </title> <address> New York, NY, </address> <year> 1990. </year>
Reference-contexts: We should use a bug taxonomy which includes the kinds of bugs and their occurrence frequencies in various stages of software development collected from industrial environments to give realism to the experimental procedure. Beizers bug taxonomy <ref> [Beizer 90] </ref> is a good starting point. 6 Conclusions We defined REA as a process of iteratively finding side effects in a software artifact as a result of making some initial change.
Reference: [Chen 90] <author> S. Chen, K. G. Heisler, W. T. Tsai, X. P. Chen and E. Leung, </author> <title> A Model for Assembly Program Maintenance, </title> <journal> Journal of Software Maintenance: Research and Practice, </journal> <volume> Vol. 2, No. 1, </volume> <year> 1990, </year> <pages> pp. 3 32. </pages>
Reference-contexts: Other levels of granularity are also possible depending on the type of artifact. 4 Program Dependence Analysis Dependence analysis is necessary in many software maintenance models <ref> [Chen 90, Harrold 93, Heisler 93] </ref>, although it was first developed to aid in optimizing compilers [Kuck 81, Ferrante 87] and later supercompilers [Zima 91].
Reference: [Collofello 88] <author> J. S. Collofello and M. Orn, </author> <title> A Practical Software Maintenance Environment, </title> <booktitle> Proc. of IEEE International Conference on Software Maintenance, </booktitle> <year> 1988, </year> <pages> pp. 4551. </pages>
Reference-contexts: A problem with automatic identification of potential side effects of a change is that it might produce a huge number of potential side effects that need to be investigated. To help with this problem, <ref> [Collofello 88] </ref> suggests keeping semantic annotations for program constructs in a database. Then these annotations can be used as filters to stop a user from pursuing a given path during interactive REA.
Reference: [Davis 93] <author> A. M. Davis, </author> <title> Software Requirements: Objects, Functions, and States, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1993. </year>
Reference-contexts: Software specifications can be written in either formal languages, such as VDM [Hekmatpour 88] or Z, semiformal languages, such as data-flow diagram or object model <ref> [Davis 93] </ref>, or natural languages, such as English. Thus we can have more automatic REA on specifications written in formal languages, than on specifications written in natural languages. This characteristic is true for all artifacts of software development, including designs, programs, and test plans.
Reference: [Ferrante 87] <author> J. Fe rr a n t e , K. J. </author> <title> O t t en st e i n a nd J. D . W a rr e n , The Program Dependence Graph and Its Use in Optimization, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 9, No. 3, </volume> <month> July </month> <year> 1987, </year> <pages> pp. 319349. </pages>
Reference-contexts: 1 Introduction This paper focuses on REA [Haney 72, Yau 78] and its relationships to program slicing [Weiser 84, Horwitz 90] and dependence analysis <ref> [Kuck 81, Ferrante 87, Zima 91] </ref>. These three techniques are used extensively in software maintenance as well as in other areas of software development such as program optimization. Both REA and program slicing are used extensively by practicing software maintainers, and both require dependence analysis. <p> Ripple effects in natural language artifacts result from definitional and referential dependences, such as when one sentence uses a term defined in another portion of the document. Dependence graphs have been used to represent dependences among program entities <ref> [Kuck 81, Ferrante 87, Horwitz 90, Harrold 93, Livadas 93] </ref>. We may also use dependence graphs for other types of software artifacts. <p> Other levels of granularity are also possible depending on the type of artifact. 4 Program Dependence Analysis Dependence analysis is necessary in many software maintenance models [Chen 90, Harrold 93, Heisler 93], although it was first developed to aid in optimizing compilers <ref> [Kuck 81, Ferrante 87] </ref> and later supercompilers [Zima 91]. <p> Two primary types of program dependence are data dependence and control dependence <ref> [Ferrante 87] </ref>. Data dependence exists between two statements whenever a program 16 would compute a different result if the two statements were executed either in reverse order or in parallel. In the following example, statement S 2 depends on statement S 1 for the correct value of variable A.
Reference: [Gallagher 91] <author> K. B. Gallagher and J. R. Lyle, </author> <title> Using Program Slicing in Software Maintenance, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 17, No. 8, </volume> <month> August </month> <year> 1991, </year> <pages> pp. 751 761. </pages>
Reference-contexts: These sets of nonsequential statements were termed slices. The idea of understanding programs by grouping nonsequential statements is similar to programming plans [Soloway 84] and clichs [Rich 90]. <ref> [Gallagher 91] </ref> extends the idea of program slicing by completely decomposing a program into slices and then defining a set of allowable modifications that may be made to a slice such that maintenance activity is guaranteed not to produce any side effects in the remainder of the program.
Reference: [Haney 72] <author> F. M. Haney, </author> <title> Module Connection AnalysisA Tool for Scheduling Software Debugging Activities, </title> <booktitle> Proceedings of the 1972 Fall Joint Computer Conference, </booktitle> <month> December </month> <year> 1972, </year> <pages> pp. 173179. </pages>
Reference-contexts: 1 Introduction This paper focuses on REA <ref> [Haney 72, Yau 78] </ref> and its relationships to program slicing [Weiser 84, Horwitz 90] and dependence analysis [Kuck 81, Ferrante 87, Zima 91]. These three techniques are used extensively in software maintenance as well as in other areas of software development such as program optimization. <p> In Section 3, we discuss program slicing and its relationship to REA. In Section 4, we take up dependence analysis and show how it applies to REA and program slicing. 2 Ripple Effect Analysis 2.1 Definition of REA The existence and importance of ripple effect has been well documented. <ref> [Haney 72] </ref> coined the term ripple effect to describe the phenomenon by which changes to one program area have tendencies to be felt in other program areas as well.
Reference: [Harrold 93] <author> M. J. Harrold and B. Malloy, </author> <title> "A Unified Interprocedural Program Representation for a Maintenance Environment, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 19, No. 6, </volume> <month> June </month> <year> 1993, </year> <pages> pp. 584 593. 25 </pages>
Reference-contexts: Ripple effects in natural language artifacts result from definitional and referential dependences, such as when one sentence uses a term defined in another portion of the document. Dependence graphs have been used to represent dependences among program entities <ref> [Kuck 81, Ferrante 87, Horwitz 90, Harrold 93, Livadas 93] </ref>. We may also use dependence graphs for other types of software artifacts. <p> Other levels of granularity are also possible depending on the type of artifact. 4 Program Dependence Analysis Dependence analysis is necessary in many software maintenance models <ref> [Chen 90, Harrold 93, Heisler 93] </ref>, although it was first developed to aid in optimizing compilers [Kuck 81, Ferrante 87] and later supercompilers [Zima 91].
Reference: [Hekmatpour 88] <author> S. Hekmatpour and D. Ince, </author> <title> Software Prototyping, Formal Methods and VDM, </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England, </address> <year> 1988. </year>
Reference-contexts: Software specifications can be written in either formal languages, such as VDM <ref> [Hekmatpour 88] </ref> or Z, semiformal languages, such as data-flow diagram or object model [Davis 93], or natural languages, such as English. Thus we can have more automatic REA on specifications written in formal languages, than on specifications written in natural languages.
Reference: [Heisler 93] <author> K. G. Heisler, Y. Kasho and W. T. Tsai, </author> <title> A Reverse Engineering Model for C Programs, </title> <journal> Information Sciences, </journal> <volume> Vol. 68, No. 12, </volume> <month> Feb. </month> <year> 1993, </year> <pages> pp. 155. </pages>
Reference-contexts: Other levels of granularity are also possible depending on the type of artifact. 4 Program Dependence Analysis Dependence analysis is necessary in many software maintenance models <ref> [Chen 90, Harrold 93, Heisler 93] </ref>, although it was first developed to aid in optimizing compilers [Kuck 81, Ferrante 87] and later supercompilers [Zima 91].
Reference: [Horwitz 90] <author> S. Horwitz, T. Reps and D. Binkley, </author> <title> Interprocedural Slicing Using Dependence Graphs, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 12, No. 1, </volume> <month> January </month> <year> 1990, </year> <pages> pp. 26 60. </pages>
Reference-contexts: 1 Introduction This paper focuses on REA [Haney 72, Yau 78] and its relationships to program slicing <ref> [Weiser 84, Horwitz 90] </ref> and dependence analysis [Kuck 81, Ferrante 87, Zima 91]. These three techniques are used extensively in software maintenance as well as in other areas of software development such as program optimization. <p> Ripple effects in natural language artifacts result from definitional and referential dependences, such as when one sentence uses a term defined in another portion of the document. Dependence graphs have been used to represent dependences among program entities <ref> [Kuck 81, Ferrante 87, Horwitz 90, Harrold 93, Livadas 93] </ref>. We may also use dependence graphs for other types of software artifacts. <p> It is discussed in Section 2. 4 Error flow analysis, a technique for REA in programs in [Yau 78], is presented in Appendix 1. 5 Forward slicing is the opposite of program slicing finding program statements that are affected by a given statement <ref> [Horwitz 90] </ref>. It is discussed in Section 2. 8 some level of granularity and whose directed edges represent some kind of dependence relation between vertices. For example in Fig. 2.2, vertex 6 is directly dependent on vertices 2 and 5, and indirectly dependent on vertices 1 and 4. <p> Two main techniques used for implementing program slicing are the relevant variable technique [Weiser 84] and the dependence graph technique <ref> [Horwitz 90] </ref>. In the dependence graph technique, slices are found by tracing all paths along backward dependence edges from the starting vertex. See Appendix 3 for a comparison of both approaches. 3.1 Forward Slicing [Horwitz 90] also introduces a variant of program slicing called forward slicing. <p> for implementing program slicing are the relevant variable technique [Weiser 84] and the dependence graph technique <ref> [Horwitz 90] </ref>. In the dependence graph technique, slices are found by tracing all paths along backward dependence edges from the starting vertex. See Appendix 3 for a comparison of both approaches. 3.1 Forward Slicing [Horwitz 90] also introduces a variant of program slicing called forward slicing. The objective of forward slicing is to find all statements that are affected by variables in the initial statement. This is the exact opposite of the question raised by program slicing.
Reference: [Joiner 93] <author> J. K. Joiner, W. T. Tsai, X. P. Chen, S. Subramanian, C. Boddu and J. Sun, </author> <title> An Integrated Data-Centered Model for Software Maintenance, T R 9 3 8 5 , De p a r t m e n t o f C o m p u t e r S c i e n c e , U n i v e r s i t y o f Minnesota, </title> <address> Minneapolis, MN 55455, </address> <year> 1993. </year>
Reference-contexts: As long as the shared data items can be mapped from one program to another, REA can assist in tracing the effects of changes between programs by linking output variables affected in one program to input variables in another program and then finding side effects of those variables <ref> [Joiner 93] </ref>. Large programs are composed of multiple modules 1 to reduce complexity. Modules are constructed of multiple procedures 2 to take advantage of abstraction, and procedures are constructed of statements. <p> This application would be useful in the reuse of any stored artifact of software developmentspecifications, designs, programs, and test cases. The application of slicing on test cases is especially interesting in terms of regression testing <ref> [Joiner 93] </ref>. If we could specify the subset of program behavior that we wanted to regression test, then we could slice out just those test cases from the entire set, saving considerable testing time. <p> For example, if we are interested in the modules that affect a variable in another module, we could obtain a module slice which lists all the modules that affect the variable in that given module <ref> [Joiner 93] </ref>.
Reference: [Kim 90] <editor> W . K i m , Introduction to ObjectOriented Databases, </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Specifically, suppose we change the inheritance tree, what are the possible side effects if multiple inheritance is used? In objectoriented databases, similar issues arise and schema evolution is used to address them. A schema evolution taxonomy has been presented and studied in the objectoriented database context <ref> [Kim 90] </ref>. However, no similar studies have been done for objectoriented programs.
Reference: [Kirani 94] <author> S. Kirani, I. A. Zualkernan and W. T. Tsai, </author> <title> Comparative Evaluation of Expert System Testing Methods, </title> <note> to appear in Communications of ACM, </note> <year> 1994. </year>
Reference-contexts: Conventional wisdom holds that, in general, a change in upstream software artifacts such as specifications or designs can cause significant changes in downstream artifacts such as programs or test cases <ref> [Kirani 94] </ref>. During forward engineering, the cost of fixing software faults increases dramatically at later stages in the life cycle [Boehm 87]. Therefore, catching faults earlier in the life cycle is better than catching them later.
Reference: [Kuck 81] <author> D. J. Kuck, R. H. Kuhn, D. A. Padua, B. Leasure, and M. Wolfe, </author> <title> Dependence Graphs and Compiler Optimizations, </title> <booktitle> 8th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Williamsburg, VA, </address> <month> Jan 26-28, </month> <year> 1981, </year> <pages> pp. 207 218. </pages>
Reference-contexts: 1 Introduction This paper focuses on REA [Haney 72, Yau 78] and its relationships to program slicing [Weiser 84, Horwitz 90] and dependence analysis <ref> [Kuck 81, Ferrante 87, Zima 91] </ref>. These three techniques are used extensively in software maintenance as well as in other areas of software development such as program optimization. Both REA and program slicing are used extensively by practicing software maintainers, and both require dependence analysis. <p> Ripple effects in natural language artifacts result from definitional and referential dependences, such as when one sentence uses a term defined in another portion of the document. Dependence graphs have been used to represent dependences among program entities <ref> [Kuck 81, Ferrante 87, Horwitz 90, Harrold 93, Livadas 93] </ref>. We may also use dependence graphs for other types of software artifacts. <p> Other levels of granularity are also possible depending on the type of artifact. 4 Program Dependence Analysis Dependence analysis is necessary in many software maintenance models [Chen 90, Harrold 93, Heisler 93], although it was first developed to aid in optimizing compilers <ref> [Kuck 81, Ferrante 87] </ref> and later supercompilers [Zima 91]. <p> This view gives us our most detailed level of understanding of module behavior and enables the most detailed level of REA using this technique. 4.2 Dependence Relations and Ripple Effect In this section, we show the relationship between dependence relations useful for optimizing compilers and dependence relations useful for REA. <ref> [Kuck 81] </ref> defines five dependence relations between program statements: loop dependence, flow dependence, output dependence, antidependence, and input dependence. [Zima 91] uses the name true dependence for flow dependence and expands loop dependence into categories loop-carried and loop-independent. <p> For this paper, we use the original five dependence 20 relations since we are concerned with determining the side effects of a change in a statement, not in the reordering or parallel execution of statements. We now define five possible dependence relations between program statements from <ref> [Kuck 81] </ref>. In the definitions that follow in Table 4.1, inputs are variables fetched by a statement and outputs are those variable elements modified by it. Also, in the following definitions, statement S 1 is executed before statement S 2 .
Reference: [Livadas 93] <author> P. E. Livadas and S. Croll, </author> <title> System Dependence Graph Construction for Recursive Programs, </title> <booktitle> Proceedings of 17th IEEE COMPSAC, </booktitle> <month> Nov </month> <year> 1993, </year> <pages> pp. 414420. </pages>
Reference-contexts: Ripple effects in natural language artifacts result from definitional and referential dependences, such as when one sentence uses a term defined in another portion of the document. Dependence graphs have been used to represent dependences among program entities <ref> [Kuck 81, Ferrante 87, Horwitz 90, Harrold 93, Livadas 93] </ref>. We may also use dependence graphs for other types of software artifacts.
Reference: [Myers 79] <author> G. J. Myers, </author> <title> The Art of Software Testing, </title> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: One implication is that not only does the error situation have to be tested after the correction is made, but one must also perform regression testing to determine if a new error has been introduced. <ref> [Myers 79] </ref> 3 2.2 Importance of REA Throughout Software Development REA is needed in all phases of software development, including forward engineering, software maintenance, and reverse engineering because at each stage, software engineers must constantly change artifacts, whether they be specifications, designs, programs, or test cases. <p> If an input parameter of a module is changed, it is likely that the design specifications of this module and other modules that may call this module will need to be updated. A test case consists of an input and its expected outputs <ref> [Myers 79] </ref>. Test cases are usually generated based on a specific testing technique, such as decision coverage testing 4 or path testing [Myers 79]. <p> A test case consists of an input and its expected outputs <ref> [Myers 79] </ref>. Test cases are usually generated based on a specific testing technique, such as decision coverage testing 4 or path testing [Myers 79]. If one of the test cases in the test plan is changed, it is likely that the remaining test cases no longer satisfy the testing criteria such as path coverage. <p> Another approach would be to inject bugs in software using a bug taxonomy, have a software developer fix the bugs, and observe the process. This approach is similar to error seeding <ref> [Myers 79] </ref>. We are interested in what type of bugs induce most of ripples by artifact type, language used, and paradigm used. Random bugs may not be all that useful because they do not represent realistic data.
Reference: [Nakagawa 90] <author> A. T. Nakagawa and K. Futatsugi, </author> <title> Software Process la Algebra: OBJ for OBJ, </title> <booktitle> IEEE Proc. 12th International Conference on Software Engineering, </booktitle> <month> March </month> <year> 1990, </year> <pages> pp. 1223. </pages>
Reference-contexts: A change in one part of a specification may cause other parts of the specification to be changed because of dependence on the changed portion. Thus REA is needed during the specification phase. <ref> [Nakagawa 90] </ref> noted this and describes the possibility of REA on specifications in the specification language OBJ.
Reference: [Podgurski 90] <author> A. Pod gur ski a nd L . A. C larke, </author> <title> A Formal Model of Program Dependences and its Implications for Software Testing, Debugging, and Maintenance, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 16, No. 9, </volume> <month> Sept. </month> <year> 1990, </year> <pages> pp. 965 979. </pages>
Reference-contexts: The ripple effect phenomenon in programs is generally caused by a combination of data flow and control flow dependences <ref> [Podgurski 90] </ref>. For example, if a variable is given a value at one program point and at a later point that variable is used in the computation of another value, then a change in the earlier computation will be felt at the later point.
Reference: [Rich 90] <author> C. Rich and R. C. Waters, </author> <title> The Programmers Apprentice, </title> <publisher> ACM Press, Addison-Wesley, </publisher> <address> New York, New York, </address> <year> 1990. </year> <month> 26 </month>
Reference-contexts: These sets of nonsequential statements were termed slices. The idea of understanding programs by grouping nonsequential statements is similar to programming plans [Soloway 84] and clichs <ref> [Rich 90] </ref>. [Gallagher 91] extends the idea of program slicing by completely decomposing a program into slices and then defining a set of allowable modifications that may be made to a slice such that maintenance activity is guaranteed not to produce any side effects in the remainder of the program.
Reference: [Soloway 84] <author> E. Soloway and K. Ehrlich, </author> <title> Empirical Studies of Programming Knowledge, </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> Vol. 10, No. 5, </volume> <month> Sep. </month> <year> 1984, </year> <pages> pp. 595-609. </pages>
Reference-contexts: He concluded that many programmers grouped sets of nonsequential statements into units of abstraction, rather than the usual sequential statement abstractions such as procedures. These sets of nonsequential statements were termed slices. The idea of understanding programs by grouping nonsequential statements is similar to programming plans <ref> [Soloway 84] </ref> and clichs [Rich 90]. [Gallagher 91] extends the idea of program slicing by completely decomposing a program into slices and then defining a set of allowable modifications that may be made to a slice such that maintenance activity is guaranteed not to produce any side effects in the remainder
Reference: [Weiser 84] <author> M. </author> <title> W e i s e r , Program Slicing, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE10, No. 4, </volume> <month> July </month> <year> 1984, </year> <pages> pp. 352 357. </pages>
Reference-contexts: 1 Introduction This paper focuses on REA [Haney 72, Yau 78] and its relationships to program slicing <ref> [Weiser 84, Horwitz 90] </ref> and dependence analysis [Kuck 81, Ferrante 87, Zima 91]. These three techniques are used extensively in software maintenance as well as in other areas of software development such as program optimization. <p> For our purposes, a dependence graph is a directed graph whose vertices represent components of a software artifact at 3 Program slicing can be useful for finding program statements that potentially have an affect on variables at a pre-specified program statement <ref> [Weiser 84] </ref>. It is discussed in Section 2. 4 Error flow analysis, a technique for REA in programs in [Yau 78], is presented in Appendix 1. 5 Forward slicing is the opposite of program slicing finding program statements that are affected by a given statement [Horwitz 90]. <p> Table 2.3 Desirable Relationships For REA Statistics 3 Program Slicing Program slicing 6 is a technique for decomposing a program that was originally proposed for debugging, maintenance, and parallel processing <ref> [Weiser 84] </ref>. A slice is a program that computes a subset of the original programs behavior. <p> Two main techniques used for implementing program slicing are the relevant variable technique <ref> [Weiser 84] </ref> and the dependence graph technique [Horwitz 90]. In the dependence graph technique, slices are found by tracing all paths along backward dependence edges from the starting vertex.
Reference: [Wilde 89] <author> N . W i l d e , R . H u i t t a n d S . Hu i t t , Dependence Analysis Tools: </author> <title> Reusable Components for Software Maintenance, I E E E P r o c . Conference on Software Maintenance, </title> <booktitle> 1989, </booktitle> <pages> pp. 126131. </pages>
Reference-contexts: In the following example, statement S 2 depends on predicate A since the value of A determines whether S 2 is executed or not. S 1 if (A) In addition to strict data or control dependence, <ref> [Wilde 89] </ref> defines additional dependence relationships that occur between program entities that must be taken into account during software maintenance, including definition dependence and calling dependence.
Reference: [Yau 78] <author> S. S. Yau, J. S. Collofello and T. MacGregor, </author> <title> Ripple Effect Analysis of Software Maintenance, </title> <booktitle> Proc. of IEEE COMPSAC, </booktitle> <year> 1978, </year> <pages> pp. 60 65. </pages>
Reference-contexts: 1 Introduction This paper focuses on REA <ref> [Haney 72, Yau 78] </ref> and its relationships to program slicing [Weiser 84, Horwitz 90] and dependence analysis [Kuck 81, Ferrante 87, Zima 91]. These three techniques are used extensively in software maintenance as well as in other areas of software development such as program optimization. <p> We generalize the notion of ripple effect to extend into all artifacts of software development, including specifications, designs, programs, and test plans. Thus, we define REA as the process of finding and correcting faults due to side effects of some initial change in a software artifact. <ref> [Yau 78] </ref> discusses ripple effect in the context of software maintenance, saying that maintenance changes tend to spawn faults in other program areas because a programmer fails to check all affected areas for consistency. <p> For example, when a maintenance solution requires that an existing program variable be redefined, then other program areas that use the variable need to be checked for consistency. To locate these additional areas, <ref> [Yau 78] </ref> provides a technique called error flow analysis (See Appendix 1). In [Yau 88], Yau and Chang present an algorithm for analyzing potential ripple effect which is based on an intermodule data flow analysis technique. <p> It is discussed in Section 2. 4 Error flow analysis, a technique for REA in programs in <ref> [Yau 78] </ref>, is presented in Appendix 1. 5 Forward slicing is the opposite of program slicing finding program statements that are affected by a given statement [Horwitz 90].
Reference: [Yau 88] <author> S. S. Yau and S. S. Liu, </author> <title> Some Approaches to Logical Ripple Effect Analysis, </title> <type> SERC TR 24F, </type> <institution> Software Engineering Research Center, University of Florida, </institution> <address> Gainesville, FL 32611, </address> <year> 1988. </year>
Reference-contexts: For example, when a maintenance solution requires that an existing program variable be redefined, then other program areas that use the variable need to be checked for consistency. To locate these additional areas, [Yau 78] provides a technique called error flow analysis (See Appendix 1). In <ref> [Yau 88] </ref>, Yau and Chang present an algorithm for analyzing potential ripple effect which is based on an intermodule data flow analysis technique.
Reference: [Zima 91] <author> H. Zima and B. Chapman, </author> <title> Supercompilers for Parallel and Vector Computers, </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction This paper focuses on REA [Haney 72, Yau 78] and its relationships to program slicing [Weiser 84, Horwitz 90] and dependence analysis <ref> [Kuck 81, Ferrante 87, Zima 91] </ref>. These three techniques are used extensively in software maintenance as well as in other areas of software development such as program optimization. Both REA and program slicing are used extensively by practicing software maintainers, and both require dependence analysis. <p> Other levels of granularity are also possible depending on the type of artifact. 4 Program Dependence Analysis Dependence analysis is necessary in many software maintenance models [Chen 90, Harrold 93, Heisler 93], although it was first developed to aid in optimizing compilers [Kuck 81, Ferrante 87] and later supercompilers <ref> [Zima 91] </ref>. <p> of REA using this technique. 4.2 Dependence Relations and Ripple Effect In this section, we show the relationship between dependence relations useful for optimizing compilers and dependence relations useful for REA. [Kuck 81] defines five dependence relations between program statements: loop dependence, flow dependence, output dependence, antidependence, and input dependence. <ref> [Zima 91] </ref> uses the name true dependence for flow dependence and expands loop dependence into categories loop-carried and loop-independent. <p> Before After S 1 X = A * B S 1 X = A / B Table 4.5 Effect of Flow Dependence on Ripple Effect Flow dependence may also be loop-carried <ref> [Zima 91] </ref>. Table 4.6 illustrates loop-carried flow dependence and shows that it too causes a side effect that must be checked.
Reference: [Zualkernan 92] <author> I. A. Zualkernan, S. Bhattacharya, H. J. Lee and W. T. Tsai, </author> <title> Ripple Effect Analysis for C Programs, </title> <type> TR 9237, </type> <institution> Department of Computer Science, University of Minnesota, </institution> <address> Minneapolis, MN 55455, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: One use of decomposition slicing is in the area of enhancing reuse from a repository [Beck 93]. In many cases, we would like to 7 Ripple propagation rules are defined in <ref> [Zualkernan 92] </ref>. 15 reuse some a portion of a previous artifact instead of the entire thing. It would be useful to have a mechanism that could slice out just the portion of the repository artifact that we were interested in.
References-found: 29

