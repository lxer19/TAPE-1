URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1995/UM-CS-1995-060.ps
Refering-URL: http://www-ccsl.cs.umass.edu/~jack/
Root-URL: 
Email: fkaplan,wiledeng@cs.umass.edu  
Title: Formalization and Application of a Unifying Model for Name Management  
Author: Alan Kaplan Jack C. Wileden 
Date: October, 1995  
Note: To appear in Proceedings of the Third Symposium on the Foundations  
Address: Amherst, Massachusetts 01003  Washington, D.C.,  
Affiliation: Convergent Computing Systems Laboratory Computer Science Department University of Massachusetts  of Software Engineering  
Abstract: CMPSCI Technical Report 95-60 July 1995 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrews, T. </author> <title> Designing linguistic interfaces to an object database or what do C++, </title> <booktitle> SQL and Hell have in common? In Fourth International Workshop on Database Programming Languages (New York, </booktitle> <address> NY, </address> <month> Aug-Sep </month> <year> 1993), </year> <pages> pp. 3-10. </pages>
Reference-contexts: This results in ad hoc naming conventions such as suffixing users' initials to mailbox objects or prefixing vendors' names to off-the-shelf objects, in order to avoid name conflicts, and in the end unnecessarily clutters the persistent store <ref> [1] </ref>. Another prob lem involves the time at which name interpretation takes place. In OODBs, interpretation of names for persistent objects is often restricted to run-time.
Reference: [2] <author> Borger, E., Gurevich, Y., and Rosenzweig, D. </author> <title> The bakery algorithm: Yet another specification and verification. In Specification and Validation Methods, </title> <editor> E. Borger, Ed. </editor> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: Evolving algebras have been used in defining formal semantics for several programming languages, including C++ [23], Modula-2 [12] and Prolog [3], for other aspects of computational systems, such as data models for object-oriented databases [9], and for particular algorithms, such as the Kermit communication protocol [13] and Lamport's bakery algorithm <ref> [2] </ref>. The formalism has also been used as a basis for proving properties of systems (e.g., [2, 13]) and has been implemented in the form of an interpreter [14] that can be used for investigating properties of EA descriptions of systems. <p> The formalism has also been used as a basis for proving properties of systems (e.g., <ref> [2, 13] </ref>) and has been implemented in the form of an interpreter [14] that can be used for investigating properties of EA descriptions of systems.
Reference: [3] <author> Borger, E., and Rosenzweig, D. </author> <title> A mathematical definition of full Prolog. </title> <booktitle> In Science of Computer Programming. </booktitle> <year> 1994. </year>
Reference-contexts: The framework itself has evolved, its current definition being captured in [11]. Evolving algebras have been used in defining formal semantics for several programming languages, including C++ [23], Modula-2 [12] and Prolog <ref> [3] </ref>, for other aspects of computational systems, such as data models for object-oriented databases [9], and for particular algorithms, such as the Kermit communication protocol [13] and Lamport's bakery algorithm [2].
Reference: [4] <author> Comer, D. E., and Peterson, L. L. </author> <title> Understanding naming in distributed systems. </title> <booktitle> Distributed Computing 3, </booktitle> <month> 2 (May </month> <year> 1989), </year> <pages> 51-60. </pages>
Reference-contexts: To that end, we have developed the Piccolo 2 model. Because of the ubiquitous nature of names in computing, there have been a number of formalisms involving or related to the use of names (e.g., <ref> [4, 8, 16, 19, 20, 22, 26] </ref>). Such formalisms, however, have generally been specific to individual, or limited sets of, computation domains.
Reference: [5] <author> Dearle, A., Connor, R., Brown, F., and Mor--rison, R. </author> <booktitle> Napier88|A database programming language? In Second International Workshop on Database Programming Languages (June 1989), </booktitle> <editor> R. Hull, R. Morrison, and D. Stemple, </editor> <booktitle> Eds., </booktitle> <pages> pp. 213-229. </pages>
Reference-contexts: The availability of binding (n; o) makes it possible to use name n to reference, access or manipulate object o. Bindings may also include additional information, such as type and mutability information (as, for exam ple, in Napier <ref> [5] </ref>). binding space: A set of bindings that serves as a collection of definitions for names. context: A set of bindings that is available for use in referencing, accessing or manipulating objects.
Reference: [6] <author> DOD. </author> <title> Reference Manual for the Ada Programming Language. </title> <institution> United States Department of Defense, </institution> <address> Washington, D.C., </address> <month> Jan. </month> <year> 1983. </year> <note> (ANSI/ MIL-STD-1815A). </note>
Reference-contexts: The possible existence of different program libraries and the means by which they are named are not concerns of the language definition; they are concerns of the programming environment <ref> [6] </ref>. As an extremely simple example of some Ada library problems, consider a software system composed of a collection of modules written in Ada and organized into three separate libraries, as shown in Figure 2. In this example, procedure C, in Library 3, imports two packages, A and B.
Reference: [7] <author> Feldman, S. </author> <title> Make a program for maintaining computer programs. </title> <journal> Software-Practice and Experience 9, </journal> <month> 4 (Apr. </month> <year> 1979), </year> <pages> 255-265. </pages>
Reference-contexts: While our three examples illustrate only a small subset of the name management problems that can arise in practice, they nevertheless provide some indication of how serious and often subtle the resulting difficulties can be. 2.1 Make Our first example is based on an extremely simple use of Make <ref> [7] </ref> (specifically, the Free Software Foundation's GNU Make [21]), a well-known and widely used Unix 1 software engineering utility.
Reference: [8] <author> Fraser, A. </author> <title> On the meaning of names in programming systems. </title> <journal> Communications of the ACM 14, </journal> <month> 6 (June </month> <year> 1971), </year> <pages> 409-416. </pages>
Reference-contexts: To that end, we have developed the Piccolo 2 model. Because of the ubiquitous nature of names in computing, there have been a number of formalisms involving or related to the use of names (e.g., <ref> [4, 8, 16, 19, 20, 22, 26] </ref>). Such formalisms, however, have generally been specific to individual, or limited sets of, computation domains.
Reference: [9] <author> Gottlob, G., Kappel, G., and Schrefl, M. </author> <title> Semantics of object-oriented data models The evolving algebra approach. In Next Generation Information System Technology, </title> <booktitle> First International East/West Database Workshop (Kiev, </booktitle> <address> USSR, </address> <month> Oct. </month> <year> 1990), </year> <editor> J. Schmidt and A. Stogny, Eds., </editor> <volume> no. </volume> <booktitle> 504 in Lecture Notes In Computer Science, </booktitle> <pages> pp. 144-160. </pages>
Reference-contexts: The framework itself has evolved, its current definition being captured in [11]. Evolving algebras have been used in defining formal semantics for several programming languages, including C++ [23], Modula-2 [12] and Prolog [3], for other aspects of computational systems, such as data models for object-oriented databases <ref> [9] </ref>, and for particular algorithms, such as the Kermit communication protocol [13] and Lamport's bakery algorithm [2].
Reference: [10] <author> Gurevich, Y. </author> <booktitle> Logic and the challenge of computer science. In Current Trends in Theoretical Computer Science, </booktitle> <editor> E. Borger, Ed. </editor> <publisher> Computer Science Press, </publisher> <year> 1988, </year> <pages> pp. 1-57. </pages>
Reference-contexts: We begin with a brief introduction to evolving algebras, then consider some aspects of an evolving algebra (EA) formalization of Piccolo, including analysis opportunities arising from such a formalization. 4.1 Overview of Evolving Algebras Evolving algebras were introduced by Gurevich as a framework for defining operational semantics <ref> [10] </ref>. The framework itself has evolved, its current definition being captured in [11].
Reference: [11] <author> Gurevich, Y. </author> <title> Evolving algebras 1993: Lipari guide. In Specification and Validation Methods, </title> <editor> E. Borger, Ed. </editor> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: The framework itself has evolved, its current definition being captured in <ref> [11] </ref>. <p> Among the advantages of the EA approach is the ability to formulate semantic definitions at multiple levels of abstraction, so that different facets of a system can be described at their respective "natural abstraction levels" <ref> [11] </ref>. We have found this feature very useful in formalizing the semantics of Piccolo concepts, as will be apparent in the examples of Section 4.2. The evolving algebra formalism is based on multi-sorted first order logical structures with partial functions. <p> This brief introduction to evolving algebras, while sufficient for our purposes in this paper, glosses over a number of technical points and omits several interesting aspects of the formalism. The interested reader is referred to <ref> [11] </ref> for a complete treatment. 4.2 An EA/Piccolo Formulation of Name Management in Make and Unix To help illustrate our application of evolving algebras to Piccolo (i.e., EA/Piccolo), we return our attention to the Make/Unix example first described in Section 2.1 and later examined in Section 3.2.
Reference: [12] <author> Gurevich, Y., and Morris, J. </author> <title> Algebraic operational semantics and Modula-2. </title> <booktitle> In First Workshop on Computer Science Logic (1988), </booktitle> <editor> E. Borger, H. K. Buning, and M. Richter, Eds., </editor> <volume> no. </volume> <booktitle> 329 in Lecture Notes In Computer Science, </booktitle> <pages> pp. 81-101. </pages>
Reference-contexts: The framework itself has evolved, its current definition being captured in [11]. Evolving algebras have been used in defining formal semantics for several programming languages, including C++ [23], Modula-2 <ref> [12] </ref> and Prolog [3], for other aspects of computational systems, such as data models for object-oriented databases [9], and for particular algorithms, such as the Kermit communication protocol [13] and Lamport's bakery algorithm [2].
Reference: [13] <author> Huggins, J. </author> <title> Kermit: Specification and verification. In Specification and Validation Methods, </title> <editor> E. Borger, Ed. </editor> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: Evolving algebras have been used in defining formal semantics for several programming languages, including C++ [23], Modula-2 [12] and Prolog [3], for other aspects of computational systems, such as data models for object-oriented databases [9], and for particular algorithms, such as the Kermit communication protocol <ref> [13] </ref> and Lamport's bakery algorithm [2]. The formalism has also been used as a basis for proving properties of systems (e.g., [2, 13]) and has been implemented in the form of an interpreter [14] that can be used for investigating properties of EA descriptions of systems. <p> The formalism has also been used as a basis for proving properties of systems (e.g., <ref> [2, 13] </ref>) and has been implemented in the form of an interpreter [14] that can be used for investigating properties of EA descriptions of systems.
Reference: [14] <author> Huggins, J., and Mani, R. </author> <title> The evolving algebra interpreter, </title> <type> version 2.0. </type> <institution> University of Michigan, </institution> <year> 1995. </year>
Reference-contexts: The formalism has also been used as a basis for proving properties of systems (e.g., [2, 13]) and has been implemented in the form of an interpreter <ref> [14] </ref> that can be used for investigating properties of EA descriptions of systems. Among the advantages of the EA approach is the ability to formulate semantic definitions at multiple levels of abstraction, so that different facets of a system can be described at their respective "natural abstraction levels" [11]. <p> These epochs were added in order to facilitate formal reasoning about our EA/Piccolo model of name management in Make/Unix. In particular, they are used to enable automated analyses of the model using the EA Interpreter <ref> [14] </ref>. The epoch e ccc is used to indicate when a particular analysis should be performed, and the epoch e hc is used to to interrupt execution of A Make/Unix by the EA Interpreter when an analysis reports an inconsistency.
Reference: [15] <author> Intermetrics, Inc. </author> <title> Ada 95 Rationale. </title> <address> Cambridge, MA, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Such problems also complicate, and therefore inhibit, inclusion of packages that define overlapping sets of names, which in turn can curtail software reuse and limit the value of standard libraries. While the provision of child libraries in Ada95 <ref> [15] </ref> ameliorates such problems to some extent, in general, these and other related difficulties are further evidence of how inadequacies in name management aspects of library management can lead to software engineering problems.
Reference: [16] <author> Johnston, J. </author> <title> The contour model of block structured processes. </title> <journal> SIGPLAN Notices 6, </journal> <month> 2 (June </month> <year> 1971), </year> <pages> 55-82. </pages>
Reference-contexts: To that end, we have developed the Piccolo 2 model. Because of the ubiquitous nature of names in computing, there have been a number of formalisms involving or related to the use of names (e.g., <ref> [4, 8, 16, 19, 20, 22, 26] </ref>). Such formalisms, however, have generally been specific to individual, or limited sets of, computation domains.
Reference: [17] <author> Kaplan, A., and Wileden, J. Conch: </author> <title> Experimenting with enhanced name management for persistent object systems. </title> <booktitle> In Sixth International Workshop on Persistent Object Systems (Taras-con, </booktitle> <address> Provence, France, </address> <month> Sept. </month> <year> 1994). </year>
Reference-contexts: Here we mention only three representative problems. A more extensive examination of these issues can be found in <ref> [17] </ref>. One of the primary goals of OODBs is to make persistence an orthogonal property to type, thus obviating the need, at least from the programmer's perspective, for traditional file systems and (relational) databases. <p> We have, in fact, used Piccolo as a basis for implementing a prototype user interface shell for an object-oriented database system <ref> [17] </ref>. Being based on the Piccolo concepts, this shell provides much more general and powerful name management capabilities to users of the OODB than did its original interface, or than are found in most such systems. <p> In fact, as noted earlier, we have already done some work along these lines. The current prototype of the Conch user interface shell <ref> [17] </ref> for the TI/Arpa Open OODB [24] implements support for context and closure definition, including simple CFT and CFP facilities, that directly reflects the main concepts found in Piccolo.
Reference: [18] <author> Kaplan, A., and Wileden, J. C. PolySPIN: </author> <title> An architecture for polylingual object-oriented databases. </title> <note> Submitted. </note>
Reference-contexts: The resulting name management mechanism is uniformly applicable from the C++ and the CLOS application programmer interfaces to Open OODB, thus contributing to multi-language interoperability <ref> [18] </ref> as well as enhanced name management. Ongoing and future work on the mechanisms facet of our name management research program includes development of similar support for Piccolo-inspired capabilities applicable to other classes of software systems and tools, such as Make-like tools and software module library systems.
Reference: [19] <author> Morrison, R., Atkinson, M., Brown, A., and Dearle, A. </author> <title> On the classification of binding mechanisms. </title> <journal> Information Processing Letters 34, </journal> <month> 1 (Feb. </month> <year> 1990), </year> <pages> 51-55. </pages>
Reference-contexts: In OODBs, interpretation of names for persistent objects is often restricted to run-time. If persistence is indeed orthogonal, then OODBs should provide a range of name interpretation times matching those provided by programming languages and operating systems (e.g., composition, compile, link and load time) <ref> [19] </ref>. Finally, OODB developers and maintainers are provided with little, if any, support for determining the name reference behavior for an object. In order to determine this information, developers and maintainers face the tedious and error-prone task of manually analyzing source code, configuration scripts, etc. <p> To that end, we have developed the Piccolo 2 model. Because of the ubiquitous nature of names in computing, there have been a number of formalisms involving or related to the use of names (e.g., <ref> [4, 8, 16, 19, 20, 22, 26] </ref>). Such formalisms, however, have generally been specific to individual, or limited sets of, computation domains.
Reference: [20] <author> Saltzer, J. </author> <title> Naming and binding of objects. In Operating Systems: An Advanced Course, no. </title> <booktitle> 60 in Lecture Notes in Computer Science. Spring-Verlag, 1978, ch. 3A, </booktitle> <pages> pp. 99-208. </pages>
Reference-contexts: To that end, we have developed the Piccolo 2 model. Because of the ubiquitous nature of names in computing, there have been a number of formalisms involving or related to the use of names (e.g., <ref> [4, 8, 16, 19, 20, 22, 26] </ref>). Such formalisms, however, have generally been specific to individual, or limited sets of, computation domains.
Reference: [21] <author> Stallman, R. M., and McGrath, R. </author> <title> GNU Make: </title>
Reference-contexts: small subset of the name management problems that can arise in practice, they nevertheless provide some indication of how serious and often subtle the resulting difficulties can be. 2.1 Make Our first example is based on an extremely simple use of Make [7] (specifically, the Free Software Foundation's GNU Make <ref> [21] </ref>), a well-known and widely used Unix 1 software engineering utility. Although Make is a versatile and powerful tool with many features (see [21] for details), in our example it is used, as it most often is, to automatically determine which pieces of a large program need to be recompiled, and <p> the resulting difficulties can be. 2.1 Make Our first example is based on an extremely simple use of Make [7] (specifically, the Free Software Foundation's GNU Make <ref> [21] </ref>), a well-known and widely used Unix 1 software engineering utility. Although Make is a versatile and powerful tool with many features (see [21] for details), in our example it is used, as it most often is, to automatically determine which pieces of a large program need to be recompiled, and then issue commands to recompile them.
References-found: 21

