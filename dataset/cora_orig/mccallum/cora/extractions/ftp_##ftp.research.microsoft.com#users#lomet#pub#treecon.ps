URL: ftp://ftp.research.microsoft.com/users/lomet/pub/treecon.ps
Refering-URL: http://www.research.microsoft.com/users/lomet/pub/default.htm
Root-URL: http://www.research.microsoft.com
Title: Access Method Concurrency with Recovery  
Author: David Lomet Betty Salzberg 
Address: One Kendall Sq., Bldg. 700 Cambridge, MA 02139  Boston, MA.  
Affiliation: Digital Equipment Corp. Cambridge Research Lab  College of Computer Science Northeastern University  
Abstract: Providing high concurrency in B + -trees has been studied extensively. But few efforts have been documented for combining concurrency methods with a recovery scheme that preserves well-formed trees across system crashes. We describe an approach for this that works for a class of index trees that is a generalization of the B link -tree. A major feature of our method is that it works with a range of different recovery methods. It achieves this by decomposing structure changes in an index tree into a sequence of atomic actions, each one leaving the tree well-formed and each working on a separate level of the tree. All atomic actions on levels of the tree above the leaf level are independent of database transactions, and so are of short duration. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bayer, R., Schkolnick, M., </author> <title> Concurrency of operations on B-trees. </title> <note> Acta Informatica 9,1 (1977) 1-21. </note>
Reference-contexts: 1 Introduction The subject of concurrency in B + -trees has a long history <ref> [1, 6, 14, 15, 16, 17] </ref>. Most work, with the exception of [5, 14], have not treated the problem of system crashes during structure changes. In this paper, we show how to manage concurrency and recovery for a wide class of index tree structures, single attribute, multiattribute, and versioned.
Reference: [2] <author> Eswaren, K., Gray, J., Lorie, R. and Traiger, I. </author> <title> On the notions of consistency and predicate locks in a database system. </title> <note> Comm ACM 19,11 (Nov 1976) 624-633. </note>
Reference-contexts: Space management information can be ordered last. When arbitrary atomic actions are possible, two phase locking is used to ensure serializability <ref> [2] </ref>. However, when dealing with index trees, latches can sometimes be released early without violating correctness. This occurs in traversing tree nodes during a search. Promoting a previously acquired latch violates the ordering of resources and compromises deadlock avoidance. Promotion is the most common cause of deadlock [5].
Reference: [3] <author> Evangelidis, G., Lomet, D. and Salzberg, B., </author> <title> Modifications of the hB-tree for node consolidation and concurrency. </title> <note> (in preparation) </note>
Reference-contexts: This makes the treatment of hyperplane splits consistent with that of other splits. This is illustrated in Figure 2. A complete description and explanation of hB-tree concurrency, node splitting, and node consolidation is given in <ref> [3] </ref>. 3 -tree Operations Here we describe the operations on -trees in a very general way. The steps do not describe how to deal with concurrent operations, with failures, or how to decompose structure changes into atomic actions.
Reference: [4] <author> Gray, J.N., Lorie, R. A., Putzulo, G. R., and Traiger, I. L., </author> <title> Granularity of locks and degrees of consistency in a shared data base. </title> <booktitle> IFIP Working Conf on Modeling of Data Base Management Systems (1976) 1-29. </booktitle>
Reference-contexts: Promotion is the most common cause of deadlock [5]. For example, when two transactions set S latches on the same object to be updated, and then subsequently desire to promote their latches to X, a deadlock results. Update (U) mode <ref> [4] </ref> supports promotion. It allows sharing by readers, but conflicts with X and other U modes. An atomic action is not allowed to promote from a S to an X latch. But it may promote from U to X mode.
Reference: [5] <author> Gray, J. and Reuter, </author> <title> A.,Transaction Processing: Techniques and Concepts, </title> <note> Morgan Kauf-mann (book in preparation). </note>
Reference-contexts: 1 Introduction The subject of concurrency in B + -trees has a long history [1, 6, 14, 15, 16, 17]. Most work, with the exception of <ref> [5, 14] </ref>, have not treated the problem of system crashes during structure changes. In this paper, we show how to manage concurrency and recovery for a wide class of index tree structures, single attribute, multiattribute, and versioned. Further, our approach works for a large class of recovery methods. <p> However, when dealing with index trees, latches can sometimes be released early without violating correctness. This occurs in traversing tree nodes during a search. Promoting a previously acquired latch violates the ordering of resources and compromises deadlock avoidance. Promotion is the most common cause of deadlock <ref> [5] </ref>. For example, when two transactions set S latches on the same object to be updated, and then subsequently desire to promote their latches to X, a deadlock results. Update (U) mode [4] supports promotion. It allows sharing by readers, but conflicts with X and other U modes.
Reference: [6] <author> Lehman, P., Yao, </author> <title> S.B., Efficient locking for concurrent operations on B-trees. </title> <journal> ACM Trans. </journal> <note> Database Systems l6,4 (Dec 1981) 650-670. </note>
Reference-contexts: 1 Introduction The subject of concurrency in B + -trees has a long history <ref> [1, 6, 14, 15, 16, 17] </ref>. Most work, with the exception of [5, 14], have not treated the problem of system crashes during structure changes. In this paper, we show how to manage concurrency and recovery for a wide class of index tree structures, single attribute, multiattribute, and versioned. <p> To copy otherwise, or to republish, requires a fee and/or specific permission. 1992 ACM SIGMOD - 6/92/CA,USA c fl1992 ACM 0-89791-522-4/92/0005/0185...$1.50 1. We define a search structure, called a -tree, that is a generalization of the B link -tree <ref> [6] </ref>. Our concurrency and recovery method is defined to work with all search structures in this class. Recent work [18] suggests that approaches based on B link -trees should have higher concurrency than other proposed methods. <p> However, each node at a level need not have a parent node at the next higher level. This is an abstraction and generalization of the idea introduced in the B link -tree <ref> [6] </ref>. That is, having a new node connected in the B link - tree only via a side pointer is acceptable. Like [17], we define the requirements of a well-formed general search structure.
Reference: [7] <author> Lomet, D. B. </author> <title> Process structuring, synchronization, and recovery using atomic actions. </title> <booktitle> Proc. ACM Conf. on Language Design for Reliable Software, SIGPLAN Notices 12,3 (Mar 1977) 128-137. </booktitle>
Reference-contexts: Recent work [18] suggests that approaches based on B link -trees should have higher concurrency than other proposed methods. Thus, our technique has both good performance and very broad applicability. 2. -tree structure changes consist of a sequence of atomic actions <ref> [7] </ref>. These separate actions are serializable and are guaranteed to have the all or nothing property by the recovery method. Searchers can see the intermediate states of the -tree that exist between these atomic actions. Hence, complete structural changes are not se-rializable.
Reference: [8] <author> Lomet, </author> <title> D.B. Subsystems of processes with deadlock avoidance. </title> <journal> IEEE Trans. </journal> <note> on Software Engineering SE-6,3 (May 1980) 297-304. </note>
Reference-contexts: Latches do not involve the database lock manager and latches do not conflict with standard database locks. Deadlock is avoided by PREVENTING cycles in a "potential delay" graph <ref> [8] </ref>. If resources are ordered and latched in that order, the potential delay graph can be kept cycle-free without materializing it.
Reference: [9] <author> Lomet, </author> <title> D.B. Recovery for shared disk systems using multiple redo logs. </title> <institution> Digital Equipment Corp. Tech ReportCRL90/4 (Oct 1990) Cambridge Research Lab, </institution> <address> Cambridge, MA </address>
Reference-contexts: To verify saved information, we use state identifiers <ref> [9] </ref> within nodes to indicate the states of each node. We record these identifiers as part of our saved path.
Reference: [10] <author> Lomet, D. and Salzberg, B., </author> <title> Access methods for multiversion data, </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Portland, OR (May 1989) 315-324. </address>
Reference-contexts: The directly contained space of a B link -tree node is the space it is responsible for minus the space it has delegated to its (one) sibling. 2.2.2 The TSB-tree A TSB-tree <ref> [10] </ref> provides indexed access to multiple versions of key sequenced records. As a result, it indexes these records both by key and by time, and we can split by either of these attributes. Historical nodes (nodes created by a split in the time dimension) never split again.
Reference: [11] <author> Lomet, D. and Salzberg, B., </author> <title> The hB-tree: a mul-tiattribute indexing method with good guaranteed performance. </title> <journal> ACM Trans. </journal> <note> Database Systems 15,4 (Dec 1990) 625-658. </note>
Reference-contexts: The new node will contain a copy of the history sibling pointer. It makes the new current node responsible for not merely its current key space, but for the entire history of this key space. 2.2.3 The hB-Tree In the hB-tree <ref> [11] </ref>, the idea of containing and contained nodes is explicit and they are described with kd-tree fragments. The "External" markers of [11] can be replaced with the addresses of the nodes which were extracted, and a linking network established with the desired properties. <p> It makes the new current node responsible for not merely its current key space, but for the entire history of this key space. 2.2.3 The hB-Tree In the hB-tree <ref> [11] </ref>, the idea of containing and contained nodes is explicit and they are described with kd-tree fragments. The "External" markers of [11] can be replaced with the addresses of the nodes which were extracted, and a linking network established with the desired properties. In addition, when the split is by a hyperplane, instead of eliminating the root of the contain copies of old history node pointers and old key pointers. <p> New historic nodes contain copies of old history pointers. Current nodes are responsible for all previous time through their historical pointers and all higher key ranges through their key (side) pointers. local tree in the splitting node, as in <ref> [11] </ref>, one child of the root (say the right child) points to the new sibling containing the contents of the right subtree. This makes the treatment of hyperplane splits consistent with that of other splits. This is illustrated in Figure 2.
Reference: [12] <author> Lomet, D. and Salzberg, B. </author> <title> Concurrency and Recovery for Index Trees. </title> <institution> Digital Equipment Corp. Tech Report CRL91/8 (Aug 1991) Cambridge Research Lab, </institution> <address> Cambridge, MA </address>
Reference-contexts: And consolidate never requests a U-latch on the index node to be updated while it holds database locks. Hence, its holding of this U-latch cannot conflict with another consolidate (or any other action) that holds database locks. Details of the consolidate operation can be found in <ref> [12] </ref>. 4.2 Page-oriented UNDO 4.2.1 Non-commutative Updates Data node splitting and consolidation require database locks for some (but not all) recovery protocols. <p> Update NODE: Post the index term in NODE. Post a log record describing the update to the log. Release all latches still held by the action. 6 Discussion There are many ways to realize -tree updates and associated structure changes. We describe a specific complete procedure in <ref> [12] </ref>. In this paper, we have emphasized the abstract elements of our approach.
Reference: [13] <author> Mohan, C., Haderle, D., Lindsay, B., Pirahesh, P., and Schwarz, P. </author> <title> ARIES: a transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. </title> <note> (to appear in ACM Trans. Database Systems). </note>
Reference-contexts: Hence, the recovery manager needs to know about atomic actions. Three possible ways of identifying an atomic action to the recovery manager are as (i) a separate database transaction, (ii) a special system transaction, or (iii) as a "nested top level action" <ref> [13] </ref>. Our approach works with any of these techniques, or any other that guarantees atomicity. 5 Structure Changes A -tree structure change is decomposed into a sequence of atomic actions. An update or insert of data into a node can result in a node split. This is one atomic action.
Reference: [14] <author> Mohan, C. and Levine, F., ARIES/IM: </author> <title> an efficient and high concurrency index management method using write-ahead logging. </title> <booktitle> (to appear in Proc. ACM SIGMOD Conf., </booktitle> <address> San Diego, </address> <month> (June </month> <year> 1992)). </year>
Reference-contexts: 1 Introduction The subject of concurrency in B + -trees has a long history <ref> [1, 6, 14, 15, 16, 17] </ref>. Most work, with the exception of [5, 14], have not treated the problem of system crashes during structure changes. In this paper, we show how to manage concurrency and recovery for a wide class of index tree structures, single attribute, multiattribute, and versioned. <p> 1 Introduction The subject of concurrency in B + -trees has a long history [1, 6, 14, 15, 16, 17]. Most work, with the exception of <ref> [5, 14] </ref>, have not treated the problem of system crashes during structure changes. In this paper, we show how to manage concurrency and recovery for a wide class of index tree structures, single attribute, multiattribute, and versioned. Further, our approach works for a large class of recovery methods. <p> These separate actions are serializable and are guaranteed to have the all or nothing property by the recovery method. Searchers can see the intermediate states of the -tree that exist between these atomic actions. Hence, complete structural changes are not se-rializable. By contrast, in ARIES/IM <ref> [14] </ref> com plete structural changes are serial. 3. We define separate actions for performing updates at each level of the tree. Update actions on non-leaf nodes are separate from any transaction whose update triggers a structure change. <p> Only node-splitting at the leaves of a tree may need to be within an updating transaction. Even in this case, only for page-oriented UNDO recovery systems do locks on the split nodes need to be kept to the end of the transaction. This is unlike <ref> [14] </ref> where entire structure changes are subtransactions of database transactions and where non-page-oriented UNDO re covery must be supported. 4. When a system crash occurs during the sequence of atomic actions that constitutes a complete - tree structure change, crash recovery takes no special measures. <p> To avoid latch-lock deadlocks, we observe the: * No Wait Rule <ref> [14] </ref>: An action does not wait for database locks while holding a latch that can conflict with a holder of a database lock. For our -tree operations, we must release latches on data nodes whenever we wait for database locks. However, latches on index nodes may be retained.
Reference: [15] <author> Sagiv, Y., </author> <title> Concurrent operations on B* trees with overtaking. </title> <journal> J Computer and System Sciences 33,2 (1986) 275-296 </journal>
Reference-contexts: 1 Introduction The subject of concurrency in B + -trees has a long history <ref> [1, 6, 14, 15, 16, 17] </ref>. Most work, with the exception of [5, 14], have not treated the problem of system crashes during structure changes. In this paper, we show how to manage concurrency and recovery for a wide class of index tree structures, single attribute, multiattribute, and versioned.
Reference: [16] <author> Salzberg, B., </author> <title> Restructuring the Lehman-Yao tree. </title> <institution> Northeastern University Tech Report TR BS-85-21 (1985), </institution> <address> Boston, MA </address>
Reference-contexts: 1 Introduction The subject of concurrency in B + -trees has a long history <ref> [1, 6, 14, 15, 16, 17] </ref>. Most work, with the exception of [5, 14], have not treated the problem of system crashes during structure changes. In this paper, we show how to manage concurrency and recovery for a wide class of index tree structures, single attribute, multiattribute, and versioned.
Reference: [17] <author> Shasha, D., Goodman, N., </author> <title> Concurrent search structure algorithms. </title> <journal> ACM Trans. </journal> <note> Database Systems 13,1 (Mar 1988) 53-90. </note>
Reference-contexts: 1 Introduction The subject of concurrency in B + -trees has a long history <ref> [1, 6, 14, 15, 16, 17] </ref>. Most work, with the exception of [5, 14], have not treated the problem of system crashes during structure changes. In this paper, we show how to manage concurrency and recovery for a wide class of index tree structures, single attribute, multiattribute, and versioned. <p> This is an abstraction and generalization of the idea introduced in the B link -tree [6]. That is, having a new node connected in the B link - tree only via a side pointer is acceptable. Like <ref> [17] </ref>, we define the requirements of a well-formed general search structure.
Reference: [18] <author> Srinivasan, V. and Carey, M. </author> <title> Performance of B-tree concurrency control algorithms. </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Denver, CO (May 1991) 416-425. </address>
Reference-contexts: We define a search structure, called a -tree, that is a generalization of the B link -tree [6]. Our concurrency and recovery method is defined to work with all search structures in this class. Recent work <ref> [18] </ref> suggests that approaches based on B link -trees should have higher concurrency than other proposed methods. Thus, our technique has both good performance and very broad applicability. 2. -tree structure changes consist of a sequence of atomic actions [7].
References-found: 18

