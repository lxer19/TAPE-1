URL: ftp://ftp.cs.caltech.edu/tr/cs-tr-92-11.ps.Z
Refering-URL: ftp://ftp.cs.caltech.edu/tr/INDEX.html
Root-URL: http://www.cs.caltech.edu
Email: ulla@cs.caltech.edu  
Title: Mutual Exclusion in a Token Ring in CC++: Program and Proof  
Author: Ulla Binau 
Date: May 18, 1992  
Affiliation: Department of Computer Science California Institute of Technology  
Pubnum: Caltech-CS-TR-92-11  
Abstract: This report describes a first attempt at using UNITY to verify reactive Compositional C++ (CC++) programs. We propose a distributed solution to the mutual exclusion problem using partially synchronous communication channels. The solution is described as a CC++ program, from which a small set of "basic" properties is derived. Using UNITY, we proof mutual exclusion and progress of the solution based on the set of properties derived from the code.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Mani Chandy and Carl Kesselman. </author> <title> CC ++ : A declarative concurrent object-oriented programming notation. </title> <type> Technical Report Caltech-CS-TR-92-01, </type> <institution> California Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: We round up with a few concluding remarks and an appendix describing the proof style and listing the UNITY proof rules applied in the progress proofs. We have chosen neither to give an introduction to UNITY nor to CC++, since both are described elsewhere (see especially [4] and <ref> [1, 2] </ref>). 2 2 Problem Specification Informal Description We are given N clients indexed i, where 0 i&lt;N . A client is in one of three states (1) thinking, (2) hungry, or (3) eating.
Reference: [2] <author> K. Mani Chandy and Carl Kesselman. </author> <title> The CC ++ language definition. </title> <type> Technical Report Caltech-CS-TR-92-02, </type> <institution> California Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: We round up with a few concluding remarks and an appendix describing the proof style and listing the UNITY proof rules applied in the progress proofs. We have chosen neither to give an introduction to UNITY nor to CC++, since both are described elsewhere (see especially [4] and <ref> [1, 2] </ref>). 2 2 Problem Specification Informal Description We are given N clients indexed i, where 0 i&lt;N . A client is in one of three states (1) thinking, (2) hungry, or (3) eating.
Reference: [3] <author> K. Mani Chandy and Carl Kesselman. </author> <title> Communication and synchronization libraries in CC ++ . Technical Report Caltech-CS-TR-92-12, </title> <institution> California Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: Because of that, we decided to leave out the UNITY programs entirely, and merely present the CC++ program. The program uses communication functions from a communication library <ref> [3] </ref>. Avoiding discussions of implementation details, we give a short description and list the properties of the functions used in this context. <p> In general CC++ channels 1 may have any number of senders and receivers. In this context, however, all channels have a single receiver, one channel has two senders, all others, a single sender (compare with figure 1 or the following program). 1 <ref> [3] </ref> describes the channel objects and their functions in detail.
Reference: [4] <author> Mani K. Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year> <month> 30 </month>
Reference-contexts: The problem specification was inspired by the description of the related dining philosophers problem in <ref> [4] </ref>. The solution given in this report|a variation of LeLann's token-passing solution [7]|is due to Mani Chandy, who has also contributed extensively to the proof. The original idea was to stepwise refine a UNITY program, and finally transform this to a CC++ program. <p> We round up with a few concluding remarks and an appendix describing the proof style and listing the UNITY proof rules applied in the progress proofs. We have chosen neither to give an introduction to UNITY nor to CC++, since both are described elsewhere (see especially <ref> [4] </ref> and [1, 2]). 2 2 Problem Specification Informal Description We are given N clients indexed i, where 0 i&lt;N . A client is in one of three states (1) thinking, (2) hungry, or (3) eating. <p> The problems involved in implicit/explicit use of the substitution axiom is mentioned briefly in section 7.2.4 in <ref> [4] </ref>. Misra gives a more thorough discussion of the substitution axiom in [10]. The first client invariant and server invariant given below can be proved without application of the substitution axiom and involves only local variables. <p> unless b (Lpsp) p ^ r 7! (q ^ r) _ b * Simple Progress-Safety-Progress and Simple Cancellation p 7! q; stable r (Lspsp) p ^ r 7! q ^ r (Lstep) p 7! r Except for the Simple Cancellation rule which is proved below, all rules are proved in <ref> [4] </ref>.
Reference: [5] <author> Edsger W. Dijkstra. </author> <title> Cooperating sequential processes. </title> <editor> In F. Genuys, editor, </editor> <booktitle> Programming Languages, </booktitle> <pages> pages 43-112. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1968. </year>
Reference-contexts: This report describes a first attempt at using UNITY to assist verification of safety and progress properties for reactive CC++ programs. The mutual fl visiting from Department of Computer Science, The Technical University of Denmark 1 exclusion problem (originally posed by Dijkstra <ref> [5] </ref>) was chosen as a first example due to its simplicity (assuming availability of atomic operations at least at the level of "test-and-set"). The problem specification was inspired by the description of the related dining philosophers problem in [4].
Reference: [6] <author> Edsger W. Dijkstra and Carel S. Scholten. </author> <title> Predicate Calculus and Program Semantics. </title> <booktitle> Text and Monographs in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Last (but definitely not least) to Mani Chandy who advised me in my work and without whom this would never have come through. Appendix: Proof Style and Proof Rules The proof style is highly inspired by <ref> [6] </ref>. However, since we use it for reasoning about leadsto properties as well as ordinary predicates, some additional remarks are needed.
Reference: [7] <author> G. LeLann. </author> <title> Distributed systems: Towards a formal approach. </title> <booktitle> In Proc. Information Processing 77, </booktitle> <pages> pages 155-160, </pages> <address> Amsterdam, 1977. </address> <publisher> North-Holland. </publisher>
Reference: [8] <author> Alain J. Martin. </author> <title> An axiomatic definition of synchronization primitives. </title> <journal> Acta Informatica, </journal> <volume> 16 </volume> <pages> 219-235, </pages> <year> 1981. </year>
Reference-contexts: Similar to Martin's axiomatic definition of synchronization primitives <ref> [8] </ref> we define for any channel: 4 * cS (non-negative, initially zero, cannot decrease) denotes the number of completed sends. * cR (non-negative, initially zero, cannot decrease) denotes the number of completed receives. * qR (non-negative, initially zero) denotes the number of suspended re ceives. * kR (non-negative, constant) denotes the
Reference: [9] <author> Alain J. Martin. </author> <title> Distributed mutual exclusion on a ring of processes. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 5 </volume> <pages> 265-276, </pages> <year> 1985. </year>
Reference-contexts: Martin gives three solutions to the mutual exclusion problem in <ref> [9] </ref>. The most efficient of these, "the reflecting privilege", uses a non-deterministic selection statement with a probe guard for each of the input channels. This type of statement is not available in CC++, but we can model it using a channel with multiple senders and a single receiver.
Reference: [10] <author> Jayadev Misra. </author> <title> Soundness of the substitution axiom. </title> <booktitle> Notes on UNITY: </booktitle> <pages> 14-90, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: The problems involved in implicit/explicit use of the substitution axiom is mentioned briefly in section 7.2.4 in [4]. Misra gives a more thorough discussion of the substitution axiom in <ref> [10] </ref>. The first client invariant and server invariant given below can be proved without application of the substitution axiom and involves only local variables. These invariants are hence also invariants of the complete system and we are free to use them in applications of the substitution axiom.
Reference: [11] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <type> Addison-Wesley, </type> <institution> AT&T Bell Laboratories, </institution> <address> 2nd edition, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction CC++ is C++ <ref> [11] </ref> extended with a small set of constructs that allow design of parallel programs. Assuming that the parallel execution of CC++ statements is fair, we may apply the UNITY proof theory to our CC++ programs.
Reference: [12] <author> A.J.M. van Gasteren and G. Tel. </author> <title> Comments on "on the proof of a distributed algorithm": Always-true is not invariant. </title> <journal> Information Processing Letters, </journal> <volume> 35 </volume> <pages> 277-279, </pages> <month> September </month> <year> 1990. </year> <month> 31 </month>
Reference-contexts: Invariants are compositional, but always-true properties are not (see e.g. <ref> [12] </ref>), so this would not be suitable for our purpose.
References-found: 12

