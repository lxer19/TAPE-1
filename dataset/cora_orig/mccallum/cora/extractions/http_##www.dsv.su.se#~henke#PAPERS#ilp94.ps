URL: http://www.dsv.su.se/~henke/PAPERS/ilp94.ps
Refering-URL: http://www.dsv.su.se/~henke/Welcome.html
Root-URL: 
Email: henke,pi@dsv.su.se  
Title: Specialization of Logic Programs by Pruning SLD-Trees  
Author: Henrik Bostrom and Peter Idestam-Almquist 
Address: Electrum 230, 164 40 Kista, Sweden  
Affiliation: Dept. of Computer and Systems Sciences Stockholm University  
Abstract: program w.r.t. positive and negative examples can be viewed as the problem of pruning an SLD-tree such that all refutations of negative examples and no refutations of positive examples are excluded. It is shown that the actual pruning can be performed by applying unfolding and clause removal. The algorithm spectre is presented, which is based on this idea. The input to the algorithm is, besides a logic program and positive and negative examples, a computation rule, which determines the shape of the SLD-tree that is to be pruned. It is shown that the generality of the resulting specialization is dependent on the computation rule, and experimental results are presented from using three different computation rules. The experiments indicate that the computation rule should be formulated so that the number of applications of unfolding is kept as low as possible. The algorithm, which uses a divide-and-conquer method, is also compared with a covering algorithm. The experiments show that a higher predictive accuracy can be achieved if the focus is on discriminating positive from negative examples rather than on achieving a high coverage of positive examples only. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bain M. and Muggleton S., </author> <title> "Non-Monotonic Learning", </title> <editor> in Muggleton S. (ed.), </editor> <booktitle> Inductive Logic Programming, </booktitle> <publisher> Academic Press, </publisher> <address> London (1992) 145-161 </address>
Reference-contexts: KP 15.4 99.0 99.3 98.6 Space Shuttle 7.6 96.6 96.9 96.5 Voting Records 16.1 93.6 95.1 91.3 Tic-Tac-Toe 89.2 83.7 89.2 73.5 Table 7: Results for spectre with the impurity measure. 4 Related Work Previous work on the specialization problem has concerned both how to mini mally <ref> [4, 1] </ref> and non-minimally specialize logic programs [14, 2, 8, 10, 3, 7, 13, 16, 9, 17]. Our approach to the specialization problem falls into the second category, and in this section it will be related to the other approaches in this category.
Reference: [2] <author> Bergadano F. and Giordana A., </author> <title> "A Knowledge Intensive Approach to Concept Induction", </title> <booktitle> Proceedings of the Fifth International Conference on Machine Learning, </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> CA (1988) 305-317 </address>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques <ref> [14, 2, 8, 12, 10, 3, 7, 13, 16, 9] </ref>. In this work, we assume that the overly general hypothesis is given as a logic program. <p> The major difference between this algorithm and the previous approaches that use specialization to find inductive hypotheses is the search method. According to the standard terminology [12], the previous approaches (except for <ref> [2] </ref>) use covering methods, like the aq family [6], while spectre uses a divide-and-conquer method, like id3 [11]. The specialization technique in [2] also uses a divide-and-conquer method but is, in contrast to spectre, restricted to pruning SLD-trees which shapes are determined by the standard Prolog computation rule. <p> According to the standard terminology [12], the previous approaches (except for <ref> [2] </ref>) use covering methods, like the aq family [6], while spectre uses a divide-and-conquer method, like id3 [11]. The specialization technique in [2] also uses a divide-and-conquer method but is, in contrast to spectre, restricted to pruning SLD-trees which shapes are determined by the standard Prolog computation rule. <p> 98.6 Space Shuttle 7.6 96.6 96.9 96.5 Voting Records 16.1 93.6 95.1 91.3 Tic-Tac-Toe 89.2 83.7 89.2 73.5 Table 7: Results for spectre with the impurity measure. 4 Related Work Previous work on the specialization problem has concerned both how to mini mally [4, 1] and non-minimally specialize logic programs <ref> [14, 2, 8, 10, 3, 7, 13, 16, 9, 17] </ref>. Our approach to the specialization problem falls into the second category, and in this section it will be related to the other approaches in this category. <p> This is achieved through clause removal and addition of literals. In contrast to spectre, mbr does not consider any positive examples when specializing a program. This means that positive examples that have been used in the construction of the program may no longer be covered by the specialization. In <ref> [14, 2, 12, 10, 13, 9] </ref>, clauses are specialized by adding literals to their bodies. The literals considered for being added are in these approaches restricted to those whose predicate symbols are defined in the original program. <p> This means that ana-ebl, focl, focl-frontier, mis and foil in this aspect resemble the aq family [6], while spectre resembles id3 [11]. The specialization technique in the ml-smart system, which is presented in <ref> [2] </ref>, is closely related to spectre. Minor differences between the techniques are that ml-smart uses best-first search and allows addition of literals while spectre uses hill-climbing and is restricted to goal reduction.
Reference: [3] <author> Cohen W. W., </author> <title> "The Generality of Overgenerality", </title> <booktitle> Machine Learning: Proceedings of the Eighth International Workshop, </booktitle> <publisher> Morgan Kaufmann (1991) 490-494 </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques <ref> [14, 2, 8, 12, 10, 3, 7, 13, 16, 9] </ref>. In this work, we assume that the overly general hypothesis is given as a logic program. <p> Since spectre also requires overly general programs as input, such programs are constructed for this evaluation in the following way (cf. <ref> [3] </ref>). For each domain a new target predicate is defined with as many arguments as the number of attributes, and for each attribute a new predicate is defined to determine the possible values of the attribute. <p> 98.6 Space Shuttle 7.6 96.6 96.9 96.5 Voting Records 16.1 93.6 95.1 91.3 Tic-Tac-Toe 89.2 83.7 89.2 73.5 Table 7: Results for spectre with the impurity measure. 4 Related Work Previous work on the specialization problem has concerned both how to mini mally [4, 1] and non-minimally specialize logic programs <ref> [14, 2, 8, 10, 3, 7, 13, 16, 9, 17] </ref>. Our approach to the specialization problem falls into the second category, and in this section it will be related to the other approaches in this category. <p> However, focl and focl-frontier use goal reduction in addition to adding literals, which means that the branching factor is increased rather than decreased in these approaches. Another algorithm that utilizes goal reduction to specialize clauses is ana-ebl <ref> [3] </ref>, which, like spectre, does not consider other possible specializations. The major difference between spectre and ana-ebl, focl and focl-frontier is the way in which the search for a specialization is performed.
Reference: [4] <author> Ling C. X., </author> <title> "Non-Monotonic Specialization", </title> <booktitle> Proceedings of International Workshop on Inductive Logic Programming, </booktitle> <address> Portugal (1991) 59-68 </address>
Reference-contexts: KP 15.4 99.0 99.3 98.6 Space Shuttle 7.6 96.6 96.9 96.5 Voting Records 16.1 93.6 95.1 91.3 Tic-Tac-Toe 89.2 83.7 89.2 73.5 Table 7: Results for spectre with the impurity measure. 4 Related Work Previous work on the specialization problem has concerned both how to mini mally <ref> [4, 1] </ref> and non-minimally specialize logic programs [14, 2, 8, 10, 3, 7, 13, 16, 9, 17]. Our approach to the specialization problem falls into the second category, and in this section it will be related to the other approaches in this category.
Reference: [5] <author> Lloyd J. W., </author> <booktitle> Foundations of Logic Programming, (2nd edition), </booktitle> <publisher> Springer-Verlag (1987) </publisher>
Reference-contexts: In section five, we discuss limitations of the algorithm and present ways of overcoming these. Finally, in section six we give some concluding remarks and point out directions for future research. In the following, we assume the reader to be familiar with the standard terminology in logic programming <ref> [5] </ref>. 1 SPECialization by TRansformation and Elimination 2 Specialization by Pruning SLD-trees We first define the specialization problem that is addressed in this work. We then show how this problem can be solved by pruning SLD-trees. <p> This definition of the target predicate is more general than the specialization obtained in section 2.3, since the spades are not required to be numbered as in the previous case. 4 The term computation rule is used in a broader sense than in <ref> [5] </ref>.
Reference: [6] <author> Michalski R. S., </author> <title> "Pattern Recognition as Rule-Guided Inductive Inference", </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence, </journal> <month> 2 </month> <year> (1980) </year> <month> 349-361 </month>
Reference-contexts: The major difference between this algorithm and the previous approaches that use specialization to find inductive hypotheses is the search method. According to the standard terminology [12], the previous approaches (except for [2]) use covering methods, like the aq family <ref> [6] </ref>, while spectre uses a divide-and-conquer method, like id3 [11]. The specialization technique in [2] also uses a divide-and-conquer method but is, in contrast to spectre, restricted to pruning SLD-trees which shapes are determined by the standard Prolog computation rule. <p> The algorithms ana-ebl, focl and focl-frontier, like mis [14] and foil, use covering methods for finding correct specializations, while spectre uses a divide-and-conquer method. This means that ana-ebl, focl, focl-frontier, mis and foil in this aspect resemble the aq family <ref> [6] </ref>, while spectre resembles id3 [11]. The specialization technique in the ml-smart system, which is presented in [2], is closely related to spectre. Minor differences between the techniques are that ml-smart uses best-first search and allows addition of literals while spectre uses hill-climbing and is restricted to goal reduction.
Reference: [7] <author> Mooney R. J. and Ourston D., </author> <title> "Constructive Induction in Theory Refinement", </title> <booktitle> Machine Learning: Proceedings of the Eighth International Workshop, </booktitle> <publisher> Morgan Kaufmann (1991) 178-182 </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques <ref> [14, 2, 8, 12, 10, 3, 7, 13, 16, 9] </ref>. In this work, we assume that the overly general hypothesis is given as a logic program. <p> 98.6 Space Shuttle 7.6 96.6 96.9 96.5 Voting Records 16.1 93.6 95.1 91.3 Tic-Tac-Toe 89.2 83.7 89.2 73.5 Table 7: Results for spectre with the impurity measure. 4 Related Work Previous work on the specialization problem has concerned both how to mini mally [4, 1] and non-minimally specialize logic programs <ref> [14, 2, 8, 10, 3, 7, 13, 16, 9, 17] </ref>. Our approach to the specialization problem falls into the second category, and in this section it will be related to the other approaches in this category. <p> They can be divided into three (not disjoint) groups with respect to their specialization techniques: clause removal, addition of literals and goal reduction. The only specialization operator that is used in <ref> [8, 7, 16] </ref> is clause removal. In contrast to spectre, the only clauses that are considered for removal in these approaches are clauses appearing in the original program.
Reference: [8] <author> Ourston D. and Mooney R. J., </author> <title> "Changing the Rules: A Comprehensive Approach to Theory Refinement", </title> <booktitle> Proceedings of the Eighth National Conference on Artificial Intelligence, </booktitle> <publisher> MIT Press (1990) 815-820 </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques <ref> [14, 2, 8, 12, 10, 3, 7, 13, 16, 9] </ref>. In this work, we assume that the overly general hypothesis is given as a logic program. <p> 98.6 Space Shuttle 7.6 96.6 96.9 96.5 Voting Records 16.1 93.6 95.1 91.3 Tic-Tac-Toe 89.2 83.7 89.2 73.5 Table 7: Results for spectre with the impurity measure. 4 Related Work Previous work on the specialization problem has concerned both how to mini mally [4, 1] and non-minimally specialize logic programs <ref> [14, 2, 8, 10, 3, 7, 13, 16, 9, 17] </ref>. Our approach to the specialization problem falls into the second category, and in this section it will be related to the other approaches in this category. <p> They can be divided into three (not disjoint) groups with respect to their specialization techniques: clause removal, addition of literals and goal reduction. The only specialization operator that is used in <ref> [8, 7, 16] </ref> is clause removal. In contrast to spectre, the only clauses that are considered for removal in these approaches are clauses appearing in the original program.
Reference: [9] <author> Pazzani M. and Brunk C., </author> <title> "Finding Accurate Frontiers: A Knowledge-Intensive Approach to Relational Learning", </title> <booktitle> Proceedings of the Eleventh National Conference on Artificial Intelligence, </booktitle> <publisher> Morgan Kaufmann (1993) 328-334 </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques <ref> [14, 2, 8, 12, 10, 3, 7, 13, 16, 9] </ref>. In this work, we assume that the overly general hypothesis is given as a logic program. <p> 98.6 Space Shuttle 7.6 96.6 96.9 96.5 Voting Records 16.1 93.6 95.1 91.3 Tic-Tac-Toe 89.2 83.7 89.2 73.5 Table 7: Results for spectre with the impurity measure. 4 Related Work Previous work on the specialization problem has concerned both how to mini mally [4, 1] and non-minimally specialize logic programs <ref> [14, 2, 8, 10, 3, 7, 13, 16, 9, 17] </ref>. Our approach to the specialization problem falls into the second category, and in this section it will be related to the other approaches in this category. <p> This is achieved through clause removal and addition of literals. In contrast to spectre, mbr does not consider any positive examples when specializing a program. This means that positive examples that have been used in the construction of the program may no longer be covered by the specialization. In <ref> [14, 2, 12, 10, 13, 9] </ref>, clauses are specialized by adding literals to their bodies. The literals considered for being added are in these approaches restricted to those whose predicate symbols are defined in the original program. <p> This means that spectre may find refinements that are missed by techniques that do not search the space exhaustively (e.g. foil [12]). The same idea is the basis for the focl [10] and focl-frontier <ref> [9] </ref> algorithms. However, focl and focl-frontier use goal reduction in addition to adding literals, which means that the branching factor is increased rather than decreased in these approaches. Another algorithm that utilizes goal reduction to specialize clauses is ana-ebl [3], which, like spectre, does not consider other possible specializations.
Reference: [10] <author> Pazzani M., Brunk C. and Silverstein G., </author> <title> "A Knowledge-Intensive Approach to Learning Relational Concepts", </title> <booktitle> Machine Learning: Proceedings of the Eighth International Workshop, </booktitle> <publisher> Morgan Kaufmann (1991) 432-436 </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques <ref> [14, 2, 8, 12, 10, 3, 7, 13, 16, 9] </ref>. In this work, we assume that the overly general hypothesis is given as a logic program. <p> 98.6 Space Shuttle 7.6 96.6 96.9 96.5 Voting Records 16.1 93.6 95.1 91.3 Tic-Tac-Toe 89.2 83.7 89.2 73.5 Table 7: Results for spectre with the impurity measure. 4 Related Work Previous work on the specialization problem has concerned both how to mini mally [4, 1] and non-minimally specialize logic programs <ref> [14, 2, 8, 10, 3, 7, 13, 16, 9, 17] </ref>. Our approach to the specialization problem falls into the second category, and in this section it will be related to the other approaches in this category. <p> This is achieved through clause removal and addition of literals. In contrast to spectre, mbr does not consider any positive examples when specializing a program. This means that positive examples that have been used in the construction of the program may no longer be covered by the specialization. In <ref> [14, 2, 12, 10, 13, 9] </ref>, clauses are specialized by adding literals to their bodies. The literals considered for being added are in these approaches restricted to those whose predicate symbols are defined in the original program. <p> This means that spectre may find refinements that are missed by techniques that do not search the space exhaustively (e.g. foil [12]). The same idea is the basis for the focl <ref> [10] </ref> and focl-frontier [9] algorithms. However, focl and focl-frontier use goal reduction in addition to adding literals, which means that the branching factor is increased rather than decreased in these approaches.
Reference: [11] <author> Quinlan J. R., </author> <title> "Induction of Decision Trees", </title> <note> Machine Learning 1 (1986) 81-106 </note>
Reference-contexts: The major difference between this algorithm and the previous approaches that use specialization to find inductive hypotheses is the search method. According to the standard terminology [12], the previous approaches (except for [2]) use covering methods, like the aq family [6], while spectre uses a divide-and-conquer method, like id3 <ref> [11] </ref>. The specialization technique in [2] also uses a divide-and-conquer method but is, in contrast to spectre, restricted to pruning SLD-trees which shapes are determined by the standard Prolog computation rule. <p> Therefore the fewer clauses that are needed in the definition of the target predicate to discriminate between positive and negative examples the more likely it is not by coincidence, cf. the preference of simple decision trees in the TDIDT-paradigm <ref> [11] </ref>. The measure of residual impurity that is used in this experiment is the same as the one used in id3 [11]: c i=1 cov (C i ; E + ) + cov (C i ; E ) log 2 cov (C i ; E + [ E ) where C <p> of the target predicate to discriminate between positive and negative examples the more likely it is not by coincidence, cf. the preference of simple decision trees in the TDIDT-paradigm <ref> [11] </ref>. The measure of residual impurity that is used in this experiment is the same as the one used in id3 [11]: c i=1 cov (C i ; E + ) + cov (C i ; E ) log 2 cov (C i ; E + [ E ) where C 1 ; : : : ; C n are the resolvents upon one of the literals in the current clause C <p> The algorithms ana-ebl, focl and focl-frontier, like mis [14] and foil, use covering methods for finding correct specializations, while spectre uses a divide-and-conquer method. This means that ana-ebl, focl, focl-frontier, mis and foil in this aspect resemble the aq family [6], while spectre resembles id3 <ref> [11] </ref>. The specialization technique in the ml-smart system, which is presented in [2], is closely related to spectre. Minor differences between the techniques are that ml-smart uses best-first search and allows addition of literals while spectre uses hill-climbing and is restricted to goal reduction.
Reference: [12] <author> Quinlan J. R., </author> <title> "Learning Logical Definitions from Relations", </title> <note> Machine Learning 5 (1990) 239-266 </note>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques <ref> [14, 2, 8, 12, 10, 3, 7, 13, 16, 9] </ref>. In this work, we assume that the overly general hypothesis is given as a logic program. <p> The major difference between this algorithm and the previous approaches that use specialization to find inductive hypotheses is the search method. According to the standard terminology <ref> [12] </ref>, the previous approaches (except for [2]) use covering methods, like the aq family [6], while spectre uses a divide-and-conquer method, like id3 [11]. <p> This is achieved through clause removal and addition of literals. In contrast to spectre, mbr does not consider any positive examples when specializing a program. This means that positive examples that have been used in the construction of the program may no longer be covered by the specialization. In <ref> [14, 2, 12, 10, 13, 9] </ref>, clauses are specialized by adding literals to their bodies. The literals considered for being added are in these approaches restricted to those whose predicate symbols are defined in the original program. <p> The literals considered for being added are in these approaches restricted to those whose predicate symbols are defined in the original program. Various restrictions are also put on the variables in the literals (e.g. at least one of the variables should appear elsewhere in the clause <ref> [12] </ref>). The branching factor in the space of possible refinements is normally much larger for these approaches than for spectre. The number of alternatives for spectre when refining a clause is equal to the number of literals in the body of the clause. <p> This means that spectre may find refinements that are missed by techniques that do not search the space exhaustively (e.g. foil <ref> [12] </ref>). The same idea is the basis for the focl [10] and focl-frontier [9] algorithms. However, focl and focl-frontier use goal reduction in addition to adding literals, which means that the branching factor is increased rather than decreased in these approaches.
Reference: [13] <author> Richards B. L. and Mooney R. J., </author> <title> "First-Order Theory Revision", </title> <booktitle> Machine Learning: Proceedings of the Eighth International Workshop, </booktitle> <address> Morgan Kauf-mann (1991) 447-451 </address>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques <ref> [14, 2, 8, 12, 10, 3, 7, 13, 16, 9] </ref>. In this work, we assume that the overly general hypothesis is given as a logic program. <p> 98.6 Space Shuttle 7.6 96.6 96.9 96.5 Voting Records 16.1 93.6 95.1 91.3 Tic-Tac-Toe 89.2 83.7 89.2 73.5 Table 7: Results for spectre with the impurity measure. 4 Related Work Previous work on the specialization problem has concerned both how to mini mally [4, 1] and non-minimally specialize logic programs <ref> [14, 2, 8, 10, 3, 7, 13, 16, 9, 17] </ref>. Our approach to the specialization problem falls into the second category, and in this section it will be related to the other approaches in this category. <p> This is achieved through clause removal and addition of literals. In contrast to spectre, mbr does not consider any positive examples when specializing a program. This means that positive examples that have been used in the construction of the program may no longer be covered by the specialization. In <ref> [14, 2, 12, 10, 13, 9] </ref>, clauses are specialized by adding literals to their bodies. The literals considered for being added are in these approaches restricted to those whose predicate symbols are defined in the original program.
Reference: [14] <author> Shapiro E. Y., </author> <title> Algorithmic Program Debugging, </title> <publisher> MIT Press (1983) </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques <ref> [14, 2, 8, 12, 10, 3, 7, 13, 16, 9] </ref>. In this work, we assume that the overly general hypothesis is given as a logic program. <p> 98.6 Space Shuttle 7.6 96.6 96.9 96.5 Voting Records 16.1 93.6 95.1 91.3 Tic-Tac-Toe 89.2 83.7 89.2 73.5 Table 7: Results for spectre with the impurity measure. 4 Related Work Previous work on the specialization problem has concerned both how to mini mally [4, 1] and non-minimally specialize logic programs <ref> [14, 2, 8, 10, 3, 7, 13, 16, 9, 17] </ref>. Our approach to the specialization problem falls into the second category, and in this section it will be related to the other approaches in this category. <p> This is achieved through clause removal and addition of literals. In contrast to spectre, mbr does not consider any positive examples when specializing a program. This means that positive examples that have been used in the construction of the program may no longer be covered by the specialization. In <ref> [14, 2, 12, 10, 13, 9] </ref>, clauses are specialized by adding literals to their bodies. The literals considered for being added are in these approaches restricted to those whose predicate symbols are defined in the original program. <p> Then the number of alternatives for spectre is 4, while the number of possible literals to add is 10 fl 5 2 + 10 fl 5 3 = 1500 (assuming that the variables are restricted to those already present in the clause as in <ref> [14] </ref>). It should be noted that spectre reduces the branching factor at the cost of expressive power, i.e. all specializations produced by spectre can be obtained by the previous approaches, while the contrary does not hold. <p> The major difference between spectre and ana-ebl, focl and focl-frontier is the way in which the search for a specialization is performed. The algorithms ana-ebl, focl and focl-frontier, like mis <ref> [14] </ref> and foil, use covering methods for finding correct specializations, while spectre uses a divide-and-conquer method. This means that ana-ebl, focl, focl-frontier, mis and foil in this aspect resemble the aq family [6], while spectre resembles id3 [11].
Reference: [15] <author> Tamaki H. and Sato T., </author> <title> "Unfold/Fold Transformations of Logic Programs", </title> <booktitle> Proceedings of the Second International Logic Programming Conference, </booktitle> <institution> Uppsala University, Uppsala, </institution> <address> Sweden (1984) 127-138 </address>
Reference-contexts: Instead, the pruning can appropriately be performed by combining clause removal with the use of the transformation rule unfolding 3 <ref> [15] </ref> in the following way. By applying unfolding, internal nodes in the SLD-tree can be eliminated, i.e. some sub-trees can be moved closer to the root. By repeated application of unfolding, any sub-tree can be made a direct sub-tree of the root. <p> Unfold upon A in the clause, and replace each instance A in the bodies of the clauses defining A and A 0 (directly or indirectly) with A 0 (i.e. folding <ref> [15] </ref>). Then an equivalent definition of A has been obtained which is non-recursive. For example, let the recursive target predicate be member (X,Y), which is defined by the two clauses: member (X,[X|L]). member (X,[Y|L]):- member (X,L).
Reference: [16] <author> Wogulis J., </author> <title> "Revising Relational Domain Theories", </title> <booktitle> Machine Learning: Proceedings of the Eighth International Workshop, </booktitle> <publisher> Morgan Kaufmann (1991) 462-466 </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques <ref> [14, 2, 8, 12, 10, 3, 7, 13, 16, 9] </ref>. In this work, we assume that the overly general hypothesis is given as a logic program. <p> 98.6 Space Shuttle 7.6 96.6 96.9 96.5 Voting Records 16.1 93.6 95.1 91.3 Tic-Tac-Toe 89.2 83.7 89.2 73.5 Table 7: Results for spectre with the impurity measure. 4 Related Work Previous work on the specialization problem has concerned both how to mini mally [4, 1] and non-minimally specialize logic programs <ref> [14, 2, 8, 10, 3, 7, 13, 16, 9, 17] </ref>. Our approach to the specialization problem falls into the second category, and in this section it will be related to the other approaches in this category. <p> They can be divided into three (not disjoint) groups with respect to their specialization techniques: clause removal, addition of literals and goal reduction. The only specialization operator that is used in <ref> [8, 7, 16] </ref> is clause removal. In contrast to spectre, the only clauses that are considered for removal in these approaches are clauses appearing in the original program.
Reference: [17] <author> Wrobel S., </author> <title> "On the Proper Definition of Minimality in Specialization and Theory Revision", </title> <booktitle> Proceedings of the European Conference on Machine Learning, </booktitle> <month> Springer-Verlag </month> <year> (1993) </year> <month> 65-82 </month>
Reference-contexts: 98.6 Space Shuttle 7.6 96.6 96.9 96.5 Voting Records 16.1 93.6 95.1 91.3 Tic-Tac-Toe 89.2 83.7 89.2 73.5 Table 7: Results for spectre with the impurity measure. 4 Related Work Previous work on the specialization problem has concerned both how to mini mally [4, 1] and non-minimally specialize logic programs <ref> [14, 2, 8, 10, 3, 7, 13, 16, 9, 17] </ref>. Our approach to the specialization problem falls into the second category, and in this section it will be related to the other approaches in this category. <p> For example, if we are given the negative example p (a,a) and the positive examples p (a,b) and p (b,a), it is not possible to obtain a correct specialization by simply removing clauses in the following program: p (X,Z):- q (X,Y), r (Y,Z). q (b,b). r (b,b). In <ref> [17] </ref> a technique for incremental specialization is presented, called mbr. It excludes a negative example by preventing a (minimal) set of clause applications from being used. This is achieved through clause removal and addition of literals.
References-found: 17

